/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 61 "../include/ipmitool/helper.h"
struct ipmi_intf;
#line 63 "../include/ipmitool/helper.h"
struct valstr {
   uint16_t val ;
   char const   *str ;
};
#line 67 "../include/ipmitool/helper.h"
struct oemvalstr {
   uint32_t oem ;
   uint16_t val ;
   char const   *str ;
};
#line 71 "../include/ipmitool/ipmi.h"
struct __anonstruct_msg_33 {
   uint8_t netfn : 6 ;
   uint8_t lun : 2 ;
   uint8_t cmd ;
   uint8_t target_cmd ;
   uint16_t data_len ;
   uint8_t *data ;
};
#line 71 "../include/ipmitool/ipmi.h"
struct ipmi_rq {
   struct __anonstruct_msg_33 msg ;
};
#line 86 "../include/ipmitool/ipmi.h"
struct __anonstruct_ipmi_request_35 {
   uint8_t rq_seq ;
   struct ipmi_rq *request ;
};
#line 86
struct ipmi_rs;
#line 86 "../include/ipmitool/ipmi.h"
struct __anonstruct_ipmi_response_36 {
   uint8_t rs_seq ;
   struct ipmi_rs *response ;
};
#line 86 "../include/ipmitool/ipmi.h"
struct __anonstruct_open_session_request_37 {
   uint8_t *request ;
};
#line 86 "../include/ipmitool/ipmi.h"
struct __anonstruct_rakp_1_message_38 {
   uint8_t *message ;
};
#line 86 "../include/ipmitool/ipmi.h"
struct __anonstruct_rakp_2_message_39 {
   uint8_t *message ;
};
#line 86 "../include/ipmitool/ipmi.h"
struct __anonstruct_rakp_3_message_40 {
   uint8_t *message ;
};
#line 86 "../include/ipmitool/ipmi.h"
struct __anonstruct_rakp_4_message_41 {
   uint8_t *message ;
};
#line 86 "../include/ipmitool/ipmi.h"
struct __anonstruct_sol_packet_42 {
   uint8_t data[1024] ;
   uint16_t character_count ;
   uint8_t packet_sequence_number ;
   uint8_t acked_packet_number ;
   uint8_t accepted_character_count ;
   uint8_t is_nack ;
   uint8_t assert_ring_wor ;
   uint8_t generate_break ;
   uint8_t deassert_cts ;
   uint8_t deassert_dcd_dsr ;
   uint8_t flush_inbound ;
   uint8_t flush_outbound ;
};
#line 86 "../include/ipmitool/ipmi.h"
union __anonunion_payload_34 {
   struct __anonstruct_ipmi_request_35 ipmi_request ;
   struct __anonstruct_ipmi_response_36 ipmi_response ;
   struct __anonstruct_open_session_request_37 open_session_request ;
   struct __anonstruct_rakp_1_message_38 rakp_1_message ;
   struct __anonstruct_rakp_2_message_39 rakp_2_message ;
   struct __anonstruct_rakp_3_message_40 rakp_3_message ;
   struct __anonstruct_rakp_4_message_41 rakp_4_message ;
   struct __anonstruct_sol_packet_42 sol_packet ;
};
#line 86 "../include/ipmitool/ipmi.h"
struct ipmi_v2_payload {
   uint16_t payload_length ;
   uint8_t payload_type ;
   union __anonunion_payload_34 payload ;
};
#line 155 "../include/ipmitool/ipmi.h"
struct __anonstruct_msg_43 {
   uint8_t netfn ;
   uint8_t cmd ;
   uint8_t seq ;
   uint8_t lun ;
};
#line 155 "../include/ipmitool/ipmi.h"
struct __anonstruct_session_44 {
   uint8_t authtype ;
   uint32_t seq ;
   uint32_t id ;
   uint8_t bEncrypted ;
   uint8_t bAuthenticated ;
   uint8_t payloadtype ;
   uint16_t msglen ;
};
#line 155 "../include/ipmitool/ipmi.h"
struct __anonstruct_ipmi_response_46 {
   uint8_t rq_addr ;
   uint8_t netfn ;
   uint8_t rq_lun ;
   uint8_t rs_addr ;
   uint8_t rq_seq ;
   uint8_t rs_lun ;
   uint8_t cmd ;
};
#line 155 "../include/ipmitool/ipmi.h"
struct __anonstruct_open_session_response_47 {
   uint8_t message_tag ;
   uint8_t rakp_return_code ;
   uint8_t max_priv_level ;
   uint32_t console_id ;
   uint32_t bmc_id ;
   uint8_t auth_alg ;
   uint8_t integrity_alg ;
   uint8_t crypt_alg ;
};
#line 155 "../include/ipmitool/ipmi.h"
struct __anonstruct_rakp2_message_48 {
   uint8_t message_tag ;
   uint8_t rakp_return_code ;
   uint32_t console_id ;
   uint8_t bmc_rand[16] ;
   uint8_t bmc_guid[16] ;
   uint8_t key_exchange_auth_code[20] ;
};
#line 155 "../include/ipmitool/ipmi.h"
struct __anonstruct_rakp4_message_49 {
   uint8_t message_tag ;
   uint8_t rakp_return_code ;
   uint32_t console_id ;
   uint8_t integrity_check_value[20] ;
};
#line 155 "../include/ipmitool/ipmi.h"
struct __anonstruct_sol_packet_50 {
   uint8_t packet_sequence_number ;
   uint8_t acked_packet_number ;
   uint8_t accepted_character_count ;
   uint8_t is_nack ;
   uint8_t transfer_unavailable ;
   uint8_t sol_inactive ;
   uint8_t transmit_overrun ;
   uint8_t break_detected ;
};
#line 155 "../include/ipmitool/ipmi.h"
union __anonunion_payload_45 {
   struct __anonstruct_ipmi_response_46 ipmi_response ;
   struct __anonstruct_open_session_response_47 open_session_response ;
   struct __anonstruct_rakp2_message_48 rakp2_message ;
   struct __anonstruct_rakp4_message_49 rakp4_message ;
   struct __anonstruct_sol_packet_50 sol_packet ;
};
#line 155 "../include/ipmitool/ipmi.h"
struct ipmi_rs {
   uint8_t ccode ;
   uint8_t data[1024] ;
   int data_len ;
   struct __anonstruct_msg_43 msg ;
   struct __anonstruct_session_44 session ;
   union __anonunion_payload_45 payload ;
};
#line 254
enum IPMI_OEM {
    IPMI_OEM_UNKNOWN = 0,
    IPMI_OEM_HP = 11,
    IPMI_OEM_SUN = 42,
    IPMI_OEM_NOKIA = 94,
    IPMI_OEM_BULL = 107,
    IPMI_OEM_HITACHI_116 = 116,
    IPMI_OEM_NEC = 119,
    IPMI_OEM_TOSHIBA = 186,
    IPMI_OEM_INTEL = 343,
    IPMI_OEM_TATUNG = 373,
    IPMI_OEM_HITACHI_399 = 399,
    IPMI_OEM_DELL = 674,
    IPMI_OEM_LMC = 2168,
    IPMI_OEM_RADISYS = 4337,
    IPMI_OEM_BROADCOM = 4413,
    IPMI_OEM_MAGNUM = 5593,
    IPMI_OEM_TYAN = 6653,
    IPMI_OEM_NEWISYS = 9237,
    IPMI_OEM_FUJITSU_SIEMENS = 10368,
    IPMI_OEM_AVOCENT = 10418,
    IPMI_OEM_PEPPERCON = 10437,
    IPMI_OEM_SUPERMICRO = 10876,
    IPMI_OEM_OSA = 11102,
    IPMI_OEM_GOOGLE = 11129,
    IPMI_OEM_PICMG = 12634,
    IPMI_OEM_RARITAN = 13742,
    IPMI_OEM_KONTRON = 15000,
    IPMI_OEM_PPS = 16394,
    IPMI_OEM_AMI = 20974,
    IPMI_OEM_NOKIA_SIEMENS_NETWORKS = 28458
} ;
#line 254 "../include/ipmitool/ipmi.h"
typedef enum IPMI_OEM IPMI_OEM;
#line 37 "../include/ipmitool/ipmi_oem.h"
struct ipmi_oem_handle {
   char const   *name ;
   char const   *desc ;
   int (*setup)(struct ipmi_intf *intf ) ;
};
#line 49 "../include/ipmitool/ipmi_intf.h"
enum LANPLUS_SESSION_STATE {
    LANPLUS_STATE_PRESESSION = 0,
    LANPLUS_STATE_OPEN_SESSION_SENT = 1,
    LANPLUS_STATE_OPEN_SESSION_RECEIEVED = 2,
    LANPLUS_STATE_RAKP_1_SENT = 3,
    LANPLUS_STATE_RAKP_2_RECEIVED = 4,
    LANPLUS_STATE_RAKP_3_SENT = 5,
    LANPLUS_STATE_ACTIVE = 6,
    LANPLUS_STATE_CLOSE_SENT = 7
} ;
#line 65 "../include/ipmitool/ipmi_intf.h"
struct __anonstruct_v2_data_51 {
   enum LANPLUS_SESSION_STATE session_state ;
   uint8_t requested_auth_alg ;
   uint8_t requested_integrity_alg ;
   uint8_t requested_crypt_alg ;
   uint8_t auth_alg ;
   uint8_t integrity_alg ;
   uint8_t crypt_alg ;
   uint8_t max_priv_level ;
   uint8_t lookupbit ;
   uint32_t console_id ;
   uint32_t bmc_id ;
   uint8_t console_rand[16] ;
   uint8_t bmc_rand[16] ;
   uint8_t bmc_guid[16] ;
   uint8_t requested_role ;
   uint8_t rakp2_return_code ;
   uint8_t sik[20] ;
   uint8_t kg[21] ;
   uint8_t k1[20] ;
   uint8_t k2[20] ;
};
#line 65 "../include/ipmitool/ipmi_intf.h"
struct __anonstruct_sol_data_52 {
   uint16_t max_inbound_payload_size ;
   uint16_t max_outbound_payload_size ;
   uint16_t port ;
   uint8_t sequence_number ;
   uint8_t last_received_sequence_number ;
   uint8_t last_received_byte_count ;
   void (*sol_input_handler)(struct ipmi_rs *rsp ) ;
};
#line 65 "../include/ipmitool/ipmi_intf.h"
struct ipmi_session {
   uint8_t hostname[64] ;
   uint8_t username[17] ;
   uint8_t authcode[21] ;
   uint8_t challenge[16] ;
   uint8_t authtype ;
   uint8_t authtype_set ;
   uint8_t authstatus ;
   uint8_t authextra ;
   uint8_t privlvl ;
   uint8_t cipher_suite_id ;
   char sol_escape_char ;
   int password ;
   int port ;
   int active ;
   int retry ;
   uint32_t session_id ;
   uint32_t in_seq ;
   uint32_t out_seq ;
   uint32_t timeout ;
   struct sockaddr_in addr ;
   socklen_t addrlen ;
   struct __anonstruct_v2_data_51 v2_data ;
   struct __anonstruct_sol_data_52 sol_data ;
};
#line 150 "../include/ipmitool/ipmi_intf.h"
struct ipmi_cmd {
   int (*func)(struct ipmi_intf *intf , int argc , char **argv ) ;
   char const   *name ;
   char const   *desc ;
};
#line 161 "../include/ipmitool/ipmi_intf.h"
struct ipmi_intf {
   char name[16] ;
   char desc[128] ;
   char *devfile ;
   int fd ;
   int opened ;
   int abort ;
   int noanswer ;
   int picmg_avail ;
   IPMI_OEM manufacturer_id ;
   struct ipmi_session *session ;
   struct ipmi_oem_handle *oem ;
   struct ipmi_cmd *cmdlist ;
   uint8_t target_ipmb_addr ;
   uint32_t my_addr ;
   uint32_t target_addr ;
   uint8_t target_lun ;
   uint8_t target_channel ;
   uint32_t transit_addr ;
   uint8_t transit_channel ;
   uint8_t channel_buf_size ;
   uint8_t devnum ;
   int (*setup)(struct ipmi_intf *intf ) ;
   int (*open)(struct ipmi_intf *intf ) ;
   void (*close)(struct ipmi_intf *intf ) ;
   struct ipmi_rs *(*sendrecv)(struct ipmi_intf *intf , struct ipmi_rq *req ) ;
   int (*sendrsp)(struct ipmi_intf *intf , struct ipmi_rs *rsp ) ;
   struct ipmi_rs *(*recv_sol)(struct ipmi_intf *intf ) ;
   struct ipmi_rs *(*send_sol)(struct ipmi_intf *intf , struct ipmi_v2_payload *payload ) ;
   int (*keepalive)(struct ipmi_intf *intf ) ;
   int (*set_my_addr)(struct ipmi_intf *intf , uint8_t addr ) ;
};
#line 56 "../include/ipmitool/ipmi_mc.h"
#pragma pack(1)
#line 58 "../include/ipmitool/ipmi_mc.h"
struct ipm_devid_rsp {
   uint8_t device_id ;
   uint8_t device_revision ;
   uint8_t fw_rev1 ;
   uint8_t fw_rev2 ;
   uint8_t ipmi_version ;
   uint8_t adtl_device_support ;
   uint8_t manufacturer_id[3] ;
   uint8_t product_id[2] ;
   uint8_t aux_fw_rev[4] ;
};
#line 70
#pragma pack(0)
#line 93
#pragma pack(1)
#line 100
#pragma pack(0)
#line 119
#pragma pack(1)
#line 132
#pragma pack(0)
#line 103 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
struct ImeUpdateImageCtx {
   uint32_t size ;
   uint8_t *pData ;
   uint8_t crc8 ;
};
#line 103 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
typedef struct ImeUpdateImageCtx tImeUpdateImageCtx;
#line 110
enum eImeState {
    IME_STATE_IDLE = 0,
    IME_STATE_UPDATE_REQUESTED = 1,
    IME_STATE_UPDATE_IN_PROGRESS = 2,
    IME_STATE_SUCCESS = 3,
    IME_STATE_FAILED = 4,
    IME_STATE_ROLLED_BACK = 5,
    IME_STATE_ABORTED = 6,
    IME_STATE_INIT_FAILED = 7
} ;
#line 110 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
typedef enum eImeState tImeStateEnum;
#line 123
enum tImeUpdateType {
    IME_UPDTYPE_NORMAL = 1,
    IME_UPDTYPE_MANUAL_ROLLBACK = 3,
    IME_UPDTYPE_ABORT = 4
} ;
#line 123 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
typedef enum tImeUpdateType tImeUpdateType;
#line 132
#pragma pack(1)
#line 134 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
struct sImeStatus {
   uint8_t image_status ;
   tImeStateEnum update_state ;
   uint8_t update_attempt_status ;
   uint8_t rollback_attempt_status ;
   uint8_t update_type ;
   uint8_t dependent_flag ;
   uint8_t free_area_size[4] ;
};
#line 134 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
typedef struct sImeStatus tImeStatus;
#line 144
#pragma pack(0)
#line 148
#pragma pack(1)
#line 150 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
struct sImeCaps {
   uint8_t area_supported ;
   uint8_t special_caps ;
};
#line 150 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
typedef struct sImeCaps tImeCaps;
#line 155
#pragma pack(0)
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 194 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef signed char int8_t;
#line 195 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef short int16_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 197 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long int64_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 47 "../include/ipmitool/ipmi_session.h"
#pragma pack(1)
#line 124
#pragma pack(0)
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 56 "../include/ipmitool/ipmi_dcmi.h"
struct dcmi_cmd {
   uint16_t val ;
   char const   *str ;
   char const   *desc ;
};
#line 63 "../include/ipmitool/ipmi_dcmi.h"
struct power_limit {
   uint8_t grp_id ;
   uint16_t reserved_1 ;
   uint8_t action ;
   uint16_t limit ;
   uint32_t correction ;
   uint16_t reserved_2 ;
   uint16_t sample ;
} __attribute__((__packed__)) ;
#line 74 "../include/ipmitool/ipmi_dcmi.h"
struct power_reading {
   uint8_t grp_id ;
   uint16_t curr_pwr ;
   uint16_t min_sample ;
   uint16_t max_sample ;
   uint16_t avg_pwr ;
   uint32_t time_stamp ;
   uint32_t sample ;
   uint8_t state ;
} __attribute__((__packed__)) ;
#line 86 "../include/ipmitool/ipmi_dcmi.h"
struct capabilities {
   uint8_t grp_id ;
   uint16_t conformance ;
   uint8_t revision ;
   uint8_t data_byte1 ;
   uint8_t data_byte2 ;
   uint8_t data_byte3 ;
   uint8_t data_byte4 ;
} __attribute__((__packed__)) ;
#line 120 "../include/ipmitool/ipmi_dcmi.h"
struct thermal_limit {
   uint8_t grp_id ;
   uint8_t exceptionActions ;
   uint8_t tempLimit ;
   uint16_t exceptionTime ;
} __attribute__((__packed__)) ;
#line 56 "../include/ipmitool/ipmi_mc.h"
#pragma pack(1)
#line 70
#pragma pack(0)
#line 93
#pragma pack(1)
#line 100
#pragma pack(0)
#line 119
#pragma pack(1)
#line 132
#pragma pack(0)
#line 37 "../include/ipmitool/ipmi_entity.h"
#pragma pack(1)
#line 50
#pragma pack(0)
#line 109 "../include/ipmitool/ipmi_sdr.h"
#pragma pack(1)
#line 120
#pragma pack(0)
#line 124
#pragma pack(1)
#line 133
#pragma pack(0)
#line 137
#pragma pack(1)
#line 144
#pragma pack(0)
#line 149
#pragma pack(1)
#line 160
#pragma pack(0)
#line 164
#pragma pack(1)
#line 166 "../include/ipmitool/ipmi_sdr.h"
struct sdr_get_rs {
   uint16_t next ;
   uint16_t id ;
   uint8_t version ;
   uint8_t type ;
   uint8_t length ;
};
#line 185
#pragma pack(0)
#line 189
#pragma pack(1)
#line 319
#pragma pack(0)
#line 323
#pragma pack(1)
#line 410
#pragma pack(0)
#line 414
#pragma pack(1)
#line 450
#pragma pack(0)
#line 454
#pragma pack(1)
#line 502
#pragma pack(0)
#line 506
#pragma pack(1)
#line 571
#pragma pack(0)
#line 575
#pragma pack(1)
#line 603
#pragma pack(0)
#line 636
#pragma pack(0)
#line 640
#pragma pack(1)
#line 670
#pragma pack(0)
#line 674
#pragma pack(1)
#line 701
#pragma pack(0)
#line 714
#pragma pack(1)
#line 742
#pragma pack(0)
#line 745 "../include/ipmitool/ipmi_sdr.h"
struct ipmi_sdr_iterator {
   uint16_t reservation ;
   int total ;
   int next ;
   int use_built_in ;
};
#line 753
#pragma pack(1)
#line 775
#pragma pack(0)
#line 69 "../include/ipmitool/ipmi_sensor.h"
#pragma pack(1)
#line 82
#pragma pack(0)
#line 37 "../include/ipmitool/ipmi_entity.h"
#pragma pack(1)
#line 39 "../include/ipmitool/ipmi_entity.h"
struct entity_id {
   uint8_t id ;
   uint8_t instance : 7 ;
   uint8_t logical : 1 ;
};
#line 50
#pragma pack(0)
#line 109 "../include/ipmitool/ipmi_sdr.h"
#pragma pack(1)
#line 120
#pragma pack(0)
#line 124
#pragma pack(1)
#line 133
#pragma pack(0)
#line 137
#pragma pack(1)
#line 144
#pragma pack(0)
#line 149
#pragma pack(1)
#line 160
#pragma pack(0)
#line 164
#pragma pack(1)
#line 185
#pragma pack(0)
#line 189
#pragma pack(1)
#line 191 "../include/ipmitool/ipmi_sdr.h"
struct __anonstruct_discrete_85 {
   uint16_t assert_event ;
   uint16_t deassert_event ;
   uint16_t read ;
};
#line 191 "../include/ipmitool/ipmi_sdr.h"
struct __anonstruct_set_88 {
   uint16_t readable : 8 ;
   uint16_t lnc : 1 ;
   uint16_t lcr : 1 ;
   uint16_t lnr : 1 ;
   uint16_t unc : 1 ;
   uint16_t ucr : 1 ;
   uint16_t unr : 1 ;
   uint16_t reserved : 2 ;
};
#line 191 "../include/ipmitool/ipmi_sdr.h"
struct __anonstruct_read_89 {
   uint16_t lnc : 1 ;
   uint16_t lcr : 1 ;
   uint16_t lnr : 1 ;
   uint16_t unc : 1 ;
   uint16_t ucr : 1 ;
   uint16_t unr : 1 ;
   uint16_t reserved : 2 ;
   uint16_t settable : 8 ;
};
#line 191 "../include/ipmitool/ipmi_sdr.h"
union __anonunion____missing_field_name_87 {
   struct __anonstruct_set_88 set ;
   struct __anonstruct_read_89 read ;
};
#line 191 "../include/ipmitool/ipmi_sdr.h"
struct __anonstruct_threshold_86 {
   uint16_t assert_lnc_low : 1 ;
   uint16_t assert_lnc_high : 1 ;
   uint16_t assert_lcr_low : 1 ;
   uint16_t assert_lcr_high : 1 ;
   uint16_t assert_lnr_low : 1 ;
   uint16_t assert_lnr_high : 1 ;
   uint16_t assert_unc_low : 1 ;
   uint16_t assert_unc_high : 1 ;
   uint16_t assert_ucr_low : 1 ;
   uint16_t assert_ucr_high : 1 ;
   uint16_t assert_unr_low : 1 ;
   uint16_t assert_unr_high : 1 ;
   uint16_t status_lnc : 1 ;
   uint16_t status_lcr : 1 ;
   uint16_t status_lnr : 1 ;
   uint16_t reserved : 1 ;
   uint16_t deassert_lnc_low : 1 ;
   uint16_t deassert_lnc_high : 1 ;
   uint16_t deassert_lcr_low : 1 ;
   uint16_t deassert_lcr_high : 1 ;
   uint16_t deassert_lnr_low : 1 ;
   uint16_t deassert_lnr_high : 1 ;
   uint16_t deassert_unc_low : 1 ;
   uint16_t deassert_unc_high : 1 ;
   uint16_t deassert_ucr_low : 1 ;
   uint16_t deassert_ucr_high : 1 ;
   uint16_t deassert_unr_low : 1 ;
   uint16_t deassert_unr_high : 1 ;
   uint16_t status_unc : 1 ;
   uint16_t status_ucr : 1 ;
   uint16_t status_unr : 1 ;
   uint16_t reserved_2 : 1 ;
   union __anonunion____missing_field_name_87 __annonCompField2 ;
};
#line 191 "../include/ipmitool/ipmi_sdr.h"
union __anonunion_type_84 {
   struct __anonstruct_discrete_85 discrete ;
   struct __anonstruct_threshold_86 threshold ;
};
#line 191 "../include/ipmitool/ipmi_sdr.h"
struct sdr_record_mask {
   union __anonunion_type_84 type ;
};
#line 319
#pragma pack(0)
#line 323
#pragma pack(1)
#line 325 "../include/ipmitool/ipmi_sdr.h"
struct __anonstruct_keys_90 {
   uint8_t owner_id ;
   uint8_t lun : 2 ;
   uint8_t __reserved : 2 ;
   uint8_t channel : 4 ;
   uint8_t sensor_num ;
};
#line 325 "../include/ipmitool/ipmi_sdr.h"
struct __anonstruct_init_92 {
   uint8_t sensor_scan : 1 ;
   uint8_t event_gen : 1 ;
   uint8_t type : 1 ;
   uint8_t hysteresis : 1 ;
   uint8_t thresholds : 1 ;
   uint8_t events : 1 ;
   uint8_t scanning : 1 ;
   uint8_t __reserved : 1 ;
};
#line 325 "../include/ipmitool/ipmi_sdr.h"
struct __anonstruct_capabilities_93 {
   uint8_t event_msg : 2 ;
   uint8_t threshold : 2 ;
   uint8_t hysteresis : 2 ;
   uint8_t rearm : 1 ;
   uint8_t ignore : 1 ;
};
#line 325 "../include/ipmitool/ipmi_sdr.h"
struct __anonstruct_sensor_91 {
   struct __anonstruct_init_92 init ;
   struct __anonstruct_capabilities_93 capabilities ;
   uint8_t type ;
};
#line 325 "../include/ipmitool/ipmi_sdr.h"
struct __anonstruct_type_95 {
   uint8_t base ;
   uint8_t modifier ;
};
#line 325 "../include/ipmitool/ipmi_sdr.h"
struct __anonstruct_unit_94 {
   uint8_t pct : 1 ;
   uint8_t modifier : 2 ;
   uint8_t rate : 3 ;
   uint8_t analog : 2 ;
   struct __anonstruct_type_95 type ;
};
#line 325 "../include/ipmitool/ipmi_sdr.h"
struct sdr_record_common_sensor {
   struct __anonstruct_keys_90 keys ;
   struct entity_id entity ;
   struct __anonstruct_sensor_91 sensor ;
   uint8_t event_type ;
   struct sdr_record_mask mask ;
   struct __anonstruct_unit_94 unit ;
};
#line 410
#pragma pack(0)
#line 414
#pragma pack(1)
#line 416 "../include/ipmitool/ipmi_sdr.h"
struct __anonstruct_share_96 {
   uint8_t count : 4 ;
   uint8_t mod_type : 2 ;
   uint8_t __reserved : 2 ;
   uint8_t mod_offset : 7 ;
   uint8_t entity_inst : 1 ;
};
#line 416 "../include/ipmitool/ipmi_sdr.h"
struct __anonstruct_hysteresis_98 {
   uint8_t positive ;
   uint8_t negative ;
};
#line 416 "../include/ipmitool/ipmi_sdr.h"
struct __anonstruct_threshold_97 {
   struct __anonstruct_hysteresis_98 hysteresis ;
};
#line 416 "../include/ipmitool/ipmi_sdr.h"
struct sdr_record_compact_sensor {
   struct sdr_record_common_sensor cmn ;
   struct __anonstruct_share_96 share ;
   struct __anonstruct_threshold_97 threshold ;
   uint8_t __reserved[3] ;
   uint8_t oem ;
   uint8_t id_code ;
   uint8_t id_string[16] ;
};
#line 450
#pragma pack(0)
#line 454
#pragma pack(1)
#line 456 "../include/ipmitool/ipmi_sdr.h"
struct __anonstruct_keys_99 {
   uint8_t owner_id ;
   uint8_t lun : 2 ;
   uint8_t fru_owner : 2 ;
   uint8_t channel : 4 ;
   uint8_t sensor_num ;
};
#line 456 "../include/ipmitool/ipmi_sdr.h"
struct __anonstruct_share_100 {
   uint8_t count : 4 ;
   uint8_t mod_type : 2 ;
   uint8_t __reserved : 2 ;
   uint8_t mod_offset : 7 ;
   uint8_t entity_inst : 1 ;
};
#line 456 "../include/ipmitool/ipmi_sdr.h"
struct sdr_record_eventonly_sensor {
   struct __anonstruct_keys_99 keys ;
   struct entity_id entity ;
   uint8_t sensor_type ;
   uint8_t event_type ;
   struct __anonstruct_share_100 share ;
   uint8_t __reserved ;
   uint8_t oem ;
   uint8_t id_code ;
   uint8_t id_string[16] ;
};
#line 502
#pragma pack(0)
#line 506
#pragma pack(1)
#line 508 "../include/ipmitool/ipmi_sdr.h"
struct __anonstruct_analog_flag_101 {
   uint8_t nominal_read : 1 ;
   uint8_t normal_max : 1 ;
   uint8_t normal_min : 1 ;
   uint8_t __reserved : 5 ;
};
#line 508 "../include/ipmitool/ipmi_sdr.h"
struct __anonstruct_upper_103 {
   uint8_t non_recover ;
   uint8_t critical ;
   uint8_t non_critical ;
};
#line 508 "../include/ipmitool/ipmi_sdr.h"
struct __anonstruct_lower_104 {
   uint8_t non_recover ;
   uint8_t critical ;
   uint8_t non_critical ;
};
#line 508 "../include/ipmitool/ipmi_sdr.h"
struct __anonstruct_hysteresis_105 {
   uint8_t positive ;
   uint8_t negative ;
};
#line 508 "../include/ipmitool/ipmi_sdr.h"
struct __anonstruct_threshold_102 {
   struct __anonstruct_upper_103 upper ;
   struct __anonstruct_lower_104 lower ;
   struct __anonstruct_hysteresis_105 hysteresis ;
};
#line 508 "../include/ipmitool/ipmi_sdr.h"
struct sdr_record_full_sensor {
   struct sdr_record_common_sensor cmn ;
   uint8_t linearization ;
   uint16_t mtol ;
   uint32_t bacc ;
   struct __anonstruct_analog_flag_101 analog_flag ;
   uint8_t nominal_read ;
   uint8_t normal_max ;
   uint8_t normal_min ;
   uint8_t sensor_max ;
   uint8_t sensor_min ;
   struct __anonstruct_threshold_102 threshold ;
   uint8_t __reserved[2] ;
   uint8_t oem ;
   uint8_t id_code ;
   uint8_t id_string[16] ;
};
#line 571
#pragma pack(0)
#line 575
#pragma pack(1)
#line 577 "../include/ipmitool/ipmi_sdr.h"
struct sdr_record_mc_locator {
   uint8_t dev_slave_addr ;
   uint8_t channel_num : 4 ;
   uint8_t __reserved2 : 4 ;
   uint8_t global_init : 4 ;
   uint8_t __reserved3 : 1 ;
   uint8_t pwr_state_notif : 3 ;
   uint8_t dev_support ;
   uint8_t __reserved4[3] ;
   struct entity_id entity ;
   uint8_t oem ;
   uint8_t id_code ;
   uint8_t id_string[16] ;
};
#line 603
#pragma pack(0)
#line 606 "../include/ipmitool/ipmi_sdr.h"
struct sdr_record_fru_locator {
   uint8_t dev_slave_addr ;
   uint8_t device_id ;
   uint8_t bus : 3 ;
   uint8_t lun : 2 ;
   uint8_t __reserved2 : 2 ;
   uint8_t logical : 1 ;
   uint8_t __reserved3 : 4 ;
   uint8_t channel_num : 4 ;
   uint8_t __reserved4 ;
   uint8_t dev_type ;
   uint8_t dev_type_modifier ;
   struct entity_id entity ;
   uint8_t oem ;
   uint8_t id_code ;
   uint8_t id_string[16] ;
};
#line 636
#pragma pack(0)
#line 640
#pragma pack(1)
#line 642 "../include/ipmitool/ipmi_sdr.h"
struct sdr_record_generic_locator {
   uint8_t dev_access_addr ;
   uint8_t dev_slave_addr ;
   uint8_t bus : 3 ;
   uint8_t lun : 2 ;
   uint8_t channel_num : 3 ;
   uint8_t __reserved1 : 5 ;
   uint8_t addr_span : 3 ;
   uint8_t __reserved2 ;
   uint8_t dev_type ;
   uint8_t dev_type_modifier ;
   struct entity_id entity ;
   uint8_t oem ;
   uint8_t id_code ;
   uint8_t id_string[16] ;
};
#line 670
#pragma pack(0)
#line 674
#pragma pack(1)
#line 676 "../include/ipmitool/ipmi_sdr.h"
struct __anonstruct_flags_106 {
   uint8_t __reserved : 5 ;
   uint8_t isaccessable : 1 ;
   uint8_t islinked : 1 ;
   uint8_t isrange : 1 ;
};
#line 676 "../include/ipmitool/ipmi_sdr.h"
struct sdr_record_entity_assoc {
   struct entity_id entity ;
   struct __anonstruct_flags_106 flags ;
   uint8_t entity_id_1 ;
   uint8_t entity_inst_1 ;
   uint8_t entity_id_2 ;
   uint8_t entity_inst_2 ;
   uint8_t entity_id_3 ;
   uint8_t entity_inst_3 ;
   uint8_t entity_id_4 ;
   uint8_t entity_inst_4 ;
};
#line 701
#pragma pack(0)
#line 704 "../include/ipmitool/ipmi_sdr.h"
struct sdr_record_oem {
   uint8_t *data ;
   int data_len ;
};
#line 714
#pragma pack(1)
#line 742
#pragma pack(0)
#line 753
#pragma pack(1)
#line 755 "../include/ipmitool/ipmi_sdr.h"
union __anonunion_record_107 {
   struct sdr_record_common_sensor *common ;
   struct sdr_record_full_sensor *full ;
   struct sdr_record_compact_sensor *compact ;
   struct sdr_record_eventonly_sensor *eventonly ;
   struct sdr_record_generic_locator *genloc ;
   struct sdr_record_fru_locator *fruloc ;
   struct sdr_record_mc_locator *mcloc ;
   struct sdr_record_entity_assoc *entassoc ;
   struct sdr_record_oem *oem ;
};
#line 755 "../include/ipmitool/ipmi_sdr.h"
struct sdr_record_list {
   uint16_t id ;
   uint8_t version ;
   uint8_t type ;
   uint8_t length ;
   uint8_t *raw ;
   struct sdr_record_list *next ;
   union __anonunion_record_107 record ;
};
#line 775
#pragma pack(0)
#line 61 "../include/ipmitool/ipmi_sel.h"
#pragma pack(1)
#line 70
#pragma pack(0)
#line 124
#pragma pack(1)
#line 136
#pragma pack(0)
#line 36 "../include/ipmitool/ipmi_delloem.h"
#pragma pack(1)
#line 84 "../include/ipmitool/ipmi_delloem.h"
struct _tag_ipmi_dell_lcd_caps {
   uint8_t parm_rev ;
   uint8_t char_set ;
   uint8_t number_lines ;
   uint8_t max_chars[4] ;
};
#line 84 "../include/ipmitool/ipmi_delloem.h"
typedef struct _tag_ipmi_dell_lcd_caps IPMI_DELL_LCD_CAPS;
#line 101 "../include/ipmitool/ipmi_delloem.h"
struct __anonstruct_selector_0_string_111 {
   uint8_t encoding : 4 ;
   uint8_t length ;
   uint8_t data[14] ;
};
#line 101 "../include/ipmitool/ipmi_delloem.h"
union __anonunion_lcd_string_110 {
   struct __anonstruct_selector_0_string_111 selector_0_string ;
   uint8_t selector_n_data[16] ;
};
#line 101 "../include/ipmitool/ipmi_delloem.h"
struct _tag_ipmi_dell_lcd_string {
   uint8_t parm_rev ;
   uint8_t data_block_selector ;
   union __anonunion_lcd_string_110 lcd_string ;
} __attribute__((__packed__)) ;
#line 101 "../include/ipmitool/ipmi_delloem.h"
typedef struct _tag_ipmi_dell_lcd_string IPMI_DELL_LCD_STRING;
#line 136 "../include/ipmitool/ipmi_delloem.h"
struct _lcd_status {
   char parametersel ;
   char vKVM_status ;
   char lock_status ;
   char Resv1 ;
   char Resv ;
} __attribute__((__packed__)) ;
#line 136 "../include/ipmitool/ipmi_delloem.h"
typedef struct _lcd_status LCD_STATUS;
#line 145 "../include/ipmitool/ipmi_delloem.h"
struct _lcd_mode {
   uint8_t parametersel ;
   uint32_t lcdmode ;
   uint16_t lcdquallifier ;
   uint32_t capabilites ;
   uint8_t error_display ;
   uint8_t Resv ;
} __attribute__((__packed__)) ;
#line 145 "../include/ipmitool/ipmi_delloem.h"
typedef struct _lcd_mode LCD_MODE;
#line 189 "../include/ipmitool/ipmi_delloem.h"
struct __anonstruct_LOMMacAddressType_114 {
   unsigned int BladSlotNumber : 4 ;
   unsigned int MacType : 2 ;
   unsigned int EthernetStatus : 2 ;
   unsigned int NICNumber : 5 ;
   unsigned int Reserved : 3 ;
   uint8_t MacAddressByte[6] ;
};
#line 189 "../include/ipmitool/ipmi_delloem.h"
typedef struct __anonstruct_LOMMacAddressType_114 LOMMacAddressType;
#line 200 "../include/ipmitool/ipmi_delloem.h"
struct __anonstruct_EmbeddedNICMacAddressType_115 {
   LOMMacAddressType LOMMacAddress[8] ;
};
#line 200 "../include/ipmitool/ipmi_delloem.h"
typedef struct __anonstruct_EmbeddedNICMacAddressType_115 EmbeddedNICMacAddressType;
#line 205 "../include/ipmitool/ipmi_delloem.h"
struct __anonstruct_MacAddressType_116 {
   uint8_t MacAddressByte[6] ;
};
#line 205 "../include/ipmitool/ipmi_delloem.h"
typedef struct __anonstruct_MacAddressType_116 MacAddressType;
#line 210 "../include/ipmitool/ipmi_delloem.h"
struct __anonstruct_EmbeddedNICMacAddressType_10G_117 {
   MacAddressType MacAddress[8] ;
};
#line 210 "../include/ipmitool/ipmi_delloem.h"
typedef struct __anonstruct_EmbeddedNICMacAddressType_10G_117 EmbeddedNICMacAddressType_10G;
#line 250 "../include/ipmitool/ipmi_delloem.h"
struct _ipmi_power_monitor {
   uint32_t cumStartTime ;
   uint32_t cumReading ;
   uint32_t maxPeakStartTime ;
   uint32_t ampPeakTime ;
   uint16_t ampReading ;
   uint32_t wattPeakTime ;
   uint16_t wattReading ;
} __attribute__((__packed__)) ;
#line 250 "../include/ipmitool/ipmi_delloem.h"
typedef struct _ipmi_power_monitor IPMI_POWER_MONITOR;
#line 291 "../include/ipmitool/ipmi_delloem.h"
struct ipmi_inst_power_consumption_data {
   uint16_t instanpowerconsumption ;
   uint16_t instanApms ;
   uint16_t resv1 ;
   uint8_t resv ;
} __attribute__((__packed__)) ;
#line 291 "../include/ipmitool/ipmi_delloem.h"
typedef struct ipmi_inst_power_consumption_data IPMI_INST_POWER_CONSUMPTION_DATA;
#line 299 "../include/ipmitool/ipmi_delloem.h"
struct _ipmi_avgpower_consump_histroy {
   uint8_t parameterselector ;
   uint16_t lastminutepower ;
   uint16_t lasthourpower ;
   uint16_t lastdaypower ;
   uint16_t lastweakpower ;
} __attribute__((__packed__)) ;
#line 299 "../include/ipmitool/ipmi_delloem.h"
typedef struct _ipmi_avgpower_consump_histroy IPMI_AVGPOWER_CONSUMP_HISTORY;
#line 309 "../include/ipmitool/ipmi_delloem.h"
struct _ipmi_power_consump_histroy {
   uint8_t parameterselector ;
   uint16_t lastminutepower ;
   uint16_t lasthourpower ;
   uint16_t lastdaypower ;
   uint16_t lastweakpower ;
   uint32_t lastminutepowertime ;
   uint32_t lasthourpowertime ;
   uint32_t lastdaypowertime ;
   uint32_t lastweekpowertime ;
} __attribute__((__packed__)) ;
#line 309 "../include/ipmitool/ipmi_delloem.h"
typedef struct _ipmi_power_consump_histroy IPMI_POWER_CONSUMP_HISTORY;
#line 323 "../include/ipmitool/ipmi_delloem.h"
struct _ipmi_delloem_power_cap {
   uint8_t parameterselector ;
   uint16_t PowerCap ;
   uint8_t unit ;
   uint16_t MaximumPowerConsmp ;
   uint16_t MinimumPowerConsmp ;
   uint16_t totalnumpowersupp ;
   uint16_t AvailablePower ;
   uint16_t SystemThrottling ;
   uint16_t Resv ;
} __attribute__((__packed__)) ;
#line 323 "../include/ipmitool/ipmi_delloem.h"
typedef struct _ipmi_delloem_power_cap IPMI_POWER_CAP;
#line 336 "../include/ipmitool/ipmi_delloem.h"
struct _power_headroom {
   uint16_t instheadroom ;
   uint16_t peakheadroom ;
} __attribute__((__packed__)) ;
#line 336 "../include/ipmitool/ipmi_delloem.h"
typedef struct _power_headroom POWER_HEADROOM;
#line 342 "../include/ipmitool/ipmi_delloem.h"
struct vFlashstr {
   uint8_t val ;
   char const   *str ;
};
#line 346 "../include/ipmitool/ipmi_delloem.h"
struct ipmi_vFlash_extended_info {
   uint8_t vflashcompcode ;
   uint8_t sdcardstatus ;
   uint32_t sdcardsize ;
   uint32_t sdcardavailsize ;
   uint8_t bootpartion ;
   uint8_t Resv ;
} __attribute__((__packed__)) ;
#line 346 "../include/ipmitool/ipmi_delloem.h"
typedef struct ipmi_vFlash_extended_info IPMI_DELL_SDCARD_INFO;
#line 357 "../include/ipmitool/ipmi_delloem.h"
struct _SensorReadingType {
   uint8_t sensorReading ;
   uint8_t sensorFlags ;
   uint16_t sensorState ;
};
#line 357 "../include/ipmitool/ipmi_delloem.h"
typedef struct _SensorReadingType SensorReadingType;
#line 69 "../include/ipmitool/ipmi_fru.h"
#pragma pack(1)
#line 84
#pragma pack(0)
#line 121
#pragma pack(1)
#line 138
#pragma pack(0)
#line 142
#pragma pack(1)
#line 188
#pragma pack(0)
#line 195
#pragma pack(1)
#line 215
#pragma pack(0)
#line 219
#pragma pack(1)
#line 237
#pragma pack(0)
#line 241
#pragma pack(1)
#line 274
#pragma pack(0)
#line 278
#pragma pack(1)
#line 284
#pragma pack(0)
#line 288
#pragma pack(1)
#line 318
#pragma pack(0)
#line 332
#pragma pack(1)
#line 339
#pragma pack(0)
#line 343
#pragma pack(1)
#line 359
#pragma pack(0)
#line 363
#pragma pack(1)
#line 375
#pragma pack(0)
#line 380
#pragma pack(1)
#line 392
#pragma pack(0)
#line 402
#pragma pack(1)
#line 418
#pragma pack(0)
#line 422
#pragma pack(1)
#line 430
#pragma pack(0)
#line 439
#pragma pack(1)
#line 447
#pragma pack(0)
#line 451
#pragma pack(1)
#line 459
#pragma pack(0)
#line 463
#pragma pack(1)
#line 470
#pragma pack(0)
#line 474
#pragma pack(1)
#line 490
#pragma pack(0)
#line 494
#pragma pack(1)
#line 508
#pragma pack(0)
#line 513
#pragma pack(1)
#line 531
#pragma pack(0)
#line 536
#pragma pack(1)
#line 583
#pragma pack(0)
#line 56 "../include/ipmitool/ipmi_mc.h"
#pragma pack(1)
#line 70
#pragma pack(0)
#line 93
#pragma pack(1)
#line 100
#pragma pack(0)
#line 119
#pragma pack(1)
#line 132
#pragma pack(0)
#line 69 "../include/ipmitool/ipmi_sensor.h"
#pragma pack(1)
#line 82
#pragma pack(0)
#line 37 "../include/ipmitool/ipmi_entity.h"
#pragma pack(1)
#line 50
#pragma pack(0)
#line 109 "../include/ipmitool/ipmi_sdr.h"
#pragma pack(1)
#line 120
#pragma pack(0)
#line 124
#pragma pack(1)
#line 133
#pragma pack(0)
#line 137
#pragma pack(1)
#line 144
#pragma pack(0)
#line 149
#pragma pack(1)
#line 160
#pragma pack(0)
#line 164
#pragma pack(1)
#line 185
#pragma pack(0)
#line 189
#pragma pack(1)
#line 319
#pragma pack(0)
#line 323
#pragma pack(1)
#line 410
#pragma pack(0)
#line 414
#pragma pack(1)
#line 450
#pragma pack(0)
#line 454
#pragma pack(1)
#line 502
#pragma pack(0)
#line 506
#pragma pack(1)
#line 571
#pragma pack(0)
#line 575
#pragma pack(1)
#line 603
#pragma pack(0)
#line 636
#pragma pack(0)
#line 640
#pragma pack(1)
#line 670
#pragma pack(0)
#line 674
#pragma pack(1)
#line 701
#pragma pack(0)
#line 714
#pragma pack(1)
#line 742
#pragma pack(0)
#line 753
#pragma pack(1)
#line 775
#pragma pack(0)
#line 63 "../include/ipmitool/ipmi_fru.h"
struct fru_info {
   uint16_t size ;
   uint8_t access : 1 ;
};
#line 69
#pragma pack(1)
#line 71 "../include/ipmitool/ipmi_fru.h"
struct __anonstruct_offset_81 {
   uint8_t internal ;
   uint8_t chassis ;
   uint8_t board ;
   uint8_t product ;
   uint8_t multi ;
};
#line 71 "../include/ipmitool/ipmi_fru.h"
struct fru_header {
   uint8_t version ;
   struct __anonstruct_offset_81 offset ;
   uint8_t pad ;
   uint8_t checksum ;
};
#line 84
#pragma pack(0)
#line 121
#pragma pack(1)
#line 123 "../include/ipmitool/ipmi_fru.h"
struct fru_multirec_header {
   uint8_t type ;
   uint8_t format ;
   uint8_t len ;
   uint8_t record_checksum ;
   uint8_t header_checksum ;
};
#line 138
#pragma pack(0)
#line 142
#pragma pack(1)
#line 144 "../include/ipmitool/ipmi_fru.h"
struct fru_multirec_powersupply {
   uint16_t capacity : 12 ;
   uint16_t __reserved1 : 4 ;
   uint16_t peak_va ;
   uint8_t inrush_current ;
   uint8_t inrush_interval ;
   uint16_t lowend_input1 ;
   uint16_t highend_input1 ;
   uint16_t lowend_input2 ;
   uint16_t highend_input2 ;
   uint8_t lowend_freq ;
   uint8_t highend_freq ;
   uint8_t dropout_tolerance ;
   uint8_t predictive_fail : 1 ;
   uint8_t pfc : 1 ;
   uint8_t autoswitch : 1 ;
   uint8_t hotswap : 1 ;
   uint8_t tach : 1 ;
   uint8_t __reserved2 : 3 ;
   uint16_t peak_cap_ht ;
   uint8_t combined_voltage2 : 4 ;
   uint8_t combined_voltage1 : 4 ;
   uint16_t combined_capacity ;
   uint8_t rps_threshold ;
};
#line 188
#pragma pack(0)
#line 195
#pragma pack(1)
#line 197 "../include/ipmitool/ipmi_fru.h"
struct fru_multirec_dcoutput {
   uint8_t output_number : 4 ;
   uint8_t __reserved : 3 ;
   uint8_t standby : 1 ;
   short nominal_voltage ;
   short max_neg_dev ;
   short max_pos_dev ;
   uint16_t ripple_and_noise ;
   uint16_t min_current ;
   uint16_t max_current ;
};
#line 215
#pragma pack(0)
#line 219
#pragma pack(1)
#line 221 "../include/ipmitool/ipmi_fru.h"
struct fru_multirec_dcload {
   uint8_t output_number : 4 ;
   uint8_t __reserved : 4 ;
   short nominal_voltage ;
   short min_voltage ;
   short max_voltage ;
   uint16_t ripple_and_noise ;
   uint16_t min_current ;
   uint16_t max_current ;
};
#line 237
#pragma pack(0)
#line 241
#pragma pack(1)
#line 243 "../include/ipmitool/ipmi_fru.h"
struct fru_multirec_oem_header {
   unsigned char mfg_id[3] ;
   unsigned char record_id ;
   unsigned char record_version ;
};
#line 274
#pragma pack(0)
#line 278
#pragma pack(1)
#line 280 "../include/ipmitool/ipmi_fru.h"
struct fru_picmgext_guid {
   unsigned char guid[16] ;
};
#line 284
#pragma pack(0)
#line 288
#pragma pack(1)
#line 290 "../include/ipmitool/ipmi_fru.h"
struct fru_picmgext_link_desc {
   unsigned int desig_channel : 6 ;
   unsigned int desig_if : 2 ;
   unsigned int desig_port : 4 ;
   unsigned int type : 8 ;
   unsigned int ext : 4 ;
   unsigned int grouping : 8 ;
};
#line 318
#pragma pack(0)
#line 332
#pragma pack(1)
#line 339
#pragma pack(0)
#line 343
#pragma pack(1)
#line 359
#pragma pack(0)
#line 363
#pragma pack(1)
#line 375
#pragma pack(0)
#line 380
#pragma pack(1)
#line 392
#pragma pack(0)
#line 402
#pragma pack(1)
#line 404 "../include/ipmitool/ipmi_fru.h"
struct fru_picmgext_chn_desc {
   unsigned int remote_slot : 8 ;
   unsigned int remote_chn : 5 ;
   unsigned int local_chn : 5 ;
   unsigned int res : 14 ;
};
#line 418
#pragma pack(0)
#line 422
#pragma pack(1)
#line 424 "../include/ipmitool/ipmi_fru.h"
struct fru_picmgext_slot_desc {
   unsigned char chan_type ;
   unsigned char slot_addr ;
   unsigned char chn_count ;
};
#line 430
#pragma pack(0)
#line 439
#pragma pack(1)
#line 447
#pragma pack(0)
#line 451
#pragma pack(1)
#line 453 "../include/ipmitool/ipmi_fru.h"
struct fru_picmgext_activation_record {
   unsigned char ibmb_addr ;
   unsigned char max_module_curr ;
   unsigned char reserved ;
};
#line 459
#pragma pack(0)
#line 463
#pragma pack(1)
#line 465 "../include/ipmitool/ipmi_fru.h"
struct fru_picmgext_carrier_p2p_record {
   unsigned char resource_id ;
   unsigned char p2p_count ;
};
#line 470
#pragma pack(0)
#line 474
#pragma pack(1)
#line 476 "../include/ipmitool/ipmi_fru.h"
struct fru_picmgext_carrier_p2p_descriptor {
   unsigned char remote_resource_id ;
   unsigned short remote_port : 5 ;
   unsigned short local_port : 5 ;
   unsigned short reserved : 6 ;
};
#line 490
#pragma pack(0)
#line 494
#pragma pack(1)
#line 496 "../include/ipmitool/ipmi_fru.h"
struct fru_picmgext_amc_p2p_record {
   unsigned char resource_id : 4 ;
   unsigned char  : 3 ;
   unsigned char record_type : 1 ;
};
#line 508
#pragma pack(0)
#line 513
#pragma pack(1)
#line 515 "../include/ipmitool/ipmi_fru.h"
struct fru_picmgext_amc_channel_desc_record {
   unsigned int lane0port : 5 ;
   unsigned int lane1port : 5 ;
   unsigned int lane2port : 5 ;
   unsigned int lane3port : 5 ;
   unsigned int  : 12 ;
};
#line 531
#pragma pack(0)
#line 536
#pragma pack(1)
#line 538 "../include/ipmitool/ipmi_fru.h"
struct fru_picmgext_amc_link_desc_record {
   unsigned int channel_id : 8 ;
   unsigned int port_flag_0 : 1 ;
   unsigned int port_flag_1 : 1 ;
   unsigned int port_flag_2 : 1 ;
   unsigned int port_flag_3 : 1 ;
   unsigned int type : 8 ;
   unsigned int type_ext : 4 ;
   unsigned int group_id : 8 ;
   unsigned int asym_match : 2 ;
   unsigned int  : 30 ;
};
#line 583
#pragma pack(0)
#line 56 "../include/ipmitool/ipmi_mc.h"
#pragma pack(1)
#line 70
#pragma pack(0)
#line 93
#pragma pack(1)
#line 100
#pragma pack(0)
#line 119
#pragma pack(1)
#line 132
#pragma pack(0)
#line 103 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
union __anonunion_u_82 {
   uint32_t bits ;
   char chars[4] ;
};
#line 238 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
struct ipmi_fru_bloc {
   uint16_t start ;
   uint16_t size ;
   uint8_t blocId[32] ;
};
#line 238 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
typedef struct ipmi_fru_bloc t_ipmi_fru_bloc;
#line 1635
#pragma pack(1)
#line 1637 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
struct OemKontronInformationRecordV0 {
   uint8_t field1TypeLength ;
   uint8_t field1[8] ;
   uint8_t field2TypeLength ;
   uint8_t field2[8] ;
   uint8_t field3TypeLength ;
   uint8_t field3[8] ;
   uint8_t crcTypeLength ;
   uint8_t crc32[8] ;
};
#line 1637 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
typedef struct OemKontronInformationRecordV0 tOemKontronInformationRecordV0;
#line 1648
#pragma pack(0)
#line 1653
#pragma pack(1)
#line 1655 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
struct OemKontronInformationRecordV1 {
   uint8_t field1TypeLength ;
   uint8_t field1[10] ;
   uint8_t field2TypeLength ;
   uint8_t field2[8] ;
   uint8_t field3TypeLength ;
   uint8_t field3[8] ;
   uint8_t crcTypeLength ;
   uint8_t crc32[8] ;
};
#line 1655 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
typedef struct OemKontronInformationRecordV1 tOemKontronInformationRecordV1;
#line 1666
#pragma pack(0)
#line 69 "../include/ipmitool/ipmi_firewall.h"
struct command_support {
   unsigned char support ;
   unsigned char version[3] ;
   unsigned char subfn_support[32 >> 3] ;
   unsigned char subfn_config[32 >> 3] ;
   unsigned char subfn_enable[32 >> 3] ;
};
#line 76 "../include/ipmitool/ipmi_firewall.h"
struct lun_netfn_support {
   unsigned char support ;
   struct command_support command[256] ;
   unsigned char command_mask[256 >> 3] ;
   unsigned char config_mask[256 >> 3] ;
   unsigned char enable_mask[256 >> 3] ;
};
#line 83 "../include/ipmitool/ipmi_firewall.h"
struct lun_support {
   unsigned char support ;
   struct lun_netfn_support netfn[32] ;
};
#line 87 "../include/ipmitool/ipmi_firewall.h"
struct bmc_fn_support {
   struct lun_support lun[4] ;
};
#line 90 "../include/ipmitool/ipmi_firewall.h"
struct ipmi_function_params {
   int channel ;
   int lun ;
   int netfn ;
   int command ;
   int subfn ;
   unsigned char force ;
};
#line 56 "../include/ipmitool/ipmi_mc.h"
#pragma pack(1)
#line 70
#pragma pack(0)
#line 93
#pragma pack(1)
#line 100
#pragma pack(0)
#line 119
#pragma pack(1)
#line 132
#pragma pack(0)
#line 63 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/../src/plugins/lan/md5.h"
typedef unsigned char md5_byte_t;
#line 64 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/../src/plugins/lan/md5.h"
typedef unsigned int md5_word_t;
#line 67 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/../src/plugins/lan/md5.h"
struct md5_state_s {
   md5_word_t count[2] ;
   md5_word_t abcd[4] ;
   md5_byte_t buf[64] ;
};
#line 67 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/../src/plugins/lan/md5.h"
typedef struct md5_state_s md5_state_t;
#line 240 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
#pragma pack(1)
#line 242 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct __anonstruct_bitField_54 {
   unsigned char component0 : 1 ;
   unsigned char component1 : 1 ;
   unsigned char component2 : 1 ;
   unsigned char component3 : 1 ;
   unsigned char component4 : 1 ;
   unsigned char component5 : 1 ;
   unsigned char component6 : 1 ;
   unsigned char component7 : 1 ;
};
#line 242 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
union __anonunion_ComponentBits_53 {
   unsigned char byte ;
   struct __anonstruct_bitField_54 bitField ;
};
#line 242 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgComponentBitMask {
   union __anonunion_ComponentBits_53 ComponentBits ;
};
#line 272
#pragma pack(0)
#line 288
#pragma pack(1)
#line 290 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgGetTargetUpgCapabilitiesReq {
   unsigned char picmgId ;
};
#line 295
#pragma pack(0)
#line 299
#pragma pack(1)
#line 301 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct __anonstruct_bitField_56 {
   unsigned char ipmcSelftestCap : 1 ;
   unsigned char autRollback : 1 ;
   unsigned char manualRollback : 1 ;
   unsigned char servAffectDuringUpg : 1 ;
   unsigned char deferActivation : 1 ;
   unsigned char ipmcDegradedDurinUpg : 1 ;
   unsigned char autRollbackOverride : 1 ;
   unsigned char fwUpgUndesirable : 1 ;
};
#line 301 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
union __anonunion_GlobalCapabilities_55 {
   unsigned char byte ;
   struct __anonstruct_bitField_56 bitField ;
};
#line 301 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgGetTargetUpgCapabilitiesResp {
   unsigned char picmgId ;
   unsigned char hpmVersion ;
   union __anonunion_GlobalCapabilities_55 GlobalCapabilities ;
   unsigned char upgradeTimeout ;
   unsigned char selftestTimeout ;
   unsigned char rollbackTimeout ;
   unsigned char inaccessTimeout ;
   struct HpmfwupgComponentBitMask componentsPresent ;
};
#line 338
#pragma pack(0)
#line 342
#pragma pack(1)
#line 344 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgGetTargetUpgCapabilitiesCtx {
   struct HpmfwupgGetTargetUpgCapabilitiesReq req ;
   struct HpmfwupgGetTargetUpgCapabilitiesResp resp ;
};
#line 350
#pragma pack(0)
#line 369
#pragma pack(1)
#line 371 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgGetComponentPropertiesReq {
   unsigned char picmgId ;
   unsigned char componentId ;
   unsigned char selector ;
};
#line 378
#pragma pack(0)
#line 382
#pragma pack(1)
#line 384 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct __anonstruct_bitfield_58 {
   unsigned char rollbackBackup : 2 ;
   unsigned char preparationSupport : 1 ;
   unsigned char comparisonSupport : 1 ;
   unsigned char deferredActivation : 1 ;
   unsigned char payloadColdReset : 1 ;
   unsigned char reserved : 2 ;
};
#line 384 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
union __anonunion_GeneralCompProperties_57 {
   unsigned char byte ;
   struct __anonstruct_bitfield_58 bitfield ;
};
#line 384 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgGetGeneralPropResp {
   unsigned char picmgId ;
   union __anonunion_GeneralCompProperties_57 GeneralCompProperties ;
};
#line 411
#pragma pack(0)
#line 415
#pragma pack(1)
#line 417 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgGetCurrentVersionResp {
   unsigned char picmgId ;
   unsigned char currentVersion[6] ;
};
#line 423
#pragma pack(0)
#line 427
#pragma pack(1)
#line 429 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgGetDescStringResp {
   unsigned char picmgId ;
   char descString[12] ;
};
#line 435
#pragma pack(0)
#line 439
#pragma pack(1)
#line 441 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgGetRollbackFwVersionResp {
   unsigned char picmgId ;
   unsigned char rollbackFwVersion[6] ;
};
#line 447
#pragma pack(0)
#line 451
#pragma pack(1)
#line 453 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgGetDeferredFwVersionResp {
   unsigned char picmgId ;
   unsigned char deferredFwVersion[6] ;
};
#line 459
#pragma pack(0)
#line 467
#pragma pack(1)
#line 469 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgGetOemProperties {
   unsigned char picmgId ;
   unsigned char oemRspData[4] ;
};
#line 475
#pragma pack(0)
#line 479
#pragma pack(1)
#line 481 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
union __anonunion_Response_59 {
   struct HpmfwupgGetGeneralPropResp generalPropResp ;
   struct HpmfwupgGetCurrentVersionResp currentVersionResp ;
   struct HpmfwupgGetDescStringResp descStringResp ;
   struct HpmfwupgGetRollbackFwVersionResp rollbackFwVersionResp ;
   struct HpmfwupgGetDeferredFwVersionResp deferredFwVersionResp ;
   struct HpmfwupgGetOemProperties oemProperties ;
};
#line 481 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgGetComponentPropertiesResp {
   union __anonunion_Response_59 Response ;
};
#line 494
#pragma pack(0)
#line 498
#pragma pack(1)
#line 500 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgGetComponentPropertiesCtx {
   struct HpmfwupgGetComponentPropertiesReq req ;
   struct HpmfwupgGetComponentPropertiesResp resp ;
};
#line 506
#pragma pack(0)
#line 514
#pragma pack(1)
#line 516 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgAbortUpgradeReq {
   unsigned char picmgId ;
};
#line 521
#pragma pack(0)
#line 525
#pragma pack(1)
#line 527 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgAbortUpgradeResp {
   unsigned char picmgId ;
};
#line 532
#pragma pack(0)
#line 536
#pragma pack(1)
#line 538 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgAbortUpgradeCtx {
   struct HpmfwupgAbortUpgradeReq req ;
   struct HpmfwupgAbortUpgradeResp resp ;
};
#line 544
#pragma pack(0)
#line 560
#pragma pack(1)
#line 562 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgInitiateUpgradeActionReq {
   unsigned char picmgId ;
   struct HpmfwupgComponentBitMask componentsMask ;
   unsigned char upgradeAction ;
};
#line 569
#pragma pack(0)
#line 573
#pragma pack(1)
#line 575 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgInitiateUpgradeActionResp {
   unsigned char picmgId ;
};
#line 580
#pragma pack(0)
#line 584
#pragma pack(1)
#line 586 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgInitiateUpgradeActionCtx {
   struct HpmfwupgInitiateUpgradeActionReq req ;
   struct HpmfwupgInitiateUpgradeActionResp resp ;
};
#line 592
#pragma pack(0)
#line 606
#pragma pack(1)
#line 608 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgUploadFirmwareBlockReq {
   unsigned char picmgId ;
   unsigned char blockNumber ;
   unsigned char data[256] ;
};
#line 615
#pragma pack(0)
#line 620
#pragma pack(1)
#line 622 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgUploadFirmwareBlockResp {
   unsigned char picmgId ;
};
#line 627
#pragma pack(0)
#line 631
#pragma pack(1)
#line 633 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgUploadFirmwareBlockCtx {
   struct HpmfwupgUploadFirmwareBlockReq req ;
   struct HpmfwupgUploadFirmwareBlockResp resp ;
};
#line 639
#pragma pack(0)
#line 650
#pragma pack(1)
#line 652 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgFinishFirmwareUploadReq {
   unsigned char picmgId ;
   unsigned char componentId ;
   unsigned char imageLength[4] ;
};
#line 659
#pragma pack(0)
#line 663
#pragma pack(1)
#line 665 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgFinishFirmwareUploadResp {
   unsigned char picmgId ;
};
#line 670
#pragma pack(0)
#line 674
#pragma pack(1)
#line 676 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgFinishFirmwareUploadCtx {
   struct HpmfwupgFinishFirmwareUploadReq req ;
   struct HpmfwupgFinishFirmwareUploadResp resp ;
};
#line 682
#pragma pack(0)
#line 689
#pragma pack(1)
#line 691 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgActivateFirmwareReq {
   unsigned char picmgId ;
   unsigned char rollback_override ;
};
#line 697
#pragma pack(0)
#line 701
#pragma pack(1)
#line 703 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgActivateFirmwareResp {
   unsigned char picmgId ;
};
#line 708
#pragma pack(0)
#line 712
#pragma pack(1)
#line 714 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgActivateFirmwareCtx {
   struct HpmfwupgActivateFirmwareReq req ;
   struct HpmfwupgActivateFirmwareResp resp ;
};
#line 720
#pragma pack(0)
#line 728
#pragma pack(1)
#line 730 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgGetUpgradeStatusReq {
   unsigned char picmgId ;
};
#line 735
#pragma pack(0)
#line 739
#pragma pack(1)
#line 741 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgGetUpgradeStatusResp {
   unsigned char picmgId ;
   unsigned char cmdInProcess ;
   unsigned char lastCmdCompCode ;
};
#line 748
#pragma pack(0)
#line 752
#pragma pack(1)
#line 754 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgGetUpgradeStatusCtx {
   struct HpmfwupgGetUpgradeStatusReq req ;
   struct HpmfwupgGetUpgradeStatusResp resp ;
};
#line 760
#pragma pack(0)
#line 768
#pragma pack(1)
#line 770 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgManualFirmwareRollbackReq {
   unsigned char picmgId ;
};
#line 775
#pragma pack(0)
#line 779
#pragma pack(1)
#line 781 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgManualFirmwareRollbackResp {
   unsigned char picmgId ;
};
#line 786
#pragma pack(0)
#line 790
#pragma pack(0)
#line 792 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgManualFirmwareRollbackCtx {
   struct HpmfwupgManualFirmwareRollbackReq req ;
   struct HpmfwupgManualFirmwareRollbackResp resp ;
};
#line 798
#pragma pack(0)
#line 805
#pragma pack(1)
#line 807 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgQueryRollbackStatusReq {
   unsigned char picmgId ;
};
#line 812
#pragma pack(0)
#line 816
#pragma pack(1)
#line 818 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgQueryRollbackStatusResp {
   unsigned char picmgId ;
   struct HpmfwupgComponentBitMask rollbackComp ;
};
#line 824
#pragma pack(0)
#line 828
#pragma pack(1)
#line 830 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgQueryRollbackStatusCtx {
   struct HpmfwupgQueryRollbackStatusReq req ;
   struct HpmfwupgQueryRollbackStatusResp resp ;
};
#line 836
#pragma pack(0)
#line 843
#pragma pack(1)
#line 845 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgQuerySelftestResultReq {
   unsigned char picmgId ;
};
#line 850
#pragma pack(0)
#line 854
#pragma pack(1)
#line 856 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgQuerySelftestResultResp {
   unsigned char picmgId ;
   unsigned char result1 ;
   unsigned char result2 ;
};
#line 863
#pragma pack(0)
#line 867
#pragma pack(1)
#line 869 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgQuerySelftestResultCtx {
   struct HpmfwupgQuerySelftestResultReq req ;
   struct HpmfwupgQuerySelftestResultResp resp ;
};
#line 875
#pragma pack(0)
#line 892
#pragma pack(1)
#line 894 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct __anonstruct_bitField_61 {
   unsigned char reserved : 4 ;
   unsigned char servAffected : 1 ;
   unsigned char manRollback : 1 ;
   unsigned char autRollback : 1 ;
   unsigned char imageSelfTest : 1 ;
};
#line 894 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
union __anonunion_imageCapabilities_60 {
   struct __anonstruct_bitField_61 bitField ;
   unsigned char byte ;
};
#line 894 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgImageHeader {
   char signature[8] ;
   unsigned char formatVersion ;
   unsigned char deviceId ;
   unsigned char manId[3] ;
   unsigned char prodId[2] ;
   unsigned char time[4] ;
   union __anonunion_imageCapabilities_60 imageCapabilities ;
   struct HpmfwupgComponentBitMask components ;
   unsigned char selfTestTimeout ;
   unsigned char rollbackTimeout ;
   unsigned char inaccessTimeout ;
   unsigned char compRevision[2] ;
   unsigned char firmRevision[6] ;
   unsigned short oemDataLength ;
};
#line 931
#pragma pack(0)
#line 938
#pragma pack(1)
#line 940 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgActionRecord {
   unsigned char actionType ;
   struct HpmfwupgComponentBitMask components ;
   unsigned char checksum ;
};
#line 947
#pragma pack(0)
#line 953
#pragma pack(1)
#line 955 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgFirmwareImage {
   unsigned char version[6] ;
   char desc[21] ;
   unsigned char length[4] ;
};
#line 962
#pragma pack(0)
#line 966
#pragma pack(1)
#line 968 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct HpmfwupgUpgradeCtx {
   struct HpmfwupgComponentBitMask compUpdateMask ;
   unsigned int imageSize ;
   unsigned char *pImageData ;
   unsigned char componentId ;
   struct HpmfwupgGetTargetUpgCapabilitiesResp targetCap ;
   struct HpmfwupgGetGeneralPropResp genCompProp[8] ;
   struct ipm_devid_rsp devId ;
};
#line 979
#pragma pack(0)
#line 1008 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
struct _VERSIONINFO {
   unsigned char componentId ;
   unsigned char targetMajor ;
   unsigned char targetMinor ;
   unsigned char targetAux[4] ;
   unsigned char rollbackMajor ;
   unsigned char rollbackMinor ;
   unsigned char rollbackAux[4] ;
   unsigned char deferredMajor ;
   unsigned char deferredMinor ;
   unsigned char deferredAux[4] ;
   unsigned char imageMajor ;
   unsigned char imageMinor ;
   unsigned char imageAux[4] ;
   unsigned char coldResetRequired ;
   unsigned char rollbackSupported ;
   char descString[15] ;
};
#line 1008 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
typedef struct _VERSIONINFO VERSIONINFO;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_10 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_10 fd_set;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 49 "../include/ipmitool/ipmi_isol.h"
struct isol_config_parameters {
   uint8_t enabled ;
   uint8_t privilege_level ;
   uint8_t bit_rate ;
};
#line 129 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
struct __anonstruct_identify_data_53 {
   uint8_t interval ;
   uint8_t force_on ;
};
#line 1092 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
struct __anonstruct_options_54 {
   char *name ;
   int i ;
   unsigned char mask ;
   unsigned char value ;
   char *desc ;
};
#line 37 "../include/ipmitool/ipmi_entity.h"
#pragma pack(1)
#line 50
#pragma pack(0)
#line 109 "../include/ipmitool/ipmi_sdr.h"
#pragma pack(1)
#line 120
#pragma pack(0)
#line 124
#pragma pack(1)
#line 133
#pragma pack(0)
#line 137
#pragma pack(1)
#line 144
#pragma pack(0)
#line 149
#pragma pack(1)
#line 160
#pragma pack(0)
#line 164
#pragma pack(1)
#line 185
#pragma pack(0)
#line 189
#pragma pack(1)
#line 319
#pragma pack(0)
#line 323
#pragma pack(1)
#line 410
#pragma pack(0)
#line 414
#pragma pack(1)
#line 450
#pragma pack(0)
#line 454
#pragma pack(1)
#line 502
#pragma pack(0)
#line 506
#pragma pack(1)
#line 571
#pragma pack(0)
#line 575
#pragma pack(1)
#line 603
#pragma pack(0)
#line 636
#pragma pack(0)
#line 640
#pragma pack(1)
#line 670
#pragma pack(0)
#line 674
#pragma pack(1)
#line 701
#pragma pack(0)
#line 714
#pragma pack(1)
#line 742
#pragma pack(0)
#line 753
#pragma pack(1)
#line 775
#pragma pack(0)
#line 61 "../include/ipmitool/ipmi_sel.h"
#pragma pack(1)
#line 70
#pragma pack(0)
#line 124
#pragma pack(1)
#line 136
#pragma pack(0)
#line 58 "../include/ipmitool/ipmi_channel.h"
#pragma pack(1)
#line 101
#pragma pack(0)
#line 111
#pragma pack(1)
#line 146
#pragma pack(0)
#line 156
#pragma pack(1)
#line 181
#pragma pack(0)
#line 185
#pragma pack(1)
#line 215
#pragma pack(0)
#line 219
#pragma pack(1)
#line 249
#pragma pack(0)
#line 56 "../include/ipmitool/ipmi_mc.h"
#pragma pack(1)
#line 70
#pragma pack(0)
#line 93
#pragma pack(1)
#line 100
#pragma pack(0)
#line 119
#pragma pack(1)
#line 132
#pragma pack(0)
#line 63 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
enum eKFWUM_Task {
    KFWUM_TASK_INFO = 0,
    KFWUM_TASK_STATUS = 1,
    KFWUM_TASK_DOWNLOAD = 2,
    KFWUM_TASK_UPGRADE = 3,
    KFWUM_TASK_START_UPGRADE = 4,
    KFWUM_TASK_ROLLBACK = 5,
    KFWUM_TASK_TRACELOG = 6
} ;
#line 63 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
typedef enum eKFWUM_Task tKFWUM_Task;
#line 74
enum eKFWUM_BoardList {
    KFWUM_BOARD_KONTRON_UNKNOWN = 0,
    KFWUM_BOARD_KONTRON_5002 = 5002
} ;
#line 74 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
typedef enum eKFWUM_BoardList tKFWUM_BoardList;
#line 80
enum eKFWUM_IanaList {
    KFWUM_IANA_KONTRON = 15000
} ;
#line 80 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
typedef enum eKFWUM_IanaList tKFWUM_IanaList;
#line 85 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
struct sKFWUM_BoardInfo {
   tKFWUM_BoardList boardId ;
   tKFWUM_IanaList iana ;
};
#line 85 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
typedef struct sKFWUM_BoardInfo tKFWUM_BoardInfo;
#line 91
enum eKFWUM_Status {
    KFWUM_STATUS_OK = 0,
    KFWUM_STATUS_ERROR = 1
} ;
#line 91 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
typedef enum eKFWUM_Status tKFWUM_Status;
#line 97
enum eKFWUM_DownloadType {
    KFWUM_DOWNLOAD_TYPE_ADDRESS = 0,
    KFWUM_DOWNLOAD_TYPE_SEQUENCE = 1
} ;
#line 97 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
typedef enum eKFWUM_DownloadType tKFWUM_DownloadType;
#line 109 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
struct sKFWUM_InFirmwareInfo {
   unsigned long fileSize ;
   unsigned short checksum ;
   unsigned short sumToRemoveFromChecksum ;
   tKFWUM_BoardList boardId ;
   unsigned char deviceId ;
   unsigned char tableVers ;
   unsigned char implRev ;
   unsigned char versMajor ;
   unsigned char versMinor ;
   unsigned char versSubMinor ;
   unsigned char sdrRev ;
   tKFWUM_IanaList iana ;
};
#line 109 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
typedef struct sKFWUM_InFirmwareInfo tKFWUM_InFirmwareInfo;
#line 129 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
struct sKFWUM_SaveFirmwareInfo {
   tKFWUM_DownloadType downloadType ;
   unsigned char bufferSize ;
   unsigned char overheadSize ;
};
#line 129 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
typedef struct sKFWUM_SaveFirmwareInfo tKFWUM_SaveFirmwareInfo;
#line 623
#pragma pack(1)
#line 625 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
struct __anonstruct_byte_58 {
   unsigned char mode : 1 ;
   unsigned char seqAdd : 1 ;
   unsigned char res : 6 ;
};
#line 625 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
struct KfwumGetInfoResp {
   unsigned char protocolRevision ;
   unsigned char controllerDeviceId ;
   struct __anonstruct_byte_58 byte ;
   unsigned char firmRev1 ;
   unsigned char firmRev2 ;
   unsigned char numBank ;
};
#line 639
#pragma pack(0)
#line 842
#pragma pack(1)
#line 844 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
struct KfwumGetStatusResp {
   unsigned char bankState ;
   unsigned char firmLengthLSB ;
   unsigned char firmLengthMid ;
   unsigned char firmLengthMSB ;
   unsigned char firmRev1 ;
   unsigned char firmRev2 ;
   unsigned char firmRev3 ;
};
#line 854
#pragma pack(0)
#line 940
#pragma pack(1)
#line 942 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
struct KfwumManualRollbackReq {
   unsigned char type ;
};
#line 946
#pragma pack(0)
#line 993
#pragma pack(1)
#line 995 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
struct KfwumStartFirmwareDownloadReq {
   unsigned char lengthLSB ;
   unsigned char lengthMid ;
   unsigned char lengthMSB ;
   unsigned char paddingLSB ;
   unsigned char paddingMSB ;
   unsigned char useSequence ;
};
#line 1004
#pragma pack(0)
#line 1008
#pragma pack(1)
#line 1010 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
struct KfwumStartFirmwareDownloadResp {
   unsigned char bank ;
};
#line 1014
#pragma pack(0)
#line 1072
#pragma pack(1)
#line 1074 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
struct KfwumSaveFirmwareAddressReq {
   unsigned char addressLSB ;
   unsigned char addressMid ;
   unsigned char addressMSB ;
   unsigned char numBytes ;
   unsigned char txBuf[26] ;
};
#line 1083
#pragma pack(0)
#line 1087
#pragma pack(1)
#line 1089 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
struct KfwumSaveFirmwareSequenceReq {
   unsigned char sequenceNumber ;
   unsigned char txBuf[32] ;
};
#line 1095
#pragma pack(0)
#line 1241
#pragma pack(1)
#line 1243 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
struct KfwumFinishFirmwareDownloadReq {
   unsigned char versionMaj ;
   unsigned char versionMinSub ;
   unsigned char versionSdr ;
   unsigned char reserved ;
};
#line 1250
#pragma pack(0)
#line 37 "../include/ipmitool/ipmi_entity.h"
#pragma pack(1)
#line 50
#pragma pack(0)
#line 109 "../include/ipmitool/ipmi_sdr.h"
#pragma pack(1)
#line 120
#pragma pack(0)
#line 124
#pragma pack(1)
#line 133
#pragma pack(0)
#line 137
#pragma pack(1)
#line 144
#pragma pack(0)
#line 149
#pragma pack(1)
#line 160
#pragma pack(0)
#line 164
#pragma pack(1)
#line 185
#pragma pack(0)
#line 189
#pragma pack(1)
#line 319
#pragma pack(0)
#line 323
#pragma pack(1)
#line 410
#pragma pack(0)
#line 414
#pragma pack(1)
#line 450
#pragma pack(0)
#line 454
#pragma pack(1)
#line 502
#pragma pack(0)
#line 506
#pragma pack(1)
#line 571
#pragma pack(0)
#line 575
#pragma pack(1)
#line 603
#pragma pack(0)
#line 636
#pragma pack(0)
#line 640
#pragma pack(1)
#line 670
#pragma pack(0)
#line 674
#pragma pack(1)
#line 701
#pragma pack(0)
#line 714
#pragma pack(1)
#line 742
#pragma pack(0)
#line 753
#pragma pack(1)
#line 775
#pragma pack(0)
#line 61 "../include/ipmitool/ipmi_sel.h"
#pragma pack(1)
#line 70
#pragma pack(0)
#line 73 "../include/ipmitool/ipmi_sel.h"
struct standard_spec_sel_rec {
   uint32_t timestamp ;
   uint16_t gen_id ;
   uint8_t evm_rev ;
   uint8_t sensor_type ;
   uint8_t sensor_num ;
   uint8_t event_type : 7 ;
   uint8_t event_dir : 1 ;
   uint8_t event_data[3] ;
};
#line 113 "../include/ipmitool/ipmi_sel.h"
struct oem_ts_spec_sel_rec {
   uint32_t timestamp ;
   uint8_t manf_id[3] ;
   uint8_t oem_defined[6] ;
};
#line 119 "../include/ipmitool/ipmi_sel.h"
struct oem_nots_spec_sel_rec {
   uint8_t oem_defined[13] ;
};
#line 124
#pragma pack(1)
#line 126 "../include/ipmitool/ipmi_sel.h"
union __anonunion_sel_type_109 {
   struct standard_spec_sel_rec standard_type ;
   struct oem_ts_spec_sel_rec oem_ts_type ;
   struct oem_nots_spec_sel_rec oem_nots_type ;
};
#line 126 "../include/ipmitool/ipmi_sel.h"
struct sel_event_record {
   uint16_t record_id ;
   uint8_t record_type ;
   union __anonunion_sel_type_109 sel_type ;
};
#line 136
#pragma pack(0)
#line 139 "../include/ipmitool/ipmi_sel.h"
struct ipmi_event_sensor_types {
   uint8_t code ;
   uint8_t offset ;
   uint8_t data ;
   uint8_t class ;
   char const   *type ;
   char const   *desc ;
};
#line 58 "../include/ipmitool/ipmi_channel.h"
#pragma pack(1)
#line 101
#pragma pack(0)
#line 111
#pragma pack(1)
#line 146
#pragma pack(0)
#line 156
#pragma pack(1)
#line 181
#pragma pack(0)
#line 185
#pragma pack(1)
#line 215
#pragma pack(0)
#line 219
#pragma pack(1)
#line 249
#pragma pack(0)
#line 45 "../include/ipmitool/ipmi_event.h"
#pragma pack(1)
#line 47 "../include/ipmitool/ipmi_event.h"
struct platform_event_msg {
   uint8_t evm_rev ;
   uint8_t sensor_type ;
   uint8_t sensor_num ;
   uint8_t event_type : 7 ;
   uint8_t event_dir : 1 ;
   uint8_t event_data[3] ;
};
#line 61
#pragma pack(0)
#line 58 "../include/ipmitool/ipmi_channel.h"
#pragma pack(1)
#line 60 "../include/ipmitool/ipmi_channel.h"
struct get_channel_auth_cap_rsp {
   uint8_t channel_number ;
   uint8_t enabled_auth_types : 6 ;
   uint8_t __reserved1 : 1 ;
   uint8_t v20_data_available : 1 ;
   uint8_t anon_login_enabled : 1 ;
   uint8_t null_usernames : 1 ;
   uint8_t non_null_usernames : 1 ;
   uint8_t user_level_auth : 1 ;
   uint8_t per_message_auth : 1 ;
   uint8_t kg_status : 1 ;
   uint8_t __reserved2 : 2 ;
   uint8_t ipmiv15_support : 1 ;
   uint8_t ipmiv20_support : 1 ;
   uint8_t __reserved3 : 6 ;
   uint8_t oem_id[3] ;
   uint8_t oem_aux_data ;
};
#line 101
#pragma pack(0)
#line 111
#pragma pack(1)
#line 113 "../include/ipmitool/ipmi_channel.h"
struct get_channel_info_rsp {
   uint8_t channel_number : 4 ;
   uint8_t __reserved1 : 4 ;
   uint8_t channel_medium : 7 ;
   uint8_t __reserved2 : 1 ;
   uint8_t channel_protocol : 5 ;
   uint8_t __reserved3 : 3 ;
   uint8_t active_sessions : 6 ;
   uint8_t session_support : 2 ;
   uint8_t vendor_id[3] ;
   uint8_t aux_info[2] ;
};
#line 146
#pragma pack(0)
#line 156
#pragma pack(1)
#line 158 "../include/ipmitool/ipmi_channel.h"
struct get_channel_access_rsp {
   uint8_t access_mode : 3 ;
   uint8_t user_level_auth : 1 ;
   uint8_t per_message_auth : 1 ;
   uint8_t alerting : 1 ;
   uint8_t __reserved1 : 2 ;
   uint8_t channel_priv_limit : 4 ;
   uint8_t __reserved2 : 4 ;
};
#line 181
#pragma pack(0)
#line 185
#pragma pack(1)
#line 187 "../include/ipmitool/ipmi_channel.h"
struct get_user_access_rsp {
   uint8_t max_user_ids : 6 ;
   uint8_t __reserved1 : 2 ;
   uint8_t enabled_user_ids : 6 ;
   uint8_t __reserved2 : 2 ;
   uint8_t fixed_user_ids : 6 ;
   uint8_t __reserved3 : 2 ;
   uint8_t privilege_limit : 4 ;
   uint8_t ipmi_messaging : 1 ;
   uint8_t link_auth : 1 ;
   uint8_t callin_callback : 1 ;
   uint8_t __reserved4 : 1 ;
};
#line 215
#pragma pack(0)
#line 219
#pragma pack(1)
#line 221 "../include/ipmitool/ipmi_channel.h"
struct set_user_access_data {
   uint8_t channel : 4 ;
   uint8_t ipmi_messaging : 1 ;
   uint8_t link_auth : 1 ;
   uint8_t callin_callback : 1 ;
   uint8_t change_bits : 1 ;
   uint8_t user_id : 6 ;
   uint8_t __reserved1 : 2 ;
   uint8_t privilege_limit : 4 ;
   uint8_t __reserved2 : 4 ;
   uint8_t session_limit : 4 ;
   uint8_t __reserved3 : 4 ;
};
#line 249
#pragma pack(0)
#line 56 "../include/ipmitool/ipmi_mc.h"
#pragma pack(1)
#line 70
#pragma pack(0)
#line 93
#pragma pack(1)
#line 100
#pragma pack(0)
#line 119
#pragma pack(1)
#line 132
#pragma pack(0)
#line 37 "../include/ipmitool/ipmi_entity.h"
#pragma pack(1)
#line 50
#pragma pack(0)
#line 109 "../include/ipmitool/ipmi_sdr.h"
#pragma pack(1)
#line 120
#pragma pack(0)
#line 124
#pragma pack(1)
#line 133
#pragma pack(0)
#line 137
#pragma pack(1)
#line 144
#pragma pack(0)
#line 149
#pragma pack(1)
#line 160
#pragma pack(0)
#line 164
#pragma pack(1)
#line 185
#pragma pack(0)
#line 189
#pragma pack(1)
#line 319
#pragma pack(0)
#line 323
#pragma pack(1)
#line 410
#pragma pack(0)
#line 414
#pragma pack(1)
#line 450
#pragma pack(0)
#line 454
#pragma pack(1)
#line 502
#pragma pack(0)
#line 506
#pragma pack(1)
#line 571
#pragma pack(0)
#line 575
#pragma pack(1)
#line 603
#pragma pack(0)
#line 636
#pragma pack(0)
#line 640
#pragma pack(1)
#line 670
#pragma pack(0)
#line 674
#pragma pack(1)
#line 701
#pragma pack(0)
#line 714
#pragma pack(1)
#line 742
#pragma pack(0)
#line 753
#pragma pack(1)
#line 775
#pragma pack(0)
#line 61 "../include/ipmitool/ipmi_sel.h"
#pragma pack(1)
#line 70
#pragma pack(0)
#line 124
#pragma pack(1)
#line 136
#pragma pack(0)
#line 63 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_gendev.c"
struct gendev_eeprom_info {
   uint32_t size ;
   uint16_t page_size ;
   uint8_t address_span ;
   uint8_t address_length ;
};
#line 63 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_gendev.c"
typedef struct gendev_eeprom_info t_gendev_eeprom_info;
#line 156 "../include/ipmitool/ipmi_intf.h"
struct ipmi_intf_support {
   char const   *name ;
   int supported ;
};
#line 37 "../include/ipmitool/ipmi_entity.h"
#pragma pack(1)
#line 50
#pragma pack(0)
#line 109 "../include/ipmitool/ipmi_sdr.h"
#pragma pack(1)
#line 120
#pragma pack(0)
#line 124
#pragma pack(1)
#line 133
#pragma pack(0)
#line 137
#pragma pack(1)
#line 144
#pragma pack(0)
#line 149
#pragma pack(1)
#line 160
#pragma pack(0)
#line 164
#pragma pack(1)
#line 185
#pragma pack(0)
#line 189
#pragma pack(1)
#line 319
#pragma pack(0)
#line 323
#pragma pack(1)
#line 410
#pragma pack(0)
#line 414
#pragma pack(1)
#line 450
#pragma pack(0)
#line 454
#pragma pack(1)
#line 502
#pragma pack(0)
#line 506
#pragma pack(1)
#line 571
#pragma pack(0)
#line 575
#pragma pack(1)
#line 603
#pragma pack(0)
#line 636
#pragma pack(0)
#line 640
#pragma pack(1)
#line 670
#pragma pack(0)
#line 674
#pragma pack(1)
#line 701
#pragma pack(0)
#line 714
#pragma pack(1)
#line 742
#pragma pack(0)
#line 753
#pragma pack(1)
#line 775
#pragma pack(0)
#line 61 "../include/ipmitool/ipmi_sel.h"
#pragma pack(1)
#line 70
#pragma pack(0)
#line 124
#pragma pack(1)
#line 136
#pragma pack(0)
#line 69 "../include/ipmitool/ipmi_fru.h"
#pragma pack(1)
#line 84
#pragma pack(0)
#line 121
#pragma pack(1)
#line 138
#pragma pack(0)
#line 142
#pragma pack(1)
#line 188
#pragma pack(0)
#line 195
#pragma pack(1)
#line 215
#pragma pack(0)
#line 219
#pragma pack(1)
#line 237
#pragma pack(0)
#line 241
#pragma pack(1)
#line 274
#pragma pack(0)
#line 278
#pragma pack(1)
#line 284
#pragma pack(0)
#line 288
#pragma pack(1)
#line 318
#pragma pack(0)
#line 332
#pragma pack(1)
#line 339
#pragma pack(0)
#line 343
#pragma pack(1)
#line 359
#pragma pack(0)
#line 363
#pragma pack(1)
#line 375
#pragma pack(0)
#line 380
#pragma pack(1)
#line 392
#pragma pack(0)
#line 402
#pragma pack(1)
#line 418
#pragma pack(0)
#line 422
#pragma pack(1)
#line 430
#pragma pack(0)
#line 439
#pragma pack(1)
#line 447
#pragma pack(0)
#line 451
#pragma pack(1)
#line 459
#pragma pack(0)
#line 463
#pragma pack(1)
#line 470
#pragma pack(0)
#line 474
#pragma pack(1)
#line 490
#pragma pack(0)
#line 494
#pragma pack(1)
#line 508
#pragma pack(0)
#line 513
#pragma pack(1)
#line 531
#pragma pack(0)
#line 536
#pragma pack(1)
#line 583
#pragma pack(0)
#line 56 "../include/ipmitool/ipmi_mc.h"
#pragma pack(1)
#line 70
#pragma pack(0)
#line 93
#pragma pack(1)
#line 100
#pragma pack(0)
#line 119
#pragma pack(1)
#line 132
#pragma pack(0)
#line 69 "../include/ipmitool/ipmi_sensor.h"
#pragma pack(1)
#line 82
#pragma pack(0)
#line 58 "../include/ipmitool/ipmi_channel.h"
#pragma pack(1)
#line 101
#pragma pack(0)
#line 111
#pragma pack(1)
#line 146
#pragma pack(0)
#line 156
#pragma pack(1)
#line 181
#pragma pack(0)
#line 185
#pragma pack(1)
#line 215
#pragma pack(0)
#line 219
#pragma pack(1)
#line 249
#pragma pack(0)
#line 47 "../include/ipmitool/ipmi_session.h"
#pragma pack(1)
#line 124
#pragma pack(0)
#line 45 "../include/ipmitool/ipmi_event.h"
#pragma pack(1)
#line 61
#pragma pack(0)
#line 88 "../include/ipmitool/ipmi_user.h"
#pragma pack(0)
#line 54 "../include/ipmitool/ipmi_pef.h"
#pragma pack(1)
#line 98
#pragma pack(0)
#line 334
#pragma pack(1)
#line 355
#pragma pack(0)
#line 400
#pragma pack(1)
#line 423
#pragma pack(0)
#line 427
#pragma pack(1)
#line 435
#pragma pack(0)
#line 439
#pragma pack(1)
#line 449
#pragma pack(0)
#line 463
#pragma pack(1)
#line 475
#pragma pack(0)
#line 479
#pragma pack(1)
#line 485
#pragma pack(0)
#line 489
#pragma pack(1)
#line 495
#pragma pack(0)
#line 499
#pragma pack(1)
#line 506
#pragma pack(0)
#line 510
#pragma pack(1)
#line 518
#pragma pack(0)
#line 522
#pragma pack(1)
#line 529
#pragma pack(0)
#line 533
#pragma pack(1)
#line 540
#pragma pack(0)
#line 544
#pragma pack(1)
#line 552
#pragma pack(0)
#line 556
#pragma pack(1)
#line 564
#pragma pack(0)
#line 568
#pragma pack(1)
#line 575
#pragma pack(0)
#line 579
#pragma pack(1)
#line 590
#pragma pack(0)
#line 594
#pragma pack(1)
#line 602
#pragma pack(0)
#line 607
#pragma pack(1)
#line 622
#pragma pack(0)
#line 626
#pragma pack(1)
#line 633
#pragma pack(0)
#line 637
#pragma pack(1)
#line 653
#pragma pack(0)
#line 667
#pragma pack(1)
#line 682
#pragma pack(0)
#line 687
#pragma pack(1)
#line 705
#pragma pack(0)
#line 709
#pragma pack(1)
#line 716
#pragma pack(0)
#line 720
#pragma pack(1)
#line 752
#pragma pack(0)
#line 769
#pragma pack(1)
#line 776
#pragma pack(0)
#line 780
#pragma pack(1)
#line 789
#pragma pack(0)
#line 793
#pragma pack(1)
#line 800
#pragma pack(0)
#line 804
#pragma pack(1)
#line 814
#pragma pack(0)
#line 818
#pragma pack(1)
#line 832
#pragma pack(0)
#line 62 "../include/ipmitool/ipmi_picmg.h"
#pragma pack(1)
#line 70
#pragma pack(0)
#line 36 "../include/ipmitool/ipmi_delloem.h"
#pragma pack(1)
#line 37 "../include/ipmitool/ipmi_entity.h"
#pragma pack(1)
#line 50
#pragma pack(0)
#line 109 "../include/ipmitool/ipmi_sdr.h"
#pragma pack(1)
#line 120
#pragma pack(0)
#line 124
#pragma pack(1)
#line 133
#pragma pack(0)
#line 137
#pragma pack(1)
#line 144
#pragma pack(0)
#line 149
#pragma pack(1)
#line 160
#pragma pack(0)
#line 164
#pragma pack(1)
#line 185
#pragma pack(0)
#line 189
#pragma pack(1)
#line 319
#pragma pack(0)
#line 323
#pragma pack(1)
#line 410
#pragma pack(0)
#line 414
#pragma pack(1)
#line 450
#pragma pack(0)
#line 454
#pragma pack(1)
#line 502
#pragma pack(0)
#line 506
#pragma pack(1)
#line 571
#pragma pack(0)
#line 575
#pragma pack(1)
#line 603
#pragma pack(0)
#line 636
#pragma pack(0)
#line 640
#pragma pack(1)
#line 670
#pragma pack(0)
#line 674
#pragma pack(1)
#line 701
#pragma pack(0)
#line 714
#pragma pack(1)
#line 742
#pragma pack(0)
#line 753
#pragma pack(1)
#line 775
#pragma pack(0)
#line 69 "../include/ipmitool/ipmi_fru.h"
#pragma pack(1)
#line 84
#pragma pack(0)
#line 121
#pragma pack(1)
#line 138
#pragma pack(0)
#line 142
#pragma pack(1)
#line 188
#pragma pack(0)
#line 195
#pragma pack(1)
#line 215
#pragma pack(0)
#line 219
#pragma pack(1)
#line 237
#pragma pack(0)
#line 241
#pragma pack(1)
#line 274
#pragma pack(0)
#line 278
#pragma pack(1)
#line 284
#pragma pack(0)
#line 288
#pragma pack(1)
#line 318
#pragma pack(0)
#line 332
#pragma pack(1)
#line 339
#pragma pack(0)
#line 343
#pragma pack(1)
#line 359
#pragma pack(0)
#line 363
#pragma pack(1)
#line 375
#pragma pack(0)
#line 380
#pragma pack(1)
#line 392
#pragma pack(0)
#line 402
#pragma pack(1)
#line 418
#pragma pack(0)
#line 422
#pragma pack(1)
#line 430
#pragma pack(0)
#line 439
#pragma pack(1)
#line 441 "../include/ipmitool/ipmi_fru.h"
struct fru_picmgext_carrier_activation_record {
   unsigned short max_internal_curr ;
   unsigned char allowance_for_readiness ;
   unsigned char module_activation_record_count ;
};
#line 447
#pragma pack(0)
#line 451
#pragma pack(1)
#line 459
#pragma pack(0)
#line 463
#pragma pack(1)
#line 470
#pragma pack(0)
#line 474
#pragma pack(1)
#line 490
#pragma pack(0)
#line 494
#pragma pack(1)
#line 508
#pragma pack(0)
#line 513
#pragma pack(1)
#line 531
#pragma pack(0)
#line 536
#pragma pack(1)
#line 583
#pragma pack(0)
#line 181 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
struct ipmi_ek_multi_header {
   struct fru_multirec_header header ;
   unsigned char *data ;
   struct ipmi_ek_multi_header *prev ;
   struct ipmi_ek_multi_header *next ;
};
#line 188 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
struct ipmi_ek_amc_p2p_connectivity_record {
   unsigned char guid_count ;
   struct fru_picmgext_guid *oem_guid ;
   unsigned char rsc_id ;
   unsigned char ch_count ;
   struct fru_picmgext_amc_channel_desc_record *ch_desc ;
   unsigned char link_desc_count ;
   struct fru_picmgext_amc_link_desc_record *link_desc ;
   int *matching_result ;
};
#line 37 "../include/ipmitool/ipmi_entity.h"
#pragma pack(1)
#line 50
#pragma pack(0)
#line 109 "../include/ipmitool/ipmi_sdr.h"
#pragma pack(1)
#line 120
#pragma pack(0)
#line 124
#pragma pack(1)
#line 133
#pragma pack(0)
#line 137
#pragma pack(1)
#line 144
#pragma pack(0)
#line 149
#pragma pack(1)
#line 160
#pragma pack(0)
#line 164
#pragma pack(1)
#line 185
#pragma pack(0)
#line 189
#pragma pack(1)
#line 319
#pragma pack(0)
#line 323
#pragma pack(1)
#line 410
#pragma pack(0)
#line 414
#pragma pack(1)
#line 450
#pragma pack(0)
#line 454
#pragma pack(1)
#line 502
#pragma pack(0)
#line 506
#pragma pack(1)
#line 571
#pragma pack(0)
#line 575
#pragma pack(1)
#line 603
#pragma pack(0)
#line 636
#pragma pack(0)
#line 640
#pragma pack(1)
#line 670
#pragma pack(0)
#line 674
#pragma pack(1)
#line 701
#pragma pack(0)
#line 714
#pragma pack(1)
#line 742
#pragma pack(0)
#line 753
#pragma pack(1)
#line 775
#pragma pack(0)
#line 69 "../include/ipmitool/ipmi_fru.h"
#pragma pack(1)
#line 84
#pragma pack(0)
#line 121
#pragma pack(1)
#line 138
#pragma pack(0)
#line 142
#pragma pack(1)
#line 188
#pragma pack(0)
#line 195
#pragma pack(1)
#line 215
#pragma pack(0)
#line 219
#pragma pack(1)
#line 237
#pragma pack(0)
#line 241
#pragma pack(1)
#line 274
#pragma pack(0)
#line 278
#pragma pack(1)
#line 284
#pragma pack(0)
#line 288
#pragma pack(1)
#line 318
#pragma pack(0)
#line 332
#pragma pack(1)
#line 339
#pragma pack(0)
#line 343
#pragma pack(1)
#line 359
#pragma pack(0)
#line 363
#pragma pack(1)
#line 375
#pragma pack(0)
#line 380
#pragma pack(1)
#line 392
#pragma pack(0)
#line 402
#pragma pack(1)
#line 418
#pragma pack(0)
#line 422
#pragma pack(1)
#line 430
#pragma pack(0)
#line 439
#pragma pack(1)
#line 447
#pragma pack(0)
#line 451
#pragma pack(1)
#line 459
#pragma pack(0)
#line 463
#pragma pack(1)
#line 470
#pragma pack(0)
#line 474
#pragma pack(1)
#line 490
#pragma pack(0)
#line 494
#pragma pack(1)
#line 508
#pragma pack(0)
#line 513
#pragma pack(1)
#line 531
#pragma pack(0)
#line 536
#pragma pack(1)
#line 583
#pragma pack(0)
#line 56 "../include/ipmitool/ipmi_mc.h"
#pragma pack(1)
#line 70
#pragma pack(0)
#line 93
#pragma pack(1)
#line 100
#pragma pack(0)
#line 119
#pragma pack(1)
#line 132
#pragma pack(0)
#line 240 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
#pragma pack(1)
#line 272
#pragma pack(0)
#line 288
#pragma pack(1)
#line 295
#pragma pack(0)
#line 299
#pragma pack(1)
#line 338
#pragma pack(0)
#line 342
#pragma pack(1)
#line 350
#pragma pack(0)
#line 369
#pragma pack(1)
#line 378
#pragma pack(0)
#line 382
#pragma pack(1)
#line 411
#pragma pack(0)
#line 415
#pragma pack(1)
#line 423
#pragma pack(0)
#line 427
#pragma pack(1)
#line 435
#pragma pack(0)
#line 439
#pragma pack(1)
#line 447
#pragma pack(0)
#line 451
#pragma pack(1)
#line 459
#pragma pack(0)
#line 467
#pragma pack(1)
#line 475
#pragma pack(0)
#line 479
#pragma pack(1)
#line 494
#pragma pack(0)
#line 498
#pragma pack(1)
#line 506
#pragma pack(0)
#line 514
#pragma pack(1)
#line 521
#pragma pack(0)
#line 525
#pragma pack(1)
#line 532
#pragma pack(0)
#line 536
#pragma pack(1)
#line 544
#pragma pack(0)
#line 560
#pragma pack(1)
#line 569
#pragma pack(0)
#line 573
#pragma pack(1)
#line 580
#pragma pack(0)
#line 584
#pragma pack(1)
#line 592
#pragma pack(0)
#line 606
#pragma pack(1)
#line 615
#pragma pack(0)
#line 620
#pragma pack(1)
#line 627
#pragma pack(0)
#line 631
#pragma pack(1)
#line 639
#pragma pack(0)
#line 650
#pragma pack(1)
#line 659
#pragma pack(0)
#line 663
#pragma pack(1)
#line 670
#pragma pack(0)
#line 674
#pragma pack(1)
#line 682
#pragma pack(0)
#line 689
#pragma pack(1)
#line 697
#pragma pack(0)
#line 701
#pragma pack(1)
#line 708
#pragma pack(0)
#line 712
#pragma pack(1)
#line 720
#pragma pack(0)
#line 728
#pragma pack(1)
#line 735
#pragma pack(0)
#line 739
#pragma pack(1)
#line 748
#pragma pack(0)
#line 752
#pragma pack(1)
#line 760
#pragma pack(0)
#line 768
#pragma pack(1)
#line 775
#pragma pack(0)
#line 779
#pragma pack(1)
#line 786
#pragma pack(0)
#line 790
#pragma pack(0)
#line 798
#pragma pack(0)
#line 805
#pragma pack(1)
#line 812
#pragma pack(0)
#line 816
#pragma pack(1)
#line 824
#pragma pack(0)
#line 828
#pragma pack(1)
#line 836
#pragma pack(0)
#line 843
#pragma pack(1)
#line 850
#pragma pack(0)
#line 854
#pragma pack(1)
#line 863
#pragma pack(0)
#line 867
#pragma pack(1)
#line 875
#pragma pack(0)
#line 892
#pragma pack(1)
#line 931
#pragma pack(0)
#line 938
#pragma pack(1)
#line 947
#pragma pack(0)
#line 953
#pragma pack(1)
#line 962
#pragma pack(0)
#line 966
#pragma pack(1)
#line 979
#pragma pack(0)
#line 37 "../include/ipmitool/ipmi_entity.h"
#pragma pack(1)
#line 50
#pragma pack(0)
#line 109 "../include/ipmitool/ipmi_sdr.h"
#pragma pack(1)
#line 120
#pragma pack(0)
#line 124
#pragma pack(1)
#line 133
#pragma pack(0)
#line 137
#pragma pack(1)
#line 144
#pragma pack(0)
#line 149
#pragma pack(1)
#line 160
#pragma pack(0)
#line 164
#pragma pack(1)
#line 185
#pragma pack(0)
#line 189
#pragma pack(1)
#line 319
#pragma pack(0)
#line 323
#pragma pack(1)
#line 410
#pragma pack(0)
#line 414
#pragma pack(1)
#line 450
#pragma pack(0)
#line 454
#pragma pack(1)
#line 502
#pragma pack(0)
#line 506
#pragma pack(1)
#line 571
#pragma pack(0)
#line 575
#pragma pack(1)
#line 603
#pragma pack(0)
#line 636
#pragma pack(0)
#line 640
#pragma pack(1)
#line 670
#pragma pack(0)
#line 674
#pragma pack(1)
#line 701
#pragma pack(0)
#line 714
#pragma pack(1)
#line 742
#pragma pack(0)
#line 753
#pragma pack(1)
#line 775
#pragma pack(0)
#line 69 "../include/ipmitool/ipmi_fru.h"
#pragma pack(1)
#line 84
#pragma pack(0)
#line 121
#pragma pack(1)
#line 138
#pragma pack(0)
#line 142
#pragma pack(1)
#line 188
#pragma pack(0)
#line 195
#pragma pack(1)
#line 215
#pragma pack(0)
#line 219
#pragma pack(1)
#line 237
#pragma pack(0)
#line 241
#pragma pack(1)
#line 274
#pragma pack(0)
#line 278
#pragma pack(1)
#line 284
#pragma pack(0)
#line 288
#pragma pack(1)
#line 318
#pragma pack(0)
#line 332
#pragma pack(1)
#line 339
#pragma pack(0)
#line 343
#pragma pack(1)
#line 359
#pragma pack(0)
#line 363
#pragma pack(1)
#line 375
#pragma pack(0)
#line 380
#pragma pack(1)
#line 392
#pragma pack(0)
#line 402
#pragma pack(1)
#line 418
#pragma pack(0)
#line 422
#pragma pack(1)
#line 430
#pragma pack(0)
#line 439
#pragma pack(1)
#line 447
#pragma pack(0)
#line 451
#pragma pack(1)
#line 459
#pragma pack(0)
#line 463
#pragma pack(1)
#line 470
#pragma pack(0)
#line 474
#pragma pack(1)
#line 490
#pragma pack(0)
#line 494
#pragma pack(1)
#line 508
#pragma pack(0)
#line 513
#pragma pack(1)
#line 531
#pragma pack(0)
#line 536
#pragma pack(1)
#line 583
#pragma pack(0)
#line 56 "../include/ipmitool/ipmi_mc.h"
#pragma pack(1)
#line 70
#pragma pack(0)
#line 93
#pragma pack(1)
#line 100
#pragma pack(0)
#line 119
#pragma pack(1)
#line 132
#pragma pack(0)
#line 623 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
#pragma pack(1)
#line 639
#pragma pack(0)
#line 842
#pragma pack(1)
#line 854
#pragma pack(0)
#line 940
#pragma pack(1)
#line 946
#pragma pack(0)
#line 993
#pragma pack(1)
#line 1004
#pragma pack(0)
#line 1008
#pragma pack(1)
#line 1014
#pragma pack(0)
#line 1072
#pragma pack(1)
#line 1083
#pragma pack(0)
#line 1087
#pragma pack(1)
#line 1095
#pragma pack(0)
#line 1241
#pragma pack(1)
#line 1250
#pragma pack(0)
#line 56 "../include/ipmitool/ipmi_mc.h"
#pragma pack(1)
#line 70
#pragma pack(0)
#line 93
#pragma pack(1)
#line 100
#pragma pack(0)
#line 119
#pragma pack(1)
#line 132
#pragma pack(0)
#line 37 "../include/ipmitool/ipmi_entity.h"
#pragma pack(1)
#line 50
#pragma pack(0)
#line 109 "../include/ipmitool/ipmi_sdr.h"
#pragma pack(1)
#line 120
#pragma pack(0)
#line 124
#pragma pack(1)
#line 133
#pragma pack(0)
#line 137
#pragma pack(1)
#line 144
#pragma pack(0)
#line 149
#pragma pack(1)
#line 160
#pragma pack(0)
#line 164
#pragma pack(1)
#line 185
#pragma pack(0)
#line 189
#pragma pack(1)
#line 319
#pragma pack(0)
#line 323
#pragma pack(1)
#line 410
#pragma pack(0)
#line 414
#pragma pack(1)
#line 450
#pragma pack(0)
#line 454
#pragma pack(1)
#line 502
#pragma pack(0)
#line 506
#pragma pack(1)
#line 571
#pragma pack(0)
#line 575
#pragma pack(1)
#line 603
#pragma pack(0)
#line 636
#pragma pack(0)
#line 640
#pragma pack(1)
#line 670
#pragma pack(0)
#line 674
#pragma pack(1)
#line 701
#pragma pack(0)
#line 714
#pragma pack(1)
#line 742
#pragma pack(0)
#line 753
#pragma pack(1)
#line 775
#pragma pack(0)
#line 69 "../include/ipmitool/ipmi_sensor.h"
#pragma pack(1)
#line 82
#pragma pack(0)
#line 129 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
struct __anonstruct_identify_data_53___0 {
   uint8_t interval ;
   uint8_t force_on ;
};
#line 1092 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
struct __anonstruct_options_54___0 {
   char *name ;
   int i ;
   unsigned char mask ;
   unsigned char value ;
   char *desc ;
};
#line 37 "../include/ipmitool/ipmi_entity.h"
#pragma pack(1)
#line 50
#pragma pack(0)
#line 109 "../include/ipmitool/ipmi_sdr.h"
#pragma pack(1)
#line 120
#pragma pack(0)
#line 124
#pragma pack(1)
#line 133
#pragma pack(0)
#line 137
#pragma pack(1)
#line 144
#pragma pack(0)
#line 149
#pragma pack(1)
#line 160
#pragma pack(0)
#line 164
#pragma pack(1)
#line 185
#pragma pack(0)
#line 189
#pragma pack(1)
#line 319
#pragma pack(0)
#line 323
#pragma pack(1)
#line 410
#pragma pack(0)
#line 414
#pragma pack(1)
#line 450
#pragma pack(0)
#line 454
#pragma pack(1)
#line 502
#pragma pack(0)
#line 506
#pragma pack(1)
#line 571
#pragma pack(0)
#line 575
#pragma pack(1)
#line 603
#pragma pack(0)
#line 636
#pragma pack(0)
#line 640
#pragma pack(1)
#line 670
#pragma pack(0)
#line 674
#pragma pack(1)
#line 701
#pragma pack(0)
#line 714
#pragma pack(1)
#line 742
#pragma pack(0)
#line 753
#pragma pack(1)
#line 775
#pragma pack(0)
#line 69 "../include/ipmitool/ipmi_fru.h"
#pragma pack(1)
#line 84
#pragma pack(0)
#line 121
#pragma pack(1)
#line 138
#pragma pack(0)
#line 142
#pragma pack(1)
#line 188
#pragma pack(0)
#line 195
#pragma pack(1)
#line 215
#pragma pack(0)
#line 219
#pragma pack(1)
#line 237
#pragma pack(0)
#line 241
#pragma pack(1)
#line 274
#pragma pack(0)
#line 278
#pragma pack(1)
#line 284
#pragma pack(0)
#line 288
#pragma pack(1)
#line 318
#pragma pack(0)
#line 332
#pragma pack(1)
#line 339
#pragma pack(0)
#line 343
#pragma pack(1)
#line 359
#pragma pack(0)
#line 363
#pragma pack(1)
#line 375
#pragma pack(0)
#line 380
#pragma pack(1)
#line 392
#pragma pack(0)
#line 402
#pragma pack(1)
#line 418
#pragma pack(0)
#line 422
#pragma pack(1)
#line 430
#pragma pack(0)
#line 439
#pragma pack(1)
#line 447
#pragma pack(0)
#line 451
#pragma pack(1)
#line 459
#pragma pack(0)
#line 463
#pragma pack(1)
#line 470
#pragma pack(0)
#line 474
#pragma pack(1)
#line 490
#pragma pack(0)
#line 494
#pragma pack(1)
#line 508
#pragma pack(0)
#line 513
#pragma pack(1)
#line 531
#pragma pack(0)
#line 536
#pragma pack(1)
#line 583
#pragma pack(0)
#line 56 "../include/ipmitool/ipmi_mc.h"
#pragma pack(1)
#line 70
#pragma pack(0)
#line 93
#pragma pack(1)
#line 100
#pragma pack(0)
#line 119
#pragma pack(1)
#line 132
#pragma pack(0)
#line 132 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
#pragma pack(1)
#line 144
#pragma pack(0)
#line 148
#pragma pack(1)
#line 155
#pragma pack(0)
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 37 "../include/ipmitool/ipmi_entity.h"
#pragma pack(1)
#line 50
#pragma pack(0)
#line 109 "../include/ipmitool/ipmi_sdr.h"
#pragma pack(1)
#line 120
#pragma pack(0)
#line 124
#pragma pack(1)
#line 133
#pragma pack(0)
#line 137
#pragma pack(1)
#line 144
#pragma pack(0)
#line 149
#pragma pack(1)
#line 160
#pragma pack(0)
#line 164
#pragma pack(1)
#line 185
#pragma pack(0)
#line 189
#pragma pack(1)
#line 319
#pragma pack(0)
#line 323
#pragma pack(1)
#line 410
#pragma pack(0)
#line 414
#pragma pack(1)
#line 450
#pragma pack(0)
#line 454
#pragma pack(1)
#line 502
#pragma pack(0)
#line 506
#pragma pack(1)
#line 571
#pragma pack(0)
#line 575
#pragma pack(1)
#line 603
#pragma pack(0)
#line 636
#pragma pack(0)
#line 640
#pragma pack(1)
#line 670
#pragma pack(0)
#line 674
#pragma pack(1)
#line 701
#pragma pack(0)
#line 714
#pragma pack(1)
#line 742
#pragma pack(0)
#line 753
#pragma pack(1)
#line 775
#pragma pack(0)
#line 69 "../include/ipmitool/ipmi_fru.h"
#pragma pack(1)
#line 84
#pragma pack(0)
#line 121
#pragma pack(1)
#line 138
#pragma pack(0)
#line 142
#pragma pack(1)
#line 188
#pragma pack(0)
#line 195
#pragma pack(1)
#line 215
#pragma pack(0)
#line 219
#pragma pack(1)
#line 237
#pragma pack(0)
#line 241
#pragma pack(1)
#line 274
#pragma pack(0)
#line 278
#pragma pack(1)
#line 284
#pragma pack(0)
#line 288
#pragma pack(1)
#line 318
#pragma pack(0)
#line 332
#pragma pack(1)
#line 339
#pragma pack(0)
#line 343
#pragma pack(1)
#line 359
#pragma pack(0)
#line 363
#pragma pack(1)
#line 375
#pragma pack(0)
#line 380
#pragma pack(1)
#line 392
#pragma pack(0)
#line 402
#pragma pack(1)
#line 418
#pragma pack(0)
#line 422
#pragma pack(1)
#line 430
#pragma pack(0)
#line 439
#pragma pack(1)
#line 447
#pragma pack(0)
#line 451
#pragma pack(1)
#line 459
#pragma pack(0)
#line 463
#pragma pack(1)
#line 470
#pragma pack(0)
#line 474
#pragma pack(1)
#line 490
#pragma pack(0)
#line 494
#pragma pack(1)
#line 508
#pragma pack(0)
#line 513
#pragma pack(1)
#line 531
#pragma pack(0)
#line 536
#pragma pack(1)
#line 583
#pragma pack(0)
#line 56 "../include/ipmitool/ipmi_mc.h"
#pragma pack(1)
#line 70
#pragma pack(0)
#line 93
#pragma pack(1)
#line 100
#pragma pack(0)
#line 119
#pragma pack(1)
#line 132
#pragma pack(0)
#line 103 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
union __anonunion_u_82___0 {
   uint32_t bits ;
   char chars[4] ;
};
#line 1635
#pragma pack(1)
#line 1648
#pragma pack(0)
#line 1653
#pragma pack(1)
#line 1666
#pragma pack(0)
#line 37 "../include/ipmitool/ipmi_entity.h"
#pragma pack(1)
#line 50
#pragma pack(0)
#line 109 "../include/ipmitool/ipmi_sdr.h"
#pragma pack(1)
#line 120
#pragma pack(0)
#line 124
#pragma pack(1)
#line 133
#pragma pack(0)
#line 137
#pragma pack(1)
#line 144
#pragma pack(0)
#line 149
#pragma pack(1)
#line 160
#pragma pack(0)
#line 164
#pragma pack(1)
#line 185
#pragma pack(0)
#line 189
#pragma pack(1)
#line 319
#pragma pack(0)
#line 323
#pragma pack(1)
#line 410
#pragma pack(0)
#line 414
#pragma pack(1)
#line 450
#pragma pack(0)
#line 454
#pragma pack(1)
#line 502
#pragma pack(0)
#line 506
#pragma pack(1)
#line 571
#pragma pack(0)
#line 575
#pragma pack(1)
#line 603
#pragma pack(0)
#line 636
#pragma pack(0)
#line 640
#pragma pack(1)
#line 670
#pragma pack(0)
#line 674
#pragma pack(1)
#line 701
#pragma pack(0)
#line 714
#pragma pack(1)
#line 742
#pragma pack(0)
#line 753
#pragma pack(1)
#line 775
#pragma pack(0)
#line 61 "../include/ipmitool/ipmi_sel.h"
#pragma pack(1)
#line 70
#pragma pack(0)
#line 124
#pragma pack(1)
#line 136
#pragma pack(0)
#line 36 "../include/ipmitool/ipmi_delloem.h"
#pragma pack(1)
#line 69 "../include/ipmitool/ipmi_fru.h"
#pragma pack(1)
#line 84
#pragma pack(0)
#line 121
#pragma pack(1)
#line 138
#pragma pack(0)
#line 142
#pragma pack(1)
#line 188
#pragma pack(0)
#line 195
#pragma pack(1)
#line 215
#pragma pack(0)
#line 219
#pragma pack(1)
#line 237
#pragma pack(0)
#line 241
#pragma pack(1)
#line 274
#pragma pack(0)
#line 278
#pragma pack(1)
#line 284
#pragma pack(0)
#line 288
#pragma pack(1)
#line 318
#pragma pack(0)
#line 332
#pragma pack(1)
#line 339
#pragma pack(0)
#line 343
#pragma pack(1)
#line 359
#pragma pack(0)
#line 363
#pragma pack(1)
#line 375
#pragma pack(0)
#line 380
#pragma pack(1)
#line 392
#pragma pack(0)
#line 402
#pragma pack(1)
#line 418
#pragma pack(0)
#line 422
#pragma pack(1)
#line 430
#pragma pack(0)
#line 439
#pragma pack(1)
#line 447
#pragma pack(0)
#line 451
#pragma pack(1)
#line 459
#pragma pack(0)
#line 463
#pragma pack(1)
#line 470
#pragma pack(0)
#line 474
#pragma pack(1)
#line 490
#pragma pack(0)
#line 494
#pragma pack(1)
#line 508
#pragma pack(0)
#line 513
#pragma pack(1)
#line 531
#pragma pack(0)
#line 536
#pragma pack(1)
#line 583
#pragma pack(0)
#line 56 "../include/ipmitool/ipmi_mc.h"
#pragma pack(1)
#line 70
#pragma pack(0)
#line 93
#pragma pack(1)
#line 100
#pragma pack(0)
#line 119
#pragma pack(1)
#line 132
#pragma pack(0)
#line 69 "../include/ipmitool/ipmi_sensor.h"
#pragma pack(1)
#line 82
#pragma pack(0)
#line 58 "../include/ipmitool/ipmi_channel.h"
#pragma pack(1)
#line 101
#pragma pack(0)
#line 111
#pragma pack(1)
#line 146
#pragma pack(0)
#line 156
#pragma pack(1)
#line 181
#pragma pack(0)
#line 185
#pragma pack(1)
#line 215
#pragma pack(0)
#line 219
#pragma pack(1)
#line 249
#pragma pack(0)
#line 56 "../include/ipmitool/ipmi_mc.h"
#pragma pack(1)
#line 70
#pragma pack(0)
#line 93
#pragma pack(1)
#line 100
#pragma pack(0)
#line 119
#pragma pack(1)
#line 132
#pragma pack(0)
#line 37 "../include/ipmitool/ipmi_entity.h"
#pragma pack(1)
#line 50
#pragma pack(0)
#line 109 "../include/ipmitool/ipmi_sdr.h"
#pragma pack(1)
#line 120
#pragma pack(0)
#line 124
#pragma pack(1)
#line 133
#pragma pack(0)
#line 137
#pragma pack(1)
#line 144
#pragma pack(0)
#line 149
#pragma pack(1)
#line 160
#pragma pack(0)
#line 164
#pragma pack(1)
#line 185
#pragma pack(0)
#line 189
#pragma pack(1)
#line 319
#pragma pack(0)
#line 323
#pragma pack(1)
#line 410
#pragma pack(0)
#line 414
#pragma pack(1)
#line 450
#pragma pack(0)
#line 454
#pragma pack(1)
#line 502
#pragma pack(0)
#line 506
#pragma pack(1)
#line 571
#pragma pack(0)
#line 575
#pragma pack(1)
#line 603
#pragma pack(0)
#line 636
#pragma pack(0)
#line 640
#pragma pack(1)
#line 670
#pragma pack(0)
#line 674
#pragma pack(1)
#line 701
#pragma pack(0)
#line 714
#pragma pack(1)
#line 742
#pragma pack(0)
#line 753
#pragma pack(1)
#line 775
#pragma pack(0)
#line 61 "../include/ipmitool/ipmi_sel.h"
#pragma pack(1)
#line 70
#pragma pack(0)
#line 124
#pragma pack(1)
#line 136
#pragma pack(0)
#line 37 "../include/ipmitool/ipmi_entity.h"
#pragma pack(1)
#line 50
#pragma pack(0)
#line 109 "../include/ipmitool/ipmi_sdr.h"
#pragma pack(1)
#line 120
#pragma pack(0)
#line 124
#pragma pack(1)
#line 133
#pragma pack(0)
#line 137
#pragma pack(1)
#line 144
#pragma pack(0)
#line 149
#pragma pack(1)
#line 160
#pragma pack(0)
#line 164
#pragma pack(1)
#line 185
#pragma pack(0)
#line 189
#pragma pack(1)
#line 319
#pragma pack(0)
#line 323
#pragma pack(1)
#line 410
#pragma pack(0)
#line 414
#pragma pack(1)
#line 450
#pragma pack(0)
#line 454
#pragma pack(1)
#line 502
#pragma pack(0)
#line 506
#pragma pack(1)
#line 571
#pragma pack(0)
#line 575
#pragma pack(1)
#line 603
#pragma pack(0)
#line 636
#pragma pack(0)
#line 640
#pragma pack(1)
#line 670
#pragma pack(0)
#line 674
#pragma pack(1)
#line 701
#pragma pack(0)
#line 714
#pragma pack(1)
#line 742
#pragma pack(0)
#line 753
#pragma pack(1)
#line 775
#pragma pack(0)
#line 61 "../include/ipmitool/ipmi_sel.h"
#pragma pack(1)
#line 70
#pragma pack(0)
#line 124
#pragma pack(1)
#line 136
#pragma pack(0)
#line 58 "../include/ipmitool/ipmi_channel.h"
#pragma pack(1)
#line 101
#pragma pack(0)
#line 111
#pragma pack(1)
#line 146
#pragma pack(0)
#line 156
#pragma pack(1)
#line 181
#pragma pack(0)
#line 185
#pragma pack(1)
#line 215
#pragma pack(0)
#line 219
#pragma pack(1)
#line 249
#pragma pack(0)
#line 45 "../include/ipmitool/ipmi_event.h"
#pragma pack(1)
#line 61
#pragma pack(0)
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_31 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_32 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_33 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_34 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_35 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_36 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_37 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_30 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_31 _kill ;
   struct __anonstruct__timer_32 _timer ;
   struct __anonstruct__rt_33 _rt ;
   struct __anonstruct__sigchld_34 _sigchld ;
   struct __anonstruct__sigfault_35 _sigfault ;
   struct __anonstruct__sigpoll_36 _sigpoll ;
   struct __anonstruct__sigsys_37 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_29 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_30 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_29 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_49 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_49 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 70 "/usr/include/linux/ipmi.h"
struct ipmi_addr {
   int addr_type ;
   short channel ;
   char data[32] ;
};
#line 153 "/usr/include/linux/ipmi.h"
struct ipmi_msg {
   unsigned char netfn ;
   unsigned char cmd ;
   unsigned short data_len ;
   unsigned char *data ;
};
#line 298 "/usr/include/linux/ipmi.h"
struct ipmi_recv {
   int recv_type ;
   unsigned char *addr ;
   unsigned int addr_len ;
   long msgid ;
   struct ipmi_msg msg ;
};
#line 37 "../include/ipmitool/ipmi_entity.h"
#pragma pack(1)
#line 50
#pragma pack(0)
#line 109 "../include/ipmitool/ipmi_sdr.h"
#pragma pack(1)
#line 120
#pragma pack(0)
#line 124
#pragma pack(1)
#line 133
#pragma pack(0)
#line 137
#pragma pack(1)
#line 144
#pragma pack(0)
#line 149
#pragma pack(1)
#line 160
#pragma pack(0)
#line 164
#pragma pack(1)
#line 185
#pragma pack(0)
#line 189
#pragma pack(1)
#line 319
#pragma pack(0)
#line 323
#pragma pack(1)
#line 410
#pragma pack(0)
#line 414
#pragma pack(1)
#line 450
#pragma pack(0)
#line 454
#pragma pack(1)
#line 502
#pragma pack(0)
#line 506
#pragma pack(1)
#line 571
#pragma pack(0)
#line 575
#pragma pack(1)
#line 603
#pragma pack(0)
#line 636
#pragma pack(0)
#line 640
#pragma pack(1)
#line 670
#pragma pack(0)
#line 674
#pragma pack(1)
#line 701
#pragma pack(0)
#line 714
#pragma pack(1)
#line 742
#pragma pack(0)
#line 753
#pragma pack(1)
#line 775
#pragma pack(0)
#line 61 "../include/ipmitool/ipmi_sel.h"
#pragma pack(1)
#line 70
#pragma pack(0)
#line 124
#pragma pack(1)
#line 136
#pragma pack(0)
#line 98 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
struct ipmi_event_intf {
   char name[16] ;
   char desc[128] ;
   char prefix[72] ;
   int (*setup)(struct ipmi_event_intf *eintf ) ;
   int (*wait)(struct ipmi_event_intf *eintf ) ;
   int (*read)(struct ipmi_event_intf *eintf ) ;
   int (*check)(struct ipmi_event_intf *eintf ) ;
   void (*log)(struct ipmi_event_intf *eintf , struct sel_event_record *evt ) ;
   struct ipmi_intf *intf ;
};
#line 111 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
struct sel_data {
   uint16_t entries ;
   int pctused ;
   int overflow ;
};
#line 37 "../include/ipmitool/ipmi_entity.h"
#pragma pack(1)
#line 50
#pragma pack(0)
#line 109 "../include/ipmitool/ipmi_sdr.h"
#pragma pack(1)
#line 120
#pragma pack(0)
#line 124
#pragma pack(1)
#line 133
#pragma pack(0)
#line 137
#pragma pack(1)
#line 144
#pragma pack(0)
#line 149
#pragma pack(1)
#line 160
#pragma pack(0)
#line 164
#pragma pack(1)
#line 185
#pragma pack(0)
#line 189
#pragma pack(1)
#line 319
#pragma pack(0)
#line 323
#pragma pack(1)
#line 410
#pragma pack(0)
#line 414
#pragma pack(1)
#line 450
#pragma pack(0)
#line 454
#pragma pack(1)
#line 502
#pragma pack(0)
#line 506
#pragma pack(1)
#line 571
#pragma pack(0)
#line 575
#pragma pack(1)
#line 603
#pragma pack(0)
#line 636
#pragma pack(0)
#line 640
#pragma pack(1)
#line 670
#pragma pack(0)
#line 674
#pragma pack(1)
#line 701
#pragma pack(0)
#line 714
#pragma pack(1)
#line 742
#pragma pack(0)
#line 753
#pragma pack(1)
#line 775
#pragma pack(0)
#line 69 "../include/ipmitool/ipmi_fru.h"
#pragma pack(1)
#line 84
#pragma pack(0)
#line 121
#pragma pack(1)
#line 138
#pragma pack(0)
#line 142
#pragma pack(1)
#line 188
#pragma pack(0)
#line 195
#pragma pack(1)
#line 215
#pragma pack(0)
#line 219
#pragma pack(1)
#line 237
#pragma pack(0)
#line 241
#pragma pack(1)
#line 274
#pragma pack(0)
#line 278
#pragma pack(1)
#line 284
#pragma pack(0)
#line 288
#pragma pack(1)
#line 318
#pragma pack(0)
#line 332
#pragma pack(1)
#line 339
#pragma pack(0)
#line 343
#pragma pack(1)
#line 359
#pragma pack(0)
#line 363
#pragma pack(1)
#line 375
#pragma pack(0)
#line 380
#pragma pack(1)
#line 392
#pragma pack(0)
#line 402
#pragma pack(1)
#line 418
#pragma pack(0)
#line 422
#pragma pack(1)
#line 430
#pragma pack(0)
#line 439
#pragma pack(1)
#line 447
#pragma pack(0)
#line 451
#pragma pack(1)
#line 459
#pragma pack(0)
#line 463
#pragma pack(1)
#line 470
#pragma pack(0)
#line 474
#pragma pack(1)
#line 490
#pragma pack(0)
#line 494
#pragma pack(1)
#line 508
#pragma pack(0)
#line 513
#pragma pack(1)
#line 531
#pragma pack(0)
#line 536
#pragma pack(1)
#line 583
#pragma pack(0)
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 73 "../include/ipmitool/helper.h"
char const   *val2str(uint16_t val , struct valstr  const  *vs ) ;
#line 74
char const   *oemval2str(uint32_t oem , uint16_t val , struct oemvalstr  const  *vs ) ;
#line 95
uint16_t buf2short(uint8_t *buf ) ;
#line 287 "../include/ipmitool/ipmi.h"
extern struct valstr  const  completion_code_vals[] ;
#line 43 "../include/ipmitool/ipmi_ime.h"
int ipmi_ime_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 59 "../include/ipmitool/log.h"
extern void lprintf(int level , char const   *format  , ...) ;
#line 54 "../include/ipmitool/ipmi_strings.h"
extern struct valstr  const  ipmi_oem_info[] ;
#line 70
extern struct oemvalstr  const  ipmi_oem_product_info[] ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 96 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int const   IME_SUCCESS  =    (int const   )0;
#line 97 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int const   IME_ERROR  =    (int const   )-1;
#line 98 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int const   IME_RESTART  =    (int const   )-2;
#line 159
static void ImePrintUsage(void) ;
#line 160
static int ImeGetInfo(struct ipmi_intf *intf ) ;
#line 161
static int ImeUpgrade(struct ipmi_intf *intf , char *imageFilename ) ;
#line 162
static int ImeManualRollback(struct ipmi_intf *intf ) ;
#line 163
static int ImeUpdatePrepare(struct ipmi_intf *intf ) ;
#line 164
static int ImeUpdateOpenArea(struct ipmi_intf *intf ) ;
#line 165
static int ImeUpdateWriteArea(struct ipmi_intf *intf , uint8_t sequence , uint8_t length ,
                              uint8_t *pBuf ) ;
#line 171
static int ImeUpdateCloseArea(struct ipmi_intf *intf , uint32_t size , uint16_t checksum ) ;
#line 177
static int ImeUpdateGetStatus(struct ipmi_intf *intf , tImeStatus *pStatus ) ;
#line 178
static int ImeUpdateGetCapabilities(struct ipmi_intf *intf , tImeCaps *pCaps ) ;
#line 179
static int ImeUpdateRegisterUpdate(struct ipmi_intf *intf , tImeUpdateType type ) ;
#line 181
static int ImeImageCtxFromFile(char *imageFilename , tImeUpdateImageCtx *pImageCtx ) ;
#line 186
static uint8_t ImeCrc8(uint32_t length , uint8_t *pBuf ) ;
#line 189 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int ImeGetInfo(struct ipmi_intf *intf ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct ipm_devid_rsp *devid ;
  char const   *product ;
  tImeStatus status ;
  tImeCaps caps ;
  char const   *tmp ;
  char const   *tmp___0 ;
  uint16_t tmp___1 ;
  uint8_t newImage ;
  uint8_t rollImage ;
  uint8_t runArea ;
  uint8_t rollSup ;
  uint8_t recovSup ;
  uint8_t operSup ;
  uint8_t piaSup ;
  uint8_t sdrSup ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 191
  rc = (int )IME_ERROR;
#line 195
  product = (char const   *)((void *)0);
#line 199
  memset((void *)(& req), 0, sizeof(req));
#line 200
  req.msg.netfn = (uint8_t )6;
#line 201
  req.msg.cmd = (uint8_t )1;
#line 202
  req.msg.data_len = (uint16_t )0;
#line 204
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 205
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 206
    lprintf(3, "Get Device ID command failed");
    }
#line 207
    return ((int )IME_ERROR);
  }
#line 209
  if ((int )rsp->ccode > 0) {
    {
#line 210
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 210
    lprintf(3, "Get Device ID command failed: %s", tmp);
    }
#line 212
    return ((int )IME_ERROR);
  }
  {
#line 215
  devid = (struct ipm_devid_rsp *)(rsp->data);
#line 217
  lprintf(7, "Device ID                 : %i", (int )devid->device_id);
#line 218
  lprintf(7, "Device Revision           : %i", (int )devid->device_revision & 15);
  }
#line 221
  if ((int )devid->device_id == 0) {
#line 221
    if (((int )devid->device_revision & 15) == 0) {
#line 221
      if ((int )devid->manufacturer_id[0] == 87) {
#line 221
        if ((int )devid->manufacturer_id[1] == 1) {
#line 221
          if ((int )devid->manufacturer_id[2] == 0) {
#line 221
            if ((int )devid->product_id[1] == 11) {
#line 221
              if ((int )devid->product_id[0] == 0) {
                {
#line 241
                rc = (int )IME_SUCCESS;
#line 242
                tmp___0 = val2str((uint16_t )((long )((uint32_t )(((((int )devid->manufacturer_id[2] & 15) << 16) | ((int )devid->manufacturer_id[1] << 8)) | (int )devid->manufacturer_id[0]))),
                                  ipmi_oem_info);
#line 242
                printf((char const   */* __restrict  */)"Manufacturer Name          : %s\n",
                       tmp___0);
#line 246
                tmp___1 = buf2short(devid->product_id);
#line 246
                printf((char const   */* __restrict  */)"Product ID                 : %u (0x%02x%02x)\n",
                       (int )tmp___1, (int )devid->product_id[1], (int )devid->product_id[0]);
#line 250
                product = oemval2str((uint32_t )(((((int )devid->manufacturer_id[2] & 15) << 16) | ((int )devid->manufacturer_id[1] << 8)) | (int )devid->manufacturer_id[0]),
                                     (uint16_t )(((int )devid->product_id[1] << 8) + (int )devid->product_id[0]),
                                     ipmi_oem_product_info);
                }
#line 254
                if ((unsigned long )product != (unsigned long )((void *)0)) {
                  {
#line 256
                  printf((char const   */* __restrict  */)"Product Name               : %s\n",
                         product);
                  }
                }
                {
#line 259
                printf((char const   */* __restrict  */)"Intel ME Firmware Revision : %x.%02x.%02x.%x%x%x.%x\n",
                       (int )devid->fw_rev1 & 63, (int )devid->fw_rev2 >> 4, (int )devid->fw_rev2 & 15,
                       (int )devid->aux_fw_rev[1] >> 4, (int )devid->aux_fw_rev[1] & 15,
                       (int )devid->aux_fw_rev[2] >> 4, (int )devid->aux_fw_rev[2] & 15);
#line 269
                printf((char const   */* __restrict  */)"SPS FW IPMI cmd version    : %x.%x\n",
                       (int )devid->aux_fw_rev[0] >> 4, (int )devid->aux_fw_rev[0] & 15);
#line 273
                lprintf(7, "Flags: %xh", (int )devid->aux_fw_rev[3]);
#line 275
                printf((char const   */* __restrict  */)"Current Image Type         : ");
                }
                {
#line 278
                if (((int )devid->aux_fw_rev[3] & 3) == 0) {
#line 278
                  goto case_0;
                }
#line 282
                if (((int )devid->aux_fw_rev[3] & 3) == 1) {
#line 282
                  goto case_1;
                }
#line 286
                if (((int )devid->aux_fw_rev[3] & 3) == 2) {
#line 286
                  goto case_2;
                }
#line 291
                goto switch_default;
                case_0: /* CIL Label */ 
                {
#line 279
                printf((char const   */* __restrict  */)"Recovery\n");
                }
#line 280
                goto switch_break;
                case_1: /* CIL Label */ 
                {
#line 283
                printf((char const   */* __restrict  */)"Operational Image 1\n");
                }
#line 284
                goto switch_break;
                case_2: /* CIL Label */ 
                {
#line 287
                printf((char const   */* __restrict  */)"Operational Image 2\n");
                }
#line 288
                goto switch_break;
                switch_default: /* CIL Label */ 
                {
#line 292
                printf((char const   */* __restrict  */)"Unknown\n");
                }
#line 293
                goto switch_break;
                switch_break: /* CIL Label */ ;
                }
              } else {
                {
#line 298
                printf((char const   */* __restrict  */)"Supported ME not found\n");
                }
              }
            } else {
              {
#line 298
              printf((char const   */* __restrict  */)"Supported ME not found\n");
              }
            }
          } else {
            {
#line 298
            printf((char const   */* __restrict  */)"Supported ME not found\n");
            }
          }
        } else {
          {
#line 298
          printf((char const   */* __restrict  */)"Supported ME not found\n");
          }
        }
      } else {
        {
#line 298
        printf((char const   */* __restrict  */)"Supported ME not found\n");
        }
      }
    } else {
      {
#line 298
      printf((char const   */* __restrict  */)"Supported ME not found\n");
      }
    }
  } else {
    {
#line 298
    printf((char const   */* __restrict  */)"Supported ME not found\n");
    }
  }
#line 301
  if (rc == (int )IME_SUCCESS) {
    {
#line 303
    rc = ImeUpdateGetStatus(intf, & status);
    }
#line 305
    if (rc == (int )IME_SUCCESS) {
      {
#line 307
      rc = ImeUpdateGetCapabilities(intf, & caps);
      }
    }
  }
#line 312
  if (rc == (int )IME_SUCCESS) {
    {
#line 314
    newImage = (uint8_t )(((int )status.image_status >> 1) & 1);
#line 315
    rollImage = (uint8_t )(((int )status.image_status >> 2) & 1);
#line 316
    runArea = (uint8_t )(((int )status.image_status >> 3) & 3);
#line 317
    rollSup = (uint8_t )((int )caps.special_caps & 1);
#line 318
    recovSup = (uint8_t )(((int )caps.special_caps >> 1) & 1);
#line 320
    operSup = (uint8_t )(((int )caps.area_supported >> 1) & 1);
#line 321
    piaSup = (uint8_t )(((int )caps.area_supported >> 2) & 1);
#line 322
    sdrSup = (uint8_t )(((int )caps.area_supported >> 3) & 1);
#line 324
    printf((char const   */* __restrict  */)"\nSupported Area\n");
    }
#line 325
    if (operSup) {
#line 325
      tmp___2 = "Supported";
    } else {
#line 325
      tmp___2 = "Unsupported";
    }
    {
#line 325
    printf((char const   */* __restrict  */)"   Operation Code          : %s\n", tmp___2);
    }
#line 326
    if (piaSup) {
#line 326
      tmp___3 = "Supported";
    } else {
#line 326
      tmp___3 = "Unsupported";
    }
    {
#line 326
    printf((char const   */* __restrict  */)"   PIA                     : %s\n", tmp___3);
    }
#line 327
    if (sdrSup) {
#line 327
      tmp___4 = "Supported";
    } else {
#line 327
      tmp___4 = "Unsupported";
    }
    {
#line 327
    printf((char const   */* __restrict  */)"   SDR                     : %s\n", tmp___4);
#line 329
    printf((char const   */* __restrict  */)"\nSpecial Capabilities\n");
    }
#line 330
    if (rollSup) {
#line 330
      tmp___5 = "Supported";
    } else {
#line 330
      tmp___5 = "Unsupported";
    }
    {
#line 330
    printf((char const   */* __restrict  */)"   Rollback                : %s\n", tmp___5);
    }
#line 331
    if (recovSup) {
#line 331
      tmp___6 = "Supported";
    } else {
#line 331
      tmp___6 = "Unsupported";
    }
    {
#line 331
    printf((char const   */* __restrict  */)"   Recovery                : %s\n", tmp___6);
#line 333
    printf((char const   */* __restrict  */)"\nImage Status\n");
    }
#line 334
    if (newImage) {
#line 334
      tmp___7 = "Valid";
    } else {
#line 334
      tmp___7 = "Invalid";
    }
    {
#line 334
    printf((char const   */* __restrict  */)"   Staging (new)           : %s\n", tmp___7);
    }
#line 335
    if (rollImage) {
#line 335
      tmp___8 = "Valid";
    } else {
#line 335
      tmp___8 = "Invalid";
    }
    {
#line 335
    printf((char const   */* __restrict  */)"   Rollback                : %s\n", tmp___8);
    }
#line 336
    if ((int )runArea == 0) {
      {
#line 337
      printf((char const   */* __restrict  */)"   Running Image Area      : CODE\n");
      }
    } else {
      {
#line 339
      printf((char const   */* __restrict  */)"   Running Image Area      : CODE%d\n",
             (int )runArea);
      }
    }
  }
#line 343
  return (rc);
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int ImeUpgrade(struct ipmi_intf *intf , char *imageFilename ) 
{ 
  int rc ;
  tImeUpdateImageCtx imgCtx ;
  tImeStatus imeStatus ;
  time_t start ;
  time_t end ;
  time_t current ;
  uint8_t sequence ;
  uint32_t counter ;
  uint8_t retry ;
  uint8_t shownPercent ;
  uint8_t length ;
  uint8_t currentPercent ;
  uint16_t timeElapsedSecond ;

  {
  {
#line 349
  rc = (int )IME_SUCCESS;
#line 354
  time(& start);
#line 356
  memset((void *)(& imgCtx), 0, sizeof(tImeUpdateImageCtx ));
#line 358
  rc = ImeImageCtxFromFile(imageFilename, & imgCtx);
  }
#line 360
  if (rc == (int )IME_ERROR) {
#line 366
    return ((int )IME_ERROR);
  } else
#line 360
  if ((unsigned long )imgCtx.pData == (unsigned long )((void *)0)) {
#line 366
    return ((int )IME_ERROR);
  } else
#line 360
  if (imgCtx.size == 0U) {
#line 366
    return ((int )IME_ERROR);
  }
  {
#line 369
  ImeUpdateGetStatus(intf, & imeStatus);
  }
#line 371
  if (rc == (int )IME_SUCCESS) {
    {
#line 373
    rc = ImeUpdatePrepare(intf);
#line 374
    ImeUpdateGetStatus(intf, & imeStatus);
    }
  }
#line 377
  if (rc == (int )IME_SUCCESS) {
#line 377
    if ((unsigned int )imeStatus.update_state == 1U) {
      {
#line 382
      rc = ImeUpdateOpenArea(intf);
#line 383
      ImeUpdateGetStatus(intf, & imeStatus);
      }
    } else {
#line 377
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 385
  if (rc == (int )IME_SUCCESS) {
    {
#line 387
    lprintf(3, "ME state error (%i), aborting", (unsigned int )imeStatus.update_state);
#line 388
    rc = (int )IME_ERROR;
    }
  }
#line 392
  if (rc == (int )IME_SUCCESS) {
#line 392
    if ((unsigned int )imeStatus.update_state == 2U) {
#line 397
      sequence = (uint8_t )0;
#line 398
      counter = (uint32_t )0;
#line 399
      retry = (uint8_t )0;
#line 400
      shownPercent = (uint8_t )255;
      {
#line 402
      while (1) {
        while_continue: /* CIL Label */ ;
#line 402
        if (counter < imgCtx.size) {
#line 402
          if (rc == (int )IME_SUCCESS) {
#line 402
            if (! ((int )retry < 5)) {
#line 402
              goto while_break;
            }
          } else {
#line 402
            goto while_break;
          }
        } else {
#line 402
          goto while_break;
        }
#line 408
        length = (uint8_t )22;
#line 411
        if (imgCtx.size - counter < 22U) {
#line 413
          length = (uint8_t )(imgCtx.size - counter);
        }
        {
#line 416
        rc = ImeUpdateWriteArea(intf, sequence, length, imgCtx.pData + counter);
#line 425
        counter += (uint32_t )length;
#line 426
        sequence = (uint8_t )((int )sequence + 1);
#line 429
        currentPercent = (uint8_t )(((float )counter / (float )imgCtx.size) * (float )100);
        }
#line 431
        if ((int )currentPercent != (int )shownPercent) {
          {
#line 435
          shownPercent = currentPercent;
#line 436
          printf((char const   */* __restrict  */)"Percent: %02i,  ", (int )shownPercent);
#line 437
          time(& current);
#line 438
          timeElapsedSecond = (uint16_t )((current - start) + (current - start) % 60L);
#line 439
          printf((char const   */* __restrict  */)"Elapsed time %02ld:%02ld\r", (current - start) / 60L,
                 (current - start) % 60L);
#line 440
          fflush(stdout);
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 444
      ImeUpdateGetStatus(intf, & imeStatus);
#line 445
      printf((char const   */* __restrict  */)"\n");
      }
    } else {
#line 392
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 447
  if (rc == (int )IME_SUCCESS) {
    {
#line 449
    lprintf(3, "ME state error (%i), aborting", (unsigned int )imeStatus.update_state);
#line 450
    rc = (int )IME_ERROR;
    }
  }
#line 453
  if (rc == (int )IME_SUCCESS) {
#line 453
    if ((unsigned int )imeStatus.update_state == 2U) {
      {
#line 458
      rc = ImeUpdateCloseArea(intf, imgCtx.size, (uint16_t )imgCtx.crc8);
#line 459
      ImeUpdateGetStatus(intf, & imeStatus);
      }
    } else {
#line 453
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 461
  if (rc == (int )IME_SUCCESS) {
    {
#line 463
    lprintf(3, "ME state error, aborting");
#line 464
    rc = (int )IME_ERROR;
    }
  }
#line 467
  if (rc == (int )IME_SUCCESS) {
#line 467
    if ((unsigned int )imeStatus.update_state == 1U) {
      {
#line 472
      printf((char const   */* __restrict  */)"UpdateCompleted, Activate now\n");
#line 473
      rc = ImeUpdateRegisterUpdate(intf, (tImeUpdateType )1);
#line 474
      ImeUpdateGetStatus(intf, & imeStatus);
      }
    } else {
#line 467
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 476
  if (rc == (int )IME_SUCCESS) {
    {
#line 478
    lprintf(3, "ME state error, aborting");
#line 479
    rc = (int )IME_ERROR;
    }
  }
#line 482
  if (rc == (int )IME_SUCCESS) {
#line 482
    if ((unsigned int )imeStatus.update_state == 3U) {
      {
#line 487
      time(& end);
#line 488
      printf((char const   */* __restrict  */)"Update Completed in %02ld:%02ld\n",
             (end - start) / 60L, (end - start) % 60L);
      }
    } else {
      {
#line 492
      time(& end);
#line 493
      printf((char const   */* __restrict  */)"Update Error\n");
#line 494
      printf((char const   */* __restrict  */)"\nTime Taken %02ld:%02ld\n", (end - start) / 60L,
             (end - start) % 60L);
      }
    }
  } else {
    {
#line 492
    time(& end);
#line 493
    printf((char const   */* __restrict  */)"Update Error\n");
#line 494
    printf((char const   */* __restrict  */)"\nTime Taken %02ld:%02ld\n", (end - start) / 60L,
           (end - start) % 60L);
    }
  }
#line 497
  return (rc);
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int ImeUpdatePrepare(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;

  {
  {
#line 510
  memset((void *)(& req), 0, sizeof(req));
#line 511
  req.msg.netfn = (uint8_t )48;
#line 512
  req.msg.cmd = (uint8_t )160;
#line 513
  req.msg.data_len = (uint16_t )0;
#line 515
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 516
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 517
    lprintf(3, "UpdatePrepare command failed");
    }
#line 518
    return ((int )IME_ERROR);
  }
#line 520
  if ((int )rsp->ccode > 0) {
    {
#line 521
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 521
    lprintf(3, "UpdatePrepare command failed: %s", tmp);
    }
#line 523
    return ((int )IME_ERROR);
  }
  {
#line 526
  lprintf(7, "UpdatePrepare command succeed");
  }
#line 527
  return ((int )IME_SUCCESS);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int ImeUpdateOpenArea(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t buffer[2] ;
  char const   *tmp ;

  {
  {
#line 540
  memset((void *)(& req), 0, sizeof(req));
#line 541
  req.msg.netfn = (uint8_t )48;
#line 542
  req.msg.cmd = (uint8_t )161;
#line 544
  buffer[0] = (uint8_t )1;
#line 545
  buffer[1] = (uint8_t )0;
#line 546
  req.msg.data = buffer;
#line 548
  req.msg.data_len = (uint16_t )2;
#line 550
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 551
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 552
    lprintf(3, "UpdateOpenArea command failed");
    }
#line 553
    return ((int )IME_ERROR);
  }
#line 555
  if ((int )rsp->ccode > 0) {
    {
#line 556
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 556
    lprintf(3, "UpdateOpenArea command failed: %s", tmp);
    }
#line 558
    return ((int )IME_ERROR);
  }
  {
#line 561
  lprintf(7, "UpdateOpenArea command succeed");
  }
#line 562
  return ((int )IME_SUCCESS);
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int ImeUpdateWriteArea(struct ipmi_intf *intf , uint8_t sequence , uint8_t length ,
                              uint8_t *pBuf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t buffer[23] ;
  char const   *tmp ;

  {
#line 578
  if ((int )length > 22) {
#line 579
    return ((int )IME_ERROR);
  }
  {
#line 581
  buffer[0] = sequence;
#line 582
  memcpy((void */* __restrict  */)(& buffer[1]), (void const   */* __restrict  */)pBuf,
         (size_t )length);
#line 584
  memset((void *)(& req), 0, sizeof(req));
#line 585
  req.msg.netfn = (uint8_t )48;
#line 586
  req.msg.cmd = (uint8_t )162;
#line 587
  req.msg.data = buffer;
#line 588
  req.msg.data_len = (uint16_t )((int )length + 1);
#line 590
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 591
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 592
    lprintf(3, "UpdateWriteArea command failed");
    }
#line 593
    return ((int )IME_ERROR);
  }
#line 595
  if ((int )rsp->ccode > 0) {
    {
#line 596
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 596
    lprintf(3, "UpdateWriteArea command failed: %s", tmp);
    }
#line 598
    if ((int )rsp->ccode == 128) {
#line 599
      return ((int )IME_RESTART);
    } else {
#line 601
      return ((int )IME_ERROR);
    }
  }
  {
#line 604
  lprintf(7, "UpdateWriteArea command succeed");
  }
#line 605
  return ((int )IME_SUCCESS);
}
}
#line 608 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int ImeUpdateCloseArea(struct ipmi_intf *intf , uint32_t size , uint16_t checksum ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t length ;
  uint8_t buffer[sizeof(uint32_t ) + sizeof(uint16_t )] ;
  char const   *tmp ;

  {
  {
#line 616
  length = (uint8_t )(sizeof(uint32_t ) + sizeof(uint16_t ));
#line 623
  buffer[0] = (uint8_t )(size & 255U);
#line 624
  buffer[1] = (uint8_t )((size & 65280U) >> 8);
#line 625
  buffer[2] = (uint8_t )((size & 16711680U) >> 16);
#line 626
  buffer[3] = (uint8_t )((size & 4278190080U) >> 24);
#line 628
  buffer[4] = (uint8_t )((int )checksum & 255);
#line 629
  buffer[5] = (uint8_t )(((int )checksum & 65280) >> 8);
#line 631
  memset((void *)(& req), 0, sizeof(req));
#line 632
  req.msg.netfn = (uint8_t )48;
#line 633
  req.msg.cmd = (uint8_t )163;
#line 634
  req.msg.data = buffer;
#line 635
  req.msg.data_len = (uint16_t )length;
#line 637
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 638
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 639
    lprintf(3, "UpdateCloseArea command failed");
    }
#line 640
    return ((int )IME_ERROR);
  }
#line 642
  if ((int )rsp->ccode > 0) {
    {
#line 643
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 643
    lprintf(3, "UpdateCloseArea command failed: %s", tmp);
    }
#line 645
    return ((int )IME_ERROR);
  }
  {
#line 648
  lprintf(7, "UpdateCloseArea command succeed");
  }
#line 649
  return ((int )IME_SUCCESS);
}
}
#line 652 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int ImeUpdateGetStatus(struct ipmi_intf *intf , tImeStatus *pStatus ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  tImeStatus *pGetStatus ;
  char const   *tmp ;

  {
  {
#line 658
  memset((void *)pStatus, 0, sizeof(tImeStatus ));
#line 659
  pStatus->update_state = (tImeStateEnum )6;
#line 666
  memset((void *)(& req), 0, sizeof(req));
#line 667
  req.msg.netfn = (uint8_t )48;
#line 668
  req.msg.cmd = (uint8_t )166;
#line 669
  req.msg.data_len = (uint16_t )0;
#line 671
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 672
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 673
    lprintf(3, "UpdatePrepare command failed");
    }
#line 674
    return ((int )IME_ERROR);
  }
#line 676
  if ((int )rsp->ccode > 0) {
    {
#line 677
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 677
    lprintf(3, "UpdatePrepare command failed: %s", tmp);
    }
#line 679
    return ((int )IME_ERROR);
  }
  {
#line 682
  lprintf(7, "UpdatePrepare command succeed");
#line 684
  pGetStatus = (tImeStatus *)(rsp->data);
#line 686
  memcpy((void */* __restrict  */)pStatus, (void const   */* __restrict  */)pGetStatus,
         sizeof(tImeStatus ));
  }
#line 723
  return ((int )IME_SUCCESS);
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int ImeUpdateGetCapabilities(struct ipmi_intf *intf , tImeCaps *pCaps ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  tImeCaps *pGetCaps ;
  char const   *tmp ;

  {
  {
#line 732
  memset((void *)pCaps, 0, sizeof(tImeCaps ));
#line 739
  memset((void *)(& req), 0, sizeof(req));
#line 740
  req.msg.netfn = (uint8_t )48;
#line 741
  req.msg.cmd = (uint8_t )167;
#line 742
  req.msg.data_len = (uint16_t )0;
#line 744
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 745
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 746
    lprintf(3, "UpdatePrepare command failed");
    }
#line 747
    return ((int )IME_ERROR);
  }
#line 749
  if ((int )rsp->ccode > 0) {
    {
#line 750
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 750
    lprintf(3, "UpdatePrepare command failed: %s", tmp);
    }
#line 752
    return ((int )IME_ERROR);
  }
  {
#line 755
  lprintf(7, "UpdatePrepare command succeed");
#line 757
  pGetCaps = (tImeCaps *)(rsp->data);
#line 759
  memcpy((void */* __restrict  */)pCaps, (void const   */* __restrict  */)pGetCaps,
         sizeof(tImeCaps ));
  }
#line 761
  return ((int )IME_SUCCESS);
}
}
#line 765 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int ImeUpdateRegisterUpdate(struct ipmi_intf *intf , tImeUpdateType type ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t buffer[2] ;
  char const   *tmp ;

  {
  {
#line 775
  buffer[0] = (uint8_t )type;
#line 776
  buffer[1] = (uint8_t )0;
#line 778
  memset((void *)(& req), 0, sizeof(req));
#line 779
  req.msg.netfn = (uint8_t )48;
#line 780
  req.msg.cmd = (uint8_t )164;
#line 781
  req.msg.data = buffer;
#line 782
  req.msg.data_len = (uint16_t )2;
#line 784
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 785
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 786
    lprintf(3, "ImeUpdateRegisterUpdate command failed");
    }
#line 787
    return ((int )IME_ERROR);
  }
#line 789
  if ((int )rsp->ccode > 0) {
    {
#line 790
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 790
    lprintf(3, "ImeUpdateRegisterUpdate command failed: %s", tmp);
    }
#line 792
    return ((int )IME_ERROR);
  }
  {
#line 795
  lprintf(7, "ImeUpdateRegisterUpdate command succeed");
  }
#line 796
  return ((int )IME_SUCCESS);
}
}
#line 878 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int ImeImageCtxFromFile(char *imageFilename , tImeUpdateImageCtx *pImageCtx ) 
{ 
  int rc ;
  FILE *pImageFile ;
  FILE *tmp ;
  long tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 883
  rc = (int )IME_SUCCESS;
#line 884
  tmp = fopen((char const   */* __restrict  */)imageFilename, (char const   */* __restrict  */)"rb");
#line 884
  pImageFile = tmp;
  }
#line 886
  if ((unsigned long )pImageFile == (unsigned long )((void *)0)) {
    {
#line 888
    lprintf(5, "Cannot open image file %s", imageFilename);
#line 889
    rc = (int )IME_ERROR;
    }
  }
#line 892
  if (rc == (int )IME_SUCCESS) {
    {
#line 895
    fseek(pImageFile, 0L, 2);
#line 896
    tmp___0 = ftell(pImageFile);
#line 896
    pImageCtx->size = (uint32_t )tmp___0;
    }
#line 897
    if (pImageCtx->size <= 0U) {
#line 898
      if (pImageCtx->size < 0U) {
        {
#line 899
        tmp___1 = __errno_location();
#line 899
        tmp___2 = strerror(*tmp___1);
#line 899
        lprintf(3, "Error seeking %s. %s\n", imageFilename, tmp___2);
        }
      }
      {
#line 900
      rc = (int )IME_ERROR;
#line 901
      fclose(pImageFile);
      }
#line 902
      return (rc);
    }
    {
#line 904
    tmp___3 = malloc(sizeof(unsigned char ) * (unsigned long )pImageCtx->size);
#line 904
    pImageCtx->pData = (uint8_t *)tmp___3;
#line 905
    rewind(pImageFile);
    }
#line 907
    if ((unsigned long )pImageCtx->pData != (unsigned long )((void *)0)) {
      {
#line 909
      tmp___4 = fread((void */* __restrict  */)pImageCtx->pData, sizeof(unsigned char ),
                      (size_t )pImageCtx->size, (FILE */* __restrict  */)pImageFile);
      }
#line 909
      if ((size_t )pImageCtx->size < tmp___4) {
#line 911
        rc = (int )IME_ERROR;
      }
    } else {
#line 915
      rc = (int )IME_ERROR;
    }
  }
#line 920
  if (rc == (int )IME_SUCCESS) {
    {
#line 922
    pImageCtx->crc8 = ImeCrc8(pImageCtx->size, pImageCtx->pData);
    }
  }
#line 926
  if ((unsigned long )pImageFile != (unsigned long )((void *)0)) {
    {
#line 928
    fclose(pImageFile);
    }
  }
#line 931
  return (rc);
}
}
#line 934 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static uint8_t ImeCrc8(uint32_t length , uint8_t *pBuf ) 
{ 
  uint8_t crc ;
  uint32_t bufCount ;
  uint8_t count ;

  {
#line 936
  crc = (uint8_t )0;
#line 939
  bufCount = (uint32_t )0;
  {
#line 939
  while (1) {
    while_continue: /* CIL Label */ ;
#line 939
    if (! (bufCount < length)) {
#line 939
      goto while_break;
    }
#line 943
    crc = (uint8_t )((int )crc ^ (int )*(pBuf + bufCount));
#line 945
    count = (uint8_t )0;
    {
#line 945
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 945
      if (! ((int )count < 8)) {
#line 945
        goto while_break___0;
      }
#line 947
      if (((int )crc & 128) != 0) {
#line 949
        crc = (uint8_t )((int )crc << 1);
#line 950
        crc = (uint8_t )((int )crc ^ 7);
      } else {
#line 954
        crc = (uint8_t )((int )crc << 1);
      }
#line 945
      count = (uint8_t )((int )count + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 939
    bufCount ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 959
  lprintf(7, "CRC8: %02xh\n", (int )crc);
  }
#line 960
  return (crc);
}
}
#line 964 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int ImeManualRollback(struct ipmi_intf *intf ) 
{ 
  int rc ;
  tImeStatus imeStatus ;

  {
  {
#line 966
  rc = (int )IME_SUCCESS;
#line 971
  rc = ImeUpdateRegisterUpdate(intf, (tImeUpdateType )3);
#line 972
  ImeUpdateGetStatus(intf, & imeStatus);
  }
#line 975
  if (rc == (int )IME_SUCCESS) {
#line 975
    if ((unsigned int )imeStatus.update_state == 5U) {
      {
#line 980
      printf((char const   */* __restrict  */)"Manual Rollback Succeed\n");
      }
#line 981
      return ((int )IME_SUCCESS);
    } else {
      {
#line 985
      printf((char const   */* __restrict  */)"Manual Rollback Completed With Error\n");
      }
#line 986
      return ((int )IME_ERROR);
    }
  } else {
    {
#line 985
    printf((char const   */* __restrict  */)"Manual Rollback Completed With Error\n");
    }
#line 986
    return ((int )IME_ERROR);
  }
}
}
#line 992 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static void ImePrintUsage(void) 
{ 


  {
  {
#line 994
  lprintf(5, "help                    - This help menu");
#line 995
  lprintf(5, "info                    - Information about the present Intel ME");
#line 996
  lprintf(5, "update <file>           - Upgrade the ME firmware from received image <file>");
#line 997
  lprintf(5, "rollback                - Manual Rollback ME");
  }
#line 999
  return;
}
}
#line 1003 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
int ipmi_ime_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1005
  rc = (int )IME_SUCCESS;
#line 1007
  lprintf(7, "ipmi_ime_main()");
  }
#line 1010
  if (argc == 0) {
    {
#line 1012
    ImePrintUsage();
    }
  } else {
    {
#line 1010
    tmp___2 = strcmp((char const   *)*(argv + 0), "help");
    }
#line 1010
    if (tmp___2 == 0) {
      {
#line 1012
      ImePrintUsage();
      }
    } else
#line 1014
    if (argc == 0) {
      {
#line 1016
      rc = ImeGetInfo(intf);
      }
    } else {
      {
#line 1014
      tmp___1 = strcmp((char const   *)*(argv + 0), "info");
      }
#line 1014
      if (tmp___1 == 0) {
        {
#line 1016
        rc = ImeGetInfo(intf);
        }
      } else {
        {
#line 1018
        tmp___0 = strcmp((char const   *)*(argv + 0), "update");
        }
#line 1018
        if (tmp___0 == 0) {
#line 1020
          if (argc == 2) {
            {
#line 1022
            lprintf(5, "Update using file: %s", *(argv + 1));
#line 1023
            rc = ImeUpgrade(intf, *(argv + 1));
            }
          } else {
            {
#line 1027
            lprintf(3, "File must be provided with this option, see help\n");
#line 1028
            rc = (int )IME_ERROR;
            }
          }
        } else
#line 1031
        if (argc == 0) {
          {
#line 1033
          rc = ImeManualRollback(intf);
          }
        } else {
          {
#line 1031
          tmp = strcmp((char const   *)*(argv + 0), "rollback");
          }
#line 1031
          if (tmp == 0) {
            {
#line 1033
            rc = ImeManualRollback(intf);
            }
          } else {
            {
#line 1037
            ImePrintUsage();
            }
          }
        }
      }
    }
  }
#line 1040
  return (rc);
}
}
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 263
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 312
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 164 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 187
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 215
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 646
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpgid)(__pid_t __pid ,
                                                                              __pid_t __pgid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 76 "../include/ipmitool/helper.h"
int str2double(char const   *str___1 , double *double_ptr ) ;
#line 77
int str2long(char const   *str___1 , int64_t *lng_ptr ) ;
#line 78
int str2ulong(char const   *str___1 , uint64_t *ulng_ptr ) ;
#line 79
int str2int(char const   *str___1 , int32_t *int_ptr ) ;
#line 80
int str2uint(char const   *str___1 , uint32_t *uint_ptr ) ;
#line 81
int str2short(char const   *str___1 , int16_t *shrt_ptr ) ;
#line 82
int str2ushort(char const   *str___1 , uint16_t *ushrt_ptr ) ;
#line 83
int str2char(char const   *str___1 , int8_t *chr_ptr ) ;
#line 84
int str2uchar(char const   *str___1 , uint8_t *uchr_ptr ) ;
#line 86
int is_fru_id(char const   *argv_ptr , uint8_t *fru_id_ptr ) ;
#line 87
int is_ipmi_channel_num(char const   *argv_ptr , uint8_t *channel_ptr ) ;
#line 88
int is_ipmi_user_id(char const   *argv_ptr , uint8_t *ipmi_uid_ptr ) ;
#line 90
uint16_t str2val(char const   *str___1 , struct valstr  const  *vs ) ;
#line 91
void print_valstr(struct valstr  const  *vs , char const   *title , int loglevel ) ;
#line 92
void print_valstr_2col(struct valstr  const  *vs , char const   *title , int loglevel ) ;
#line 96
uint32_t buf2long(uint8_t *buf ) ;
#line 97
char const   *buf2str(uint8_t *buf , int len ) ;
#line 98
void printbuf(uint8_t const   *buf , int len , char const   *desc ) ;
#line 99
uint8_t ipmi_csum(uint8_t *d , int s___1 ) ;
#line 100
FILE *ipmi_open_file(char const   *file , int rw ) ;
#line 101
void ipmi_start_daemon(struct ipmi_intf *intf ) ;
#line 68 "../include/ipmitool/ipmi.h"
int verbose ;
#line 60 "../include/ipmitool/log.h"
extern void lperror(int level , char const   *format  , ...) ;
#line 65 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
uint32_t buf2long(uint8_t *buf ) 
{ 


  {
#line 67
  return ((uint32_t )(((((int )*(buf + 3) << 24) | ((int )*(buf + 2) << 16)) | ((int )*(buf + 1) << 8)) | (int )*(buf + 0)));
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
uint16_t buf2short(uint8_t *buf ) 
{ 


  {
#line 72
  return ((uint16_t )(((int )*(buf + 1) << 8) | (int )*(buf + 0)));
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
static char str[2049]  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
char const   *buf2str(uint8_t *buf , int len ) 
{ 
  int i ;

  {
#line 80
  if (len <= 0) {
#line 81
    return ((char const   *)((void *)0));
  } else
#line 80
  if (len > 1024) {
#line 81
    return ((char const   *)((void *)0));
  }
  {
#line 83
  memset((void *)(str), 0, (size_t )2049);
#line 85
  i = 0;
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! (i < len)) {
#line 85
      goto while_break;
    }
    {
#line 86
    sprintf((char */* __restrict  */)((str + i) + i), (char const   */* __restrict  */)"%2.2x",
            (int )*(buf + i));
#line 85
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  str[len * 2] = (char )'\000';
#line 90
  return ((char const   *)(str));
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
void printbuf(uint8_t const   *buf , int len , char const   *desc ) 
{ 
  int i ;

  {
#line 97
  if (len <= 0) {
#line 98
    return;
  }
#line 100
  if (verbose < 1) {
#line 101
    return;
  }
  {
#line 103
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s (%d bytes)\n",
          desc, len);
#line 104
  i = 0;
  }
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! (i < len)) {
#line 104
      goto while_break;
    }
#line 105
    if (i % 16 == 0) {
#line 105
      if (i != 0) {
        {
#line 106
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      }
    }
    {
#line 107
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %2.2x",
            (int const   )*(buf + i));
#line 104
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 110
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
static char un_str[32]  ;
#line 112 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
char const   *val2str(uint16_t val , struct valstr  const  *vs ) 
{ 
  int i ;

  {
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! ((unsigned long )(vs + i)->str != (unsigned long )((void *)0))) {
#line 117
      goto while_break;
    }
#line 118
    if ((int const   )(vs + i)->val == (int const   )val) {
#line 119
      return ((char const   *)(vs + i)->str);
    }
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 122
  memset((void *)(un_str), 0, (size_t )32);
#line 123
  snprintf((char */* __restrict  */)(un_str), (size_t )32, (char const   */* __restrict  */)"Unknown (0x%02X)",
           (int )val);
  }
#line 125
  return ((char const   *)(un_str));
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
static char un_str___0[32]  ;
#line 128 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
char const   *oemval2str(uint32_t oem , uint16_t val , struct oemvalstr  const  *vs ) 
{ 
  int i ;

  {
#line 134
  i = 0;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if ((vs + i)->oem != 16777215U) {
#line 134
      if (! ((unsigned long )(vs + i)->str != (unsigned long )((void *)0))) {
#line 134
        goto while_break;
      }
    } else {
#line 134
      goto while_break;
    }
#line 136
    if ((vs + i)->oem == (uint32_t const   )oem) {
#line 136
      goto _L;
    } else
#line 136
    if ((vs + i)->oem == 12634U) {
      _L: /* CIL Label */ 
#line 136
      if ((int const   )(vs + i)->val == (int const   )val) {
#line 138
        return ((char const   *)(vs + i)->str);
      }
    }
#line 134
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 142
  memset((void *)(un_str___0), 0, (size_t )32);
#line 143
  snprintf((char */* __restrict  */)(un_str___0), (size_t )32, (char const   */* __restrict  */)"Unknown (0x%X)",
           (int )val);
  }
#line 145
  return ((char const   *)(un_str___0));
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
int str2double(char const   *str___1 , double *double_ptr ) 
{ 
  char *end_ptr ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 158
  end_ptr = (char *)0;
#line 159
  if (! str___1) {
#line 160
    return (-1);
  } else
#line 159
  if (! double_ptr) {
#line 160
    return (-1);
  }
  {
#line 162
  *double_ptr = (double )0;
#line 163
  tmp = __errno_location();
#line 163
  *tmp = 0;
#line 164
  *double_ptr = strtod((char const   */* __restrict  */)str___1, (char **/* __restrict  */)(& end_ptr));
  }
#line 166
  if ((int )*end_ptr != 0) {
#line 167
    return (-2);
  }
  {
#line 169
  tmp___0 = __errno_location();
  }
#line 169
  if (*tmp___0 != 0) {
#line 170
    return (-3);
  }
#line 172
  return (0);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
int str2long(char const   *str___1 , int64_t *lng_ptr ) 
{ 
  char *end_ptr ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 185
  end_ptr = (char *)0;
#line 186
  if (! str___1) {
#line 187
    return (-1);
  } else
#line 186
  if (! lng_ptr) {
#line 187
    return (-1);
  }
  {
#line 189
  *lng_ptr = (int64_t )0;
#line 190
  tmp = __errno_location();
#line 190
  *tmp = 0;
#line 191
  *lng_ptr = strtol((char const   */* __restrict  */)str___1, (char **/* __restrict  */)(& end_ptr),
                    0);
  }
#line 193
  if ((int )*end_ptr != 0) {
#line 194
    return (-2);
  }
  {
#line 196
  tmp___0 = __errno_location();
  }
#line 196
  if (*tmp___0 != 0) {
#line 197
    return (-3);
  }
#line 199
  return (0);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
int str2ulong(char const   *str___1 , uint64_t *ulng_ptr ) 
{ 
  char *end_ptr ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 212
  end_ptr = (char *)0;
#line 213
  if (! str___1) {
#line 214
    return (-1);
  } else
#line 213
  if (! ulng_ptr) {
#line 214
    return (-1);
  }
  {
#line 216
  *ulng_ptr = (uint64_t )0;
#line 217
  tmp = __errno_location();
#line 217
  *tmp = 0;
#line 218
  *ulng_ptr = strtoul((char const   */* __restrict  */)str___1, (char **/* __restrict  */)(& end_ptr),
                      0);
  }
#line 220
  if ((int )*end_ptr != 0) {
#line 221
    return (-2);
  }
  {
#line 223
  tmp___0 = __errno_location();
  }
#line 223
  if (*tmp___0 != 0) {
#line 224
    return (-3);
  }
#line 226
  return (0);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
int str2int(char const   *str___1 , int32_t *int_ptr ) 
{ 
  int rc ;
  int64_t arg_long ;

  {
#line 239
  rc = 0;
#line 240
  arg_long = (int64_t )0;
#line 241
  if (! str___1) {
#line 242
    return (-1);
  } else
#line 241
  if (! int_ptr) {
#line 242
    return (-1);
  }
  {
#line 244
  rc = str2long(str___1, & arg_long);
  }
#line 244
  if (rc != 0) {
#line 245
    *int_ptr = 0;
#line 246
    return (rc);
  }
#line 249
  if (arg_long < (-0x7FFFFFFF-1)) {
#line 250
    return (-3);
  } else
#line 249
  if (arg_long > 2147483647L) {
#line 250
    return (-3);
  }
#line 252
  *int_ptr = (int32_t )arg_long;
#line 253
  return (0);
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
int str2uint(char const   *str___1 , uint32_t *uint_ptr ) 
{ 
  int rc ;
  uint64_t arg_ulong ;

  {
#line 266
  rc = 0;
#line 267
  arg_ulong = (uint64_t )0;
#line 268
  if (! str___1) {
#line 269
    return (-1);
  } else
#line 268
  if (! uint_ptr) {
#line 269
    return (-1);
  }
  {
#line 271
  rc = str2ulong(str___1, & arg_ulong);
  }
#line 271
  if (rc != 0) {
#line 272
    *uint_ptr = (uint32_t )0;
#line 273
    return (rc);
  }
#line 276
  if (arg_ulong > 4294967295UL) {
#line 277
    return (-3);
  }
#line 279
  *uint_ptr = (uint32_t )arg_ulong;
#line 280
  return (0);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
int str2short(char const   *str___1 , int16_t *shrt_ptr ) 
{ 
  int rc ;
  int64_t arg_long ;

  {
#line 293
  rc = -3;
#line 294
  arg_long = (int64_t )0;
#line 295
  if (! str___1) {
#line 296
    return (-1);
  } else
#line 295
  if (! shrt_ptr) {
#line 296
    return (-1);
  }
  {
#line 298
  rc = str2long(str___1, & arg_long);
  }
#line 298
  if (rc != 0) {
#line 299
    *shrt_ptr = (int16_t )0;
#line 300
    return (rc);
  }
#line 303
  if (arg_long < -32768L) {
#line 304
    return (-3);
  } else
#line 303
  if (arg_long > 32767L) {
#line 304
    return (-3);
  }
#line 306
  *shrt_ptr = (int16_t )arg_long;
#line 307
  return (0);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
int str2ushort(char const   *str___1 , uint16_t *ushrt_ptr ) 
{ 
  int rc ;
  uint64_t arg_ulong ;

  {
#line 320
  rc = -3;
#line 321
  arg_ulong = (uint64_t )0;
#line 322
  if (! str___1) {
#line 323
    return (-1);
  } else
#line 322
  if (! ushrt_ptr) {
#line 323
    return (-1);
  }
  {
#line 325
  rc = str2ulong(str___1, & arg_ulong);
  }
#line 325
  if (rc != 0) {
#line 326
    *ushrt_ptr = (uint16_t )0;
#line 327
    return (rc);
  }
#line 330
  if (arg_ulong > 65535UL) {
#line 331
    return (-3);
  }
#line 333
  *ushrt_ptr = (uint16_t )arg_ulong;
#line 334
  return (0);
}
}
#line 345 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
int str2char(char const   *str___1 , int8_t *chr_ptr ) 
{ 
  int rc ;
  int64_t arg_long ;

  {
#line 347
  rc = -3;
#line 348
  arg_long = (int64_t )0;
#line 349
  if (! str___1) {
#line 350
    return (-1);
  } else
#line 349
  if (! chr_ptr) {
#line 350
    return (-1);
  }
  {
#line 352
  rc = str2long(str___1, & arg_long);
  }
#line 352
  if (rc != 0) {
#line 353
    *chr_ptr = (int8_t )0;
#line 354
    return (rc);
  }
#line 356
  if (arg_long < -128L) {
#line 357
    return (-3);
  } else
#line 356
  if (arg_long > 127L) {
#line 357
    return (-3);
  }
#line 359
  return (0);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
int str2uchar(char const   *str___1 , uint8_t *uchr_ptr ) 
{ 
  int rc ;
  uint64_t arg_ulong ;

  {
#line 372
  rc = -3;
#line 373
  arg_ulong = (uint64_t )0;
#line 374
  if (! str___1) {
#line 375
    return (-1);
  } else
#line 374
  if (! uchr_ptr) {
#line 375
    return (-1);
  }
  {
#line 377
  rc = str2ulong(str___1, & arg_ulong);
  }
#line 377
  if (rc != 0) {
#line 378
    *uchr_ptr = (uint8_t )0;
#line 379
    return (rc);
  }
#line 382
  if (arg_ulong > 255UL) {
#line 383
    return (-3);
  }
#line 385
  *uchr_ptr = (uint8_t )arg_ulong;
#line 386
  return (0);
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
uint16_t str2val(char const   *str___1 , struct valstr  const  *vs ) 
{ 
  int i ;
  int x ;
  size_t tmp ;
  int y ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 393
  i = 0;
  {
#line 393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 393
    if (! ((unsigned long )(vs + i)->str != (unsigned long )((void *)0))) {
#line 393
      goto while_break;
    }
    {
#line 394
    tmp = strlen(str___1);
#line 394
    x = (int )tmp;
#line 394
    tmp___0 = strlen((char const   *)(vs + i)->str);
#line 394
    y = (int )tmp___0;
    }
#line 394
    if (x > y) {
#line 394
      tmp___1 = x;
    } else {
#line 394
      tmp___1 = y;
    }
    {
#line 394
    tmp___2 = strncasecmp((char const   *)(vs + i)->str, str___1, (size_t )tmp___1);
    }
#line 394
    if (tmp___2 == 0) {
#line 395
      return ((uint16_t )(vs + i)->val);
    }
#line 393
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 398
  return ((uint16_t )(vs + i)->val);
}
}
#line 407 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
void print_valstr(struct valstr  const  *vs , char const   *title , int loglevel ) 
{ 
  int i ;

  {
#line 412
  if ((unsigned long )vs == (unsigned long )((void *)0)) {
#line 413
    return;
  }
#line 415
  if ((unsigned long )title != (unsigned long )((void *)0)) {
#line 416
    if (loglevel < 0) {
      {
#line 417
      printf((char const   */* __restrict  */)"\n%s:\n\n", title);
      }
    } else {
      {
#line 419
      lprintf(loglevel, "\n%s:\n", title);
      }
    }
  }
#line 422
  if (loglevel < 0) {
    {
#line 423
    printf((char const   */* __restrict  */)"  VALUE\tHEX\tSTRING\n");
#line 424
    printf((char const   */* __restrict  */)"==============================================\n");
    }
  } else {
    {
#line 426
    lprintf(loglevel, "  VAL\tHEX\tSTRING");
#line 427
    lprintf(loglevel, "==============================================");
    }
  }
#line 430
  i = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! ((unsigned long )(vs + i)->str != (unsigned long )((void *)0))) {
#line 430
      goto while_break;
    }
#line 431
    if (loglevel < 0) {
#line 432
      if ((int const   )(vs + i)->val < 256) {
        {
#line 433
        printf((char const   */* __restrict  */)"  %d\t0x%02x\t%s\n", (int const   )(vs + i)->val,
               (int const   )(vs + i)->val, (vs + i)->str);
        }
      } else {
        {
#line 435
        printf((char const   */* __restrict  */)"  %d\t0x%04x\t%s\n", (int const   )(vs + i)->val,
               (int const   )(vs + i)->val, (vs + i)->str);
        }
      }
    } else
#line 437
    if ((int const   )(vs + i)->val < 256) {
      {
#line 438
      lprintf(loglevel, "  %d\t0x%02x\t%s", (int const   )(vs + i)->val, (int const   )(vs + i)->val,
              (vs + i)->str);
      }
    } else {
      {
#line 440
      lprintf(loglevel, "  %d\t0x%04x\t%s", (int const   )(vs + i)->val, (int const   )(vs + i)->val,
              (vs + i)->str);
      }
    }
#line 430
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 444
  if (loglevel < 0) {
    {
#line 445
    printf((char const   */* __restrict  */)"\n");
    }
  } else {
    {
#line 447
    lprintf(loglevel, "");
    }
  }
#line 448
  return;
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
void print_valstr_2col(struct valstr  const  *vs , char const   *title , int loglevel ) 
{ 
  int i ;

  {
#line 461
  if ((unsigned long )vs == (unsigned long )((void *)0)) {
#line 462
    return;
  }
#line 464
  if ((unsigned long )title != (unsigned long )((void *)0)) {
#line 465
    if (loglevel < 0) {
      {
#line 466
      printf((char const   */* __restrict  */)"\n%s:\n\n", title);
      }
    } else {
      {
#line 468
      lprintf(loglevel, "\n%s:\n", title);
      }
    }
  }
#line 471
  i = 0;
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (! ((unsigned long )(vs + i)->str != (unsigned long )((void *)0))) {
#line 471
      goto while_break;
    }
#line 472
    if ((unsigned long )(vs + (i + 1))->str == (unsigned long )((void *)0)) {
#line 474
      if (loglevel < 0) {
        {
#line 475
        printf((char const   */* __restrict  */)"  %4d  %-32s\n", (int const   )(vs + i)->val,
               (vs + i)->str);
        }
      } else {
        {
#line 477
        lprintf(loglevel, "  %4d  %-32s\n", (int const   )(vs + i)->val, (vs + i)->str);
        }
      }
    } else {
#line 481
      if (loglevel < 0) {
        {
#line 482
        printf((char const   */* __restrict  */)"  %4d  %-32s    %4d  %-32s\n", (int const   )(vs + i)->val,
               (vs + i)->str, (int const   )(vs + (i + 1))->val, (vs + (i + 1))->str);
        }
      } else {
        {
#line 485
        lprintf(loglevel, "  %4d  %-32s    %4d  %-32s\n", (int const   )(vs + i)->val,
                (vs + i)->str, (int const   )(vs + (i + 1))->val, (vs + (i + 1))->str);
        }
      }
#line 488
      i ++;
    }
#line 471
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 492
  if (loglevel < 0) {
    {
#line 493
    printf((char const   */* __restrict  */)"\n");
    }
  } else {
    {
#line 495
    lprintf(loglevel, "");
    }
  }
#line 496
  return;
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
uint8_t ipmi_csum(uint8_t *d , int s___1 ) 
{ 
  uint8_t c ;

  {
#line 506
  c = (uint8_t )0;
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;
#line 507
    if (! (s___1 > 0)) {
#line 507
      goto while_break;
    }
#line 508
    c = (uint8_t )((int )c + (int )*d);
#line 507
    s___1 --;
#line 507
    d ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 509
  return ((uint8_t )(- ((int )c)));
}
}
#line 520 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
FILE *ipmi_open_file(char const   *file , int rw ) 
{ 
  struct stat st1 ;
  struct stat st2 ;
  FILE *fp ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 527
  tmp = lstat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st1));
  }
#line 527
  if (tmp < 0) {
#line 528
    if (rw) {
      {
#line 530
      fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"w");
      }
#line 531
      if ((unsigned long )fp == (unsigned long )((void *)0)) {
        {
#line 532
        lperror(3, "Unable to open file %s for write", file);
        }
#line 534
        return ((FILE *)((void *)0));
      }
#line 537
      return (fp);
    } else {
      {
#line 539
      lprintf(3, "File %s does not exist", file);
      }
#line 540
      return ((FILE *)((void *)0));
    }
  }
#line 545
  if (! rw) {
    {
#line 547
    fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
    }
#line 548
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 549
      lperror(3, "Unable to open file %s", file);
      }
#line 550
      return ((FILE *)((void *)0));
    }
#line 552
    return (fp);
  }
#line 557
  if (((st1.st_mode & 61440U) == 32768U) == 0) {
    {
#line 558
    lprintf(3, "File %s has invalid mode: %d", file, st1.st_mode);
    }
#line 560
    return ((FILE *)((void *)0));
  }
#line 564
  if (st1.st_nlink != 1UL) {
    {
#line 565
    lprintf(3, "File %s has invalid link count: %d != 1", file, (int )st1.st_nlink);
    }
#line 567
    return ((FILE *)((void *)0));
  }
#line 570
  if (rw) {
#line 570
    tmp___0 = "w+";
  } else {
#line 570
    tmp___0 = "r";
  }
  {
#line 570
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)tmp___0);
  }
#line 571
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 572
    lperror(3, "Unable to open file %s", file);
    }
#line 573
    return ((FILE *)((void *)0));
  }
  {
#line 577
  tmp___1 = fileno(fp);
#line 577
  tmp___2 = fstat(tmp___1, & st2);
  }
#line 577
  if (tmp___2 < 0) {
    {
#line 578
    lperror(3, "Unable to stat file %s", file);
#line 579
    fclose(fp);
    }
#line 580
    return ((FILE *)((void *)0));
  }
#line 584
  if (st1.st_ino != st2.st_ino) {
    {
#line 585
    lprintf(3, "File %s has invalid inode: %d != %d", file, st1.st_ino, st2.st_ino);
#line 587
    fclose(fp);
    }
#line 588
    return ((FILE *)((void *)0));
  }
#line 592
  if (st1.st_uid != st2.st_uid) {
    {
#line 593
    lprintf(3, "File %s has invalid user id: %d != %d", file, st1.st_uid, st2.st_uid);
#line 595
    fclose(fp);
    }
#line 596
    return ((FILE *)((void *)0));
  }
#line 600
  if (st2.st_nlink != 1UL) {
    {
#line 601
    lprintf(3, "File %s has invalid link count: %d != 1", file, st2.st_nlink);
#line 603
    fclose(fp);
    }
#line 604
    return ((FILE *)((void *)0));
  }
#line 607
  return (fp);
}
}
#line 610 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
void ipmi_start_daemon(struct ipmi_intf *intf ) 
{ 
  pid_t pid ;
  int fd ;
  sigset_t sighup ;
  int tmp ;
  __pid_t tmp___0 ;
  __pid_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 620
  sigemptyset(& sighup);
#line 621
  sigaddset(& sighup, 1);
#line 622
  tmp = sigprocmask(1, (sigset_t const   */* __restrict  */)(& sighup), (sigset_t */* __restrict  */)((void *)0));
  }
#line 622
  if (tmp < 0) {
    {
#line 623
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: could not unblock SIGHUP signal\n");
    }
  }
  {
#line 624
  signal(1, (void (*)(int  ))1);
#line 627
  signal(22, (void (*)(int  ))1);
#line 630
  signal(21, (void (*)(int  ))1);
#line 633
  signal(3, (void (*)(int  ))1);
#line 636
  signal(20, (void (*)(int  ))1);
#line 639
  tmp___0 = fork();
#line 639
  pid = tmp___0;
  }
#line 640
  if (pid < 0) {
    {
#line 641
    exit(0);
    }
  } else
#line 640
  if (pid > 0) {
    {
#line 641
    exit(0);
    }
  }
  {
#line 644
  tmp___1 = getpid();
#line 644
  tmp___2 = setpgid(0, tmp___1);
  }
#line 644
  if (tmp___2 == -1) {
    {
#line 645
    exit(1);
    }
  }
  {
#line 646
  fd = open("/dev/tty", 2);
  }
#line 646
  if (fd >= 0) {
    {
#line 647
    ioctl(fd, 21538UL, (void *)0);
#line 648
    close(fd);
    }
  }
  {
#line 658
  chdir("/");
#line 659
  umask((__mode_t )0);
#line 661
  fd = 0;
  }
  {
#line 661
  while (1) {
    while_continue: /* CIL Label */ ;
#line 661
    if (! (fd < 64)) {
#line 661
      goto while_break;
    }
#line 662
    if (fd != intf->fd) {
      {
#line 663
      close(fd);
      }
    }
#line 661
    fd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 666
  open("/dev/null", 2);
#line 667
  dup(0);
#line 668
  dup(0);
  }
#line 669
  return;
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
int is_fru_id(char const   *argv_ptr , uint8_t *fru_id_ptr ) 
{ 
  int tmp ;

  {
#line 684
  if (! argv_ptr) {
    {
#line 685
    lprintf(3, "is_fru_id(): invalid argument(s).");
    }
#line 686
    return (-1);
  } else
#line 684
  if (! fru_id_ptr) {
    {
#line 685
    lprintf(3, "is_fru_id(): invalid argument(s).");
    }
#line 686
    return (-1);
  }
  {
#line 689
  tmp = str2uchar(argv_ptr, fru_id_ptr);
  }
#line 689
  if (tmp == 0) {
#line 690
    return (0);
  }
  {
#line 692
  lprintf(3, "FRU ID \'%s\' is either invalid or out of range.", argv_ptr);
  }
#line 694
  return (-1);
}
}
#line 710 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
int is_ipmi_channel_num(char const   *argv_ptr , uint8_t *channel_ptr ) 
{ 
  int tmp ;

  {
#line 713
  if (! argv_ptr) {
    {
#line 714
    lprintf(3, "is_ipmi_channel_num(): invalid argument(s).");
    }
#line 716
    return (-1);
  } else
#line 713
  if (! channel_ptr) {
    {
#line 714
    lprintf(3, "is_ipmi_channel_num(): invalid argument(s).");
    }
#line 716
    return (-1);
  }
  {
#line 718
  tmp = str2uchar(argv_ptr, channel_ptr);
  }
#line 718
  if (tmp == 0) {
#line 718
    if ((int )*channel_ptr >= 0) {
#line 718
      if ((int )*channel_ptr <= 7) {
#line 721
        return (0);
      } else {
#line 718
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 718
    if ((int )*channel_ptr >= 14) {
#line 718
      if ((int )*channel_ptr <= 15) {
#line 721
        return (0);
      }
    }
  }
  {
#line 723
  lprintf(3, "Given Channel number \'%s\' is either invalid or out of range.", argv_ptr);
#line 726
  lprintf(3, "Channel number must be from ranges: <0..7>, <0xE..0xF>");
  }
#line 727
  return (-1);
}
}
#line 739 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
int is_ipmi_user_id(char const   *argv_ptr , uint8_t *ipmi_uid_ptr ) 
{ 
  int tmp ;

  {
#line 742
  if (! argv_ptr) {
    {
#line 743
    lprintf(3, "is_ipmi_user_id(): invalid argument(s).");
    }
#line 745
    return (-1);
  } else
#line 742
  if (! ipmi_uid_ptr) {
    {
#line 743
    lprintf(3, "is_ipmi_user_id(): invalid argument(s).");
    }
#line 745
    return (-1);
  }
  {
#line 747
  tmp = str2uchar(argv_ptr, ipmi_uid_ptr);
  }
#line 747
  if (tmp == 0) {
#line 747
    if ((int )*ipmi_uid_ptr >= 1) {
#line 747
      if ((int )*ipmi_uid_ptr <= 63) {
#line 750
        return (0);
      }
    }
  }
  {
#line 752
  lprintf(3, "Given User ID \'%s\' is either invalid or out of range.", argv_ptr);
#line 755
  lprintf(3, "User ID is limited to range <%i..%i>.", 1, 63);
  }
#line 757
  return (-1);
}
}
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 69 "../include/ipmitool/ipmi.h"
int csv_output ;
#line 200 "../include/ipmitool/ipmi_intf.h"
extern void ipmi_intf_session_set_hostname(struct ipmi_intf *intf , char *hostname ) ;
#line 201
extern void ipmi_intf_session_set_username(struct ipmi_intf *intf , char *username ) ;
#line 202
extern void ipmi_intf_session_set_password(struct ipmi_intf *intf , char *password ) ;
#line 203
extern void ipmi_intf_session_set_privlvl(struct ipmi_intf *intf , uint8_t privlvl ) ;
#line 208
extern void ipmi_intf_session_set_port(struct ipmi_intf *intf , int port ) ;
#line 209
extern void ipmi_intf_session_set_authtype(struct ipmi_intf *intf , uint8_t authtype ) ;
#line 40 "../include/ipmitool/ipmi_main.h"
extern int ipmi_cmd_run(struct ipmi_intf *intf , char *name , int argc , char **argv ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmishell.c"
extern struct valstr  const  ipmi_privlvl_vals[] ;
#line 56
extern struct valstr  const  ipmi_authtype_session_vals[] ;
#line 216 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmishell.c"
int ipmi_shell_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 


  {
  {
#line 219
  lprintf(3, "Compiled without readline, shell is disabled");
  }
#line 220
  return (-1);
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmishell.c"
int ipmi_echo_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int i ;

  {
#line 229
  i = 0;
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (! (i < argc)) {
#line 229
      goto while_break;
    }
    {
#line 230
    printf((char const   */* __restrict  */)"%s ", *(argv + i));
#line 229
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 232
  printf((char const   */* __restrict  */)"\n");
  }
#line 234
  return (0);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmishell.c"
static void ipmi_set_usage(void) 
{ 


  {
  {
#line 240
  lprintf(5, "Usage: set <option> <value>\n");
#line 241
  lprintf(5, "Options are:");
#line 242
  lprintf(5, "    hostname <host>        Session hostname");
#line 243
  lprintf(5, "    username <user>        Session username");
#line 244
  lprintf(5, "    password <pass>        Session password");
#line 245
  lprintf(5, "    privlvl <level>        Session privilege level force");
#line 246
  lprintf(5, "    authtype <type>        Authentication type force");
#line 247
  lprintf(5, "    localaddr <addr>       Local IPMB address");
#line 248
  lprintf(5, "    targetaddr <addr>      Remote target IPMB address");
#line 249
  lprintf(5, "    port <port>            Remote RMCP port");
#line 250
  lprintf(5, "    csv [level]            enable output in comma separated format");
#line 251
  lprintf(5, "    verbose [level]        Verbose level");
#line 252
  lprintf(5, "");
  }
#line 253
  return;
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmishell.c"
int ipmi_set_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int authtype ;
  uint16_t tmp___4 ;
  char const   *tmp___5 ;
  int privlvl ;
  uint16_t tmp___6 ;
  char const   *tmp___7 ;
  int port ;
  int tmp___8 ;
  uint8_t my_addr ;
  int tmp___9 ;
  uint8_t target_addr ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 257
  if (argc == 0) {
    {
#line 258
    ipmi_set_usage();
    }
#line 259
    return (-1);
  } else {
    {
#line 257
    tmp = strncmp((char const   *)*(argv + 0), "help", (size_t )4);
    }
#line 257
    if (tmp == 0) {
      {
#line 258
      ipmi_set_usage();
      }
#line 259
      return (-1);
    }
  }
  {
#line 263
  tmp___1 = strncmp((char const   *)*(argv + 0), "verbose", (size_t )7);
  }
#line 263
  if (tmp___1 == 0) {
#line 264
    if (argc > 1) {
      {
#line 265
      tmp___0 = str2int((char const   *)*(argv + 1), & verbose);
      }
#line 265
      if (tmp___0 != 0) {
        {
#line 266
        lprintf(3, "Given verbose \'%s\' argument is invalid.", *(argv + 1));
        }
#line 269
        return (-1);
      }
    } else {
#line 272
      verbose ++;
    }
#line 274
    return (0);
  }
  {
#line 276
  tmp___3 = strncmp((char const   *)*(argv + 0), "csv", (size_t )3);
  }
#line 276
  if (tmp___3 == 0) {
#line 277
    if (argc > 1) {
      {
#line 278
      tmp___2 = str2int((char const   *)*(argv + 1), & csv_output);
      }
#line 278
      if (tmp___2 != 0) {
        {
#line 279
        lprintf(3, "Given csv \'%s\' argument is invalid.", *(argv + 1));
        }
#line 282
        return (-1);
      }
    } else {
#line 285
      csv_output = 1;
    }
#line 287
    return (0);
  }
#line 291
  if (argc == 1) {
    {
#line 292
    ipmi_set_usage();
    }
#line 293
    return (-1);
  }
  {
#line 296
  tmp___20 = strncmp((char const   *)*(argv + 0), "host", (size_t )4);
  }
#line 296
  if (tmp___20 == 0) {
#line 296
    goto _L___1;
  } else {
    {
#line 296
    tmp___21 = strncmp((char const   *)*(argv + 0), "hostname", (size_t )8);
    }
#line 296
    if (tmp___21 == 0) {
      _L___1: /* CIL Label */ 
      {
#line 298
      ipmi_intf_session_set_hostname(intf, *(argv + 1));
      }
#line 299
      if ((unsigned long )intf->session == (unsigned long )((void *)0)) {
        {
#line 300
        lprintf(3, "Failed to set session hostname.");
        }
#line 301
        return (-1);
      }
      {
#line 303
      printf((char const   */* __restrict  */)"Set session hostname to %s\n", (intf->session)->hostname);
      }
    } else {
      {
#line 306
      tmp___18 = strncmp((char const   *)*(argv + 0), "user", (size_t )4);
      }
#line 306
      if (tmp___18 == 0) {
#line 306
        goto _L___0;
      } else {
        {
#line 306
        tmp___19 = strncmp((char const   *)*(argv + 0), "username", (size_t )8);
        }
#line 306
        if (tmp___19 == 0) {
          _L___0: /* CIL Label */ 
          {
#line 308
          ipmi_intf_session_set_username(intf, *(argv + 1));
          }
#line 309
          if ((unsigned long )intf->session == (unsigned long )((void *)0)) {
            {
#line 310
            lprintf(3, "Failed to set session username.");
            }
#line 311
            return (-1);
          }
          {
#line 313
          printf((char const   */* __restrict  */)"Set session username to %s\n",
                 (intf->session)->username);
          }
        } else {
          {
#line 316
          tmp___16 = strncmp((char const   *)*(argv + 0), "pass", (size_t )4);
          }
#line 316
          if (tmp___16 == 0) {
#line 316
            goto _L;
          } else {
            {
#line 316
            tmp___17 = strncmp((char const   *)*(argv + 0), "password", (size_t )8);
            }
#line 316
            if (tmp___17 == 0) {
              _L: /* CIL Label */ 
              {
#line 318
              ipmi_intf_session_set_password(intf, *(argv + 1));
              }
#line 319
              if ((unsigned long )intf->session == (unsigned long )((void *)0)) {
                {
#line 320
                lprintf(3, "Failed to set session password.");
                }
#line 321
                return (-1);
              }
              {
#line 323
              printf((char const   */* __restrict  */)"Set session password\n");
              }
            } else {
              {
#line 325
              tmp___15 = strncmp((char const   *)*(argv + 0), "authtype", (size_t )8);
              }
#line 325
              if (tmp___15 == 0) {
                {
#line 327
                tmp___4 = str2val((char const   *)*(argv + 1), ipmi_authtype_session_vals);
#line 327
                authtype = (int )tmp___4;
                }
#line 328
                if (authtype == 255) {
                  {
#line 329
                  lprintf(3, "Invalid authtype: %s", *(argv + 1));
                  }
#line 331
                  return (-1);
                }
                {
#line 333
                ipmi_intf_session_set_authtype(intf, (uint8_t )authtype);
                }
#line 334
                if ((unsigned long )intf->session == (unsigned long )((void *)0)) {
                  {
#line 335
                  lprintf(3, "Failed to set session authtype.");
                  }
#line 336
                  return (-1);
                }
                {
#line 338
                tmp___5 = val2str((uint16_t )(intf->session)->authtype_set, ipmi_authtype_session_vals);
#line 338
                printf((char const   */* __restrict  */)"Set session authtype to %s\n",
                       tmp___5);
                }
              } else {
                {
#line 342
                tmp___14 = strncmp((char const   *)*(argv + 0), "privlvl", (size_t )7);
                }
#line 342
                if (tmp___14 == 0) {
                  {
#line 344
                  tmp___6 = str2val((char const   *)*(argv + 1), ipmi_privlvl_vals);
#line 344
                  privlvl = (int )tmp___6;
                  }
#line 345
                  if (privlvl == 255) {
                    {
#line 346
                    lprintf(3, "Invalid privilege level: %s", *(argv + 1));
                    }
#line 348
                    return (-1);
                  }
                  {
#line 350
                  ipmi_intf_session_set_privlvl(intf, (uint8_t )privlvl);
                  }
#line 351
                  if ((unsigned long )intf->session == (unsigned long )((void *)0)) {
                    {
#line 352
                    lprintf(3, "Failed to set session privilege level.");
                    }
#line 354
                    return (-1);
                  }
                  {
#line 356
                  tmp___7 = val2str((uint16_t )(intf->session)->privlvl, ipmi_privlvl_vals);
#line 356
                  printf((char const   */* __restrict  */)"Set session privilege level to %s\n",
                         tmp___7);
                  }
                } else {
                  {
#line 360
                  tmp___13 = strncmp((char const   *)*(argv + 0), "port", (size_t )4);
                  }
#line 360
                  if (tmp___13 == 0) {
                    {
#line 361
                    port = 0;
#line 362
                    tmp___8 = str2int((char const   *)*(argv + 1), & port);
                    }
#line 362
                    if (tmp___8 != 0) {
                      {
#line 363
                      lprintf(3, "Given port \'%s\' is invalid.", *(argv + 1));
                      }
#line 365
                      return (-1);
                    } else
#line 362
                    if (port > 65535) {
                      {
#line 363
                      lprintf(3, "Given port \'%s\' is invalid.", *(argv + 1));
                      }
#line 365
                      return (-1);
                    }
                    {
#line 367
                    ipmi_intf_session_set_port(intf, port);
                    }
#line 368
                    if ((unsigned long )intf->session == (unsigned long )((void *)0)) {
                      {
#line 369
                      lprintf(3, "Failed to set session port.");
                      }
#line 370
                      return (-1);
                    }
                    {
#line 372
                    printf((char const   */* __restrict  */)"Set session port to %d\n",
                           (intf->session)->port);
                    }
                  } else {
                    {
#line 374
                    tmp___12 = strncmp((char const   *)*(argv + 0), "localaddr", (size_t )9);
                    }
#line 374
                    if (tmp___12 == 0) {
                      {
#line 375
                      my_addr = (uint8_t )0;
#line 376
                      tmp___9 = str2uchar((char const   *)*(argv + 1), & my_addr);
                      }
#line 376
                      if (tmp___9 != 0) {
                        {
#line 377
                        lprintf(3, "Given localaddr \'%s\' is invalid.", *(argv + 1));
                        }
#line 379
                        return (-1);
                      }
                      {
#line 381
                      intf->my_addr = (uint32_t )my_addr;
#line 382
                      printf((char const   */* __restrict  */)"Set local IPMB address to 0x%02x\n",
                             intf->my_addr);
                      }
                    } else {
                      {
#line 384
                      tmp___11 = strncmp((char const   *)*(argv + 0), "targetaddr",
                                         (size_t )10);
                      }
#line 384
                      if (tmp___11 == 0) {
                        {
#line 385
                        target_addr = (uint8_t )0;
#line 386
                        tmp___10 = str2uchar((char const   *)*(argv + 1), & target_addr);
                        }
#line 386
                        if (tmp___10 != 0) {
                          {
#line 387
                          lprintf(3, "Given targetaddr \'%s\' is invalid.", *(argv + 1));
                          }
#line 389
                          return (-1);
                        }
                        {
#line 391
                        intf->target_addr = (uint32_t )target_addr;
#line 392
                        printf((char const   */* __restrict  */)"Set remote IPMB address to 0x%02x\n",
                               intf->target_addr);
                        }
                      } else {
                        {
#line 395
                        ipmi_set_usage();
                        }
#line 396
                        return (-1);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 398
  return (0);
}
}
#line 401 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmishell.c"
int ipmi_exec_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  FILE *fp ;
  char buf[2048] ;
  char *ptr ;
  char *tok ;
  char *ret ;
  char *tmp ;
  int __argc ;
  int i ;
  int r ;
  char *__argv[64] ;
  int rc ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;

  {
#line 408
  rc = 0;
#line 410
  if (argc < 1) {
    {
#line 411
    lprintf(3, "Usage: exec <filename>");
    }
#line 412
    return (-1);
  }
  {
#line 415
  fp = ipmi_open_file((char const   *)*(argv + 0), 0);
  }
#line 416
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 417
    return (-1);
  }
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 419
    tmp___10 = feof(fp);
    }
#line 419
    if (! (tmp___10 == 0)) {
#line 419
      goto while_break;
    }
    {
#line 420
    ret = fgets((char */* __restrict  */)(buf), 2048, (FILE */* __restrict  */)fp);
    }
#line 421
    if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 422
      goto while_continue;
    }
    {
#line 425
    ptr = strchr((char const   *)(buf), '#');
    }
#line 426
    if (ptr) {
#line 427
      *ptr = (char )'\000';
    } else {
      {
#line 429
      tmp___0 = strlen((char const   *)(buf));
#line 429
      ptr = buf + tmp___0;
      }
    }
#line 432
    ptr = buf;
    {
#line 433
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 433
      if (! ((int )*ptr != 0)) {
#line 433
        goto while_break___0;
      }
#line 434
      if ((int )*ptr == 34) {
#line 435
        ptr ++;
        {
#line 436
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 436
          if ((int )*ptr != 34) {
#line 436
            if (! ((int )*ptr != 0)) {
#line 436
              goto while_break___1;
            }
          } else {
#line 436
            goto while_break___1;
          }
          {
#line 437
          tmp___1 = __ctype_b_loc();
          }
#line 437
          if ((int const   )*(*tmp___1 + (int )*ptr) & 8192) {
#line 438
            *ptr = (char )'~';
          }
#line 439
          ptr ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 442
      if ((int )*ptr == 39) {
#line 443
        ptr ++;
        {
#line 444
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 444
          if ((int )*ptr != 39) {
#line 444
            if (! ((int )*ptr != 0)) {
#line 444
              goto while_break___2;
            }
          } else {
#line 444
            goto while_break___2;
          }
          {
#line 445
          tmp___2 = __ctype_b_loc();
          }
#line 445
          if ((int const   )*(*tmp___2 + (int )*ptr) & 8192) {
#line 446
            *ptr = (char )'~';
          }
#line 447
          ptr ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 450
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 454
    ptr --;
    {
#line 455
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 455
      tmp___4 = __ctype_b_loc();
      }
#line 455
      if ((int const   )*(*tmp___4 + (int )*ptr) & 8192) {
#line 455
        if (! ((unsigned long )ptr >= (unsigned long )(buf))) {
#line 455
          goto while_break___3;
        }
      } else {
#line 455
        goto while_break___3;
      }
#line 456
      tmp___3 = ptr;
#line 456
      ptr --;
#line 456
      *tmp___3 = (char )'\000';
    }
    while_break___3: /* CIL Label */ ;
    }
#line 457
    ptr = buf;
    {
#line 458
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 458
      tmp___5 = __ctype_b_loc();
      }
#line 458
      if (! ((int const   )*(*tmp___5 + (int )*ptr) & 8192)) {
#line 458
        goto while_break___4;
      }
#line 459
      ptr ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 460
    tmp___6 = strlen((char const   *)ptr);
    }
#line 460
    if (tmp___6 == 0UL) {
#line 461
      goto while_continue;
    }
    {
#line 464
    __argc = 0;
#line 465
    tok = strtok((char */* __restrict  */)ptr, (char const   */* __restrict  */)" ");
    }
    {
#line 465
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 465
      if (! ((unsigned long )tok != (unsigned long )((void *)0))) {
#line 465
        goto while_break___5;
      }
#line 466
      if (__argc < 64) {
        {
#line 467
        tmp___7 = __argc;
#line 467
        __argc ++;
#line 467
        __argv[tmp___7] = strdup((char const   *)tok);
        }
#line 468
        if ((unsigned long )__argv[__argc - 1] == (unsigned long )((void *)0)) {
          {
#line 469
          lprintf(3, "ipmitool: malloc failure");
          }
#line 470
          return (-1);
        }
#line 472
        tmp = __argv[__argc - 1];
#line 473
        if ((int )*tmp == 39) {
          {
#line 474
          tmp___8 = strlen((char const   *)tmp);
#line 474
          memmove((void *)tmp, (void const   *)(tmp + 1), tmp___8);
          }
          {
#line 475
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 475
            if ((int )*tmp != 39) {
#line 475
              if (! ((int )*tmp != 0)) {
#line 475
                goto while_break___6;
              }
            } else {
#line 475
              goto while_break___6;
            }
#line 476
            if ((int )*tmp == 126) {
#line 477
              *tmp = (char )' ';
            }
#line 478
            tmp ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 480
          *tmp = (char )'\000';
        }
#line 482
        if ((int )*tmp == 34) {
          {
#line 483
          tmp___9 = strlen((char const   *)tmp);
#line 483
          memmove((void *)tmp, (void const   *)(tmp + 1), tmp___9);
          }
          {
#line 484
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 484
            if ((int )*tmp != 34) {
#line 484
              if (! ((int )*tmp != 0)) {
#line 484
                goto while_break___7;
              }
            } else {
#line 484
              goto while_break___7;
            }
#line 485
            if ((int )*tmp == 126) {
#line 486
              *tmp = (char )' ';
            }
#line 487
            tmp ++;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 489
          *tmp = (char )'\000';
        }
      }
      {
#line 465
      tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 495
    r = ipmi_cmd_run(intf, __argv[0], __argc - 1, & __argv[1]);
    }
#line 496
    if (r != 0) {
#line 497
      rc = r;
    }
#line 500
    i = 0;
    {
#line 500
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 500
      if (! (i < __argc)) {
#line 500
        goto while_break___8;
      }
#line 501
      if ((unsigned long )__argv[i] != (unsigned long )((void *)0)) {
        {
#line 502
        free((void *)__argv[i]);
#line 503
        __argv[i] = (char *)((void *)0);
        }
      }
#line 500
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 508
  fclose(fp);
  }
#line 509
  return (rc);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 249 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime_r)(time_t const   * __restrict  __timer ,
                                                                                      struct tm * __restrict  __tp ) ;
#line 261
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) asctime)(struct tm  const  *__tp ) ;
#line 127 "../include/ipmitool/ipmi_dcmi.h"
int ipmi_dcmi_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 863 "../include/ipmitool/ipmi_sdr.h"
extern struct ipmi_sdr_iterator *ipmi_sdr_start(struct ipmi_intf *intf , int use_builtin ) ;
#line 865
extern struct sdr_get_rs *ipmi_sdr_get_next_header(struct ipmi_intf *intf , struct ipmi_sdr_iterator *i ) ;
#line 867
extern uint8_t *ipmi_sdr_get_record(struct ipmi_intf *intf , struct sdr_get_rs *header ,
                                    struct ipmi_sdr_iterator *i ) ;
#line 869
extern void ipmi_sdr_end(struct ipmi_intf *intf , struct ipmi_sdr_iterator *i ) ;
#line 874
extern int ipmi_sdr_print_rawentry(struct ipmi_intf *intf , uint8_t type , uint8_t *raw ,
                                   int len ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_print_sensor_info(struct ipmi_intf *intf , uint16_t rec_id ) ;
#line 77 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct dcmi_cmd  const  dcmi_cmd_vals[13]  = 
#line 77
  {      {(uint16_t )0, "discover", "           Used to discover supported DCMI capabilities"}, 
        {(uint16_t )1,
      "power", "              Platform power limit command options"}, 
        {(uint16_t )2, "sensors", "            Prints the available DCMI sensors"}, 
        {(uint16_t )3, "asset_tag", "          Prints the platform\'s asset tag"}, 
        {(uint16_t )4, "set_asset_tag", "      Sets the platform\'s asset tag"}, 
        {(uint16_t )5, "get_mc_id_string", "   Get management controller ID string"}, 
        {(uint16_t )6,
      "set_mc_id_string", "   Set management controller ID string"}, 
        {(uint16_t )7, "thermalpolicy", "      Thermal policy get/set"}, 
        {(uint16_t )8, "get_temp_reading", "   Get Temperature Readings"}, 
        {(uint16_t )9, "get_conf_param", "     Get DCMI Config Parameters"}, 
        {(uint16_t )10, "set_conf_param", "     Set DCMI Config Parameters"}, 
        {(uint16_t )11, "oob_discover", "       Ping/Pong Message for DCMI Discovery"}, 
        {(uint16_t )255,
      (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 94 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct dcmi_cmd  const  dcmi_capable_vals[5]  = {      {(uint16_t )1, "platform", "            Lists the system capabilities"}, 
        {(uint16_t )2, "mandatory_attributes", "Lists SEL, identification andtemperature attributes"}, 
        {(uint16_t )3,
      "optional_attributes", " Lists power capabilities"}, 
        {(uint16_t )4, "managebility access", " Lists OOB channel information"}, 
        {(uint16_t )255, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 107 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct dcmi_cmd  const  dcmi_mandatory_platform_capabilities[5]  = {      {(uint16_t )1, "Identification support available", ""}, 
        {(uint16_t )2, "SEL logging available", ""}, 
        {(uint16_t )3, "Chassis power available", ""}, 
        {(uint16_t )4, "Temperature monitor available", ""}, 
        {(uint16_t )255, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 116 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct dcmi_cmd  const  dcmi_optional_platform_capabilities[2]  = {      {(uint16_t )1, "Power management available", ""}, 
        {(uint16_t )255, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 122 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct dcmi_cmd  const  dcmi_management_access_capabilities[7]  = {      {(uint16_t )1, "In-band KCS channel available", ""}, 
        {(uint16_t )2, "Out-of-band serial TMODE available", ""}, 
        {(uint16_t )3, "Out-of-band secondary LAN channel available", ""}, 
        {(uint16_t )4, "Out-of-band primary LAN channel available", ""}, 
        {(uint16_t )5, "SOL enabled", ""}, 
        {(uint16_t )6, "VLAN capable", ""}, 
        {(uint16_t )255, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 133 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct dcmi_cmd  const  dcmi_id_capabilities_vals[4]  = {      {(uint16_t )1, "GUID", ""}, 
        {(uint16_t )2, "DHCP hostname", ""}, 
        {(uint16_t )3, "Asset tag", ""}, 
        {(uint16_t )255, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 141 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct dcmi_cmd  const  dcmi_conf_param_vals[6]  = {      {(uint16_t )1, "activate_dhcp", "\tActivate DHCP"}, 
        {(uint16_t )2, "dhcp_config", "\tDHCP Configuration"}, 
        {(uint16_t )3, "init", "\t\tInitial timeout interval"}, 
        {(uint16_t )4, "timeout", "\t\tServer contact timeout interval"}, 
        {(uint16_t )5, "retry", "\t\tServer contact retry interval"}, 
        {(uint16_t )255, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 152 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct dcmi_cmd  const  dcmi_temp_monitoring_vals[4]  = {      {(uint16_t )1, "inlet", "    Inlet air temperature sensors"}, 
        {(uint16_t )2, "cpu", "      CPU temperature sensors"}, 
        {(uint16_t )3, "baseboard", "Baseboard temperature sensors"}, 
        {(uint16_t )255, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 163 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct dcmi_cmd  const  dcmi_discvry_snsr_vals[4]  = {      {(uint16_t )64, "Inlet", "    Inlet air temperature sensors"}, 
        {(uint16_t )65, "CPU", "      CPU temperature sensors"}, 
        {(uint16_t )66, "Baseboard", "Baseboard temperature sensors"}, 
        {(uint16_t )255, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 171 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct dcmi_cmd  const  dcmi_temp_read_vals[4]  = {      {(uint16_t )64, "Inlet", "Inlet air temperature(40h)         "}, 
        {(uint16_t )65, "CPU", "CPU temperature sensors(41h)       "}, 
        {(uint16_t )66, "Baseboard", "Baseboard temperature sensors(42h) "}, 
        {(uint16_t )255, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 179 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct dcmi_cmd  const  dcmi_pwrmgmt_vals[6]  = {      {(uint16_t )0, "reading", "   Get power related readings from the system"}, 
        {(uint16_t )1, "get_limit", " Get the configured power limits"}, 
        {(uint16_t )2, "set_limit", " Set a power limit option"}, 
        {(uint16_t )3, "activate", "  Activate the set power limit"}, 
        {(uint16_t )4, "deactivate", "Deactivate the set power limit"}, 
        {(uint16_t )255, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 189 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct dcmi_cmd  const  dcmi_pwrmgmt_set_usage_vals[5]  = {      {(uint16_t )0, "action", "    <sel_logging | power_off>"}, 
        {(uint16_t )1, "limit", "     <number in Watts>"}, 
        {(uint16_t )2, "correction", "<number in milliseconds>"}, 
        {(uint16_t )3, "sample", "    <number in seconds>"}, 
        {(uint16_t )255, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 198 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct dcmi_cmd  const  dcmi_pwrmgmt_action_vals[4]  = {      {(uint16_t )0, "No Action", ""}, 
        {(uint16_t )1, "Hard Power Off & Log Event to SEL", ""}, 
        {(uint16_t )17, "Log Event to SEL", ""}, 
        {(uint16_t )255, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 206 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct dcmi_cmd  const  dcmi_thermalpolicy_vals[3]  = {      {(uint16_t )0, "get", "Get thermal policy"}, 
        {(uint16_t )1, "set", "Set thermal policy"}, 
        {(uint16_t )255, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 213 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct dcmi_cmd  const  dcmi_confparameters_vals[3]  = {      {(uint16_t )0, "get", "Get configuration parameters"}, 
        {(uint16_t )1, "set", "Set configuration parameters"}, 
        {(uint16_t )255, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 220 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct dcmi_cmd  const  dcmi_thermalpolicy_set_parameters_vals[8]  = 
#line 220
  {      {(uint16_t )0, "volatile", "   Current Power Cycle"}, 
        {(uint16_t )1, "nonvolatile", "Set across power cycles"}, 
        {(uint16_t )1, "poweroff", "   Hard Power Off system"}, 
        {(uint16_t )0, "nopoweroff", " No \'Hard Power Off\' action"}, 
        {(uint16_t )1, "sel", "        Log event to SEL"}, 
        {(uint16_t )0, "nosel", "      No \'Log event to SEL\' action"}, 
        {(uint16_t )0, "disabled", "   Disabled"}, 
        {(uint16_t )0, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 244 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct valstr  const  dcmi_ccode_vals[9]  = 
#line 244
  {      {(uint16_t )128, "Parameter not supported"}, 
        {(uint16_t )129, "Something else has already claimed these parameters"}, 
        {(uint16_t )130, "Not supported or failed to write a read-only parameter"}, 
        {(uint16_t )131, "Access mode is not supported"}, 
        {(uint16_t )132, "Power/Thermal limit out of range"}, 
        {(uint16_t )133, "Correction/Exception time out of range"}, 
        {(uint16_t )137, "Sample/Statistics Reporting period out of range"}, 
        {(uint16_t )138, "Power limit already active"}, 
        {(uint16_t )255, (char const   *)((void *)0)}};
#line 269 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
void print_strs(struct dcmi_cmd  const  *vs , char const   *title , int loglevel ,
                int verthorz ) 
{ 
  int i ;

  {
#line 275
  if ((unsigned long )vs == (unsigned long )((void *)0)) {
#line 276
    return;
  }
#line 278
  if ((unsigned long )title != (unsigned long )((void *)0)) {
#line 279
    if (loglevel < 0) {
      {
#line 280
      printf((char const   */* __restrict  */)"\n%s\n", title);
      }
    } else {
      {
#line 282
      lprintf(loglevel, "\n%s", title);
      }
    }
  }
#line 284
  i = 0;
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    if (! ((unsigned long )(vs + i)->str != (unsigned long )((void *)0))) {
#line 284
      goto while_break;
    }
#line 285
    if (loglevel < 0) {
#line 286
      if ((int const   )(vs + i)->val < 256) {
#line 287
        if (verthorz == 0) {
          {
#line 288
          printf((char const   */* __restrict  */)"    %s    %s\n", (vs + i)->str,
                 (vs + i)->desc);
          }
        } else {
          {
#line 290
          printf((char const   */* __restrict  */)"%s", (vs + i)->str);
          }
        }
      } else
#line 291
      if (verthorz == 0) {
        {
#line 292
        printf((char const   */* __restrict  */)"    %s    %s\n", (vs + i)->str, (vs + i)->desc);
        }
      } else {
        {
#line 294
        printf((char const   */* __restrict  */)"%s", (vs + i)->str);
        }
      }
    } else
#line 296
    if ((int const   )(vs + i)->val < 256) {
      {
#line 297
      lprintf(loglevel, "    %s    %s", (vs + i)->str, (vs + i)->desc);
      }
    } else {
      {
#line 299
      lprintf(loglevel, "    %s    %s", (vs + i)->str, (vs + i)->desc);
      }
    }
#line 304
    if (verthorz == 1) {
#line 304
      if ((unsigned long )(vs + (i + 1))->str != (unsigned long )((void *)0)) {
        {
#line 305
        printf((char const   */* __restrict  */)" | ");
        }
      }
    }
#line 284
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  if (verthorz == 0) {
#line 308
    if (loglevel < 0) {
      {
#line 309
      printf((char const   */* __restrict  */)"\n");
      }
    } else {
      {
#line 311
      lprintf(loglevel, "");
      }
    }
  }
#line 314
  return;
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
uint16_t str2val2(char const   *str___1 , struct dcmi_cmd  const  *vs ) 
{ 
  int i ;
  int x ;
  size_t tmp ;
  int y ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 328
  if ((unsigned long )vs == (unsigned long )((void *)0)) {
#line 329
    return ((uint16_t )0);
  } else
#line 328
  if ((unsigned long )str___1 == (unsigned long )((void *)0)) {
#line 329
    return ((uint16_t )0);
  }
#line 331
  i = 0;
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    if (! ((unsigned long )(vs + i)->str != (unsigned long )((void *)0))) {
#line 331
      goto while_break;
    }
    {
#line 333
    tmp = strlen(str___1);
#line 333
    x = (int )tmp;
#line 333
    tmp___0 = strlen((char const   *)(vs + i)->str);
#line 333
    y = (int )tmp___0;
    }
#line 333
    if (x > y) {
#line 333
      tmp___1 = x;
    } else {
#line 333
      tmp___1 = y;
    }
    {
#line 333
    tmp___2 = strncasecmp((char const   *)(vs + i)->str, str___1, (size_t )tmp___1);
    }
#line 333
    if (tmp___2 == 0) {
#line 334
      return ((uint16_t )(vs + i)->val);
    }
#line 331
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 337
  return ((uint16_t )(vs + i)->val);
}
}
#line 351 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static char un_str___1[32]  ;
#line 348 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
char const   *val2str2(uint16_t val , struct dcmi_cmd  const  *vs ) 
{ 
  int i ;

  {
#line 354
  if ((unsigned long )vs == (unsigned long )((void *)0)) {
#line 355
    return ((char const   *)((void *)0));
  }
#line 357
  i = 0;
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (! ((unsigned long )(vs + i)->str != (unsigned long )((void *)0))) {
#line 357
      goto while_break;
    }
#line 358
    if ((int const   )(vs + i)->val == (int const   )val) {
#line 359
      return ((char const   *)(vs + i)->str);
    }
#line 357
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 361
  memset((void *)(un_str___1), 0, (size_t )32);
#line 362
  snprintf((char */* __restrict  */)(un_str___1), (size_t )32, (char const   */* __restrict  */)"Unknown (0x%x)",
           (int )val);
  }
#line 363
  return ((char const   *)(un_str___1));
}
}
#line 369 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int chk_rsp(struct ipmi_rs *rsp ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 375
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 376
    lprintf(3, "\n    Unable to get DCMI information");
    }
#line 377
    return (1);
  }
#line 383
  if ((int )rsp->ccode >= 128) {
#line 383
    if ((int )rsp->ccode <= 143) {
      {
#line 384
      tmp = val2str((uint16_t )rsp->ccode, dcmi_ccode_vals);
#line 384
      lprintf(3, "\n    DCMI request failed because: %s (%x)", tmp, (int )rsp->ccode);
      }
#line 386
      return (1);
    } else {
#line 383
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 387
  if ((int )rsp->ccode > 0) {
    {
#line 388
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 388
    lprintf(3, "\n    DCMI request failed because: %s (%x)", tmp___0, (int )rsp->ccode);
    }
#line 390
    return (1);
  }
#line 393
  if ((int )rsp->data[0] != 220) {
    {
#line 394
    printf((char const   */* __restrict  */)"\n    A valid DCMI command was not returned! (%x)",
           (int )rsp->data[0]);
    }
#line 395
    return (1);
  }
#line 397
  return (0);
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct ipmi_rs *ipmi_dcmi_getcapabilities(struct ipmi_intf *intf , uint8_t selector ) 
{ 
  struct ipmi_rq req ;
  uint8_t msg_data[2] ;
  struct ipmi_rs *tmp ;

  {
  {
#line 417
  msg_data[0] = (uint8_t )220;
#line 418
  msg_data[1] = selector;
#line 420
  memset((void *)(& req), 0, sizeof(req));
#line 421
  req.msg.netfn = (uint8_t )44;
#line 422
  req.msg.cmd = (uint8_t )1;
#line 423
  req.msg.data = msg_data;
#line 424
  req.msg.data_len = (uint16_t )2;
#line 426
  tmp = (*(intf->sendrecv))(intf, & req);
  }
#line 426
  return (tmp);
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
void display_capabilities_attributes(struct dcmi_cmd  const  *cmd , uint8_t data_val ) 
{ 
  uint8_t i ;
  char const   *tmp ;

  {
#line 440
  i = (uint8_t )1;
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (! ((int const   )(cmd + ((int )i - 1))->val != 255)) {
#line 440
      goto while_break;
    }
#line 441
    if ((int )data_val & (1 << ((int )i - 1))) {
      {
#line 442
      tmp = val2str2((uint16_t )i, cmd);
#line 442
      printf((char const   */* __restrict  */)"        %s\n", tmp);
      }
    }
#line 440
    i = (uint8_t )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 445
  return;
}
}
#line 447 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_prnt_oobDiscover(struct ipmi_intf *intf ) 
{ 


  {
  {
#line 451
  lprintf(3, "DCMI Discovery is available only when LANplus(IPMI v2.0) is enabled.");
  }
#line 453
  return (-1);
}
}
#line 540 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_prnt_getcapabilities(struct ipmi_intf *intf , uint8_t selector ) 
{ 
  uint8_t bit_shifter ;
  struct capabilities cape ;
  struct ipmi_rs *rsp ;
  int tmp ;
  uint16_t sel_entries ;

  {
  {
#line 544
  bit_shifter = (uint8_t )0;
#line 547
  rsp = ipmi_dcmi_getcapabilities(intf, selector);
#line 549
  tmp = chk_rsp(rsp);
  }
#line 549
  if (tmp) {
#line 550
    return (-1);
  }
  {
#line 553
  memcpy((void */* __restrict  */)(& cape), (void const   */* __restrict  */)(rsp->data),
         sizeof(cape));
  }
#line 555
  if ((int )cape.conformance != 1) {
#line 555
    if ((int )cape.conformance != 257) {
#line 555
      if ((int )cape.conformance != 1281) {
        {
#line 558
        lprintf(3, "ERROR!  This command is not available on this platform");
        }
#line 560
        return (-1);
      }
    }
  }
#line 563
  if ((int )cape.revision != 1) {
#line 563
    if ((int )cape.revision != 2) {
      {
#line 564
      lprintf(3, "ERROR!  This command is not compatible with this version");
      }
#line 566
      return (-1);
    }
  }
  {
#line 576
  if ((int )selector == 1) {
#line 576
    goto case_1;
  }
#line 597
  if ((int )selector == 2) {
#line 597
    goto case_2;
  }
#line 626
  if ((int )selector == 3) {
#line 626
    goto case_3;
  }
#line 648
  if ((int )selector == 4) {
#line 648
    goto case_4;
  }
#line 671
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 577
  printf((char const   */* __restrict  */)"    Supported DCMI capabilities:\n");
#line 581
  printf((char const   */* __restrict  */)"\n         Mandatory platform capabilties\n");
#line 582
  display_capabilities_attributes(dcmi_mandatory_platform_capabilities, cape.data_byte1);
#line 587
  printf((char const   */* __restrict  */)"\n         Optional platform capabilties\n");
#line 588
  display_capabilities_attributes(dcmi_optional_platform_capabilities, cape.data_byte2);
#line 593
  printf((char const   */* __restrict  */)"\n         Managebility access capabilties\n");
#line 594
  display_capabilities_attributes(dcmi_management_access_capabilities, cape.data_byte3);
  }
#line 596
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 598
  printf((char const   */* __restrict  */)"\n    Mandatory platform attributes:\n");
#line 600
  printf((char const   */* __restrict  */)"\n         SEL Attributes: ");
#line 601
  printf((char const   */* __restrict  */)"\n               SEL automatic rollover is ");
  }
#line 605
  if ((int )cape.data_byte2 & 128) {
    {
#line 606
    printf((char const   */* __restrict  */)"enabled");
    }
  } else {
    {
#line 608
    printf((char const   */* __restrict  */)"not present");
    }
  }
  {
#line 613
  sel_entries = (uint16_t )cape.data_byte1;
#line 615
  sel_entries = (uint16_t )((int )sel_entries | ((int )((uint16_t )cape.data_byte2) << 8));
#line 616
  printf((char const   */* __restrict  */)"\n               %d SEL entries\n", (int )sel_entries & 4095);
#line 618
  printf((char const   */* __restrict  */)"\n         Identification Attributes: \n");
#line 619
  display_capabilities_attributes(dcmi_id_capabilities_vals, cape.data_byte3);
#line 622
  printf((char const   */* __restrict  */)"\n         Temperature Monitoring Attributes: \n");
#line 623
  display_capabilities_attributes(dcmi_temp_monitoring_vals, cape.data_byte4);
  }
#line 625
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 627
  printf((char const   */* __restrict  */)"\n    Optional Platform Attributes: \n");
#line 629
  printf((char const   */* __restrict  */)"\n         Power Management:\n");
  }
#line 630
  if ((int )cape.data_byte1 == 64) {
    {
#line 631
    printf((char const   */* __restrict  */)"                Slave address of device: 20h (BMC)\n");
    }
  } else {
    {
#line 633
    printf((char const   */* __restrict  */)"                Slave address of device: %xh (8bits)(Satellite/External controller)\n",
           (int )cape.data_byte1);
    }
  }
#line 638
  if ((int )cape.data_byte2 >> 4 == 0) {
    {
#line 639
    printf((char const   */* __restrict  */)"                Channel number is 0h (Primary BMC)\n");
    }
  } else {
    {
#line 641
    printf((char const   */* __restrict  */)"                Channel number is %xh \n",
           (int )cape.data_byte2 >> 4);
    }
  }
  {
#line 645
  printf((char const   */* __restrict  */)"                    Device revision is %d \n",
         (int )cape.data_byte2 & 15);
  }
#line 647
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 650
  printf((char const   */* __restrict  */)"\n    Manageability Access Attributes: \n");
  }
#line 651
  if ((int )cape.data_byte1 == 255) {
    {
#line 652
    printf((char const   */* __restrict  */)"         Primary LAN channel is not available for OOB\n");
    }
  } else {
    {
#line 654
    printf((char const   */* __restrict  */)"         Primary LAN channel number: %d is available\n",
           (int )cape.data_byte1);
    }
  }
#line 657
  if ((int )cape.data_byte2 == 255) {
    {
#line 658
    printf((char const   */* __restrict  */)"         Secondary LAN channel is not available for OOB\n");
    }
  } else {
    {
#line 660
    printf((char const   */* __restrict  */)"         Secondary LAN channel number: %d is available\n",
           (int )cape.data_byte2);
    }
  }
#line 664
  if ((int )cape.data_byte3 == 255) {
    {
#line 665
    printf((char const   */* __restrict  */)"         No serial channel is available\n");
    }
  } else {
    {
#line 667
    printf((char const   */* __restrict  */)"         Serial channel number: %d is available\n",
           (int )cape.data_byte3);
    }
  }
#line 670
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 672
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 674
  return (0);
}
}
#line 688 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct ipmi_rs *ipmi_dcmi_getassettag(struct ipmi_intf *intf , uint8_t offset , uint8_t length ) 
{ 
  struct ipmi_rq req ;
  uint8_t msg_data[3] ;
  struct ipmi_rs *tmp ;

  {
  {
#line 694
  msg_data[0] = (uint8_t )220;
#line 695
  msg_data[1] = offset;
#line 696
  msg_data[2] = length;
#line 698
  memset((void *)(& req), 0, sizeof(req));
#line 699
  req.msg.netfn = (uint8_t )44;
#line 700
  req.msg.cmd = (uint8_t )6;
#line 701
  req.msg.data = msg_data;
#line 702
  req.msg.data_len = (uint16_t )3;
#line 703
  tmp = (*(intf->sendrecv))(intf, & req);
  }
#line 703
  return (tmp);
}
}
#line 716 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_prnt_getassettag(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  uint8_t taglength ;
  uint8_t getlength ;
  uint8_t offset ;
  uint8_t i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 721
  taglength = (uint8_t )0;
#line 722
  getlength = (uint8_t )0;
#line 723
  offset = (uint8_t )0;
#line 726
  rsp = ipmi_dcmi_getassettag(intf, (uint8_t )0, (uint8_t )0);
#line 727
  tmp = chk_rsp(rsp);
  }
#line 727
  if (tmp) {
#line 728
    return (-1);
  }
  {
#line 730
  taglength = rsp->data[1];
#line 731
  printf((char const   */* __restrict  */)"\n Asset tag: ");
  }
  {
#line 732
  while (1) {
    while_continue: /* CIL Label */ ;
#line 732
    if (! taglength) {
#line 732
      goto while_break;
    }
#line 733
    if ((int )taglength / 16) {
#line 733
      getlength = (uint8_t )16;
    } else {
#line 733
      getlength = (uint8_t )((int )taglength % 16);
    }
    {
#line 735
    rsp = ipmi_dcmi_getassettag(intf, offset, getlength);
    }
#line 739
    if ((unsigned long )rsp != (unsigned long )((void *)0)) {
#line 740
      if ((int )rsp->ccode == 128) {
#line 740
        rsp->ccode = (uint8_t )0;
      } else
#line 740
      if ((int )rsp->ccode == 129) {
#line 740
        rsp->ccode = (uint8_t )0;
      } else
#line 740
      if ((int )rsp->ccode == 130) {
#line 740
        rsp->ccode = (uint8_t )0;
      } else
#line 740
      if ((int )rsp->ccode == 131) {
#line 740
        rsp->ccode = (uint8_t )0;
      } else {
#line 740
        rsp->ccode = rsp->ccode;
      }
    }
    {
#line 742
    tmp___0 = chk_rsp(rsp);
    }
#line 742
    if (tmp___0) {
#line 743
      return (-1);
    }
#line 745
    i = (uint8_t )0;
    {
#line 745
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 745
      if (! ((int )i < (int )getlength)) {
#line 745
        goto while_break___0;
      }
      {
#line 746
      printf((char const   */* __restrict  */)"%c", (int )rsp->data[(int )i + 2]);
#line 745
      i = (uint8_t )((int )i + 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 748
    offset = (uint8_t )((int )offset + (int )getlength);
#line 749
    taglength = (uint8_t )((int )taglength - (int )getlength);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 751
  printf((char const   */* __restrict  */)"\n");
  }
#line 752
  return (0);
}
}
#line 766 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct ipmi_rs *ipmi_dcmi_setassettag(struct ipmi_intf *intf , uint8_t offset , uint8_t length ,
                                      uint8_t *data ) 
{ 
  struct ipmi_rq req ;
  uint8_t *msg_data ;
  unsigned long __lengthofmsg_data ;
  void *tmp ;
  struct ipmi_rs *tmp___0 ;

  {
  {
#line 771
  __lengthofmsg_data = (unsigned long )(3 + (int )length);
#line 771
  tmp = __builtin_alloca(sizeof(*msg_data) * __lengthofmsg_data);
#line 771
  msg_data = (uint8_t *)tmp;
#line 773
  *(msg_data + 0) = (uint8_t )220;
#line 774
  *(msg_data + 1) = offset;
#line 775
  *(msg_data + 2) = length;
#line 777
  memset((void *)(& req), 0, sizeof(req));
#line 778
  req.msg.netfn = (uint8_t )44;
#line 779
  req.msg.cmd = (uint8_t )8;
#line 780
  req.msg.data = msg_data;
#line 782
  req.msg.data_len = (uint16_t )((int )length + 3);
#line 783
  memcpy((void */* __restrict  */)(req.msg.data + 3), (void const   */* __restrict  */)data,
         (size_t )length);
#line 785
  tmp___0 = (*(intf->sendrecv))(intf, & req);
  }
#line 785
  return (tmp___0);
}
}
#line 788 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_prnt_setassettag(struct ipmi_intf *intf , uint8_t *data ) 
{ 
  struct ipmi_rs *rsp ;
  uint8_t tmpData[16] ;
  uint8_t taglength ;
  uint8_t getlength ;
  uint8_t offset ;
  uint8_t i ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 794
  taglength = (uint8_t )0;
#line 795
  getlength = (uint8_t )0;
#line 796
  offset = (uint8_t )0;
#line 800
  tmp = strlen((char const   *)data);
#line 800
  taglength = (uint8_t )tmp;
  }
#line 801
  if ((int )taglength > 64) {
    {
#line 802
    lprintf(3, "\nValue is too long.");
    }
#line 803
    return (-1);
  }
  {
#line 805
  printf((char const   */* __restrict  */)"\n Set Asset Tag: ");
  }
  {
#line 806
  while (1) {
    while_continue: /* CIL Label */ ;
#line 806
    if (! taglength) {
#line 806
      goto while_break;
    }
#line 807
    if ((int )taglength / 16) {
#line 807
      getlength = (uint8_t )16;
    } else {
#line 807
      getlength = (uint8_t )((int )taglength % 16);
    }
    {
#line 809
    memcpy((void */* __restrict  */)(tmpData), (void const   */* __restrict  */)(data + (int )offset),
           (size_t )getlength);
#line 810
    rsp = ipmi_dcmi_setassettag(intf, offset, getlength, tmpData);
#line 811
    tmp___0 = chk_rsp(rsp);
    }
#line 811
    if (tmp___0) {
#line 812
      return (-1);
    }
#line 814
    i = (uint8_t )0;
    {
#line 814
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 814
      if (! ((int )i < (int )getlength)) {
#line 814
        goto while_break___0;
      }
      {
#line 815
      printf((char const   */* __restrict  */)"%c", (int )tmpData[i]);
#line 814
      i = (uint8_t )((int )i + 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 817
    offset = (uint8_t )((int )offset + (int )getlength);
#line 818
    taglength = (uint8_t )((int )taglength - (int )getlength);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 820
  printf((char const   */* __restrict  */)"\n");
  }
#line 821
  return (0);
}
}
#line 833 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct ipmi_rs *ipmi_dcmi_getmngctrlids(struct ipmi_intf *intf , uint8_t offset ,
                                        uint8_t length ) 
{ 
  struct ipmi_rq req ;
  uint8_t msg_data[3] ;
  struct ipmi_rs *tmp ;

  {
  {
#line 839
  msg_data[0] = (uint8_t )220;
#line 840
  msg_data[1] = offset;
#line 841
  msg_data[2] = length;
#line 843
  memset((void *)(& req), 0, sizeof(req));
#line 844
  req.msg.netfn = (uint8_t )44;
#line 845
  req.msg.cmd = (uint8_t )9;
#line 846
  req.msg.data = msg_data;
#line 848
  req.msg.data_len = (uint16_t )3;
#line 849
  tmp = (*(intf->sendrecv))(intf, & req);
  }
#line 849
  return (tmp);
}
}
#line 852 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_prnt_getmngctrlids(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  uint8_t taglength ;
  uint8_t getlength ;
  uint8_t offset ;
  uint8_t i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 857
  taglength = (uint8_t )0;
#line 858
  getlength = (uint8_t )0;
#line 859
  offset = (uint8_t )0;
#line 863
  rsp = ipmi_dcmi_getmngctrlids(intf, (uint8_t )0, (uint8_t )1);
#line 865
  tmp = chk_rsp(rsp);
  }
#line 865
  if (tmp) {
#line 866
    return (-1);
  }
  {
#line 869
  taglength = rsp->data[1];
#line 871
  printf((char const   */* __restrict  */)"\n Get Management Controller Identifier String: ");
  }
  {
#line 872
  while (1) {
    while_continue: /* CIL Label */ ;
#line 872
    if (! taglength) {
#line 872
      goto while_break;
    }
#line 873
    if ((int )taglength / 16) {
#line 873
      getlength = (uint8_t )16;
    } else {
#line 873
      getlength = (uint8_t )((int )taglength % 16);
    }
    {
#line 875
    rsp = ipmi_dcmi_getmngctrlids(intf, offset, getlength);
#line 877
    tmp___0 = chk_rsp(rsp);
    }
#line 877
    if (tmp___0) {
#line 878
      return (-1);
    }
#line 880
    i = (uint8_t )0;
    {
#line 880
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 880
      if (! ((int )i < (int )getlength)) {
#line 880
        goto while_break___0;
      }
      {
#line 881
      printf((char const   */* __restrict  */)"%c", (int )rsp->data[(int )i + 2]);
#line 880
      i = (uint8_t )((int )i + 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 883
    offset = (uint8_t )((int )offset + (int )getlength);
#line 884
    taglength = (uint8_t )((int )taglength - (int )getlength);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 886
  printf((char const   */* __restrict  */)"\n");
  }
#line 887
  return (0);
}
}
#line 900 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct ipmi_rs *ipmi_dcmi_setmngctrlids(struct ipmi_intf *intf , uint8_t offset ,
                                        uint8_t length , uint8_t *data ) 
{ 
  struct ipmi_rq req ;
  uint8_t *msg_data ;
  unsigned long __lengthofmsg_data ;
  void *tmp ;
  struct ipmi_rs *tmp___0 ;

  {
  {
#line 905
  __lengthofmsg_data = (unsigned long )(3 + (int )length);
#line 905
  tmp = __builtin_alloca(sizeof(*msg_data) * __lengthofmsg_data);
#line 905
  msg_data = (uint8_t *)tmp;
#line 907
  *(msg_data + 0) = (uint8_t )220;
#line 908
  *(msg_data + 1) = offset;
#line 909
  *(msg_data + 2) = length;
#line 911
  memset((void *)(& req), 0, sizeof(req));
#line 912
  req.msg.netfn = (uint8_t )44;
#line 913
  req.msg.cmd = (uint8_t )10;
#line 914
  req.msg.data = msg_data;
#line 916
  req.msg.data_len = (uint16_t )(3 + (int )length);
#line 917
  memcpy((void */* __restrict  */)(req.msg.data + 3), (void const   */* __restrict  */)data,
         (size_t )length);
#line 919
  tmp___0 = (*(intf->sendrecv))(intf, & req);
  }
#line 919
  return (tmp___0);
}
}
#line 930 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_prnt_setmngctrlids(struct ipmi_intf *intf , uint8_t *data ) 
{ 
  struct ipmi_rs *rsp ;
  uint8_t tmpData[16] ;
  uint8_t taglength ;
  uint8_t getlength ;
  uint8_t offset ;
  uint8_t i ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 936
  taglength = (uint8_t )0;
#line 937
  getlength = (uint8_t )0;
#line 938
  offset = (uint8_t )0;
#line 941
  data += 0;
#line 942
  tmp = strlen((char const   *)data);
#line 942
  taglength = (uint8_t )(tmp + 1UL);
  }
#line 944
  if ((int )taglength > 64) {
    {
#line 945
    lprintf(3, "\nValue is too long.");
    }
#line 946
    return (-1);
  }
  {
#line 949
  printf((char const   */* __restrict  */)"\n Set Management Controller Identifier String Command: ");
  }
  {
#line 950
  while (1) {
    while_continue: /* CIL Label */ ;
#line 950
    if (! taglength) {
#line 950
      goto while_break;
    }
#line 951
    if ((int )taglength / 16) {
#line 951
      getlength = (uint8_t )16;
    } else {
#line 951
      getlength = (uint8_t )((int )taglength % 16);
    }
    {
#line 953
    memcpy((void */* __restrict  */)(tmpData), (void const   */* __restrict  */)(data + (int )offset),
           (size_t )getlength);
#line 954
    rsp = ipmi_dcmi_setmngctrlids(intf, offset, getlength, tmpData);
#line 958
    tmp___1 = strncmp((char const   *)(intf->name), "lanplus", (size_t )7);
    }
#line 958
    if (tmp___1) {
      {
#line 959
      tmp___0 = chk_rsp(rsp);
      }
#line 959
      if (tmp___0) {
#line 960
        return (-1);
      }
    }
#line 963
    i = (uint8_t )0;
    {
#line 963
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 963
      if (! ((int )i < (int )getlength)) {
#line 963
        goto while_break___0;
      }
      {
#line 964
      printf((char const   */* __restrict  */)"%c", (int )tmpData[i]);
#line 963
      i = (uint8_t )((int )i + 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 966
    offset = (uint8_t )((int )offset + (int )getlength);
#line 967
    taglength = (uint8_t )((int )taglength - (int )getlength);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 969
  printf((char const   */* __restrict  */)"\n");
  }
#line 970
  return (0);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct ipmi_rs *ipmi_dcmi_discvry_snsr(struct ipmi_intf *intf , uint8_t isnsr , uint8_t offset ) 
{ 
  struct ipmi_rq req ;
  uint8_t msg_data[5] ;
  struct ipmi_rs *tmp ;

  {
  {
#line 988
  msg_data[0] = (uint8_t )220;
#line 989
  msg_data[1] = (uint8_t )1;
#line 990
  msg_data[2] = isnsr;
#line 991
  msg_data[3] = (uint8_t )0;
#line 992
  msg_data[4] = offset;
#line 994
  memset((void *)(& req), 0, sizeof(req));
#line 995
  req.msg.netfn = (uint8_t )44;
#line 996
  req.msg.cmd = (uint8_t )7;
#line 997
  req.msg.data = msg_data;
#line 998
  req.msg.data_len = (uint16_t )5;
#line 1000
  tmp = (*(intf->sendrecv))(intf, & req);
  }
#line 1000
  return (tmp);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_prnt_discvry_snsr(struct ipmi_intf *intf , uint8_t isnsr ) 
{ 
  int i ;
  struct ipmi_rs *rsp ;
  uint8_t records ;
  int8_t instances ;
  uint8_t offset ;
  uint16_t record_id ;
  uint8_t id_buff[16] ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1014
  i = 0;
#line 1016
  records = (uint8_t )0;
#line 1017
  instances = (int8_t )0;
#line 1018
  offset = (uint8_t )0;
#line 1019
  record_id = (uint16_t )0;
#line 1021
  rsp = ipmi_dcmi_discvry_snsr(intf, isnsr, (uint8_t )0);
#line 1022
  tmp = chk_rsp(rsp);
  }
#line 1022
  if (tmp) {
#line 1023
    return (-1);
  }
#line 1025
  instances = (int8_t )rsp->data[1];
#line 1026
  if ((int )instances > 1) {
#line 1026
    tmp___0 = "s";
  } else {
#line 1026
    tmp___0 = "";
  }
  {
#line 1026
  tmp___1 = val2str2((uint16_t )isnsr, dcmi_discvry_snsr_vals);
#line 1026
  printf((char const   */* __restrict  */)"\n%s: %d temperature sensor%s found:\n",
         tmp___1, (int )instances, tmp___0);
  }
  {
#line 1030
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1030
    if (! ((int )instances > 0)) {
#line 1030
      goto while_break;
    }
    {
#line 1031
    ipmi_dcmi_discvry_snsr(intf, isnsr, offset);
#line 1032
    tmp___2 = chk_rsp(rsp);
    }
#line 1032
    if (tmp___2) {
#line 1033
      return (-1);
    }
    {
#line 1035
    records = rsp->data[2];
#line 1039
    memcpy((void */* __restrict  */)(id_buff), (void const   */* __restrict  */)(& rsp->data[3]),
           (size_t )16);
#line 1040
    i = 0;
    }
    {
#line 1040
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1040
      if (! (i < (int )records)) {
#line 1040
        goto while_break___0;
      }
      {
#line 1042
      record_id = (uint16_t )(((int )id_buff[2 * i + 1] << 8) + (int )id_buff[2 * i]);
#line 1043
      printf((char const   */* __restrict  */)"Record ID 0x%04x: ", (int )record_id);
#line 1044
      ipmi_print_sensor_info(intf, record_id);
#line 1040
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1046
    offset = (uint8_t )((int )offset + 8);
#line 1047
    instances = (int8_t )((int )instances - (int )records);
  }
  while_break: /* CIL Label */ ;
  }
#line 1049
  return (0);
}
}
#line 1057 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_pwr_rd(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct power_reading val ;
  struct tm tm_t ;
  time_t t ;
  uint8_t msg_data[4] ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 1066
  memset((void *)(& tm_t), 0, sizeof(tm_t));
#line 1067
  memset((void *)(& t), 0, sizeof(t));
#line 1069
  msg_data[0] = (uint8_t )220;
#line 1070
  msg_data[1] = (uint8_t )1;
#line 1071
  msg_data[2] = (uint8_t )0;
#line 1072
  msg_data[3] = (uint8_t )0;
#line 1074
  memset((void *)(& req), 0, sizeof(req));
#line 1075
  req.msg.netfn = (uint8_t )44;
#line 1076
  req.msg.cmd = (uint8_t )2;
#line 1077
  req.msg.data = msg_data;
#line 1078
  req.msg.data_len = (uint16_t )4;
#line 1080
  rsp = (*(intf->sendrecv))(intf, & req);
#line 1082
  tmp = chk_rsp(rsp);
  }
#line 1082
  if (tmp) {
#line 1083
    return (-1);
  }
  {
#line 1087
  memcpy((void */* __restrict  */)(& val), (void const   */* __restrict  */)(rsp->data),
         sizeof(val));
#line 1088
  t = (time_t )val.time_stamp;
#line 1089
  gmtime_r((time_t const   */* __restrict  */)(& t), (struct tm */* __restrict  */)(& tm_t));
#line 1090
  printf((char const   */* __restrict  */)"\n");
#line 1091
  printf((char const   */* __restrict  */)"    Instantaneous power reading:              %8d Watts\n",
         (int )val.curr_pwr);
#line 1093
  printf((char const   */* __restrict  */)"    Minimum during sampling period:           %8d Watts\n",
         (int )val.min_sample);
#line 1095
  printf((char const   */* __restrict  */)"    Maximum during sampling period:           %8d Watts\n",
         (int )val.max_sample);
#line 1097
  printf((char const   */* __restrict  */)"    Average power reading over sample period: %8d Watts\n",
         (int )val.avg_pwr);
#line 1099
  tmp___0 = asctime((struct tm  const  *)(& tm_t));
#line 1099
  printf((char const   */* __restrict  */)"    IPMI timestamp:                           %s",
         tmp___0);
#line 1101
  printf((char const   */* __restrict  */)"    Sampling period:                          %08d Milliseconds\n",
         val.sample);
#line 1103
  printf((char const   */* __restrict  */)"    Power reading state is:                   ");
  }
#line 1105
  if (((int )val.state & 64) == 64) {
    {
#line 1106
    printf((char const   */* __restrict  */)"activated");
    }
  } else {
    {
#line 1108
    printf((char const   */* __restrict  */)"deactivated");
    }
  }
  {
#line 1110
  printf((char const   */* __restrict  */)"\n\n");
  }
#line 1111
  return (0);
}
}
#line 1120 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
int ipmi_dcmi_getthermalpolicy(struct ipmi_intf *intf , uint8_t entityID , uint8_t entityInstance ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct thermal_limit val ;
  uint8_t msg_data[3] ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 1129
  msg_data[0] = (uint8_t )220;
#line 1130
  msg_data[1] = entityID;
#line 1131
  msg_data[2] = entityInstance;
#line 1133
  memset((void *)(& req), 0, sizeof(req));
#line 1134
  req.msg.netfn = (uint8_t )44;
#line 1135
  req.msg.cmd = (uint8_t )12;
#line 1136
  req.msg.data = msg_data;
#line 1137
  req.msg.data_len = (uint16_t )3;
#line 1139
  rsp = (*(intf->sendrecv))(intf, & req);
#line 1141
  tmp = chk_rsp(rsp);
  }
#line 1141
  if (tmp) {
#line 1142
    return (-1);
  }
  {
#line 1145
  memcpy((void */* __restrict  */)(& val), (void const   */* __restrict  */)(rsp->data),
         sizeof(val));
#line 1146
  printf((char const   */* __restrict  */)"\n");
  }
#line 1147
  if ((int )val.exceptionActions & 128) {
#line 1147
    tmp___0 = "set";
  } else {
#line 1147
    tmp___0 = "notset";
  }
  {
#line 1147
  printf((char const   */* __restrict  */)"    Persistance flag is:                      %s\n",
         tmp___0);
#line 1149
  printf((char const   */* __restrict  */)"    Exception Actions, taken if the Temperature Limit exceeded:\n");
  }
#line 1150
  if ((int )val.exceptionActions & 64) {
#line 1150
    tmp___1 = "active";
  } else {
#line 1150
    tmp___1 = "inactive";
  }
  {
#line 1150
  printf((char const   */* __restrict  */)"        Hard Power Off system and log event:  %s\n",
         tmp___1);
  }
#line 1152
  if ((int )val.exceptionActions & 32) {
#line 1152
    tmp___2 = "active";
  } else {
#line 1152
    tmp___2 = "inactive";
  }
  {
#line 1152
  printf((char const   */* __restrict  */)"        Log event to SEL only:                %s\n",
         tmp___2);
#line 1154
  printf((char const   */* __restrict  */)"    Temperature Limit                         %d degrees\n",
         (int )val.tempLimit);
#line 1156
  printf((char const   */* __restrict  */)"    Exception Time                            %d seconds\n",
         (int )val.exceptionTime);
#line 1158
  printf((char const   */* __restrict  */)"\n\n");
  }
#line 1159
  return (0);
}
}
#line 1166 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
int ipmi_dcmi_setthermalpolicy(struct ipmi_intf *intf , uint8_t entityID , uint8_t entityInst ,
                               uint8_t persistanceFlag , uint8_t actionHardPowerOff ,
                               uint8_t actionLogToSEL , uint8_t tempLimit , uint8_t samplingTimeLSB ,
                               uint8_t samplingTimeMSB ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[7] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1181
  msg_data[0] = (uint8_t )220;
#line 1182
  msg_data[1] = entityID;
#line 1183
  msg_data[2] = entityInst;
#line 1185
  if (persistanceFlag) {
#line 1185
    tmp = 1;
  } else {
#line 1185
    tmp = 0;
  }
#line 1185
  if (actionHardPowerOff) {
#line 1185
    tmp___0 = 1;
  } else {
#line 1185
    tmp___0 = 0;
  }
#line 1185
  if (actionLogToSEL) {
#line 1185
    tmp___1 = 1;
  } else {
#line 1185
    tmp___1 = 0;
  }
  {
#line 1185
  msg_data[3] = (uint8_t )(((tmp << 7) | (tmp___0 << 6)) | (tmp___1 << 5));
#line 1188
  msg_data[4] = tempLimit;
#line 1189
  msg_data[5] = samplingTimeLSB;
#line 1190
  msg_data[6] = samplingTimeMSB;
#line 1192
  memset((void *)(& req), 0, sizeof(req));
#line 1193
  req.msg.netfn = (uint8_t )44;
#line 1195
  req.msg.cmd = (uint8_t )11;
#line 1196
  req.msg.data = msg_data;
#line 1198
  req.msg.data_len = (uint16_t )7;
#line 1200
  rsp = (*(intf->sendrecv))(intf, & req);
#line 1201
  tmp___2 = chk_rsp(rsp);
  }
#line 1201
  if (tmp___2) {
#line 1202
    return (-1);
  }
  {
#line 1205
  printf((char const   */* __restrict  */)"\nThermal policy %d for %0Xh entity successfully set.\n\n",
         (int )entityInst, (int )entityID);
  }
#line 1207
  return (0);
}
}
#line 1216 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct ipmi_rs *ipmi_dcmi_get_temp_readings(struct ipmi_intf *intf , uint8_t entityID ,
                                            uint8_t entityInst , uint8_t entityInstStart ) 
{ 
  struct ipmi_rq req ;
  uint8_t msg_data[5] ;
  struct ipmi_rs *tmp ;

  {
  {
#line 1225
  msg_data[0] = (uint8_t )220;
#line 1226
  msg_data[1] = (uint8_t )1;
#line 1227
  msg_data[2] = entityID;
#line 1228
  msg_data[3] = entityInst;
#line 1229
  msg_data[4] = entityInstStart;
#line 1231
  memset((void *)(& req), 0, sizeof(req));
#line 1232
  req.msg.netfn = (uint8_t )44;
#line 1233
  req.msg.cmd = (uint8_t )16;
#line 1234
  req.msg.data = msg_data;
#line 1236
  req.msg.data_len = (uint16_t )5;
#line 1237
  tmp = (*(intf->sendrecv))(intf, & req);
  }
#line 1237
  return (tmp);
}
}
#line 1240 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_prnt_get_temp_readings(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  int i ;
  int j ;
  int tota_inst ;
  int get_inst ;
  int offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1244
  offset = 0;
#line 1246
  printf((char const   */* __restrict  */)"\n\tEntity ID\t\t\tEntity Instance\t   Temp. Readings");
#line 1247
  i = 0;
  }
  {
#line 1247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1247
    if (! ((unsigned long )dcmi_temp_read_vals[i].str != (unsigned long )((void *)0))) {
#line 1247
      goto while_break;
    }
    {
#line 1249
    rsp = ipmi_dcmi_get_temp_readings(intf, (uint8_t )dcmi_temp_read_vals[i].val,
                                      (uint8_t )0, (uint8_t )0);
#line 1251
    tmp = chk_rsp(rsp);
    }
#line 1251
    if (tmp) {
#line 1252
      goto __Cont;
    }
#line 1255
    offset = 0;
#line 1256
    tota_inst = (int )rsp->data[1];
    {
#line 1257
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1257
      if (! (tota_inst > 0)) {
#line 1257
        goto while_break___0;
      }
#line 1258
      if (tota_inst / 8) {
#line 1258
        get_inst = 8;
      } else {
#line 1258
        get_inst = tota_inst % 8;
      }
      {
#line 1261
      rsp = ipmi_dcmi_get_temp_readings(intf, (uint8_t )dcmi_temp_read_vals[i].val,
                                        (uint8_t )offset, (uint8_t )0);
#line 1263
      tmp___0 = chk_rsp(rsp);
      }
#line 1263
      if (tmp___0) {
#line 1264
        goto while_continue___0;
      }
#line 1269
      j = 0;
      {
#line 1269
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1269
        if (! (j < (int )rsp->data[2] * 2)) {
#line 1269
          goto while_break___1;
        }
        {
#line 1271
        printf((char const   */* __restrict  */)"\n%s", dcmi_temp_read_vals[i].desc);
        }
#line 1272
        if ((int )rsp->data[j + 3] >> 7) {
#line 1272
          tmp___1 = '-';
        } else {
#line 1272
          tmp___1 = '+';
        }
        {
#line 1272
        printf((char const   */* __restrict  */)"\t\t%i\t\t%c%i C", (int )rsp->data[j + 4],
               tmp___1, (int )rsp->data[j + 3] & 127);
#line 1269
        j += 2;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1276
      offset += get_inst;
#line 1277
      tota_inst -= get_inst;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1247
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1280
  return (0);
}
}
#line 1289 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct ipmi_rs *ipmi_dcmi_getconfparam(struct ipmi_intf *intf , int param_selector ) 
{ 
  struct ipmi_rq req ;
  uint8_t msg_data[3] ;
  struct ipmi_rs *tmp ;

  {
  {
#line 1295
  msg_data[0] = (uint8_t )220;
#line 1296
  msg_data[1] = (uint8_t )param_selector;
#line 1300
  msg_data[2] = (uint8_t )0;
#line 1302
  memset((void *)(& req), 0, sizeof(req));
#line 1303
  req.msg.netfn = (uint8_t )44;
#line 1304
  req.msg.cmd = (uint8_t )19;
#line 1305
  req.msg.data = msg_data;
#line 1307
  req.msg.data_len = (uint16_t )3;
#line 1308
  tmp = (*(intf->sendrecv))(intf, & req);
  }
#line 1308
  return (tmp);
}
}
#line 1311 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_prnt_getconfparam(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  int dcmi_conf_params ;
  int param_selector ;
  uint16_t tmp_value ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 1315
  dcmi_conf_params = 5;
#line 1317
  tmp_value = (uint16_t )0;
#line 1319
  param_selector = 2;
  {
#line 1319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1319
    if (! (param_selector <= dcmi_conf_params)) {
#line 1319
      goto while_break;
    }
    {
#line 1321
    rsp = ipmi_dcmi_getconfparam(intf, param_selector);
#line 1322
    tmp = chk_rsp(rsp);
    }
#line 1322
    if (tmp) {
#line 1323
      return (-1);
    }
    {
#line 1327
    if (param_selector == 2) {
#line 1327
      goto case_2;
    }
#line 1335
    if (param_selector == 3) {
#line 1335
      goto case_3;
    }
#line 1339
    if (param_selector == 4) {
#line 1339
      goto case_4;
    }
#line 1343
    if (param_selector == 5) {
#line 1343
      goto case_5;
    }
#line 1347
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 1328
    tmp_value = (uint16_t )((int )rsp->data[4] & 1);
#line 1329
    printf((char const   */* __restrict  */)"\n\tDHCP Discovery method\t: ");
    }
#line 1330
    if (tmp_value) {
#line 1330
      tmp___0 = "enabled";
    } else {
#line 1330
      tmp___0 = "disabled";
    }
    {
#line 1330
    printf((char const   */* __restrict  */)"\n\t\tManagement Controller ID String is %s",
           tmp___0);
    }
#line 1332
    if ((int )rsp->data[4] & 2) {
#line 1332
      tmp___1 = "enabled";
    } else {
#line 1332
      tmp___1 = "disabled";
    }
    {
#line 1332
    printf((char const   */* __restrict  */)"\n\t\tVendor class identifier DCMI IANA and Vendor class-specific Informationa are %s",
           tmp___1);
    }
#line 1334
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1336
    printf((char const   */* __restrict  */)"\n\tInitial timeout interval\t: %i seconds",
           (int )rsp->data[4]);
    }
#line 1338
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1340
    printf((char const   */* __restrict  */)"\n\tServer contact timeout interval\t: %i seconds",
           (int )rsp->data[4] + ((int )rsp->data[5] << 8));
    }
#line 1342
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 1344
    printf((char const   */* __restrict  */)"\n\tServer contact retry interval\t: %i seconds",
           (int )rsp->data[4] + ((int )rsp->data[5] << 8));
    }
#line 1346
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1348
    printf((char const   */* __restrict  */)"\n\tConfiguration Parameter not supported.");
    }
    switch_break: /* CIL Label */ ;
    }
#line 1319
    param_selector ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1351
  return (0);
}
}
#line 1360 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct ipmi_rs *ipmi_dcmi_setconfparam(struct ipmi_intf *intf , uint8_t param_selector ,
                                       uint16_t value ) 
{ 
  struct ipmi_rq req ;
  uint8_t msg_data[5] ;
  struct ipmi_rs *tmp ;

  {
#line 1367
  msg_data[0] = (uint8_t )220;
#line 1368
  msg_data[1] = param_selector;
#line 1370
  msg_data[2] = (uint8_t )0;
#line 1372
  if ((int )param_selector > 3) {
#line 1374
    msg_data[3] = (uint8_t )((int )value & 255);
#line 1375
    msg_data[4] = (uint8_t )((int )value >> 8);
  } else {
#line 1377
    msg_data[3] = (uint8_t )value;
  }
  {
#line 1380
  memset((void *)(& req), 0, sizeof(req));
#line 1381
  req.msg.netfn = (uint8_t )44;
#line 1382
  req.msg.cmd = (uint8_t )18;
#line 1383
  req.msg.data = msg_data;
  }
#line 1384
  if ((int )param_selector > 3) {
#line 1387
    req.msg.data_len = (uint16_t )5;
  } else {
#line 1390
    req.msg.data_len = (uint16_t )4;
  }
  {
#line 1392
  tmp = (*(intf->sendrecv))(intf, & req);
  }
#line 1392
  return (tmp);
}
}
#line 1406 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
struct ipmi_rs *ipmi_dcmi_pwr_glimit(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rq req ;
  uint8_t msg_data[3] ;
  struct ipmi_rs *tmp ;

  {
  {
#line 1411
  msg_data[0] = (uint8_t )220;
#line 1412
  msg_data[1] = (uint8_t )0;
#line 1413
  msg_data[2] = (uint8_t )0;
#line 1415
  memset((void *)(& req), 0, sizeof(req));
#line 1416
  req.msg.netfn = (uint8_t )44;
#line 1417
  req.msg.cmd = (uint8_t )3;
#line 1418
  req.msg.data = msg_data;
#line 1420
  req.msg.data_len = (uint16_t )3;
#line 1422
  tmp = (*(intf->sendrecv))(intf, & req);
  }
#line 1422
  return (tmp);
}
}
#line 1433 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_pwr_prnt_glimit(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct power_limit val ;
  uint8_t realCc ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 1438
  realCc = (uint8_t )255;
#line 1440
  rsp = ipmi_dcmi_pwr_glimit(intf);
  }
#line 1444
  if ((unsigned long )rsp != (unsigned long )((void *)0)) {
#line 1445
    realCc = rsp->ccode;
#line 1446
    if ((int )rsp->ccode == 128) {
#line 1446
      rsp->ccode = (uint8_t )0;
    } else {
#line 1446
      rsp->ccode = rsp->ccode;
    }
  }
  {
#line 1448
  tmp = chk_rsp(rsp);
  }
#line 1448
  if (tmp) {
#line 1449
    return (-1);
  }
  {
#line 1453
  memcpy((void */* __restrict  */)(& val), (void const   */* __restrict  */)(rsp->data),
         sizeof(val));
  }
#line 1454
  if ((int )realCc == 0) {
#line 1454
    tmp___0 = "Power Limit Active";
  } else {
#line 1454
    tmp___0 = "No Active Power Limit";
  }
  {
#line 1454
  printf((char const   */* __restrict  */)"\n    Current Limit State: %s\n", tmp___0);
#line 1457
  tmp___1 = val2str2((uint16_t )val.action, dcmi_pwrmgmt_action_vals);
#line 1457
  printf((char const   */* __restrict  */)"    Exception actions:   %s\n", tmp___1);
#line 1459
  printf((char const   */* __restrict  */)"    Power Limit:         %i Watts\n", (int )val.limit);
#line 1460
  printf((char const   */* __restrict  */)"    Correction time:     %i milliseconds\n",
         val.correction);
#line 1461
  printf((char const   */* __restrict  */)"    Sampling period:     %i seconds\n",
         (int )val.sample);
#line 1462
  printf((char const   */* __restrict  */)"\n");
  }
#line 1463
  return (0);
}
}
#line 1478 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_pwr_slimit(struct ipmi_intf *intf , char const   *option , char const   *value ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct power_limit val ;
  uint8_t msg_data[15] ;
  uint32_t lvalue ;
  int tmp ;
  int tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1486
  lvalue = (uint32_t )0;
#line 1489
  tmp = str2uint(value, & lvalue);
  }
#line 1489
  if (tmp != 0) {
    {
#line 1490
    lprintf(3, "Given %s \'%s\' is invalid.", option, value);
    }
#line 1492
    return (-1);
  }
  {
#line 1495
  rsp = ipmi_dcmi_pwr_glimit(intf);
  }
#line 1509
  if ((unsigned long )rsp != (unsigned long )((void *)0)) {
#line 1510
    if ((int )rsp->ccode == 128) {
#line 1510
      rsp->ccode = (uint8_t )0;
    } else {
#line 1510
      rsp->ccode = rsp->ccode;
    }
  }
  {
#line 1512
  tmp___0 = chk_rsp(rsp);
  }
#line 1512
  if (tmp___0) {
#line 1513
    return (-1);
  }
  {
#line 1515
  memcpy((void */* __restrict  */)(& val), (void const   */* __restrict  */)(rsp->data),
         sizeof(val));
#line 1532
  tmp___1 = str2val2(option, dcmi_pwrmgmt_set_usage_vals);
  }
  {
#line 1533
  if ((int )tmp___1 == 0) {
#line 1533
    goto case_0;
  }
#line 1549
  if ((int )tmp___1 == 1) {
#line 1549
    goto case_1___0;
  }
#line 1553
  if ((int )tmp___1 == 2) {
#line 1553
    goto case_2;
  }
#line 1557
  if ((int )tmp___1 == 3) {
#line 1557
    goto case_3;
  }
#line 1561
  if ((int )tmp___1 == 255) {
#line 1561
    goto case_255___0;
  }
#line 1532
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1535
  tmp___2 = str2val2(value, dcmi_pwrmgmt_action_vals);
  }
  {
#line 1536
  if ((int )tmp___2 == 1) {
#line 1536
    goto case_1;
  }
#line 1540
  if ((int )tmp___2 == 17) {
#line 1540
    goto case_17;
  }
#line 1544
  if ((int )tmp___2 == 255) {
#line 1544
    goto case_255;
  }
#line 1535
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 1538
  val.action = (uint8_t )1;
#line 1539
  goto switch_break___0;
  case_17: /* CIL Label */ 
#line 1542
  val.action = (uint8_t )17;
#line 1543
  goto switch_break___0;
  case_255: /* CIL Label */ 
#line 1546
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
#line 1548
  goto switch_break;
  case_1___0: /* CIL Label */ 
#line 1551
  val.limit = *((uint16_t *)(& lvalue));
#line 1552
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1555
  val.correction = lvalue;
#line 1556
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1559
  val.sample = *((uint16_t *)(& lvalue));
#line 1560
  goto switch_break;
  case_255___0: /* CIL Label */ 
#line 1563
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1566
  msg_data[0] = val.grp_id;
#line 1567
  msg_data[1] = (uint8_t )0;
#line 1568
  msg_data[2] = (uint8_t )0;
#line 1569
  msg_data[3] = (uint8_t )0;
#line 1570
  msg_data[4] = val.action;
#line 1573
  *((uint16_t *)(& msg_data[5])) = val.limit;
#line 1578
  *((uint32_t *)(& msg_data[7])) = val.correction;
#line 1584
  msg_data[11] = (uint8_t )0;
#line 1585
  msg_data[12] = (uint8_t )0;
#line 1587
  *((uint16_t *)(& msg_data[13])) = val.sample;
#line 1589
  memset((void *)(& req), 0, sizeof(req));
#line 1590
  req.msg.netfn = (uint8_t )44;
#line 1591
  req.msg.cmd = (uint8_t )4;
#line 1592
  req.msg.data = msg_data;
#line 1594
  req.msg.data_len = (uint16_t )15;
#line 1596
  rsp = (*(intf->sendrecv))(intf, & req);
#line 1598
  tmp___3 = chk_rsp(rsp);
  }
#line 1598
  if (tmp___3) {
#line 1599
    return (-1);
  }
#line 1601
  return (0);
}
}
#line 1610 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_pwr_actdeact(struct ipmi_intf *intf , uint8_t option ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[4] ;
  int tmp ;

  {
  {
#line 1617
  msg_data[0] = (uint8_t )220;
#line 1618
  msg_data[1] = option;
#line 1619
  msg_data[2] = (uint8_t )0;
#line 1620
  msg_data[3] = (uint8_t )0;
#line 1622
  memset((void *)(& req), 0, sizeof(req));
#line 1623
  req.msg.netfn = (uint8_t )44;
#line 1624
  req.msg.cmd = (uint8_t )5;
#line 1625
  req.msg.data = msg_data;
#line 1626
  req.msg.data_len = (uint16_t )4;
#line 1628
  rsp = (*(intf->sendrecv))(intf, & req);
#line 1629
  tmp = chk_rsp(rsp);
  }
#line 1629
  if (tmp) {
#line 1630
    return (-1);
  }
  {
#line 1632
  printf((char const   */* __restrict  */)"\n    Power limit successfully ");
  }
#line 1633
  if ((int )option == 0) {
    {
#line 1634
    printf((char const   */* __restrict  */)"deactivated");
    }
  } else {
    {
#line 1636
    printf((char const   */* __restrict  */)"activated");
    }
  }
  {
#line 1638
  printf((char const   */* __restrict  */)"\n");
  }
#line 1639
  return (0);
}
}
#line 1649 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
int ipmi_dcmi_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int rc ;
  uint8_t ctl ;
  int i ;
  struct ipmi_rs *rsp ;
  int tmp ;
  uint16_t tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  uint16_t tmp___3 ;
  struct ipmi_rq req ;
  uint8_t data[256] ;
  uint16_t sample ;
  uint16_t limit ;
  uint32_t correction ;
  uint16_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  uint8_t entityID ;
  uint8_t entityInst ;
  uint8_t persistanceFlag ;
  uint8_t actionHardPowerOff ;
  uint8_t actionLogToSEL ;
  uint8_t tempLimit ;
  uint8_t samplingTimeLSB ;
  uint8_t samplingTimeMSB ;
  uint16_t samplingTime ;
  uint16_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  uint16_t tmp___18 ;
  uint16_t tmp___19 ;
  uint16_t tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  uint16_t tmp_val ;
  int tmp___27 ;
  uint16_t tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;

  {
#line 1652
  rc = 0;
#line 1653
  ctl = (uint8_t )0;
#line 1657
  if (argc == 0) {
    {
#line 1658
    print_strs(dcmi_cmd_vals, "Data Center Management Interface commands", -1, 0);
    }
#line 1661
    return (-1);
  } else {
    {
#line 1657
    tmp = strncmp((char const   *)*(argv + 0), "help", (size_t )4);
    }
#line 1657
    if (tmp == 0) {
      {
#line 1658
      print_strs(dcmi_cmd_vals, "Data Center Management Interface commands", -1, 0);
      }
#line 1661
      return (-1);
    }
  }
  {
#line 1664
  tmp___0 = str2val2((char const   *)*(argv + 0), dcmi_cmd_vals);
  }
  {
#line 1665
  if ((int )tmp___0 == 0) {
#line 1665
    goto case_0;
  }
#line 1675
  if ((int )tmp___0 == 1) {
#line 1675
    goto case_1;
  }
#line 1812
  if ((int )tmp___0 == 2) {
#line 1812
    goto case_2___0;
  }
#line 1825
  if ((int )tmp___0 == 3) {
#line 1825
    goto case_3___0;
  }
#line 1833
  if ((int )tmp___0 == 4) {
#line 1833
    goto case_4___0;
  }
#line 1849
  if ((int )tmp___0 == 5) {
#line 1849
    goto case_5;
  }
#line 1858
  if ((int )tmp___0 == 6) {
#line 1858
    goto case_6;
  }
#line 1875
  if ((int )tmp___0 == 7) {
#line 1875
    goto case_7;
  }
#line 1970
  if ((int )tmp___0 == 8) {
#line 1970
    goto case_8;
  }
#line 1976
  if ((int )tmp___0 == 9) {
#line 1976
    goto case_9;
  }
#line 1982
  if ((int )tmp___0 == 10) {
#line 1982
    goto case_10;
  }
#line 2021
  if ((int )tmp___0 == 11) {
#line 2021
    goto case_11;
  }
#line 2034
  goto switch_default___2;
  case_0: /* CIL Label */ 
#line 1667
  i = 1;
  {
#line 1667
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1667
    if (! ((unsigned long )dcmi_capable_vals[i - 1].str != (unsigned long )((void *)0))) {
#line 1667
      goto while_break;
    }
    {
#line 1668
    tmp___2 = ipmi_dcmi_prnt_getcapabilities(intf, (uint8_t )i);
    }
#line 1668
    if (tmp___2 < 0) {
      {
#line 1669
      tmp___1 = val2str2((uint16_t )i, dcmi_capable_vals);
#line 1669
      printf((char const   */* __restrict  */)"Error discovering %s capabilities!\n",
             tmp___1);
      }
#line 1671
      return (-1);
    }
#line 1667
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1674
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1677
  argv ++;
#line 1678
  if ((unsigned long )*(argv + 0) == (unsigned long )((void *)0)) {
    {
#line 1679
    print_strs(dcmi_pwrmgmt_vals, "power <command>", -1, 0);
    }
#line 1681
    return (-1);
  }
  {
#line 1684
  tmp___3 = str2val2((char const   *)*(argv + 0), dcmi_pwrmgmt_vals);
  }
  {
#line 1685
  if ((int )tmp___3 == 0) {
#line 1685
    goto case_0___0;
  }
#line 1689
  if ((int )tmp___3 == 1) {
#line 1689
    goto case_1___0;
  }
#line 1697
  if ((int )tmp___3 == 2) {
#line 1697
    goto case_2;
  }
#line 1795
  if ((int )tmp___3 == 3) {
#line 1795
    goto case_3;
  }
#line 1799
  if ((int )tmp___3 == 4) {
#line 1799
    goto case_4;
  }
#line 1803
  goto switch_default;
  case_0___0: /* CIL Label */ 
  {
#line 1687
  rc = ipmi_dcmi_pwr_rd(intf);
  }
#line 1688
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 1695
  rc = ipmi_dcmi_pwr_prnt_glimit(intf);
  }
#line 1696
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 1699
  if (argc < 4) {
    {
#line 1700
    print_strs(dcmi_pwrmgmt_set_usage_vals, "set_limit <parameter> <value>", -1, 0);
    }
#line 1703
    return (-1);
  }
#line 1705
  if (argc == 10) {
    {
#line 1709
    sample = (uint16_t )0;
#line 1710
    limit = (uint16_t )0;
#line 1711
    correction = (uint32_t )0;
#line 1713
    memset((void *)(data), 0, sizeof(data));
#line 1714
    memset((void *)(& req), 0, sizeof(req));
#line 1716
    req.msg.netfn = (uint8_t )44;
#line 1717
    req.msg.lun = (uint8_t )0;
#line 1718
    req.msg.cmd = (uint8_t )4;
#line 1719
    req.msg.data = data;
#line 1720
    req.msg.data_len = (uint16_t )15;
#line 1722
    data[0] = (uint8_t )220;
#line 1723
    data[1] = (uint8_t )0;
#line 1724
    data[2] = (uint8_t )0;
#line 1725
    data[3] = (uint8_t )0;
#line 1728
    tmp___4 = str2val2((char const   *)*(argv + 2), dcmi_pwrmgmt_action_vals);
    }
    {
#line 1729
    if ((int )tmp___4 == 1) {
#line 1729
      goto case_1___1;
    }
#line 1733
    if ((int )tmp___4 == 17) {
#line 1733
      goto case_17;
    }
#line 1737
    if ((int )tmp___4 == 255) {
#line 1737
      goto case_255;
    }
#line 1728
    goto switch_break___1;
    case_1___1: /* CIL Label */ 
#line 1731
    data[4] = (uint8_t )1;
#line 1732
    goto switch_break___1;
    case_17: /* CIL Label */ 
#line 1735
    data[4] = (uint8_t )17;
#line 1736
    goto switch_break___1;
    case_255: /* CIL Label */ 
#line 1739
    return (-1);
    switch_break___1: /* CIL Label */ ;
    }
    {
#line 1742
    tmp___5 = str2ushort((char const   *)*(argv + 4), & limit);
    }
#line 1742
    if (tmp___5 != 0) {
      {
#line 1743
      lprintf(3, "Given Limit \'%s\' is invalid.", *(argv + 4));
      }
#line 1746
      return (-1);
    }
    {
#line 1748
    data[5] = (uint8_t )((int )limit);
#line 1749
    data[6] = (uint8_t )((int )limit >> 8);
#line 1751
    tmp___6 = str2uint((char const   *)*(argv + 6), & correction);
    }
#line 1751
    if (tmp___6 != 0) {
      {
#line 1752
      lprintf(3, "Given Correction \'%s\' is invalid.", *(argv + 6));
      }
#line 1755
      return (-1);
    }
    {
#line 1757
    data[7] = (uint8_t )correction;
#line 1758
    data[8] = (uint8_t )(correction >> 8);
#line 1759
    data[9] = (uint8_t )(correction >> 16);
#line 1760
    data[10] = (uint8_t )(correction >> 24);
#line 1761
    data[11] = (uint8_t )0;
#line 1762
    data[12] = (uint8_t )0;
#line 1764
    tmp___7 = str2ushort((char const   *)*(argv + 8), & sample);
    }
#line 1764
    if (tmp___7 != 0) {
      {
#line 1765
      lprintf(3, "Given Sample \'%s\' is invalid.", *(argv + 8));
      }
#line 1768
      return (-1);
    }
    {
#line 1770
    data[13] = (uint8_t )((int )sample);
#line 1771
    data[14] = (uint8_t )((int )sample >> 8);
#line 1773
    rsp = (*(intf->sendrecv))(intf, & req);
#line 1774
    tmp___8 = chk_rsp(rsp);
    }
#line 1774
    if (tmp___8) {
#line 1775
      return (-1);
    }
  } else {
    {
#line 1779
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1779
      if ((unsigned long )*(argv + 1) != (unsigned long )((void *)0)) {
#line 1779
        if (! ((unsigned long )*(argv + 2) != (unsigned long )((void *)0))) {
#line 1779
          goto while_break___0;
        }
      } else {
#line 1779
        goto while_break___0;
      }
      {
#line 1780
      rc = ipmi_dcmi_pwr_slimit(intf, (char const   *)*(argv + 1), (char const   *)*(argv + 2));
      }
#line 1782
      if (rc > 0) {
        {
#line 1783
        print_strs(dcmi_pwrmgmt_set_usage_vals, "set_limit <parameter> <value>", -1,
                   0);
        }
#line 1785
        return (-1);
      }
#line 1790
      argv += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1793
  rc = ipmi_dcmi_pwr_prnt_glimit(intf);
  }
#line 1794
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 1797
  rc = ipmi_dcmi_pwr_actdeact(intf, (uint8_t )1);
  }
#line 1798
  goto switch_break___0;
  case_4: /* CIL Label */ 
  {
#line 1801
  rc = ipmi_dcmi_pwr_actdeact(intf, (uint8_t )0);
  }
#line 1802
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 1805
  print_strs(dcmi_pwrmgmt_vals, "power <command>", -1, 0);
  }
#line 1807
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1810
  goto switch_break;
  case_2___0: /* CIL Label */ 
#line 1818
  i = 0;
  {
#line 1818
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1818
    if (! ((unsigned long )dcmi_discvry_snsr_vals[i].str != (unsigned long )((void *)0))) {
#line 1818
      goto while_break___1;
    }
    {
#line 1820
    rc = ipmi_dcmi_prnt_discvry_snsr(intf, (uint8_t )dcmi_discvry_snsr_vals[i].val);
#line 1818
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1823
  goto switch_break;
  case_3___0: /* CIL Label */ 
  {
#line 1827
  tmp___9 = ipmi_dcmi_prnt_getassettag(intf);
  }
#line 1827
  if (tmp___9 < 0) {
    {
#line 1828
    lprintf(3, "Error getting asset tag!");
    }
#line 1829
    return (-1);
  }
#line 1831
  goto switch_break;
  case_4___0: /* CIL Label */ 
#line 1836
  if (argc == 1) {
    {
#line 1837
    print_strs(dcmi_cmd_vals, "Data Center Management Interface commands", -1, 0);
    }
#line 1840
    return (-1);
  }
  {
#line 1842
  tmp___10 = ipmi_dcmi_prnt_setassettag(intf, (uint8_t *)*(argv + 1));
  }
#line 1842
  if (tmp___10 < 0) {
    {
#line 1843
    lprintf(3, "\nError setting asset tag!");
    }
#line 1844
    return (-1);
  }
#line 1846
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1851
  tmp___11 = ipmi_dcmi_prnt_getmngctrlids(intf);
  }
#line 1851
  if (tmp___11 < 0) {
    {
#line 1852
    lprintf(3, "Error getting management controller identifier string!");
    }
#line 1854
    return (-1);
  }
#line 1856
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1861
  if (argc == 1) {
    {
#line 1862
    print_strs(dcmi_cmd_vals, "Data Center Management Interface commands", -1, 0);
    }
#line 1865
    return (-1);
  }
  {
#line 1867
  tmp___12 = ipmi_dcmi_prnt_setmngctrlids(intf, (uint8_t *)*(argv + 1));
  }
#line 1867
  if (tmp___12 < 0) {
    {
#line 1868
    lprintf(3, "Error setting management controller identifier string!");
    }
#line 1870
    return (-1);
  }
#line 1872
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1877
  entityID = (uint8_t )0;
#line 1878
  entityInst = (uint8_t )0;
#line 1882
  tempLimit = (uint8_t )0;
#line 1885
  samplingTime = (uint16_t )0;
#line 1888
  tmp___13 = str2val2((char const   *)*(argv + 1), dcmi_thermalpolicy_vals);
  }
  {
#line 1889
  if ((int )tmp___13 == 0) {
#line 1889
    goto case_0___1;
  }
#line 1908
  if ((int )tmp___13 == 1) {
#line 1908
    goto case_1___2;
  }
#line 1962
  goto switch_default___0;
  case_0___1: /* CIL Label */ 
#line 1890
  if (argc < 4) {
    {
#line 1891
    lprintf(5, "Get <entityID> <instanceID>");
    }
#line 1892
    return (-1);
  }
  {
#line 1894
  tmp___14 = str2uchar((char const   *)*(argv + 2), & entityID);
  }
#line 1894
  if (tmp___14 != 0) {
    {
#line 1895
    lprintf(3, "Given Entity ID \'%s\' is invalid.", *(argv + 2));
    }
#line 1898
    return (-1);
  }
  {
#line 1900
  tmp___15 = str2uchar((char const   *)*(argv + 3), & entityInst);
  }
#line 1900
  if (tmp___15 != 0) {
    {
#line 1901
    lprintf(3, "Given Instance ID \'%s\' is invalid.", *(argv + 3));
    }
#line 1904
    return (-1);
  }
  {
#line 1906
  rc = ipmi_dcmi_getthermalpolicy(intf, entityID, entityInst);
  }
#line 1907
  goto switch_break___2;
  case_1___2: /* CIL Label */ 
#line 1909
  if (argc < 4) {
    {
#line 1910
    lprintf(5, "Set <entityID> <instanceID>");
    }
#line 1911
    return (-1);
  } else
#line 1912
  if (argc < 9) {
    {
#line 1913
    print_strs(dcmi_thermalpolicy_set_parameters_vals, "Set thermalpolicy instance parameters: <volatile/nonvolatile/disabled> <poweroff/nopoweroff/disabled> <sel/nosel/disabled> <templimitByte> <exceptionTime>",
               -1, 0);
    }
#line 1919
    return (-1);
  }
  {
#line 1921
  tmp___16 = str2uchar((char const   *)*(argv + 2), & entityID);
  }
#line 1921
  if (tmp___16 != 0) {
    {
#line 1922
    lprintf(3, "Given Entity ID \'%s\' is invalid.", *(argv + 2));
    }
#line 1925
    return (-1);
  }
  {
#line 1927
  tmp___17 = str2uchar((char const   *)*(argv + 3), & entityInst);
  }
#line 1927
  if (tmp___17 != 0) {
    {
#line 1928
    lprintf(3, "Given Instance ID \'%s\' is invalid.", *(argv + 3));
    }
#line 1931
    return (-1);
  }
  {
#line 1933
  tmp___18 = str2val2((char const   *)*(argv + 4), dcmi_thermalpolicy_set_parameters_vals);
#line 1933
  persistanceFlag = (uint8_t )tmp___18;
#line 1934
  tmp___19 = str2val2((char const   *)*(argv + 5), dcmi_thermalpolicy_set_parameters_vals);
#line 1934
  actionHardPowerOff = (uint8_t )tmp___19;
#line 1935
  tmp___20 = str2val2((char const   *)*(argv + 6), dcmi_thermalpolicy_set_parameters_vals);
#line 1935
  actionLogToSEL = (uint8_t )tmp___20;
#line 1936
  tmp___21 = str2uchar((char const   *)*(argv + 7), & tempLimit);
  }
#line 1936
  if (tmp___21 != 0) {
    {
#line 1937
    lprintf(3, "Given Temp Limit \'%s\' is invalid.", *(argv + 7));
    }
#line 1940
    return (-1);
  }
  {
#line 1942
  tmp___22 = str2ushort((char const   *)*(argv + 8), & samplingTime);
  }
#line 1942
  if (tmp___22 != 0) {
    {
#line 1943
    lprintf(3, "Given Sampling Time \'%s\' is invalid.", *(argv + 8));
    }
#line 1946
    return (-1);
  }
  {
#line 1948
  samplingTimeLSB = (uint8_t )((int )samplingTime & 255);
#line 1949
  samplingTimeMSB = (uint8_t )(((int )samplingTime & 65280) >> 8);
#line 1951
  rc = ipmi_dcmi_setthermalpolicy(intf, entityID, entityInst, persistanceFlag, actionHardPowerOff,
                                  actionLogToSEL, tempLimit, samplingTimeLSB, samplingTimeMSB);
  }
#line 1961
  goto switch_break___2;
  switch_default___0: /* CIL Label */ 
  {
#line 1963
  print_strs(dcmi_thermalpolicy_vals, "thermalpolicy <command>", -1, 0);
  }
#line 1966
  return (-1);
  switch_break___2: /* CIL Label */ ;
  }
#line 1968
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1971
  tmp___23 = ipmi_dcmi_prnt_get_temp_readings(intf);
  }
#line 1971
  if (tmp___23 < 0) {
    {
#line 1972
    lprintf(3, "Error get temperature readings!");
    }
  }
#line 1975
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 1977
  tmp___24 = ipmi_dcmi_prnt_getconfparam(intf);
  }
#line 1977
  if (tmp___24 < 0) {
    {
#line 1978
    lprintf(3, "Error Get DCMI Configuration Parameters!");
    }
  }
#line 1981
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 1985
  if (argc == 2) {
#line 1985
    goto case_2___1;
  }
#line 1993
  goto switch_default___1;
  case_2___1: /* CIL Label */ 
  {
#line 1986
  tmp___25 = strncmp((char const   *)*(argv + 1), "activate_dhcp", (size_t )13);
  }
#line 1986
  if (tmp___25 != 0) {
    {
#line 1987
    print_strs(dcmi_conf_param_vals, "DCMI Configuration Parameters", -1, 0);
    }
#line 1990
    return (-1);
  }
#line 1992
  goto switch_break___3;
  switch_default___1: /* CIL Label */ 
#line 1994
  if (argc != 3) {
    {
#line 1995
    print_strs(dcmi_conf_param_vals, "DCMI Configuration Parameters", -1, 0);
    }
#line 1998
    return (-1);
  } else {
    {
#line 1994
    tmp___26 = strncmp((char const   *)*(argv + 1), "help", (size_t )4);
    }
#line 1994
    if (tmp___26 == 0) {
      {
#line 1995
      print_strs(dcmi_conf_param_vals, "DCMI Configuration Parameters", -1, 0);
      }
#line 1998
      return (-1);
    }
  }
  switch_break___3: /* CIL Label */ ;
  }
  {
#line 2001
  tmp___29 = strncmp((char const   *)*(argv + 1), "activate_dhcp", (size_t )13);
  }
#line 2001
  if (tmp___29 == 0) {
    {
#line 2002
    rsp = ipmi_dcmi_setconfparam(intf, (uint8_t )1, (uint16_t )1);
    }
  } else {
    {
#line 2004
    tmp_val = (uint16_t )0;
#line 2005
    tmp___27 = str2ushort((char const   *)*(argv + 2), & tmp_val);
    }
#line 2005
    if (tmp___27 != 0) {
      {
#line 2006
      lprintf(3, "Given %s \'%s\' is invalid.", *(argv + 1), *(argv + 2));
      }
#line 2009
      return (-1);
    }
    {
#line 2011
    tmp___28 = str2val2((char const   *)*(argv + 1), dcmi_conf_param_vals);
#line 2011
    rsp = ipmi_dcmi_setconfparam(intf, (uint8_t )tmp___28, tmp_val);
    }
  }
  {
#line 2015
  tmp___30 = chk_rsp(rsp);
  }
#line 2015
  if (tmp___30) {
    {
#line 2016
    lprintf(3, "Error Set DCMI Configuration Parameters!");
    }
  }
#line 2019
  goto switch_break;
  case_11: /* CIL Label */ 
#line 2023
  if ((unsigned long )intf->session == (unsigned long )((void *)0)) {
    {
#line 2024
    lprintf(3, "\nOOB discovery is available only via RMCP interface.");
    }
#line 2026
    return (-1);
  }
  {
#line 2028
  tmp___31 = ipmi_dcmi_prnt_oobDiscover(intf);
  }
#line 2028
  if (tmp___31 < 0) {
    {
#line 2029
    lprintf(3, "\nOOB discovering capabilities failed.");
    }
#line 2030
    return (-1);
  }
#line 2032
  goto switch_break;
  switch_default___2: /* CIL Label */ 
  {
#line 2036
  print_strs(dcmi_cmd_vals, "Data Center Management Interface commands", -1, 0);
  }
#line 2039
  return (-1);
#line 2040
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 2042
  printf((char const   */* __restrict  */)"\n");
  }
#line 2043
  return (0);
}
}
#line 2054 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_print_sensor_info(struct ipmi_intf *intf , uint16_t rec_id ) 
{ 
  struct sdr_get_rs *header ;
  struct ipmi_sdr_iterator *itr ;
  int rc ;
  uint8_t *rec ;

  {
  {
#line 2059
  rc = 0;
#line 2060
  rec = (uint8_t *)((void *)0);
#line 2062
  itr = ipmi_sdr_start(intf, 0);
  }
#line 2063
  if ((unsigned long )itr == (unsigned long )((void *)0)) {
    {
#line 2064
    lprintf(3, "Unable to open SDR for reading");
    }
#line 2065
    return (-1);
  }
  {
#line 2068
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2068
    header = ipmi_sdr_get_next_header(intf, itr);
    }
#line 2068
    if (! ((unsigned long )header != (unsigned long )((void *)0))) {
#line 2068
      goto while_break;
    }
#line 2069
    if ((int )header->id == (int )rec_id) {
#line 2070
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2073
  if ((unsigned long )header == (unsigned long )((void *)0)) {
    {
#line 2074
    lprintf(7, "header == NULL");
#line 2075
    ipmi_sdr_end(intf, itr);
    }
#line 2076
    return (-1);
  }
  {
#line 2079
  rec = ipmi_sdr_get_record(intf, header, itr);
  }
#line 2080
  if ((unsigned long )rec == (unsigned long )((void *)0)) {
    {
#line 2081
    lprintf(7, "rec == NULL");
#line 2082
    ipmi_sdr_end(intf, itr);
    }
#line 2083
    return (-1);
  }
#line 2085
  if ((int )header->type == 1) {
    {
#line 2087
    rc = ipmi_sdr_print_rawentry(intf, header->type, rec, (int )header->length);
    }
  } else
#line 2085
  if ((int )header->type == 2) {
    {
#line 2087
    rc = ipmi_sdr_print_rawentry(intf, header->type, rec, (int )header->length);
    }
  } else {
#line 2090
    rc = -1;
  }
  {
#line 2092
  free((void *)rec);
#line 2093
  rec = (uint8_t *)((void *)0);
#line 2094
  ipmi_sdr_end(intf, itr);
  }
#line 2095
  return (rc);
}
}
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 239 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 893 "../include/ipmitool/ipmi_sdr.h"
extern double sdr_convert_sensor_reading(struct sdr_record_full_sensor *sensor , uint8_t val ) ;
#line 906
extern struct ipmi_rs *ipmi_sdr_get_sensor_thresholds(struct ipmi_intf *intf , uint8_t sensor ,
                                                      uint8_t target , uint8_t lun ,
                                                      uint8_t channel ) ;
#line 934
extern struct sdr_record_list *ipmi_sdr_find_sdr_byid(struct ipmi_intf *intf , char *id ) ;
#line 364 "../include/ipmitool/ipmi_delloem.h"
int ipmi_delloem_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 166 "../include/ipmitool/ipmi_mc.h"
extern int ipmi_mc_getsysinfo(struct ipmi_intf *intf , int param , int block , int set ,
                              int len , void *buffer ) ;
#line 168
extern int ipmi_mc_setsysinfo(struct ipmi_intf *intf , int len , void *buffer ) ;
#line 88 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
char AciveLOM_String[6][10]  = { {        (char )'N',        (char )'o',        (char )'n',        (char )'e', 
            (char )'\000'}, 
   {        (char )'L',        (char )'O',        (char )'M',        (char )'1', 
            (char )'\000'}, 
   {        (char )'L',        (char )'O',        (char )'M',        (char )'2', 
            (char )'\000'}, 
   {        (char )'L',        (char )'O',        (char )'M',        (char )'3', 
            (char )'\000'}, 
   {        (char )'L',        (char )'O',        (char )'M',        (char )'4', 
            (char )'\000'}, 
   {        (char )'d',        (char )'e',        (char )'d',        (char )'i', 
            (char )'c',        (char )'a',        (char )'t',        (char )'e', 
            (char )'d',        (char )'\000'}};
#line 97 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
char NIC_Selection_Mode_String[4][50]  = { {        (char )'s',        (char )'h',        (char )'a',        (char )'r', 
            (char )'e',        (char )'d',        (char )'\000'}, 
   {        (char )'s',        (char )'h',        (char )'a',        (char )'r', 
            (char )'e',        (char )'d',        (char )' ',        (char )'w', 
            (char )'i',        (char )'t',        (char )'h',        (char )' ', 
            (char )'f',        (char )'a',        (char )'i',        (char )'l', 
            (char )'o',        (char )'v',        (char )'e',        (char )'r', 
            (char )' ',        (char )'l',        (char )'o',        (char )'m', 
            (char )'2',        (char )'\000'}, 
   {        (char )'d',        (char )'e',        (char )'d',        (char )'i', 
            (char )'c',        (char )'a',        (char )'t',        (char )'e', 
            (char )'d',        (char )'\000'}, 
   {        (char )'s',        (char )'h',        (char )'a',        (char )'r', 
            (char )'e',        (char )'d',        (char )' ',        (char )'w', 
            (char )'i',        (char )'t',        (char )'h',        (char )' ', 
            (char )'F',        (char )'a',        (char )'i',        (char )'l', 
            (char )'o',        (char )'v',        (char )'e',        (char )'r', 
            (char )' ',        (char )'a',        (char )'l',        (char )'l', 
            (char )' ',        (char )'l',        (char )'o',        (char )'m', 
            (char )'s',        (char )'\000'}};
#line 104 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
char NIC_Selection_Mode_String_12g[10][50]  = 
#line 104
  { {        (char )'d',        (char )'e',        (char )'d',        (char )'i', 
            (char )'c',        (char )'a',        (char )'t',        (char )'e', 
            (char )'d',        (char )'\000'}, 
   {        (char )'s',        (char )'h',        (char )'a',        (char )'r', 
            (char )'e',        (char )'d',        (char )' ',        (char )'w', 
            (char )'i',        (char )'t',        (char )'h',        (char )' ', 
            (char )'l',        (char )'o',        (char )'m',        (char )'1', 
            (char )'\000'}, 
   {        (char )'s',        (char )'h',        (char )'a',        (char )'r', 
            (char )'e',        (char )'d',        (char )' ',        (char )'w', 
            (char )'i',        (char )'t',        (char )'h',        (char )' ', 
            (char )'l',        (char )'o',        (char )'m',        (char )'2', 
            (char )'\000'}, 
   {        (char )'s',        (char )'h',        (char )'a',        (char )'r', 
            (char )'e',        (char )'d',        (char )' ',        (char )'w', 
            (char )'i',        (char )'t',        (char )'h',        (char )' ', 
            (char )'l',        (char )'o',        (char )'m',        (char )'3', 
            (char )'\000'}, 
   {        (char )'s',        (char )'h',        (char )'a',        (char )'r', 
            (char )'e',        (char )'d',        (char )' ',        (char )'w', 
            (char )'i',        (char )'t',        (char )'h',        (char )' ', 
            (char )'l',        (char )'o',        (char )'m',        (char )'4', 
            (char )'\000'}, 
   {        (char )'s',        (char )'h',        (char )'a',        (char )'r', 
            (char )'e',        (char )'d',        (char )' ',        (char )'w', 
            (char )'i',        (char )'t',        (char )'h',        (char )' ', 
            (char )'f',        (char )'a',        (char )'i',        (char )'l', 
            (char )'o',        (char )'v',        (char )'e',        (char )'r', 
            (char )' ',        (char )'l',        (char )'o',        (char )'m', 
            (char )'1',        (char )'\000'}, 
   {        (char )'s',        (char )'h',        (char )'a',        (char )'r', 
            (char )'e',        (char )'d',        (char )' ',        (char )'w', 
            (char )'i',        (char )'t',        (char )'h',        (char )' ', 
            (char )'f',        (char )'a',        (char )'i',        (char )'l', 
            (char )'o',        (char )'v',        (char )'e',        (char )'r', 
            (char )' ',        (char )'l',        (char )'o',        (char )'m', 
            (char )'2',        (char )'\000'}, 
   {        (char )'s',        (char )'h',        (char )'a',        (char )'r', 
            (char )'e',        (char )'d',        (char )' ',        (char )'w', 
            (char )'i',        (char )'t',        (char )'h',        (char )' ', 
            (char )'f',        (char )'a',        (char )'i',        (char )'l', 
            (char )'o',        (char )'v',        (char )'e',        (char )'r', 
            (char )' ',        (char )'l',        (char )'o',        (char )'m', 
            (char )'3',        (char )'\000'}, 
   {        (char )'s',        (char )'h',        (char )'a',        (char )'r', 
            (char )'e',        (char )'d',        (char )' ',        (char )'w', 
            (char )'i',        (char )'t',        (char )'h',        (char )' ', 
            (char )'f',        (char )'a',        (char )'i',        (char )'l', 
            (char )'o',        (char )'v',        (char )'e',        (char )'r', 
            (char )' ',        (char )'l',        (char )'o',        (char )'m', 
            (char )'4',        (char )'\000'}, 
   {        (char )'s',        (char )'h',        (char )'a',        (char )'r', 
            (char )'e',        (char )'d',        (char )' ',        (char )'w', 
            (char )'i',        (char )'t',        (char )'h',        (char )' ', 
            (char )'f',        (char )'a',        (char )'i',        (char )'l', 
            (char )'o',        (char )'v',        (char )'e',        (char )'r', 
            (char )' ',        (char )'a',        (char )'l',        (char )'l', 
            (char )' ',        (char )'l',        (char )'o',        (char )'m', 
            (char )'s',        (char )'\000'}};
#line 117 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
struct vFlashstr  const  vFlash_completion_code_vals[4]  = {      {(uint8_t )0, "SUCCESS"}, 
        {(uint8_t )1, "NO_SD_CARD"}, 
        {(uint8_t )99, "UNKNOWN_ERROR"}, 
        {(uint8_t )0, (char const   *)((void *)0)}};
#line 124 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int current_arg  =    0;
#line 125 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
uint8_t iDRAC_FLAG  =    (uint8_t )0;
#line 126 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
LCD_MODE lcd_mode  ;
#line 127 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static uint8_t LcdSupported  =    (uint8_t )0;
#line 128 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static uint8_t SetLEDSupported  =    (uint8_t )0;
#line 130 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
unsigned char volatile   IMC_Type  =    (uint8_t volatile   )((uint8_t )8);
#line 132 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
POWER_HEADROOM powerheadroom  ;
#line 134 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
uint8_t PowercapSetable_flag  =    (uint8_t )0;
#line 135 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
uint8_t PowercapstatusFlag  =    (uint8_t )0;
#line 137
static void usage(void) ;
#line 139
static int ipmi_delloem_lcd_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 141
int ipmi_lcd_get_platform_model_name(struct ipmi_intf *intf , char *lcdstring , uint8_t max_length ,
                                     uint8_t field_type ) ;
#line 143
static int ipmi_idracvalidator_command(struct ipmi_intf *intf ) ;
#line 144
static int ipmi_lcd_get_configure_command_wh(struct ipmi_intf *intf ) ;
#line 145
static int ipmi_lcd_get_configure_command(struct ipmi_intf *intf , uint8_t *command ) ;
#line 147
static int ipmi_lcd_set_configure_command(struct ipmi_intf *intf , int command ) ;
#line 148
static int ipmi_lcd_set_configure_command_wh(struct ipmi_intf *intf , uint32_t mode ,
                                             uint16_t lcdquallifier , uint8_t errordisp ) ;
#line 150
static int ipmi_lcd_get_single_line_text(struct ipmi_intf *intf , char *lcdstring ,
                                         uint8_t max_length ) ;
#line 152
static int ipmi_lcd_get_info_wh(struct ipmi_intf *intf ) ;
#line 153
static int ipmi_lcd_get_info(struct ipmi_intf *intf ) ;
#line 154
static int ipmi_lcd_get_status_val(struct ipmi_intf *intf , LCD_STATUS *lcdstatus ) ;
#line 156
static int IsLCDSupported(void) ;
#line 157
static void CheckLCDSupport(struct ipmi_intf *intf ) ;
#line 158
static void ipmi_lcd_status_print(LCD_STATUS lcdstatus ) ;
#line 159
static int ipmi_lcd_get_status(struct ipmi_intf *intf ) ;
#line 160
static int ipmi_lcd_set_kvm(struct ipmi_intf *intf , char status ) ;
#line 161
static int ipmi_lcd_set_lock(struct ipmi_intf *intf , char lock ) ;
#line 162
static int ipmi_lcd_set_single_line_text(struct ipmi_intf *intf , char *text ) ;
#line 163
static int ipmi_lcd_set_text(struct ipmi_intf *intf , char *text , int line_number ) ;
#line 165
static int ipmi_lcd_configure_wh(struct ipmi_intf *intf , uint32_t mode , uint16_t lcdquallifier ,
                                 uint8_t errordisp , int8_t line_number , char *text ) ;
#line 167
static int ipmi_lcd_configure(struct ipmi_intf *intf , int command , int8_t line_number ,
                              char *text ) ;
#line 169
static void ipmi_lcd_usage(void) ;
#line 171
static int ipmi_delloem_mac_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 172
static void InitEmbeddedNICMacAddressValues(void) ;
#line 173
static int ipmi_macinfo_drac_idrac_virtual_mac(struct ipmi_intf *intf , uint8_t NicNum ) ;
#line 175
static int ipmi_macinfo_drac_idrac_mac(struct ipmi_intf *intf , uint8_t NicNum ) ;
#line 176
static int ipmi_macinfo_10g(struct ipmi_intf *intf , uint8_t NicNum ) ;
#line 177
static int ipmi_macinfo_11g(struct ipmi_intf *intf , uint8_t NicNum ) ;
#line 178
static int ipmi_macinfo(struct ipmi_intf *intf , uint8_t NicNum ) ;
#line 179
static void ipmi_mac_usage(void) ;
#line 181
static int ipmi_delloem_lan_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 182
static int IsLANSupported(void) ;
#line 183
static int get_nic_selection_mode(int current_arg___1 , char **argv ) ;
#line 184
static int ipmi_lan_set_nic_selection(struct ipmi_intf *intf , uint8_t nic_selection ) ;
#line 186
static int ipmi_lan_get_nic_selection(struct ipmi_intf *intf ) ;
#line 187
static int ipmi_lan_get_active_nic(struct ipmi_intf *intf ) ;
#line 188
static void ipmi_lan_usage(void) ;
#line 189
static int ipmi_lan_set_nic_selection_12g(struct ipmi_intf *intf , uint8_t *nic_selection ) ;
#line 192
static int ipmi_delloem_powermonitor_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 194
static void ipmi_time_to_str(time_t rawTime , char *strTime ) ;
#line 195
static int ipmi_get_sensor_reading(struct ipmi_intf *intf , unsigned char sensorNumber ,
                                   SensorReadingType *pSensorReadingData ) ;
#line 197
static int ipmi_get_power_capstatus_command(struct ipmi_intf *intf ) ;
#line 198
static int ipmi_set_power_capstatus_command(struct ipmi_intf *intf , uint8_t val ) ;
#line 200
static int ipmi_powermgmt(struct ipmi_intf *intf ) ;
#line 201
static int ipmi_powermgmt_clear(struct ipmi_intf *intf , uint8_t clearValue ) ;
#line 202
static uint64_t watt_to_btuphr_conversion(uint32_t powerinwatt ) ;
#line 203
static uint32_t btuphr_to_watt_conversion(uint64_t powerinbtuphr ) ;
#line 204
static int ipmi_get_power_headroom_command(struct ipmi_intf *intf , uint8_t unit ) ;
#line 205
static int ipmi_get_power_consumption_data(struct ipmi_intf *intf , uint8_t unit ) ;
#line 206
static int ipmi_get_instan_power_consmpt_data(struct ipmi_intf *intf , IPMI_INST_POWER_CONSUMPTION_DATA *instpowerconsumptiondata ) ;
#line 208
static void ipmi_print_get_instan_power_Amps_data(IPMI_INST_POWER_CONSUMPTION_DATA instpowerconsumptiondata ) ;
#line 210
static int ipmi_print_get_power_consmpt_data(struct ipmi_intf *intf , uint8_t unit ) ;
#line 212
static int ipmi_get_avgpower_consmpt_history(struct ipmi_intf *intf , IPMI_AVGPOWER_CONSUMP_HISTORY *pavgpower ) ;
#line 214
static int ipmi_get_peakpower_consmpt_history(struct ipmi_intf *intf , IPMI_POWER_CONSUMP_HISTORY *pstPeakpower ) ;
#line 216
static int ipmi_get_minpower_consmpt_history(struct ipmi_intf *intf , IPMI_POWER_CONSUMP_HISTORY *pstMinpower ) ;
#line 218
static int ipmi_print_power_consmpt_history(struct ipmi_intf *intf , int unit ) ;
#line 219
static int ipmi_get_power_cap(struct ipmi_intf *intf , IPMI_POWER_CAP *ipmipowercap ) ;
#line 221
static int ipmi_print_power_cap(struct ipmi_intf *intf , uint8_t unit ) ;
#line 222
static int ipmi_set_power_cap(struct ipmi_intf *intf , int unit , int val ) ;
#line 223
static void ipmi_powermonitor_usage(void) ;
#line 225
static int ipmi_delloem_vFlash_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 227
char const   *get_vFlash_compcode_str(uint8_t vflashcompcode , struct vFlashstr  const  *vs ) ;
#line 229
static int ipmi_get_sd_card_info(struct ipmi_intf *intf ) ;
#line 230
static int ipmi_delloem_vFlash_process(struct ipmi_intf *intf , int current_arg___1 ,
                                       char **argv ) ;
#line 232
static void ipmi_vFlash_usage(void) ;
#line 234
static int ipmi_getsesmask(int argc , char **argv ) ;
#line 235
static void CheckSetLEDSupport(struct ipmi_intf *intf ) ;
#line 236
static int IsSetLEDSupported(void) ;
#line 237
static void ipmi_setled_usage(void) ;
#line 238
static int ipmi_delloem_setled_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 240
static int ipmi_setled_state(struct ipmi_intf *intf , int bayId , int slotId , int state ) ;
#line 242
static int ipmi_getdrivemap(struct ipmi_intf *intf , int b , int d , int f , int *bay ,
                            int *slot ) ;
#line 256 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
int ipmi_delloem_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 259
  rc = 0;
#line 260
  current_arg = 0;
#line 261
  if (argc == 0) {
    {
#line 262
    usage();
    }
#line 263
    return (0);
  } else {
    {
#line 261
    tmp = strncmp((char const   *)*(argv + 0), "help\000", (size_t )5);
    }
#line 261
    if (tmp == 0) {
      {
#line 262
      usage();
      }
#line 263
      return (0);
    }
  }
  {
#line 265
  tmp___5 = strncmp((char const   *)*(argv + current_arg), "lcd\000", (size_t )4);
  }
#line 265
  if (0 == tmp___5) {
    {
#line 266
    ipmi_delloem_lcd_main(intf, argc, argv);
    }
  } else {
    {
#line 267
    tmp___4 = strncmp((char const   *)*(argv + current_arg), "mac\000", (size_t )4);
    }
#line 267
    if (tmp___4 == 0) {
      {
#line 269
      ipmi_delloem_mac_main(intf, argc, argv);
      }
    } else {
      {
#line 270
      tmp___3 = strncmp((char const   *)*(argv + current_arg), "lan\000", (size_t )4);
      }
#line 270
      if (tmp___3 == 0) {
        {
#line 272
        ipmi_delloem_lan_main(intf, argc, argv);
        }
      } else {
        {
#line 273
        tmp___2 = strncmp((char const   *)*(argv + current_arg), "setled\000", (size_t )7);
        }
#line 273
        if (tmp___2 == 0) {
          {
#line 275
          ipmi_delloem_setled_main(intf, argc, argv);
          }
        } else {
          {
#line 276
          tmp___1 = strncmp((char const   *)*(argv + current_arg), "powermonitor\000",
                            (size_t )13);
          }
#line 276
          if (tmp___1 == 0) {
            {
#line 278
            ipmi_delloem_powermonitor_main(intf, argc, argv);
            }
          } else {
            {
#line 279
            tmp___0 = strncmp((char const   *)*(argv + current_arg), "vFlash\000",
                              (size_t )7);
            }
#line 279
            if (tmp___0 == 0) {
              {
#line 281
              ipmi_delloem_vFlash_main(intf, argc, argv);
              }
            } else {
              {
#line 283
              usage();
              }
#line 284
              return (-1);
            }
          }
        }
      }
    }
  }
#line 286
  return (rc);
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void usage(void) 
{ 


  {
  {
#line 301
  lprintf(5, "");
#line 303
  lprintf(5, "usage: delloem <command> [option...]");
#line 305
  lprintf(5, "");
#line 307
  lprintf(5, "commands:");
#line 309
  lprintf(5, "    lcd");
#line 311
  lprintf(5, "    mac");
#line 313
  lprintf(5, "    lan");
#line 315
  lprintf(5, "    setled");
#line 317
  lprintf(5, "    powermonitor");
#line 319
  lprintf(5, "    vFlash");
#line 321
  lprintf(5, "");
#line 323
  lprintf(5, "For help on individual commands type:");
#line 325
  lprintf(5, "delloem <command> help");
  }
#line 327
  return;
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_delloem_lcd_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int rc ;
  int tmp ;
  uint8_t line_number ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;

  {
#line 344
  rc = 0;
#line 345
  current_arg ++;
#line 346
  if (argc < current_arg) {
    {
#line 347
    usage();
    }
#line 348
    return (-1);
  }
#line 351
  if (argc == 1) {
    {
#line 352
    ipmi_lcd_usage();
    }
#line 353
    return (0);
  } else {
    {
#line 351
    tmp = strcmp((char const   *)*(argv + current_arg), "help");
    }
#line 351
    if (tmp == 0) {
      {
#line 352
      ipmi_lcd_usage();
      }
#line 353
      return (0);
    }
  }
  {
#line 355
  CheckLCDSupport(intf);
#line 356
  ipmi_idracvalidator_command(intf);
#line 357
  tmp___41 = IsLCDSupported();
  }
#line 357
  if (tmp___41) {
    {
#line 360
    tmp___40 = strncmp((char const   *)*(argv + current_arg), "info\000", (size_t )5);
    }
#line 360
    if (tmp___40 == 0) {
#line 361
      if ((int )iDRAC_FLAG == 1) {
        {
#line 362
        rc = ipmi_lcd_get_info_wh(intf);
        }
      } else
#line 361
      if ((int )iDRAC_FLAG == 2) {
        {
#line 362
        rc = ipmi_lcd_get_info_wh(intf);
        }
      } else {
        {
#line 364
        rc = ipmi_lcd_get_info(intf);
        }
      }
    } else {
      {
#line 366
      tmp___39 = strncmp((char const   *)*(argv + current_arg), "status\000", (size_t )7);
      }
#line 366
      if (tmp___39 == 0) {
        {
#line 367
        rc = ipmi_lcd_get_status(intf);
        }
      } else {
        {
#line 368
        tmp___38 = strncmp((char const   *)*(argv + current_arg), "set\000", (size_t )4);
        }
#line 368
        if (tmp___38 == 0) {
#line 370
          line_number = (uint8_t )0;
#line 371
          current_arg ++;
#line 372
          if (argc <= current_arg) {
            {
#line 373
            ipmi_lcd_usage();
            }
#line 374
            return (-1);
          }
          {
#line 376
          tmp___1 = strncmp((char const   *)*(argv + current_arg), "line\000", (size_t )5);
          }
#line 376
          if (tmp___1 == 0) {
#line 377
            current_arg ++;
#line 378
            if (argc <= current_arg) {
              {
#line 379
              usage();
              }
#line 380
              return (-1);
            }
            {
#line 382
            tmp___0 = str2uchar((char const   *)*(argv + current_arg), & line_number);
            }
#line 382
            if (tmp___0 != 0) {
              {
#line 383
              lprintf(3, "Argument \'%s\' is either not a number or out of range.",
                      *(argv + current_arg));
              }
#line 386
              return (-1);
            }
#line 388
            current_arg ++;
#line 389
            if (argc <= current_arg) {
              {
#line 390
              usage();
              }
#line 391
              return (-1);
            }
          }
          {
#line 394
          tmp___37 = strncmp((char const   *)*(argv + current_arg), "mode\000", (size_t )5);
          }
#line 394
          if (tmp___37 == 0) {
#line 394
            if ((int )iDRAC_FLAG == 1) {
#line 394
              goto _L___7;
            } else
#line 394
            if ((int )iDRAC_FLAG == 2) {
              _L___7: /* CIL Label */ 
#line 396
              current_arg ++;
#line 397
              if (argc <= current_arg) {
                {
#line 398
                ipmi_lcd_usage();
                }
#line 399
                return (-1);
              }
#line 401
              if ((unsigned long )*(argv + current_arg) == (unsigned long )((void *)0)) {
                {
#line 402
                ipmi_lcd_usage();
                }
#line 403
                return (-1);
              }
              {
#line 405
              tmp___13 = strncmp((char const   *)*(argv + current_arg), "none\000",
                                 (size_t )5);
              }
#line 405
              if (tmp___13 == 0) {
                {
#line 406
                rc = ipmi_lcd_configure_wh(intf, (uint32_t )2, (uint16_t )255, (uint8_t )255,
                                           (int8_t )0, (char *)((void *)0));
                }
              } else {
                {
#line 408
                tmp___12 = strncmp((char const   *)*(argv + current_arg), "modelname\000",
                                   (size_t )10);
                }
#line 408
                if (tmp___12 == 0) {
                  {
#line 409
                  rc = ipmi_lcd_configure_wh(intf, (uint32_t )1, (uint16_t )255, (uint8_t )255,
                                             (int8_t )0, (char *)((void *)0));
                  }
                } else {
                  {
#line 411
                  tmp___11 = strncmp((char const   *)*(argv + current_arg), "userdefined\000",
                                     (size_t )12);
                  }
#line 411
                  if (tmp___11 == 0) {
#line 412
                    current_arg ++;
#line 413
                    if (argc <= current_arg) {
                      {
#line 414
                      ipmi_lcd_usage();
                      }
#line 415
                      return (-1);
                    }
                    {
#line 417
                    rc = ipmi_lcd_configure_wh(intf, (uint32_t )0, (uint16_t )255,
                                               (uint8_t )255, (int8_t )line_number,
                                               *(argv + current_arg));
                    }
                  } else {
                    {
#line 419
                    tmp___10 = strncmp((char const   *)*(argv + current_arg), "ipv4address\000",
                                       (size_t )12);
                    }
#line 419
                    if (tmp___10 == 0) {
                      {
#line 420
                      rc = ipmi_lcd_configure_wh(intf, (uint32_t )4, (uint16_t )255,
                                                 (uint8_t )255, (int8_t )0, (char *)((void *)0));
                      }
                    } else {
                      {
#line 422
                      tmp___9 = strncmp((char const   *)*(argv + current_arg), "macaddress\000",
                                        (size_t )11);
                      }
#line 422
                      if (tmp___9 == 0) {
                        {
#line 423
                        rc = ipmi_lcd_configure_wh(intf, (uint32_t )8, (uint16_t )255,
                                                   (uint8_t )255, (int8_t )0, (char *)((void *)0));
                        }
                      } else {
                        {
#line 425
                        tmp___8 = strncmp((char const   *)*(argv + current_arg), "systemname\000",
                                          (size_t )11);
                        }
#line 425
                        if (tmp___8 == 0) {
                          {
#line 426
                          rc = ipmi_lcd_configure_wh(intf, (uint32_t )16, (uint16_t )255,
                                                     (uint8_t )255, (int8_t )0, (char *)((void *)0));
                          }
                        } else {
                          {
#line 428
                          tmp___7 = strncmp((char const   *)*(argv + current_arg),
                                            "servicetag\000", (size_t )11);
                          }
#line 428
                          if (tmp___7 == 0) {
                            {
#line 429
                            rc = ipmi_lcd_configure_wh(intf, (uint32_t )32, (uint16_t )255,
                                                       (uint8_t )255, (int8_t )0,
                                                       (char *)((void *)0));
                            }
                          } else {
                            {
#line 431
                            tmp___6 = strncmp((char const   *)*(argv + current_arg),
                                              "ipv6address\000", (size_t )12);
                            }
#line 431
                            if (tmp___6 == 0) {
                              {
#line 432
                              rc = ipmi_lcd_configure_wh(intf, (uint32_t )64, (uint16_t )255,
                                                         (uint8_t )255, (int8_t )0,
                                                         (char *)((void *)0));
                              }
                            } else {
                              {
#line 434
                              tmp___5 = strncmp((char const   *)*(argv + current_arg),
                                                "ambienttemp\000", (size_t )12);
                              }
#line 434
                              if (tmp___5 == 0) {
                                {
#line 435
                                rc = ipmi_lcd_configure_wh(intf, (uint32_t )128, (uint16_t )255,
                                                           (uint8_t )255, (int8_t )0,
                                                           (char *)((void *)0));
                                }
                              } else {
                                {
#line 437
                                tmp___4 = strncmp((char const   *)*(argv + current_arg),
                                                  "systemwatt\000", (size_t )11);
                                }
#line 437
                                if (tmp___4 == 0) {
                                  {
#line 438
                                  rc = ipmi_lcd_configure_wh(intf, (uint32_t )256,
                                                             (uint16_t )255, (uint8_t )255,
                                                             (int8_t )0, (char *)((void *)0));
                                  }
                                } else {
                                  {
#line 440
                                  tmp___3 = strncmp((char const   *)*(argv + current_arg),
                                                    "assettag\000", (size_t )9);
                                  }
#line 440
                                  if (tmp___3 == 0) {
                                    {
#line 441
                                    rc = ipmi_lcd_configure_wh(intf, (uint32_t )512,
                                                               (uint16_t )255, (uint8_t )255,
                                                               (int8_t )0, (char *)((void *)0));
                                    }
                                  } else {
                                    {
#line 443
                                    tmp___2 = strncmp((char const   *)*(argv + current_arg),
                                                      "help\000", (size_t )5);
                                    }
#line 443
                                    if (tmp___2 == 0) {
                                      {
#line 444
                                      ipmi_lcd_usage();
                                      }
                                    } else {
                                      {
#line 446
                                      ipmi_lcd_usage();
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
#line 394
              goto _L___6;
            }
          } else {
            _L___6: /* CIL Label */ 
            {
#line 448
            tmp___36 = strncmp((char const   *)*(argv + current_arg), "lcdqualifier\000",
                               (size_t )13);
            }
#line 448
            if (tmp___36 == 0) {
#line 448
              if ((int )iDRAC_FLAG == 1) {
#line 448
                goto _L___5;
              } else
#line 448
              if ((int )iDRAC_FLAG == 2) {
                _L___5: /* CIL Label */ 
#line 450
                current_arg ++;
#line 451
                if (argc <= current_arg) {
                  {
#line 452
                  ipmi_lcd_usage();
                  }
#line 453
                  return (-1);
                }
#line 455
                if ((unsigned long )*(argv + current_arg) == (unsigned long )((void *)0)) {
                  {
#line 456
                  ipmi_lcd_usage();
                  }
#line 457
                  return (-1);
                }
                {
#line 459
                tmp___18 = strncmp((char const   *)*(argv + current_arg), "watt\000",
                                   (size_t )5);
                }
#line 459
                if (tmp___18 == 0) {
                  {
#line 460
                  rc = ipmi_lcd_configure_wh(intf, (uint32_t )255, (uint16_t )0, (uint8_t )255,
                                             (int8_t )0, (char *)((void *)0));
                  }
                } else {
                  {
#line 461
                  tmp___17 = strncmp((char const   *)*(argv + current_arg), "btuphr\000",
                                     (size_t )7);
                  }
#line 461
                  if (tmp___17 == 0) {
                    {
#line 462
                    rc = ipmi_lcd_configure_wh(intf, (uint32_t )255, (uint16_t )1,
                                               (uint8_t )255, (int8_t )0, (char *)((void *)0));
                    }
                  } else {
                    {
#line 463
                    tmp___16 = strncmp((char const   *)*(argv + current_arg), "celsius\000",
                                       (size_t )8);
                    }
#line 463
                    if (tmp___16 == 0) {
                      {
#line 464
                      rc = ipmi_lcd_configure_wh(intf, (uint32_t )255, (uint16_t )2,
                                                 (uint8_t )255, (int8_t )0, (char *)((void *)0));
                      }
                    } else {
                      {
#line 465
                      tmp___15 = strncmp((char const   *)*(argv + current_arg), "fahrenheit",
                                         (size_t )11);
                      }
#line 465
                      if (tmp___15 == 0) {
                        {
#line 466
                        rc = ipmi_lcd_configure_wh(intf, (uint32_t )255, (uint16_t )3,
                                                   (uint8_t )255, (int8_t )0, (char *)((void *)0));
                        }
                      } else {
                        {
#line 467
                        tmp___14 = strncmp((char const   *)*(argv + current_arg),
                                           "help\000", (size_t )5);
                        }
#line 467
                        if (tmp___14 == 0) {
                          {
#line 468
                          ipmi_lcd_usage();
                          }
                        } else {
                          {
#line 470
                          ipmi_lcd_usage();
                          }
                        }
                      }
                    }
                  }
                }
              } else {
#line 448
                goto _L___4;
              }
            } else {
              _L___4: /* CIL Label */ 
              {
#line 472
              tmp___35 = strncmp((char const   *)*(argv + current_arg), "errordisplay\000",
                                 (size_t )13);
              }
#line 472
              if (tmp___35 == 0) {
#line 472
                if ((int )iDRAC_FLAG == 1) {
#line 472
                  goto _L___3;
                } else
#line 472
                if ((int )iDRAC_FLAG == 2) {
                  _L___3: /* CIL Label */ 
#line 474
                  current_arg ++;
#line 475
                  if (argc <= current_arg) {
                    {
#line 476
                    ipmi_lcd_usage();
                    }
#line 477
                    return (-1);
                  }
#line 479
                  if ((unsigned long )*(argv + current_arg) == (unsigned long )((void *)0)) {
                    {
#line 480
                    ipmi_lcd_usage();
                    }
#line 481
                    return (-1);
                  }
                  {
#line 483
                  tmp___21 = strncmp((char const   *)*(argv + current_arg), "sel\000",
                                     (size_t )4);
                  }
#line 483
                  if (tmp___21 == 0) {
                    {
#line 484
                    rc = ipmi_lcd_configure_wh(intf, (uint32_t )255, (uint16_t )255,
                                               (uint8_t )1, (int8_t )0, (char *)((void *)0));
                    }
                  } else {
                    {
#line 486
                    tmp___20 = strncmp((char const   *)*(argv + current_arg), "simple\000",
                                       (size_t )7);
                    }
#line 486
                    if (tmp___20 == 0) {
                      {
#line 487
                      rc = ipmi_lcd_configure_wh(intf, (uint32_t )255, (uint16_t )255,
                                                 (uint8_t )2, (int8_t )0, (char *)((void *)0));
                      }
                    } else {
                      {
#line 489
                      tmp___19 = strncmp((char const   *)*(argv + current_arg), "help\000",
                                         (size_t )5);
                      }
#line 489
                      if (tmp___19 == 0) {
                        {
#line 490
                        ipmi_lcd_usage();
                        }
                      } else {
                        {
#line 492
                        ipmi_lcd_usage();
                        }
                      }
                    }
                  }
                } else {
#line 472
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
                {
#line 494
                tmp___34 = strncmp((char const   *)*(argv + current_arg), "none\000",
                                   (size_t )5);
                }
#line 494
                if (tmp___34 == 0) {
#line 494
                  if ((int )iDRAC_FLAG == 0) {
                    {
#line 496
                    rc = ipmi_lcd_configure(intf, 2, (int8_t )0, (char *)((void *)0));
                    }
                  } else {
#line 494
                    goto _L___1;
                  }
                } else {
                  _L___1: /* CIL Label */ 
                  {
#line 497
                  tmp___33 = strncmp((char const   *)*(argv + current_arg), "default\000",
                                     (size_t )8);
                  }
#line 497
                  if (tmp___33 == 0) {
#line 497
                    if ((int )iDRAC_FLAG == 0) {
                      {
#line 499
                      rc = ipmi_lcd_configure(intf, 1, (int8_t )0, (char *)((void *)0));
                      }
                    } else {
#line 497
                      goto _L___0;
                    }
                  } else {
                    _L___0: /* CIL Label */ 
                    {
#line 500
                    tmp___32 = strncmp((char const   *)*(argv + current_arg), "custom\000",
                                       (size_t )7);
                    }
#line 500
                    if (tmp___32 == 0) {
#line 500
                      if ((int )iDRAC_FLAG == 0) {
#line 502
                        current_arg ++;
#line 503
                        if (argc <= current_arg) {
                          {
#line 504
                          ipmi_lcd_usage();
                          }
#line 505
                          return (-1);
                        }
                        {
#line 507
                        rc = ipmi_lcd_configure(intf, 0, (int8_t )line_number, *(argv + current_arg));
                        }
                      } else {
#line 500
                        goto _L;
                      }
                    } else {
                      _L: /* CIL Label */ 
                      {
#line 509
                      tmp___31 = strncmp((char const   *)*(argv + current_arg), "vkvm\000",
                                         (size_t )5);
                      }
#line 509
                      if (tmp___31 == 0) {
#line 510
                        current_arg ++;
#line 511
                        if (argc <= current_arg) {
                          {
#line 512
                          ipmi_lcd_usage();
                          }
#line 513
                          return (-1);
                        }
                        {
#line 515
                        tmp___24 = strncmp((char const   *)*(argv + current_arg),
                                           "active\000", (size_t )7);
                        }
#line 515
                        if (tmp___24 == 0) {
                          {
#line 516
                          rc = ipmi_lcd_set_kvm(intf, (char)1);
                          }
                        } else {
                          {
#line 517
                          tmp___23 = strncmp((char const   *)*(argv + current_arg),
                                             "inactive\000", (size_t )9);
                          }
#line 517
                          if (tmp___23 == 0) {
                            {
#line 518
                            rc = ipmi_lcd_set_kvm(intf, (char)0);
                            }
                          } else {
                            {
#line 519
                            tmp___22 = strncmp((char const   *)*(argv + current_arg),
                                               "help\000", (size_t )5);
                            }
#line 519
                            if (tmp___22 == 0) {
                              {
#line 520
                              ipmi_lcd_usage();
                              }
                            } else {
                              {
#line 522
                              ipmi_lcd_usage();
                              }
                            }
                          }
                        }
                      } else {
                        {
#line 524
                        tmp___30 = strncmp((char const   *)*(argv + current_arg),
                                           "frontpanelaccess\000", (size_t )17);
                        }
#line 524
                        if (tmp___30 == 0) {
#line 525
                          current_arg ++;
#line 526
                          if (argc <= current_arg) {
                            {
#line 527
                            ipmi_lcd_usage();
                            }
#line 528
                            return (-1);
                          }
                          {
#line 530
                          tmp___28 = strncmp((char const   *)*(argv + current_arg),
                                             "viewandmodify\000", (size_t )14);
                          }
#line 530
                          if (tmp___28 == 0) {
                            {
#line 531
                            rc = ipmi_lcd_set_lock(intf, (char)0);
                            }
                          } else {
                            {
#line 532
                            tmp___27 = strncmp((char const   *)*(argv + current_arg),
                                               "viewonly\000", (size_t )9);
                            }
#line 532
                            if (tmp___27 == 0) {
                              {
#line 533
                              rc = ipmi_lcd_set_lock(intf, (char)1);
                              }
                            } else {
                              {
#line 534
                              tmp___26 = strncmp((char const   *)*(argv + current_arg),
                                                 "disabled\000", (size_t )9);
                              }
#line 534
                              if (tmp___26 == 0) {
                                {
#line 535
                                rc = ipmi_lcd_set_lock(intf, (char)2);
                                }
                              } else {
                                {
#line 536
                                tmp___25 = strncmp((char const   *)*(argv + current_arg),
                                                   "help\000", (size_t )5);
                                }
#line 536
                                if (tmp___25 == 0) {
                                  {
#line 537
                                  ipmi_lcd_usage();
                                  }
                                } else {
                                  {
#line 539
                                  ipmi_lcd_usage();
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          {
#line 541
                          tmp___29 = strncmp((char const   *)*(argv + current_arg),
                                             "help\000", (size_t )5);
                          }
#line 541
                          if (tmp___29 == 0) {
#line 541
                            if ((int )iDRAC_FLAG == 0) {
                              {
#line 543
                              ipmi_lcd_usage();
                              }
                            } else {
                              {
#line 545
                              ipmi_lcd_usage();
                              }
#line 546
                              return (-1);
                            }
                          } else {
                            {
#line 545
                            ipmi_lcd_usage();
                            }
#line 546
                            return (-1);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          {
#line 549
          ipmi_lcd_usage();
          }
#line 550
          return (-1);
        }
      }
    }
  } else {
    {
#line 358
    lprintf(3, "lcd is not supported on this system.");
    }
#line 359
    return (-1);
  }
#line 552
  return (rc);
}
}
#line 564 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
int ipmi_lcd_get_platform_model_name(struct ipmi_intf *intf , char *lcdstring , uint8_t max_length ,
                                     uint8_t field_type ) 
{ 
  int bytes_copied ;
  int ii ;
  int lcdstring_len ;
  int rc ;
  IPMI_DELL_LCD_STRING lcdstringblock ;
  int bytes_to_copy ;
  char const   *tmp ;
  int string_offset ;

  {
#line 569
  bytes_copied = 0;
#line 570
  ii = 0;
#line 571
  lcdstring_len = 0;
#line 572
  rc = 0;
#line 575
  ii = 0;
  {
#line 575
  while (1) {
    while_continue: /* CIL Label */ ;
#line 575
    if (! (ii < 4)) {
#line 575
      goto while_break;
    }
    {
#line 577
    rc = ipmi_mc_getsysinfo(intf, (int )field_type, ii, 0, (int )sizeof(lcdstringblock),
                            (void *)(& lcdstringblock));
    }
#line 579
    if (rc < 0) {
      {
#line 580
      lprintf(3, "Error getting platform model name");
      }
#line 581
      goto while_break;
    } else
#line 582
    if (rc > 0) {
      {
#line 583
      tmp = val2str((uint16_t )rc, completion_code_vals);
#line 583
      lprintf(3, "Error getting platform model name: %s", tmp);
      }
#line 585
      goto while_break;
    }
#line 588
    if (ii == 0) {
#line 589
      lcdstring_len = (int )lcdstringblock.lcd_string.selector_0_string.length;
#line 590
      if (lcdstring_len < (int )max_length) {
#line 590
        lcdstring_len = lcdstring_len;
      } else {
#line 590
        lcdstring_len = (int )max_length;
      }
#line 591
      if (lcdstring_len < 14) {
#line 591
        bytes_to_copy = lcdstring_len;
      } else {
#line 591
        bytes_to_copy = 14;
      }
      {
#line 592
      memcpy((void */* __restrict  */)lcdstring, (void const   */* __restrict  */)(lcdstringblock.lcd_string.selector_0_string.data),
             (size_t )bytes_to_copy);
      }
    } else {
#line 596
      if (lcdstring_len - bytes_copied < 16) {
#line 596
        bytes_to_copy = lcdstring_len - bytes_copied;
      } else {
#line 596
        bytes_to_copy = 16;
      }
#line 598
      if (bytes_to_copy < 1) {
#line 599
        goto while_break;
      }
      {
#line 601
      string_offset = 14 + 16 * (ii - 1);
#line 603
      memcpy((void */* __restrict  */)(lcdstring + string_offset), (void const   */* __restrict  */)(lcdstringblock.lcd_string.selector_n_data),
             (size_t )bytes_to_copy);
      }
    }
#line 606
    bytes_copied += bytes_to_copy;
#line 607
    if (bytes_copied >= lcdstring_len) {
#line 608
      goto while_break;
    }
#line 575
    ii ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 611
  return (rc);
}
}
#line 623 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_idracvalidator_command(struct ipmi_intf *intf ) 
{ 
  int rc ;
  uint8_t data[11] ;

  {
  {
#line 628
  rc = ipmi_mc_getsysinfo(intf, 221, 2, 0, (int )sizeof(data), (void *)(data));
  }
#line 630
  if (rc < 0) {
#line 632
    return (-1);
  } else
#line 633
  if (rc > 0) {
#line 636
    return (-1);
  }
#line 639
  if (10 == (int )data[10]) {
#line 643
    iDRAC_FLAG = (uint8_t )1;
  } else
#line 639
  if (11 == (int )data[10]) {
#line 643
    iDRAC_FLAG = (uint8_t )1;
  } else
#line 639
  if (13 == (int )data[10]) {
#line 643
    iDRAC_FLAG = (uint8_t )1;
  } else
#line 639
  if (14 == (int )data[10]) {
#line 643
    iDRAC_FLAG = (uint8_t )1;
  } else
#line 644
  if (16 == (int )data[10]) {
#line 646
    iDRAC_FLAG = (uint8_t )2;
  } else
#line 644
  if (17 == (int )data[10]) {
#line 646
    iDRAC_FLAG = (uint8_t )2;
  } else {
#line 648
    iDRAC_FLAG = (uint8_t )0;
  }
#line 650
  IMC_Type = (unsigned char volatile   )data[10];
#line 651
  return (0);
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_get_configure_command_wh(struct ipmi_intf *intf ) 
{ 
  int rc ;
  char const   *tmp ;

  {
  {
#line 671
  rc = ipmi_mc_getsysinfo(intf, 194, 0, 0, (int )sizeof(lcd_mode), (void *)(& lcd_mode));
  }
#line 673
  if (rc < 0) {
    {
#line 674
    lprintf(3, "Error getting LCD configuration");
    }
#line 675
    return (-1);
  } else
#line 676
  if (rc == 193) {
    {
#line 677
    lprintf(3, "Error getting LCD configuration: Command not supported on this system.");
    }
  } else
#line 676
  if (rc == 203) {
    {
#line 677
    lprintf(3, "Error getting LCD configuration: Command not supported on this system.");
    }
  } else
#line 679
  if (rc > 0) {
    {
#line 680
    tmp = val2str((uint16_t )rc, completion_code_vals);
#line 680
    lprintf(3, "Error getting LCD configuration: %s", tmp);
    }
#line 682
    return (-1);
  }
#line 684
  return (0);
}
}
#line 697 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_get_configure_command(struct ipmi_intf *intf , uint8_t *command ) 
{ 
  uint8_t data[4] ;
  int rc ;
  char const   *tmp ;

  {
  {
#line 702
  rc = ipmi_mc_getsysinfo(intf, 194, 0, 0, (int )sizeof(data), (void *)(data));
  }
#line 704
  if (rc < 0) {
    {
#line 705
    lprintf(3, "Error getting LCD configuration");
    }
#line 706
    return (-1);
  } else
#line 707
  if (rc == 193) {
    {
#line 708
    lprintf(3, "Error getting LCD configuration: Command not supported on this system.");
    }
#line 710
    return (-1);
  } else
#line 707
  if (rc == 203) {
    {
#line 708
    lprintf(3, "Error getting LCD configuration: Command not supported on this system.");
    }
#line 710
    return (-1);
  } else
#line 711
  if (rc > 0) {
    {
#line 712
    tmp = val2str((uint16_t )rc, completion_code_vals);
#line 712
    lprintf(3, "Error getting LCD configuration: %s", tmp);
    }
#line 714
    return (-1);
  }
#line 717
  *command = data[1];
#line 718
  return (0);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_set_configure_command(struct ipmi_intf *intf , int command ) 
{ 
  uint8_t data[2] ;
  int rc ;
  char const   *tmp ;

  {
  {
#line 736
  data[0] = (uint8_t )194;
#line 737
  data[1] = (uint8_t )command;
#line 738
  rc = ipmi_mc_setsysinfo(intf, 2, (void *)(data));
  }
#line 739
  if (rc < 0) {
    {
#line 740
    lprintf(3, "Error setting LCD configuration");
    }
#line 741
    return (-1);
  } else
#line 742
  if (rc == 193) {
    {
#line 743
    lprintf(3, "Error setting LCD configuration: Command not supported on this system.");
    }
  } else
#line 742
  if (rc == 203) {
    {
#line 743
    lprintf(3, "Error setting LCD configuration: Command not supported on this system.");
    }
  } else
#line 745
  if (rc > 0) {
    {
#line 746
    tmp = val2str((uint16_t )rc, completion_code_vals);
#line 746
    lprintf(3, "Error setting LCD configuration: %s", tmp);
    }
#line 748
    return (-1);
  }
#line 750
  return (0);
}
}
#line 763 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_set_configure_command_wh(struct ipmi_intf *intf , uint32_t mode ,
                                             uint16_t lcdquallifier , uint8_t errordisp ) 
{ 
  uint8_t data[13] ;
  int rc ;
  char const   *tmp ;

  {
  {
#line 770
  ipmi_lcd_get_configure_command_wh(intf);
#line 771
  data[0] = (uint8_t )194;
  }
#line 772
  if (mode != 255U) {
#line 773
    data[1] = (uint8_t )(mode & 255U);
#line 774
    data[2] = (uint8_t )((mode & 65280U) >> 8);
#line 775
    data[3] = (uint8_t )((mode & 16711680U) >> 16);
#line 776
    data[4] = (uint8_t )((mode & 4278190080U) >> 24);
  } else {
#line 778
    data[1] = (uint8_t )(lcd_mode.lcdmode & 255U);
#line 779
    data[2] = (uint8_t )((lcd_mode.lcdmode & 65280U) >> 8);
#line 780
    data[3] = (uint8_t )((lcd_mode.lcdmode & 16711680U) >> 16);
#line 781
    data[4] = (uint8_t )((lcd_mode.lcdmode & 4278190080U) >> 24);
  }
#line 783
  if ((int )lcdquallifier != 255) {
#line 784
    if ((int )lcdquallifier == 1) {
#line 785
      data[5] = (uint8_t )((int )lcd_mode.lcdquallifier | 1);
    } else
#line 786
    if ((int )lcdquallifier == 0) {
#line 787
      data[5] = (uint8_t )((int )lcd_mode.lcdquallifier & 254);
    } else
#line 788
    if ((int )lcdquallifier == 3) {
#line 789
      data[5] = (uint8_t )((int )lcd_mode.lcdquallifier | 2);
    } else
#line 790
    if ((int )lcdquallifier == 2) {
#line 791
      data[5] = (uint8_t )((int )lcd_mode.lcdquallifier & 253);
    }
  } else {
#line 794
    data[5] = (uint8_t )lcd_mode.lcdquallifier;
  }
#line 796
  if ((int )errordisp != 255) {
#line 797
    data[11] = errordisp;
  } else {
#line 799
    data[11] = lcd_mode.error_display;
  }
  {
#line 801
  rc = ipmi_mc_setsysinfo(intf, 13, (void *)(data));
  }
#line 802
  if (rc < 0) {
    {
#line 803
    lprintf(3, "Error setting LCD configuration");
    }
#line 804
    return (-1);
  } else
#line 805
  if (rc == 193) {
    {
#line 806
    lprintf(3, "Error setting LCD configuration: Command not supported on this system.");
    }
  } else
#line 805
  if (rc == 203) {
    {
#line 806
    lprintf(3, "Error setting LCD configuration: Command not supported on this system.");
    }
  } else
#line 808
  if (rc > 0) {
    {
#line 809
    tmp = val2str((uint16_t )rc, completion_code_vals);
#line 809
    lprintf(3, "Error setting LCD configuration: %s", tmp);
    }
#line 811
    return (-1);
  }
#line 813
  return (0);
}
}
#line 825 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_get_single_line_text(struct ipmi_intf *intf , char *lcdstring ,
                                         uint8_t max_length ) 
{ 
  IPMI_DELL_LCD_STRING lcdstringblock ;
  int lcdstring_len ;
  int bytes_copied ;
  int ii ;
  int rc ;
  int bytes_to_copy ;
  char const   *tmp ;
  int string_offset ;

  {
#line 830
  lcdstring_len = 0;
#line 831
  bytes_copied = 0;
#line 833
  ii = 0;
  {
#line 833
  while (1) {
    while_continue: /* CIL Label */ ;
#line 833
    if (! (ii < 4)) {
#line 833
      goto while_break;
    }
    {
#line 835
    rc = ipmi_mc_getsysinfo(intf, 193, ii, 0, (int )sizeof(lcdstringblock), (void *)(& lcdstringblock));
    }
#line 837
    if (rc < 0) {
      {
#line 838
      lprintf(3, "Error getting text data");
      }
#line 839
      return (-1);
    } else
#line 840
    if (rc > 0) {
      {
#line 841
      tmp = val2str((uint16_t )rc, completion_code_vals);
#line 841
      lprintf(3, "Error getting text data: %s", tmp);
      }
#line 843
      return (-1);
    }
#line 846
    if (0 == ii) {
#line 847
      lcdstring_len = (int )lcdstringblock.lcd_string.selector_0_string.length;
#line 848
      if (lcdstring_len < 1) {
#line 849
        goto while_break;
      } else
#line 848
      if (lcdstring_len > (int )max_length) {
#line 849
        goto while_break;
      }
#line 851
      if (lcdstring_len < 14) {
#line 851
        bytes_to_copy = lcdstring_len;
      } else {
#line 851
        bytes_to_copy = 14;
      }
      {
#line 852
      memcpy((void */* __restrict  */)lcdstring, (void const   */* __restrict  */)(lcdstringblock.lcd_string.selector_0_string.data),
             (size_t )bytes_to_copy);
      }
    } else {
#line 856
      if (lcdstring_len - bytes_copied < 16) {
#line 856
        bytes_to_copy = lcdstring_len - bytes_copied;
      } else {
#line 856
        bytes_to_copy = 16;
      }
#line 858
      if (bytes_to_copy < 1) {
#line 859
        goto while_break;
      }
      {
#line 861
      string_offset = 14 + 16 * (ii - 1);
#line 863
      memcpy((void */* __restrict  */)(lcdstring + string_offset), (void const   */* __restrict  */)(lcdstringblock.lcd_string.selector_n_data),
             (size_t )bytes_to_copy);
      }
    }
#line 866
    bytes_copied += bytes_to_copy;
#line 867
    if (bytes_copied >= lcdstring_len) {
#line 868
      goto while_break;
    }
#line 833
    ii ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 871
  return (0);
}
}
#line 881 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_get_info_wh(struct ipmi_intf *intf ) 
{ 
  IPMI_DELL_LCD_CAPS lcd_caps ;
  char lcdstring[63] ;
  unsigned int tmp ;
  int rc ;
  int tmp___0 ;
  char text[63] ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;

  {
#line 885
  lcdstring[0] = (char)0;
#line 885
  tmp = 1U;
  {
#line 885
  while (1) {
    while_continue: /* CIL Label */ ;
#line 885
    if (tmp >= 63U) {
#line 885
      goto while_break;
    }
#line 885
    lcdstring[tmp] = (char)0;
#line 885
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 887
  printf((char const   */* __restrict  */)"LCD info\n");
#line 888
  tmp___0 = ipmi_lcd_get_configure_command_wh(intf);
  }
#line 888
  if (tmp___0 != 0) {
#line 889
    return (-1);
  }
#line 891
  if (lcd_mode.lcdmode == 1U) {
#line 892
    text[0] = (char)0;
#line 892
    tmp___1 = 1U;
    {
#line 892
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 892
      if (tmp___1 >= 63U) {
#line 892
        goto while_break___0;
      }
#line 892
      text[tmp___1] = (char)0;
#line 892
      tmp___1 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 893
    tmp___2 = ipmi_lcd_get_platform_model_name(intf, text, (uint8_t )62, (uint8_t )209);
    }
#line 893
    if (tmp___2 != 0) {
#line 896
      return (-1);
    }
    {
#line 898
    printf((char const   */* __restrict  */)"    Setting:Model name\n");
#line 899
    printf((char const   */* __restrict  */)"    Line 1:  %s\n", text);
    }
  } else
#line 900
  if (lcd_mode.lcdmode == 2U) {
    {
#line 901
    printf((char const   */* __restrict  */)"    Setting:   none\n");
    }
  } else
#line 902
  if (lcd_mode.lcdmode == 0U) {
    {
#line 903
    printf((char const   */* __restrict  */)"    Setting: User defined\n");
#line 904
    rc = ipmi_mc_getsysinfo(intf, 207, 0, 0, (int )sizeof(lcd_caps), (void *)(& lcd_caps));
    }
#line 906
    if (rc < 0) {
      {
#line 907
      lprintf(3, "Error getting LCD capabilities.");
      }
#line 908
      return (-1);
    } else
#line 909
    if (rc == 193) {
      {
#line 910
      lprintf(3, "Error getting LCD capabilities: Command not supported on this system.");
      }
    } else
#line 909
    if (rc == 203) {
      {
#line 910
      lprintf(3, "Error getting LCD capabilities: Command not supported on this system.");
      }
    } else
#line 912
    if (rc > 0) {
      {
#line 913
      tmp___3 = val2str((uint16_t )rc, completion_code_vals);
#line 913
      lprintf(3, "Error getting LCD capabilities: %s", tmp___3);
      }
#line 915
      return (-1);
    }
#line 917
    if ((int )lcd_caps.number_lines > 0) {
      {
#line 918
      memset((void *)(lcdstring), 0, (size_t )63);
#line 919
      rc = ipmi_lcd_get_single_line_text(intf, lcdstring, lcd_caps.max_chars[0]);
#line 921
      printf((char const   */* __restrict  */)"    Text:    %s\n", lcdstring);
      }
    } else {
      {
#line 923
      printf((char const   */* __restrict  */)"    No lines to show\n");
      }
    }
  } else
#line 925
  if (lcd_mode.lcdmode == 4U) {
    {
#line 926
    printf((char const   */* __restrict  */)"    Setting:   IPV4 Address\n");
    }
  } else
#line 927
  if (lcd_mode.lcdmode == 8U) {
    {
#line 928
    printf((char const   */* __restrict  */)"    Setting:   MAC Address\n");
    }
  } else
#line 929
  if (lcd_mode.lcdmode == 16U) {
    {
#line 930
    printf((char const   */* __restrict  */)"    Setting:   OS System Name\n");
    }
  } else
#line 931
  if (lcd_mode.lcdmode == 32U) {
    {
#line 932
    printf((char const   */* __restrict  */)"    Setting:   System Tag\n");
    }
  } else
#line 933
  if (lcd_mode.lcdmode == 64U) {
    {
#line 934
    printf((char const   */* __restrict  */)"    Setting:  IPV6 Address\n");
    }
  } else
#line 935
  if (lcd_mode.lcdmode == 512U) {
    {
#line 936
    printf((char const   */* __restrict  */)"    Setting:  Asset Tag\n");
    }
  } else
#line 937
  if (lcd_mode.lcdmode == 128U) {
    {
#line 938
    printf((char const   */* __restrict  */)"    Setting:  Ambient Temp\n");
    }
#line 939
    if ((int )lcd_mode.lcdquallifier & 2) {
      {
#line 940
      printf((char const   */* __restrict  */)"    Unit:  F\n");
      }
    } else {
      {
#line 942
      printf((char const   */* __restrict  */)"    Unit:  C\n");
      }
    }
  } else
#line 944
  if (lcd_mode.lcdmode == 256U) {
    {
#line 945
    printf((char const   */* __restrict  */)"    Setting:  System Watts\n");
    }
#line 946
    if ((int )lcd_mode.lcdquallifier & 1) {
      {
#line 947
      printf((char const   */* __restrict  */)"    Unit:  BTU/hr\n");
      }
    } else {
      {
#line 949
      printf((char const   */* __restrict  */)"    Unit:  Watt\n");
      }
    }
  }
#line 952
  if ((int )lcd_mode.error_display == 1) {
    {
#line 953
    printf((char const   */* __restrict  */)"    Error Display:  SEL\n");
    }
  } else
#line 954
  if ((int )lcd_mode.error_display == 2) {
    {
#line 955
    printf((char const   */* __restrict  */)"    Error Display:  Simple\n");
    }
  }
#line 957
  return (0);
}
}
#line 967 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_get_info(struct ipmi_intf *intf ) 
{ 
  IPMI_DELL_LCD_CAPS lcd_caps ;
  uint8_t command ;
  char lcdstring[63] ;
  unsigned int tmp ;
  int rc ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
#line 971
  command = (uint8_t )0;
#line 972
  lcdstring[0] = (char)0;
#line 972
  tmp = 1U;
  {
#line 972
  while (1) {
    while_continue: /* CIL Label */ ;
#line 972
    if (tmp >= 63U) {
#line 972
      goto while_break;
    }
#line 972
    lcdstring[tmp] = (char)0;
#line 972
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 975
  printf((char const   */* __restrict  */)"LCD info\n");
#line 977
  tmp___0 = ipmi_lcd_get_configure_command(intf, & command);
  }
#line 977
  if (tmp___0 != 0) {
#line 978
    return (-1);
  }
#line 980
  if ((int )command == 1) {
    {
#line 981
    memset((void *)(lcdstring), 0, (size_t )63);
#line 982
    tmp___1 = ipmi_lcd_get_platform_model_name(intf, lcdstring, (uint8_t )62, (uint8_t )209);
    }
#line 982
    if (tmp___1 != 0) {
#line 985
      return (-1);
    }
    {
#line 987
    printf((char const   */* __restrict  */)"    Setting: default\n");
#line 988
    printf((char const   */* __restrict  */)"    Line 1:  %s\n", lcdstring);
    }
  } else
#line 989
  if ((int )command == 2) {
    {
#line 990
    printf((char const   */* __restrict  */)"    Setting:   none\n");
    }
  } else
#line 991
  if ((int )command == 0) {
    {
#line 992
    printf((char const   */* __restrict  */)"    Setting: custom\n");
#line 993
    rc = ipmi_mc_getsysinfo(intf, 207, 0, 0, (int )sizeof(lcd_caps), (void *)(& lcd_caps));
    }
#line 995
    if (rc < 0) {
      {
#line 996
      lprintf(3, "Error getting LCD capabilities.");
      }
#line 997
      return (-1);
    } else
#line 998
    if (rc == 193) {
      {
#line 999
      lprintf(3, "Error getting LCD capabilities: Command not supported on this system.");
      }
    } else
#line 998
    if (rc == 203) {
      {
#line 999
      lprintf(3, "Error getting LCD capabilities: Command not supported on this system.");
      }
    } else
#line 1001
    if (rc > 0) {
      {
#line 1002
      tmp___2 = val2str((uint16_t )rc, completion_code_vals);
#line 1002
      lprintf(3, "Error getting LCD capabilities: %s", tmp___2);
      }
#line 1004
      return (-1);
    }
#line 1006
    if ((int )lcd_caps.number_lines > 0) {
      {
#line 1007
      memset((void *)(lcdstring), 0, (size_t )63);
#line 1008
      rc = ipmi_lcd_get_single_line_text(intf, lcdstring, lcd_caps.max_chars[0]);
#line 1010
      printf((char const   */* __restrict  */)"    Text:    %s\n", lcdstring);
      }
    } else {
      {
#line 1012
      printf((char const   */* __restrict  */)"    No lines to show\n");
      }
    }
  }
#line 1015
  return (0);
}
}
#line 1025 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_get_status_val(struct ipmi_intf *intf , LCD_STATUS *lcdstatus ) 
{ 
  int rc ;
  char const   *tmp ;

  {
  {
#line 1029
  rc = ipmi_mc_getsysinfo(intf, 231, 0, 0, (int )sizeof(*lcdstatus), (void *)lcdstatus);
  }
#line 1031
  if (rc < 0) {
    {
#line 1032
    lprintf(3, "Error getting LCD Status");
    }
#line 1033
    return (-1);
  } else
#line 1034
  if (rc == 193) {
    {
#line 1035
    lprintf(3, "Error getting LCD status: Command not supported on this system.");
    }
#line 1037
    return (-1);
  } else
#line 1034
  if (rc == 203) {
    {
#line 1035
    lprintf(3, "Error getting LCD status: Command not supported on this system.");
    }
#line 1037
    return (-1);
  } else
#line 1038
  if (rc > 0) {
    {
#line 1039
    tmp = val2str((uint16_t )rc, completion_code_vals);
#line 1039
    lprintf(3, "Error getting LCD Status: %s", tmp);
    }
#line 1041
    return (-1);
  }
#line 1043
  return (0);
}
}
#line 1053 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int IsLCDSupported(void) 
{ 


  {
#line 1056
  return ((int )LcdSupported);
}
}
#line 1066 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void CheckLCDSupport(struct ipmi_intf *intf ) 
{ 
  int rc ;

  {
  {
#line 1070
  LcdSupported = (uint8_t )0;
#line 1071
  rc = ipmi_mc_getsysinfo(intf, 231, 0, 0, 0, (void *)0);
  }
#line 1072
  if (rc == 0) {
#line 1073
    LcdSupported = (uint8_t )1;
  }
#line 1075
  return;
}
}
#line 1084 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void ipmi_lcd_status_print(LCD_STATUS lcdstatus ) 
{ 


  {
  {
#line 1088
  if ((int )lcdstatus.vKVM_status == 0) {
#line 1088
    goto case_0;
  }
#line 1091
  if ((int )lcdstatus.vKVM_status == 1) {
#line 1091
    goto case_1;
  }
#line 1094
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1089
  printf((char const   */* __restrict  */)"LCD KVM Status :Inactive\n");
  }
#line 1090
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1092
  printf((char const   */* __restrict  */)"LCD KVM Status :Active\n");
  }
#line 1093
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1095
  printf((char const   */* __restrict  */)"LCD KVM Status :Invalid Status\n");
  }
#line 1096
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1099
  if ((int )lcdstatus.lock_status == 0) {
#line 1099
    goto case_0___0;
  }
#line 1102
  if ((int )lcdstatus.lock_status == 1) {
#line 1102
    goto case_1___0;
  }
#line 1105
  if ((int )lcdstatus.lock_status == 2) {
#line 1105
    goto case_2;
  }
#line 1108
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
  {
#line 1100
  printf((char const   */* __restrict  */)"LCD lock Status :View and modify\n");
  }
#line 1101
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 1103
  printf((char const   */* __restrict  */)"LCD lock Status :View only\n");
  }
#line 1104
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 1106
  printf((char const   */* __restrict  */)"LCD lock Status :disabled\n");
  }
#line 1107
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 1109
  printf((char const   */* __restrict  */)"LCD lock Status :Invalid\n");
  }
#line 1110
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1112
  return;
}
}
#line 1122 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_get_status(struct ipmi_intf *intf ) 
{ 
  int rc ;
  LCD_STATUS lcdstatus ;

  {
  {
#line 1125
  rc = 0;
#line 1127
  rc = ipmi_lcd_get_status_val(intf, & lcdstatus);
  }
#line 1128
  if (rc < 0) {
#line 1129
    return (-1);
  }
  {
#line 1131
  ipmi_lcd_status_print(lcdstatus);
  }
#line 1132
  return (rc);
}
}
#line 1144 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_set_kvm(struct ipmi_intf *intf , char status ) 
{ 
  LCD_STATUS lcdstatus ;
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t data[5] ;
  char const   *tmp ;

  {
  {
#line 1149
  rc = 0;
#line 1150
  rsp = (struct ipmi_rs *)((void *)0);
#line 1151
  req.msg.netfn = (uint8_t )0;
#line 1151
  req.msg.lun = (unsigned char)0;
#line 1151
  req.msg.cmd = (unsigned char)0;
#line 1151
  req.msg.target_cmd = (unsigned char)0;
#line 1151
  req.msg.data_len = (unsigned short)0;
#line 1151
  req.msg.data = (uint8_t *)0;
#line 1153
  rc = ipmi_lcd_get_status_val(intf, & lcdstatus);
  }
#line 1154
  if (rc < 0) {
#line 1155
    return (-1);
  }
  {
#line 1157
  req.msg.netfn = (uint8_t )6;
#line 1158
  req.msg.lun = (uint8_t )0;
#line 1159
  req.msg.cmd = (uint8_t )88;
#line 1160
  req.msg.data_len = (uint16_t )5;
#line 1161
  req.msg.data = data;
#line 1162
  data[0] = (uint8_t )231;
#line 1163
  data[1] = (uint8_t )status;
#line 1164
  data[2] = (uint8_t )lcdstatus.lock_status;
#line 1165
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 1166
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 1167
    lprintf(3, "Error setting LCD status");
#line 1168
    rc = -1;
    }
  } else
#line 1169
  if ((int )rsp->ccode == 193) {
    {
#line 1170
    lprintf(3, "Error getting LCD status: Command not supported on this system.");
    }
#line 1172
    return (-1);
  } else
#line 1169
  if ((int )rsp->ccode == 203) {
    {
#line 1170
    lprintf(3, "Error getting LCD status: Command not supported on this system.");
    }
#line 1172
    return (-1);
  } else
#line 1173
  if ((int )rsp->ccode > 0) {
    {
#line 1174
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 1174
    lprintf(3, "Error setting LCD status: %s", tmp);
#line 1176
    rc = -1;
    }
  }
#line 1178
  return (rc);
}
}
#line 1190 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_set_lock(struct ipmi_intf *intf , char lock ) 
{ 
  LCD_STATUS lcdstatus ;
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t data[5] ;
  char const   *tmp ;

  {
  {
#line 1195
  rc = 0;
#line 1196
  rsp = (struct ipmi_rs *)((void *)0);
#line 1197
  req.msg.netfn = (uint8_t )0;
#line 1197
  req.msg.lun = (unsigned char)0;
#line 1197
  req.msg.cmd = (unsigned char)0;
#line 1197
  req.msg.target_cmd = (unsigned char)0;
#line 1197
  req.msg.data_len = (unsigned short)0;
#line 1197
  req.msg.data = (uint8_t *)0;
#line 1199
  rc = ipmi_lcd_get_status_val(intf, & lcdstatus);
  }
#line 1200
  if (rc < 0) {
#line 1201
    return (-1);
  }
  {
#line 1203
  req.msg.netfn = (uint8_t )6;
#line 1204
  req.msg.lun = (uint8_t )0;
#line 1205
  req.msg.cmd = (uint8_t )88;
#line 1206
  req.msg.data_len = (uint16_t )5;
#line 1207
  req.msg.data = data;
#line 1208
  data[0] = (uint8_t )231;
#line 1209
  data[1] = (uint8_t )lcdstatus.vKVM_status;
#line 1210
  data[2] = (uint8_t )lock;
#line 1211
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 1212
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 1213
    lprintf(3, "Error setting LCD status");
#line 1214
    rc = -1;
    }
  } else
#line 1215
  if ((int )rsp->ccode == 193) {
    {
#line 1216
    lprintf(3, "Error getting LCD status: Command not supported on this system.");
#line 1218
    rc = -1;
    }
  } else
#line 1215
  if ((int )rsp->ccode == 203) {
    {
#line 1216
    lprintf(3, "Error getting LCD status: Command not supported on this system.");
#line 1218
    rc = -1;
    }
  } else
#line 1219
  if ((int )rsp->ccode > 0) {
    {
#line 1220
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 1220
    lprintf(3, "Error setting LCD status: %s", tmp);
#line 1222
    rc = -1;
    }
  }
#line 1224
  return (rc);
}
}
#line 1236 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_set_single_line_text(struct ipmi_intf *intf , char *text ) 
{ 
  uint8_t data[18] ;
  int bytes_to_store ;
  size_t tmp ;
  int bytes_stored ;
  int ii ;
  int rc ;
  int size_of_copy ;
  int tmp___0 ;
  int size_of_copy___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 1240
  tmp = strlen((char const   *)text);
#line 1240
  bytes_to_store = (int )tmp;
#line 1241
  bytes_stored = 0;
#line 1243
  rc = 0;
  }
#line 1244
  if (bytes_to_store > 62) {
    {
#line 1245
    lprintf(3, "Out of range Max limit is 62 characters");
    }
#line 1246
    return (-1);
  } else {
#line 1248
    if (bytes_to_store < 62) {
#line 1248
      bytes_to_store = bytes_to_store;
    } else {
#line 1248
      bytes_to_store = 62;
    }
#line 1249
    ii = 0;
    {
#line 1249
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1249
      if (! (ii < 4)) {
#line 1249
        goto while_break;
      }
#line 1251
      if (0 == ii) {
#line 1252
        if (bytes_to_store - bytes_stored < 14) {
#line 1252
          tmp___0 = bytes_to_store - bytes_stored;
        } else {
#line 1252
          tmp___0 = 14;
        }
#line 1252
        size_of_copy = tmp___0;
#line 1254
        if (size_of_copy < 0) {
#line 1256
          goto while_break;
        }
        {
#line 1258
        data[0] = (uint8_t )193;
#line 1259
        data[1] = (uint8_t )ii;
#line 1260
        data[2] = (uint8_t )0;
#line 1261
        data[3] = (uint8_t )bytes_to_store;
#line 1262
        memcpy((void */* __restrict  */)(data + 4), (void const   */* __restrict  */)(text + bytes_stored),
               (size_t )size_of_copy);
#line 1263
        bytes_stored += size_of_copy;
        }
      } else {
#line 1265
        if (bytes_to_store - bytes_stored < 16) {
#line 1265
          tmp___1 = bytes_to_store - bytes_stored;
        } else {
#line 1265
          tmp___1 = 16;
        }
#line 1265
        size_of_copy___0 = tmp___1;
#line 1267
        if (size_of_copy___0 <= 0) {
#line 1268
          goto while_break;
        }
        {
#line 1270
        data[0] = (uint8_t )193;
#line 1271
        data[1] = (uint8_t )ii;
#line 1272
        memcpy((void */* __restrict  */)(data + 2), (void const   */* __restrict  */)(text + bytes_stored),
               (size_t )size_of_copy___0);
#line 1273
        bytes_stored += size_of_copy___0;
        }
      }
      {
#line 1275
      rc = ipmi_mc_setsysinfo(intf, 18, (void *)(data));
      }
#line 1276
      if (rc < 0) {
        {
#line 1277
        lprintf(3, "Error setting text data");
#line 1278
        rc = -1;
        }
      } else
#line 1279
      if (rc > 0) {
        {
#line 1280
        tmp___2 = val2str((uint16_t )rc, completion_code_vals);
#line 1280
        lprintf(3, "Error setting text data: %s", tmp___2);
#line 1282
        rc = -1;
        }
      }
#line 1249
      ii ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1286
  return (rc);
}
}
#line 1299 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_set_text(struct ipmi_intf *intf , char *text , int line_number ) 
{ 
  int rc ;
  IPMI_DELL_LCD_CAPS lcd_caps ;
  char const   *tmp ;

  {
  {
#line 1302
  rc = 0;
#line 1304
  rc = ipmi_mc_getsysinfo(intf, 207, 0, 0, (int )sizeof(lcd_caps), (void *)(& lcd_caps));
  }
#line 1306
  if (rc < 0) {
    {
#line 1307
    lprintf(3, "Error getting LCD capabilities");
    }
#line 1308
    return (-1);
  } else
#line 1309
  if (rc > 0) {
    {
#line 1310
    tmp = val2str((uint16_t )rc, completion_code_vals);
#line 1310
    lprintf(3, "Error getting LCD capabilities: %s", tmp);
    }
#line 1312
    return (-1);
  }
#line 1314
  if ((int )lcd_caps.number_lines > 0) {
    {
#line 1315
    rc = ipmi_lcd_set_single_line_text(intf, text);
    }
  } else {
    {
#line 1317
    lprintf(3, "LCD does not have any lines that can be set");
#line 1318
    rc = -1;
    }
  }
#line 1320
  return (rc);
}
}
#line 1335 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_configure_wh(struct ipmi_intf *intf , uint32_t mode , uint16_t lcdquallifier ,
                                 uint8_t errordisp , int8_t line_number , char *text ) 
{ 
  int rc ;

  {
#line 1339
  rc = 0;
#line 1340
  if (0U == mode) {
    {
#line 1342
    rc = ipmi_lcd_set_text(intf, text, (int )line_number);
    }
  }
#line 1344
  if (rc == 0) {
    {
#line 1345
    rc = ipmi_lcd_set_configure_command_wh(intf, mode, lcdquallifier, errordisp);
    }
  }
#line 1347
  return (rc);
}
}
#line 1361 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_configure(struct ipmi_intf *intf , int command , int8_t line_number ,
                              char *text ) 
{ 
  int rc ;

  {
#line 1365
  rc = 0;
#line 1366
  if (0 == command) {
    {
#line 1367
    rc = ipmi_lcd_set_text(intf, text, (int )line_number);
    }
  }
#line 1369
  if (rc == 0) {
    {
#line 1370
    rc = ipmi_lcd_set_configure_command(intf, command);
    }
  }
#line 1372
  return (rc);
}
}
#line 1383 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void ipmi_lcd_usage(void) 
{ 


  {
  {
#line 1386
  lprintf(5, "");
#line 1388
  lprintf(5, "Generic DELL HW:");
#line 1390
  lprintf(5, "   lcd set {none}|{default}|{custom <text>}");
#line 1392
  lprintf(5, "      Set LCD text displayed during non-fault conditions");
#line 1394
  lprintf(5, "");
#line 1396
  lprintf(5, "iDRAC 11g or iDRAC 12g:");
#line 1398
  lprintf(5, "   lcd set {mode}|{lcdqualifier}|{errordisplay}");
#line 1400
  lprintf(5, "      Allows you to set the LCD mode and user-defined string.");
#line 1402
  lprintf(5, "");
#line 1404
  lprintf(5, "   lcd set mode {none}|{modelname}|{ipv4address}|{macaddress}|");
#line 1406
  lprintf(5, "   {systemname}|{servicetag}|{ipv6address}|{ambienttemp}");
#line 1408
  lprintf(5, "   {systemwatt }|{assettag}|{userdefined}<text>");
#line 1410
  lprintf(5, "\t   Allows you to set the LCD display mode to any of the preceding");
#line 1412
  lprintf(5, "      parameters");
#line 1414
  lprintf(5, "");
#line 1416
  lprintf(5, "   lcd set lcdqualifier {watt}|{btuphr}|{celsius}|{fahrenheit}");
#line 1418
  lprintf(5, "      Allows you to set the unit for the system ambient temperature mode.");
#line 1420
  lprintf(5, "");
#line 1422
  lprintf(5, "   lcd set errordisplay {sel}|{simple}");
#line 1424
  lprintf(5, "      Allows you to set the error display.");
#line 1426
  lprintf(5, "");
#line 1428
  lprintf(5, "   lcd info");
#line 1430
  lprintf(5, "      Show LCD text that is displayed during non-fault conditions");
#line 1432
  lprintf(5, "");
#line 1434
  lprintf(5, "");
#line 1436
  lprintf(5, "   lcd set vkvm{active}|{inactive}");
#line 1438
  lprintf(5, "      Set vKVM active and inactive, message will be displayed on lcd");
#line 1440
  lprintf(5, "      when vKVM is active and vKVM session is in progress");
#line 1442
  lprintf(5, "");
#line 1444
  lprintf(5, "   lcd set frontpanelaccess {viewandmodify}|{viewonly}|{disabled}");
#line 1446
  lprintf(5, "      Set LCD mode to view and modify, view only or disabled ");
#line 1448
  lprintf(5, "");
#line 1450
  lprintf(5, "   lcd status");
#line 1452
  lprintf(5, "      Show LCD Status for vKVM display<active|inactive>");
#line 1454
  lprintf(5, "      and Front Panel access mode {viewandmodify}|{viewonly}|{disabled}");
#line 1456
  lprintf(5, "");
  }
#line 1458
  return;
}
}
#line 1471 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_delloem_mac_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int rc ;
  int currIdInt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1474
  rc = 0;
#line 1475
  currIdInt = -1;
#line 1476
  current_arg ++;
#line 1477
  if (argc > 1) {
    {
#line 1477
    tmp = strcmp((char const   *)*(argv + current_arg), "help");
    }
#line 1477
    if (tmp == 0) {
      {
#line 1478
      ipmi_mac_usage();
      }
#line 1479
      return (0);
    }
  }
  {
#line 1481
  ipmi_idracvalidator_command(intf);
  }
#line 1482
  if (argc == 1) {
    {
#line 1483
    rc = ipmi_macinfo(intf, (uint8_t )255);
    }
  } else {
    {
#line 1484
    tmp___2 = strncmp((char const   *)*(argv + current_arg), "list\000", (size_t )5);
    }
#line 1484
    if (tmp___2 == 0) {
      {
#line 1485
      rc = ipmi_macinfo(intf, (uint8_t )255);
      }
    } else {
      {
#line 1486
      tmp___1 = strncmp((char const   *)*(argv + current_arg), "get\000", (size_t )4);
      }
#line 1486
      if (tmp___1 == 0) {
#line 1487
        current_arg ++;
#line 1488
        if ((unsigned long )*(argv + current_arg) == (unsigned long )((void *)0)) {
          {
#line 1489
          ipmi_mac_usage();
          }
#line 1490
          return (-1);
        }
        {
#line 1492
        tmp___0 = str2int((char const   *)*(argv + current_arg), & currIdInt);
        }
#line 1492
        if (tmp___0 != 0) {
          {
#line 1493
          lprintf(3, "Invalid NIC number. The NIC number should be between 0-8");
          }
#line 1495
          return (-1);
        }
#line 1497
        if (currIdInt > 8) {
          {
#line 1498
          lprintf(3, "Invalid NIC number. The NIC number should be between 0-8");
          }
#line 1500
          return (-1);
        } else
#line 1497
        if (currIdInt < 0) {
          {
#line 1498
          lprintf(3, "Invalid NIC number. The NIC number should be between 0-8");
          }
#line 1500
          return (-1);
        }
        {
#line 1502
        rc = ipmi_macinfo(intf, (uint8_t )currIdInt);
        }
      } else {
        {
#line 1504
        ipmi_mac_usage();
        }
      }
    }
  }
#line 1506
  return (rc);
}
}
#line 1509 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
EmbeddedNICMacAddressType EmbeddedNICMacAddress  ;
#line 1511 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
EmbeddedNICMacAddressType_10G EmbeddedNICMacAddress_10G  ;
#line 1513 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void InitEmbeddedNICMacAddressValues(void) 
{ 
  uint8_t i ;
  uint8_t j ;

  {
#line 1518
  i = (uint8_t )0;
  {
#line 1518
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1518
    if (! ((int )i < 8)) {
#line 1518
      goto while_break;
    }
#line 1519
    EmbeddedNICMacAddress.LOMMacAddress[i].BladSlotNumber = 0U;
#line 1520
    EmbeddedNICMacAddress.LOMMacAddress[i].MacType = 3U;
#line 1521
    EmbeddedNICMacAddress.LOMMacAddress[i].EthernetStatus = 3U;
#line 1523
    EmbeddedNICMacAddress.LOMMacAddress[i].NICNumber = 0U;
#line 1524
    EmbeddedNICMacAddress.LOMMacAddress[i].Reserved = 0U;
#line 1525
    j = (uint8_t )0;
    {
#line 1525
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1525
      if (! ((int )j < 6)) {
#line 1525
        goto while_break___0;
      }
#line 1526
      EmbeddedNICMacAddress.LOMMacAddress[i].MacAddressByte[j] = (uint8_t )0;
#line 1527
      EmbeddedNICMacAddress_10G.MacAddress[i].MacAddressByte[j] = (uint8_t )0;
#line 1525
      j = (uint8_t )((int )j + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1518
    i = (uint8_t )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 1530
  return;
}
}
#line 1532 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
uint8_t UseVirtualMacAddress  =    (uint8_t )0;
#line 1533 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_macinfo_drac_idrac_virtual_mac(struct ipmi_intf *intf , uint8_t NicNum ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[30] ;
  uint8_t VirtualMacAddress[6] ;
  uint8_t input_length ;
  uint8_t j ;
  uint8_t i ;
  uint8_t tmp ;

  {
#line 1540
  input_length = (uint8_t )0;
#line 1543
  if ((int )NicNum != 255) {
#line 1543
    if ((int )NicNum != 8) {
#line 1544
      return (0);
    }
  }
  {
#line 1546
  UseVirtualMacAddress = (uint8_t )0;
#line 1547
  input_length = (uint8_t )0;
#line 1548
  tmp = input_length;
#line 1548
  input_length = (uint8_t )((int )input_length + 1);
#line 1548
  msg_data[tmp] = (uint8_t )1;
#line 1550
  req.msg.netfn = (uint8_t )48;
#line 1551
  req.msg.lun = (uint8_t )0;
#line 1552
  req.msg.cmd = (uint8_t )201;
#line 1553
  req.msg.data = msg_data;
#line 1554
  req.msg.data_len = (uint16_t )input_length;
#line 1556
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 1557
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
#line 1558
    return (-1);
  }
#line 1560
  if ((int )rsp->ccode > 0) {
#line 1561
    return (-1);
  }
#line 1563
  if (17 == (int )IMC_Type) {
#line 1563
    goto _L;
  } else
#line 1563
  if (16 == (int )IMC_Type) {
    _L: /* CIL Label */ 
    {
#line 1566
    memcpy((void */* __restrict  */)(VirtualMacAddress), (void const   */* __restrict  */)(rsp->data + 1),
           (size_t )6);
#line 1567
    i = (uint8_t )0;
    }
    {
#line 1567
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1567
      if (! ((int )i < 6)) {
#line 1567
        goto while_break;
      }
#line 1568
      if ((int )VirtualMacAddress[i] != 0) {
#line 1569
        UseVirtualMacAddress = (uint8_t )1;
      }
#line 1567
      i = (uint8_t )((int )i + 1);
    }
    while_break: /* CIL Label */ ;
    }
#line 1573
    if (! UseVirtualMacAddress) {
      {
#line 1574
      memcpy((void */* __restrict  */)(VirtualMacAddress), (void const   */* __restrict  */)((rsp->data + 1) + 6),
             (size_t )6);
#line 1576
      i = (uint8_t )0;
      }
      {
#line 1576
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1576
        if (! ((int )i < 6)) {
#line 1576
          goto while_break___0;
        }
#line 1577
        if ((int )VirtualMacAddress[i] != 0) {
#line 1578
          UseVirtualMacAddress = (uint8_t )1;
        }
#line 1576
        i = (uint8_t )((int )i + 1);
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 1583
    memcpy((void */* __restrict  */)(VirtualMacAddress), (void const   */* __restrict  */)(rsp->data + 1),
           (size_t )6);
#line 1585
    i = (uint8_t )0;
    }
    {
#line 1585
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1585
      if (! ((int )i < 6)) {
#line 1585
        goto while_break___1;
      }
#line 1586
      if ((int )VirtualMacAddress[i] != 0) {
#line 1587
        UseVirtualMacAddress = (uint8_t )1;
      }
#line 1585
      i = (uint8_t )((int )i + 1);
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1591
  if ((int )UseVirtualMacAddress == 0) {
#line 1592
    return (-1);
  }
#line 1594
  if (8 == (int )IMC_Type) {
    {
#line 1595
    printf((char const   */* __restrict  */)"\nDRAC MAC Address ");
    }
  } else
#line 1596
  if (11 == (int )IMC_Type) {
    {
#line 1598
    printf((char const   */* __restrict  */)"\niDRAC6 MAC Address ");
    }
  } else
#line 1596
  if (10 == (int )IMC_Type) {
    {
#line 1598
    printf((char const   */* __restrict  */)"\niDRAC6 MAC Address ");
    }
  } else
#line 1599
  if (17 == (int )IMC_Type) {
    {
#line 1601
    printf((char const   */* __restrict  */)"\niDRAC7 MAC Address ");
    }
  } else
#line 1599
  if (16 == (int )IMC_Type) {
    {
#line 1601
    printf((char const   */* __restrict  */)"\niDRAC7 MAC Address ");
    }
  } else
#line 1602
  if (13 == (int )IMC_Type) {
    {
#line 1604
    printf((char const   */* __restrict  */)"\nBMC MAC Address ");
    }
  } else
#line 1602
  if (14 == (int )IMC_Type) {
    {
#line 1604
    printf((char const   */* __restrict  */)"\nBMC MAC Address ");
    }
  } else {
    {
#line 1606
    printf((char const   */* __restrict  */)"\niDRAC6 MAC Address ");
    }
  }
#line 1609
  j = (uint8_t )0;
  {
#line 1609
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1609
    if (! ((int )j < 5)) {
#line 1609
      goto while_break___2;
    }
    {
#line 1610
    printf((char const   */* __restrict  */)"%02x:", (int )VirtualMacAddress[j]);
#line 1609
    j = (uint8_t )((int )j + 1);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1612
  printf((char const   */* __restrict  */)"%02x", (int )VirtualMacAddress[j]);
#line 1613
  printf((char const   */* __restrict  */)"\n");
  }
#line 1614
  return (0);
}
}
#line 1624 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_macinfo_drac_idrac_mac(struct ipmi_intf *intf , uint8_t NicNum ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[30] ;
  uint8_t input_length ;
  uint8_t iDRAC6MacAddressByte[6] ;
  uint8_t j ;
  uint8_t tmp ;
  uint8_t tmp___0 ;
  uint8_t tmp___1 ;
  uint8_t tmp___2 ;
  char const   *tmp___3 ;

  {
  {
#line 1630
  input_length = (uint8_t )0;
#line 1633
  ipmi_macinfo_drac_idrac_virtual_mac(intf, NicNum);
  }
#line 1634
  if ((int )NicNum != 255) {
#line 1634
    if ((int )NicNum != 8) {
#line 1636
      return (0);
    } else {
#line 1634
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1634
  if ((int )UseVirtualMacAddress != 0) {
#line 1636
    return (0);
  }
  {
#line 1638
  input_length = (uint8_t )0;
#line 1639
  tmp = input_length;
#line 1639
  input_length = (uint8_t )((int )input_length + 1);
#line 1639
  msg_data[tmp] = (uint8_t )1;
#line 1640
  tmp___0 = input_length;
#line 1640
  input_length = (uint8_t )((int )input_length + 1);
#line 1640
  msg_data[tmp___0] = (uint8_t )5;
#line 1641
  tmp___1 = input_length;
#line 1641
  input_length = (uint8_t )((int )input_length + 1);
#line 1641
  msg_data[tmp___1] = (uint8_t )0;
#line 1642
  tmp___2 = input_length;
#line 1642
  input_length = (uint8_t )((int )input_length + 1);
#line 1642
  msg_data[tmp___2] = (uint8_t )0;
#line 1644
  req.msg.netfn = (uint8_t )12;
#line 1645
  req.msg.lun = (uint8_t )0;
#line 1646
  req.msg.cmd = (uint8_t )2;
#line 1647
  req.msg.data = msg_data;
#line 1648
  req.msg.data_len = (uint16_t )input_length;
#line 1650
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 1651
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 1652
    lprintf(3, "Error in getting MAC Address");
    }
#line 1653
    return (-1);
  }
#line 1655
  if ((int )rsp->ccode > 0) {
    {
#line 1656
    tmp___3 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 1656
    lprintf(3, "Error in getting MAC Address (%s)", tmp___3);
    }
#line 1658
    return (-1);
  }
  {
#line 1660
  memcpy((void */* __restrict  */)(iDRAC6MacAddressByte), (void const   */* __restrict  */)(rsp->data + 1),
         (size_t )6);
  }
#line 1663
  if (8 == (int )IMC_Type) {
    {
#line 1664
    printf((char const   */* __restrict  */)"\nDRAC MAC Address ");
    }
  } else
#line 1665
  if (11 == (int )IMC_Type) {
    {
#line 1667
    printf((char const   */* __restrict  */)"\niDRAC6 MAC Address ");
    }
  } else
#line 1665
  if (10 == (int )IMC_Type) {
    {
#line 1667
    printf((char const   */* __restrict  */)"\niDRAC6 MAC Address ");
    }
  } else
#line 1668
  if (17 == (int )IMC_Type) {
    {
#line 1670
    printf((char const   */* __restrict  */)"\niDRAC7 MAC Address ");
    }
  } else
#line 1668
  if (16 == (int )IMC_Type) {
    {
#line 1670
    printf((char const   */* __restrict  */)"\niDRAC7 MAC Address ");
    }
  } else
#line 1671
  if (13 == (int )IMC_Type) {
    {
#line 1673
    printf((char const   */* __restrict  */)"\n\rBMC MAC Address ");
    }
  } else
#line 1671
  if (14 == (int )IMC_Type) {
    {
#line 1673
    printf((char const   */* __restrict  */)"\n\rBMC MAC Address ");
    }
  } else {
    {
#line 1675
    printf((char const   */* __restrict  */)"\niDRAC6 MAC Address ");
    }
  }
#line 1678
  j = (uint8_t )0;
  {
#line 1678
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1678
    if (! ((int )j < 5)) {
#line 1678
      goto while_break;
    }
    {
#line 1679
    printf((char const   */* __restrict  */)"%02x:", (int )iDRAC6MacAddressByte[j]);
#line 1678
    j = (uint8_t )((int )j + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1681
  printf((char const   */* __restrict  */)"%02x", (int )iDRAC6MacAddressByte[j]);
#line 1682
  printf((char const   */* __restrict  */)"\n");
  }
#line 1683
  return (0);
}
}
#line 1694 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_macinfo_10g(struct ipmi_intf *intf , uint8_t NicNum ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[30] ;
  uint8_t input_length ;
  uint8_t j ;
  uint8_t i ;
  uint8_t Total_No_NICs ;
  uint8_t tmp ;
  uint8_t tmp___0 ;
  uint8_t tmp___1 ;
  uint8_t tmp___2 ;
  char const   *tmp___3 ;

  {
  {
#line 1700
  input_length = (uint8_t )0;
#line 1703
  Total_No_NICs = (uint8_t )0;
#line 1704
  InitEmbeddedNICMacAddressValues();
#line 1705
  memset((void *)(msg_data), 0, sizeof(msg_data));
#line 1706
  input_length = (uint8_t )0;
#line 1707
  tmp = input_length;
#line 1707
  input_length = (uint8_t )((int )input_length + 1);
#line 1707
  msg_data[tmp] = (uint8_t )0;
#line 1708
  tmp___0 = input_length;
#line 1708
  input_length = (uint8_t )((int )input_length + 1);
#line 1708
  msg_data[tmp___0] = (uint8_t )203;
#line 1709
  tmp___1 = input_length;
#line 1709
  input_length = (uint8_t )((int )input_length + 1);
#line 1709
  msg_data[tmp___1] = (uint8_t )0;
#line 1710
  tmp___2 = input_length;
#line 1710
  input_length = (uint8_t )((int )input_length + 1);
#line 1710
  msg_data[tmp___2] = (uint8_t )0;
#line 1711
  memset((void *)(& req), 0, sizeof(req));
#line 1712
  req.msg.netfn = (uint8_t )6;
#line 1713
  req.msg.lun = (uint8_t )0;
#line 1714
  req.msg.cmd = (uint8_t )89;
#line 1715
  req.msg.data = msg_data;
#line 1716
  req.msg.data_len = (uint16_t )input_length;
#line 1717
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 1718
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 1719
    lprintf(3, "Error in getting MAC Address");
    }
#line 1720
    return (-1);
  }
#line 1722
  if ((int )rsp->ccode > 0) {
    {
#line 1723
    tmp___3 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 1723
    lprintf(3, "Error in getting MAC Address (%s)", tmp___3);
    }
#line 1725
    return (-1);
  }
#line 1727
  Total_No_NICs = rsp->data[1];
#line 1728
  if (8 != (int )NicNum) {
#line 1729
    if (255 == (int )NicNum) {
      {
#line 1730
      printf((char const   */* __restrict  */)"\nSystem LOMs");
      }
    }
    {
#line 1732
    printf((char const   */* __restrict  */)"\nNIC Number\tMAC Address\n");
#line 1733
    memcpy((void */* __restrict  */)(& EmbeddedNICMacAddress_10G), (void const   */* __restrict  */)((rsp->data + 1) + 1),
           (size_t )((int )Total_No_NICs * 6));
#line 1737
    i = (uint8_t )0;
    }
    {
#line 1737
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1737
      if (! ((int )i < (int )Total_No_NICs)) {
#line 1737
        goto while_break;
      }
#line 1738
      if (255 == (int )NicNum) {
#line 1738
        goto _L;
      } else
#line 1738
      if ((int )i == (int )NicNum) {
        _L: /* CIL Label */ 
        {
#line 1739
        printf((char const   */* __restrict  */)"\n%d", (int )i);
#line 1740
        printf((char const   */* __restrict  */)"\t\t");
#line 1741
        j = (uint8_t )0;
        }
        {
#line 1741
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1741
          if (! ((int )j < 5)) {
#line 1741
            goto while_break___0;
          }
          {
#line 1742
          printf((char const   */* __restrict  */)"%02x:", (int )EmbeddedNICMacAddress_10G.MacAddress[i].MacAddressByte[j]);
#line 1741
          j = (uint8_t )((int )j + 1);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1745
        printf((char const   */* __restrict  */)"%02x", (int )EmbeddedNICMacAddress_10G.MacAddress[i].MacAddressByte[j]);
        }
      }
#line 1737
      i = (uint8_t )((int )i + 1);
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1749
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 1751
  ipmi_macinfo_drac_idrac_mac(intf, NicNum);
  }
#line 1752
  return (0);
}
}
#line 1762 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_macinfo_11g(struct ipmi_intf *intf , uint8_t NicNum ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t input_length ;
  uint8_t i ;
  uint8_t j ;
  uint8_t len ;
  uint8_t loop_count ;
  uint8_t maxlen ;
  uint8_t msg_data[30] ;
  uint8_t offset ;
  uint8_t tmp ;
  uint8_t tmp___0 ;
  uint8_t tmp___1 ;
  uint8_t tmp___2 ;
  uint8_t tmp___3 ;
  uint8_t tmp___4 ;
  char const   *tmp___5 ;
  uint8_t tmp___6 ;
  uint8_t tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 1767
  input_length = (uint8_t )0;
#line 1775
  offset = (uint8_t )0;
#line 1776
  len = (uint8_t )8;
#line 1777
  maxlen = (uint8_t )64;
#line 1778
  loop_count = (uint8_t )((int )maxlen / (int )len);
#line 1779
  InitEmbeddedNICMacAddressValues();
#line 1780
  memset((void *)(msg_data), 0, sizeof(msg_data));
#line 1781
  input_length = (uint8_t )0;
#line 1782
  tmp = input_length;
#line 1782
  input_length = (uint8_t )((int )input_length + 1);
#line 1782
  msg_data[tmp] = (uint8_t )0;
#line 1783
  tmp___0 = input_length;
#line 1783
  input_length = (uint8_t )((int )input_length + 1);
#line 1783
  msg_data[tmp___0] = (uint8_t )218;
#line 1784
  tmp___1 = input_length;
#line 1784
  input_length = (uint8_t )((int )input_length + 1);
#line 1784
  msg_data[tmp___1] = (uint8_t )0;
#line 1785
  tmp___2 = input_length;
#line 1785
  input_length = (uint8_t )((int )input_length + 1);
#line 1785
  msg_data[tmp___2] = (uint8_t )0;
#line 1786
  tmp___3 = input_length;
#line 1786
  input_length = (uint8_t )((int )input_length + 1);
#line 1786
  msg_data[tmp___3] = (uint8_t )0;
#line 1787
  tmp___4 = input_length;
#line 1787
  input_length = (uint8_t )((int )input_length + 1);
#line 1787
  msg_data[tmp___4] = (uint8_t )0;
#line 1789
  memset((void *)(& req), 0, sizeof(req));
#line 1790
  req.msg.netfn = (uint8_t )6;
#line 1791
  req.msg.lun = (uint8_t )0;
#line 1792
  req.msg.cmd = (uint8_t )89;
#line 1793
  req.msg.data = msg_data;
#line 1794
  req.msg.data_len = (uint16_t )input_length;
#line 1796
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 1797
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 1798
    lprintf(3, "Error in getting MAC Address");
    }
#line 1799
    return (-1);
  }
#line 1801
  if ((int )rsp->ccode > 0) {
    {
#line 1802
    tmp___5 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 1802
    lprintf(3, "Error in getting MAC Address (%s)", tmp___5);
    }
#line 1804
    return (-1);
  }
#line 1806
  len = (uint8_t )8;
#line 1807
  maxlen = rsp->data[1];
#line 1808
  loop_count = (uint8_t )((int )maxlen / (int )len);
#line 1809
  if (8 != (int )NicNum) {
#line 1810
    if (255 == (int )NicNum) {
      {
#line 1811
      printf((char const   */* __restrict  */)"\nSystem LOMs");
      }
    }
    {
#line 1813
    printf((char const   */* __restrict  */)"\nNIC Number\tMAC Address\t\tStatus\n");
#line 1815
    offset = (uint8_t )0;
#line 1816
    i = (uint8_t )0;
    }
    {
#line 1816
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1816
      if (! ((int )i < (int )loop_count)) {
#line 1816
        goto while_break;
      }
      {
#line 1817
      input_length = (uint8_t )4;
#line 1818
      tmp___6 = input_length;
#line 1818
      input_length = (uint8_t )((int )input_length + 1);
#line 1818
      msg_data[tmp___6] = offset;
#line 1819
      tmp___7 = input_length;
#line 1819
      input_length = (uint8_t )((int )input_length + 1);
#line 1819
      msg_data[tmp___7] = len;
#line 1821
      req.msg.netfn = (uint8_t )6;
#line 1822
      req.msg.lun = (uint8_t )0;
#line 1823
      req.msg.cmd = (uint8_t )89;
#line 1824
      req.msg.data = msg_data;
#line 1825
      req.msg.data_len = (uint16_t )input_length;
#line 1827
      rsp = (*(intf->sendrecv))(intf, & req);
      }
#line 1828
      if ((unsigned long )rsp == (unsigned long )((void *)0)) {
        {
#line 1829
        lprintf(3, "Error in getting MAC Address");
        }
#line 1830
        return (-1);
      }
#line 1832
      if ((int )rsp->ccode > 0) {
        {
#line 1833
        tmp___8 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 1833
        lprintf(3, "Error in getting MAC Address (%s)", tmp___8);
        }
#line 1835
        return (-1);
      }
      {
#line 1837
      memcpy((void */* __restrict  */)(& EmbeddedNICMacAddress.LOMMacAddress[i]),
             (void const   */* __restrict  */)(rsp->data + 1), (size_t )len);
      }
#line 1839
      if (0U == EmbeddedNICMacAddress.LOMMacAddress[i].MacType) {
#line 1840
        if (255 == (int )NicNum) {
#line 1840
          goto _L;
        } else
#line 1840
        if ((unsigned int )NicNum == EmbeddedNICMacAddress.LOMMacAddress[i].NICNumber) {
          _L: /* CIL Label */ 
          {
#line 1842
          printf((char const   */* __restrict  */)"\n%d", EmbeddedNICMacAddress.LOMMacAddress[i].NICNumber);
#line 1843
          printf((char const   */* __restrict  */)"\t\t");
#line 1844
          j = (uint8_t )0;
          }
          {
#line 1844
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1844
            if (! ((int )j < 5)) {
#line 1844
              goto while_break___0;
            }
            {
#line 1845
            printf((char const   */* __restrict  */)"%02x:", (int )EmbeddedNICMacAddress.LOMMacAddress[i].MacAddressByte[j]);
#line 1844
            j = (uint8_t )((int )j + 1);
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 1848
          printf((char const   */* __restrict  */)"%02x", (int )EmbeddedNICMacAddress.LOMMacAddress[i].MacAddressByte[j]);
          }
#line 1851
          if (0U == EmbeddedNICMacAddress.LOMMacAddress[i].EthernetStatus) {
            {
#line 1853
            printf((char const   */* __restrict  */)"\tEnabled");
            }
          } else {
            {
#line 1855
            printf((char const   */* __restrict  */)"\tDisabled");
            }
          }
        }
      }
#line 1816
      i = (uint8_t )((int )i + 1);
#line 1816
      offset = (uint8_t )((int )offset + (int )len);
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1860
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 1862
  ipmi_macinfo_drac_idrac_mac(intf, NicNum);
  }
#line 1863
  return (0);
}
}
#line 1873 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_macinfo(struct ipmi_intf *intf , uint8_t NicNum ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1876
  if (8 == (int )IMC_Type) {
    {
#line 1877
    tmp = ipmi_macinfo_10g(intf, NicNum);
    }
#line 1877
    return (tmp);
  } else
#line 1878
  if (11 == (int )IMC_Type) {
    {
#line 1883
    tmp___0 = ipmi_macinfo_11g(intf, NicNum);
    }
#line 1883
    return (tmp___0);
  } else
#line 1878
  if (10 == (int )IMC_Type) {
    {
#line 1883
    tmp___0 = ipmi_macinfo_11g(intf, NicNum);
    }
#line 1883
    return (tmp___0);
  } else
#line 1878
  if (17 == (int )IMC_Type) {
    {
#line 1883
    tmp___0 = ipmi_macinfo_11g(intf, NicNum);
    }
#line 1883
    return (tmp___0);
  } else
#line 1878
  if (16 == (int )IMC_Type) {
    {
#line 1883
    tmp___0 = ipmi_macinfo_11g(intf, NicNum);
    }
#line 1883
    return (tmp___0);
  } else
#line 1878
  if (14 == (int )IMC_Type) {
    {
#line 1883
    tmp___0 = ipmi_macinfo_11g(intf, NicNum);
    }
#line 1883
    return (tmp___0);
  } else
#line 1878
  if (13 == (int )IMC_Type) {
    {
#line 1883
    tmp___0 = ipmi_macinfo_11g(intf, NicNum);
    }
#line 1883
    return (tmp___0);
  } else {
    {
#line 1885
    lprintf(3, "Error in getting MAC Address : Not supported platform");
    }
#line 1886
    return (-1);
  }
}
}
#line 1898 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void ipmi_mac_usage(void) 
{ 


  {
  {
#line 1901
  lprintf(5, "");
#line 1903
  lprintf(5, "   mac list");
#line 1905
  lprintf(5, "      Lists the MAC address of LOMs");
#line 1907
  lprintf(5, "");
#line 1909
  lprintf(5, "   mac get <NIC number>");
#line 1911
  lprintf(5, "      Shows the MAC address of specified LOM. 0-7 System LOM, 8- DRAC/iDRAC.");
#line 1913
  lprintf(5, "");
  }
#line 1915
  return;
}
}
#line 1950
int get_nic_selection_mode_12g(struct ipmi_intf *intf , int current_arg___1 , char **argv ,
                               char *nic_set ) ;
#line 1928 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_delloem_lan_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int rc ;
  int nic_selection ;
  char nic_set[2] ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1931
  rc = 0;
#line 1932
  nic_selection = 0;
#line 1933
  nic_set[0] = (char)0;
#line 1933
  tmp = 1U;
  {
#line 1933
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1933
    if (tmp >= 2U) {
#line 1933
      goto while_break;
    }
#line 1933
    nic_set[tmp] = (char)0;
#line 1933
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1934
  current_arg ++;
#line 1935
  if ((unsigned long )*(argv + current_arg) == (unsigned long )((void *)0)) {
    {
#line 1936
    ipmi_lan_usage();
    }
#line 1937
    return (0);
  } else {
    {
#line 1935
    tmp___0 = strcmp((char const   *)*(argv + current_arg), "help");
    }
#line 1935
    if (tmp___0 == 0) {
      {
#line 1936
      ipmi_lan_usage();
      }
#line 1937
      return (0);
    }
  }
  {
#line 1939
  ipmi_idracvalidator_command(intf);
#line 1940
  tmp___4 = IsLANSupported();
  }
#line 1940
  if (tmp___4) {
    {
#line 1943
    tmp___3 = strncmp((char const   *)*(argv + current_arg), "set\000", (size_t )4);
    }
#line 1943
    if (tmp___3 == 0) {
#line 1944
      current_arg ++;
#line 1945
      if ((unsigned long )*(argv + current_arg) == (unsigned long )((void *)0)) {
        {
#line 1946
        ipmi_lan_usage();
        }
#line 1947
        return (-1);
      }
#line 1949
      if ((int )iDRAC_FLAG == 2) {
        {
#line 1950
        nic_selection = get_nic_selection_mode_12g(intf, current_arg, argv, nic_set);
        }
#line 1952
        if (-1 == nic_selection) {
          {
#line 1953
          ipmi_lan_usage();
          }
#line 1954
          return (-1);
        } else
#line 1955
        if (-2 == nic_selection) {
          {
#line 1956
          lprintf(3, "ERROR: Cannot set shared with failover lom same as current shared lom.");
          }
#line 1957
          return (-1);
        } else
#line 1958
        if (-3 == nic_selection) {
          {
#line 1959
          lprintf(3, "ERROR: Cannot set shared with failover loms when NIC is set to dedicated Mode.");
          }
#line 1960
          return (-1);
        } else
#line 1961
        if (-4 == nic_selection) {
          {
#line 1962
          lprintf(3, "ERROR: Cannot set shared Mode for Blades.");
          }
#line 1963
          return (-1);
        }
        {
#line 1965
        rc = ipmi_lan_set_nic_selection_12g(intf, (uint8_t *)(nic_set));
        }
      } else {
        {
#line 1967
        nic_selection = get_nic_selection_mode(current_arg, argv);
        }
#line 1968
        if (-1 == nic_selection) {
          {
#line 1969
          ipmi_lan_usage();
          }
#line 1970
          return (-1);
        }
#line 1972
        if (11 == (int )IMC_Type) {
          {
#line 1973
          lprintf(3, "ERROR: Cannot set shared Mode for Blades.");
          }
#line 1974
          return (-1);
        }
        {
#line 1976
        rc = ipmi_lan_set_nic_selection(intf, (uint8_t )nic_selection);
        }
      }
#line 1978
      return (0);
    } else {
      {
#line 1979
      tmp___2 = strncmp((char const   *)*(argv + current_arg), "get\000", (size_t )4);
      }
#line 1979
      if (tmp___2 == 0) {
#line 1980
        current_arg ++;
#line 1981
        if ((unsigned long )*(argv + current_arg) == (unsigned long )((void *)0)) {
          {
#line 1982
          rc = ipmi_lan_get_nic_selection(intf);
          }
#line 1983
          return (rc);
        } else {
          {
#line 1984
          tmp___1 = strncmp((char const   *)*(argv + current_arg), "active\000", (size_t )7);
          }
#line 1984
          if (tmp___1 == 0) {
            {
#line 1985
            rc = ipmi_lan_get_active_nic(intf);
            }
#line 1986
            return (rc);
          } else {
            {
#line 1988
            ipmi_lan_usage();
            }
          }
        }
      } else {
        {
#line 1991
        ipmi_lan_usage();
        }
#line 1992
        return (-1);
      }
    }
  } else {
    {
#line 1941
    lprintf(3, "lan is not supported on this system.");
    }
#line 1942
    return (-1);
  }
#line 1994
  return (rc);
}
}
#line 1997 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int IsLANSupported(void) 
{ 


  {
#line 2000
  if (11 == (int )IMC_Type) {
#line 2001
    return (0);
  }
#line 2003
  return (1);
}
}
#line 2006 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
int get_nic_selection_mode_12g(struct ipmi_intf *intf , int current_arg___1 , char **argv ,
                               char *nic_set ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  int failover ;
  int nic_selection_mode ;
  uint8_t input_length ;
  uint8_t msg_data[30] ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 2013
  failover = 0;
#line 2014
  nic_selection_mode = 0;
#line 2015
  input_length = (uint8_t )0;
#line 2018
  input_length = (uint8_t )0;
#line 2019
  req.msg.netfn = (uint8_t )48;
#line 2020
  req.msg.lun = (uint8_t )0;
#line 2021
  req.msg.cmd = (uint8_t )41;
#line 2022
  req.msg.data = msg_data;
#line 2023
  req.msg.data_len = (uint16_t )input_length;
#line 2024
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2025
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2026
    lprintf(3, "Error in getting nic selection");
    }
#line 2027
    return (-1);
  } else
#line 2028
  if ((int )rsp->ccode > 0) {
    {
#line 2029
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2029
    lprintf(3, "Error in getting nic selection (%s)", tmp);
    }
#line 2031
    return (-1);
  }
#line 2033
  *(nic_set + 0) = (char )rsp->data[0];
#line 2034
  *(nic_set + 1) = (char )rsp->data[1];
#line 2035
  if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
    {
#line 2035
    tmp___0 = strncmp((char const   *)*(argv + current_arg___1), "dedicated\000",
                      (size_t )10);
    }
#line 2035
    if (tmp___0 == 0) {
#line 2037
      *(nic_set + 0) = (char)1;
#line 2038
      *(nic_set + 1) = (char)0;
#line 2039
      return (0);
    }
  }
#line 2041
  if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
    {
#line 2041
    tmp___1 = strncmp((char const   *)*(argv + current_arg___1), "shared\000", (size_t )7);
    }
#line 2041
    if (! (tmp___1 == 0)) {
#line 2045
      return (-1);
    }
  } else {
#line 2045
    return (-1);
  }
#line 2048
  current_arg___1 ++;
#line 2049
  if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
    {
#line 2049
    tmp___2 = strncmp((char const   *)*(argv + current_arg___1), "with\000", (size_t )5);
    }
#line 2049
    if (! (tmp___2 == 0)) {
#line 2053
      return (-1);
    }
  } else {
#line 2053
    return (-1);
  }
#line 2056
  current_arg___1 ++;
#line 2057
  if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
    {
#line 2057
    tmp___3 = strncmp((char const   *)*(argv + current_arg___1), "failover\000", (size_t )9);
    }
#line 2057
    if (tmp___3 == 0) {
#line 2059
      failover = 1;
    }
  }
#line 2061
  if (failover) {
#line 2062
    current_arg___1 ++;
  }
#line 2064
  if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
    {
#line 2064
    tmp___9 = strncmp((char const   *)*(argv + current_arg___1), "lom1\000", (size_t )5);
    }
#line 2064
    if (tmp___9 == 0) {
#line 2066
      if (17 == (int )IMC_Type) {
#line 2067
        return (-4);
      }
#line 2069
      if (failover) {
#line 2070
        if ((int )*(nic_set + 0) == 2) {
#line 2071
          return (-2);
        } else
#line 2072
        if ((int )*(nic_set + 0) == 1) {
#line 2073
          return (-3);
        }
#line 2075
        *(nic_set + 1) = (char)2;
      } else {
#line 2077
        *(nic_set + 0) = (char)2;
#line 2078
        if ((int )*(nic_set + 1) == 2) {
#line 2079
          *(nic_set + 1) = (char)0;
        }
      }
#line 2082
      return (0);
    } else {
#line 2064
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 2083
  if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
    {
#line 2083
    tmp___8 = strncmp((char const   *)*(argv + current_arg___1), "lom2\000", (size_t )5);
    }
#line 2083
    if (tmp___8 == 0) {
#line 2085
      if (17 == (int )IMC_Type) {
#line 2086
        return (-4);
      }
#line 2088
      if (failover) {
#line 2089
        if ((int )*(nic_set + 0) == 3) {
#line 2090
          return (-2);
        } else
#line 2091
        if ((int )*(nic_set + 0) == 1) {
#line 2092
          return (-3);
        }
#line 2094
        *(nic_set + 1) = (char)3;
      } else {
#line 2096
        *(nic_set + 0) = (char)3;
#line 2097
        if ((int )*(nic_set + 1) == 3) {
#line 2098
          *(nic_set + 1) = (char)0;
        }
      }
#line 2101
      return (0);
    } else {
#line 2083
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 2102
  if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
    {
#line 2102
    tmp___7 = strncmp((char const   *)*(argv + current_arg___1), "lom3\000", (size_t )5);
    }
#line 2102
    if (tmp___7 == 0) {
#line 2104
      if (17 == (int )IMC_Type) {
#line 2105
        return (-4);
      }
#line 2107
      if (failover) {
#line 2108
        if ((int )*(nic_set + 0) == 4) {
#line 2109
          return (-2);
        } else
#line 2110
        if ((int )*(nic_set + 0) == 1) {
#line 2111
          return (-3);
        }
#line 2113
        *(nic_set + 1) = (char)4;
      } else {
#line 2115
        *(nic_set + 0) = (char)4;
#line 2116
        if ((int )*(nic_set + 1) == 4) {
#line 2117
          *(nic_set + 1) = (char)0;
        }
      }
#line 2120
      return (0);
    } else {
#line 2102
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 2121
  if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
    {
#line 2121
    tmp___6 = strncmp((char const   *)*(argv + current_arg___1), "lom4\000", (size_t )5);
    }
#line 2121
    if (tmp___6 == 0) {
#line 2123
      if (17 == (int )IMC_Type) {
#line 2124
        return (-4);
      }
#line 2126
      if (failover) {
#line 2127
        if ((int )*(nic_set + 0) == 5) {
#line 2128
          return (-2);
        } else
#line 2129
        if ((int )*(nic_set + 0) == 1) {
#line 2130
          return (-3);
        }
#line 2132
        *(nic_set + 1) = (char)5;
      } else {
#line 2134
        *(nic_set + 0) = (char)5;
#line 2135
        if ((int )*(nic_set + 1) == 5) {
#line 2136
          *(nic_set + 1) = (char)0;
        }
      }
#line 2139
      return (0);
    } else {
#line 2121
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 2140
  if (failover) {
#line 2140
    if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
      {
#line 2140
      tmp___5 = strncmp((char const   *)*(argv + current_arg___1), "none\000", (size_t )5);
      }
#line 2140
      if (tmp___5 == 0) {
#line 2142
        if (17 == (int )IMC_Type) {
#line 2143
          return (-4);
        }
#line 2145
        if (failover) {
#line 2146
          if ((int )*(nic_set + 0) == 1) {
#line 2147
            return (-3);
          }
#line 2149
          *(nic_set + 1) = (char)0;
        }
#line 2151
        return (0);
      } else {
#line 2140
        goto _L___0;
      }
    } else {
#line 2140
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 2152
  if (failover) {
#line 2152
    if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
      {
#line 2152
      tmp___4 = strncmp((char const   *)*(argv + current_arg___1), "all\000", (size_t )4);
      }
#line 2152
      if (! (tmp___4 == 0)) {
#line 2156
        return (-1);
      }
    } else {
#line 2156
      return (-1);
    }
  } else {
#line 2156
    return (-1);
  }
#line 2159
  current_arg___1 ++;
#line 2160
  if (failover) {
#line 2160
    if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
      {
#line 2160
      tmp___10 = strncmp((char const   *)*(argv + current_arg___1), "loms\000", (size_t )5);
      }
#line 2160
      if (tmp___10 == 0) {
#line 2162
        if (17 == (int )IMC_Type) {
#line 2163
          return (-4);
        }
#line 2165
        if ((int )*(nic_set + 0) == 1) {
#line 2166
          return (-3);
        }
#line 2168
        *(nic_set + 1) = (char)6;
#line 2169
        return (0);
      }
    }
  }
#line 2171
  return (-1);
}
}
#line 2174 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int get_nic_selection_mode(int current_arg___1 , char **argv ) 
{ 
  int nic_selection_mode ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 2177
  nic_selection_mode = 0;
#line 2178
  if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
    {
#line 2178
    tmp = strncmp((char const   *)*(argv + current_arg___1), "dedicated\000", (size_t )10);
    }
#line 2178
    if (tmp == 0) {
#line 2180
      return (2);
    }
  }
#line 2182
  if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
    {
#line 2182
    tmp___0 = strncmp((char const   *)*(argv + current_arg___1), "shared\000", (size_t )7);
    }
#line 2182
    if (tmp___0 == 0) {
#line 2184
      if ((unsigned long )*(argv + (current_arg___1 + 1)) == (unsigned long )((void *)0)) {
#line 2185
        return (0);
      }
    }
  }
#line 2189
  current_arg___1 ++;
#line 2190
  if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
    {
#line 2190
    tmp___1 = strncmp((char const   *)*(argv + current_arg___1), "with\000", (size_t )5);
    }
#line 2190
    if (! (tmp___1 == 0)) {
#line 2194
      return (-1);
    }
  } else {
#line 2194
    return (-1);
  }
#line 2197
  current_arg___1 ++;
#line 2198
  if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
    {
#line 2198
    tmp___2 = strncmp((char const   *)*(argv + current_arg___1), "failover\000", (size_t )9);
    }
#line 2198
    if (! (tmp___2 == 0)) {
#line 2202
      return (-1);
    }
  } else {
#line 2202
    return (-1);
  }
#line 2205
  current_arg___1 ++;
#line 2206
  if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
    {
#line 2206
    tmp___4 = strncmp((char const   *)*(argv + current_arg___1), "lom2\000", (size_t )5);
    }
#line 2206
    if (tmp___4 == 0) {
#line 2208
      return (1);
    } else {
#line 2206
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2209
  if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
    {
#line 2209
    tmp___3 = strncmp((char const   *)*(argv + current_arg___1), "all\000", (size_t )4);
    }
#line 2209
    if (! (tmp___3 == 0)) {
#line 2213
      return (-1);
    }
  } else {
#line 2213
    return (-1);
  }
#line 2216
  current_arg___1 ++;
#line 2217
  if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
    {
#line 2217
    tmp___5 = strncmp((char const   *)*(argv + current_arg___1), "loms\000", (size_t )5);
    }
#line 2217
    if (tmp___5 == 0) {
#line 2219
      return (3);
    }
  }
#line 2221
  return (-1);
}
}
#line 2224 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lan_set_nic_selection_12g(struct ipmi_intf *intf , uint8_t *nic_selection ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t input_length ;
  uint8_t msg_data[30] ;
  uint8_t tmp ;
  uint8_t tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 2229
  input_length = (uint8_t )0;
#line 2232
  input_length = (uint8_t )0;
#line 2233
  tmp = input_length;
#line 2233
  input_length = (uint8_t )((int )input_length + 1);
#line 2233
  msg_data[tmp] = *(nic_selection + 0);
#line 2234
  tmp___0 = input_length;
#line 2234
  input_length = (uint8_t )((int )input_length + 1);
#line 2234
  msg_data[tmp___0] = *(nic_selection + 1);
#line 2235
  req.msg.netfn = (uint8_t )48;
#line 2236
  req.msg.lun = (uint8_t )0;
#line 2237
  req.msg.cmd = (uint8_t )40;
#line 2238
  req.msg.data = msg_data;
#line 2239
  req.msg.data_len = (uint16_t )input_length;
#line 2240
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2241
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2242
    lprintf(3, "Error in setting nic selection");
    }
#line 2243
    return (-1);
  } else
#line 2244
  if ((int )*(nic_selection + 0) == 1) {
#line 2244
    if ((int )iDRAC_FLAG == 2) {
#line 2244
      if ((int )rsp->ccode == 111) {
        {
#line 2247
        lprintf(3, "FM001 : A required license is missing or expired");
        }
#line 2249
        return (-1);
      } else {
#line 2244
        goto _L;
      }
    } else {
#line 2244
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2250
  if ((int )rsp->ccode > 0) {
    {
#line 2251
    tmp___1 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2251
    lprintf(3, "Error in setting nic selection (%s)", tmp___1);
    }
#line 2253
    return (-1);
  }
  {
#line 2255
  printf((char const   */* __restrict  */)"configured successfully");
  }
#line 2256
  return (0);
}
}
#line 2259 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lan_set_nic_selection(struct ipmi_intf *intf , uint8_t nic_selection ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t input_length ;
  uint8_t msg_data[30] ;
  uint8_t tmp ;
  char const   *tmp___0 ;

  {
  {
#line 2264
  input_length = (uint8_t )0;
#line 2267
  input_length = (uint8_t )0;
#line 2268
  tmp = input_length;
#line 2268
  input_length = (uint8_t )((int )input_length + 1);
#line 2268
  msg_data[tmp] = nic_selection;
#line 2269
  req.msg.netfn = (uint8_t )48;
#line 2270
  req.msg.lun = (uint8_t )0;
#line 2271
  req.msg.cmd = (uint8_t )36;
#line 2272
  req.msg.data = msg_data;
#line 2273
  req.msg.data_len = (uint16_t )input_length;
#line 2274
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2275
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2276
    lprintf(3, "Error in setting nic selection");
    }
#line 2277
    return (-1);
  } else
#line 2278
  if ((int )rsp->ccode > 0) {
    {
#line 2279
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2279
    lprintf(3, "Error in setting nic selection (%s)", tmp___0);
    }
#line 2281
    return (-1);
  }
  {
#line 2283
  printf((char const   */* __restrict  */)"configured successfully");
  }
#line 2284
  return (0);
}
}
#line 2287 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lan_get_nic_selection(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t input_length ;
  uint8_t msg_data[30] ;
  uint8_t nic_selection ;
  uint8_t nic_selection_failover ;
  char const   *tmp ;

  {
#line 2292
  input_length = (uint8_t )0;
#line 2294
  nic_selection = (uint8_t )-1;
#line 2295
  nic_selection_failover = (uint8_t )0;
#line 2297
  input_length = (uint8_t )0;
#line 2298
  req.msg.netfn = (uint8_t )48;
#line 2299
  req.msg.lun = (uint8_t )0;
#line 2300
  if ((int )iDRAC_FLAG == 2) {
#line 2301
    req.msg.cmd = (uint8_t )41;
  } else {
#line 2303
    req.msg.cmd = (uint8_t )37;
  }
  {
#line 2305
  req.msg.data = msg_data;
#line 2306
  req.msg.data_len = (uint16_t )input_length;
#line 2307
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2308
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2309
    lprintf(3, "Error in getting nic selection");
    }
#line 2310
    return (-1);
  } else
#line 2311
  if ((int )rsp->ccode > 0) {
    {
#line 2312
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2312
    lprintf(3, "Error in getting nic selection (%s)", tmp);
    }
#line 2314
    return (-1);
  }
#line 2316
  nic_selection = rsp->data[0];
#line 2317
  if ((int )iDRAC_FLAG == 2) {
#line 2318
    nic_selection_failover = rsp->data[1];
#line 2319
    if ((int )nic_selection < 6) {
#line 2319
      if ((int )nic_selection > 0) {
#line 2319
        if ((int )nic_selection_failover < 7) {
#line 2321
          if ((int )nic_selection == 1) {
            {
#line 2322
            printf((char const   */* __restrict  */)"%s\n", NIC_Selection_Mode_String_12g[(int )nic_selection - 1]);
            }
          } else
#line 2323
          if (nic_selection) {
            {
#line 2324
            printf((char const   */* __restrict  */)"Shared LOM   :  %s\n", NIC_Selection_Mode_String_12g[(int )nic_selection - 1]);
            }
#line 2326
            if ((int )nic_selection_failover == 0) {
              {
#line 2327
              printf((char const   */* __restrict  */)"Failover LOM :  None\n");
              }
            } else
#line 2328
            if ((int )nic_selection_failover >= 2) {
#line 2328
              if ((int )nic_selection_failover <= 6) {
                {
#line 2329
                printf((char const   */* __restrict  */)"Failover LOM :  %s\n", NIC_Selection_Mode_String_12g[(int )nic_selection_failover + 3]);
                }
              }
            }
          }
        } else {
          {
#line 2334
          lprintf(3, "Error Outof bond Value received (%d) (%d)", (int )nic_selection,
                  (int )nic_selection_failover);
          }
#line 2336
          return (-1);
        }
      } else {
        {
#line 2334
        lprintf(3, "Error Outof bond Value received (%d) (%d)", (int )nic_selection,
                (int )nic_selection_failover);
        }
#line 2336
        return (-1);
      }
    } else {
      {
#line 2334
      lprintf(3, "Error Outof bond Value received (%d) (%d)", (int )nic_selection,
              (int )nic_selection_failover);
      }
#line 2336
      return (-1);
    }
  } else {
    {
#line 2339
    printf((char const   */* __restrict  */)"%s\n", NIC_Selection_Mode_String[nic_selection]);
    }
  }
#line 2341
  return (0);
}
}
#line 2344 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lan_get_active_nic(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t active_nic ;
  uint8_t current_lom ;
  uint8_t input_length ;
  uint8_t msg_data[30] ;
  uint8_t tmp ;
  uint8_t tmp___0 ;
  uint8_t tmp___1 ;
  char const   *tmp___2 ;
  uint8_t tmp___3 ;
  uint8_t tmp___4 ;
  uint8_t tmp___5 ;
  char const   *tmp___6 ;

  {
  {
#line 2349
  active_nic = (uint8_t )0;
#line 2350
  current_lom = (uint8_t )0;
#line 2351
  input_length = (uint8_t )0;
#line 2354
  input_length = (uint8_t )0;
#line 2355
  tmp = input_length;
#line 2355
  input_length = (uint8_t )((int )input_length + 1);
#line 2355
  msg_data[tmp] = (uint8_t )0;
#line 2356
  tmp___0 = input_length;
#line 2356
  input_length = (uint8_t )((int )input_length + 1);
#line 2356
  msg_data[tmp___0] = (uint8_t )0;
#line 2357
  tmp___1 = input_length;
#line 2357
  input_length = (uint8_t )((int )input_length + 1);
#line 2357
  msg_data[tmp___1] = (uint8_t )0;
#line 2358
  req.msg.netfn = (uint8_t )48;
#line 2359
  req.msg.lun = (uint8_t )0;
#line 2360
  req.msg.cmd = (uint8_t )193;
#line 2361
  req.msg.data = msg_data;
#line 2362
  req.msg.data_len = (uint16_t )input_length;
#line 2363
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2364
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2365
    lprintf(3, "Error in getting Active LOM Status");
    }
#line 2366
    return (-1);
  } else
#line 2367
  if ((int )rsp->ccode > 0) {
    {
#line 2368
    tmp___2 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2368
    lprintf(3, "Error in getting Active LOM Status (%s)", tmp___2);
    }
#line 2370
    return (-1);
  }
  {
#line 2372
  current_lom = rsp->data[0];
#line 2373
  input_length = (uint8_t )0;
#line 2374
  tmp___3 = input_length;
#line 2374
  input_length = (uint8_t )((int )input_length + 1);
#line 2374
  msg_data[tmp___3] = (uint8_t )1;
#line 2375
  tmp___4 = input_length;
#line 2375
  input_length = (uint8_t )((int )input_length + 1);
#line 2375
  msg_data[tmp___4] = (uint8_t )0;
#line 2376
  tmp___5 = input_length;
#line 2376
  input_length = (uint8_t )((int )input_length + 1);
#line 2376
  msg_data[tmp___5] = (uint8_t )0;
#line 2377
  req.msg.netfn = (uint8_t )48;
#line 2378
  req.msg.lun = (uint8_t )0;
#line 2379
  req.msg.cmd = (uint8_t )193;
#line 2380
  req.msg.data = msg_data;
#line 2381
  req.msg.data_len = (uint16_t )input_length;
#line 2382
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2383
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2384
    lprintf(3, "Error in getting Active LOM Status");
    }
#line 2385
    return (-1);
  } else
#line 2386
  if ((int )rsp->ccode > 0) {
    {
#line 2387
    tmp___6 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2387
    lprintf(3, "Error in getting Active LOM Status (%s)", tmp___6);
    }
#line 2389
    return (-1);
  }
#line 2391
  active_nic = rsp->data[1];
#line 2392
  if ((int )current_lom < 6) {
#line 2392
    if (active_nic) {
      {
#line 2393
      printf((char const   */* __restrict  */)"\n%s\n", AciveLOM_String[current_lom]);
      }
    } else {
      {
#line 2395
      printf((char const   */* __restrict  */)"\n%s\n", AciveLOM_String[0]);
      }
    }
  } else {
    {
#line 2395
    printf((char const   */* __restrict  */)"\n%s\n", AciveLOM_String[0]);
    }
  }
#line 2397
  return (0);
}
}
#line 2400 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void ipmi_lan_usage(void) 
{ 


  {
  {
#line 2409
  lprintf(5, "");
#line 2411
  lprintf(5, "   lan set <Mode>");
#line 2413
  lprintf(5, "      sets the NIC Selection Mode :");
#line 2415
  lprintf(5, "          on iDRAC12g :");
#line 2417
  lprintf(5, "              dedicated, shared with lom1, shared with lom2,shared with lom3,shared");
#line 2419
  lprintf(5, "              with lom4,shared with failover lom1,shared with failover lom2,shared");
#line 2421
  lprintf(5, "              with failover lom3,shared with failover lom4,shared with Failover all");
#line 2423
  lprintf(5, "              loms, shared with Failover None).");
#line 2425
  lprintf(5, "          on other systems :");
#line 2427
  lprintf(5, "              dedicated, shared, shared with failover lom2,");
#line 2429
  lprintf(5, "              shared with Failover all loms.");
#line 2431
  lprintf(5, "");
#line 2433
  lprintf(5, "   lan get ");
#line 2435
  lprintf(5, "          on iDRAC12g :");
#line 2437
  lprintf(5, "              returns the current NIC Selection Mode (dedicated, shared with lom1, shared");
#line 2439
  lprintf(5, "              with lom2, shared with lom3, shared with lom4,shared with failover lom1,");
#line 2441
  lprintf(5, "              shared with failover lom2,shared with failover lom3,shared with failover");
#line 2443
  lprintf(5, "              lom4,shared with Failover all loms,shared with Failover None).");
#line 2445
  lprintf(5, "          on other systems :");
#line 2447
  lprintf(5, "              dedicated, shared, shared with failover,");
#line 2449
  lprintf(5, "              lom2, shared with Failover all loms.");
#line 2451
  lprintf(5, "");
#line 2453
  lprintf(5, "   lan get active");
#line 2455
  lprintf(5, "      returns the current active NIC (dedicated, LOM1, LOM2, LOM3, LOM4).");
#line 2457
  lprintf(5, "");
  }
#line 2459
  return;
}
}
#line 2472 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_delloem_powermonitor_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int val ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
#line 2475
  rc = 0;
#line 2476
  current_arg ++;
#line 2477
  if (argc > 1) {
    {
#line 2477
    tmp = strcmp((char const   *)*(argv + current_arg), "help");
    }
#line 2477
    if (tmp == 0) {
      {
#line 2478
      ipmi_powermonitor_usage();
      }
#line 2479
      return (0);
    }
  }
  {
#line 2481
  ipmi_idracvalidator_command(intf);
  }
#line 2482
  if (argc == 1) {
    {
#line 2483
    rc = ipmi_powermgmt(intf);
    }
  } else {
    {
#line 2484
    tmp___20 = strncmp((char const   *)*(argv + current_arg), "status\000", (size_t )7);
    }
#line 2484
    if (tmp___20 == 0) {
      {
#line 2485
      rc = ipmi_powermgmt(intf);
      }
    } else {
      {
#line 2486
      tmp___19 = strncmp((char const   *)*(argv + current_arg), "clear\000", (size_t )6);
      }
#line 2486
      if (tmp___19 == 0) {
#line 2487
        current_arg ++;
#line 2488
        if ((unsigned long )*(argv + current_arg) == (unsigned long )((void *)0)) {
          {
#line 2489
          ipmi_powermonitor_usage();
          }
#line 2490
          return (-1);
        } else {
          {
#line 2491
          tmp___1 = strncmp((char const   *)*(argv + current_arg), "peakpower\000",
                            (size_t )10);
          }
#line 2491
          if (tmp___1 == 0) {
            {
#line 2492
            rc = ipmi_powermgmt_clear(intf, (uint8_t )1);
            }
          } else {
            {
#line 2493
            tmp___0 = strncmp((char const   *)*(argv + current_arg), "cumulativepower\000",
                              (size_t )16);
            }
#line 2493
            if (tmp___0 == 0) {
              {
#line 2494
              rc = ipmi_powermgmt_clear(intf, (uint8_t )0);
              }
            } else {
              {
#line 2496
              ipmi_powermonitor_usage();
              }
#line 2497
              return (-1);
            }
          }
        }
      } else {
        {
#line 2499
        tmp___18 = strncmp((char const   *)*(argv + current_arg), "powerconsumption\000",
                           (size_t )17);
        }
#line 2499
        if (tmp___18 == 0) {
#line 2500
          current_arg ++;
#line 2501
          if ((unsigned long )*(argv + current_arg) == (unsigned long )((void *)0)) {
            {
#line 2502
            rc = ipmi_print_get_power_consmpt_data(intf, (uint8_t )0);
            }
          } else {
            {
#line 2503
            tmp___3 = strncmp((char const   *)*(argv + current_arg), "watt\000", (size_t )5);
            }
#line 2503
            if (tmp___3 == 0) {
              {
#line 2504
              rc = ipmi_print_get_power_consmpt_data(intf, (uint8_t )0);
              }
            } else {
              {
#line 2505
              tmp___2 = strncmp((char const   *)*(argv + current_arg), "btuphr\000",
                                (size_t )7);
              }
#line 2505
              if (tmp___2 == 0) {
                {
#line 2506
                rc = ipmi_print_get_power_consmpt_data(intf, (uint8_t )1);
                }
              } else {
                {
#line 2508
                ipmi_powermonitor_usage();
                }
#line 2509
                return (-1);
              }
            }
          }
        } else {
          {
#line 2511
          tmp___17 = strncmp((char const   *)*(argv + current_arg), "powerconsumptionhistory\000",
                             (size_t )23);
          }
#line 2511
          if (tmp___17 == 0) {
#line 2512
            current_arg ++;
#line 2513
            if ((unsigned long )*(argv + current_arg) == (unsigned long )((void *)0)) {
              {
#line 2514
              rc = ipmi_print_power_consmpt_history(intf, 0);
              }
            } else {
              {
#line 2515
              tmp___5 = strncmp((char const   *)*(argv + current_arg), "watt\000",
                                (size_t )5);
              }
#line 2515
              if (tmp___5 == 0) {
                {
#line 2516
                rc = ipmi_print_power_consmpt_history(intf, 0);
                }
              } else {
                {
#line 2517
                tmp___4 = strncmp((char const   *)*(argv + current_arg), "btuphr\000",
                                  (size_t )7);
                }
#line 2517
                if (tmp___4 == 0) {
                  {
#line 2518
                  rc = ipmi_print_power_consmpt_history(intf, 1);
                  }
                } else {
                  {
#line 2520
                  ipmi_powermonitor_usage();
                  }
#line 2521
                  return (-1);
                }
              }
            }
          } else {
            {
#line 2523
            tmp___16 = strncmp((char const   *)*(argv + current_arg), "getpowerbudget\000",
                               (size_t )15);
            }
#line 2523
            if (tmp___16 == 0) {
#line 2524
              current_arg ++;
#line 2525
              if ((unsigned long )*(argv + current_arg) == (unsigned long )((void *)0)) {
                {
#line 2526
                rc = ipmi_print_power_cap(intf, (uint8_t )0);
                }
              } else {
                {
#line 2527
                tmp___7 = strncmp((char const   *)*(argv + current_arg), "watt\000",
                                  (size_t )5);
                }
#line 2527
                if (tmp___7 == 0) {
                  {
#line 2528
                  rc = ipmi_print_power_cap(intf, (uint8_t )0);
                  }
                } else {
                  {
#line 2529
                  tmp___6 = strncmp((char const   *)*(argv + current_arg), "btuphr\000",
                                    (size_t )7);
                  }
#line 2529
                  if (tmp___6 == 0) {
                    {
#line 2530
                    rc = ipmi_print_power_cap(intf, (uint8_t )1);
                    }
                  } else {
                    {
#line 2532
                    ipmi_powermonitor_usage();
                    }
#line 2533
                    return (-1);
                  }
                }
              }
            } else {
              {
#line 2535
              tmp___15 = strncmp((char const   *)*(argv + current_arg), "setpowerbudget\000",
                                 (size_t )15);
              }
#line 2535
              if (tmp___15 == 0) {
#line 2537
                current_arg ++;
#line 2538
                if ((unsigned long )*(argv + current_arg) == (unsigned long )((void *)0)) {
                  {
#line 2539
                  ipmi_powermonitor_usage();
                  }
#line 2540
                  return (-1);
                }
                {
#line 2542
                tmp___8 = strchr((char const   *)*(argv + current_arg), '.');
                }
#line 2542
                if (tmp___8) {
                  {
#line 2543
                  lprintf(3, "Cap value in Watts, Btu/hr or percent should be whole number");
                  }
#line 2545
                  return (-1);
                }
                {
#line 2547
                tmp___9 = str2int((char const   *)*(argv + current_arg), & val);
                }
#line 2547
                if (tmp___9 != 0) {
                  {
#line 2548
                  lprintf(3, "Given capacity value \'%s\' is invalid.", *(argv + current_arg));
                  }
#line 2550
                  return (-1);
                }
#line 2552
                current_arg ++;
#line 2553
                if ((unsigned long )*(argv + current_arg) == (unsigned long )((void *)0)) {
                  {
#line 2554
                  ipmi_powermonitor_usage();
                  }
                } else {
                  {
#line 2555
                  tmp___12 = strncmp((char const   *)*(argv + current_arg), "watt\000",
                                     (size_t )5);
                  }
#line 2555
                  if (tmp___12 == 0) {
                    {
#line 2556
                    rc = ipmi_set_power_cap(intf, 0, val);
                    }
                  } else {
                    {
#line 2557
                    tmp___11 = strncmp((char const   *)*(argv + current_arg), "btuphr\000",
                                       (size_t )7);
                    }
#line 2557
                    if (tmp___11 == 0) {
                      {
#line 2558
                      rc = ipmi_set_power_cap(intf, 1, val);
                      }
                    } else {
                      {
#line 2559
                      tmp___10 = strncmp((char const   *)*(argv + current_arg), "percent\000",
                                         (size_t )8);
                      }
#line 2559
                      if (tmp___10 == 0) {
                        {
#line 2560
                        rc = ipmi_set_power_cap(intf, 3, val);
                        }
                      } else {
                        {
#line 2562
                        ipmi_powermonitor_usage();
                        }
#line 2563
                        return (-1);
                      }
                    }
                  }
                }
              } else {
                {
#line 2565
                tmp___14 = strncmp((char const   *)*(argv + current_arg), "enablepowercap\000",
                                   (size_t )15);
                }
#line 2565
                if (tmp___14 == 0) {
                  {
#line 2566
                  ipmi_set_power_capstatus_command(intf, (uint8_t )1);
                  }
                } else {
                  {
#line 2567
                  tmp___13 = strncmp((char const   *)*(argv + current_arg), "disablepowercap\000",
                                     (size_t )16);
                  }
#line 2567
                  if (tmp___13 == 0) {
                    {
#line 2568
                    ipmi_set_power_capstatus_command(intf, (uint8_t )0);
                    }
                  } else {
                    {
#line 2570
                    ipmi_powermonitor_usage();
                    }
#line 2571
                    return (-1);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 2573
  return (rc);
}
}
#line 2584 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void ipmi_time_to_str(time_t rawTime , char *strTime ) 
{ 
  struct tm *tm ;
  char *temp ;

  {
  {
#line 2589
  tm = gmtime((time_t const   *)(& rawTime));
#line 2590
  temp = asctime((struct tm  const  *)tm);
#line 2591
  strcpy((char */* __restrict  */)strTime, (char const   */* __restrict  */)temp);
  }
#line 2592
  return;
}
}
#line 2604 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_get_sensor_reading(struct ipmi_intf *intf , unsigned char sensorNumber ,
                                   SensorReadingType *pSensorReadingData ) 
{ 
  struct ipmi_rq req ;
  struct ipmi_rs *rsp ;
  int rc ;

  {
  {
#line 2610
  rc = 0;
#line 2611
  memset((void *)(& req), 0, sizeof(req));
#line 2612
  req.msg.netfn = (uint8_t )4;
#line 2613
  req.msg.lun = (uint8_t )0;
#line 2614
  req.msg.cmd = (uint8_t )45;
#line 2615
  req.msg.data = & sensorNumber;
#line 2616
  req.msg.data_len = (uint16_t )1;
  }
#line 2617
  if ((unsigned long )pSensorReadingData == (unsigned long )((void *)0)) {
#line 2618
    return (-1);
  }
  {
#line 2620
  memset((void *)pSensorReadingData, 0, sizeof(SensorReadingType ));
#line 2621
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2622
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
#line 2623
    return (1);
  } else
#line 2624
  if ((int )rsp->ccode > 0) {
#line 2625
    return (1);
  }
  {
#line 2627
  memcpy((void */* __restrict  */)pSensorReadingData, (void const   */* __restrict  */)(rsp->data),
         sizeof(SensorReadingType ));
  }
#line 2629
  if ((int )rsp->ccode != 0) {
#line 2630
    rc = 1;
  }
#line 2633
  if (! ((int )rsp->data[1] & 192)) {
#line 2634
    rc = 1;
  } else
#line 2633
  if ((int )rsp->data[1] & 32) {
#line 2634
    rc = 1;
  }
#line 2636
  return (rc);
}
}
#line 2648 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_get_power_capstatus_command(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t data[2] ;
  char const   *tmp ;

  {
  {
#line 2651
  rsp = (struct ipmi_rs *)((void *)0);
#line 2652
  req.msg.netfn = (uint8_t )0;
#line 2652
  req.msg.lun = (unsigned char)0;
#line 2652
  req.msg.cmd = (unsigned char)0;
#line 2652
  req.msg.target_cmd = (unsigned char)0;
#line 2652
  req.msg.data_len = (unsigned short)0;
#line 2652
  req.msg.data = (uint8_t *)0;
#line 2654
  req.msg.netfn = (uint8_t )48;
#line 2655
  req.msg.lun = (uint8_t )0;
#line 2656
  req.msg.cmd = (uint8_t )186;
#line 2657
  req.msg.data_len = (uint16_t )2;
#line 2658
  req.msg.data = data;
#line 2659
  data[0] = (uint8_t )1;
#line 2660
  data[1] = (uint8_t )255;
#line 2661
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2662
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2663
    lprintf(3, "Error getting powercap status");
    }
#line 2664
    return (-1);
  } else
#line 2665
  if ((int )iDRAC_FLAG == 2) {
#line 2665
    if ((int )rsp->ccode == 111) {
      {
#line 2666
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 2668
      return (-1);
    } else {
#line 2665
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2669
  if ((int )rsp->ccode > 0) {
    {
#line 2670
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2670
    lprintf(3, "Error getting powercap statusr: %s", tmp);
    }
#line 2672
    return (-1);
  }
#line 2674
  if ((int )rsp->data[0] & 2) {
#line 2675
    PowercapSetable_flag = (uint8_t )1;
  }
#line 2677
  if ((int )rsp->data[0] & 1) {
#line 2678
    PowercapstatusFlag = (uint8_t )1;
  }
#line 2680
  return (0);
}
}
#line 2692 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_set_power_capstatus_command(struct ipmi_intf *intf , uint8_t val ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t data[2] ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 2695
  rsp = (struct ipmi_rs *)((void *)0);
#line 2696
  req.msg.netfn = (uint8_t )0;
#line 2696
  req.msg.lun = (unsigned char)0;
#line 2696
  req.msg.cmd = (unsigned char)0;
#line 2696
  req.msg.target_cmd = (unsigned char)0;
#line 2696
  req.msg.data_len = (unsigned short)0;
#line 2696
  req.msg.data = (uint8_t *)0;
#line 2698
  tmp = ipmi_get_power_capstatus_command(intf);
  }
#line 2698
  if (tmp < 0) {
#line 2699
    return (-1);
  }
#line 2701
  if ((int )PowercapSetable_flag != 1) {
    {
#line 2702
    lprintf(3, "Can not set powercap on this system");
    }
#line 2703
    return (-1);
  }
  {
#line 2705
  req.msg.netfn = (uint8_t )48;
#line 2706
  req.msg.lun = (uint8_t )0;
#line 2707
  req.msg.cmd = (uint8_t )186;
#line 2708
  req.msg.data_len = (uint16_t )2;
#line 2709
  req.msg.data = data;
#line 2710
  data[0] = (uint8_t )0;
#line 2711
  data[1] = val;
#line 2712
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2713
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2714
    lprintf(3, "Error setting powercap status");
    }
#line 2715
    return (-1);
  } else
#line 2716
  if ((int )iDRAC_FLAG == 2) {
#line 2716
    if ((int )rsp->ccode == 111) {
      {
#line 2717
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 2719
      return (-1);
    } else {
#line 2716
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2720
  if ((int )rsp->ccode > 0) {
    {
#line 2721
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2721
    lprintf(3, "Error setting powercap statusr: %s", tmp___0);
    }
#line 2723
    return (-1);
  }
#line 2725
  return (0);
}
}
#line 2736 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_powermgmt(struct ipmi_intf *intf ) 
{ 
  time_t now ;
  struct tm *tm ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[2] ;
  uint32_t cumStartTimeConv ;
  uint32_t cumReadingConv ;
  uint32_t maxPeakStartTimeConv ;
  uint32_t ampPeakTimeConv ;
  uint16_t ampReadingConv ;
  uint32_t wattPeakTimeConv ;
  uint32_t wattReadingConv ;
  uint32_t bmctimeconv ;
  uint32_t *bmctimeconvval ;
  IPMI_POWER_MONITOR *pwrMonitorInfo ;
  char cumStartTime[26] ;
  char maxPeakStartTime[26] ;
  char ampPeakTime[26] ;
  char wattPeakTime[26] ;
  char bmctime[26] ;
  int ampReading ;
  int ampReadingRemainder ;
  int remainder___0 ;
  int wattReading ;

  {
  {
#line 2767
  now = time((time_t *)0);
#line 2768
  tm = gmtime((time_t const   *)(& now));
#line 2770
  memset((void *)(& req), 0, sizeof(req));
#line 2771
  req.msg.netfn = (uint8_t )10;
#line 2772
  req.msg.lun = (uint8_t )0;
#line 2773
  req.msg.cmd = (uint8_t )72;
#line 2775
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2776
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2777
    lprintf(3, "Error getting BMC time info.");
    }
#line 2778
    return (-1);
  }
#line 2780
  if ((int )rsp->ccode != 0) {
    {
#line 2781
    lprintf(3, "Error getting power management information, return code %x", (int )rsp->ccode);
    }
#line 2784
    return (-1);
  }
  {
#line 2786
  bmctimeconvval = (uint32_t *)(rsp->data);
#line 2790
  bmctimeconv = *bmctimeconvval;
#line 2794
  req.msg.netfn = (uint8_t )48;
#line 2795
  req.msg.lun = (uint8_t )0;
#line 2796
  req.msg.cmd = (uint8_t )156;
#line 2797
  req.msg.data = msg_data;
#line 2798
  req.msg.data_len = (uint16_t )2;
#line 2800
  memset((void *)(msg_data), 0, (size_t )2);
#line 2801
  msg_data[0] = (uint8_t )7;
#line 2802
  msg_data[1] = (uint8_t )1;
#line 2804
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2805
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2806
    lprintf(3, "Error getting power management information.");
    }
#line 2807
    return (-1);
  }
#line 2810
  if ((int )iDRAC_FLAG == 2) {
#line 2810
    if ((int )rsp->ccode == 111) {
      {
#line 2811
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 2813
      return (-1);
    } else {
#line 2810
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2814
  if ((int )rsp->ccode == 193) {
    {
#line 2815
    lprintf(3, "Error getting power management information: Command not supported on this system.");
    }
#line 2817
    return (-1);
  } else
#line 2814
  if ((int )rsp->ccode == 203) {
    {
#line 2815
    lprintf(3, "Error getting power management information: Command not supported on this system.");
    }
#line 2817
    return (-1);
  } else
#line 2818
  if ((int )rsp->ccode != 0) {
    {
#line 2819
    lprintf(3, "Error getting power management information, return code %x", (int )rsp->ccode);
    }
#line 2822
    return (-1);
  }
  {
#line 2825
  pwrMonitorInfo = (IPMI_POWER_MONITOR *)(rsp->data);
#line 2835
  cumStartTimeConv = pwrMonitorInfo->cumStartTime;
#line 2836
  cumReadingConv = pwrMonitorInfo->cumReading;
#line 2837
  maxPeakStartTimeConv = pwrMonitorInfo->maxPeakStartTime;
#line 2838
  ampPeakTimeConv = pwrMonitorInfo->ampPeakTime;
#line 2839
  ampReadingConv = pwrMonitorInfo->ampReading;
#line 2840
  wattPeakTimeConv = pwrMonitorInfo->wattPeakTime;
#line 2841
  wattReadingConv = (uint32_t )pwrMonitorInfo->wattReading;
#line 2844
  ipmi_time_to_str((time_t )cumStartTimeConv, cumStartTime);
#line 2845
  ipmi_time_to_str((time_t )maxPeakStartTimeConv, maxPeakStartTime);
#line 2846
  ipmi_time_to_str((time_t )ampPeakTimeConv, ampPeakTime);
#line 2847
  ipmi_time_to_str((time_t )wattPeakTimeConv, wattPeakTime);
#line 2848
  ipmi_time_to_str((time_t )bmctimeconv, bmctime);
#line 2849
  now = time((time_t *)0);
#line 2851
  remainder___0 = (int )(cumReadingConv % 1000U);
#line 2852
  cumReadingConv /= 1000U;
#line 2853
  remainder___0 = (remainder___0 + 50) / 100;
#line 2855
  ampReading = (int )ampReadingConv;
#line 2856
  ampReadingRemainder = ampReading % 10;
#line 2857
  ampReading /= 10;
#line 2859
  wattReading = (int )wattReadingConv;
#line 2861
  printf((char const   */* __restrict  */)"Power Tracking Statistics\n");
#line 2862
  printf((char const   */* __restrict  */)"Statistic      : Cumulative Energy Consumption\n");
#line 2863
  printf((char const   */* __restrict  */)"Start Time     : %s", cumStartTime);
#line 2864
  printf((char const   */* __restrict  */)"Finish Time    : %s", bmctime);
#line 2865
  printf((char const   */* __restrict  */)"Reading        : %d.%d kWh\n\n", cumReadingConv,
         remainder___0);
#line 2867
  printf((char const   */* __restrict  */)"Statistic      : System Peak Power\n");
#line 2868
  printf((char const   */* __restrict  */)"Start Time     : %s", maxPeakStartTime);
#line 2869
  printf((char const   */* __restrict  */)"Peak Time      : %s", wattPeakTime);
#line 2870
  printf((char const   */* __restrict  */)"Peak Reading   : %d W\n\n", wattReading);
#line 2872
  printf((char const   */* __restrict  */)"Statistic      : System Peak Amperage\n");
#line 2873
  printf((char const   */* __restrict  */)"Start Time     : %s", maxPeakStartTime);
#line 2874
  printf((char const   */* __restrict  */)"Peak Time      : %s", ampPeakTime);
#line 2875
  printf((char const   */* __restrict  */)"Peak Reading   : %d.%d A\n", ampReading,
         ampReadingRemainder);
  }
#line 2876
  return (0);
}
}
#line 2888 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_powermgmt_clear(struct ipmi_intf *intf , uint8_t clearValue ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t clearType ;
  uint8_t msg_data[3] ;
  char const   *tmp ;

  {
#line 2893
  clearType = (uint8_t )1;
#line 2895
  if (clearValue) {
#line 2896
    clearType = (uint8_t )2;
  }
  {
#line 2899
  req.msg.netfn = (uint8_t )48;
#line 2900
  req.msg.lun = (uint8_t )0;
#line 2901
  req.msg.cmd = (uint8_t )157;
#line 2902
  req.msg.data = msg_data;
#line 2903
  req.msg.data_len = (uint16_t )3;
#line 2904
  memset((void *)(msg_data), 0, (size_t )3);
#line 2905
  msg_data[0] = (uint8_t )7;
#line 2906
  msg_data[1] = (uint8_t )1;
#line 2907
  msg_data[2] = clearType;
#line 2909
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2910
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2911
    lprintf(3, "Error clearing power values.");
    }
#line 2912
    return (-1);
  } else
#line 2913
  if ((int )iDRAC_FLAG == 2) {
#line 2913
    if ((int )rsp->ccode == 111) {
      {
#line 2915
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 2917
      return (-1);
    } else {
#line 2913
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2918
  if ((int )rsp->ccode == 193) {
    {
#line 2919
    lprintf(3, "Error clearing power values, command not supported on this system.");
    }
#line 2921
    return (-1);
  } else
#line 2922
  if ((int )rsp->ccode != 0) {
    {
#line 2923
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2923
    lprintf(3, "Error clearing power values: %s", tmp);
    }
#line 2925
    return (-1);
  }
#line 2927
  return (0);
}
}
#line 2939 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static uint64_t watt_to_btuphr_conversion(uint32_t powerinwatt ) 
{ 
  uint64_t powerinbtuphr ;

  {
#line 2943
  powerinbtuphr = (uint64_t )(3.413 * (double )powerinwatt);
#line 2944
  return (powerinbtuphr);
}
}
#line 2956 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static uint32_t btuphr_to_watt_conversion(uint64_t powerinbtuphr ) 
{ 
  uint32_t powerinwatt ;

  {
#line 2961
  powerinwatt = (uint32_t )((double )powerinbtuphr / 3.413);
#line 2962
  return (powerinwatt);
}
}
#line 2974 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_get_power_headroom_command(struct ipmi_intf *intf , uint8_t unit ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint64_t peakpowerheadroombtuphr ;
  uint64_t instantpowerhearoom ;
  char const   *tmp ;

  {
  {
#line 2977
  rsp = (struct ipmi_rs *)((void *)0);
#line 2978
  req.msg.netfn = (uint8_t )0;
#line 2978
  req.msg.lun = (unsigned char)0;
#line 2978
  req.msg.cmd = (unsigned char)0;
#line 2978
  req.msg.target_cmd = (unsigned char)0;
#line 2978
  req.msg.data_len = (unsigned short)0;
#line 2978
  req.msg.data = (uint8_t *)0;
#line 2982
  req.msg.netfn = (uint8_t )48;
#line 2983
  req.msg.lun = (uint8_t )0;
#line 2984
  req.msg.cmd = (uint8_t )187;
#line 2985
  req.msg.data_len = (uint16_t )0;
#line 2987
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2988
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2989
    lprintf(3, "Error getting power headroom status");
    }
#line 2990
    return (-1);
  } else
#line 2991
  if ((int )iDRAC_FLAG == 2) {
#line 2991
    if ((int )rsp->ccode == 111) {
      {
#line 2993
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 2995
      return (-1);
    } else {
#line 2991
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2996
  if ((int )rsp->ccode == 193) {
    {
#line 2997
    lprintf(3, "Error getting power headroom status: Command not supported on this system ");
    }
#line 2999
    return (-1);
  } else
#line 2996
  if ((int )rsp->ccode == 203) {
    {
#line 2997
    lprintf(3, "Error getting power headroom status: Command not supported on this system ");
    }
#line 2999
    return (-1);
  } else
#line 3000
  if ((int )rsp->ccode > 0) {
    {
#line 3001
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3001
    lprintf(3, "Error getting power headroom status: %s", tmp);
    }
#line 3003
    return (-1);
  }
#line 3005
  if (verbose > 1) {
    {
#line 3007
    printf((char const   */* __restrict  */)"power headroom  Data               : %x %x %x %x ",
           (int )rsp->data[0], (int )rsp->data[1], (int )rsp->data[2], (int )rsp->data[3]);
    }
  }
  {
#line 3010
  powerheadroom = *((POWER_HEADROOM *)(rsp->data));
#line 3015
  printf((char const   */* __restrict  */)"Headroom\n");
#line 3016
  printf((char const   */* __restrict  */)"Statistic                     Reading\n");
  }
#line 3017
  if ((int )unit == 1) {
    {
#line 3018
    peakpowerheadroombtuphr = watt_to_btuphr_conversion((uint32_t )powerheadroom.peakheadroom);
#line 3019
    instantpowerhearoom = watt_to_btuphr_conversion((uint32_t )powerheadroom.instheadroom);
#line 3020
    printf((char const   */* __restrict  */)"System Instantaneous Headroom : %lld BTU/hr\n",
           instantpowerhearoom);
#line 3022
    printf((char const   */* __restrict  */)"System Peak Headroom          : %lld BTU/hr\n",
           peakpowerheadroombtuphr);
    }
  } else {
    {
#line 3025
    printf((char const   */* __restrict  */)"System Instantaneous Headroom : %d W\n",
           (int )powerheadroom.instheadroom);
#line 3027
    printf((char const   */* __restrict  */)"System Peak Headroom          : %d W\n",
           (int )powerheadroom.peakheadroom);
    }
  }
#line 3030
  return (0);
}
}
#line 3042 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_get_power_consumption_data(struct ipmi_intf *intf , uint8_t unit ) 
{ 
  SensorReadingType sensorReadingData ;
  struct ipmi_rs *rsp ;
  struct sdr_record_list *sdr ;
  int readingbtuphr ;
  int warning_threshbtuphr ;
  int failure_threshbtuphr ;
  int status ;
  int sensor_number ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  uint64_t tmp___2 ;
  uint64_t tmp___3 ;
  uint64_t tmp___4 ;

  {
  {
#line 3047
  rsp = (struct ipmi_rs *)((void *)0);
#line 3049
  readingbtuphr = 0;
#line 3050
  warning_threshbtuphr = 0;
#line 3051
  failure_threshbtuphr = 0;
#line 3052
  status = 0;
#line 3053
  sensor_number = 0;
#line 3054
  sdr = ipmi_sdr_find_sdr_byid(intf, (char *)"System Level");
  }
#line 3055
  if ((unsigned long )sdr == (unsigned long )((void *)0)) {
    {
#line 3056
    lprintf(3, "Error : Can not access the System Level sensor data");
    }
#line 3058
    return (-1);
  }
  {
#line 3060
  sensor_number = (int )(sdr->record.common)->keys.sensor_num;
#line 3061
  ipmi_get_sensor_reading(intf, (unsigned char )sensor_number, & sensorReadingData);
#line 3062
  rsp = ipmi_sdr_get_sensor_thresholds(intf, (sdr->record.common)->keys.sensor_num,
                                       (sdr->record.common)->keys.owner_id, (sdr->record.common)->keys.lun,
                                       (sdr->record.common)->keys.channel);
  }
#line 3067
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 3068
    lprintf(3, "Error : Can not access the System Level sensor data");
    }
#line 3070
    return (-1);
  } else
#line 3067
  if ((int )rsp->ccode != 0) {
    {
#line 3068
    lprintf(3, "Error : Can not access the System Level sensor data");
    }
#line 3070
    return (-1);
  }
  {
#line 3072
  tmp = sdr_convert_sensor_reading(sdr->record.full, sensorReadingData.sensorReading);
#line 3072
  readingbtuphr = (int )tmp;
#line 3074
  tmp___0 = sdr_convert_sensor_reading(sdr->record.full, rsp->data[4]);
#line 3074
  warning_threshbtuphr = (int )tmp___0;
#line 3076
  tmp___1 = sdr_convert_sensor_reading(sdr->record.full, rsp->data[5]);
#line 3076
  failure_threshbtuphr = (int )tmp___1;
#line 3079
  printf((char const   */* __restrict  */)"System Board System Level\n");
  }
#line 3080
  if ((int )unit == 1) {
    {
#line 3081
    tmp___2 = watt_to_btuphr_conversion((uint32_t )readingbtuphr);
#line 3081
    readingbtuphr = (int )tmp___2;
#line 3082
    tmp___3 = watt_to_btuphr_conversion((uint32_t )warning_threshbtuphr);
#line 3082
    warning_threshbtuphr = (int )tmp___3;
#line 3083
    tmp___4 = watt_to_btuphr_conversion((uint32_t )failure_threshbtuphr);
#line 3083
    failure_threshbtuphr = (int )tmp___4;
#line 3085
    printf((char const   */* __restrict  */)"Reading                        : %d BTU/hr\n",
           readingbtuphr);
#line 3086
    printf((char const   */* __restrict  */)"Warning threshold      : %d BTU/hr\n",
           warning_threshbtuphr);
#line 3087
    printf((char const   */* __restrict  */)"Failure threshold      : %d BTU/hr\n",
           failure_threshbtuphr);
    }
  } else {
    {
#line 3089
    printf((char const   */* __restrict  */)"Reading                        : %d W \n",
           readingbtuphr);
#line 3090
    printf((char const   */* __restrict  */)"Warning threshold      : %d W \n", warning_threshbtuphr);
#line 3091
    printf((char const   */* __restrict  */)"Failure threshold      : %d W \n", failure_threshbtuphr);
    }
  }
#line 3093
  return (status);
}
}
#line 3104 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_get_instan_power_consmpt_data(struct ipmi_intf *intf , IPMI_INST_POWER_CONSUMPTION_DATA *instpowerconsumptiondata ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[2] ;
  char const   *tmp ;

  {
  {
#line 3109
  req.msg.netfn = (uint8_t )0;
#line 3109
  req.msg.lun = (unsigned char)0;
#line 3109
  req.msg.cmd = (unsigned char)0;
#line 3109
  req.msg.target_cmd = (unsigned char)0;
#line 3109
  req.msg.data_len = (unsigned short)0;
#line 3109
  req.msg.data = (uint8_t *)0;
#line 3112
  req.msg.netfn = (uint8_t )48;
#line 3113
  req.msg.lun = (uint8_t )0;
#line 3114
  req.msg.cmd = (uint8_t )179;
#line 3115
  req.msg.data = msg_data;
#line 3116
  req.msg.data_len = (uint16_t )2;
#line 3117
  memset((void *)(msg_data), 0, (size_t )2);
#line 3118
  msg_data[0] = (uint8_t )10;
#line 3119
  msg_data[1] = (uint8_t )0;
#line 3121
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 3122
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 3123
    lprintf(3, "Error getting instantaneous power consumption data .");
    }
#line 3124
    return (-1);
  } else
#line 3125
  if ((int )iDRAC_FLAG == 2) {
#line 3125
    if ((int )rsp->ccode == 111) {
      {
#line 3127
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 3129
      return (-1);
    } else {
#line 3125
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3130
  if ((int )rsp->ccode == 193) {
    {
#line 3131
    lprintf(3, "Error getting instantaneous power consumption data: Command not supported on this system.");
    }
#line 3133
    return (-1);
  } else
#line 3130
  if ((int )rsp->ccode == 203) {
    {
#line 3131
    lprintf(3, "Error getting instantaneous power consumption data: Command not supported on this system.");
    }
#line 3133
    return (-1);
  } else
#line 3134
  if ((int )rsp->ccode != 0) {
    {
#line 3135
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3135
    lprintf(3, "Error getting instantaneous power consumption data: %s", tmp);
    }
#line 3137
    return (-1);
  }
#line 3139
  *instpowerconsumptiondata = *((IPMI_INST_POWER_CONSUMPTION_DATA *)(rsp->data));
#line 3145
  return (0);
}
}
#line 3156 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void ipmi_print_get_instan_power_Amps_data(IPMI_INST_POWER_CONSUMPTION_DATA instpowerconsumptiondata ) 
{ 
  uint16_t intampsval ;
  uint16_t decimalampsval ;

  {
#line 3159
  intampsval = (uint16_t )0;
#line 3160
  decimalampsval = (uint16_t )0;
#line 3161
  if ((int )instpowerconsumptiondata.instanApms > 0) {
#line 3162
    decimalampsval = (uint16_t )((int )instpowerconsumptiondata.instanApms % 10);
#line 3163
    intampsval = (uint16_t )((int )instpowerconsumptiondata.instanApms / 10);
  }
  {
#line 3165
  printf((char const   */* __restrict  */)"\nAmperage value: %d.%d A \n", (int )intampsval,
         (int )decimalampsval);
  }
#line 3166
  return;
}
}
#line 3177 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_print_get_power_consmpt_data(struct ipmi_intf *intf , uint8_t unit ) 
{ 
  int rc ;
  IPMI_INST_POWER_CONSUMPTION_DATA instpowerconsumptiondata ;

  {
  {
#line 3180
  rc = 0;
#line 3181
  instpowerconsumptiondata.instanpowerconsumption = (uint16_t )0;
#line 3181
  instpowerconsumptiondata.instanApms = (uint16_t )0;
#line 3181
  instpowerconsumptiondata.resv1 = (uint16_t )0;
#line 3181
  instpowerconsumptiondata.resv = (uint8_t )0;
#line 3182
  printf((char const   */* __restrict  */)"\nPower consumption information\n");
#line 3183
  rc = ipmi_get_power_consumption_data(intf, unit);
  }
#line 3184
  if (rc == -1) {
#line 3185
    return (rc);
  }
  {
#line 3187
  rc = ipmi_get_instan_power_consmpt_data(intf, & instpowerconsumptiondata);
  }
#line 3188
  if (rc == -1) {
#line 3189
    return (rc);
  }
  {
#line 3191
  ipmi_print_get_instan_power_Amps_data(instpowerconsumptiondata);
#line 3192
  rc = ipmi_get_power_headroom_command(intf, unit);
  }
#line 3193
  if (rc == -1) {
#line 3194
    return (rc);
  }
#line 3196
  return (rc);
}
}
#line 3207 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_get_avgpower_consmpt_history(struct ipmi_intf *intf , IPMI_AVGPOWER_CONSUMP_HISTORY *pavgpower ) 
{ 
  int rc ;
  uint8_t *rdata ;
  char const   *tmp ;

  {
  {
#line 3213
  rc = ipmi_mc_getsysinfo(intf, 235, 0, 0, (int )sizeof(*pavgpower), (void *)pavgpower);
  }
#line 3214
  if (rc < 0) {
    {
#line 3215
    lprintf(3, "Error getting average power consumption history data.");
    }
#line 3217
    return (-1);
  } else
#line 3218
  if ((int )iDRAC_FLAG == 2) {
#line 3218
    if (rc == 111) {
      {
#line 3219
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 3221
      return (-1);
    } else {
#line 3218
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3222
  if (rc == 193) {
    {
#line 3223
    lprintf(3, "Error getting average power consumption history data: Command not supported on this system.");
    }
#line 3225
    return (-1);
  } else
#line 3222
  if (rc == 203) {
    {
#line 3223
    lprintf(3, "Error getting average power consumption history data: Command not supported on this system.");
    }
#line 3225
    return (-1);
  } else
#line 3226
  if (rc != 0) {
    {
#line 3227
    tmp = val2str((uint16_t )rc, completion_code_vals);
#line 3227
    lprintf(3, "Error getting average power consumption history data: %s", tmp);
    }
#line 3230
    return (-1);
  }
#line 3232
  if (verbose > 1) {
    {
#line 3233
    rdata = (uint8_t *)((void *)pavgpower);
#line 3234
    printf((char const   */* __restrict  */)"Average power consumption history data       :%x %x %x %x %x %x %x\n\n",
           (int )*(rdata + 0), (int )*(rdata + 1), (int )*(rdata + 2), (int )*(rdata + 3),
           (int )*(rdata + 4), (int )*(rdata + 5), (int )*(rdata + 6), (int )*(rdata + 7));
    }
  }
#line 3245
  return (0);
}
}
#line 3256 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_get_peakpower_consmpt_history(struct ipmi_intf *intf , IPMI_POWER_CONSUMP_HISTORY *pstPeakpower ) 
{ 
  uint8_t *rdata ;
  int rc ;
  char const   *tmp ;

  {
  {
#line 3262
  rc = ipmi_mc_getsysinfo(intf, 236, 0, 0, (int )sizeof(*pstPeakpower), (void *)pstPeakpower);
  }
#line 3264
  if (rc < 0) {
    {
#line 3265
    lprintf(3, "Error getting  peak power consumption history data.");
    }
#line 3266
    return (-1);
  } else
#line 3267
  if ((int )iDRAC_FLAG == 2) {
#line 3267
    if (rc == 111) {
      {
#line 3268
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 3270
      return (-1);
    } else {
#line 3267
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3271
  if (rc == 193) {
    {
#line 3272
    lprintf(3, "Error getting peak power consumption history data: Command not supported on this system.");
    }
#line 3274
    return (-1);
  } else
#line 3271
  if (rc == 203) {
    {
#line 3272
    lprintf(3, "Error getting peak power consumption history data: Command not supported on this system.");
    }
#line 3274
    return (-1);
  } else
#line 3275
  if (rc != 0) {
    {
#line 3276
    tmp = val2str((uint16_t )rc, completion_code_vals);
#line 3276
    lprintf(3, "Error getting peak power consumption history data: %s", tmp);
    }
#line 3278
    return (-1);
  }
#line 3280
  if (verbose > 1) {
    {
#line 3281
    rdata = (uint8_t *)((void *)pstPeakpower);
#line 3282
    printf((char const   */* __restrict  */)"Peak power consmhistory  Data               : %x %x %x %x %x %x %x %x %x %x\n   %x %x %x %x %x %x %x %x %x %x %x %x %x\n\n",
           (int )*(rdata + 0), (int )*(rdata + 1), (int )*(rdata + 2), (int )*(rdata + 3),
           (int )*(rdata + 4), (int )*(rdata + 5), (int )*(rdata + 6), (int )*(rdata + 7),
           (int )*(rdata + 8), (int )*(rdata + 9), (int )*(rdata + 10), (int )*(rdata + 11),
           (int )*(rdata + 12), (int )*(rdata + 13), (int )*(rdata + 14), (int )*(rdata + 15),
           (int )*(rdata + 16), (int )*(rdata + 17), (int )*(rdata + 18), (int )*(rdata + 19),
           (int )*(rdata + 20), (int )*(rdata + 21), (int )*(rdata + 22), (int )*(rdata + 23));
    }
  }
#line 3302
  return (0);
}
}
#line 3313 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_get_minpower_consmpt_history(struct ipmi_intf *intf , IPMI_POWER_CONSUMP_HISTORY *pstMinpower ) 
{ 
  uint8_t *rdata ;
  int rc ;
  char const   *tmp ;

  {
  {
#line 3319
  rc = ipmi_mc_getsysinfo(intf, 237, 0, 0, (int )sizeof(*pstMinpower), (void *)pstMinpower);
  }
#line 3321
  if (rc < 0) {
    {
#line 3322
    lprintf(3, "Error getting  peak power consumption history data .");
    }
#line 3323
    return (-1);
  } else
#line 3324
  if ((int )iDRAC_FLAG == 2) {
#line 3324
    if (rc == 111) {
      {
#line 3325
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 3327
      return (-1);
    } else {
#line 3324
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3328
  if (rc == 193) {
    {
#line 3329
    lprintf(3, "Error getting peak power consumption history data: Command not supported on this system.");
    }
#line 3331
    return (-1);
  } else
#line 3328
  if (rc == 203) {
    {
#line 3329
    lprintf(3, "Error getting peak power consumption history data: Command not supported on this system.");
    }
#line 3331
    return (-1);
  } else
#line 3332
  if (rc != 0) {
    {
#line 3333
    tmp = val2str((uint16_t )rc, completion_code_vals);
#line 3333
    lprintf(3, "Error getting peak power consumption history data: %s", tmp);
    }
#line 3335
    return (-1);
  }
#line 3337
  if (verbose > 1) {
    {
#line 3338
    rdata = (uint8_t *)((void *)pstMinpower);
#line 3339
    printf((char const   */* __restrict  */)"Peak power consmhistory  Data               : %x %x %x %x %x %x %x %x %x %x\n   %x %x %x %x %x %x %x %x %x %x %x %x %x\n\n",
           (int )*(rdata + 0), (int )*(rdata + 1), (int )*(rdata + 2), (int )*(rdata + 3),
           (int )*(rdata + 4), (int )*(rdata + 5), (int )*(rdata + 6), (int )*(rdata + 7),
           (int )*(rdata + 8), (int )*(rdata + 9), (int )*(rdata + 10), (int )*(rdata + 11),
           (int )*(rdata + 12), (int )*(rdata + 13), (int )*(rdata + 14), (int )*(rdata + 15),
           (int )*(rdata + 16), (int )*(rdata + 17), (int )*(rdata + 18), (int )*(rdata + 19),
           (int )*(rdata + 20), (int )*(rdata + 21), (int )*(rdata + 22), (int )*(rdata + 23));
    }
  }
#line 3359
  return (0);
}
}
#line 3371 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_print_power_consmpt_history(struct ipmi_intf *intf , int unit ) 
{ 
  char timestr[30] ;
  uint32_t lastminutepeakpower ;
  uint32_t lasthourpeakpower ;
  uint32_t lastdaypeakpower ;
  uint32_t lastweekpeakpower ;
  uint64_t tempbtuphrconv ;
  int rc ;
  IPMI_AVGPOWER_CONSUMP_HISTORY avgpower ;
  IPMI_POWER_CONSUMP_HISTORY stMinpower ;
  IPMI_POWER_CONSUMP_HISTORY stPeakpower ;

  {
  {
#line 3380
  rc = 0;
#line 3386
  rc = ipmi_get_avgpower_consmpt_history(intf, & avgpower);
  }
#line 3387
  if (rc == -1) {
#line 3388
    return (rc);
  }
  {
#line 3391
  rc = ipmi_get_peakpower_consmpt_history(intf, & stPeakpower);
  }
#line 3392
  if (rc == -1) {
#line 3393
    return (rc);
  }
  {
#line 3396
  rc = ipmi_get_minpower_consmpt_history(intf, & stMinpower);
  }
#line 3397
  if (rc == -1) {
#line 3398
    return (rc);
  }
#line 3400
  if (rc != 0) {
#line 3401
    return (rc);
  }
  {
#line 3403
  printf((char const   */* __restrict  */)"Power Consumption History\n\n");
#line 3406
  printf((char const   */* __restrict  */)"Statistic                   Last Minute     Last Hour     Last Day     Last Week\n\n");
  }
#line 3408
  if (unit == 1) {
    {
#line 3409
    printf((char const   */* __restrict  */)"Average Power Consumption  ");
#line 3410
    tempbtuphrconv = watt_to_btuphr_conversion((uint32_t )avgpower.lastminutepower);
#line 3411
    printf((char const   */* __restrict  */)"%4lld BTU/hr     ", tempbtuphrconv);
#line 3412
    tempbtuphrconv = watt_to_btuphr_conversion((uint32_t )avgpower.lasthourpower);
#line 3413
    printf((char const   */* __restrict  */)"%4lld BTU/hr   ", tempbtuphrconv);
#line 3414
    tempbtuphrconv = watt_to_btuphr_conversion((uint32_t )avgpower.lastdaypower);
#line 3415
    printf((char const   */* __restrict  */)"%4lld BTU/hr  ", tempbtuphrconv);
#line 3416
    tempbtuphrconv = watt_to_btuphr_conversion((uint32_t )avgpower.lastweakpower);
#line 3417
    printf((char const   */* __restrict  */)"%4lld BTU/hr\n", tempbtuphrconv);
#line 3419
    printf((char const   */* __restrict  */)"Max Power Consumption      ");
#line 3420
    tempbtuphrconv = watt_to_btuphr_conversion((uint32_t )stPeakpower.lastminutepower);
#line 3421
    printf((char const   */* __restrict  */)"%4lld BTU/hr     ", tempbtuphrconv);
#line 3422
    tempbtuphrconv = watt_to_btuphr_conversion((uint32_t )stPeakpower.lasthourpower);
#line 3423
    printf((char const   */* __restrict  */)"%4lld BTU/hr   ", tempbtuphrconv);
#line 3424
    tempbtuphrconv = watt_to_btuphr_conversion((uint32_t )stPeakpower.lastdaypower);
#line 3425
    printf((char const   */* __restrict  */)"%4lld BTU/hr  ", tempbtuphrconv);
#line 3426
    tempbtuphrconv = watt_to_btuphr_conversion((uint32_t )stPeakpower.lastweakpower);
#line 3427
    printf((char const   */* __restrict  */)"%4lld BTU/hr\n", tempbtuphrconv);
#line 3429
    printf((char const   */* __restrict  */)"Min Power Consumption      ");
#line 3430
    tempbtuphrconv = watt_to_btuphr_conversion((uint32_t )stMinpower.lastminutepower);
#line 3431
    printf((char const   */* __restrict  */)"%4lld BTU/hr     ", tempbtuphrconv);
#line 3432
    tempbtuphrconv = watt_to_btuphr_conversion((uint32_t )stMinpower.lasthourpower);
#line 3433
    printf((char const   */* __restrict  */)"%4lld BTU/hr   ", tempbtuphrconv);
#line 3434
    tempbtuphrconv = watt_to_btuphr_conversion((uint32_t )stMinpower.lastdaypower);
#line 3435
    printf((char const   */* __restrict  */)"%4lld BTU/hr  ", tempbtuphrconv);
#line 3436
    tempbtuphrconv = watt_to_btuphr_conversion((uint32_t )stMinpower.lastweakpower);
#line 3437
    printf((char const   */* __restrict  */)"%4lld BTU/hr\n\n", tempbtuphrconv);
    }
  } else {
    {
#line 3439
    printf((char const   */* __restrict  */)"Average Power Consumption  ");
#line 3440
    tempbtuphrconv = (uint64_t )avgpower.lastminutepower;
#line 3441
    printf((char const   */* __restrict  */)"%4lld W          ", tempbtuphrconv);
#line 3442
    tempbtuphrconv = (uint64_t )avgpower.lasthourpower;
#line 3443
    printf((char const   */* __restrict  */)"%4lld W        ", tempbtuphrconv);
#line 3444
    tempbtuphrconv = (uint64_t )avgpower.lastdaypower;
#line 3445
    printf((char const   */* __restrict  */)"%4lld W       ", tempbtuphrconv);
#line 3446
    tempbtuphrconv = (uint64_t )avgpower.lastweakpower;
#line 3447
    printf((char const   */* __restrict  */)"%4lld W   \n", tempbtuphrconv);
#line 3449
    printf((char const   */* __restrict  */)"Max Power Consumption      ");
#line 3450
    tempbtuphrconv = (uint64_t )stPeakpower.lastminutepower;
#line 3451
    printf((char const   */* __restrict  */)"%4lld W          ", tempbtuphrconv);
#line 3452
    tempbtuphrconv = (uint64_t )stPeakpower.lasthourpower;
#line 3453
    printf((char const   */* __restrict  */)"%4lld W        ", tempbtuphrconv);
#line 3454
    tempbtuphrconv = (uint64_t )stPeakpower.lastdaypower;
#line 3455
    printf((char const   */* __restrict  */)"%4lld W       ", tempbtuphrconv);
#line 3456
    tempbtuphrconv = (uint64_t )stPeakpower.lastweakpower;
#line 3457
    printf((char const   */* __restrict  */)"%4lld W   \n", tempbtuphrconv);
#line 3459
    printf((char const   */* __restrict  */)"Min Power Consumption      ");
#line 3460
    tempbtuphrconv = (uint64_t )stMinpower.lastminutepower;
#line 3461
    printf((char const   */* __restrict  */)"%4lld W          ", tempbtuphrconv);
#line 3462
    tempbtuphrconv = (uint64_t )stMinpower.lasthourpower;
#line 3463
    printf((char const   */* __restrict  */)"%4lld W        ", tempbtuphrconv);
#line 3464
    tempbtuphrconv = (uint64_t )stMinpower.lastdaypower;
#line 3465
    printf((char const   */* __restrict  */)"%4lld W       ", tempbtuphrconv);
#line 3466
    tempbtuphrconv = (uint64_t )stMinpower.lastweakpower;
#line 3467
    printf((char const   */* __restrict  */)"%4lld W   \n\n", tempbtuphrconv);
    }
  }
  {
#line 3470
  lastminutepeakpower = stPeakpower.lastminutepowertime;
#line 3471
  lasthourpeakpower = stPeakpower.lasthourpowertime;
#line 3472
  lastdaypeakpower = stPeakpower.lastdaypowertime;
#line 3473
  lastweekpeakpower = stPeakpower.lastweekpowertime;
#line 3475
  printf((char const   */* __restrict  */)"Max Power Time\n");
#line 3476
  ipmi_time_to_str((time_t )lastminutepeakpower, timestr);
#line 3477
  printf((char const   */* __restrict  */)"Last Minute     : %s", timestr);
#line 3478
  ipmi_time_to_str((time_t )lasthourpeakpower, timestr);
#line 3479
  printf((char const   */* __restrict  */)"Last Hour       : %s", timestr);
#line 3480
  ipmi_time_to_str((time_t )lastdaypeakpower, timestr);
#line 3481
  printf((char const   */* __restrict  */)"Last Day        : %s", timestr);
#line 3482
  ipmi_time_to_str((time_t )lastweekpeakpower, timestr);
#line 3483
  printf((char const   */* __restrict  */)"Last Week       : %s", timestr);
#line 3485
  lastminutepeakpower = stMinpower.lastminutepowertime;
#line 3486
  lasthourpeakpower = stMinpower.lasthourpowertime;
#line 3487
  lastdaypeakpower = stMinpower.lastdaypowertime;
#line 3488
  lastweekpeakpower = stMinpower.lastweekpowertime;
#line 3490
  printf((char const   */* __restrict  */)"Min Power Time\n");
#line 3491
  ipmi_time_to_str((time_t )lastminutepeakpower, timestr);
#line 3492
  printf((char const   */* __restrict  */)"Last Minute     : %s", timestr);
#line 3493
  ipmi_time_to_str((time_t )lasthourpeakpower, timestr);
#line 3494
  printf((char const   */* __restrict  */)"Last Hour       : %s", timestr);
#line 3495
  ipmi_time_to_str((time_t )lastdaypeakpower, timestr);
#line 3496
  printf((char const   */* __restrict  */)"Last Day        : %s", timestr);
#line 3497
  ipmi_time_to_str((time_t )lastweekpeakpower, timestr);
#line 3498
  printf((char const   */* __restrict  */)"Last Week       : %s", timestr);
  }
#line 3499
  return (rc);
}
}
#line 3510 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_get_power_cap(struct ipmi_intf *intf , IPMI_POWER_CAP *ipmipowercap ) 
{ 
  uint8_t *rdata ;
  int rc ;
  char const   *tmp ;

  {
  {
#line 3516
  rc = ipmi_mc_getsysinfo(intf, 234, 0, 0, (int )sizeof(*ipmipowercap), (void *)ipmipowercap);
  }
#line 3518
  if (rc < 0) {
    {
#line 3519
    lprintf(3, "Error getting power cap.");
    }
#line 3520
    return (-1);
  } else
#line 3521
  if ((int )iDRAC_FLAG == 2) {
#line 3521
    if (rc == 111) {
      {
#line 3522
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 3524
      return (-1);
    } else {
#line 3521
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3525
  if (rc == 193) {
    {
#line 3526
    lprintf(3, "Error getting power cap: Command not supported on this system.");
    }
#line 3528
    return (-1);
  } else
#line 3525
  if (rc == 203) {
    {
#line 3526
    lprintf(3, "Error getting power cap: Command not supported on this system.");
    }
#line 3528
    return (-1);
  } else
#line 3529
  if (rc != 0) {
    {
#line 3530
    tmp = val2str((uint16_t )rc, completion_code_vals);
#line 3530
    lprintf(3, "Error getting power cap: %s", tmp);
    }
#line 3532
    return (-1);
  }
#line 3534
  if (verbose > 1) {
    {
#line 3535
    rdata = (uint8_t *)((void *)ipmipowercap);
#line 3536
    printf((char const   */* __restrict  */)"power cap  Data               :%x %x %x %x %x %x %x %x %x %x ",
           (int )*(rdata + 1), (int )*(rdata + 2), (int )*(rdata + 3), (int )*(rdata + 4),
           (int )*(rdata + 5), (int )*(rdata + 6), (int )*(rdata + 7), (int )*(rdata + 8),
           (int )*(rdata + 9), (int )*(rdata + 10), (int )*(rdata + 11));
    }
  }
#line 3550
  return (0);
}
}
#line 3561 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_print_power_cap(struct ipmi_intf *intf , uint8_t unit ) 
{ 
  uint64_t tempbtuphrconv ;
  int rc ;
  IPMI_POWER_CAP ipmipowercap ;

  {
  {
#line 3567
  memset((void *)(& ipmipowercap), 0, sizeof(ipmipowercap));
#line 3568
  rc = ipmi_get_power_cap(intf, & ipmipowercap);
  }
#line 3569
  if (rc == 0) {
#line 3570
    if ((int )unit == 1) {
      {
#line 3571
      tempbtuphrconv = watt_to_btuphr_conversion((uint32_t )ipmipowercap.MaximumPowerConsmp);
#line 3572
      printf((char const   */* __restrict  */)"Maximum power: %lld  BTU/hr\n", tempbtuphrconv);
#line 3573
      tempbtuphrconv = watt_to_btuphr_conversion((uint32_t )ipmipowercap.MinimumPowerConsmp);
#line 3574
      printf((char const   */* __restrict  */)"Minimum power: %lld  BTU/hr\n", tempbtuphrconv);
#line 3575
      tempbtuphrconv = watt_to_btuphr_conversion((uint32_t )ipmipowercap.PowerCap);
#line 3576
      printf((char const   */* __restrict  */)"Power cap    : %lld  BTU/hr\n", tempbtuphrconv);
      }
    } else {
      {
#line 3578
      printf((char const   */* __restrict  */)"Maximum power: %d Watt\n", (int )ipmipowercap.MaximumPowerConsmp);
#line 3579
      printf((char const   */* __restrict  */)"Minimum power: %d Watt\n", (int )ipmipowercap.MinimumPowerConsmp);
#line 3580
      printf((char const   */* __restrict  */)"Power cap    : %d Watt\n", (int )ipmipowercap.PowerCap);
      }
    }
  }
#line 3583
  return (rc);
}
}
#line 3595 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_set_power_cap(struct ipmi_intf *intf , int unit , int val ) 
{ 
  int rc ;
  uint8_t data[13] ;
  uint8_t *rdata ;
  uint16_t powercapval ;
  uint64_t maxpowerbtuphr ;
  uint64_t maxpowerbtuphr1 ;
  uint64_t minpowerbtuphr ;
  IPMI_POWER_CAP ipmipowercap ;
  int tmp ;
  char const   *tmp___0 ;
  uint32_t tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 3606
  tmp = ipmi_get_power_capstatus_command(intf);
  }
#line 3606
  if (tmp < 0) {
#line 3607
    return (-1);
  }
#line 3609
  if ((int )PowercapSetable_flag != 1) {
    {
#line 3610
    lprintf(3, "Can not set powercap on this system");
    }
#line 3611
    return (-1);
  } else
#line 3612
  if ((int )PowercapstatusFlag != 1) {
    {
#line 3613
    lprintf(3, "Power cap set feature is not enabled");
    }
#line 3614
    return (-1);
  }
  {
#line 3616
  rc = ipmi_mc_getsysinfo(intf, 234, 0, 0, (int )sizeof(ipmipowercap), (void *)(& ipmipowercap));
  }
#line 3618
  if (rc < 0) {
    {
#line 3619
    lprintf(3, "Error getting power cap.");
    }
#line 3620
    return (-1);
  } else
#line 3621
  if ((int )iDRAC_FLAG == 2) {
#line 3621
    if (rc == 111) {
      {
#line 3622
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 3624
      return (-1);
    } else {
#line 3621
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3625
  if (rc == 193) {
    {
#line 3626
    lprintf(3, "Error getting power cap, command not supported on this system.");
    }
#line 3628
    return (-1);
  } else
#line 3629
  if (rc != 0) {
    {
#line 3630
    tmp___0 = val2str((uint16_t )rc, completion_code_vals);
#line 3630
    lprintf(3, "Error getting power cap: %s", tmp___0);
    }
#line 3632
    return (-1);
  }
#line 3634
  if (verbose > 1) {
    {
#line 3635
    rdata = (uint8_t *)((void *)(& ipmipowercap));
#line 3636
    printf((char const   */* __restrict  */)"power cap  Data               :%x %x %x %x %x %x %x %x %x %x ",
           (int )*(rdata + 1), (int )*(rdata + 2), (int )*(rdata + 3), (int )*(rdata + 4),
           (int )*(rdata + 5), (int )*(rdata + 6), (int )*(rdata + 7), (int )*(rdata + 8),
           (int )*(rdata + 9), (int )*(rdata + 10), (int )*(rdata + 11));
    }
  }
  {
#line 3648
  memset((void *)(data), 0, (size_t )13);
#line 3649
  data[0] = (uint8_t )234;
#line 3650
  powercapval = (uint16_t )val;
#line 3651
  data[1] = (uint8_t )((int )powercapval & 255);
#line 3652
  data[2] = (uint8_t )(((int )powercapval & 65280) >> 8);
#line 3653
  data[3] = (uint8_t )unit;
#line 3654
  data[4] = (uint8_t )((int )ipmipowercap.MaximumPowerConsmp & 255);
#line 3655
  data[5] = (uint8_t )(((int )ipmipowercap.MaximumPowerConsmp & 65280) >> 8);
#line 3656
  data[6] = (uint8_t )((int )ipmipowercap.MinimumPowerConsmp & 255);
#line 3657
  data[7] = (uint8_t )(((int )ipmipowercap.MinimumPowerConsmp & 65280) >> 8);
#line 3658
  data[8] = (uint8_t )ipmipowercap.totalnumpowersupp;
#line 3659
  data[9] = (uint8_t )((int )ipmipowercap.AvailablePower & 255);
#line 3660
  data[10] = (uint8_t )(((int )ipmipowercap.AvailablePower & 65280) >> 8);
#line 3661
  data[11] = (uint8_t )ipmipowercap.SystemThrottling;
#line 3662
  data[12] = (uint8_t )0;
  }
#line 3664
  if (unit == 1) {
    {
#line 3665
    tmp___1 = btuphr_to_watt_conversion((uint64_t )val);
#line 3665
    val = (int )tmp___1;
    }
  } else
#line 3666
  if (unit == 3) {
#line 3667
    if (val < 0) {
      {
#line 3668
      lprintf(3, "Cap value is out of boundary conditon it should be between 0  - 100");
      }
#line 3670
      return (-1);
    } else
#line 3667
    if (val > 100) {
      {
#line 3668
      lprintf(3, "Cap value is out of boundary conditon it should be between 0  - 100");
      }
#line 3670
      return (-1);
    }
    {
#line 3672
    val = (val * ((int )ipmipowercap.MaximumPowerConsmp - (int )ipmipowercap.MinimumPowerConsmp)) / 100 + (int )ipmipowercap.MinimumPowerConsmp;
#line 3675
    lprintf(3, "Cap value in percentage is  %d ", val);
#line 3676
    data[1] = (uint8_t )(val & 255);
#line 3677
    data[2] = (uint8_t )((val & 65280) >> 8);
#line 3678
    data[3] = (uint8_t )0;
    }
  }
#line 3680
  if (val < (int )ipmipowercap.MinimumPowerConsmp) {
#line 3680
    goto _L___2;
  } else
#line 3680
  if (val > (int )ipmipowercap.MaximumPowerConsmp) {
    _L___2: /* CIL Label */ 
#line 3680
    if (unit == 0) {
      {
#line 3682
      lprintf(3, "Cap value is out of boundary conditon it should be between %d  - %d",
              (int )ipmipowercap.MinimumPowerConsmp, (int )ipmipowercap.MaximumPowerConsmp);
      }
#line 3685
      return (-1);
    } else {
#line 3680
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 3686
  if (val < (int )ipmipowercap.MinimumPowerConsmp) {
#line 3686
    goto _L___0;
  } else
#line 3686
  if (val > (int )ipmipowercap.MaximumPowerConsmp) {
    _L___0: /* CIL Label */ 
#line 3686
    if (unit == 1) {
      {
#line 3688
      minpowerbtuphr = watt_to_btuphr_conversion((uint32_t )ipmipowercap.MinimumPowerConsmp);
#line 3689
      maxpowerbtuphr = watt_to_btuphr_conversion((uint32_t )ipmipowercap.MaximumPowerConsmp);
#line 3690
      maxpowerbtuphr1 = watt_to_btuphr_conversion((uint32_t )ipmipowercap.MaximumPowerConsmp);
#line 3691
      lprintf(3, "Cap value is out of boundary conditon it should be between %d",
              minpowerbtuphr);
#line 3694
      lprintf(3, " -%d", maxpowerbtuphr1);
      }
#line 3695
      return (-1);
    }
  }
  {
#line 3697
  rc = ipmi_mc_setsysinfo(intf, 13, (void *)(data));
  }
#line 3698
  if (rc < 0) {
    {
#line 3699
    lprintf(3, "Error setting power cap");
    }
#line 3700
    return (-1);
  } else
#line 3701
  if ((int )iDRAC_FLAG == 2) {
#line 3701
    if (rc == 111) {
      {
#line 3702
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 3704
      return (-1);
    } else {
#line 3701
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 3705
  if (rc > 0) {
    {
#line 3706
    tmp___2 = val2str((uint16_t )rc, completion_code_vals);
#line 3706
    lprintf(3, "Error setting power cap: %s", tmp___2);
    }
#line 3708
    return (-1);
  }
#line 3710
  if (verbose > 1) {
    {
#line 3711
    printf((char const   */* __restrict  */)"CC for setpowercap :%d ", rc);
    }
  }
#line 3713
  return (0);
}
}
#line 3724 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void ipmi_powermonitor_usage(void) 
{ 


  {
  {
#line 3727
  lprintf(5, "");
#line 3729
  lprintf(5, "   powermonitor");
#line 3731
  lprintf(5, "      Shows power tracking statistics ");
#line 3733
  lprintf(5, "");
#line 3735
  lprintf(5, "   powermonitor clear cumulativepower");
#line 3737
  lprintf(5, "      Reset cumulative power reading");
#line 3739
  lprintf(5, "");
#line 3741
  lprintf(5, "   powermonitor clear peakpower");
#line 3743
  lprintf(5, "      Reset peak power reading");
#line 3745
  lprintf(5, "");
#line 3747
  lprintf(5, "   powermonitor powerconsumption");
#line 3749
  lprintf(5, "      Displays power consumption in <watt|btuphr>");
#line 3751
  lprintf(5, "");
#line 3753
  lprintf(5, "   powermonitor powerconsumptionhistory <watt|btuphr>");
#line 3755
  lprintf(5, "      Displays power consumption history ");
#line 3757
  lprintf(5, "");
#line 3759
  lprintf(5, "   powermonitor getpowerbudget");
#line 3761
  lprintf(5, "      Displays power cap in <watt|btuphr>");
#line 3763
  lprintf(5, "");
#line 3765
  lprintf(5, "   powermonitor setpowerbudget <val><watt|btuphr|percent>");
#line 3767
  lprintf(5, "      Allows user to set the  power cap in <watt|BTU/hr|percentage>");
#line 3769
  lprintf(5, "");
#line 3771
  lprintf(5, "   powermonitor enablepowercap ");
#line 3773
  lprintf(5, "      To enable set power cap");
#line 3775
  lprintf(5, "");
#line 3777
  lprintf(5, "   powermonitor disablepowercap ");
#line 3779
  lprintf(5, "      To disable set power cap");
#line 3781
  lprintf(5, "");
  }
#line 3783
  return;
}
}
#line 3796 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_delloem_vFlash_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int rc ;

  {
  {
#line 3799
  rc = 0;
#line 3800
  current_arg ++;
#line 3801
  rc = ipmi_delloem_vFlash_process(intf, current_arg, argv);
  }
#line 3802
  return (rc);
}
}
#line 3816 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static char un_str___2[32]  ;
#line 3813 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
char const   *get_vFlash_compcode_str(uint8_t vflashcompcode , struct vFlashstr  const  *vs ) 
{ 
  int i ;

  {
#line 3818
  i = 0;
  {
#line 3818
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3818
    if (! ((unsigned long )(vs + i)->str != (unsigned long )((void *)0))) {
#line 3818
      goto while_break;
    }
#line 3819
    if ((int const   )(vs + i)->val == (int const   )vflashcompcode) {
#line 3820
      return ((char const   *)(vs + i)->str);
    }
#line 3818
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3822
  memset((void *)(un_str___2), 0, (size_t )32);
#line 3823
  snprintf((char */* __restrict  */)(un_str___2), (size_t )32, (char const   */* __restrict  */)"Unknown (0x%02X)",
           (int )vflashcompcode);
  }
#line 3824
  return ((char const   *)(un_str___2));
}
}
#line 3834 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_get_sd_card_info(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[2] ;
  uint8_t input_length ;
  uint8_t cardstatus ;
  IPMI_DELL_SDCARD_INFO *sdcardinfoblock ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 3839
  input_length = (uint8_t )0;
#line 3840
  cardstatus = (uint8_t )0;
#line 3843
  input_length = (uint8_t )2;
#line 3844
  msg_data[1] = (uint8_t )0;
#line 3844
  msg_data[0] = msg_data[1];
#line 3845
  req.msg.netfn = (uint8_t )48;
#line 3846
  req.msg.lun = (uint8_t )0;
#line 3847
  req.msg.cmd = (uint8_t )164;
#line 3848
  req.msg.data = msg_data;
#line 3849
  req.msg.data_len = (uint16_t )input_length;
#line 3851
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 3852
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 3853
    lprintf(3, "Error in getting SD Card Extended Information");
    }
#line 3854
    return (-1);
  } else
#line 3855
  if ((int )rsp->ccode > 0) {
    {
#line 3856
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3856
    lprintf(3, "Error in getting SD Card Extended Information (%s)", tmp);
    }
#line 3858
    return (-1);
  }
#line 3861
  sdcardinfoblock = (IPMI_DELL_SDCARD_INFO *)((void *)(rsp->data));
#line 3863
  if ((int )iDRAC_FLAG == 2) {
#line 3863
    if ((int )sdcardinfoblock->vflashcompcode == 51) {
      {
#line 3865
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 3867
      return (-1);
    } else {
#line 3863
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3868
  if ((int )sdcardinfoblock->vflashcompcode != 0) {
    {
#line 3869
    tmp___0 = get_vFlash_compcode_str(sdcardinfoblock->vflashcompcode, vFlash_completion_code_vals);
#line 3869
    lprintf(3, "Error in getting SD Card Extended Information (%s)", tmp___0);
    }
#line 3872
    return (-1);
  }
#line 3875
  if (! ((int )sdcardinfoblock->sdcardstatus & 4)) {
    {
#line 3876
    lprintf(3, "vFlash SD card is unavailable, please insert the card of");
#line 3878
    lprintf(3, "size 256MB or greater");
    }
#line 3880
    return (-1);
  }
  {
#line 3883
  printf((char const   */* __restrict  */)"vFlash SD Card Properties\n");
#line 3884
  printf((char const   */* __restrict  */)"SD Card size       : %8dMB\n", sdcardinfoblock->sdcardsize);
#line 3885
  printf((char const   */* __restrict  */)"Available size     : %8dMB\n", sdcardinfoblock->sdcardavailsize);
  }
#line 3886
  if ((int )sdcardinfoblock->sdcardstatus & 128) {
#line 3886
    tmp___1 = "Yes";
  } else {
#line 3886
    tmp___1 = "No";
  }
  {
#line 3886
  printf((char const   */* __restrict  */)"Initialized        : %10s\n", tmp___1);
  }
#line 3888
  if ((int )sdcardinfoblock->sdcardstatus & 64) {
#line 3888
    tmp___2 = "Yes";
  } else {
#line 3888
    tmp___2 = "No";
  }
  {
#line 3888
  printf((char const   */* __restrict  */)"Licensed           : %10s\n", tmp___2);
  }
#line 3890
  if ((int )sdcardinfoblock->sdcardstatus & 32) {
#line 3890
    tmp___3 = "Yes";
  } else {
#line 3890
    tmp___3 = "No";
  }
  {
#line 3890
  printf((char const   */* __restrict  */)"Attached           : %10s\n", tmp___3);
  }
#line 3892
  if ((int )sdcardinfoblock->sdcardstatus & 16) {
#line 3892
    tmp___4 = "Yes";
  } else {
#line 3892
    tmp___4 = "No";
  }
  {
#line 3892
  printf((char const   */* __restrict  */)"Enabled            : %10s\n", tmp___4);
  }
#line 3894
  if ((int )sdcardinfoblock->sdcardstatus & 8) {
#line 3894
    tmp___5 = "Yes";
  } else {
#line 3894
    tmp___5 = "No";
  }
  {
#line 3894
  printf((char const   */* __restrict  */)"Write Protected    : %10s\n", tmp___5);
#line 3896
  cardstatus = (uint8_t )((int )sdcardinfoblock->sdcardstatus & 3);
  }
#line 3897
  if (0 == (int )cardstatus) {
#line 3897
    tmp___8 = "OK";
  } else {
#line 3897
    if ((int )cardstatus == 3) {
#line 3897
      tmp___7 = "Undefined";
    } else {
#line 3897
      if ((int )cardstatus == 2) {
#line 3897
        tmp___6 = "Critical";
      } else {
#line 3897
        tmp___6 = "Warning";
      }
#line 3897
      tmp___7 = tmp___6;
    }
#line 3897
    tmp___8 = tmp___7;
  }
  {
#line 3897
  printf((char const   */* __restrict  */)"Health             : %10s\n", tmp___8);
#line 3901
  printf((char const   */* __restrict  */)"Bootable partition : %10d\n", (int )sdcardinfoblock->bootpartion);
  }
#line 3902
  return (0);
}
}
#line 3912 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_delloem_vFlash_process(struct ipmi_intf *intf , int current_arg___1 ,
                                       char **argv ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 3916
  tmp = strncmp((char const   *)(intf->name), "wmi\000", (size_t )4);
  }
#line 3916
  if (tmp) {
    {
#line 3916
    tmp___0 = strncmp((char const   *)(intf->name), "open\000", (size_t )5);
    }
#line 3916
    if (tmp___0) {
      {
#line 3917
      lprintf(3, "vFlash support is enabled only for wmi and open interface.");
#line 3919
      lprintf(3, "Its not enabled for lan and lanplus interface.");
      }
#line 3920
      return (-1);
    }
  }
#line 3923
  if ((unsigned long )*(argv + current_arg___1) == (unsigned long )((void *)0)) {
    {
#line 3924
    ipmi_vFlash_usage();
    }
#line 3925
    return (0);
  } else {
    {
#line 3923
    tmp___1 = strcmp((char const   *)*(argv + current_arg___1), "help");
    }
#line 3923
    if (tmp___1 == 0) {
      {
#line 3924
      ipmi_vFlash_usage();
      }
#line 3925
      return (0);
    }
  }
  {
#line 3927
  ipmi_idracvalidator_command(intf);
#line 3928
  tmp___3 = strncmp((char const   *)*(argv + current_arg___1), "info\000", (size_t )5);
  }
#line 3928
  if (tmp___3) {
    {
#line 3948
    ipmi_vFlash_usage();
    }
#line 3949
    return (-1);
  } else {
#line 3929
    current_arg___1 ++;
#line 3930
    if ((unsigned long )*(argv + current_arg___1) == (unsigned long )((void *)0)) {
      {
#line 3931
      ipmi_vFlash_usage();
      }
#line 3932
      return (-1);
    } else {
      {
#line 3933
      tmp___2 = strncmp((char const   *)*(argv + current_arg___1), "Card\000", (size_t )5);
      }
#line 3933
      if (tmp___2 == 0) {
#line 3934
        current_arg___1 ++;
#line 3935
        if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
          {
#line 3936
          ipmi_vFlash_usage();
          }
#line 3937
          return (-1);
        }
        {
#line 3939
        rc = ipmi_get_sd_card_info(intf);
        }
#line 3940
        return (rc);
      } else {
        {
#line 3943
        ipmi_vFlash_usage();
        }
#line 3944
        return (-1);
      }
    }
  }
}
}
#line 3960 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void ipmi_vFlash_usage(void) 
{ 


  {
  {
#line 3963
  lprintf(5, "");
#line 3965
  lprintf(5, "   vFlash info Card");
#line 3967
  lprintf(5, "      Shows Extended SD Card information");
#line 3969
  lprintf(5, "");
  }
#line 3971
  return;
}
}
#line 3981 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void ipmi_setled_usage(void) 
{ 


  {
  {
#line 3984
  lprintf(5, "");
#line 3986
  lprintf(5, "   setled <b:d.f> <state..>");
#line 3988
  lprintf(5, "      Set backplane LED state");
#line 3990
  lprintf(5, "      b:d.f = PCI Bus:Device.Function of drive (lspci format)");
#line 3992
  lprintf(5, "      state = present|online|hotspare|identify|rebuilding|");
#line 3994
  lprintf(5, "              fault|predict|critical|failed");
#line 3996
  lprintf(5, "");
  }
#line 3998
  return;
}
}
#line 4000 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int IsSetLEDSupported(void) 
{ 


  {
#line 4003
  return ((int )SetLEDSupported);
}
}
#line 4006 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void CheckSetLEDSupport(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t data[10] ;

  {
  {
#line 4009
  rsp = (struct ipmi_rs *)((void *)0);
#line 4010
  req.msg.netfn = (uint8_t )0;
#line 4010
  req.msg.lun = (unsigned char)0;
#line 4010
  req.msg.cmd = (unsigned char)0;
#line 4010
  req.msg.target_cmd = (unsigned char)0;
#line 4010
  req.msg.data_len = (unsigned short)0;
#line 4010
  req.msg.data = (uint8_t *)0;
#line 4013
  SetLEDSupported = (uint8_t )0;
#line 4014
  req.msg.netfn = (uint8_t )48;
#line 4015
  req.msg.lun = (uint8_t )0;
#line 4016
  req.msg.cmd = (uint8_t )213;
#line 4017
  req.msg.data_len = (uint16_t )10;
#line 4018
  req.msg.data = data;
#line 4020
  memset((void *)(data), 0, sizeof(data));
#line 4021
  data[0] = (uint8_t )1;
#line 4022
  data[1] = (uint8_t )0;
#line 4023
  data[2] = (uint8_t )8;
#line 4024
  data[3] = (uint8_t )0;
#line 4025
  data[4] = (uint8_t )0;
#line 4026
  data[5] = (uint8_t )0;
#line 4027
  data[6] = (uint8_t )0;
#line 4028
  data[7] = (uint8_t )0;
#line 4029
  data[8] = (uint8_t )0;
#line 4030
  data[9] = (uint8_t )0;
#line 4032
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 4033
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
#line 4034
    return;
  } else
#line 4033
  if ((int )rsp->ccode != 0) {
#line 4034
    return;
  }
#line 4036
  SetLEDSupported = (uint8_t )1;
#line 4037
  return;
}
}
#line 4050 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_getdrivemap(struct ipmi_intf *intf , int b , int d , int f , int *bay ,
                            int *slot ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t data[8] ;
  char const   *tmp ;

  {
  {
#line 4054
  rsp = (struct ipmi_rs *)((void *)0);
#line 4055
  req.msg.netfn = (uint8_t )0;
#line 4055
  req.msg.lun = (unsigned char)0;
#line 4055
  req.msg.cmd = (unsigned char)0;
#line 4055
  req.msg.target_cmd = (unsigned char)0;
#line 4055
  req.msg.data_len = (unsigned short)0;
#line 4055
  req.msg.data = (uint8_t *)0;
#line 4058
  req.msg.netfn = (uint8_t )48;
#line 4059
  req.msg.lun = (uint8_t )0;
#line 4060
  req.msg.cmd = (uint8_t )213;
#line 4061
  req.msg.data_len = (uint16_t )8;
#line 4062
  req.msg.data = data;
#line 4064
  memset((void *)(data), 0, sizeof(data));
#line 4065
  data[0] = (uint8_t )1;
#line 4066
  data[1] = (uint8_t )7;
#line 4067
  data[2] = (uint8_t )6;
#line 4068
  data[3] = (uint8_t )0;
#line 4069
  data[4] = (uint8_t )0;
#line 4070
  data[5] = (uint8_t )0;
#line 4071
  data[6] = (uint8_t )b;
#line 4072
  data[7] = (uint8_t )((d << 3) + f);
#line 4074
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 4075
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 4076
    lprintf(3, "Error issuing getdrivemap command.");
    }
#line 4077
    return (-1);
  } else
#line 4078
  if ((int )rsp->ccode != 0) {
    {
#line 4079
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 4079
    lprintf(3, "Error issuing getdrivemap command: %s", tmp);
    }
#line 4081
    return (-1);
  }
#line 4083
  *bay = (int )rsp->data[7];
#line 4084
  *slot = (int )rsp->data[8];
#line 4085
  if (*bay == 255) {
    {
#line 4086
    lprintf(3, "Error could not get drive bay:slot mapping");
    }
#line 4087
    return (-1);
  } else
#line 4085
  if (*slot == 255) {
    {
#line 4086
    lprintf(3, "Error could not get drive bay:slot mapping");
    }
#line 4087
    return (-1);
  }
#line 4089
  return (0);
}
}
#line 4102 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_setled_state(struct ipmi_intf *intf , int bayId , int slotId , int state ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t data[20] ;
  char const   *tmp ;

  {
  {
#line 4105
  rsp = (struct ipmi_rs *)((void *)0);
#line 4106
  req.msg.netfn = (uint8_t )0;
#line 4106
  req.msg.lun = (unsigned char)0;
#line 4106
  req.msg.cmd = (unsigned char)0;
#line 4106
  req.msg.target_cmd = (unsigned char)0;
#line 4106
  req.msg.data_len = (unsigned short)0;
#line 4106
  req.msg.data = (uint8_t *)0;
#line 4109
  req.msg.netfn = (uint8_t )48;
#line 4110
  req.msg.lun = (uint8_t )0;
#line 4111
  req.msg.cmd = (uint8_t )213;
#line 4112
  req.msg.data_len = (uint16_t )20;
#line 4113
  req.msg.data = data;
#line 4115
  memset((void *)(data), 0, sizeof(data));
#line 4116
  data[0] = (uint8_t )0;
#line 4117
  data[1] = (uint8_t )4;
#line 4118
  data[2] = (uint8_t )14;
#line 4119
  data[3] = (uint8_t )0;
#line 4120
  data[4] = (uint8_t )0;
#line 4121
  data[5] = (uint8_t )0;
#line 4122
  data[6] = (uint8_t )14;
#line 4123
  data[7] = (uint8_t )0;
#line 4124
  data[8] = (uint8_t )bayId;
#line 4125
  data[9] = (uint8_t )slotId;
#line 4126
  data[10] = (uint8_t )(state & 255);
#line 4127
  data[11] = (uint8_t )(state >> 8);
#line 4129
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 4130
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 4131
    lprintf(3, "Error issuing setled command.");
    }
#line 4132
    return (-1);
  } else
#line 4133
  if ((int )rsp->ccode != 0) {
    {
#line 4134
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 4134
    lprintf(3, "Error issuing setled command: %s", tmp);
    }
#line 4136
    return (-1);
  }
#line 4138
  return (0);
}
}
#line 4146 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_getsesmask(int argc , char **argv ) 
{ 
  int mask ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 4149
  mask = 0;
  {
#line 4150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4150
    if (! (current_arg < argc)) {
#line 4150
      goto while_break;
    }
    {
#line 4151
    tmp = strcmp((char const   *)*(argv + current_arg), "present");
    }
#line 4151
    if (! tmp) {
#line 4152
      mask = (int )((long )mask | 1L);
    }
    {
#line 4153
    tmp___0 = strcmp((char const   *)*(argv + current_arg), "online");
    }
#line 4153
    if (! tmp___0) {
#line 4154
      mask = (int )((long )mask | (1L << 1));
    }
    {
#line 4155
    tmp___1 = strcmp((char const   *)*(argv + current_arg), "hotspare");
    }
#line 4155
    if (! tmp___1) {
#line 4156
      mask = (int )((long )mask | (1L << 2));
    }
    {
#line 4157
    tmp___2 = strcmp((char const   *)*(argv + current_arg), "identify");
    }
#line 4157
    if (! tmp___2) {
#line 4158
      mask = (int )((long )mask | (1L << 3));
    }
    {
#line 4159
    tmp___3 = strcmp((char const   *)*(argv + current_arg), "rebuilding");
    }
#line 4159
    if (! tmp___3) {
#line 4160
      mask = (int )((long )mask | (1L << 4));
    }
    {
#line 4161
    tmp___4 = strcmp((char const   *)*(argv + current_arg), "fault");
    }
#line 4161
    if (! tmp___4) {
#line 4162
      mask = (int )((long )mask | (1L << 5));
    }
    {
#line 4163
    tmp___5 = strcmp((char const   *)*(argv + current_arg), "predict");
    }
#line 4163
    if (! tmp___5) {
#line 4164
      mask = (int )((long )mask | (1L << 6));
    }
    {
#line 4165
    tmp___6 = strcmp((char const   *)*(argv + current_arg), "critical");
    }
#line 4165
    if (! tmp___6) {
#line 4166
      mask = (int )((long )mask | (1L << 9));
    }
    {
#line 4167
    tmp___7 = strcmp((char const   *)*(argv + current_arg), "failed");
    }
#line 4167
    if (! tmp___7) {
#line 4168
      mask = (int )((long )mask | (1L << 10));
    }
#line 4169
    current_arg ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4171
  return (mask);
}
}
#line 4185 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_delloem_setled_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int b ;
  int d ;
  int f ;
  int mask ;
  int bayId ;
  int slotId ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 4190
  bayId = 255;
#line 4191
  slotId = 255;
#line 4192
  current_arg ++;
#line 4193
  if (argc < current_arg) {
    {
#line 4194
    usage();
    }
#line 4195
    return (-1);
  }
#line 4198
  if (argc == 1) {
    {
#line 4199
    ipmi_setled_usage();
    }
#line 4200
    return (0);
  } else {
    {
#line 4198
    tmp = strcmp((char const   *)*(argv + current_arg), "help");
    }
#line 4198
    if (tmp == 0) {
      {
#line 4199
      ipmi_setled_usage();
      }
#line 4200
      return (0);
    }
  }
  {
#line 4202
  CheckSetLEDSupport(intf);
#line 4203
  tmp___2 = IsSetLEDSupported();
  }
#line 4203
  if (tmp___2) {
    {
#line 4206
    tmp___1 = sscanf((char const   */* __restrict  */)*(argv + current_arg), (char const   */* __restrict  */)"%*x:%x:%x.%x",
                     & b, & d, & f);
    }
#line 4206
    if (tmp___1 == 3) {
      {
#line 4208
      current_arg ++;
#line 4209
      ipmi_getdrivemap(intf, b, d, f, & bayId, & slotId);
      }
    } else {
      {
#line 4210
      tmp___0 = sscanf((char const   */* __restrict  */)*(argv + current_arg), (char const   */* __restrict  */)"%x:%x.%x",
                       & b, & d, & f);
      }
#line 4210
      if (tmp___0 == 3) {
#line 4212
        current_arg ++;
      } else {
        {
#line 4214
        ipmi_setled_usage();
        }
#line 4215
        return (-1);
      }
    }
  } else {
    {
#line 4204
    lprintf(3, "\'setled\' is not supported on this system.");
    }
#line 4205
    return (-1);
  }
  {
#line 4218
  mask = ipmi_getsesmask(argc, argv);
#line 4220
  tmp___3 = ipmi_getdrivemap(intf, b, d, f, & bayId, & slotId);
  }
#line 4220
  if (tmp___3) {
#line 4221
    return (-1);
  }
  {
#line 4224
  tmp___4 = ipmi_setled_state(intf, bayId, slotId, mask);
  }
#line 4224
  return (tmp___4);
}
}
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 431 "/usr/include/stdio.h"
extern int scanf(char const   * __restrict  __format  , ...)  __asm__("__isoc99_scanf")  ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 191 "../include/ipmitool/ipmi_fru.h"
static char const   *combined_voltage_desc[4]  __attribute__((__unused__))  = {      "12 V",      "-12 V",      "5 V",      "3.3 V"};
#line 587 "../include/ipmitool/ipmi_fru.h"
static unsigned long const   secs_from_1970_1996  =    (uint64_t const   )820454400;
#line 588 "../include/ipmitool/ipmi_fru.h"
static char const   *chassis_type_desc[30]  __attribute__((__unused__))  = 
#line 588
  {      "Unspecified",      "Other",      "Unknown",      "Desktop", 
        "Low Profile Desktop",      "Pizza Box",      "Mini Tower",      "Tower", 
        "Portable",      "LapTop",      "Notebook",      "Hand Held", 
        "Docking Station",      "All in One",      "Sub Notebook",      "Space-saving", 
        "Lunch Box",      "Main Server Chassis",      "Expansion Chassis",      "SubChassis", 
        "Bus Expansion Chassis",      "Peripheral Chassis",      "RAID Chassis",      "Rack Mount Chassis", 
        "Sealed-case PC",      "Multi-system Chassis",      "CompactPCI",      "AdvancedTCA", 
        "Blade",      "Blade Enclosure"};
#line 601
int ipmi_fru_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 602
int ipmi_fru_print(struct ipmi_intf *intf , struct sdr_record_fru_locator *fru ) ;
#line 243 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 65 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static void ipmi_fru_read_to_bin(struct ipmi_intf *intf , char *pFileName , uint8_t fruId ) ;
#line 66
static void ipmi_fru_write_from_bin(struct ipmi_intf *intf , char *pFileName , uint8_t fruId ) ;
#line 67
static int ipmi_fru_upg_ekeying(struct ipmi_intf *intf , char *pFileName , uint8_t fruId ) ;
#line 68
static int ipmi_fru_get_multirec_location_from_fru(struct ipmi_intf *intf , uint8_t fruId ,
                                                   struct fru_info *pFruInfo , uint32_t *pRetLocation ,
                                                   uint32_t *pRetSize ) ;
#line 71
static int ipmi_fru_get_multirec_from_file(char *pFileName , uint8_t *pBufArea , uint32_t size ,
                                           uint32_t offset ) ;
#line 73
static int ipmi_fru_get_multirec_size_from_file(char *pFileName , uint32_t *pSize ,
                                                uint32_t *pOffset ) ;
#line 74
int ipmi_fru_get_adjust_size_from_buffer(uint8_t *fru_data , uint32_t *pSize ) ;
#line 75
static void ipmi_fru_picmg_ext_print(uint8_t *fru_data , int off , int length ) ;
#line 77
static int ipmi_fru_set_field_string(struct ipmi_intf *intf , unsigned char fruId ,
                                     uint8_t f_type , uint8_t f_index , char *f_string ) ;
#line 79
static int ipmi_fru_set_field_string_rebuild(struct ipmi_intf *intf , uint8_t fruId ,
                                             struct fru_info fru , struct fru_header header ,
                                             uint8_t f_type , uint8_t f_index , char *f_string ) ;
#line 87
int read_fru_area(struct ipmi_intf *intf , struct fru_info *fru , uint8_t id , uint32_t offset ,
                  uint32_t length , uint8_t *frubuf ) ;
#line 100
char *get_fru_area_str(uint8_t *data , uint32_t *offset ) ;
#line 100 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static char const   bcd_plus[17]  = 
#line 100
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )' ',      (char const   )'-', 
        (char const   )'.',      (char const   )':',      (char const   )',',      (char const   )'_', 
        (char const   )'\000'};
#line 98 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
char *get_fru_area_str(uint8_t *data , uint32_t *offset ) 
{ 
  char *str___1 ;
  int len ;
  int off ;
  int size ;
  int i ;
  int j ;
  int k ;
  int typecode ;
  union __anonunion_u_82 u ;
  int tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 108
  size = 0;
#line 109
  off = (int )*offset;
#line 112
  typecode = ((int )*(data + off) & 192) >> 6;
#line 116
  tmp = off;
#line 116
  off ++;
#line 116
  len = (int )*(data + tmp);
#line 117
  len &= 63;
  {
#line 120
  if (typecode == 0) {
#line 120
    goto case_0;
  }
#line 124
  if (typecode == 2) {
#line 124
    goto case_2;
  }
#line 129
  if (typecode == 1) {
#line 129
    goto case_1;
  }
#line 129
  if (typecode == 3) {
#line 129
    goto case_1;
  }
#line 119
  goto switch_break;
  case_0: /* CIL Label */ 
#line 122
  size = len * 2;
#line 123
  goto switch_break;
  case_2: /* CIL Label */ 
#line 126
  size = ((len + 2) * 4) / 3 & -4;
#line 127
  goto switch_break;
  case_1: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 131
  size = len;
#line 132
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 135
  if (size < 1) {
#line 136
    *offset = (uint32_t )off;
#line 137
    return ((char *)((void *)0));
  }
  {
#line 139
  tmp___0 = malloc((size_t )(size + 1));
#line 139
  str___1 = (char *)tmp___0;
  }
#line 140
  if ((unsigned long )str___1 == (unsigned long )((void *)0)) {
#line 141
    return ((char *)((void *)0));
  }
  {
#line 142
  memset((void *)str___1, 0, (size_t )(size + 1));
  }
#line 144
  if (len == 0) {
#line 145
    *(str___1 + 0) = (char )'\000';
#line 146
    *offset = (uint32_t )off;
#line 147
    return (str___1);
  }
  {
#line 151
  if (typecode == 0) {
#line 151
    goto case_0___0;
  }
#line 155
  if (typecode == 1) {
#line 155
    goto case_1___0;
  }
#line 161
  if (typecode == 2) {
#line 161
    goto case_2___0;
  }
#line 182
  if (typecode == 3) {
#line 182
    goto case_3___0;
  }
#line 150
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
  {
#line 152
  tmp___1 = buf2str(data + off, len);
#line 152
  strncpy((char */* __restrict  */)str___1, (char const   */* __restrict  */)tmp___1,
          (size_t )(len * 2));
  }
#line 153
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 156
  k = 0;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (k < len)) {
#line 156
      goto while_break;
    }
#line 157
    *(str___1 + k) = (char )bcd_plus[(int )*(data + (off + k)) & 15];
#line 156
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  *(str___1 + k) = (char )'\000';
#line 159
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 162
  j = 0;
#line 162
  i = j;
  {
#line 162
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 162
    if (! (i < len)) {
#line 162
      goto while_break___0;
    }
#line 163
    u.bits = (uint32_t )0;
#line 164
    if (len - i < 3) {
#line 164
      k = len - i;
    } else {
#line 164
      k = 3;
    }
    {
#line 171
    memcpy((void */* __restrict  */)((void *)(& u.bits)), (void const   */* __restrict  */)(data + (off + i)),
           (size_t )k);
#line 174
    k = 0;
    }
    {
#line 174
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 174
      if (! (k < 4)) {
#line 174
        goto while_break___1;
      }
#line 175
      tmp___2 = j;
#line 175
      j ++;
#line 175
      *(str___1 + tmp___2) = (char )(((int )u.chars[0] & 63) + 32);
#line 176
      u.bits >>= 6;
#line 174
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 162
    i += 3;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 179
  *(str___1 + j) = (char )'\000';
#line 180
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 183
  memcpy((void */* __restrict  */)str___1, (void const   */* __restrict  */)(data + off),
         (size_t )len);
#line 184
  *(str___1 + len) = (char )'\000';
  }
#line 185
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 188
  off += len;
#line 189
  *offset = (uint32_t )off;
#line 191
  return (str___1);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
int is_valid_filename(char const   *input_filename ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 206
  if ((unsigned long )input_filename == (unsigned long )((void *)0)) {
    {
#line 207
    lprintf(3, "ERROR: NULL pointer passed.");
    }
#line 208
    return (-1);
  }
  {
#line 211
  tmp = strlen(input_filename);
  }
#line 211
  if (tmp < 1UL) {
    {
#line 212
    lprintf(3, "File/path is invalid.");
    }
#line 213
    return (-2);
  }
  {
#line 216
  tmp___0 = strlen(input_filename);
  }
#line 216
  if (tmp___0 >= 512UL) {
    {
#line 217
    lprintf(3, "File/path must be shorter than 512 bytes.");
    }
#line 218
    return (-3);
  }
#line 221
  return (0);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
t_ipmi_fru_bloc *build_fru_bloc(struct ipmi_intf *intf , struct fru_info *fru , uint8_t id ,
                                uint16_t *ptr_number_bloc ) 
{ 
  t_ipmi_fru_bloc *p_bloc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct fru_header header ;
  uint8_t *fru_data ;
  uint8_t msg_data[4] ;
  uint16_t num_bloc ;
  uint16_t bloc_count ;
  char const   *tmp ;
  uint32_t i ;
  struct fru_multirec_header *h ;
  uint32_t last_off ;
  uint32_t len ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  uint32_t i___0 ;
  struct fru_multirec_header *h___0 ;
  unsigned short counter ;

  {
  {
#line 253
  fru_data = (uint8_t *)((void *)0);
#line 258
  *ptr_number_bloc = (uint16_t )0;
#line 261
  memset((void *)(& header), 0, sizeof(struct fru_header ));
#line 266
  msg_data[0] = id;
#line 267
  msg_data[1] = (uint8_t )0;
#line 268
  msg_data[2] = (uint8_t )0;
#line 269
  msg_data[3] = (uint8_t )8;
#line 271
  memset((void *)(& req), 0, sizeof(req));
#line 272
  req.msg.netfn = (uint8_t )10;
#line 273
  req.msg.cmd = (uint8_t )17;
#line 274
  req.msg.data = msg_data;
#line 275
  req.msg.data_len = (uint16_t )4;
#line 278
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 279
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 280
    lprintf(3, " Device not present (No Response)\n");
    }
#line 281
    return ((t_ipmi_fru_bloc *)((void *)0));
  }
#line 283
  if ((int )rsp->ccode > 0) {
    {
#line 284
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 284
    lprintf(3, " Device not present (%s)\n", tmp);
    }
#line 286
    return ((t_ipmi_fru_bloc *)((void *)0));
  }
#line 289
  if (verbose > 1) {
    {
#line 290
    printbuf((uint8_t const   *)(rsp->data), rsp->data_len, "FRU DATA");
    }
  }
  {
#line 292
  memcpy((void */* __restrict  */)(& header), (void const   */* __restrict  */)(rsp->data + 1),
         (size_t )8);
  }
#line 294
  if ((int )header.version != 1) {
    {
#line 295
    lprintf(3, " Unknown FRU header version 0x%02x", (int )header.version);
    }
#line 297
    return ((t_ipmi_fru_bloc *)((void *)0));
  }
#line 305
  num_bloc = (uint16_t )1;
#line 307
  if (header.offset.internal) {
#line 308
    num_bloc = (uint16_t )((int )num_bloc + 1);
  }
#line 310
  if (header.offset.chassis) {
#line 311
    num_bloc = (uint16_t )((int )num_bloc + 1);
  }
#line 313
  if (header.offset.board) {
#line 314
    num_bloc = (uint16_t )((int )num_bloc + 1);
  }
#line 316
  if (header.offset.product) {
#line 317
    num_bloc = (uint16_t )((int )num_bloc + 1);
  }
#line 320
  if (header.offset.multi) {
    {
#line 327
    last_off = (uint32_t )((int )header.offset.multi * 8);
#line 327
    i = last_off;
#line 330
    tmp___0 = malloc((size_t )((int )fru->size + 1));
#line 330
    fru_data = (uint8_t *)tmp___0;
    }
#line 331
    if ((unsigned long )fru_data == (unsigned long )((void *)0)) {
      {
#line 332
      lprintf(3, " Out of memory!");
      }
#line 333
      return ((t_ipmi_fru_bloc *)((void *)0));
    }
    {
#line 336
    memset((void *)fru_data, 0, (size_t )((int )fru->size + 1));
    }
    {
#line 338
    while (1) {
      while_continue: /* CIL Label */ ;
#line 339
      h = (struct fru_multirec_header *)(fru_data + i);
#line 342
      if ((unsigned long )last_off < (unsigned long )i + sizeof(*h)) {
#line 342
        goto _L;
      } else
#line 342
      if (last_off < i + (uint32_t )h->len) {
        _L: /* CIL Label */ 
#line 344
        len = (uint32_t )fru->size - last_off;
#line 345
        if ((unsigned long )len > 255UL + sizeof(struct fru_multirec_header )) {
#line 346
          len = (uint32_t )(255UL + sizeof(struct fru_multirec_header ));
        }
        {
#line 348
        tmp___1 = read_fru_area(intf, fru, id, last_off, len, fru_data);
        }
#line 348
        if (tmp___1 < 0) {
#line 349
          goto while_break;
        }
#line 351
        last_off += len;
      }
#line 354
      num_bloc = (uint16_t )((int )num_bloc + 1);
#line 359
      i = (uint32_t )((unsigned long )i + ((unsigned long )h->len + sizeof(struct fru_multirec_header )));
#line 338
      if (! ((int )h->format & 128)) {
#line 338
        if (! (last_off < (uint32_t )fru->size)) {
#line 338
          goto while_break;
        }
      } else {
#line 338
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 362
    lprintf(7, "Multi-Record area ends at: %i (%xh)", i, i);
    }
#line 364
    if ((uint32_t )fru->size > i) {
#line 367
      num_bloc = (uint16_t )((int )num_bloc + 1);
    }
  }
  {
#line 381
  tmp___2 = malloc(sizeof(t_ipmi_fru_bloc ) * (unsigned long )num_bloc);
#line 381
  p_bloc = (t_ipmi_fru_bloc *)tmp___2;
  }
#line 382
  if (! p_bloc) {
    {
#line 384
    lprintf(3, " Unable to get memory to build Fru bloc");
    }
#line 386
    if ((unsigned long )fru_data != (unsigned long )((void *)0)) {
      {
#line 387
      free((void *)fru_data);
#line 388
      fru_data = (uint8_t *)((void *)0);
      }
    }
#line 391
    return ((t_ipmi_fru_bloc *)((void *)0));
  }
  {
#line 395
  bloc_count = (uint16_t )0;
#line 397
  (p_bloc + bloc_count)->start = (uint16_t )0;
#line 398
  (p_bloc + bloc_count)->size = (uint16_t )8;
#line 399
  strcpy((char */* __restrict  */)((char *)((p_bloc + bloc_count)->blocId)), (char const   */* __restrict  */)"Common Header Section");
#line 400
  bloc_count = (uint16_t )((int )bloc_count + 1);
  }
#line 403
  if (header.offset.internal) {
    {
#line 405
    (p_bloc + bloc_count)->start = (uint16_t )((int )header.offset.internal * 8);
#line 406
    (p_bloc + bloc_count)->size = (uint16_t )0;
#line 407
    strcpy((char */* __restrict  */)((char *)((p_bloc + bloc_count)->blocId)), (char const   */* __restrict  */)"Internal Use Section");
#line 408
    bloc_count = (uint16_t )((int )bloc_count + 1);
    }
  }
#line 411
  if (header.offset.chassis) {
    {
#line 413
    (p_bloc + bloc_count)->start = (uint16_t )((int )header.offset.chassis * 8);
#line 414
    (p_bloc + bloc_count)->size = (uint16_t )0;
#line 415
    strcpy((char */* __restrict  */)((char *)((p_bloc + bloc_count)->blocId)), (char const   */* __restrict  */)"Chassis Section");
#line 416
    bloc_count = (uint16_t )((int )bloc_count + 1);
    }
  }
#line 419
  if (header.offset.board) {
    {
#line 421
    (p_bloc + bloc_count)->start = (uint16_t )((int )header.offset.board * 8);
#line 422
    (p_bloc + bloc_count)->size = (uint16_t )0;
#line 423
    strcpy((char */* __restrict  */)((char *)((p_bloc + bloc_count)->blocId)), (char const   */* __restrict  */)"Board Section");
#line 424
    bloc_count = (uint16_t )((int )bloc_count + 1);
    }
  }
#line 427
  if (header.offset.product) {
    {
#line 429
    (p_bloc + bloc_count)->start = (uint16_t )((int )header.offset.product * 8);
#line 430
    (p_bloc + bloc_count)->size = (uint16_t )0;
#line 431
    strcpy((char */* __restrict  */)((char *)((p_bloc + bloc_count)->blocId)), (char const   */* __restrict  */)"Product Section");
#line 432
    bloc_count = (uint16_t )((int )bloc_count + 1);
    }
  }
#line 436
  if (header.offset.multi) {
#line 436
    if (fru_data) {
#line 442
      i___0 = (uint32_t )((int )header.offset.multi * 8);
      {
#line 445
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 446
        h___0 = (struct fru_multirec_header *)(fru_data + i___0);
#line 448
        (p_bloc + bloc_count)->start = (uint16_t )i___0;
#line 449
        (p_bloc + bloc_count)->size = (uint16_t )((unsigned long )h___0->len + sizeof(struct fru_multirec_header ));
#line 450
        sprintf((char */* __restrict  */)((char *)((p_bloc + bloc_count)->blocId)),
                (char const   */* __restrict  */)"Multi-Rec Aread: Type %i", (int )h___0->type);
#line 451
        bloc_count = (uint16_t )((int )bloc_count + 1);
#line 456
        i___0 = (uint32_t )((unsigned long )i___0 + ((unsigned long )h___0->len + sizeof(struct fru_multirec_header )));
        }
#line 445
        if (! ((int )h___0->format & 128)) {
#line 445
          if (! ((int )bloc_count < (int )num_bloc)) {
#line 445
            goto while_break___0;
          }
        } else {
#line 445
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 460
      lprintf(7, "Multi-Record area ends at: %i (%xh)", i___0, i___0);
      }
#line 464
      if ((uint32_t )fru->size > i___0) {
#line 464
        if ((int )bloc_count < (int )num_bloc) {
          {
#line 467
          (p_bloc + bloc_count)->start = (uint16_t )i___0;
#line 468
          (p_bloc + bloc_count)->size = (uint16_t )((uint32_t )fru->size - i___0);
#line 469
          sprintf((char */* __restrict  */)((char *)((p_bloc + bloc_count)->blocId)),
                  (char const   */* __restrict  */)"Unused space");
#line 470
          bloc_count = (uint16_t )((int )bloc_count + 1);
          }
        }
      }
    }
  }
#line 475
  if ((unsigned long )fru_data != (unsigned long )((void *)0)) {
    {
#line 476
    free((void *)fru_data);
#line 477
    fru_data = (uint8_t *)((void *)0);
    }
  }
  {
#line 483
  lprintf(7, "\nNumber Bloc : %i\n", (int )num_bloc);
#line 484
  counter = (unsigned short)0;
  }
  {
#line 484
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 484
    if (! ((int )counter < (int )num_bloc)) {
#line 484
      goto while_break___1;
    }
#line 487
    if ((int )(p_bloc + counter)->size == 0) {
#line 490
      if ((int )counter + 1 < (int )num_bloc) {
#line 492
        (p_bloc + counter)->size = (uint16_t )((int )(p_bloc + ((int )counter + 1))->start - (int )(p_bloc + counter)->start);
      } else {
#line 496
        (p_bloc + counter)->size = (uint16_t )((int )fru->size - (int )(p_bloc + counter)->start);
      }
    }
    {
#line 499
    lprintf(7, "Bloc Numb : %i\n", (int )counter);
#line 500
    lprintf(7, "Bloc Id   : %s\n", (p_bloc + counter)->blocId);
#line 501
    lprintf(7, "Bloc Start: %i\n", (int )(p_bloc + counter)->start);
#line 502
    lprintf(7, "Bloc Size : %i\n", (int )(p_bloc + counter)->size);
#line 503
    lprintf(7, "\n");
#line 484
    counter = (unsigned short )((int )counter + 1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 507
  *ptr_number_bloc = num_bloc;
#line 509
  return (p_bloc);
}
}
#line 521
int write_fru_area(struct ipmi_intf *intf , struct fru_info *fru , uint8_t id , uint16_t soffset ,
                   uint16_t doffset , uint16_t length , uint8_t *pFrubuf ) ;
#line 521 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static uint16_t fru_data_rqst_size  =    (uint16_t )32;
#line 513 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
int write_fru_area(struct ipmi_intf *intf , struct fru_info *fru , uint8_t id , uint16_t soffset ,
                   uint16_t doffset , uint16_t length , uint8_t *pFrubuf ) 
{ 
  uint16_t off ;
  uint16_t tmp ;
  uint16_t finish ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[256] ;
  uint8_t writeLength ;
  uint16_t num_bloc ;
  t_ipmi_fru_bloc *fru_bloc ;
  t_ipmi_fru_bloc *tmp___0 ;
  uint16_t end_bloc ;
  uint8_t protected_bloc ;
  uint16_t found_bloc ;
  uint16_t counter ;

  {
#line 522
  off = (uint16_t )0;
#line 529
  finish = (uint16_t )((int )doffset + (int )length);
#line 530
  if ((int )finish > (int )fru->size) {
    {
#line 532
    lprintf(3, "Return error\n");
    }
#line 533
    return (-1);
  }
  {
#line 536
  tmp___0 = build_fru_bloc(intf, fru, id, & num_bloc);
#line 536
  fru_bloc = tmp___0;
  }
#line 538
  if ((unsigned long )fru_bloc == (unsigned long )((void *)0)) {
    {
#line 539
    lprintf(3, "Failed to build FRU bloc.");
    }
#line 540
    return (-1);
  }
  {
#line 543
  memset((void *)(& req), 0, sizeof(req));
#line 544
  req.msg.netfn = (uint8_t )10;
#line 545
  req.msg.cmd = (uint8_t )18;
#line 546
  req.msg.data = msg_data;
  }
#line 549
  if ((int )fru_data_rqst_size > 16) {
#line 553
    fru_data_rqst_size = (uint16_t )16;
  }
#line 556
  if ((int )intf->channel_buf_size != 0) {
#line 558
    fru_data_rqst_size = (uint16_t )((int )intf->channel_buf_size - 5);
  }
  {
#line 561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 563
    end_bloc = finish;
#line 564
    protected_bloc = (uint8_t )0;
#line 565
    found_bloc = (uint16_t )65535;
#line 568
    if (fru->access) {
#line 568
      tmp = (uint16_t )(((int )doffset + (int )off) >> 1);
    } else {
#line 568
      tmp = (uint16_t )((int )doffset + (int )off);
    }
#line 569
    msg_data[0] = id;
#line 570
    msg_data[1] = (uint8_t )tmp;
#line 571
    msg_data[2] = (uint8_t )((int )tmp >> 8);
#line 576
    counter = (uint16_t )0;
    {
#line 576
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 576
      if (! ((int )counter < (int )num_bloc)) {
#line 576
        goto while_break___0;
      }
#line 578
      if ((int )tmp >= (int )(fru_bloc + counter)->start) {
#line 578
        if ((int )tmp < (int )(fru_bloc + counter)->start + (int )(fru_bloc + counter)->size) {
#line 584
          found_bloc = counter;
#line 585
          end_bloc = (uint16_t )((int )(fru_bloc + counter)->start + (int )(fru_bloc + counter)->size);
#line 586
          counter = num_bloc;
        }
      }
#line 576
      counter = (uint16_t )((int )counter + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 591
    tmp = (uint16_t )((int )end_bloc - ((int )doffset + (int )off));
#line 592
    if ((int )tmp > (int )fru_data_rqst_size) {
      {
#line 593
      memcpy((void */* __restrict  */)(& msg_data[3]), (void const   */* __restrict  */)((pFrubuf + (int )soffset) + (int )off),
             (size_t )fru_data_rqst_size);
#line 594
      req.msg.data_len = (uint16_t )((int )fru_data_rqst_size + 3);
      }
    } else {
      {
#line 597
      memcpy((void */* __restrict  */)(& msg_data[3]), (void const   */* __restrict  */)((pFrubuf + (int )soffset) + (int )off),
             (size_t )((uint8_t )tmp));
#line 598
      req.msg.data_len = (uint16_t )((int )tmp + 3);
      }
    }
#line 600
    if ((int )found_bloc == 0) {
      {
#line 602
      lprintf(6, "Writing %d bytes", (int )req.msg.data_len - 3);
      }
    } else
#line 604
    if ((int )found_bloc != 65535) {
      {
#line 606
      lprintf(6, "Writing %d bytes (Bloc #%i: %s)", (int )req.msg.data_len - 3, (int )found_bloc,
              (fru_bloc + found_bloc)->blocId);
      }
    }
    {
#line 611
    writeLength = (uint8_t )((int )req.msg.data_len - 3);
#line 613
    rsp = (*(intf->sendrecv))(intf, & req);
    }
#line 614
    if (! rsp) {
#line 615
      goto while_break;
    }
#line 618
    if ((int )rsp->ccode == 128) {
#line 620
      protected_bloc = (uint8_t )1;
    } else
#line 622
    if ((int )rsp->ccode == 199) {
#line 622
      goto _L___0;
    } else
#line 622
    if ((int )rsp->ccode == 200) {
#line 622
      goto _L___0;
    } else
#line 622
    if ((int )rsp->ccode == 202) {
      _L___0: /* CIL Label */ 
#line 622
      fru_data_rqst_size = (uint16_t )((int )fru_data_rqst_size - 1);
#line 622
      if ((int )fru_data_rqst_size > 8) {
        {
#line 624
        lprintf(5, "Bad CC -> %x\n", (int )rsp->ccode);
        }
#line 625
        goto while_break;
      } else {
#line 622
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 627
    if ((int )rsp->ccode > 0) {
#line 628
      goto while_break;
    }
#line 630
    if ((int )protected_bloc == 0) {
      {
#line 632
      lprintf(6, "Wrote %d bytes", (int )writeLength);
#line 633
      off = (uint16_t )((int )off + (int )writeLength);
      }
    } else {
#line 637
      if ((int )found_bloc != 65535) {
        {
#line 640
        lprintf(6, "Bloc [%s] protected at offset: %i (size %i bytes)", (fru_bloc + found_bloc)->blocId,
                (int )(fru_bloc + found_bloc)->start, (int )(fru_bloc + found_bloc)->size);
#line 644
        lprintf(6, "Jumping over this bloc");
        }
      } else {
        {
#line 648
        lprintf(6, "Remaining FRU is protected following offset: %i", (int )off);
        }
      }
#line 652
      off = end_bloc;
    }
#line 561
    if (! ((int )doffset + (int )off < (int )finish)) {
#line 561
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 656
  free((void *)fru_bloc);
#line 657
  fru_bloc = (t_ipmi_fru_bloc *)((void *)0);
  }
#line 659
  return ((int )doffset + (int )off >= (int )finish);
}
}
#line 752 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static uint32_t fru_data_rqst_size___0  =    (uint32_t )20;
#line 748 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
int read_fru_area(struct ipmi_intf *intf , struct fru_info *fru , uint8_t id , uint32_t offset ,
                  uint32_t length , uint8_t *frubuf ) 
{ 
  uint32_t off ;
  uint32_t tmp ;
  uint32_t finish ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[4] ;
  char const   *tmp___0 ;

  {
#line 753
  off = offset;
#line 758
  if (offset > (uint32_t )fru->size) {
    {
#line 759
    lprintf(3, "Read FRU Area offset incorrect: %d > %d", offset, (int )fru->size);
    }
#line 761
    return (-1);
  }
#line 764
  finish = offset + length;
#line 765
  if (finish > (uint32_t )fru->size) {
    {
#line 766
    finish = (uint32_t )fru->size;
#line 767
    lprintf(5, "Read FRU Area length %d too large, Adjusting to %d", offset + length,
            finish - offset);
    }
  }
  {
#line 772
  memset((void *)(& req), 0, sizeof(req));
#line 773
  req.msg.netfn = (uint8_t )10;
#line 774
  req.msg.cmd = (uint8_t )17;
#line 775
  req.msg.data = msg_data;
#line 776
  req.msg.data_len = (uint16_t )4;
  }
#line 779
  if (fru_data_rqst_size___0 > 16U) {
#line 783
    fru_data_rqst_size___0 = (uint32_t )16;
  }
#line 787
  if ((int )intf->channel_buf_size != 0) {
#line 789
    fru_data_rqst_size___0 = (uint32_t )((int )intf->channel_buf_size - 9);
  }
  {
#line 793
  while (1) {
    while_continue: /* CIL Label */ ;
#line 794
    if (fru->access) {
#line 794
      tmp = off >> 1;
    } else {
#line 794
      tmp = off;
    }
#line 795
    msg_data[0] = id;
#line 796
    msg_data[1] = (uint8_t )(tmp & 255U);
#line 797
    msg_data[2] = (uint8_t )(tmp >> 8);
#line 798
    tmp = finish - off;
#line 799
    if (tmp > fru_data_rqst_size___0) {
#line 800
      msg_data[3] = (uint8_t )fru_data_rqst_size___0;
    } else {
#line 802
      msg_data[3] = (uint8_t )tmp;
    }
    {
#line 804
    rsp = (*(intf->sendrecv))(intf, & req);
    }
#line 805
    if ((unsigned long )rsp == (unsigned long )((void *)0)) {
      {
#line 806
      lprintf(5, "FRU Read failed");
      }
#line 807
      goto while_break;
    }
#line 809
    if ((int )rsp->ccode > 0) {
#line 812
      if ((int )rsp->ccode == 199) {
#line 812
        goto _L;
      } else
#line 812
      if ((int )rsp->ccode == 200) {
#line 812
        goto _L;
      } else
#line 812
      if ((int )rsp->ccode == 202) {
        _L: /* CIL Label */ 
#line 812
        fru_data_rqst_size___0 --;
#line 812
        if (fru_data_rqst_size___0 > 8U) {
          {
#line 814
          lprintf(6, "Retrying FRU read with request size %d", fru_data_rqst_size___0);
          }
#line 816
          goto __Cont;
        }
      }
      {
#line 818
      tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 818
      lprintf(5, "FRU Read failed: %s", tmp___0);
      }
#line 820
      goto while_break;
    }
#line 823
    if (fru->access) {
#line 823
      tmp = (uint32_t )((int )rsp->data[0] << 1);
    } else {
#line 823
      tmp = (uint32_t )rsp->data[0];
    }
    {
#line 824
    memcpy((void */* __restrict  */)(frubuf + off), (void const   */* __restrict  */)(rsp->data + 1),
           (size_t )tmp);
#line 825
    off += tmp;
    }
#line 830
    if (tmp == 0U) {
#line 830
      if (off < finish) {
#line 831
        return (0);
      }
    }
    __Cont: /* CIL Label */ 
#line 793
    if (! (off < finish)) {
#line 793
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 835
  if (off < finish) {
#line 836
    return (-1);
  }
#line 838
  return (0);
}
}
#line 857
int read_fru_area_section(struct ipmi_intf *intf , struct fru_info *fru , uint8_t id ,
                          uint32_t offset , uint32_t length , uint8_t *frubuf ) ;
#line 857 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static uint32_t fru_data_rqst_size___1  =    (uint32_t )20;
#line 853 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
int read_fru_area_section(struct ipmi_intf *intf , struct fru_info *fru , uint8_t id ,
                          uint32_t offset , uint32_t length , uint8_t *frubuf ) 
{ 
  uint32_t off ;
  uint32_t tmp ;
  uint32_t finish ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[4] ;
  char const   *tmp___0 ;

  {
#line 858
  off = offset;
#line 863
  if (offset > (uint32_t )fru->size) {
    {
#line 864
    lprintf(3, "Read FRU Area offset incorrect: %d > %d", offset, (int )fru->size);
    }
#line 866
    return (-1);
  }
#line 869
  finish = offset + length;
#line 870
  if (finish > (uint32_t )fru->size) {
    {
#line 871
    finish = (uint32_t )fru->size;
#line 872
    lprintf(5, "Read FRU Area length %d too large, Adjusting to %d", offset + length,
            finish - offset);
    }
  }
  {
#line 877
  memset((void *)(& req), 0, sizeof(req));
#line 878
  req.msg.netfn = (uint8_t )10;
#line 879
  req.msg.cmd = (uint8_t )17;
#line 880
  req.msg.data = msg_data;
#line 881
  req.msg.data_len = (uint16_t )4;
  }
#line 884
  if (fru_data_rqst_size___1 > 16U) {
#line 888
    fru_data_rqst_size___1 = (uint32_t )16;
  }
  {
#line 889
  while (1) {
    while_continue: /* CIL Label */ ;
#line 890
    if (fru->access) {
#line 890
      tmp = off >> 1;
    } else {
#line 890
      tmp = off;
    }
#line 891
    msg_data[0] = id;
#line 892
    msg_data[1] = (uint8_t )(tmp & 255U);
#line 893
    msg_data[2] = (uint8_t )(tmp >> 8);
#line 894
    tmp = finish - off;
#line 895
    if (tmp > fru_data_rqst_size___1) {
#line 896
      msg_data[3] = (uint8_t )fru_data_rqst_size___1;
    } else {
#line 898
      msg_data[3] = (uint8_t )tmp;
    }
    {
#line 900
    rsp = (*(intf->sendrecv))(intf, & req);
    }
#line 901
    if ((unsigned long )rsp == (unsigned long )((void *)0)) {
      {
#line 902
      lprintf(5, "FRU Read failed");
      }
#line 903
      goto while_break;
    }
#line 905
    if ((int )rsp->ccode > 0) {
#line 908
      if ((int )rsp->ccode == 199) {
#line 908
        goto _L;
      } else
#line 908
      if ((int )rsp->ccode == 200) {
#line 908
        goto _L;
      } else
#line 908
      if ((int )rsp->ccode == 202) {
        _L: /* CIL Label */ 
#line 908
        fru_data_rqst_size___1 --;
#line 908
        if (fru_data_rqst_size___1 > 8U) {
          {
#line 910
          lprintf(6, "Retrying FRU read with request size %d", fru_data_rqst_size___1);
          }
#line 912
          goto __Cont;
        }
      }
      {
#line 914
      tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 914
      lprintf(5, "FRU Read failed: %s", tmp___0);
      }
#line 916
      goto while_break;
    }
#line 919
    if (fru->access) {
#line 919
      tmp = (uint32_t )((int )rsp->data[0] << 1);
    } else {
#line 919
      tmp = (uint32_t )rsp->data[0];
    }
    {
#line 920
    memcpy((void */* __restrict  */)((frubuf + off) - offset), (void const   */* __restrict  */)(rsp->data + 1),
           (size_t )tmp);
#line 921
    off += tmp;
    }
#line 926
    if (tmp == 0U) {
#line 926
      if (off < finish) {
#line 927
        return (0);
      }
    }
    __Cont: /* CIL Label */ 
#line 889
    if (! (off < finish)) {
#line 889
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 931
  if (off < finish) {
#line 932
    return (-1);
  }
#line 934
  return (0);
}
}
#line 1007 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static void fru_area_print_chassis(struct ipmi_intf *intf , struct fru_info *fru ,
                                   uint8_t id , uint32_t offset ) 
{ 
  char *fru_area ;
  uint8_t *fru_data ;
  uint32_t fru_len ;
  uint32_t area_len ;
  uint32_t i ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int j ;
  size_t tmp___6 ;

  {
  {
#line 1012
  fru_data = (uint8_t *)((void *)0);
#line 1015
  i = offset;
#line 1016
  fru_len = (uint32_t )0;
#line 1018
  tmp = malloc((size_t )((int )fru->size + 1));
#line 1018
  fru_data = (uint8_t *)tmp;
  }
#line 1019
  if ((unsigned long )fru_data == (unsigned long )((void *)0)) {
    {
#line 1020
    lprintf(3, " Out of memory!");
    }
#line 1021
    return;
  }
  {
#line 1023
  memset((void *)fru_data, 0, (size_t )((int )fru->size + 1));
#line 1026
  tmp___0 = read_fru_area(intf, fru, id, i, (uint32_t )2, fru_data);
  }
#line 1026
  if (tmp___0 == 0) {
#line 1027
    fru_len = (uint32_t )(8 * (int )*(fru_data + (i + 1U)));
  }
#line 1028
  if (fru_len <= 0U) {
    {
#line 1029
    free((void *)fru_data);
#line 1030
    fru_data = (uint8_t *)((void *)0);
    }
#line 1031
    return;
  }
  {
#line 1035
  tmp___1 = read_fru_area(intf, fru, id, i, fru_len, fru_data);
  }
#line 1035
  if (tmp___1 < 0) {
    {
#line 1036
    free((void *)fru_data);
#line 1037
    fru_data = (uint8_t *)((void *)0);
    }
#line 1038
    return;
  }
  {
#line 1041
  i ++;
#line 1042
  tmp___2 = i;
#line 1042
  i ++;
#line 1042
  area_len = (uint32_t )((int )*(fru_data + tmp___2) * 8);
#line 1044
  tmp___3 = i;
#line 1044
  i ++;
#line 1044
  printf((char const   */* __restrict  */)" Chassis Type          : %s\n", chassis_type_desc[*(fru_data + tmp___3)]);
#line 1047
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1048
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1049
    tmp___4 = strlen((char const   *)fru_area);
    }
#line 1049
    if (tmp___4 > 0UL) {
      {
#line 1050
      printf((char const   */* __restrict  */)" Chassis Part Number   : %s\n", fru_area);
      }
    }
    {
#line 1052
    free((void *)fru_area);
#line 1053
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1056
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1057
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1058
    tmp___5 = strlen((char const   *)fru_area);
    }
#line 1058
    if (tmp___5 > 0UL) {
      {
#line 1059
      printf((char const   */* __restrict  */)" Chassis Serial        : %s\n", fru_area);
      }
    }
    {
#line 1061
    free((void *)fru_area);
#line 1062
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1066
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1066
    if ((int )*(fru_data + i) != 193) {
#line 1066
      if (! (i < offset + area_len)) {
#line 1066
        goto while_break;
      }
    } else {
#line 1066
      goto while_break;
    }
    {
#line 1068
    j = (int )i;
#line 1069
    fru_area = get_fru_area_str(fru_data, & i);
    }
#line 1070
    if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
      {
#line 1071
      tmp___6 = strlen((char const   *)fru_area);
      }
#line 1071
      if (tmp___6 > 0UL) {
        {
#line 1072
        printf((char const   */* __restrict  */)" Chassis Extra         : %s\n", fru_area);
        }
      }
      {
#line 1074
      free((void *)fru_area);
#line 1075
      fru_area = (char *)((void *)0);
      }
    }
#line 1077
    if (i == (uint32_t )j) {
#line 1078
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1081
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1082
    free((void *)fru_data);
#line 1083
    fru_data = (uint8_t *)((void *)0);
    }
  }
#line 1085
  return;
}
}
#line 1094 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static void fru_area_print_board(struct ipmi_intf *intf , struct fru_info *fru , uint8_t id ,
                                 uint32_t offset ) 
{ 
  char *fru_area ;
  uint8_t *fru_data ;
  uint32_t fru_len ;
  uint32_t area_len ;
  uint32_t i ;
  time_t tval ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  uint32_t tmp___2 ;
  struct tm *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int j ;
  size_t tmp___10 ;

  {
  {
#line 1099
  fru_data = (uint8_t *)((void *)0);
#line 1103
  i = offset;
#line 1104
  fru_len = (uint32_t )0;
#line 1106
  tmp = malloc((size_t )((int )fru->size + 1));
#line 1106
  fru_data = (uint8_t *)tmp;
  }
#line 1107
  if ((unsigned long )fru_data == (unsigned long )((void *)0)) {
    {
#line 1108
    lprintf(3, " Out of memory!");
    }
#line 1109
    return;
  }
  {
#line 1111
  memset((void *)fru_data, 0, (size_t )((int )fru->size + 1));
#line 1114
  tmp___0 = read_fru_area(intf, fru, id, i, (uint32_t )2, fru_data);
  }
#line 1114
  if (tmp___0 == 0) {
#line 1115
    fru_len = (uint32_t )(8 * (int )*(fru_data + (i + 1U)));
  }
#line 1116
  if (fru_len <= 0U) {
    {
#line 1117
    free((void *)fru_data);
#line 1118
    fru_data = (uint8_t *)((void *)0);
    }
#line 1119
    return;
  }
  {
#line 1123
  tmp___1 = read_fru_area(intf, fru, id, i, fru_len, fru_data);
  }
#line 1123
  if (tmp___1 < 0) {
    {
#line 1124
    free((void *)fru_data);
#line 1125
    fru_data = (uint8_t *)((void *)0);
    }
#line 1126
    return;
  }
  {
#line 1129
  i ++;
#line 1130
  tmp___2 = i;
#line 1130
  i ++;
#line 1130
  area_len = (uint32_t )((int )*(fru_data + tmp___2) * 8);
#line 1131
  i ++;
#line 1132
  tval = (time_t )((((int )*(fru_data + (i + 2U)) << 16) + ((int )*(fru_data + (i + 1U)) << 8)) + (int )*(fru_data + i));
#line 1133
  tval *= 60L;
#line 1134
  tval = (time_t )((unsigned long const   )tval + secs_from_1970_1996);
#line 1135
  tmp___3 = localtime((time_t const   *)(& tval));
#line 1135
  tmp___4 = asctime((struct tm  const  *)tmp___3);
#line 1135
  printf((char const   */* __restrict  */)" Board Mfg Date        : %s", tmp___4);
#line 1136
  i += 3U;
#line 1138
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1139
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1140
    tmp___5 = strlen((char const   *)fru_area);
    }
#line 1140
    if (tmp___5 > 0UL) {
      {
#line 1141
      printf((char const   */* __restrict  */)" Board Mfg             : %s\n", fru_area);
      }
    }
    {
#line 1143
    free((void *)fru_area);
#line 1144
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1147
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1148
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1149
    tmp___6 = strlen((char const   *)fru_area);
    }
#line 1149
    if (tmp___6 > 0UL) {
      {
#line 1150
      printf((char const   */* __restrict  */)" Board Product         : %s\n", fru_area);
      }
    }
    {
#line 1152
    free((void *)fru_area);
#line 1153
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1156
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1157
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1158
    tmp___7 = strlen((char const   *)fru_area);
    }
#line 1158
    if (tmp___7 > 0UL) {
      {
#line 1159
      printf((char const   */* __restrict  */)" Board Serial          : %s\n", fru_area);
      }
    }
    {
#line 1161
    free((void *)fru_area);
#line 1162
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1165
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1166
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1167
    tmp___8 = strlen((char const   *)fru_area);
    }
#line 1167
    if (tmp___8 > 0UL) {
      {
#line 1168
      printf((char const   */* __restrict  */)" Board Part Number     : %s\n", fru_area);
      }
    }
    {
#line 1170
    free((void *)fru_area);
#line 1171
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1174
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1175
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1176
    tmp___9 = strlen((char const   *)fru_area);
    }
#line 1176
    if (tmp___9 > 0UL) {
#line 1176
      if (verbose > 0) {
        {
#line 1177
        printf((char const   */* __restrict  */)" Board FRU ID          : %s\n", fru_area);
        }
      }
    }
    {
#line 1179
    free((void *)fru_area);
#line 1180
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1184
    if ((int )*(fru_data + i) != 193) {
#line 1184
      if (! (i < offset + area_len)) {
#line 1184
        goto while_break;
      }
    } else {
#line 1184
      goto while_break;
    }
    {
#line 1186
    j = (int )i;
#line 1187
    fru_area = get_fru_area_str(fru_data, & i);
    }
#line 1188
    if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
      {
#line 1189
      tmp___10 = strlen((char const   *)fru_area);
      }
#line 1189
      if (tmp___10 > 0UL) {
        {
#line 1190
        printf((char const   */* __restrict  */)" Board Extra           : %s\n", fru_area);
        }
      }
      {
#line 1192
      free((void *)fru_area);
#line 1193
      fru_area = (char *)((void *)0);
      }
    }
#line 1195
    if (i == (uint32_t )j) {
#line 1196
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1199
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1200
    free((void *)fru_data);
#line 1201
    fru_data = (uint8_t *)((void *)0);
    }
  }
#line 1203
  return;
}
}
#line 1212 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static void fru_area_print_product(struct ipmi_intf *intf , struct fru_info *fru ,
                                   uint8_t id , uint32_t offset ) 
{ 
  char *fru_area ;
  uint8_t *fru_data ;
  uint32_t fru_len ;
  uint32_t area_len ;
  uint32_t i ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  uint32_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int j ;
  size_t tmp___10 ;

  {
  {
#line 1216
  fru_area = (char *)((void *)0);
#line 1217
  fru_data = (uint8_t *)((void *)0);
#line 1220
  i = offset;
#line 1221
  fru_len = (uint32_t )0;
#line 1223
  tmp = malloc((size_t )((int )fru->size + 1));
#line 1223
  fru_data = (uint8_t *)tmp;
  }
#line 1224
  if ((unsigned long )fru_data == (unsigned long )((void *)0)) {
    {
#line 1225
    lprintf(3, " Out of memory!");
    }
#line 1226
    return;
  }
  {
#line 1228
  memset((void *)fru_data, 0, (size_t )((int )fru->size + 1));
#line 1231
  tmp___0 = read_fru_area(intf, fru, id, i, (uint32_t )2, fru_data);
  }
#line 1231
  if (tmp___0 == 0) {
#line 1232
    fru_len = (uint32_t )(8 * (int )*(fru_data + (i + 1U)));
  }
#line 1233
  if (fru_len <= 0U) {
    {
#line 1234
    free((void *)fru_data);
#line 1235
    fru_data = (uint8_t *)((void *)0);
    }
#line 1236
    return;
  }
  {
#line 1240
  tmp___1 = read_fru_area(intf, fru, id, i, fru_len, fru_data);
  }
#line 1240
  if (tmp___1 < 0) {
    {
#line 1241
    free((void *)fru_data);
#line 1242
    fru_data = (uint8_t *)((void *)0);
    }
#line 1243
    return;
  }
  {
#line 1246
  i ++;
#line 1247
  tmp___2 = i;
#line 1247
  i ++;
#line 1247
  area_len = (uint32_t )((int )*(fru_data + tmp___2) * 8);
#line 1248
  i ++;
#line 1250
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1251
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1252
    tmp___3 = strlen((char const   *)fru_area);
    }
#line 1252
    if (tmp___3 > 0UL) {
      {
#line 1253
      printf((char const   */* __restrict  */)" Product Manufacturer  : %s\n", fru_area);
      }
    }
    {
#line 1255
    free((void *)fru_area);
#line 1256
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1259
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1260
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1261
    tmp___4 = strlen((char const   *)fru_area);
    }
#line 1261
    if (tmp___4 > 0UL) {
      {
#line 1262
      printf((char const   */* __restrict  */)" Product Name          : %s\n", fru_area);
      }
    }
    {
#line 1264
    free((void *)fru_area);
#line 1265
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1268
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1269
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1270
    tmp___5 = strlen((char const   *)fru_area);
    }
#line 1270
    if (tmp___5 > 0UL) {
      {
#line 1271
      printf((char const   */* __restrict  */)" Product Part Number   : %s\n", fru_area);
      }
    }
    {
#line 1273
    free((void *)fru_area);
#line 1274
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1277
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1278
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1279
    tmp___6 = strlen((char const   *)fru_area);
    }
#line 1279
    if (tmp___6 > 0UL) {
      {
#line 1280
      printf((char const   */* __restrict  */)" Product Version       : %s\n", fru_area);
      }
    }
    {
#line 1282
    free((void *)fru_area);
#line 1283
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1286
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1287
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1288
    tmp___7 = strlen((char const   *)fru_area);
    }
#line 1288
    if (tmp___7 > 0UL) {
      {
#line 1289
      printf((char const   */* __restrict  */)" Product Serial        : %s\n", fru_area);
      }
    }
    {
#line 1291
    free((void *)fru_area);
#line 1292
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1295
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1296
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1297
    tmp___8 = strlen((char const   *)fru_area);
    }
#line 1297
    if (tmp___8 > 0UL) {
      {
#line 1298
      printf((char const   */* __restrict  */)" Product Asset Tag     : %s\n", fru_area);
      }
    }
    {
#line 1300
    free((void *)fru_area);
#line 1301
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1304
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1305
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1306
    tmp___9 = strlen((char const   *)fru_area);
    }
#line 1306
    if (tmp___9 > 0UL) {
#line 1306
      if (verbose > 0) {
        {
#line 1307
        printf((char const   */* __restrict  */)" Product FRU ID        : %s\n", fru_area);
        }
      }
    }
    {
#line 1309
    free((void *)fru_area);
#line 1310
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1314
    if ((int )*(fru_data + i) != 193) {
#line 1314
      if (! (i < offset + area_len)) {
#line 1314
        goto while_break;
      }
    } else {
#line 1314
      goto while_break;
    }
    {
#line 1316
    j = (int )i;
#line 1317
    fru_area = get_fru_area_str(fru_data, & i);
    }
#line 1318
    if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
      {
#line 1319
      tmp___10 = strlen((char const   *)fru_area);
      }
#line 1319
      if (tmp___10 > 0UL) {
        {
#line 1320
        printf((char const   */* __restrict  */)" Product Extra         : %s\n", fru_area);
        }
      }
      {
#line 1322
      free((void *)fru_area);
#line 1323
      fru_area = (char *)((void *)0);
      }
    }
#line 1325
    if (i == (uint32_t )j) {
#line 1326
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1329
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1330
    free((void *)fru_data);
#line 1331
    fru_data = (uint8_t *)((void *)0);
    }
  }
#line 1333
  return;
}
}
#line 1342 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static void fru_area_print_multirec(struct ipmi_intf *intf , struct fru_info *fru ,
                                    uint8_t id , uint32_t offset ) 
{ 
  uint8_t *fru_data ;
  uint32_t fru_len ;
  uint32_t i ;
  struct fru_multirec_header *h ;
  struct fru_multirec_powersupply *ps ;
  struct fru_multirec_dcoutput *dc ;
  struct fru_multirec_dcload *dl ;
  uint16_t peak_capacity ;
  uint8_t peak_hold_up_time ;
  uint32_t last_off ;
  uint32_t len ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  struct fru_multirec_oem_header *oh ;
  uint32_t iana ;
  char const   *tmp___10 ;

  {
  {
#line 1356
  last_off = offset;
#line 1356
  i = last_off;
#line 1357
  fru_len = (uint32_t )0;
#line 1359
  tmp = malloc((size_t )((int )fru->size + 1));
#line 1359
  fru_data = (uint8_t *)tmp;
  }
#line 1360
  if ((unsigned long )fru_data == (unsigned long )((void *)0)) {
    {
#line 1361
    lprintf(3, " Out of memory!");
    }
#line 1362
    return;
  }
  {
#line 1364
  memset((void *)fru_data, 0, (size_t )((int )fru->size + 1));
  }
  {
#line 1366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1367
    h = (struct fru_multirec_header *)(fru_data + i);
#line 1370
    if ((unsigned long )last_off < (unsigned long )i + sizeof(*h)) {
#line 1370
      goto _L;
    } else
#line 1370
    if (last_off < i + (uint32_t )h->len) {
      _L: /* CIL Label */ 
#line 1372
      len = (uint32_t )fru->size - last_off;
#line 1373
      if ((unsigned long )len > 255UL + sizeof(struct fru_multirec_header )) {
#line 1374
        len = (uint32_t )(255UL + sizeof(struct fru_multirec_header ));
      }
      {
#line 1376
      tmp___0 = read_fru_area(intf, fru, id, last_off, len, fru_data);
      }
#line 1376
      if (tmp___0 < 0) {
#line 1377
        goto while_break;
      }
#line 1379
      last_off += len;
    }
    {
#line 1384
    if ((int )h->type == 0) {
#line 1384
      goto case_0;
    }
#line 1442
    if ((int )h->type == 1) {
#line 1442
      goto case_1;
    }
#line 1474
    if ((int )h->type == 2) {
#line 1474
      goto case_2;
    }
#line 1503
    if ((int )h->type == 192) {
#line 1503
      goto case_192;
    }
#line 1382
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 1385
    ps = (struct fru_multirec_powersupply *)((fru_data + i) + sizeof(struct fru_multirec_header ));
#line 1398
    peak_hold_up_time = (uint8_t )(((int )ps->peak_cap_ht & 61440) >> 12);
#line 1399
    peak_capacity = (uint16_t )((int )ps->peak_cap_ht & 4095);
#line 1401
    printf((char const   */* __restrict  */)" Power Supply Record\n");
#line 1402
    printf((char const   */* __restrict  */)"  Capacity                   : %d W\n",
           (int )ps->capacity);
#line 1404
    printf((char const   */* __restrict  */)"  Peak VA                    : %d VA\n",
           (int )ps->peak_va);
#line 1406
    printf((char const   */* __restrict  */)"  Inrush Current             : %d A\n",
           (int )ps->inrush_current);
#line 1408
    printf((char const   */* __restrict  */)"  Inrush Interval            : %d ms\n",
           (int )ps->inrush_interval);
#line 1410
    printf((char const   */* __restrict  */)"  Input Voltage Range 1      : %d-%d V\n",
           (int )ps->lowend_input1 / 100, (int )ps->highend_input1 / 100);
#line 1412
    printf((char const   */* __restrict  */)"  Input Voltage Range 2      : %d-%d V\n",
           (int )ps->lowend_input2 / 100, (int )ps->highend_input2 / 100);
#line 1414
    printf((char const   */* __restrict  */)"  Input Frequency Range      : %d-%d Hz\n",
           (int )ps->lowend_freq, (int )ps->highend_freq);
#line 1416
    printf((char const   */* __restrict  */)"  A/C Dropout Tolerance      : %d ms\n",
           (int )ps->dropout_tolerance);
    }
#line 1418
    if (ps->predictive_fail) {
#line 1418
      if (ps->rps_threshold) {
#line 1418
        if (ps->tach) {
#line 1418
          tmp___1 = "\'Two pulses per rotation\'";
        } else {
#line 1418
          tmp___1 = "\'One pulse per rotation\'";
        }
#line 1418
        tmp___3 = tmp___1;
      } else {
#line 1418
        if (ps->tach) {
#line 1418
          tmp___2 = "\'Failure on pin de-assertion\'";
        } else {
#line 1418
          tmp___2 = "\'Failure on pin assertion\'";
        }
#line 1418
        tmp___3 = tmp___2;
      }
#line 1418
      tmp___4 = tmp___3;
    } else {
#line 1418
      tmp___4 = "";
    }
#line 1418
    if (ps->hotswap) {
#line 1418
      tmp___5 = "\'Hot swap\' ";
    } else {
#line 1418
      tmp___5 = "";
    }
#line 1418
    if (ps->autoswitch) {
#line 1418
      tmp___6 = "\'Autoswitch voltage\' ";
    } else {
#line 1418
      tmp___6 = "";
    }
#line 1418
    if (ps->pfc) {
#line 1418
      tmp___7 = "\'Power factor correction\' ";
    } else {
#line 1418
      tmp___7 = "";
    }
#line 1418
    if (ps->predictive_fail) {
#line 1418
      tmp___8 = "\'Predictive fail\' ";
    } else {
#line 1418
      tmp___8 = "";
    }
    {
#line 1418
    printf((char const   */* __restrict  */)"  Flags                      : %s%s%s%s%s\n",
           tmp___8, tmp___7, tmp___6, tmp___5, tmp___4);
#line 1426
    printf((char const   */* __restrict  */)"  Peak capacity              : %d W\n",
           (int )peak_capacity);
#line 1428
    printf((char const   */* __restrict  */)"  Peak capacity holdup       : %d s\n",
           (int )peak_hold_up_time);
    }
#line 1430
    if ((int )ps->combined_capacity == 0) {
      {
#line 1431
      printf((char const   */* __restrict  */)"  Combined capacity          : not specified\n");
      }
    } else {
      {
#line 1433
      printf((char const   */* __restrict  */)"  Combined capacity          : %d W (%s and %s)\n",
             (int )ps->combined_capacity, combined_voltage_desc[ps->combined_voltage1],
             combined_voltage_desc[ps->combined_voltage2]);
      }
    }
#line 1437
    if (ps->predictive_fail) {
      {
#line 1438
      printf((char const   */* __restrict  */)"  Fan lower threshold        : %d RPS\n",
             (int )ps->rps_threshold);
      }
    }
#line 1440
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1443
    dc = (struct fru_multirec_dcoutput *)((fru_data + i) + sizeof(struct fru_multirec_header ));
#line 1455
    printf((char const   */* __restrict  */)" DC Output Record\n");
#line 1456
    printf((char const   */* __restrict  */)"  Output Number              : %d\n",
           (int )dc->output_number);
    }
#line 1458
    if (dc->standby) {
#line 1458
      tmp___9 = "Yes";
    } else {
#line 1458
      tmp___9 = "No";
    }
    {
#line 1458
    printf((char const   */* __restrict  */)"  Standby power              : %s\n",
           tmp___9);
#line 1460
    printf((char const   */* __restrict  */)"  Nominal voltage            : %.2f V\n",
           (double )dc->nominal_voltage / (double )100);
#line 1462
    printf((char const   */* __restrict  */)"  Max negative deviation     : %.2f V\n",
           (double )dc->max_neg_dev / (double )100);
#line 1464
    printf((char const   */* __restrict  */)"  Max positive deviation     : %.2f V\n",
           (double )dc->max_pos_dev / (double )100);
#line 1466
    printf((char const   */* __restrict  */)"  Ripple and noise pk-pk     : %d mV\n",
           (int )dc->ripple_and_noise);
#line 1468
    printf((char const   */* __restrict  */)"  Minimum current draw       : %.3f A\n",
           (double )dc->min_current / (double )1000);
#line 1470
    printf((char const   */* __restrict  */)"  Maximum current draw       : %.3f A\n",
           (double )dc->max_current / (double )1000);
    }
#line 1472
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1475
    dl = (struct fru_multirec_dcload *)((fru_data + i) + sizeof(struct fru_multirec_header ));
#line 1487
    printf((char const   */* __restrict  */)" DC Load Record\n");
#line 1488
    printf((char const   */* __restrict  */)"  Output Number              : %d\n",
           (int )dl->output_number);
#line 1490
    printf((char const   */* __restrict  */)"  Nominal voltage            : %.2f V\n",
           (double )dl->nominal_voltage / (double )100);
#line 1492
    printf((char const   */* __restrict  */)"  Min voltage allowed        : %.2f V\n",
           (double )dl->min_voltage / (double )100);
#line 1494
    printf((char const   */* __restrict  */)"  Max voltage allowed        : %.2f V\n",
           (double )dl->max_voltage / (double )100);
#line 1496
    printf((char const   */* __restrict  */)"  Ripple and noise pk-pk     : %d mV\n",
           (int )dl->ripple_and_noise);
#line 1498
    printf((char const   */* __restrict  */)"  Minimum current load       : %.3f A\n",
           (double )dl->min_current / (double )1000);
#line 1500
    printf((char const   */* __restrict  */)"  Maximum current load       : %.3f A\n",
           (double )dl->max_current / (double )1000);
    }
#line 1502
    goto switch_break;
    case_192: /* CIL Label */ 
#line 1505
    oh = (struct fru_multirec_oem_header *)(fru_data + ((unsigned long )i + sizeof(struct fru_multirec_header )));
#line 1507
    iana = (uint32_t )(((int )oh->mfg_id[0] | ((int )oh->mfg_id[1] << 8)) | ((int )oh->mfg_id[2] << 16));
#line 1511
    if (iana == 12634U) {
      {
#line 1512
      printf((char const   */* __restrict  */)"  PICMG Extension Record\n");
#line 1513
      ipmi_fru_picmg_ext_print(fru_data, (int )((unsigned long )i + sizeof(struct fru_multirec_header )),
                               (int )h->len);
      }
    } else {
      {
#line 1519
      tmp___10 = val2str((uint16_t )iana, ipmi_oem_info);
#line 1519
      printf((char const   */* __restrict  */)"  OEM (%s) Record\n", tmp___10);
      }
    }
#line 1522
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1524
    i = (uint32_t )((unsigned long )i + ((unsigned long )h->len + sizeof(struct fru_multirec_header )));
#line 1366
    if (! (! ((int )h->format & 128))) {
#line 1366
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1527
  lprintf(7, "Multi-Record area ends at: %i (%xh)", i, i);
#line 1529
  free((void *)fru_data);
#line 1530
  fru_data = (uint8_t *)((void *)0);
  }
#line 1531
  return;
}
}
#line 1542 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
int ipmi_fru_query_new_value(uint8_t *data , int offset , size_t len ) 
{ 
  int status ;
  int ret ;
  char answer ;
  int i ;
  unsigned int *holder ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 1544
  status = 0;
#line 1548
  printf((char const   */* __restrict  */)"Would you like to change this value <y/n> ? ");
#line 1549
  ret = scanf((char const   */* __restrict  */)"%c", & answer);
  }
#line 1550
  if (ret != 1) {
#line 1551
    return (0);
  }
#line 1554
  if ((int )answer == 121) {
#line 1554
    goto _L;
  } else
#line 1554
  if ((int )answer == 89) {
    _L: /* CIL Label */ 
    {
#line 1558
    tmp = malloc(len);
#line 1558
    holder = (unsigned int *)tmp;
#line 1559
    printf((char const   */* __restrict  */)"Enter hex values for each of the %d entries (lsb first), hit <enter> between entries\n",
           (int )len);
#line 1564
    i = 0;
    }
    {
#line 1564
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1564
      if (! ((size_t )i < len)) {
#line 1564
        goto while_break;
      }
      {
#line 1565
      ret = scanf((char const   */* __restrict  */)"%x", holder + i);
      }
#line 1566
      if (ret != 1) {
        {
#line 1567
        free((void *)holder);
        }
#line 1568
        return (0);
      }
#line 1564
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1571
    i = 0;
    {
#line 1571
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1571
      if (! ((size_t )i < len)) {
#line 1571
        goto while_break___0;
      }
#line 1572
      tmp___0 = offset;
#line 1572
      offset ++;
#line 1572
      *(data + tmp___0) = (unsigned char )*(holder + i);
#line 1571
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1575
    free((void *)holder);
#line 1576
    holder = (unsigned int *)((void *)0);
#line 1577
    status = 1;
    }
  } else {
    {
#line 1580
    printf((char const   */* __restrict  */)"Entered %c\n", (int )answer);
    }
  }
#line 1583
  return (status);
}
}
#line 1679
static void ipmi_fru_oemkontron_get(int argc , char **argv , uint8_t *fru_data , int off ,
                                    int len , struct fru_multirec_header *h , struct fru_multirec_oem_header *oh ) ;
#line 1679 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int badParams  =    0;
#line 1674 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static void ipmi_fru_oemkontron_get(int argc , char **argv , uint8_t *fru_data , int off ,
                                    int len , struct fru_multirec_header *h , struct fru_multirec_oem_header *oh ) 
{ 
  int start ;
  int offset ;
  int length ;
  int tmp ;
  uint8_t version ;
  int blockstart ;
  uint8_t blockCount ;
  uint8_t blockIndex ;
  unsigned int matchInstance ;
  uint8_t instance ;
  int tmp___0 ;
  int tmp___1 ;
  void *pRecordData ;
  uint8_t nameLen ;
  int tmp___2 ;
  uint8_t tmp___3 ;

  {
#line 1680
  start = off;
#line 1681
  offset = start;
#line 1682
  length = len;
#line 1684
  offset = (int )((unsigned long )offset + sizeof(struct fru_multirec_oem_header ));
#line 1686
  if (! badParams) {
#line 1688
    if (argc > 2) {
      {
#line 1689
      tmp = strncmp("oem", (char const   *)*(argv + 2), (size_t )3);
      }
#line 1689
      if (tmp) {
        {
#line 1690
        printf((char const   */* __restrict  */)"usage: fru get <id> <oem>\n");
#line 1691
        badParams = 1;
        }
#line 1692
        return;
      }
    }
#line 1695
    if (argc < 5) {
      {
#line 1696
      printf((char const   */* __restrict  */)"usage: oem <iana> <recordid>\n");
#line 1697
      printf((char const   */* __restrict  */)"usage: oem 15000 3\n");
#line 1698
      badParams = 1;
      }
#line 1699
      return;
    }
  }
#line 1703
  if (! badParams) {
#line 1705
    if ((int )oh->record_id == 3) {
      {
#line 1709
      printf((char const   */* __restrict  */)"Kontron OEM Information Record\n");
#line 1710
      version = oh->record_version;
#line 1714
      blockIndex = (uint8_t )0;
#line 1716
      matchInstance = 0U;
#line 1717
      instance = (uint8_t )0;
#line 1719
      tmp___0 = str2uchar((char const   *)*(argv + 7), & instance);
      }
#line 1719
      if (tmp___0 != 0) {
        {
#line 1720
        lprintf(3, "Instance argument \'%s\' is either invalid or out of range.",
                *(argv + 7));
#line 1723
        badParams = 1;
        }
#line 1724
        return;
      }
#line 1727
      tmp___1 = offset;
#line 1727
      offset ++;
#line 1727
      blockCount = *(fru_data + tmp___1);
#line 1729
      blockIndex = (uint8_t )0;
      {
#line 1729
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1729
        if (! ((int )blockIndex < (int )blockCount)) {
#line 1729
          goto while_break;
        }
        {
#line 1733
        blockstart = offset;
#line 1734
        tmp___2 = offset;
#line 1734
        offset ++;
#line 1734
        tmp___3 = (uint8_t )((int )*(fru_data + tmp___2) & 63);
#line 1734
        *(fru_data + tmp___2) = tmp___3;
#line 1734
        nameLen = tmp___3;
#line 1735
        printf((char const   */* __restrict  */)"  Name: %*.*s\n", (int )nameLen,
               (int )nameLen, (char const   *)(fru_data + offset));
#line 1737
        offset += (int )nameLen;
#line 1739
        pRecordData = (void *)(fru_data + offset);
#line 1741
        printf((char const   */* __restrict  */)"  Record Version: %d\n", (int )version);
        }
#line 1742
        if ((int )version == 0) {
          {
#line 1744
          printf((char const   */* __restrict  */)"  Version: %*.*s\n", 8, 8, ((tOemKontronInformationRecordV0 *)pRecordData)->field1);
#line 1748
          printf((char const   */* __restrict  */)"  Build Date: %*.*s\n", 8, 8, ((tOemKontronInformationRecordV0 *)pRecordData)->field2);
#line 1752
          printf((char const   */* __restrict  */)"  Update Date: %*.*s\n", 8, 8,
                 ((tOemKontronInformationRecordV0 *)pRecordData)->field3);
#line 1756
          printf((char const   */* __restrict  */)"  Checksum: %*.*s\n\n", 8, 8, ((tOemKontronInformationRecordV0 *)pRecordData)->crc32);
#line 1760
          matchInstance ++;
#line 1761
          offset = (int )((unsigned long )offset + sizeof(tOemKontronInformationRecordV0 ));
#line 1762
          offset ++;
          }
        } else
#line 1764
        if ((int )version == 1) {
          {
#line 1766
          printf((char const   */* __restrict  */)"  Version: %*.*s\n", 10, 10, ((tOemKontronInformationRecordV1 *)pRecordData)->field1);
#line 1770
          printf((char const   */* __restrict  */)"  Build Date: %*.*s\n", 8, 8, ((tOemKontronInformationRecordV1 *)pRecordData)->field2);
#line 1774
          printf((char const   */* __restrict  */)"  Update Date: %*.*s\n", 8, 8,
                 ((tOemKontronInformationRecordV1 *)pRecordData)->field3);
#line 1778
          printf((char const   */* __restrict  */)"  Checksum: %*.*s\n\n", 8, 8, ((tOemKontronInformationRecordV1 *)pRecordData)->crc32);
#line 1782
          matchInstance ++;
#line 1783
          offset = (int )((unsigned long )offset + sizeof(tOemKontronInformationRecordV1 ));
#line 1784
          offset ++;
          }
        } else {
          {
#line 1788
          printf((char const   */* __restrict  */)"  Unsupported version %d\n", (int )version);
          }
        }
#line 1729
        blockIndex = (uint8_t )((int )blockIndex + 1);
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1793
  return;
}
}
#line 1800
static int ipmi_fru_oemkontron_edit(int argc , char **argv , uint8_t *fru_data , int off ,
                                    int len , struct fru_multirec_header *h , struct fru_multirec_oem_header *oh ) ;
#line 1800 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int badParams___0  =    0;
#line 1795 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_oemkontron_edit(int argc , char **argv , uint8_t *fru_data , int off ,
                                    int len , struct fru_multirec_header *h , struct fru_multirec_oem_header *oh ) 
{ 
  int hasChanged ;
  int start ;
  int offset ;
  int length ;
  int i ;
  uint8_t record_id ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  uint8_t formatVersion ;
  uint8_t version ;
  int tmp___3 ;
  int blockstart ;
  uint8_t blockCount ;
  uint8_t blockIndex ;
  uint8_t matchInstance ;
  uint8_t instance ;
  int tmp___4 ;
  int tmp___5 ;
  void *pRecordData ;
  uint8_t nameLen ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  uint8_t record_checksum ;
  uint8_t header_checksum ;
  int index___0 ;
  uint8_t data ;

  {
#line 1801
  hasChanged = 0;
#line 1802
  start = off;
#line 1803
  offset = start;
#line 1804
  length = len;
#line 1806
  record_id = (uint8_t )0;
#line 1807
  offset = (int )((unsigned long )offset + sizeof(struct fru_multirec_oem_header ));
#line 1809
  if (! badParams___0) {
#line 1811
    if (argc > 2) {
      {
#line 1812
      tmp = strncmp("oem", (char const   *)*(argv + 2), (size_t )3);
      }
#line 1812
      if (tmp) {
        {
#line 1813
        printf((char const   */* __restrict  */)"usage: fru edit <id> <oem> <args...>\n");
#line 1814
        badParams___0 = 1;
        }
#line 1815
        return (hasChanged);
      }
    }
#line 1818
    if (argc < 12) {
      {
#line 1819
      printf((char const   */* __restrict  */)"usage: oem <iana> <recordid> <format> <args...>\n");
#line 1820
      printf((char const   */* __restrict  */)"usage: oem 15000 3 0 <name> <instance> <field1> <field2> <field3> <crc32>\n");
#line 1822
      badParams___0 = 1;
      }
#line 1823
      return (hasChanged);
    }
    {
#line 1825
    tmp___0 = str2uchar((char const   *)*(argv + 4), & record_id);
    }
#line 1825
    if (tmp___0 != 0) {
      {
#line 1826
      lprintf(3, "Record ID argument \'%s\' is either invalid or out of range.", *(argv + 4));
#line 1829
      badParams___0 = 1;
      }
#line 1830
      return (hasChanged);
    }
#line 1832
    if ((int )record_id == 3) {
#line 1833
      i = 8;
      {
#line 1833
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1833
        if (! (i <= 11)) {
#line 1833
          goto while_break;
        }
        {
#line 1834
        tmp___1 = strlen((char const   *)*(argv + i));
        }
#line 1834
        if (tmp___1 != 8UL) {
          {
#line 1834
          tmp___2 = strlen((char const   *)*(argv + i));
          }
#line 1834
          if (tmp___2 != 10UL) {
            {
#line 1836
            printf((char const   */* __restrict  */)"error: version fields must have %d characters\n",
                   8);
#line 1838
            badParams___0 = 1;
            }
#line 1839
            return (hasChanged);
          }
        }
#line 1833
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1845
  if (! badParams___0) {
#line 1847
    if ((int )oh->record_id == 3) {
      {
#line 1848
      formatVersion = (uint8_t )0;
#line 1851
      tmp___3 = str2uchar((char const   *)*(argv + 5), & formatVersion);
      }
#line 1851
      if (tmp___3 != 0) {
        {
#line 1852
        lprintf(3, "Format argument \'%s\' is either invalid or out of range.", *(argv + 5));
#line 1855
        badParams___0 = 1;
        }
#line 1856
        return (hasChanged);
      }
      {
#line 1859
      printf((char const   */* __restrict  */)"   Kontron OEM Information Record\n");
#line 1860
      version = oh->record_version;
      }
#line 1862
      if ((int )version == (int )formatVersion) {
        {
#line 1865
        blockIndex = (uint8_t )0;
#line 1867
        matchInstance = (uint8_t )0;
#line 1868
        instance = (uint8_t )0;
#line 1870
        tmp___4 = str2uchar((char const   *)*(argv + 7), & instance);
        }
#line 1870
        if (tmp___4 != 0) {
          {
#line 1871
          lprintf(3, "Instance argument \'%s\' is either invalid or out of range.",
                  *(argv + 7));
#line 1874
          badParams___0 = 1;
          }
#line 1875
          return (hasChanged);
        }
        {
#line 1878
        tmp___5 = offset;
#line 1878
        offset ++;
#line 1878
        blockCount = *(fru_data + tmp___5);
#line 1879
        printf((char const   */* __restrict  */)"   blockCount: %d\n", (int )blockCount);
#line 1881
        blockIndex = (uint8_t )0;
        }
        {
#line 1881
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1881
          if (! ((int )blockIndex < (int )blockCount)) {
#line 1881
            goto while_break___0;
          }
#line 1885
          blockstart = offset;
#line 1887
          tmp___6 = offset;
#line 1887
          offset ++;
#line 1887
          nameLen = (uint8_t )((int )*(fru_data + tmp___6) & 63);
#line 1889
          if ((int )version == 0) {
#line 1889
            goto _L___0;
          } else
#line 1889
          if ((int )version == 1) {
            _L___0: /* CIL Label */ 
            {
#line 1891
            tmp___8 = strncmp((char const   *)*(argv + 6), (char const   *)(fru_data + offset),
                              (size_t )nameLen);
            }
#line 1891
            if (tmp___8) {
              _L: /* CIL Label */ 
              {
#line 1941
              tmp___7 = strncmp((char const   *)*(argv + 6), (char const   *)(fru_data + offset),
                                (size_t )nameLen);
              }
#line 1941
              if (tmp___7) {
#line 1949
                offset += (int )nameLen;
              } else {
                {
#line 1943
                printf((char const   */* __restrict  */)"Skipped : %s  [instance %d]\n",
                       *(argv + 6), (unsigned int )matchInstance);
#line 1945
                matchInstance = (uint8_t )((int )matchInstance + 1);
#line 1946
                offset += (int )nameLen;
                }
              }
            } else
#line 1891
            if ((int )matchInstance == (int )instance) {
              {
#line 1894
              printf((char const   */* __restrict  */)"Found : %s\n", *(argv + 6));
#line 1895
              offset += (int )nameLen;
#line 1897
              pRecordData = (void *)(fru_data + offset);
              }
#line 1899
              if ((int )version == 0) {
                {
#line 1901
                memcpy((void */* __restrict  */)(((tOemKontronInformationRecordV0 *)pRecordData)->field1),
                       (void const   */* __restrict  */)*(argv + 8), (size_t )8);
#line 1905
                memcpy((void */* __restrict  */)(((tOemKontronInformationRecordV0 *)pRecordData)->field2),
                       (void const   */* __restrict  */)*(argv + 9), (size_t )8);
#line 1909
                memcpy((void */* __restrict  */)(((tOemKontronInformationRecordV0 *)pRecordData)->field3),
                       (void const   */* __restrict  */)*(argv + 10), (size_t )8);
#line 1913
                memcpy((void */* __restrict  */)(((tOemKontronInformationRecordV0 *)pRecordData)->crc32),
                       (void const   */* __restrict  */)*(argv + 11), (size_t )8);
                }
              } else {
                {
#line 1920
                memcpy((void */* __restrict  */)(((tOemKontronInformationRecordV1 *)pRecordData)->field1),
                       (void const   */* __restrict  */)*(argv + 8), (size_t )10);
#line 1924
                memcpy((void */* __restrict  */)(((tOemKontronInformationRecordV1 *)pRecordData)->field2),
                       (void const   */* __restrict  */)*(argv + 9), (size_t )8);
#line 1928
                memcpy((void */* __restrict  */)(((tOemKontronInformationRecordV1 *)pRecordData)->field3),
                       (void const   */* __restrict  */)*(argv + 10), (size_t )8);
#line 1932
                memcpy((void */* __restrict  */)(((tOemKontronInformationRecordV1 *)pRecordData)->crc32),
                       (void const   */* __restrict  */)*(argv + 11), (size_t )8);
                }
              }
#line 1938
              matchInstance = (uint8_t )((int )matchInstance + 1);
#line 1939
              hasChanged = 1;
            } else {
#line 1891
              goto _L;
            }
#line 1952
            if ((int )version == 0) {
#line 1954
              offset = (int )((unsigned long )offset + sizeof(tOemKontronInformationRecordV0 ));
            } else {
#line 1958
              offset = (int )((unsigned long )offset + sizeof(tOemKontronInformationRecordV1 ));
            }
#line 1960
            offset ++;
          } else {
            {
#line 1964
            printf((char const   */* __restrict  */)"  Unsupported version %d\n",
                   (int )version);
            }
          }
#line 1881
          blockIndex = (uint8_t )((int )blockIndex + 1);
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 1969
        printf((char const   */* __restrict  */)"   Version: %d\n", (int )version);
        }
      }
    }
#line 1972
    if (hasChanged) {
      {
#line 1974
      record_checksum = (uint8_t )0;
#line 1975
      header_checksum = (uint8_t )0;
#line 1978
      lprintf(7, "Initial record checksum : %x", (int )h->record_checksum);
#line 1979
      lprintf(7, "Initial header checksum : %x", (int )h->header_checksum);
#line 1980
      index___0 = 0;
      }
      {
#line 1980
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1980
        if (! (index___0 < length)) {
#line 1980
          goto while_break___1;
        }
#line 1981
        record_checksum = (uint8_t )((int )record_checksum + (int )*(fru_data + (start + index___0)));
#line 1980
        index___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1984
      h->record_checksum = (uint8_t )(~ ((int )record_checksum) + 1);
#line 1987
      index___0 = 0;
      {
#line 1987
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1987
        if (! ((unsigned long )index___0 < sizeof(struct fru_multirec_header ) - 1UL)) {
#line 1987
          goto while_break___2;
        }
#line 1988
        data = *((uint8_t *)h + index___0);
#line 1989
        header_checksum = (uint8_t )((int )header_checksum + (int )data);
#line 1987
        index___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1992
      h->header_checksum = (uint8_t )(~ ((int )header_checksum) + 1);
#line 1994
      lprintf(7, "Final record checksum : %x", (int )h->record_checksum);
#line 1995
      lprintf(7, "Final header checksum : %x", (int )h->header_checksum);
      }
    }
  }
#line 2001
  return (hasChanged);
}
}
#line 2015 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_picmg_ext_edit(uint8_t *fru_data , int off , int len , struct fru_multirec_header *h ,
                                   struct fru_multirec_oem_header *oh ) 
{ 
  int hasChanged ;
  int start ;
  int offset ;
  int length ;
  int index___0 ;
  uint16_t max_current ;
  int tmp ;
  struct fru_picmgext_activation_record *a ;
  int index___1 ;
  unsigned char current ;
  int tmp___0 ;
  uint8_t record_checksum ;
  uint8_t header_checksum ;
  int index___2 ;
  uint8_t data ;

  {
#line 2020
  hasChanged = 0;
#line 2021
  start = off;
#line 2022
  offset = start;
#line 2023
  length = len;
#line 2024
  offset = (int )((unsigned long )offset + sizeof(struct fru_multirec_oem_header ));
  {
#line 2028
  if ((int )oh->record_id == 23) {
#line 2028
    goto case_23;
  }
#line 2067
  if ((int )oh->record_id == 22) {
#line 2067
    goto case_22;
  }
#line 2026
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 2029
  printf((char const   */* __restrict  */)"    FRU_AMC_ACTIVATION\n");
#line 2031
  index___0 = offset;
#line 2034
  max_current = (uint16_t )*(fru_data + offset);
#line 2035
  offset ++;
#line 2035
  max_current = (uint16_t )((int )max_current | ((int )*(fru_data + offset) << 8));
#line 2037
  printf((char const   */* __restrict  */)"      Maximum Internal Current(@12V): %.2f A (0x%02x)\n",
         (double )((float )max_current / 10.0f), (int )max_current);
#line 2040
  tmp = ipmi_fru_query_new_value(fru_data, index___0, (size_t )2);
  }
#line 2040
  if (tmp) {
    {
#line 2041
    max_current = (uint16_t )*(fru_data + index___0);
#line 2042
    index___0 ++;
#line 2042
    max_current = (uint16_t )((int )max_current | ((int )*(fru_data + index___0) << 8));
#line 2043
    printf((char const   */* __restrict  */)"      New Maximum Internal Current(@12V): %.2f A (0x%02x)\n",
           (double )((float )max_current / 10.0f), (int )max_current);
#line 2045
    hasChanged = 1;
    }
  }
  {
#line 2049
  offset ++;
#line 2049
  printf((char const   */* __restrict  */)"      Module Activation Readiness:       %i sec.\n",
         (int )*(fru_data + offset));
#line 2050
  offset ++;
#line 2050
  printf((char const   */* __restrict  */)"      Descriptor Count: %i\n", (int )*(fru_data + offset));
#line 2051
  printf((char const   */* __restrict  */)"\n");
#line 2053
  offset ++;
  }
  {
#line 2053
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2053
    if (! (offset < off + length)) {
#line 2053
      goto while_break;
    }
    {
#line 2056
    a = (struct fru_picmgext_activation_record *)(fru_data + offset);
#line 2059
    printf((char const   */* __restrict  */)"        IPMB-Address:         0x%x\n",
           (int )a->ibmb_addr);
#line 2060
    printf((char const   */* __restrict  */)"        Max. Module Current:  %.2f A\n",
           (double )((float )a->max_module_curr / 10.0f));
#line 2062
    printf((char const   */* __restrict  */)"\n");
#line 2053
    offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_activation_record ));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2065
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 2068
  printf((char const   */* __restrict  */)"    FRU_AMC_CURRENT\n");
#line 2070
  index___1 = offset;
#line 2073
  current = *(fru_data + index___1);
#line 2075
  printf((char const   */* __restrict  */)"      Current draw(@12V): %.2f A (0x%02x)\n",
         (double )((float )current / 10.0f), (int )current);
#line 2078
  tmp___0 = ipmi_fru_query_new_value(fru_data, index___1, (size_t )1);
  }
#line 2078
  if (tmp___0) {
    {
#line 2079
    current = *(fru_data + index___1);
#line 2081
    printf((char const   */* __restrict  */)"      New Current draw(@12V): %.2f A (0x%02x)\n",
           (double )((float )current / 10.0f), (int )current);
#line 2083
    hasChanged = 1;
    }
  }
#line 2086
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2089
  if (hasChanged) {
    {
#line 2091
    record_checksum = (uint8_t )0;
#line 2092
    header_checksum = (uint8_t )0;
#line 2095
    lprintf(7, "Initial record checksum : %x", (int )h->record_checksum);
#line 2096
    lprintf(7, "Initial header checksum : %x", (int )h->header_checksum);
#line 2097
    index___2 = 0;
    }
    {
#line 2097
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2097
      if (! (index___2 < length)) {
#line 2097
        goto while_break___0;
      }
#line 2098
      record_checksum = (uint8_t )((int )record_checksum + (int )*(fru_data + (start + index___2)));
#line 2097
      index___2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2101
    h->record_checksum = (uint8_t )(~ ((int )record_checksum) + 1);
#line 2104
    index___2 = 0;
    {
#line 2104
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2104
      if (! ((unsigned long )index___2 < sizeof(struct fru_multirec_header ) - 1UL)) {
#line 2104
        goto while_break___1;
      }
#line 2105
      data = *((uint8_t *)h + index___2);
#line 2106
      header_checksum = (uint8_t )((int )header_checksum + (int )data);
#line 2104
      index___2 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2109
    h->header_checksum = (uint8_t )(~ ((int )header_checksum) + 1);
#line 2111
    lprintf(7, "Final record checksum : %x", (int )h->record_checksum);
#line 2112
    lprintf(7, "Final header checksum : %x", (int )h->header_checksum);
    }
  }
#line 2117
  return (hasChanged);
}
}
#line 2128 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static void ipmi_fru_picmg_ext_print(uint8_t *fru_data , int off , int length ) 
{ 
  struct fru_multirec_oem_header *h ;
  int guid_count ;
  int offset ;
  int start_offset ;
  int i ;
  uint8_t index___0 ;
  unsigned int data ;
  struct fru_picmgext_slot_desc *slot_d ;
  struct fru_picmgext_chn_desc *d ;
  unsigned int hwaddr ;
  unsigned int sitetype ;
  unsigned int sitenum ;
  unsigned int entries ;
  unsigned int i___0 ;
  char *picmg_site_type_strings[10] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  unsigned int entries___0 ;
  unsigned int feeds ;
  unsigned int hwaddr___0 ;
  unsigned int i___1 ;
  unsigned int id ;
  unsigned int j ;
  unsigned int maxext ;
  unsigned int maxint ;
  unsigned int minexp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int i___2 ;
  unsigned int count ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int j___0 ;
  struct fru_picmgext_link_desc *d___0 ;
  unsigned int data___0 ;
  unsigned char current ;
  uint16_t max_current ;
  struct fru_picmgext_activation_record *a ;
  uint16_t index___1 ;
  struct fru_picmgext_carrier_p2p_record *h___0 ;
  unsigned char data___1[3] ;
  struct fru_picmgext_carrier_p2p_descriptor *desc ;
  unsigned int index___2 ;
  unsigned char channel_count ;
  struct fru_picmgext_amc_p2p_record *h___1 ;
  int j___1 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  unsigned int data___2 ;
  struct fru_picmgext_amc_channel_desc_record *d___1 ;
  unsigned int data___3[2] ;
  struct fru_picmgext_amc_link_desc_record *l ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  unsigned char extVersion ;
  unsigned char siteCount ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  unsigned char desc_count ;
  int i___3 ;
  int j___2 ;
  int tmp___21 ;
  unsigned char resource_id ;
  unsigned char channel_count___0 ;
  int tmp___22 ;
  int tmp___23 ;
  unsigned char loc_channel ;
  unsigned char rem_channel ;
  unsigned char rem_resource ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  unsigned char resource_id___0 ;
  unsigned char descr_count ;
  int i___4 ;
  int j___3 ;
  int tmp___27 ;
  int tmp___28 ;
  unsigned char channel_id ;
  unsigned char control ;
  unsigned char indirect_cnt ;
  unsigned char direct_cnt ;
  int tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  unsigned char feature ;
  unsigned char dep_chn_id ;
  int tmp___34 ;
  int tmp___35 ;
  char const   *tmp___36 ;
  unsigned char feature___0 ;
  unsigned char family ;
  unsigned char accuracy ;
  unsigned int freq ;
  unsigned int min_freq ;
  unsigned int max_freq ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  char const   *tmp___40 ;

  {
#line 2132
  offset = off;
#line 2133
  start_offset = off;
#line 2136
  h = (struct fru_multirec_oem_header *)(fru_data + offset);
#line 2137
  offset = (int )((unsigned long )offset + sizeof(struct fru_multirec_oem_header ));
  {
#line 2141
  if ((int )h->record_id == 4) {
#line 2141
    goto case_4;
  }
#line 2214
  if ((int )h->record_id == 16) {
#line 2214
    goto case_16;
  }
#line 2261
  if ((int )h->record_id == 17) {
#line 2261
    goto case_17;
  }
#line 2329
  if ((int )h->record_id == 18) {
#line 2329
    goto case_18;
  }
#line 2359
  if ((int )h->record_id == 19) {
#line 2359
    goto case_19;
  }
#line 2363
  if ((int )h->record_id == 20) {
#line 2363
    goto case_20;
  }
#line 2500
  if ((int )h->record_id == 22) {
#line 2500
    goto case_22;
  }
#line 2513
  if ((int )h->record_id == 23) {
#line 2513
    goto case_23;
  }
#line 2542
  if ((int )h->record_id == 24) {
#line 2542
    goto case_24;
  }
#line 2590
  if ((int )h->record_id == 25) {
#line 2590
    goto case_25;
  }
#line 2782
  if ((int )h->record_id == 26) {
#line 2782
    goto case_26;
  }
#line 2803
  if ((int )h->record_id == 44) {
#line 2803
    goto case_44;
  }
#line 2846
  if ((int )h->record_id == 45) {
#line 2846
    goto case_45;
  }
#line 2932
  if ((int )h->record_id == 43) {
#line 2932
    goto case_43;
  }
#line 2932
  if ((int )h->record_id == 42) {
#line 2932
    goto case_43;
  }
#line 2932
  if ((int )h->record_id == 41) {
#line 2932
    goto case_43;
  }
#line 2932
  if ((int )h->record_id == 40) {
#line 2932
    goto case_43;
  }
#line 2932
  if ((int )h->record_id == 39) {
#line 2932
    goto case_43;
  }
#line 2932
  if ((int )h->record_id == 38) {
#line 2932
    goto case_43;
  }
#line 2932
  if ((int )h->record_id == 37) {
#line 2932
    goto case_43;
  }
#line 2932
  if ((int )h->record_id == 36) {
#line 2932
    goto case_43;
  }
#line 2932
  if ((int )h->record_id == 35) {
#line 2932
    goto case_43;
  }
#line 2932
  if ((int )h->record_id == 34) {
#line 2932
    goto case_43;
  }
#line 2932
  if ((int )h->record_id == 33) {
#line 2932
    goto case_43;
  }
#line 2932
  if ((int )h->record_id == 32) {
#line 2932
    goto case_43;
  }
#line 2937
  goto switch_default___8;
  case_4: /* CIL Label */ 
  {
#line 2147
  slot_d = (struct fru_picmgext_slot_desc *)(fru_data + offset);
#line 2149
  offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_slot_desc ));
#line 2150
  printf((char const   */* __restrict  */)"    FRU_PICMG_BACKPLANE_P2P\n");
  }
  {
#line 2152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2152
    if (! (offset <= start_offset + length)) {
#line 2152
      goto while_break;
    }
    {
#line 2153
    printf((char const   */* __restrict  */)"\n");
#line 2154
    printf((char const   */* __restrict  */)"    Channel Type:  ");
    }
    {
#line 2158
    if ((int )slot_d->chan_type == 7) {
#line 2158
      goto case_7;
    }
#line 2158
    if ((int )slot_d->chan_type == 0) {
#line 2158
      goto case_7;
    }
#line 2161
    if ((int )slot_d->chan_type == 8) {
#line 2161
      goto case_8;
    }
#line 2164
    if ((int )slot_d->chan_type == 9) {
#line 2164
      goto case_9;
    }
#line 2167
    if ((int )slot_d->chan_type == 10) {
#line 2167
      goto case_10;
    }
#line 2170
    if ((int )slot_d->chan_type == 11) {
#line 2170
      goto case_11;
    }
#line 2173
    if ((int )slot_d->chan_type == 12) {
#line 2173
      goto case_12;
    }
#line 2176
    if ((int )slot_d->chan_type == 13) {
#line 2176
      goto case_13;
    }
#line 2179
    goto switch_default;
    case_7: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 2159
    printf((char const   */* __restrict  */)"PICMG 2.9\n");
    }
#line 2160
    goto switch_break___0;
    case_8: /* CIL Label */ 
    {
#line 2162
    printf((char const   */* __restrict  */)"Single Port Fabric IF\n");
    }
#line 2163
    goto switch_break___0;
    case_9: /* CIL Label */ 
    {
#line 2165
    printf((char const   */* __restrict  */)"Double Port Fabric IF\n");
    }
#line 2166
    goto switch_break___0;
    case_10: /* CIL Label */ 
    {
#line 2168
    printf((char const   */* __restrict  */)"Full Channel Fabric IF\n");
    }
#line 2169
    goto switch_break___0;
    case_11: /* CIL Label */ 
    {
#line 2171
    printf((char const   */* __restrict  */)"Base IF\n");
    }
#line 2172
    goto switch_break___0;
    case_12: /* CIL Label */ 
    {
#line 2174
    printf((char const   */* __restrict  */)"Update Channel IF\n");
    }
#line 2175
    goto switch_break___0;
    case_13: /* CIL Label */ 
    {
#line 2177
    printf((char const   */* __restrict  */)"ShMC Cross Connect\n");
    }
#line 2178
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 2180
    printf((char const   */* __restrict  */)"Unknown IF (0x%x)\n", (int )slot_d->chan_type);
    }
#line 2182
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 2184
    printf((char const   */* __restrict  */)"    Slot Addr.   : %02x\n", (int )slot_d->slot_addr);
#line 2186
    printf((char const   */* __restrict  */)"    Channel Count: %i\n", (int )slot_d->chn_count);
#line 2189
    index___0 = (uint8_t )0;
    }
    {
#line 2189
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2189
      if (! ((int )index___0 < (int )slot_d->chn_count)) {
#line 2189
        goto while_break___0;
      }
#line 2193
      data = (unsigned int )(((int )*(fru_data + offset) | ((int )*(fru_data + (offset + 1)) << 8)) | ((int )*(fru_data + (offset + 2)) << 16));
#line 2196
      d = (struct fru_picmgext_chn_desc *)(& data);
#line 2197
      if (verbose) {
        {
#line 2198
        printf((char const   */* __restrict  */)"       Chn: %02x  ->  Chn: %02x in Slot: %02x\n",
               d->local_chn, d->remote_chn, d->remote_slot);
        }
      }
#line 2206
      offset += 3;
#line 2189
      index___0 = (uint8_t )((int )index___0 + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2208
    slot_d = (struct fru_picmgext_slot_desc *)(fru_data + offset);
#line 2209
    offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_slot_desc ));
  }
  while_break: /* CIL Label */ ;
  }
#line 2212
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 2221
  picmg_site_type_strings[0] = (char *)"AdvancedTCA Board";
#line 2221
  picmg_site_type_strings[1] = (char *)"Power Entry";
#line 2221
  picmg_site_type_strings[2] = (char *)"Shelf FRU Information";
#line 2221
  picmg_site_type_strings[3] = (char *)"Dedicated ShMC";
#line 2221
  picmg_site_type_strings[4] = (char *)"Fan Tray";
#line 2221
  picmg_site_type_strings[5] = (char *)"Fan Filter Tray";
#line 2221
  picmg_site_type_strings[6] = (char *)"Alarm";
#line 2221
  picmg_site_type_strings[7] = (char *)"AdvancedMC Module";
#line 2221
  picmg_site_type_strings[8] = (char *)"PMC";
#line 2221
  picmg_site_type_strings[9] = (char *)"Rear Transition Module";
#line 2234
  printf((char const   */* __restrict  */)"    FRU_PICMG_ADDRESS_TABLE\n");
#line 2235
  tmp = offset;
#line 2235
  offset ++;
#line 2235
  printf((char const   */* __restrict  */)"      Type/Len:  0x%02x\n", (int )*(fru_data + tmp));
#line 2236
  printf((char const   */* __restrict  */)"      Shelf Addr: ");
#line 2237
  i___0 = 0U;
  }
  {
#line 2237
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2237
    if (! (i___0 < 20U)) {
#line 2237
      goto while_break___1;
    }
    {
#line 2238
    tmp___0 = offset;
#line 2238
    offset ++;
#line 2238
    printf((char const   */* __restrict  */)"0x%02x ", (int )*(fru_data + tmp___0));
#line 2237
    i___0 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2240
  printf((char const   */* __restrict  */)"\n");
#line 2242
  tmp___1 = offset;
#line 2242
  offset ++;
#line 2242
  entries = (unsigned int )*(fru_data + tmp___1);
#line 2243
  printf((char const   */* __restrict  */)"      Addr Table Entries: 0x%02x\n", entries);
#line 2245
  i___0 = 0U;
  }
  {
#line 2245
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2245
    if (! (i___0 < entries)) {
#line 2245
      goto while_break___2;
    }
#line 2246
    hwaddr = (unsigned int )*(fru_data + offset);
#line 2247
    sitenum = (unsigned int )*(fru_data + (offset + 1));
#line 2248
    sitetype = (unsigned int )*(fru_data + (offset + 2));
#line 2249
    if (sitetype < 10U) {
#line 2249
      tmp___2 = (char const   *)picmg_site_type_strings[sitetype];
    } else {
#line 2249
      tmp___2 = "Reserved";
    }
    {
#line 2249
    printf((char const   */* __restrict  */)"        HWAddr: 0x%02x (0x%02x) SiteNum: %d SiteType: 0x%02x %s\n",
           hwaddr, hwaddr * 2U, sitenum, sitetype, tmp___2);
#line 2256
    offset += 3;
#line 2245
    i___0 ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2259
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 2274
  printf((char const   */* __restrict  */)"    FRU_PICMG_SHELF_POWER_DIST\n");
#line 2276
  tmp___3 = offset;
#line 2276
  offset ++;
#line 2276
  feeds = (unsigned int )*(fru_data + tmp___3);
#line 2277
  printf((char const   */* __restrict  */)"      Number of Power Feeds:   0x%02x\n",
         feeds);
#line 2280
  i___1 = 0U;
  }
  {
#line 2280
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2280
    if (! (i___1 < feeds)) {
#line 2280
      goto while_break___3;
    }
    {
#line 2281
    printf((char const   */* __restrict  */)"    Feed %d:\n", i___1);
#line 2282
    maxext = (unsigned int )((int )*(fru_data + offset) | ((int )*(fru_data + (offset + 1)) << 8));
#line 2284
    offset += 2;
#line 2285
    maxint = (unsigned int )((int )*(fru_data + offset) | ((int )*(fru_data + (offset + 1)) << 8));
#line 2287
    offset += 2;
#line 2288
    minexp = (unsigned int )*(fru_data + offset);
#line 2289
    offset ++;
#line 2290
    entries___0 = (unsigned int )*(fru_data + offset);
#line 2291
    offset ++;
#line 2293
    printf((char const   */* __restrict  */)"      Max External Current:   %d.%d Amps (0x%04x)\n",
           maxext / 10U, maxext % 10U, maxext);
    }
#line 2296
    if (maxint < 65535U) {
      {
#line 2297
      printf((char const   */* __restrict  */)"      Max Internal Current:   %d.%d Amps (0x%04x)\n",
             maxint / 10U, maxint % 10U, maxint);
      }
    } else {
      {
#line 2302
      printf((char const   */* __restrict  */)"      Max Internal Current:   Not Specified\n");
      }
    }
#line 2306
    if (minexp >= 72U) {
#line 2306
      if (minexp <= 144U) {
        {
#line 2307
        printf((char const   */* __restrict  */)"      Min Expected Voltage:   -%02d.%dV\n",
               minexp / 2U, (minexp % 2U) * 5U);
        }
      } else {
        {
#line 2311
        printf((char const   */* __restrict  */)"      Min Expected Voltage:   -36V (actual invalid value 0x%x)\n",
               36, minexp);
        }
      }
    } else {
      {
#line 2311
      printf((char const   */* __restrict  */)"      Min Expected Voltage:   -36V (actual invalid value 0x%x)\n",
             36, minexp);
      }
    }
#line 2315
    j = 0U;
    {
#line 2315
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2315
      if (! (j < entries___0)) {
#line 2315
        goto while_break___4;
      }
      {
#line 2316
      tmp___4 = offset;
#line 2316
      offset ++;
#line 2316
      hwaddr___0 = (unsigned int )*(fru_data + tmp___4);
#line 2317
      tmp___5 = offset;
#line 2317
      offset ++;
#line 2317
      id = (unsigned int )*(fru_data + tmp___5);
#line 2318
      printf((char const   */* __restrict  */)"        FRU HW Addr: 0x%02x (0x%02x)",
             hwaddr___0, hwaddr___0 * 2U);
#line 2321
      printf((char const   */* __restrict  */)"   FRU ID: 0x%02x\n", id);
#line 2315
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2280
    i___1 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2327
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 2332
  count = 0U;
#line 2334
  printf((char const   */* __restrict  */)"    FRU_PICMG_SHELF_ACTIVATION\n");
#line 2335
  tmp___6 = offset;
#line 2335
  offset ++;
#line 2335
  printf((char const   */* __restrict  */)"      Allowance for FRU Act Readiness:   0x%02x\n",
         (int )*(fru_data + tmp___6));
#line 2339
  tmp___7 = offset;
#line 2339
  offset ++;
#line 2339
  count = (unsigned int )*(fru_data + tmp___7);
#line 2340
  printf((char const   */* __restrict  */)"      FRU activation and Power Desc Cnt: 0x%02x\n",
         count);
#line 2344
  i___2 = 0U;
  }
  {
#line 2344
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2344
    if (! (i___2 < count)) {
#line 2344
      goto while_break___5;
    }
    {
#line 2345
    tmp___8 = offset;
#line 2345
    offset ++;
#line 2345
    printf((char const   */* __restrict  */)"         HW Addr: 0x%02x ", (int )*(fru_data + tmp___8));
#line 2347
    tmp___9 = offset;
#line 2347
    offset ++;
#line 2347
    printf((char const   */* __restrict  */)"         FRU ID: 0x%02x ", (int )*(fru_data + tmp___9));
#line 2349
    printf((char const   */* __restrict  */)"         Max FRU Power: 0x%04x ", (int )*(fru_data + offset) | ((int )*(fru_data + (offset + 1)) << 8));
#line 2352
    offset += 2;
#line 2353
    tmp___10 = offset;
#line 2353
    offset ++;
#line 2353
    printf((char const   */* __restrict  */)"         Config: 0x%02x \n", (int )*(fru_data + tmp___10));
#line 2344
    i___2 ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2357
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 2360
  printf((char const   */* __restrict  */)"    FRU_PICMG_SHMC_IP_CONN\n");
  }
#line 2361
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 2364
  printf((char const   */* __restrict  */)"    FRU_PICMG_BOARD_P2P\n");
#line 2366
  tmp___11 = offset;
#line 2366
  offset ++;
#line 2366
  guid_count = (int )*(fru_data + tmp___11);
#line 2367
  printf((char const   */* __restrict  */)"      GUID count: %2d\n", guid_count);
#line 2368
  i = 0;
  }
  {
#line 2368
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 2368
    if (! (i < guid_count)) {
#line 2368
      goto while_break___6;
    }
    {
#line 2370
    printf((char const   */* __restrict  */)"        GUID [%2d]: 0x", i);
#line 2372
    j___0 = 0;
    }
    {
#line 2372
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2372
      if (! ((unsigned long )j___0 < sizeof(struct fru_picmgext_guid ))) {
#line 2372
        goto while_break___7;
      }
      {
#line 2374
      printf((char const   */* __restrict  */)"%02x", (int )*(fru_data + (offset + j___0)));
#line 2372
      j___0 ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 2377
    printf((char const   */* __restrict  */)"\n");
#line 2378
    offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_guid ));
#line 2368
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 2380
  printf((char const   */* __restrict  */)"\n");
  }
  {
#line 2382
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 2382
    if (! (offset < off + length)) {
#line 2382
      goto while_break___8;
    }
    {
#line 2387
    data___0 = (unsigned int )((((int )*(fru_data + offset) | ((int )*(fru_data + (offset + 1)) << 8)) | ((int )*(fru_data + (offset + 2)) << 16)) | ((int )*(fru_data + (offset + 3)) << 24));
#line 2391
    d___0 = (struct fru_picmgext_link_desc *)(& data___0);
#line 2393
    printf((char const   */* __restrict  */)"      Link Grouping ID:     0x%02x\n",
           d___0->grouping);
#line 2395
    printf((char const   */* __restrict  */)"      Link Type Extension:  0x%02x - ",
           d___0->ext);
    }
#line 2397
    if (d___0->type == 1U) {
      {
#line 2400
      if (d___0->ext == 0U) {
#line 2400
        goto case_0___0;
      }
#line 2403
      if (d___0->ext == 1U) {
#line 2403
        goto case_1;
      }
#line 2406
      goto switch_default___0;
      case_0___0: /* CIL Label */ 
      {
#line 2401
      printf((char const   */* __restrict  */)"10/100/1000BASE-T Link (four-pair)\n");
      }
#line 2402
      goto switch_break___1;
      case_1: /* CIL Label */ 
      {
#line 2404
      printf((char const   */* __restrict  */)"ShMC Cross-connect (two-pair)\n");
      }
#line 2405
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
      {
#line 2407
      printf((char const   */* __restrict  */)"Unknwon\n");
      }
#line 2408
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    } else
#line 2410
    if (d___0->type == 2U) {
      {
#line 2413
      if (d___0->ext == 0U) {
#line 2413
        goto case_0___1;
      }
#line 2416
      if (d___0->ext == 1U) {
#line 2416
        goto case_1___0;
      }
#line 2419
      if (d___0->ext == 2U) {
#line 2419
        goto case_2;
      }
#line 2422
      goto switch_default___1;
      case_0___1: /* CIL Label */ 
      {
#line 2414
      printf((char const   */* __restrict  */)"Fixed 1000Base-BX\n");
      }
#line 2415
      goto switch_break___2;
      case_1___0: /* CIL Label */ 
      {
#line 2417
      printf((char const   */* __restrict  */)"Fixed 10GBASE-BX4 [XAUI]\n");
      }
#line 2418
      goto switch_break___2;
      case_2: /* CIL Label */ 
      {
#line 2420
      printf((char const   */* __restrict  */)"FC-PI\n");
      }
#line 2421
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
      {
#line 2423
      printf((char const   */* __restrict  */)"Unknwon\n");
      }
#line 2424
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
    } else
#line 2426
    if (d___0->type == 3U) {
      {
#line 2427
      printf((char const   */* __restrict  */)"Unknwon\n");
      }
    } else
#line 2428
    if (d___0->type == 4U) {
      {
#line 2429
      printf((char const   */* __restrict  */)"Unknwon\n");
      }
    } else
#line 2430
    if (d___0->type == 5U) {
      {
#line 2431
      printf((char const   */* __restrict  */)"Unknwon\n");
      }
    } else {
      {
#line 2433
      printf((char const   */* __restrict  */)"Unknwon\n");
      }
    }
    {
#line 2436
    printf((char const   */* __restrict  */)"      Link Type:            0x%02x - ",
           d___0->type);
    }
#line 2438
    if (d___0->type == 0U) {
      {
#line 2439
      printf((char const   */* __restrict  */)"Reserved\n");
      }
    } else
#line 2438
    if (d___0->type == 255U) {
      {
#line 2439
      printf((char const   */* __restrict  */)"Reserved\n");
      }
    } else
#line 2441
    if (d___0->type >= 6U) {
#line 2441
      if (d___0->type <= 239U) {
        {
#line 2442
        printf((char const   */* __restrict  */)"Reserved\n");
        }
      } else {
#line 2441
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2444
    if (d___0->type >= 240U) {
#line 2444
      if (d___0->type <= 254U) {
        {
#line 2445
        printf((char const   */* __restrict  */)"OEM GUID Definition\n");
        }
      } else {
#line 2444
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 2450
      if (d___0->type == 1U) {
#line 2450
        goto case_1___1;
      }
#line 2453
      if (d___0->type == 2U) {
#line 2453
        goto case_2___0;
      }
#line 2456
      if (d___0->type == 3U) {
#line 2456
        goto case_3;
      }
#line 2459
      if (d___0->type == 4U) {
#line 2459
        goto case_4___0;
      }
#line 2462
      if (d___0->type == 5U) {
#line 2462
        goto case_5;
      }
#line 2465
      goto switch_default___2;
      case_1___1: /* CIL Label */ 
      {
#line 2451
      printf((char const   */* __restrict  */)"PICMG 3.0 Base Interface 10/100/1000\n");
      }
#line 2452
      goto switch_break___3;
      case_2___0: /* CIL Label */ 
      {
#line 2454
      printf((char const   */* __restrict  */)"PICMG 3.1 Ethernet Fabric Interface\n");
      }
#line 2455
      goto switch_break___3;
      case_3: /* CIL Label */ 
      {
#line 2457
      printf((char const   */* __restrict  */)"PICMG 3.2 Infiniband Fabric Interface\n");
      }
#line 2458
      goto switch_break___3;
      case_4___0: /* CIL Label */ 
      {
#line 2460
      printf((char const   */* __restrict  */)"PICMG 3.3 Star Fabric Interface\n");
      }
#line 2461
      goto switch_break___3;
      case_5: /* CIL Label */ 
      {
#line 2463
      printf((char const   */* __restrict  */)"PICMG 3.4 PCI Express Fabric Interface\n");
      }
#line 2464
      goto switch_break___3;
      switch_default___2: /* CIL Label */ 
      {
#line 2466
      printf((char const   */* __restrict  */)"Invalid\n");
      }
#line 2467
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
    }
    {
#line 2470
    printf((char const   */* __restrict  */)"      Link Designator: \n");
#line 2471
    printf((char const   */* __restrict  */)"        Port Flag:            0x%02x\n",
           d___0->desig_port);
#line 2473
    printf((char const   */* __restrict  */)"        Interface:            0x%02x - ",
           d___0->desig_if);
    }
    {
#line 2477
    if (d___0->desig_if == 0U) {
#line 2477
      goto case_0___2;
    }
#line 2480
    if (d___0->desig_if == 1U) {
#line 2480
      goto case_1___2;
    }
#line 2483
    if (d___0->desig_if == 2U) {
#line 2483
      goto case_2___1;
    }
#line 2486
    if (d___0->desig_if == 3U) {
#line 2486
      goto case_3___0;
    }
#line 2489
    goto switch_default___3;
    case_0___2: /* CIL Label */ 
    {
#line 2478
    printf((char const   */* __restrict  */)"Base Interface\n");
    }
#line 2479
    goto switch_break___4;
    case_1___2: /* CIL Label */ 
    {
#line 2481
    printf((char const   */* __restrict  */)"Fabric Interface\n");
    }
#line 2482
    goto switch_break___4;
    case_2___1: /* CIL Label */ 
    {
#line 2484
    printf((char const   */* __restrict  */)"Update Channel\n");
    }
#line 2485
    goto switch_break___4;
    case_3___0: /* CIL Label */ 
    {
#line 2487
    printf((char const   */* __restrict  */)"Reserved\n");
    }
#line 2488
    goto switch_break___4;
    switch_default___3: /* CIL Label */ 
    {
#line 2490
    printf((char const   */* __restrict  */)"Invalid");
    }
#line 2491
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
    {
#line 2493
    printf((char const   */* __restrict  */)"        Channel Number:       0x%02x\n",
           d___0->desig_channel);
#line 2495
    printf((char const   */* __restrict  */)"\n");
#line 2382
    offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_link_desc ));
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 2498
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 2503
  printf((char const   */* __restrict  */)"    FRU_AMC_CURRENT\n");
#line 2505
  current = *(fru_data + offset);
#line 2506
  printf((char const   */* __restrict  */)"      Current draw(@12V): %.2f A [ %.2f Watt ]\n",
         (double )((float )current / 10.0f), (double )(((float )current / 10.0f) * 12.0f));
#line 2509
  printf((char const   */* __restrict  */)"\n");
  }
#line 2511
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 2514
  printf((char const   */* __restrict  */)"    FRU_AMC_ACTIVATION\n");
#line 2518
  max_current = (uint16_t )*(fru_data + offset);
#line 2519
  offset ++;
#line 2519
  max_current = (uint16_t )((int )max_current | ((int )*(fru_data + offset) << 8));
#line 2520
  printf((char const   */* __restrict  */)"      Maximum Internal Current(@12V): %.2f A [ %.2f Watt ]\n",
         (double )((float )max_current / 10.0f), (double )(((float )max_current / 10.0f) * 12.0f));
#line 2524
  offset ++;
#line 2524
  printf((char const   */* __restrict  */)"      Module Activation Readiness:    %i sec.\n",
         (int )*(fru_data + offset));
#line 2525
  offset ++;
#line 2525
  printf((char const   */* __restrict  */)"      Descriptor Count: %i\n", (int )*(fru_data + offset));
#line 2526
  printf((char const   */* __restrict  */)"\n");
#line 2528
  offset ++;
  }
  {
#line 2528
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 2528
    if (! (offset < off + length)) {
#line 2528
      goto while_break___9;
    }
    {
#line 2532
    a = (struct fru_picmgext_activation_record *)(fru_data + offset);
#line 2533
    printf((char const   */* __restrict  */)"        IPMB-Address:         0x%x\n",
           (int )a->ibmb_addr);
#line 2535
    printf((char const   */* __restrict  */)"        Max. Module Current:  %.2f A\n",
           (double )((float )a->max_module_curr / 10.0f));
#line 2537
    printf((char const   */* __restrict  */)"\n");
#line 2528
    offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_activation_record ));
    }
  }
  while_break___9: /* CIL Label */ ;
  }
#line 2540
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 2545
  printf((char const   */* __restrict  */)"    FRU_CARRIER_P2P\n");
  }
  {
#line 2546
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 2546
    if (! (offset < off + length)) {
#line 2546
      goto while_break___10;
    }
    {
#line 2547
    h___0 = (struct fru_picmgext_carrier_p2p_record *)(fru_data + offset);
#line 2549
    printf((char const   */* __restrict  */)"\n");
#line 2550
    printf((char const   */* __restrict  */)"      Resource ID:      %i", (int )h___0->resource_id & 7);
#line 2552
    printf((char const   */* __restrict  */)"  Type: ");
    }
#line 2553
    if ((int )h___0->resource_id >> 7 == 1) {
      {
#line 2554
      printf((char const   */* __restrict  */)"AMC\n");
      }
    } else {
      {
#line 2556
      printf((char const   */* __restrict  */)"Local\n");
      }
    }
    {
#line 2558
    printf((char const   */* __restrict  */)"      Descriptor Count: %i\n", (int )h___0->p2p_count);
#line 2560
    offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_carrier_p2p_record ));
#line 2561
    index___1 = (uint16_t )0;
    }
    {
#line 2561
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 2561
      if (! ((int )index___1 < (int )h___0->p2p_count)) {
#line 2561
        goto while_break___11;
      }
      {
#line 2566
      data___1[0] = *(fru_data + offset);
#line 2567
      data___1[1] = *(fru_data + (offset + 1));
#line 2568
      data___1[2] = *(fru_data + (offset + 2));
#line 2574
      desc = (struct fru_picmgext_carrier_p2p_descriptor *)(& data___1);
#line 2575
      printf((char const   */* __restrict  */)"        Port: %02d\t->  Remote Port: %02d\t",
             (int )desc->local_port, (int )desc->remote_port);
      }
#line 2577
      if ((int )desc->remote_resource_id >> 7 == 1) {
        {
#line 2578
        printf((char const   */* __restrict  */)"[ AMC   ID: %02d ]\n", (int )desc->remote_resource_id & 15);
        }
      } else {
        {
#line 2581
        printf((char const   */* __restrict  */)"[ local ID: %02d ]\n", (int )desc->remote_resource_id & 15);
        }
      }
#line 2584
      offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_carrier_p2p_descriptor ));
#line 2561
      index___1 = (uint16_t )((int )index___1 + 1);
    }
    while_break___11: /* CIL Label */ ;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
#line 2588
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 2595
  printf((char const   */* __restrict  */)"    FRU_AMC_P2P\n");
#line 2596
  guid_count = (int )*(fru_data + offset);
#line 2597
  printf((char const   */* __restrict  */)"      GUID count: %2d\n", guid_count);
#line 2598
  i = 0;
  }
  {
#line 2598
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 2598
    if (! (i < guid_count)) {
#line 2598
      goto while_break___12;
    }
    {
#line 2600
    printf((char const   */* __restrict  */)"        GUID %2d: ", i);
#line 2601
    j___1 = 0;
    }
    {
#line 2601
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 2601
      if (! ((unsigned long )j___1 < sizeof(struct fru_picmgext_guid ))) {
#line 2601
        goto while_break___13;
      }
      {
#line 2603
      printf((char const   */* __restrict  */)"%02x", (int )*(fru_data + (offset + j___1)));
#line 2604
      offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_guid ));
#line 2605
      printf((char const   */* __restrict  */)"\n");
#line 2601
      j___1 ++;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
#line 2607
    offset ++;
#line 2607
    h___1 = (struct fru_picmgext_amc_p2p_record *)(fru_data + offset);
#line 2608
    if (h___1->record_type) {
#line 2608
      tmp___12 = "AMC Module:";
    } else {
#line 2608
      tmp___12 = "On-Carrier Device";
    }
    {
#line 2608
    printf((char const   */* __restrict  */)"      %s", tmp___12);
#line 2611
    printf((char const   */* __restrict  */)"   Resource ID: %i\n", (int )h___1->resource_id);
#line 2612
    offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_amc_p2p_record ));
#line 2613
    tmp___13 = offset;
#line 2613
    offset ++;
#line 2613
    channel_count = *(fru_data + tmp___13);
#line 2614
    printf((char const   */* __restrict  */)"       Descriptor Count: %i\n", (int )channel_count);
#line 2616
    index___2 = 0U;
    }
    {
#line 2616
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 2616
      if (! (index___2 < (unsigned int )channel_count)) {
#line 2616
        goto while_break___14;
      }
      {
#line 2622
      data___2 = (unsigned int )(((int )*(fru_data + offset) | ((int )*(fru_data + (offset + 1)) << 8)) | ((int )*(fru_data + (offset + 2)) << 16));
#line 2625
      d___1 = (struct fru_picmgext_amc_channel_desc_record *)(& data___2);
#line 2626
      printf((char const   */* __restrict  */)"        Lane 0 Port: %i\n", d___1->lane0port);
#line 2628
      printf((char const   */* __restrict  */)"        Lane 1 Port: %i\n", d___1->lane1port);
#line 2630
      printf((char const   */* __restrict  */)"        Lane 2 Port: %i\n", d___1->lane2port);
#line 2632
      printf((char const   */* __restrict  */)"        Lane 3 Port: %i\n\n", d___1->lane3port);
#line 2634
      offset += 3;
#line 2616
      index___2 ++;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 2636
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 2636
      if (! (offset < off + length)) {
#line 2636
        goto while_break___15;
      }
#line 2639
      l = (struct fru_picmgext_amc_link_desc_record *)(& data___3[0]);
#line 2640
      data___3[0] = (unsigned int )((((int )*(fru_data + offset) | ((int )*(fru_data + (offset + 1)) << 8)) | ((int )*(fru_data + (offset + 2)) << 16)) | ((int )*(fru_data + (offset + 3)) << 24));
#line 2644
      data___3[1] = (unsigned int )*(fru_data + (offset + 4));
#line 2645
      if (l->port_flag_3) {
#line 2645
        tmp___14 = "o";
      } else {
#line 2645
        tmp___14 = "-";
      }
#line 2645
      if (l->port_flag_2) {
#line 2645
        tmp___15 = "o";
      } else {
#line 2645
        tmp___15 = "-";
      }
#line 2645
      if (l->port_flag_1) {
#line 2645
        tmp___16 = "o";
      } else {
#line 2645
        tmp___16 = "-";
      }
#line 2645
      if (l->port_flag_0) {
#line 2645
        tmp___17 = "o";
      } else {
#line 2645
        tmp___17 = "-";
      }
      {
#line 2645
      printf((char const   */* __restrict  */)"      Link Designator:  Channel ID: %i\n            Port Flag 0: %s%s%s%s\n",
             l->channel_id, tmp___17, tmp___16, tmp___15, tmp___14);
      }
      {
#line 2653
      if (l->type == 2U) {
#line 2653
        goto case_2___2;
      }
#line 2687
      if (l->type == 4U) {
#line 2687
        goto case_4___1;
      }
#line 2687
      if (l->type == 3U) {
#line 2687
        goto case_4___1;
      }
#line 2696
      if (l->type == 5U) {
#line 2696
        goto case_5___0;
      }
#line 2722
      if (l->type == 7U) {
#line 2722
        goto case_7___0;
      }
#line 2754
      if (l->type == 6U) {
#line 2754
        goto case_6;
      }
#line 2763
      goto switch_default___7;
      case_2___2: /* CIL Label */ 
      {
#line 2655
      printf((char const   */* __restrict  */)"        Link Type:       %02x - AMC.1 PCI Express\n",
             l->type);
      }
      {
#line 2658
      if (l->type_ext == 0U) {
#line 2658
        goto case_0___3;
      }
#line 2663
      if (l->type_ext == 1U) {
#line 2663
        goto case_1___3;
      }
#line 2668
      if (l->type_ext == 2U) {
#line 2668
        goto case_2___3;
      }
#line 2673
      if (l->type_ext == 3U) {
#line 2673
        goto case_3___1;
      }
#line 2678
      goto switch_default___4;
      case_0___3: /* CIL Label */ 
      {
#line 2659
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i -  Gen 1 capable - non SSC\n",
             l->type_ext);
      }
#line 2662
      goto switch_break___6;
      case_1___3: /* CIL Label */ 
      {
#line 2664
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i -  Gen 1 capable - SSC\n",
             l->type_ext);
      }
#line 2667
      goto switch_break___6;
      case_2___3: /* CIL Label */ 
      {
#line 2669
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i -  Gen 2 capable - non SSC\n",
             l->type_ext);
      }
#line 2672
      goto switch_break___6;
      case_3___1: /* CIL Label */ 
      {
#line 2674
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i -  Gen 2 capable - SSC\n",
             l->type_ext);
      }
#line 2677
      goto switch_break___6;
      switch_default___4: /* CIL Label */ 
      {
#line 2679
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i -  Invalid\n",
             l->type_ext);
      }
#line 2682
      goto switch_break___6;
      switch_break___6: /* CIL Label */ ;
      }
#line 2684
      goto switch_break___5;
      case_4___1: /* CIL Label */ 
      case_3___2: /* CIL Label */ 
      {
#line 2689
      printf((char const   */* __restrict  */)"        Link Type:       %02x - AMC.1 PCI Express Advanced Switching\n",
             l->type);
#line 2692
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i\n", l->type_ext);
      }
#line 2694
      goto switch_break___5;
      case_5___0: /* CIL Label */ 
      {
#line 2698
      printf((char const   */* __restrict  */)"        Link Type:       %02x - AMC.2 Ethernet\n",
             l->type);
      }
      {
#line 2702
      if (l->type_ext == 0U) {
#line 2702
        goto case_0___4;
      }
#line 2708
      if (l->type_ext == 1U) {
#line 2708
        goto case_1___4;
      }
#line 2714
      goto switch_default___5;
      case_0___4: /* CIL Label */ 
      {
#line 2703
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i -  1000Base-Bx (SerDES Gigabit) Ethernet Link\n",
             l->type_ext);
      }
#line 2706
      goto switch_break___7;
      case_1___4: /* CIL Label */ 
      {
#line 2709
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i -  10Gbit XAUI Ethernet Link\n",
             l->type_ext);
      }
#line 2712
      goto switch_break___7;
      switch_default___5: /* CIL Label */ 
      {
#line 2715
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i -  Invalid\n",
             l->type_ext);
      }
#line 2718
      goto switch_break___7;
      switch_break___7: /* CIL Label */ ;
      }
#line 2720
      goto switch_break___5;
      case_7___0: /* CIL Label */ 
      {
#line 2724
      printf((char const   */* __restrict  */)"        Link Type:       %02x - AMC.3 Storage\n",
             l->type);
      }
      {
#line 2728
      if (l->type_ext == 0U) {
#line 2728
        goto case_0___5;
      }
#line 2734
      if (l->type_ext == 1U) {
#line 2734
        goto case_1___5;
      }
#line 2740
      if (l->type_ext == 2U) {
#line 2740
        goto case_2___4;
      }
#line 2746
      goto switch_default___6;
      case_0___5: /* CIL Label */ 
      {
#line 2729
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i -  Fibre Channel\n",
             l->type_ext);
      }
#line 2732
      goto switch_break___8;
      case_1___5: /* CIL Label */ 
      {
#line 2735
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i -  Serial ATA\n",
             l->type_ext);
      }
#line 2738
      goto switch_break___8;
      case_2___4: /* CIL Label */ 
      {
#line 2741
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i -  Serial Attached SCSI\n",
             l->type_ext);
      }
#line 2744
      goto switch_break___8;
      switch_default___6: /* CIL Label */ 
      {
#line 2747
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i -  Invalid\n",
             l->type_ext);
      }
#line 2750
      goto switch_break___8;
      switch_break___8: /* CIL Label */ ;
      }
#line 2752
      goto switch_break___5;
      case_6: /* CIL Label */ 
      {
#line 2756
      printf((char const   */* __restrict  */)"        Link Type:       %02x - AMC.4 Serial Rapid IO\n",
             l->type);
#line 2759
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i\n", l->type_ext);
      }
#line 2761
      goto switch_break___5;
      switch_default___7: /* CIL Label */ 
      {
#line 2764
      printf((char const   */* __restrict  */)"        Link Type:       %02x - reserved or OEM GUID",
             l->type);
#line 2767
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i\n", l->type_ext);
      }
#line 2769
      goto switch_break___5;
      switch_break___5: /* CIL Label */ ;
      }
      {
#line 2772
      printf((char const   */* __restrict  */)"        Link group Id:   %i\n", l->group_id);
#line 2774
      printf((char const   */* __restrict  */)"        Link Asym Match: %i\n\n", l->asym_match);
#line 2776
      offset += 5;
      }
    }
    while_break___15: /* CIL Label */ ;
    }
#line 2598
    i ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 2780
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 2787
  printf((char const   */* __restrict  */)"    FRU_CARRIER_INFO\n");
#line 2789
  tmp___18 = offset;
#line 2789
  offset ++;
#line 2789
  extVersion = *(fru_data + tmp___18);
#line 2790
  tmp___19 = offset;
#line 2790
  offset ++;
#line 2790
  siteCount = *(fru_data + tmp___19);
#line 2792
  printf((char const   */* __restrict  */)"      AMC.0 extension version: R%d.%d\n",
         (int )extVersion & 15, ((int )extVersion >> 4) & 15);
#line 2795
  printf((char const   */* __restrict  */)"      Carrier Sie Number Cnt: %d\n", (int )siteCount);
#line 2797
  i = 0;
  }
  {
#line 2797
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 2797
    if (! (i < (int )siteCount)) {
#line 2797
      goto while_break___16;
    }
    {
#line 2798
    tmp___20 = offset;
#line 2798
    offset ++;
#line 2798
    printf((char const   */* __restrict  */)"       Site ID: %i \n", (int )*(fru_data + tmp___20));
#line 2797
    i ++;
    }
  }
  while_break___16: /* CIL Label */ ;
  }
  {
#line 2800
  printf((char const   */* __restrict  */)"\n");
  }
#line 2802
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 2808
  printf((char const   */* __restrict  */)"    FRU_PICMG_CLK_CARRIER_P2P\n");
#line 2810
  tmp___21 = offset;
#line 2810
  offset ++;
#line 2810
  desc_count = *(fru_data + tmp___21);
#line 2812
  i___3 = 0;
  }
  {
#line 2812
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 2812
    if (! (i___3 < (int )desc_count)) {
#line 2812
      goto while_break___17;
    }
    {
#line 2816
    tmp___22 = offset;
#line 2816
    offset ++;
#line 2816
    resource_id = *(fru_data + tmp___22);
#line 2817
    tmp___23 = offset;
#line 2817
    offset ++;
#line 2817
    channel_count___0 = *(fru_data + tmp___23);
#line 2819
    printf((char const   */* __restrict  */)"\n");
#line 2820
    printf((char const   */* __restrict  */)"      Clock Resource ID: 0x%02x  Type: ",
           (int )resource_id);
    }
#line 2821
    if (((int )resource_id & 192) >> 6 == 0) {
      {
#line 2821
      printf((char const   */* __restrict  */)"On-Carrier-Device\n");
      }
    } else
#line 2822
    if (((int )resource_id & 192) >> 6 == 1) {
      {
#line 2822
      printf((char const   */* __restrict  */)"AMC slot\n");
      }
    } else
#line 2823
    if (((int )resource_id & 192) >> 6 == 2) {
      {
#line 2823
      printf((char const   */* __restrict  */)"Backplane\n");
      }
    } else {
      {
#line 2824
      printf((char const   */* __restrict  */)"reserved\n");
      }
    }
    {
#line 2825
    printf((char const   */* __restrict  */)"      Channel Count: 0x%02x\n", (int )channel_count___0);
#line 2827
    j___2 = 0;
    }
    {
#line 2827
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 2827
      if (! (j___2 < (int )channel_count___0)) {
#line 2827
        goto while_break___18;
      }
      {
#line 2830
      tmp___24 = offset;
#line 2830
      offset ++;
#line 2830
      loc_channel = *(fru_data + tmp___24);
#line 2831
      tmp___25 = offset;
#line 2831
      offset ++;
#line 2831
      rem_channel = *(fru_data + tmp___25);
#line 2832
      tmp___26 = offset;
#line 2832
      offset ++;
#line 2832
      rem_resource = *(fru_data + tmp___26);
#line 2834
      printf((char const   */* __restrict  */)"        CLK-ID: 0x%02x    ->", (int )loc_channel);
#line 2835
      printf((char const   */* __restrict  */)" remote CLKID: 0x%02x   ", (int )rem_channel);
      }
#line 2836
      if (((int )rem_resource & 192) >> 6 == 0) {
        {
#line 2836
        printf((char const   */* __restrict  */)"[ Carrier-Dev");
        }
      } else
#line 2837
      if (((int )rem_resource & 192) >> 6 == 1) {
        {
#line 2837
        printf((char const   */* __restrict  */)"[ AMC slot   ");
        }
      } else
#line 2838
      if (((int )rem_resource & 192) >> 6 == 2) {
        {
#line 2838
        printf((char const   */* __restrict  */)"[ Backplane  ");
        }
      } else {
        {
#line 2839
        printf((char const   */* __restrict  */)"reserved         ");
        }
      }
      {
#line 2840
      printf((char const   */* __restrict  */)" 0x%02x ]\n", (int )rem_resource & 15);
#line 2827
      j___2 ++;
      }
    }
    while_break___18: /* CIL Label */ ;
    }
#line 2812
    i___3 ++;
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 2843
  printf((char const   */* __restrict  */)"\n");
  }
#line 2845
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 2851
  printf((char const   */* __restrict  */)"    FRU_PICMG_CLK_CONFIG\n");
#line 2853
  tmp___27 = offset;
#line 2853
  offset ++;
#line 2853
  resource_id___0 = *(fru_data + tmp___27);
#line 2854
  tmp___28 = offset;
#line 2854
  offset ++;
#line 2854
  descr_count = *(fru_data + tmp___28);
#line 2856
  printf((char const   */* __restrict  */)"\n");
#line 2857
  printf((char const   */* __restrict  */)"      Clock Resource ID: 0x%02x\n", (int )resource_id___0);
#line 2858
  printf((char const   */* __restrict  */)"      Descr. Count:      0x%02x\n", (int )descr_count);
#line 2860
  i___4 = 0;
  }
  {
#line 2860
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 2860
    if (! (i___4 < (int )descr_count)) {
#line 2860
      goto while_break___19;
    }
    {
#line 2864
    tmp___29 = offset;
#line 2864
    offset ++;
#line 2864
    channel_id = *(fru_data + tmp___29);
#line 2865
    tmp___30 = offset;
#line 2865
    offset ++;
#line 2865
    control = *(fru_data + tmp___30);
#line 2866
    printf((char const   */* __restrict  */)"        CLK-ID: 0x%02x  -  ", (int )channel_id);
    }
#line 2867
    if (((int )control & 1) == 0) {
#line 2867
      tmp___31 = "Carrier IPMC";
    } else {
#line 2867
      tmp___31 = "Application";
    }
    {
#line 2867
    printf((char const   */* __restrict  */)"CTRL 0x%02x [ %12s ]\n", (int )control,
           tmp___31);
#line 2871
    tmp___32 = offset;
#line 2871
    offset ++;
#line 2871
    indirect_cnt = *(fru_data + tmp___32);
#line 2872
    tmp___33 = offset;
#line 2872
    offset ++;
#line 2872
    direct_cnt = *(fru_data + tmp___33);
#line 2873
    printf((char const   */* __restrict  */)"         Cnt: Indirect 0x%02x  /  Direct 0x%02x\n",
           (int )indirect_cnt, (int )direct_cnt);
#line 2878
    j___3 = 0;
    }
    {
#line 2878
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 2878
      if (! (j___3 < (int )indirect_cnt)) {
#line 2878
        goto while_break___20;
      }
#line 2882
      tmp___34 = offset;
#line 2882
      offset ++;
#line 2882
      feature = *(fru_data + tmp___34);
#line 2883
      tmp___35 = offset;
#line 2883
      offset ++;
#line 2883
      dep_chn_id = *(fru_data + tmp___35);
#line 2885
      if (((int )feature & 1) == 1) {
#line 2885
        tmp___36 = "Source";
      } else {
#line 2885
        tmp___36 = "Receiver";
      }
      {
#line 2885
      printf((char const   */* __restrict  */)"          Feature: 0x%02x [%8s] - ",
             (int )feature, tmp___36);
#line 2886
      printf((char const   */* __restrict  */)"          Dep. CLK-ID: 0x%02x\n", (int )dep_chn_id);
#line 2878
      j___3 ++;
      }
    }
    while_break___20: /* CIL Label */ ;
    }
#line 2890
    j___3 = 0;
    {
#line 2890
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 2890
      if (! (j___3 < (int )direct_cnt)) {
#line 2890
        goto while_break___21;
      }
#line 2894
      tmp___37 = offset;
#line 2894
      offset ++;
#line 2894
      feature___0 = *(fru_data + tmp___37);
#line 2895
      tmp___38 = offset;
#line 2895
      offset ++;
#line 2895
      family = *(fru_data + tmp___38);
#line 2896
      tmp___39 = offset;
#line 2896
      offset ++;
#line 2896
      accuracy = *(fru_data + tmp___39);
#line 2897
      freq = (unsigned int )((((int )*(fru_data + offset) | ((int )*(fru_data + (offset + 1)) << 8)) | ((int )*(fru_data + (offset + 2)) << 16)) | ((int )*(fru_data + (offset + 3)) << 24));
#line 2899
      offset += 4;
#line 2900
      min_freq = (unsigned int )((((int )*(fru_data + offset) | ((int )*(fru_data + (offset + 1)) << 8)) | ((int )*(fru_data + (offset + 2)) << 16)) | ((int )*(fru_data + (offset + 3)) << 24));
#line 2902
      offset += 4;
#line 2903
      max_freq = (unsigned int )((((int )*(fru_data + offset) | ((int )*(fru_data + (offset + 1)) << 8)) | ((int )*(fru_data + (offset + 2)) << 16)) | ((int )*(fru_data + (offset + 3)) << 24));
#line 2905
      offset += 4;
#line 2907
      if ((int )feature___0 & 1) {
#line 2907
        tmp___40 = "Source";
      } else {
#line 2907
        tmp___40 = "Receiver";
      }
      {
#line 2907
      printf((char const   */* __restrict  */)"          - Feature: 0x%02x  - PLL: %x / Asym: %s\n",
             (int )feature___0, ((int )feature___0 > 1) & 1, tmp___40);
#line 2911
      printf((char const   */* __restrict  */)"            Family:  0x%02x  - AccLVL: 0x%02x\n",
             (int )family, (int )accuracy);
#line 2912
      printf((char const   */* __restrict  */)"            FRQ: %-9ld - min: %-9ld - max: %-9ld\n",
             freq, min_freq, max_freq);
#line 2890
      j___3 ++;
      }
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 2915
    printf((char const   */* __restrict  */)"\n");
#line 2860
    i___4 ++;
    }
  }
  while_break___19: /* CIL Label */ ;
  }
  {
#line 2917
  printf((char const   */* __restrict  */)"\n");
  }
#line 2919
  goto switch_break;
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_32: /* CIL Label */ 
  {
#line 2933
  printf((char const   */* __restrict  */)"    Not implemented yet. uTCA specific record found!!\n");
#line 2934
  printf((char const   */* __restrict  */)"     - Record ID: 0x%02x\n", (int )h->record_id);
  }
#line 2935
  goto switch_break;
  switch_default___8: /* CIL Label */ 
  {
#line 2938
  printf((char const   */* __restrict  */)"    Unknown OEM Extension Record ID: %x\n",
         (int )h->record_id);
  }
#line 2939
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2942
  return;
}
}
#line 2954 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int __ipmi_fru_print(struct ipmi_intf *intf , uint8_t id ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct fru_info fru ;
  struct fru_header header ;
  uint8_t msg_data[4] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 2963
  memset((void *)(& fru), 0, sizeof(struct fru_info ));
#line 2964
  memset((void *)(& header), 0, sizeof(struct fru_header ));
#line 2969
  memset((void *)(msg_data), 0, (size_t )4);
#line 2970
  msg_data[0] = id;
#line 2972
  memset((void *)(& req), 0, sizeof(req));
#line 2973
  req.msg.netfn = (uint8_t )10;
#line 2974
  req.msg.cmd = (uint8_t )16;
#line 2975
  req.msg.data = msg_data;
#line 2976
  req.msg.data_len = (uint16_t )1;
#line 2978
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2979
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2980
    printf((char const   */* __restrict  */)" Device not present (No Response)\n");
    }
#line 2981
    return (-1);
  }
#line 2983
  if ((int )rsp->ccode > 0) {
    {
#line 2984
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2984
    printf((char const   */* __restrict  */)" Device not present (%s)\n", tmp);
    }
#line 2986
    return (-1);
  }
#line 2989
  fru.size = (uint16_t )(((int )rsp->data[1] << 8) | (int )rsp->data[0]);
#line 2990
  fru.access = (uint8_t )((int )rsp->data[2] & 1);
#line 2992
  if (fru.access) {
#line 2992
    tmp___0 = "words";
  } else {
#line 2992
    tmp___0 = "bytes";
  }
  {
#line 2992
  lprintf(7, "fru.size = %d bytes (accessed by %s)", (int )fru.size, tmp___0);
  }
#line 2995
  if ((int )fru.size < 1) {
    {
#line 2996
    lprintf(3, " Invalid FRU size %d", (int )fru.size);
    }
#line 2997
    return (-1);
  }
  {
#line 3003
  msg_data[0] = id;
#line 3004
  msg_data[1] = (uint8_t )0;
#line 3005
  msg_data[2] = (uint8_t )0;
#line 3006
  msg_data[3] = (uint8_t )8;
#line 3008
  memset((void *)(& req), 0, sizeof(req));
#line 3009
  req.msg.netfn = (uint8_t )10;
#line 3010
  req.msg.cmd = (uint8_t )17;
#line 3011
  req.msg.data = msg_data;
#line 3012
  req.msg.data_len = (uint16_t )4;
#line 3014
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 3015
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 3016
    printf((char const   */* __restrict  */)" Device not present (No Response)\n");
    }
#line 3017
    return (1);
  }
#line 3019
  if ((int )rsp->ccode > 0) {
    {
#line 3020
    tmp___1 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3020
    printf((char const   */* __restrict  */)" Device not present (%s)\n", tmp___1);
    }
#line 3022
    return (1);
  }
#line 3025
  if (verbose > 1) {
    {
#line 3026
    printbuf((uint8_t const   *)(rsp->data), rsp->data_len, "FRU DATA");
    }
  }
  {
#line 3028
  memcpy((void */* __restrict  */)(& header), (void const   */* __restrict  */)(rsp->data + 1),
         (size_t )8);
  }
#line 3030
  if ((int )header.version != 1) {
    {
#line 3031
    lprintf(3, " Unknown FRU header version 0x%02x", (int )header.version);
    }
#line 3033
    return (-1);
  }
  {
#line 3041
  lprintf(7, "fru.header.version:         0x%x", (int )header.version);
#line 3043
  lprintf(7, "fru.header.offset.internal: 0x%x", (int )header.offset.internal * 8);
#line 3045
  lprintf(7, "fru.header.offset.chassis:  0x%x", (int )header.offset.chassis * 8);
#line 3047
  lprintf(7, "fru.header.offset.board:    0x%x", (int )header.offset.board * 8);
#line 3049
  lprintf(7, "fru.header.offset.product:  0x%x", (int )header.offset.product * 8);
#line 3051
  lprintf(7, "fru.header.offset.multi:    0x%x", (int )header.offset.multi * 8);
  }
#line 3059
  if ((unsigned long )((int )header.offset.chassis * 8) >= sizeof(struct fru_header )) {
    {
#line 3060
    fru_area_print_chassis(intf, & fru, id, (uint32_t )((int )header.offset.chassis * 8));
    }
  }
#line 3063
  if ((unsigned long )((int )header.offset.board * 8) >= sizeof(struct fru_header )) {
    {
#line 3064
    fru_area_print_board(intf, & fru, id, (uint32_t )((int )header.offset.board * 8));
    }
  }
#line 3067
  if ((unsigned long )((int )header.offset.product * 8) >= sizeof(struct fru_header )) {
    {
#line 3068
    fru_area_print_product(intf, & fru, id, (uint32_t )((int )header.offset.product * 8));
    }
  }
#line 3071
  if (verbose == 0) {
#line 3072
    return (0);
  }
#line 3074
  if ((unsigned long )((int )header.offset.multi * 8) >= sizeof(struct fru_header )) {
    {
#line 3075
    fru_area_print_multirec(intf, & fru, id, (uint32_t )((int )header.offset.multi * 8));
    }
  }
#line 3077
  return (0);
}
}
#line 3147
int ipmi_spd_print_fru(struct ipmi_intf *intf , uint8_t id ) ;
#line 3087 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
int ipmi_fru_print(struct ipmi_intf *intf , struct sdr_record_fru_locator *fru ) 
{ 
  char desc[17] ;
  uint32_t save_addr ;
  uint32_t save_channel ;
  int rc ;
  int tmp ;

  {
#line 3091
  save_addr = (uint32_t )0;
#line 3093
  rc = 0;
#line 3095
  if ((unsigned long )fru == (unsigned long )((void *)0)) {
    {
#line 3096
    tmp = __ipmi_fru_print(intf, (uint8_t )0);
    }
#line 3096
    return (tmp);
  }
#line 3115
  if ((int )fru->dev_type != 16) {
#line 3115
    if ((int )fru->dev_type_modifier != 2) {
#line 3118
      return (-1);
    } else
#line 3115
    if ((int )fru->dev_type < 8) {
#line 3118
      return (-1);
    } else
#line 3115
    if ((int )fru->dev_type > 15) {
#line 3118
      return (-1);
    }
  }
#line 3120
  if ((int )fru->dev_slave_addr == 32) {
#line 3120
    if ((int )fru->device_id == 0) {
#line 3122
      return (0);
    }
  }
  {
#line 3124
  memset((void *)(desc), 0, sizeof(desc));
#line 3125
  memcpy((void */* __restrict  */)(desc), (void const   */* __restrict  */)(fru->id_string),
         (size_t )((int )fru->id_code & 31));
#line 3126
  desc[(int )fru->id_code & 31] = (char)0;
#line 3127
  printf((char const   */* __restrict  */)"FRU Device Description : %s (ID %d)\n",
         desc, (int )fru->device_id);
  }
  {
#line 3131
  if ((int )fru->dev_type_modifier == 2) {
#line 3131
    goto case_2;
  }
#line 3131
  if ((int )fru->dev_type_modifier == 0) {
#line 3131
    goto case_2;
  }
#line 3146
  if ((int )fru->dev_type_modifier == 1) {
#line 3146
    goto case_1;
  }
#line 3149
  goto switch_default;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 3132
  if ((int )fru->channel_num == 0) {
#line 3132
    if (intf->target_ipmb_addr) {
#line 3132
      if (! ((int )intf->target_ipmb_addr == (int )fru->dev_slave_addr)) {
#line 3132
        goto _L___0;
      }
    } else {
#line 3132
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 3132
  if ((uint32_t )fru->dev_slave_addr == intf->target_addr) {
#line 3132
    if (! ((int )fru->channel_num == (int )intf->target_channel)) {
#line 3134
      save_addr = intf->target_addr;
#line 3135
      intf->target_addr = (uint32_t )fru->dev_slave_addr;
#line 3136
      save_channel = (uint32_t )intf->target_channel;
#line 3137
      intf->target_channel = fru->channel_num;
    }
  } else {
#line 3134
    save_addr = intf->target_addr;
#line 3135
    intf->target_addr = (uint32_t )fru->dev_slave_addr;
#line 3136
    save_channel = (uint32_t )intf->target_channel;
#line 3137
    intf->target_channel = fru->channel_num;
  }
  {
#line 3140
  rc = __ipmi_fru_print(intf, fru->device_id);
  }
#line 3141
  if (save_addr) {
#line 3142
    intf->target_addr = save_addr;
#line 3143
    intf->target_channel = (uint8_t )save_channel;
  }
#line 3145
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 3147
  rc = ipmi_spd_print_fru(intf, (int )fru->device_id);
  }
#line 3148
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3150
  if (verbose) {
    {
#line 3151
    printf((char const   */* __restrict  */)" Unsupported device 0x%02x type 0x%02x with modifier 0x%02x\n",
           (int )fru->device_id, (int )fru->dev_type, (int )fru->dev_type_modifier);
    }
  } else {
    {
#line 3156
    printf((char const   */* __restrict  */)" Unsupported device\n");
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 3158
  printf((char const   */* __restrict  */)"\n");
  }
#line 3160
  return (rc);
}
}
#line 3169 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_print_all(struct ipmi_intf *intf ) 
{ 
  struct ipmi_sdr_iterator *itr ;
  struct sdr_get_rs *header ;
  struct sdr_record_fru_locator *fru ;
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct ipm_devid_rsp *devid ;
  struct sdr_record_mc_locator *mc ;
  uint32_t save_addr ;
  char const   *tmp ;
  uint8_t *tmp___0 ;
  uint8_t *tmp___1 ;

  {
  {
#line 3182
  printf((char const   */* __restrict  */)"FRU Device Description : Builtin FRU Device (ID 0)\n");
#line 3186
  memset((void *)(& req), 0, sizeof(req));
#line 3187
  req.msg.netfn = (uint8_t )6;
#line 3188
  req.msg.cmd = (uint8_t )1;
#line 3189
  req.msg.data_len = (uint16_t )0;
#line 3191
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 3192
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 3193
    lprintf(3, "Get Device ID command failed");
    }
#line 3194
    return (-1);
  }
#line 3196
  if ((int )rsp->ccode > 0) {
    {
#line 3197
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3197
    lprintf(3, "Get Device ID command failed: %s", tmp);
    }
#line 3199
    return (-1);
  }
#line 3202
  devid = (struct ipm_devid_rsp *)(rsp->data);
#line 3207
  if ((int )devid->adtl_device_support & 8) {
    {
#line 3208
    rc = ipmi_fru_print(intf, (struct sdr_record_fru_locator *)((void *)0));
#line 3209
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 3212
  itr = ipmi_sdr_start(intf, 0);
  }
#line 3212
  if ((unsigned long )itr == (unsigned long )((void *)0)) {
#line 3213
    return (-1);
  }
  {
#line 3219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3219
    header = ipmi_sdr_get_next_header(intf, itr);
    }
#line 3219
    if (! ((unsigned long )header != (unsigned long )((void *)0))) {
#line 3219
      goto while_break;
    }
#line 3221
    if ((int )header->type == 18) {
      {
#line 3223
      tmp___0 = ipmi_sdr_get_record(intf, header, itr);
#line 3223
      mc = (struct sdr_record_mc_locator *)tmp___0;
      }
#line 3226
      if (mc) {
#line 3226
        if ((int )mc->dev_support & 8) {
          {
#line 3231
          save_addr = intf->target_addr;
#line 3234
          intf->target_addr = (uint32_t )mc->dev_slave_addr;
#line 3236
          printf((char const   */* __restrict  */)"FRU Device Description : %-16s\n",
                 mc->id_string);
#line 3240
          rc = __ipmi_fru_print(intf, (uint8_t )0);
#line 3242
          printf((char const   */* __restrict  */)"\n");
#line 3245
          intf->target_addr = save_addr;
          }
        }
      }
#line 3248
      if (mc) {
        {
#line 3249
        free((void *)mc);
#line 3250
        mc = (struct sdr_record_mc_locator *)((void *)0);
        }
      }
#line 3253
      goto while_continue;
    }
#line 3256
    if ((int )header->type != 17) {
#line 3257
      goto while_continue;
    }
    {
#line 3260
    tmp___1 = ipmi_sdr_get_record(intf, header, itr);
#line 3260
    fru = (struct sdr_record_fru_locator *)tmp___1;
    }
#line 3262
    if ((unsigned long )fru == (unsigned long )((void *)0)) {
#line 3262
      goto _L;
    } else
#line 3262
    if (! fru->logical) {
      _L: /* CIL Label */ 
#line 3263
      if (fru) {
        {
#line 3264
        free((void *)fru);
#line 3265
        fru = (struct sdr_record_fru_locator *)((void *)0);
        }
      }
#line 3267
      goto while_continue;
    }
    {
#line 3269
    rc = ipmi_fru_print(intf, fru);
#line 3270
    free((void *)fru);
#line 3271
    fru = (struct sdr_record_fru_locator *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3274
  ipmi_sdr_end(intf, itr);
  }
#line 3276
  return (rc);
}
}
#line 3283 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
void ipmi_fru_read_help(void) 
{ 


  {
  {
#line 3286
  lprintf(5, "fru read <fru id> <fru file>");
#line 3287
  lprintf(5, "Note: FRU ID and file(incl. full path) must be specified.");
#line 3288
  lprintf(5, "Example: ipmitool fru read 0 /root/fru.bin");
  }
#line 3289
  return;
}
}
#line 3291 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static void ipmi_fru_read_to_bin(struct ipmi_intf *intf , char *pFileName , uint8_t fruId ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct fru_info fru ;
  uint8_t msg_data[4] ;
  uint8_t *pFruBuf ;
  void *tmp ;
  FILE *pFile ;

  {
  {
#line 3302
  msg_data[0] = fruId;
#line 3304
  memset((void *)(& req), 0, sizeof(req));
#line 3305
  req.msg.netfn = (uint8_t )10;
#line 3306
  req.msg.cmd = (uint8_t )16;
#line 3307
  req.msg.data = msg_data;
#line 3308
  req.msg.data_len = (uint16_t )1;
#line 3310
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 3311
  if (! rsp) {
#line 3312
    return;
  }
#line 3314
  if ((int )rsp->ccode > 0) {
#line 3315
    if ((int )rsp->ccode == 195) {
      {
#line 3316
      printf((char const   */* __restrict  */)"  Timeout accessing FRU info. (Device not present?)\n");
      }
    }
#line 3317
    return;
  }
#line 3319
  fru.size = (uint16_t )(((int )rsp->data[1] << 8) | (int )rsp->data[0]);
#line 3320
  fru.access = (uint8_t )((int )rsp->data[2] & 1);
#line 3322
  if (verbose) {
    {
#line 3323
    printf((char const   */* __restrict  */)"Fru Size   = %d bytes\n", (int )fru.size);
#line 3324
    printf((char const   */* __restrict  */)"Fru Access = %xh\n", (int )fru.access);
    }
  }
  {
#line 3327
  tmp = malloc((size_t )fru.size);
#line 3327
  pFruBuf = (uint8_t *)tmp;
  }
#line 3328
  if ((unsigned long )pFruBuf != (unsigned long )((void *)0)) {
    {
#line 3329
    printf((char const   */* __restrict  */)"Fru Size         : %d bytes\n", (int )fru.size);
#line 3330
    read_fru_area(intf, & fru, fruId, (uint32_t )0, (uint32_t )fru.size, pFruBuf);
    }
  } else {
    {
#line 3332
    lprintf(3, "Cannot allocate %d bytes\n", (int )fru.size);
    }
#line 3333
    return;
  }
#line 3336
  if ((unsigned long )pFruBuf != (unsigned long )((void *)0)) {
    {
#line 3339
    pFile = fopen((char const   */* __restrict  */)pFileName, (char const   */* __restrict  */)"wb");
    }
#line 3340
    if (pFile) {
      {
#line 3341
      fwrite((void const   */* __restrict  */)pFruBuf, (size_t )fru.size, (size_t )1,
             (FILE */* __restrict  */)pFile);
#line 3342
      printf((char const   */* __restrict  */)"Done\n");
      }
    } else {
      {
#line 3344
      lprintf(3, "Error opening file %s\n", pFileName);
#line 3345
      free((void *)pFruBuf);
#line 3346
      pFruBuf = (uint8_t *)((void *)0);
      }
#line 3347
      return;
    }
    {
#line 3349
    fclose(pFile);
    }
  }
  {
#line 3351
  free((void *)pFruBuf);
#line 3352
  pFruBuf = (uint8_t *)((void *)0);
  }
#line 3353
  return;
}
}
#line 3355 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static void ipmi_fru_write_from_bin(struct ipmi_intf *intf , char *pFileName , uint8_t fruId ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct fru_info fru ;
  uint8_t msg_data[4] ;
  uint8_t *pFruBuf ;
  uint16_t len ;
  FILE *pFile ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 3365
  len = (uint16_t )0;
#line 3368
  msg_data[0] = fruId;
#line 3370
  memset((void *)(& req), 0, sizeof(req));
#line 3371
  req.msg.netfn = (uint8_t )10;
#line 3372
  req.msg.cmd = (uint8_t )16;
#line 3373
  req.msg.data = msg_data;
#line 3374
  req.msg.data_len = (uint16_t )1;
#line 3376
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 3377
  if (! rsp) {
#line 3378
    return;
  }
#line 3380
  if (rsp->ccode) {
#line 3381
    if ((int )rsp->ccode == 195) {
      {
#line 3382
      printf((char const   */* __restrict  */)"  Timeout accessing FRU info. (Device not present?)\n");
      }
    }
#line 3383
    return;
  }
#line 3385
  fru.size = (uint16_t )(((int )rsp->data[1] << 8) | (int )rsp->data[0]);
#line 3386
  fru.access = (uint8_t )((int )rsp->data[2] & 1);
#line 3388
  if (verbose) {
    {
#line 3389
    printf((char const   */* __restrict  */)"Fru Size   = %d bytes\n", (int )fru.size);
#line 3390
    printf((char const   */* __restrict  */)"Fru Access = %xh\n", (int )fru.access);
    }
  }
  {
#line 3393
  tmp = malloc((size_t )fru.size);
#line 3393
  pFruBuf = (uint8_t *)tmp;
  }
#line 3394
  if ((unsigned long )pFruBuf == (unsigned long )((void *)0)) {
    {
#line 3395
    lprintf(3, "Cannot allocate %d bytes\n", (int )fru.size);
    }
#line 3396
    return;
  }
  {
#line 3399
  pFile = fopen((char const   */* __restrict  */)pFileName, (char const   */* __restrict  */)"rb");
  }
#line 3400
  if ((unsigned long )pFile != (unsigned long )((void *)0)) {
    {
#line 3401
    tmp___0 = fread((void */* __restrict  */)pFruBuf, (size_t )1, (size_t )fru.size,
                    (FILE */* __restrict  */)pFile);
#line 3401
    len = (uint16_t )tmp___0;
#line 3402
    printf((char const   */* __restrict  */)"Fru Size         : %d bytes\n", (int )fru.size);
#line 3403
    printf((char const   */* __restrict  */)"Size to Write    : %d bytes\n", (int )len);
#line 3404
    fclose(pFile);
    }
  } else {
    {
#line 3406
    lprintf(3, "Error opening file %s\n", pFileName);
    }
  }
#line 3409
  if ((int )len != 0) {
    {
#line 3410
    write_fru_area(intf, & fru, fruId, (uint16_t )0, (uint16_t )0, len, pFruBuf);
#line 3411
    lprintf(6, "Done");
    }
  }
  {
#line 3414
  free((void *)pFruBuf);
#line 3415
  pFruBuf = (uint8_t *)((void *)0);
  }
#line 3416
  return;
}
}
#line 3422 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
void ipmi_fru_write_help(void) 
{ 


  {
  {
#line 3425
  lprintf(5, "fru write <fru id> <fru file>");
#line 3426
  lprintf(5, "Note: FRU ID and file(incl. full path) must be specified.");
#line 3427
  lprintf(5, "Example: ipmitool fru write 0 /root/fru.bin");
  }
#line 3428
  return;
}
}
#line 3434 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
void ipmi_fru_edit_help(void) 
{ 


  {
  {
#line 3437
  lprintf(5, "fru edit <fruid> field <section> <index> <string> - edit FRU string");
#line 3439
  lprintf(5, "fru edit <fruid> oem iana <record> <format> <args> - limited OEM support");
  }
#line 3441
  return;
}
}
#line 3452 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_edit_multirec(struct ipmi_intf *intf , uint8_t id , int argc ,
                                  char **argv ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct fru_info fru ;
  struct fru_header header ;
  uint8_t msg_data[4] ;
  uint16_t retStatus ;
  uint32_t offFruMultiRec ;
  uint32_t fruMultiRecSize ;
  struct fru_info fruInfo ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  uint8_t *fru_data ;
  uint32_t fru_len ;
  uint32_t i ;
  uint32_t offset ;
  struct fru_multirec_header *h ;
  uint32_t last_off ;
  uint32_t len ;
  uint8_t error ;
  void *tmp___2 ;
  int tmp___3 ;
  struct fru_multirec_oem_header *oh ;
  uint32_t iana ;
  uint32_t suppliedIana ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 3463
  retStatus = (uint16_t )0;
#line 3465
  fruMultiRecSize = (uint32_t )0;
#line 3467
  tmp = ipmi_fru_get_multirec_location_from_fru(intf, id, & fruInfo, & offFruMultiRec,
                                                & fruMultiRecSize);
#line 3467
  retStatus = (uint16_t )tmp;
#line 3472
  lprintf(7, "FRU Size        : %lu\n", fruMultiRecSize);
#line 3473
  lprintf(7, "Multi Rec offset: %lu\n", offFruMultiRec);
#line 3478
  memset((void *)(& fru), 0, sizeof(struct fru_info ));
#line 3479
  memset((void *)(& header), 0, sizeof(struct fru_header ));
#line 3484
  memset((void *)(msg_data), 0, (size_t )4);
#line 3485
  msg_data[0] = id;
#line 3487
  memset((void *)(& req), 0, sizeof(req));
#line 3488
  req.msg.netfn = (uint8_t )10;
#line 3489
  req.msg.cmd = (uint8_t )16;
#line 3490
  req.msg.data = msg_data;
#line 3491
  req.msg.data_len = (uint16_t )1;
#line 3493
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 3494
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 3495
    printf((char const   */* __restrict  */)" Device not present (No Response)\n");
    }
#line 3496
    return (-1);
  }
#line 3498
  if ((int )rsp->ccode > 0) {
    {
#line 3499
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3499
    printf((char const   */* __restrict  */)" Device not present (%s)\n", tmp___0);
    }
#line 3501
    return (-1);
  }
#line 3504
  fru.size = (uint16_t )(((int )rsp->data[1] << 8) | (int )rsp->data[0]);
#line 3505
  fru.access = (uint8_t )((int )rsp->data[2] & 1);
#line 3507
  if (fru.access) {
#line 3507
    tmp___1 = "words";
  } else {
#line 3507
    tmp___1 = "bytes";
  }
  {
#line 3507
  lprintf(7, "fru.size = %d bytes (accessed by %s)", (int )fru.size, tmp___1);
  }
#line 3510
  if ((int )fru.size < 1) {
    {
#line 3511
    lprintf(3, " Invalid FRU size %d", (int )fru.size);
    }
#line 3512
    return (-1);
  }
  {
#line 3519
  offset = offFruMultiRec;
#line 3522
  error = (uint8_t )0;
#line 3524
  last_off = offset;
#line 3524
  i = last_off;
#line 3525
  fru_len = (uint32_t )0;
#line 3527
  tmp___2 = malloc((size_t )((int )fru.size + 1));
#line 3527
  fru_data = (uint8_t *)tmp___2;
  }
#line 3528
  if ((unsigned long )fru_data == (unsigned long )((void *)0)) {
    {
#line 3529
    lprintf(3, " Out of memory!");
    }
#line 3530
    return (-1);
  }
  {
#line 3532
  memset((void *)fru_data, 0, (size_t )((int )fru.size + 1));
  }
  {
#line 3534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3535
    h = (struct fru_multirec_header *)(fru_data + i);
#line 3538
    if ((unsigned long )last_off < (unsigned long )i + sizeof(*h)) {
#line 3538
      goto _L;
    } else
#line 3538
    if (last_off < i + (uint32_t )h->len) {
      _L: /* CIL Label */ 
#line 3540
      len = (uint32_t )fru.size - last_off;
#line 3541
      if ((unsigned long )len > 255UL + sizeof(struct fru_multirec_header )) {
#line 3542
        len = (uint32_t )(255UL + sizeof(struct fru_multirec_header ));
      }
      {
#line 3544
      tmp___3 = read_fru_area(intf, & fru, id, last_off, len, fru_data);
      }
#line 3544
      if (tmp___3 < 0) {
#line 3545
        goto while_break;
      }
#line 3547
      last_off += len;
    }
#line 3549
    if ((int )h->type == 192) {
#line 3551
      oh = (struct fru_multirec_oem_header *)(fru_data + ((unsigned long )i + sizeof(struct fru_multirec_header )));
#line 3553
      iana = (uint32_t )(((int )oh->mfg_id[0] | ((int )oh->mfg_id[1] << 8)) | ((int )oh->mfg_id[2] << 16));
#line 3555
      suppliedIana = (uint32_t )0;
#line 3559
      if (argc <= 2) {
#line 3560
        suppliedIana = (uint32_t )12634;
      } else {
        {
#line 3562
        tmp___5 = strncmp((char const   *)*(argv + 2), "oem", (size_t )3);
        }
#line 3562
        if (! tmp___5) {
#line 3564
          if (argc <= 3) {
            {
#line 3565
            lprintf(3, "oem iana <record> <format> [<args>]");
#line 3566
            error = (uint8_t )1;
            }
          } else {
            {
#line 3568
            tmp___4 = str2uint((char const   *)*(argv + 3), & suppliedIana);
            }
#line 3568
            if (tmp___4 == 0) {
              {
#line 3569
              lprintf(7, "using iana: %d", suppliedIana);
              }
            } else {
              {
#line 3573
              lprintf(3, "Given IANA \'%s\' is invalid.", *(argv + 3));
#line 3576
              error = (uint8_t )1;
              }
            }
          }
        }
      }
#line 3582
      if (suppliedIana == iana) {
        {
#line 3583
        lprintf(7, "Matching record found");
        }
#line 3585
        if (iana == 12634U) {
          {
#line 3586
          tmp___6 = ipmi_fru_picmg_ext_edit(fru_data, (int )((unsigned long )i + sizeof(struct fru_multirec_header )),
                                            (int )h->len, h, oh);
          }
#line 3586
          if (tmp___6) {
            {
#line 3590
            write_fru_area(intf, & fru, id, (uint16_t )i, (uint16_t )i, (uint16_t )((unsigned long )h->len + sizeof(struct fru_multirec_header )),
                           fru_data);
            }
          }
        } else
#line 3594
        if (iana == 15000U) {
          {
#line 3595
          tmp___7 = ipmi_fru_oemkontron_edit(argc, argv, fru_data, (int )((unsigned long )i + sizeof(struct fru_multirec_header )),
                                             (int )h->len, h, oh);
          }
#line 3595
          if (tmp___7) {
            {
#line 3599
            write_fru_area(intf, & fru, id, (uint16_t )i, (uint16_t )i, (uint16_t )((unsigned long )h->len + sizeof(struct fru_multirec_header )),
                           fru_data);
            }
          }
        } else {
          {
#line 3605
          tmp___8 = val2str((uint16_t )iana, ipmi_oem_info);
#line 3605
          printf((char const   */* __restrict  */)"  OEM IANA (%s) Record not support in this mode\n",
                 tmp___8);
#line 3607
          error = (uint8_t )1;
          }
        }
      }
    }
#line 3611
    i = (uint32_t )((unsigned long )i + ((unsigned long )h->len + sizeof(struct fru_multirec_header )));
#line 3534
    if (! ((int )h->format & 128)) {
#line 3534
      if (! ((int )error != 1)) {
#line 3534
        goto while_break;
      }
    } else {
#line 3534
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3614
  free((void *)fru_data);
#line 3615
  fru_data = (uint8_t *)((void *)0);
  }
#line 3617
  return (0);
}
}
#line 3624 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
void ipmi_fru_get_help(void) 
{ 


  {
  {
#line 3627
  lprintf(5, "fru get <fruid> oem iana <record> <format> <args> - limited OEM support");
  }
#line 3629
  return;
}
}
#line 3631 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
void ipmi_fru_internaluse_help(void) 
{ 


  {
  {
#line 3634
  lprintf(5, "fru internaluse <fru id> info             - get internal use area size");
#line 3636
  lprintf(5, "fru internaluse <fru id> print            - print internal use area in hex");
#line 3638
  lprintf(5, "fru internaluse <fru id> read  <fru file> - read internal use area to file");
#line 3640
  lprintf(5, "fru internaluse <fru id> write <fru file> - write internal use area from file");
  }
#line 3642
  return;
}
}
#line 3653 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_get_multirec(struct ipmi_intf *intf , uint8_t id , int argc ,
                                 char **argv ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct fru_info fru ;
  struct fru_header header ;
  uint8_t msg_data[4] ;
  uint16_t retStatus ;
  uint32_t offFruMultiRec ;
  uint32_t fruMultiRecSize ;
  struct fru_info fruInfo ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  uint8_t *fru_data ;
  uint32_t fru_len ;
  uint32_t i ;
  uint32_t offset ;
  struct fru_multirec_header *h ;
  uint32_t last_off ;
  uint32_t len ;
  uint8_t error ;
  void *tmp___2 ;
  int tmp___3 ;
  struct fru_multirec_oem_header *oh ;
  uint32_t iana ;
  uint32_t suppliedIana ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;

  {
  {
#line 3664
  retStatus = (uint16_t )0;
#line 3666
  fruMultiRecSize = (uint32_t )0;
#line 3668
  tmp = ipmi_fru_get_multirec_location_from_fru(intf, id, & fruInfo, & offFruMultiRec,
                                                & fruMultiRecSize);
#line 3668
  retStatus = (uint16_t )tmp;
#line 3673
  lprintf(7, "FRU Size        : %lu\n", fruMultiRecSize);
#line 3674
  lprintf(7, "Multi Rec offset: %lu\n", offFruMultiRec);
#line 3679
  memset((void *)(& fru), 0, sizeof(struct fru_info ));
#line 3680
  memset((void *)(& header), 0, sizeof(struct fru_header ));
#line 3685
  memset((void *)(msg_data), 0, (size_t )4);
#line 3686
  msg_data[0] = id;
#line 3688
  memset((void *)(& req), 0, sizeof(req));
#line 3689
  req.msg.netfn = (uint8_t )10;
#line 3690
  req.msg.cmd = (uint8_t )16;
#line 3691
  req.msg.data = msg_data;
#line 3692
  req.msg.data_len = (uint16_t )1;
#line 3694
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 3695
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 3696
    printf((char const   */* __restrict  */)" Device not present (No Response)\n");
    }
#line 3697
    return (-1);
  }
#line 3699
  if ((int )rsp->ccode > 0) {
    {
#line 3700
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3700
    printf((char const   */* __restrict  */)" Device not present (%s)\n", tmp___0);
    }
#line 3702
    return (-1);
  }
#line 3705
  fru.size = (uint16_t )(((int )rsp->data[1] << 8) | (int )rsp->data[0]);
#line 3706
  fru.access = (uint8_t )((int )rsp->data[2] & 1);
#line 3708
  if (fru.access) {
#line 3708
    tmp___1 = "words";
  } else {
#line 3708
    tmp___1 = "bytes";
  }
  {
#line 3708
  lprintf(7, "fru.size = %d bytes (accessed by %s)", (int )fru.size, tmp___1);
  }
#line 3711
  if ((int )fru.size < 1) {
    {
#line 3712
    lprintf(3, " Invalid FRU size %d", (int )fru.size);
    }
#line 3713
    return (-1);
  }
  {
#line 3720
  offset = offFruMultiRec;
#line 3723
  error = (uint8_t )0;
#line 3725
  last_off = offset;
#line 3725
  i = last_off;
#line 3726
  fru_len = (uint32_t )0;
#line 3728
  tmp___2 = malloc((size_t )((int )fru.size + 1));
#line 3728
  fru_data = (uint8_t *)tmp___2;
  }
#line 3729
  if ((unsigned long )fru_data == (unsigned long )((void *)0)) {
    {
#line 3730
    lprintf(3, " Out of memory!");
    }
#line 3731
    return (-1);
  }
  {
#line 3733
  memset((void *)fru_data, 0, (size_t )((int )fru.size + 1));
  }
  {
#line 3735
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3736
    h = (struct fru_multirec_header *)(fru_data + i);
#line 3739
    if ((unsigned long )last_off < (unsigned long )i + sizeof(*h)) {
#line 3739
      goto _L;
    } else
#line 3739
    if (last_off < i + (uint32_t )h->len) {
      _L: /* CIL Label */ 
#line 3741
      len = (uint32_t )fru.size - last_off;
#line 3742
      if ((unsigned long )len > 255UL + sizeof(struct fru_multirec_header )) {
#line 3743
        len = (uint32_t )(255UL + sizeof(struct fru_multirec_header ));
      }
      {
#line 3745
      tmp___3 = read_fru_area(intf, & fru, id, last_off, len, fru_data);
      }
#line 3745
      if (tmp___3 < 0) {
#line 3746
        goto while_break;
      }
#line 3748
      last_off += len;
    }
#line 3750
    if ((int )h->type == 192) {
      {
#line 3752
      oh = (struct fru_multirec_oem_header *)(fru_data + ((unsigned long )i + sizeof(struct fru_multirec_header )));
#line 3754
      iana = (uint32_t )(((int )oh->mfg_id[0] | ((int )oh->mfg_id[1] << 8)) | ((int )oh->mfg_id[2] << 16));
#line 3756
      suppliedIana = (uint32_t )0;
#line 3758
      tmp___5 = strncmp((char const   *)*(argv + 2), "oem", (size_t )3);
      }
#line 3758
      if (! tmp___5) {
#line 3760
        if (argc <= 3) {
          {
#line 3761
          lprintf(3, "oem iana <record> <format>");
#line 3762
          error = (uint8_t )1;
          }
        } else {
          {
#line 3764
          tmp___4 = str2uint((char const   *)*(argv + 3), & suppliedIana);
          }
#line 3764
          if (tmp___4 == 0) {
            {
#line 3765
            lprintf(7, "using iana: %d", suppliedIana);
            }
          } else {
            {
#line 3769
            lprintf(3, "Given IANA \'%s\' is invalid.", *(argv + 3));
#line 3772
            error = (uint8_t )1;
            }
          }
        }
      }
#line 3777
      if (suppliedIana == iana) {
        {
#line 3778
        lprintf(7, "Matching record found");
        }
#line 3780
        if (iana == 15000U) {
          {
#line 3781
          ipmi_fru_oemkontron_get(argc, argv, fru_data, (int )((unsigned long )i + sizeof(struct fru_multirec_header )),
                                  (int )h->len, h, oh);
          }
        } else {
          {
#line 3787
          tmp___6 = val2str((uint16_t )iana, ipmi_oem_info);
#line 3787
          printf((char const   */* __restrict  */)"  OEM IANA (%s) Record not supported in this mode\n",
                 tmp___6);
#line 3789
          error = (uint8_t )1;
          }
        }
      }
    }
#line 3793
    i = (uint32_t )((unsigned long )i + ((unsigned long )h->len + sizeof(struct fru_multirec_header )));
#line 3735
    if (! ((int )h->format & 128)) {
#line 3735
      if (! ((int )error != 1)) {
#line 3735
        goto while_break;
      }
    } else {
#line 3735
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3796
  free((void *)fru_data);
#line 3797
  fru_data = (uint8_t *)((void *)0);
  }
#line 3799
  return (0);
}
}
#line 3802 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_upg_ekeying(struct ipmi_intf *intf , char *pFileName , uint8_t fruId ) 
{ 
  struct fru_info fruInfo ;
  uint8_t *buf ;
  uint32_t offFruMultiRec ;
  uint32_t fruMultiRecSize ;
  uint32_t offFileMultiRec ;
  uint32_t fileMultiRecSize ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 3808
  buf = (uint8_t *)((void *)0);
#line 3809
  offFruMultiRec = (uint32_t )0;
#line 3810
  fruMultiRecSize = (uint32_t )0;
#line 3811
  offFileMultiRec = (uint32_t )0;
#line 3812
  fileMultiRecSize = (uint32_t )0;
#line 3813
  if ((unsigned long )pFileName == (unsigned long )((void *)0)) {
    {
#line 3814
    lprintf(3, "File expected, but none given.");
    }
#line 3815
    return (-1);
  }
  {
#line 3817
  tmp = ipmi_fru_get_multirec_location_from_fru(intf, fruId, & fruInfo, & offFruMultiRec,
                                                & fruMultiRecSize);
  }
#line 3817
  if (tmp != 0) {
    {
#line 3819
    lprintf(3, "Failed to get multirec location from FRU.");
    }
#line 3820
    return (-1);
  }
  {
#line 3822
  lprintf(7, "FRU Size        : %lu\n", fruMultiRecSize);
#line 3823
  lprintf(7, "Multi Rec offset: %lu\n", offFruMultiRec);
#line 3824
  tmp___0 = ipmi_fru_get_multirec_size_from_file(pFileName, & fileMultiRecSize, & offFileMultiRec);
  }
#line 3824
  if (tmp___0 != 0) {
    {
#line 3826
    lprintf(3, "Failed to get multirec size from file \'%s\'.", pFileName);
    }
#line 3827
    return (-1);
  }
  {
#line 3829
  tmp___1 = malloc((size_t )fileMultiRecSize);
#line 3829
  buf = (uint8_t *)tmp___1;
  }
#line 3830
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 3831
    lprintf(3, "ipmitool: malloc failure");
    }
#line 3832
    return (-1);
  }
  {
#line 3834
  tmp___2 = ipmi_fru_get_multirec_from_file(pFileName, buf, fileMultiRecSize, offFileMultiRec);
  }
#line 3834
  if (tmp___2 != 0) {
    {
#line 3836
    lprintf(3, "Failed to get multirec from file \'%s\'.", pFileName);
    }
#line 3837
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
      {
#line 3838
      free((void *)buf);
#line 3839
      buf = (uint8_t *)((void *)0);
      }
    }
#line 3841
    return (-1);
  }
  {
#line 3843
  tmp___3 = ipmi_fru_get_adjust_size_from_buffer(buf, & fileMultiRecSize);
  }
#line 3843
  if (tmp___3 != 0) {
    {
#line 3844
    lprintf(3, "Failed to adjust size from buffer.");
    }
#line 3845
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
      {
#line 3846
      free((void *)buf);
#line 3847
      buf = (uint8_t *)((void *)0);
      }
    }
#line 3849
    return (-1);
  }
  {
#line 3851
  tmp___4 = write_fru_area(intf, & fruInfo, fruId, (uint16_t )0, (uint16_t )offFruMultiRec,
                           (uint16_t )fileMultiRecSize, buf);
  }
#line 3851
  if (tmp___4 != 0) {
    {
#line 3853
    lprintf(3, "Failed to write FRU area.");
    }
#line 3854
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
      {
#line 3855
      free((void *)buf);
#line 3856
      buf = (uint8_t *)((void *)0);
      }
    }
#line 3858
    return (-1);
  }
#line 3860
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
    {
#line 3861
    free((void *)buf);
#line 3862
    buf = (uint8_t *)((void *)0);
    }
  }
  {
#line 3864
  lprintf(6, "Done upgrading Ekey.");
  }
#line 3865
  return (0);
}
}
#line 3872 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
void ipmi_fru_upgekey_help(void) 
{ 


  {
  {
#line 3875
  lprintf(5, "fru upgEkey <fru id> <fru file>");
#line 3876
  lprintf(5, "Note: FRU ID and file(incl. full path) must be specified.");
#line 3877
  lprintf(5, "Example: ipmitool fru upgEkey 0 /root/fru.bin");
  }
#line 3878
  return;
}
}
#line 3880 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_get_multirec_size_from_file(char *pFileName , uint32_t *pSize ,
                                                uint32_t *pOffset ) 
{ 
  struct fru_header header ;
  FILE *pFile ;
  uint8_t len ;
  uint32_t end ;
  size_t tmp ;
  long tmp___0 ;

  {
  {
#line 3887
  len = (uint8_t )0;
#line 3888
  end = (uint32_t )0;
#line 3889
  *pSize = (uint32_t )0;
#line 3891
  pFile = fopen((char const   */* __restrict  */)pFileName, (char const   */* __restrict  */)"rb");
  }
#line 3892
  if (pFile) {
    {
#line 3893
    rewind(pFile);
#line 3894
    tmp = fread((void */* __restrict  */)(& header), (size_t )1, (size_t )8, (FILE */* __restrict  */)pFile);
#line 3894
    len = (uint8_t )tmp;
#line 3895
    fseek(pFile, 0L, 2);
#line 3896
    tmp___0 = ftell(pFile);
#line 3896
    end = (uint32_t )tmp___0;
#line 3897
    fclose(pFile);
    }
  }
  {
#line 3900
  lprintf(7, "File Size = %lu\n", end);
#line 3901
  lprintf(7, "Len = %u\n", (int )len);
  }
#line 3903
  if ((int )len != 8) {
    {
#line 3904
    printf((char const   */* __restrict  */)"Error with file %s in getting size\n",
           pFileName);
    }
#line 3905
    return (-1);
  }
#line 3908
  if ((int )header.version != 1) {
    {
#line 3909
    printf((char const   */* __restrict  */)"Unknown FRU header version %02x.\n",
           (int )header.version);
    }
#line 3910
    return (-1);
  }
#line 3914
  if ((int )header.offset.internal * 8 > (int )header.offset.internal * 8) {
#line 3914
    if ((uint32_t )((int )header.offset.internal * 8) < end) {
#line 3916
      end = (uint32_t )((int )header.offset.internal * 8);
    }
  }
#line 3918
  if ((int )header.offset.chassis * 8 > (int )header.offset.chassis * 8) {
#line 3918
    if ((uint32_t )((int )header.offset.chassis * 8) < end) {
#line 3920
      end = (uint32_t )((int )header.offset.chassis * 8);
    }
  }
#line 3922
  if ((int )header.offset.board * 8 > (int )header.offset.board * 8) {
#line 3922
    if ((uint32_t )((int )header.offset.board * 8) < end) {
#line 3924
      end = (uint32_t )((int )header.offset.board * 8);
    }
  }
#line 3926
  if ((int )header.offset.product * 8 > (int )header.offset.product * 8) {
#line 3926
    if ((uint32_t )((int )header.offset.product * 8) < end) {
#line 3928
      end = (uint32_t )((int )header.offset.product * 8);
    }
  }
#line 3930
  *pSize = end - (uint32_t )((int )header.offset.multi * 8);
#line 3931
  *pOffset = (uint32_t )((int )header.offset.multi * 8);
#line 3933
  return (0);
}
}
#line 3936 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
int ipmi_fru_get_adjust_size_from_buffer(uint8_t *fru_data , uint32_t *pSize ) 
{ 
  struct fru_multirec_header *head ;
  int status ;
  uint8_t checksum ;
  uint8_t counter ;
  uint16_t count ;

  {
#line 3940
  status = 0;
#line 3941
  checksum = (uint8_t )0;
#line 3942
  counter = (uint8_t )0;
#line 3943
  count = (uint16_t )0;
  {
#line 3944
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3945
    checksum = (uint8_t )0;
#line 3946
    head = (struct fru_multirec_header *)(fru_data + (int )count);
#line 3947
    if (verbose) {
      {
#line 3948
      printf((char const   */* __restrict  */)"Adding (");
      }
    }
#line 3950
    counter = (uint8_t )0;
    {
#line 3950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3950
      if (! ((unsigned long )counter < sizeof(struct fru_multirec_header ))) {
#line 3950
        goto while_break___0;
      }
#line 3951
      if (verbose) {
        {
#line 3952
        printf((char const   */* __restrict  */)" %02X", (int )*((fru_data + (int )count) + (int )counter));
        }
      }
#line 3954
      checksum = (uint8_t )((int )checksum + (int )*((fru_data + (int )count) + (int )counter));
#line 3950
      counter = (uint8_t )((int )counter + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3956
    if (verbose) {
      {
#line 3957
      printf((char const   */* __restrict  */)")");
      }
    }
#line 3959
    if ((int )checksum != 0) {
      {
#line 3960
      lprintf(3, "Bad checksum in Multi Records");
#line 3961
      status = -1;
      }
#line 3962
      if (verbose) {
        {
#line 3963
        printf((char const   */* __restrict  */)"--> FAIL");
        }
      }
    } else
#line 3965
    if (verbose) {
      {
#line 3966
      printf((char const   */* __restrict  */)"--> OK");
      }
    }
#line 3968
    if (verbose > 1) {
#line 3968
      if ((int )checksum == 0) {
#line 3969
        counter = (uint8_t )0;
        {
#line 3969
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3969
          if (! ((int )counter < (int )head->len)) {
#line 3969
            goto while_break___1;
          }
          {
#line 3970
          printf((char const   */* __restrict  */)" %02X", (int )*(((fru_data + (int )count) + (int )counter) + sizeof(struct fru_multirec_header )));
#line 3969
          counter = (uint8_t )((int )counter + 1);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 3974
    if (verbose) {
      {
#line 3975
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 3977
    count = (uint16_t )((unsigned long )count + ((unsigned long )head->len + sizeof(struct fru_multirec_header )));
#line 3944
    if (! ((int )head->format & 128)) {
#line 3944
      if (! (status == 0)) {
#line 3944
        goto while_break;
      }
    } else {
#line 3944
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3980
  *pSize = (uint32_t )count;
#line 3981
  lprintf(7, "Size of multirec: %lu\n", *pSize);
  }
#line 3982
  return (status);
}
}
#line 3985 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_get_multirec_from_file(char *pFileName , uint8_t *pBufArea , uint32_t size ,
                                           uint32_t offset ) 
{ 
  FILE *pFile ;
  uint32_t len ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;

  {
#line 3990
  len = (uint32_t )0;
#line 3991
  if ((unsigned long )pFileName == (unsigned long )((void *)0)) {
    {
#line 3992
    lprintf(3, "Invalid file name given.");
    }
#line 3993
    return (-1);
  }
  {
#line 3996
  tmp = __errno_location();
#line 3996
  *tmp = 0;
#line 3997
  pFile = fopen((char const   */* __restrict  */)pFileName, (char const   */* __restrict  */)"rb");
  }
#line 3998
  if (! pFile) {
    {
#line 3999
    tmp___0 = __errno_location();
#line 3999
    tmp___1 = strerror(*tmp___0);
#line 3999
    tmp___2 = __errno_location();
#line 3999
    lprintf(3, "Error opening file \'%s\': %i -> %s.", pFileName, *tmp___2, tmp___1);
    }
#line 4001
    return (-1);
  }
  {
#line 4003
  tmp___3 = __errno_location();
#line 4003
  *tmp___3 = 0;
#line 4004
  tmp___7 = fseek(pFile, (long )offset, 0);
  }
#line 4004
  if (tmp___7 != 0) {
    {
#line 4005
    tmp___4 = __errno_location();
#line 4005
    tmp___5 = strerror(*tmp___4);
#line 4005
    tmp___6 = __errno_location();
#line 4005
    lprintf(3, "Failed to seek in file \'%s\': %i -> %s.", pFileName, *tmp___6, tmp___5);
#line 4007
    fclose(pFile);
    }
#line 4008
    return (-1);
  }
  {
#line 4010
  tmp___8 = fread((void */* __restrict  */)pBufArea, (size_t )size, (size_t )1, (FILE */* __restrict  */)pFile);
#line 4010
  len = (uint32_t )tmp___8;
#line 4011
  fclose(pFile);
  }
#line 4013
  if (len != 1U) {
    {
#line 4014
    lprintf(3, "Error in file \'%s\'.", pFileName);
    }
#line 4015
    return (-1);
  }
#line 4017
  return (0);
}
}
#line 4020 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_get_multirec_location_from_fru(struct ipmi_intf *intf , uint8_t fruId ,
                                                   struct fru_info *pFruInfo , uint32_t *pRetLocation ,
                                                   uint32_t *pRetSize ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[4] ;
  uint32_t end ;
  struct fru_header header ;
  char const   *tmp ;

  {
  {
#line 4033
  *pRetLocation = (uint32_t )0;
#line 4035
  msg_data[0] = fruId;
#line 4037
  memset((void *)(& req), 0, sizeof(req));
#line 4038
  req.msg.netfn = (uint8_t )10;
#line 4039
  req.msg.cmd = (uint8_t )16;
#line 4040
  req.msg.data = msg_data;
#line 4041
  req.msg.data_len = (uint16_t )1;
#line 4043
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 4044
  if (! rsp) {
#line 4045
    if (verbose > 1) {
      {
#line 4046
      printf((char const   */* __restrict  */)"no response\n");
      }
    }
#line 4047
    return (-1);
  }
#line 4050
  if ((int )rsp->ccode > 0) {
#line 4051
    if ((int )rsp->ccode == 195) {
      {
#line 4052
      printf((char const   */* __restrict  */)"  Timeout accessing FRU info. (Device not present?)\n");
      }
    } else {
      {
#line 4054
      printf((char const   */* __restrict  */)"   CCODE = 0x%02x\n", (int )rsp->ccode);
      }
    }
#line 4055
    return (-1);
  }
#line 4057
  pFruInfo->size = (uint16_t )(((int )rsp->data[1] << 8) | (int )rsp->data[0]);
#line 4058
  pFruInfo->access = (uint8_t )((int )rsp->data[2] & 1);
#line 4060
  if (verbose > 1) {
#line 4061
    if (pFruInfo->access) {
#line 4061
      tmp = "words";
    } else {
#line 4061
      tmp = "bytes";
    }
    {
#line 4061
    printf((char const   */* __restrict  */)"pFruInfo->size = %d bytes (accessed by %s)\n",
           (int )pFruInfo->size, tmp);
    }
  }
#line 4064
  if (! pFruInfo->size) {
#line 4065
    return (-1);
  }
  {
#line 4067
  msg_data[0] = fruId;
#line 4068
  msg_data[1] = (uint8_t )0;
#line 4069
  msg_data[2] = (uint8_t )0;
#line 4070
  msg_data[3] = (uint8_t )8;
#line 4072
  memset((void *)(& req), 0, sizeof(req));
#line 4073
  req.msg.netfn = (uint8_t )10;
#line 4074
  req.msg.cmd = (uint8_t )17;
#line 4075
  req.msg.data = msg_data;
#line 4076
  req.msg.data_len = (uint16_t )4;
#line 4078
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 4080
  if (! rsp) {
#line 4081
    return (-1);
  }
#line 4082
  if ((int )rsp->ccode > 0) {
#line 4083
    if ((int )rsp->ccode == 195) {
      {
#line 4084
      printf((char const   */* __restrict  */)"  Timeout while reading FRU data. (Device not present?)\n");
      }
    }
#line 4085
    return (-1);
  }
#line 4088
  if (verbose > 1) {
    {
#line 4089
    printbuf((uint8_t const   *)(rsp->data), rsp->data_len, "FRU DATA");
    }
  }
  {
#line 4091
  memcpy((void */* __restrict  */)(& header), (void const   */* __restrict  */)(rsp->data + 1),
         (size_t )8);
  }
#line 4093
  if ((int )header.version != 1) {
    {
#line 4094
    printf((char const   */* __restrict  */)"  Unknown FRU header version %02x.\n",
           (int )header.version);
    }
#line 4095
    return (-1);
  }
#line 4098
  end = (uint32_t )pFruInfo->size;
#line 4101
  if ((int )header.offset.internal * 8 > (int )header.offset.internal * 8) {
#line 4101
    if ((uint32_t )((int )header.offset.internal * 8) < end) {
#line 4103
      end = (uint32_t )((int )header.offset.internal * 8);
    }
  }
#line 4105
  if ((int )header.offset.chassis * 8 > (int )header.offset.chassis * 8) {
#line 4105
    if ((uint32_t )((int )header.offset.chassis * 8) < end) {
#line 4107
      end = (uint32_t )((int )header.offset.chassis * 8);
    }
  }
#line 4109
  if ((int )header.offset.board * 8 > (int )header.offset.board * 8) {
#line 4109
    if ((uint32_t )((int )header.offset.board * 8) < end) {
#line 4111
      end = (uint32_t )((int )header.offset.board * 8);
    }
  }
#line 4113
  if ((int )header.offset.product * 8 > (int )header.offset.product * 8) {
#line 4113
    if ((uint32_t )((int )header.offset.product * 8) < end) {
#line 4115
      end = (uint32_t )((int )header.offset.product * 8);
    }
  }
#line 4117
  *pRetSize = end;
#line 4118
  *pRetLocation = (uint32_t )(8 * (int )header.offset.multi);
#line 4120
  return (0);
}
}
#line 4132 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_get_internal_use_info(struct ipmi_intf *intf , uint8_t id , struct fru_info *fru ,
                                          uint16_t *size , uint16_t *offset ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct fru_header header ;
  uint8_t msg_data[4] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 4145
  *offset = (uint16_t )0;
#line 4146
  *size = (uint16_t )0;
#line 4148
  memset((void *)fru, 0, sizeof(struct fru_info ));
#line 4149
  memset((void *)(& header), 0, sizeof(struct fru_header ));
#line 4154
  memset((void *)(msg_data), 0, (size_t )4);
#line 4155
  msg_data[0] = id;
#line 4157
  memset((void *)(& req), 0, sizeof(req));
#line 4158
  req.msg.netfn = (uint8_t )10;
#line 4159
  req.msg.cmd = (uint8_t )16;
#line 4160
  req.msg.data = msg_data;
#line 4161
  req.msg.data_len = (uint16_t )1;
#line 4163
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 4164
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 4165
    printf((char const   */* __restrict  */)" Device not present (No Response)\n");
    }
#line 4166
    return (-1);
  }
#line 4168
  if ((int )rsp->ccode > 0) {
    {
#line 4169
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 4169
    printf((char const   */* __restrict  */)" Device not present (%s)\n", tmp);
    }
#line 4171
    return (-1);
  }
#line 4174
  fru->size = (uint16_t )(((int )rsp->data[1] << 8) | (int )rsp->data[0]);
#line 4175
  fru->access = (uint8_t )((int )rsp->data[2] & 1);
#line 4177
  if (fru->access) {
#line 4177
    tmp___0 = "words";
  } else {
#line 4177
    tmp___0 = "bytes";
  }
  {
#line 4177
  lprintf(7, "fru.size = %d bytes (accessed by %s)", (int )fru->size, tmp___0);
  }
#line 4180
  if ((int )fru->size < 1) {
    {
#line 4181
    lprintf(3, " Invalid FRU size %d", (int )fru->size);
    }
#line 4182
    return (-1);
  }
  {
#line 4188
  msg_data[0] = id;
#line 4189
  msg_data[1] = (uint8_t )0;
#line 4190
  msg_data[2] = (uint8_t )0;
#line 4191
  msg_data[3] = (uint8_t )8;
#line 4193
  memset((void *)(& req), 0, sizeof(req));
#line 4194
  req.msg.netfn = (uint8_t )10;
#line 4195
  req.msg.cmd = (uint8_t )17;
#line 4196
  req.msg.data = msg_data;
#line 4197
  req.msg.data_len = (uint16_t )4;
#line 4199
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 4200
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 4201
    printf((char const   */* __restrict  */)" Device not present (No Response)\n");
    }
#line 4202
    return (1);
  }
#line 4204
  if ((int )rsp->ccode > 0) {
    {
#line 4205
    tmp___1 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 4205
    printf((char const   */* __restrict  */)" Device not present (%s)\n", tmp___1);
    }
#line 4207
    return (1);
  }
#line 4210
  if (verbose > 1) {
    {
#line 4211
    printbuf((uint8_t const   *)(rsp->data), rsp->data_len, "FRU DATA");
    }
  }
  {
#line 4213
  memcpy((void */* __restrict  */)(& header), (void const   */* __restrict  */)(rsp->data + 1),
         (size_t )8);
  }
#line 4215
  if ((int )header.version != 1) {
    {
#line 4216
    lprintf(3, " Unknown FRU header version 0x%02x", (int )header.version);
    }
#line 4218
    return (-1);
  }
  {
#line 4221
  lprintf(7, "fru.header.version:         0x%x", (int )header.version);
#line 4223
  lprintf(7, "fru.header.offset.internal: 0x%x", (int )header.offset.internal * 8);
#line 4225
  lprintf(7, "fru.header.offset.chassis:  0x%x", (int )header.offset.chassis * 8);
#line 4227
  lprintf(7, "fru.header.offset.board:    0x%x", (int )header.offset.board * 8);
#line 4229
  lprintf(7, "fru.header.offset.product:  0x%x", (int )header.offset.product * 8);
#line 4231
  lprintf(7, "fru.header.offset.multi:    0x%x", (int )header.offset.multi * 8);
  }
#line 4234
  if ((int )header.offset.internal * 8 == 0) {
#line 4236
    *size = (uint16_t )0;
#line 4237
    *offset = (uint16_t )0;
  } else {
#line 4241
    *offset = (uint16_t )((int )header.offset.internal * 8);
#line 4243
    if ((int )header.offset.chassis != 0) {
#line 4245
      *size = (uint16_t )((int )header.offset.chassis * 8 - (int )*offset);
    } else
#line 4247
    if ((int )header.offset.board != 0) {
#line 4249
      *size = (uint16_t )((int )header.offset.board * 8 - (int )*offset);
    } else
#line 4251
    if ((int )header.offset.product != 0) {
#line 4253
      *size = (uint16_t )((int )header.offset.product * 8 - (int )*offset);
    } else
#line 4255
    if ((int )header.offset.multi != 0) {
#line 4257
      *size = (uint16_t )((int )header.offset.multi * 8 - (int )*offset);
    } else {
#line 4261
      *size = (uint16_t )((int )fru->size - (int )*offset);
    }
  }
#line 4264
  return (0);
}
}
#line 4276 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_info_internal_use(struct ipmi_intf *intf , uint8_t id ) 
{ 
  struct fru_info fru ;
  uint16_t size ;
  uint16_t offset ;
  int rc ;

  {
  {
#line 4282
  rc = 0;
#line 4284
  rc = ipmi_fru_get_internal_use_info(intf, id, & fru, & size, & offset);
  }
#line 4286
  if (rc == 0) {
    {
#line 4288
    lprintf(7, "Internal Use Area Offset: %i", (int )offset);
#line 4289
    printf((char const   */* __restrict  */)"Internal Use Area Size  : %i\n", (int )size);
    }
  } else {
    {
#line 4293
    lprintf(3, "Cannot access internal use area");
    }
#line 4294
    return (-1);
  }
#line 4296
  return (0);
}
}
#line 4303 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
void ipmi_fru_help(void) 
{ 


  {
  {
#line 4306
  lprintf(5, "FRU Commands:  print read write upgEkey edit internaluse get");
  }
#line 4308
  return;
}
}
#line 4319 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_read_internal_use(struct ipmi_intf *intf , uint8_t id , char *pFileName ) 
{ 
  struct fru_info fru ;
  uint16_t size ;
  uint16_t offset ;
  int rc ;
  uint8_t *frubuf ;
  void *tmp ;
  uint16_t counter ;
  FILE *pFile ;

  {
  {
#line 4325
  rc = 0;
#line 4327
  rc = ipmi_fru_get_internal_use_info(intf, id, & fru, & size, & offset);
  }
#line 4329
  if (rc == 0) {
    {
#line 4333
    lprintf(7, "Internal Use Area Offset: %i", (int )offset);
#line 4334
    printf((char const   */* __restrict  */)"Internal Use Area Size  : %i\n", (int )size);
#line 4336
    tmp = malloc((size_t )size);
#line 4336
    frubuf = (uint8_t *)tmp;
    }
#line 4337
    if (frubuf) {
      {
#line 4339
      rc = read_fru_area_section(intf, & fru, id, (uint32_t )offset, (uint32_t )size,
                                 frubuf);
      }
#line 4341
      if (rc == 0) {
#line 4343
        if ((unsigned long )pFileName == (unsigned long )((void *)0)) {
#line 4346
          counter = (uint16_t )0;
          {
#line 4346
          while (1) {
            while_continue: /* CIL Label */ ;
#line 4346
            if (! ((int )counter < (int )size)) {
#line 4346
              goto while_break;
            }
#line 4348
            if ((int )counter % 16 == 0) {
              {
#line 4349
              printf((char const   */* __restrict  */)"\n%02i- ", (int )counter / 16);
              }
            }
            {
#line 4350
            printf((char const   */* __restrict  */)"%02X ", (int )*(frubuf + counter));
#line 4346
            counter = (uint16_t )((int )counter + 1);
            }
          }
          while_break: /* CIL Label */ ;
          }
        } else {
          {
#line 4356
          pFile = fopen((char const   */* __restrict  */)pFileName, (char const   */* __restrict  */)"wb");
          }
#line 4357
          if (pFile) {
            {
#line 4359
            fwrite((void const   */* __restrict  */)frubuf, (size_t )size, (size_t )1,
                   (FILE */* __restrict  */)pFile);
#line 4360
            printf((char const   */* __restrict  */)"Done\n");
            }
          } else {
            {
#line 4364
            lprintf(3, "Error opening file %s\n", pFileName);
#line 4365
            free((void *)frubuf);
#line 4366
            frubuf = (uint8_t *)((void *)0);
            }
#line 4367
            return (-1);
          }
          {
#line 4369
          fclose(pFile);
          }
        }
      }
      {
#line 4372
      printf((char const   */* __restrict  */)"\n");
#line 4374
      free((void *)frubuf);
#line 4375
      frubuf = (uint8_t *)((void *)0);
      }
    }
  } else {
    {
#line 4381
    lprintf(3, "Cannot access internal use area");
    }
  }
#line 4383
  return (0);
}
}
#line 4395 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_write_internal_use(struct ipmi_intf *intf , uint8_t id , char *pFileName ) 
{ 
  struct fru_info fru ;
  uint16_t size ;
  uint16_t offset ;
  int rc ;
  uint8_t *frubuf ;
  FILE *fp ;
  uint32_t fileLength ;
  long tmp ;
  void *tmp___0 ;
  uint16_t fru_read_size ;
  size_t tmp___1 ;

  {
  {
#line 4401
  rc = 0;
#line 4403
  rc = ipmi_fru_get_internal_use_info(intf, id, & fru, & size, & offset);
  }
#line 4405
  if (rc == 0) {
    {
#line 4409
    fileLength = (uint32_t )0;
#line 4411
    lprintf(7, "Internal Use Area Offset: %i", (int )offset);
#line 4412
    printf((char const   */* __restrict  */)"Internal Use Area Size  : %i\n", (int )size);
#line 4414
    fp = fopen((char const   */* __restrict  */)pFileName, (char const   */* __restrict  */)"r");
    }
#line 4416
    if (fp) {
      {
#line 4419
      fseek(fp, 0L, 2);
#line 4420
      tmp = ftell(fp);
#line 4420
      fileLength = (uint32_t )tmp;
#line 4422
      lprintf(3, "File Size: %i", fileLength);
#line 4423
      lprintf(3, "Area Size: %i", (int )size);
      }
#line 4424
      if (fileLength != (uint32_t )size) {
        {
#line 4426
        lprintf(3, "File size does not fit Eeprom Size");
#line 4427
        fclose(fp);
#line 4428
        fp = (FILE *)((void *)0);
        }
      } else {
        {
#line 4432
        fseek(fp, 0L, 0);
        }
      }
    }
#line 4436
    if (fp) {
      {
#line 4438
      tmp___0 = malloc((size_t )size);
#line 4438
      frubuf = (uint8_t *)tmp___0;
      }
#line 4439
      if (frubuf) {
        {
#line 4442
        tmp___1 = fread((void */* __restrict  */)frubuf, (size_t )1, (size_t )size,
                        (FILE */* __restrict  */)fp);
#line 4442
        fru_read_size = (uint16_t )tmp___1;
        }
#line 4444
        if ((int )fru_read_size == (int )size) {
          {
#line 4446
          rc = write_fru_area(intf, & fru, id, (uint16_t )0, offset, size, frubuf);
          }
#line 4448
          if (rc == 0) {
            {
#line 4450
            lprintf(6, "Done\n");
            }
          }
        } else {
          {
#line 4455
          lprintf(3, "Unable to read file: %i\n", (int )fru_read_size);
          }
        }
        {
#line 4458
        free((void *)frubuf);
#line 4459
        frubuf = (uint8_t *)((void *)0);
        }
      }
      {
#line 4461
      fclose(fp);
#line 4462
      fp = (FILE *)((void *)0);
      }
    }
  } else {
    {
#line 4467
    lprintf(3, "Cannot access internal use area");
    }
  }
#line 4469
  return (0);
}
}
#line 4472 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
int ipmi_fru_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int rc ;
  uint8_t fru_id ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;

  {
#line 4475
  rc = 0;
#line 4476
  fru_id = (uint8_t )0;
#line 4478
  if (argc < 1) {
    {
#line 4479
    rc = ipmi_fru_print_all(intf);
    }
  } else {
    {
#line 4481
    tmp___36 = strncmp((char const   *)*(argv + 0), "help", (size_t )4);
    }
#line 4481
    if (tmp___36 == 0) {
      {
#line 4482
      ipmi_fru_help();
      }
#line 4483
      return (0);
    } else {
      {
#line 4485
      tmp___34 = strncmp((char const   *)*(argv + 0), "print", (size_t )5);
      }
#line 4485
      if (tmp___34 == 0) {
#line 4485
        goto _L___7;
      } else {
        {
#line 4485
        tmp___35 = strncmp((char const   *)*(argv + 0), "list", (size_t )4);
        }
#line 4485
        if (tmp___35 == 0) {
          _L___7: /* CIL Label */ 
#line 4487
          if (argc > 1) {
            {
#line 4488
            tmp = strcmp((char const   *)*(argv + 1), "help");
            }
#line 4488
            if (tmp == 0) {
              {
#line 4489
              lprintf(5, "fru print [fru id] - print information about FRU(s)");
              }
#line 4490
              return (0);
            }
            {
#line 4493
            tmp___0 = is_fru_id((char const   *)*(argv + 1), & fru_id);
            }
#line 4493
            if (tmp___0 != 0) {
#line 4494
              return (-1);
            }
            {
#line 4496
            rc = __ipmi_fru_print(intf, fru_id);
            }
          } else {
            {
#line 4498
            rc = ipmi_fru_print_all(intf);
            }
          }
        } else {
          {
#line 4501
          tmp___33 = strncmp((char const   *)*(argv + 0), "read", (size_t )5);
          }
#line 4501
          if (tmp___33) {
            {
#line 4525
            tmp___32 = strncmp((char const   *)*(argv + 0), "write", (size_t )5);
            }
#line 4525
            if (tmp___32) {
              {
#line 4549
              tmp___31 = strncmp((char const   *)*(argv + 0), "upgEkey", (size_t )7);
              }
#line 4549
              if (tmp___31) {
                {
#line 4568
                tmp___30 = strncmp((char const   *)*(argv + 0), "internaluse", (size_t )11);
                }
#line 4568
                if (tmp___30) {
                  {
#line 4622
                  tmp___29 = strncmp((char const   *)*(argv + 0), "edit", (size_t )4);
                  }
#line 4622
                  if (tmp___29) {
                    {
#line 4663
                    tmp___28 = strncmp((char const   *)*(argv + 0), "get", (size_t )4);
                    }
#line 4663
                    if (tmp___28) {
                      {
#line 4697
                      lprintf(3, "Invalid FRU command: %s", *(argv + 0));
#line 4698
                      ipmi_fru_help();
                      }
#line 4699
                      return (-1);
                    } else {
#line 4664
                      if (argc > 1) {
                        {
#line 4664
                        tmp___25 = strncmp((char const   *)*(argv + 1), "help", (size_t )4);
                        }
#line 4664
                        if (tmp___25 == 0) {
                          {
#line 4665
                          ipmi_fru_get_help();
                          }
#line 4666
                          return (0);
                        } else {
#line 4664
                          goto _L___6;
                        }
                      } else
                      _L___6: /* CIL Label */ 
#line 4667
                      if (argc < 2) {
                        {
#line 4668
                        lprintf(3, "Not enough parameters given.");
#line 4669
                        ipmi_fru_get_help();
                        }
#line 4670
                        return (-1);
                      }
#line 4673
                      if (argc >= 2) {
                        {
#line 4674
                        tmp___26 = is_fru_id((char const   *)*(argv + 1), & fru_id);
                        }
#line 4674
                        if (tmp___26 != 0) {
#line 4675
                          return (-1);
                        }
#line 4677
                        if (verbose) {
                          {
#line 4678
                          printf((char const   */* __restrict  */)"FRU ID           : %d\n",
                                 (int )fru_id);
                          }
                        }
                      } else {
                        {
#line 4681
                        printf((char const   */* __restrict  */)"Using default FRU ID: %d\n",
                               (int )fru_id);
                        }
                      }
#line 4684
                      if (argc >= 3) {
                        {
#line 4685
                        tmp___27 = strncmp((char const   *)*(argv + 2), "oem", (size_t )3);
                        }
#line 4685
                        if (tmp___27) {
                          {
#line 4688
                          lprintf(3, "Invalid command: %s", *(argv + 2));
#line 4689
                          ipmi_fru_get_help();
                          }
#line 4690
                          return (-1);
                        } else {
                          {
#line 4686
                          rc = ipmi_fru_get_multirec(intf, fru_id, argc, argv);
                          }
                        }
                      } else {
                        {
#line 4693
                        rc = ipmi_fru_get_multirec(intf, fru_id, argc, argv);
                        }
                      }
                    }
                  } else {
#line 4623
                    if (argc > 1) {
                      {
#line 4623
                      tmp___21 = strcmp((char const   *)*(argv + 1), "help");
                      }
#line 4623
                      if (tmp___21 == 0) {
                        {
#line 4624
                        ipmi_fru_edit_help();
                        }
#line 4625
                        return (0);
                      } else {
#line 4623
                        goto _L___5;
                      }
                    } else
                    _L___5: /* CIL Label */ 
#line 4626
                    if (argc < 2) {
                      {
#line 4627
                      lprintf(3, "Not enough parameters given.");
#line 4628
                      ipmi_fru_edit_help();
                      }
#line 4629
                      return (-1);
                    }
#line 4632
                    if (argc >= 2) {
                      {
#line 4633
                      tmp___22 = is_fru_id((char const   *)*(argv + 1), & fru_id);
                      }
#line 4633
                      if (tmp___22 != 0) {
#line 4634
                        return (-1);
                      }
#line 4636
                      if (verbose) {
                        {
#line 4637
                        printf((char const   */* __restrict  */)"FRU ID           : %d\n",
                               (int )fru_id);
                        }
                      }
                    } else {
                      {
#line 4640
                      printf((char const   */* __restrict  */)"Using default FRU ID: %d\n",
                             (int )fru_id);
                      }
                    }
#line 4643
                    if (argc >= 3) {
                      {
#line 4644
                      tmp___24 = strncmp((char const   *)*(argv + 2), "field", (size_t )5);
                      }
#line 4644
                      if (tmp___24) {
                        {
#line 4652
                        tmp___23 = strncmp((char const   *)*(argv + 2), "oem", (size_t )3);
                        }
#line 4652
                        if (tmp___23) {
                          {
#line 4655
                          lprintf(3, "Invalid command: %s", *(argv + 2));
#line 4656
                          ipmi_fru_edit_help();
                          }
#line 4657
                          return (-1);
                        } else {
                          {
#line 4653
                          rc = ipmi_fru_edit_multirec(intf, fru_id, argc, argv);
                          }
                        }
                      } else {
#line 4645
                        if (argc != 6) {
                          {
#line 4646
                          lprintf(3, "Not enough parameters given.");
#line 4647
                          ipmi_fru_edit_help();
                          }
#line 4648
                          return (-1);
                        }
                        {
#line 4650
                        rc = ipmi_fru_set_field_string(intf, fru_id, (uint8_t )*(*(argv + 3)),
                                                       (uint8_t )*(*(argv + 4)), *(argv + 5));
                        }
                      }
                    } else {
                      {
#line 4660
                      rc = ipmi_fru_edit_multirec(intf, fru_id, argc, argv);
                      }
                    }
                  }
                } else {
#line 4569
                  if (argc > 1) {
                    {
#line 4569
                    tmp___10 = strcmp((char const   *)*(argv + 1), "help");
                    }
#line 4569
                    if (tmp___10 == 0) {
                      {
#line 4570
                      ipmi_fru_internaluse_help();
                      }
#line 4571
                      return (0);
                    }
                  }
#line 4574
                  if (argc >= 3) {
                    {
#line 4574
                    tmp___20 = strncmp((char const   *)*(argv + 2), "info", (size_t )4);
                    }
#line 4574
                    if (tmp___20) {
#line 4574
                      goto _L___4;
                    } else {
                      {
#line 4576
                      tmp___11 = is_fru_id((char const   *)*(argv + 1), & fru_id);
                      }
#line 4576
                      if (tmp___11 != 0) {
#line 4577
                        return (-1);
                      }
                      {
#line 4579
                      rc = ipmi_fru_info_internal_use(intf, fru_id);
                      }
                    }
                  } else
                  _L___4: /* CIL Label */ 
#line 4581
                  if (argc >= 3) {
                    {
#line 4581
                    tmp___19 = strncmp((char const   *)*(argv + 2), "print", (size_t )5);
                    }
#line 4581
                    if (tmp___19) {
#line 4581
                      goto _L___3;
                    } else {
                      {
#line 4583
                      tmp___12 = is_fru_id((char const   *)*(argv + 1), & fru_id);
                      }
#line 4583
                      if (tmp___12 != 0) {
#line 4584
                        return (-1);
                      }
                      {
#line 4586
                      rc = ipmi_fru_read_internal_use(intf, fru_id, (char *)((void *)0));
                      }
                    }
                  } else
                  _L___3: /* CIL Label */ 
#line 4588
                  if (argc >= 4) {
                    {
#line 4588
                    tmp___18 = strncmp((char const   *)*(argv + 2), "read", (size_t )4);
                    }
#line 4588
                    if (tmp___18) {
#line 4588
                      goto _L___2;
                    } else {
                      {
#line 4590
                      tmp___13 = is_fru_id((char const   *)*(argv + 1), & fru_id);
                      }
#line 4590
                      if (tmp___13 != 0) {
#line 4591
                        return (-1);
                      }
                      {
#line 4594
                      tmp___14 = is_valid_filename((char const   *)*(argv + 3));
                      }
#line 4594
                      if (tmp___14 != 0) {
#line 4595
                        return (-1);
                      }
                      {
#line 4597
                      lprintf(7, "FRU ID           : %d", (int )fru_id);
#line 4598
                      lprintf(7, "FRU File         : %s", *(argv + 3));
#line 4600
                      rc = ipmi_fru_read_internal_use(intf, fru_id, *(argv + 3));
                      }
                    }
                  } else
                  _L___2: /* CIL Label */ 
#line 4602
                  if (argc >= 4) {
                    {
#line 4602
                    tmp___17 = strncmp((char const   *)*(argv + 2), "write", (size_t )5);
                    }
#line 4602
                    if (tmp___17) {
                      {
#line 4616
                      lprintf(3, "Either unknown command or not enough parameters given.");
#line 4618
                      ipmi_fru_internaluse_help();
                      }
#line 4619
                      return (-1);
                    } else {
                      {
#line 4604
                      tmp___15 = is_fru_id((char const   *)*(argv + 1), & fru_id);
                      }
#line 4604
                      if (tmp___15 != 0) {
#line 4605
                        return (-1);
                      }
                      {
#line 4608
                      tmp___16 = is_valid_filename((char const   *)*(argv + 3));
                      }
#line 4608
                      if (tmp___16 != 0) {
#line 4609
                        return (-1);
                      }
                      {
#line 4611
                      lprintf(7, "FRU ID           : %d", (int )fru_id);
#line 4612
                      lprintf(7, "FRU File         : %s", *(argv + 3));
#line 4614
                      rc = ipmi_fru_write_internal_use(intf, fru_id, *(argv + 3));
                      }
                    }
                  } else {
                    {
#line 4616
                    lprintf(3, "Either unknown command or not enough parameters given.");
#line 4618
                    ipmi_fru_internaluse_help();
                    }
#line 4619
                    return (-1);
                  }
                }
              } else {
#line 4550
                if (argc > 1) {
                  {
#line 4550
                  tmp___7 = strcmp((char const   *)*(argv + 1), "help");
                  }
#line 4550
                  if (tmp___7 == 0) {
                    {
#line 4551
                    ipmi_fru_upgekey_help();
                    }
#line 4552
                    return (0);
                  } else {
#line 4550
                    goto _L___1;
                  }
                } else
                _L___1: /* CIL Label */ 
#line 4553
                if (argc < 3) {
                  {
#line 4554
                  lprintf(3, "Not enough parameters given.");
#line 4555
                  ipmi_fru_upgekey_help();
                  }
#line 4556
                  return (-1);
                }
                {
#line 4559
                tmp___8 = is_fru_id((char const   *)*(argv + 1), & fru_id);
                }
#line 4559
                if (tmp___8 != 0) {
#line 4560
                  return (-1);
                }
                {
#line 4563
                tmp___9 = is_valid_filename((char const   *)*(argv + 2));
                }
#line 4563
                if (tmp___9 != 0) {
#line 4564
                  return (-1);
                }
                {
#line 4566
                rc = ipmi_fru_upg_ekeying(intf, *(argv + 2), fru_id);
                }
              }
            } else {
#line 4526
              if (argc > 1) {
                {
#line 4526
                tmp___4 = strcmp((char const   *)*(argv + 1), "help");
                }
#line 4526
                if (tmp___4 == 0) {
                  {
#line 4527
                  ipmi_fru_write_help();
                  }
#line 4528
                  return (0);
                } else {
#line 4526
                  goto _L___0;
                }
              } else
              _L___0: /* CIL Label */ 
#line 4529
              if (argc < 3) {
                {
#line 4530
                lprintf(3, "Not enough parameters given.");
#line 4531
                ipmi_fru_write_help();
                }
#line 4532
                return (-1);
              }
              {
#line 4535
              tmp___5 = is_fru_id((char const   *)*(argv + 1), & fru_id);
              }
#line 4535
              if (tmp___5 != 0) {
#line 4536
                return (-1);
              }
              {
#line 4539
              tmp___6 = is_valid_filename((char const   *)*(argv + 2));
              }
#line 4539
              if (tmp___6 != 0) {
#line 4540
                return (-1);
              }
#line 4542
              if (verbose) {
                {
#line 4543
                printf((char const   */* __restrict  */)"FRU ID           : %d\n",
                       (int )fru_id);
#line 4544
                printf((char const   */* __restrict  */)"FRU File         : %s\n",
                       *(argv + 2));
                }
              }
              {
#line 4547
              ipmi_fru_write_from_bin(intf, *(argv + 2), fru_id);
              }
            }
          } else {
#line 4502
            if (argc > 1) {
              {
#line 4502
              tmp___1 = strcmp((char const   *)*(argv + 1), "help");
              }
#line 4502
              if (tmp___1 == 0) {
                {
#line 4503
                ipmi_fru_read_help();
                }
#line 4504
                return (0);
              } else {
#line 4502
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
#line 4505
            if (argc < 3) {
              {
#line 4506
              lprintf(3, "Not enough parameters given.");
#line 4507
              ipmi_fru_read_help();
              }
#line 4508
              return (-1);
            }
            {
#line 4511
            tmp___2 = is_fru_id((char const   *)*(argv + 1), & fru_id);
            }
#line 4511
            if (tmp___2 != 0) {
#line 4512
              return (-1);
            }
            {
#line 4515
            tmp___3 = is_valid_filename((char const   *)*(argv + 2));
            }
#line 4515
            if (tmp___3 != 0) {
#line 4516
              return (-1);
            }
#line 4518
            if (verbose) {
              {
#line 4519
              printf((char const   */* __restrict  */)"FRU ID           : %d\n", (int )fru_id);
#line 4520
              printf((char const   */* __restrict  */)"FRU File         : %s\n", *(argv + 2));
              }
            }
            {
#line 4523
            ipmi_fru_read_to_bin(intf, *(argv + 2), fru_id);
            }
          }
        }
      }
    }
  }
#line 4702
  return (rc);
}
}
#line 4718 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_set_field_string(struct ipmi_intf *intf , unsigned char fruId ,
                                     uint8_t f_type , uint8_t f_index , char *f_string ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct fru_info fru ;
  struct fru_header header ;
  uint8_t msg_data[4] ;
  uint8_t checksum ;
  int i ;
  int rc ;
  uint8_t *fru_data ;
  uint8_t *fru_area ;
  uint32_t fru_field_offset ;
  uint32_t fru_field_offset_tmp ;
  uint32_t fru_section_len ;
  uint32_t header_offset ;
  char const   *tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;

  {
  {
#line 4729
  i = 0;
#line 4730
  rc = 1;
#line 4731
  fru_data = (uint8_t *)((void *)0);
#line 4732
  fru_area = (uint8_t *)((void *)0);
#line 4736
  memset((void *)(msg_data), 0, (size_t )4);
#line 4737
  msg_data[0] = fruId;
#line 4739
  memset((void *)(& req), 0, sizeof(req));
#line 4740
  req.msg.netfn = (uint8_t )10;
#line 4741
  req.msg.cmd = (uint8_t )16;
#line 4742
  req.msg.data = msg_data;
#line 4743
  req.msg.data_len = (uint16_t )1;
#line 4745
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 4746
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 4747
    printf((char const   */* __restrict  */)" Device not present (No Response)\n");
#line 4748
    rc = -1;
    }
#line 4749
    goto ipmi_fru_set_field_string_out;
  }
#line 4751
  if ((int )rsp->ccode > 0) {
    {
#line 4752
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 4752
    printf((char const   */* __restrict  */)" Device not present (%s)\n", tmp);
#line 4754
    rc = -1;
    }
#line 4755
    goto ipmi_fru_set_field_string_out;
  }
#line 4758
  fru.size = (uint16_t )(((int )rsp->data[1] << 8) | (int )rsp->data[0]);
#line 4759
  fru.access = (uint8_t )((int )rsp->data[2] & 1);
#line 4761
  if ((int )fru.size < 1) {
    {
#line 4762
    printf((char const   */* __restrict  */)" Invalid FRU size %d", (int )fru.size);
#line 4763
    rc = -1;
    }
#line 4764
    goto ipmi_fru_set_field_string_out;
  }
  {
#line 4769
  msg_data[0] = fruId;
#line 4770
  msg_data[1] = (uint8_t )0;
#line 4771
  msg_data[2] = (uint8_t )0;
#line 4772
  msg_data[3] = (uint8_t )8;
#line 4774
  memset((void *)(& req), 0, sizeof(req));
#line 4775
  req.msg.netfn = (uint8_t )10;
#line 4776
  req.msg.cmd = (uint8_t )17;
#line 4777
  req.msg.data = msg_data;
#line 4778
  req.msg.data_len = (uint16_t )4;
#line 4780
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 4781
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 4783
    printf((char const   */* __restrict  */)" Device not present (No Response)\n");
#line 4784
    rc = -1;
    }
#line 4785
    goto ipmi_fru_set_field_string_out;
  }
#line 4787
  if ((int )rsp->ccode > 0) {
    {
#line 4789
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 4789
    printf((char const   */* __restrict  */)" Device not present (%s)\n", tmp___0);
#line 4791
    rc = -1;
    }
#line 4792
    goto ipmi_fru_set_field_string_out;
  }
#line 4795
  if (verbose > 1) {
    {
#line 4796
    printbuf((uint8_t const   *)(rsp->data), rsp->data_len, "FRU DATA");
    }
  }
  {
#line 4798
  memcpy((void */* __restrict  */)(& header), (void const   */* __restrict  */)(rsp->data + 1),
         (size_t )8);
  }
#line 4800
  if ((int )header.version != 1) {
    {
#line 4802
    printf((char const   */* __restrict  */)" Unknown FRU header version 0x%02x",
           (int )header.version);
#line 4804
    rc = -1;
    }
#line 4805
    goto ipmi_fru_set_field_string_out;
  }
  {
#line 4808
  tmp___1 = malloc((size_t )fru.size);
#line 4808
  fru_data = (uint8_t *)tmp___1;
  }
#line 4810
  if ((unsigned long )fru_data == (unsigned long )((void *)0)) {
    {
#line 4812
    printf((char const   */* __restrict  */)"Out of memory!\n");
#line 4813
    rc = -1;
    }
#line 4814
    goto ipmi_fru_set_field_string_out;
  }
#line 4820
  if ((int )f_type == 99) {
    {
#line 4821
    header_offset = (uint32_t )((int )header.offset.chassis * 8);
#line 4822
    read_fru_area(intf, & fru, fruId, header_offset, (uint32_t )3, fru_data);
#line 4823
    fru_field_offset = (uint32_t )((int )header.offset.chassis * 8 + 3);
#line 4824
    fru_section_len = (uint32_t )((int )*((fru_data + header_offset) + 1) * 8);
    }
  } else
#line 4827
  if ((int )f_type == 98) {
    {
#line 4828
    header_offset = (uint32_t )((int )header.offset.board * 8);
#line 4829
    read_fru_area(intf, & fru, fruId, header_offset, (uint32_t )3, fru_data);
#line 4830
    fru_field_offset = (uint32_t )((int )header.offset.board * 8 + 6);
#line 4831
    fru_section_len = (uint32_t )((int )*((fru_data + header_offset) + 1) * 8);
    }
  } else
#line 4834
  if ((int )f_type == 112) {
    {
#line 4835
    header_offset = (uint32_t )((int )header.offset.product * 8);
#line 4836
    read_fru_area(intf, & fru, fruId, header_offset, (uint32_t )3, fru_data);
#line 4837
    fru_field_offset = (uint32_t )((int )header.offset.product * 8 + 3);
#line 4838
    fru_section_len = (uint32_t )((int )*((fru_data + header_offset) + 1) * 8);
    }
  } else {
    {
#line 4842
    printf((char const   */* __restrict  */)"Wrong field type.");
#line 4843
    rc = -1;
    }
#line 4844
    goto ipmi_fru_set_field_string_out;
  }
  {
#line 4846
  memset((void *)fru_data, 0, (size_t )fru.size);
#line 4847
  tmp___2 = read_fru_area(intf, & fru, fruId, header_offset, fru_section_len, fru_data);
  }
#line 4847
  if (tmp___2 < 0) {
#line 4850
    rc = -1;
#line 4851
    goto ipmi_fru_set_field_string_out;
  }
#line 4854
  f_index = (uint8_t )((int )f_index - 48);
#line 4857
  i = 0;
  {
#line 4857
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4857
    if (! (i <= (int )f_index)) {
#line 4857
      goto while_break;
    }
#line 4858
    fru_field_offset_tmp = fru_field_offset;
#line 4859
    if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
      {
#line 4860
      free((void *)fru_area);
#line 4861
      fru_area = (uint8_t *)((void *)0);
      }
    }
    {
#line 4863
    tmp___3 = get_fru_area_str(fru_data, & fru_field_offset);
#line 4863
    fru_area = (uint8_t *)tmp___3;
#line 4857
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4866
  if ((unsigned long )fru_area == (unsigned long )((void *)0)) {
    {
#line 4867
    printf((char const   */* __restrict  */)"Field not found !\n");
#line 4868
    rc = -1;
    }
#line 4869
    goto ipmi_fru_set_field_string_out;
  } else {
    {
#line 4866
    tmp___4 = strlen((char const   *)fru_area);
    }
#line 4866
    if (tmp___4 == 0UL) {
      {
#line 4867
      printf((char const   */* __restrict  */)"Field not found !\n");
#line 4868
      rc = -1;
      }
#line 4869
      goto ipmi_fru_set_field_string_out;
    }
  }
  {
#line 4872
  tmp___8 = strlen((char const   *)fru_area);
#line 4872
  tmp___9 = strlen((char const   *)f_string);
  }
#line 4872
  if (tmp___8 == tmp___9) {
    {
#line 4874
    printf((char const   */* __restrict  */)"Updating Field \'%s\' with \'%s\' ...\n",
           fru_area, f_string);
#line 4875
    tmp___5 = strlen((char const   *)f_string);
#line 4875
    memcpy((void */* __restrict  */)((fru_data + fru_field_offset_tmp) + 1), (void const   */* __restrict  */)f_string,
           tmp___5);
#line 4878
    checksum = (uint8_t )0;
#line 4880
    i = (int )header_offset;
    }
    {
#line 4880
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4880
      if (! ((uint32_t )i < (header_offset + fru_section_len) - 1U)) {
#line 4880
        goto while_break___0;
      }
#line 4883
      checksum = (uint8_t )((int )checksum + (int )*(fru_data + i));
#line 4880
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 4885
    checksum = (uint8_t )(~ ((int )checksum) + 1);
#line 4886
    *(fru_data + ((header_offset + fru_section_len) - 1U)) = checksum;
#line 4889
    tmp___6 = write_fru_area(intf, & fru, fruId, (uint16_t )header_offset, (uint16_t )header_offset,
                             (uint16_t )fru_section_len, fru_data);
    }
#line 4889
    if (tmp___6 < 0) {
      {
#line 4892
      printf((char const   */* __restrict  */)"Write to FRU data failed.\n");
#line 4893
      rc = -1;
      }
#line 4894
      goto ipmi_fru_set_field_string_out;
    }
  } else {
    {
#line 4898
    printf((char const   */* __restrict  */)"String size are not equal, resizing fru to fit new string\n");
#line 4899
    tmp___7 = ipmi_fru_set_field_string_rebuild(intf, fruId, fru, header, f_type,
                                                f_index, f_string);
    }
#line 4899
    if (tmp___7) {
#line 4903
      rc = -1;
#line 4904
      goto ipmi_fru_set_field_string_out;
    }
  }
  ipmi_fru_set_field_string_out: 
#line 4909
  if ((unsigned long )fru_data != (unsigned long )((void *)0)) {
    {
#line 4910
    free((void *)fru_data);
#line 4911
    fru_data = (uint8_t *)((void *)0);
    }
  }
#line 4913
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 4914
    free((void *)fru_area);
#line 4915
    fru_area = (uint8_t *)((void *)0);
    }
  }
#line 4918
  return (rc);
}
}
#line 4950 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_set_field_string_rebuild(struct ipmi_intf *intf , uint8_t fruId ,
                                             struct fru_info fru , struct fru_header header ,
                                             uint8_t f_type , uint8_t f_index , char *f_string ) 
{ 
  int i ;
  uint8_t *fru_data_old ;
  uint8_t *fru_data_new ;
  uint8_t *fru_area ;
  uint32_t fru_field_offset ;
  uint32_t fru_field_offset_tmp ;
  uint32_t fru_section_len ;
  uint32_t old_section_len ;
  uint32_t header_offset ;
  uint32_t chassis_offset ;
  uint32_t board_offset ;
  uint32_t product_offset ;
  uint32_t chassis_len ;
  uint32_t board_len ;
  uint32_t product_len ;
  uint32_t product_len_new ;
  int num_byte_change ;
  int padding_len ;
  uint32_t counter ;
  unsigned char cksum ;
  int rc ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  uint32_t remaining_offset ;
  int change_size_by_8 ;
  unsigned char *pfru_header ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;

  {
  {
#line 4957
  i = 0;
#line 4958
  fru_data_old = (uint8_t *)((void *)0);
#line 4959
  fru_data_new = (uint8_t *)((void *)0);
#line 4960
  fru_area = (uint8_t *)((void *)0);
#line 4965
  num_byte_change = 0;
#line 4965
  padding_len = 0;
#line 4968
  rc = 1;
#line 4970
  tmp = calloc((size_t )fru.size, sizeof(uint8_t ));
#line 4970
  fru_data_old = (uint8_t *)tmp;
#line 4972
  tmp___0 = malloc((size_t )fru.size);
#line 4972
  fru_data_new = (uint8_t *)tmp___0;
  }
#line 4974
  if ((unsigned long )fru_data_old == (unsigned long )((void *)0)) {
    {
#line 4976
    printf((char const   */* __restrict  */)"Out of memory!\n");
#line 4977
    rc = -1;
    }
#line 4978
    goto ipmi_fru_set_field_string_rebuild_out;
  } else
#line 4974
  if ((unsigned long )fru_data_new == (unsigned long )((void *)0)) {
    {
#line 4976
    printf((char const   */* __restrict  */)"Out of memory!\n");
#line 4977
    rc = -1;
    }
#line 4978
    goto ipmi_fru_set_field_string_rebuild_out;
  }
  {
#line 4983
  printf((char const   */* __restrict  */)"Read All FRU area\n");
#line 4984
  printf((char const   */* __restrict  */)"Fru Size       : %u bytes\n", (int )fru.size);
#line 4987
  read_fru_area(intf, & fru, fruId, (uint32_t )0, (uint32_t )fru.size, fru_data_old);
#line 4990
  printf((char const   */* __restrict  */)"Copy to new FRU\n");
#line 4995
  memcpy((void */* __restrict  */)fru_data_new, (void const   */* __restrict  */)fru_data_old,
         (size_t )fru.size);
#line 4998
  chassis_offset = (uint32_t )((int )header.offset.chassis * 8);
#line 4999
  board_offset = (uint32_t )((int )header.offset.board * 8);
#line 5000
  product_offset = (uint32_t )((int )header.offset.product * 8);
#line 5003
  chassis_len = (uint32_t )((int )*((fru_data_old + chassis_offset) + 1) * 8);
#line 5004
  board_len = (uint32_t )((int )*((fru_data_old + board_offset) + 1) * 8);
#line 5005
  product_len = (uint32_t )((int )*((fru_data_old + product_offset) + 1) * 8);
#line 5006
  product_len_new = product_len;
  }
#line 5009
  if ((int )f_type == 99) {
#line 5011
    header_offset = chassis_offset;
#line 5012
    fru_field_offset = chassis_offset + 3U;
#line 5013
    fru_section_len = chassis_len;
  } else
#line 5016
  if ((int )f_type == 98) {
#line 5018
    header_offset = board_offset;
#line 5019
    fru_field_offset = board_offset + 6U;
#line 5020
    fru_section_len = board_len;
  } else
#line 5023
  if ((int )f_type == 112) {
#line 5025
    header_offset = product_offset;
#line 5026
    fru_field_offset = product_offset + 3U;
#line 5027
    fru_section_len = product_len;
  } else {
    {
#line 5031
    printf((char const   */* __restrict  */)"Wrong field type.");
#line 5032
    rc = -1;
    }
#line 5033
    goto ipmi_fru_set_field_string_rebuild_out;
  }
#line 5037
  old_section_len = fru_section_len;
#line 5041
  i = 0;
  {
#line 5041
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5041
    if (! (i <= (int )f_index)) {
#line 5041
      goto while_break;
    }
#line 5042
    fru_field_offset_tmp = fru_field_offset;
#line 5043
    if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
      {
#line 5044
      free((void *)fru_area);
#line 5045
      fru_area = (uint8_t *)((void *)0);
      }
    }
    {
#line 5047
    tmp___1 = get_fru_area_str(fru_data_old, & fru_field_offset);
#line 5047
    fru_area = (uint8_t *)tmp___1;
#line 5041
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5050
  if ((unsigned long )fru_area == (unsigned long )((void *)0)) {
    {
#line 5051
    printf((char const   */* __restrict  */)"Field not found (1)!\n");
#line 5052
    rc = -1;
    }
#line 5053
    goto ipmi_fru_set_field_string_rebuild_out;
  } else {
    {
#line 5050
    tmp___2 = strlen((char const   *)fru_area);
    }
#line 5050
    if (tmp___2 == 0UL) {
      {
#line 5051
      printf((char const   */* __restrict  */)"Field not found (1)!\n");
#line 5052
      rc = -1;
      }
#line 5053
      goto ipmi_fru_set_field_string_rebuild_out;
    }
  }
  {
#line 5057
  printf((char const   */* __restrict  */)"Section Length: %u\n", fru_section_len);
#line 5062
  counter = (uint32_t )2;
  }
  {
#line 5062
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5062
    if (! (counter < fru_section_len)) {
#line 5062
      goto while_break___0;
    }
#line 5064
    if ((int )*(fru_data_old + ((header_offset + fru_section_len) - counter)) == 0) {
#line 5065
      padding_len ++;
    } else {
#line 5067
      goto while_break___0;
    }
#line 5062
    counter ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 5069
  tmp___3 = strlen((char const   *)f_string);
#line 5069
  tmp___4 = strlen((char const   *)fru_area);
#line 5069
  num_byte_change = (int )(tmp___3 - tmp___4);
#line 5072
  printf((char const   */* __restrict  */)"Padding Length: %u\n", padding_len);
#line 5073
  printf((char const   */* __restrict  */)"NumByte Change: %i\n", num_byte_change);
#line 5074
  printf((char const   */* __restrict  */)"Start SecChnge: %x\n", (int )*(fru_data_old + fru_field_offset_tmp));
#line 5075
  tmp___5 = strlen((char const   *)f_string);
#line 5075
  printf((char const   */* __restrict  */)"End SecChnge  : %x\n", (int )*(((fru_data_old + fru_field_offset_tmp) + tmp___5) + 1));
#line 5077
  printf((char const   */* __restrict  */)"Start Section : %x\n", (int )*(fru_data_old + header_offset));
#line 5078
  printf((char const   */* __restrict  */)"End Sec wo Pad: %x\n", (int )*((((fru_data_old + header_offset) + fru_section_len) - 2) - padding_len));
#line 5079
  printf((char const   */* __restrict  */)"End Section   : %x\n", (int )*(((fru_data_old + header_offset) + fru_section_len) - 1));
#line 5083
  padding_len -= num_byte_change;
#line 5086
  printf((char const   */* __restrict  */)"New Padding Length: %i\n", padding_len);
  }
#line 5091
  if (padding_len < 0) {
#line 5091
    goto _L;
  } else
#line 5091
  if (padding_len >= 8) {
    _L: /* CIL Label */ 
#line 5093
    remaining_offset = (uint32_t )((int )header.offset.product * 8) + product_len;
#line 5096
    if (padding_len >= 8) {
#line 5099
      change_size_by_8 = (padding_len / 8) * -1;
    } else {
#line 5104
      change_size_by_8 = 1 + ((padding_len + 1) / 8) * -1;
    }
    {
#line 5108
    fru_section_len += (uint32_t )(change_size_by_8 * 8);
#line 5109
    padding_len += change_size_by_8 * 8;
#line 5112
    printf((char const   */* __restrict  */)"change_size_by_8: %i\n", change_size_by_8);
#line 5113
    printf((char const   */* __restrict  */)"New Padding Length: %i\n", padding_len);
#line 5114
    printf((char const   */* __restrict  */)"change_size_by_8: %i\n", change_size_by_8);
#line 5115
    printf((char const   */* __restrict  */)"header.offset.board: %i\n", (int )header.offset.board);
    }
#line 5125
    if ((int )f_type == 99) {
      {
#line 5127
      printf((char const   */* __restrict  */)"Moving Section Chassis, from %i to %i\n",
             (int )header.offset.board * 8, ((int )header.offset.board + change_size_by_8) * 8);
#line 5131
      memcpy((void */* __restrict  */)(fru_data_new + ((int )header.offset.board + change_size_by_8) * 8),
             (void const   */* __restrict  */)(fru_data_old + (int )header.offset.board * 8),
             (size_t )board_len);
#line 5136
      header.offset.board = (uint8_t )((int )header.offset.board + change_size_by_8);
      }
    }
#line 5139
    if ((int )f_type == 99) {
      {
#line 5141
      printf((char const   */* __restrict  */)"Moving Section Product, from %i to %i\n",
             (int )header.offset.product * 8, ((int )header.offset.product + change_size_by_8) * 8);
#line 5145
      memcpy((void */* __restrict  */)(fru_data_new + ((int )header.offset.product + change_size_by_8) * 8),
             (void const   */* __restrict  */)(fru_data_old + (int )header.offset.product * 8),
             (size_t )product_len);
#line 5150
      header.offset.product = (uint8_t )((int )header.offset.product + change_size_by_8);
      }
    } else
#line 5139
    if ((int )f_type == 98) {
      {
#line 5141
      printf((char const   */* __restrict  */)"Moving Section Product, from %i to %i\n",
             (int )header.offset.product * 8, ((int )header.offset.product + change_size_by_8) * 8);
#line 5145
      memcpy((void */* __restrict  */)(fru_data_new + ((int )header.offset.product + change_size_by_8) * 8),
             (void const   */* __restrict  */)(fru_data_old + (int )header.offset.product * 8),
             (size_t )product_len);
#line 5150
      header.offset.product = (uint8_t )((int )header.offset.product + change_size_by_8);
      }
    }
#line 5154
    if ((int )f_type == 99) {
#line 5156
      *((fru_data_new + chassis_offset) + 1) = (uint8_t )((int )*((fru_data_new + chassis_offset) + 1) + change_size_by_8);
    } else
#line 5158
    if ((int )f_type == 98) {
#line 5160
      *((fru_data_new + board_offset) + 1) = (uint8_t )((int )*((fru_data_new + board_offset) + 1) + change_size_by_8);
    } else
#line 5162
    if ((int )f_type == 112) {
#line 5164
      *((fru_data_new + product_offset) + 1) = (uint8_t )((int )*((fru_data_new + product_offset) + 1) + change_size_by_8);
#line 5165
      product_len_new = (uint32_t )((int )*((fru_data_new + product_offset) + 1) * 8);
    }
#line 5170
    pfru_header = (unsigned char *)(& header);
#line 5171
    header.checksum = (uint8_t )0;
#line 5172
    counter = (uint32_t )0;
    {
#line 5172
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 5172
      if (! ((unsigned long )counter < sizeof(struct fru_header ) - 1UL)) {
#line 5172
        goto while_break___1;
      }
#line 5174
      header.checksum = (uint8_t )((int )header.checksum + (int )*(pfru_header + counter));
#line 5172
      counter ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 5176
    header.checksum = (uint8_t )(0 - (int )header.checksum);
#line 5177
    memcpy((void */* __restrict  */)fru_data_new, (void const   */* __restrict  */)pfru_header,
           sizeof(struct fru_header ));
#line 5181
    printf((char const   */* __restrict  */)"Moving Remaining Bytes (Multi-Rec , etc..), from %i to %i\n",
           remaining_offset, (uint32_t )((int )header.offset.product * 8) + product_len_new);
    }
#line 5185
    if (((uint32_t )((int )header.offset.product * 8) + product_len_new) - remaining_offset < 0U) {
      {
#line 5187
      memcpy((void */* __restrict  */)((fru_data_new + (int )header.offset.product * 8) + product_len_new),
             (void const   */* __restrict  */)(fru_data_old + remaining_offset), (size_t )((uint32_t )fru.size - remaining_offset));
      }
    } else {
      {
#line 5195
      memcpy((void */* __restrict  */)((fru_data_new + (int )header.offset.product * 8) + product_len_new),
             (void const   */* __restrict  */)(fru_data_old + remaining_offset), (size_t )((uint32_t )fru.size - ((uint32_t )((int )header.offset.product * 8) + product_len_new)));
      }
    }
  }
#line 5207
  if (padding_len >= 0) {
#line 5207
    if (padding_len < 8) {
      {
#line 5212
      tmp___6 = strlen((char const   *)f_string);
#line 5212
      printf((char const   */* __restrict  */)"Updating Field : \'%s\' with \'%s\' ... (Length from \'%d\' to \'%d\')\n",
             fru_area, f_string, (int )*(fru_data_old + fru_field_offset_tmp), (int )(192UL + tmp___6));
#line 5217
      tmp___7 = strlen((char const   *)f_string);
#line 5217
      *(fru_data_new + fru_field_offset_tmp) = (uint8_t )(192UL + tmp___7);
#line 5218
      tmp___8 = strlen((char const   *)f_string);
#line 5218
      memcpy((void */* __restrict  */)((fru_data_new + fru_field_offset_tmp) + 1),
             (void const   */* __restrict  */)f_string, tmp___8);
#line 5222
      tmp___9 = strlen((char const   *)f_string);
#line 5222
      printf((char const   */* __restrict  */)"Copying remaining of sections: %d \n",
             (int )((((fru_data_old + header_offset) + fru_section_len) - 1) - (((fru_data_old + fru_field_offset_tmp) + tmp___9) + 1)));
#line 5227
      tmp___10 = strlen((char const   *)f_string);
#line 5227
      tmp___11 = strlen((char const   *)fru_area);
#line 5227
      tmp___12 = strlen((char const   *)f_string);
#line 5227
      memcpy((void */* __restrict  */)(((fru_data_new + fru_field_offset_tmp) + 1) + tmp___12),
             (void const   */* __restrict  */)(((fru_data_old + fru_field_offset_tmp) + 1) + tmp___11),
             (size_t )((((fru_data_old + header_offset) + fru_section_len) - 1) - (((fru_data_old + fru_field_offset_tmp) + tmp___10) + 1)));
#line 5235
      counter = (uint32_t )0;
      }
      {
#line 5235
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 5235
        if (! (counter < (uint32_t )padding_len)) {
#line 5235
          goto while_break___2;
        }
#line 5237
        *(((((fru_data_new + header_offset) + fru_section_len) - 1) - padding_len) + counter) = (uint8_t )0;
#line 5235
        counter ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 5242
      cksum = (unsigned char)0;
#line 5243
      counter = (uint32_t )0;
      {
#line 5243
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 5243
        if (! (counter < fru_section_len - 1U)) {
#line 5243
          goto while_break___3;
        }
#line 5245
        cksum = (unsigned char )((int )cksum + (int )*((fru_data_new + header_offset) + counter));
#line 5243
        counter ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 5247
      *(((fru_data_new + header_offset) + fru_section_len) - 1) = (uint8_t )(0 - (int )cksum);
#line 5250
      printf((char const   */* __restrict  */)"Calculate New Checksum: %x\n", 0 - (int )cksum);
      }
    } else {
      {
#line 5280
      printf((char const   */* __restrict  */)"Internal error, padding length %i (must be from 0 to 7) ",
             padding_len);
#line 5281
      rc = -1;
      }
#line 5282
      goto ipmi_fru_set_field_string_rebuild_out;
    }
  } else {
    {
#line 5280
    printf((char const   */* __restrict  */)"Internal error, padding length %i (must be from 0 to 7) ",
           padding_len);
#line 5281
    rc = -1;
    }
#line 5282
    goto ipmi_fru_set_field_string_rebuild_out;
  }
  {
#line 5287
  printf((char const   */* __restrict  */)"Writing new FRU.\n");
#line 5288
  tmp___13 = write_fru_area(intf, & fru, fruId, (uint16_t )0, (uint16_t )0, fru.size,
                            fru_data_new);
  }
#line 5288
  if (tmp___13 < 0) {
    {
#line 5290
    printf((char const   */* __restrict  */)"Write to FRU data failed.\n");
#line 5291
    rc = -1;
    }
#line 5292
    goto ipmi_fru_set_field_string_rebuild_out;
  }
  {
#line 5295
  printf((char const   */* __restrict  */)"Done.\n");
  }
  ipmi_fru_set_field_string_rebuild_out: 
#line 5298
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 5299
    free((void *)fru_area);
#line 5300
    fru_area = (uint8_t *)((void *)0);
    }
  }
#line 5302
  if ((unsigned long )fru_data_new != (unsigned long )((void *)0)) {
    {
#line 5303
    free((void *)fru_data_new);
#line 5304
    fru_data_new = (uint8_t *)((void *)0);
    }
  }
#line 5306
  if ((unsigned long )fru_data_old != (unsigned long )((void *)0)) {
    {
#line 5307
    free((void *)fru_data_old);
#line 5308
    fru_data_old = (uint8_t *)((void *)0);
    }
  }
#line 5311
  return (rc);
}
}
#line 38 "../include/ipmitool/ipmi_firewall.h"
int ipmi_firewall_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 99 "../include/ipmitool/ipmi_firewall.h"
__inline static int bit_test(unsigned char const   *bf , int n ) 
{ 


  {
#line 100
  return (! (! ((int const   )*(bf + (n >> 3)) & (int const   )(1 << n % 8))));
}
}
#line 102 "../include/ipmitool/ipmi_firewall.h"
__inline static void bit_set(unsigned char *bf , int n , int v ) 
{ 
  int tmp ;

  {
#line 103
  if (v) {
#line 103
    tmp = 1;
  } else {
#line 103
    tmp = 0;
  }
#line 103
  *(bf + (n >> 3)) = (unsigned char )(((int )*(bf + (n >> 3)) & ~ (1 << n % 8)) | (tmp << n % 8));
#line 104
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static void printf_firewall_usage(void) 
{ 


  {
  {
#line 50
  lprintf(5, "Firmware Firewall Commands:");
#line 52
  lprintf(5, "\tinfo [channel H] [lun L]");
#line 54
  lprintf(5, "\tinfo [channel H] [lun L [netfn N [command C [subfn S]]]]");
#line 56
  lprintf(5, "\tenable [channel H] [lun L [netfn N [command C [subfn S]]]]");
#line 58
  lprintf(5, "\tdisable [channel H] [lun L [netfn N [command C [subfn S]]]] [force])");
#line 60
  lprintf(5, "\treset [channel H]");
#line 62
  lprintf(5, "\t\twhere H is a Channel, L is a LUN, N is a NetFn,");
#line 64
  lprintf(5, "\t\tC is a Command and S is a Sub-Function");
  }
#line 66
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
void printf_firewall_info_usage(void) 
{ 


  {
  {
#line 71
  lprintf(5, "info [channel H]");
#line 73
  lprintf(5, "\tList all of the firewall information for all LUNs, NetFns");
#line 75
  lprintf(5, "\tand Commands, This is a long list and is not very human readable.");
#line 77
  lprintf(5, "info [channel H] lun L");
#line 79
  lprintf(5, "\tThis also prints a long list that is not very human readable.");
#line 81
  lprintf(5, "info [channel H] lun L netfn N");
#line 83
  lprintf(5, "\tThis prints out information for a single LUN/NetFn pair.");
#line 85
  lprintf(5, "\tThat is not really very usable, but at least it is short.");
#line 87
  lprintf(5, "info [channel H] lun L netfn N command C");
#line 89
  lprintf(5, "\tThis is the one you want -- it prints out detailed human");
#line 91
  lprintf(5, "\treadable information.  It shows the support, configurable, and");
#line 93
  lprintf(5, "\tenabled bits for the Command C on LUN/NetFn pair L,N and the");
#line 95
  lprintf(5, "\tsame information about each of its Sub-functions.");
  }
#line 97
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static void print_bitfield(unsigned char const   *bf , int n , int invert , int loglevel ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 101
  i = 0;
#line 102
  if (loglevel < 0) {
    {
#line 103
    while (1) {
      while_continue: /* CIL Label */ ;
#line 103
      if (! (i < n)) {
#line 103
        goto while_break;
      }
#line 104
      if (invert) {
#line 104
        tmp = ~ ((int const   )*(bf + i));
      } else {
#line 104
        tmp = (int const   )*(bf + i);
      }
      {
#line 104
      printf((char const   */* __restrict  */)"%02x", (int )((unsigned char )tmp));
#line 105
      i ++;
      }
#line 105
      if (i % 4 == 0) {
        {
#line 106
        printf((char const   */* __restrict  */)" ");
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 108
    printf((char const   */* __restrict  */)"\n");
    }
  } else {
    {
#line 110
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 110
      if (! (i < n)) {
#line 110
        goto while_break___0;
      }
#line 111
      if (invert) {
#line 111
        tmp___0 = ~ ((int const   )*(bf + i));
      } else {
#line 111
        tmp___0 = (int const   )*(bf + i);
      }
      {
#line 111
      lprintf(loglevel, "%02x", (int )((unsigned char )tmp___0));
#line 112
      i ++;
      }
#line 112
      if (i % 4 == 0) {
        {
#line 113
        lprintf(loglevel, " ");
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 115
    lprintf(loglevel, "\n");
    }
  }
#line 118
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int ipmi_firewall_parse_args(int argc , char **argv , struct ipmi_function_params *p ) 
{ 
  int i ;
  uint8_t conv_err ;
  uint8_t channel_tmp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 124
  conv_err = (uint8_t )0;
#line 126
  if (! p) {
    {
#line 127
    lprintf(3, "ipmi_firewall_parse_args: p is NULL");
    }
#line 128
    return (-1);
  }
#line 130
  i = 0;
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! (i < argc)) {
#line 130
      goto while_break;
    }
    {
#line 131
    tmp___9 = strncmp((char const   *)*(argv + i), "channel", (size_t )7);
    }
#line 131
    if (tmp___9 == 0) {
#line 131
      i ++;
#line 131
      if (i < argc) {
        {
#line 132
        channel_tmp = (uint8_t )0;
#line 133
        tmp = is_ipmi_channel_num((char const   *)*(argv + i), & channel_tmp);
        }
#line 133
        if (tmp != 0) {
#line 134
          conv_err = (uint8_t )1;
#line 135
          goto while_break;
        } else {
#line 137
          p->channel = (int )channel_tmp;
        }
      } else {
#line 131
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      {
#line 140
      tmp___8 = strncmp((char const   *)*(argv + i), "lun", (size_t )3);
      }
#line 140
      if (tmp___8 == 0) {
#line 140
        i ++;
#line 140
        if (i < argc) {
          {
#line 141
          tmp___0 = str2int((char const   *)*(argv + i), & p->lun);
          }
#line 141
          if (tmp___0 != 0) {
            {
#line 142
            lprintf(3, "Given lun \'%s\' is invalid.", *(argv + i));
#line 143
            conv_err = (uint8_t )1;
            }
#line 144
            goto while_break;
          }
        } else {
#line 140
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        {
#line 147
        tmp___7 = strncmp((char const   *)*(argv + i), "force", (size_t )5);
        }
#line 147
        if (tmp___7 == 0) {
#line 148
          p->force = (unsigned char)1;
        } else {
          {
#line 150
          tmp___6 = strncmp((char const   *)*(argv + i), "netfn", (size_t )5);
          }
#line 150
          if (tmp___6 == 0) {
#line 150
            i ++;
#line 150
            if (i < argc) {
              {
#line 151
              tmp___1 = str2int((char const   *)*(argv + i), & p->netfn);
              }
#line 151
              if (tmp___1 != 0) {
                {
#line 152
                lprintf(3, "Given netfn \'%s\' is invalid.", *(argv + i));
#line 153
                conv_err = (uint8_t )1;
                }
#line 154
                goto while_break;
              }
            } else {
#line 150
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
            {
#line 157
            tmp___5 = strncmp((char const   *)*(argv + i), "command", (size_t )7);
            }
#line 157
            if (tmp___5 == 0) {
#line 157
              i ++;
#line 157
              if (i < argc) {
                {
#line 158
                tmp___2 = str2int((char const   *)*(argv + i), & p->command);
                }
#line 158
                if (tmp___2 != 0) {
                  {
#line 159
                  lprintf(3, "Given command \'%s\' is invalid.", *(argv + i));
#line 160
                  conv_err = (uint8_t )1;
                  }
#line 161
                  goto while_break;
                }
              } else {
#line 157
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              {
#line 164
              tmp___4 = strncmp((char const   *)*(argv + i), "subfn", (size_t )5);
              }
#line 164
              if (tmp___4 == 0) {
#line 164
                i ++;
#line 164
                if (i < argc) {
                  {
#line 165
                  tmp___3 = str2int((char const   *)*(argv + i), & p->subfn);
                  }
#line 165
                  if (tmp___3 != 0) {
                    {
#line 166
                    lprintf(3, "Given subfn \'%s\' is invalid.", *(argv + i));
#line 167
                    conv_err = (uint8_t )1;
                    }
#line 168
                    goto while_break;
                  }
                }
              }
            }
          }
        }
      }
    }
#line 130
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  if ((int )conv_err != 0) {
#line 173
    return (-1);
  }
#line 175
  if (p->subfn >= 32) {
    {
#line 176
    lprintf(3, "subfn is out of range (0-%d)", 31);
    }
#line 177
    return (-1);
  }
#line 179
  if (p->command >= 256) {
    {
#line 180
    lprintf(3, "command is out of range (0-%d)", 255);
    }
#line 181
    return (-1);
  }
#line 183
  if (p->netfn >= 64) {
    {
#line 184
    lprintf(3, "netfn is out of range (0-%d)", 63);
    }
#line 185
    return (-1);
  }
#line 187
  if (p->lun >= 4) {
    {
#line 188
    lprintf(3, "lun is out of range (0-%d)", 3);
    }
#line 189
    return (-1);
  }
#line 191
  if (p->netfn >= 0) {
#line 191
    if (p->lun < 0) {
      {
#line 192
      lprintf(3, "if netfn is set, so must be lun");
      }
#line 193
      return (-1);
    }
  }
#line 195
  if (p->command >= 0) {
#line 195
    if (p->netfn < 0) {
      {
#line 196
      lprintf(3, "if command is set, so must be netfn");
      }
#line 197
      return (-1);
    }
  }
#line 199
  if (p->subfn >= 0) {
#line 199
    if (p->command < 0) {
      {
#line 200
      lprintf(3, "if subfn is set, so must be command");
      }
#line 201
      return (-1);
    }
  }
#line 203
  return (0);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int _get_netfn_support(struct ipmi_intf *intf , int channel , unsigned char *lun ,
                              unsigned char *netfn ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char *d ;
  unsigned char rqdata ;
  unsigned int l ;
  char const   *tmp ;

  {
#line 225
  if (! lun) {
    {
#line 226
    lprintf(3, "_get_netfn_suport: lun or netfn is NULL");
    }
#line 227
    return (-1);
  } else
#line 225
  if (! netfn) {
    {
#line 226
    lprintf(3, "_get_netfn_suport: lun or netfn is NULL");
    }
#line 227
    return (-1);
  }
  {
#line 230
  memset((void *)(& req), 0, sizeof(req));
#line 231
  req.msg.netfn = (uint8_t )6;
#line 232
  req.msg.cmd = (uint8_t )9;
#line 233
  rqdata = (unsigned char )channel;
#line 234
  req.msg.data = & rqdata;
#line 235
  req.msg.data_len = (uint16_t )1;
#line 237
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 238
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 239
    lprintf(3, "Get NetFn Support command failed");
    }
#line 240
    return (-1);
  }
#line 242
  if ((int )rsp->ccode > 0) {
    {
#line 243
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 243
    lprintf(3, "Get NetFn Support command failed: %s", tmp);
    }
#line 245
    return (-1);
  }
#line 248
  d = rsp->data;
#line 249
  l = 0U;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! (l < 4U)) {
#line 249
      goto while_break;
    }
#line 250
    *(lun + l) = (unsigned char )(((int )*d >> 2U * l) & 3);
#line 249
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 252
  d ++;
#line 254
  memcpy((void */* __restrict  */)netfn, (void const   */* __restrict  */)d, (size_t )16);
  }
#line 256
  return (0);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int _get_command_support(struct ipmi_intf *intf , struct ipmi_function_params *p ,
                                struct lun_netfn_support *lnfn ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char *d ;
  unsigned char rqdata[3] ;
  unsigned int c ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 277
  if (! p) {
    {
#line 278
    lprintf(3, "_get_netfn_suport: p or lnfn is NULL");
    }
#line 279
    return (-1);
  } else
#line 277
  if (! lnfn) {
    {
#line 278
    lprintf(3, "_get_netfn_suport: p or lnfn is NULL");
    }
#line 279
    return (-1);
  }
  {
#line 282
  memset((void *)(& req), 0, sizeof(req));
#line 283
  req.msg.netfn = (uint8_t )6;
#line 284
  req.msg.cmd = (uint8_t )10;
#line 285
  rqdata[0] = (unsigned char )p->channel;
#line 286
  rqdata[1] = (unsigned char )p->netfn;
#line 287
  rqdata[2] = (unsigned char )p->lun;
#line 288
  req.msg.data = rqdata;
#line 289
  req.msg.data_len = (uint16_t )3;
#line 291
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 292
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 293
    lprintf(3, "Get Command Support (LUN=%d, NetFn=%d, op=0) command failed", p->lun,
            p->netfn);
    }
#line 294
    return (-1);
  }
#line 296
  if ((int )rsp->ccode > 0) {
    {
#line 297
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 297
    lprintf(3, "Get Command Support (LUN=%d, NetFn=%d, op=0) command failed: %s",
            p->lun, p->netfn, tmp);
    }
#line 299
    return (-1);
  }
#line 302
  d = rsp->data;
#line 303
  c = 0U;
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    if (! (c < 128U)) {
#line 303
      goto while_break;
    }
#line 304
    if (! ((int )*(d + (c >> 3)) & (1 << c % 8U))) {
#line 305
      lnfn->command[c].support = (unsigned char )((int )lnfn->command[c].support | 1);
    }
#line 303
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 307
  memcpy((void */* __restrict  */)(lnfn->command_mask), (void const   */* __restrict  */)d,
         (size_t )((256 >> 3) / 2));
#line 309
  memset((void *)(& req), 0, sizeof(req));
#line 310
  req.msg.netfn = (uint8_t )6;
#line 311
  req.msg.cmd = (uint8_t )10;
#line 312
  rqdata[0] = (unsigned char )p->channel;
#line 313
  rqdata[1] = (unsigned char )(64 | p->netfn);
#line 314
  rqdata[2] = (unsigned char )p->lun;
#line 315
  req.msg.data = rqdata;
#line 316
  req.msg.data_len = (uint16_t )3;
#line 318
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 319
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 320
    lprintf(3, "Get Command Support (LUN=%d, NetFn=%d, op=1) command failed", p->lun,
            p->netfn);
    }
#line 321
    return (-1);
  }
#line 323
  if ((int )rsp->ccode > 0) {
    {
#line 324
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 324
    lprintf(3, "Get Command Support (LUN=%d, NetFn=%d, op=1) command failed: %s",
            p->lun, p->netfn, tmp___0);
    }
#line 326
    return (-1);
  }
#line 329
  d = rsp->data;
#line 330
  c = 0U;
  {
#line 330
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 330
    if (! (c < 128U)) {
#line 330
      goto while_break___0;
    }
#line 331
    if (! ((int )*(d + (c >> 3)) & (1 << c % 8U))) {
#line 332
      lnfn->command[128U + c].support = (unsigned char )((int )lnfn->command[128U + c].support | 1);
    }
#line 330
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 334
  memcpy((void */* __restrict  */)(lnfn->command_mask + (256 >> 3) / 2), (void const   */* __restrict  */)d,
         (size_t )((256 >> 3) / 2));
  }
#line 335
  return (0);
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int _get_command_configurable(struct ipmi_intf *intf , struct ipmi_function_params *p ,
                                     struct lun_netfn_support *lnfn ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char *d ;
  unsigned char rqdata[3] ;
  unsigned int c ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 356
  if (! p) {
    {
#line 357
    lprintf(3, "_get_command_configurable: p or lnfn is NULL");
    }
#line 358
    return (-1);
  } else
#line 356
  if (! lnfn) {
    {
#line 357
    lprintf(3, "_get_command_configurable: p or lnfn is NULL");
    }
#line 358
    return (-1);
  }
  {
#line 361
  memset((void *)(& req), 0, sizeof(req));
#line 362
  req.msg.netfn = (uint8_t )6;
#line 363
  req.msg.cmd = (uint8_t )12;
#line 364
  rqdata[0] = (unsigned char )p->channel;
#line 365
  rqdata[1] = (unsigned char )p->netfn;
#line 366
  rqdata[2] = (unsigned char )p->lun;
#line 367
  req.msg.data = rqdata;
#line 368
  req.msg.data_len = (uint16_t )3;
#line 370
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 371
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 372
    lprintf(3, "Get Configurable Command (LUN=%d, NetFn=%d, op=0) command failed",
            p->lun, p->netfn);
    }
#line 373
    return (-1);
  }
#line 375
  if ((int )rsp->ccode > 0) {
    {
#line 376
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 376
    lprintf(3, "Get Configurable Command (LUN=%d, NetFn=%d, op=0) command failed: %s",
            p->lun, p->netfn, tmp);
    }
#line 378
    return (-1);
  }
#line 381
  d = rsp->data;
#line 382
  c = 0U;
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 382
    if (! (c < 128U)) {
#line 382
      goto while_break;
    }
#line 383
    if ((int )*(d + (c >> 3)) & (1 << c % 8U)) {
#line 384
      lnfn->command[c].support = (unsigned char )((int )lnfn->command[c].support | 2);
    }
#line 382
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 386
  memcpy((void */* __restrict  */)(lnfn->config_mask), (void const   */* __restrict  */)d,
         (size_t )((256 >> 3) / 2));
#line 388
  memset((void *)(& req), 0, sizeof(req));
#line 389
  req.msg.netfn = (uint8_t )6;
#line 390
  req.msg.cmd = (uint8_t )12;
#line 391
  rqdata[0] = (unsigned char )p->channel;
#line 392
  rqdata[1] = (unsigned char )(64 | p->netfn);
#line 393
  rqdata[2] = (unsigned char )p->lun;
#line 394
  req.msg.data = rqdata;
#line 395
  req.msg.data_len = (uint16_t )3;
#line 397
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 398
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 399
    lprintf(3, "Get Configurable Command (LUN=%d, NetFn=%d, op=1) command failed",
            p->lun, p->netfn);
    }
#line 400
    return (-1);
  }
#line 402
  if ((int )rsp->ccode > 0) {
    {
#line 403
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 403
    lprintf(3, "Get Configurable Command (LUN=%d, NetFn=%d, op=1) command failed: %s",
            p->lun, p->netfn, tmp___0);
    }
#line 405
    return (-1);
  }
#line 408
  d = rsp->data;
#line 409
  c = 0U;
  {
#line 409
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 409
    if (! (c < 128U)) {
#line 409
      goto while_break___0;
    }
#line 410
    if ((int )*(d + (c >> 3)) & (1 << c % 8U)) {
#line 411
      lnfn->command[128U + c].support = (unsigned char )((int )lnfn->command[128U + c].support | 2);
    }
#line 409
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 413
  memcpy((void */* __restrict  */)(lnfn->config_mask + (256 >> 3) / 2), (void const   */* __restrict  */)d,
         (size_t )((256 >> 3) / 2));
  }
#line 414
  return (0);
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int _get_command_enables(struct ipmi_intf *intf , struct ipmi_function_params *p ,
                                struct lun_netfn_support *lnfn ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char *d ;
  unsigned char rqdata[3] ;
  unsigned int c ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 435
  if (! p) {
    {
#line 436
    lprintf(3, "_get_command_enables: p or lnfn is NULL");
    }
#line 437
    return (-1);
  } else
#line 435
  if (! lnfn) {
    {
#line 436
    lprintf(3, "_get_command_enables: p or lnfn is NULL");
    }
#line 437
    return (-1);
  }
  {
#line 440
  memset((void *)(& req), 0, sizeof(req));
#line 441
  req.msg.netfn = (uint8_t )6;
#line 442
  req.msg.cmd = (uint8_t )97;
#line 443
  rqdata[0] = (unsigned char )p->channel;
#line 444
  rqdata[1] = (unsigned char )p->netfn;
#line 445
  rqdata[2] = (unsigned char )p->lun;
#line 446
  req.msg.data = rqdata;
#line 447
  req.msg.data_len = (uint16_t )3;
#line 449
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 450
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 451
    lprintf(3, "Get Command Enables (LUN=%d, NetFn=%d, op=0) command failed", p->lun,
            p->netfn);
    }
#line 452
    return (-1);
  }
#line 454
  if ((int )rsp->ccode > 0) {
    {
#line 455
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 455
    lprintf(3, "Get Command Enables (LUN=%d, NetFn=%d, op=0) command failed: %s",
            p->lun, p->netfn, tmp);
    }
#line 457
    return (-1);
  }
#line 460
  d = rsp->data;
#line 461
  c = 0U;
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    if (! (c < 128U)) {
#line 461
      goto while_break;
    }
#line 462
    if ((int )*(d + (c >> 3)) & (1 << c % 8U)) {
#line 463
      lnfn->command[c].support = (unsigned char )((int )lnfn->command[c].support | 4);
    }
#line 461
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 465
  memcpy((void */* __restrict  */)(lnfn->enable_mask), (void const   */* __restrict  */)d,
         (size_t )((256 >> 3) / 2));
#line 467
  memset((void *)(& req), 0, sizeof(req));
#line 468
  req.msg.netfn = (uint8_t )6;
#line 469
  req.msg.cmd = (uint8_t )97;
#line 470
  rqdata[0] = (unsigned char )p->channel;
#line 471
  rqdata[1] = (unsigned char )(64 | p->netfn);
#line 472
  rqdata[2] = (unsigned char )p->lun;
#line 473
  req.msg.data = rqdata;
#line 474
  req.msg.data_len = (uint16_t )3;
#line 476
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 477
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 478
    lprintf(3, "Get Command Enables (LUN=%d, NetFn=%d, op=1) command failed", p->lun,
            p->netfn);
    }
#line 479
    return (-1);
  }
#line 481
  if ((int )rsp->ccode > 0) {
    {
#line 482
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 482
    lprintf(3, "Get Command Enables (LUN=%d, NetFn=%d, op=1) command failed: %s",
            p->lun, p->netfn, tmp___0);
    }
#line 484
    return (-1);
  }
#line 487
  d = rsp->data;
#line 488
  c = 0U;
  {
#line 488
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 488
    if (! (c < 128U)) {
#line 488
      goto while_break___0;
    }
#line 489
    if ((int )*(d + (c >> 3)) & (1 << c % 8U)) {
#line 490
      lnfn->command[128U + c].support = (unsigned char )((int )lnfn->command[128U + c].support | 4);
    }
#line 488
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 492
  memcpy((void */* __restrict  */)(lnfn->enable_mask + (256 >> 3) / 2), (void const   */* __restrict  */)d,
         (size_t )((256 >> 3) / 2));
  }
#line 493
  return (0);
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int _set_command_enables(struct ipmi_intf *intf , struct ipmi_function_params *p ,
                                struct lun_netfn_support *lnfn , unsigned char *enable ,
                                int gun ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char *d ;
  unsigned char rqdata[19] ;
  unsigned int c ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 518
  if (! p) {
    {
#line 519
    lprintf(3, "_set_command_enables: p or lnfn is NULL");
    }
#line 520
    return (-1);
  } else
#line 518
  if (! lnfn) {
    {
#line 519
    lprintf(3, "_set_command_enables: p or lnfn is NULL");
    }
#line 520
    return (-1);
  }
  {
#line 523
  lprintf(6, "support:            ");
#line 524
  print_bitfield((unsigned char const   *)(lnfn->command_mask), 256 >> 3, 1, 6);
#line 525
  lprintf(6, "configurable:       ");
#line 526
  print_bitfield((unsigned char const   *)(lnfn->config_mask), 256 >> 3, 0, 6);
#line 527
  lprintf(6, "enabled:            ");
#line 528
  print_bitfield((unsigned char const   *)(lnfn->enable_mask), 256 >> 3, 0, 6);
#line 529
  lprintf(6, "enable mask before: ");
#line 530
  print_bitfield((unsigned char const   *)enable, 256 >> 3, 0, 6);
#line 534
  c = 0U;
  }
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 534
    if (! (c < (unsigned int )(256 >> 3))) {
#line 534
      goto while_break;
    }
#line 535
    *(enable + c) = (unsigned char )(((int )lnfn->config_mask[c] & (int )*(enable + c)) | (~ ((int )lnfn->config_mask[c]) & (int )lnfn->enable_mask[c]));
#line 534
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 540
  if (! gun) {
#line 541
    *(enable + 12) = (unsigned char )(~ ((int )lnfn->config_mask[12]) & (int )lnfn->enable_mask[12]);
  }
  {
#line 547
  lprintf(6, "enable mask after: ");
#line 548
  print_bitfield((unsigned char const   *)enable, 256 >> 3, 0, 6);
#line 550
  memset((void *)(& req), 0, sizeof(req));
#line 551
  req.msg.netfn = (uint8_t )6;
#line 552
  req.msg.cmd = (uint8_t )96;
#line 553
  rqdata[0] = (unsigned char )p->channel;
#line 554
  rqdata[1] = (unsigned char )p->netfn;
#line 555
  rqdata[2] = (unsigned char )p->lun;
#line 556
  memcpy((void */* __restrict  */)(& rqdata[3]), (void const   */* __restrict  */)enable,
         (size_t )((256 >> 3) / 2));
#line 557
  req.msg.data = rqdata;
#line 558
  req.msg.data_len = (uint16_t )19;
#line 560
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 561
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 562
    lprintf(3, "Set Command Enables (LUN=%d, NetFn=%d, op=0) command failed", p->lun,
            p->netfn);
    }
#line 563
    return (-1);
  }
#line 565
  if ((int )rsp->ccode > 0) {
    {
#line 566
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 566
    lprintf(3, "Set Command Enables (LUN=%d, NetFn=%d, op=0) command failed: %s",
            p->lun, p->netfn, tmp);
    }
#line 568
    return (-1);
  }
  {
#line 571
  d = rsp->data;
#line 573
  memset((void *)(& req), 0, sizeof(req));
#line 574
  req.msg.netfn = (uint8_t )6;
#line 575
  req.msg.cmd = (uint8_t )96;
#line 576
  rqdata[0] = (unsigned char )p->channel;
#line 577
  rqdata[1] = (unsigned char )(64 | p->netfn);
#line 578
  rqdata[2] = (unsigned char )p->lun;
#line 579
  memcpy((void */* __restrict  */)(& rqdata[3]), (void const   */* __restrict  */)(enable + (256 >> 3) / 2),
         (size_t )((256 >> 3) / 2));
#line 580
  req.msg.data = rqdata;
#line 581
  req.msg.data_len = (uint16_t )19;
#line 583
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 584
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 585
    lprintf(3, "Set Command Enables (LUN=%d, NetFn=%d, op=1) command failed", p->lun,
            p->netfn);
    }
#line 586
    return (-1);
  }
#line 588
  if ((int )rsp->ccode > 0) {
    {
#line 589
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 589
    lprintf(3, "Set Command Enables (LUN=%d, NetFn=%d, op=1) command failed: %s",
            p->lun, p->netfn, tmp___0);
    }
#line 591
    return (-1);
  }
#line 594
  d = rsp->data;
#line 595
  return (0);
}
}
#line 607 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int _get_subfn_support(struct ipmi_intf *intf , struct ipmi_function_params *p ,
                              struct command_support *cmd ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char rqdata[4] ;
  char const   *tmp ;

  {
#line 615
  if (! p) {
    {
#line 616
    lprintf(3, "_get_subfn_support: p or cmd is NULL");
    }
#line 617
    return (-1);
  } else
#line 615
  if (! cmd) {
    {
#line 616
    lprintf(3, "_get_subfn_support: p or cmd is NULL");
    }
#line 617
    return (-1);
  }
  {
#line 620
  memset((void *)(& req), 0, sizeof(req));
#line 621
  req.msg.netfn = (uint8_t )6;
#line 622
  req.msg.cmd = (uint8_t )11;
#line 623
  rqdata[0] = (unsigned char )p->channel;
#line 624
  rqdata[1] = (unsigned char )p->netfn;
#line 625
  rqdata[2] = (unsigned char )p->lun;
#line 626
  rqdata[3] = (unsigned char )p->command;
#line 627
  req.msg.data = rqdata;
#line 628
  req.msg.data_len = (uint16_t )4;
#line 630
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 631
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 632
    lprintf(3, "Get Command Sub-function Support (LUN=%d, NetFn=%d, command=%d) command failed",
            p->lun, p->netfn, p->command);
    }
#line 633
    return (-1);
  }
#line 635
  if ((int )rsp->ccode > 0) {
    {
#line 636
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 636
    lprintf(3, "Get Command Sub-function Support (LUN=%d, NetFn=%d, command=%d) command failed: %s",
            p->lun, p->netfn, p->command, tmp);
    }
#line 638
    return (-1);
  }
  {
#line 641
  memcpy((void */* __restrict  */)(cmd->subfn_support), (void const   */* __restrict  */)(rsp->data),
         sizeof(cmd->subfn_support));
  }
#line 642
  return (0);
}
}
#line 654 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int _get_subfn_configurable(struct ipmi_intf *intf , struct ipmi_function_params *p ,
                                   struct command_support *cmd ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char rqdata[4] ;
  char const   *tmp ;

  {
#line 662
  if (! p) {
    {
#line 663
    lprintf(3, "_get_subfn_configurable: p or cmd is NULL");
    }
#line 664
    return (-1);
  } else
#line 662
  if (! cmd) {
    {
#line 663
    lprintf(3, "_get_subfn_configurable: p or cmd is NULL");
    }
#line 664
    return (-1);
  }
  {
#line 667
  memset((void *)(& req), 0, sizeof(req));
#line 668
  req.msg.netfn = (uint8_t )6;
#line 669
  req.msg.cmd = (uint8_t )13;
#line 670
  rqdata[0] = (unsigned char )p->channel;
#line 671
  rqdata[1] = (unsigned char )p->netfn;
#line 672
  rqdata[2] = (unsigned char )p->lun;
#line 673
  rqdata[3] = (unsigned char )p->command;
#line 674
  req.msg.data = rqdata;
#line 675
  req.msg.data_len = (uint16_t )4;
#line 677
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 678
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 679
    lprintf(3, "Get Configurable Command Sub-function (LUN=%d, NetFn=%d, command=%d) command failed",
            p->lun, p->netfn, p->command);
    }
#line 680
    return (-1);
  }
#line 682
  if ((int )rsp->ccode > 0) {
    {
#line 683
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 683
    lprintf(3, "Get Configurable Command Sub-function (LUN=%d, NetFn=%d, command=%d) command failed: %s",
            p->lun, p->netfn, p->command, tmp);
    }
#line 685
    return (-1);
  }
  {
#line 688
  memcpy((void */* __restrict  */)(cmd->subfn_config), (void const   */* __restrict  */)(rsp->data),
         sizeof(cmd->subfn_config));
  }
#line 689
  return (0);
}
}
#line 701 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int _get_subfn_enables(struct ipmi_intf *intf , struct ipmi_function_params *p ,
                              struct command_support *cmd ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char rqdata[4] ;
  char const   *tmp ;

  {
#line 709
  if (! p) {
    {
#line 710
    lprintf(3, "_get_subfn_enables: p or cmd is NULL");
    }
#line 711
    return (-1);
  } else
#line 709
  if (! cmd) {
    {
#line 710
    lprintf(3, "_get_subfn_enables: p or cmd is NULL");
    }
#line 711
    return (-1);
  }
  {
#line 714
  memset((void *)(& req), 0, sizeof(req));
#line 715
  req.msg.netfn = (uint8_t )6;
#line 716
  req.msg.cmd = (uint8_t )99;
#line 717
  rqdata[0] = (unsigned char )p->channel;
#line 718
  rqdata[1] = (unsigned char )p->netfn;
#line 719
  rqdata[2] = (unsigned char )p->lun;
#line 720
  rqdata[3] = (unsigned char )p->command;
#line 721
  req.msg.data = rqdata;
#line 722
  req.msg.data_len = (uint16_t )4;
#line 724
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 725
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 726
    lprintf(3, "Get Command Sub-function Enables (LUN=%d, NetFn=%d, command=%d) command failed",
            p->lun, p->netfn, p->command);
    }
#line 727
    return (-1);
  }
#line 729
  if ((int )rsp->ccode > 0) {
    {
#line 730
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 730
    lprintf(3, "Get Command Sub-function Enables (LUN=%d, NetFn=%d, command=%d) command failed: %s",
            p->lun, p->netfn, p->command, tmp);
    }
#line 732
    return (-1);
  }
  {
#line 735
  memcpy((void */* __restrict  */)(cmd->subfn_enable), (void const   */* __restrict  */)(rsp->data),
         sizeof(cmd->subfn_enable));
  }
#line 736
  return (0);
}
}
#line 749 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int _set_subfn_enables(struct ipmi_intf *intf , struct ipmi_function_params *p ,
                              struct command_support *cmd , unsigned char *enable ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char rqdata[8] ;
  unsigned int c ;
  char const   *tmp ;

  {
#line 759
  if (! p) {
    {
#line 760
    lprintf(3, "_set_subfn_enables: p or cmd is NULL");
    }
#line 761
    return (-1);
  } else
#line 759
  if (! cmd) {
    {
#line 760
    lprintf(3, "_set_subfn_enables: p or cmd is NULL");
    }
#line 761
    return (-1);
  }
  {
#line 764
  lprintf(6, "support:            ");
#line 765
  print_bitfield((unsigned char const   *)(cmd->subfn_support), 32 >> 3, 1, 6);
#line 766
  lprintf(6, "configurable:       ");
#line 767
  print_bitfield((unsigned char const   *)(cmd->subfn_config), 32 >> 3, 0, 6);
#line 768
  lprintf(6, "enabled:            ");
#line 769
  print_bitfield((unsigned char const   *)(cmd->subfn_enable), 32 >> 3, 0, 6);
#line 770
  lprintf(6, "enable mask before: ");
#line 771
  print_bitfield((unsigned char const   *)enable, 32 >> 3, 0, 6);
#line 774
  c = 0U;
  }
  {
#line 774
  while (1) {
    while_continue: /* CIL Label */ ;
#line 774
    if (! ((unsigned long )c < sizeof(cmd->subfn_enable))) {
#line 774
      goto while_break;
    }
#line 775
    *(enable + c) = (unsigned char )(((int )cmd->subfn_config[c] & (int )*(enable + c)) | (~ ((int )cmd->subfn_config[c]) & (int )cmd->subfn_enable[c]));
#line 774
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 778
  lprintf(6, "enable mask after: ");
#line 779
  print_bitfield((unsigned char const   *)enable, 32 >> 3, 0, 6);
#line 781
  memset((void *)(& req), 0, sizeof(req));
#line 782
  req.msg.netfn = (uint8_t )6;
#line 783
  req.msg.cmd = (uint8_t )98;
#line 784
  rqdata[0] = (unsigned char )p->channel;
#line 785
  rqdata[1] = (unsigned char )p->netfn;
#line 786
  rqdata[2] = (unsigned char )p->lun;
#line 787
  rqdata[3] = (unsigned char )p->command;
#line 788
  memcpy((void */* __restrict  */)(& rqdata[4]), (void const   */* __restrict  */)enable,
         (size_t )(32 >> 3));
#line 789
  req.msg.data = rqdata;
#line 790
  req.msg.data_len = (uint16_t )8;
#line 792
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 793
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 794
    lprintf(3, "Set Command Sub-function Enables (LUN=%d, NetFn=%d, command=%d) command failed",
            p->lun, p->netfn, p->command);
    }
#line 795
    return (-1);
  }
#line 797
  if ((int )rsp->ccode > 0) {
    {
#line 798
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 798
    lprintf(3, "Set Command Sub-function Enables (LUN=%d, NetFn=%d, command=%d) command failed: %s",
            p->lun, p->netfn, p->command, tmp);
    }
#line 800
    return (-1);
  }
#line 803
  return (0);
}
}
#line 816 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int _gather_info(struct ipmi_intf *intf , struct ipmi_function_params *p ,
                        struct bmc_fn_support *bmc ) 
{ 
  int ret ;
  int l ;
  int n ;
  unsigned char lun[4] ;
  unsigned char netfn[16] ;
  int offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 821
  ret = _get_netfn_support(intf, p->channel, lun, netfn);
  }
#line 822
  if (! ret) {
#line 823
    l = 0;
    {
#line 823
    while (1) {
      while_continue: /* CIL Label */ ;
#line 823
      if (! (l < 4)) {
#line 823
        goto while_break;
      }
#line 824
      if (p->lun >= 0) {
#line 824
        if (p->lun != l) {
#line 825
          goto __Cont;
        }
      }
#line 826
      bmc->lun[l].support = lun[l];
#line 827
      if (lun[l]) {
#line 828
        n = 0;
        {
#line 828
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 828
          if (! (n < 32)) {
#line 828
            goto while_break___0;
          }
#line 829
          offset = l * 32 + n;
#line 830
          bmc->lun[l].netfn[n].support = (unsigned char )(! (! ((int )netfn[offset >> 3] & (1 << offset % 8))));
#line 828
          n ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      __Cont: /* CIL Label */ 
#line 823
      l ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 836
  if (p->netfn >= 0) {
#line 837
    if (p->lun < 0) {
#line 837
      goto _L;
    } else
#line 837
    if (bmc->lun[p->lun].support) {
      _L: /* CIL Label */ 
#line 837
      if (! (p->netfn < 0)) {
#line 837
        if (! bmc->lun[p->lun].netfn[p->netfn >> 1].support) {
          {
#line 839
          lprintf(3, "LUN or LUN/NetFn pair %d,%d not supported", p->lun, p->netfn);
          }
#line 840
          return (0);
        }
      }
    } else {
      {
#line 839
      lprintf(3, "LUN or LUN/NetFn pair %d,%d not supported", p->lun, p->netfn);
      }
#line 840
      return (0);
    }
    {
#line 842
    ret = _get_command_support(intf, p, & bmc->lun[p->lun].netfn[p->netfn >> 1]);
#line 843
    tmp = _get_command_configurable(intf, p, & bmc->lun[p->lun].netfn[p->netfn >> 1]);
#line 843
    ret |= tmp;
#line 844
    tmp___0 = _get_command_enables(intf, p, & bmc->lun[p->lun].netfn[p->netfn >> 1]);
#line 844
    ret |= tmp___0;
    }
#line 845
    if (! ret) {
#line 845
      if (p->command >= 0) {
        {
#line 846
        ret = _get_subfn_support(intf, p, & bmc->lun[p->lun].netfn[p->netfn >> 1].command[p->command]);
#line 848
        tmp___1 = _get_subfn_configurable(intf, p, & bmc->lun[p->lun].netfn[p->netfn >> 1].command[p->command]);
#line 848
        ret |= tmp___1;
#line 850
        tmp___2 = _get_subfn_enables(intf, p, & bmc->lun[p->lun].netfn[p->netfn >> 1].command[p->command]);
#line 850
        ret |= tmp___2;
        }
      }
    }
  } else
#line 854
  if (p->lun >= 0) {
#line 855
    l = p->lun;
#line 856
    if (bmc->lun[l].support) {
#line 857
      n = 0;
      {
#line 857
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 857
        if (! (n < 32)) {
#line 857
          goto while_break___1;
        }
#line 858
        p->netfn = n * 2;
#line 859
        if (bmc->lun[l].netfn[n].support) {
          {
#line 860
          ret = _get_command_support(intf, p, & bmc->lun[l].netfn[n]);
#line 861
          tmp___3 = _get_command_configurable(intf, p, & bmc->lun[l].netfn[n]);
#line 861
          ret |= tmp___3;
#line 862
          tmp___4 = _get_command_enables(intf, p, & bmc->lun[l].netfn[n]);
#line 862
          ret |= tmp___4;
          }
        }
#line 864
        if (ret) {
#line 865
          bmc->lun[l].netfn[n].support = (unsigned char)0;
        }
#line 857
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 868
    p->netfn = -1;
  } else {
#line 870
    l = 0;
    {
#line 870
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 870
      if (! (l < 4)) {
#line 870
        goto while_break___2;
      }
#line 871
      p->lun = l;
#line 872
      if (bmc->lun[l].support) {
#line 873
        n = 0;
        {
#line 873
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 873
          if (! (n < 32)) {
#line 873
            goto while_break___3;
          }
#line 874
          p->netfn = n * 2;
#line 875
          if (bmc->lun[l].netfn[n].support) {
            {
#line 876
            ret = _get_command_support(intf, p, & bmc->lun[l].netfn[n]);
#line 877
            tmp___5 = _get_command_configurable(intf, p, & bmc->lun[l].netfn[n]);
#line 877
            ret |= tmp___5;
#line 878
            tmp___6 = _get_command_enables(intf, p, & bmc->lun[l].netfn[n]);
#line 878
            ret |= tmp___6;
            }
          }
#line 880
          if (ret) {
#line 881
            bmc->lun[l].netfn[n].support = (unsigned char)0;
          }
#line 873
          n ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 870
      l ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 885
    p->lun = -1;
#line 886
    p->netfn = -1;
  }
#line 889
  return (0);
}
}
#line 901 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int ipmi_firewall_info(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int ret ;
  struct ipmi_function_params p ;
  struct bmc_fn_support *bmc_fn_support ;
  unsigned int l ;
  unsigned int n ;
  unsigned int c ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  struct command_support *cmd ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 904
  ret = 0;
#line 905
  p.channel = 14;
#line 905
  p.lun = -1;
#line 905
  p.netfn = -1;
#line 905
  p.command = -1;
#line 905
  p.subfn = -1;
#line 905
  p.force = (unsigned char)0;
#line 909
  if (argc > 0) {
    {
#line 909
    tmp = strncmp((char const   *)*(argv + 0), "help", (size_t )4);
    }
#line 909
    if (tmp == 0) {
      {
#line 911
      printf_firewall_info_usage();
      }
#line 912
      return (0);
    } else {
#line 909
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 909
    tmp___0 = ipmi_firewall_parse_args(argc, argv, & p);
    }
#line 909
    if (tmp___0 < 0) {
      {
#line 911
      printf_firewall_info_usage();
      }
#line 912
      return (0);
    }
  }
  {
#line 915
  tmp___1 = malloc(sizeof(struct bmc_fn_support ));
#line 915
  bmc_fn_support = (struct bmc_fn_support *)tmp___1;
  }
#line 916
  if (! bmc_fn_support) {
    {
#line 917
    lprintf(3, "malloc struct bmc_fn_support failed");
    }
#line 918
    return (-1);
  }
  {
#line 921
  ret = _gather_info(intf, & p, bmc_fn_support);
  }
#line 923
  if (p.command >= 0) {
#line 925
    if (p.lun < 0) {
#line 925
      goto _L___1;
    } else
#line 925
    if (bmc_fn_support->lun[p.lun].support) {
      _L___1: /* CIL Label */ 
#line 925
      if (p.netfn < 0) {
#line 925
        goto _L___0;
      } else
#line 925
      if (bmc_fn_support->lun[p.lun].netfn[p.netfn >> 1].support) {
        _L___0: /* CIL Label */ 
#line 925
        if (! bmc_fn_support->lun[p.lun].netfn[p.netfn >> 1].command[p.command].support) {
          {
#line 929
          lprintf(3, "Command 0x%02x not supported on LUN/NetFn pair %02x,%02x", p.command,
                  p.lun, p.netfn);
#line 931
          free((void *)bmc_fn_support);
#line 932
          bmc_fn_support = (struct bmc_fn_support *)((void *)0);
          }
#line 933
          return (0);
        }
      } else {
        {
#line 929
        lprintf(3, "Command 0x%02x not supported on LUN/NetFn pair %02x,%02x", p.command,
                p.lun, p.netfn);
#line 931
        free((void *)bmc_fn_support);
#line 932
        bmc_fn_support = (struct bmc_fn_support *)((void *)0);
        }
#line 933
        return (0);
      }
    } else {
      {
#line 929
      lprintf(3, "Command 0x%02x not supported on LUN/NetFn pair %02x,%02x", p.command,
              p.lun, p.netfn);
#line 931
      free((void *)bmc_fn_support);
#line 932
      bmc_fn_support = (struct bmc_fn_support *)((void *)0);
      }
#line 933
      return (0);
    }
    {
#line 935
    cmd = & bmc_fn_support->lun[p.lun].netfn[p.netfn >> 1].command[p.command];
#line 937
    c = (unsigned int )cmd->support;
#line 938
    printf((char const   */* __restrict  */)"(A)vailable, (C)onfigurable, (E)nabled: | A | C | E |\n");
#line 939
    printf((char const   */* __restrict  */)"-----------------------------------------------------\n");
    }
#line 940
    if (c & 4U) {
#line 940
      tmp___2 = 'X';
    } else {
#line 940
      tmp___2 = ' ';
    }
#line 940
    if (c & 2U) {
#line 940
      tmp___3 = 'X';
    } else {
#line 940
      tmp___3 = ' ';
    }
#line 940
    if (c & 1U) {
#line 940
      tmp___4 = 'X';
    } else {
#line 940
      tmp___4 = ' ';
    }
    {
#line 940
    printf((char const   */* __restrict  */)"LUN %01d, NetFn 0x%02x, Command 0x%02x:        | %c | %c | %c |\n",
           p.lun, p.netfn, p.command, tmp___4, tmp___3, tmp___2);
#line 946
    n = 0U;
    }
    {
#line 946
    while (1) {
      while_continue: /* CIL Label */ ;
#line 946
      if (! (n < 32U)) {
#line 946
        goto while_break;
      }
      {
#line 947
      tmp___7 = bit_test((unsigned char const   *)(cmd->subfn_enable), (int )n);
      }
#line 947
      if (tmp___7) {
#line 947
        tmp___6 = 'X';
      } else {
#line 947
        tmp___6 = ' ';
      }
      {
#line 947
      tmp___10 = bit_test((unsigned char const   *)(cmd->subfn_config), (int )n);
      }
#line 947
      if (tmp___10) {
#line 947
        tmp___9 = 'X';
      } else {
#line 947
        tmp___9 = ' ';
      }
      {
#line 947
      tmp___13 = bit_test((unsigned char const   *)(cmd->subfn_support), (int )n);
      }
#line 947
      if (tmp___13) {
#line 947
        tmp___12 = ' ';
      } else {
#line 947
        tmp___12 = 'X';
      }
      {
#line 947
      printf((char const   */* __restrict  */)"sub-function 0x%02x:                      | %c | %c | %c |\n",
             n, tmp___12, tmp___9, tmp___6);
#line 946
      n ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 953
  if (p.netfn >= 0) {
#line 954
    if (p.lun < 0) {
#line 954
      goto _L___2;
    } else
#line 954
    if (bmc_fn_support->lun[p.lun].support) {
      _L___2: /* CIL Label */ 
#line 954
      if (! bmc_fn_support->lun[p.lun].netfn[p.netfn >> 1].support) {
        {
#line 957
        lprintf(3, "LUN or LUN/NetFn pair %02x,%02x not supported", p.lun, p.netfn);
#line 959
        free((void *)bmc_fn_support);
#line 960
        bmc_fn_support = (struct bmc_fn_support *)((void *)0);
        }
#line 961
        return (0);
      }
    } else {
      {
#line 957
      lprintf(3, "LUN or LUN/NetFn pair %02x,%02x not supported", p.lun, p.netfn);
#line 959
      free((void *)bmc_fn_support);
#line 960
      bmc_fn_support = (struct bmc_fn_support *)((void *)0);
      }
#line 961
      return (0);
    }
    {
#line 963
    n = (unsigned int )(p.netfn >> 1);
#line 964
    l = (unsigned int )p.lun;
#line 965
    printf((char const   */* __restrict  */)"Commands on LUN 0x%02x, NetFn 0x%02x\n",
           p.lun, p.netfn);
#line 966
    printf((char const   */* __restrict  */)"support:      ");
#line 967
    print_bitfield((unsigned char const   *)(bmc_fn_support->lun[l].netfn[n].command_mask),
                   256 >> 3, 1, -1);
#line 969
    printf((char const   */* __restrict  */)"configurable: ");
#line 970
    print_bitfield((unsigned char const   *)(bmc_fn_support->lun[l].netfn[n].config_mask),
                   256 >> 3, 0, -1);
#line 972
    printf((char const   */* __restrict  */)"enabled:      ");
#line 973
    print_bitfield((unsigned char const   *)(bmc_fn_support->lun[l].netfn[n].enable_mask),
                   256 >> 3, 0, -1);
    }
  } else {
#line 977
    l = 0U;
    {
#line 977
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 977
      if (! (l < 4U)) {
#line 977
        goto while_break___0;
      }
#line 978
      p.lun = (int )l;
#line 979
      if (bmc_fn_support->lun[l].support) {
#line 980
        n = 0U;
        {
#line 980
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 980
          if (! (n < 32U)) {
#line 980
            goto while_break___1;
          }
#line 981
          p.netfn = (int )(n * 2U);
#line 982
          if (bmc_fn_support->lun[l].netfn[n].support) {
            {
#line 983
            printf((char const   */* __restrict  */)"%02x,%02x support:      ", p.lun,
                   p.netfn);
#line 984
            print_bitfield((unsigned char const   *)(bmc_fn_support->lun[l].netfn[n].command_mask),
                           256 >> 3, 1, -1);
#line 986
            printf((char const   */* __restrict  */)"%02x,%02x configurable: ", p.lun,
                   p.netfn);
#line 987
            print_bitfield((unsigned char const   *)(bmc_fn_support->lun[l].netfn[n].config_mask),
                           256 >> 3, 0, -1);
#line 989
            printf((char const   */* __restrict  */)"%02x,%02x enabled:      ", p.lun,
                   p.netfn);
#line 990
            print_bitfield((unsigned char const   *)(bmc_fn_support->lun[l].netfn[n].enable_mask),
                           256 >> 3, 0, -1);
            }
          }
#line 980
          n ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 977
      l ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 996
    p.lun = -1;
#line 997
    p.netfn = -1;
  }
  {
#line 1000
  free((void *)bmc_fn_support);
#line 1001
  bmc_fn_support = (struct bmc_fn_support *)((void *)0);
  }
#line 1002
  return (ret);
}
}
#line 1015 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int ipmi_firewall_enable_disable(struct ipmi_intf *intf , int enable , int argc ,
                                        char **argv ) 
{ 
  struct ipmi_function_params p ;
  struct bmc_fn_support *bmc_fn_support ;
  unsigned int l ;
  unsigned int n ;
  unsigned int c ;
  unsigned int ret ;
  unsigned char enables[256 >> 3] ;
  char *s1 ;
  char const   *tmp ;
  char *s2 ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1018
  p.channel = 14;
#line 1018
  p.lun = -1;
#line 1018
  p.netfn = -1;
#line 1018
  p.command = -1;
#line 1018
  p.subfn = -1;
#line 1018
  p.force = (unsigned char)0;
#line 1023
  if (argc < 1) {
#line 1023
    goto _L;
  } else {
    {
#line 1023
    tmp___1 = strncmp((char const   *)*(argv + 0), "help", (size_t )4);
    }
#line 1023
    if (tmp___1 == 0) {
      _L: /* CIL Label */ 
#line 1024
      if (enable) {
#line 1024
        tmp = "en";
      } else {
#line 1024
        tmp = "dis";
      }
#line 1024
      s1 = (char *)tmp;
#line 1025
      if (enable) {
#line 1025
        tmp___0 = "";
      } else {
#line 1025
        tmp___0 = " [force]";
      }
      {
#line 1025
      s2 = (char *)tmp___0;
#line 1026
      printf((char const   */* __restrict  */)"%sable [channel H] lun L netfn N%s\n",
             s1, s2);
#line 1027
      printf((char const   */* __restrict  */)"\t%sable all commands on this LUN/NetFn pair\n",
             s1);
#line 1028
      printf((char const   */* __restrict  */)"%sable [channel H] lun L netfn N command C%s\n",
             s1, s2);
#line 1029
      printf((char const   */* __restrict  */)"\t%sable Command C and all its Sub-functions for this LUN/NetFn pair\n",
             s1);
#line 1030
      printf((char const   */* __restrict  */)"%sable [channel H] lun L netfn N command C subfn S\n",
             s1);
#line 1031
      printf((char const   */* __restrict  */)"\t%sable Sub-function S for Command C for this LUN/NetFn pair\n",
             s1);
      }
#line 1032
      if (! enable) {
        {
#line 1033
        printf((char const   */* __restrict  */)"* force will allow you to disable the \"Command Set Enable\" command\n");
#line 1034
        printf((char const   */* __restrict  */)"\tthereby letting you shoot yourself in the foot\n");
#line 1035
        printf((char const   */* __restrict  */)"\tthis is only recommended for advanced users\n");
        }
      }
#line 1037
      return (0);
    }
  }
  {
#line 1039
  tmp___2 = ipmi_firewall_parse_args(argc, argv, & p);
  }
#line 1039
  if (tmp___2 < 0) {
#line 1040
    return (-1);
  }
  {
#line 1042
  tmp___3 = malloc(sizeof(struct bmc_fn_support ));
#line 1042
  bmc_fn_support = (struct bmc_fn_support *)tmp___3;
  }
#line 1043
  if (! bmc_fn_support) {
    {
#line 1044
    lprintf(3, "malloc struct bmc_fn_support failed");
    }
#line 1045
    return (-1);
  }
  {
#line 1048
  tmp___4 = _gather_info(intf, & p, bmc_fn_support);
#line 1048
  ret = (unsigned int )tmp___4;
  }
#line 1049
  if (ret < 0U) {
    {
#line 1050
    free((void *)bmc_fn_support);
#line 1051
    bmc_fn_support = (struct bmc_fn_support *)((void *)0);
    }
#line 1052
    return ((int )ret);
  }
#line 1055
  l = (unsigned int )p.lun;
#line 1056
  n = (unsigned int )(p.netfn >> 1);
#line 1057
  c = (unsigned int )p.command;
#line 1058
  if (p.subfn >= 0) {
    {
#line 1061
    memcpy((void */* __restrict  */)(enables), (void const   */* __restrict  */)(bmc_fn_support->lun[l].netfn[n].command[c].subfn_enable),
           (size_t )(32 >> 3));
#line 1064
    bit_set(enables, p.subfn, enable);
#line 1065
    tmp___5 = _set_subfn_enables(intf, & p, & bmc_fn_support->lun[l].netfn[n].command[c],
                                 enables);
#line 1065
    ret = (unsigned int )tmp___5;
    }
  } else
#line 1068
  if (p.command >= 0) {
#line 1071
    if (enable) {
#line 1071
      tmp___6 = 255;
    } else {
#line 1071
      tmp___6 = 0;
    }
    {
#line 1071
    memset((void *)(enables), tmp___6, (size_t )(32 >> 3));
#line 1072
    tmp___7 = _set_subfn_enables(intf, & p, & bmc_fn_support->lun[l].netfn[n].command[c],
                                 enables);
#line 1072
    ret = (unsigned int )tmp___7;
#line 1074
    memcpy((void */* __restrict  */)(enables), (void const   */* __restrict  */)(& bmc_fn_support->lun[l].netfn[n].enable_mask),
           sizeof(enables));
#line 1076
    bit_set(enables, p.command, enable);
#line 1077
    tmp___8 = _set_command_enables(intf, & p, & bmc_fn_support->lun[l].netfn[n], enables,
                                   (int )p.force);
#line 1077
    ret |= (unsigned int )tmp___8;
    }
  } else
#line 1079
  if (p.netfn >= 0) {
#line 1082
    if (enable) {
#line 1082
      tmp___9 = 255;
    } else {
#line 1082
      tmp___9 = 0;
    }
    {
#line 1082
    memset((void *)(enables), tmp___9, sizeof(enables));
#line 1083
    tmp___10 = _set_command_enables(intf, & p, & bmc_fn_support->lun[l].netfn[n],
                                    enables, (int )p.force);
#line 1083
    ret = (unsigned int )tmp___10;
    }
  }
  {
#line 1091
  free((void *)bmc_fn_support);
#line 1092
  bmc_fn_support = (struct bmc_fn_support *)((void *)0);
  }
#line 1093
  return ((int )ret);
}
}
#line 1105 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int ipmi_firewall_reset(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  struct ipmi_function_params p ;
  struct bmc_fn_support *bmc_fn_support ;
  unsigned int l ;
  unsigned int n ;
  unsigned int c ;
  unsigned int ret ;
  unsigned char enables[256 >> 3] ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1108
  p.channel = 14;
#line 1108
  p.lun = -1;
#line 1108
  p.netfn = -1;
#line 1108
  p.command = -1;
#line 1108
  p.subfn = -1;
#line 1108
  p.force = (unsigned char)0;
#line 1113
  if (argc > 0) {
    {
#line 1114
    printf_firewall_usage();
    }
#line 1115
    return (0);
  } else
#line 1113
  if (argc > 0) {
    {
#line 1113
    tmp = strncmp((char const   *)*(argv + 0), "help", (size_t )4);
    }
#line 1113
    if (tmp == 0) {
      {
#line 1114
      printf_firewall_usage();
      }
#line 1115
      return (0);
    }
  }
  {
#line 1117
  tmp___0 = ipmi_firewall_parse_args(argc, argv, & p);
  }
#line 1117
  if (tmp___0 < 0) {
#line 1118
    return (-1);
  }
  {
#line 1120
  tmp___1 = malloc(sizeof(struct bmc_fn_support ));
#line 1120
  bmc_fn_support = (struct bmc_fn_support *)tmp___1;
  }
#line 1121
  if (! bmc_fn_support) {
    {
#line 1122
    lprintf(3, "malloc struct bmc_fn_support failed");
    }
#line 1123
    return (-1);
  }
  {
#line 1126
  tmp___2 = _gather_info(intf, & p, bmc_fn_support);
#line 1126
  ret = (unsigned int )tmp___2;
  }
#line 1127
  if (ret < 0U) {
    {
#line 1128
    free((void *)bmc_fn_support);
#line 1129
    bmc_fn_support = (struct bmc_fn_support *)((void *)0);
    }
#line 1130
    return ((int )ret);
  }
#line 1133
  l = 0U;
  {
#line 1133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1133
    if (! (l < 4U)) {
#line 1133
      goto while_break;
    }
#line 1134
    p.lun = (int )l;
#line 1135
    n = 0U;
    {
#line 1135
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1135
      if (! (n < 64U)) {
#line 1135
        goto while_break___0;
      }
#line 1136
      p.netfn = (int )n;
#line 1137
      c = 0U;
      {
#line 1137
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1137
        if (! (c < 256U)) {
#line 1137
          goto while_break___1;
        }
        {
#line 1138
        p.command = (int )c;
#line 1139
        printf((char const   */* __restrict  */)"reset lun %d, netfn %d, command %d, subfn\n",
               l, n, c);
#line 1140
        memset((void *)(enables), 255, (size_t )(32 >> 3));
#line 1141
        tmp___3 = _set_subfn_enables(intf, & p, & bmc_fn_support->lun[l].netfn[n].command[c],
                                     enables);
#line 1141
        ret = (unsigned int )tmp___3;
#line 1137
        c ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1144
      printf((char const   */* __restrict  */)"reset lun %d, netfn %d, command\n",
             l, n);
#line 1145
      memset((void *)(enables), 255, sizeof(enables));
#line 1146
      tmp___4 = _set_command_enables(intf, & p, & bmc_fn_support->lun[l].netfn[n],
                                     enables, 0);
#line 1146
      ret = (unsigned int )tmp___4;
#line 1135
      n += 2U;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1133
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1151
  free((void *)bmc_fn_support);
#line 1152
  bmc_fn_support = (struct bmc_fn_support *)((void *)0);
  }
#line 1153
  return ((int )ret);
}
}
#line 1166 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
int ipmi_firewall_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1169
  rc = 0;
#line 1171
  if (argc < 1) {
    {
#line 1172
    printf_firewall_usage();
    }
  } else {
    {
#line 1171
    tmp___3 = strncmp((char const   *)*(argv + 0), "help", (size_t )4);
    }
#line 1171
    if (tmp___3 == 0) {
      {
#line 1172
      printf_firewall_usage();
      }
    } else {
      {
#line 1174
      tmp___2 = strncmp((char const   *)*(argv + 0), "info", (size_t )4);
      }
#line 1174
      if (tmp___2 == 0) {
        {
#line 1175
        rc = ipmi_firewall_info(intf, argc - 1, argv + 1);
        }
      } else {
        {
#line 1177
        tmp___1 = strncmp((char const   *)*(argv + 0), "enable", (size_t )6);
        }
#line 1177
        if (tmp___1 == 0) {
          {
#line 1178
          rc = ipmi_firewall_enable_disable(intf, 1, argc - 1, argv + 1);
          }
        } else {
          {
#line 1180
          tmp___0 = strncmp((char const   *)*(argv + 0), "disable", (size_t )7);
          }
#line 1180
          if (tmp___0 == 0) {
            {
#line 1181
            rc = ipmi_firewall_enable_disable(intf, 0, argc - 1, argv + 1);
            }
          } else {
            {
#line 1183
            tmp = strncmp((char const   *)*(argv + 0), "reset", (size_t )5);
            }
#line 1183
            if (tmp == 0) {
              {
#line 1184
              rc = ipmi_firewall_reset(intf, argc - 1, argv + 1);
              }
            } else {
              {
#line 1187
              printf_firewall_usage();
              }
            }
          }
        }
      }
    }
  }
#line 1190
  return (rc);
}
}
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 39 "../include/ipmitool/ipmi_hpmfwupg.h"
int ipmi_hpmfwupg_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 79 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/../src/plugins/lan/md5.h"
extern void md5_init(md5_state_t *pms ) ;
#line 82
extern void md5_append(md5_state_t *pms , md5_byte_t const   *data , int nbytes ) ;
#line 85
extern void md5_finish(md5_state_t *pms , md5_byte_t *digest ) ;
#line 206 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int errorCount  ;
#line 276 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int const   HPMFWUPG_SUCCESS  =    (int const   )0;
#line 277 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int const   HPMFWUPG_ERROR  =    (int const   )-1;
#line 279 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int const   HPMFWUPG_UPLOAD_BLOCK_LENGTH  =    (int const   )1;
#line 280 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int const   HPMFWUPG_UPLOAD_RETRY  =    (int const   )2;
#line 1028 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
VERSIONINFO gVersionInfo[8]  ;
#line 1037
static int HpmfwupgUpgrade(struct ipmi_intf *intf , char *imageFilename , int activate ,
                           int componentToUpload , int option ) ;
#line 1038
static int HpmfwupgValidateImageIntegrity(struct HpmfwupgUpgradeCtx *pFwupgCtx ) ;
#line 1039
static int HpmfwupgPreparationStage(struct ipmi_intf *intf , struct HpmfwupgUpgradeCtx *pFwupgCtx ,
                                    int option ) ;
#line 1041
static int HpmfwupgUpgradeStage(struct ipmi_intf *intf , struct HpmfwupgUpgradeCtx *pFwupgCtx ,
                                int componentToUpload , int option ) ;
#line 1043
static int HpmfwupgActivationStage(struct ipmi_intf *intf , struct HpmfwupgUpgradeCtx *pFwupgCtx ) ;
#line 1045
static int HpmfwupgGetTargetUpgCapabilities(struct ipmi_intf *intf , struct HpmfwupgGetTargetUpgCapabilitiesCtx *pCtx ) ;
#line 1047
static int HpmfwupgGetComponentProperties(struct ipmi_intf *intf , struct HpmfwupgGetComponentPropertiesCtx *pCtx ) ;
#line 1049
static int HpmfwupgQuerySelftestResult(struct ipmi_intf *intf , struct HpmfwupgQuerySelftestResultCtx *pCtx ,
                                       struct HpmfwupgUpgradeCtx *pFwupgCtx ) ;
#line 1052
static int HpmfwupgQueryRollbackStatus(struct ipmi_intf *intf , struct HpmfwupgQueryRollbackStatusCtx *pCtx ,
                                       struct HpmfwupgUpgradeCtx *pFwupgCtx ) ;
#line 1055
static int HpmfwupgAbortUpgrade(struct ipmi_intf *intf , struct HpmfwupgAbortUpgradeCtx *pCtx ) ;
#line 1057
static int HpmfwupgInitiateUpgradeAction(struct ipmi_intf *intf , struct HpmfwupgInitiateUpgradeActionCtx *pCtx ,
                                         struct HpmfwupgUpgradeCtx *pFwupgCtx ) ;
#line 1060
static int HpmfwupgUploadFirmwareBlock(struct ipmi_intf *intf , struct HpmfwupgUploadFirmwareBlockCtx *pCtx ,
                                       struct HpmfwupgUpgradeCtx *pFwupgCtx , int count ,
                                       unsigned int *imageOffset , unsigned int *blockLength ) ;
#line 1064
static int HpmfwupgFinishFirmwareUpload(struct ipmi_intf *intf , struct HpmfwupgFinishFirmwareUploadCtx *pCtx ,
                                        struct HpmfwupgUpgradeCtx *pFwupgCtx ) ;
#line 1067
static int HpmfwupgActivateFirmware(struct ipmi_intf *intf , struct HpmfwupgActivateFirmwareCtx *pCtx ,
                                    struct HpmfwupgUpgradeCtx *pFwupgCtx ) ;
#line 1070
static int HpmfwupgGetUpgradeStatus(struct ipmi_intf *intf , struct HpmfwupgGetUpgradeStatusCtx *pCtx ,
                                    struct HpmfwupgUpgradeCtx *pFwupgCtx , int silent ) ;
#line 1071
static int HpmfwupgManualFirmwareRollback(struct ipmi_intf *intf , struct HpmfwupgManualFirmwareRollbackCtx *pCtx ,
                                          struct HpmfwupgUpgradeCtx *pFwupgCtx ) ;
#line 1074
static void HpmfwupgPrintUsage(void) ;
#line 1075
static unsigned char HpmfwupgCalculateChecksum(unsigned char *pData , unsigned int length ) ;
#line 1076
static int HpmfwupgGetDeviceId(struct ipmi_intf *intf , struct ipm_devid_rsp *pGetDevId ) ;
#line 1077
static int HpmfwupgGetBufferFromFile(char *imageFilename , struct HpmfwupgUpgradeCtx *pFwupgCtx ) ;
#line 1078
static int HpmfwupgWaitLongDurationCmd(struct ipmi_intf *intf , struct HpmfwupgUpgradeCtx *pFwupgCtx ) ;
#line 1080
static struct ipmi_rs *HpmfwupgSendCmd(struct ipmi_intf *intf , struct ipmi_rq req ,
                                       struct HpmfwupgUpgradeCtx *pFwupgCtx ) ;
#line 1084
static int HpmFwupgActionUploadFirmware(struct HpmfwupgComponentBitMask components ,
                                        struct HpmfwupgUpgradeCtx *pFwupgCtx , unsigned char **pImagePtr ,
                                        int componentToUpload , struct ipmi_intf *intf ,
                                        int option , int *pFlagColdReset ) ;
#line 1114
extern int ( /* missing proto */  toupper)() ;
#line 1103 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
int HpmGetUserInput(char *str___1 ) 
{ 
  char userInput[2] ;
  int ret ;
  int tmp ;

  {
  {
#line 1108
  printf((char const   */* __restrict  */)"%s", str___1);
#line 1109
  ret = scanf((char const   */* __restrict  */)"%s", userInput);
  }
#line 1110
  if (! ret) {
#line 1111
    return (1);
  }
  {
#line 1114
  tmp = toupper((int )userInput[0]);
  }
#line 1114
  if (tmp == 89) {
#line 1116
    return (1);
  }
#line 1118
  return (0);
}
}
#line 1127 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
void HpmDisplayLine(char *s___1 , int n ) 
{ 
  int tmp ;

  {
  {
#line 1129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1129
    tmp = n;
#line 1129
    n --;
#line 1129
    if (! tmp) {
#line 1129
      goto while_break;
    }
    {
#line 1129
    printf((char const   */* __restrict  */)"%c", (int )*s___1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1130
  printf((char const   */* __restrict  */)"\n");
  }
#line 1131
  return;
}
}
#line 1140 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
void HpmDisplayUpgradeHeader(void) 
{ 


  {
  {
#line 1142
  printf((char const   */* __restrict  */)"\n");
#line 1143
  HpmDisplayLine((char *)"-", 79);
#line 1144
  printf((char const   */* __restrict  */)"|ID  | Name        |                     Versions                        | %%  |\n");
#line 1146
  printf((char const   */* __restrict  */)"|    |             |      Active     |      Backup     |      File       |    |\n");
#line 1148
  printf((char const   */* __restrict  */)"|----|-------------|-----------------|-----------------|-----------------|----|\n");
  }
#line 1150
  return;
}
}
#line 1164
void HpmDisplayUpgrade(int skip , unsigned int totalSent , unsigned int displayFWLength ,
                       time_t timeElapsed ) ;
#line 1164 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int old_percent  =    1;
#line 1160 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
void HpmDisplayUpgrade(int skip , unsigned int totalSent , unsigned int displayFWLength ,
                       time_t timeElapsed ) 
{ 
  int percent ;

  {
#line 1165
  if (skip) {
    {
#line 1167
    printf((char const   */* __restrict  */)"Skip|\n");
    }
#line 1168
    return;
  }
  {
#line 1170
  fflush(stdout);
#line 1172
  percent = (int )(((float )totalSent / (float )displayFWLength) * (float )100);
  }
#line 1173
  if (percent != old_percent) {
#line 1175
    if (percent == 0) {
      {
#line 1175
      printf((char const   */* __restrict  */)"  0%%|");
      }
    } else
#line 1176
    if (percent == 100) {
      {
#line 1176
      printf((char const   */* __restrict  */)"\b\b\b\b\b100%%|\n");
      }
    } else {
      {
#line 1177
      printf((char const   */* __restrict  */)"\b\b\b\b\b%3d%%|", percent);
      }
    }
#line 1178
    old_percent = percent;
  }
#line 1181
  if (totalSent == displayFWLength) {
    {
#line 1184
    printf((char const   */* __restrict  */)"|    |Upload Time: %02ld:%02ld             | Image Size: %7d bytes              |\n",
           timeElapsed / 60L, timeElapsed % 60L, totalSent);
    }
  }
#line 1188
  return;
}
}
#line 1197 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
void HpmDisplayVersionHeader(int mode ) 
{ 


  {
#line 1199
  if (mode & 4) {
    {
#line 1201
    HpmDisplayLine((char *)"-", 74);
#line 1202
    printf((char const   */* __restrict  */)"|ID  | Name        |                     Versions                        |\n");
#line 1204
    printf((char const   */* __restrict  */)"|    |             |     Active      |     Backup      |      File       |\n");
#line 1206
    HpmDisplayLine((char *)"-", 74);
    }
  } else {
    {
#line 1210
    HpmDisplayLine((char *)"-", 74);
#line 1211
    printf((char const   */* __restrict  */)"|ID  | Name        |                     Versions                        |\n");
#line 1213
    printf((char const   */* __restrict  */)"|    |             |     Active      |     Backup      |      Deferred   |\n");
#line 1215
    HpmDisplayLine((char *)"-", 74);
    }
  }
#line 1217
  return;
}
}
#line 1226 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
void HpmDisplayVersion(int mode , VERSIONINFO *pVersion , int upgradable ) 
{ 
  char descString[16] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1230
  memset((void *)(& descString), 0, sizeof(descString));
#line 1235
  strncpy((char */* __restrict  */)(descString), (char const   */* __restrict  */)(pVersion->descString),
          (size_t )13);
  }
#line 1242
  if (upgradable) {
#line 1242
    tmp = '^';
  } else {
#line 1242
    tmp = ' ';
  }
#line 1242
  if (pVersion->coldResetRequired) {
#line 1242
    tmp___0 = '*';
  } else {
#line 1242
    tmp___0 = ' ';
  }
  {
#line 1242
  printf((char const   */* __restrict  */)"|%c%c%2d|%-13s|", tmp___0, tmp, (int )pVersion->componentId,
         descString);
  }
#line 1247
  if (mode & 1) {
#line 1249
    if ((int )pVersion->targetMajor == 255) {
#line 1249
      goto _L;
    } else
#line 1249
    if ((int )pVersion->targetMajor == 127) {
      _L: /* CIL Label */ 
#line 1249
      if ((int )pVersion->targetMinor == 255) {
        {
#line 1252
        printf((char const   */* __restrict  */)" ---.-- -------- |");
        }
      } else {
        {
#line 1254
        printf((char const   */* __restrict  */)" %3d.%02x %02X%02X%02X%02X |", (int )pVersion->targetMajor,
               (int )pVersion->targetMinor, (int )pVersion->targetAux[0], (int )pVersion->targetAux[1],
               (int )pVersion->targetAux[2], (int )pVersion->targetAux[3]);
        }
      }
    } else {
      {
#line 1254
      printf((char const   */* __restrict  */)" %3d.%02x %02X%02X%02X%02X |", (int )pVersion->targetMajor,
             (int )pVersion->targetMinor, (int )pVersion->targetAux[0], (int )pVersion->targetAux[1],
             (int )pVersion->targetAux[2], (int )pVersion->targetAux[3]);
      }
    }
#line 1262
    if (mode & 2) {
#line 1264
      if ((int )pVersion->rollbackMajor == 255) {
#line 1264
        goto _L___0;
      } else
#line 1264
      if ((int )pVersion->rollbackMajor == 127) {
        _L___0: /* CIL Label */ 
#line 1264
        if ((int )pVersion->rollbackMinor == 255) {
          {
#line 1267
          printf((char const   */* __restrict  */)" ---.-- -------- |");
          }
        } else {
          {
#line 1269
          printf((char const   */* __restrict  */)" %3d.%02x %02X%02X%02X%02X |",
                 (int )pVersion->rollbackMajor, (int )pVersion->rollbackMinor, (int )pVersion->rollbackAux[0],
                 (int )pVersion->rollbackAux[1], (int )pVersion->rollbackAux[2], (int )pVersion->rollbackAux[3]);
          }
        }
      } else {
        {
#line 1269
        printf((char const   */* __restrict  */)" %3d.%02x %02X%02X%02X%02X |", (int )pVersion->rollbackMajor,
               (int )pVersion->rollbackMinor, (int )pVersion->rollbackAux[0], (int )pVersion->rollbackAux[1],
               (int )pVersion->rollbackAux[2], (int )pVersion->rollbackAux[3]);
        }
      }
    } else {
      {
#line 1278
      printf((char const   */* __restrict  */)" ---.-- -------- |");
      }
    }
  }
#line 1281
  if (mode & 4) {
#line 1283
    if ((int )pVersion->imageMajor == 255) {
#line 1283
      goto _L___1;
    } else
#line 1283
    if ((int )pVersion->imageMajor == 127) {
      _L___1: /* CIL Label */ 
#line 1283
      if ((int )pVersion->imageMinor == 255) {
        {
#line 1286
        printf((char const   */* __restrict  */)" ---.-- |");
        }
      } else {
        {
#line 1288
        printf((char const   */* __restrict  */)" %3d.%02x %02X%02X%02X%02X |", (int )pVersion->imageMajor,
               (int )pVersion->imageMinor, (int )pVersion->imageAux[0], (int )pVersion->imageAux[1],
               (int )pVersion->imageAux[2], (int )pVersion->imageAux[3]);
        }
      }
    } else {
      {
#line 1288
      printf((char const   */* __restrict  */)" %3d.%02x %02X%02X%02X%02X |", (int )pVersion->imageMajor,
             (int )pVersion->imageMinor, (int )pVersion->imageAux[0], (int )pVersion->imageAux[1],
             (int )pVersion->imageAux[2], (int )pVersion->imageAux[3]);
      }
    }
  } else
#line 1298
  if ((int )pVersion->deferredMajor == 255) {
#line 1298
    goto _L___2;
  } else
#line 1298
  if ((int )pVersion->deferredMajor == 127) {
    _L___2: /* CIL Label */ 
#line 1298
    if ((int )pVersion->deferredMinor == 255) {
      {
#line 1301
      printf((char const   */* __restrict  */)" ---.-- -------- |");
      }
    } else {
      {
#line 1303
      printf((char const   */* __restrict  */)" %3d.%02x %02X%02X%02X%02X |", (int )pVersion->deferredMajor,
             (int )pVersion->deferredMinor, (int )pVersion->deferredAux[0], (int )pVersion->deferredAux[1],
             (int )pVersion->deferredAux[2], (int )pVersion->deferredAux[3]);
      }
    }
  } else {
    {
#line 1303
    printf((char const   */* __restrict  */)" %3d.%02x %02X%02X%02X%02X |", (int )pVersion->deferredMajor,
           (int )pVersion->deferredMinor, (int )pVersion->deferredAux[0], (int )pVersion->deferredAux[1],
           (int )pVersion->deferredAux[2], (int )pVersion->deferredAux[3]);
    }
  }
#line 1311
  return;
}
}
#line 1322 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
int HpmfwupgTargetCheck(struct ipmi_intf *intf , int option ) 
{ 
  struct HpmfwupgGetTargetUpgCapabilitiesCtx targetCapCmd ;
  int rc ;
  int componentId ;
  int flagColdReset ;
  struct ipm_devid_rsp devIdrsp ;
  struct HpmfwupgGetComponentPropertiesCtx getCompProp ;
  int mode ;
  uint16_t tmp ;
  uint16_t tmp___0 ;
  char const   *tmp___1 ;
  uint16_t tmp___2 ;

  {
  {
#line 1326
  rc = (int )HPMFWUPG_SUCCESS;
#line 1327
  componentId = 0;
#line 1328
  flagColdReset = 0;
#line 1331
  mode = 0;
#line 1334
  rc = HpmfwupgGetDeviceId(intf, & devIdrsp);
  }
#line 1336
  if (rc != (int )HPMFWUPG_SUCCESS) {
    {
#line 1338
    lprintf(5, "Verify whether the Target board is present \n");
    }
#line 1339
    return ((int )HPMFWUPG_ERROR);
  }
  {
#line 1342
  rc = HpmfwupgGetTargetUpgCapabilities(intf, & targetCapCmd);
  }
#line 1343
  if (rc != (int )HPMFWUPG_SUCCESS) {
    {
#line 1349
    lprintf(5, "Board might not be supporting the HPM.1 Standards\n");
    }
#line 1350
    return (rc);
  }
#line 1352
  if (option & 2) {
    {
#line 1354
    lprintf(5, "-------Target Information-------");
#line 1355
    lprintf(5, "Device Id          : 0x%x", (int )devIdrsp.device_id);
#line 1356
    lprintf(5, "Device Revision    : 0x%x", (int )devIdrsp.device_revision);
#line 1357
    tmp = buf2short(devIdrsp.product_id);
#line 1357
    lprintf(5, "Product Id         : 0x%04x", (int )tmp);
#line 1358
    tmp___0 = buf2short(devIdrsp.manufacturer_id);
#line 1358
    tmp___1 = val2str(tmp___0, ipmi_oem_info);
#line 1358
    tmp___2 = buf2short(devIdrsp.manufacturer_id);
#line 1358
    lprintf(5, "Manufacturer Id    : 0x%04x (%s)\n\n", (int )tmp___2, tmp___1);
#line 1360
    HpmDisplayVersionHeader(3);
    }
  }
#line 1363
  componentId = 0;
  {
#line 1363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1363
    if (! (componentId < 8)) {
#line 1363
      goto while_break;
    }
#line 1367
    if ((1 << componentId) & (int )targetCapCmd.resp.componentsPresent.ComponentBits.byte) {
      {
#line 1369
      memset((void *)(& gVersionInfo[componentId]), 0, sizeof(VERSIONINFO ));
#line 1371
      getCompProp.req.componentId = (unsigned char )componentId;
#line 1372
      getCompProp.req.selector = (unsigned char)0;
#line 1373
      rc = HpmfwupgGetComponentProperties(intf, & getCompProp);
      }
#line 1374
      if (rc != (int )HPMFWUPG_SUCCESS) {
        {
#line 1376
        lprintf(5, "Get CompGenProp Failed for component Id %d\n", componentId);
        }
#line 1377
        return (rc);
      }
      {
#line 1380
      gVersionInfo[componentId].rollbackSupported = getCompProp.resp.Response.generalPropResp.GeneralCompProperties.bitfield.rollbackBackup;
#line 1382
      gVersionInfo[componentId].coldResetRequired = getCompProp.resp.Response.generalPropResp.GeneralCompProperties.bitfield.payloadColdReset;
#line 1385
      getCompProp.req.selector = (unsigned char)2;
#line 1386
      rc = HpmfwupgGetComponentProperties(intf, & getCompProp);
      }
#line 1387
      if (rc != (int )HPMFWUPG_SUCCESS) {
        {
#line 1389
        lprintf(5, "Get CompDescString Failed for component Id %d\n", componentId);
        }
#line 1390
        return (rc);
      }
      {
#line 1392
      strcpy((char */* __restrict  */)((char *)(& gVersionInfo[componentId].descString)),
             (char const   */* __restrict  */)(getCompProp.resp.Response.descStringResp.descString));
#line 1395
      getCompProp.req.selector = (unsigned char)1;
#line 1396
      rc = HpmfwupgGetComponentProperties(intf, & getCompProp);
      }
#line 1397
      if (rc != (int )HPMFWUPG_SUCCESS) {
        {
#line 1399
        lprintf(5, "Get CompCurrentVersion Failed for component Id %d\n", componentId);
        }
#line 1400
        return (rc);
      }
#line 1403
      gVersionInfo[componentId].componentId = (unsigned char )componentId;
#line 1404
      gVersionInfo[componentId].targetMajor = getCompProp.resp.Response.currentVersionResp.currentVersion[0];
#line 1406
      gVersionInfo[componentId].targetMinor = getCompProp.resp.Response.currentVersionResp.currentVersion[1];
#line 1408
      gVersionInfo[componentId].targetAux[0] = getCompProp.resp.Response.currentVersionResp.currentVersion[2];
#line 1410
      gVersionInfo[componentId].targetAux[1] = getCompProp.resp.Response.currentVersionResp.currentVersion[3];
#line 1412
      gVersionInfo[componentId].targetAux[2] = getCompProp.resp.Response.currentVersionResp.currentVersion[4];
#line 1414
      gVersionInfo[componentId].targetAux[3] = getCompProp.resp.Response.currentVersionResp.currentVersion[5];
#line 1416
      mode = 1;
#line 1418
      if (gVersionInfo[componentId].rollbackSupported) {
        {
#line 1420
        getCompProp.req.selector = (unsigned char)3;
#line 1421
        rc = HpmfwupgGetComponentProperties(intf, & getCompProp);
        }
#line 1422
        if (rc != (int )HPMFWUPG_SUCCESS) {
          {
#line 1424
          lprintf(5, "Get CompRollbackVersion Failed for component Id %d\n", componentId);
          }
        } else {
#line 1426
          gVersionInfo[componentId].rollbackMajor = getCompProp.resp.Response.rollbackFwVersionResp.rollbackFwVersion[0];
#line 1428
          gVersionInfo[componentId].rollbackMinor = getCompProp.resp.Response.rollbackFwVersionResp.rollbackFwVersion[1];
#line 1430
          gVersionInfo[componentId].rollbackAux[0] = getCompProp.resp.Response.rollbackFwVersionResp.rollbackFwVersion[2];
#line 1431
          gVersionInfo[componentId].rollbackAux[1] = getCompProp.resp.Response.rollbackFwVersionResp.rollbackFwVersion[3];
#line 1432
          gVersionInfo[componentId].rollbackAux[2] = getCompProp.resp.Response.rollbackFwVersionResp.rollbackFwVersion[4];
#line 1433
          gVersionInfo[componentId].rollbackAux[3] = getCompProp.resp.Response.rollbackFwVersionResp.rollbackFwVersion[5];
        }
        {
#line 1436
        getCompProp.req.selector = (unsigned char)4;
#line 1437
        rc = HpmfwupgGetComponentProperties(intf, & getCompProp);
        }
#line 1438
        if (rc != (int )HPMFWUPG_SUCCESS) {
          {
#line 1440
          lprintf(5, "Get CompRollbackVersion Failed for component Id %d\n", componentId);
          }
        } else {
#line 1442
          gVersionInfo[componentId].deferredMajor = getCompProp.resp.Response.deferredFwVersionResp.deferredFwVersion[0];
#line 1444
          gVersionInfo[componentId].deferredMinor = getCompProp.resp.Response.deferredFwVersionResp.deferredFwVersion[1];
#line 1446
          gVersionInfo[componentId].deferredAux[0] = getCompProp.resp.Response.deferredFwVersionResp.deferredFwVersion[2];
#line 1447
          gVersionInfo[componentId].deferredAux[1] = getCompProp.resp.Response.deferredFwVersionResp.deferredFwVersion[3];
#line 1448
          gVersionInfo[componentId].deferredAux[2] = getCompProp.resp.Response.deferredFwVersionResp.deferredFwVersion[4];
#line 1449
          gVersionInfo[componentId].deferredAux[3] = getCompProp.resp.Response.deferredFwVersionResp.deferredFwVersion[5];
        }
#line 1451
        mode |= 2;
      } else {
#line 1455
        gVersionInfo[componentId].rollbackMajor = (unsigned char)255;
#line 1456
        gVersionInfo[componentId].rollbackMinor = (unsigned char)255;
#line 1457
        gVersionInfo[componentId].rollbackAux[0] = (unsigned char)255;
#line 1458
        gVersionInfo[componentId].rollbackAux[1] = (unsigned char)255;
#line 1459
        gVersionInfo[componentId].rollbackAux[2] = (unsigned char)255;
#line 1460
        gVersionInfo[componentId].rollbackAux[3] = (unsigned char)255;
#line 1462
        gVersionInfo[componentId].deferredMajor = (unsigned char)255;
#line 1463
        gVersionInfo[componentId].deferredMinor = (unsigned char)255;
#line 1464
        gVersionInfo[componentId].deferredAux[0] = (unsigned char)255;
#line 1465
        gVersionInfo[componentId].deferredAux[1] = (unsigned char)255;
#line 1466
        gVersionInfo[componentId].deferredAux[2] = (unsigned char)255;
#line 1467
        gVersionInfo[componentId].deferredAux[3] = (unsigned char)255;
      }
#line 1470
      if (gVersionInfo[componentId].coldResetRequired) {
#line 1476
        flagColdReset = 1;
      }
#line 1478
      if (option & 2) {
        {
#line 1480
        HpmDisplayVersion(mode, & gVersionInfo[componentId], 0);
#line 1481
        printf((char const   */* __restrict  */)"\n");
        }
      }
    }
#line 1363
    componentId ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1486
  if (option & 2) {
    {
#line 1488
    HpmDisplayLine((char *)"-", 74);
#line 1489
    fflush(stdout);
#line 1490
    lprintf(5, "(*) Component requires Payload Cold Reset");
#line 1491
    printf((char const   */* __restrict  */)"\n\n");
    }
  }
#line 1493
  return ((int )HPMFWUPG_SUCCESS);
}
}
#line 1575
int HpmfwupgPreUpgradeCheck(struct ipmi_intf *intf , struct HpmfwupgUpgradeCtx *pFwupgCtx ,
                            int componentToUpload , int option ) ;
#line 1504 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgUpgrade(struct ipmi_intf *intf , char *imageFilename , int activate ,
                           int componentToUpload , int option ) 
{ 
  int rc ;
  struct HpmfwupgUpgradeCtx fwupgCtx ;

  {
  {
#line 1507
  rc = (int )HPMFWUPG_SUCCESS;
#line 1515
  rc = HpmfwupgGetBufferFromFile(imageFilename, & fwupgCtx);
  }
#line 1521
  if (rc == (int )HPMFWUPG_SUCCESS) {
    {
#line 1523
    printf((char const   */* __restrict  */)"Validating firmware image integrity...");
#line 1524
    fflush(stdout);
#line 1525
    rc = HpmfwupgValidateImageIntegrity(& fwupgCtx);
    }
#line 1526
    if (rc == (int )HPMFWUPG_SUCCESS) {
      {
#line 1528
      printf((char const   */* __restrict  */)"OK\n");
#line 1529
      fflush(stdout);
      }
    } else {
      {
#line 1533
      free((void *)fwupgCtx.pImageData);
#line 1534
      fwupgCtx.pImageData = (unsigned char *)((void *)0);
      }
    }
  }
#line 1542
  if (rc == (int )HPMFWUPG_SUCCESS) {
    {
#line 1544
    printf((char const   */* __restrict  */)"Performing preparation stage...");
#line 1545
    fflush(stdout);
#line 1546
    rc = HpmfwupgPreparationStage(intf, & fwupgCtx, option);
    }
#line 1547
    if (rc == (int )HPMFWUPG_SUCCESS) {
      {
#line 1549
      printf((char const   */* __restrict  */)"OK\n");
#line 1550
      fflush(stdout);
      }
    } else {
      {
#line 1554
      free((void *)fwupgCtx.pImageData);
#line 1555
      fwupgCtx.pImageData = (unsigned char *)((void *)0);
      }
    }
  }
#line 1563
  if (rc == (int )HPMFWUPG_SUCCESS) {
#line 1565
    if (option & 2) {
      {
#line 1567
      lprintf(5, "\nComparing Target & Image File version");
      }
    } else {
      {
#line 1571
      lprintf(5, "\nPerforming upgrade stage:");
      }
    }
#line 1573
    if (option & 2) {
      {
#line 1575
      rc = HpmfwupgPreUpgradeCheck(intf, & fwupgCtx, componentToUpload, 2);
      }
    } else {
      {
#line 1579
      rc = HpmfwupgPreUpgradeCheck(intf, & fwupgCtx, componentToUpload, option);
      }
#line 1580
      if (rc == (int )HPMFWUPG_SUCCESS) {
#line 1582
        if (verbose) {
          {
#line 1583
          printf((char const   */* __restrict  */)"Component update mask : 0x%02x\n",
                 (int )fwupgCtx.compUpdateMask.ComponentBits.byte);
          }
        }
        {
#line 1585
        rc = HpmfwupgUpgradeStage(intf, & fwupgCtx, componentToUpload, option);
        }
      }
    }
#line 1589
    if (rc != (int )HPMFWUPG_SUCCESS) {
      {
#line 1591
      free((void *)fwupgCtx.pImageData);
#line 1592
      fwupgCtx.pImageData = (unsigned char *)((void *)0);
      }
    }
  }
#line 1599
  if (rc == (int )HPMFWUPG_SUCCESS) {
#line 1599
    if (activate) {
      {
#line 1601
      lprintf(5, "Performing activation stage: ");
#line 1602
      rc = HpmfwupgActivationStage(intf, & fwupgCtx);
      }
#line 1603
      if (rc != (int )HPMFWUPG_SUCCESS) {
        {
#line 1605
        free((void *)fwupgCtx.pImageData);
#line 1606
        fwupgCtx.pImageData = (unsigned char *)((void *)0);
        }
      }
    }
  }
#line 1610
  if (rc == (int )HPMFWUPG_SUCCESS) {
#line 1612
    if (option & 2) {
      {
#line 1615
      lprintf(5, " ");
      }
    } else {
      {
#line 1619
      lprintf(5, "\nFirmware upgrade procedure successful\n");
      }
    }
    {
#line 1621
    free((void *)fwupgCtx.pImageData);
#line 1622
    fwupgCtx.pImageData = (unsigned char *)((void *)0);
    }
  } else {
    {
#line 1626
    lprintf(5, "Firmware upgrade procedure failed\n");
    }
  }
#line 1629
  return (rc);
}
}
#line 1647 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static unsigned char md[16]  ;
#line 1641 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgValidateImageIntegrity(struct HpmfwupgUpgradeCtx *pFwupgCtx ) 
{ 
  int rc ;
  struct HpmfwupgImageHeader *pImageHeader ;
  md5_state_t ctx ;
  unsigned char *pMd5Sig ;
  int tmp ;
  unsigned char tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1643
  rc = (int )HPMFWUPG_SUCCESS;
#line 1644
  pImageHeader = (struct HpmfwupgImageHeader *)pFwupgCtx->pImageData;
#line 1648
  pMd5Sig = pFwupgCtx->pImageData + (pFwupgCtx->imageSize - 16U);
#line 1653
  memset((void *)(md), 0, (size_t )16);
#line 1654
  memset((void *)(& ctx), 0, sizeof(md5_state_t ));
#line 1655
  md5_init(& ctx);
#line 1656
  md5_append(& ctx, (md5_byte_t const   *)pFwupgCtx->pImageData, (int )(pFwupgCtx->imageSize - 16U));
#line 1658
  md5_finish(& ctx, (md5_byte_t *)(md));
#line 1659
  tmp = memcmp((void const   *)(md), (void const   *)pMd5Sig, (size_t )16);
  }
#line 1659
  if (tmp != 0) {
    {
#line 1661
    lprintf(5, "\n    Invalid MD5 signature");
#line 1662
    rc = (int )HPMFWUPG_ERROR;
    }
  }
#line 1665
  if (rc == (int )HPMFWUPG_SUCCESS) {
    {
#line 1668
    tmp___1 = strncmp((char const   *)(pImageHeader->signature), "PICMGFWU", (size_t )8);
    }
#line 1668
    if (tmp___1 == 0) {
#line 1671
      if ((int )pImageHeader->formatVersion == 0) {
        {
#line 1674
        tmp___0 = HpmfwupgCalculateChecksum((unsigned char *)pImageHeader, (unsigned int )((sizeof(struct HpmfwupgImageHeader ) + (unsigned long )pImageHeader->oemDataLength) + sizeof(unsigned char )));
        }
#line 1674
        if ((int )tmp___0 != 0) {
          {
#line 1679
          lprintf(5, "\n    Invalid header checksum");
#line 1680
          rc = (int )HPMFWUPG_ERROR;
          }
        }
      } else {
        {
#line 1685
        lprintf(5, "\n    Unrecognized image version");
#line 1686
        rc = (int )HPMFWUPG_ERROR;
        }
      }
    } else {
      {
#line 1691
      lprintf(5, "\n    Invalid image signature");
#line 1692
      rc = (int )HPMFWUPG_ERROR;
      }
    }
  }
#line 1695
  return (rc);
}
}
#line 1707 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgPreparationStage(struct ipmi_intf *intf , struct HpmfwupgUpgradeCtx *pFwupgCtx ,
                                    int option ) 
{ 
  int rc ;
  struct HpmfwupgImageHeader *pImageHeader ;
  uint16_t tmp ;
  int tmp___0 ;
  uint16_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct HpmfwupgGetTargetUpgCapabilitiesCtx targetCapCmd ;
  int tmp___5 ;
  int componentId ;
  struct HpmfwupgGetComponentPropertiesCtx getCompPropCmd ;

  {
  {
#line 1709
  rc = (int )HPMFWUPG_SUCCESS;
#line 1710
  pImageHeader = (struct HpmfwupgImageHeader *)pFwupgCtx->pImageData;
#line 1714
  rc = HpmfwupgGetDeviceId(intf, & pFwupgCtx->devId);
  }
#line 1717
  if (rc == (int )HPMFWUPG_SUCCESS) {
#line 1720
    if ((int )pImageHeader->deviceId == (int )pFwupgCtx->devId.device_id) {
      {
#line 1723
      tmp___2 = memcmp((void const   *)(pImageHeader->prodId), (void const   *)(pFwupgCtx->devId.product_id),
                       (size_t )2);
      }
#line 1723
      if (tmp___2 == 0) {
        {
#line 1726
        tmp___0 = memcmp((void const   *)(pImageHeader->manId), (void const   *)(pFwupgCtx->devId.manufacturer_id),
                         (size_t )3);
        }
#line 1726
        if (tmp___0 != 0) {
          {
#line 1729
          tmp = buf2short(pFwupgCtx->devId.manufacturer_id);
#line 1729
          lprintf(5, "\n    Invalid image file for manufacturer %u", (int )tmp);
#line 1731
          rc = (int )HPMFWUPG_ERROR;
          }
        }
      } else {
        {
#line 1736
        tmp___1 = buf2short(pFwupgCtx->devId.product_id);
#line 1736
        lprintf(5, "\n    Invalid image file for product %u", (int )tmp___1);
#line 1738
        rc = (int )HPMFWUPG_ERROR;
        }
      }
    } else {
      {
#line 1744
      lprintf(5, "\n    Invalid device ID %x", (int )pFwupgCtx->devId.device_id);
#line 1745
      rc = (int )HPMFWUPG_ERROR;
      }
    }
#line 1748
    if (rc != (int )HPMFWUPG_SUCCESS) {
#line 1756
      if (option & 24) {
#line 1756
        goto _L;
      } else
#line 1756
      if (option & 2) {
        _L: /* CIL Label */ 
        {
#line 1758
        printf((char const   */* __restrict  */)"\n    Image Information");
#line 1759
        printf((char const   */* __restrict  */)"\n        Device Id : 0x%x", (int )pImageHeader->deviceId);
#line 1760
        printf((char const   */* __restrict  */)"\n        Prod   Id : 0x%02x%02x",
               (int )pImageHeader->prodId[1], (int )pImageHeader->prodId[0]);
#line 1761
        printf((char const   */* __restrict  */)"\n        Manuf  Id : 0x%02x%02x%02x",
               (int )pImageHeader->manId[2], (int )pImageHeader->manId[1], (int )pImageHeader->manId[0]);
#line 1763
        printf((char const   */* __restrict  */)"\n    Board Information");
#line 1764
        printf((char const   */* __restrict  */)"\n        Device Id : 0x%x", (int )pFwupgCtx->devId.device_id);
#line 1765
        printf((char const   */* __restrict  */)"\n        Prod   Id : 0x%02x%02x",
               (int )pFwupgCtx->devId.product_id[1], (int )pFwupgCtx->devId.product_id[0]);
#line 1766
        printf((char const   */* __restrict  */)"\n        Manuf  Id : 0x%02x%02x%02x",
               (int )pFwupgCtx->devId.manufacturer_id[2], (int )pFwupgCtx->devId.manufacturer_id[1],
               (int )pFwupgCtx->devId.manufacturer_id[0]);
#line 1768
        tmp___3 = HpmGetUserInput((char *)"\n Continue ignoring DeviceID/ProductID/ManufacturingID (Y/N) :");
        }
#line 1768
        if (tmp___3) {
#line 1769
          rc = (int )HPMFWUPG_SUCCESS;
        }
      } else {
        {
#line 1773
        printf((char const   */* __restrict  */)"\n\n Use \"force\" option for copying all the components\n");
        }
      }
    }
  }
#line 1779
  if (rc == (int )HPMFWUPG_SUCCESS) {
#line 1782
    if (! ((int )pImageHeader->compRevision[0] < (int )pFwupgCtx->devId.fw_rev1)) {
#line 1786
      if ((int )pImageHeader->compRevision[0] == (int )pFwupgCtx->devId.fw_rev1) {
#line 1789
        if ((int )pImageHeader->compRevision[1] > (int )pFwupgCtx->devId.fw_rev2) {
          {
#line 1792
          lprintf(5, "\n    Version: Major: %d", (int )pImageHeader->compRevision[0]);
#line 1793
          lprintf(5, "             Minor: %x", (int )pImageHeader->compRevision[1]);
#line 1794
          lprintf(5, "    Not compatible with ");
#line 1795
          lprintf(5, "    Version: Major: %d", (int )pFwupgCtx->devId.fw_rev1);
#line 1796
          lprintf(5, "             Minor: %x", (int )pFwupgCtx->devId.fw_rev2);
#line 1797
          rc = (int )HPMFWUPG_ERROR;
          }
        }
      } else {
        {
#line 1803
        lprintf(5, "\n    Version: Major: %d", (int )pImageHeader->compRevision[0]);
#line 1804
        lprintf(5, "             Minor: %x", (int )pImageHeader->compRevision[1]);
#line 1805
        lprintf(5, "    Not compatible with ");
#line 1806
        lprintf(5, "    Version: Major: %d", (int )pFwupgCtx->devId.fw_rev1);
#line 1807
        lprintf(5, "             Minor: %x", (int )pFwupgCtx->devId.fw_rev2);
#line 1808
        rc = (int )HPMFWUPG_ERROR;
        }
      }
    }
#line 1811
    if (rc != (int )HPMFWUPG_SUCCESS) {
#line 1814
      if (option & 24) {
#line 1814
        goto _L___0;
      } else
#line 1814
      if (option & 2) {
        _L___0: /* CIL Label */ 
        {
#line 1816
        tmp___4 = HpmGetUserInput((char *)"\n Continue IGNORING Earliest compatibility (Y/N) :");
        }
#line 1816
        if (tmp___4) {
#line 1817
          rc = (int )HPMFWUPG_SUCCESS;
        }
      }
    }
  }
#line 1823
  if (rc == (int )HPMFWUPG_SUCCESS) {
    {
#line 1827
    rc = HpmfwupgGetTargetUpgCapabilities(intf, & targetCapCmd);
    }
#line 1829
    if (rc == (int )HPMFWUPG_SUCCESS) {
      {
#line 1832
      memcpy((void */* __restrict  */)(& pFwupgCtx->targetCap), (void const   */* __restrict  */)(& targetCapCmd.resp),
             sizeof(struct HpmfwupgGetTargetUpgCapabilitiesResp ));
      }
#line 1836
      if (option & 2) {
#line 1838
        return (rc);
      } else {
#line 1844
        if (((int )pImageHeader->components.ComponentBits.byte & (int )pFwupgCtx->targetCap.componentsPresent.ComponentBits.byte) != (int )pImageHeader->components.ComponentBits.byte) {
          {
#line 1848
          lprintf(5, "\n    Some components present in the image file are not supported by the IPMC");
#line 1849
          rc = (int )HPMFWUPG_ERROR;
          }
        }
#line 1853
        if ((int )pFwupgCtx->targetCap.GlobalCapabilities.bitField.fwUpgUndesirable == 1) {
          {
#line 1855
          lprintf(5, "\n    Upgrade undesirable at this moment");
#line 1856
          rc = (int )HPMFWUPG_ERROR;
          }
        }
#line 1861
        if ((int )pFwupgCtx->targetCap.GlobalCapabilities.bitField.servAffectDuringUpg == 1) {
#line 1861
          goto _L___1;
        } else
#line 1861
        if ((int )pImageHeader->imageCapabilities.bitField.servAffected == 1) {
          _L___1: /* CIL Label */ 
          {
#line 1864
          tmp___5 = HpmGetUserInput((char *)"\nServices may be affected during upgrade. Do you wish to continue? y/n ");
          }
#line 1864
          if (tmp___5) {
#line 1866
            rc = (int )HPMFWUPG_SUCCESS;
          } else {
#line 1870
            rc = (int )HPMFWUPG_ERROR;
          }
        }
      }
    }
  }
#line 1878
  if (rc == (int )HPMFWUPG_SUCCESS) {
#line 1882
    componentId = 0;
    {
#line 1882
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1882
      if (! (componentId < 8)) {
#line 1882
        goto while_break;
      }
      {
#line 1887
      memset((void *)(& pFwupgCtx->genCompProp[componentId]), 0, sizeof(struct HpmfwupgGetGeneralPropResp ));
      }
#line 1889
      if ((1 << componentId) & (int )pImageHeader->components.ComponentBits.byte) {
        {
#line 1894
        getCompPropCmd.req.componentId = (unsigned char )componentId;
#line 1895
        getCompPropCmd.req.selector = (unsigned char)0;
#line 1897
        rc = HpmfwupgGetComponentProperties(intf, & getCompPropCmd);
        }
#line 1899
        if (rc == (int )HPMFWUPG_SUCCESS) {
          {
#line 1902
          memcpy((void */* __restrict  */)(& pFwupgCtx->genCompProp[componentId]),
                 (void const   */* __restrict  */)(& getCompPropCmd.resp), sizeof(struct HpmfwupgGetGeneralPropResp ));
          }
        }
      }
#line 1882
      componentId ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1910
  return (rc);
}
}
#line 1913 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int image_version_upgradable(VERSIONINFO *pVersionInfo ) 
{ 


  {
#line 1917
  if ((int )pVersionInfo->imageMajor != (int )pVersionInfo->targetMajor) {
#line 1923
    return (1);
  } else
#line 1917
  if ((int )pVersionInfo->imageMinor != (int )pVersionInfo->targetMinor) {
#line 1923
    return (1);
  } else
#line 1917
  if ((int )pVersionInfo->imageAux[0] != (int )pVersionInfo->targetAux[0]) {
#line 1923
    return (1);
  } else
#line 1917
  if ((int )pVersionInfo->imageAux[1] != (int )pVersionInfo->targetAux[1]) {
#line 1923
    return (1);
  } else
#line 1917
  if ((int )pVersionInfo->imageAux[2] != (int )pVersionInfo->targetAux[2]) {
#line 1923
    return (1);
  } else
#line 1917
  if ((int )pVersionInfo->imageAux[3] != (int )pVersionInfo->targetAux[3]) {
#line 1923
    return (1);
  }
#line 1927
  if (! pVersionInfo->rollbackSupported) {
#line 1928
    return (0);
  }
#line 1932
  if ((int )pVersionInfo->imageMajor != (int )pVersionInfo->rollbackMajor) {
#line 1938
    return (1);
  } else
#line 1932
  if ((int )pVersionInfo->imageMinor != (int )pVersionInfo->rollbackMinor) {
#line 1938
    return (1);
  } else
#line 1932
  if ((int )pVersionInfo->imageAux[0] != (int )pVersionInfo->rollbackAux[0]) {
#line 1938
    return (1);
  } else
#line 1932
  if ((int )pVersionInfo->imageAux[1] != (int )pVersionInfo->rollbackAux[1]) {
#line 1938
    return (1);
  } else
#line 1932
  if ((int )pVersionInfo->imageAux[2] != (int )pVersionInfo->rollbackAux[2]) {
#line 1938
    return (1);
  } else
#line 1932
  if ((int )pVersionInfo->imageAux[3] != (int )pVersionInfo->rollbackAux[3]) {
#line 1938
    return (1);
  }
#line 1941
  return (0);
}
}
#line 1953 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
int HpmfwupgPreUpgradeCheck(struct ipmi_intf *intf , struct HpmfwupgUpgradeCtx *pFwupgCtx ,
                            int componentToUpload , int option ) 
{ 
  unsigned char *pImagePtr ;
  struct HpmfwupgActionRecord *pActionRecord ;
  int flagColdReset ;
  struct HpmfwupgImageHeader *pImageHeader ;
  unsigned char tmp ;
  struct HpmfwupgFirmwareImage *pFwImage ;
  unsigned char *pData ;
  unsigned int firmwareLength ;
  unsigned char mode ;
  unsigned char componentId ;
  unsigned char componentIdByte ;
  unsigned int upgrade_comp ;
  VERSIONINFO *pVersionInfo ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 1959
  flagColdReset = 0;
#line 1962
  pImageHeader = (struct HpmfwupgImageHeader *)pFwupgCtx->pImageData;
#line 1965
  pImagePtr = ((pFwupgCtx->pImageData + sizeof(struct HpmfwupgImageHeader )) + (int )pImageHeader->oemDataLength) + sizeof(unsigned char );
#line 1969
  if (option & 2) {
    {
#line 1970
    HpmDisplayVersionHeader(7);
    }
  }
  {
#line 1974
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1974
    if (! ((unsigned long )pImagePtr < (unsigned long )((pFwupgCtx->pImageData + pFwupgCtx->imageSize) - 16))) {
#line 1974
      goto while_break;
    }
    {
#line 1977
    pActionRecord = (struct HpmfwupgActionRecord *)pImagePtr;
#line 1980
    tmp = HpmfwupgCalculateChecksum((unsigned char *)pActionRecord, (unsigned int )sizeof(struct HpmfwupgActionRecord ));
    }
#line 1980
    if ((int )tmp != 0) {
      {
#line 1982
      lprintf(5, "    Invalid Action record.");
      }
#line 1983
      return ((int )HPMFWUPG_ERROR);
    }
    {
#line 1988
    if ((int )pActionRecord->actionType == 0) {
#line 1988
      goto case_0;
    }
#line 1994
    if ((int )pActionRecord->actionType == 1) {
#line 1994
      goto case_1;
    }
#line 2008
    if ((int )pActionRecord->actionType == 2) {
#line 2008
      goto case_2;
    }
#line 2086
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1990
    pImagePtr += sizeof(struct HpmfwupgActionRecord );
#line 1992
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1996
    if (componentToUpload != 15) {
#line 1997
      if (! ((1 << componentToUpload) & (int )pActionRecord->components.ComponentBits.byte)) {
        {
#line 1999
        lprintf(5, "\nComponent Id given is not supported\n");
        }
#line 2001
        return ((int )HPMFWUPG_ERROR);
      }
    }
#line 2004
    pImagePtr += sizeof(struct HpmfwupgActionRecord );
#line 2006
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2022
    componentIdByte = pActionRecord->components.ComponentBits.byte;
#line 2024
    componentId = (unsigned char)0;
    {
#line 2025
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2025
      componentIdByte = (unsigned char )((int )componentIdByte >> 1);
#line 2025
      if (! ((int )componentIdByte != 0)) {
#line 2025
        goto while_break___0;
      }
#line 2026
      componentId = (unsigned char )((int )componentId + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2028
    pFwupgCtx->componentId = componentId;
#line 2030
    pFwImage = (struct HpmfwupgFirmwareImage *)(pImagePtr + sizeof(struct HpmfwupgActionRecord ));
#line 2033
    pData = (unsigned char *)pFwImage + sizeof(struct HpmfwupgFirmwareImage );
#line 2037
    firmwareLength = (unsigned int )pFwImage->length[0];
#line 2038
    firmwareLength |= (unsigned int )(((int )pFwImage->length[1] << 8) & 65280);
#line 2039
    firmwareLength |= (unsigned int )(((int )pFwImage->length[2] << 16) & 16711680);
#line 2040
    firmwareLength |= (unsigned int )((int )pFwImage->length[3] << 24) & 4278190080U;
#line 2042
    pVersionInfo = & gVersionInfo[componentId];
#line 2044
    pVersionInfo->imageMajor = pFwImage->version[0];
#line 2045
    pVersionInfo->imageMinor = pFwImage->version[1];
#line 2046
    pVersionInfo->imageAux[0] = pFwImage->version[2];
#line 2047
    pVersionInfo->imageAux[1] = pFwImage->version[3];
#line 2048
    pVersionInfo->imageAux[2] = pFwImage->version[4];
#line 2049
    pVersionInfo->imageAux[3] = pFwImage->version[5];
#line 2051
    mode = (unsigned char)5;
#line 2053
    if (pVersionInfo->coldResetRequired) {
#line 2054
      flagColdReset = 1;
    }
#line 2056
    upgrade_comp = 0U;
#line 2057
    if (option & 8) {
#line 2058
      upgrade_comp = 1U;
    } else
#line 2060
    if (option & 16) {
#line 2060
      if (componentToUpload == (int )componentId) {
#line 2062
        upgrade_comp = 1U;
      } else {
#line 2060
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 2064
      tmp___0 = image_version_upgradable(pVersionInfo);
      }
#line 2064
      if (tmp___0) {
#line 2065
        upgrade_comp = 1U;
      }
    }
#line 2068
    if (verbose) {
#line 2069
      if (upgrade_comp) {
#line 2069
        tmp___1 = "Updating";
      } else {
#line 2069
        tmp___1 = "Skipping";
      }
      {
#line 2069
      lprintf(5, "%s component %d", tmp___1, (int )componentId);
      }
    }
#line 2073
    if (upgrade_comp) {
#line 2074
      pFwupgCtx->compUpdateMask.ComponentBits.byte = (unsigned char )((int )pFwupgCtx->compUpdateMask.ComponentBits.byte | (1 << (int )componentId));
    }
#line 2077
    if (option & 2) {
#line 2078
      if (pVersionInfo->rollbackSupported) {
#line 2079
        mode = (unsigned char )((int )mode | 2);
      }
      {
#line 2080
      HpmDisplayVersion((int )mode, pVersionInfo, (int )upgrade_comp);
#line 2081
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 2083
    pImagePtr = pData + firmwareLength;
#line 2085
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2087
    lprintf(5, "    Invalid Action type. Cannot continue");
    }
#line 2089
    return ((int )HPMFWUPG_ERROR);
#line 2090
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2094
  if (option & 2) {
    {
#line 2095
    HpmDisplayLine((char *)"-", 74);
#line 2096
    fflush(stdout);
#line 2097
    lprintf(5, "(*) Component requires Payload Cold Reset");
#line 2098
    lprintf(5, "(^) Indicates component would be upgraded");
    }
  }
#line 2100
  return ((int )HPMFWUPG_SUCCESS);
}
}
#line 2113 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgUpgradeStage(struct ipmi_intf *intf , struct HpmfwupgUpgradeCtx *pFwupgCtx ,
                                int componentToUpload , int option ) 
{ 
  struct HpmfwupgImageHeader *pImageHeader ;
  struct HpmfwupgActionRecord *pActionRecord ;
  int rc ;
  unsigned char *pImagePtr ;
  unsigned int actionsSize ;
  int flagColdReset ;
  unsigned char tmp ;
  struct HpmfwupgInitiateUpgradeActionCtx initUpgActionCmd ;
  int componentId ;
  struct HpmfwupgInitiateUpgradeActionCtx initUpgActionCmd___0 ;

  {
#line 2116
  pImageHeader = (struct HpmfwupgImageHeader *)pFwupgCtx->pImageData;
#line 2120
  rc = (int )HPMFWUPG_SUCCESS;
#line 2123
  flagColdReset = 0;
#line 2127
  pImagePtr = ((pFwupgCtx->pImageData + sizeof(struct HpmfwupgImageHeader )) + (int )pImageHeader->oemDataLength) + sizeof(unsigned char );
#line 2132
  actionsSize = (unsigned int )((unsigned long )pFwupgCtx->imageSize - sizeof(struct HpmfwupgImageHeader ));
#line 2134
  if (option & 1) {
    {
#line 2136
    HpmDisplayUpgradeHeader();
    }
  } else
#line 2134
  if (option & 24) {
    {
#line 2136
    HpmDisplayUpgradeHeader();
    }
  }
  {
#line 2140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2140
    if ((unsigned long )pImagePtr < (unsigned long )((pFwupgCtx->pImageData + pFwupgCtx->imageSize) - 16)) {
#line 2140
      if (! (rc == (int )HPMFWUPG_SUCCESS)) {
#line 2140
        goto while_break;
      }
    } else {
#line 2140
      goto while_break;
    }
    {
#line 2145
    pActionRecord = (struct HpmfwupgActionRecord *)pImagePtr;
#line 2148
    tmp = HpmfwupgCalculateChecksum((unsigned char *)pActionRecord, (unsigned int )sizeof(struct HpmfwupgActionRecord ));
    }
#line 2148
    if ((int )tmp != 0) {
      {
#line 2151
      lprintf(5, "    Invalid Action record.");
#line 2152
      rc = (int )HPMFWUPG_ERROR;
      }
    }
#line 2155
    if (rc == (int )HPMFWUPG_SUCCESS) {
      {
#line 2159
      if ((int )pActionRecord->actionType == 0) {
#line 2159
        goto case_0;
      }
#line 2172
      if ((int )pActionRecord->actionType == 1) {
#line 2172
        goto case_1;
      }
#line 2212
      if ((int )pActionRecord->actionType == 2) {
#line 2212
        goto case_2;
      }
#line 2226
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 2164
      initUpgActionCmd.req.componentsMask = pFwupgCtx->compUpdateMask;
#line 2166
      initUpgActionCmd.req.upgradeAction = (unsigned char)0;
#line 2167
      rc = HpmfwupgInitiateUpgradeAction(intf, & initUpgActionCmd, pFwupgCtx);
#line 2168
      pImagePtr += sizeof(struct HpmfwupgActionRecord );
      }
#line 2171
      goto switch_break;
      case_1: /* CIL Label */ 
#line 2180
      componentId = 0;
      {
#line 2180
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2180
        if (! (componentId < 8)) {
#line 2180
          goto while_break___0;
        }
#line 2184
        if ((1 << componentId) & (int )pFwupgCtx->compUpdateMask.ComponentBits.byte) {
#line 2186
          if ((int )pFwupgCtx->genCompProp[componentId].GeneralCompProperties.bitfield.preparationSupport == 0) {
            {
#line 2188
            lprintf(5, "    Prepare component not supported by component ID %d", componentId);
#line 2189
            rc = (int )HPMFWUPG_ERROR;
            }
#line 2190
            goto while_break___0;
          }
        }
#line 2180
        componentId ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2195
      if (rc == (int )HPMFWUPG_SUCCESS) {
#line 2197
        if ((int )pFwupgCtx->compUpdateMask.ComponentBits.byte != 0) {
          {
#line 2201
          initUpgActionCmd___0.req.componentsMask = pFwupgCtx->compUpdateMask;
#line 2203
          initUpgActionCmd___0.req.upgradeAction = (unsigned char)1;
#line 2204
          rc = HpmfwupgInitiateUpgradeAction(intf, & initUpgActionCmd___0, pFwupgCtx);
          }
        }
#line 2207
        pImagePtr += sizeof(struct HpmfwupgActionRecord );
      }
#line 2210
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 2214
      rc = HpmFwupgActionUploadFirmware(pActionRecord->components, pFwupgCtx, & pImagePtr,
                                        componentToUpload, intf, option, & flagColdReset);
      }
#line 2225
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 2227
      lprintf(5, "    Invalid Action type. Cannot continue");
#line 2228
      rc = (int )HPMFWUPG_ERROR;
      }
#line 2229
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2234
  HpmDisplayLine((char *)"-", 79);
#line 2236
  fflush(stdout);
#line 2237
  lprintf(5, "(*) Component requires Payload Cold Reset");
  }
#line 2239
  return (rc);
}
}
#line 2242 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmFwupgActionUploadFirmware(struct HpmfwupgComponentBitMask components ,
                                        struct HpmfwupgUpgradeCtx *pFwupgCtx , unsigned char **pImagePtr ,
                                        int componentToUpload , struct ipmi_intf *intf ,
                                        int option , int *pFlagColdReset ) 
{ 
  struct HpmfwupgFirmwareImage *pFwImage ;
  struct HpmfwupgInitiateUpgradeActionCtx initUpgActionCmd ;
  struct HpmfwupgUploadFirmwareBlockCtx uploadCmd ;
  struct HpmfwupgFinishFirmwareUploadCtx finishCmd ;
  VERSIONINFO *pVersionInfo ;
  time_t start ;
  time_t end ;
  int rc ;
  int skip ;
  unsigned char *pData ;
  unsigned char *pDataInitial ;
  unsigned char count ;
  unsigned int totalSent ;
  unsigned char bufLength ;
  unsigned int firmwareLength ;
  unsigned int displayFWLength ;
  unsigned char *pDataTemp ;
  unsigned int imageOffset ;
  unsigned int blockLength ;
  unsigned int lengthOfBlock ;
  unsigned int numTxPkts ;
  unsigned int numRxPkts ;
  unsigned char mode ;
  unsigned char componentId ;
  unsigned char componentIdByte ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 2261
  rc = (int )HPMFWUPG_SUCCESS;
#line 2262
  skip = 1;
#line 2265
  totalSent = 0U;
#line 2266
  bufLength = (unsigned char)0;
#line 2267
  firmwareLength = 0U;
#line 2269
  displayFWLength = 0U;
#line 2271
  imageOffset = 0U;
#line 2272
  blockLength = 0U;
#line 2273
  lengthOfBlock = 0U;
#line 2274
  numTxPkts = 0U;
#line 2275
  numRxPkts = 0U;
#line 2276
  mode = (unsigned char)0;
#line 2277
  componentId = (unsigned char)0;
#line 2278
  componentIdByte = (unsigned char)0;
#line 2281
  componentIdByte = components.ComponentBits.byte;
  {
#line 2282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2282
    componentIdByte = (unsigned char )((int )componentIdByte >> 1);
#line 2282
    if (! ((int )componentIdByte != 0)) {
#line 2282
      goto while_break;
    }
#line 2284
    componentId = (unsigned char )((int )componentId + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 2286
  pFwupgCtx->componentId = componentId;
#line 2288
  pVersionInfo = & gVersionInfo[componentId];
#line 2290
  pFwImage = (struct HpmfwupgFirmwareImage *)(*pImagePtr + sizeof(struct HpmfwupgActionRecord ));
#line 2293
  pDataInitial = (unsigned char *)pFwImage + sizeof(struct HpmfwupgFirmwareImage );
#line 2294
  pData = pDataInitial;
#line 2297
  firmwareLength = (unsigned int )pFwImage->length[0];
#line 2298
  firmwareLength |= (unsigned int )(((int )pFwImage->length[1] << 8) & 65280);
#line 2299
  firmwareLength |= (unsigned int )(((int )pFwImage->length[2] << 16) & 16711680);
#line 2300
  firmwareLength |= (unsigned int )((int )pFwImage->length[3] << 24) & 4278190080U;
#line 2302
  mode = (unsigned char)5;
#line 2304
  if (pVersionInfo->rollbackSupported) {
#line 2306
    mode = (unsigned char )((int )mode | 2);
  }
#line 2309
  if (option & 4) {
    {
#line 2311
    printf((char const   */* __restrict  */)"\n\n Comp ID : %d\t [%-20s]\n", (int )pVersionInfo->componentId,
           pFwImage->desc);
    }
  } else {
    {
#line 2315
    HpmDisplayVersion((int )mode, pVersionInfo, 0);
    }
  }
#line 2318
  if ((1 << (int )componentId) & (int )pFwupgCtx->compUpdateMask.ComponentBits.byte) {
#line 2320
    if (verbose) {
      {
#line 2321
      lprintf(5, "Do not skip %d", (int )componentId);
      }
    }
#line 2323
    skip = 0;
  }
#line 2326
  if (! skip) {
    {
#line 2328
    HpmDisplayUpgrade(0, 0U, 1U, (time_t )0);
#line 2330
    uploadCmd.req.blockNumber = (unsigned char)0;
    }
#line 2333
    if ((int )intf->channel_buf_size != 0) {
#line 2335
      if (intf->target_addr == intf->my_addr) {
#line 2337
        bufLength = (unsigned char )((int )intf->channel_buf_size - 9);
      } else {
#line 2341
        bufLength = (unsigned char )((int )intf->channel_buf_size - 11);
      }
    } else {
      {
#line 2347
      tmp___0 = strstr((char const   *)(intf->name), "lan");
      }
#line 2347
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 2349
        bufLength = (unsigned char)23;
#line 2350
        if (intf->transit_addr != intf->my_addr) {
#line 2350
          if (intf->transit_addr != 0U) {
#line 2351
            bufLength = (unsigned char )((int )bufLength - 8);
          }
        }
      } else {
        {
#line 2355
        tmp = strstr((char const   *)(intf->name), "open");
        }
#line 2355
        if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 2355
          if (intf->target_addr == intf->my_addr) {
#line 2364
            bufLength = (unsigned char)28;
          } else {
#line 2355
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 2368
        if ((int )intf->target_channel == 7) {
#line 2370
          bufLength = (unsigned char)26;
        } else {
#line 2374
          bufLength = (unsigned char)26;
        }
      }
    }
    {
#line 2381
    initUpgActionCmd.req.componentsMask = components;
#line 2383
    initUpgActionCmd.req.upgradeAction = (unsigned char)2;
#line 2384
    rc = HpmfwupgInitiateUpgradeAction(intf, & initUpgActionCmd, pFwupgCtx);
    }
#line 2386
    if (rc != (int )HPMFWUPG_SUCCESS) {
#line 2388
      skip = 1;
    }
#line 2391
    if (pVersionInfo->coldResetRequired) {
#line 2391
      if (! skip) {
#line 2393
        *pFlagColdReset = 1;
      }
    }
    {
#line 2397
    pData = pDataInitial;
#line 2398
    pDataTemp = pDataInitial;
#line 2399
    lengthOfBlock = firmwareLength;
#line 2400
    totalSent = 0U;
#line 2401
    displayFWLength = firmwareLength;
#line 2402
    time(& start);
    }
    {
#line 2405
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2405
      if ((unsigned long )pData < (unsigned long )(pDataTemp + lengthOfBlock)) {
#line 2405
        if (! (rc == (int )HPMFWUPG_SUCCESS)) {
#line 2405
          goto while_break___0;
        }
      } else {
#line 2405
        goto while_break___0;
      }
#line 2407
      if ((unsigned long )(pData + (int )bufLength) <= (unsigned long )(pDataTemp + lengthOfBlock)) {
#line 2409
        count = bufLength;
      } else {
#line 2413
        count = (unsigned char )((pDataTemp + lengthOfBlock) - pData);
      }
      {
#line 2415
      memcpy((void */* __restrict  */)(& uploadCmd.req.data), (void const   */* __restrict  */)pData,
             (size_t )bufLength);
#line 2417
      imageOffset = 0U;
#line 2418
      blockLength = 0U;
#line 2419
      numTxPkts ++;
#line 2420
      rc = HpmfwupgUploadFirmwareBlock(intf, & uploadCmd, pFwupgCtx, (int )count,
                                       & imageOffset, & blockLength);
#line 2422
      numRxPkts ++;
      }
#line 2424
      if (rc != (int )HPMFWUPG_SUCCESS) {
#line 2426
        if (rc == (int )HPMFWUPG_UPLOAD_BLOCK_LENGTH) {
          {
#line 2429
          tmp___1 = strstr((char const   *)(intf->name), "lan");
          }
#line 2429
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
            {
#line 2431
            bufLength = (unsigned char )((int )bufLength - 8);
#line 2432
            lprintf(6, "Trying reduced buffer length: %d", (int )bufLength);
            }
          } else {
            {
#line 2436
            bufLength = (unsigned char )((int )bufLength - 1);
#line 2437
            lprintf(6, "Trying reduced buffer length: %d", (int )bufLength);
            }
          }
#line 2439
          rc = (int )HPMFWUPG_SUCCESS;
        } else
#line 2441
        if (rc == (int )HPMFWUPG_UPLOAD_RETRY) {
#line 2443
          rc = (int )HPMFWUPG_SUCCESS;
        } else {
          {
#line 2447
          fflush(stdout);
#line 2448
          lprintf(5, "\n Error in Upload FIRMWARE command [rc=%d]\n", rc);
#line 2449
          lprintf(5, "\n TotalSent:0x%x ", totalSent);
#line 2451
          rc = (int )HPMFWUPG_ERROR;
          }
        }
      } else {
#line 2456
        if (blockLength > firmwareLength) {
          {
#line 2462
          lprintf(5, "\n Error in Upload FIRMWARE command [rc=%d]\n", rc);
#line 2463
          lprintf(5, "\n TotalSent:0x%x Img offset:0x%x  Blk length:0x%x  Fwlen:0x%x\n",
                  totalSent, imageOffset, blockLength, firmwareLength);
#line 2465
          rc = (int )HPMFWUPG_ERROR;
          }
        }
#line 2467
        totalSent += (unsigned int )count;
#line 2468
        if (imageOffset != 0U) {
#line 2471
          lengthOfBlock = blockLength;
#line 2472
          pDataTemp = pDataInitial + imageOffset;
#line 2473
          pData = pDataTemp;
#line 2474
          if (displayFWLength == firmwareLength) {
#line 2477
            displayFWLength = blockLength + totalSent;
          }
        } else {
#line 2482
          pData += (int )count;
        }
        {
#line 2484
        time(& end);
        }
#line 2489
        if (option & 4) {
          {
#line 2491
          fflush(stdout);
#line 2492
          printf((char const   */* __restrict  */)" Blk Num : %02x        Bytes : %05x ",
                 (int )uploadCmd.req.blockNumber, totalSent);
          }
#line 2494
          if (imageOffset) {
            {
#line 2496
            printf((char const   */* __restrict  */)"\n--> ImgOff : %x BlkLen : %x\n",
                   imageOffset, blockLength);
            }
          } else
#line 2494
          if (blockLength) {
            {
#line 2496
            printf((char const   */* __restrict  */)"\n--> ImgOff : %x BlkLen : %x\n",
                   imageOffset, blockLength);
            }
          }
#line 2498
          if (displayFWLength == totalSent) {
            {
#line 2500
            printf((char const   */* __restrict  */)"\n Time Taken %02ld:%02ld", (end - start) / 60L,
                   (end - start) % 60L);
#line 2501
            printf((char const   */* __restrict  */)"\n\n");
            }
          }
        } else {
          {
#line 2506
          HpmDisplayUpgrade(0, totalSent, displayFWLength, end - start);
          }
        }
#line 2508
        uploadCmd.req.blockNumber = (unsigned char )((int )uploadCmd.req.blockNumber + 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2513
  if (skip) {
    {
#line 2516
    HpmDisplayUpgrade(1, 0U, 0U, (time_t )0);
#line 2517
    *pImagePtr = pDataInitial + firmwareLength;
    }
  }
#line 2520
  if (rc == (int )HPMFWUPG_SUCCESS) {
#line 2520
    if (! skip) {
      {
#line 2529
      finishCmd.req.componentId = componentId;
#line 2533
      finishCmd.req.imageLength[0] = (unsigned char )(totalSent & 255U);
#line 2534
      finishCmd.req.imageLength[1] = (unsigned char )((totalSent >> 8) & 255U);
#line 2535
      finishCmd.req.imageLength[2] = (unsigned char )((totalSent >> 16) & 255U);
#line 2536
      finishCmd.req.imageLength[3] = (unsigned char )((totalSent >> 24) & 255U);
#line 2537
      rc = HpmfwupgFinishFirmwareUpload(intf, & finishCmd, pFwupgCtx);
#line 2538
      *pImagePtr = pDataInitial + firmwareLength;
      }
    }
  }
#line 2541
  return (rc);
}
}
#line 2553 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgActivationStage(struct ipmi_intf *intf , struct HpmfwupgUpgradeCtx *pFwupgCtx ) 
{ 
  int rc ;
  struct HpmfwupgActivateFirmwareCtx activateCmd ;
  struct HpmfwupgImageHeader *pImageHeader ;
  struct HpmfwupgQuerySelftestResultCtx selfTestCmd ;
  struct HpmfwupgQueryRollbackStatusCtx rollCmd ;

  {
  {
#line 2555
  rc = (int )HPMFWUPG_SUCCESS;
#line 2557
  pImageHeader = (struct HpmfwupgImageHeader *)pFwupgCtx->pImageData;
#line 2561
  printf((char const   */* __restrict  */)"    ");
#line 2562
  fflush(stdout);
#line 2564
  rc = HpmfwupgActivateFirmware(intf, & activateCmd, pFwupgCtx);
  }
#line 2566
  if (rc == (int )HPMFWUPG_SUCCESS) {
#line 2569
    if ((int )pFwupgCtx->targetCap.GlobalCapabilities.bitField.ipmcSelftestCap == 1) {
#line 2569
      goto _L;
    } else
#line 2569
    if ((int )pImageHeader->imageCapabilities.bitField.imageSelfTest == 1) {
      _L: /* CIL Label */ 
      {
#line 2573
      rc = HpmfwupgQuerySelftestResult(intf, & selfTestCmd, pFwupgCtx);
      }
#line 2575
      if (rc == (int )HPMFWUPG_SUCCESS) {
#line 2578
        if ((int )selfTestCmd.resp.result1 != 85) {
          {
#line 2582
          lprintf(5, "    Self test failed:");
#line 2583
          lprintf(5, "    Result1 = %x", (int )selfTestCmd.resp.result1);
#line 2584
          lprintf(5, "    Result2 = %x", (int )selfTestCmd.resp.result2);
#line 2585
          rc = (int )HPMFWUPG_ERROR;
          }
        }
      } else {
        {
#line 2592
        lprintf(5, "    Self test failed.");
        }
      }
    }
  }
#line 2598
  if (rc == (int )HPMFWUPG_ERROR) {
#line 2600
    if ((int )pFwupgCtx->targetCap.GlobalCapabilities.bitField.autRollback == 1) {
#line 2600
      if ((int )pFwupgCtx->genCompProp[pFwupgCtx->componentId].GeneralCompProperties.bitfield.rollbackBackup != 0) {
        {
#line 2604
        lprintf(5, "    Getting rollback status...");
#line 2605
        fflush(stdout);
#line 2606
        rc = HpmfwupgQueryRollbackStatus(intf, & rollCmd, pFwupgCtx);
        }
      }
    }
  }
#line 2610
  return (rc);
}
}
#line 2613 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgGetBufferFromFile(char *imageFilename , struct HpmfwupgUpgradeCtx *pFwupgCtx ) 
{ 
  int rc ;
  int ret ;
  FILE *pImageFile ;
  FILE *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 2615
  rc = (int )HPMFWUPG_SUCCESS;
#line 2616
  ret = 0;
#line 2617
  tmp = fopen((char const   */* __restrict  */)imageFilename, (char const   */* __restrict  */)"rb");
#line 2617
  pImageFile = tmp;
  }
#line 2619
  if ((unsigned long )pImageFile == (unsigned long )((void *)0)) {
    {
#line 2621
    lprintf(5, "Cannot open image file %s", imageFilename);
#line 2622
    rc = (int )HPMFWUPG_ERROR;
    }
  }
#line 2625
  if (rc == (int )HPMFWUPG_SUCCESS) {
    {
#line 2628
    fseek(pImageFile, 0L, 2);
#line 2629
    tmp___0 = ftell(pImageFile);
#line 2629
    pFwupgCtx->imageSize = (unsigned int )tmp___0;
#line 2630
    tmp___1 = malloc(sizeof(unsigned char ) * (unsigned long )pFwupgCtx->imageSize);
#line 2630
    pFwupgCtx->pImageData = (unsigned char *)tmp___1;
#line 2631
    pFwupgCtx->compUpdateMask.ComponentBits.byte = (unsigned char)0;
#line 2632
    rewind(pImageFile);
    }
#line 2633
    if ((unsigned long )pFwupgCtx->pImageData != (unsigned long )((void *)0)) {
      {
#line 2635
      tmp___2 = fread((void */* __restrict  */)pFwupgCtx->pImageData, sizeof(unsigned char ),
                      (size_t )pFwupgCtx->imageSize, (FILE */* __restrict  */)pImageFile);
#line 2635
      ret = (int )tmp___2;
      }
#line 2637
      if ((unsigned int )ret != pFwupgCtx->imageSize) {
        {
#line 2638
        lprintf(3, "Failed to read file %s size %d", imageFilename, pFwupgCtx->imageSize);
#line 2640
        rc = (int )HPMFWUPG_ERROR;
        }
      }
    } else {
#line 2645
      rc = (int )HPMFWUPG_ERROR;
    }
    {
#line 2648
    fclose(pImageFile);
    }
  }
#line 2651
  return (rc);
}
}
#line 2654 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgGetDeviceId(struct ipmi_intf *intf , struct ipm_devid_rsp *pGetDevId ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;

  {
  {
#line 2656
  rc = (int )HPMFWUPG_SUCCESS;
#line 2660
  memset((void *)(& req), 0, sizeof(req));
#line 2661
  req.msg.netfn = (uint8_t )6;
#line 2662
  req.msg.cmd = (uint8_t )1;
#line 2663
  req.msg.data_len = (uint16_t )0;
#line 2665
  rsp = HpmfwupgSendCmd(intf, req, (struct HpmfwupgUpgradeCtx *)((void *)0));
  }
#line 2667
  if (rsp) {
#line 2669
    if ((int )rsp->ccode == 0) {
      {
#line 2671
      memcpy((void */* __restrict  */)pGetDevId, (void const   */* __restrict  */)(rsp->data),
             sizeof(struct ipm_devid_rsp ));
      }
    } else {
      {
#line 2675
      lprintf(5, "Error getting device ID");
#line 2676
      tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2676
      lprintf(5, "compcode=0x%x: %s", (int )rsp->ccode, tmp);
#line 2679
      rc = (int )HPMFWUPG_ERROR;
      }
    }
  } else {
    {
#line 2684
    lprintf(5, "Error getting device ID\n");
#line 2685
    rc = (int )HPMFWUPG_ERROR;
    }
  }
#line 2687
  return (rc);
}
}
#line 2690 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgGetTargetUpgCapabilities(struct ipmi_intf *intf , struct HpmfwupgGetTargetUpgCapabilitiesCtx *pCtx ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 2693
  rc = (int )HPMFWUPG_SUCCESS;
#line 2697
  pCtx->req.picmgId = (unsigned char)0;
#line 2699
  memset((void *)(& req), 0, sizeof(req));
#line 2700
  req.msg.netfn = (uint8_t )44;
#line 2701
  req.msg.cmd = (uint8_t )46;
#line 2702
  req.msg.data = (unsigned char *)(& pCtx->req);
#line 2703
  req.msg.data_len = (uint16_t )sizeof(struct HpmfwupgGetTargetUpgCapabilitiesReq );
#line 2705
  rsp = HpmfwupgSendCmd(intf, req, (struct HpmfwupgUpgradeCtx *)((void *)0));
  }
#line 2707
  if (rsp) {
#line 2709
    if ((int )rsp->ccode == 0) {
      {
#line 2711
      memcpy((void */* __restrict  */)(& pCtx->resp), (void const   */* __restrict  */)(rsp->data),
             sizeof(struct HpmfwupgGetTargetUpgCapabilitiesResp ));
      }
#line 2712
      if (verbose) {
        {
#line 2714
        lprintf(5, "TARGET UPGRADE CAPABILITIES");
#line 2715
        lprintf(5, "-------------------------------");
#line 2716
        lprintf(5, "HPM.1 version............%d    ", (int )pCtx->resp.hpmVersion);
        }
#line 2717
        if (pCtx->resp.componentsPresent.ComponentBits.bitField.component0) {
#line 2717
          tmp = 'y';
        } else {
#line 2717
          tmp = 'n';
        }
        {
#line 2717
        lprintf(5, "Component 0 presence....[%c]   ", tmp);
        }
#line 2719
        if (pCtx->resp.componentsPresent.ComponentBits.bitField.component1) {
#line 2719
          tmp___0 = 'y';
        } else {
#line 2719
          tmp___0 = 'n';
        }
        {
#line 2719
        lprintf(5, "Component 1 presence....[%c]   ", tmp___0);
        }
#line 2721
        if (pCtx->resp.componentsPresent.ComponentBits.bitField.component2) {
#line 2721
          tmp___1 = 'y';
        } else {
#line 2721
          tmp___1 = 'n';
        }
        {
#line 2721
        lprintf(5, "Component 2 presence....[%c]   ", tmp___1);
        }
#line 2723
        if (pCtx->resp.componentsPresent.ComponentBits.bitField.component3) {
#line 2723
          tmp___2 = 'y';
        } else {
#line 2723
          tmp___2 = 'n';
        }
        {
#line 2723
        lprintf(5, "Component 3 presence....[%c]   ", tmp___2);
        }
#line 2725
        if (pCtx->resp.componentsPresent.ComponentBits.bitField.component4) {
#line 2725
          tmp___3 = 'y';
        } else {
#line 2725
          tmp___3 = 'n';
        }
        {
#line 2725
        lprintf(5, "Component 4 presence....[%c]   ", tmp___3);
        }
#line 2727
        if (pCtx->resp.componentsPresent.ComponentBits.bitField.component5) {
#line 2727
          tmp___4 = 'y';
        } else {
#line 2727
          tmp___4 = 'n';
        }
        {
#line 2727
        lprintf(5, "Component 5 presence....[%c]   ", tmp___4);
        }
#line 2729
        if (pCtx->resp.componentsPresent.ComponentBits.bitField.component6) {
#line 2729
          tmp___5 = 'y';
        } else {
#line 2729
          tmp___5 = 'n';
        }
        {
#line 2729
        lprintf(5, "Component 6 presence....[%c]   ", tmp___5);
        }
#line 2731
        if (pCtx->resp.componentsPresent.ComponentBits.bitField.component7) {
#line 2731
          tmp___6 = 'y';
        } else {
#line 2731
          tmp___6 = 'n';
        }
        {
#line 2731
        lprintf(5, "Component 7 presence....[%c]   ", tmp___6);
        }
#line 2733
        if (pCtx->resp.GlobalCapabilities.bitField.fwUpgUndesirable) {
#line 2733
          tmp___7 = 'y';
        } else {
#line 2733
          tmp___7 = 'n';
        }
        {
#line 2733
        lprintf(5, "Upgrade undesirable.....[%c]   ", tmp___7);
        }
#line 2735
        if (pCtx->resp.GlobalCapabilities.bitField.autRollbackOverride) {
#line 2735
          tmp___8 = 'y';
        } else {
#line 2735
          tmp___8 = 'n';
        }
        {
#line 2735
        lprintf(5, "Aut rollback override...[%c]   ", tmp___8);
        }
#line 2737
        if (pCtx->resp.GlobalCapabilities.bitField.ipmcDegradedDurinUpg) {
#line 2737
          tmp___9 = 'y';
        } else {
#line 2737
          tmp___9 = 'n';
        }
        {
#line 2737
        lprintf(5, "IPMC degraded...........[%c]   ", tmp___9);
        }
#line 2739
        if (pCtx->resp.GlobalCapabilities.bitField.deferActivation) {
#line 2739
          tmp___10 = 'y';
        } else {
#line 2739
          tmp___10 = 'n';
        }
        {
#line 2739
        lprintf(5, "Defered activation......[%c]   ", tmp___10);
        }
#line 2741
        if (pCtx->resp.GlobalCapabilities.bitField.servAffectDuringUpg) {
#line 2741
          tmp___11 = 'y';
        } else {
#line 2741
          tmp___11 = 'n';
        }
        {
#line 2741
        lprintf(5, "Service affected........[%c]   ", tmp___11);
        }
#line 2743
        if (pCtx->resp.GlobalCapabilities.bitField.manualRollback) {
#line 2743
          tmp___12 = 'y';
        } else {
#line 2743
          tmp___12 = 'n';
        }
        {
#line 2743
        lprintf(5, "Manual rollback.........[%c]   ", tmp___12);
        }
#line 2745
        if (pCtx->resp.GlobalCapabilities.bitField.autRollback) {
#line 2745
          tmp___13 = 'y';
        } else {
#line 2745
          tmp___13 = 'n';
        }
        {
#line 2745
        lprintf(5, "Automatic rollback......[%c]   ", tmp___13);
        }
#line 2747
        if (pCtx->resp.GlobalCapabilities.bitField.ipmcSelftestCap) {
#line 2747
          tmp___14 = 'y';
        } else {
#line 2747
          tmp___14 = 'n';
        }
        {
#line 2747
        lprintf(5, "Self test...............[%c]   ", tmp___14);
#line 2749
        lprintf(5, "Upgrade timeout.........[%d sec] ", (int )pCtx->resp.upgradeTimeout * 5);
#line 2750
        lprintf(5, "Self test timeout.......[%d sec] ", (int )pCtx->resp.selftestTimeout * 5);
#line 2751
        lprintf(5, "Rollback timeout........[%d sec] ", (int )pCtx->resp.rollbackTimeout * 5);
#line 2752
        lprintf(5, "Inaccessibility timeout.[%d sec] \n", (int )pCtx->resp.inaccessTimeout * 5);
        }
      }
    } else {
      {
#line 2757
      lprintf(5, "Error getting target upgrade capabilities\n", (int )rsp->ccode);
#line 2758
      rc = (int )HPMFWUPG_ERROR;
      }
    }
  } else {
    {
#line 2763
    lprintf(5, "Error getting target upgrade capabilities\n");
#line 2764
    rc = (int )HPMFWUPG_ERROR;
    }
  }
#line 2769
  return (rc);
}
}
#line 2773 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgGetComponentProperties(struct ipmi_intf *intf , struct HpmfwupgGetComponentPropertiesCtx *pCtx ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned char i ;
  char const   *tmp___4 ;

  {
  {
#line 2775
  rc = (int )HPMFWUPG_SUCCESS;
#line 2779
  pCtx->req.picmgId = (unsigned char)0;
#line 2781
  memset((void *)(& req), 0, sizeof(req));
#line 2782
  req.msg.netfn = (uint8_t )44;
#line 2783
  req.msg.cmd = (uint8_t )47;
#line 2784
  req.msg.data = (unsigned char *)(& pCtx->req);
#line 2785
  req.msg.data_len = (uint16_t )sizeof(struct HpmfwupgGetComponentPropertiesReq );
#line 2787
  rsp = HpmfwupgSendCmd(intf, req, (struct HpmfwupgUpgradeCtx *)((void *)0));
  }
#line 2789
  if (rsp) {
#line 2791
    if ((int )rsp->ccode == 0) {
      {
#line 2795
      if ((int )pCtx->req.selector == 0) {
#line 2795
        goto case_0;
      }
#line 2813
      if ((int )pCtx->req.selector == 1) {
#line 2813
        goto case_1;
      }
#line 2826
      if ((int )pCtx->req.selector == 2) {
#line 2826
        goto case_2;
      }
#line 2833
      if ((int )pCtx->req.selector == 3) {
#line 2833
        goto case_3;
      }
#line 2846
      if ((int )pCtx->req.selector == 4) {
#line 2846
        goto case_4;
      }
#line 2860
      if ((int )pCtx->req.selector == 192) {
#line 2860
        goto case_192;
      }
#line 2872
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 2796
      memcpy((void */* __restrict  */)(& pCtx->resp), (void const   */* __restrict  */)(rsp->data),
             sizeof(struct HpmfwupgGetGeneralPropResp ));
      }
#line 2797
      if (verbose) {
        {
#line 2799
        lprintf(5, "GENERAL PROPERTIES");
#line 2800
        lprintf(5, "-------------------------------");
        }
#line 2801
        if (pCtx->resp.Response.generalPropResp.GeneralCompProperties.bitfield.payloadColdReset) {
#line 2801
          tmp = 'y';
        } else {
#line 2801
          tmp = 'n';
        }
        {
#line 2801
        lprintf(5, "Payload cold reset req....[%c]   ", tmp);
        }
#line 2803
        if (pCtx->resp.Response.generalPropResp.GeneralCompProperties.bitfield.deferredActivation) {
#line 2803
          tmp___0 = 'y';
        } else {
#line 2803
          tmp___0 = 'n';
        }
        {
#line 2803
        lprintf(5, "Def. activation supported.[%c]   ", tmp___0);
        }
#line 2805
        if (pCtx->resp.Response.generalPropResp.GeneralCompProperties.bitfield.comparisonSupport) {
#line 2805
          tmp___1 = 'y';
        } else {
#line 2805
          tmp___1 = 'n';
        }
        {
#line 2805
        lprintf(5, "Comparison supported......[%c]   ", tmp___1);
        }
#line 2807
        if (pCtx->resp.Response.generalPropResp.GeneralCompProperties.bitfield.preparationSupport) {
#line 2807
          tmp___2 = 'y';
        } else {
#line 2807
          tmp___2 = 'n';
        }
        {
#line 2807
        lprintf(5, "Preparation supported.....[%c]   ", tmp___2);
        }
#line 2809
        if (pCtx->resp.Response.generalPropResp.GeneralCompProperties.bitfield.rollbackBackup) {
#line 2809
          tmp___3 = 'y';
        } else {
#line 2809
          tmp___3 = 'n';
        }
        {
#line 2809
        lprintf(5, "Rollback supported........[%c]   \n", tmp___3);
        }
      }
#line 2812
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 2814
      memcpy((void */* __restrict  */)(& pCtx->resp), (void const   */* __restrict  */)(rsp->data),
             sizeof(struct HpmfwupgGetCurrentVersionResp ));
      }
#line 2815
      if (verbose) {
        {
#line 2817
        lprintf(5, "Current Version: ");
#line 2818
        lprintf(5, " Major: %d", (int )pCtx->resp.Response.currentVersionResp.currentVersion[0]);
#line 2819
        lprintf(5, " Minor: %x", (int )pCtx->resp.Response.currentVersionResp.currentVersion[1]);
#line 2820
        lprintf(5, " Aux  : %03d %03d %03d %03d\n", (int )pCtx->resp.Response.currentVersionResp.currentVersion[2],
                (int )pCtx->resp.Response.currentVersionResp.currentVersion[3], (int )pCtx->resp.Response.currentVersionResp.currentVersion[4],
                (int )pCtx->resp.Response.currentVersionResp.currentVersion[5]);
        }
      }
#line 2825
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 2827
      memcpy((void */* __restrict  */)(& pCtx->resp), (void const   */* __restrict  */)(rsp->data),
             sizeof(struct HpmfwupgGetDescStringResp ));
      }
#line 2828
      if (verbose) {
        {
#line 2830
        lprintf(5, "Description string: %s\n", pCtx->resp.Response.descStringResp.descString);
        }
      }
#line 2832
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 2834
      memcpy((void */* __restrict  */)(& pCtx->resp), (void const   */* __restrict  */)(rsp->data),
             sizeof(struct HpmfwupgGetRollbackFwVersionResp ));
      }
#line 2835
      if (verbose) {
        {
#line 2837
        lprintf(5, "Rollback FW Version: ");
#line 2838
        lprintf(5, " Major: %d", (int )pCtx->resp.Response.rollbackFwVersionResp.rollbackFwVersion[0]);
#line 2839
        lprintf(5, " Minor: %x", (int )pCtx->resp.Response.rollbackFwVersionResp.rollbackFwVersion[1]);
#line 2840
        lprintf(5, " Aux  : %03d %03d %03d %03d\n", (int )pCtx->resp.Response.rollbackFwVersionResp.rollbackFwVersion[2],
                (int )pCtx->resp.Response.rollbackFwVersionResp.rollbackFwVersion[3],
                (int )pCtx->resp.Response.rollbackFwVersionResp.rollbackFwVersion[4],
                (int )pCtx->resp.Response.rollbackFwVersionResp.rollbackFwVersion[5]);
        }
      }
#line 2845
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 2847
      memcpy((void */* __restrict  */)(& pCtx->resp), (void const   */* __restrict  */)(rsp->data),
             sizeof(struct HpmfwupgGetDeferredFwVersionResp ));
      }
#line 2848
      if (verbose) {
        {
#line 2850
        lprintf(5, "Deferred FW Version: ");
#line 2851
        lprintf(5, " Major: %d", (int )pCtx->resp.Response.deferredFwVersionResp.deferredFwVersion[0]);
#line 2852
        lprintf(5, " Minor: %x", (int )pCtx->resp.Response.deferredFwVersionResp.deferredFwVersion[1]);
#line 2853
        lprintf(5, " Aux  : %03d %03d %03d %03d\n", (int )pCtx->resp.Response.deferredFwVersionResp.deferredFwVersion[2],
                (int )pCtx->resp.Response.deferredFwVersionResp.deferredFwVersion[3],
                (int )pCtx->resp.Response.deferredFwVersionResp.deferredFwVersion[4],
                (int )pCtx->resp.Response.deferredFwVersionResp.deferredFwVersion[5]);
        }
      }
#line 2858
      goto switch_break;
      case_192: /* CIL Label */ 
      {
#line 2861
      memcpy((void */* __restrict  */)(& pCtx->resp), (void const   */* __restrict  */)(rsp->data),
             sizeof(struct HpmfwupgGetOemProperties ));
      }
#line 2862
      if (verbose) {
        {
#line 2864
        i = (unsigned char)0;
#line 2865
        lprintf(5, "OEM Properties: ");
#line 2866
        i = (unsigned char)0;
        }
        {
#line 2866
        while (1) {
          while_continue: /* CIL Label */ ;
#line 2866
          if (! ((int )i < 4)) {
#line 2866
            goto while_break;
          }
          {
#line 2868
          lprintf(5, " 0x%x ", (int )pCtx->resp.Response.oemProperties.oemRspData[i]);
#line 2866
          i = (unsigned char )((int )i + 1);
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 2871
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 2873
      lprintf(5, "Unsupported component selector");
#line 2874
      rc = (int )HPMFWUPG_ERROR;
      }
#line 2875
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 2880
      lprintf(5, "Error getting component properties");
#line 2881
      tmp___4 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2881
      lprintf(5, "compcode=0x%x: %s", (int )rsp->ccode, tmp___4);
#line 2884
      rc = (int )HPMFWUPG_ERROR;
      }
    }
  } else {
    {
#line 2889
    lprintf(5, "Error getting component properties\n");
#line 2890
    rc = (int )HPMFWUPG_ERROR;
    }
  }
#line 2894
  return (rc);
}
}
#line 2897 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgAbortUpgrade(struct ipmi_intf *intf , struct HpmfwupgAbortUpgradeCtx *pCtx ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;

  {
  {
#line 2899
  rc = (int )HPMFWUPG_SUCCESS;
#line 2903
  pCtx->req.picmgId = (unsigned char)0;
#line 2905
  memset((void *)(& req), 0, sizeof(req));
#line 2906
  req.msg.netfn = (uint8_t )44;
#line 2907
  req.msg.cmd = (uint8_t )48;
#line 2908
  req.msg.data = (unsigned char *)(& pCtx->req);
#line 2909
  req.msg.data_len = (uint16_t )sizeof(struct HpmfwupgAbortUpgradeReq );
#line 2911
  rsp = HpmfwupgSendCmd(intf, req, (struct HpmfwupgUpgradeCtx *)((void *)0));
  }
#line 2913
  if (rsp) {
#line 2915
    if ((int )rsp->ccode != 0) {
      {
#line 2917
      lprintf(5, "Error aborting upgrade");
#line 2918
      tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2918
      lprintf(5, "compcode=0x%x: %s", (int )rsp->ccode, tmp);
#line 2921
      rc = (int )HPMFWUPG_ERROR;
      }
    }
  } else {
    {
#line 2926
    lprintf(5, "Error aborting upgrade\n");
#line 2927
    rc = (int )HPMFWUPG_ERROR;
    }
  }
#line 2929
  return (rc);
}
}
#line 2932 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgInitiateUpgradeAction(struct ipmi_intf *intf , struct HpmfwupgInitiateUpgradeActionCtx *pCtx ,
                                         struct HpmfwupgUpgradeCtx *pFwupgCtx ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;

  {
  {
#line 2935
  rc = (int )HPMFWUPG_SUCCESS;
#line 2939
  pCtx->req.picmgId = (unsigned char)0;
#line 2941
  memset((void *)(& req), 0, sizeof(req));
#line 2942
  req.msg.netfn = (uint8_t )44;
#line 2943
  req.msg.cmd = (uint8_t )49;
#line 2944
  req.msg.data = (unsigned char *)(& pCtx->req);
#line 2945
  req.msg.data_len = (uint16_t )sizeof(struct HpmfwupgInitiateUpgradeActionReq );
#line 2947
  rsp = HpmfwupgSendCmd(intf, req, pFwupgCtx);
  }
#line 2949
  if (rsp) {
#line 2952
    if ((int )rsp->ccode == 128) {
      {
#line 2954
      rc = HpmfwupgWaitLongDurationCmd(intf, pFwupgCtx);
      }
    } else
#line 2956
    if ((int )rsp->ccode != 0) {
      {
#line 2958
      lprintf(5, "Error initiating upgrade action");
#line 2959
      tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2959
      lprintf(5, "compcode=0x%x: %s", (int )rsp->ccode, tmp);
#line 2962
      rc = (int )HPMFWUPG_ERROR;
      }
    }
  } else {
    {
#line 2967
    lprintf(5, "Error initiating upgrade action\n");
#line 2968
    rc = (int )HPMFWUPG_ERROR;
    }
  }
#line 2971
  return (rc);
}
}
#line 2974 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgUploadFirmwareBlock(struct ipmi_intf *intf , struct HpmfwupgUploadFirmwareBlockCtx *pCtx ,
                                       struct HpmfwupgUpgradeCtx *pFwupgCtx , int count ,
                                       unsigned int *imageOffset , unsigned int *blockLength ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2978
  rc = (int )HPMFWUPG_SUCCESS;
#line 2982
  pCtx->req.picmgId = (unsigned char)0;
#line 2984
  memset((void *)(& req), 0, sizeof(req));
#line 2985
  req.msg.netfn = (uint8_t )44;
#line 2986
  req.msg.cmd = (uint8_t )50;
#line 2987
  req.msg.data = (unsigned char *)(& pCtx->req);
#line 2989
  req.msg.data_len = (uint16_t )(2 + count);
#line 2991
  rsp = HpmfwupgSendCmd(intf, req, pFwupgCtx);
  }
#line 2993
  if (rsp) {
#line 2995
    if ((int )rsp->ccode == 128) {
#line 2995
      goto _L;
    } else
#line 2995
    if ((int )rsp->ccode == 0) {
      _L: /* CIL Label */ 
#line 3002
      if (rsp->data_len > 1) {
#line 3009
        if (rsp->data_len == 9) {
#line 3012
          *imageOffset = (unsigned int )(((((int )rsp->data[4] << 24) + ((int )rsp->data[3] << 16)) + ((int )rsp->data[2] << 8)) + (int )rsp->data[1]);
#line 3013
          *blockLength = (unsigned int )(((((int )rsp->data[8] << 24) + ((int )rsp->data[7] << 16)) + ((int )rsp->data[6] << 8)) + (int )rsp->data[5]);
        } else {
          {
#line 3022
          lprintf(5, "Error wrong rsp->datalen %d for Upload Firmware block command\n",
                  rsp->data_len);
#line 3023
          rsp->ccode = (uint8_t )130;
          }
        }
      }
    }
#line 3028
    if ((int )rsp->ccode == 128) {
      {
#line 3030
      rc = HpmfwupgWaitLongDurationCmd(intf, pFwupgCtx);
      }
    } else
#line 3032
    if ((int )rsp->ccode != 0) {
#line 3039
      if ((int )rsp->ccode == 131) {
#line 3039
        goto _L___0;
      } else
#line 3039
      if ((int )rsp->ccode == 130) {
#line 3039
        goto _L___0;
      } else
#line 3039
      if ((int )rsp->ccode == 128) {
        _L___0: /* CIL Label */ 
#line 3039
        tmp___2 = errorCount;
#line 3039
        errorCount ++;
#line 3039
        if (tmp___2 < 3) {
#line 3039
          tmp___1 = 1;
        } else {
#line 3039
          tmp___1 = 0;
        }
      } else {
#line 3039
        tmp___1 = 0;
      }
#line 3039
      if (tmp___1) {
        {
#line 3041
        lprintf(7, "HPM: [PATCH]Retryable error detected");
#line 3042
        rc = (int )HPMFWUPG_UPLOAD_RETRY;
        }
      } else
#line 3048
      if ((int )rsp->ccode == 199) {
#line 3050
        rc = (int )HPMFWUPG_UPLOAD_BLOCK_LENGTH;
      } else {
        {
#line 3054
        lprintf(5, "Error uploading firmware block");
#line 3055
        tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3055
        lprintf(5, "compcode=0x%x: %s", (int )rsp->ccode, tmp);
#line 3058
        rc = (int )HPMFWUPG_ERROR;
        }
      }
    }
  } else {
    {
#line 3064
    lprintf(5, "Error uploading firmware block\n");
#line 3065
    rc = (int )HPMFWUPG_ERROR;
    }
  }
#line 3068
  return (rc);
}
}
#line 3071 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgFinishFirmwareUpload(struct ipmi_intf *intf , struct HpmfwupgFinishFirmwareUploadCtx *pCtx ,
                                        struct HpmfwupgUpgradeCtx *pFwupgCtx ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;

  {
  {
#line 3074
  rc = (int )HPMFWUPG_SUCCESS;
#line 3078
  pCtx->req.picmgId = (unsigned char)0;
#line 3080
  memset((void *)(& req), 0, sizeof(req));
#line 3081
  req.msg.netfn = (uint8_t )44;
#line 3082
  req.msg.cmd = (uint8_t )51;
#line 3083
  req.msg.data = (unsigned char *)(& pCtx->req);
#line 3084
  req.msg.data_len = (uint16_t )sizeof(struct HpmfwupgFinishFirmwareUploadReq );
#line 3086
  rsp = HpmfwupgSendCmd(intf, req, pFwupgCtx);
  }
#line 3088
  if (rsp) {
#line 3091
    if ((int )rsp->ccode == 128) {
      {
#line 3093
      rc = HpmfwupgWaitLongDurationCmd(intf, pFwupgCtx);
      }
    } else
#line 3095
    if ((int )rsp->ccode != 0) {
      {
#line 3097
      lprintf(5, "Error finishing firmware upload");
#line 3098
      tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3098
      lprintf(5, "compcode=0x%x: %s", (int )rsp->ccode, tmp);
#line 3101
      rc = (int )HPMFWUPG_ERROR;
      }
    }
  } else {
    {
#line 3106
    lprintf(5, "Error fininshing firmware upload\n");
#line 3107
    rc = (int )HPMFWUPG_ERROR;
    }
  }
#line 3110
  return (rc);
}
}
#line 3113 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgActivateFirmware(struct ipmi_intf *intf , struct HpmfwupgActivateFirmwareCtx *pCtx ,
                                    struct HpmfwupgUpgradeCtx *pFwupgCtx ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 3116
  rc = (int )HPMFWUPG_SUCCESS;
#line 3120
  pCtx->req.picmgId = (unsigned char)0;
#line 3122
  memset((void *)(& req), 0, sizeof(req));
#line 3123
  req.msg.netfn = (uint8_t )44;
#line 3124
  req.msg.cmd = (uint8_t )53;
#line 3125
  req.msg.data = (unsigned char *)(& pCtx->req);
  }
#line 3126
  if (! pCtx->req.rollback_override) {
#line 3126
    tmp = 1;
  } else {
#line 3126
    tmp = 0;
  }
  {
#line 3126
  req.msg.data_len = (uint16_t )(sizeof(struct HpmfwupgActivateFirmwareReq ) - (unsigned long )tmp);
#line 3129
  rsp = HpmfwupgSendCmd(intf, req, pFwupgCtx);
  }
#line 3131
  if (rsp) {
#line 3134
    if ((int )rsp->ccode == 128) {
      {
#line 3136
      printf((char const   */* __restrict  */)"Waiting firmware activation...");
#line 3137
      fflush(stdout);
#line 3139
      rc = HpmfwupgWaitLongDurationCmd(intf, pFwupgCtx);
      }
#line 3141
      if (rc == (int )HPMFWUPG_SUCCESS) {
        {
#line 3143
        lprintf(5, "OK");
        }
      } else {
        {
#line 3147
        lprintf(5, "Failed");
        }
      }
    } else
#line 3150
    if ((int )rsp->ccode != 0) {
      {
#line 3152
      lprintf(5, "Error activating firmware");
#line 3153
      tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3153
      lprintf(5, "compcode=0x%x: %s", (int )rsp->ccode, tmp___0);
#line 3156
      rc = (int )HPMFWUPG_ERROR;
      }
    }
  } else {
    {
#line 3161
    lprintf(5, "Error activating firmware\n");
#line 3162
    rc = (int )HPMFWUPG_ERROR;
    }
  }
#line 3165
  return (rc);
}
}
#line 3168 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgGetUpgradeStatus(struct ipmi_intf *intf , struct HpmfwupgGetUpgradeStatusCtx *pCtx ,
                                    struct HpmfwupgUpgradeCtx *pFwupgCtx , int silent ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 3173
  rc = (int )HPMFWUPG_SUCCESS;
#line 3177
  pCtx->req.picmgId = (unsigned char)0;
#line 3179
  memset((void *)(& req), 0, sizeof(req));
#line 3180
  req.msg.netfn = (uint8_t )44;
#line 3181
  req.msg.cmd = (uint8_t )52;
#line 3182
  req.msg.data = (unsigned char *)(& pCtx->req);
#line 3183
  req.msg.data_len = (uint16_t )sizeof(struct HpmfwupgGetUpgradeStatusReq );
#line 3185
  rsp = HpmfwupgSendCmd(intf, req, pFwupgCtx);
  }
#line 3186
  if (! rsp) {
    {
#line 3187
    lprintf(5, "Error getting upgrade status. Failed to get response.");
    }
#line 3189
    return ((int )HPMFWUPG_ERROR);
  }
#line 3192
  if ((int )rsp->ccode == 0) {
    {
#line 3193
    memcpy((void */* __restrict  */)(& pCtx->resp), (void const   */* __restrict  */)(rsp->data),
           sizeof(struct HpmfwupgGetUpgradeStatusResp ));
    }
#line 3195
    if (! silent) {
      {
#line 3197
      lprintf(5, "Upgrade status:");
#line 3198
      lprintf(5, " Command in progress:          %x", (int )pCtx->resp.cmdInProcess);
#line 3200
      lprintf(5, " Last command completion code: %x", (int )pCtx->resp.lastCmdCompCode);
      }
    }
  } else {
#line 3203
    if ((int )rsp->ccode == 131) {
#line 3203
      goto _L;
    } else
#line 3203
    if ((int )rsp->ccode == 130) {
#line 3203
      goto _L;
    } else
#line 3203
    if ((int )rsp->ccode == 128) {
      _L: /* CIL Label */ 
#line 3203
      tmp___2 = errorCount;
#line 3203
      errorCount ++;
#line 3203
      if (tmp___2 < 3) {
#line 3203
        tmp___1 = 1;
      } else {
#line 3203
        tmp___1 = 0;
      }
    } else {
#line 3203
      tmp___1 = 0;
    }
#line 3203
    if (tmp___1) {
#line 3211
      if (! silent) {
        {
#line 3213
        lprintf(7, "HPM: Retryable error detected");
        }
      }
#line 3215
      pCtx->resp.lastCmdCompCode = (unsigned char)128;
    } else {
      {
#line 3217
      lprintf(5, "Error getting upgrade status");
#line 3218
      tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3218
      lprintf(5, "compcode=0x%x: %s", (int )rsp->ccode, tmp);
      }
#line 3221
      return ((int )HPMFWUPG_ERROR);
    }
  }
#line 3224
  return ((int )HPMFWUPG_SUCCESS);
}
}
#line 3227 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgManualFirmwareRollback(struct ipmi_intf *intf , struct HpmfwupgManualFirmwareRollbackCtx *pCtx ,
                                          struct HpmfwupgUpgradeCtx *pFwupgCtx ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct HpmfwupgQueryRollbackStatusCtx resCmd ;
  char const   *tmp ;

  {
  {
#line 3230
  rc = (int )HPMFWUPG_SUCCESS;
#line 3234
  pCtx->req.picmgId = (unsigned char)0;
#line 3236
  memset((void *)(& req), 0, sizeof(req));
#line 3237
  req.msg.netfn = (uint8_t )44;
#line 3238
  req.msg.cmd = (uint8_t )56;
#line 3239
  req.msg.data = (unsigned char *)(& pCtx->req);
#line 3240
  req.msg.data_len = (uint16_t )sizeof(struct HpmfwupgManualFirmwareRollbackReq );
#line 3242
  rsp = HpmfwupgSendCmd(intf, req, pFwupgCtx);
  }
#line 3244
  if (rsp) {
#line 3247
    if ((int )rsp->ccode == 128) {
      {
#line 3250
      printf((char const   */* __restrict  */)"Waiting firmware rollback...");
#line 3251
      fflush(stdout);
#line 3252
      rc = HpmfwupgQueryRollbackStatus(intf, & resCmd, pFwupgCtx);
      }
    } else
#line 3254
    if ((int )rsp->ccode != 0) {
      {
#line 3256
      lprintf(5, "Error sending manual rollback");
#line 3257
      tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3257
      lprintf(5, "compcode=0x%x: %s", (int )rsp->ccode, tmp);
#line 3260
      rc = (int )HPMFWUPG_ERROR;
      }
    }
  } else {
    {
#line 3265
    lprintf(5, "Error sending manual rollback\n");
#line 3266
    rc = (int )HPMFWUPG_ERROR;
    }
  }
#line 3268
  return (rc);
}
}
#line 3317
extern int ( /* missing proto */  usleep)() ;
#line 3271 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgQueryRollbackStatus(struct ipmi_intf *intf , struct HpmfwupgQueryRollbackStatusCtx *pCtx ,
                                       struct HpmfwupgUpgradeCtx *pFwupgCtx ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned int rollbackTimeout ;
  unsigned int timeoutSec1 ;
  unsigned int timeoutSec2 ;
  struct HpmfwupgGetTargetUpgCapabilitiesCtx targetCapCmd ;
  time_t tmp ;
  time_t tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  time_t tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 3274
  rc = (int )HPMFWUPG_SUCCESS;
#line 3277
  rollbackTimeout = 0U;
#line 3280
  pCtx->req.picmgId = (unsigned char)0;
#line 3282
  memset((void *)(& req), 0, sizeof(req));
#line 3283
  req.msg.netfn = (uint8_t )44;
#line 3284
  req.msg.cmd = (uint8_t )55;
#line 3285
  req.msg.data = (unsigned char *)(& pCtx->req);
#line 3286
  req.msg.data_len = (uint16_t )sizeof(struct HpmfwupgQueryRollbackStatusReq );
  }
#line 3291
  if ((unsigned long )pFwupgCtx != (unsigned long )((void *)0)) {
#line 3293
    rollbackTimeout = (unsigned int )((int )pFwupgCtx->targetCap.rollbackTimeout * 5);
  } else {
    {
#line 3298
    verbose --;
#line 3299
    rc = HpmfwupgGetTargetUpgCapabilities(intf, & targetCapCmd);
#line 3300
    verbose ++;
    }
#line 3301
    if (rc == (int )HPMFWUPG_SUCCESS) {
#line 3303
      rollbackTimeout = (unsigned int )((int )targetCapCmd.resp.rollbackTimeout * 5);
    } else {
#line 3307
      rollbackTimeout = 60U;
    }
  }
  {
#line 3312
  tmp = time((time_t *)((void *)0));
#line 3312
  timeoutSec1 = (unsigned int )tmp;
#line 3313
  tmp___0 = time((time_t *)((void *)0));
#line 3313
  timeoutSec2 = (unsigned int )tmp___0;
  }
  {
#line 3314
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3317
    usleep(100000);
#line 3318
    rsp = HpmfwupgSendCmd(intf, req, pFwupgCtx);
    }
#line 3324
    if (rsp) {
#line 3326
      if ((int )rsp->ccode == 131) {
#line 3326
        goto _L;
      } else
#line 3326
      if ((int )rsp->ccode == 130) {
#line 3326
        goto _L;
      } else
#line 3326
      if ((int )rsp->ccode == 128) {
        _L: /* CIL Label */ 
#line 3326
        tmp___3 = errorCount;
#line 3326
        errorCount ++;
#line 3326
        if (tmp___3 < 3) {
#line 3326
          tmp___2 = 1;
        } else {
#line 3326
          tmp___2 = 0;
        }
      } else {
#line 3326
        tmp___2 = 0;
      }
#line 3326
      if (tmp___2) {
        {
#line 3328
        lprintf(7, "HPM: [PATCH]Retryable error detected");
#line 3329
        rsp->ccode = (uint8_t )128;
        }
      }
    }
    {
#line 3332
    tmp___4 = time((time_t *)((void *)0));
#line 3332
    timeoutSec2 = (unsigned int )tmp___4;
    }
#line 3314
    if (rsp) {
#line 3314
      if ((int )rsp->ccode == 128) {
#line 3314
        goto _L___0;
      } else
#line 3314
      if ((int )rsp->ccode == 195) {
        _L___0: /* CIL Label */ 
#line 3314
        if (! (timeoutSec2 - timeoutSec1 < rollbackTimeout)) {
#line 3314
          goto while_break;
        }
      } else {
#line 3314
        goto while_break;
      }
    } else {
#line 3314
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3339
  if (rsp) {
#line 3341
    if ((int )rsp->ccode == 0) {
      {
#line 3343
      memcpy((void */* __restrict  */)(& pCtx->resp), (void const   */* __restrict  */)(rsp->data),
             sizeof(struct HpmfwupgQueryRollbackStatusResp ));
      }
#line 3344
      if ((int )pCtx->resp.rollbackComp.ComponentBits.byte != 0) {
        {
#line 3347
        lprintf(5, "Rollback occured on component mask: 0x%02x", (int )pCtx->resp.rollbackComp.ComponentBits.byte);
        }
      } else {
        {
#line 3352
        lprintf(5, "No Firmware rollback occured");
        }
      }
    } else
#line 3355
    if ((int )rsp->ccode == 129) {
      {
#line 3357
      lprintf(5, "Rollback failed on component mask: 0x%02x", (int )pCtx->resp.rollbackComp.ComponentBits.byte);
#line 3359
      rc = (int )HPMFWUPG_ERROR;
      }
    } else {
      {
#line 3363
      lprintf(5, "Error getting rollback status");
#line 3364
      tmp___5 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3364
      lprintf(5, "compcode=0x%x: %s", (int )rsp->ccode, tmp___5);
#line 3367
      rc = (int )HPMFWUPG_ERROR;
      }
    }
  } else {
    {
#line 3372
    lprintf(5, "Error getting upgrade status\n");
#line 3373
    rc = (int )HPMFWUPG_ERROR;
    }
  }
#line 3376
  return (rc);
}
}
#line 3379 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgQuerySelftestResult(struct ipmi_intf *intf , struct HpmfwupgQuerySelftestResultCtx *pCtx ,
                                       struct HpmfwupgUpgradeCtx *pFwupgCtx ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char selfTestTimeout ;
  unsigned int timeoutSec1 ;
  unsigned int timeoutSec2 ;
  struct HpmfwupgImageHeader *pImageHeader ;
  time_t tmp ;
  time_t tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  time_t tmp___4 ;
  char const   *tmp___5 ;

  {
#line 3382
  rc = (int )HPMFWUPG_SUCCESS;
#line 3385
  selfTestTimeout = (unsigned char)0;
#line 3388
  pCtx->req.picmgId = (unsigned char)0;
#line 3393
  if ((unsigned long )pFwupgCtx != (unsigned long )((void *)0)) {
#line 3396
    pImageHeader = (struct HpmfwupgImageHeader *)pFwupgCtx->pImageData;
#line 3398
    selfTestTimeout = pImageHeader->selfTestTimeout;
  } else {
#line 3402
    selfTestTimeout = (unsigned char)60;
  }
  {
#line 3405
  memset((void *)(& req), 0, sizeof(req));
#line 3406
  req.msg.netfn = (uint8_t )44;
#line 3407
  req.msg.cmd = (uint8_t )54;
#line 3408
  req.msg.data = (unsigned char *)(& pCtx->req);
#line 3409
  req.msg.data_len = (uint16_t )sizeof(struct HpmfwupgQuerySelftestResultReq );
#line 3413
  tmp = time((time_t *)((void *)0));
#line 3413
  timeoutSec1 = (unsigned int )tmp;
#line 3414
  tmp___0 = time((time_t *)((void *)0));
#line 3414
  timeoutSec2 = (unsigned int )tmp___0;
  }
  {
#line 3415
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3418
    usleep(100000);
#line 3419
    rsp = HpmfwupgSendCmd(intf, req, pFwupgCtx);
    }
#line 3425
    if (rsp) {
#line 3427
      if ((int )rsp->ccode == 131) {
#line 3427
        goto _L;
      } else
#line 3427
      if ((int )rsp->ccode == 130) {
#line 3427
        goto _L;
      } else
#line 3427
      if ((int )rsp->ccode == 128) {
        _L: /* CIL Label */ 
#line 3427
        tmp___3 = errorCount;
#line 3427
        errorCount ++;
#line 3427
        if (tmp___3 < 3) {
#line 3427
          tmp___2 = 1;
        } else {
#line 3427
          tmp___2 = 0;
        }
      } else {
#line 3427
        tmp___2 = 0;
      }
#line 3427
      if (tmp___2) {
        {
#line 3429
        lprintf(7, "HPM: [PATCH]Retryable error detected");
#line 3430
        rsp->ccode = (uint8_t )128;
        }
      }
    }
    {
#line 3433
    tmp___4 = time((time_t *)((void *)0));
#line 3433
    timeoutSec2 = (unsigned int )tmp___4;
    }
#line 3415
    if (rsp) {
#line 3415
      if ((int )rsp->ccode == 128) {
#line 3415
        if (! (timeoutSec2 - timeoutSec1 < (unsigned int )selfTestTimeout)) {
#line 3415
          goto while_break;
        }
      } else {
#line 3415
        goto while_break;
      }
    } else {
#line 3415
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3439
  if (rsp) {
#line 3441
    if ((int )rsp->ccode == 0) {
      {
#line 3443
      memcpy((void */* __restrict  */)(& pCtx->resp), (void const   */* __restrict  */)(rsp->data),
             sizeof(struct HpmfwupgQuerySelftestResultResp ));
      }
#line 3444
      if (verbose) {
        {
#line 3446
        lprintf(5, "Self test results:");
#line 3447
        lprintf(5, "Result1 = %x", (int )pCtx->resp.result1);
#line 3448
        lprintf(5, "Result2 = %x", (int )pCtx->resp.result2);
        }
      }
    } else {
      {
#line 3453
      lprintf(5, "Error getting self test results");
#line 3454
      tmp___5 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3454
      lprintf(5, "compcode=0x%x: %s", (int )rsp->ccode, tmp___5);
#line 3457
      rc = (int )HPMFWUPG_ERROR;
      }
    }
  } else {
    {
#line 3462
    lprintf(5, "Error getting upgrade status\n");
#line 3463
    rc = (int )HPMFWUPG_ERROR;
    }
  }
#line 3466
  return (rc);
}
}
#line 3501 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static unsigned char isValidSize  =    (unsigned char)0;
#line 3510 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int errorCount___0  =    0;
#line 3511 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static struct ipmi_rs fakeRsp  ;
#line 3469 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static struct ipmi_rs *HpmfwupgSendCmd(struct ipmi_intf *intf , struct ipmi_rq req ,
                                       struct HpmfwupgUpgradeCtx *pFwupgCtx ) 
{ 
  struct ipmi_rs *rsp ;
  unsigned int inaccessTimeout ;
  unsigned int inaccessTimeoutCounter ;
  unsigned int upgradeTimeout ;
  unsigned int upgradeTimeoutCounter ;
  unsigned int timeoutSec1 ;
  unsigned int timeoutSec2 ;
  unsigned char retry ;
  time_t tmp ;
  time_t tmp___0 ;
  time_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  time_t tmp___4 ;
  time_t tmp___5 ;
  time_t tmp___6 ;
  time_t tmp___7 ;

  {
#line 3473
  inaccessTimeout = 0U;
#line 3473
  inaccessTimeoutCounter = 0U;
#line 3474
  upgradeTimeout = 0U;
#line 3474
  upgradeTimeoutCounter = 0U;
#line 3476
  retry = (unsigned char)0;
#line 3481
  if ((unsigned long )pFwupgCtx != (unsigned long )((void *)0)) {
#line 3483
    inaccessTimeout = (unsigned int )((int )pFwupgCtx->targetCap.inaccessTimeout * 5);
#line 3484
    upgradeTimeout = (unsigned int )((int )pFwupgCtx->targetCap.upgradeTimeout * 5);
  } else {
#line 3493
    inaccessTimeout = 60U;
#line 3494
    upgradeTimeout = 60U;
  }
  {
#line 3497
  tmp = time((time_t *)((void *)0));
#line 3497
  timeoutSec1 = (unsigned int )tmp;
  }
  {
#line 3499
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3502
    rsp = (*(intf->sendrecv))(intf, & req);
    }
#line 3504
    if ((unsigned long )rsp == (unsigned long )((void *)0)) {
      {
#line 3508
      tmp___3 = strstr((char const   *)(intf->name), "lan");
      }
#line 3508
      if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
        {
#line 3513
        lprintf(7, "HPM: no response available");
#line 3514
        lprintf(7, "HPM: the command may be rejected for security reasons");
        }
#line 3517
        if ((int )req.msg.netfn == 44) {
#line 3517
          if ((int )req.msg.cmd == 50) {
#line 3517
            if (errorCount___0 < 6) {
#line 3517
              if (! isValidSize) {
                {
#line 3528
                lprintf(7, "HPM: upload firmware block API called");
#line 3529
                lprintf(7, "HPM: returning length error to force resize");
#line 3531
                fakeRsp.ccode = (uint8_t )199;
#line 3532
                rsp = & fakeRsp;
#line 3533
                errorCount___0 ++;
                }
              } else {
#line 3517
                goto _L___3;
              }
            } else {
#line 3517
              goto _L___3;
            }
          } else {
#line 3517
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 3535
        if ((int )req.msg.netfn == 44) {
#line 3535
          if ((int )req.msg.cmd == 53) {
            {
#line 3548
            lprintf(7, "HPM: activate/rollback firmware API called");
#line 3549
            lprintf(7, "HPM: returning in progress to handle IOL session lost");
#line 3551
            fakeRsp.ccode = (uint8_t )128;
#line 3552
            rsp = & fakeRsp;
            }
          } else
#line 3535
          if ((int )req.msg.cmd == 56) {
            {
#line 3548
            lprintf(7, "HPM: activate/rollback firmware API called");
#line 3549
            lprintf(7, "HPM: returning in progress to handle IOL session lost");
#line 3551
            fakeRsp.ccode = (uint8_t )128;
#line 3552
            rsp = & fakeRsp;
            }
          } else {
#line 3535
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 3554
        if ((int )req.msg.netfn == 44) {
#line 3554
          if ((int )req.msg.cmd == 55) {
#line 3554
            goto _L;
          } else
#line 3554
          if ((int )req.msg.cmd == 52) {
            _L: /* CIL Label */ 
            {
#line 3569
            lprintf(7, "HPM: upg/rollback status firmware API called");
#line 3570
            lprintf(7, "HPM: try to re-open IOL session");
#line 3574
            intf->opened = 0;
#line 3575
            (intf->session)->authtype = (uint8_t )0;
#line 3576
            (intf->session)->session_id = (uint32_t )0;
#line 3577
            (intf->session)->in_seq = (uint32_t )0;
#line 3578
            (intf->session)->out_seq = (uint32_t )0;
#line 3579
            (intf->session)->active = 0;
#line 3580
            (intf->session)->retry = 10;
            }
            {
#line 3582
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 3582
              tmp___2 = (*(intf->open))(intf);
              }
#line 3582
              if (tmp___2 == (int )HPMFWUPG_ERROR) {
#line 3582
                if (! (inaccessTimeoutCounter < inaccessTimeout)) {
#line 3582
                  goto while_break___0;
                }
              } else {
#line 3582
                goto while_break___0;
              }
              {
#line 3589
              tmp___0 = time((time_t *)((void *)0));
#line 3589
              inaccessTimeoutCounter = (unsigned int )((time_t )inaccessTimeoutCounter + (tmp___0 - (time_t )timeoutSec1));
#line 3590
              tmp___1 = time((time_t *)((void *)0));
#line 3590
              timeoutSec1 = (unsigned int )tmp___1;
              }
            }
            while_break___0: /* CIL Label */ ;
            }
#line 3593
            fakeRsp.ccode = (uint8_t )195;
#line 3594
            rsp = & fakeRsp;
          }
        }
      }
    }
#line 3601
    if ((unsigned long )rsp == (unsigned long )((void *)0)) {
#line 3601
      goto _L___4;
    } else
#line 3601
    if ((int )rsp->ccode == 255) {
#line 3601
      goto _L___4;
    } else
#line 3601
    if ((int )rsp->ccode == 195) {
#line 3601
      goto _L___4;
    } else
#line 3601
    if ((int )rsp->ccode == 211) {
      _L___4: /* CIL Label */ 
#line 3603
      if (inaccessTimeoutCounter < inaccessTimeout) {
        {
#line 3605
        tmp___4 = time((time_t *)((void *)0));
#line 3605
        timeoutSec2 = (unsigned int )tmp___4;
        }
#line 3606
        if (timeoutSec2 > timeoutSec1) {
          {
#line 3608
          inaccessTimeoutCounter += timeoutSec2 - timeoutSec1;
#line 3609
          tmp___5 = time((time_t *)((void *)0));
#line 3609
          timeoutSec1 = (unsigned int )tmp___5;
          }
        }
        {
#line 3611
        usleep(100000);
#line 3612
        retry = (unsigned char)1;
        }
      } else {
#line 3616
        retry = (unsigned char)0;
      }
    } else
#line 3620
    if ((int )rsp->ccode == 192) {
#line 3622
      if (upgradeTimeoutCounter < upgradeTimeout) {
        {
#line 3624
        tmp___6 = time((time_t *)((void *)0));
#line 3624
        timeoutSec2 = (unsigned int )tmp___6;
        }
#line 3625
        if (timeoutSec2 > timeoutSec1) {
          {
#line 3627
          tmp___7 = time((time_t *)((void *)0));
#line 3627
          timeoutSec1 = (unsigned int )tmp___7;
#line 3628
          upgradeTimeoutCounter += timeoutSec2 - timeoutSec1;
          }
        }
        {
#line 3630
        usleep(100000);
#line 3631
        retry = (unsigned char)1;
        }
      } else {
#line 3635
        retry = (unsigned char)0;
      }
    } else {
#line 3641
      if ((int )rsp->ccode == 0) {
#line 3643
        errorCount = 0;
      }
#line 3646
      retry = (unsigned char)0;
#line 3648
      if ((int )req.msg.netfn == 44) {
#line 3648
        if ((int )req.msg.cmd == 50) {
#line 3648
          if (! isValidSize) {
            {
#line 3657
            lprintf(6, "Buffer length is now considered valid");
#line 3659
            isValidSize = (unsigned char)1;
            }
          }
        }
      }
    }
#line 3499
    if (! retry) {
#line 3499
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3663
  return (rsp);
}
}
#line 3666 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgWaitLongDurationCmd(struct ipmi_intf *intf , struct HpmfwupgUpgradeCtx *pFwupgCtx ) 
{ 
  int rc ;
  unsigned int upgradeTimeout ;
  unsigned int timeoutSec1 ;
  unsigned int timeoutSec2 ;
  struct HpmfwupgGetUpgradeStatusCtx upgStatusCmd ;
  struct HpmfwupgGetTargetUpgCapabilitiesCtx targetCapCmd ;
  int tmp ;
  time_t tmp___0 ;
  time_t tmp___1 ;
  time_t tmp___2 ;

  {
#line 3668
  rc = (int )HPMFWUPG_SUCCESS;
#line 3669
  upgradeTimeout = 0U;
#line 3676
  if ((unsigned long )pFwupgCtx != (unsigned long )((void *)0)) {
#line 3678
    upgradeTimeout = (unsigned int )((int )pFwupgCtx->targetCap.upgradeTimeout * 5);
#line 3679
    if (verbose) {
      {
#line 3680
      printf((char const   */* __restrict  */)"Use File Upgrade Capabilities: %i seconds\n",
             upgradeTimeout);
      }
    }
  } else {
    {
#line 3687
    tmp = HpmfwupgGetTargetUpgCapabilities(intf, & targetCapCmd);
    }
#line 3687
    if (tmp != (int )HPMFWUPG_SUCCESS) {
#line 3689
      upgradeTimeout = 60U;
#line 3691
      if (verbose) {
        {
#line 3692
        printf((char const   */* __restrict  */)"Use default timeout: %i seconds\n",
               upgradeTimeout);
        }
      }
    } else {
#line 3696
      upgradeTimeout = (unsigned int )((int )targetCapCmd.resp.upgradeTimeout * 5);
#line 3697
      if (verbose) {
        {
#line 3698
        printf((char const   */* __restrict  */)"Use Command Upgrade Capabilities Timeout: %i seconds\n",
               upgradeTimeout);
        }
      }
    }
  }
#line 3702
  if (rc == (int )HPMFWUPG_SUCCESS) {
    {
#line 3705
    tmp___0 = time((time_t *)((void *)0));
#line 3705
    timeoutSec1 = (unsigned int )tmp___0;
#line 3706
    tmp___1 = time((time_t *)((void *)0));
#line 3706
    timeoutSec2 = (unsigned int )tmp___1;
#line 3707
    rc = HpmfwupgGetUpgradeStatus(intf, & upgStatusCmd, pFwupgCtx, 1);
    }
  }
  {
#line 3710
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3710
    if ((int )upgStatusCmd.resp.lastCmdCompCode != 0) {
#line 3710
      if (timeoutSec2 - timeoutSec1 < upgradeTimeout) {
#line 3710
        if (! (rc == (int )HPMFWUPG_SUCCESS)) {
#line 3710
          goto while_break;
        }
      } else {
#line 3710
        goto while_break;
      }
    } else {
#line 3710
      goto while_break;
    }
    {
#line 3718
    usleep(1000000);
#line 3719
    tmp___2 = time((time_t *)((void *)0));
#line 3719
    timeoutSec2 = (unsigned int )tmp___2;
#line 3720
    rc = HpmfwupgGetUpgradeStatus(intf, & upgStatusCmd, pFwupgCtx, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3724
  if ((int )upgStatusCmd.resp.lastCmdCompCode != 0) {
#line 3726
    if (verbose) {
      {
#line 3728
      lprintf(5, "Error waiting for command %x, compcode = %x", (int )upgStatusCmd.resp.cmdInProcess,
              (int )upgStatusCmd.resp.lastCmdCompCode);
      }
    }
#line 3732
    rc = (int )HPMFWUPG_ERROR;
  }
#line 3735
  return (rc);
}
}
#line 3738 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static unsigned char HpmfwupgCalculateChecksum(unsigned char *pData , unsigned int length ) 
{ 
  unsigned char checksum ;
  int dataIdx ;

  {
#line 3740
  checksum = (unsigned char)0;
#line 3741
  dataIdx = 0;
#line 3743
  dataIdx = 0;
  {
#line 3743
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3743
    if (! ((unsigned int )dataIdx < length)) {
#line 3743
      goto while_break;
    }
#line 3745
    checksum = (unsigned char )((int )checksum + (int )*(pData + dataIdx));
#line 3743
    dataIdx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3747
  return (checksum);
}
}
#line 3750 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static void HpmfwupgPrintUsage(void) 
{ 


  {
  {
#line 3752
  lprintf(5, "help                    - This help menu.");
#line 3753
  lprintf(5, "");
#line 3754
  lprintf(5, "check                   - Check the target information.");
#line 3755
  lprintf(5, "check <file>            - If the user is unsure of what update is going to be ");
#line 3756
  lprintf(5, "                          This will display the existing target version and");
#line 3757
  lprintf(5, "                          image version on the screen");
#line 3758
  lprintf(5, "");
#line 3759
  lprintf(5, "upgrade <file>          - Copies all the components from a valid HPM.1");
#line 3760
  lprintf(5, "                          image <file> to the target.");
#line 3761
  lprintf(5, "                          This compares the versions from both the target");
#line 3762
  lprintf(5, "                          and image and will only perform the copy");
#line 3763
  lprintf(5, "                          if the versions differ.");
#line 3764
  lprintf(5, "upgrade <file> activate - Copy and activate the firmware using a valid HPM.1");
#line 3765
  lprintf(5, "                          image <file>.");
#line 3766
  lprintf(5, "                          This compares the versions from both the target");
#line 3767
  lprintf(5, "                          and image and will only perform the copy and");
#line 3768
  lprintf(5, "                          activation if the versions differ.");
#line 3769
  lprintf(5, "upgrade <file> force    - Copies all the components present in <file>");
#line 3770
  lprintf(5, "                          to the target board without checking the versions.");
#line 3771
  lprintf(5, "                          Make sure to check the versions first using the");
#line 3772
  lprintf(5, "                          \"check <file>\" command.");
#line 3773
  lprintf(5, "upgrade <file> component x - Copy only component <x> from the given <file>");
#line 3774
  lprintf(5, "                          without checking if the versions differ.");
#line 3775
  lprintf(5, "                          For example:");
#line 3776
  lprintf(5, "                          component 0 = Bootloader");
#line 3777
  lprintf(5, "                          component 1 = Firmware");
#line 3778
  lprintf(5, "                          Make sure to check the versions first using the");
#line 3779
  lprintf(5, "                          \"check <file>\" command.");
#line 3780
  lprintf(5, "upgstatus               - Returns the status of the last long duration command.");
#line 3781
  lprintf(5, "");
#line 3782
  lprintf(5, "activate                - Activate the newly uploaded firmware.");
#line 3783
  lprintf(5, "activate norollback     - Activate the newly uploaded firmware but inform");
#line 3784
  lprintf(5, "                          the target to not automatically rollback if ");
#line 3785
  lprintf(5, "                          the upgrade fails.");
#line 3786
  lprintf(5, "");
#line 3787
  lprintf(5, "targetcap               - Get the target upgrade capabilities.");
#line 3788
  lprintf(5, "");
#line 3789
  lprintf(5, "compprop <id> <prop>    - Get specified component properties from the target.");
#line 3790
  lprintf(5, "                          Valid component <id>: 0-7 ");
#line 3791
  lprintf(5, "                          Properties <prop> can be one of the following: ");
#line 3792
  lprintf(5, "                          0- General properties");
#line 3793
  lprintf(5, "                          1- Current firmware version");
#line 3794
  lprintf(5, "                          2- Description string");
#line 3795
  lprintf(5, "                          3- Rollback firmware version");
#line 3796
  lprintf(5, "                          4- Deferred firmware version");
#line 3797
  lprintf(5, "");
#line 3798
  lprintf(5, "abort                   - Abort the on-going firmware upgrade.");
#line 3799
  lprintf(5, "");
#line 3800
  lprintf(5, "rollback                - Performs a manual rollback on the IPM Controller.");
#line 3801
  lprintf(5, "                          firmware");
#line 3802
  lprintf(5, "rollbackstatus          - Query the rollback status.");
#line 3803
  lprintf(5, "");
#line 3804
  lprintf(5, "selftestresult          - Query the self test results.\n");
  }
#line 3805
  return;
}
}
#line 3807 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
int ipmi_hpmfwupg_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int rc ;
  int activateFlag ;
  int componentId ;
  int option ;
  int tmp ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct HpmfwupgActivateFirmwareCtx cmdCtx ;
  int tmp___5 ;
  struct HpmfwupgGetTargetUpgCapabilitiesCtx cmdCtx___0 ;
  struct HpmfwupgGetComponentPropertiesCtx cmdCtx___1 ;
  int tmp___6 ;
  int tmp___7 ;
  struct HpmfwupgAbortUpgradeCtx cmdCtx___2 ;
  struct HpmfwupgGetUpgradeStatusCtx cmdCtx___3 ;
  struct HpmfwupgManualFirmwareRollbackCtx cmdCtx___4 ;
  struct HpmfwupgQueryRollbackStatusCtx cmdCtx___5 ;
  struct HpmfwupgQuerySelftestResultCtx cmdCtx___6 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  {
#line 3809
  rc = (int )HPMFWUPG_SUCCESS;
#line 3810
  activateFlag = 0;
#line 3811
  componentId = 15;
#line 3812
  option = 1;
#line 3814
  lprintf(7, "ipmi_hpmfwupg_main()");
#line 3817
  lprintf(5, "\nPICMG HPM.1 Upgrade Agent %d.%d.%d: \n", 1, 0, 8);
  }
#line 3820
  if (argc == 0) {
    {
#line 3822
    HpmfwupgPrintUsage();
    }
#line 3823
    return ((int )HPMFWUPG_ERROR);
  } else {
    {
#line 3820
    tmp = strcmp((char const   *)*(argv + 0), "help");
    }
#line 3820
    if (tmp == 0) {
      {
#line 3822
      HpmfwupgPrintUsage();
      }
#line 3823
      return ((int )HPMFWUPG_ERROR);
    }
  }
  {
#line 3825
  tmp___17 = strcmp((char const   *)*(argv + 0), "check");
  }
#line 3825
  if (tmp___17 == 0) {
#line 3828
    if ((unsigned long )*(argv + 1) == (unsigned long )((void *)0)) {
      {
#line 3830
      rc = HpmfwupgTargetCheck(intf, 2);
      }
    } else {
      {
#line 3835
      rc = HpmfwupgTargetCheck(intf, 0);
      }
#line 3836
      if (rc == (int )HPMFWUPG_SUCCESS) {
        {
#line 3838
        rc = HpmfwupgUpgrade(intf, *(argv + 1), 0, 15, 2);
        }
      }
    }
  } else {
    {
#line 3843
    tmp___16 = strcmp((char const   *)*(argv + 0), "upgrade");
    }
#line 3843
    if (tmp___16 == 0) {
#line 3845
      i = 0;
#line 3846
      i = 1;
      {
#line 3846
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3846
        if (! (i < argc)) {
#line 3846
          goto while_break;
        }
        {
#line 3848
        tmp___0 = strcmp((char const   *)*(argv + i), "activate");
        }
#line 3848
        if (tmp___0 == 0) {
#line 3850
          activateFlag = 1;
        }
        {
#line 3853
        tmp___1 = strcmp((char const   *)*(argv + i), "force");
        }
#line 3853
        if (tmp___1 == 0) {
#line 3855
          option &= -2;
#line 3856
          option &= -3;
#line 3857
          option |= 8;
        }
        {
#line 3860
        tmp___3 = strcmp((char const   *)*(argv + i), "component");
        }
#line 3860
        if (tmp___3 == 0) {
#line 3862
          if (i + 1 < argc) {
            {
#line 3864
            tmp___2 = str2int((char const   *)*(argv + (i + 1)), & componentId);
            }
#line 3864
            if (tmp___2 != 0) {
              {
#line 3866
              lprintf(3, "Given Component ID \'%s\' is invalid.", *(argv + (i + 1)));
#line 3868
              lprintf(3, "Valid Compoment ID is: <0..7>");
              }
#line 3869
              return (-1);
            } else
#line 3864
            if (componentId < 0) {
              {
#line 3866
              lprintf(3, "Given Component ID \'%s\' is invalid.", *(argv + (i + 1)));
#line 3868
              lprintf(3, "Valid Compoment ID is: <0..7>");
              }
#line 3869
              return (-1);
            } else
#line 3864
            if (componentId > 7) {
              {
#line 3866
              lprintf(3, "Given Component ID \'%s\' is invalid.", *(argv + (i + 1)));
#line 3868
              lprintf(3, "Valid Compoment ID is: <0..7>");
              }
#line 3869
              return (-1);
            }
#line 3871
            option &= -2;
#line 3872
            option &= -3;
#line 3873
            option |= 16;
#line 3875
            if (verbose) {
              {
#line 3876
              lprintf(5, "Component Id %d provided", componentId);
              }
            }
#line 3880
            if (componentId >= 8) {
              {
#line 3882
              lprintf(5, "Given component ID %d exceeds Max Comp ID %d\n", componentId,
                      7);
              }
#line 3884
              return ((int )HPMFWUPG_ERROR);
            }
          }
#line 3887
          if (componentId == 15) {
            {
#line 3891
            lprintf(5, "No component Id provided\n");
            }
#line 3892
            return ((int )HPMFWUPG_ERROR);
          }
        }
        {
#line 3895
        tmp___4 = strcmp((char const   *)*(argv + i), "debug");
        }
#line 3895
        if (tmp___4 == 0) {
#line 3897
          option |= 4;
        }
#line 3846
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 3900
      rc = HpmfwupgTargetCheck(intf, 0);
      }
#line 3901
      if (rc == (int )HPMFWUPG_SUCCESS) {
        {
#line 3904
        rc = HpmfwupgUpgrade(intf, *(argv + 1), activateFlag, componentId, option);
        }
      }
    } else
#line 3908
    if (argc >= 1) {
      {
#line 3908
      tmp___15 = strcmp((char const   *)*(argv + 0), "activate");
      }
#line 3908
      if (tmp___15 == 0) {
#line 3911
        if (argc == 2) {
          {
#line 3911
          tmp___5 = strcmp((char const   *)*(argv + 1), "norollback");
          }
#line 3911
          if (tmp___5 == 0) {
#line 3912
            cmdCtx.req.rollback_override = (unsigned char)1;
          } else {
#line 3914
            cmdCtx.req.rollback_override = (unsigned char)0;
          }
        } else {
#line 3914
          cmdCtx.req.rollback_override = (unsigned char)0;
        }
        {
#line 3915
        rc = HpmfwupgActivateFirmware(intf, & cmdCtx, (struct HpmfwupgUpgradeCtx *)((void *)0));
        }
      } else {
#line 3908
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 3917
    if (argc == 1) {
      {
#line 3917
      tmp___14 = strcmp((char const   *)*(argv + 0), "targetcap");
      }
#line 3917
      if (tmp___14 == 0) {
        {
#line 3920
        verbose ++;
#line 3921
        rc = HpmfwupgGetTargetUpgCapabilities(intf, & cmdCtx___0);
        }
      } else {
#line 3917
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 3923
    if (argc == 3) {
      {
#line 3923
      tmp___13 = strcmp((char const   *)*(argv + 0), "compprop");
      }
#line 3923
      if (tmp___13 == 0) {
        {
#line 3926
        tmp___6 = str2uchar((char const   *)*(argv + 1), & cmdCtx___1.req.componentId);
        }
#line 3926
        if (tmp___6 != 0) {
          {
#line 3928
          lprintf(3, "Given Component ID \'%s\' is invalid.", *(argv + 1));
#line 3929
          lprintf(3, "Valid Compoment ID is: <0..7>");
          }
#line 3930
          return (-1);
        } else
#line 3926
        if ((int )cmdCtx___1.req.componentId > 7) {
          {
#line 3928
          lprintf(3, "Given Component ID \'%s\' is invalid.", *(argv + 1));
#line 3929
          lprintf(3, "Valid Compoment ID is: <0..7>");
          }
#line 3930
          return (-1);
        }
        {
#line 3932
        tmp___7 = str2uchar((char const   *)*(argv + 2), & cmdCtx___1.req.selector);
        }
#line 3932
        if (tmp___7 != 0) {
          {
#line 3934
          lprintf(3, "Given Properties selector \'%s\' is invalid.", *(argv + 2));
#line 3936
          lprintf(3, "Valid Properties selector is: <0..4>");
          }
#line 3937
          return (-1);
        } else
#line 3932
        if ((int )cmdCtx___1.req.selector > 4) {
          {
#line 3934
          lprintf(3, "Given Properties selector \'%s\' is invalid.", *(argv + 2));
#line 3936
          lprintf(3, "Valid Properties selector is: <0..4>");
          }
#line 3937
          return (-1);
        }
        {
#line 3939
        verbose ++;
#line 3940
        rc = HpmfwupgGetComponentProperties(intf, & cmdCtx___1);
        }
      } else {
#line 3923
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 3942
    if (argc == 1) {
      {
#line 3942
      tmp___12 = strcmp((char const   *)*(argv + 0), "abort");
      }
#line 3942
      if (tmp___12 == 0) {
        {
#line 3945
        verbose ++;
#line 3946
        rc = HpmfwupgAbortUpgrade(intf, & cmdCtx___2);
        }
      } else {
#line 3942
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 3948
    if (argc == 1) {
      {
#line 3948
      tmp___11 = strcmp((char const   *)*(argv + 0), "upgstatus");
      }
#line 3948
      if (tmp___11 == 0) {
        {
#line 3951
        verbose ++;
#line 3952
        rc = HpmfwupgGetUpgradeStatus(intf, & cmdCtx___3, (struct HpmfwupgUpgradeCtx *)((void *)0),
                                      0);
        }
      } else {
#line 3948
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 3954
    if (argc == 1) {
      {
#line 3954
      tmp___10 = strcmp((char const   *)*(argv + 0), "rollback");
      }
#line 3954
      if (tmp___10 == 0) {
        {
#line 3957
        verbose ++;
#line 3958
        rc = HpmfwupgManualFirmwareRollback(intf, & cmdCtx___4, (struct HpmfwupgUpgradeCtx *)((void *)0));
        }
      } else {
#line 3954
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 3960
    if (argc == 1) {
      {
#line 3960
      tmp___9 = strcmp((char const   *)*(argv + 0), "rollbackstatus");
      }
#line 3960
      if (tmp___9 == 0) {
        {
#line 3963
        verbose ++;
#line 3964
        rc = HpmfwupgQueryRollbackStatus(intf, & cmdCtx___5, (struct HpmfwupgUpgradeCtx *)((void *)0));
        }
      } else {
#line 3960
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 3966
    if (argc == 1) {
      {
#line 3966
      tmp___8 = strcmp((char const   *)*(argv + 0), "selftestresult");
      }
#line 3966
      if (tmp___8 == 0) {
        {
#line 3969
        verbose ++;
#line 3970
        rc = HpmfwupgQuerySelftestResult(intf, & cmdCtx___6, (struct HpmfwupgUpgradeCtx *)((void *)0));
        }
      } else {
        {
#line 3974
        HpmfwupgPrintUsage();
        }
      }
    } else {
      {
#line 3974
      HpmfwupgPrintUsage();
      }
    }
  }
#line 3977
  return (rc);
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 846
extern void perror(char const   *__s ) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 44 "../include/ipmitool/ipmi_strings.h"
extern struct valstr  const  ipmi_bit_rate_vals[] ;
#line 55 "../include/ipmitool/ipmi_isol.h"
int ipmi_isol_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static struct termios _saved_tio  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static int _in_raw_mode  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static int ipmi_get_isol_info(struct ipmi_intf *intf , struct isol_config_parameters *params ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char data[6] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 71
  memset((void *)(& req), 0, sizeof(req));
#line 72
  req.msg.netfn = (uint8_t )52;
#line 73
  req.msg.cmd = (uint8_t )4;
#line 74
  req.msg.data = data;
#line 75
  req.msg.data_len = (uint16_t )4;
#line 79
  memset((void *)(data), 0, (size_t )6);
#line 80
  data[0] = (unsigned char)0;
#line 81
  data[1] = (unsigned char)1;
#line 82
  data[2] = (unsigned char)0;
#line 83
  data[3] = (unsigned char)0;
#line 85
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 86
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 87
    lprintf(3, "Error in Get ISOL Config Command");
    }
#line 88
    return (-1);
  }
#line 90
  if ((int )rsp->ccode == 193) {
    {
#line 91
    lprintf(3, "IPMI v1.5 Serial Over Lan (ISOL) not supported!");
    }
#line 92
    return (-1);
  }
#line 94
  if ((int )rsp->ccode > 0) {
    {
#line 95
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 95
    lprintf(3, "Error in Get ISOL Config Command: %s", tmp);
    }
#line 97
    return (-1);
  }
  {
#line 99
  params->enabled = rsp->data[1];
#line 103
  memset((void *)(data), 0, (size_t )6);
#line 104
  data[0] = (unsigned char)0;
#line 105
  data[1] = (unsigned char)2;
#line 106
  data[2] = (unsigned char)0;
#line 107
  data[3] = (unsigned char)0;
#line 109
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 110
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 111
    lprintf(3, "Error in Get ISOL Config Command");
    }
#line 112
    return (-1);
  }
#line 114
  if ((int )rsp->ccode > 0) {
    {
#line 115
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 115
    lprintf(3, "Error in Get ISOL Config Command: %s", tmp___0);
    }
#line 117
    return (-1);
  }
  {
#line 119
  params->privilege_level = rsp->data[1];
#line 123
  memset((void *)(data), 0, (size_t )6);
#line 124
  data[0] = (unsigned char)0;
#line 125
  data[1] = (unsigned char)5;
#line 126
  data[2] = (unsigned char)0;
#line 127
  data[3] = (unsigned char)0;
#line 129
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 130
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 131
    lprintf(3, "Error in Get ISOL Config Command");
    }
#line 132
    return (-1);
  }
#line 134
  if ((int )rsp->ccode > 0) {
    {
#line 135
    tmp___1 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 135
    lprintf(3, "Error in Get ISOL Config Command: %s", tmp___1);
    }
#line 137
    return (-1);
  }
#line 139
  params->bit_rate = rsp->data[1];
#line 141
  return (0);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static int ipmi_print_isol_info(struct ipmi_intf *intf ) 
{ 
  struct isol_config_parameters params ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 146
  params.enabled = (uint8_t )0;
#line 146
  params.privilege_level = (unsigned char)0;
#line 146
  params.bit_rate = (unsigned char)0;
#line 147
  tmp = ipmi_get_isol_info(intf, & params);
  }
#line 147
  if (tmp) {
#line 148
    return (-1);
  }
#line 150
  if (csv_output) {
#line 152
    if ((int )params.enabled & 1) {
#line 152
      tmp___0 = "true";
    } else {
#line 152
      tmp___0 = "false";
    }
    {
#line 152
    printf((char const   */* __restrict  */)"%s,", tmp___0);
#line 153
    tmp___1 = val2str((uint16_t )((int )params.privilege_level & 15), ipmi_privlvl_vals);
#line 153
    printf((char const   */* __restrict  */)"%s,", tmp___1);
#line 155
    tmp___2 = val2str((uint16_t )((int )params.bit_rate & 15), ipmi_bit_rate_vals);
#line 155
    printf((char const   */* __restrict  */)"%s,", tmp___2);
    }
  } else {
#line 160
    if ((int )params.enabled & 1) {
#line 160
      tmp___3 = "true";
    } else {
#line 160
      tmp___3 = "false";
    }
    {
#line 160
    printf((char const   */* __restrict  */)"Enabled                         : %s\n",
           tmp___3);
#line 162
    tmp___4 = val2str((uint16_t )((int )params.privilege_level & 15), ipmi_privlvl_vals);
#line 162
    printf((char const   */* __restrict  */)"Privilege Level                 : %s\n",
           tmp___4);
#line 164
    tmp___5 = val2str((uint16_t )((int )params.bit_rate & 15), ipmi_bit_rate_vals);
#line 164
    printf((char const   */* __restrict  */)"Bit Rate (kbps)                 : %s\n",
           tmp___5);
    }
  }
#line 168
  return (0);
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static int ipmi_isol_set_param(struct ipmi_intf *intf , char const   *param , char const   *value ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char data[6] ;
  struct isol_config_parameters params ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;

  {
  {
#line 178
  params.enabled = (uint8_t )0;
#line 178
  params.privilege_level = (unsigned char)0;
#line 178
  params.bit_rate = (unsigned char)0;
#line 181
  tmp = ipmi_get_isol_info(intf, & params);
  }
#line 181
  if (tmp) {
#line 182
    return (-1);
  }
  {
#line 184
  memset((void *)(& req), 0, sizeof(req));
#line 185
  req.msg.netfn = (uint8_t )52;
#line 186
  req.msg.cmd = (uint8_t )3;
#line 187
  req.msg.data = data;
#line 188
  req.msg.data_len = (uint16_t )3;
#line 190
  memset((void *)(data), 0, (size_t )6);
#line 195
  tmp___14 = strcmp(param, "enabled");
  }
#line 195
  if (tmp___14 == 0) {
    {
#line 197
    data[1] = (unsigned char)1;
#line 198
    tmp___1 = strcmp(value, "true");
    }
#line 198
    if (tmp___1 == 0) {
#line 199
      data[2] = (unsigned char)1;
    } else {
      {
#line 200
      tmp___0 = strcmp(value, "false");
      }
#line 200
      if (tmp___0 == 0) {
#line 201
        data[2] = (unsigned char)0;
      } else {
        {
#line 203
        lprintf(3, "Invalid value %s for parameter %s", value, param);
#line 205
        lprintf(3, "Valid values are true and false");
        }
#line 206
        return (-1);
      }
    }
  } else {
    {
#line 213
    tmp___13 = strcmp(param, "privilege-level");
    }
#line 213
    if (tmp___13 == 0) {
      {
#line 215
      data[1] = (unsigned char)2;
#line 216
      tmp___5 = strcmp(value, "user");
      }
#line 216
      if (tmp___5) {
        {
#line 218
        tmp___4 = strcmp(value, "operator");
        }
#line 218
        if (tmp___4) {
          {
#line 220
          tmp___3 = strcmp(value, "admin");
          }
#line 220
          if (tmp___3) {
            {
#line 222
            tmp___2 = strcmp(value, "oem");
            }
#line 222
            if (tmp___2) {
              {
#line 226
              lprintf(3, "Invalid value %s for parameter %s", value, param);
#line 228
              lprintf(3, "Valid values are user, operator, admin, and oem");
              }
#line 229
              return (-1);
            } else {
#line 223
              data[2] = (unsigned char)5;
            }
          } else {
#line 221
            data[2] = (unsigned char)4;
          }
        } else {
#line 219
          data[2] = (unsigned char)3;
        }
      } else {
#line 217
        data[2] = (unsigned char)2;
      }
#line 232
      if ((int )params.privilege_level & 128) {
#line 232
        tmp___6 = 128;
      } else {
#line 232
        tmp___6 = 0;
      }
#line 232
      data[2] = (unsigned char )((int )data[2] | tmp___6);
    } else {
      {
#line 238
      tmp___12 = strcmp(param, "bit-rate");
      }
#line 238
      if (tmp___12 == 0) {
        {
#line 240
        data[1] = (unsigned char)5;
#line 241
        tmp___11 = strncmp(value, "9.6", (size_t )3);
        }
#line 241
        if (tmp___11 == 0) {
#line 242
          data[2] = (unsigned char)6;
        } else {
          {
#line 244
          tmp___10 = strncmp(value, "19.2", (size_t )4);
          }
#line 244
          if (tmp___10 == 0) {
#line 245
            data[2] = (unsigned char)7;
          } else {
            {
#line 247
            tmp___9 = strncmp(value, "38.4", (size_t )4);
            }
#line 247
            if (tmp___9 == 0) {
#line 248
              data[2] = (unsigned char)8;
            } else {
              {
#line 250
              tmp___8 = strncmp(value, "57.6", (size_t )4);
              }
#line 250
              if (tmp___8 == 0) {
#line 251
                data[2] = (unsigned char)9;
              } else {
                {
#line 253
                tmp___7 = strncmp(value, "115.2", (size_t )5);
                }
#line 253
                if (tmp___7 == 0) {
#line 254
                  data[2] = (unsigned char)10;
                } else {
                  {
#line 257
                  lprintf(3, "ISOL - Unsupported baud rate: %s", value);
#line 258
                  lprintf(3, "Valid values are 9.6, 19.2, 38.4, 57.6 and 115.2");
                  }
#line 259
                  return (-1);
                }
              }
            }
          }
        }
      } else {
        {
#line 264
        lprintf(3, "Error: invalid ISOL parameter %s", param);
        }
#line 265
        return (-1);
      }
    }
  }
  {
#line 273
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 274
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 275
    lprintf(3, "Error setting ISOL parameter \'%s\'", param);
    }
#line 276
    return (-1);
  }
#line 278
  if ((int )rsp->ccode > 0) {
    {
#line 279
    tmp___15 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 279
    lprintf(3, "Error setting ISOL parameter \'%s\': %s", param, tmp___15);
    }
#line 281
    return (-1);
  }
#line 284
  return (0);
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static void leave_raw_mode(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 290
  if (! _in_raw_mode) {
#line 291
    return;
  }
  {
#line 292
  tmp = fileno(stdin);
#line 292
  tmp___0 = tcsetattr(tmp, 1, (struct termios  const  *)(& _saved_tio));
  }
#line 292
  if (tmp___0 == -1) {
    {
#line 293
    perror("tcsetattr");
    }
  } else {
#line 295
    _in_raw_mode = 0;
  }
#line 296
  return;
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static void enter_raw_mode(void) 
{ 
  struct termios tio ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 304
  tmp = fileno(stdin);
#line 304
  tmp___0 = tcgetattr(tmp, & tio);
  }
#line 304
  if (tmp___0 == -1) {
    {
#line 305
    perror("tcgetattr");
    }
#line 306
    return;
  }
  {
#line 308
  _saved_tio = tio;
#line 309
  tio.c_iflag |= 4U;
#line 310
  tio.c_iflag &= 4294959647U;
#line 312
  tio.c_lflag &= 4294967172U;
#line 314
  tio.c_lflag &= 4294934527U;
#line 316
  tio.c_oflag &= 4294967294U;
#line 317
  tio.c_cc[6] = (cc_t )1;
#line 318
  tio.c_cc[5] = (cc_t )0;
#line 319
  tmp___1 = fileno(stdin);
#line 319
  tmp___2 = tcsetattr(tmp___1, 1, (struct termios  const  *)(& tio));
  }
#line 319
  if (tmp___2 == -1) {
    {
#line 320
    perror("tcsetattr");
    }
  } else {
#line 322
    _in_raw_mode = 1;
  }
#line 323
  return;
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static void sendBreak(struct ipmi_intf *intf ) 
{ 
  struct ipmi_v2_payload v2_payload ;

  {
  {
#line 331
  memset((void *)(& v2_payload), 0, sizeof(v2_payload));
#line 333
  v2_payload.payload.sol_packet.character_count = (uint16_t )0;
#line 334
  v2_payload.payload.sol_packet.generate_break = (uint8_t )1;
#line 336
  (*(intf->send_sol))(intf, & v2_payload);
  }
#line 337
  return;
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static void suspendSelf(int bRestoreTty ) 
{ 
  __pid_t tmp ;

  {
  {
#line 350
  leave_raw_mode();
#line 351
  tmp = getpid();
#line 351
  kill(tmp, 20);
  }
#line 353
  if (bRestoreTty) {
    {
#line 354
    enter_raw_mode();
    }
  }
#line 355
  return;
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static void printiSolEscapeSequences(void) 
{ 


  {
  {
#line 367
  printf((char const   */* __restrict  */)"%c?\n\tSupported escape sequences:\n\t%c.  - terminate connection\n\t%c^Z - suspend ipmitool\n\t%c^X - suspend ipmitool, but don\'t restore tty on restart\n\t%cB  - send break\n\t%c?  - this message\n\t%c%c  - send the escape character by typing it twice\n\t(Note that escapes are only recognized immediately after newline.)\n",
         '~', '~', '~', '~', '~', '~', '~', '~');
  }
#line 385
  return;
}
}
#line 394 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static void output(struct ipmi_rs *rsp ) 
{ 
  int i ;

  {
#line 397
  if (rsp) {
#line 400
    i = 0;
    {
#line 400
    while (1) {
      while_continue: /* CIL Label */ ;
#line 400
      if (! (i < rsp->data_len)) {
#line 400
        goto while_break;
      }
      {
#line 401
      _IO_putc((int )rsp->data[i], stdout);
#line 400
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 403
    fflush(stdout);
    }
  }
#line 405
  return;
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static int ipmi_isol_deactivate(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t data[6] ;
  char const   *tmp ;

  {
  {
#line 418
  memset((void *)(& req), 0, sizeof(req));
#line 419
  req.msg.netfn = (uint8_t )52;
#line 420
  req.msg.cmd = (uint8_t )1;
#line 421
  req.msg.data = data;
#line 422
  req.msg.data_len = (uint16_t )5;
#line 424
  memset((void *)(data), 0, (size_t )6);
#line 425
  data[0] = (uint8_t )0;
#line 426
  data[1] = (uint8_t )0;
#line 427
  data[2] = (uint8_t )0;
#line 428
  data[3] = (uint8_t )0;
#line 429
  data[5] = (uint8_t )0;
#line 431
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 432
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 433
    lprintf(3, "Error deactivating ISOL");
    }
#line 434
    return (-1);
  }
#line 436
  if ((int )rsp->ccode > 0) {
    {
#line 437
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 437
    lprintf(3, "Error deactivating ISOL: %s", tmp);
    }
#line 439
    return (-1);
  }
#line 443
  return (0);
}
}
#line 461
static int processiSolUserInput(struct ipmi_intf *intf , uint8_t *input , uint16_t buffer_length ) ;
#line 461 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static int escape_pending  =    0;
#line 462 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static int last_was_cr  =    1;
#line 456 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static int processiSolUserInput(struct ipmi_intf *intf , uint8_t *input , uint16_t buffer_length ) 
{ 
  struct ipmi_v2_payload v2_payload ;
  int length ;
  int retval ;
  char ch ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct ipmi_rs *rsp ;

  {
  {
#line 464
  length = 0;
#line 465
  retval = 0;
#line 469
  memset((void *)(& v2_payload), 0, sizeof(v2_payload));
#line 475
  i = 0;
  }
  {
#line 475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 475
    if (! (i < (int )buffer_length)) {
#line 475
      goto while_break;
    }
#line 477
    ch = (char )*(input + i);
#line 479
    if (escape_pending) {
#line 480
      escape_pending = 0;
      {
#line 486
      if ((int )ch == 46) {
#line 486
        goto case_46;
      }
#line 490
      if ((int )ch == 26) {
#line 490
        goto case_26;
      }
#line 495
      if ((int )ch == 24) {
#line 495
        goto case_24;
      }
#line 500
      if ((int )ch == 66) {
#line 500
        goto case_66;
      }
#line 505
      if ((int )ch == 63) {
#line 505
        goto case_63;
      }
#line 508
      goto switch_default;
      case_46: /* CIL Label */ 
      {
#line 487
      printf((char const   */* __restrict  */)"%c. [terminated ipmitool]\n", '~');
#line 488
      retval = 1;
      }
#line 489
      goto switch_break;
      case_26: /* CIL Label */ 
      {
#line 491
      printf((char const   */* __restrict  */)"%c^Z [suspend ipmitool]\n", '~');
#line 492
      suspendSelf(1);
      }
#line 493
      goto __Cont;
      case_24: /* CIL Label */ 
      {
#line 496
      printf((char const   */* __restrict  */)"%c^X [suspend ipmitool]\n", '~');
#line 497
      suspendSelf(0);
      }
#line 498
      goto __Cont;
      case_66: /* CIL Label */ 
      {
#line 501
      printf((char const   */* __restrict  */)"%cb [send break]\n", '~');
#line 502
      sendBreak(intf);
      }
#line 503
      goto __Cont;
      case_63: /* CIL Label */ 
      {
#line 506
      printiSolEscapeSequences();
      }
#line 507
      goto __Cont;
      switch_default: /* CIL Label */ 
#line 509
      if ((int )ch != 126) {
#line 510
        tmp = length;
#line 510
        length ++;
#line 510
        v2_payload.payload.sol_packet.data[tmp] = (uint8_t )'~';
      }
#line 512
      tmp___0 = length;
#line 512
      length ++;
#line 512
      v2_payload.payload.sol_packet.data[tmp___0] = (uint8_t )ch;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 518
      if (last_was_cr) {
#line 518
        if ((int )ch == 126) {
#line 519
          escape_pending = 1;
#line 520
          goto __Cont;
        }
      }
#line 523
      tmp___1 = length;
#line 523
      length ++;
#line 523
      v2_payload.payload.sol_packet.data[tmp___1] = (uint8_t )ch;
    }
#line 530
    if ((int )ch == 13) {
#line 530
      tmp___2 = 1;
    } else
#line 530
    if ((int )ch == 10) {
#line 530
      tmp___2 = 1;
    } else {
#line 530
      tmp___2 = 0;
    }
#line 530
    last_was_cr = tmp___2;
    __Cont: /* CIL Label */ 
#line 475
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 538
  if (length) {
    {
#line 542
    v2_payload.payload.sol_packet.flush_outbound = (uint8_t )1;
#line 543
    v2_payload.payload.sol_packet.character_count = (uint16_t )length;
#line 544
    rsp = (*(intf->send_sol))(intf, & v2_payload);
    }
#line 546
    if (! rsp) {
      {
#line 547
      lprintf(3, "Error sending SOL data");
#line 548
      retval = -1;
      }
    } else
#line 552
    if ((int )rsp->session.payloadtype == 1) {
#line 552
      if (rsp->payload.sol_packet.packet_sequence_number) {
        {
#line 554
        output(rsp);
        }
      }
    }
  }
#line 556
  return (retval);
}
}
#line 562 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static int ipmi_isol_red_pill(struct ipmi_intf *intf ) 
{ 
  char *buffer ;
  int numRead ;
  int bShouldExit ;
  int bBmcClosedSession ;
  fd_set read_fds ;
  struct timeval tv ;
  int retval ;
  int buffer_size ;
  int timedout ;
  void *tmp ;
  int __d0 ;
  int __d1 ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int rc ;
  int tmp___2 ;
  struct ipmi_rs *rs ;
  struct ipmi_rs *tmp___3 ;

  {
  {
#line 567
  bShouldExit = 0;
#line 568
  bBmcClosedSession = 0;
#line 572
  buffer_size = 255;
#line 573
  timedout = 0;
#line 575
  tmp = malloc((size_t )buffer_size);
#line 575
  buffer = (char *)tmp;
  }
#line 576
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 577
    lprintf(3, "ipmitool: malloc failure");
    }
#line 578
    return (-1);
  }
  {
#line 581
  enter_raw_mode();
  }
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;
#line 583
    if (! (! bShouldExit)) {
#line 583
      goto while_break;
    }
    {
#line 585
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 585
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& read_fds.__fds_bits[0]): "memory");
#line 585
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 586
    read_fds.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 587
    read_fds.__fds_bits[intf->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << intf->fd % (8 * (int )sizeof(__fd_mask ));
#line 590
    tv.tv_sec = (__time_t )0;
#line 591
    tv.tv_usec = (__suseconds_t )500000;
#line 593
    retval = select(intf->fd + 1, (fd_set */* __restrict  */)(& read_fds), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 595
    if (retval) {
#line 597
      if (retval == -1) {
        {
#line 600
        perror("select");
        }
#line 601
        return (-1);
      }
#line 604
      timedout = 0;
#line 609
      if ((read_fds.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] & (1L << 0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 611
        memset((void *)buffer, 0, (size_t )buffer_size);
#line 612
        tmp___0 = fileno(stdin);
#line 612
        tmp___1 = read(tmp___0, (void *)buffer, (size_t )buffer_size);
#line 612
        numRead = (int )tmp___1;
        }
#line 616
        if (numRead > 0) {
          {
#line 618
          tmp___2 = processiSolUserInput(intf, (uint8_t *)buffer, (uint16_t )numRead);
#line 618
          rc = tmp___2;
          }
#line 620
          if (rc) {
#line 622
            if (rc < 0) {
#line 623
              bBmcClosedSession = 1;
#line 623
              bShouldExit = bBmcClosedSession;
            } else {
#line 625
              bShouldExit = 1;
            }
          }
        } else {
#line 630
          bShouldExit = 1;
        }
      } else
#line 638
      if ((read_fds.__fds_bits[intf->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << intf->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 640
        tmp___3 = (*(intf->recv_sol))(intf);
#line 640
        rs = tmp___3;
        }
#line 641
        if (! rs) {
#line 643
          bBmcClosedSession = 1;
#line 643
          bShouldExit = bBmcClosedSession;
        } else {
          {
#line 646
          output(rs);
          }
        }
      } else {
        {
#line 655
        lprintf(3, "Error: Select returned with nothing to read");
#line 656
        bShouldExit = 1;
        }
      }
    } else {
#line 661
      timedout ++;
#line 661
      if (timedout == 20) {
        {
#line 663
        (*(intf->keepalive))(intf);
#line 664
        timedout = 0;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 669
  leave_raw_mode();
  }
#line 671
  if (bBmcClosedSession) {
    {
#line 673
    lprintf(3, "SOL session closed by BMC");
    }
  } else {
    {
#line 676
    ipmi_isol_deactivate(intf);
    }
  }
#line 678
  return (0);
}
}
#line 684 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static int ipmi_isol_activate(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t data[6] ;
  struct isol_config_parameters params ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 692
  tmp = ipmi_get_isol_info(intf, & params);
  }
#line 692
  if (tmp) {
#line 693
    return (-1);
  }
#line 695
  if (! ((int )params.enabled & 1)) {
    {
#line 696
    lprintf(3, "ISOL is not enabled!");
    }
#line 697
    return (-1);
  }
  {
#line 705
  (intf->session)->sol_data.sol_input_handler = & output;
#line 707
  memset((void *)(& req), 0, sizeof(req));
#line 708
  req.msg.netfn = (uint8_t )52;
#line 709
  req.msg.cmd = (uint8_t )1;
#line 710
  req.msg.data = data;
#line 711
  req.msg.data_len = (uint16_t )5;
#line 713
  memset((void *)(data), 0, (size_t )6);
#line 714
  data[0] = (uint8_t )1;
#line 715
  data[1] = (uint8_t )0;
#line 716
  data[2] = (uint8_t )0;
#line 717
  data[3] = (uint8_t )0;
#line 718
  data[5] = (uint8_t )0;
#line 720
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 721
  if ((unsigned long )((void *)0) != (unsigned long )rsp) {
    {
#line 723
    if ((int )rsp->ccode == 0) {
#line 723
      goto case_0;
    }
#line 733
    if ((int )rsp->ccode == 128) {
#line 733
      goto case_128;
    }
#line 736
    if ((int )rsp->ccode == 129) {
#line 736
      goto case_129;
    }
#line 739
    if ((int )rsp->ccode == 130) {
#line 739
      goto case_130;
    }
#line 742
    goto switch_default;
    case_0: /* CIL Label */ 
#line 724
    if (rsp->data_len == 4) {
#line 725
      goto switch_break;
    } else {
      {
#line 727
      lprintf(3, "Error: Unexpected data length (%d) received in ISOL activation response",
              rsp->data_len);
      }
#line 730
      return (-1);
    }
#line 732
    goto switch_break;
    case_128: /* CIL Label */ 
    {
#line 734
    lprintf(3, "Info: ISOL already active on another session");
    }
#line 735
    return (-1);
    case_129: /* CIL Label */ 
    {
#line 737
    lprintf(3, "Info: ISOL disabled");
    }
#line 738
    return (-1);
    case_130: /* CIL Label */ 
    {
#line 740
    lprintf(3, "Info: ISOL activation limit reached");
    }
#line 741
    return (-1);
    switch_default: /* CIL Label */ 
    {
#line 743
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 743
    lprintf(3, "Error activating ISOL: %s", tmp___0);
    }
#line 745
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 748
    lprintf(3, "Error: No response activating ISOL");
    }
#line 749
    return (-1);
  }
  {
#line 755
  printf((char const   */* __restrict  */)"[SOL Session operational.  Use %c? for help]\n",
         '~');
#line 764
  tmp___1 = ipmi_isol_red_pill(intf);
  }
#line 764
  if (tmp___1) {
    {
#line 765
    lprintf(3, "Error in SOL session");
    }
#line 766
    return (-1);
  }
#line 769
  return (0);
}
}
#line 772 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static void print_isol_set_usage(void) 
{ 


  {
  {
#line 773
  lprintf(5, "\nISOL set parameters and values: \n");
#line 774
  lprintf(5, "  enabled                     true | false");
#line 775
  lprintf(5, "  privilege-level             user | operator | admin | oem");
#line 776
  lprintf(5, "  bit-rate                    9.6 | 19.2 | 38.4 | 57.6 | 115.2");
#line 778
  lprintf(5, "");
  }
#line 779
  return;
}
}
#line 781 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static void print_isol_usage(void) 
{ 


  {
  {
#line 782
  lprintf(5, "ISOL Commands: info");
#line 783
  lprintf(5, "               set <parameter> <setting>");
#line 784
  lprintf(5, "               activate");
  }
#line 785
  return;
}
}
#line 787 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
int ipmi_isol_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 789
  ret = 0;
#line 794
  if (! argc) {
    {
#line 795
    print_isol_usage();
    }
  } else {
    {
#line 794
    tmp___2 = strncmp((char const   *)*(argv + 0), "help", (size_t )4);
    }
#line 794
    if (tmp___2) {
      {
#line 800
      tmp___1 = strncmp((char const   *)*(argv + 0), "info", (size_t )4);
      }
#line 800
      if (tmp___1) {
        {
#line 807
        tmp___0 = strncmp((char const   *)*(argv + 0), "set", (size_t )3);
        }
#line 807
        if (tmp___0) {
          {
#line 818
          tmp = strncmp((char const   *)*(argv + 0), "activate", (size_t )8);
          }
#line 818
          if (tmp) {
            {
#line 823
            print_isol_usage();
#line 824
            ret = -1;
            }
          } else {
            {
#line 819
            ret = ipmi_isol_activate(intf);
            }
          }
        } else {
#line 808
          if (argc < 3) {
            {
#line 809
            print_isol_set_usage();
            }
#line 810
            return (-1);
          }
          {
#line 812
          ret = ipmi_isol_set_param(intf, (char const   *)*(argv + 1), (char const   *)*(argv + 2));
          }
        }
      } else {
        {
#line 801
        ret = ipmi_print_isol_info(intf);
        }
      }
    } else {
      {
#line 795
      print_isol_usage();
      }
    }
  }
#line 827
  return (ret);
}
}
#line 359 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2,3), __leaf__)) strtok_r)(char * __restrict  __s ,
                                                                                                   char const   * __restrict  __delim ,
                                                                                                   char ** __restrict  __save_ptr ) ;
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 50 "../include/ipmitool/ipmi_strings.h"
extern struct valstr  const  ipmi_chassis_power_control_vals[] ;
#line 50 "../include/ipmitool/ipmi_chassis.h"
int ipmi_chassis_power_status(struct ipmi_intf *intf ) ;
#line 51
int ipmi_chassis_power_control(struct ipmi_intf *intf , uint8_t ctl ) ;
#line 52
int ipmi_chassis_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 53
int ipmi_power_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
int ipmi_chassis_power_status(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;

  {
  {
#line 54
  memset((void *)(& req), 0, sizeof(req));
#line 55
  req.msg.netfn = (uint8_t )0;
#line 56
  req.msg.cmd = (uint8_t )1;
#line 57
  req.msg.data_len = (uint16_t )0;
#line 59
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 60
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 61
    lprintf(3, "Unable to get Chassis Power Status");
    }
#line 62
    return (-1);
  }
#line 64
  if ((int )rsp->ccode > 0) {
    {
#line 65
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 65
    lprintf(3, "Get Chassis Power Status failed: %s", tmp);
    }
#line 67
    return (-1);
  }
#line 70
  return ((int )rsp->data[0] & 1);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
static int ipmi_chassis_print_power_status(struct ipmi_intf *intf ) 
{ 
  int ps ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 76
  tmp = ipmi_chassis_power_status(intf);
#line 76
  ps = tmp;
  }
#line 78
  if (ps < 0) {
#line 79
    return (-1);
  }
#line 81
  if (ps) {
#line 81
    tmp___0 = "on";
  } else {
#line 81
    tmp___0 = "off";
  }
  {
#line 81
  printf((char const   */* __restrict  */)"Chassis Power is %s\n", tmp___0);
  }
#line 83
  return (0);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
int ipmi_chassis_power_control(struct ipmi_intf *intf , uint8_t ctl ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 92
  memset((void *)(& req), 0, sizeof(req));
#line 93
  req.msg.netfn = (uint8_t )0;
#line 94
  req.msg.cmd = (uint8_t )2;
#line 95
  req.msg.data = & ctl;
#line 96
  req.msg.data_len = (uint16_t )1;
#line 98
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 99
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 100
    tmp = val2str((uint16_t )ctl, ipmi_chassis_power_control_vals);
#line 100
    lprintf(3, "Unable to set Chassis Power Control to %s", tmp);
    }
#line 102
    return (-1);
  }
#line 104
  if ((int )rsp->ccode > 0) {
    {
#line 105
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 105
    tmp___1 = val2str((uint16_t )ctl, ipmi_chassis_power_control_vals);
#line 105
    lprintf(3, "Set Chassis Power Control to %s failed: %s", tmp___1, tmp___0);
    }
#line 108
    return (-1);
  }
  {
#line 111
  tmp___2 = val2str((uint16_t )ctl, ipmi_chassis_power_control_vals);
#line 111
  printf((char const   */* __restrict  */)"Chassis Power Control: %s\n", tmp___2);
  }
#line 119
  return (0);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
static int ipmi_chassis_identify(struct ipmi_intf *intf , char *arg ) 
{ 
  struct ipmi_rq req ;
  struct ipmi_rs *rsp ;
  int rc ;
  struct __anonstruct_identify_data_53 identify_data ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 127
  rc = -3;
#line 129
  identify_data.interval = (uint8_t )0;
#line 129
  identify_data.force_on = (uint8_t )0;
#line 134
  memset((void *)(& req), 0, sizeof(req));
#line 135
  req.msg.netfn = (uint8_t )0;
#line 136
  req.msg.cmd = (uint8_t )4;
  }
#line 138
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
    {
#line 139
    tmp = strncmp((char const   *)arg, "force", (size_t )5);
    }
#line 139
    if (tmp == 0) {
#line 140
      identify_data.force_on = (uint8_t )1;
    } else {
      {
#line 142
      rc = str2uchar((char const   *)arg, & identify_data.interval);
      }
#line 142
      if (rc != 0) {
#line 143
        if (rc == -2) {
          {
#line 144
          lprintf(3, "Invalid interval given.");
          }
        } else {
          {
#line 146
          lprintf(3, "Given interval is too big.");
          }
        }
#line 148
        return (-1);
      }
    }
#line 151
    req.msg.data = (uint8_t *)(& identify_data);
#line 157
    if (identify_data.force_on) {
#line 157
      req.msg.data_len = (uint16_t )2;
    } else {
#line 157
      req.msg.data_len = (uint16_t )1;
    }
  }
  {
#line 160
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 161
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 162
    lprintf(3, "Unable to set Chassis Identify");
    }
#line 163
    return (-1);
  }
#line 165
  if ((int )rsp->ccode > 0) {
    {
#line 166
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 166
    lprintf(3, "Set Chassis Identify failed: %s", tmp___0);
    }
#line 168
    if ((int )identify_data.force_on != 0) {
      {
#line 173
      lprintf(4, "Chassis may not support Force Identify On\n");
      }
    }
#line 175
    return (-1);
  }
  {
#line 178
  printf((char const   */* __restrict  */)"Chassis identify interval: ");
  }
#line 179
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    {
#line 180
    printf((char const   */* __restrict  */)"default (15 seconds)\n");
    }
  } else
#line 182
  if ((int )identify_data.force_on != 0) {
    {
#line 183
    printf((char const   */* __restrict  */)"indefinite\n");
    }
  } else
#line 185
  if ((int )identify_data.interval == 0) {
    {
#line 186
    printf((char const   */* __restrict  */)"off\n");
    }
  } else {
    {
#line 188
    printf((char const   */* __restrict  */)"%i seconds\n", (int )identify_data.interval);
    }
  }
#line 191
  return (0);
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
static int ipmi_chassis_poh(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t mins_per_count ;
  uint32_t count ;
  float minutes ;
  uint32_t days ;
  uint32_t hours ;
  char const   *tmp ;

  {
  {
#line 204
  memset((void *)(& req), 0, sizeof(req));
#line 205
  req.msg.netfn = (uint8_t )0;
#line 206
  req.msg.cmd = (uint8_t )15;
#line 208
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 209
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 210
    lprintf(3, "Unable to get Chassis Power-On-Hours");
    }
#line 211
    return (-1);
  }
#line 213
  if ((int )rsp->ccode > 0) {
    {
#line 214
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 214
    lprintf(3, "Get Chassis Power-On-Hours failed: %s", tmp);
    }
#line 216
    return (-1);
  }
  {
#line 219
  mins_per_count = rsp->data[0];
#line 220
  memcpy((void */* __restrict  */)(& count), (void const   */* __restrict  */)(rsp->data + 1),
         (size_t )4);
#line 225
  minutes = (float )count * (float )mins_per_count;
#line 226
  days = (uint32_t )(minutes / (float )1440);
#line 227
  minutes -= (float )days * (float )1440;
#line 228
  hours = (uint32_t )(minutes / (float )60);
#line 229
  minutes -= (float )(hours * 60U);
  }
#line 231
  if ((int )mins_per_count < 60) {
    {
#line 232
    printf((char const   */* __restrict  */)"POH Counter  : %i days, %i hours, %li minutes\n",
           days, hours, (long )minutes);
    }
  } else {
    {
#line 235
    printf((char const   */* __restrict  */)"POH Counter  : %i days, %i hours\n",
           days, hours);
    }
  }
#line 238
  return (0);
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
static int ipmi_chassis_restart_cause(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;

  {
  {
#line 247
  memset((void *)(& req), 0, sizeof(req));
#line 248
  req.msg.netfn = (uint8_t )0;
#line 249
  req.msg.cmd = (uint8_t )7;
#line 251
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 252
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 253
    lprintf(3, "Unable to get Chassis Restart Cause");
    }
#line 254
    return (-1);
  }
#line 256
  if ((int )rsp->ccode > 0) {
    {
#line 257
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 257
    lprintf(3, "Get Chassis Restart Cause failed: %s", tmp);
    }
#line 259
    return (-1);
  }
  {
#line 262
  printf((char const   */* __restrict  */)"System restart cause: ");
  }
  {
#line 265
  if (((int )rsp->data[0] & 15) == 0) {
#line 265
    goto case_0;
  }
#line 268
  if (((int )rsp->data[0] & 15) == 1) {
#line 268
    goto case_1;
  }
#line 271
  if (((int )rsp->data[0] & 15) == 2) {
#line 271
    goto case_2;
  }
#line 274
  if (((int )rsp->data[0] & 15) == 3) {
#line 274
    goto case_3;
  }
#line 277
  if (((int )rsp->data[0] & 15) == 4) {
#line 277
    goto case_4;
  }
#line 280
  if (((int )rsp->data[0] & 15) == 5) {
#line 280
    goto case_5;
  }
#line 283
  if (((int )rsp->data[0] & 15) == 6) {
#line 283
    goto case_6;
  }
#line 286
  if (((int )rsp->data[0] & 15) == 7) {
#line 286
    goto case_7;
  }
#line 289
  if (((int )rsp->data[0] & 15) == 8) {
#line 289
    goto case_8;
  }
#line 292
  if (((int )rsp->data[0] & 15) == 9) {
#line 292
    goto case_9;
  }
#line 295
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 266
  printf((char const   */* __restrict  */)"unknown\n");
  }
#line 267
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 269
  printf((char const   */* __restrict  */)"chassis power control command\n");
  }
#line 270
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 272
  printf((char const   */* __restrict  */)"reset via pushbutton\n");
  }
#line 273
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 275
  printf((char const   */* __restrict  */)"power-up via pushbutton\n");
  }
#line 276
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 278
  printf((char const   */* __restrict  */)"watchdog expired\n");
  }
#line 279
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 281
  printf((char const   */* __restrict  */)"OEM\n");
  }
#line 282
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 284
  printf((char const   */* __restrict  */)"power-up due to always-restore power policy\n");
  }
#line 285
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 287
  printf((char const   */* __restrict  */)"power-up due to restore-previous power policy\n");
  }
#line 288
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 290
  printf((char const   */* __restrict  */)"reset via PEF\n");
  }
#line 291
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 293
  printf((char const   */* __restrict  */)"power-cycle via PEF\n");
  }
#line 294
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 296
  printf((char const   */* __restrict  */)"invalid\n");
  }
  switch_break: /* CIL Label */ ;
  }
#line 299
  return (0);
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
int ipmi_chassis_status(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;

  {
  {
#line 308
  memset((void *)(& req), 0, sizeof(req));
#line 309
  req.msg.netfn = (uint8_t )0;
#line 310
  req.msg.cmd = (uint8_t )1;
#line 312
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 313
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 314
    lprintf(3, "Error sending Chassis Status command");
    }
#line 315
    return (-1);
  }
#line 317
  if ((int )rsp->ccode > 0) {
    {
#line 318
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 318
    lprintf(3, "Error sending Chassis Status command: %s", tmp);
    }
#line 320
    return (-1);
  }
#line 324
  if ((int )rsp->data[0] & 1) {
#line 324
    tmp___0 = "on";
  } else {
#line 324
    tmp___0 = "off";
  }
  {
#line 324
  printf((char const   */* __restrict  */)"System Power         : %s\n", tmp___0);
  }
#line 325
  if ((int )rsp->data[0] & 2) {
#line 325
    tmp___1 = "true";
  } else {
#line 325
    tmp___1 = "false";
  }
  {
#line 325
  printf((char const   */* __restrict  */)"Power Overload       : %s\n", tmp___1);
  }
#line 326
  if ((int )rsp->data[0] & 4) {
#line 326
    tmp___2 = "active";
  } else {
#line 326
    tmp___2 = "inactive";
  }
  {
#line 326
  printf((char const   */* __restrict  */)"Power Interlock      : %s\n", tmp___2);
  }
#line 327
  if ((int )rsp->data[0] & 8) {
#line 327
    tmp___3 = "true";
  } else {
#line 327
    tmp___3 = "false";
  }
  {
#line 327
  printf((char const   */* __restrict  */)"Main Power Fault     : %s\n", tmp___3);
  }
#line 328
  if ((int )rsp->data[0] & 16) {
#line 328
    tmp___4 = "true";
  } else {
#line 328
    tmp___4 = "false";
  }
  {
#line 328
  printf((char const   */* __restrict  */)"Power Control Fault  : %s\n", tmp___4);
#line 329
  printf((char const   */* __restrict  */)"Power Restore Policy : ");
  }
  {
#line 331
  if (((int )rsp->data[0] & 96) >> 5 == 0) {
#line 331
    goto case_0;
  }
#line 334
  if (((int )rsp->data[0] & 96) >> 5 == 1) {
#line 334
    goto case_1;
  }
#line 337
  if (((int )rsp->data[0] & 96) >> 5 == 2) {
#line 337
    goto case_2;
  }
#line 341
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 332
  printf((char const   */* __restrict  */)"always-off\n");
  }
#line 333
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 335
  printf((char const   */* __restrict  */)"previous\n");
  }
#line 336
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 338
  printf((char const   */* __restrict  */)"always-on\n");
  }
#line 339
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 342
  printf((char const   */* __restrict  */)"unknown\n");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 346
  printf((char const   */* __restrict  */)"Last Power Event     : ");
  }
#line 347
  if ((int )rsp->data[1] & 1) {
    {
#line 348
    printf((char const   */* __restrict  */)"ac-failed ");
    }
  }
#line 349
  if ((int )rsp->data[1] & 2) {
    {
#line 350
    printf((char const   */* __restrict  */)"overload ");
    }
  }
#line 351
  if ((int )rsp->data[1] & 4) {
    {
#line 352
    printf((char const   */* __restrict  */)"interlock ");
    }
  }
#line 353
  if ((int )rsp->data[1] & 8) {
    {
#line 354
    printf((char const   */* __restrict  */)"fault ");
    }
  }
#line 355
  if ((int )rsp->data[1] & 16) {
    {
#line 356
    printf((char const   */* __restrict  */)"command");
    }
  }
  {
#line 357
  printf((char const   */* __restrict  */)"\n");
  }
#line 360
  if ((int )rsp->data[2] & 1) {
#line 360
    tmp___5 = "active";
  } else {
#line 360
    tmp___5 = "inactive";
  }
  {
#line 360
  printf((char const   */* __restrict  */)"Chassis Intrusion    : %s\n", tmp___5);
  }
#line 361
  if ((int )rsp->data[2] & 2) {
#line 361
    tmp___6 = "active";
  } else {
#line 361
    tmp___6 = "inactive";
  }
  {
#line 361
  printf((char const   */* __restrict  */)"Front-Panel Lockout  : %s\n", tmp___6);
  }
#line 362
  if ((int )rsp->data[2] & 4) {
#line 362
    tmp___7 = "true";
  } else {
#line 362
    tmp___7 = "false";
  }
  {
#line 362
  printf((char const   */* __restrict  */)"Drive Fault          : %s\n", tmp___7);
  }
#line 363
  if ((int )rsp->data[2] & 8) {
#line 363
    tmp___8 = "true";
  } else {
#line 363
    tmp___8 = "false";
  }
  {
#line 363
  printf((char const   */* __restrict  */)"Cooling/Fan Fault    : %s\n", tmp___8);
  }
#line 365
  if (rsp->data_len > 3) {
#line 367
    if ((int )rsp->data[3] == 0) {
      {
#line 368
      printf((char const   */* __restrict  */)"Front Panel Control  : none\n");
      }
    } else {
#line 370
      if ((int )rsp->data[3] & 128) {
#line 370
        tmp___9 = "allowed";
      } else {
#line 370
        tmp___9 = "not allowed";
      }
      {
#line 370
      printf((char const   */* __restrict  */)"Sleep Button Disable : %s\n", tmp___9);
      }
#line 371
      if ((int )rsp->data[3] & 64) {
#line 371
        tmp___10 = "allowed";
      } else {
#line 371
        tmp___10 = "not allowed";
      }
      {
#line 371
      printf((char const   */* __restrict  */)"Diag Button Disable  : %s\n", tmp___10);
      }
#line 372
      if ((int )rsp->data[3] & 32) {
#line 372
        tmp___11 = "allowed";
      } else {
#line 372
        tmp___11 = "not allowed";
      }
      {
#line 372
      printf((char const   */* __restrict  */)"Reset Button Disable : %s\n", tmp___11);
      }
#line 373
      if ((int )rsp->data[3] & 16) {
#line 373
        tmp___12 = "allowed";
      } else {
#line 373
        tmp___12 = "not allowed";
      }
      {
#line 373
      printf((char const   */* __restrict  */)"Power Button Disable : %s\n", tmp___12);
      }
#line 374
      if ((int )rsp->data[3] & 8) {
#line 374
        tmp___13 = "true";
      } else {
#line 374
        tmp___13 = "false";
      }
      {
#line 374
      printf((char const   */* __restrict  */)"Sleep Button Disabled: %s\n", tmp___13);
      }
#line 375
      if ((int )rsp->data[3] & 4) {
#line 375
        tmp___14 = "true";
      } else {
#line 375
        tmp___14 = "false";
      }
      {
#line 375
      printf((char const   */* __restrict  */)"Diag Button Disabled : %s\n", tmp___14);
      }
#line 376
      if ((int )rsp->data[3] & 2) {
#line 376
        tmp___15 = "true";
      } else {
#line 376
        tmp___15 = "false";
      }
      {
#line 376
      printf((char const   */* __restrict  */)"Reset Button Disabled: %s\n", tmp___15);
      }
#line 377
      if ((int )rsp->data[3] & 1) {
#line 377
        tmp___16 = "true";
      } else {
#line 377
        tmp___16 = "false";
      }
      {
#line 377
      printf((char const   */* __restrict  */)"Power Button Disabled: %s\n", tmp___16);
      }
    }
  }
#line 381
  return (0);
}
}
#line 385 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
static int ipmi_chassis_selftest(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;
  int i ;
  struct valstr broken_dev_vals[9] ;
  char const   *tmp___0 ;

  {
  {
#line 391
  memset((void *)(& req), 0, sizeof(req));
#line 392
  req.msg.netfn = (uint8_t )6;
#line 393
  req.msg.cmd = (uint8_t )4;
#line 395
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 396
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 397
    lprintf(3, "Error sending Get Self Test command");
    }
#line 398
    return (-1);
  }
#line 400
  if ((int )rsp->ccode > 0) {
    {
#line 401
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 401
    lprintf(3, "Error sending Get Self Test command: %s", tmp);
    }
#line 403
    return (-1);
  }
  {
#line 406
  printf((char const   */* __restrict  */)"Self Test Results    : ");
  }
  {
#line 408
  if ((int )rsp->data[0] == 85) {
#line 408
    goto case_85;
  }
#line 412
  if ((int )rsp->data[0] == 86) {
#line 412
    goto case_86;
  }
#line 416
  if ((int )rsp->data[0] == 87) {
#line 416
    goto case_87;
  }
#line 440
  if ((int )rsp->data[0] == 88) {
#line 440
    goto case_88;
  }
#line 444
  goto switch_default;
  case_85: /* CIL Label */ 
  {
#line 409
  printf((char const   */* __restrict  */)"passed\n");
  }
#line 410
  goto switch_break;
  case_86: /* CIL Label */ 
  {
#line 413
  printf((char const   */* __restrict  */)"not implemented\n");
  }
#line 414
  goto switch_break;
  case_87: /* CIL Label */ 
  {
#line 419
  broken_dev_vals[0].val = (uint16_t )0;
#line 419
  broken_dev_vals[0].str = "firmware corrupted";
#line 419
  broken_dev_vals[1].val = (uint16_t )1;
#line 419
  broken_dev_vals[1].str = "boot block corrupted";
#line 419
  broken_dev_vals[2].val = (uint16_t )2;
#line 419
  broken_dev_vals[2].str = "FRU Internal Use Area corrupted";
#line 419
  broken_dev_vals[3].val = (uint16_t )3;
#line 419
  broken_dev_vals[3].str = "SDR Repository empty";
#line 419
  broken_dev_vals[4].val = (uint16_t )4;
#line 419
  broken_dev_vals[4].str = "IPMB not responding";
#line 419
  broken_dev_vals[5].val = (uint16_t )5;
#line 419
  broken_dev_vals[5].str = "cannot access BMC FRU";
#line 419
  broken_dev_vals[6].val = (uint16_t )6;
#line 419
  broken_dev_vals[6].str = "cannot access SDR Repository";
#line 419
  broken_dev_vals[7].val = (uint16_t )7;
#line 419
  broken_dev_vals[7].str = "cannot access SEL Device";
#line 419
  broken_dev_vals[8].val = (uint16_t )255;
#line 419
  broken_dev_vals[8].str = (char const   *)((void *)0);
#line 430
  printf((char const   */* __restrict  */)"device error\n");
#line 431
  i = 0;
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! (i < 8)) {
#line 431
      goto while_break;
    }
#line 432
    if ((int )rsp->data[1] & (1 << i)) {
      {
#line 433
      tmp___0 = val2str((uint16_t )i, (struct valstr  const  *)(broken_dev_vals));
#line 433
      printf((char const   */* __restrict  */)"                       [%s]\n", tmp___0);
      }
    }
#line 431
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 438
  goto switch_break;
  case_88: /* CIL Label */ 
  {
#line 441
  printf((char const   */* __restrict  */)"Fatal hardware error: %02xh\n", (int )rsp->data[1]);
  }
#line 442
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 445
  printf((char const   */* __restrict  */)"Device-specific failure %02xh:%02xh\n",
         (int )rsp->data[0], (int )rsp->data[1]);
  }
#line 447
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 450
  return (0);
}
}
#line 453 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
static int ipmi_chassis_set_bootparam(struct ipmi_intf *intf , uint8_t param , uint8_t *data ,
                                      int len ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[16] ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 460
  memset((void *)(msg_data), 0, (size_t )16);
#line 461
  msg_data[0] = (uint8_t )((int )param & 127);
#line 462
  memcpy((void */* __restrict  */)(msg_data + 1), (void const   */* __restrict  */)data,
         (size_t )len);
#line 464
  memset((void *)(& req), 0, sizeof(req));
#line 465
  req.msg.netfn = (uint8_t )0;
#line 466
  req.msg.cmd = (uint8_t )8;
#line 467
  req.msg.data = msg_data;
#line 468
  req.msg.data_len = (uint16_t )(len + 1);
#line 470
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 471
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 472
    lprintf(3, "Error setting Chassis Boot Parameter %d", (int )param);
    }
#line 473
    return (-1);
  }
#line 475
  if ((int )rsp->ccode > 0) {
#line 476
    if ((int )param != 0) {
      {
#line 477
      tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 477
      lprintf(3, "Set Chassis Boot Parameter %d failed: %s", (int )param, tmp);
      }
    }
#line 480
    return (-1);
  }
  {
#line 483
  tmp___0 = buf2str(data, len);
#line 483
  lprintf(7, "Chassis Set Boot Parameter %d to %s", (int )param, tmp___0);
  }
#line 484
  return (0);
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
static int ipmi_chassis_get_bootparam(struct ipmi_intf *intf , char *arg ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[3] ;
  uint8_t param_id ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  unsigned long session_id ;
  unsigned long timestamp ;
  char time_buf[40] ;
  time_t out_time ;
  struct tm *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 493
  param_id = (uint8_t )0;
#line 495
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 496
    return (-1);
  }
  {
#line 498
  tmp = str2uchar((char const   *)arg, & param_id);
  }
#line 498
  if (tmp != 0) {
    {
#line 499
    lprintf(3, "Invalid parameter \'%s\' given instead of bootparam.", arg);
    }
#line 501
    return (-1);
  }
  {
#line 504
  memset((void *)(msg_data), 0, (size_t )3);
#line 506
  msg_data[0] = (uint8_t )((int )param_id & 127);
#line 507
  msg_data[1] = (uint8_t )0;
#line 508
  msg_data[2] = (uint8_t )0;
#line 510
  memset((void *)(& req), 0, sizeof(req));
#line 511
  req.msg.netfn = (uint8_t )0;
#line 512
  req.msg.cmd = (uint8_t )9;
#line 513
  req.msg.data = msg_data;
#line 514
  req.msg.data_len = (uint16_t )3;
#line 516
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 517
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 518
    lprintf(3, "Error Getting Chassis Boot Parameter %s", arg);
    }
#line 519
    return (-1);
  }
#line 521
  if ((int )rsp->ccode > 0) {
    {
#line 522
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 522
    lprintf(3, "Get Chassis Boot Parameter %s failed: %s", arg, tmp___0);
    }
#line 524
    return (-1);
  }
#line 527
  if (verbose > 2) {
    {
#line 528
    printbuf((uint8_t const   *)(rsp->data), rsp->data_len, "Boot Option");
    }
  }
  {
#line 530
  param_id = (uint8_t )0;
#line 531
  param_id = (uint8_t )((int )rsp->data[1] & 127);
#line 533
  printf((char const   */* __restrict  */)"Boot parameter version: %d\n", (int )rsp->data[0]);
  }
#line 534
  if ((int )rsp->data[1] & 128) {
#line 534
    tmp___1 = "invalid/locked";
  } else {
#line 534
    tmp___1 = "valid/unlocked";
  }
  {
#line 534
  printf((char const   */* __restrict  */)"Boot parameter %d is %s\n", (int )rsp->data[1] & 127,
         tmp___1);
#line 536
  tmp___2 = buf2str(rsp->data + 2, rsp->data_len - 2);
#line 536
  printf((char const   */* __restrict  */)"Boot parameter data: %s\n", tmp___2);
  }
  {
#line 540
  if ((int )param_id == 0) {
#line 540
    goto case_0;
  }
#line 552
  if ((int )param_id == 1) {
#line 552
    goto case_1___0;
  }
#line 565
  if ((int )param_id == 2) {
#line 565
    goto case_2___0;
  }
#line 581
  if ((int )param_id == 3) {
#line 581
    goto case_3;
  }
#line 603
  if ((int )param_id == 4) {
#line 603
    goto case_4;
  }
#line 625
  if ((int )param_id == 5) {
#line 625
    goto case_5;
  }
#line 705
  if ((int )param_id == 6) {
#line 705
    goto case_6___0;
  }
#line 743
  if ((int )param_id == 7) {
#line 743
    goto case_7;
  }
#line 749
  goto switch_default___4;
  case_0: /* CIL Label */ 
  {
#line 542
  printf((char const   */* __restrict  */)" Set In Progress : ");
  }
  {
#line 545
  if (((int )rsp->data[2] & 3) == 0) {
#line 545
    goto case_0___0;
  }
#line 546
  if (((int )rsp->data[2] & 3) == 1) {
#line 546
    goto case_1;
  }
#line 547
  if (((int )rsp->data[2] & 3) == 2) {
#line 547
    goto case_2;
  }
#line 548
  goto switch_default;
  case_0___0: /* CIL Label */ 
  {
#line 545
  printf((char const   */* __restrict  */)"set complete\n");
  }
#line 545
  goto switch_break___0;
  case_1: /* CIL Label */ 
  {
#line 546
  printf((char const   */* __restrict  */)"set in progress\n");
  }
#line 546
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 547
  printf((char const   */* __restrict  */)"commit write\n");
  }
#line 547
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 548
  printf((char const   */* __restrict  */)"error, reserved bit\n");
  }
#line 548
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 551
  goto switch_break;
  case_1___0: /* CIL Label */ 
  {
#line 554
  printf((char const   */* __restrict  */)" Service Partition Selector : ");
  }
#line 555
  if ((int )rsp->data[2] == 0) {
    {
#line 557
    printf((char const   */* __restrict  */)"unspecified\n");
    }
  } else {
    {
#line 561
    printf((char const   */* __restrict  */)"%d\n", (int )rsp->data[2]);
    }
  }
#line 564
  goto switch_break;
  case_2___0: /* CIL Label */ 
  {
#line 567
  printf((char const   */* __restrict  */)" Service Partition Scan :\n");
  }
#line 568
  if (((int )rsp->data[2] & 3) != 0) {
#line 570
    if (((int )rsp->data[2] & 1) == 1) {
      {
#line 571
      printf((char const   */* __restrict  */)"     - Request BIOS to scan\n");
      }
    }
#line 572
    if (((int )rsp->data[2] & 2) == 2) {
      {
#line 573
      printf((char const   */* __restrict  */)"     - Service Partition Discovered\n");
      }
    }
  } else {
    {
#line 577
    printf((char const   */* __restrict  */)"     No flag set\n");
    }
  }
#line 580
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 583
  printf((char const   */* __restrict  */)" BMC boot flag valid bit clearing :\n");
  }
#line 584
  if (((int )rsp->data[2] & 31) != 0) {
#line 586
    if (((int )rsp->data[2] & 16) == 16) {
      {
#line 587
      printf((char const   */* __restrict  */)"     - Don\'t clear valid bit on reset/power cycle cause by PEF\n");
      }
    }
#line 588
    if (((int )rsp->data[2] & 8) == 8) {
      {
#line 589
      printf((char const   */* __restrict  */)"     - Don\'t automatically clear boot flag valid bit on timeout\n");
      }
    }
#line 590
    if (((int )rsp->data[2] & 4) == 4) {
      {
#line 591
      printf((char const   */* __restrict  */)"     - Don\'t clear valid bit on reset/power cycle cause by watchdog\n");
      }
    }
#line 592
    if (((int )rsp->data[2] & 2) == 2) {
      {
#line 593
      printf((char const   */* __restrict  */)"     - Don\'t clear valid bit on push button reset // soft reset\n");
      }
    }
#line 594
    if (((int )rsp->data[2] & 1) == 1) {
      {
#line 595
      printf((char const   */* __restrict  */)"     - Don\'t clear valid bit on power up via power push button or wake event\n");
      }
    }
  } else {
    {
#line 599
    printf((char const   */* __restrict  */)"     No flag set\n");
    }
  }
#line 602
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 605
  printf((char const   */* __restrict  */)" Boot Info Acknowledge :\n");
  }
#line 606
  if (((int )rsp->data[3] & 31) != 0) {
#line 608
    if (((int )rsp->data[3] & 16) == 16) {
      {
#line 609
      printf((char const   */* __restrict  */)"    - OEM has handled boot info\n");
      }
    }
#line 610
    if (((int )rsp->data[3] & 8) == 8) {
      {
#line 611
      printf((char const   */* __restrict  */)"    - SMS has handled boot info\n");
      }
    }
#line 612
    if (((int )rsp->data[3] & 4) == 4) {
      {
#line 613
      printf((char const   */* __restrict  */)"    - OS // service partition has handled boot info\n");
      }
    }
#line 614
    if (((int )rsp->data[3] & 2) == 2) {
      {
#line 615
      printf((char const   */* __restrict  */)"    - OS Loader has handled boot info\n");
      }
    }
#line 616
    if (((int )rsp->data[3] & 1) == 1) {
      {
#line 617
      printf((char const   */* __restrict  */)"    - BIOS/POST has handled boot info\n");
      }
    }
  } else {
    {
#line 621
    printf((char const   */* __restrict  */)"     No flag set\n");
    }
  }
#line 624
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 627
  printf((char const   */* __restrict  */)" Boot Flags :\n");
  }
#line 629
  if (((int )rsp->data[2] & 128) == 128) {
    {
#line 630
    printf((char const   */* __restrict  */)"   - Boot Flag Valid\n");
    }
  } else {
    {
#line 632
    printf((char const   */* __restrict  */)"   - Boot Flag Invalid\n");
    }
  }
#line 634
  if (((int )rsp->data[2] & 64) == 64) {
    {
#line 635
    printf((char const   */* __restrict  */)"   - Options apply to all future boots\n");
    }
  } else {
    {
#line 637
    printf((char const   */* __restrict  */)"   - Options apply to only next boot\n");
    }
  }
#line 639
  if (((int )rsp->data[2] & 32) == 32) {
    {
#line 640
    printf((char const   */* __restrict  */)"   - BIOS EFI boot \n");
    }
  } else {
    {
#line 642
    printf((char const   */* __restrict  */)"   - BIOS PC Compatible (legacy) boot \n");
    }
  }
#line 644
  if (((int )rsp->data[3] & 128) == 128) {
    {
#line 645
    printf((char const   */* __restrict  */)"   - CMOS Clear\n");
    }
  }
#line 646
  if (((int )rsp->data[3] & 64) == 64) {
    {
#line 647
    printf((char const   */* __restrict  */)"   - Lock Keyboard\n");
    }
  }
  {
#line 648
  printf((char const   */* __restrict  */)"   - Boot Device Selector : ");
  }
  {
#line 651
  if ((((int )rsp->data[3] >> 2) & 15) == 0) {
#line 651
    goto case_0___1;
  }
#line 652
  if ((((int )rsp->data[3] >> 2) & 15) == 1) {
#line 652
    goto case_1___1;
  }
#line 653
  if ((((int )rsp->data[3] >> 2) & 15) == 2) {
#line 653
    goto case_2___1;
  }
#line 654
  if ((((int )rsp->data[3] >> 2) & 15) == 3) {
#line 654
    goto case_3___0;
  }
#line 655
  if ((((int )rsp->data[3] >> 2) & 15) == 4) {
#line 655
    goto case_4___0;
  }
#line 656
  if ((((int )rsp->data[3] >> 2) & 15) == 5) {
#line 656
    goto case_5___0;
  }
#line 657
  if ((((int )rsp->data[3] >> 2) & 15) == 6) {
#line 657
    goto case_6;
  }
#line 658
  if ((((int )rsp->data[3] >> 2) & 15) == 15) {
#line 658
    goto case_15;
  }
#line 659
  goto switch_default___0;
  case_0___1: /* CIL Label */ 
  {
#line 651
  printf((char const   */* __restrict  */)"No override\n");
  }
#line 651
  goto switch_break___1;
  case_1___1: /* CIL Label */ 
  {
#line 652
  printf((char const   */* __restrict  */)"Force PXE\n");
  }
#line 652
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
  {
#line 653
  printf((char const   */* __restrict  */)"Force Boot from default Hard-Drive\n");
  }
#line 653
  goto switch_break___1;
  case_3___0: /* CIL Label */ 
  {
#line 654
  printf((char const   */* __restrict  */)"Force Boot from default Hard-Drive, request Safe-Mode\n");
  }
#line 654
  goto switch_break___1;
  case_4___0: /* CIL Label */ 
  {
#line 655
  printf((char const   */* __restrict  */)"Force Boot from Diagnostic Partition\n");
  }
#line 655
  goto switch_break___1;
  case_5___0: /* CIL Label */ 
  {
#line 656
  printf((char const   */* __restrict  */)"Force Boot from CD/DVD\n");
  }
#line 656
  goto switch_break___1;
  case_6: /* CIL Label */ 
  {
#line 657
  printf((char const   */* __restrict  */)"Force Boot into BIOS Setup\n");
  }
#line 657
  goto switch_break___1;
  case_15: /* CIL Label */ 
  {
#line 658
  printf((char const   */* __restrict  */)"Force Boot from Floppy/primary removable media\n");
  }
#line 658
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
  {
#line 659
  printf((char const   */* __restrict  */)"Flag error\n");
  }
#line 659
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 661
  if (((int )rsp->data[3] & 2) == 2) {
    {
#line 662
    printf((char const   */* __restrict  */)"   - Screen blank\n");
    }
  }
#line 663
  if (((int )rsp->data[3] & 1) == 1) {
    {
#line 664
    printf((char const   */* __restrict  */)"   - Lock out Reset buttons\n");
    }
  }
#line 666
  if (((int )rsp->data[4] & 128) == 128) {
    {
#line 667
    printf((char const   */* __restrict  */)"   - Lock out (power off/sleep request) vi Power Button\n");
    }
  }
  {
#line 668
  printf((char const   */* __restrict  */)"   - Console Redirection control : ");
  }
  {
#line 671
  if ((((int )rsp->data[4] >> 5) & 3) == 0) {
#line 671
    goto case_0___2;
  }
#line 672
  if ((((int )rsp->data[4] >> 5) & 3) == 1) {
#line 672
    goto case_1___2;
  }
#line 673
  if ((((int )rsp->data[4] >> 5) & 3) == 2) {
#line 673
    goto case_2___2;
  }
#line 674
  goto switch_default___1;
  case_0___2: /* CIL Label */ 
  {
#line 671
  printf((char const   */* __restrict  */)"System Default\n");
  }
#line 671
  goto switch_break___2;
  case_1___2: /* CIL Label */ 
  {
#line 672
  printf((char const   */* __restrict  */)"Request Quiet Display\n");
  }
#line 672
  goto switch_break___2;
  case_2___2: /* CIL Label */ 
  {
#line 673
  printf((char const   */* __restrict  */)"Request Verbose Display\n");
  }
#line 673
  goto switch_break___2;
  switch_default___1: /* CIL Label */ 
  {
#line 674
  printf((char const   */* __restrict  */)"Flag error\n");
  }
#line 674
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 676
  if (((int )rsp->data[4] & 16) == 16) {
    {
#line 677
    printf((char const   */* __restrict  */)"   - Force progress event traps\n");
    }
  }
#line 678
  if (((int )rsp->data[4] & 8) == 8) {
    {
#line 679
    printf((char const   */* __restrict  */)"   - User password bypass\n");
    }
  }
#line 680
  if (((int )rsp->data[4] & 4) == 4) {
    {
#line 681
    printf((char const   */* __restrict  */)"   - Lock Out Sleep Button\n");
    }
  }
#line 682
  if (((int )rsp->data[4] & 2) == 2) {
    {
#line 683
    printf((char const   */* __restrict  */)"   - Lock Out Sleep Button\n");
    }
  }
  {
#line 684
  printf((char const   */* __restrict  */)"   - BIOS verbosity : ");
  }
  {
#line 687
  if (((int )rsp->data[4] & 3) == 0) {
#line 687
    goto case_0___3;
  }
#line 688
  if (((int )rsp->data[4] & 3) == 1) {
#line 688
    goto case_1___3;
  }
#line 689
  if (((int )rsp->data[4] & 3) == 2) {
#line 689
    goto case_2___3;
  }
#line 690
  goto switch_default___2;
  case_0___3: /* CIL Label */ 
  {
#line 687
  printf((char const   */* __restrict  */)"Console redirection occurs per BIOS configuration setting (default)\n");
  }
#line 687
  goto switch_break___3;
  case_1___3: /* CIL Label */ 
  {
#line 688
  printf((char const   */* __restrict  */)"Suppress (skip) console redirection if enabled\n");
  }
#line 688
  goto switch_break___3;
  case_2___3: /* CIL Label */ 
  {
#line 689
  printf((char const   */* __restrict  */)"Request console redirection be enabled\n");
  }
#line 689
  goto switch_break___3;
  switch_default___2: /* CIL Label */ 
  {
#line 690
  printf((char const   */* __restrict  */)"Flag error\n");
  }
#line 690
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 693
  if (((int )rsp->data[5] & 8) == 8) {
    {
#line 694
    printf((char const   */* __restrict  */)"   - BIOS Shared Mode Override\n");
    }
  }
  {
#line 695
  printf((char const   */* __restrict  */)"   - BIOS Mux Control Override : ");
  }
  {
#line 698
  if (((int )rsp->data[5] & 7) == 0) {
#line 698
    goto case_0___4;
  }
#line 699
  if (((int )rsp->data[5] & 7) == 1) {
#line 699
    goto case_1___4;
  }
#line 700
  if (((int )rsp->data[5] & 7) == 2) {
#line 700
    goto case_2___4;
  }
#line 701
  goto switch_default___3;
  case_0___4: /* CIL Label */ 
  {
#line 698
  printf((char const   */* __restrict  */)"BIOS uses recommended setting of the mux at the end of POST\n");
  }
#line 698
  goto switch_break___4;
  case_1___4: /* CIL Label */ 
  {
#line 699
  printf((char const   */* __restrict  */)"Requests BIOS to force mux to BMC at conclusion of POST/start of OS boot\n");
  }
#line 699
  goto switch_break___4;
  case_2___4: /* CIL Label */ 
  {
#line 700
  printf((char const   */* __restrict  */)"Requests BIOS to force mux to system at conclusion of POST/start of OS boot\n");
  }
#line 700
  goto switch_break___4;
  switch_default___3: /* CIL Label */ 
  {
#line 701
  printf((char const   */* __restrict  */)"Flag error\n");
  }
#line 701
  goto switch_break___4;
  switch_break___4: /* CIL Label */ ;
  }
#line 704
  goto switch_break;
  case_6___0: /* CIL Label */ 
  {
#line 712
  session_id = (unsigned long )rsp->data[3];
#line 713
  session_id |= (unsigned long )rsp->data[4] << 8;
#line 714
  session_id |= (unsigned long )rsp->data[5] << 16;
#line 715
  session_id |= (unsigned long )rsp->data[6] << 24;
#line 717
  timestamp = (unsigned long )rsp->data[7];
#line 718
  timestamp |= (unsigned long )rsp->data[8] << 8;
#line 719
  timestamp |= (unsigned long )rsp->data[9] << 16;
#line 720
  timestamp |= (unsigned long )rsp->data[10] << 24;
#line 722
  memset((void *)(time_buf), 0, (size_t )40);
#line 723
  tmp___3 = localtime((time_t const   *)(& out_time));
#line 723
  strftime((char */* __restrict  */)(time_buf), sizeof(time_buf), (char const   */* __restrict  */)"%m/%d/%Y %H:%M:%S",
           (struct tm  const  */* __restrict  */)tmp___3);
#line 729
  printf((char const   */* __restrict  */)" Boot Initiator Info :\n");
#line 730
  printf((char const   */* __restrict  */)"    Channel Number : %d\n", (int )rsp->data[2] & 15);
#line 731
  printf((char const   */* __restrict  */)"    Session Id     : %08lXh\n", session_id);
  }
#line 732
  if (timestamp != 0UL) {
    {
#line 734
    printf((char const   */* __restrict  */)"    Timestamp      : %08lXh, %s\n", timestamp,
           time_buf);
    }
  } else {
    {
#line 738
    printf((char const   */* __restrict  */)"    Timestamp      : %08lXh, undefined\n",
           timestamp);
    }
  }
#line 742
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 745
  printf((char const   */* __restrict  */)" Selector   : %d\n", (int )rsp->data[2]);
#line 746
  tmp___4 = buf2str(rsp->data + 3, rsp->data_len - 2);
#line 746
  printf((char const   */* __restrict  */)" Block Data : %s\n", tmp___4);
  }
#line 748
  goto switch_break;
  switch_default___4: /* CIL Label */ 
  {
#line 750
  printf((char const   */* __restrict  */)" Undefined byte\n");
  }
#line 751
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 754
  return (0);
}
}
#line 757 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
static int ipmi_chassis_set_bootdev(struct ipmi_intf *intf , char *arg , uint8_t *iflags ) 
{ 
  uint8_t flags[5] ;
  int rc ;
  int use_progress ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 761
  rc = 0;
#line 762
  use_progress = 1;
#line 764
  if (use_progress) {
    {
#line 766
    memset((void *)(flags), 0, (size_t )5);
#line 767
    flags[0] = (uint8_t )1;
#line 768
    rc = ipmi_chassis_set_bootparam(intf, (uint8_t )0, flags, 1);
    }
#line 770
    if (rc < 0) {
#line 771
      use_progress = 0;
    }
  }
  {
#line 774
  memset((void *)(flags), 0, (size_t )5);
#line 775
  flags[0] = (uint8_t )1;
#line 776
  flags[1] = (uint8_t )1;
#line 777
  rc = ipmi_chassis_set_bootparam(intf, (uint8_t )4, flags, 2);
  }
#line 780
  if (rc < 0) {
#line 781
    if (use_progress) {
      {
#line 783
      memset((void *)(flags), 0, (size_t )5);
#line 784
      ipmi_chassis_set_bootparam(intf, (uint8_t )0, flags, 1);
      }
    }
#line 788
    return (-1);
  }
#line 791
  if ((unsigned long )iflags == (unsigned long )((void *)0)) {
    {
#line 792
    memset((void *)(flags), 0, (size_t )5);
    }
  } else {
    {
#line 794
    memcpy((void */* __restrict  */)(flags), (void const   */* __restrict  */)iflags,
           sizeof(flags));
    }
  }
#line 796
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 797
    flags[1] = (uint8_t )((int )flags[1]);
  } else {
    {
#line 798
    tmp___13 = strncmp((char const   *)arg, "none", (size_t )4);
    }
#line 798
    if (tmp___13 == 0) {
#line 799
      flags[1] = (uint8_t )((int )flags[1]);
    } else {
      {
#line 800
      tmp___11 = strncmp((char const   *)arg, "pxe", (size_t )3);
      }
#line 800
      if (tmp___11 == 0) {
#line 802
        flags[1] = (uint8_t )((int )flags[1] | 4);
      } else {
        {
#line 800
        tmp___12 = strncmp((char const   *)arg, "force_pxe", (size_t )9);
        }
#line 800
        if (tmp___12 == 0) {
#line 802
          flags[1] = (uint8_t )((int )flags[1] | 4);
        } else {
          {
#line 803
          tmp___9 = strncmp((char const   *)arg, "disk", (size_t )4);
          }
#line 803
          if (tmp___9 == 0) {
#line 805
            flags[1] = (uint8_t )((int )flags[1] | 8);
          } else {
            {
#line 803
            tmp___10 = strncmp((char const   *)arg, "force_disk", (size_t )10);
            }
#line 803
            if (tmp___10 == 0) {
#line 805
              flags[1] = (uint8_t )((int )flags[1] | 8);
            } else {
              {
#line 806
              tmp___7 = strncmp((char const   *)arg, "safe", (size_t )4);
              }
#line 806
              if (tmp___7 == 0) {
#line 808
                flags[1] = (uint8_t )((int )flags[1] | 12);
              } else {
                {
#line 806
                tmp___8 = strncmp((char const   *)arg, "force_safe", (size_t )10);
                }
#line 806
                if (tmp___8 == 0) {
#line 808
                  flags[1] = (uint8_t )((int )flags[1] | 12);
                } else {
                  {
#line 809
                  tmp___5 = strncmp((char const   *)arg, "diag", (size_t )4);
                  }
#line 809
                  if (tmp___5 == 0) {
#line 811
                    flags[1] = (uint8_t )((int )flags[1] | 16);
                  } else {
                    {
#line 809
                    tmp___6 = strncmp((char const   *)arg, "force_diag", (size_t )10);
                    }
#line 809
                    if (tmp___6 == 0) {
#line 811
                      flags[1] = (uint8_t )((int )flags[1] | 16);
                    } else {
                      {
#line 812
                      tmp___3 = strncmp((char const   *)arg, "cdrom", (size_t )5);
                      }
#line 812
                      if (tmp___3 == 0) {
#line 814
                        flags[1] = (uint8_t )((int )flags[1] | 20);
                      } else {
                        {
#line 812
                        tmp___4 = strncmp((char const   *)arg, "force_cdrom", (size_t )11);
                        }
#line 812
                        if (tmp___4 == 0) {
#line 814
                          flags[1] = (uint8_t )((int )flags[1] | 20);
                        } else {
                          {
#line 815
                          tmp___1 = strncmp((char const   *)arg, "floppy", (size_t )6);
                          }
#line 815
                          if (tmp___1 == 0) {
#line 817
                            flags[1] = (uint8_t )((int )flags[1] | 60);
                          } else {
                            {
#line 815
                            tmp___2 = strncmp((char const   *)arg, "force_floppy",
                                              (size_t )12);
                            }
#line 815
                            if (tmp___2 == 0) {
#line 817
                              flags[1] = (uint8_t )((int )flags[1] | 60);
                            } else {
                              {
#line 818
                              tmp = strncmp((char const   *)arg, "bios", (size_t )4);
                              }
#line 818
                              if (tmp == 0) {
#line 820
                                flags[1] = (uint8_t )((int )flags[1] | 24);
                              } else {
                                {
#line 818
                                tmp___0 = strncmp((char const   *)arg, "force_bios",
                                                  (size_t )10);
                                }
#line 818
                                if (tmp___0 == 0) {
#line 820
                                  flags[1] = (uint8_t )((int )flags[1] | 24);
                                } else {
                                  {
#line 822
                                  lprintf(3, "Invalid argument: %s", arg);
                                  }
#line 823
                                  if (use_progress) {
                                    {
#line 825
                                    memset((void *)(flags), 0, (size_t )5);
#line 826
                                    ipmi_chassis_set_bootparam(intf, (uint8_t )0,
                                                               flags, 1);
                                    }
                                  }
#line 830
                                  return (-1);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 834
  flags[0] = (uint8_t )((int )flags[0] | 128);
#line 836
  rc = ipmi_chassis_set_bootparam(intf, (uint8_t )5, flags, 5);
  }
#line 838
  if (rc == 0) {
#line 839
    if (use_progress) {
      {
#line 841
      memset((void *)(flags), 0, (size_t )5);
#line 842
      flags[0] = (uint8_t )2;
#line 843
      ipmi_chassis_set_bootparam(intf, (uint8_t )0, flags, 1);
      }
    }
    {
#line 848
    printf((char const   */* __restrict  */)"Set Boot Device to %s\n", arg);
    }
  }
#line 851
  if (use_progress) {
    {
#line 853
    memset((void *)(flags), 0, (size_t )5);
#line 854
    ipmi_chassis_set_bootparam(intf, (uint8_t )0, flags, 1);
    }
  }
#line 859
  return (rc);
}
}
#line 862 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
static int ipmi_chassis_power_policy(struct ipmi_intf *intf , uint8_t policy ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;

  {
  {
#line 868
  memset((void *)(& req), 0, sizeof(req));
#line 869
  req.msg.netfn = (uint8_t )0;
#line 870
  req.msg.cmd = (uint8_t )6;
#line 871
  req.msg.data = & policy;
#line 872
  req.msg.data_len = (uint16_t )1;
#line 874
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 875
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 876
    lprintf(3, "Error in Power Restore Policy command");
    }
#line 877
    return (-1);
  }
#line 879
  if ((int )rsp->ccode > 0) {
    {
#line 880
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 880
    lprintf(3, "Power Restore Policy command failed: %s", tmp);
    }
#line 882
    return (-1);
  }
#line 885
  if ((int )policy == 3) {
    {
#line 886
    printf((char const   */* __restrict  */)"Supported chassis power policy:  ");
    }
#line 887
    if ((int )rsp->data[0] & 1) {
      {
#line 888
      printf((char const   */* __restrict  */)"always-off ");
      }
    }
#line 889
    if ((int )rsp->data[0] & (1 << 2)) {
      {
#line 890
      printf((char const   */* __restrict  */)"always-on ");
      }
    }
#line 891
    if ((int )rsp->data[0] & (1 << 1)) {
      {
#line 892
      printf((char const   */* __restrict  */)"previous");
      }
    }
    {
#line 893
    printf((char const   */* __restrict  */)"\n");
    }
  } else {
    {
#line 896
    printf((char const   */* __restrict  */)"Set chassis power restore policy to ");
    }
    {
#line 898
    if ((int )policy == 2) {
#line 898
      goto case_2;
    }
#line 901
    if ((int )policy == 0) {
#line 901
      goto case_0;
    }
#line 904
    if ((int )policy == 1) {
#line 904
      goto case_1;
    }
#line 907
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 899
    printf((char const   */* __restrict  */)"always-on\n");
    }
#line 900
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 902
    printf((char const   */* __restrict  */)"always-off\n");
    }
#line 903
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 905
    printf((char const   */* __restrict  */)"previous\n");
    }
#line 906
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 908
    printf((char const   */* __restrict  */)"unknown\n");
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 911
  return (0);
}
}
#line 914 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
int ipmi_power_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int rc ;
  uint8_t ctl ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 917
  rc = 0;
#line 918
  ctl = (uint8_t )0;
#line 920
  if (argc < 1) {
    {
#line 921
    lprintf(5, "chassis power Commands: status, on, off, cycle, reset, diag, soft");
    }
#line 922
    return (0);
  } else {
    {
#line 920
    tmp = strncmp((char const   *)*(argv + 0), "help", (size_t )4);
    }
#line 920
    if (tmp == 0) {
      {
#line 921
      lprintf(5, "chassis power Commands: status, on, off, cycle, reset, diag, soft");
      }
#line 922
      return (0);
    }
  }
  {
#line 924
  tmp___0 = strncmp((char const   *)*(argv + 0), "status", (size_t )6);
  }
#line 924
  if (tmp___0 == 0) {
    {
#line 925
    rc = ipmi_chassis_print_power_status(intf);
    }
#line 926
    return (rc);
  }
  {
#line 928
  tmp___8 = strncmp((char const   *)*(argv + 0), "up", (size_t )2);
  }
#line 928
  if (tmp___8 == 0) {
#line 929
    ctl = (uint8_t )1;
  } else {
    {
#line 928
    tmp___9 = strncmp((char const   *)*(argv + 0), "on", (size_t )2);
    }
#line 928
    if (tmp___9 == 0) {
#line 929
      ctl = (uint8_t )1;
    } else {
      {
#line 930
      tmp___6 = strncmp((char const   *)*(argv + 0), "down", (size_t )4);
      }
#line 930
      if (tmp___6 == 0) {
#line 931
        ctl = (uint8_t )0;
      } else {
        {
#line 930
        tmp___7 = strncmp((char const   *)*(argv + 0), "off", (size_t )3);
        }
#line 930
        if (tmp___7 == 0) {
#line 931
          ctl = (uint8_t )0;
        } else {
          {
#line 932
          tmp___5 = strncmp((char const   *)*(argv + 0), "cycle", (size_t )5);
          }
#line 932
          if (tmp___5 == 0) {
#line 933
            ctl = (uint8_t )2;
          } else {
            {
#line 934
            tmp___4 = strncmp((char const   *)*(argv + 0), "reset", (size_t )5);
            }
#line 934
            if (tmp___4 == 0) {
#line 935
              ctl = (uint8_t )3;
            } else {
              {
#line 936
              tmp___3 = strncmp((char const   *)*(argv + 0), "diag", (size_t )4);
              }
#line 936
              if (tmp___3 == 0) {
#line 937
                ctl = (uint8_t )4;
              } else {
                {
#line 938
                tmp___1 = strncmp((char const   *)*(argv + 0), "acpi", (size_t )4);
                }
#line 938
                if (tmp___1 == 0) {
#line 939
                  ctl = (uint8_t )5;
                } else {
                  {
#line 938
                  tmp___2 = strncmp((char const   *)*(argv + 0), "soft", (size_t )4);
                  }
#line 938
                  if (tmp___2 == 0) {
#line 939
                    ctl = (uint8_t )5;
                  } else {
                    {
#line 941
                    lprintf(3, "Invalid chassis power command: %s", *(argv + 0));
                    }
#line 942
                    return (-1);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 945
  rc = ipmi_chassis_power_control(intf, ctl);
  }
#line 946
  return (rc);
}
}
#line 1092 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
static struct __anonstruct_options_54 options[18]  = 
#line 1092
  {      {(char *)"valid", 0, (unsigned char )(1 << 7), (unsigned char )(1 << 7), (char *)"Boot flags valid"}, 
        {(char *)"persistent",
      0, (unsigned char )(1 << 6), (unsigned char )(1 << 6), (char *)"Changes are persistent for all future boots"}, 
        {(char *)"efiboot",
      0, (unsigned char )(1 << 5), (unsigned char )(1 << 5), (char *)"Extensible Firmware Interface Boot (EFI)"}, 
        {(char *)"clear-cmos",
      1, (unsigned char )(1 << 7), (unsigned char )(1 << 7), (char *)"CMOS clear"}, 
        {(char *)"lockkbd",
      1, (unsigned char )(1 << 6), (unsigned char )(1 << 6), (char *)"Lock Keyboard"}, 
        {(char *)"screenblank",
      1, (unsigned char )(1 << 1), (unsigned char )(1 << 1), (char *)"Screen Blank"}, 
        {(char *)"lockoutreset",
      1, (unsigned char)1, (unsigned char)1, (char *)"Lock out Resetbuttons"}, 
        {(char *)"lockout_power", 2, (unsigned char )(1 << 7), (unsigned char )(1 << 7),
      (char *)"Lock out (power off/sleep request) via Power Button"}, 
        {(char *)"verbose=default", 2, (unsigned char )(3 << 5), (unsigned char)0, (char *)"Request quiet BIOS display"}, 
        {(char *)"verbose=no",
      2, (unsigned char )(3 << 5), (unsigned char )(1 << 5), (char *)"Request quiet BIOS display"}, 
        {(char *)"verbose=yes",
      2, (unsigned char )(3 << 5), (unsigned char )(2 << 5), (char *)"Request verbose BIOS display"}, 
        {(char *)"force_pet",
      2, (unsigned char )(1 << 4), (unsigned char )(1 << 4), (char *)"Force progress event traps"}, 
        {(char *)"upw_bypass",
      2, (unsigned char )(1 << 3), (unsigned char )(1 << 3), (char *)"User password bypass"}, 
        {(char *)"lockout_sleep",
      2, (unsigned char )(1 << 2), (unsigned char )(1 << 2), (char *)"Log Out Sleep Button"}, 
        {(char *)"cons_redirect=default",
      2, (unsigned char)3, (unsigned char)0, (char *)"Console redirection occurs per BIOS configuration setting"}, 
        {(char *)"cons_redirect=skip",
      2, (unsigned char)3, (unsigned char)1, (char *)"Suppress (skip) console redirection if enabled"}, 
        {(char *)"cons_redirect=enable",
      2, (unsigned char)3, (unsigned char)2, (char *)"Suppress (skip) console redirection if enabled"}, 
        {(char *)((void *)0),
      0, (unsigned char)0, (unsigned char)0, (char *)0}};
#line 1092 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
static struct __anonstruct_options_54 *op  ;
#line 949 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
int ipmi_chassis_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int rc ;
  uint8_t ctl ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  uint8_t ctl___0 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  uint8_t flags[5] ;
  int tmp___20 ;
  char *token ;
  char *saveptr ;
  int optionError ;
  unsigned char flags___0[5] ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;

  {
#line 952
  rc = 0;
#line 954
  if (argc == 0) {
    {
#line 955
    lprintf(5, "Chassis Commands:  status, power, identify, policy, restart_cause, poh, bootdev, bootparam, selftest");
    }
  } else {
    {
#line 954
    tmp___35 = strncmp((char const   *)*(argv + 0), "help", (size_t )4);
    }
#line 954
    if (tmp___35 == 0) {
      {
#line 955
      lprintf(5, "Chassis Commands:  status, power, identify, policy, restart_cause, poh, bootdev, bootparam, selftest");
      }
    } else {
      {
#line 957
      tmp___34 = strncmp((char const   *)*(argv + 0), "status", (size_t )6);
      }
#line 957
      if (tmp___34 == 0) {
        {
#line 958
        rc = ipmi_chassis_status(intf);
        }
      } else {
        {
#line 960
        tmp___33 = strncmp((char const   *)*(argv + 0), "selftest", (size_t )8);
        }
#line 960
        if (tmp___33 == 0) {
          {
#line 961
          rc = ipmi_chassis_selftest(intf);
          }
        } else {
          {
#line 963
          tmp___32 = strncmp((char const   *)*(argv + 0), "power", (size_t )5);
          }
#line 963
          if (tmp___32 == 0) {
#line 964
            ctl = (uint8_t )0;
#line 966
            if (argc < 2) {
              {
#line 967
              lprintf(5, "chassis power Commands: status, on, off, cycle, reset, diag, soft");
              }
#line 968
              return (0);
            } else {
              {
#line 966
              tmp = strncmp((char const   *)*(argv + 1), "help", (size_t )4);
              }
#line 966
              if (tmp == 0) {
                {
#line 967
                lprintf(5, "chassis power Commands: status, on, off, cycle, reset, diag, soft");
                }
#line 968
                return (0);
              }
            }
            {
#line 970
            tmp___0 = strncmp((char const   *)*(argv + 1), "status", (size_t )6);
            }
#line 970
            if (tmp___0 == 0) {
              {
#line 971
              rc = ipmi_chassis_print_power_status(intf);
              }
#line 972
              return (rc);
            }
            {
#line 974
            tmp___8 = strncmp((char const   *)*(argv + 1), "up", (size_t )2);
            }
#line 974
            if (tmp___8 == 0) {
#line 975
              ctl = (uint8_t )1;
            } else {
              {
#line 974
              tmp___9 = strncmp((char const   *)*(argv + 1), "on", (size_t )2);
              }
#line 974
              if (tmp___9 == 0) {
#line 975
                ctl = (uint8_t )1;
              } else {
                {
#line 976
                tmp___6 = strncmp((char const   *)*(argv + 1), "down", (size_t )4);
                }
#line 976
                if (tmp___6 == 0) {
#line 977
                  ctl = (uint8_t )0;
                } else {
                  {
#line 976
                  tmp___7 = strncmp((char const   *)*(argv + 1), "off", (size_t )3);
                  }
#line 976
                  if (tmp___7 == 0) {
#line 977
                    ctl = (uint8_t )0;
                  } else {
                    {
#line 978
                    tmp___5 = strncmp((char const   *)*(argv + 1), "cycle", (size_t )5);
                    }
#line 978
                    if (tmp___5 == 0) {
#line 979
                      ctl = (uint8_t )2;
                    } else {
                      {
#line 980
                      tmp___4 = strncmp((char const   *)*(argv + 1), "reset", (size_t )5);
                      }
#line 980
                      if (tmp___4 == 0) {
#line 981
                        ctl = (uint8_t )3;
                      } else {
                        {
#line 982
                        tmp___3 = strncmp((char const   *)*(argv + 1), "diag", (size_t )4);
                        }
#line 982
                        if (tmp___3 == 0) {
#line 983
                          ctl = (uint8_t )4;
                        } else {
                          {
#line 984
                          tmp___1 = strncmp((char const   *)*(argv + 1), "acpi", (size_t )4);
                          }
#line 984
                          if (tmp___1 == 0) {
#line 985
                            ctl = (uint8_t )5;
                          } else {
                            {
#line 984
                            tmp___2 = strncmp((char const   *)*(argv + 1), "soft",
                                              (size_t )4);
                            }
#line 984
                            if (tmp___2 == 0) {
#line 985
                              ctl = (uint8_t )5;
                            } else {
                              {
#line 987
                              lprintf(3, "Invalid chassis power command: %s", *(argv + 1));
                              }
#line 988
                              return (-1);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            {
#line 991
            rc = ipmi_chassis_power_control(intf, ctl);
            }
          } else {
            {
#line 993
            tmp___31 = strncmp((char const   *)*(argv + 0), "identify", (size_t )8);
            }
#line 993
            if (tmp___31 == 0) {
#line 994
              if (argc < 2) {
                {
#line 995
                rc = ipmi_chassis_identify(intf, (char *)((void *)0));
                }
              } else {
                {
#line 997
                tmp___10 = strncmp((char const   *)*(argv + 1), "help", (size_t )4);
                }
#line 997
                if (tmp___10 == 0) {
                  {
#line 998
                  lprintf(5, "chassis identify <interval>");
#line 999
                  lprintf(5, "                 default is 15 seconds");
#line 1000
                  lprintf(5, "                 0 to turn off");
#line 1001
                  lprintf(5, "                 force to turn on indefinitely");
                  }
                } else {
                  {
#line 1003
                  rc = ipmi_chassis_identify(intf, *(argv + 1));
                  }
                }
              }
            } else {
              {
#line 1006
              tmp___30 = strncmp((char const   *)*(argv + 0), "poh", (size_t )3);
              }
#line 1006
              if (tmp___30 == 0) {
                {
#line 1007
                rc = ipmi_chassis_poh(intf);
                }
              } else {
                {
#line 1009
                tmp___29 = strncmp((char const   *)*(argv + 0), "restart_cause", (size_t )13);
                }
#line 1009
                if (tmp___29 == 0) {
                  {
#line 1010
                  rc = ipmi_chassis_restart_cause(intf);
                  }
                } else {
                  {
#line 1012
                  tmp___28 = strncmp((char const   *)*(argv + 0), "policy", (size_t )4);
                  }
#line 1012
                  if (tmp___28 == 0) {
#line 1013
                    if (argc < 2) {
                      {
#line 1014
                      lprintf(5, "chassis policy <state>");
#line 1015
                      lprintf(5, "   list        : return supported policies");
#line 1016
                      lprintf(5, "   always-on   : turn on when power is restored");
#line 1017
                      lprintf(5, "   previous    : return to previous state when power is restored");
#line 1018
                      lprintf(5, "   always-off  : stay off after power is restored");
                      }
                    } else {
                      {
#line 1013
                      tmp___15 = strncmp((char const   *)*(argv + 1), "help", (size_t )4);
                      }
#line 1013
                      if (tmp___15 == 0) {
                        {
#line 1014
                        lprintf(5, "chassis policy <state>");
#line 1015
                        lprintf(5, "   list        : return supported policies");
#line 1016
                        lprintf(5, "   always-on   : turn on when power is restored");
#line 1017
                        lprintf(5, "   previous    : return to previous state when power is restored");
#line 1018
                        lprintf(5, "   always-off  : stay off after power is restored");
                        }
                      } else {
                        {
#line 1021
                        tmp___14 = strncmp((char const   *)*(argv + 1), "list", (size_t )4);
                        }
#line 1021
                        if (tmp___14 == 0) {
#line 1022
                          ctl___0 = (uint8_t )3;
                        } else {
                          {
#line 1023
                          tmp___13 = strncmp((char const   *)*(argv + 1), "always-on",
                                             (size_t )9);
                          }
#line 1023
                          if (tmp___13 == 0) {
#line 1024
                            ctl___0 = (uint8_t )2;
                          } else {
                            {
#line 1025
                            tmp___12 = strncmp((char const   *)*(argv + 1), "previous",
                                               (size_t )8);
                            }
#line 1025
                            if (tmp___12 == 0) {
#line 1026
                              ctl___0 = (uint8_t )1;
                            } else {
                              {
#line 1027
                              tmp___11 = strncmp((char const   *)*(argv + 1), "always-off",
                                                 (size_t )10);
                              }
#line 1027
                              if (tmp___11 == 0) {
#line 1028
                                ctl___0 = (uint8_t )0;
                              } else {
                                {
#line 1030
                                lprintf(3, "Invalid chassis policy: %s", *(argv + 1));
                                }
#line 1031
                                return (-1);
                              }
                            }
                          }
                        }
                        {
#line 1033
                        rc = ipmi_chassis_power_policy(intf, ctl___0);
                        }
                      }
                    }
                  } else {
                    {
#line 1036
                    tmp___27 = strncmp((char const   *)*(argv + 0), "bootparam", (size_t )9);
                    }
#line 1036
                    if (tmp___27 == 0) {
#line 1037
                      if (argc < 3) {
#line 1037
                        goto _L;
                      } else {
                        {
#line 1037
                        tmp___19 = strncmp((char const   *)*(argv + 1), "help", (size_t )4);
                        }
#line 1037
                        if (tmp___19 == 0) {
                          _L: /* CIL Label */ 
                          {
#line 1038
                          lprintf(5, "bootparam get <param #>");
#line 1039
                          lprintf(5, "bootparam set bootflag <flag>");
#line 1040
                          lprintf(5, "  force_pxe   : Force PXE boot");
#line 1041
                          lprintf(5, "  force_disk  : Force boot from default Hard-drive");
#line 1042
                          lprintf(5, "  force_safe  : Force boot from default Hard-drive, request Safe Mode");
#line 1043
                          lprintf(5, "  force_diag  : Force boot from Diagnostic Partition");
#line 1044
                          lprintf(5, "  force_cdrom : Force boot from CD/DVD");
#line 1045
                          lprintf(5, "  force_bios  : Force boot into BIOS Setup");
                          }
                        } else {
                          {
#line 1048
                          tmp___18 = strncmp((char const   *)*(argv + 1), "get", (size_t )3);
                          }
#line 1048
                          if (tmp___18 == 0) {
                            {
#line 1049
                            rc = ipmi_chassis_get_bootparam(intf, *(argv + 2));
                            }
                          } else {
                            {
#line 1051
                            tmp___17 = strncmp((char const   *)*(argv + 1), "set",
                                               (size_t )3);
                            }
#line 1051
                            if (tmp___17 == 0) {
#line 1052
                              if (argc < 4) {
                                {
#line 1053
                                lprintf(5, "bootparam set <option> [value ...]");
                                }
                              } else {
                                {
#line 1055
                                tmp___16 = strncmp((char const   *)*(argv + 2), "bootflag",
                                                   (size_t )8);
                                }
#line 1055
                                if (tmp___16 == 0) {
                                  {
#line 1056
                                  rc = ipmi_chassis_set_bootdev(intf, *(argv + 3),
                                                                (uint8_t *)((void *)0));
                                  }
                                } else {
                                  {
#line 1058
                                  lprintf(5, "bootparam set <option> [value ...]");
                                  }
                                }
                              }
                            } else {
                              {
#line 1062
                              lprintf(5, "bootparam get|set <option> [value ...]");
                              }
                            }
                          }
                        }
                      }
                    } else {
                      {
#line 1065
                      tmp___26 = strncmp((char const   *)*(argv + 0), "bootdev", (size_t )7);
                      }
#line 1065
                      if (tmp___26 == 0) {
#line 1066
                        if (argc < 2) {
#line 1066
                          goto _L___0;
                        } else {
                          {
#line 1066
                          tmp___25 = strncmp((char const   *)*(argv + 1), "help",
                                             (size_t )4);
                          }
#line 1066
                          if (tmp___25 == 0) {
                            _L___0: /* CIL Label */ 
                            {
#line 1067
                            lprintf(5, "bootdev <device> [clear-cmos=yes|no]");
#line 1068
                            lprintf(5, "bootdev <device> [options=help,...]");
#line 1069
                            lprintf(5, "  none  : Do not change boot device order");
#line 1070
                            lprintf(5, "  pxe   : Force PXE boot");
#line 1071
                            lprintf(5, "  disk  : Force boot from default Hard-drive");
#line 1072
                            lprintf(5, "  safe  : Force boot from default Hard-drive, request Safe Mode");
#line 1073
                            lprintf(5, "  diag  : Force boot from Diagnostic Partition");
#line 1074
                            lprintf(5, "  cdrom : Force boot from CD/DVD");
#line 1075
                            lprintf(5, "  bios  : Force boot into BIOS Setup");
#line 1076
                            lprintf(5, "  floppy: Force boot from Floppy/primary removable media");
                            }
                          } else
#line 1078
                          if (argc < 3) {
                            {
#line 1079
                            rc = ipmi_chassis_set_bootdev(intf, *(argv + 1), (uint8_t *)((void *)0));
                            }
                          } else {
                            {
#line 1080
                            tmp___24 = strncmp((char const   *)*(argv + 2), "clear-cmos=",
                                               (size_t )11);
                            }
#line 1080
                            if (tmp___24 == 0) {
                              {
#line 1081
                              tmp___20 = strncmp((char const   *)(*(argv + 2) + 11),
                                                 "yes", (size_t )3);
                              }
#line 1081
                              if (tmp___20 == 0) {
                                {
#line 1082
                                flags[0] = (uint8_t )0;
#line 1082
                                flags[1] = (uint8_t )(1 << 7);
#line 1082
                                flags[2] = (uint8_t )0;
#line 1082
                                flags[3] = (uint8_t )0;
#line 1082
                                flags[4] = (uint8_t )0;
#line 1083
                                rc = ipmi_chassis_set_bootdev(intf, *(argv + 1), flags);
                                }
                              } else {
                                {
#line 1085
                                rc = ipmi_chassis_set_bootdev(intf, *(argv + 1), (uint8_t *)((void *)0));
                                }
                              }
                            } else {
                              {
#line 1087
                              tmp___23 = strncmp((char const   *)*(argv + 2), "options=",
                                                 (size_t )8);
                              }
#line 1087
                              if (tmp___23 == 0) {
                                {
#line 1089
                                saveptr = (char *)((void *)0);
#line 1090
                                optionError = 0;
#line 1147
                                memset((void *)(& flags___0[0]), 0, sizeof(flags___0));
#line 1148
                                token = strtok_r((char */* __restrict  */)(*(argv + 2) + 8),
                                                 (char const   */* __restrict  */)",",
                                                 (char **/* __restrict  */)(& saveptr));
                                }
                                {
#line 1149
                                while (1) {
                                  while_continue: /* CIL Label */ ;
#line 1149
                                  if (! ((unsigned long )token != (unsigned long )((void *)0))) {
#line 1149
                                    goto while_break;
                                  }
                                  {
#line 1150
                                  tmp___21 = strcmp((char const   *)token, "help");
                                  }
#line 1150
                                  if (tmp___21 == 0) {
#line 1151
                                    optionError = 1;
#line 1152
                                    goto while_break;
                                  }
#line 1154
                                  op = options;
                                  {
#line 1154
                                  while (1) {
                                    while_continue___0: /* CIL Label */ ;
#line 1154
                                    if (! ((unsigned long )op->name != (unsigned long )((void *)0))) {
#line 1154
                                      goto while_break___0;
                                    }
                                    {
#line 1155
                                    tmp___22 = strcmp((char const   *)token, (char const   *)op->name);
                                    }
#line 1155
                                    if (tmp___22 == 0) {
#line 1156
                                      flags___0[op->i] = (unsigned char )((int )flags___0[op->i] & (int )op->mask);
#line 1157
                                      flags___0[op->i] = (unsigned char )((int )flags___0[op->i] | (int )op->value);
#line 1158
                                      goto while_break___0;
                                    }
#line 1154
                                    op ++;
                                  }
                                  while_break___0: /* CIL Label */ ;
                                  }
#line 1161
                                  if ((unsigned long )op->name == (unsigned long )((void *)0)) {
                                    {
#line 1163
                                    optionError = 1;
#line 1164
                                    lprintf(3, "Invalid option: %s", token);
                                    }
                                  }
                                  {
#line 1166
                                  token = strtok_r((char */* __restrict  */)((void *)0),
                                                   (char const   */* __restrict  */)",",
                                                   (char **/* __restrict  */)(& saveptr));
                                  }
                                }
                                while_break: /* CIL Label */ ;
                                }
#line 1168
                                if (optionError) {
                                  {
#line 1169
                                  lprintf(5, "Legal options are:");
#line 1170
                                  lprintf(5, "\thelp:\tprint this message");
#line 1171
                                  op = options;
                                  }
                                  {
#line 1171
                                  while (1) {
                                    while_continue___1: /* CIL Label */ ;
#line 1171
                                    if (! ((unsigned long )op->name != (unsigned long )((void *)0))) {
#line 1171
                                      goto while_break___1;
                                    }
                                    {
#line 1172
                                    lprintf(5, "\t%s:\t%s", op->name, op->desc);
#line 1171
                                    op ++;
                                    }
                                  }
                                  while_break___1: /* CIL Label */ ;
                                  }
#line 1174
                                  return (-1);
                                }
                                {
#line 1176
                                rc = ipmi_chassis_set_bootdev(intf, *(argv + 1), flags___0);
                                }
                              } else {
                                {
#line 1179
                                rc = ipmi_chassis_set_bootdev(intf, *(argv + 1), (uint8_t *)((void *)0));
                                }
                              }
                            }
                          }
                        }
                      } else {
                        {
#line 1183
                        lprintf(3, "Invalid Chassis command: %s", *(argv + 0));
                        }
#line 1184
                        return (-1);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 1187
  return (rc);
}
}
#line 928 "../include/ipmitool/ipmi_sdr.h"
extern struct sdr_record_list *ipmi_sdr_find_sdr_byentity(struct ipmi_intf *intf ,
                                                          struct entity_id *entity ) ;
#line 936
extern struct sdr_record_list *ipmi_sdr_find_sdr_bytype(struct ipmi_intf *intf , uint8_t type ) ;
#line 51 "../include/ipmitool/ipmi_sunoem.h"
int ipmi_sunoem_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 53
struct ipmi_rs *sunoem_led_get(struct ipmi_intf *intf , struct sdr_record_generic_locator *dev ,
                               int ledtype ) ;
#line 54
struct ipmi_rs *sunoem_led_set(struct ipmi_intf *intf , struct sdr_record_generic_locator *dev ,
                               int ledtype , int ledmode ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_sunoem.c"
static struct valstr  const  sunoem_led_type_vals[5]  = {      {(uint16_t )0, "OK2RM"}, 
        {(uint16_t )1, "SERVICE"}, 
        {(uint16_t )2, "ACT"}, 
        {(uint16_t )3, "LOCATE"}, 
        {(uint16_t )255, (char const   *)((void *)0)}};
#line 64 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_sunoem.c"
static struct valstr  const  sunoem_led_mode_vals[6]  = {      {(uint16_t )0, "OFF"}, 
        {(uint16_t )1, "ON"}, 
        {(uint16_t )2, "STANDBY"}, 
        {(uint16_t )3, "SLOW"}, 
        {(uint16_t )4, "FAST"}, 
        {(uint16_t )255, (char const   *)((void *)0)}};
#line 72 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_sunoem.c"
static struct valstr  const  sunoem_led_mode_optvals[6]  = {      {(uint16_t )0, "STEADY_OFF"}, 
        {(uint16_t )1, "STEADY_ON"}, 
        {(uint16_t )2, "STANDBY_BLINK"}, 
        {(uint16_t )3, "SLOW_BLINK"}, 
        {(uint16_t )4, "FAST_BLINK"}, 
        {(uint16_t )255, (char const   *)((void *)0)}};
#line 81 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_sunoem.c"
int is_sbcmd  =    0;
#line 83 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_sunoem.c"
static void ipmi_sunoem_usage(void) 
{ 


  {
  {
#line 86
  lprintf(5, "usage: sunoem <command> [option...]");
#line 87
  lprintf(5, "");
#line 88
  lprintf(5, "   fan speed <0-100>");
#line 89
  lprintf(5, "      Set system fan speed (PWM duty cycle)");
#line 90
  lprintf(5, "");
#line 91
  lprintf(5, "   sshkey set <userid> <id_rsa.pub>");
#line 92
  lprintf(5, "      Set ssh key for a userid into authorized_keys,");
#line 93
  lprintf(5, "      view users with \'user list\' command.");
#line 94
  lprintf(5, "");
#line 95
  lprintf(5, "   sshkey del <userid>");
#line 96
  lprintf(5, "      Delete ssh key for userid from authorized_keys,");
#line 97
  lprintf(5, "      view users with \'user list\' command.");
#line 98
  lprintf(5, "");
#line 99
  lprintf(5, "   led get <sensorid> [ledtype]");
#line 100
  lprintf(5, "      Read status of LED found in Generic Device Locator.");
#line 102
  lprintf(5, "");
#line 103
  lprintf(5, "   led set <sensorid> <ledmode> [ledtype]");
#line 104
  lprintf(5, "      Set mode of LED found in Generic Device Locator.");
#line 106
  lprintf(5, "");
#line 107
  lprintf(5, "   sbled get <sensorid> [ledtype]");
#line 108
  lprintf(5, "      Read status of LED found in Generic Device Locator");
#line 110
  lprintf(5, "      for Sun Blade Modular Systems.");
#line 111
  lprintf(5, "");
#line 112
  lprintf(5, "   sbled set <sensorid> <ledmode> [ledtype]");
#line 113
  lprintf(5, "      Set mode of LED found in Generic Device Locator");
#line 114
  lprintf(5, "      for Sun Blade Modular Systems.");
#line 115
  lprintf(5, "");
#line 116
  lprintf(5, "      Use \'sdr list generic\' command to get list of Generic");
#line 118
  lprintf(5, "      Devices that are controllable LEDs.");
#line 119
  lprintf(5, "");
#line 120
  lprintf(5, "      Required SIS LED Mode:");
#line 121
  lprintf(5, "         OFF          Off");
#line 122
  lprintf(5, "         ON           Steady On");
#line 123
  lprintf(5, "         STANDBY      100ms on 2900ms off blink rate");
#line 124
  lprintf(5, "         SLOW         1HZ blink rate");
#line 125
  lprintf(5, "         FAST         4HZ blink rate");
#line 126
  lprintf(5, "");
#line 127
  lprintf(5, "      Optional SIS LED Type:");
#line 128
  lprintf(5, "         OK2RM        OK to Remove");
#line 129
  lprintf(5, "         SERVICE      Service Required");
#line 130
  lprintf(5, "         ACT          Activity");
#line 131
  lprintf(5, "         LOCATE       Locate");
#line 132
  lprintf(5, "");
  }
#line 133
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_sunoem.c"
static int ipmi_sunoem_fan_speed(struct ipmi_intf *intf , uint8_t speed ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;

  {
#line 150
  if ((int )speed > 100) {
    {
#line 151
    lprintf(5, "Invalid fan speed: %d", (int )speed);
    }
#line 152
    return (-1);
  }
  {
#line 155
  req.msg.netfn = (uint8_t )46;
#line 156
  req.msg.cmd = (uint8_t )32;
#line 157
  req.msg.data = & speed;
#line 158
  req.msg.data_len = (uint16_t )1;
#line 160
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 161
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 162
    lprintf(3, "Sun OEM Set Fan Speed command failed");
    }
#line 163
    return (-1);
  } else
#line 165
  if ((int )rsp->ccode > 0) {
    {
#line 166
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 166
    lprintf(3, "Sun OEM Set Fan Speed command failed: %s", tmp);
    }
#line 168
    return (-1);
  }
  {
#line 171
  printf((char const   */* __restrict  */)"Set Fan speed to %d%%\n", (int )speed);
  }
#line 173
  return (0);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_sunoem.c"
static void __sdr_list_empty(struct sdr_record_list *head ) 
{ 
  struct sdr_record_list *e ;
  struct sdr_record_list *f ;

  {
#line 180
  e = head;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 180
      goto while_break;
    }
    {
#line 181
    f = e->next;
#line 182
    free((void *)e);
#line 183
    e = (struct sdr_record_list *)((void *)0);
#line 180
    e = f;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  head = (struct sdr_record_list *)((void *)0);
#line 186
  return;
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_sunoem.c"
static void led_print(char const   *name , uint8_t state ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 191
  if (csv_output) {
    {
#line 192
    tmp = val2str((uint16_t )state, sunoem_led_mode_vals);
#line 192
    printf((char const   */* __restrict  */)"%s,%s\n", name, tmp);
    }
  } else {
    {
#line 194
    tmp___0 = val2str((uint16_t )state, sunoem_led_mode_vals);
#line 194
    printf((char const   */* __restrict  */)"%-16s | %s\n", name, tmp___0);
    }
  }
#line 195
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_sunoem.c"
struct ipmi_rs *sunoem_led_get(struct ipmi_intf *intf , struct sdr_record_generic_locator *dev ,
                               int ledtype ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t rqdata[7] ;
  int rqdata_len ;
  char const   *tmp ;

  {
#line 205
  rqdata_len = 5;
#line 207
  if ((unsigned long )dev == (unsigned long )((void *)0)) {
#line 208
    return ((struct ipmi_rs *)((void *)0));
  }
#line 210
  rqdata[0] = dev->dev_slave_addr;
#line 211
  if (ledtype == 255) {
#line 212
    rqdata[1] = dev->oem;
  } else {
#line 214
    rqdata[1] = (uint8_t )ledtype;
  }
#line 215
  rqdata[2] = dev->dev_access_addr;
#line 216
  rqdata[3] = dev->oem;
#line 217
  if (is_sbcmd) {
#line 218
    rqdata[4] = dev->entity.id;
#line 219
    rqdata[5] = dev->entity.instance;
#line 220
    rqdata[6] = (uint8_t )0;
#line 221
    rqdata_len = 7;
  } else {
#line 224
    rqdata[4] = (uint8_t )0;
  }
  {
#line 227
  req.msg.netfn = (uint8_t )46;
#line 228
  req.msg.cmd = (uint8_t )33;
#line 229
  req.msg.lun = dev->lun;
#line 230
  req.msg.data = rqdata;
#line 231
  req.msg.data_len = (uint16_t )rqdata_len;
#line 233
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 234
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 235
    lprintf(3, "Sun OEM Get LED command failed");
    }
#line 236
    return ((struct ipmi_rs *)((void *)0));
  } else
#line 238
  if ((int )rsp->ccode > 0) {
    {
#line 239
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 239
    lprintf(3, "Sun OEM Get LED command failed: %s", tmp);
    }
#line 241
    return ((struct ipmi_rs *)((void *)0));
  }
#line 244
  return (rsp);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_sunoem.c"
struct ipmi_rs *sunoem_led_set(struct ipmi_intf *intf , struct sdr_record_generic_locator *dev ,
                               int ledtype , int ledmode ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t rqdata[9] ;
  int rqdata_len ;
  char const   *tmp ;

  {
#line 255
  rqdata_len = 7;
#line 257
  if ((unsigned long )dev == (unsigned long )((void *)0)) {
#line 258
    return ((struct ipmi_rs *)((void *)0));
  }
#line 260
  rqdata[0] = dev->dev_slave_addr;
#line 261
  if (ledtype == 255) {
#line 262
    rqdata[1] = dev->oem;
  } else {
#line 264
    rqdata[1] = (uint8_t )ledtype;
  }
#line 265
  rqdata[2] = dev->dev_access_addr;
#line 266
  rqdata[3] = dev->oem;
#line 267
  rqdata[4] = (uint8_t )ledmode;
#line 268
  if (is_sbcmd) {
#line 269
    rqdata[5] = dev->entity.id;
#line 270
    rqdata[6] = dev->entity.instance;
#line 271
    rqdata[7] = (uint8_t )0;
#line 272
    rqdata[8] = (uint8_t )0;
#line 273
    rqdata_len = 9;
  } else {
#line 276
    rqdata[5] = (uint8_t )0;
#line 277
    rqdata[6] = (uint8_t )0;
  }
  {
#line 280
  req.msg.netfn = (uint8_t )46;
#line 281
  req.msg.cmd = (uint8_t )34;
#line 282
  req.msg.lun = dev->lun;
#line 283
  req.msg.data = rqdata;
#line 284
  req.msg.data_len = (uint16_t )rqdata_len;
#line 286
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 287
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 288
    lprintf(3, "Sun OEM Set LED command failed");
    }
#line 289
    return ((struct ipmi_rs *)((void *)0));
  } else
#line 291
  if ((int )rsp->ccode > 0) {
    {
#line 292
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 292
    lprintf(3, "Sun OEM Set LED command failed: %s", tmp);
    }
#line 294
    return ((struct ipmi_rs *)((void *)0));
  }
#line 297
  return (rsp);
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_sunoem.c"
static void sunoem_led_get_byentity(struct ipmi_intf *intf , uint8_t entity_id , uint8_t entity_inst ,
                                    int ledtype ) 
{ 
  struct ipmi_rs *rsp ;
  struct sdr_record_list *elist ;
  struct sdr_record_list *e ;
  struct entity_id entity ;

  {
#line 308
  if ((int )entity_id == 0) {
#line 309
    return;
  }
  {
#line 312
  memset((void *)(& entity), 0, sizeof(struct entity_id ));
#line 313
  entity.id = entity_id;
#line 314
  entity.instance = entity_inst;
#line 316
  elist = ipmi_sdr_find_sdr_byentity(intf, & entity);
#line 319
  e = elist;
  }
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 319
      goto while_break;
    }
#line 320
    if ((int )e->type != 16) {
#line 321
      goto __Cont;
    }
    {
#line 322
    rsp = sunoem_led_get(intf, e->record.genloc, ledtype);
    }
#line 323
    if (rsp) {
#line 323
      if (rsp->data_len == 1) {
        {
#line 324
        led_print((char const   *)((e->record.genloc)->id_string), rsp->data[0]);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 319
    e = e->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 328
  __sdr_list_empty(elist);
  }
#line 329
  return;
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_sunoem.c"
static void sunoem_led_set_byentity(struct ipmi_intf *intf , uint8_t entity_id , uint8_t entity_inst ,
                                    int ledtype , int ledmode ) 
{ 
  struct ipmi_rs *rsp ;
  struct sdr_record_list *elist ;
  struct sdr_record_list *e ;
  struct entity_id entity ;

  {
#line 339
  if ((int )entity_id == 0) {
#line 340
    return;
  }
  {
#line 343
  memset((void *)(& entity), 0, sizeof(struct entity_id ));
#line 344
  entity.id = entity_id;
#line 345
  entity.instance = entity_inst;
#line 347
  elist = ipmi_sdr_find_sdr_byentity(intf, & entity);
#line 350
  e = elist;
  }
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 350
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 350
      goto while_break;
    }
#line 351
    if ((int )e->type != 16) {
#line 352
      goto __Cont;
    }
    {
#line 353
    rsp = sunoem_led_set(intf, e->record.genloc, ledtype, ledmode);
    }
#line 354
    if (rsp) {
#line 354
      if (rsp->data_len == 0) {
        {
#line 355
        led_print((char const   *)((e->record.genloc)->id_string), (uint8_t )ledmode);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 350
    e = e->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 359
  __sdr_list_empty(elist);
  }
#line 360
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_sunoem.c"
static int ipmi_sunoem_led_get(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  struct ipmi_rs *rsp ;
  struct sdr_record_list *sdr ;
  struct sdr_record_list *alist ;
  struct sdr_record_list *a ;
  struct sdr_record_entity_assoc *assoc ;
  int ledtype ;
  int i ;
  int tmp ;
  uint16_t tmp___0 ;
  int tmp___1 ;

  {
#line 389
  ledtype = 255;
#line 396
  if (argc < 1) {
    {
#line 397
    ipmi_sunoem_usage();
    }
#line 398
    return (0);
  } else {
    {
#line 396
    tmp = strncmp((char const   *)*(argv + 0), "help", (size_t )4);
    }
#line 396
    if (tmp == 0) {
      {
#line 397
      ipmi_sunoem_usage();
      }
#line 398
      return (0);
    }
  }
#line 401
  if (argc > 1) {
    {
#line 402
    tmp___0 = str2val((char const   *)*(argv + 1), sunoem_led_type_vals);
#line 402
    ledtype = (int )tmp___0;
    }
#line 403
    if (ledtype == 255) {
      {
#line 404
      lprintf(3, "Unknow ledtype, will use data from the SDR oem field");
      }
    }
  }
  {
#line 407
  tmp___1 = strncasecmp((char const   *)*(argv + 0), "all", (size_t )3);
  }
#line 407
  if (tmp___1 == 0) {
    {
#line 409
    alist = ipmi_sdr_find_sdr_bytype(intf, (uint8_t )16);
#line 411
    a = alist;
    }
    {
#line 411
    while (1) {
      while_continue: /* CIL Label */ ;
#line 411
      if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 411
        goto while_break;
      }
#line 412
      if ((int )a->type != 16) {
#line 413
        goto __Cont;
      }
#line 414
      if ((a->record.genloc)->entity.logical) {
#line 415
        goto __Cont;
      }
      {
#line 416
      rsp = sunoem_led_get(intf, a->record.genloc, ledtype);
      }
#line 417
      if (rsp) {
#line 417
        if (rsp->data_len == 1) {
          {
#line 418
          led_print((char const   *)((a->record.genloc)->id_string), rsp->data[0]);
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 411
      a = a->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 421
    __sdr_list_empty(alist);
    }
#line 422
    return (0);
  }
  {
#line 426
  sdr = ipmi_sdr_find_sdr_byid(intf, *(argv + 0));
  }
#line 428
  if ((unsigned long )sdr == (unsigned long )((void *)0)) {
    {
#line 429
    lprintf(3, "No Sensor Data Record found for %s", *(argv + 0));
    }
#line 430
    return (-1);
  }
#line 433
  if ((int )sdr->type != 16) {
    {
#line 434
    lprintf(3, "Invalid SDR type %d", (int )sdr->type);
    }
#line 435
    return (-1);
  }
#line 438
  if (! (sdr->record.genloc)->entity.logical) {
    {
#line 442
    rsp = sunoem_led_get(intf, sdr->record.genloc, ledtype);
    }
#line 443
    if (rsp) {
#line 443
      if (rsp->data_len == 1) {
        {
#line 444
        led_print((char const   *)((sdr->record.genloc)->id_string), rsp->data[0]);
        }
      }
    }
#line 446
    return (0);
  }
  {
#line 453
  lprintf(6, "LED %s is logical device", *(argv + 0));
#line 456
  alist = ipmi_sdr_find_sdr_bytype(intf, (uint8_t )8);
#line 457
  a = alist;
  }
  {
#line 457
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 457
    if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 457
      goto while_break___0;
    }
#line 458
    if ((int )a->type != 8) {
#line 459
      goto __Cont___0;
    }
#line 460
    assoc = a->record.entassoc;
#line 461
    if ((unsigned long )assoc == (unsigned long )((void *)0)) {
#line 462
      goto __Cont___0;
    }
#line 465
    if ((int )assoc->entity.id != (int )(sdr->record.genloc)->entity.id) {
#line 467
      goto __Cont___0;
    } else
#line 465
    if ((int )assoc->entity.instance != (int )(sdr->record.genloc)->entity.instance) {
#line 467
      goto __Cont___0;
    }
#line 469
    if (assoc->flags.isrange) {
#line 478
      if ((int )assoc->entity_id_1 == (int )assoc->entity_id_2) {
#line 479
        i = (int )assoc->entity_inst_1;
        {
#line 479
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 479
          if (! (i <= (int )assoc->entity_inst_2)) {
#line 479
            goto while_break___1;
          }
          {
#line 480
          sunoem_led_get_byentity(intf, assoc->entity_id_1, (uint8_t )i, ledtype);
#line 479
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 483
      if ((int )assoc->entity_id_3 == (int )assoc->entity_id_4) {
#line 484
        i = (int )assoc->entity_inst_3;
        {
#line 484
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 484
          if (! (i <= (int )assoc->entity_inst_4)) {
#line 484
            goto while_break___2;
          }
          {
#line 485
          sunoem_led_get_byentity(intf, assoc->entity_id_3, (uint8_t )i, ledtype);
#line 484
          i ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 491
      sunoem_led_get_byentity(intf, assoc->entity_id_1, assoc->entity_inst_1, ledtype);
#line 493
      sunoem_led_get_byentity(intf, assoc->entity_id_2, assoc->entity_inst_2, ledtype);
#line 495
      sunoem_led_get_byentity(intf, assoc->entity_id_3, assoc->entity_inst_3, ledtype);
#line 497
      sunoem_led_get_byentity(intf, assoc->entity_id_4, assoc->entity_inst_4, ledtype);
      }
    }
    __Cont___0: /* CIL Label */ 
#line 457
    a = a->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 502
  __sdr_list_empty(alist);
  }
#line 504
  return (0);
}
}
#line 536 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_sunoem.c"
static int ipmi_sunoem_led_set(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  struct ipmi_rs *rsp ;
  struct sdr_record_list *sdr ;
  struct sdr_record_list *alist ;
  struct sdr_record_list *a ;
  struct sdr_record_entity_assoc *assoc ;
  int ledmode ;
  int ledtype ;
  int i ;
  int tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;
  int tmp___3 ;

  {
#line 544
  ledtype = 255;
#line 551
  if (argc < 2) {
    {
#line 552
    ipmi_sunoem_usage();
    }
#line 553
    return (0);
  } else {
    {
#line 551
    tmp = strncmp((char const   *)*(argv + 0), "help", (size_t )4);
    }
#line 551
    if (tmp == 0) {
      {
#line 552
      ipmi_sunoem_usage();
      }
#line 553
      return (0);
    }
  }
  {
#line 556
  tmp___0 = str2val((char const   *)*(argv + 1), sunoem_led_mode_vals);
#line 556
  ledmode = (int )tmp___0;
  }
#line 557
  if (ledmode == 255) {
    {
#line 558
    tmp___1 = str2val((char const   *)*(argv + 1), sunoem_led_mode_optvals);
#line 558
    ledmode = (int )tmp___1;
    }
#line 559
    if (ledmode == 255) {
      {
#line 560
      lprintf(5, "Invalid LED Mode: %s", *(argv + 1));
      }
#line 561
      return (-1);
    }
  }
#line 565
  if (argc > 3) {
    {
#line 566
    tmp___2 = str2val((char const   *)*(argv + 2), sunoem_led_type_vals);
#line 566
    ledtype = (int )tmp___2;
    }
#line 567
    if (ledtype == 255) {
      {
#line 568
      lprintf(3, "Unknow ledtype, will use data from the SDR oem field");
      }
    }
  }
  {
#line 571
  tmp___3 = strncasecmp((char const   *)*(argv + 0), "all", (size_t )3);
  }
#line 571
  if (tmp___3 == 0) {
    {
#line 573
    alist = ipmi_sdr_find_sdr_bytype(intf, (uint8_t )16);
#line 575
    a = alist;
    }
    {
#line 575
    while (1) {
      while_continue: /* CIL Label */ ;
#line 575
      if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 575
        goto while_break;
      }
#line 576
      if ((int )a->type != 16) {
#line 577
        goto __Cont;
      }
#line 578
      if ((a->record.genloc)->entity.logical) {
#line 579
        goto __Cont;
      }
      {
#line 580
      rsp = sunoem_led_set(intf, a->record.genloc, ledtype, ledmode);
      }
#line 581
      if (rsp) {
#line 581
        if ((int )rsp->ccode == 0) {
          {
#line 582
          led_print((char const   *)((a->record.genloc)->id_string), (uint8_t )ledmode);
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 575
      a = a->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 585
    __sdr_list_empty(alist);
    }
#line 586
    return (0);
  }
  {
#line 590
  sdr = ipmi_sdr_find_sdr_byid(intf, *(argv + 0));
  }
#line 592
  if ((unsigned long )sdr == (unsigned long )((void *)0)) {
    {
#line 593
    lprintf(3, "No Sensor Data Record found for %s", *(argv + 0));
    }
#line 595
    return (-1);
  }
#line 598
  if ((int )sdr->type != 16) {
    {
#line 599
    lprintf(3, "Invalid SDR type %d", (int )sdr->type);
    }
#line 600
    return (-1);
  }
#line 603
  if (! (sdr->record.genloc)->entity.logical) {
    {
#line 607
    rsp = sunoem_led_set(intf, sdr->record.genloc, ledtype, ledmode);
    }
#line 608
    if (rsp) {
#line 608
      if ((int )rsp->ccode == 0) {
        {
#line 609
        led_print((char const   *)*(argv + 0), (uint8_t )ledmode);
        }
      }
    }
#line 611
    return (0);
  }
  {
#line 618
  lprintf(6, "LED %s is logical device", *(argv + 0));
#line 621
  alist = ipmi_sdr_find_sdr_bytype(intf, (uint8_t )8);
#line 622
  a = alist;
  }
  {
#line 622
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 622
    if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 622
      goto while_break___0;
    }
#line 623
    if ((int )a->type != 8) {
#line 624
      goto __Cont___0;
    }
#line 625
    assoc = a->record.entassoc;
#line 626
    if ((unsigned long )assoc == (unsigned long )((void *)0)) {
#line 627
      goto __Cont___0;
    }
#line 630
    if ((int )assoc->entity.id != (int )(sdr->record.genloc)->entity.id) {
#line 632
      goto __Cont___0;
    } else
#line 630
    if ((int )assoc->entity.instance != (int )(sdr->record.genloc)->entity.instance) {
#line 632
      goto __Cont___0;
    }
#line 634
    if (assoc->flags.isrange) {
#line 643
      if ((int )assoc->entity_id_1 == (int )assoc->entity_id_2) {
#line 644
        i = (int )assoc->entity_inst_1;
        {
#line 644
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 644
          if (! (i <= (int )assoc->entity_inst_2)) {
#line 644
            goto while_break___1;
          }
          {
#line 645
          sunoem_led_set_byentity(intf, assoc->entity_id_1, (uint8_t )i, ledtype,
                                  ledmode);
#line 644
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 649
      if ((int )assoc->entity_id_3 == (int )assoc->entity_id_4) {
#line 650
        i = (int )assoc->entity_inst_3;
        {
#line 650
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 650
          if (! (i <= (int )assoc->entity_inst_4)) {
#line 650
            goto while_break___2;
          }
          {
#line 651
          sunoem_led_set_byentity(intf, assoc->entity_id_3, (uint8_t )i, ledtype,
                                  ledmode);
#line 650
          i ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 658
      sunoem_led_set_byentity(intf, assoc->entity_id_1, assoc->entity_inst_1, ledtype,
                              ledmode);
#line 660
      sunoem_led_set_byentity(intf, assoc->entity_id_2, assoc->entity_inst_2, ledtype,
                              ledmode);
#line 662
      sunoem_led_set_byentity(intf, assoc->entity_id_3, assoc->entity_inst_3, ledtype,
                              ledmode);
#line 664
      sunoem_led_set_byentity(intf, assoc->entity_id_4, assoc->entity_inst_4, ledtype,
                              ledmode);
      }
    }
    __Cont___0: /* CIL Label */ 
#line 622
    a = a->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 669
  __sdr_list_empty(alist);
  }
#line 671
  return (0);
}
}
#line 674 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_sunoem.c"
static int ipmi_sunoem_sshkey_del(struct ipmi_intf *intf , uint8_t uid ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;

  {
  {
#line 680
  memset((void *)(& req), 0, sizeof(struct ipmi_rq ));
#line 681
  req.msg.netfn = (uint8_t )46;
#line 682
  req.msg.cmd = (uint8_t )2;
#line 683
  req.msg.data = & uid;
#line 684
  req.msg.data_len = (uint16_t )1;
#line 686
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 687
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 688
    lprintf(3, "Unable to delete ssh key for UID %d", (int )uid);
    }
#line 689
    return (-1);
  } else
#line 691
  if ((int )rsp->ccode > 0) {
    {
#line 692
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 692
    lprintf(3, "Unable to delete ssh key for UID %d: %s", (int )uid, tmp);
    }
#line 694
    return (-1);
  }
  {
#line 697
  printf((char const   */* __restrict  */)"Deleted SSH key for user id %d\n", (int )uid);
  }
#line 698
  return (0);
}
}
#line 702 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_sunoem.c"
static int ipmi_sunoem_sshkey_set(struct ipmi_intf *intf , uint8_t uid , char *ifile ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  FILE *fp ;
  int count ;
  uint16_t i_size ;
  uint16_t r ;
  uint16_t size ;
  uint8_t wbuf[67] ;
  long tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 712
  if ((unsigned long )ifile == (unsigned long )((void *)0)) {
    {
#line 713
    lprintf(3, "Invalid or misisng input filename");
    }
#line 714
    return (-1);
  }
  {
#line 717
  fp = ipmi_open_file((char const   *)ifile, 0);
  }
#line 718
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 719
    lprintf(3, "Unable to open file %s for reading", ifile);
    }
#line 720
    return (-1);
  }
  {
#line 723
  printf((char const   */* __restrict  */)"Setting SSH key for user id %d...", (int )uid);
#line 725
  memset((void *)(& req), 0, sizeof(struct ipmi_rq ));
#line 726
  req.msg.netfn = (uint8_t )46;
#line 727
  req.msg.cmd = (uint8_t )1;
#line 728
  req.msg.data = wbuf;
#line 730
  fseek(fp, 0L, 2);
#line 731
  tmp = ftell(fp);
#line 731
  size = (uint16_t )tmp;
#line 732
  fseek(fp, 0L, 0);
#line 734
  r = (uint16_t )0;
  }
  {
#line 734
  while (1) {
    while_continue: /* CIL Label */ ;
#line 734
    if (! ((int )r < (int )size)) {
#line 734
      goto while_break;
    }
#line 735
    i_size = (uint16_t )((int )size - (int )r);
#line 736
    if ((int )i_size > 64) {
#line 737
      i_size = (uint16_t )64;
    }
    {
#line 739
    memset((void *)(wbuf), 0, (size_t )64);
#line 740
    tmp___2 = fseek(fp, (long )r, 0);
    }
#line 740
    if (-1 == tmp___2) {
      {
#line 741
      tmp___0 = __errno_location();
#line 741
      tmp___1 = strerror(*tmp___0);
#line 741
      lprintf(3, "Seek error %s. %s", ifile, tmp___1);
      }
#line 742
      return (-1);
    }
    {
#line 744
    tmp___3 = fread((void */* __restrict  */)(wbuf + 3), (size_t )1, (size_t )i_size,
                    (FILE */* __restrict  */)fp);
#line 744
    count = (int )tmp___3;
    }
#line 745
    if (count != (int )i_size) {
      {
#line 746
      lprintf(3, "Unable to read %d bytes from file %s", (int )i_size, ifile);
#line 747
      fclose(fp);
      }
#line 748
      return (-1);
    }
    {
#line 751
    printf((char const   */* __restrict  */)".");
#line 752
    fflush(stdout);
#line 754
    wbuf[0] = uid;
    }
#line 755
    if ((int )r + 64 >= (int )size) {
#line 756
      wbuf[1] = (uint8_t )255;
    } else {
#line 758
      wbuf[1] = (uint8_t )((int )r / 64);
    }
    {
#line 759
    wbuf[2] = (uint8_t )i_size;
#line 760
    req.msg.data_len = (uint16_t )((int )i_size + 3);
#line 762
    rsp = (*(intf->sendrecv))(intf, & req);
    }
#line 763
    if ((unsigned long )rsp == (unsigned long )((void *)0)) {
      {
#line 764
      lprintf(3, "Unable to set ssh key for UID %d", (int )uid);
      }
#line 765
      goto while_break;
    }
#line 734
    r = (uint16_t )((int )r + (int )i_size);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 769
  printf((char const   */* __restrict  */)"done\n");
#line 771
  fclose(fp);
  }
#line 772
  return (0);
}
}
#line 776 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_sunoem.c"
int ipmi_sunoem_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int rc ;
  int tmp ;
  uint8_t pct ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *arg[1] ;
  int tmp___3 ;
  int tmp___4 ;
  uint8_t uid ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 779
  rc = -1;
#line 781
  if (argc == 0) {
    {
#line 782
    ipmi_sunoem_usage();
    }
#line 783
    return (0);
  } else {
    {
#line 781
    tmp = strncmp((char const   *)*(argv + 0), "help", (size_t )4);
    }
#line 781
    if (tmp == 0) {
      {
#line 782
      ipmi_sunoem_usage();
      }
#line 783
      return (0);
    }
  }
  {
#line 786
  tmp___11 = strncmp((char const   *)*(argv + 0), "fan", (size_t )3);
  }
#line 786
  if (tmp___11 == 0) {
#line 787
    if (argc == 3) {
      {
#line 787
      tmp___1 = strncmp((char const   *)*(argv + 1), "speed", (size_t )5);
      }
#line 787
      if (tmp___1 == 0) {
        {
#line 788
        pct = (uint8_t )0;
#line 789
        tmp___0 = str2uchar((char const   *)*(argv + 2), & pct);
        }
#line 789
        if (tmp___0 != 0) {
          {
#line 790
          lprintf(3, "Fan speed is limited to range <0..100>.");
          }
#line 791
          return (-1);
        } else
#line 789
        if ((int )pct > 100) {
          {
#line 790
          lprintf(3, "Fan speed is limited to range <0..100>.");
          }
#line 791
          return (-1);
        }
        {
#line 793
        rc = ipmi_sunoem_fan_speed(intf, pct);
        }
      } else {
        {
#line 796
        ipmi_sunoem_usage();
        }
#line 797
        return (-1);
      }
    } else {
      {
#line 796
      ipmi_sunoem_usage();
      }
#line 797
      return (-1);
    }
  } else {
    {
#line 800
    tmp___9 = strncmp((char const   *)*(argv + 0), "led", (size_t )3);
    }
#line 800
    if (tmp___9 == 0) {
#line 800
      goto _L;
    } else {
      {
#line 800
      tmp___10 = strncmp((char const   *)*(argv + 0), "sbled", (size_t )5);
      }
#line 800
      if (tmp___10 == 0) {
        _L: /* CIL Label */ 
#line 802
        if (argc < 2) {
          {
#line 803
          ipmi_sunoem_usage();
          }
#line 804
          return (-1);
        }
        {
#line 806
        tmp___2 = strncmp((char const   *)*(argv + 0), "sbled", (size_t )5);
        }
#line 806
        if (tmp___2 == 0) {
#line 807
          is_sbcmd = 1;
        }
        {
#line 809
        tmp___4 = strncmp((char const   *)*(argv + 1), "get", (size_t )3);
        }
#line 809
        if (tmp___4 == 0) {
#line 810
          if (argc < 3) {
            {
#line 811
            arg[0] = (char *)"all";
#line 812
            rc = ipmi_sunoem_led_get(intf, 1, arg);
            }
          } else {
            {
#line 815
            rc = ipmi_sunoem_led_get(intf, argc - 2, argv + 2);
            }
          }
        } else {
          {
#line 818
          tmp___3 = strncmp((char const   *)*(argv + 1), "set", (size_t )3);
          }
#line 818
          if (tmp___3 == 0) {
#line 819
            if (argc < 4) {
              {
#line 820
              ipmi_sunoem_usage();
              }
#line 821
              return (-1);
            }
            {
#line 823
            rc = ipmi_sunoem_led_set(intf, argc - 2, argv + 2);
            }
          } else {
            {
#line 826
            ipmi_sunoem_usage();
            }
#line 827
            return (-1);
          }
        }
      } else {
        {
#line 830
        tmp___8 = strncmp((char const   *)*(argv + 0), "sshkey", (size_t )6);
        }
#line 830
        if (tmp___8 == 0) {
#line 831
          uid = (uint8_t )0;
#line 832
          if (argc < 3) {
            {
#line 833
            ipmi_sunoem_usage();
            }
#line 834
            return (-1);
          }
          {
#line 837
          tmp___5 = str2uchar((char const   *)*(argv + 2), & uid);
          }
#line 837
          if (tmp___5 != 0) {
            {
#line 838
            lprintf(3, "User ID is limited to range <1..63>.");
            }
#line 839
            return (-1);
          } else
#line 837
          if ((int )uid < 1) {
            {
#line 838
            lprintf(3, "User ID is limited to range <1..63>.");
            }
#line 839
            return (-1);
          } else
#line 837
          if ((int )uid > 63) {
            {
#line 838
            lprintf(3, "User ID is limited to range <1..63>.");
            }
#line 839
            return (-1);
          }
          {
#line 842
          tmp___7 = strncmp((char const   *)*(argv + 1), "del", (size_t )3);
          }
#line 842
          if (tmp___7 == 0) {
            {
#line 843
            rc = ipmi_sunoem_sshkey_del(intf, uid);
            }
          } else
#line 845
          if (argc == 4) {
            {
#line 845
            tmp___6 = strncmp((char const   *)*(argv + 1), "set", (size_t )3);
            }
#line 845
            if (tmp___6 == 0) {
              {
#line 846
              rc = ipmi_sunoem_sshkey_set(intf, uid, *(argv + 3));
              }
            } else {
              {
#line 849
              ipmi_sunoem_usage();
              }
#line 850
              return (-1);
            }
          } else {
            {
#line 849
            ipmi_sunoem_usage();
            }
#line 850
            return (-1);
          }
        } else {
          {
#line 854
          ipmi_sunoem_usage();
          }
#line 855
          return (-1);
        }
      }
    }
  }
#line 858
  return (rc);
}
}
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 40 "../include/ipmitool/ipmi_fwum.h"
int ipmi_fwum_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static unsigned char fileName[512]  ;
#line 145 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static unsigned char firmBuf[524288]  ;
#line 146 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_SaveFirmwareInfo saveFirmwareInfo  ;
#line 148
static void KfwumOutputHelp(void) ;
#line 149
static void KfwumMain(struct ipmi_intf *intf , tKFWUM_Task task ) ;
#line 150
static tKFWUM_Status KfwumGetFileSize(unsigned char *pFileName , unsigned long *pFileSize ) ;
#line 152
static tKFWUM_Status KfwumSetupBuffersFromFile(unsigned char *pFileName , unsigned long fileSize ) ;
#line 154
static void KfwumShowProgress(unsigned char const   *task , unsigned long current ,
                              unsigned long total ) ;
#line 156
static unsigned short KfwumCalculateChecksumPadding(unsigned char *pBuffer , unsigned long totalSize ) ;
#line 160
static tKFWUM_Status KfwumGetInfo(struct ipmi_intf *intf , unsigned char output___1 ,
                                  unsigned char *pNumBank ) ;
#line 162
static tKFWUM_Status KfwumGetDeviceInfo(struct ipmi_intf *intf , unsigned char output___1 ,
                                        tKFWUM_BoardInfo *pBoardInfo ) ;
#line 164
static tKFWUM_Status KfwumGetStatus(struct ipmi_intf *intf ) ;
#line 165
static tKFWUM_Status KfwumManualRollback(struct ipmi_intf *intf ) ;
#line 166
static tKFWUM_Status KfwumStartFirmwareImage(struct ipmi_intf *intf , unsigned long length ,
                                             unsigned short padding___1 ) ;
#line 168
static tKFWUM_Status KfwumSaveFirmwareImage(struct ipmi_intf *intf , unsigned char sequenceNumber ,
                                            unsigned long address , unsigned char *pFirmBuf ,
                                            unsigned char *pInBufLength ) ;
#line 171
static tKFWUM_Status KfwumFinishFirmwareImage(struct ipmi_intf *intf , tKFWUM_InFirmwareInfo firmInfo ) ;
#line 173
static tKFWUM_Status KfwumUploadFirmware(struct ipmi_intf *intf , unsigned char *pBuffer ,
                                         unsigned long totalSize ) ;
#line 175
static tKFWUM_Status KfwumStartFirmwareUpgrade(struct ipmi_intf *intf ) ;
#line 177
static tKFWUM_Status KfwumGetInfoFromFirmware(unsigned char *pBuf , unsigned long bufSize ,
                                              tKFWUM_InFirmwareInfo *pInfo ) ;
#line 179
static void KfwumFixTableVersionForOldFirmware(tKFWUM_InFirmwareInfo *pInfo ) ;
#line 181
static tKFWUM_Status KfwumGetTraceLog(struct ipmi_intf *intf ) ;
#line 183
tKFWUM_Status KfwumValidFirmwareForBoard(tKFWUM_BoardInfo boardInfo , tKFWUM_InFirmwareInfo firmInfo ) ;
#line 185
static void KfwumOutputInfo(tKFWUM_BoardInfo boardInfo , tKFWUM_InFirmwareInfo firmInfo ) ;
#line 198 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
int ipmi_fwum_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 200
  printf((char const   */* __restrict  */)"FWUM extension Version %d.%d\n", 1, 3);
  }
#line 201
  if (! argc) {
    {
#line 203
    KfwumOutputHelp();
    }
  } else {
    {
#line 201
    tmp___9 = strncmp((char const   *)*(argv + 0), "help", (size_t )4);
    }
#line 201
    if (tmp___9) {
      {
#line 207
      tmp___8 = strncmp((char const   *)*(argv + 0), "info", (size_t )4);
      }
#line 207
      if (tmp___8) {
        {
#line 211
        tmp___7 = strncmp((char const   *)*(argv + 0), "status", (size_t )6);
        }
#line 211
        if (tmp___7) {
          {
#line 215
          tmp___6 = strncmp((char const   *)*(argv + 0), "rollback", (size_t )8);
          }
#line 215
          if (tmp___6) {
            {
#line 219
            tmp___5 = strncmp((char const   *)*(argv + 0), "download", (size_t )8);
            }
#line 219
            if (tmp___5) {
              {
#line 241
              tmp___4 = strncmp((char const   *)*(argv + 0), "upgrade", (size_t )7);
              }
#line 241
              if (tmp___4) {
                {
#line 263
                tmp___3 = strncmp((char const   *)*(argv + 0), "tracelog", (size_t )8);
                }
#line 263
                if (tmp___3) {
                  {
#line 269
                  printf((char const   */* __restrict  */)"Invalid KFWUM command: %s\n",
                         *(argv + 0));
                  }
                } else {
                  {
#line 265
                  KfwumMain(intf, (tKFWUM_Task )6);
                  }
                }
              } else
#line 243
              if (argc >= 2) {
                {
#line 243
                tmp___2 = strlen((char const   *)*(argv + 1));
                }
#line 243
                if (tmp___2 > 0UL) {
                  {
#line 246
                  tmp___1 = strlen((char const   *)*(argv + 1));
                  }
#line 246
                  if (tmp___1 < 512UL) {
                    {
#line 248
                    strcpy((char */* __restrict  */)((char *)(fileName)), (char const   */* __restrict  */)*(argv + 1));
#line 249
                    printf((char const   */* __restrict  */)"Upgrading using file name %s\n",
                           fileName);
#line 250
                    KfwumMain(intf, (tKFWUM_Task )3);
                    }
                  } else {
                    {
#line 254
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File name must be smaller than 512 bytes\n");
                    }
                  }
                } else {
                  {
#line 259
                  KfwumMain(intf, (tKFWUM_Task )4);
                  }
                }
              } else {
                {
#line 259
                KfwumMain(intf, (tKFWUM_Task )4);
                }
              }
            } else
#line 221
            if (argc >= 2) {
              {
#line 221
              tmp___0 = strlen((char const   *)*(argv + 1));
              }
#line 221
              if (tmp___0 > 0UL) {
                {
#line 224
                tmp = strlen((char const   *)*(argv + 1));
                }
#line 224
                if (tmp < 512UL) {
                  {
#line 226
                  strcpy((char */* __restrict  */)((char *)(fileName)), (char const   */* __restrict  */)*(argv + 1));
#line 227
                  printf((char const   */* __restrict  */)"Firmware File Name         : %s\n",
                         fileName);
#line 229
                  KfwumMain(intf, (tKFWUM_Task )2);
                  }
                } else {
                  {
#line 233
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File name must be smaller than 512 bytes\n");
                  }
                }
              } else {
                {
#line 238
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A path and a file name must be specified\n");
                }
              }
            } else {
              {
#line 238
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A path and a file name must be specified\n");
              }
            }
          } else {
            {
#line 217
            KfwumMain(intf, (tKFWUM_Task )5);
            }
          }
        } else {
          {
#line 213
          KfwumMain(intf, (tKFWUM_Task )1);
          }
        }
      } else {
        {
#line 209
        KfwumMain(intf, (tKFWUM_Task )0);
        }
      }
    } else {
      {
#line 203
      KfwumOutputHelp();
      }
    }
  }
#line 272
  return (0);
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static void KfwumOutputHelp(void) 
{ 


  {
  {
#line 278
  printf((char const   */* __restrict  */)"KFWUM Commands:  info status download upgrade rollback tracelog\n");
  }
#line 279
  return;
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static unsigned short padding  ;
#line 333 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static void KfwumMain(struct ipmi_intf *intf , tKFWUM_Task task ) 
{ 
  tKFWUM_Status status ;
  tKFWUM_BoardInfo boardInfo ;
  tKFWUM_InFirmwareInfo firmInfo ;
  unsigned long fileSize ;
  unsigned char notUsed ;
  unsigned char notUsed___0 ;

  {
#line 335
  status = (tKFWUM_Status )0;
#line 337
  firmInfo.fileSize = 0UL;
#line 337
  firmInfo.checksum = (unsigned short)0;
#line 337
  firmInfo.sumToRemoveFromChecksum = (unsigned short)0;
#line 337
  firmInfo.boardId = 0U;
#line 337
  firmInfo.deviceId = (unsigned char)0;
#line 337
  firmInfo.tableVers = (unsigned char)0;
#line 337
  firmInfo.implRev = (unsigned char)0;
#line 337
  firmInfo.versMajor = (unsigned char)0;
#line 337
  firmInfo.versMinor = (unsigned char)0;
#line 337
  firmInfo.versSubMinor = (unsigned char)0;
#line 337
  firmInfo.sdrRev = (unsigned char)0;
#line 337
  firmInfo.iana = 0U;
#line 338
  fileSize = 0UL;
#line 341
  if ((unsigned int )status == 0U) {
#line 341
    if ((unsigned int )task == 0U) {
#line 344
      if (verbose) {
        {
#line 346
        printf((char const   */* __restrict  */)"Getting Kontron FWUM Info\n");
        }
      }
      {
#line 348
      KfwumGetDeviceInfo(intf, (unsigned char)1, & boardInfo);
#line 349
      KfwumGetInfo(intf, (unsigned char)1, & notUsed);
      }
    }
  }
#line 354
  if ((unsigned int )status == 0U) {
#line 354
    if ((unsigned int )task == 1U) {
#line 356
      if (verbose) {
        {
#line 358
        printf((char const   */* __restrict  */)"Getting Kontron FWUM Status\n");
        }
      }
      {
#line 360
      KfwumGetStatus(intf);
      }
    }
  }
#line 363
  if ((unsigned int )status == 0U) {
#line 363
    if ((unsigned int )task == 5U) {
      {
#line 365
      status = KfwumManualRollback(intf);
      }
    }
  }
#line 368
  if ((unsigned int )status == 0U) {
#line 368
    if ((unsigned int )task == 3U) {
#line 368
      goto _L;
    } else
#line 368
    if ((unsigned int )task == 2U) {
      _L: /* CIL Label */ 
      {
#line 375
      status = KfwumGetFileSize(fileName, & fileSize);
      }
#line 376
      if ((unsigned int )status == 0U) {
        {
#line 378
        status = KfwumSetupBuffersFromFile(fileName, fileSize);
        }
#line 379
        if ((unsigned int )status == 0U) {
          {
#line 381
          padding = KfwumCalculateChecksumPadding(firmBuf, fileSize);
          }
        }
      }
#line 384
      if ((unsigned int )status == 0U) {
        {
#line 386
        status = KfwumGetInfoFromFirmware(firmBuf, fileSize, & firmInfo);
        }
      }
#line 388
      if ((unsigned int )status == 0U) {
        {
#line 390
        status = KfwumGetDeviceInfo(intf, (unsigned char)0, & boardInfo);
        }
      }
#line 393
      if ((unsigned int )status == 0U) {
        {
#line 395
        status = KfwumValidFirmwareForBoard(boardInfo, firmInfo);
        }
      }
#line 398
      if ((unsigned int )status == 0U) {
        {
#line 401
        KfwumGetInfo(intf, (unsigned char)0, & notUsed___0);
        }
      }
      {
#line 404
      KfwumOutputInfo(boardInfo, firmInfo);
      }
    }
  }
#line 407
  if ((unsigned int )status == 0U) {
#line 407
    if ((unsigned int )task == 3U) {
      {
#line 414
      status = KfwumStartFirmwareImage(intf, fileSize, padding);
      }
    } else
#line 407
    if ((unsigned int )task == 2U) {
      {
#line 414
      status = KfwumStartFirmwareImage(intf, fileSize, padding);
      }
    }
  }
#line 418
  if ((unsigned int )status == 0U) {
#line 418
    if ((unsigned int )task == 3U) {
      {
#line 425
      status = KfwumUploadFirmware(intf, firmBuf, fileSize);
      }
    } else
#line 418
    if ((unsigned int )task == 2U) {
      {
#line 425
      status = KfwumUploadFirmware(intf, firmBuf, fileSize);
      }
    }
  }
#line 428
  if ((unsigned int )status == 0U) {
#line 428
    if ((unsigned int )task == 3U) {
      {
#line 435
      status = KfwumFinishFirmwareImage(intf, firmInfo);
      }
    } else
#line 428
    if ((unsigned int )task == 2U) {
      {
#line 435
      status = KfwumFinishFirmwareImage(intf, firmInfo);
      }
    }
  }
#line 438
  if ((unsigned int )status == 0U) {
#line 438
    if ((unsigned int )task == 3U) {
      {
#line 445
      status = KfwumGetStatus(intf);
      }
    } else
#line 438
    if ((unsigned int )task == 2U) {
      {
#line 445
      status = KfwumGetStatus(intf);
      }
    }
  }
#line 448
  if ((unsigned int )status == 0U) {
#line 448
    if ((unsigned int )task == 3U) {
      {
#line 455
      status = KfwumStartFirmwareUpgrade(intf);
      }
    } else
#line 448
    if ((unsigned int )task == 4U) {
      {
#line 455
      status = KfwumStartFirmwareUpgrade(intf);
      }
    }
  }
#line 458
  if ((unsigned int )status == 0U) {
#line 458
    if ((unsigned int )task == 6U) {
      {
#line 460
      status = KfwumGetTraceLog(intf);
      }
    }
  }
#line 464
  return;
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumGetFileSize(unsigned char *pFileName , unsigned long *pFileSize ) 
{ 
  tKFWUM_Status status ;
  FILE *pFileHandle ;
  long tmp ;
  int tmp___0 ;

  {
  {
#line 476
  status = (tKFWUM_Status )1;
#line 479
  pFileHandle = fopen((char const   */* __restrict  */)((char const   *)pFileName),
                      (char const   */* __restrict  */)"rb");
  }
#line 481
  if (pFileHandle) {
    {
#line 483
    tmp___0 = fseek(pFileHandle, 0L, 2);
    }
#line 483
    if (tmp___0 == 0) {
      {
#line 485
      tmp = ftell(pFileHandle);
#line 485
      *pFileSize = (unsigned long )tmp;
      }
#line 487
      if (*pFileSize != 0UL) {
#line 489
        status = (tKFWUM_Status )0;
      }
    }
    {
#line 492
    fclose(pFileHandle);
    }
  }
#line 495
  return (status);
}
}
#line 506 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumSetupBuffersFromFile(unsigned char *pFileName , unsigned long fileSize ) 
{ 
  tKFWUM_Status status ;
  FILE *pFileHandle ;
  int count ;
  int modulus ;
  int qty ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 509
  status = (tKFWUM_Status )1;
#line 510
  pFileHandle = (FILE *)((void *)0);
#line 513
  qty = 0;
#line 515
  pFileHandle = fopen((char const   */* __restrict  */)((char const   *)pFileName),
                      (char const   */* __restrict  */)"rb");
  }
#line 516
  if ((unsigned long )pFileHandle == (unsigned long )((void *)0)) {
    {
#line 517
    lprintf(3, "Failed to open \'%s\' for reading.", (char *)pFileName);
    }
#line 519
    return ((tKFWUM_Status )1);
  }
  {
#line 521
  count = (int )((fileSize / 1024UL) * 16UL);
#line 522
  modulus = (int )((fileSize % 1024UL) * 16UL);
#line 524
  rewind(pFileHandle);
#line 525
  qty = 0;
  }
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    if (! (qty < count)) {
#line 525
      goto while_break;
    }
    {
#line 526
    KfwumShowProgress((unsigned char const   *)"Reading Firmware from File", (unsigned long )qty,
                      (unsigned long )count);
#line 528
    tmp = fread((void */* __restrict  */)(& firmBuf[(qty * 1024) * 16]), (size_t )1,
                (size_t )16384, (FILE */* __restrict  */)pFileHandle);
    }
#line 528
    if (tmp == 16384UL) {
#line 531
      status = (tKFWUM_Status )0;
    }
#line 525
    qty ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 534
  if (modulus) {
    {
#line 535
    tmp___0 = fread((void */* __restrict  */)(& firmBuf[(qty * 1024) * 16]), (size_t )1,
                    (size_t )modulus, (FILE */* __restrict  */)pFileHandle);
    }
#line 535
    if (tmp___0 == (size_t )modulus) {
#line 537
      status = (tKFWUM_Status )0;
    }
  }
#line 540
  if ((unsigned int )status == 0U) {
    {
#line 541
    KfwumShowProgress((unsigned char const   *)"Reading Firmware from File", 100UL,
                      100UL);
    }
  }
  {
#line 544
  fclose(pFileHandle);
  }
#line 545
  return (status);
}
}
#line 560 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static unsigned long staticProgress  =    4294967295UL;
#line 557 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static void KfwumShowProgress(unsigned char const   *task , unsigned long current ,
                              unsigned long total ) 
{ 
  unsigned char spaces[43] ;
  unsigned short hash ;
  float percent ;
  unsigned long progress ;

  {
#line 564
  percent = (float )current / (float )total;
#line 565
  progress = (unsigned long )((float )100 * percent);
#line 567
  if (! (staticProgress == progress)) {
    {
#line 573
    staticProgress = progress;
#line 576
    printf((char const   */* __restrict  */)"%-25s : ", task);
#line 578
    hash = (unsigned short )(percent * (float )42);
#line 579
    memset((void *)(spaces), '#', (size_t )hash);
#line 580
    spaces[hash] = (unsigned char )'\000';
#line 581
    printf((char const   */* __restrict  */)"%s", spaces);
#line 583
    memset((void *)(spaces), ' ', (size_t )(42 - (int )hash));
#line 584
    spaces[42 - (int )hash] = (unsigned char )'\000';
#line 585
    printf((char const   */* __restrict  */)"%s", spaces);
#line 588
    printf((char const   */* __restrict  */)" %3ld %%\r", progress);
    }
#line 590
    if (progress == 100UL) {
      {
#line 592
      printf((char const   */* __restrict  */)"\n");
      }
    }
    {
#line 594
    fflush(stdout);
    }
  }
#line 596
  return;
}
}
#line 603 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static unsigned short KfwumCalculateChecksumPadding(unsigned char *pBuffer , unsigned long totalSize ) 
{ 
  unsigned short sumOfBytes ;
  unsigned short padding___1 ;
  unsigned long counter ;

  {
#line 606
  sumOfBytes = (unsigned short)0;
#line 610
  counter = 0UL;
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 610
    if (! (counter < totalSize)) {
#line 610
      goto while_break;
    }
#line 612
    sumOfBytes = (unsigned short )((int )sumOfBytes + (int )*(pBuffer + counter));
#line 610
    counter ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 615
  padding___1 = (unsigned short )(0 - (int )sumOfBytes);
#line 616
  return (padding___1);
}
}
#line 654 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static struct KfwumGetInfoResp *pGetInfo  ;
#line 650 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumGetInfo(struct ipmi_intf *intf , unsigned char output___1 ,
                                  unsigned char *pNumBank ) 
{ 
  tKFWUM_Status status ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 653
  status = (tKFWUM_Status )0;
#line 658
  memset((void *)(& req), 0, sizeof(req));
#line 659
  req.msg.netfn = (uint8_t )8;
#line 660
  req.msg.cmd = (uint8_t )0;
#line 661
  req.msg.data_len = (uint16_t )0;
#line 663
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 665
  if (! rsp) {
    {
#line 667
    printf((char const   */* __restrict  */)"Error in FWUM Firmware Get Info Command\n");
#line 668
    status = (tKFWUM_Status )1;
    }
  } else
#line 670
  if (rsp->ccode) {
    {
#line 672
    printf((char const   */* __restrict  */)"FWUM Firmware Get Info returned %x\n",
           (int )rsp->ccode);
#line 673
    status = (tKFWUM_Status )1;
    }
  }
#line 676
  if ((unsigned int )status == 0U) {
#line 678
    pGetInfo = (struct KfwumGetInfoResp *)(rsp->data);
#line 679
    if (output___1) {
      {
#line 681
      printf((char const   */* __restrict  */)"\nFWUM info\n");
#line 682
      printf((char const   */* __restrict  */)"=========\n");
#line 683
      printf((char const   */* __restrict  */)"Protocol Revision         : %02Xh\n",
             (int )pGetInfo->protocolRevision);
#line 685
      printf((char const   */* __restrict  */)"Controller Device Id      : %02Xh\n",
             (int )pGetInfo->controllerDeviceId);
#line 687
      printf((char const   */* __restrict  */)"Firmware Revision         : %u.%u%u",
             (int )pGetInfo->firmRev1, (int )pGetInfo->firmRev2 >> 4, (int )pGetInfo->firmRev2 & 15);
      }
#line 690
      if ((int )pGetInfo->byte.mode != 0) {
        {
#line 692
        printf((char const   */* __restrict  */)" - DEBUG BUILD\n");
        }
      } else {
        {
#line 696
        printf((char const   */* __restrict  */)"\n");
        }
      }
      {
#line 698
      printf((char const   */* __restrict  */)"Number Of Memory Bank     : %u\n",
             (int )pGetInfo->numBank);
      }
    }
#line 700
    *pNumBank = pGetInfo->numBank;
#line 705
    if ((int )pGetInfo->protocolRevision <= 5) {
#line 705
      goto _L___1;
    } else
#line 705
    if (rsp->data_len < 7) {
      _L___1: /* CIL Label */ 
#line 707
      saveFirmwareInfo.downloadType = (tKFWUM_DownloadType )0;
#line 708
      saveFirmwareInfo.bufferSize = (unsigned char)32;
#line 709
      saveFirmwareInfo.overheadSize = (unsigned char)6;
#line 711
      if (verbose) {
        {
#line 713
        printf((char const   */* __restrict  */)"Protocol Revision          :");
#line 714
        printf((char const   */* __restrict  */)" <= 5 detected, adjusting buffers\n");
        }
      }
    } else {
#line 719
      saveFirmwareInfo.downloadType = (tKFWUM_DownloadType )1;
#line 720
      saveFirmwareInfo.overheadSize = (unsigned char)4;
#line 724
      if (verbose) {
        {
#line 726
        printf((char const   */* __restrict  */)"Protocol Revision          :");
#line 727
        printf((char const   */* __restrict  */)" > 5 optimizing buffers\n");
        }
      }
      {
#line 730
      tmp___0 = strstr((char const   *)(intf->name), "lan");
      }
#line 730
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 732
        saveFirmwareInfo.bufferSize = (unsigned char)32;
#line 733
        if (verbose) {
          {
#line 735
          printf((char const   */* __restrict  */)"IOL payload size           : %d\n",
                 (int )saveFirmwareInfo.bufferSize);
          }
        }
      } else {
        {
#line 739
        tmp = strstr((char const   *)(intf->name), "open");
        }
#line 739
        if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 739
          if (intf->target_addr != 32U) {
#line 739
            if (intf->target_addr != intf->my_addr) {
#line 750
              saveFirmwareInfo.bufferSize = (unsigned char)32;
#line 751
              if (verbose) {
                {
#line 753
                printf((char const   */* __restrict  */)"IPMB payload size          : %d\n",
                       (int )saveFirmwareInfo.bufferSize);
                }
              }
            } else {
#line 739
              goto _L___0;
            }
          } else {
#line 739
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 759
          saveFirmwareInfo.bufferSize = (unsigned char)32;
#line 760
          if (verbose) {
            {
#line 762
            printf((char const   */* __restrict  */)"SMI payload size           : %d\n",
                   (int )saveFirmwareInfo.bufferSize);
            }
          }
        }
      }
    }
  }
#line 768
  return (status);
}
}
#line 777 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumGetDeviceInfo(struct ipmi_intf *intf , unsigned char output___1 ,
                                        tKFWUM_BoardInfo *pBoardInfo ) 
{ 
  struct ipm_devid_rsp *pGetDevId ;
  tKFWUM_Status status ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint16_t tmp ;
  tKFWUM_BoardList tmp___0 ;

  {
#line 781
  status = (tKFWUM_Status )0;
#line 786
  if ((unsigned int )status == 0U) {
    {
#line 788
    memset((void *)(& req), 0, sizeof(req));
#line 789
    req.msg.netfn = (uint8_t )6;
#line 790
    req.msg.cmd = (uint8_t )1;
#line 791
    req.msg.data_len = (uint16_t )0;
#line 793
    rsp = (*(intf->sendrecv))(intf, & req);
    }
#line 794
    if (! rsp) {
      {
#line 796
      printf((char const   */* __restrict  */)"Error in Get Device Id Command\n");
#line 797
      status = (tKFWUM_Status )1;
      }
    } else
#line 799
    if (rsp->ccode) {
      {
#line 801
      printf((char const   */* __restrict  */)"Get Device Id returned %x\n", (int )rsp->ccode);
#line 802
      status = (tKFWUM_Status )1;
      }
    }
  }
#line 806
  if ((unsigned int )status == 0U) {
    {
#line 808
    pGetDevId = (struct ipm_devid_rsp *)(rsp->data);
#line 809
    pBoardInfo->iana = (tKFWUM_IanaList )((uint32_t )(((((int )pGetDevId->manufacturer_id[2] & 15) << 16) | ((int )pGetDevId->manufacturer_id[1] << 8)) | (int )pGetDevId->manufacturer_id[0]));
#line 810
    tmp = buf2short(pGetDevId->product_id);
#line 810
    pBoardInfo->boardId = (tKFWUM_BoardList )tmp;
    }
#line 811
    if (output___1) {
      {
#line 813
      printf((char const   */* __restrict  */)"\nIPMC Info\n");
#line 814
      printf((char const   */* __restrict  */)"=========\n");
#line 815
      printf((char const   */* __restrict  */)"Manufacturer Id           : %u\n",
             (unsigned int )pBoardInfo->iana);
#line 816
      printf((char const   */* __restrict  */)"Board Id                  : %u\n",
             (unsigned int )pBoardInfo->boardId);
#line 817
      printf((char const   */* __restrict  */)"Firmware Revision         : %u.%u%u",
             (int )pGetDevId->fw_rev1, (int )pGetDevId->fw_rev2 >> 4, (int )pGetDevId->fw_rev2 & 15);
      }
#line 820
      if ((unsigned int )pBoardInfo->iana == 15000U) {
#line 820
        tmp___0 = (tKFWUM_BoardList )5002;
#line 820
        pBoardInfo->boardId = tmp___0;
#line 820
        if (tmp___0) {
          {
#line 828
          printf((char const   */* __restrict  */)" SDR %u\n", (int )pGetDevId->aux_fw_rev[0]);
          }
        } else {
          {
#line 832
          printf((char const   */* __restrict  */)"\n");
          }
        }
      } else {
        {
#line 832
        printf((char const   */* __restrict  */)"\n");
        }
      }
    }
  }
#line 837
  return (status);
}
}
#line 858 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
struct valstr  const  bankStateValS[5]  = {      {(uint16_t )0, "Not programmed"}, 
        {(uint16_t )1, "New firmware"}, 
        {(uint16_t )2, "Wait for validation"}, 
        {(uint16_t )3, "Last Known Good"}, 
        {(uint16_t )4, "Previous Good"}};
#line 870 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumGetStatus(struct ipmi_intf *intf ) 
{ 
  tKFWUM_Status status ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct KfwumGetStatusResp *pGetStatus ;
  unsigned char numBank ;
  unsigned char counter ;
  char const   *tmp ;
  unsigned long firmLength ;

  {
#line 872
  status = (tKFWUM_Status )0;
#line 879
  if (verbose) {
    {
#line 881
    printf((char const   */* __restrict  */)" Getting Status!\n");
    }
  }
  {
#line 885
  status = KfwumGetInfo(intf, (unsigned char)0, & numBank);
#line 887
  counter = (unsigned char)0;
  }
  {
#line 887
  while (1) {
    while_continue: /* CIL Label */ ;
#line 887
    if ((int )counter < (int )numBank) {
#line 887
      if (! ((unsigned int )status == 0U)) {
#line 887
        goto while_break;
      }
    } else {
#line 887
      goto while_break;
    }
    {
#line 894
    memset((void *)(& req), 0, sizeof(req));
#line 895
    req.msg.netfn = (uint8_t )8;
#line 896
    req.msg.cmd = (uint8_t )7;
#line 897
    req.msg.data = & counter;
#line 898
    req.msg.data_len = (uint16_t )1;
#line 900
    rsp = (*(intf->sendrecv))(intf, & req);
    }
#line 902
    if (! rsp) {
      {
#line 904
      printf((char const   */* __restrict  */)"Error in FWUM Firmware Get Status Command\n");
#line 905
      status = (tKFWUM_Status )1;
      }
    } else
#line 907
    if (rsp->ccode) {
      {
#line 909
      printf((char const   */* __restrict  */)"FWUM Firmware Get Status returned %x\n",
             (int )rsp->ccode);
#line 910
      status = (tKFWUM_Status )1;
      }
    }
#line 914
    if ((unsigned int )status == 0U) {
      {
#line 916
      pGetStatus = (struct KfwumGetStatusResp *)(rsp->data);
#line 917
      tmp = val2str((uint16_t )pGetStatus->bankState, bankStateValS);
#line 917
      printf((char const   */* __restrict  */)"\nBank State %d               : %s\n",
             (int )counter, tmp);
      }
#line 919
      if (pGetStatus->bankState) {
        {
#line 922
        firmLength = (unsigned long )pGetStatus->firmLengthMSB;
#line 923
        firmLength <<= 8;
#line 924
        firmLength |= (unsigned long )pGetStatus->firmLengthMid;
#line 925
        firmLength <<= 8;
#line 926
        firmLength |= (unsigned long )pGetStatus->firmLengthLSB;
#line 928
        printf((char const   */* __restrict  */)"Firmware Length            : %ld bytes\n",
               firmLength);
#line 929
        printf((char const   */* __restrict  */)"Firmware Revision          : %u.%u%u SDR %u\n",
               (int )pGetStatus->firmRev1, (int )pGetStatus->firmRev2 >> 4, (int )pGetStatus->firmRev2 & 15,
               (int )pGetStatus->firmRev3);
        }
      }
    }
#line 887
    counter = (unsigned char )((int )counter + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 935
  printf((char const   */* __restrict  */)"\n");
  }
#line 936
  return (status);
}
}
#line 954 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumManualRollback(struct ipmi_intf *intf ) 
{ 
  tKFWUM_Status status ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct KfwumManualRollbackReq thisReq ;

  {
  {
#line 956
  status = (tKFWUM_Status )0;
#line 962
  memset((void *)(& req), 0, sizeof(req));
#line 963
  req.msg.netfn = (uint8_t )8;
#line 964
  req.msg.cmd = (uint8_t )14;
#line 966
  thisReq.type = (unsigned char)0;
#line 968
  req.msg.data = (unsigned char *)(& thisReq);
#line 969
  req.msg.data_len = (uint16_t )1;
#line 971
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 973
  if (! rsp) {
    {
#line 975
    printf((char const   */* __restrict  */)"Error in FWUM Manual Rollback Command\n");
#line 976
    status = (tKFWUM_Status )1;
    }
  } else
#line 978
  if (rsp->ccode) {
    {
#line 980
    printf((char const   */* __restrict  */)"Error in FWUM Manual Rollback Command returned %x\n",
           (int )rsp->ccode);
#line 982
    status = (tKFWUM_Status )1;
    }
  }
#line 985
  if ((unsigned int )status == 0U) {
    {
#line 987
    printf((char const   */* __restrict  */)"FWUM Starting Manual Rollback \n");
    }
  }
#line 989
  return (status);
}
}
#line 1017 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumStartFirmwareImage(struct ipmi_intf *intf , unsigned long length ,
                                             unsigned short padding___1 ) 
{ 
  tKFWUM_Status status ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct KfwumStartFirmwareDownloadResp *pResp ;
  struct KfwumStartFirmwareDownloadReq thisReq ;

  {
  {
#line 1020
  status = (tKFWUM_Status )0;
#line 1026
  thisReq.lengthLSB = (unsigned char )(length & 255UL);
#line 1027
  thisReq.lengthMid = (unsigned char )((length >> 8) & 255UL);
#line 1028
  thisReq.lengthMSB = (unsigned char )((length >> 16) & 255UL);
#line 1029
  thisReq.paddingLSB = (unsigned char )((int )padding___1 & 255);
#line 1030
  thisReq.paddingMSB = (unsigned char )(((int )padding___1 >> 8) & 255);
#line 1031
  thisReq.useSequence = (unsigned char)1;
#line 1033
  memset((void *)(& req), 0, sizeof(req));
#line 1034
  req.msg.netfn = (uint8_t )8;
#line 1035
  req.msg.cmd = (uint8_t )10;
#line 1036
  req.msg.data = (unsigned char *)(& thisReq);
  }
#line 1039
  if ((unsigned int )saveFirmwareInfo.downloadType == 0U) {
#line 1041
    req.msg.data_len = (uint16_t )5;
  } else {
#line 1045
    req.msg.data_len = (uint16_t )6;
  }
  {
#line 1048
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 1050
  if (! rsp) {
    {
#line 1052
    printf((char const   */* __restrict  */)"Error in FWUM Firmware Start Firmware Image Download Command\n");
#line 1053
    status = (tKFWUM_Status )1;
    }
  } else
#line 1055
  if (rsp->ccode) {
    {
#line 1057
    printf((char const   */* __restrict  */)"FWUM Firmware Start Firmware Image Download returned %x\n",
           (int )rsp->ccode);
#line 1059
    status = (tKFWUM_Status )1;
    }
  }
#line 1062
  if ((unsigned int )status == 0U) {
    {
#line 1064
    pResp = (struct KfwumStartFirmwareDownloadResp *)(rsp->data);
#line 1065
    printf((char const   */* __restrict  */)"Bank holding new firmware  : %d\n", (int )pResp->bank);
#line 1066
    sleep(5U);
    }
  }
#line 1068
  return (status);
}
}
#line 1101 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumSaveFirmwareImage(struct ipmi_intf *intf , unsigned char sequenceNumber ,
                                            unsigned long address , unsigned char *pFirmBuf ,
                                            unsigned char *pInBufLength ) 
{ 
  tKFWUM_Status status ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char out ;
  unsigned char retry ;
  unsigned char noResponse ;
  struct KfwumSaveFirmwareAddressReq addressReq ;
  struct KfwumSaveFirmwareSequenceReq sequenceReq ;
  char *tmp ;

  {
#line 1105
  status = (tKFWUM_Status )0;
#line 1108
  out = (unsigned char)0;
#line 1109
  retry = (unsigned char)0;
#line 1110
  noResponse = (unsigned char)0;
  {
#line 1115
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1117
    memset((void *)(& req), 0, sizeof(req));
#line 1118
    req.msg.netfn = (uint8_t )8;
#line 1119
    req.msg.cmd = (uint8_t )11;
    }
#line 1121
    if ((unsigned int )saveFirmwareInfo.downloadType == 0U) {
      {
#line 1123
      addressReq.addressLSB = (unsigned char )(address & 255UL);
#line 1124
      addressReq.addressMid = (unsigned char )((address >> 8) & 255UL);
#line 1125
      addressReq.addressMSB = (unsigned char )((address >> 16) & 255UL);
#line 1126
      addressReq.numBytes = *pInBufLength;
#line 1127
      memcpy((void */* __restrict  */)(addressReq.txBuf), (void const   */* __restrict  */)pFirmBuf,
             (size_t )*pInBufLength);
#line 1128
      req.msg.data = (unsigned char *)(& addressReq);
#line 1129
      req.msg.data_len = (uint16_t )((int )*pInBufLength + 4);
      }
    } else {
      {
#line 1133
      sequenceReq.sequenceNumber = sequenceNumber;
#line 1134
      memcpy((void */* __restrict  */)(sequenceReq.txBuf), (void const   */* __restrict  */)pFirmBuf,
             (size_t )*pInBufLength);
#line 1135
      req.msg.data = (unsigned char *)(& sequenceReq);
#line 1136
      req.msg.data_len = (uint16_t )((unsigned long )*pInBufLength + sizeof(unsigned char ));
      }
    }
    {
#line 1139
    rsp = (*(intf->sendrecv))(intf, & req);
    }
#line 1141
    if (! rsp) {
      {
#line 1143
      printf((char const   */* __restrict  */)"Error in FWUM Firmware Save Firmware Image Download Command\n");
#line 1145
      out = (unsigned char)0;
#line 1146
      status = (tKFWUM_Status )0;
#line 1150
      tmp = strstr((char const   *)(intf->name), "lan");
      }
#line 1150
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 1152
        noResponse = (unsigned char )((int )noResponse + 1);
#line 1154
        if ((int )noResponse < 6) {
#line 1156
          *pInBufLength = (unsigned char )((int )*pInBufLength - 1);
#line 1157
          out = (unsigned char)0;
        } else {
          {
#line 1161
          printf((char const   */* __restrict  */)"Error, too many commands without response\n");
#line 1162
          *pInBufLength = (unsigned char)0;
#line 1163
          out = (unsigned char)1;
          }
        }
      }
    } else
#line 1167
    if (rsp->ccode) {
#line 1169
      if ((int )rsp->ccode == 192) {
        {
#line 1171
        status = (tKFWUM_Status )0;
#line 1172
        sleep(1U);
        }
      } else
#line 1174
      if ((int )rsp->ccode == 199) {
#line 1183
        *pInBufLength = (unsigned char )((int )*pInBufLength - 1);
#line 1184
        status = (tKFWUM_Status )0;
#line 1185
        retry = (unsigned char)1;
      } else
#line 1174
      if ((int )rsp->ccode == 195) {
#line 1174
        if ((int )sequenceNumber == 0) {
#line 1183
          *pInBufLength = (unsigned char )((int )*pInBufLength - 1);
#line 1184
          status = (tKFWUM_Status )0;
#line 1185
          retry = (unsigned char)1;
        } else {
#line 1174
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1187
      if ((int )rsp->ccode == 130) {
#line 1190
        status = (tKFWUM_Status )0;
#line 1191
        out = (unsigned char)1;
      } else
#line 1193
      if ((int )rsp->ccode == 131) {
#line 1195
        if ((int )retry == 0) {
#line 1197
          retry = (unsigned char)1;
#line 1198
          status = (tKFWUM_Status )0;
        } else {
#line 1202
          status = (tKFWUM_Status )1;
#line 1203
          out = (unsigned char)1;
        }
      } else
#line 1206
      if ((int )rsp->ccode == 207) {
#line 1208
        retry = (unsigned char)1;
#line 1209
        status = (tKFWUM_Status )0;
      } else
#line 1211
      if ((int )rsp->ccode == 195) {
#line 1213
        if ((int )retry == 0) {
#line 1215
          retry = (unsigned char)1;
#line 1216
          status = (tKFWUM_Status )0;
        } else {
#line 1220
          status = (tKFWUM_Status )1;
#line 1221
          out = (unsigned char)1;
        }
      } else {
        {
#line 1226
        printf((char const   */* __restrict  */)"FWUM Firmware Save Firmware Image Download returned %x\n",
               (int )rsp->ccode);
#line 1228
        status = (tKFWUM_Status )1;
#line 1229
        out = (unsigned char)1;
        }
      }
    } else {
#line 1234
      out = (unsigned char)1;
    }
#line 1115
    if (! ((int )out == 0)) {
#line 1115
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1237
  return (status);
}
}
#line 1253 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumFinishFirmwareImage(struct ipmi_intf *intf , tKFWUM_InFirmwareInfo firmInfo ) 
{ 
  tKFWUM_Status status ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct KfwumFinishFirmwareDownloadReq thisReq ;

  {
  {
#line 1256
  status = (tKFWUM_Status )0;
#line 1261
  thisReq.versionMaj = firmInfo.versMajor;
#line 1262
  thisReq.versionMinSub = (unsigned char )(((int )firmInfo.versMinor << 4) | (int )firmInfo.versSubMinor);
#line 1263
  thisReq.versionSdr = firmInfo.sdrRev;
#line 1264
  thisReq.reserved = (unsigned char)0;
#line 1267
  memset((void *)(& req), 0, sizeof(req));
#line 1268
  req.msg.netfn = (uint8_t )8;
#line 1269
  req.msg.cmd = (uint8_t )12;
#line 1270
  req.msg.data = (unsigned char *)(& thisReq);
#line 1271
  req.msg.data_len = (uint16_t )4;
  }
  {
#line 1273
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1275
    rsp = (*(intf->sendrecv))(intf, & req);
    }
#line 1273
    if (! ((unsigned long )rsp == (unsigned long )((void *)0))) {
#line 1273
      if (! ((int )rsp->ccode == 192)) {
#line 1273
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1278
  if (! rsp) {
    {
#line 1280
    printf((char const   */* __restrict  */)"Error in FWUM Firmware Finish Firmware Image Download Command\n");
#line 1281
    status = (tKFWUM_Status )1;
    }
  } else
#line 1283
  if (rsp->ccode) {
    {
#line 1285
    printf((char const   */* __restrict  */)"FWUM Firmware Finish Firmware Image Download returned %x\n",
           (int )rsp->ccode);
#line 1287
    status = (tKFWUM_Status )1;
    }
  }
#line 1290
  return (status);
}
}
#line 1295 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumUploadFirmware(struct ipmi_intf *intf , unsigned char *pBuffer ,
                                         unsigned long totalSize ) 
{ 
  tKFWUM_Status status ;
  unsigned long address ;
  unsigned char writeSize ;
  unsigned char oldWriteSize ;
  unsigned long lastAddress ;
  unsigned char sequenceNumber ;
  unsigned char retry ;
  unsigned char isLengthValid ;
  unsigned char tmp ;

  {
#line 1298
  status = (tKFWUM_Status )1;
#line 1299
  address = 0UL;
#line 1302
  lastAddress = 0UL;
#line 1303
  sequenceNumber = (unsigned char)0;
#line 1304
  retry = (unsigned char)6;
#line 1305
  isLengthValid = (unsigned char)1;
  {
#line 1307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1309
    writeSize = (unsigned char )((int )saveFirmwareInfo.bufferSize - (int )saveFirmwareInfo.overheadSize);
#line 1312
    if (address + (unsigned long )writeSize > totalSize) {
#line 1314
      writeSize = (unsigned char )(totalSize - address);
    } else
#line 1317
    if (address % 256UL + (unsigned long )writeSize > 256UL) {
#line 1319
      writeSize = (unsigned char )(256UL - address % 256UL);
    }
    {
#line 1322
    oldWriteSize = writeSize;
#line 1323
    status = KfwumSaveFirmwareImage(intf, sequenceNumber, address, pBuffer + address,
                                    & writeSize);
    }
#line 1326
    if ((unsigned int )status != 0U) {
#line 1326
      tmp = retry;
#line 1326
      retry = (unsigned char )((int )retry - 1);
#line 1326
      if ((int )tmp != 0) {
#line 1328
        address = lastAddress;
#line 1329
        status = (tKFWUM_Status )0;
      } else {
#line 1326
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1331
    if ((int )writeSize == 0) {
#line 1333
      status = (tKFWUM_Status )1;
    } else {
#line 1337
      if ((int )writeSize != (int )oldWriteSize) {
        {
#line 1339
        printf((char const   */* __restrict  */)"Adjusting length to %d bytes \n",
               (int )writeSize);
#line 1340
        saveFirmwareInfo.bufferSize = (unsigned char )((int )saveFirmwareInfo.bufferSize - ((int )oldWriteSize - (int )writeSize));
        }
      }
#line 1343
      retry = (unsigned char)6;
#line 1344
      lastAddress = address;
#line 1345
      address += (unsigned long )writeSize;
    }
#line 1348
    if ((unsigned int )status == 0U) {
#line 1350
      if (address % 1024UL == 0UL) {
        {
#line 1352
        KfwumShowProgress((unsigned char const   *)"Writting Firmware in Flash", address,
                          totalSize);
        }
      }
#line 1355
      sequenceNumber = (unsigned char )((int )sequenceNumber + 1);
    }
#line 1307
    if ((unsigned int )status == 0U) {
#line 1307
      if (! (address < totalSize)) {
#line 1307
        goto while_break;
      }
    } else {
#line 1307
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1360
  if ((unsigned int )status == 0U) {
    {
#line 1362
    KfwumShowProgress((unsigned char const   *)"Writting Firmware in Flash", 100UL,
                      100UL);
    }
  }
#line 1366
  return (status);
}
}
#line 1369 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumStartFirmwareUpgrade(struct ipmi_intf *intf ) 
{ 
  tKFWUM_Status status ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char upgType ;

  {
  {
#line 1371
  status = (tKFWUM_Status )0;
#line 1374
  upgType = (unsigned char)0;
#line 1376
  memset((void *)(& req), 0, sizeof(req));
#line 1377
  req.msg.netfn = (uint8_t )8;
#line 1378
  req.msg.cmd = (uint8_t )9;
#line 1379
  req.msg.data = & upgType;
#line 1380
  req.msg.data_len = (uint16_t )1;
#line 1382
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 1384
  if (! rsp) {
    {
#line 1386
    printf((char const   */* __restrict  */)"Error in FWUM Firmware Start Firmware Upgrade Command\n");
#line 1387
    status = (tKFWUM_Status )1;
    }
  } else
#line 1389
  if (rsp->ccode) {
#line 1391
    if ((int )rsp->ccode == 213) {
      {
#line 1393
      printf((char const   */* __restrict  */)"No firmware available for upgrade.  Download Firmware first\n");
      }
    } else {
      {
#line 1397
      printf((char const   */* __restrict  */)"FWUM Firmware Start Firmware Upgrade returned %x\n",
             (int )rsp->ccode);
      }
    }
#line 1400
    status = (tKFWUM_Status )1;
  }
#line 1403
  return (status);
}
}
#line 1411 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static char const   *CMD_ID_STRING[16]  = 
#line 1411
  {      "GetFwInfo",      "KickWatchdog",      "GetLastAnswer",      "BootHandshake", 
        "ReportStatus",      "CtrlIPMBLine",      "SetFwState",      "GetFwStatus", 
        "GetSpiMemStatus",      "StartFwUpdate",      "StartFwImage",      "SaveFwImage", 
        "FinishFwImage",      "ReadFwImage",      "ManualRollback",      "GetTraceLog"};
#line 1429 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static char const   *EXT_CMD_ID_STRING[6]  = {      "FwUpgradeLock",      "ProcessFwUpg",      "ProcessFwRb",      "WaitHSAfterUpg", 
        "WaitFirstHSUpg",      "FwInfoStateChange"};
#line 1438 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static char const   *CMD_STATE_STRING[4]  = {      "Invalid",      "Begin",      "Progress",      "Completed"};
#line 1445 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumGetTraceLog(struct ipmi_intf *intf ) 
{ 
  tKFWUM_Status status ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char chunkIdx ;
  unsigned char cmdIdx ;

  {
#line 1447
  status = (tKFWUM_Status )0;
#line 1453
  if (verbose) {
    {
#line 1455
    printf((char const   */* __restrict  */)" Getting Trace Log!\n");
    }
  }
#line 1458
  chunkIdx = (unsigned char)0;
  {
#line 1458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1458
    if ((int )chunkIdx < 7) {
#line 1458
      if (! ((unsigned int )status == 0U)) {
#line 1458
        goto while_break;
      }
    } else {
#line 1458
      goto while_break;
    }
    {
#line 1461
    memset((void *)(& req), 0, sizeof(req));
#line 1462
    req.msg.netfn = (uint8_t )8;
#line 1463
    req.msg.cmd = (uint8_t )15;
#line 1464
    req.msg.data = & chunkIdx;
#line 1465
    req.msg.data_len = (uint16_t )1;
#line 1467
    rsp = (*(intf->sendrecv))(intf, & req);
    }
#line 1469
    if (! rsp) {
      {
#line 1471
      printf((char const   */* __restrict  */)"Error in FWUM Firmware Get Trace Log Command\n");
#line 1472
      status = (tKFWUM_Status )1;
      }
    } else
#line 1474
    if (rsp->ccode) {
      {
#line 1476
      printf((char const   */* __restrict  */)"FWUM Firmware Get Trace Log returned %x\n",
             (int )rsp->ccode);
#line 1477
      status = (tKFWUM_Status )1;
      }
    }
#line 1480
    if ((unsigned int )status == 0U) {
#line 1482
      cmdIdx = (unsigned char)0;
      {
#line 1482
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1482
        if (! ((int )cmdIdx < 7)) {
#line 1482
          goto while_break___0;
        }
#line 1485
        if ((int )rsp->data[3 * (int )cmdIdx + 1] != 0) {
#line 1485
          if ((int )rsp->data[3 * (int )cmdIdx] < 16) {
            {
#line 1488
            printf((char const   */* __restrict  */)"  Cmd ID: %17s -- CmdState: %10s -- CompCode: %2x\n",
                   CMD_ID_STRING[rsp->data[3 * (int )cmdIdx]], CMD_STATE_STRING[rsp->data[3 * (int )cmdIdx + 1]],
                   (int )rsp->data[3 * (int )cmdIdx + 2]);
            }
          } else {
#line 1485
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 1493
        if ((int )rsp->data[3 * (int )cmdIdx + 1] != 0) {
#line 1493
          if ((int )rsp->data[3 * (int )cmdIdx] >= 192) {
            {
#line 1496
            printf((char const   */* __restrict  */)"  Cmd ID: %17s -- CmdState: %10s -- CompCode: %2x\n",
                   EXT_CMD_ID_STRING[(int )rsp->data[3 * (int )cmdIdx] - 192], CMD_STATE_STRING[rsp->data[3 * (int )cmdIdx + 1]],
                   (int )rsp->data[3 * (int )cmdIdx + 2]);
            }
          }
        }
#line 1482
        cmdIdx = (unsigned char )((int )cmdIdx + 1);
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1458
    chunkIdx = (unsigned char )((int )chunkIdx + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1504
  printf((char const   */* __restrict  */)"\n");
  }
#line 1505
  return (status);
}
}
#line 1549 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumGetInfoFromFirmware(unsigned char *pBuf , unsigned long bufSize ,
                                              tKFWUM_InFirmwareInfo *pInfo ) 
{ 
  tKFWUM_Status status ;
  unsigned long offset ;

  {
#line 1552
  status = (tKFWUM_Status )1;
#line 1554
  if (bufSize >= 1460UL) {
    {
#line 1556
    offset = 1440UL;
#line 1559
    pInfo->checksum = (unsigned short )((int )((unsigned short )*(pBuf + (offset + 4UL))) << 8);
#line 1561
    pInfo->checksum = (unsigned short )((int )pInfo->checksum | (int )((unsigned short )*(pBuf + ((offset + 1UL) + 4UL))));
#line 1565
    pInfo->sumToRemoveFromChecksum = (unsigned short )*(pBuf + (offset + 4UL));
#line 1569
    pInfo->sumToRemoveFromChecksum = (unsigned short )((int )pInfo->sumToRemoveFromChecksum + (int )*(pBuf + ((offset + 4UL) + 1UL)));
#line 1573
    pInfo->fileSize = (unsigned long )((int )*(pBuf + offset) << 24);
#line 1576
    pInfo->fileSize |= (unsigned long )*(pBuf + (offset + 1UL)) << 16;
#line 1579
    pInfo->fileSize |= (unsigned long )*(pBuf + (offset + 2UL)) << 8;
#line 1582
    pInfo->fileSize |= (unsigned long )*(pBuf + (offset + 3UL));
#line 1586
    pInfo->boardId = (tKFWUM_BoardList )((int )*(pBuf + (offset + 6UL)) << 8);
#line 1589
    pInfo->boardId = (tKFWUM_BoardList )((unsigned int )pInfo->boardId | (unsigned int )*(pBuf + ((offset + 6UL) + 1UL)));
#line 1593
    pInfo->deviceId = *(pBuf + (offset + 8UL));
#line 1597
    pInfo->tableVers = *(pBuf + (offset + 9UL));
#line 1600
    pInfo->implRev = *(pBuf + (offset + 10UL));
#line 1603
    pInfo->versMajor = (unsigned char )((int )*(pBuf + (offset + 11UL)) & 15);
#line 1606
    pInfo->versMinor = (unsigned char )(((int )*(pBuf + (offset + 12UL)) >> 4) & 15);
#line 1609
    pInfo->versSubMinor = (unsigned char )((int )*(pBuf + (offset + 12UL)) & 15);
#line 1612
    pInfo->sdrRev = *(pBuf + (offset + 13UL));
#line 1615
    pInfo->iana = (tKFWUM_IanaList )((int )*(pBuf + (offset + 16UL)) << 16);
#line 1618
    pInfo->iana = (tKFWUM_IanaList )((unsigned long )pInfo->iana | ((unsigned long )*(pBuf + (offset + 15UL)) << 8));
#line 1621
    pInfo->iana = (tKFWUM_IanaList )((unsigned long )pInfo->iana | (unsigned long )*(pBuf + (offset + 14UL)));
#line 1625
    KfwumFixTableVersionForOldFirmware(pInfo);
#line 1627
    status = (tKFWUM_Status )0;
    }
  }
#line 1629
  return (status);
}
}
#line 1633 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static void KfwumFixTableVersionForOldFirmware(tKFWUM_InFirmwareInfo *pInfo ) 
{ 


  {
  {
#line 1637
  if ((unsigned int )pInfo->boardId == 0U) {
#line 1637
    goto case_0;
  }
#line 1640
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1638
  pInfo->tableVers = (unsigned char)255;
#line 1639
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1642
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1644
  return;
}
}
#line 1647 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
tKFWUM_Status KfwumValidFirmwareForBoard(tKFWUM_BoardInfo boardInfo , tKFWUM_InFirmwareInfo firmInfo ) 
{ 
  tKFWUM_Status status ;

  {
#line 1650
  status = (tKFWUM_Status )0;
#line 1652
  if ((unsigned int )boardInfo.iana != (unsigned int )firmInfo.iana) {
    {
#line 1654
    printf((char const   */* __restrict  */)"Board IANA does not match firmware IANA\n");
#line 1655
    status = (tKFWUM_Status )1;
    }
  }
#line 1658
  if ((unsigned int )boardInfo.boardId != (unsigned int )firmInfo.boardId) {
    {
#line 1660
    printf((char const   */* __restrict  */)"Board IANA does not match firmware IANA\n");
#line 1661
    status = (tKFWUM_Status )1;
    }
  }
#line 1665
  if ((unsigned int )status == 1U) {
    {
#line 1667
    printf((char const   */* __restrict  */)"Firmware invalid for target board.  Download of upgrade aborted\n");
    }
  }
#line 1669
  return (status);
}
}
#line 1673 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static void KfwumOutputInfo(tKFWUM_BoardInfo boardInfo , tKFWUM_InFirmwareInfo firmInfo ) 
{ 


  {
  {
#line 1676
  printf((char const   */* __restrict  */)"Target Board Id            : %u\n", (unsigned int )boardInfo.boardId);
#line 1677
  printf((char const   */* __restrict  */)"Target IANA number         : %u\n", (unsigned int )boardInfo.iana);
#line 1678
  printf((char const   */* __restrict  */)"File Size                  : %lu bytes\n",
         firmInfo.fileSize);
#line 1679
  printf((char const   */* __restrict  */)"Firmware Version           : %d.%d%d SDR %d\n",
         (int )firmInfo.versMajor, (int )firmInfo.versMinor, (int )firmInfo.versSubMinor,
         (int )firmInfo.sdrRev);
  }
#line 1681
  return;
}
}
#line 909 "../include/ipmitool/ipmi_sdr.h"
extern struct ipmi_rs *ipmi_sdr_get_sensor_hysteresis(struct ipmi_intf *intf , uint8_t sensor ,
                                                      uint8_t target , uint8_t lun ,
                                                      uint8_t channel ) ;
#line 945
extern void ipmi_sdr_print_discrete_state_mini(char const   *header , char const   *separator ,
                                               uint8_t sensor_type , uint8_t event_type ,
                                               uint8_t state1 , uint8_t state2 ) ;
#line 227 "../include/ipmitool/ipmi_sel.h"
static struct ipmi_event_sensor_types generic_event_types[58]  __attribute__((__unused__))  = 
#line 227 "../include/ipmitool/ipmi_sel.h"
  {      {(uint8_t )1, (uint8_t )0, (uint8_t )255, (uint8_t )2, "Threshold", "Lower Non-critical going low "}, 
        {(uint8_t )1,
      (uint8_t )1, (uint8_t )255, (uint8_t )2, "Threshold", "Lower Non-critical going high"}, 
        {(uint8_t )1,
      (uint8_t )2, (uint8_t )255, (uint8_t )2, "Threshold", "Lower Critical going low "}, 
        {(uint8_t )1,
      (uint8_t )3, (uint8_t )255, (uint8_t )2, "Threshold", "Lower Critical going high"}, 
        {(uint8_t )1,
      (uint8_t )4, (uint8_t )255, (uint8_t )2, "Threshold", "Lower Non-recoverable going low "}, 
        {(uint8_t )1,
      (uint8_t )5, (uint8_t )255, (uint8_t )2, "Threshold", "Lower Non-recoverable going high"}, 
        {(uint8_t )1,
      (uint8_t )6, (uint8_t )255, (uint8_t )2, "Threshold", "Upper Non-critical going low "}, 
        {(uint8_t )1,
      (uint8_t )7, (uint8_t )255, (uint8_t )2, "Threshold", "Upper Non-critical going high"}, 
        {(uint8_t )1,
      (uint8_t )8, (uint8_t )255, (uint8_t )2, "Threshold", "Upper Critical going low "}, 
        {(uint8_t )1,
      (uint8_t )9, (uint8_t )255, (uint8_t )2, "Threshold", "Upper Critical going high"}, 
        {(uint8_t )1,
      (uint8_t )10, (uint8_t )255, (uint8_t )2, "Threshold", "Upper Non-recoverable going low "}, 
        {(uint8_t )1,
      (uint8_t )11, (uint8_t )255, (uint8_t )2, "Threshold", "Upper Non-recoverable going high"}, 
        {(uint8_t )2,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Usage State", "Transition to Idle"}, 
        {(uint8_t )2,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Usage State", "Transition to Active"}, 
        {(uint8_t )2,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Usage State", "Transition to Busy"}, 
        {(uint8_t )3,
      (uint8_t )0, (uint8_t )255, (uint8_t )1, "Digital State", "State Deasserted"}, 
        {(uint8_t )3,
      (uint8_t )1, (uint8_t )255, (uint8_t )1, "Digital State", "State Asserted"}, 
        {(uint8_t )4,
      (uint8_t )0, (uint8_t )255, (uint8_t )1, "Digital State", "Predictive Failure Deasserted"}, 
        {(uint8_t )4,
      (uint8_t )1, (uint8_t )255, (uint8_t )1, "Digital State", "Predictive Failure Asserted"}, 
        {(uint8_t )5,
      (uint8_t )0, (uint8_t )255, (uint8_t )1, "Digital State", "Limit Not Exceeded"}, 
        {(uint8_t )5,
      (uint8_t )1, (uint8_t )255, (uint8_t )1, "Digital State", "Limit Exceeded"}, 
        {(uint8_t )6,
      (uint8_t )0, (uint8_t )255, (uint8_t )1, "Digital State", "Performance Met"}, 
        {(uint8_t )6,
      (uint8_t )1, (uint8_t )255, (uint8_t )1, "Digital State", "Performance Lags"}, 
        {(uint8_t )7,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Severity State", "Transition to OK"}, 
        {(uint8_t )7,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Severity State", "Transition to Non-critical from OK"}, 
        {(uint8_t )7,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Severity State", "Transition to Critical from less severe"}, 
        {(uint8_t )7,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Severity State", "Transition to Non-recoverable from less severe"}, 
        {(uint8_t )7,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Severity State", "Transition to Non-critical from more severe"}, 
        {(uint8_t )7,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Severity State", "Transition to Critical from Non-recoverable"}, 
        {(uint8_t )7,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "Severity State", "Transition to Non-recoverable"}, 
        {(uint8_t )7,
      (uint8_t )7, (uint8_t )255, (uint8_t )0, "Severity State", "Monitor"}, 
        {(uint8_t )7, (uint8_t )8, (uint8_t )255, (uint8_t )0, "Severity State", "Informational"}, 
        {(uint8_t )8,
      (uint8_t )0, (uint8_t )255, (uint8_t )1, "Availability State", "Device Absent"}, 
        {(uint8_t )8,
      (uint8_t )1, (uint8_t )255, (uint8_t )1, "Availability State", "Device Present"}, 
        {(uint8_t )9,
      (uint8_t )0, (uint8_t )255, (uint8_t )1, "Availability State", "Device Disabled"}, 
        {(uint8_t )9,
      (uint8_t )1, (uint8_t )255, (uint8_t )1, "Availability State", "Device Enabled"}, 
        {(uint8_t )10,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Availability State", "Transition to Running"}, 
        {(uint8_t )10,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Availability State", "Transition to In Test"}, 
        {(uint8_t )10,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Availability State", "Transition to Power Off"}, 
        {(uint8_t )10,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Availability State", "Transition to On Line"}, 
        {(uint8_t )10,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Availability State", "Transition to Off Line"}, 
        {(uint8_t )10,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Availability State", "Transition to Off Duty"}, 
        {(uint8_t )10,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "Availability State", "Transition to Degraded"}, 
        {(uint8_t )10,
      (uint8_t )7, (uint8_t )255, (uint8_t )0, "Availability State", "Transition to Power Save"}, 
        {(uint8_t )10,
      (uint8_t )8, (uint8_t )255, (uint8_t )0, "Availability State", "Install Error"}, 
        {(uint8_t )11,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Redundancy State", "Fully Redundant"}, 
        {(uint8_t )11,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Redundancy State", "Redundancy Lost"}, 
        {(uint8_t )11,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Redundancy State", "Redundancy Degraded"}, 
        {(uint8_t )11,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Redundancy State", "Non-Redundant: Sufficient from Redundant"}, 
        {(uint8_t )11,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Redundancy State", "Non-Redundant: Sufficient from Insufficient"}, 
        {(uint8_t )11,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Redundancy State", "Non-Redundant: Insufficient Resources"}, 
        {(uint8_t )11,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "Redundancy State", "Redundancy Degraded from Fully Redundant"}, 
        {(uint8_t )11,
      (uint8_t )7, (uint8_t )255, (uint8_t )0, "Redundancy State", "Redundancy Degraded from Non-Redundant"}, 
        {(uint8_t )12,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "ACPI Device Power State", "D0 Power State"}, 
        {(uint8_t )12,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "ACPI Device Power State", "D1 Power State"}, 
        {(uint8_t )12,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "ACPI Device Power State", "D2 Power State"}, 
        {(uint8_t )12,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "ACPI Device Power State", "D3 Power State"}, 
        {(uint8_t )0,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 296 "../include/ipmitool/ipmi_sel.h"
static struct ipmi_event_sensor_types sensor_specific_types[340]  __attribute__((__unused__))  = 
#line 296
  {      {(uint8_t )0, (uint8_t )0, (uint8_t )255, (uint8_t )0, "Reserved", (char const   *)((void *)0)}, 
        {(uint8_t )1,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Temperature", (char const   *)((void *)0)}, 
        {(uint8_t )2,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Voltage", (char const   *)((void *)0)}, 
        {(uint8_t )3,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Current", (char const   *)((void *)0)}, 
        {(uint8_t )4,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Fan", (char const   *)((void *)0)}, 
        {(uint8_t )5,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Physical Security", "General Chassis intrusion"}, 
        {(uint8_t )5,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Physical Security", "Drive Bay intrusion"}, 
        {(uint8_t )5,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Physical Security", "I/O Card area intrusion"}, 
        {(uint8_t )5,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Physical Security", "Processor area intrusion"}, 
        {(uint8_t )5,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Physical Security", "System unplugged from LAN"}, 
        {(uint8_t )5,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Physical Security", "Unauthorized dock"}, 
        {(uint8_t )5,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "Physical Security", "FAN area intrusion"}, 
        {(uint8_t )6,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Platform Security", "Front Panel Lockout violation attempted"}, 
        {(uint8_t )6,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Platform Security", "Pre-boot password violation - user password"}, 
        {(uint8_t )6,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Platform Security", "Pre-boot password violation - setup password"}, 
        {(uint8_t )6,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Platform Security", "Pre-boot password violation - network boot password"}, 
        {(uint8_t )6,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Platform Security", "Other pre-boot password violation"}, 
        {(uint8_t )6,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Platform Security", "Out-of-band access password violation"}, 
        {(uint8_t )7,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Processor", "IERR"}, 
        {(uint8_t )7, (uint8_t )1, (uint8_t )255, (uint8_t )0, "Processor", "Thermal Trip"}, 
        {(uint8_t )7,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Processor", "FRB1/BIST failure"}, 
        {(uint8_t )7, (uint8_t )3, (uint8_t )255, (uint8_t )0, "Processor", "FRB2/Hang in POST failure"}, 
        {(uint8_t )7,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Processor", "FRB3/Processor startup/init failure"}, 
        {(uint8_t )7,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Processor", "Configuration Error"}, 
        {(uint8_t )7,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "Processor", "SM BIOS Uncorrectable CPU-complex Error"}, 
        {(uint8_t )7,
      (uint8_t )7, (uint8_t )255, (uint8_t )0, "Processor", "Presence detected"}, 
        {(uint8_t )7, (uint8_t )8, (uint8_t )255, (uint8_t )0, "Processor", "Disabled"}, 
        {(uint8_t )7,
      (uint8_t )9, (uint8_t )255, (uint8_t )0, "Processor", "Terminator presence detected"}, 
        {(uint8_t )7,
      (uint8_t )10, (uint8_t )255, (uint8_t )0, "Processor", "Throttled"}, 
        {(uint8_t )8, (uint8_t )0, (uint8_t )255, (uint8_t )0, "Power Supply", "Presence detected"}, 
        {(uint8_t )8,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Power Supply", "Failure detected"}, 
        {(uint8_t )8,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Power Supply", "Predictive failure"}, 
        {(uint8_t )8,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Power Supply", "Power Supply AC lost"}, 
        {(uint8_t )8,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Power Supply", "AC lost or out-of-range"}, 
        {(uint8_t )8,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Power Supply", "AC out-of-range, but present"}, 
        {(uint8_t )8,
      (uint8_t )6, (uint8_t )0, (uint8_t )0, "Power Supply", "Config Error: Vendor Mismatch"}, 
        {(uint8_t )8,
      (uint8_t )6, (uint8_t )1, (uint8_t )0, "Power Supply", "Config Error: Revision Mismatch"}, 
        {(uint8_t )8,
      (uint8_t )6, (uint8_t )2, (uint8_t )0, "Power Supply", "Config Error: Processor Missing"}, 
        {(uint8_t )8,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "Power Supply", "Config Error"}, 
        {(uint8_t )9, (uint8_t )0, (uint8_t )255, (uint8_t )0, "Power Unit", "Power off/down"}, 
        {(uint8_t )9,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Power Unit", "Power cycle"}, 
        {(uint8_t )9, (uint8_t )2, (uint8_t )255, (uint8_t )0, "Power Unit", "240VA power down"}, 
        {(uint8_t )9,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Power Unit", "Interlock power down"}, 
        {(uint8_t )9,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Power Unit", "AC lost"}, 
        {(uint8_t )9, (uint8_t )5, (uint8_t )255, (uint8_t )0, "Power Unit", "Soft-power control failure"}, 
        {(uint8_t )9,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "Power Unit", "Failure detected"}, 
        {(uint8_t )9, (uint8_t )7, (uint8_t )255, (uint8_t )0, "Power Unit", "Predictive failure"}, 
        {(uint8_t )10,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Cooling Device", (char const   *)((void *)0)}, 
        {(uint8_t )11,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Other Units-based Sensor", (char const   *)((void *)0)}, 
        {(uint8_t )12,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Memory", "Correctable ECC"}, 
        {(uint8_t )12, (uint8_t )1, (uint8_t )255, (uint8_t )0, "Memory", "Uncorrectable ECC"}, 
        {(uint8_t )12,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Memory", "Parity"}, 
        {(uint8_t )12, (uint8_t )3, (uint8_t )255, (uint8_t )0, "Memory", "Memory Scrub Failed"}, 
        {(uint8_t )12,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Memory", "Memory Device Disabled"}, 
        {(uint8_t )12,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Memory", "Correctable ECC logging limit reached"}, 
        {(uint8_t )12,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "Memory", "Presence Detected"}, 
        {(uint8_t )12, (uint8_t )7, (uint8_t )255, (uint8_t )0, "Memory", "Configuration Error"}, 
        {(uint8_t )12,
      (uint8_t )8, (uint8_t )255, (uint8_t )0, "Memory", "Spare"}, 
        {(uint8_t )12, (uint8_t )9, (uint8_t )255, (uint8_t )0, "Memory", "Throttled"}, 
        {(uint8_t )13,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Drive Slot", "Drive Present"}, 
        {(uint8_t )13, (uint8_t )1, (uint8_t )255, (uint8_t )0, "Drive Slot", "Drive Fault"}, 
        {(uint8_t )13,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Drive Slot", "Predictive Failure"}, 
        {(uint8_t )13,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Drive Slot", "Hot Spare"}, 
        {(uint8_t )13, (uint8_t )4, (uint8_t )255, (uint8_t )0, "Drive Slot", "Parity Check In Progress"}, 
        {(uint8_t )13,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Drive Slot", "In Critical Array"}, 
        {(uint8_t )13,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "Drive Slot", "In Failed Array"}, 
        {(uint8_t )13, (uint8_t )7, (uint8_t )255, (uint8_t )0, "Drive Slot", "Rebuild In Progress"}, 
        {(uint8_t )13,
      (uint8_t )8, (uint8_t )255, (uint8_t )0, "Drive Slot", "Rebuild Aborted"}, 
        {(uint8_t )14, (uint8_t )0, (uint8_t )255, (uint8_t )0, "POST Memory Resize",
      (char const   *)((void *)0)}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )0, (uint8_t )0, "System Firmware Error",
      "Unspecified"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )1, (uint8_t )0, "System Firmware Error",
      "No system memory installed"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )2, (uint8_t )0, "System Firmware Error",
      "No usable system memory"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )3, (uint8_t )0, "System Firmware Error",
      "Unrecoverable IDE device failure"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )4, (uint8_t )0, "System Firmware Error",
      "Unrecoverable system-board failure"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )5, (uint8_t )0, "System Firmware Error",
      "Unrecoverable diskette failure"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )6, (uint8_t )0, "System Firmware Error",
      "Unrecoverable hard-disk controller failure"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )7, (uint8_t )0, "System Firmware Error",
      "Unrecoverable PS/2 or USB keyboard failure"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )8, (uint8_t )0, "System Firmware Error",
      "Removable boot media not found"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )9, (uint8_t )0, "System Firmware Error",
      "Unrecoverable video controller failure"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )10, (uint8_t )0, "System Firmware Error",
      "No video device selected"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )11, (uint8_t )0, "System Firmware Error",
      "BIOS corruption detected"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )12, (uint8_t )0, "System Firmware Error",
      "CPU voltage mismatch"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )13, (uint8_t )0, "System Firmware Error",
      "CPU speed mismatch failure"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )255, (uint8_t )0, "System Firmware Error",
      "Unknown Error"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )0, (uint8_t )0, "System Firmware Hang",
      "Unspecified"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )1, (uint8_t )0, "System Firmware Hang",
      "Memory initialization"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )2, (uint8_t )0, "System Firmware Hang",
      "Hard-disk initialization"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )3, (uint8_t )0, "System Firmware Hang",
      "Secondary CPU Initialization"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )4, (uint8_t )0, "System Firmware Hang",
      "User authentication"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )5, (uint8_t )0, "System Firmware Hang",
      "User-initiated system setup"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )6, (uint8_t )0, "System Firmware Hang",
      "USB resource configuration"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )7, (uint8_t )0, "System Firmware Hang",
      "PCI resource configuration"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )8, (uint8_t )0, "System Firmware Hang",
      "Option ROM initialization"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )9, (uint8_t )0, "System Firmware Hang",
      "Video initialization"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )10, (uint8_t )0, "System Firmware Hang",
      "Cache initialization"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )11, (uint8_t )0, "System Firmware Hang",
      "SMBus initialization"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )12, (uint8_t )0, "System Firmware Hang",
      "Keyboard controller initialization"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )13, (uint8_t )0, "System Firmware Hang",
      "Management controller initialization"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )14, (uint8_t )0, "System Firmware Hang",
      "Docking station attachment"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )15, (uint8_t )0, "System Firmware Hang",
      "Enabling docking station"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )16, (uint8_t )0, "System Firmware Hang",
      "Docking station ejection"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )17, (uint8_t )0, "System Firmware Hang",
      "Disabling docking station"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )18, (uint8_t )0, "System Firmware Hang",
      "Calling operating system wake-up vector"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )19, (uint8_t )0, "System Firmware Hang",
      "System boot initiated"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )20, (uint8_t )0, "System Firmware Hang",
      "Motherboard initialization"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )21, (uint8_t )0, "System Firmware Hang",
      "reserved"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )22, (uint8_t )0, "System Firmware Hang",
      "Floppy initialization"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )23, (uint8_t )0, "System Firmware Hang",
      "Keyboard test"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )24, (uint8_t )0, "System Firmware Hang",
      "Pointing device test"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )25, (uint8_t )0, "System Firmware Hang",
      "Primary CPU initialization"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )255, (uint8_t )0, "System Firmware Hang",
      "Unknown Hang"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )0, (uint8_t )0, "System Firmware Progress",
      "Unspecified"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )1, (uint8_t )0, "System Firmware Progress",
      "Memory initialization"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )2, (uint8_t )0, "System Firmware Progress",
      "Hard-disk initialization"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )3, (uint8_t )0, "System Firmware Progress",
      "Secondary CPU Initialization"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )4, (uint8_t )0, "System Firmware Progress",
      "User authentication"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )5, (uint8_t )0, "System Firmware Progress",
      "User-initiated system setup"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )6, (uint8_t )0, "System Firmware Progress",
      "USB resource configuration"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )7, (uint8_t )0, "System Firmware Progress",
      "PCI resource configuration"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )8, (uint8_t )0, "System Firmware Progress",
      "Option ROM initialization"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )9, (uint8_t )0, "System Firmware Progress",
      "Video initialization"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )10, (uint8_t )0, "System Firmware Progress",
      "Cache initialization"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )11, (uint8_t )0, "System Firmware Progress",
      "SMBus initialization"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )12, (uint8_t )0, "System Firmware Progress",
      "Keyboard controller initialization"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )13, (uint8_t )0, "System Firmware Progress",
      "Management controller initialization"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )14, (uint8_t )0, "System Firmware Progress",
      "Docking station attachment"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )15, (uint8_t )0, "System Firmware Progress",
      "Enabling docking station"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )16, (uint8_t )0, "System Firmware Progress",
      "Docking station ejection"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )17, (uint8_t )0, "System Firmware Progress",
      "Disabling docking station"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )18, (uint8_t )0, "System Firmware Progress",
      "Calling operating system wake-up vector"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )19, (uint8_t )0, "System Firmware Progress",
      "System boot initiated"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )20, (uint8_t )0, "System Firmware Progress",
      "Motherboard initialization"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )21, (uint8_t )0, "System Firmware Progress",
      "reserved"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )22, (uint8_t )0, "System Firmware Progress",
      "Floppy initialization"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )23, (uint8_t )0, "System Firmware Progress",
      "Keyboard test"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )24, (uint8_t )0, "System Firmware Progress",
      "Pointing device test"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )25, (uint8_t )0, "System Firmware Progress",
      "Primary CPU initialization"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )255, (uint8_t )0, "System Firmware Progress",
      "Unknown Progress"}, 
        {(uint8_t )16, (uint8_t )0, (uint8_t )255, (uint8_t )0, "Event Logging Disabled",
      "Correctable memory error logging disabled"}, 
        {(uint8_t )16, (uint8_t )1, (uint8_t )255, (uint8_t )0, "Event Logging Disabled",
      "Event logging disabled"}, 
        {(uint8_t )16, (uint8_t )2, (uint8_t )255, (uint8_t )0, "Event Logging Disabled",
      "Log area reset/cleared"}, 
        {(uint8_t )16, (uint8_t )3, (uint8_t )255, (uint8_t )0, "Event Logging Disabled",
      "All event logging disabled"}, 
        {(uint8_t )16, (uint8_t )4, (uint8_t )255, (uint8_t )0, "Event Logging Disabled",
      "Log full"}, 
        {(uint8_t )16, (uint8_t )5, (uint8_t )255, (uint8_t )0, "Event Logging Disabled",
      "Log almost full"}, 
        {(uint8_t )17, (uint8_t )0, (uint8_t )255, (uint8_t )0, "Watchdog 1", "BIOS Reset"}, 
        {(uint8_t )17,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Watchdog 1", "OS Reset"}, 
        {(uint8_t )17, (uint8_t )2, (uint8_t )255, (uint8_t )0, "Watchdog 1", "OS Shut Down"}, 
        {(uint8_t )17,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Watchdog 1", "OS Power Down"}, 
        {(uint8_t )17, (uint8_t )4, (uint8_t )255, (uint8_t )0, "Watchdog 1", "OS Power Cycle"}, 
        {(uint8_t )17,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Watchdog 1", "OS NMI/Diag Interrupt"}, 
        {(uint8_t )17,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "Watchdog 1", "OS Expired"}, 
        {(uint8_t )17, (uint8_t )7, (uint8_t )255, (uint8_t )0, "Watchdog 1", "OS pre-timeout Interrupt"}, 
        {(uint8_t )18,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "System Event", "System Reconfigured"}, 
        {(uint8_t )18,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "System Event", "OEM System boot event"}, 
        {(uint8_t )18,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "System Event", "Undetermined system hardware failure"}, 
        {(uint8_t )18,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "System Event", "Entry added to auxiliary log"}, 
        {(uint8_t )18,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "System Event", "PEF Action"}, 
        {(uint8_t )18, (uint8_t )5, (uint8_t )255, (uint8_t )0, "System Event", "Timestamp Clock Sync"}, 
        {(uint8_t )19,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Critical Interrupt", "NMI/Diag Interrupt"}, 
        {(uint8_t )19,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Critical Interrupt", "Bus Timeout"}, 
        {(uint8_t )19,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Critical Interrupt", "I/O Channel check NMI"}, 
        {(uint8_t )19,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Critical Interrupt", "Software NMI"}, 
        {(uint8_t )19,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Critical Interrupt", "PCI PERR"}, 
        {(uint8_t )19, (uint8_t )5, (uint8_t )255, (uint8_t )0, "Critical Interrupt",
      "PCI SERR"}, 
        {(uint8_t )19, (uint8_t )6, (uint8_t )255, (uint8_t )0, "Critical Interrupt",
      "EISA failsafe timeout"}, 
        {(uint8_t )19, (uint8_t )7, (uint8_t )255, (uint8_t )0, "Critical Interrupt",
      "Bus Correctable error"}, 
        {(uint8_t )19, (uint8_t )8, (uint8_t )255, (uint8_t )0, "Critical Interrupt",
      "Bus Uncorrectable error"}, 
        {(uint8_t )19, (uint8_t )9, (uint8_t )255, (uint8_t )0, "Critical Interrupt",
      "Fatal NMI"}, 
        {(uint8_t )19, (uint8_t )10, (uint8_t )255, (uint8_t )0, "Critical Interrupt",
      "Bus Fatal Error"}, 
        {(uint8_t )20, (uint8_t )0, (uint8_t )255, (uint8_t )0, "Button", "Power Button pressed"}, 
        {(uint8_t )20,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Button", "Sleep Button pressed"}, 
        {(uint8_t )20, (uint8_t )2, (uint8_t )255, (uint8_t )0, "Button", "Reset Button pressed"}, 
        {(uint8_t )20,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Button", "FRU Latch"}, 
        {(uint8_t )20, (uint8_t )4, (uint8_t )255, (uint8_t )0, "Button", "FRU Service"}, 
        {(uint8_t )21,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Module/Board", (char const   *)((void *)0)}, 
        {(uint8_t )22,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Microcontroller/Coprocessor", (char const   *)((void *)0)}, 
        {(uint8_t )23,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Add-in Card", (char const   *)((void *)0)}, 
        {(uint8_t )24,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Chassis", (char const   *)((void *)0)}, 
        {(uint8_t )25,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Chip Set", (char const   *)((void *)0)}, 
        {(uint8_t )26,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Other FRU", (char const   *)((void *)0)}, 
        {(uint8_t )27,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Cable/Interconnect", "Connected"}, 
        {(uint8_t )27,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Cable/Interconnect", "Config Error"}, 
        {(uint8_t )28,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Terminator", (char const   *)((void *)0)}, 
        {(uint8_t )29,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "System Boot Initiated", "Initiated by power up"}, 
        {(uint8_t )29,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "System Boot Initiated", "Initiated by hard reset"}, 
        {(uint8_t )29,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "System Boot Initiated", "Initiated by warm reset"}, 
        {(uint8_t )29,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "System Boot Initiated", "User requested PXE boot"}, 
        {(uint8_t )29,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "System Boot Initiated", "Automatic boot to diagnostic"}, 
        {(uint8_t )29,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "System Boot Initiated", "OS initiated hard reset"}, 
        {(uint8_t )29,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "System Boot Initiated", "OS initiated warm reset"}, 
        {(uint8_t )29,
      (uint8_t )7, (uint8_t )255, (uint8_t )0, "System Boot Initiated", "System Restart"}, 
        {(uint8_t )30,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Boot Error", "No bootable media"}, 
        {(uint8_t )30,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Boot Error", "Non-bootable disk in drive"}, 
        {(uint8_t )30,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Boot Error", "PXE server not found"}, 
        {(uint8_t )30,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Boot Error", "Invalid boot sector"}, 
        {(uint8_t )30,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Boot Error", "Timeout waiting for selection"}, 
        {(uint8_t )31,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "OS Boot", "A: boot completed"}, 
        {(uint8_t )31, (uint8_t )1, (uint8_t )255, (uint8_t )0, "OS Boot", "C: boot completed"}, 
        {(uint8_t )31,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "OS Boot", "PXE boot completed"}, 
        {(uint8_t )31, (uint8_t )3, (uint8_t )255, (uint8_t )0, "OS Boot", "Diagnostic boot completed"}, 
        {(uint8_t )31,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "OS Boot", "CD-ROM boot completed"}, 
        {(uint8_t )31,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "OS Boot", "ROM boot completed"}, 
        {(uint8_t )31, (uint8_t )6, (uint8_t )255, (uint8_t )0, "OS Boot", "boot completed - device not specified"}, 
        {(uint8_t )32,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "OS Stop/Shutdown", "Error during system startup"}, 
        {(uint8_t )32,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "OS Stop/Shutdown", "Run-time critical stop"}, 
        {(uint8_t )32,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "OS Stop/Shutdown", "OS graceful stop"}, 
        {(uint8_t )32,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "OS Stop/Shutdown", "OS graceful shutdown"}, 
        {(uint8_t )32,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "OS Stop/Shutdown", "PEF initiated soft shutdown"}, 
        {(uint8_t )32,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "OS Stop/Shutdown", "Agent not responding"}, 
        {(uint8_t )33,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Slot/Connector", "Fault Status"}, 
        {(uint8_t )33, (uint8_t )1, (uint8_t )255, (uint8_t )0, "Slot/Connector", "Identify Status"}, 
        {(uint8_t )33,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Slot/Connector", "Device Installed"}, 
        {(uint8_t )33,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Slot/Connector", "Ready for Device Installation"}, 
        {(uint8_t )33,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Slot/Connector", "Ready for Device Removal"}, 
        {(uint8_t )33,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Slot/Connector", "Slot Power is Off"}, 
        {(uint8_t )33,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "Slot/Connector", "Device Removal Request"}, 
        {(uint8_t )33,
      (uint8_t )7, (uint8_t )255, (uint8_t )0, "Slot/Connector", "Interlock"}, 
        {(uint8_t )33, (uint8_t )8, (uint8_t )255, (uint8_t )0, "Slot/Connector", "Slot is Disabled"}, 
        {(uint8_t )33,
      (uint8_t )9, (uint8_t )255, (uint8_t )0, "Slot/Connector", "Spare Device"}, 
        {(uint8_t )34, (uint8_t )0, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "S0/G0: working"}, 
        {(uint8_t )34, (uint8_t )1, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "S1: sleeping with system hw & processor context maintained"}, 
        {(uint8_t )34, (uint8_t )2, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "S2: sleeping, processor context lost"}, 
        {(uint8_t )34, (uint8_t )3, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "S3: sleeping, processor & hw context lost, memory retained"}, 
        {(uint8_t )34, (uint8_t )4, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "S4: non-volatile sleep/suspend-to-disk"}, 
        {(uint8_t )34, (uint8_t )5, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "S5/G2: soft-off"}, 
        {(uint8_t )34, (uint8_t )6, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "S4/S5: soft-off"}, 
        {(uint8_t )34, (uint8_t )7, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "G3: mechanical off"}, 
        {(uint8_t )34, (uint8_t )8, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "Sleeping in S1/S2/S3 state"}, 
        {(uint8_t )34, (uint8_t )9, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "G1: sleeping"}, 
        {(uint8_t )34, (uint8_t )10, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "S5: entered by override"}, 
        {(uint8_t )34, (uint8_t )11, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "Legacy ON state"}, 
        {(uint8_t )34, (uint8_t )12, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "Legacy OFF state"}, 
        {(uint8_t )34, (uint8_t )14, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "Unknown"}, 
        {(uint8_t )35, (uint8_t )0, (uint8_t )255, (uint8_t )0, "Watchdog 2", "Timer expired"}, 
        {(uint8_t )35,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Watchdog 2", "Hard reset"}, 
        {(uint8_t )35, (uint8_t )2, (uint8_t )255, (uint8_t )0, "Watchdog 2", "Power down"}, 
        {(uint8_t )35,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Watchdog 2", "Power cycle"}, 
        {(uint8_t )35, (uint8_t )4, (uint8_t )255, (uint8_t )0, "Watchdog 2", "reserved"}, 
        {(uint8_t )35,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Watchdog 2", "reserved"}, 
        {(uint8_t )35, (uint8_t )6, (uint8_t )255, (uint8_t )0, "Watchdog 2", "reserved"}, 
        {(uint8_t )35,
      (uint8_t )7, (uint8_t )255, (uint8_t )0, "Watchdog 2", "reserved"}, 
        {(uint8_t )35, (uint8_t )8, (uint8_t )255, (uint8_t )0, "Watchdog 2", "Timer interrupt"}, 
        {(uint8_t )36,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Platform Alert", "Platform generated page"}, 
        {(uint8_t )36,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Platform Alert", "Platform generated LAN alert"}, 
        {(uint8_t )36,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Platform Alert", "Platform Event Trap generated"}, 
        {(uint8_t )36,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Platform Alert", "Platform generated SNMP trap, OEM format"}, 
        {(uint8_t )37,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Entity Presence", "Present"}, 
        {(uint8_t )37, (uint8_t )1, (uint8_t )255, (uint8_t )0, "Entity Presence", "Absent"}, 
        {(uint8_t )37,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Entity Presence", "Disabled"}, 
        {(uint8_t )38, (uint8_t )0, (uint8_t )255, (uint8_t )0, "Monitor ASIC/IC", (char const   *)((void *)0)}, 
        {(uint8_t )39,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "LAN", "Heartbeat Lost"}, 
        {(uint8_t )39, (uint8_t )1, (uint8_t )255, (uint8_t )0, "LAN", "Heartbeat"}, 
        {(uint8_t )40, (uint8_t )0, (uint8_t )255, (uint8_t )0, "Management Subsystem Health",
      "Sensor access degraded or unavailable"}, 
        {(uint8_t )40, (uint8_t )1, (uint8_t )255, (uint8_t )0, "Management Subsystem Health",
      "Controller access degraded or unavailable"}, 
        {(uint8_t )40, (uint8_t )2, (uint8_t )255, (uint8_t )0, "Management Subsystem Health",
      "Management controller off-line"}, 
        {(uint8_t )40, (uint8_t )3, (uint8_t )255, (uint8_t )0, "Management Subsystem Health",
      "Management controller unavailable"}, 
        {(uint8_t )40, (uint8_t )4, (uint8_t )255, (uint8_t )0, "Management Subsystem Health",
      "Sensor failure"}, 
        {(uint8_t )40, (uint8_t )5, (uint8_t )255, (uint8_t )0, "Management Subsystem Health",
      "FRU failure"}, 
        {(uint8_t )41, (uint8_t )0, (uint8_t )255, (uint8_t )0, "Battery", "Low"}, 
        {(uint8_t )41, (uint8_t )1, (uint8_t )255, (uint8_t )0, "Battery", "Failed"}, 
        {(uint8_t )41,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Battery", "Presence Detected"}, 
        {(uint8_t )43, (uint8_t )0, (uint8_t )255, (uint8_t )0, "Version Change", "Hardware change detected"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )0, (uint8_t )0, "Version Change", "Firmware or software change detected"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )1, (uint8_t )0, "Version Change", "Firmware or software change detected, Mngmt Ctrl Dev Id"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )2, (uint8_t )0, "Version Change", "Firmware or software change detected, Mngmt Ctrl Firm Rev"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )3, (uint8_t )0, "Version Change", "Firmware or software change detected, Mngmt Ctrl Dev Rev"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )4, (uint8_t )0, "Version Change", "Firmware or software change detected, Mngmt Ctrl Manuf Id"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )5, (uint8_t )0, "Version Change", "Firmware or software change detected, Mngmt Ctrl IPMI Vers"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )6, (uint8_t )0, "Version Change", "Firmware or software change detected, Mngmt Ctrl Aux Firm Id"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )7, (uint8_t )0, "Version Change", "Firmware or software change detected, Mngmt Ctrl Firm Boot Block"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )8, (uint8_t )0, "Version Change", "Firmware or software change detected, Mngmt Ctrl Other"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )9, (uint8_t )0, "Version Change", "Firmware or software change detected, BIOS/EFI change"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )10, (uint8_t )0, "Version Change", "Firmware or software change detected, SMBIOS change"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )11, (uint8_t )0, "Version Change", "Firmware or software change detected, O/S change"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )12, (uint8_t )0, "Version Change", "Firmware or software change detected, O/S loader change"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )13, (uint8_t )0, "Version Change", "Firmware or software change detected, Service Diag change"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )14, (uint8_t )0, "Version Change", "Firmware or software change detected, Mngmt SW agent change"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )15, (uint8_t )0, "Version Change", "Firmware or software change detected, Mngmt SW App change"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )16, (uint8_t )0, "Version Change", "Firmware or software change detected, Mngmt SW Middle"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )17, (uint8_t )0, "Version Change", "Firmware or software change detected, Prog HW Change (FPGA)"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )18, (uint8_t )0, "Version Change", "Firmware or software change detected, board/FRU module change"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )19, (uint8_t )0, "Version Change", "Firmware or software change detected, board/FRU component change"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )20, (uint8_t )0, "Version Change", "Firmware or software change detected, board/FRU replace equ ver"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )21, (uint8_t )0, "Version Change", "Firmware or software change detected, board/FRU replace new ver"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )22, (uint8_t )0, "Version Change", "Firmware or software change detected, board/FRU replace old ver"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )23, (uint8_t )0, "Version Change", "Firmware or software change detected, board/FRU HW conf change"}, 
        {(uint8_t )43,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Version Change", "Hardware incompatibility detected"}, 
        {(uint8_t )43,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Version Change", "Firmware or software incompatibility detected"}, 
        {(uint8_t )43,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Version Change", "Invalid or unsupported hardware version"}, 
        {(uint8_t )43,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Version Change", "Invalid or unsupported firmware or software version"}, 
        {(uint8_t )43,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "Version Change", "Hardware change success"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )0, (uint8_t )0, "Version Change", "Firmware or software change success"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )1, (uint8_t )0, "Version Change", "Firmware or software change success, Mngmt Ctrl Dev Id"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )2, (uint8_t )0, "Version Change", "Firmware or software change success, Mngmt Ctrl Firm Rev"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )3, (uint8_t )0, "Version Change", "Firmware or software change success, Mngmt Ctrl Dev Rev"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )4, (uint8_t )0, "Version Change", "Firmware or software change success, Mngmt Ctrl Manuf Id"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )5, (uint8_t )0, "Version Change", "Firmware or software change success, Mngmt Ctrl IPMI Vers"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )6, (uint8_t )0, "Version Change", "Firmware or software change success, Mngmt Ctrl Aux Firm Id"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )7, (uint8_t )0, "Version Change", "Firmware or software change success, Mngmt Ctrl Firm Boot Block"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )8, (uint8_t )0, "Version Change", "Firmware or software change success, Mngmt Ctrl Other"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )9, (uint8_t )0, "Version Change", "Firmware or software change success, BIOS/EFI change"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )10, (uint8_t )0, "Version Change", "Firmware or software change success, SMBIOS change"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )11, (uint8_t )0, "Version Change", "Firmware or software change success, O/S change"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )12, (uint8_t )0, "Version Change", "Firmware or software change success, O/S loader change"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )13, (uint8_t )0, "Version Change", "Firmware or software change success, Service Diag change"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )14, (uint8_t )0, "Version Change", "Firmware or software change success, Mngmt SW agent change"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )15, (uint8_t )0, "Version Change", "Firmware or software change success, Mngmt SW App change"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )16, (uint8_t )0, "Version Change", "Firmware or software change success, Mngmt SW Middle"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )17, (uint8_t )0, "Version Change", "Firmware or software change success, Prog HW Change (FPGA)"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )18, (uint8_t )0, "Version Change", "Firmware or software change success, board/FRU module change"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )19, (uint8_t )0, "Version Change", "Firmware or software change success, board/FRU component change"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )20, (uint8_t )0, "Version Change", "Firmware or software change success, board/FRU replace equ ver"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )21, (uint8_t )0, "Version Change", "Firmware or software change success, board/FRU replace new ver"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )22, (uint8_t )0, "Version Change", "Firmware or software change success, board/FRU replace old ver"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )23, (uint8_t )0, "Version Change", "Firmware or software change success, board/FRU HW conf change"}, 
        {(uint8_t )44,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "FRU State", "Not Installed"}, 
        {(uint8_t )44, (uint8_t )1, (uint8_t )255, (uint8_t )0, "FRU State", "Inactive"}, 
        {(uint8_t )44,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "FRU State", "Activation Requested"}, 
        {(uint8_t )44,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "FRU State", "Activation in Progress"}, 
        {(uint8_t )44,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "FRU State", "Active"}, 
        {(uint8_t )44, (uint8_t )5, (uint8_t )255, (uint8_t )0, "FRU State", "Deactivation Requested"}, 
        {(uint8_t )44,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "FRU State", "Deactivation in Progress"}, 
        {(uint8_t )44,
      (uint8_t )7, (uint8_t )255, (uint8_t )0, "FRU State", "Communication lost"}, 
        {(uint8_t )240,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "FRU Hot Swap", "Transition to M0"}, 
        {(uint8_t )240,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "FRU Hot Swap", "Transition to M1"}, 
        {(uint8_t )240,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "FRU Hot Swap", "Transition to M2"}, 
        {(uint8_t )240,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "FRU Hot Swap", "Transition to M3"}, 
        {(uint8_t )240,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "FRU Hot Swap", "Transition to M4"}, 
        {(uint8_t )240,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "FRU Hot Swap", "Transition to M5"}, 
        {(uint8_t )240,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "FRU Hot Swap", "Transition to M6"}, 
        {(uint8_t )240,
      (uint8_t )7, (uint8_t )255, (uint8_t )0, "FRU Hot Swap", "Transition to M7"}, 
        {(uint8_t )241,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "IPMB-0 Status", "IPMB-A disabled, IPMB-B disabled"}, 
        {(uint8_t )241,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "IPMB-0 Status", "IPMB-A enabled, IPMB-B disabled"}, 
        {(uint8_t )241,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "IPMB-0 Status", "IPMB-A disabled, IPMB-B enabled"}, 
        {(uint8_t )241,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "IPMB-0 Status", "IPMB-A enabled, IPMP-B enabled"}, 
        {(uint8_t )242,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Module Hot Swap", "Module Handle Closed"}, 
        {(uint8_t )242,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Module Hot Swap", "Module Handle Opened"}, 
        {(uint8_t )242,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Module Hot Swap", "Quiesced"}, 
        {(uint8_t )192, (uint8_t )0, (uint8_t )255, (uint8_t )0, "OEM", "OEM Specific"}, 
        {(uint8_t )0,
      (uint8_t )0, (uint8_t )0, (uint8_t )0, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 680
extern void ipmi_sel_print_std_entry(struct ipmi_intf *intf , struct sel_event_record *evt ) ;
#line 682
extern void ipmi_sel_print_extended_entry(struct ipmi_intf *intf , struct sel_event_record *evt ) ;
#line 683
extern void ipmi_sel_print_extended_entry_verbose(struct ipmi_intf *intf , struct sel_event_record *evt ) ;
#line 253 "../include/ipmitool/ipmi_channel.h"
uint8_t ipmi_current_channel_medium(struct ipmi_intf *intf ) ;
#line 64 "../include/ipmitool/ipmi_event.h"
int ipmi_event_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_event.c"
static void ipmi_event_msg_print(struct ipmi_intf *intf , struct platform_event_msg *pmsg ) 
{ 
  struct sel_event_record sel_event ;

  {
  {
#line 61
  memset((void *)(& sel_event), 0, sizeof(struct sel_event_record ));
#line 63
  sel_event.record_id = (uint16_t )0;
#line 64
  sel_event.sel_type.standard_type.gen_id = (uint16_t )2;
#line 66
  sel_event.sel_type.standard_type.evm_rev = pmsg->evm_rev;
#line 67
  sel_event.sel_type.standard_type.sensor_type = pmsg->sensor_type;
#line 68
  sel_event.sel_type.standard_type.sensor_num = pmsg->sensor_num;
#line 69
  sel_event.sel_type.standard_type.event_type = pmsg->event_type;
#line 70
  sel_event.sel_type.standard_type.event_dir = pmsg->event_dir;
#line 71
  sel_event.sel_type.standard_type.event_data[0] = pmsg->event_data[0];
#line 72
  sel_event.sel_type.standard_type.event_data[1] = pmsg->event_data[1];
#line 73
  sel_event.sel_type.standard_type.event_data[2] = pmsg->event_data[2];
  }
#line 75
  if (verbose) {
    {
#line 76
    ipmi_sel_print_extended_entry_verbose(intf, & sel_event);
    }
  } else {
    {
#line 78
    ipmi_sel_print_extended_entry(intf, & sel_event);
    }
  }
#line 79
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_event.c"
static int ipmi_send_platform_event(struct ipmi_intf *intf , struct platform_event_msg *emsg ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t rqdata[8] ;
  uint8_t chmed ;
  char const   *tmp ;

  {
  {
#line 89
  memset((void *)(& req), 0, sizeof(req));
#line 90
  memset((void *)(rqdata), 0, (size_t )8);
#line 92
  req.msg.netfn = (uint8_t )4;
#line 93
  req.msg.cmd = (uint8_t )2;
#line 94
  req.msg.data = rqdata;
#line 96
  chmed = ipmi_current_channel_medium(intf);
  }
#line 97
  if ((int )chmed == 12) {
    {
#line 99
    req.msg.data_len = (uint16_t )8;
#line 100
    rqdata[0] = (uint8_t )65;
#line 101
    memcpy((void */* __restrict  */)(rqdata + 1), (void const   */* __restrict  */)emsg,
           sizeof(struct platform_event_msg ));
    }
  } else {
    {
#line 104
    req.msg.data_len = (uint16_t )7;
#line 105
    memcpy((void */* __restrict  */)(rqdata), (void const   */* __restrict  */)emsg,
           sizeof(struct platform_event_msg ));
    }
  }
  {
#line 108
  ipmi_event_msg_print(intf, emsg);
#line 110
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 111
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 112
    lprintf(3, "Platform Event Message command failed");
    }
#line 113
    return (-1);
  } else
#line 115
  if ((int )rsp->ccode > 0) {
    {
#line 116
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 116
    lprintf(3, "Platform Event Message command failed: %s", tmp);
    }
#line 118
    return (-1);
  }
#line 121
  return (0);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_event.c"
static struct valstr  const  ipmi_event_thresh_lo[7]  = {      {(uint16_t )0, "lnc"}, 
        {(uint16_t )2, "lcr"}, 
        {(uint16_t )4, "lnr"}, 
        {(uint16_t )6, "unc"}, 
        {(uint16_t )8, "ucr"}, 
        {(uint16_t )10, "unr"}, 
        {(uint16_t )0, (char const   *)((void *)0)}};
#line 146 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_event.c"
static struct valstr  const  ipmi_event_thresh_hi[7]  = {      {(uint16_t )1, "lnc"}, 
        {(uint16_t )3, "lcr"}, 
        {(uint16_t )5, "lnr"}, 
        {(uint16_t )7, "unc"}, 
        {(uint16_t )9, "ucr"}, 
        {(uint16_t )11, "unr"}, 
        {(uint16_t )0, (char const   *)((void *)0)}};
#line 156 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_event.c"
static int ipmi_send_platform_event_num(struct ipmi_intf *intf , int num ) 
{ 
  struct platform_event_msg emsg ;
  int tmp ;

  {
  {
#line 161
  memset((void *)(& emsg), 0, sizeof(struct platform_event_msg ));
  }
  {
#line 165
  if (num == 1) {
#line 165
    goto case_1;
  }
#line 177
  if (num == 2) {
#line 177
    goto case_2;
  }
#line 189
  if (num == 3) {
#line 189
    goto case_3;
  }
#line 200
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 166
  printf((char const   */* __restrict  */)"Sending SAMPLE event: Temperature - Upper Critical - Going High\n");
#line 168
  emsg.evm_rev = (uint8_t )4;
#line 169
  emsg.sensor_type = (uint8_t )1;
#line 170
  emsg.sensor_num = (uint8_t )48;
#line 171
  emsg.event_dir = (uint8_t )0;
#line 172
  emsg.event_type = (uint8_t )1;
#line 173
  emsg.event_data[0] = (uint8_t )9;
#line 174
  emsg.event_data[1] = (uint8_t )255;
#line 175
  emsg.event_data[2] = (uint8_t )255;
  }
#line 176
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 178
  printf((char const   */* __restrict  */)"Sending SAMPLE event: Voltage Threshold - Lower Critical - Going Low\n");
#line 180
  emsg.evm_rev = (uint8_t )4;
#line 181
  emsg.sensor_type = (uint8_t )2;
#line 182
  emsg.sensor_num = (uint8_t )96;
#line 183
  emsg.event_dir = (uint8_t )0;
#line 184
  emsg.event_type = (uint8_t )1;
#line 185
  emsg.event_data[0] = (uint8_t )2;
#line 186
  emsg.event_data[1] = (uint8_t )255;
#line 187
  emsg.event_data[2] = (uint8_t )255;
  }
#line 188
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 190
  printf((char const   */* __restrict  */)"Sending SAMPLE event: Memory - Correctable ECC\n");
#line 191
  emsg.evm_rev = (uint8_t )4;
#line 192
  emsg.sensor_type = (uint8_t )12;
#line 193
  emsg.sensor_num = (uint8_t )83;
#line 194
  emsg.event_dir = (uint8_t )0;
#line 195
  emsg.event_type = (uint8_t )111;
#line 196
  emsg.event_data[0] = (uint8_t )0;
#line 197
  emsg.event_data[1] = (uint8_t )255;
#line 198
  emsg.event_data[2] = (uint8_t )255;
  }
#line 199
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 201
  lprintf(3, "Invalid event number: %d", num);
  }
#line 202
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 205
  tmp = ipmi_send_platform_event(intf, & emsg);
  }
#line 205
  return (tmp);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_event.c"
static int ipmi_event_find_offset(uint8_t code , struct ipmi_event_sensor_types *evt ,
                                  char *desc ) 
{ 
  int x ;
  size_t tmp ;
  int y ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 213
  if ((unsigned long )desc == (unsigned long )((void *)0)) {
#line 214
    return (0);
  } else
#line 213
  if ((int )code == 0) {
#line 214
    return (0);
  }
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! evt->type) {
#line 216
      goto while_break;
    }
#line 218
    if ((int )evt->code == (int )code) {
#line 218
      if ((unsigned long )evt->desc != (unsigned long )((void *)0)) {
        {
#line 218
        tmp = strlen((char const   *)desc);
#line 218
        x = (int )tmp;
#line 218
        tmp___0 = strlen(evt->desc);
#line 218
        y = (int )tmp___0;
        }
#line 218
        if (x > y) {
#line 218
          tmp___1 = x;
        } else {
#line 218
          tmp___1 = y;
        }
        {
#line 218
        tmp___2 = strncasecmp((char const   *)desc, evt->desc, (size_t )tmp___1);
        }
#line 218
        if (tmp___2 == 0) {
#line 219
          return ((int )evt->offset);
        }
      }
    }
#line 220
    evt ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 223
  lprintf(4, "Unable to find matching event offset for \'%s\'", desc);
  }
#line 224
  return (-1);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_event.c"
static void print_sensor_states(uint8_t sensor_type , uint8_t event_type ) 
{ 


  {
  {
#line 230
  ipmi_sdr_print_discrete_state_mini("Sensor States: \n  ", "\n  ", sensor_type, event_type,
                                     (uint8_t )255, (uint8_t )255);
#line 233
  printf((char const   */* __restrict  */)"\n");
  }
#line 234
  return;
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_event.c"
static int ipmi_event_fromsensor(struct ipmi_intf *intf , char *id , char *state ,
                                 char *evdir ) 
{ 
  struct ipmi_rs *rsp ;
  struct sdr_record_list *sdr ;
  struct platform_event_msg emsg ;
  int off ;
  uint8_t target ;
  uint8_t lun ;
  uint8_t channel ;
  int tmp ;
  int tmp___0 ;
  int dir ;
  int hilo ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  uint16_t tmp___8 ;
  uint16_t tmp___9 ;
  char const   *tmp___10 ;
  int x ;
  char const   *digi_on[7] ;
  char const   *digi_off[7] ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 246
  if ((unsigned long )id == (unsigned long )((void *)0)) {
    {
#line 247
    lprintf(3, "No sensor ID supplied");
    }
#line 248
    return (-1);
  }
  {
#line 251
  memset((void *)(& emsg), 0, sizeof(struct platform_event_msg ));
#line 252
  emsg.evm_rev = (uint8_t )4;
  }
#line 254
  if ((unsigned long )evdir == (unsigned long )((void *)0)) {
#line 255
    emsg.event_dir = (uint8_t )0;
  } else {
    {
#line 256
    tmp___0 = strncasecmp((char const   *)evdir, "assert", (size_t )6);
    }
#line 256
    if (tmp___0 == 0) {
#line 257
      emsg.event_dir = (uint8_t )0;
    } else {
      {
#line 258
      tmp = strncasecmp((char const   *)evdir, "deassert", (size_t )8);
      }
#line 258
      if (tmp == 0) {
#line 259
        emsg.event_dir = (uint8_t )1;
      } else {
        {
#line 261
        lprintf(3, "Invalid event direction %s.  Must be \'assert\' or \'deassert\'",
                evdir);
        }
#line 262
        return (-1);
      }
    }
  }
  {
#line 265
  printf((char const   */* __restrict  */)"Finding sensor %s... ", id);
#line 266
  sdr = ipmi_sdr_find_sdr_byid(intf, id);
  }
#line 267
  if ((unsigned long )sdr == (unsigned long )((void *)0)) {
    {
#line 268
    printf((char const   */* __restrict  */)"not found!\n");
    }
#line 269
    return (-1);
  }
  {
#line 271
  printf((char const   */* __restrict  */)"ok\n");
  }
  {
#line 276
  if ((int )sdr->type == 2) {
#line 276
    goto case_2;
  }
#line 276
  if ((int )sdr->type == 1) {
#line 276
    goto case_2;
  }
#line 285
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 278
  emsg.sensor_type = (sdr->record.common)->sensor.type;
#line 279
  emsg.sensor_num = (sdr->record.common)->keys.sensor_num;
#line 280
  emsg.event_type = (sdr->record.common)->event_type;
#line 281
  target = (sdr->record.common)->keys.owner_id;
#line 282
  lun = (sdr->record.common)->keys.lun;
#line 283
  channel = (sdr->record.common)->keys.channel;
#line 284
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 286
  lprintf(3, "Unknown sensor type for id \'%s\'", id);
  }
#line 287
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 290
  emsg.event_data[1] = (uint8_t )255;
#line 291
  emsg.event_data[2] = (uint8_t )255;
  {
#line 298
  if ((int )emsg.event_type == 1) {
#line 298
    goto case_1___0;
  }
#line 391
  if ((int )emsg.event_type == 9) {
#line 391
    goto case_9;
  }
#line 391
  if ((int )emsg.event_type == 8) {
#line 391
    goto case_9;
  }
#line 391
  if ((int )emsg.event_type == 6) {
#line 391
    goto case_9;
  }
#line 391
  if ((int )emsg.event_type == 5) {
#line 391
    goto case_9;
  }
#line 391
  if ((int )emsg.event_type == 4) {
#line 391
    goto case_9;
  }
#line 391
  if ((int )emsg.event_type == 3) {
#line 391
    goto case_9;
  }
#line 436
  if ((int )emsg.event_type == 12) {
#line 436
    goto case_12;
  }
#line 436
  if ((int )emsg.event_type == 11) {
#line 436
    goto case_12;
  }
#line 436
  if ((int )emsg.event_type == 10) {
#line 436
    goto case_12;
  }
#line 436
  if ((int )emsg.event_type == 7) {
#line 436
    goto case_12;
  }
#line 436
  if ((int )emsg.event_type == 2) {
#line 436
    goto case_12;
  }
#line 456
  if ((int )emsg.event_type == 111) {
#line 456
    goto case_111;
  }
#line 473
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
#line 300
  dir = 0;
#line 301
  hilo = 0;
#line 302
  off = 1;
#line 304
  if ((unsigned long )state == (unsigned long )((void *)0)) {
#line 304
    goto _L;
  } else {
    {
#line 304
    tmp___1 = strncasecmp((char const   *)state, "list", (size_t )4);
    }
#line 304
    if (tmp___1 == 0) {
      _L: /* CIL Label */ 
      {
#line 305
      printf((char const   */* __restrict  */)"Sensor States:\n");
#line 306
      printf((char const   */* __restrict  */)"  lnr : Lower Non-Recoverable \n");
#line 307
      printf((char const   */* __restrict  */)"  lcr : Lower Critical\n");
#line 308
      printf((char const   */* __restrict  */)"  lnc : Lower Non-Critical\n");
#line 309
      printf((char const   */* __restrict  */)"  unc : Upper Non-Critical\n");
#line 310
      printf((char const   */* __restrict  */)"  ucr : Upper Critical\n");
#line 311
      printf((char const   */* __restrict  */)"  unr : Upper Non-Recoverable\n");
      }
#line 312
      return (-1);
    }
  }
  {
#line 315
  tmp___2 = strncasecmp((char const   *)state, "lnr", (size_t )3);
  }
#line 315
  if (0 != tmp___2) {
    {
#line 315
    tmp___3 = strncasecmp((char const   *)state, "lcr", (size_t )3);
    }
#line 315
    if (0 != tmp___3) {
      {
#line 315
      tmp___4 = strncasecmp((char const   *)state, "lnc", (size_t )3);
      }
#line 315
      if (0 != tmp___4) {
        {
#line 315
        tmp___5 = strncasecmp((char const   *)state, "unc", (size_t )3);
        }
#line 315
        if (0 != tmp___5) {
          {
#line 315
          tmp___6 = strncasecmp((char const   *)state, "ucr", (size_t )3);
          }
#line 315
          if (0 != tmp___6) {
            {
#line 315
            tmp___7 = strncasecmp((char const   *)state, "unr", (size_t )3);
            }
#line 315
            if (0 != tmp___7) {
              {
#line 322
              lprintf(3, "Invalid threshold identifier %s", state);
              }
#line 323
              return (-1);
            }
          }
        }
      }
    }
  }
#line 326
  if ((int )*(state + 0) == 117) {
#line 327
    hilo = 1;
  } else {
#line 329
    hilo = 0;
  }
#line 331
  if ((int )emsg.event_dir == 0) {
#line 332
    dir = hilo;
  } else {
#line 334
    dir = ! hilo;
  }
#line 336
  if ((int )emsg.event_dir == 0) {
#line 336
    if (hilo == 1) {
      {
#line 338
      tmp___8 = str2val((char const   *)state, ipmi_event_thresh_hi);
#line 338
      emsg.event_data[0] = (uint8_t )((int )tmp___8 & 15);
      }
    } else {
#line 336
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 336
  if ((int )emsg.event_dir == 1) {
#line 336
    if (hilo == 0) {
      {
#line 338
      tmp___8 = str2val((char const   *)state, ipmi_event_thresh_hi);
#line 338
      emsg.event_data[0] = (uint8_t )((int )tmp___8 & 15);
      }
    } else {
#line 336
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 339
  if ((int )emsg.event_dir == 0) {
#line 339
    if (hilo == 0) {
      {
#line 341
      tmp___9 = str2val((char const   *)state, ipmi_event_thresh_lo);
#line 341
      emsg.event_data[0] = (uint8_t )((int )tmp___9 & 15);
      }
    } else {
#line 339
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 339
  if ((int )emsg.event_dir == 1) {
#line 339
    if (hilo == 1) {
      {
#line 341
      tmp___9 = str2val((char const   *)state, ipmi_event_thresh_lo);
#line 341
      emsg.event_data[0] = (uint8_t )((int )tmp___9 & 15);
      }
    } else {
      {
#line 343
      lprintf(3, "Invalid Event");
      }
#line 344
      return (-1);
    }
  } else {
    {
#line 343
    lprintf(3, "Invalid Event");
    }
#line 344
    return (-1);
  }
  {
#line 347
  rsp = ipmi_sdr_get_sensor_thresholds(intf, emsg.sensor_num, target, lun, channel);
  }
#line 349
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 350
    lprintf(3, "Command Get Sensor Thresholds failed: invalid response.");
    }
#line 352
    return (-1);
  } else
#line 353
  if ((int )rsp->ccode != 0) {
    {
#line 354
    tmp___10 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 354
    lprintf(3, "Command Get Sensor Thresholds failed: %s", tmp___10);
    }
#line 356
    return (-1);
  }
  {
#line 360
  emsg.event_data[2] = rsp->data[(int )emsg.event_data[0] / 2 + 1];
#line 362
  rsp = ipmi_sdr_get_sensor_hysteresis(intf, emsg.sensor_num, target, lun, channel);
  }
#line 364
  if ((unsigned long )rsp != (unsigned long )((void *)0)) {
#line 364
    if ((int )rsp->ccode == 0) {
#line 365
      if (dir) {
#line 365
        off = (int )rsp->data[0];
      } else {
#line 365
        off = (int )rsp->data[1];
      }
    }
  }
#line 366
  if (off <= 0) {
#line 367
    off = 1;
  }
#line 370
  if (dir) {
#line 371
    if ((int )emsg.event_data[2] + off > 255) {
#line 372
      emsg.event_data[1] = (uint8_t )255;
    } else {
#line 374
      emsg.event_data[1] = (uint8_t )((int )emsg.event_data[2] + off);
    }
  } else
#line 377
  if ((int )emsg.event_data[2] - off < 0) {
#line 378
    emsg.event_data[1] = (uint8_t )0;
  } else {
#line 380
    emsg.event_data[1] = (uint8_t )((int )emsg.event_data[2] - off);
  }
#line 384
  emsg.event_data[0] = (uint8_t )((int )emsg.event_data[0] | 80);
#line 386
  goto switch_break___0;
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 394
  digi_on[0] = "present";
#line 394
  digi_on[1] = "assert";
#line 394
  digi_on[2] = "limit";
#line 394
  digi_on[3] = "fail";
#line 394
  digi_on[4] = "yes";
#line 394
  digi_on[5] = "on";
#line 394
  digi_on[6] = "up";
#line 396
  digi_off[0] = "absent";
#line 396
  digi_off[1] = "deassert";
#line 396
  digi_off[2] = "nolimit";
#line 396
  digi_off[3] = "nofail";
#line 396
  digi_off[4] = "no";
#line 396
  digi_off[5] = "off";
#line 396
  digi_off[6] = "down";
#line 401
  if ((unsigned long )state == (unsigned long )((void *)0)) {
#line 401
    goto _L___3;
  } else {
    {
#line 401
    tmp___11 = strncasecmp((char const   *)state, "list", (size_t )4);
    }
#line 401
    if (tmp___11 == 0) {
      _L___3: /* CIL Label */ 
      {
#line 402
      print_sensor_states(emsg.sensor_type, emsg.event_type);
#line 403
      printf((char const   */* __restrict  */)"Sensor State Shortcuts:\n");
#line 404
      x = 0;
      }
      {
#line 404
      while (1) {
        while_continue: /* CIL Label */ ;
#line 404
        if (! ((unsigned long )x < sizeof(digi_on) / sizeof(digi_on[0]))) {
#line 404
          goto while_break;
        }
        {
#line 405
        printf((char const   */* __restrict  */)"  %-9s  %-9s\n", digi_on[x], digi_off[x]);
#line 404
        x ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 407
      return (0);
    }
  }
#line 410
  off = 0;
#line 411
  x = 0;
  {
#line 411
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 411
    if (! ((unsigned long )x < sizeof(digi_on) / sizeof(digi_on[0]))) {
#line 411
      goto while_break___0;
    }
    {
#line 412
    tmp___14 = strlen(digi_on[x]);
#line 412
    tmp___15 = strncasecmp((char const   *)state, digi_on[x], tmp___14);
    }
#line 412
    if (tmp___15 == 0) {
#line 413
      emsg.event_data[0] = (uint8_t )1;
#line 414
      off = 1;
#line 415
      goto while_break___0;
    } else {
      {
#line 417
      tmp___12 = strlen(digi_off[x]);
#line 417
      tmp___13 = strncasecmp((char const   *)state, digi_off[x], tmp___12);
      }
#line 417
      if (tmp___13 == 0) {
#line 418
        emsg.event_data[0] = (uint8_t )0;
#line 419
        off = 1;
#line 420
        goto while_break___0;
      }
    }
#line 411
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 423
  if (off == 0) {
    {
#line 424
    off = ipmi_event_find_offset(emsg.event_type, generic_event_types, state);
    }
#line 426
    if (off < 0) {
#line 427
      return (-1);
    }
#line 428
    emsg.event_data[0] = (uint8_t )off;
  }
#line 431
  goto switch_break___0;
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
#line 441
  if ((unsigned long )state == (unsigned long )((void *)0)) {
    {
#line 442
    print_sensor_states(emsg.sensor_type, emsg.event_type);
    }
#line 443
    return (0);
  } else {
    {
#line 441
    tmp___16 = strncasecmp((char const   *)state, "list", (size_t )4);
    }
#line 441
    if (tmp___16 == 0) {
      {
#line 442
      print_sensor_states(emsg.sensor_type, emsg.event_type);
      }
#line 443
      return (0);
    }
  }
  {
#line 445
  off = ipmi_event_find_offset(emsg.event_type, generic_event_types, state);
  }
#line 447
  if (off < 0) {
#line 448
    return (-1);
  }
#line 449
  emsg.event_data[0] = (uint8_t )off;
#line 451
  goto switch_break___0;
  case_111: /* CIL Label */ 
#line 461
  if ((unsigned long )state == (unsigned long )((void *)0)) {
    {
#line 462
    print_sensor_states(emsg.sensor_type, emsg.event_type);
    }
#line 463
    return (0);
  } else {
    {
#line 461
    tmp___17 = strncasecmp((char const   *)state, "list", (size_t )4);
    }
#line 461
    if (tmp___17 == 0) {
      {
#line 462
      print_sensor_states(emsg.sensor_type, emsg.event_type);
      }
#line 463
      return (0);
    }
  }
  {
#line 465
  off = ipmi_event_find_offset(emsg.sensor_type, sensor_specific_types, state);
  }
#line 467
  if (off < 0) {
#line 468
    return (-1);
  }
#line 469
  emsg.event_data[0] = (uint8_t )off;
#line 471
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 474
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 478
  tmp___18 = ipmi_send_platform_event(intf, & emsg);
  }
#line 478
  return (tmp___18);
}
}
#line 481 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_event.c"
static int ipmi_event_fromfile(struct ipmi_intf *intf , char *file ) 
{ 
  FILE *fp ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct sel_event_record sel_event ;
  uint8_t rqdata[8] ;
  char buf[1024] ;
  char *ptr ;
  char *tok ;
  int i ;
  int j ;
  uint8_t chmed ;
  int rc ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  int tmp___16 ;

  {
#line 493
  rc = 0;
#line 495
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 496
    return (-1);
  }
  {
#line 498
  memset((void *)(rqdata), 0, (size_t )8);
#line 501
  memset((void *)(& req), 0, sizeof(req));
#line 502
  req.msg.netfn = (uint8_t )4;
#line 503
  req.msg.cmd = (uint8_t )2;
#line 504
  req.msg.data = rqdata;
#line 505
  req.msg.data_len = (uint16_t )7;
#line 507
  chmed = ipmi_current_channel_medium(intf);
  }
#line 508
  if ((int )chmed == 12) {
#line 510
    rqdata[0] = (uint8_t )65;
#line 511
    req.msg.data_len = (uint16_t )8;
  }
  {
#line 514
  fp = ipmi_open_file((char const   *)file, 0);
  }
#line 515
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 516
    return (-1);
  }
  {
#line 518
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 518
    tmp___16 = feof(fp);
    }
#line 518
    if (! (tmp___16 == 0)) {
#line 518
      goto while_break;
    }
    {
#line 519
    tmp = fgets((char */* __restrict  */)(buf), 1024, (FILE */* __restrict  */)fp);
    }
#line 519
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 520
      goto while_continue;
    }
    {
#line 523
    ptr = strchr((char const   *)(buf), '#');
    }
#line 524
    if (ptr) {
#line 525
      *ptr = (char )'\000';
    } else {
      {
#line 527
      tmp___0 = strlen((char const   *)(buf));
#line 527
      ptr = buf + tmp___0;
      }
    }
#line 530
    ptr --;
    {
#line 531
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 531
      tmp___2 = __ctype_b_loc();
      }
#line 531
      if ((int const   )*(*tmp___2 + (int )*ptr) & 8192) {
#line 531
        if (! ((unsigned long )ptr >= (unsigned long )(buf))) {
#line 531
          goto while_break___0;
        }
      } else {
#line 531
        goto while_break___0;
      }
#line 532
      tmp___1 = ptr;
#line 532
      ptr --;
#line 532
      *tmp___1 = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 533
    ptr = buf;
    {
#line 534
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 534
      tmp___3 = __ctype_b_loc();
      }
#line 534
      if (! ((int const   )*(*tmp___3 + (int )*ptr) & 8192)) {
#line 534
        goto while_break___1;
      }
#line 535
      ptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 536
    tmp___4 = strlen((char const   *)ptr);
    }
#line 536
    if (tmp___4 == 0UL) {
#line 537
      goto while_continue;
    }
    {
#line 541
    i = 0;
#line 542
    tok = strtok((char */* __restrict  */)ptr, (char const   */* __restrict  */)" ");
    }
    {
#line 543
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 543
      if (! tok) {
#line 543
        goto while_break___2;
      }
#line 544
      if (i == 7) {
#line 545
        goto while_break___2;
      }
#line 546
      tmp___5 = i;
#line 546
      i ++;
#line 546
      j = tmp___5;
#line 547
      if ((int )chmed == 12) {
#line 548
        j ++;
      }
      {
#line 549
      tmp___6 = strtol((char const   */* __restrict  */)tok, (char **/* __restrict  */)((void *)0),
                       0);
#line 549
      rqdata[j] = (uint8_t )tmp___6;
#line 550
      tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 552
    if (i < 7) {
      {
#line 553
      tmp___7 = buf2str(rqdata, (int )sizeof(rqdata));
#line 553
      lprintf(3, "Invalid Event: %s", tmp___7);
      }
#line 555
      goto while_continue;
    }
    {
#line 558
    memset((void *)(& sel_event), 0, sizeof(struct sel_event_record ));
#line 559
    sel_event.record_id = (uint16_t )0;
#line 560
    sel_event.sel_type.standard_type.gen_id = (uint16_t )2;
    }
#line 562
    if ((int )chmed == 12) {
#line 562
      j = 1;
    } else {
#line 562
      j = 0;
    }
    {
#line 563
    tmp___8 = j;
#line 563
    j ++;
#line 563
    sel_event.sel_type.standard_type.evm_rev = rqdata[tmp___8];
#line 564
    tmp___9 = j;
#line 564
    j ++;
#line 564
    sel_event.sel_type.standard_type.sensor_type = rqdata[tmp___9];
#line 565
    tmp___10 = j;
#line 565
    j ++;
#line 565
    sel_event.sel_type.standard_type.sensor_num = rqdata[tmp___10];
#line 566
    sel_event.sel_type.standard_type.event_type = (uint8_t )((int )rqdata[j] & 127);
#line 567
    tmp___11 = j;
#line 567
    j ++;
#line 567
    sel_event.sel_type.standard_type.event_dir = (uint8_t )(((int )rqdata[tmp___11] & 128) >> 7);
#line 568
    tmp___12 = j;
#line 568
    j ++;
#line 568
    sel_event.sel_type.standard_type.event_data[0] = rqdata[tmp___12];
#line 569
    tmp___13 = j;
#line 569
    j ++;
#line 569
    sel_event.sel_type.standard_type.event_data[1] = rqdata[tmp___13];
#line 570
    tmp___14 = j;
#line 570
    j ++;
#line 570
    sel_event.sel_type.standard_type.event_data[2] = rqdata[tmp___14];
#line 572
    ipmi_sel_print_std_entry(intf, & sel_event);
#line 574
    rsp = (*(intf->sendrecv))(intf, & req);
    }
#line 575
    if ((unsigned long )rsp == (unsigned long )((void *)0)) {
      {
#line 576
      lprintf(3, "Platform Event Message command failed");
#line 577
      rc = -1;
      }
    } else
#line 579
    if ((int )rsp->ccode > 0) {
      {
#line 580
      tmp___15 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 580
      lprintf(3, "Platform Event Message command failed: %s", tmp___15);
#line 582
      rc = -1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 586
  fclose(fp);
  }
#line 587
  return (rc);
}
}
#line 590 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_event.c"
static void ipmi_event_usage(void) 
{ 


  {
  {
#line 593
  lprintf(5, "");
#line 594
  lprintf(5, "usage: event <num>");
#line 595
  lprintf(5, "   Send generic test events");
#line 596
  lprintf(5, "   1 : Temperature - Upper Critical - Going High");
#line 597
  lprintf(5, "   2 : Voltage Threshold - Lower Critical - Going Low");
#line 598
  lprintf(5, "   3 : Memory - Correctable ECC");
#line 599
  lprintf(5, "");
#line 600
  lprintf(5, "usage: event file <filename>");
#line 601
  lprintf(5, "   Read and generate events from file");
#line 602
  lprintf(5, "   Use the \'sel save\' command to generate from SEL");
#line 603
  lprintf(5, "");
#line 604
  lprintf(5, "usage: event <sensorid> <state> [event_dir]");
#line 605
  lprintf(5, "   sensorid  : Sensor ID string to use for event data");
#line 606
  lprintf(5, "   state     : Sensor state, use \'list\' to see possible states for sensor");
#line 607
  lprintf(5, "   event_dir : assert, deassert [default=assert]");
#line 608
  lprintf(5, "");
  }
#line 609
  return;
}
}
#line 611 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_event.c"
int ipmi_event_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;

  {
#line 614
  rc = 0;
#line 616
  if (argc == 0) {
    {
#line 617
    ipmi_event_usage();
    }
#line 618
    return (0);
  } else {
    {
#line 616
    tmp = strncmp((char const   *)*(argv + 0), "help", (size_t )4);
    }
#line 616
    if (tmp == 0) {
      {
#line 617
      ipmi_event_usage();
      }
#line 618
      return (0);
    }
  }
  {
#line 620
  tmp___1 = strncmp((char const   *)*(argv + 0), "file", (size_t )4);
  }
#line 620
  if (tmp___1 == 0) {
#line 621
    if (argc < 2) {
      {
#line 622
      ipmi_event_usage();
      }
#line 623
      return (0);
    }
    {
#line 625
    tmp___0 = ipmi_event_fromfile(intf, *(argv + 1));
    }
#line 625
    return (tmp___0);
  }
  {
#line 627
  tmp___5 = strlen((char const   *)*(argv + 0));
  }
#line 627
  if (tmp___5 == 1UL) {
    {
#line 629
    if ((int )*(*(argv + 0) + 0) == 49) {
#line 629
      goto case_49;
    }
#line 630
    if ((int )*(*(argv + 0) + 0) == 50) {
#line 630
      goto case_50;
    }
#line 631
    if ((int )*(*(argv + 0) + 0) == 51) {
#line 631
      goto case_51;
    }
#line 628
    goto switch_break;
    case_49: /* CIL Label */ 
    {
#line 629
    tmp___2 = ipmi_send_platform_event_num(intf, 1);
    }
#line 629
    return (tmp___2);
    case_50: /* CIL Label */ 
    {
#line 630
    tmp___3 = ipmi_send_platform_event_num(intf, 2);
    }
#line 630
    return (tmp___3);
    case_51: /* CIL Label */ 
    {
#line 631
    tmp___4 = ipmi_send_platform_event_num(intf, 3);
    }
#line 631
    return (tmp___4);
    switch_break: /* CIL Label */ ;
    }
  }
#line 634
  if (argc < 2) {
    {
#line 635
    rc = ipmi_event_fromsensor(intf, *(argv + 0), (char *)((void *)0), (char *)((void *)0));
    }
  } else
#line 636
  if (argc < 3) {
    {
#line 637
    rc = ipmi_event_fromsensor(intf, *(argv + 0), *(argv + 1), (char *)((void *)0));
    }
  } else {
    {
#line 639
    rc = ipmi_event_fromsensor(intf, *(argv + 0), *(argv + 1), *(argv + 2));
    }
  }
#line 641
  return (rc);
}
}
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 459
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 252 "../include/ipmitool/ipmi_channel.h"
uint8_t ipmi_get_channel_medium(struct ipmi_intf *intf , uint8_t channel ) ;
#line 254
int ipmi_channel_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 255
int ipmi_get_channel_auth_cap(struct ipmi_intf *intf , uint8_t channel , uint8_t priv ) ;
#line 256
int ipmi_get_channel_info(struct ipmi_intf *intf , uint8_t channel ) ;
#line 47 "../include/ipmitool/ipmi_strings.h"
extern struct valstr  const  ipmi_authtype_vals[] ;
#line 48
extern struct valstr  const  ipmi_channel_protocol_vals[] ;
#line 49
extern struct valstr  const  ipmi_channel_medium_vals[] ;
#line 51
extern struct valstr  const  ipmi_auth_algorithms[] ;
#line 52
extern struct valstr  const  ipmi_integrity_algorithms[] ;
#line 53
extern struct valstr  const  ipmi_encryption_algorithms[] ;
#line 57 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_channel.c"
void printf_channel_usage(void) ;
#line 69 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_channel.c"
static char supportedTypes[128]  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_channel.c"
static char const   *ipmi_1_5_authtypes(uint8_t n ) 
{ 
  uint32_t i ;

  {
  {
#line 71
  bzero((void *)(supportedTypes), (size_t )128);
#line 73
  i = (uint32_t )0;
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! ((int const   )ipmi_authtype_vals[i].val != 0)) {
#line 73
      goto while_break;
    }
#line 74
    if ((int )n & (int )ipmi_authtype_vals[i].val) {
      {
#line 75
      strcat((char */* __restrict  */)(supportedTypes), (char const   */* __restrict  */)ipmi_authtype_vals[i].str);
#line 76
      strcat((char */* __restrict  */)(supportedTypes), (char const   */* __restrict  */)" ");
      }
    }
#line 73
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return ((char const   *)(supportedTypes));
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_channel.c"
int ipmi_get_channel_auth_cap(struct ipmi_intf *intf , uint8_t channel , uint8_t priv ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct get_channel_auth_cap_rsp auth_cap ;
  uint8_t msg_data[2] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 101
  msg_data[0] = (uint8_t )((int )channel | 128);
#line 102
  msg_data[1] = priv;
#line 104
  memset((void *)(& req), 0, sizeof(req));
#line 105
  req.msg.netfn = (uint8_t )6;
#line 106
  req.msg.cmd = (uint8_t )56;
#line 107
  req.msg.data = msg_data;
#line 108
  req.msg.data_len = (uint16_t )2;
#line 110
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 112
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
#line 112
    goto _L;
  } else
#line 112
  if ((int )rsp->ccode > 0) {
    _L: /* CIL Label */ 
    {
#line 117
    msg_data[0] = (uint8_t )((int )msg_data[0] & 127);
#line 119
    rsp = (*(intf->sendrecv))(intf, & req);
    }
#line 120
    if ((unsigned long )rsp == (unsigned long )((void *)0)) {
      {
#line 121
      lprintf(3, "Unable to Get Channel Authentication Capabilities");
      }
#line 122
      return (-1);
    }
#line 124
    if ((int )rsp->ccode > 0) {
      {
#line 125
      tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 125
      lprintf(3, "Get Channel Authentication Capabilities failed: %s", tmp);
      }
#line 127
      return (-1);
    }
  }
  {
#line 131
  memcpy((void */* __restrict  */)(& auth_cap), (void const   */* __restrict  */)(rsp->data),
         sizeof(struct get_channel_auth_cap_rsp ));
#line 133
  printf((char const   */* __restrict  */)"Channel number             : %d\n", (int )auth_cap.channel_number);
#line 135
  tmp___0 = ipmi_1_5_authtypes(auth_cap.enabled_auth_types);
#line 135
  printf((char const   */* __restrict  */)"IPMI v1.5  auth types      : %s\n", tmp___0);
  }
#line 138
  if (auth_cap.v20_data_available) {
#line 139
    if (auth_cap.kg_status) {
#line 139
      tmp___1 = "non-zero";
    } else {
#line 139
      tmp___1 = "default (all zeroes)";
    }
    {
#line 139
    printf((char const   */* __restrict  */)"KG status                  : %s\n", tmp___1);
    }
  }
#line 142
  if (auth_cap.per_message_auth) {
#line 142
    tmp___2 = "dis";
  } else {
#line 142
    tmp___2 = "en";
  }
  {
#line 142
  printf((char const   */* __restrict  */)"Per message authentication : %sabled\n",
         tmp___2);
  }
#line 144
  if (auth_cap.user_level_auth) {
#line 144
    tmp___3 = "dis";
  } else {
#line 144
    tmp___3 = "en";
  }
  {
#line 144
  printf((char const   */* __restrict  */)"User level authentication  : %sabled\n",
         tmp___3);
  }
#line 147
  if (auth_cap.non_null_usernames) {
#line 147
    tmp___4 = "yes";
  } else {
#line 147
    tmp___4 = "no";
  }
  {
#line 147
  printf((char const   */* __restrict  */)"Non-null user names exist  : %s\n", tmp___4);
  }
#line 149
  if (auth_cap.null_usernames) {
#line 149
    tmp___5 = "yes";
  } else {
#line 149
    tmp___5 = "no";
  }
  {
#line 149
  printf((char const   */* __restrict  */)"Null user names exist      : %s\n", tmp___5);
  }
#line 151
  if (auth_cap.anon_login_enabled) {
#line 151
    tmp___6 = "yes";
  } else {
#line 151
    tmp___6 = "no";
  }
  {
#line 151
  printf((char const   */* __restrict  */)"Anonymous login enabled    : %s\n", tmp___6);
  }
#line 154
  if (auth_cap.v20_data_available) {
#line 155
    if (auth_cap.ipmiv15_support) {
#line 155
      tmp___7 = "yes";
    } else {
#line 155
      tmp___7 = "no";
    }
    {
#line 155
    printf((char const   */* __restrict  */)"Channel supports IPMI v1.5 : %s\n", tmp___7);
    }
#line 157
    if (auth_cap.ipmiv20_support) {
#line 157
      tmp___8 = "yes";
    } else {
#line 157
      tmp___8 = "no";
    }
    {
#line 157
    printf((char const   */* __restrict  */)"Channel supports IPMI v2.0 : %s\n", tmp___8);
    }
  }
#line 165
  if ((int )auth_cap.enabled_auth_types & 32) {
    {
#line 166
    printf((char const   */* __restrict  */)"IANA Number for OEM        : %d\n", ((int )auth_cap.oem_id[0] | ((int )auth_cap.oem_id[1] << 8)) | ((int )auth_cap.oem_id[2] << 16));
#line 170
    printf((char const   */* __restrict  */)"OEM Auxiliary Data         : 0x%x\n",
           (int )auth_cap.oem_aux_data);
    }
  }
#line 174
  return (0);
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_channel.c"
int ipmi_get_channel_info(struct ipmi_intf *intf , uint8_t channel ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t rqdata[2] ;
  uint8_t medium ;
  struct get_channel_info_rsp channel_info ;
  struct get_channel_access_rsp channel_access ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;

  {
  {
#line 196
  memset((void *)(& req), 0, sizeof(req));
#line 197
  req.msg.netfn = (uint8_t )6;
#line 198
  req.msg.cmd = (uint8_t )66;
#line 199
  req.msg.data = & channel;
#line 200
  req.msg.data_len = (uint16_t )1;
#line 202
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 203
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 204
    lprintf(3, "Unable to Get Channel Info");
    }
#line 205
    return (-1);
  }
#line 207
  if ((int )rsp->ccode > 0) {
    {
#line 208
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 208
    lprintf(3, "Get Channel Info failed: %s", tmp);
    }
#line 210
    return (-1);
  }
  {
#line 213
  memcpy((void */* __restrict  */)(& channel_info), (void const   */* __restrict  */)(rsp->data),
         sizeof(struct get_channel_info_rsp ));
#line 215
  printf((char const   */* __restrict  */)"Channel 0x%x info:\n", (int )channel_info.channel_number);
#line 217
  tmp___0 = val2str((uint16_t )channel_info.channel_medium, ipmi_channel_medium_vals);
#line 217
  printf((char const   */* __restrict  */)"  Channel Medium Type   : %s\n", tmp___0);
#line 220
  tmp___1 = val2str((uint16_t )channel_info.channel_protocol, ipmi_channel_protocol_vals);
#line 220
  printf((char const   */* __restrict  */)"  Channel Protocol Type : %s\n", tmp___1);
#line 223
  printf((char const   */* __restrict  */)"  Session Support       : ");
  }
  {
#line 225
  if ((int )channel_info.session_support == 0) {
#line 225
    goto case_0;
  }
#line 228
  if ((int )channel_info.session_support == 1) {
#line 228
    goto case_1;
  }
#line 231
  if ((int )channel_info.session_support == 2) {
#line 231
    goto case_2;
  }
#line 235
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 226
  printf((char const   */* __restrict  */)"session-less\n");
  }
#line 227
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 229
  printf((char const   */* __restrict  */)"single-session\n");
  }
#line 230
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 232
  printf((char const   */* __restrict  */)"multi-session\n");
  }
#line 233
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 236
  printf((char const   */* __restrict  */)"session-based\n");
  }
#line 237
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 240
  printf((char const   */* __restrict  */)"  Active Session Count  : %d\n", (int )channel_info.active_sessions);
#line 243
  printf((char const   */* __restrict  */)"  Protocol Vendor ID    : %d\n", ((int )channel_info.vendor_id[0] | ((int )channel_info.vendor_id[1] << 8)) | ((int )channel_info.vendor_id[2] << 16));
#line 250
  medium = ipmi_get_channel_medium(intf, channel);
  }
#line 251
  if ((int )medium != 4) {
#line 251
    if ((int )medium != 6) {
#line 253
      return (0);
    }
  }
  {
#line 256
  memset((void *)(& req), 0, sizeof(req));
#line 257
  rqdata[0] = (uint8_t )((int )channel & 15);
#line 261
  rqdata[1] = (uint8_t )128;
#line 262
  req.msg.netfn = (uint8_t )6;
#line 263
  req.msg.cmd = (uint8_t )65;
#line 264
  req.msg.data = rqdata;
#line 265
  req.msg.data_len = (uint16_t )2;
#line 267
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 268
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 269
    lprintf(3, "Unable to Get Channel Access (volatile)");
    }
#line 270
    return (-1);
  }
#line 272
  if ((int )rsp->ccode > 0) {
    {
#line 273
    tmp___2 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 273
    lprintf(3, "Get Channel Access (volatile) failed: %s", tmp___2);
    }
#line 275
    return (-1);
  }
  {
#line 278
  memcpy((void */* __restrict  */)(& channel_access), (void const   */* __restrict  */)(rsp->data),
         sizeof(struct get_channel_access_rsp ));
#line 281
  printf((char const   */* __restrict  */)"  Volatile(active) Settings\n");
  }
#line 282
  if (channel_access.alerting) {
#line 282
    tmp___3 = "dis";
  } else {
#line 282
    tmp___3 = "en";
  }
  {
#line 282
  printf((char const   */* __restrict  */)"    Alerting            : %sabled\n", tmp___3);
  }
#line 284
  if (channel_access.per_message_auth) {
#line 284
    tmp___4 = "dis";
  } else {
#line 284
    tmp___4 = "en";
  }
  {
#line 284
  printf((char const   */* __restrict  */)"    Per-message Auth    : %sabled\n", tmp___4);
  }
#line 286
  if (channel_access.user_level_auth) {
#line 286
    tmp___5 = "dis";
  } else {
#line 286
    tmp___5 = "en";
  }
  {
#line 286
  printf((char const   */* __restrict  */)"    User Level Auth     : %sabled\n", tmp___5);
#line 289
  printf((char const   */* __restrict  */)"    Access Mode         : ");
  }
  {
#line 291
  if ((int )channel_access.access_mode == 0) {
#line 291
    goto case_0___0;
  }
#line 294
  if ((int )channel_access.access_mode == 1) {
#line 294
    goto case_1___0;
  }
#line 297
  if ((int )channel_access.access_mode == 2) {
#line 297
    goto case_2___0;
  }
#line 300
  if ((int )channel_access.access_mode == 3) {
#line 300
    goto case_3;
  }
#line 303
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
  {
#line 292
  printf((char const   */* __restrict  */)"disabled\n");
  }
#line 293
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 295
  printf((char const   */* __restrict  */)"pre-boot only\n");
  }
#line 296
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 298
  printf((char const   */* __restrict  */)"always available\n");
  }
#line 299
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 301
  printf((char const   */* __restrict  */)"shared\n");
  }
#line 302
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 304
  printf((char const   */* __restrict  */)"unknown\n");
  }
#line 305
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 310
  rqdata[1] = (uint8_t )64;
#line 311
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 312
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 313
    lprintf(3, "Unable to Get Channel Access (non-volatile)");
    }
#line 314
    return (-1);
  }
#line 316
  if ((int )rsp->ccode > 0) {
    {
#line 317
    tmp___6 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 317
    lprintf(3, "Get Channel Access (non-volatile) failed: %s", tmp___6);
    }
#line 319
    return (-1);
  }
  {
#line 322
  memcpy((void */* __restrict  */)(& channel_access), (void const   */* __restrict  */)(rsp->data),
         sizeof(struct get_channel_access_rsp ));
#line 324
  printf((char const   */* __restrict  */)"  Non-Volatile Settings\n");
  }
#line 325
  if (channel_access.alerting) {
#line 325
    tmp___7 = "dis";
  } else {
#line 325
    tmp___7 = "en";
  }
  {
#line 325
  printf((char const   */* __restrict  */)"    Alerting            : %sabled\n", tmp___7);
  }
#line 327
  if (channel_access.per_message_auth) {
#line 327
    tmp___8 = "dis";
  } else {
#line 327
    tmp___8 = "en";
  }
  {
#line 327
  printf((char const   */* __restrict  */)"    Per-message Auth    : %sabled\n", tmp___8);
  }
#line 329
  if (channel_access.user_level_auth) {
#line 329
    tmp___9 = "dis";
  } else {
#line 329
    tmp___9 = "en";
  }
  {
#line 329
  printf((char const   */* __restrict  */)"    User Level Auth     : %sabled\n", tmp___9);
#line 332
  printf((char const   */* __restrict  */)"    Access Mode         : ");
  }
  {
#line 334
  if ((int )channel_access.access_mode == 0) {
#line 334
    goto case_0___1;
  }
#line 337
  if ((int )channel_access.access_mode == 1) {
#line 337
    goto case_1___1;
  }
#line 340
  if ((int )channel_access.access_mode == 2) {
#line 340
    goto case_2___1;
  }
#line 343
  if ((int )channel_access.access_mode == 3) {
#line 343
    goto case_3___0;
  }
#line 346
  goto switch_default___1;
  case_0___1: /* CIL Label */ 
  {
#line 335
  printf((char const   */* __restrict  */)"disabled\n");
  }
#line 336
  goto switch_break___1;
  case_1___1: /* CIL Label */ 
  {
#line 338
  printf((char const   */* __restrict  */)"pre-boot only\n");
  }
#line 339
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
  {
#line 341
  printf((char const   */* __restrict  */)"always available\n");
  }
#line 342
  goto switch_break___1;
  case_3___0: /* CIL Label */ 
  {
#line 344
  printf((char const   */* __restrict  */)"shared\n");
  }
#line 345
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
  {
#line 347
  printf((char const   */* __restrict  */)"unknown\n");
  }
#line 348
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 351
  return (0);
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_channel.c"
static int ipmi_get_user_access(struct ipmi_intf *intf , uint8_t channel , uint8_t userid ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req1 ;
  struct ipmi_rq req2 ;
  uint8_t rqdata[2] ;
  struct get_user_access_rsp user_access ;
  int curr_uid ;
  int max_uid ;
  int init ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;

  {
#line 361
  max_uid = 0;
#line 361
  init = 1;
#line 363
  tmp = (int )userid;
#line 363
  if (! tmp) {
#line 363
    tmp = 1;
  }
  {
#line 363
  curr_uid = tmp;
#line 365
  memset((void *)(& req1), 0, sizeof(req1));
#line 366
  req1.msg.netfn = (uint8_t )6;
#line 367
  req1.msg.cmd = (uint8_t )68;
#line 368
  req1.msg.data = rqdata;
#line 369
  req1.msg.data_len = (uint16_t )2;
#line 371
  memset((void *)(& req2), 0, sizeof(req2));
#line 372
  req2.msg.netfn = (uint8_t )6;
#line 373
  req2.msg.cmd = (uint8_t )70;
#line 374
  req2.msg.data = rqdata;
#line 375
  req2.msg.data_len = (uint16_t )1;
  }
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 379
    rqdata[0] = (uint8_t )((int )channel & 15);
#line 380
    rqdata[1] = (uint8_t )(curr_uid & 63);
#line 382
    rsp = (*(intf->sendrecv))(intf, & req1);
    }
#line 383
    if ((unsigned long )rsp == (unsigned long )((void *)0)) {
      {
#line 384
      lprintf(3, "Unable to Get User Access (channel %d id %d)", (int )rqdata[0],
              (int )rqdata[1]);
      }
#line 386
      return (-1);
    }
#line 388
    if ((int )rsp->ccode > 0) {
      {
#line 389
      tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 389
      lprintf(3, "Get User Access (channel %d id %d) failed: %s", (int )rqdata[0],
              (int )rqdata[1], tmp___0);
      }
#line 392
      return (-1);
    }
    {
#line 395
    memcpy((void */* __restrict  */)(& user_access), (void const   */* __restrict  */)(rsp->data),
           sizeof(struct get_user_access_rsp ));
#line 397
    rqdata[0] = (uint8_t )(curr_uid & 63);
#line 399
    rsp = (*(intf->sendrecv))(intf, & req2);
    }
#line 400
    if ((unsigned long )rsp == (unsigned long )((void *)0)) {
      {
#line 401
      lprintf(3, "Unable to Get User Name (id %d)", (int )rqdata[0]);
      }
#line 402
      return (-1);
    }
#line 404
    if ((int )rsp->ccode > 0) {
      {
#line 405
      tmp___1 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 405
      lprintf(3, "Get User Name (id %d) failed: %s", (int )rqdata[0], tmp___1);
      }
#line 407
      return (-1);
    }
#line 410
    if (init) {
      {
#line 411
      printf((char const   */* __restrict  */)"Maximum User IDs     : %d\n", (int )user_access.max_user_ids);
#line 412
      printf((char const   */* __restrict  */)"Enabled User IDs     : %d\n", (int )user_access.enabled_user_ids);
#line 413
      max_uid = (int )user_access.max_user_ids;
#line 414
      init = 0;
      }
    }
    {
#line 417
    printf((char const   */* __restrict  */)"\n");
#line 418
    printf((char const   */* __restrict  */)"User ID              : %d\n", curr_uid);
#line 419
    printf((char const   */* __restrict  */)"User Name            : %s\n", rsp->data);
    }
#line 420
    if (curr_uid <= (int )user_access.fixed_user_ids) {
#line 420
      tmp___2 = "Yes";
    } else {
#line 420
      tmp___2 = "No";
    }
    {
#line 420
    printf((char const   */* __restrict  */)"Fixed Name           : %s\n", tmp___2);
    }
#line 422
    if (user_access.callin_callback) {
#line 422
      tmp___3 = "callback";
    } else {
#line 422
      tmp___3 = "call-in / callback";
    }
    {
#line 422
    printf((char const   */* __restrict  */)"Access Available     : %s\n", tmp___3);
    }
#line 424
    if (user_access.link_auth) {
#line 424
      tmp___4 = "en";
    } else {
#line 424
      tmp___4 = "dis";
    }
    {
#line 424
    printf((char const   */* __restrict  */)"Link Authentication  : %sabled\n", tmp___4);
    }
#line 426
    if (user_access.ipmi_messaging) {
#line 426
      tmp___5 = "en";
    } else {
#line 426
      tmp___5 = "dis";
    }
    {
#line 426
    printf((char const   */* __restrict  */)"IPMI Messaging       : %sabled\n", tmp___5);
#line 428
    tmp___6 = val2str((uint16_t )user_access.privilege_limit, ipmi_privlvl_vals);
#line 428
    printf((char const   */* __restrict  */)"Privilege Level      : %s\n", tmp___6);
#line 431
    curr_uid ++;
    }
#line 377
    if (! userid) {
#line 377
      if (! (curr_uid <= max_uid)) {
#line 377
        goto while_break;
      }
    } else {
#line 377
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  return (0);
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_channel.c"
static int ipmi_set_user_access(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  uint8_t channel ;
  uint8_t privilege_limit ;
  uint8_t userid ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t rqdata[2] ;
  struct get_user_access_rsp user_access ;
  struct set_user_access_data set_access ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;

  {
#line 449
  if (argc < 3) {
    {
#line 450
    printf_channel_usage();
    }
#line 451
    return (0);
  } else {
    {
#line 449
    tmp = strncmp((char const   *)*(argv + 0), "help", (size_t )4);
    }
#line 449
    if (tmp == 0) {
      {
#line 450
      printf_channel_usage();
      }
#line 451
      return (0);
    }
  }
  {
#line 454
  tmp___0 = str2uchar((char const   *)*(argv + 0), & channel);
  }
#line 454
  if (tmp___0 != 0) {
    {
#line 455
    lprintf(3, "Numeric value expected, but \'%s\' given.", *(argv + 0));
    }
#line 456
    return (-1);
  }
  {
#line 458
  tmp___1 = str2uchar((char const   *)*(argv + 1), & userid);
  }
#line 458
  if (tmp___1 != 0) {
    {
#line 459
    lprintf(3, "Numeric value expected, but \'%s\' given.", *(argv + 1));
    }
#line 460
    return (-1);
  }
  {
#line 463
  memset((void *)(& req), 0, sizeof(req));
#line 464
  req.msg.netfn = (uint8_t )6;
#line 465
  req.msg.cmd = (uint8_t )68;
#line 466
  req.msg.data = rqdata;
#line 467
  req.msg.data_len = (uint16_t )2;
#line 469
  rqdata[0] = (uint8_t )((int )channel & 15);
#line 470
  rqdata[1] = (uint8_t )((int )userid & 63);
#line 472
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 473
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 474
    lprintf(3, "Unable to Get User Access (channel %d id %d)", (int )rqdata[0], (int )rqdata[1]);
    }
#line 476
    return (-1);
  }
#line 478
  if ((int )rsp->ccode > 0) {
    {
#line 479
    tmp___2 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 479
    lprintf(3, "Get User Access (channel %d id %d) failed: %s", (int )rqdata[0], (int )rqdata[1],
            tmp___2);
    }
#line 482
    return (-1);
  }
  {
#line 485
  memcpy((void */* __restrict  */)(& user_access), (void const   */* __restrict  */)(rsp->data),
         sizeof(struct get_user_access_rsp ));
#line 487
  memset((void *)(& set_access), 0, sizeof(set_access));
#line 488
  set_access.change_bits = (uint8_t )1;
#line 489
  set_access.callin_callback = user_access.callin_callback;
#line 490
  set_access.link_auth = user_access.link_auth;
#line 491
  set_access.ipmi_messaging = user_access.ipmi_messaging;
#line 492
  set_access.channel = channel;
#line 493
  set_access.user_id = userid;
#line 494
  set_access.privilege_limit = user_access.privilege_limit;
#line 495
  set_access.session_limit = (uint8_t )0;
#line 497
  i = 2;
  }
  {
#line 497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 497
    if (! (i < argc)) {
#line 497
      goto while_break;
    }
    {
#line 499
    tmp___11 = strncmp((char const   *)*(argv + i), "callin=", (size_t )7);
    }
#line 499
    if (tmp___11 == 0) {
      {
#line 500
      tmp___3 = strncmp((char const   *)(*(argv + i) + 7), "off", (size_t )3);
      }
#line 500
      if (tmp___3) {
#line 500
        tmp___4 = 0;
      } else {
#line 500
        tmp___4 = 1;
      }
#line 500
      set_access.callin_callback = (uint8_t )tmp___4;
    } else {
      {
#line 502
      tmp___10 = strncmp((char const   *)*(argv + i), "link=", (size_t )5);
      }
#line 502
      if (tmp___10 == 0) {
        {
#line 503
        tmp___5 = strncmp((char const   *)(*(argv + i) + 5), "off", (size_t )3);
#line 503
        set_access.link_auth = (uint8_t )tmp___5;
        }
      } else {
        {
#line 505
        tmp___9 = strncmp((char const   *)*(argv + i), "ipmi=", (size_t )5);
        }
#line 505
        if (tmp___9 == 0) {
          {
#line 506
          tmp___6 = strncmp((char const   *)(*(argv + i) + 5), "off", (size_t )3);
#line 506
          set_access.ipmi_messaging = (uint8_t )tmp___6;
          }
        } else {
          {
#line 508
          tmp___8 = strncmp((char const   *)*(argv + i), "privilege=", (size_t )10);
          }
#line 508
          if (tmp___8 == 0) {
            {
#line 509
            tmp___7 = str2uchar((char const   *)(*(argv + i) + 10), & privilege_limit);
            }
#line 509
            if (tmp___7 != 0) {
              {
#line 510
              lprintf(3, "Numeric value expected, but \'%s\' given.", *(argv + i) + 10);
              }
#line 511
              return (-1);
            }
#line 513
            set_access.privilege_limit = privilege_limit;
          } else {
            {
#line 516
            printf((char const   */* __restrict  */)"Invalid option: %s\n", *(argv + i));
            }
#line 517
            return (-1);
          }
        }
      }
    }
#line 497
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 521
  memset((void *)(& req), 0, sizeof(req));
#line 522
  req.msg.netfn = (uint8_t )6;
#line 523
  req.msg.cmd = (uint8_t )67;
#line 524
  req.msg.data = (uint8_t *)(& set_access);
#line 525
  req.msg.data_len = (uint16_t )4;
#line 527
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 528
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 529
    lprintf(3, "Unable to Set User Access (channel %d id %d)", (int )set_access.channel,
            (int )set_access.user_id);
    }
#line 531
    return (-1);
  }
#line 533
  if ((int )rsp->ccode > 0) {
    {
#line 534
    tmp___12 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 534
    lprintf(3, "Set User Access (channel %d id %d) failed: %s", (int )set_access.channel,
            (int )set_access.user_id, tmp___12);
    }
#line 537
    return (-1);
  }
#line 540
  return (0);
}
}
#line 547 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_channel.c"
static char s[10]  ;
#line 544 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_channel.c"
static char const   *iana_string(uint32_t iana ) 
{ 


  {
#line 549
  if (iana) {
    {
#line 551
    sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%06x",
            iana);
    }
#line 552
    return ((char const   *)(s));
  } else {
#line 555
    return ("N/A");
  }
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_channel.c"
static int ipmi_get_channel_cipher_suites(struct ipmi_intf *intf , char const   *payload_type ,
                                          uint8_t channel ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t oem_record ;
  uint8_t rqdata[3] ;
  uint32_t iana ;
  uint8_t auth_alg ;
  uint8_t integrity_alg ;
  uint8_t crypt_alg ;
  uint8_t cipher_suite_id ;
  uint8_t list_index ;
  uint8_t cipher_suite_data[1024] ;
  uint16_t offset ;
  uint16_t cipher_suite_data_length ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  uint16_t tmp___3 ;
  uint16_t tmp___4 ;
  uint16_t tmp___5 ;
  uint16_t tmp___6 ;
  uint16_t tmp___7 ;
  uint16_t tmp___8 ;
  uint16_t tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;

  {
  {
#line 572
  list_index = (uint8_t )0;
#line 574
  offset = (uint16_t )0;
#line 575
  cipher_suite_data_length = (uint16_t )0;
#line 577
  memset((void *)(cipher_suite_data), 0, sizeof(cipher_suite_data));
#line 579
  memset((void *)(& req), 0, sizeof(req));
#line 580
  req.msg.netfn = (uint8_t )6;
#line 581
  req.msg.cmd = (uint8_t )84;
#line 582
  req.msg.data = rqdata;
#line 583
  req.msg.data_len = (uint16_t )3;
#line 585
  rqdata[0] = channel;
#line 586
  tmp___0 = strncmp(payload_type, "ipmi", (size_t )4);
  }
#line 586
  if (tmp___0 == 0) {
#line 586
    rqdata[1] = (uint8_t )0;
  } else {
#line 586
    rqdata[1] = (uint8_t )1;
  }
  {
#line 587
  rqdata[2] = (uint8_t )128;
#line 589
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 590
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 591
    lprintf(3, "Unable to Get Channel Cipher Suites");
    }
#line 592
    return (-1);
  }
#line 594
  if ((int )rsp->ccode > 0) {
    {
#line 595
    tmp___1 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 595
    lprintf(3, "Get Channel Cipher Suites failed: %s", tmp___1);
    }
#line 597
    return (-1);
  }
#line 603
  if (rsp->data_len >= 1) {
#line 604
    channel = rsp->data[0];
  }
  {
#line 606
  while (1) {
    while_continue: /* CIL Label */ ;
#line 606
    if (rsp->data_len > 1) {
#line 606
      if (rsp->data_len == 17) {
#line 606
        if (! ((int )list_index < 63)) {
#line 606
          goto while_break;
        }
      } else {
#line 606
        goto while_break;
      }
    } else {
#line 606
      goto while_break;
    }
    {
#line 612
    memcpy((void */* __restrict  */)(cipher_suite_data + (int )offset), (void const   */* __restrict  */)(rsp->data + 1),
           (size_t )(rsp->data_len - 1));
#line 613
    offset = (uint16_t )((int )offset + (rsp->data_len - 1));
#line 618
    list_index = (uint8_t )((int )list_index + 1);
#line 619
    rqdata[2] = (uint8_t )(((int )rqdata[2] & 128) + (int )list_index);
#line 621
    rsp = (*(intf->sendrecv))(intf, & req);
    }
#line 622
    if ((unsigned long )rsp == (unsigned long )((void *)0)) {
      {
#line 623
      lprintf(3, "Unable to Get Channel Cipher Suites");
      }
#line 624
      return (-1);
    }
#line 626
    if ((int )rsp->ccode > 0) {
      {
#line 627
      tmp___2 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 627
      lprintf(3, "Get Channel Cipher Suites failed: %s", tmp___2);
      }
#line 629
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 634
  if (rsp->data_len > 1) {
    {
#line 640
    memcpy((void */* __restrict  */)(cipher_suite_data + (int )offset), (void const   */* __restrict  */)(rsp->data + 1),
           (size_t )(rsp->data_len - 1));
#line 641
    offset = (uint16_t )((int )offset + (rsp->data_len - 1));
    }
  }
#line 647
  cipher_suite_data_length = offset;
#line 648
  offset = (uint16_t )0;
#line 650
  if (! csv_output) {
    {
#line 651
    printf((char const   */* __restrict  */)"ID   IANA    Auth Alg        Integrity Alg   Confidentiality Alg\n");
    }
  }
  {
#line 653
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 653
    if (! ((int )offset < (int )cipher_suite_data_length)) {
#line 653
      goto while_break___0;
    }
#line 655
    tmp___6 = offset;
#line 655
    offset = (uint16_t )((int )offset + 1);
#line 655
    if ((int )cipher_suite_data[tmp___6] == 192) {
#line 657
      oem_record = (uint8_t )0;
#line 658
      iana = (uint32_t )0;
#line 661
      if ((int )cipher_suite_data_length - (int )offset < 4) {
        {
#line 663
        lprintf(3, "Incomplete data record in cipher suite data");
        }
#line 664
        return (-1);
      }
#line 667
      tmp___3 = offset;
#line 667
      offset = (uint16_t )((int )offset + 1);
#line 667
      cipher_suite_id = cipher_suite_data[tmp___3];
    } else {
#line 670
      tmp___5 = offset;
#line 670
      offset = (uint16_t )((int )offset + 1);
#line 670
      if ((int )cipher_suite_data[tmp___5] == 193) {
#line 672
        oem_record = (uint8_t )1;
#line 675
        if ((int )cipher_suite_data_length - (int )offset < 4) {
          {
#line 677
          lprintf(3, "Incomplete data record in cipher suite data");
          }
#line 678
          return (-1);
        }
#line 681
        tmp___4 = offset;
#line 681
        offset = (uint16_t )((int )offset + 1);
#line 681
        cipher_suite_id = cipher_suite_data[tmp___4];
#line 686
        iana = (uint32_t )(((int )cipher_suite_data[offset] | ((int )cipher_suite_data[(int )offset + 1] << 8)) | ((int )cipher_suite_data[(int )offset + 2] << 16));
#line 690
        offset = (uint16_t )((int )offset + 3);
      } else {
        {
#line 694
        lprintf(3, "Bad start of record byte in cipher suite data");
        }
#line 695
        return (-1);
      }
    }
#line 706
    auth_alg = (uint8_t )0;
#line 707
    integrity_alg = (uint8_t )0;
#line 708
    crypt_alg = (uint8_t )0;
    {
#line 710
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 710
      if (((int )cipher_suite_data[offset] & 192) != 192) {
#line 710
        if (! ((int )cipher_suite_data_length - (int )offset > 0)) {
#line 710
          goto while_break___1;
        }
      } else {
#line 710
        goto while_break___1;
      }
      {
#line 715
      if (((int )cipher_suite_data[offset] & 192) == 0) {
#line 715
        goto case_0;
      }
#line 719
      if (((int )cipher_suite_data[offset] & 192) == 64) {
#line 719
        goto case_64;
      }
#line 723
      if (((int )cipher_suite_data[offset] & 192) == 128) {
#line 723
        goto case_128;
      }
#line 713
      goto switch_break;
      case_0: /* CIL Label */ 
#line 717
      tmp___7 = offset;
#line 717
      offset = (uint16_t )((int )offset + 1);
#line 717
      auth_alg = (uint8_t )((int )cipher_suite_data[tmp___7] & 63);
#line 718
      goto switch_break;
      case_64: /* CIL Label */ 
#line 721
      tmp___8 = offset;
#line 721
      offset = (uint16_t )((int )offset + 1);
#line 721
      integrity_alg = (uint8_t )((int )cipher_suite_data[tmp___8] & 63);
#line 722
      goto switch_break;
      case_128: /* CIL Label */ 
#line 725
      tmp___9 = offset;
#line 725
      offset = (uint16_t )((int )offset + 1);
#line 725
      crypt_alg = (uint8_t )((int )cipher_suite_data[tmp___9] & 63);
#line 726
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 734
    tmp___10 = val2str((uint16_t )crypt_alg, ipmi_encryption_algorithms);
#line 734
    tmp___11 = val2str((uint16_t )integrity_alg, ipmi_integrity_algorithms);
#line 734
    tmp___12 = val2str((uint16_t )auth_alg, ipmi_auth_algorithms);
#line 734
    tmp___13 = iana_string(iana);
    }
#line 734
    if (csv_output) {
#line 734
      tmp___14 = "%d,%s,%s,%s,%s\n";
    } else {
#line 734
      tmp___14 = "%-4d %-7s %-15s %-15s %-15s\n";
    }
    {
#line 734
    printf((char const   */* __restrict  */)tmp___14, (int )cipher_suite_id, tmp___13,
           tmp___12, tmp___11, tmp___10);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 744
  return (0);
}
}
#line 749 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_channel.c"
uint8_t ipmi_get_channel_medium(struct ipmi_intf *intf , uint8_t channel ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct get_channel_info_rsp info ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 756
  memset((void *)(& req), 0, sizeof(req));
#line 757
  req.msg.netfn = (uint8_t )6;
#line 758
  req.msg.cmd = (uint8_t )66;
#line 759
  req.msg.data = & channel;
#line 760
  req.msg.data_len = (uint16_t )1;
#line 762
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 763
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 764
    lprintf(3, "Get Channel Info command failed");
    }
#line 765
    return ((uint8_t )0);
  }
#line 767
  if ((int )rsp->ccode > 0) {
#line 768
    if ((int )rsp->ccode == 204) {
#line 769
      return ((uint8_t )0);
    }
    {
#line 770
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 770
    lprintf(6, "Get Channel Info command failed: %s", tmp);
    }
#line 772
    return ((uint8_t )0);
  }
  {
#line 775
  memcpy((void */* __restrict  */)(& info), (void const   */* __restrict  */)(rsp->data),
         sizeof(struct get_channel_info_rsp ));
#line 777
  tmp___0 = val2str((uint16_t )info.channel_medium, ipmi_channel_medium_vals);
#line 777
  lprintf(7, "Channel type: %s", tmp___0);
  }
#line 780
  return (info.channel_medium);
}
}
#line 783 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_channel.c"
uint8_t ipmi_current_channel_medium(struct ipmi_intf *intf ) 
{ 
  uint8_t tmp ;

  {
  {
#line 786
  tmp = ipmi_get_channel_medium(intf, (uint8_t )14);
  }
#line 786
  return (tmp);
}
}
#line 789 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_channel.c"
void printf_channel_usage(void) 
{ 


  {
  {
#line 792
  lprintf(5, "Channel Commands: authcap   <channel number> <max privilege>");
#line 793
  lprintf(5, "                  getaccess <channel number> [user id]");
#line 794
  lprintf(5, "                  setaccess <channel number> <user id> [callin=on|off] [ipmi=on|off] [link=on|off] [privilege=level]");
#line 796
  lprintf(5, "                  info      [channel number]");
#line 797
  lprintf(5, "                  getciphers <ipmi | sol> [channel]\n");
#line 798
  lprintf(5, "Possible privilege levels are:");
#line 799
  lprintf(5, "   1   Callback level");
#line 800
  lprintf(5, "   2   User level");
#line 801
  lprintf(5, "   3   Operator level");
#line 802
  lprintf(5, "   4   Administrator level");
#line 803
  lprintf(5, "   5   OEM Proprietary level");
#line 804
  lprintf(5, "  15   No access");
  }
#line 805
  return;
}
}
#line 808 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_channel.c"
int ipmi_channel_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int retval ;
  uint8_t channel ;
  uint8_t priv ;
  int tmp ;
  int tmp___0 ;
  uint8_t ch ;
  uint8_t id ;
  int tmp___1 ;
  int tmp___2 ;
  uint8_t ch___0 ;
  int tmp___3 ;
  uint8_t ch___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 811
  retval = 0;
#line 812
  priv = (uint8_t )0;
#line 814
  if (argc == 0) {
    {
#line 816
    printf_channel_usage();
    }
  } else {
    {
#line 814
    tmp___12 = strncmp((char const   *)*(argv + 0), "help", (size_t )4);
    }
#line 814
    if (tmp___12 == 0) {
      {
#line 816
      printf_channel_usage();
      }
    } else {
      {
#line 818
      tmp___11 = strncmp((char const   *)*(argv + 0), "authcap", (size_t )7);
      }
#line 818
      if (tmp___11 == 0) {
#line 820
        if (argc != 3) {
          {
#line 821
          printf_channel_usage();
          }
#line 822
          return (-1);
        } else {
          {
#line 824
          tmp = str2uchar((char const   *)*(argv + 1), & channel);
          }
#line 824
          if (tmp != 0) {
            {
#line 825
            lprintf(3, "Numeric value expected, but \'%s\' given.", *(argv + 1));
            }
#line 826
            return (-1);
          }
          {
#line 828
          tmp___0 = str2uchar((char const   *)*(argv + 2), & priv);
          }
#line 828
          if (tmp___0 != 0) {
            {
#line 829
            lprintf(3, "Numeric value expected, but \'%s\' given.", *(argv + 2));
            }
#line 830
            return (-1);
          }
          {
#line 832
          retval = ipmi_get_channel_auth_cap(intf, channel, priv);
          }
        }
      } else {
        {
#line 835
        tmp___10 = strncmp((char const   *)*(argv + 0), "getaccess", (size_t )10);
        }
#line 835
        if (tmp___10 == 0) {
#line 837
          if (argc < 2) {
            {
#line 838
            printf_channel_usage();
            }
          } else
#line 837
          if (argc > 3) {
            {
#line 838
            printf_channel_usage();
            }
          } else {
            {
#line 840
            ch = (uint8_t )0;
#line 841
            id = (uint8_t )0;
#line 842
            tmp___1 = str2uchar((char const   *)*(argv + 1), & ch);
            }
#line 842
            if (tmp___1 != 0) {
              {
#line 843
              lprintf(3, "Numeric value expected, but \'%s\' given.", *(argv + 1));
              }
#line 844
              return (-1);
            }
#line 846
            if (argc == 3) {
              {
#line 847
              tmp___2 = str2uchar((char const   *)*(argv + 2), & id);
              }
#line 847
              if (tmp___2 != 0) {
                {
#line 848
                lprintf(3, "Numeric value expected, but \'%s\' given.", *(argv + 2));
                }
#line 849
                return (-1);
              }
            }
            {
#line 852
            retval = ipmi_get_user_access(intf, ch, id);
            }
          }
        } else {
          {
#line 855
          tmp___9 = strncmp((char const   *)*(argv + 0), "setaccess", (size_t )9);
          }
#line 855
          if (tmp___9 == 0) {
            {
#line 857
            retval = ipmi_set_user_access(intf, argc - 1, argv + 1);
            }
          } else {
            {
#line 859
            tmp___8 = strncmp((char const   *)*(argv + 0), "info", (size_t )4);
            }
#line 859
            if (tmp___8 == 0) {
#line 861
              if (argc > 2) {
                {
#line 862
                printf_channel_usage();
                }
              } else {
#line 864
                ch___0 = (uint8_t )14;
#line 865
                if (argc == 2) {
                  {
#line 866
                  tmp___3 = str2uchar((char const   *)*(argv + 1), & ch___0);
                  }
#line 866
                  if (tmp___3 != 0) {
                    {
#line 867
                    lprintf(3, "Numeric value expected, but \'%s\' given.", *(argv + 1));
                    }
#line 868
                    return (-1);
                  }
                }
                {
#line 871
                retval = ipmi_get_channel_info(intf, ch___0);
                }
              }
            } else {
              {
#line 876
              tmp___7 = strncmp((char const   *)*(argv + 0), "getciphers", (size_t )10);
              }
#line 876
              if (tmp___7 == 0) {
#line 878
                if (argc < 2) {
                  {
#line 880
                  printf_channel_usage();
                  }
                } else
#line 878
                if (argc > 3) {
                  {
#line 880
                  printf_channel_usage();
                  }
                } else {
                  {
#line 878
                  tmp___5 = strncmp((char const   *)*(argv + 1), "ipmi", (size_t )4);
                  }
#line 878
                  if (tmp___5) {
                    {
#line 878
                    tmp___6 = strncmp((char const   *)*(argv + 1), "sol", (size_t )3);
                    }
#line 878
                    if (tmp___6) {
                      {
#line 880
                      printf_channel_usage();
                      }
                    } else {
#line 878
                      goto _L;
                    }
                  } else {
                    _L: /* CIL Label */ 
#line 883
                    ch___1 = (uint8_t )14;
#line 884
                    if (argc == 3) {
                      {
#line 885
                      tmp___4 = str2uchar((char const   *)*(argv + 2), & ch___1);
                      }
#line 885
                      if (tmp___4 != 0) {
                        {
#line 886
                        lprintf(3, "Numeric value expected, but \'%s\' given.", *(argv + 2));
                        }
#line 887
                        return (-1);
                      }
                    }
                    {
#line 890
                    retval = ipmi_get_channel_cipher_suites(intf, (char const   *)*(argv + 1),
                                                            ch___1);
                    }
                  }
                }
              } else {
                {
#line 897
                printf((char const   */* __restrict  */)"Invalid CHANNEL command: %s\n",
                       *(argv + 0));
#line 898
                printf_channel_usage();
#line 899
                retval = -1;
                }
              }
            }
          }
        }
      }
    }
  }
#line 902
  return (retval);
}
}
#line 376 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 870 "../include/ipmitool/ipmi_sdr.h"
extern int ipmi_sdr_print_sdr(struct ipmi_intf *intf , uint8_t type ) ;
#line 46 "../include/ipmitool/ipmi_gendev.h"
int ipmi_gendev_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 39 "../include/ipmitool/ipmi_raw.h"
extern struct ipmi_rs *ipmi_master_write_read(struct ipmi_intf *intf , uint8_t bus ,
                                              uint8_t addr , uint8_t *wdata , uint8_t wsize ,
                                              uint8_t rsize ) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_gendev.c"
static int ipmi_gendev_get_eeprom_size(struct ipmi_intf *intf , struct sdr_record_generic_locator *dev ,
                                       t_gendev_eeprom_info *info ) 
{ 
  int eeprom_size ;

  {
#line 79
  eeprom_size = 0;
#line 91
  if ((unsigned long )info != (unsigned long )((void *)0)) {
    {
#line 95
    if ((int )dev->dev_type == 8) {
#line 95
      goto case_8;
    }
#line 101
    if ((int )dev->dev_type == 9) {
#line 101
      goto case_9;
    }
#line 107
    if ((int )dev->dev_type == 10) {
#line 107
      goto case_10;
    }
#line 113
    if ((int )dev->dev_type == 11) {
#line 113
      goto case_11;
    }
#line 119
    if ((int )dev->dev_type == 12) {
#line 119
      goto case_12;
    }
#line 125
    if ((int )dev->dev_type == 13) {
#line 125
      goto case_13;
    }
#line 131
    if ((int )dev->dev_type == 14) {
#line 131
      goto case_14;
    }
#line 137
    if ((int )dev->dev_type == 15) {
#line 137
      goto case_15;
    }
#line 143
    if ((int )dev->dev_type == 192) {
#line 143
      goto case_192;
    }
#line 149
    if ((int )dev->dev_type == 193) {
#line 149
      goto case_193;
    }
#line 155
    if ((int )dev->dev_type == 194) {
#line 155
      goto case_194;
    }
#line 161
    if ((int )dev->dev_type == 195) {
#line 161
      goto case_195;
    }
#line 168
    goto switch_default;
    case_8: /* CIL Label */ 
#line 96
    info->size = (uint32_t )128;
#line 97
    info->page_size = (uint16_t )8;
#line 98
    info->address_span = dev->addr_span;
#line 99
    info->address_length = (uint8_t )1;
#line 100
    goto switch_break;
    case_9: /* CIL Label */ 
#line 102
    info->size = (uint32_t )256;
#line 103
    info->page_size = (uint16_t )8;
#line 104
    info->address_span = dev->addr_span;
#line 105
    info->address_length = (uint8_t )1;
#line 106
    goto switch_break;
    case_10: /* CIL Label */ 
#line 108
    info->size = (uint32_t )512;
#line 109
    info->page_size = (uint16_t )8;
#line 110
    info->address_span = dev->addr_span;
#line 111
    info->address_length = (uint8_t )2;
#line 112
    goto switch_break;
    case_11: /* CIL Label */ 
#line 114
    info->size = (uint32_t )1024;
#line 115
    info->page_size = (uint16_t )8;
#line 116
    info->address_span = dev->addr_span;
#line 117
    info->address_length = (uint8_t )2;
#line 118
    goto switch_break;
    case_12: /* CIL Label */ 
#line 120
    info->size = (uint32_t )2048;
#line 121
    info->page_size = (uint16_t )256;
#line 122
    info->address_span = dev->addr_span;
#line 123
    info->address_length = (uint8_t )2;
#line 124
    goto switch_break;
    case_13: /* CIL Label */ 
#line 126
    info->size = (uint32_t )2048;
#line 127
    info->page_size = (uint16_t )256;
#line 128
    info->address_span = dev->addr_span;
#line 129
    info->address_length = (uint8_t )2;
#line 130
    goto switch_break;
    case_14: /* CIL Label */ 
#line 132
    info->size = (uint32_t )4096;
#line 133
    info->page_size = (uint16_t )8;
#line 134
    info->address_span = dev->addr_span;
#line 135
    info->address_length = (uint8_t )2;
#line 136
    goto switch_break;
    case_15: /* CIL Label */ 
#line 138
    info->size = (uint32_t )8192;
#line 139
    info->page_size = (uint16_t )32;
#line 140
    info->address_span = dev->addr_span;
#line 141
    info->address_length = (uint8_t )2;
#line 142
    goto switch_break;
    case_192: /* CIL Label */ 
#line 144
    info->size = (uint32_t )16384;
#line 145
    info->page_size = (uint16_t )64;
#line 146
    info->address_span = dev->addr_span;
#line 147
    info->address_length = (uint8_t )2;
#line 148
    goto switch_break;
    case_193: /* CIL Label */ 
#line 150
    info->size = (uint32_t )32748;
#line 151
    info->page_size = (uint16_t )64;
#line 152
    info->address_span = dev->addr_span;
#line 153
    info->address_length = (uint8_t )2;
#line 154
    goto switch_break;
    case_194: /* CIL Label */ 
#line 156
    info->size = (uint32_t )65536;
#line 157
    info->page_size = (uint16_t )128;
#line 158
    info->address_span = dev->addr_span;
#line 159
    info->address_length = (uint8_t )2;
#line 160
    goto switch_break;
    case_195: /* CIL Label */ 
#line 162
    info->size = (uint32_t )131072;
#line 163
    info->page_size = (uint16_t )128;
#line 164
    info->address_span = dev->addr_span;
#line 165
    info->address_length = (uint8_t )2;
#line 166
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 169
    info->size = (uint32_t )0;
#line 170
    info->page_size = (uint16_t )0;
#line 171
    info->address_span = (uint8_t )0;
#line 172
    info->address_length = (uint8_t )0;
#line 173
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 176
    eeprom_size = (int )info->size;
  }
#line 179
  return (eeprom_size);
}
}
#line 304
static int ipmi_gendev_read_file(struct ipmi_intf *intf , struct sdr_record_generic_locator *dev ,
                                 char const   *ofile ) ;
#line 304 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_gendev.c"
static uint8_t previousCompleted  =    (uint8_t )101;
#line 184 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_gendev.c"
static int ipmi_gendev_read_file(struct ipmi_intf *intf , struct sdr_record_generic_locator *dev ,
                                 char const   *ofile ) 
{ 
  int rc ;
  int eeprom_size ;
  t_gendev_eeprom_info eeprom_info ;
  FILE *fp ;
  struct ipmi_rs *rsp ;
  int numWrite ;
  uint32_t counter ;
  uint8_t msize ;
  uint8_t channel ;
  uint8_t i2cbus ;
  uint8_t i2caddr ;
  uint8_t privatebus ;
  uint32_t address_span_size ;
  uint8_t percentCompleted ;
  uint8_t retryCounter ;
  uint8_t wrByte[18] ;
  size_t tmp ;

  {
  {
#line 191
  rc = 0;
#line 195
  eeprom_size = ipmi_gendev_get_eeprom_size(intf, dev, & eeprom_info);
  }
#line 197
  if (eeprom_size > 0) {
    {
#line 202
    fp = ipmi_open_file(ofile, 1);
    }
#line 204
    if (fp) {
#line 210
      channel = dev->channel_num;
#line 211
      i2cbus = dev->bus;
#line 212
      i2caddr = dev->dev_slave_addr;
#line 213
      privatebus = (uint8_t )1;
#line 215
      percentCompleted = (uint8_t )0;
#line 219
      if ((int )eeprom_info.address_span != 0) {
#line 221
        address_span_size = eeprom_info.size / (uint32_t )((int )eeprom_info.address_span + 1);
      } else {
#line 226
        address_span_size = eeprom_info.size;
      }
#line 230
      if ((int )eeprom_info.page_size < 16) {
#line 232
        msize = (uint8_t )eeprom_info.page_size;
      } else {
#line 236
        msize = (uint8_t )16;
      }
#line 242
      i2cbus = (uint8_t )(((((int )channel & 15) << 4) | (((int )i2cbus & 7) << 1)) | (int )privatebus);
#line 250
      counter = (uint32_t )0;
      {
#line 250
      while (1) {
        while_continue: /* CIL Label */ ;
#line 250
        if (counter < eeprom_info.size) {
#line 250
          if (! (rc == 0)) {
#line 250
            goto while_break;
          }
        } else {
#line 250
          goto while_break;
        }
#line 258
        retryCounter = (uint8_t )0;
        {
#line 258
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 258
          if (! ((int )retryCounter < 5)) {
#line 258
            goto while_break___0;
          }
#line 266
          wrByte[0] = (uint8_t )counter;
#line 267
          if ((int )eeprom_info.address_length > 1) {
#line 269
            wrByte[1] = (uint8_t )(counter >> 8);
          }
          {
#line 272
          i2caddr = (uint8_t )((unsigned int )i2caddr + (eeprom_info.size % address_span_size) * 2U);
#line 274
          rsp = ipmi_master_write_read(intf, i2cbus, i2caddr, wrByte, eeprom_info.address_length,
                                       msize);
          }
#line 283
          if ((unsigned long )rsp != (unsigned long )((void *)0)) {
#line 285
            retryCounter = (uint8_t )5;
#line 286
            rc = 0;
          } else
#line 288
          if ((int )retryCounter < 5) {
            {
#line 290
            retryCounter = (uint8_t )((int )retryCounter + 1);
#line 291
            lprintf(3, "Retry");
#line 292
            sleep(1U);
#line 293
            rc = -1;
            }
          } else {
            {
#line 297
            lprintf(3, "Unable to perform I2C Master Write-Read");
#line 298
            rc = -1;
            }
          }
#line 258
          retryCounter = (uint8_t )((int )retryCounter + 1);
        }
        while_break___0: /* CIL Label */ ;
        }
#line 302
        if (rc == 0) {
          {
#line 305
          tmp = fwrite((void const   */* __restrict  */)(rsp->data), (size_t )1, (size_t )msize,
                       (FILE */* __restrict  */)fp);
#line 305
          numWrite = (int )tmp;
          }
#line 306
          if (numWrite != (int )msize) {
            {
#line 308
            lprintf(3, "Error writing file %s", ofile);
#line 309
            rc = -1;
            }
#line 310
            goto while_break;
          }
#line 313
          percentCompleted = (uint8_t )((counter * 100U) / eeprom_info.size);
#line 315
          if ((int )percentCompleted != (int )previousCompleted) {
            {
#line 317
            printf((char const   */* __restrict  */)"\r%i percent completed", (int )percentCompleted);
#line 318
            previousCompleted = percentCompleted;
            }
          }
        }
#line 250
        counter += (uint32_t )msize;
      }
      while_break: /* CIL Label */ ;
      }
#line 324
      if (counter == eeprom_info.size) {
        {
#line 326
        printf((char const   */* __restrict  */)"\r%%100 percent completed\n");
        }
      } else {
        {
#line 330
        printf((char const   */* __restrict  */)"\rError: %i percent completed, read not completed \n",
               (int )percentCompleted);
        }
      }
      {
#line 333
      fclose(fp);
      }
    }
  } else {
    {
#line 338
    lprintf(3, "The selected generic device is not an eeprom");
    }
  }
#line 341
  return (rc);
}
}
#line 500
static int ipmi_gendev_write_file(struct ipmi_intf *intf , struct sdr_record_generic_locator *dev ,
                                  char const   *ofile ) ;
#line 500 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_gendev.c"
static uint8_t previousCompleted___0  =    (uint8_t )101;
#line 356 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_gendev.c"
static int ipmi_gendev_write_file(struct ipmi_intf *intf , struct sdr_record_generic_locator *dev ,
                                  char const   *ofile ) 
{ 
  int rc ;
  int eeprom_size ;
  t_gendev_eeprom_info eeprom_info ;
  FILE *fp ;
  uint32_t fileLength ;
  long tmp ;
  struct ipmi_rs *rsp ;
  int numRead ;
  uint32_t counter ;
  uint8_t msize ;
  uint8_t channel ;
  uint8_t i2cbus ;
  uint8_t i2caddr ;
  uint8_t privatebus ;
  uint32_t address_span_size ;
  uint8_t percentCompleted ;
  uint8_t retryCounter ;
  uint8_t readByte[16] ;
  size_t tmp___0 ;
  uint8_t wrByte[18] ;

  {
  {
#line 363
  rc = 0;
#line 367
  eeprom_size = ipmi_gendev_get_eeprom_size(intf, dev, & eeprom_info);
  }
#line 369
  if (eeprom_size > 0) {
    {
#line 372
    fileLength = (uint32_t )0;
#line 375
    fp = ipmi_open_file(ofile, 0);
    }
#line 377
    if (fp) {
      {
#line 380
      fseek(fp, 0L, 2);
#line 381
      tmp = ftell(fp);
#line 381
      fileLength = (uint32_t )tmp;
#line 383
      lprintf(3, "File   Size: %i", fileLength);
#line 384
      lprintf(3, "Eeprom Size: %i", eeprom_size);
      }
#line 385
      if (fileLength != (uint32_t )eeprom_size) {
        {
#line 387
        lprintf(3, "File size does not fit Eeprom Size");
#line 388
        fclose(fp);
#line 389
        fp = (FILE *)((void *)0);
        }
      } else {
        {
#line 393
        fseek(fp, 0L, 0);
        }
      }
    }
#line 397
    if (fp) {
#line 403
      channel = dev->channel_num;
#line 404
      i2cbus = dev->bus;
#line 405
      i2caddr = dev->dev_slave_addr;
#line 406
      privatebus = (uint8_t )1;
#line 408
      percentCompleted = (uint8_t )0;
#line 412
      if ((int )eeprom_info.address_span != 0) {
#line 414
        address_span_size = eeprom_info.size / (uint32_t )((int )eeprom_info.address_span + 1);
      } else {
#line 419
        address_span_size = eeprom_info.size;
      }
#line 423
      if ((int )eeprom_info.page_size < 16) {
#line 425
        msize = (uint8_t )eeprom_info.page_size;
      } else {
#line 429
        msize = (uint8_t )16;
      }
#line 435
      i2cbus = (uint8_t )(((((int )channel & 15) << 4) | (((int )i2cbus & 7) << 1)) | (int )privatebus);
#line 443
      counter = (uint32_t )0;
      {
#line 443
      while (1) {
        while_continue: /* CIL Label */ ;
#line 443
        if (counter < eeprom_info.size) {
#line 443
          if (! (rc == 0)) {
#line 443
            goto while_break;
          }
        } else {
#line 443
          goto while_break;
        }
        {
#line 452
        tmp___0 = fread((void */* __restrict  */)(readByte), (size_t )1, (size_t )msize,
                        (FILE */* __restrict  */)fp);
#line 452
        numRead = (int )tmp___0;
        }
#line 453
        if (numRead != (int )msize) {
          {
#line 455
          lprintf(3, "Error reading file %s", ofile);
#line 456
          rc = -1;
          }
#line 457
          goto while_break;
        }
#line 462
        retryCounter = (uint8_t )0;
        {
#line 462
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 462
          if (! ((int )retryCounter < 5)) {
#line 462
            goto while_break___0;
          }
#line 469
          wrByte[0] = (uint8_t )counter;
#line 470
          if ((int )eeprom_info.address_length > 1) {
#line 472
            wrByte[1] = (uint8_t )(counter >> 8);
          }
          {
#line 474
          memcpy((void */* __restrict  */)(& wrByte[eeprom_info.address_length]),
                 (void const   */* __restrict  */)(readByte), (size_t )msize);
#line 476
          i2caddr = (uint8_t )((unsigned int )i2caddr + (eeprom_info.size % address_span_size) * 2U);
#line 478
          rsp = ipmi_master_write_read(intf, i2cbus, i2caddr, wrByte, (uint8_t )((int )eeprom_info.address_length + (int )msize),
                                       (uint8_t )0);
          }
#line 479
          if ((unsigned long )rsp != (unsigned long )((void *)0)) {
#line 481
            retryCounter = (uint8_t )5;
#line 482
            rc = 0;
          } else
#line 484
          if ((int )retryCounter < 5) {
            {
#line 486
            retryCounter = (uint8_t )((int )retryCounter + 1);
#line 487
            lprintf(3, "Retry");
#line 488
            sleep(1U);
#line 489
            rc = -1;
            }
          } else {
            {
#line 493
            lprintf(3, "Unable to perform I2C Master Write-Read");
#line 494
            rc = -1;
            }
          }
#line 462
          retryCounter = (uint8_t )((int )retryCounter + 1);
        }
        while_break___0: /* CIL Label */ ;
        }
#line 498
        if (rc == 0) {
#line 501
          percentCompleted = (uint8_t )((counter * 100U) / eeprom_info.size);
#line 503
          if ((int )percentCompleted != (int )previousCompleted___0) {
            {
#line 505
            printf((char const   */* __restrict  */)"\r%i percent completed", (int )percentCompleted);
#line 506
            previousCompleted___0 = percentCompleted;
            }
          }
        }
#line 443
        counter += (uint32_t )msize;
      }
      while_break: /* CIL Label */ ;
      }
#line 511
      if (counter == eeprom_info.size) {
        {
#line 513
        printf((char const   */* __restrict  */)"\r%%100 percent completed\n");
        }
      } else {
        {
#line 517
        printf((char const   */* __restrict  */)"\rError: %i percent completed, read not completed \n",
               (int )percentCompleted);
        }
      }
      {
#line 520
      fclose(fp);
      }
    }
  } else {
    {
#line 525
    lprintf(3, "The selected generic device is not an eeprom");
    }
  }
#line 528
  return (rc);
}
}
#line 541 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_gendev.c"
int ipmi_gendev_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int rc ;
  time_t tmp ;
  struct sdr_record_list *sdr ;
  struct sdr_record_list *sdr___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 544
  rc = 0;
#line 547
  tmp = time((time_t *)((void *)0));
#line 547
  srand((unsigned int )tmp);
#line 549
  lprintf(3, "Rx gendev command: %s", *(argv + 0));
  }
#line 551
  if (argc == 0) {
    {
#line 557
    lprintf(3, "SDR Commands:  list read write");
#line 559
    lprintf(3, "                     list                     List All Generic Device Locators");
#line 561
    lprintf(3, "                     read <sdr name> <file>   Read to file eeprom specify by Generic Device Locators");
#line 563
    lprintf(3, "                     write <sdr name> <file>  Write from file eeprom specify by Generic Device Locators");
    }
  } else {
    {
#line 551
    tmp___3 = strncmp((char const   *)*(argv + 0), "help", (size_t )4);
    }
#line 551
    if (tmp___3 == 0) {
      {
#line 557
      lprintf(3, "SDR Commands:  list read write");
#line 559
      lprintf(3, "                     list                     List All Generic Device Locators");
#line 561
      lprintf(3, "                     read <sdr name> <file>   Read to file eeprom specify by Generic Device Locators");
#line 563
      lprintf(3, "                     write <sdr name> <file>  Write from file eeprom specify by Generic Device Locators");
      }
    } else {
      {
#line 566
      tmp___2 = strncmp((char const   *)*(argv + 0), "list", (size_t )4);
      }
#line 566
      if (tmp___2 == 0) {
        {
#line 568
        rc = ipmi_sdr_print_sdr(intf, (uint8_t )16);
        }
      } else {
        {
#line 571
        tmp___1 = strncmp((char const   *)*(argv + 0), "read", (size_t )4);
        }
#line 571
        if (tmp___1 == 0) {
#line 573
          if (argc < 3) {
            {
#line 574
            lprintf(3, "usage: gendev read <gendev> <filename>");
            }
          } else {
            {
#line 579
            lprintf(3, "Gendev read sdr name : %s", *(argv + 1));
#line 581
            printf((char const   */* __restrict  */)"Locating sensor record \'%s\'...\n",
                   *(argv + 1));
#line 584
            sdr = ipmi_sdr_find_sdr_byid(intf, *(argv + 1));
            }
#line 585
            if ((unsigned long )sdr == (unsigned long )((void *)0)) {
              {
#line 587
              lprintf(3, "Sensor data record not found!");
              }
#line 588
              return (-1);
            }
#line 591
            if ((int )sdr->type != 16) {
              {
#line 593
              lprintf(3, "Target SDR is not a generic device locator");
              }
#line 594
              return (-1);
            }
            {
#line 597
            lprintf(3, "Gendev read file name: %s", *(argv + 2));
#line 598
            ipmi_gendev_read_file(intf, sdr->record.genloc, (char const   *)*(argv + 2));
            }
          }
        } else {
          {
#line 602
          tmp___0 = strncmp((char const   *)*(argv + 0), "write", (size_t )5);
          }
#line 602
          if (tmp___0 == 0) {
#line 604
            if (argc < 3) {
              {
#line 605
              lprintf(3, "usage: gendev write <gendev> <filename>");
              }
            } else {
              {
#line 610
              lprintf(3, "Gendev write sdr name : %s", *(argv + 1));
#line 612
              printf((char const   */* __restrict  */)"Locating sensor record \'%s\'...\n",
                     *(argv + 1));
#line 615
              sdr___0 = ipmi_sdr_find_sdr_byid(intf, *(argv + 1));
              }
#line 616
              if ((unsigned long )sdr___0 == (unsigned long )((void *)0)) {
                {
#line 618
                lprintf(3, "Sensor data record not found!");
                }
#line 619
                return (-1);
              }
#line 622
              if ((int )sdr___0->type != 16) {
                {
#line 624
                lprintf(3, "Target SDR is not a generic device locator");
                }
#line 625
                return (-1);
              }
              {
#line 628
              lprintf(3, "Gendev write file name: %s", *(argv + 2));
#line 629
              ipmi_gendev_write_file(intf, sdr___0->record.genloc, (char const   *)*(argv + 2));
              }
            }
          } else {
            {
#line 635
            lprintf(3, "Invalid gendev command: %s", *(argv + 0));
#line 636
            rc = -1;
            }
          }
        }
      }
    }
  }
#line 639
  return (rc);
}
}
#line 38 "../include/ipmitool/ipmi_main.h"
extern int ipmi_main(int argc , char **argv , struct ipmi_cmd *cmdlist , struct ipmi_intf_support *intflist ) ;
#line 46 "../include/ipmitool/ipmi_sdr.h"
extern int ipmi_sdr_main(struct ipmi_intf * , int  , char ** ) ;
#line 679 "../include/ipmitool/ipmi_sel.h"
extern int ipmi_sel_main(struct ipmi_intf * , int  , char ** ) ;
#line 102 "../include/ipmitool/ipmi_sol.h"
extern int ipmi_sol_main(struct ipmi_intf * , int  , char ** ) ;
#line 44 "../include/ipmitool/ipmi_tsol.h"
int ipmi_tsol_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 130 "../include/ipmitool/ipmi_lanp.h"
extern int ipmi_lanp_main(struct ipmi_intf * , int  , char ** ) ;
#line 49 "../include/ipmitool/ipmi_mc.h"
extern int ipmi_mc_main(struct ipmi_intf * , int  , char ** ) ;
#line 86 "../include/ipmitool/ipmi_sensor.h"
extern int ipmi_sensor_main(struct ipmi_intf * , int  , char ** ) ;
#line 129 "../include/ipmitool/ipmi_session.h"
extern int ipmi_session_main(struct ipmi_intf * , int  , char ** ) ;
#line 93 "../include/ipmitool/ipmi_user.h"
extern int ipmi_user_main(struct ipmi_intf * , int  , char ** ) ;
#line 38 "../include/ipmitool/ipmi_raw.h"
extern int ipmi_raw_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 41
extern int ipmi_rawi2c_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 42
extern int ipmi_rawspd_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 954 "../include/ipmitool/ipmi_pef.h"
extern int ipmi_pef_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 207 "../include/ipmitool/ipmi_picmg.h"
extern int ipmi_picmg_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 43 "../include/ipmitool/ipmi_kontronoem.h"
int ipmi_kontronoem_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 66 "../include/ipmitool/ipmi_ekanalyzer.h"
int ipmi_ekanalyzer_main(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 81 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmitool.c"
int csv_output  =    0;
#line 82 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmitool.c"
int verbose  =    0;
#line 84 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmitool.c"
struct ipmi_cmd ipmitool_cmd_list[35]  = 
#line 84
  {      {& ipmi_raw_main, "raw", "Send a RAW IPMI request and print response"}, 
        {& ipmi_rawi2c_main, "i2c", "Send an I2C Master Write-Read command and print response"}, 
        {& ipmi_rawspd_main,
      "spd", "Print SPD info from remote I2C device"}, 
        {& ipmi_lanp_main, "lan", "Configure LAN Channels"}, 
        {& ipmi_chassis_main, "chassis", "Get chassis status and set power state"}, 
        {& ipmi_power_main, "power", "Shortcut to chassis power commands"}, 
        {& ipmi_event_main, "event", "Send pre-defined events to MC"}, 
        {& ipmi_mc_main, "mc", "Management Controller status and global enables"}, 
        {& ipmi_mc_main, "bmc", (char const   *)((void *)0)}, 
        {& ipmi_sdr_main, "sdr", "Print Sensor Data Repository entries and readings"}, 
        {& ipmi_sensor_main,
      "sensor", "Print detailed sensor information"}, 
        {& ipmi_fru_main, "fru", "Print built-in FRU and scan SDR for FRU locators"}, 
        {& ipmi_gendev_main,
      "gendev", "Read/Write Device associated with Generic Device locators sdr"}, 
        {& ipmi_sel_main, "sel", "Print System Event Log (SEL)"}, 
        {& ipmi_pef_main, "pef", "Configure Platform Event Filtering (PEF)"}, 
        {& ipmi_sol_main, "sol", "Configure and connect IPMIv2.0 Serial-over-LAN"}, 
        {& ipmi_tsol_main, "tsol", "Configure and connect with Tyan IPMIv1.5 Serial-over-LAN"}, 
        {& ipmi_isol_main,
      "isol", "Configure IPMIv1.5 Serial-over-LAN"}, 
        {& ipmi_user_main, "user", "Configure Management Controller users"}, 
        {& ipmi_channel_main, "channel", "Configure Management Controller channels"}, 
        {& ipmi_session_main,
      "session", "Print session information"}, 
        {& ipmi_dcmi_main, "dcmi", "Data Center Management Interface"}, 
        {& ipmi_sunoem_main, "sunoem", "OEM Commands for Sun servers"}, 
        {& ipmi_kontronoem_main, "kontronoem", "OEM Commands for Kontron devices"}, 
        {& ipmi_picmg_main, "picmg", "Run a PICMG/ATCA extended cmd"}, 
        {& ipmi_fwum_main, "fwum", "Update IPMC using Kontron OEM Firmware Update Manager"}, 
        {& ipmi_firewall_main,
      "firewall", "Configure Firmware Firewall"}, 
        {& ipmi_delloem_main, "delloem", "OEM Commands for Dell systems"}, 
        {& ipmi_exec_main, "exec", "Run list of commands from file"}, 
        {& ipmi_set_main, "set", "Set runtime variable for shell and exec"}, 
        {& ipmi_echo_main, "echo", (char const   *)((void *)0)}, 
        {& ipmi_hpmfwupg_main, "hpm", "Update HPM components using PICMG HPM.1 file"}, 
        {& ipmi_ekanalyzer_main,
      "ekanalyzer", "run FRU-Ekeying analyzer using FRU files"}, 
        {& ipmi_ime_main, "ime", "Update Intel Manageability Engine Firmware"}, 
        {(int (*)(struct ipmi_intf *intf , int argc , char **argv ))((void *)0), (char const   *)0,
      (char const   *)0}};
#line 125 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmitool.c"
int main(int argc , char **argv ) 
{ 
  int rc ;

  {
  {
#line 130
  rc = ipmi_main(argc, argv, ipmitool_cmd_list, (struct ipmi_intf_support *)((void *)0));
  }
#line 132
  if (rc < 0) {
    {
#line 133
    exit(1);
    }
  } else {
    {
#line 135
    exit(0);
    }
  }
}
}
#line 830 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 587 "../include/ipmitool/ipmi_fru.h"
static unsigned long const   secs_from_1970_1996___0  =    (uint64_t const   )820454400;
#line 51 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
int const   ERROR_STATUS  =    (int const   )-1;
#line 52 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
int const   OK_STATUS  =    (int const   )0;
#line 54 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
char const   *STAR_LINE_LIMITER  =    "*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*";
#line 56 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
char const   *EQUAL_LINE_LIMITER  =    "=================================================================";
#line 58 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
int const   SIZE_OF_FILE_TYPE  =    (int const   )3;
#line 59 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
unsigned char const   AMC_MODULE  =    (unsigned char const   )128;
#line 60 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
int const   PICMG_ID_OFFSET  =    (int const   )3;
#line 61 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
unsigned int const   COMPARE_CANDIDATE  =    (unsigned int const   )2;
#line 66 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
int const   START_DATA_OFFSET  =    (int const   )5;
#line 67 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
int const   LOWER_OEM_TYPE  =    (int const   )240;
#line 68 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
int const   UPPER_OEM_TYPE  =    (int const   )254;
#line 69 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
unsigned char const   DISABLE_PORT  =    (unsigned char const   )31;
#line 71 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
struct valstr  const  ipmi_ekanalyzer_module_type[13]  = 
#line 71
  {      {(uint16_t )9, "On-Carrier Device"}, 
        {(uint16_t )1, "AMC slot A1"}, 
        {(uint16_t )2, "AMC slot A2"}, 
        {(uint16_t )3, "AMC slot A3"}, 
        {(uint16_t )4, "AMC slot A4"}, 
        {(uint16_t )5, "AMC slot B1"}, 
        {(uint16_t )6, "AMC slot B2"}, 
        {(uint16_t )7, "AMC slot B3"}, 
        {(uint16_t )8, "AMC slot B4"}, 
        {(uint16_t )0, "RTM"}, 
        {(uint16_t )10, "Configuration file"}, 
        {(uint16_t )11, "Shelf Manager"}, 
        {(uint16_t )65535, (char const   *)((void *)0)}};
#line 87 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
struct valstr  const  ipmi_ekanalyzer_IPMBL_addr[10]  = 
#line 87
  {      {(uint16_t )114, "AMC slot A1"}, 
        {(uint16_t )116, "AMC slot A2"}, 
        {(uint16_t )118, "AMC slot A3"}, 
        {(uint16_t )120, "AMC slot A4"}, 
        {(uint16_t )122, "AMC slot B1"}, 
        {(uint16_t )124, "AMC slot B2"}, 
        {(uint16_t )126, "AMC slot B3"}, 
        {(uint16_t )128, "AMC slot B4"}, 
        {(uint16_t )144, "RTM"}, 
        {(uint16_t )65535, (char const   *)((void *)0)}};
#line 100 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
struct valstr  const  ipmi_ekanalyzer_link_type[24]  = 
#line 100
  {      {(uint16_t )0, "Reserved"}, 
        {(uint16_t )1, "Reserved"}, 
        {(uint16_t )2, "AMC.1 PCI Express"}, 
        {(uint16_t )3, "AMC.1 PCI Express Advanced Switching"}, 
        {(uint16_t )4, "AMC.1 PCI Express Advanced Switching"}, 
        {(uint16_t )5, "AMC.2 Ethernet"}, 
        {(uint16_t )6, "AMC.4 Serial RapidIO"}, 
        {(uint16_t )7, "AMC.3 Storage"}, 
        {(uint16_t )240, "OEM Type 0"}, 
        {(uint16_t )241, "OEM Type 1"}, 
        {(uint16_t )242, "OEM Type 2"}, 
        {(uint16_t )243, "OEM Type 3"}, 
        {(uint16_t )244, "OEM Type 4"}, 
        {(uint16_t )245, "OEM Type 5"}, 
        {(uint16_t )246, "OEM Type 6"}, 
        {(uint16_t )247, "OEM Type 7"}, 
        {(uint16_t )248, "OEM Type 8"}, 
        {(uint16_t )249, "OEM Type 9"}, 
        {(uint16_t )250, "OEM Type 10"}, 
        {(uint16_t )251, "OEM Type 11"}, 
        {(uint16_t )252, "OEM Type 12"}, 
        {(uint16_t )253, "OEM Type 13"}, 
        {(uint16_t )254, "OEM Type 14"}, 
        {(uint16_t )255, "Reserved"}};
#line 129 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
struct valstr  const  ipmi_ekanalyzer_extension_PCIE[5]  = {      {(uint16_t )0, "Gen 1 capable - non SSC"}, 
        {(uint16_t )1, "Gen 1 capable - SSC"}, 
        {(uint16_t )2, "Gen 2 capable - non SSC"}, 
        {(uint16_t )3, "Gen 3 capable - SSC"}, 
        {(uint16_t )15, "Reserved"}};
#line 137 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
struct valstr  const  ipmi_ekanalyzer_extension_ETHERNET[2]  = {      {(uint16_t )0, "1000BASE-BX (SerDES Gigabit) Ethernet link"}, 
        {(uint16_t )1, "10GBASE-BX4 10 Gigabit Ethernet link"}};
#line 142 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
struct valstr  const  ipmi_ekanalyzer_extension_STORAGE[3]  = {      {(uint16_t )0, "Fibre Channel  (FC)"}, 
        {(uint16_t )1, "Serial ATA (SATA)"}, 
        {(uint16_t )2, "Serial Attached SCSI (SAS/SATA)"}};
#line 148 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
struct valstr  const  ipmi_ekanalyzer_asym_PCIE[3]  = {      {(uint16_t )0, "exact match"}, 
        {(uint16_t )1, "provides a Primary PCI Express Port"}, 
        {(uint16_t )2, "provides a Secondary PCI Express Port"}};
#line 154 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
struct valstr  const  ipmi_ekanalyzer_asym_STORAGE[4]  = {      {(uint16_t )0, "FC or SAS interface {exact match}"}, 
        {(uint16_t )1, "SATA Server interface"}, 
        {(uint16_t )2, "SATA Client interface"}, 
        {(uint16_t )3, "Reserved"}};
#line 161 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
struct valstr  const  ipmi_ekanalyzer_picmg_record_id[15]  = 
#line 161
  {      {(uint16_t )4, "Backplane Point to Point Connectivity Record"}, 
        {(uint16_t )16, "Address Table Record"}, 
        {(uint16_t )17, "Shelf Power Distribution Record"}, 
        {(uint16_t )18, "Shelf Activation and Power Management Record"}, 
        {(uint16_t )19, "Shelf Manager IP Connection Record"}, 
        {(uint16_t )20, "Board Point to Point Connectivity Record"}, 
        {(uint16_t )21, "Radial IPMB-0 Link Mapping Record"}, 
        {(uint16_t )22, "Module Current Requirements Record"}, 
        {(uint16_t )23, "Carrier Activation and Power Management Record"}, 
        {(uint16_t )24, "Carrier Point-to-Point Connectivity Record"}, 
        {(uint16_t )25, "AdvancedMC Point-to-Point Connectivity Record"}, 
        {(uint16_t )26, "Carrier Information Table"}, 
        {(uint16_t )27, "Shelf Fan Geography Record"}, 
        {(uint16_t )44, "Carrier Clock Point-to-Point Connectivity Record"}, 
        {(uint16_t )45, "Clock Configuration Record"}};
#line 205
static int ipmi_ekanalyzer_print(int argc , char *opt , char **filename , int *file_type ) ;
#line 208
static int ipmi_ekanalyzer_ekeying_match(int argc , char *opt , char **filename ,
                                         int *file_type ) ;
#line 214
static void ipmi_ek_add_record2list(struct ipmi_ek_multi_header **record , struct ipmi_ek_multi_header **list_head ,
                                    struct ipmi_ek_multi_header **list_last ) ;
#line 218
static void ipmi_ek_display_record(struct ipmi_ek_multi_header *record , struct ipmi_ek_multi_header *list_head ,
                                   struct ipmi_ek_multi_header *list_last ) ;
#line 222
static void ipmi_ek_remove_record_from_list(struct ipmi_ek_multi_header *record ,
                                            struct ipmi_ek_multi_header **list_head ,
                                            struct ipmi_ek_multi_header **list_last ) ;
#line 227
static int ipmi_ekanalyzer_fru_file2structure(char *filename , struct ipmi_ek_multi_header **list_head ,
                                              struct ipmi_ek_multi_header **list_record ,
                                              struct ipmi_ek_multi_header **list_last ) ;
#line 235
static int ipmi_ek_matching_process(int *file_type , int index1 , int index2 , struct ipmi_ek_multi_header **list_head ,
                                    struct ipmi_ek_multi_header **list_last , char *opt ,
                                    struct ipmi_ek_multi_header *pphysical ) ;
#line 240
static int ipmi_ek_get_resource_descriptor(int port_count , int index___0 , struct fru_picmgext_carrier_p2p_descriptor *port_desc ,
                                           struct ipmi_ek_multi_header *record ) ;
#line 244
static int ipmi_ek_create_amc_p2p_record(struct ipmi_ek_multi_header *record , struct ipmi_ek_amc_p2p_connectivity_record *amc_record ) ;
#line 247
static int ipmi_ek_compare_link(struct ipmi_ek_multi_header *physic_record , struct ipmi_ek_amc_p2p_connectivity_record record1 ,
                                struct ipmi_ek_amc_p2p_connectivity_record record2 ,
                                char *opt , int file_type1 , int file_type2 ) ;
#line 252
static int ipmi_ek_compare_channel_descriptor(struct fru_picmgext_amc_channel_desc_record ch_desc1 ,
                                              struct fru_picmgext_amc_channel_desc_record ch_desc2 ,
                                              struct fru_picmgext_carrier_p2p_descriptor *port_desc ,
                                              int index_port , unsigned char rsc_id ) ;
#line 258
static int ipmi_ek_compare_link_descriptor(struct ipmi_ek_amc_p2p_connectivity_record record1 ,
                                           int index1 , struct ipmi_ek_amc_p2p_connectivity_record record2 ,
                                           int index2 ) ;
#line 262
static int ipmi_ek_compare_asym(unsigned char *asym ) ;
#line 264
static int ipmi_ek_compare_number_of_enable_port(struct fru_picmgext_amc_link_desc_record *link_desc ) ;
#line 267
static int ipmi_ek_check_physical_connectivity(struct ipmi_ek_amc_p2p_connectivity_record record1 ,
                                               int index1 , struct ipmi_ek_amc_p2p_connectivity_record record2 ,
                                               int index2 , struct ipmi_ek_multi_header *record ,
                                               int filetype1 , int filetype2 , char *option ) ;
#line 276
static int ipmi_ek_display_fru_header(char *filename ) ;
#line 278
static int ipmi_ek_display_fru_header_detail(char *filename ) ;
#line 280
static int ipmi_ek_display_chassis_info_area(FILE *input_file , long offset ) ;
#line 282
static size_t ipmi_ek_display_board_info_area(FILE *input_file , char *board_type ,
                                              unsigned int *board_length ) ;
#line 285
static int ipmi_ek_display_product_info_area(FILE *input_file , long offset ) ;
#line 287
static int ipmi_ek_display_link_descriptor(int file_type , unsigned char rsc_id ,
                                           char *str___1 , struct fru_picmgext_amc_link_desc_record link_desc ) ;
#line 291
static void ipmi_ek_display_oem_guid(struct ipmi_ek_amc_p2p_connectivity_record amc_record ) ;
#line 294
static int ipmi_ek_display_carrier_connectivity(struct ipmi_ek_multi_header *record ) ;
#line 297
static int ipmi_ek_display_power(int argc , char *opt , char **filename , int *file_type ) ;
#line 300
static void ipmi_ek_display_current_descriptor(struct fru_picmgext_carrier_activation_record car ,
                                               struct fru_picmgext_activation_record *cur_desc ,
                                               char *filename ) ;
#line 304
static void ipmi_ek_display_backplane_p2p_record(struct ipmi_ek_multi_header *record ) ;
#line 307
static void ipmi_ek_display_address_table_record(struct ipmi_ek_multi_header *record ) ;
#line 310
static void ipmi_ek_display_shelf_power_distribution_record(struct ipmi_ek_multi_header *record ) ;
#line 313
static void ipmi_ek_display_shelf_activation_record(struct ipmi_ek_multi_header *record ) ;
#line 316
static void ipmi_ek_display_shelf_ip_connection_record(struct ipmi_ek_multi_header *record ) ;
#line 322
static void ipmi_ek_display_board_p2p_record(struct ipmi_ek_multi_header *record ) ;
#line 325
static void ipmi_ek_display_radial_ipmb0_record(struct ipmi_ek_multi_header *record ) ;
#line 328
static void ipmi_ek_display_amc_current_record(struct ipmi_ek_multi_header *record ) ;
#line 331
static void ipmi_ek_display_amc_activation_record(struct ipmi_ek_multi_header *record ) ;
#line 334
static void ipmi_ek_display_amc_p2p_record(struct ipmi_ek_multi_header *record ) ;
#line 337
static void ipmi_ek_display_amc_carrier_info_record(struct ipmi_ek_multi_header *record ) ;
#line 340
static void ipmi_ek_display_clock_carrier_p2p_record(struct ipmi_ek_multi_header *record ) ;
#line 343
static void ipmi_ek_display_clock_config_record(struct ipmi_ek_multi_header *record ) ;
#line 363 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ekanalyzer_usage(void) 
{ 


  {
  {
#line 366
  lprintf(5, "Ekeying analyzer tool version 1.00");
#line 367
  lprintf(5, "ekanalyzer Commands:");
#line 368
  lprintf(5, "      print    [carrier | power | all] <oc=filename1> <b1=filename2>...");
#line 370
  lprintf(5, "      frushow  <b2=filename>");
#line 372
  lprintf(5, "      summary  [match | unmatch | all] <oc=filename1> <b1=filename2>...");
  }
#line 374
  return;
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_get_file_type(char *argument ) 
{ 
  int index_name ;
  int filetype ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;

  {
  {
#line 400
  index_name = 0;
#line 401
  filetype = (int )ERROR_STATUS;
#line 403
  tmp___11 = strlen((char const   *)argument);
  }
#line 403
  if (tmp___11 > 2UL) {
    {
#line 404
    tmp___10 = strncmp((char const   *)argument, "oc=", (size_t )SIZE_OF_FILE_TYPE);
    }
#line 404
    if (tmp___10 == 0) {
#line 405
      filetype = 9;
    } else {
      {
#line 407
      tmp___9 = strncmp((char const   *)argument, "a1=", (size_t )SIZE_OF_FILE_TYPE);
      }
#line 407
      if (tmp___9 == 0) {
#line 408
        filetype = 1;
      } else {
        {
#line 410
        tmp___8 = strncmp((char const   *)argument, "a2=", (size_t )SIZE_OF_FILE_TYPE);
        }
#line 410
        if (tmp___8 == 0) {
#line 411
          filetype = 2;
        } else {
          {
#line 413
          tmp___7 = strncmp((char const   *)argument, "a3=", (size_t )SIZE_OF_FILE_TYPE);
          }
#line 413
          if (tmp___7 == 0) {
#line 414
            filetype = 3;
          } else {
            {
#line 416
            tmp___6 = strncmp((char const   *)argument, "a4=", (size_t )SIZE_OF_FILE_TYPE);
            }
#line 416
            if (tmp___6 == 0) {
#line 417
              filetype = 4;
            } else {
              {
#line 419
              tmp___5 = strncmp((char const   *)argument, "b1=", (size_t )SIZE_OF_FILE_TYPE);
              }
#line 419
              if (tmp___5 == 0) {
#line 420
                filetype = 5;
              } else {
                {
#line 422
                tmp___4 = strncmp((char const   *)argument, "b2=", (size_t )SIZE_OF_FILE_TYPE);
                }
#line 422
                if (tmp___4 == 0) {
#line 423
                  filetype = 6;
                } else {
                  {
#line 425
                  tmp___3 = strncmp((char const   *)argument, "b3=", (size_t )SIZE_OF_FILE_TYPE);
                  }
#line 425
                  if (tmp___3 == 0) {
#line 426
                    filetype = 7;
                  } else {
                    {
#line 428
                    tmp___2 = strncmp((char const   *)argument, "b4=", (size_t )SIZE_OF_FILE_TYPE);
                    }
#line 428
                    if (tmp___2 == 0) {
#line 429
                      filetype = 8;
                    } else {
                      {
#line 431
                      tmp___1 = strncmp((char const   *)argument, "rt=", (size_t )SIZE_OF_FILE_TYPE);
                      }
#line 431
                      if (tmp___1 == 0) {
#line 432
                        filetype = 0;
                      } else {
                        {
#line 434
                        tmp___0 = strncmp((char const   *)argument, "rc=", (size_t )SIZE_OF_FILE_TYPE);
                        }
#line 434
                        if (tmp___0 == 0) {
#line 435
                          filetype = 10;
                        } else {
                          {
#line 437
                          tmp = strncmp((char const   *)argument, "sm=", (size_t )SIZE_OF_FILE_TYPE);
                          }
#line 437
                          if (tmp == 0) {
#line 438
                            filetype = 11;
                          } else {
#line 441
                            filetype = (int )ERROR_STATUS;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 444
  return (filetype);
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
int ipmi_ekanalyzer_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int rc ;
  int file_type[8] ;
  int tmp_ret ;
  char *filename[8] ;
  unsigned int argument_offset ;
  unsigned int type_offset ;
  struct ipmi_ek_multi_header *list_head ;
  struct ipmi_ek_multi_header *list_record ;
  struct ipmi_ek_multi_header *list_last ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *option ;
  int index___0 ;
  int filename_size ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int i ;
  size_t tmp___9 ;
  void *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 470
  rc = (int )ERROR_STATUS;
#line 472
  tmp_ret = 0;
#line 474
  argument_offset = 0U;
#line 475
  type_offset = 0U;
#line 477
  list_head = (struct ipmi_ek_multi_header *)((void *)0);
#line 478
  list_record = (struct ipmi_ek_multi_header *)((void *)0);
#line 479
  list_last = (struct ipmi_ek_multi_header *)((void *)0);
#line 481
  if (argc == 0) {
    {
#line 482
    lprintf(3, "Too few or too many arguments!");
#line 483
    ipmi_ekanalyzer_usage();
#line 484
    rc = (int )ERROR_STATUS;
    }
  } else
#line 481
  if (argc - 1 > 8) {
    {
#line 482
    lprintf(3, "Too few or too many arguments!");
#line 483
    ipmi_ekanalyzer_usage();
#line 484
    rc = (int )ERROR_STATUS;
    }
  } else {
    {
#line 486
    tmp___17 = strcmp((char const   *)*(argv + argument_offset), "help");
    }
#line 486
    if (tmp___17 == 0) {
      {
#line 487
      ipmi_ekanalyzer_usage();
#line 488
      rc = 0;
      }
    } else {
      {
#line 490
      tmp___16 = strcmp((char const   *)*(argv + argument_offset), "frushow");
      }
#line 490
      if (tmp___16 == 0) {
#line 490
        if (argc > 1) {
#line 493
          type_offset = 0U;
          {
#line 493
          while (1) {
            while_continue: /* CIL Label */ ;
#line 493
            if (! (type_offset < (unsigned int )(argc - 1))) {
#line 493
              goto while_break;
            }
            {
#line 494
            argument_offset ++;
#line 495
            file_type[type_offset] = ipmi_ek_get_file_type(*(argv + argument_offset));
            }
#line 496
            if (file_type[type_offset] != (int )ERROR_STATUS) {
#line 497
              if (file_type[type_offset] != 10) {
                {
#line 501
                tmp = strlen((char const   *)*(argv + argument_offset));
#line 501
                tmp___0 = malloc((tmp + 1UL) - (size_t )SIZE_OF_FILE_TYPE);
#line 501
                filename[type_offset] = (char *)tmp___0;
                }
#line 504
                if ((unsigned long )filename[type_offset] != (unsigned long )((void *)0)) {
                  {
#line 505
                  strcpy((char */* __restrict  */)filename[type_offset], (char const   */* __restrict  */)(*(argv + argument_offset) + SIZE_OF_FILE_TYPE));
#line 507
                  printf((char const   */* __restrict  */)"Start converting file \'%s\'...\n",
                         filename[type_offset]);
#line 509
                  rc = ipmi_ek_display_fru_header(filename[type_offset]);
                  }
#line 511
                  if (rc != (int )ERROR_STATUS) {
                    {
#line 513
                    tmp_ret = ipmi_ek_display_fru_header_detail(filename[type_offset]);
#line 515
                    rc = ipmi_ekanalyzer_fru_file2structure(filename[type_offset],
                                                            & list_head, & list_record,
                                                            & list_last);
#line 518
                    ipmi_ek_display_record(list_record, list_head, list_last);
                    }
                    {
#line 520
                    while (1) {
                      while_continue___0: /* CIL Label */ ;
#line 520
                      if (! ((unsigned long )list_head != (unsigned long )((void *)0))) {
#line 520
                        goto while_break___0;
                      }
                      {
#line 521
                      ipmi_ek_remove_record_from_list(list_head, & list_head, & list_last);
                      }
#line 523
                      if (verbose > 1) {
                        {
#line 524
                        printf((char const   */* __restrict  */)"record has been removed!\n");
                        }
                      }
                    }
                    while_break___0: /* CIL Label */ ;
                    }
                  }
                  {
#line 527
                  free((void *)filename[type_offset]);
#line 528
                  filename[type_offset] = (char *)((void *)0);
                  }
                }
              }
            } else {
              {
#line 533
              lprintf(3, "Invalid file type!");
#line 534
              lprintf(3, "   ekanalyzer frushow <xx=frufile> ...");
              }
            }
#line 493
            type_offset ++;
          }
          while_break: /* CIL Label */ ;
          }
        } else {
#line 490
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 538
        tmp___14 = strcmp((char const   *)*(argv + argument_offset), "print");
        }
#line 538
        if (tmp___14 == 0) {
#line 538
          goto _L;
        } else {
          {
#line 538
          tmp___15 = strcmp((char const   *)*(argv + argument_offset), "summary");
          }
#line 538
          if (tmp___15 == 0) {
            _L: /* CIL Label */ 
#line 544
            if (argc < 2) {
              {
#line 545
              lprintf(3, "Not enough parameters given.");
#line 546
              tmp___1 = strcmp((char const   *)*(argv + argument_offset), "print");
              }
#line 546
              if (tmp___1 == 0) {
                {
#line 547
                lprintf(3, "   ekanalyzer print [carrier/power/all] <xx=frufile> <xx=frufile> [xx=frufile]");
                }
              } else {
                {
#line 552
                lprintf(3, "   ekanalyzer summary [match/ unmatch/ all] <xx=frufile> <xx=frufile> [xx=frufile]");
                }
              }
            } else {
              {
#line 560
              index___0 = 1;
#line 561
              filename_size = 0;
#line 563
              argument_offset ++;
#line 564
              tmp___6 = strcmp((char const   *)*(argv + argument_offset), "carrier");
              }
#line 564
              if (tmp___6 == 0) {
#line 568
                option = *(argv + argument_offset);
#line 569
                index___0 ++;
#line 570
                argc --;
              } else {
                {
#line 564
                tmp___7 = strcmp((char const   *)*(argv + argument_offset), "power");
                }
#line 564
                if (tmp___7 == 0) {
#line 568
                  option = *(argv + argument_offset);
#line 569
                  index___0 ++;
#line 570
                  argc --;
                } else {
                  {
#line 564
                  tmp___8 = strcmp((char const   *)*(argv + argument_offset), "all");
                  }
#line 564
                  if (tmp___8 == 0) {
#line 568
                    option = *(argv + argument_offset);
#line 569
                    index___0 ++;
#line 570
                    argc --;
                  } else {
                    {
#line 572
                    tmp___4 = strcmp((char const   *)*(argv + argument_offset), "match");
                    }
#line 572
                    if (tmp___4 == 0) {
#line 575
                      option = *(argv + argument_offset);
#line 576
                      index___0 ++;
#line 577
                      argc --;
                    } else {
                      {
#line 572
                      tmp___5 = strcmp((char const   *)*(argv + argument_offset),
                                       "unmatch");
                      }
#line 572
                      if (tmp___5 == 0) {
#line 575
                        option = *(argv + argument_offset);
#line 576
                        index___0 ++;
#line 577
                        argc --;
                      } else {
                        {
#line 582
                        tmp___3 = strncmp((char const   *)(*(argv + argument_offset) + 2),
                                          "=", (size_t )1);
                        }
#line 582
                        if (tmp___3 == 0) {
#line 583
                          option = (char *)"default";
#line 586
                          index___0 = 1;
                        } else {
                          {
#line 589
                          option = (char *)"invalid";
#line 590
                          printf((char const   */* __restrict  */)"Invalid option \'%s\'\n",
                                 *(argv + argument_offset));
#line 591
                          argument_offset --;
#line 592
                          tmp___2 = strcmp((char const   *)*(argv + 0), "print");
                          }
#line 592
                          if (tmp___2 == 0) {
                            {
#line 593
                            lprintf(3, "   ekanalyzer print [carrier/power/all] <xx=frufile> <xx=frufile> [xx=frufile]");
                            }
                          } else {
                            {
#line 598
                            lprintf(3, "   ekanalyzer summary [match/ unmatch/ all] <xx=frufile> <xx=frufile> [xx=frufile]");
                            }
                          }
#line 602
                          rc = (int )ERROR_STATUS;
                        }
                      }
                    }
                  }
                }
              }
              {
#line 604
              tmp___13 = strcmp((char const   *)option, "invalid");
              }
#line 604
              if (tmp___13 != 0) {
#line 605
                i = 0;
#line 607
                i = 0;
                {
#line 607
                while (1) {
                  while_continue___1: /* CIL Label */ ;
#line 607
                  if (! (i < argc - 1)) {
#line 607
                    goto while_break___1;
                  }
                  {
#line 608
                  file_type[i] = ipmi_ek_get_file_type(*(argv + index___0));
                  }
#line 609
                  if (file_type[i] == (int )ERROR_STATUS) {
                    {
#line 611
                    lprintf(3, "Invalid file type: %c%c\n", (int )*(*(argv + index___0) + 0),
                            (int )*(*(argv + index___0) + 1));
#line 613
                    ipmi_ekanalyzer_usage();
#line 614
                    rc = (int )ERROR_STATUS;
                    }
#line 615
                    goto while_break___1;
                  }
                  {
#line 620
                  tmp___9 = strlen((char const   *)*(argv + index___0));
#line 620
                  filename_size = (int )((tmp___9 - (size_t )SIZE_OF_FILE_TYPE) + 1UL);
                  }
#line 621
                  if (filename_size > 0) {
                    {
#line 622
                    tmp___10 = malloc((size_t )filename_size);
#line 622
                    filename[i] = (char *)tmp___10;
                    }
#line 623
                    if ((unsigned long )filename[i] != (unsigned long )((void *)0)) {
                      {
#line 624
                      strcpy((char */* __restrict  */)filename[i], (char const   */* __restrict  */)(*(argv + index___0) + SIZE_OF_FILE_TYPE));
                      }
                    }
                  }
#line 626
                  rc = (int )OK_STATUS;
#line 627
                  index___0 ++;
#line 607
                  i ++;
                }
                while_break___1: /* CIL Label */ ;
                }
#line 629
                if (rc != (int )ERROR_STATUS) {
#line 630
                  if (verbose > 0) {
#line 631
                    i = 0;
                    {
#line 631
                    while (1) {
                      while_continue___2: /* CIL Label */ ;
#line 631
                      if (! (i < argc - 1)) {
#line 631
                        goto while_break___2;
                      }
                      {
#line 632
                      tmp___11 = val2str((uint16_t )file_type[i], ipmi_ekanalyzer_module_type);
#line 632
                      printf((char const   */* __restrict  */)"Type: %s,   ", tmp___11);
#line 634
                      printf((char const   */* __restrict  */)"file name: %s\n", filename[i]);
#line 631
                      i ++;
                      }
                    }
                    while_break___2: /* CIL Label */ ;
                    }
                  }
                  {
#line 637
                  tmp___12 = strcmp((char const   *)*(argv + 0), "print");
                  }
#line 637
                  if (tmp___12 == 0) {
                    {
#line 638
                    rc = ipmi_ekanalyzer_print(argc - 1, option, filename, file_type);
                    }
                  } else {
                    {
#line 642
                    rc = ipmi_ekanalyzer_ekeying_match(argc - 1, option, filename,
                                                       file_type);
                    }
                  }
#line 645
                  i = 0;
                  {
#line 645
                  while (1) {
                    while_continue___3: /* CIL Label */ ;
#line 645
                    if (! (i < argc - 1)) {
#line 645
                      goto while_break___3;
                    }
#line 646
                    if ((unsigned long )filename[i] != (unsigned long )((void *)0)) {
                      {
#line 647
                      free((void *)filename[i]);
#line 648
                      filename[i] = (char *)((void *)0);
                      }
                    }
#line 645
                    i ++;
                  }
                  while_break___3: /* CIL Label */ ;
                  }
                }
              }
            }
          } else {
            {
#line 656
            lprintf(3, "Invalid ekanalyzer command: %s", *(argv + 0));
#line 657
            ipmi_ekanalyzer_usage();
#line 658
            rc = (int )ERROR_STATUS;
            }
          }
        }
      }
    }
  }
#line 661
  return (rc);
}
}
#line 687 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ekanalyzer_print(int argc , char *opt , char **filename , int *file_type ) 
{ 
  int return_value ;
  int found_flag ;
  int index___0 ;
  int *index_name ;
  unsigned long __lengthofindex_name ;
  void *tmp ;
  int list ;
  struct ipmi_ek_multi_header **list_head ;
  unsigned long __lengthoflist_head ;
  void *tmp___0 ;
  struct ipmi_ek_multi_header **list_record ;
  unsigned long __lengthoflist_record ;
  void *tmp___1 ;
  struct ipmi_ek_multi_header **list_last ;
  unsigned long __lengthoflist_last ;
  void *tmp___2 ;
  int i ;
  int first_data ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 690
  return_value = (int )OK_STATUS;
#line 693
  tmp___5 = strcmp((char const   *)opt, "carrier");
  }
#line 693
  if (tmp___5 == 0) {
#line 693
    goto _L;
  } else {
    {
#line 693
    tmp___6 = strcmp((char const   *)opt, "default");
    }
#line 693
    if (tmp___6 == 0) {
      _L: /* CIL Label */ 
      {
#line 694
      found_flag = 0;
#line 695
      index___0 = 0;
#line 696
      __lengthofindex_name = (unsigned long )argc;
#line 696
      tmp = __builtin_alloca(sizeof(*index_name) * __lengthofindex_name);
#line 696
      index_name = (int *)tmp;
#line 697
      list = 0;
#line 699
      __lengthoflist_head = (unsigned long )argc;
#line 699
      tmp___0 = __builtin_alloca(sizeof(*list_head) * __lengthoflist_head);
#line 699
      list_head = (struct ipmi_ek_multi_header **)tmp___0;
#line 700
      __lengthoflist_record = (unsigned long )argc;
#line 700
      tmp___1 = __builtin_alloca(sizeof(*list_record) * __lengthoflist_record);
#line 700
      list_record = (struct ipmi_ek_multi_header **)tmp___1;
#line 701
      __lengthoflist_last = (unsigned long )argc;
#line 701
      tmp___2 = __builtin_alloca(sizeof(*list_last) * __lengthoflist_last);
#line 701
      list_last = (struct ipmi_ek_multi_header **)tmp___2;
#line 703
      list = 0;
      }
      {
#line 703
      while (1) {
        while_continue: /* CIL Label */ ;
#line 703
        if (! (list < argc)) {
#line 703
          goto while_break;
        }
#line 704
        *(list_head + list) = (struct ipmi_ek_multi_header *)((void *)0);
#line 705
        *(list_record + list) = (struct ipmi_ek_multi_header *)((void *)0);
#line 706
        *(list_last + list) = (struct ipmi_ek_multi_header *)((void *)0);
#line 703
        list ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 709
      list = 0;
#line 710
      index___0 = 0;
      {
#line 710
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 710
        if (! (index___0 < argc)) {
#line 710
          goto while_break___0;
        }
#line 711
        if (*(file_type + index___0) == 9) {
          {
#line 712
          *(index_name + list) = index___0;
#line 713
          return_value = ipmi_ekanalyzer_fru_file2structure(*(filename + index___0),
                                                            list_head + list, list_record + list,
                                                            list_last + list);
#line 715
          list ++;
#line 716
          found_flag = 1;
          }
        }
#line 710
        index___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 719
      if (! found_flag) {
        {
#line 720
        printf((char const   */* __restrict  */)"No carrier file has been found\n");
#line 721
        return_value = (int )ERROR_STATUS;
        }
      } else {
#line 724
        i = 0;
#line 725
        i = 0;
        {
#line 725
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 725
          if (! (i < argc)) {
#line 725
            goto while_break___1;
          }
#line 727
          first_data = 1;
#line 728
          *(list_record + i) = *(list_head + i);
          {
#line 728
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 728
            if (! ((unsigned long )*(list_record + i) != (unsigned long )((void *)0))) {
#line 728
              goto while_break___2;
            }
#line 731
            if ((int )*((*(list_record + i))->data + PICMG_ID_OFFSET) == 24) {
#line 734
              if (first_data) {
                {
#line 735
                printf((char const   */* __restrict  */)"%s\n", STAR_LINE_LIMITER);
#line 736
                printf((char const   */* __restrict  */)"From Carrier file: %s\n",
                       *(filename + *(index_name + i)));
#line 737
                first_data = 0;
                }
              }
              {
#line 739
              return_value = ipmi_ek_display_carrier_connectivity(*(list_record + i));
              }
            } else
#line 742
            if ((int )*((*(list_record + i))->data + PICMG_ID_OFFSET) == 26) {
#line 747
              if (first_data) {
                {
#line 748
                printf((char const   */* __restrict  */)"From Carrier file: %s\n",
                       *(filename + *(index_name + i)));
#line 749
                first_data = 0;
                }
              }
              {
#line 751
              printf((char const   */* __restrict  */)"   Number of AMC bays supported by Carrier: %d\n",
                     (int )*((*(list_record + i))->data + 6));
              }
            }
#line 728
            *(list_record + i) = (*(list_record + i))->next;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 725
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 757
        i = 0;
        {
#line 757
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 757
          if (! (i < argc)) {
#line 757
            goto while_break___3;
          }
          {
#line 758
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 758
            if (! ((unsigned long )*(list_head + i) != (unsigned long )((void *)0))) {
#line 758
              goto while_break___4;
            }
            {
#line 759
            ipmi_ek_remove_record_from_list(*(list_head + i), list_head + i, list_last + i);
            }
          }
          while_break___4: /* CIL Label */ ;
          }
#line 763
          if (i == list - 1) {
#line 763
            if (verbose) {
              {
#line 764
              printf((char const   */* __restrict  */)"Record list has been removed successfully\n");
              }
            }
          }
#line 757
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 768
      tmp___4 = strcmp((char const   *)opt, "power");
      }
#line 768
      if (tmp___4 == 0) {
        {
#line 769
        printf((char const   */* __restrict  */)"Print power information\n");
#line 770
        return_value = ipmi_ek_display_power(argc, opt, filename, file_type);
        }
      } else {
        {
#line 772
        tmp___3 = strcmp((char const   *)opt, "all");
        }
#line 772
        if (tmp___3 == 0) {
          {
#line 773
          printf((char const   */* __restrict  */)"Print all information\n");
#line 774
          return_value = ipmi_ek_display_power(argc, opt, filename, file_type);
          }
        } else {
          {
#line 777
          lprintf(3, "Invalid option %s", opt);
#line 778
          return_value = (int )ERROR_STATUS;
          }
        }
      }
    }
  }
#line 780
  return (return_value);
}
}
#line 802 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_display_carrier_connectivity(struct ipmi_ek_multi_header *record ) 
{ 
  int return_value ;
  struct fru_picmgext_carrier_p2p_record rsc_desc ;
  struct fru_picmgext_carrier_p2p_descriptor *port_desc ;
  int offset ;
  int k ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  unsigned char data[3] ;
  char const   *tmp___3 ;

  {
#line 805
  return_value = (int )ERROR_STATUS;
#line 809
  if ((unsigned long )record == (unsigned long )((void *)0)) {
    {
#line 810
    lprintf(3, "P2P connectivity record is invalid\n");
#line 811
    return_value = (int )ERROR_STATUS;
    }
  } else {
#line 814
    offset = (int )START_DATA_OFFSET;
#line 815
    if (verbose > 1) {
      {
#line 816
      k = 0;
#line 817
      printf((char const   */* __restrict  */)"Binary data of Carrier p2p connectivity record starting from mfg id\n");
#line 819
      k = 0;
      }
      {
#line 819
      while (1) {
        while_continue: /* CIL Label */ ;
#line 819
        if (! (k < (int )record->header.len)) {
#line 819
          goto while_break;
        }
        {
#line 820
        printf((char const   */* __restrict  */)"%02x   ", (int )*(record->data + k));
#line 819
        k ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 822
      printf((char const   */* __restrict  */)"\n");
      }
    }
    {
#line 824
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 824
      if (! (offset <= (int )record->header.len - (int )START_DATA_OFFSET)) {
#line 824
        goto while_break___0;
      }
#line 825
      tmp = offset;
#line 825
      offset ++;
#line 825
      rsc_desc.resource_id = *(record->data + tmp);
#line 826
      tmp___0 = offset;
#line 826
      offset ++;
#line 826
      rsc_desc.p2p_count = *(record->data + tmp___0);
#line 827
      if (verbose > 0) {
        {
#line 828
        printf((char const   */* __restrict  */)"resource id= %02x  port count= %d\n",
               (int )rsc_desc.resource_id, (int )rsc_desc.p2p_count);
        }
      }
#line 832
      if (((int )rsc_desc.resource_id & (int )AMC_MODULE) == (int )AMC_MODULE) {
#line 834
        if ((int )rsc_desc.resource_id == (int )AMC_MODULE) {
          {
#line 835
          tmp___1 = val2str((uint16_t )144, ipmi_ekanalyzer_IPMBL_addr);
#line 835
          printf((char const   */* __restrict  */)"   %s topology:\n", tmp___1);
          }
        } else {
          {
#line 842
          tmp___2 = val2str((uint16_t )((int )rsc_desc.resource_id & 15), ipmi_ekanalyzer_module_type);
#line 842
          printf((char const   */* __restrict  */)"   %s topology:\n", tmp___2);
          }
        }
      } else {
        {
#line 848
        printf((char const   */* __restrict  */)"   On Carrier Device ID %d topology: \n",
               (int )rsc_desc.resource_id & 15);
        }
      }
      {
#line 851
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 851
        if (! ((int )rsc_desc.p2p_count > 0)) {
#line 851
          goto while_break___1;
        }
#line 854
        data[0] = *(record->data + offset);
#line 855
        data[1] = *(record->data + (offset + 1));
#line 856
        data[2] = *(record->data + (offset + 2));
#line 862
        port_desc = (struct fru_picmgext_carrier_p2p_descriptor *)(data);
#line 863
        offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_carrier_p2p_descriptor ));
#line 864
        if (((int )port_desc->remote_resource_id & (int )AMC_MODULE) == (int )AMC_MODULE) {
          {
#line 865
          tmp___3 = val2str((uint16_t )((int )port_desc->remote_resource_id & 15),
                            ipmi_ekanalyzer_module_type);
#line 865
          printf((char const   */* __restrict  */)"\tPort %d =====> %s, Port %d\n",
                 (int )port_desc->local_port, tmp___3, (int )port_desc->remote_port);
          }
        } else {
          {
#line 872
          printf((char const   */* __restrict  */)"\tPort %d =====> On Carrier Device ID %d, Port %d\n",
                 (int )port_desc->local_port, (int )port_desc->remote_resource_id & 15,
                 (int )port_desc->remote_port);
          }
        }
#line 877
        rsc_desc.p2p_count = (unsigned char )((int )rsc_desc.p2p_count - 1);
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 880
    return_value = (int )OK_STATUS;
  }
#line 882
  return (return_value);
}
}
#line 908 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_display_power(int argc , char *opt , char **filename , int *file_type ) 
{ 
  int num_file ;
  int return_value ;
  int index___0 ;
  struct ipmi_ek_multi_header **list_head ;
  unsigned long __lengthoflist_head ;
  void *tmp ;
  struct ipmi_ek_multi_header **list_record ;
  unsigned long __lengthoflist_record ;
  void *tmp___0 ;
  struct ipmi_ek_multi_header **list_last ;
  unsigned long __lengthoflist_last ;
  void *tmp___1 ;
  int is_first_data ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int index_data ;
  struct fru_picmgext_carrier_activation_record car ;
  struct fru_picmgext_activation_record *cur_desc ;
  void *tmp___4 ;
  float power_in_watt ;
  float current_in_amp ;
  char const   *tmp___5 ;

  {
  {
#line 911
  num_file = 0;
#line 912
  return_value = (int )ERROR_STATUS;
#line 913
  index___0 = 0;
#line 916
  __lengthoflist_head = (unsigned long )argc;
#line 916
  tmp = __builtin_alloca(sizeof(*list_head) * __lengthoflist_head);
#line 916
  list_head = (struct ipmi_ek_multi_header **)tmp;
#line 917
  __lengthoflist_record = (unsigned long )argc;
#line 917
  tmp___0 = __builtin_alloca(sizeof(*list_record) * __lengthoflist_record);
#line 917
  list_record = (struct ipmi_ek_multi_header **)tmp___0;
#line 918
  __lengthoflist_last = (unsigned long )argc;
#line 918
  tmp___1 = __builtin_alloca(sizeof(*list_last) * __lengthoflist_last);
#line 918
  list_last = (struct ipmi_ek_multi_header **)tmp___1;
#line 920
  num_file = 0;
  }
  {
#line 920
  while (1) {
    while_continue: /* CIL Label */ ;
#line 920
    if (! (num_file < argc)) {
#line 920
      goto while_break;
    }
#line 921
    *(list_head + num_file) = (struct ipmi_ek_multi_header *)((void *)0);
#line 922
    *(list_record + num_file) = (struct ipmi_ek_multi_header *)((void *)0);
#line 923
    *(list_last + num_file) = (struct ipmi_ek_multi_header *)((void *)0);
#line 920
    num_file ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 926
  num_file = 0;
  {
#line 926
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 926
    if (! (num_file < argc)) {
#line 926
      goto while_break___0;
    }
#line 927
    is_first_data = 1;
#line 928
    if (*(file_type + num_file) == 10) {
#line 929
      num_file ++;
    }
#line 932
    if (is_first_data) {
      {
#line 933
      printf((char const   */* __restrict  */)"%s\n", STAR_LINE_LIMITER);
#line 934
      tmp___2 = val2str((uint16_t )*(file_type + num_file), ipmi_ekanalyzer_module_type);
#line 934
      printf((char const   */* __restrict  */)"\nFrom %s file \'%s\'\n", tmp___2,
             *(filename + num_file));
#line 937
      is_first_data = 0;
      }
    }
    {
#line 940
    return_value = ipmi_ekanalyzer_fru_file2structure(*(filename + num_file), list_head + num_file,
                                                      list_record + num_file, list_last + num_file);
    }
#line 943
    if ((unsigned long )*(list_head + num_file) != (unsigned long )((void *)0)) {
#line 944
      *(list_record + num_file) = *(list_head + num_file);
      {
#line 944
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 944
        if (! ((unsigned long )*(list_record + num_file) != (unsigned long )((void *)0))) {
#line 944
          goto while_break___1;
        }
        {
#line 948
        tmp___3 = strcmp((char const   *)opt, "all");
        }
#line 948
        if (tmp___3 == 0) {
#line 948
          if (*(file_type + num_file) == 9) {
#line 951
            if ((int )*((*(list_record + num_file))->data + PICMG_ID_OFFSET) == 24) {
              {
#line 955
              return_value = ipmi_ek_display_carrier_connectivity(*(list_record + num_file));
              }
            } else
#line 958
            if ((int )*((*(list_record + num_file))->data + PICMG_ID_OFFSET) == 26) {
              {
#line 965
              printf((char const   */* __restrict  */)"   Number of AMC bays supported by Carrier: %d\n",
                     (int )*((*(list_record + num_file))->data + (START_DATA_OFFSET + 1)));
              }
            }
          }
        }
#line 972
        if ((int )*((*(list_record + num_file))->data + PICMG_ID_OFFSET) == 23) {
          {
#line 976
          index_data = (int )START_DATA_OFFSET;
#line 980
          memcpy((void */* __restrict  */)(& car), (void const   */* __restrict  */)((*(list_record + num_file))->data + index_data),
                 sizeof(struct fru_picmgext_carrier_activation_record ));
#line 982
          index_data = (int )((unsigned long )index_data + sizeof(struct fru_picmgext_carrier_activation_record ));
#line 984
          tmp___4 = malloc((unsigned long )car.module_activation_record_count * sizeof(struct fru_picmgext_activation_record ));
#line 984
          cur_desc = (struct fru_picmgext_activation_record *)tmp___4;
#line 986
          index___0 = 0;
          }
          {
#line 986
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 986
            if (! (index___0 < (int )car.module_activation_record_count)) {
#line 986
              goto while_break___2;
            }
            {
#line 987
            memcpy((void */* __restrict  */)(cur_desc + index___0), (void const   */* __restrict  */)((*(list_record + num_file))->data + index_data),
                   sizeof(struct fru_picmgext_activation_record ));
#line 991
            index_data = (int )((unsigned long )index_data + sizeof(struct fru_picmgext_activation_record ));
#line 986
            index___0 ++;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 994
          ipmi_ek_display_current_descriptor(car, cur_desc, *(filename + num_file));
#line 996
          free((void *)cur_desc);
#line 997
          cur_desc = (struct fru_picmgext_activation_record *)((void *)0);
          }
        } else
#line 1000
        if ((int )*((*(list_record + num_file))->data + PICMG_ID_OFFSET) == 22) {
          {
#line 1003
          power_in_watt = (float )0;
#line 1004
          current_in_amp = (float )0;
#line 1006
          tmp___5 = val2str((uint16_t )*(file_type + num_file), ipmi_ekanalyzer_module_type);
#line 1006
          printf((char const   */* __restrict  */)"   %s power required (Current Draw): ",
                 tmp___5);
#line 1008
          current_in_amp = (float )((double )*((*(list_record + num_file))->data + START_DATA_OFFSET) * 0.1);
#line 1010
          power_in_watt = current_in_amp * (float )12;
#line 1011
          printf((char const   */* __restrict  */)"%.2f Watts (%.2f Amps)\n", (double )power_in_watt,
                 (double )current_in_amp);
          }
        }
#line 944
        *(list_record + num_file) = (*(list_record + num_file))->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1014
      return_value = (int )OK_STATUS;
#line 1016
      index___0 = 0;
      {
#line 1016
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1016
        if (! (index___0 < argc)) {
#line 1016
          goto while_break___3;
        }
        {
#line 1017
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1017
          if (! ((unsigned long )*(list_head + index___0) != (unsigned long )((void *)0))) {
#line 1017
            goto while_break___4;
          }
          {
#line 1018
          ipmi_ek_remove_record_from_list(*(list_head + index___0), list_head + index___0,
                                          list_last + index___0);
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1021
        if (verbose > 1) {
          {
#line 1022
          printf((char const   */* __restrict  */)"Record list has been removed successfully\n");
          }
        }
#line 1016
        index___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 926
    num_file ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1026
  printf((char const   */* __restrict  */)"%s\n", STAR_LINE_LIMITER);
  }
#line 1027
  return (return_value);
}
}
#line 1051 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_current_descriptor(struct fru_picmgext_carrier_activation_record car ,
                                               struct fru_picmgext_activation_record *cur_desc ,
                                               char *filename ) 
{ 
  int index___0 ;
  float power_in_watt ;
  float current_in_amp ;
  char const   *tmp ;

  {
#line 1056
  index___0 = 0;
#line 1057
  power_in_watt = (float )0.0;
#line 1058
  current_in_amp = (float )0.0;
#line 1060
  index___0 = 0;
  {
#line 1060
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1060
    if (! (index___0 < (int )car.module_activation_record_count)) {
#line 1060
      goto while_break;
    }
    {
#line 1062
    current_in_amp = (float )((double )((float )(cur_desc + index___0)->max_module_curr) * 0.1);
#line 1063
    power_in_watt = current_in_amp * (float )12;
#line 1065
    tmp = val2str((uint16_t )(cur_desc + index___0)->ibmb_addr, ipmi_ekanalyzer_IPMBL_addr);
#line 1065
    printf((char const   */* __restrict  */)"   Carrier AMC power available on %s:\n",
           tmp);
#line 1067
    printf((char const   */* __restrict  */)"\t- Local IPMB Address    \t: %02x\n",
           (int )(cur_desc + index___0)->ibmb_addr);
#line 1068
    printf((char const   */* __restrict  */)"\t- Maximum module Current\t: %.2f Watts (%.2f Amps)\n",
           (double )power_in_watt, (double )current_in_amp);
#line 1060
    index___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1072
  current_in_amp = (float )((double )((float )car.max_internal_curr) * 0.1);
#line 1073
  power_in_watt = current_in_amp * (float )12;
#line 1074
  printf((char const   */* __restrict  */)"   Carrier AMC total power available for all bays from file \'%s\':",
         filename);
#line 1076
  printf((char const   */* __restrict  */)" %.2f Watts (%.2f Amps)\n", (double )power_in_watt,
         (double )current_in_amp);
  }
#line 1077
  return;
}
}
#line 1100 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ekanalyzer_ekeying_match(int argc , char *opt , char **filename ,
                                         int *file_type ) 
{ 
  int return_value ;
  int num_file ;
  int amc_file ;
  int oc_file ;
  struct ipmi_ek_multi_header **list_head ;
  unsigned long __lengthoflist_head ;
  void *tmp ;
  struct ipmi_ek_multi_header **list_record ;
  unsigned long __lengthoflist_record ;
  void *tmp___0 ;
  struct ipmi_ek_multi_header **list_last ;
  unsigned long __lengthoflist_last ;
  void *tmp___1 ;
  struct ipmi_ek_multi_header *pcarrier_p2p ;
  int list ;
  int match_pair ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1104
  return_value = 0;
#line 1106
  tmp___4 = strcmp((char const   *)opt, "carrier");
  }
#line 1106
  if (tmp___4 == 0) {
    {
#line 1107
    lprintf(3, "   ekanalyzer summary [match/ unmatch/ all] <xx=frufile> <xx=frufile> [xx=frufile]");
#line 1109
    return_value = (int )ERROR_STATUS;
    }
  } else {
    {
#line 1106
    tmp___5 = strcmp((char const   *)opt, "power");
    }
#line 1106
    if (tmp___5 == 0) {
      {
#line 1107
      lprintf(3, "   ekanalyzer summary [match/ unmatch/ all] <xx=frufile> <xx=frufile> [xx=frufile]");
#line 1109
      return_value = (int )ERROR_STATUS;
      }
    } else {
#line 1112
      num_file = 0;
#line 1113
      amc_file = 0;
#line 1114
      oc_file = 0;
#line 1117
      num_file = 0;
      {
#line 1117
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1117
        if (! (num_file < argc)) {
#line 1117
          goto while_break;
        }
#line 1118
        if (*(file_type + num_file) == 9) {
#line 1122
          amc_file = 0;
        } else
#line 1118
        if (*(file_type + num_file) == 10) {
#line 1122
          amc_file = 0;
        } else
#line 1118
        if (*(file_type + num_file) == 11) {
#line 1122
          amc_file = 0;
        } else {
#line 1125
          amc_file = 1;
#line 1126
          goto while_break;
        }
#line 1117
        num_file ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1129
      if (amc_file == 0) {
        {
#line 1130
        printf((char const   */* __restrict  */)"\nNo AMC FRU file is provided ---> No possible ekeying match!\n");
#line 1132
        return_value = (int )ERROR_STATUS;
        }
      } else {
#line 1136
        num_file = 0;
        {
#line 1136
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1136
          if (! (num_file < argc)) {
#line 1136
            goto while_break___0;
          }
#line 1137
          if (*(file_type + num_file) == 9) {
#line 1141
            oc_file = 1;
#line 1142
            goto while_break___0;
          } else
#line 1137
          if (*(file_type + num_file) == 10) {
#line 1141
            oc_file = 1;
#line 1142
            goto while_break___0;
          } else
#line 1137
          if (*(file_type + num_file) == 11) {
#line 1141
            oc_file = 1;
#line 1142
            goto while_break___0;
          }
#line 1136
          num_file ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1145
        if (! oc_file) {
          {
#line 1146
          printf((char const   */* __restrict  */)"\nNo Carrier FRU file is provided ---> No possible ekeying match!\n");
#line 1148
          return_value = (int )ERROR_STATUS;
          }
        } else {
          {
#line 1152
          __lengthoflist_head = (unsigned long )argc;
#line 1152
          tmp = __builtin_alloca(sizeof(*list_head) * __lengthoflist_head);
#line 1152
          list_head = (struct ipmi_ek_multi_header **)tmp;
#line 1153
          __lengthoflist_record = (unsigned long )argc;
#line 1153
          tmp___0 = __builtin_alloca(sizeof(*list_record) * __lengthoflist_record);
#line 1153
          list_record = (struct ipmi_ek_multi_header **)tmp___0;
#line 1154
          __lengthoflist_last = (unsigned long )argc;
#line 1154
          tmp___1 = __builtin_alloca(sizeof(*list_last) * __lengthoflist_last);
#line 1154
          list_last = (struct ipmi_ek_multi_header **)tmp___1;
#line 1156
          list = 0;
#line 1157
          match_pair = 0;
#line 1160
          list = 0;
          }
          {
#line 1160
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1160
            if (! (list < argc)) {
#line 1160
              goto while_break___1;
            }
#line 1161
            *(list_head + list) = (struct ipmi_ek_multi_header *)((void *)0);
#line 1162
            *(list_record + list) = (struct ipmi_ek_multi_header *)((void *)0);
#line 1163
            *(list_last + list) = (struct ipmi_ek_multi_header *)((void *)0);
#line 1160
            list ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 1165
          list = 0;
#line 1167
          num_file = 0;
          {
#line 1167
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1167
            if (! (num_file < argc)) {
#line 1167
              goto while_break___2;
            }
#line 1168
            if (*(file_type + num_file) != 10) {
              {
#line 1169
              return_value = ipmi_ekanalyzer_fru_file2structure(*(filename + num_file),
                                                                list_head + num_file,
                                                                list_record + num_file,
                                                                list_last + num_file);
              }
            }
#line 1167
            num_file ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1175
          num_file = 0;
          {
#line 1175
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1175
            if (! (num_file < argc)) {
#line 1175
              goto while_break___3;
            }
#line 1176
            if (*(file_type + num_file) == 9) {
#line 1177
              pcarrier_p2p = *(list_head + num_file);
              {
#line 1177
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 1177
                if (! ((unsigned long )pcarrier_p2p != (unsigned long )((void *)0))) {
#line 1177
                  goto while_break___4;
                }
#line 1181
                if ((int )*(pcarrier_p2p->data + PICMG_ID_OFFSET) == 24) {
#line 1184
                  goto while_break___4;
                }
#line 1177
                pcarrier_p2p = pcarrier_p2p->next;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 1187
              goto while_break___3;
            }
#line 1175
            num_file ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 1191
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1191
            if (! (match_pair < argc)) {
#line 1191
              goto while_break___5;
            }
#line 1192
            num_file = match_pair + 1;
            {
#line 1192
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 1192
              if (! (num_file < argc)) {
#line 1192
                goto while_break___6;
              }
#line 1193
              if (*(file_type + match_pair) != 10) {
#line 1193
                if (*(file_type + num_file) != 10) {
#line 1196
                  if (*(file_type + match_pair) != 9) {
#line 1196
                    goto _L;
                  } else
#line 1196
                  if (*(file_type + num_file) != 9) {
                    _L: /* CIL Label */ 
                    {
#line 1199
                    tmp___2 = val2str((uint16_t )*(file_type + num_file), ipmi_ekanalyzer_module_type);
#line 1199
                    tmp___3 = val2str((uint16_t )*(file_type + match_pair), ipmi_ekanalyzer_module_type);
#line 1199
                    printf((char const   */* __restrict  */)"%s vs %s\n", tmp___3,
                           tmp___2);
                    }
#line 1205
                    if (verbose > 0) {
                      {
#line 1206
                      printf((char const   */* __restrict  */)"Start matching process\n");
                      }
                    }
                    {
#line 1208
                    return_value = ipmi_ek_matching_process(file_type, match_pair,
                                                            num_file, list_head, list_last,
                                                            opt, pcarrier_p2p);
                    }
                  }
                }
              }
#line 1192
              num_file ++;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 1214
            match_pair ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 1216
          num_file = 0;
          {
#line 1216
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 1216
            if (! (num_file < argc)) {
#line 1216
              goto while_break___7;
            }
#line 1217
            if ((unsigned long )*(list_head + num_file) != (unsigned long )((void *)0)) {
              {
#line 1218
              ipmi_ek_remove_record_from_list(*(list_head + num_file), list_record + num_file,
                                              list_last + num_file);
              }
            }
#line 1221
            if (num_file == argc - 1) {
#line 1221
              if (verbose) {
                {
#line 1222
                printf((char const   */* __restrict  */)"Record list has been removed successfully\n");
                }
              }
            }
#line 1216
            num_file ++;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 1224
          return_value = (int )OK_STATUS;
        }
      }
    }
  }
#line 1228
  return (return_value);
}
}
#line 1261 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_matching_process(int *file_type , int index1 , int index2 , struct ipmi_ek_multi_header **list_head ,
                                    struct ipmi_ek_multi_header **list_last , char *opt ,
                                    struct ipmi_ek_multi_header *pphysical ) 
{ 
  int result ;
  struct ipmi_ek_multi_header *record ;
  int num_amc_record1 ;
  int num_amc_record2 ;
  int index_temp ;
  int index_record1 ;
  int index_record2 ;
  struct ipmi_ek_amc_p2p_connectivity_record *amc_record1 ;
  struct ipmi_ek_amc_p2p_connectivity_record *amc_record2 ;
  void *tmp ;
  void *tmp___0 ;
  struct ipmi_ek_multi_header *current_record ;

  {
#line 1266
  result = (int )ERROR_STATUS;
#line 1268
  num_amc_record1 = 0;
#line 1269
  num_amc_record2 = 0;
#line 1272
  if (*(file_type + index2) == 9) {
#line 1273
    index_temp = 0;
#line 1274
    index_temp = index1;
#line 1275
    index1 = index2;
#line 1276
    index2 = index_temp;
  }
#line 1279
  record = *(list_head + index1);
  {
#line 1279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1279
    if (! ((unsigned long )record != (unsigned long )((void *)0))) {
#line 1279
      goto while_break;
    }
#line 1280
    if ((int )*(record->data + PICMG_ID_OFFSET) == 25) {
#line 1281
      num_amc_record2 ++;
    }
#line 1279
    record = record->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1285
  record = *(list_head + index2);
  {
#line 1285
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1285
    if (! ((unsigned long )record != (unsigned long )((void *)0))) {
#line 1285
      goto while_break___0;
    }
#line 1286
    if ((int )*(record->data + PICMG_ID_OFFSET) == 25) {
#line 1287
      num_amc_record1 ++;
    }
#line 1285
    record = record->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1290
  if (num_amc_record1 > 0) {
#line 1290
    if (num_amc_record2 > 0) {
      {
#line 1291
      index_record1 = 0;
#line 1292
      index_record2 = 0;
#line 1294
      amc_record1 = (struct ipmi_ek_amc_p2p_connectivity_record *)((void *)0);
#line 1296
      amc_record2 = (struct ipmi_ek_amc_p2p_connectivity_record *)((void *)0);
#line 1298
      tmp = malloc((unsigned long )num_amc_record1 * sizeof(struct ipmi_ek_amc_p2p_connectivity_record ));
#line 1298
      amc_record1 = (struct ipmi_ek_amc_p2p_connectivity_record *)tmp;
#line 1300
      tmp___0 = malloc((unsigned long )num_amc_record2 * sizeof(struct ipmi_ek_amc_p2p_connectivity_record ));
#line 1300
      amc_record2 = (struct ipmi_ek_amc_p2p_connectivity_record *)tmp___0;
#line 1303
      record = *(list_head + index2);
      }
      {
#line 1303
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1303
        if (! ((unsigned long )record != (unsigned long )((void *)0))) {
#line 1303
          goto while_break___1;
        }
#line 1304
        if ((int )*(record->data + PICMG_ID_OFFSET) == 25) {
          {
#line 1305
          result = ipmi_ek_create_amc_p2p_record(record, amc_record1 + index_record1);
          }
#line 1307
          if (result != (int )ERROR_STATUS) {
#line 1308
            current_record = (struct ipmi_ek_multi_header *)((void *)0);
#line 1310
            current_record = *(list_head + index1);
            {
#line 1310
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 1310
              if (! ((unsigned long )current_record != (unsigned long )((void *)0))) {
#line 1310
                goto while_break___2;
              }
#line 1314
              if ((int )*(current_record->data + PICMG_ID_OFFSET) == 25) {
                {
#line 1315
                result = ipmi_ek_create_amc_p2p_record(current_record, amc_record2 + index_record2);
                }
#line 1317
                if (result != (int )ERROR_STATUS) {
#line 1318
                  if (result == (int )OK_STATUS) {
                    {
#line 1320
                    result = ipmi_ek_compare_link(pphysical, *(amc_record1 + index_record1),
                                                  *(amc_record2 + index_record2),
                                                  opt, *(file_type + index1), *(file_type + index2));
                    }
                  }
#line 1325
                  index_record2 ++;
                }
              }
#line 1310
              current_record = current_record->next;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 1329
            index_record1 ++;
          }
        }
#line 1303
        record = record->next;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1333
      free((void *)amc_record1);
#line 1334
      amc_record1 = (struct ipmi_ek_amc_p2p_connectivity_record *)((void *)0);
#line 1335
      free((void *)amc_record2);
#line 1336
      amc_record2 = (struct ipmi_ek_amc_p2p_connectivity_record *)((void *)0);
      }
    } else {
      {
#line 1339
      printf((char const   */* __restrict  */)"No amc record is found!\n");
      }
    }
  } else {
    {
#line 1339
    printf((char const   */* __restrict  */)"No amc record is found!\n");
    }
  }
#line 1342
  return (result);
}
}
#line 1374 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_check_physical_connectivity(struct ipmi_ek_amc_p2p_connectivity_record record1 ,
                                               int index1 , struct ipmi_ek_amc_p2p_connectivity_record record2 ,
                                               int index2 , struct ipmi_ek_multi_header *record ,
                                               int filetype1 , int filetype2 , char *option ) 
{ 
  int return_status ;
  int index___0 ;
  int amc_site ;
  struct fru_picmgext_carrier_p2p_record rsc_desc ;
  struct fru_picmgext_carrier_p2p_descriptor *port_desc ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int j ;
  int match_lane ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;

  {
#line 1381
  return_status = (int )OK_STATUS;
#line 1383
  if ((unsigned long )record == (unsigned long )((void *)0)) {
    {
#line 1384
    printf((char const   */* __restrict  */)"NO Carrier p2p connectivity !\n");
#line 1385
    return_status = (int )ERROR_STATUS;
    }
  } else {
#line 1389
    index___0 = (int )START_DATA_OFFSET;
#line 1390
    amc_site = -1;
#line 1392
    port_desc = (struct fru_picmgext_carrier_p2p_descriptor *)((void *)0);
    {
#line 1395
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1395
      if (! (index___0 < (int )record->header.len)) {
#line 1395
        goto while_break;
      }
#line 1396
      tmp = index___0;
#line 1396
      index___0 ++;
#line 1396
      rsc_desc.resource_id = *(record->data + tmp);
#line 1397
      tmp___0 = index___0;
#line 1397
      index___0 ++;
#line 1397
      rsc_desc.p2p_count = *(record->data + tmp___0);
#line 1399
      if ((int )rsc_desc.resource_id == (int )record1.rsc_id) {
#line 1399
        goto _L;
      } else
#line 1399
      if ((int )rsc_desc.resource_id == (int )record2.rsc_id) {
        _L: /* CIL Label */ 
#line 1403
        if ((int )rsc_desc.p2p_count <= 0) {
          {
#line 1404
          printf((char const   */* __restrict  */)"No p2p count\n");
#line 1405
          return_status = (int )ERROR_STATUS;
          }
        } else {
          {
#line 1408
          tmp___1 = malloc((unsigned long )rsc_desc.p2p_count * sizeof(struct fru_picmgext_carrier_p2p_descriptor ));
#line 1408
          port_desc = (struct fru_picmgext_carrier_p2p_descriptor *)tmp___1;
#line 1410
          index___0 = ipmi_ek_get_resource_descriptor((int )rsc_desc.p2p_count, index___0,
                                                      port_desc, record);
#line 1412
          amc_site = -1;
          }
#line 1413
          goto while_break;
        }
      } else {
#line 1417
        if ((int )rsc_desc.resource_id == (int )AMC_MODULE) {
#line 1418
          if (filetype1 != 9) {
#line 1419
            amc_site = filetype1;
          } else {
#line 1422
            amc_site = filetype2;
          }
        } else {
#line 1426
          amc_site = (int )rsc_desc.resource_id & 15;
        }
#line 1428
        if (amc_site > 0) {
#line 1429
          if (amc_site == filetype1) {
            {
#line 1430
            tmp___2 = malloc((unsigned long )rsc_desc.p2p_count * sizeof(struct fru_picmgext_carrier_p2p_descriptor ));
#line 1430
            port_desc = (struct fru_picmgext_carrier_p2p_descriptor *)tmp___2;
#line 1432
            index___0 = ipmi_ek_get_resource_descriptor((int )rsc_desc.p2p_count,
                                                        index___0, port_desc, record);
            }
#line 1434
            goto while_break;
          } else
#line 1429
          if (amc_site == filetype2) {
            {
#line 1430
            tmp___2 = malloc((unsigned long )rsc_desc.p2p_count * sizeof(struct fru_picmgext_carrier_p2p_descriptor ));
#line 1430
            port_desc = (struct fru_picmgext_carrier_p2p_descriptor *)tmp___2;
#line 1432
            index___0 = ipmi_ek_get_resource_descriptor((int )rsc_desc.p2p_count,
                                                        index___0, port_desc, record);
            }
#line 1434
            goto while_break;
          }
        } else {
#line 1438
          return_status = (int )ERROR_STATUS;
        }
      }
#line 1444
      index___0 = (int )((unsigned long )index___0 + sizeof(struct fru_picmgext_carrier_p2p_descriptor ) * (unsigned long )rsc_desc.p2p_count);
    }
    while_break: /* CIL Label */ ;
    }
#line 1448
    if ((unsigned long )port_desc != (unsigned long )((void *)0)) {
#line 1448
      if (return_status != (int )ERROR_STATUS) {
#line 1449
        j = 0;
#line 1451
        j = 0;
        {
#line 1451
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1451
          if (! (j < (int )rsc_desc.p2p_count)) {
#line 1451
            goto while_break___0;
          }
#line 1453
          if ((record1.ch_desc + index1)->lane0port != (unsigned int )DISABLE_PORT) {
            {
#line 1455
            match_lane = 0;
#line 1457
            match_lane = ipmi_ek_compare_channel_descriptor(*(record1.ch_desc + index1),
                                                            *(record2.ch_desc + index2),
                                                            port_desc, j, rsc_desc.resource_id);
            }
#line 1461
            if (match_lane) {
#line 1462
              if (filetype1 != 9) {
#line 1463
                if (filetype1 == ((int )rsc_desc.resource_id & 15)) {
#line 1463
                  if (filetype2 == ((int )(port_desc + j)->remote_resource_id & 15)) {
#line 1463
                    goto _L___0;
                  } else {
#line 1463
                    goto _L___2;
                  }
                } else
                _L___2: /* CIL Label */ 
#line 1463
                if (filetype2 == ((int )rsc_desc.resource_id & 15)) {
#line 1463
                  if (filetype1 == ((int )(port_desc + j)->remote_resource_id & 15)) {
                    _L___0: /* CIL Label */ 
                    {
#line 1475
                    tmp___5 = strcmp((char const   *)option, "unmatch");
                    }
#line 1475
                    if (! (tmp___5 == 0)) {
                      {
#line 1476
                      tmp___3 = val2str((uint16_t )filetype1, ipmi_ekanalyzer_module_type);
#line 1476
                      tmp___4 = val2str((uint16_t )filetype2, ipmi_ekanalyzer_module_type);
#line 1476
                      printf((char const   */* __restrict  */)"%s port %d ==> %s port %d\n",
                             tmp___4, (record1.ch_desc + index1)->lane0port, tmp___3,
                             (record2.ch_desc + index2)->lane0port);
                      }
                    }
#line 1482
                    return_status = (int )OK_STATUS;
#line 1484
                    goto while_break___0;
                  } else {
#line 1463
                    goto _L___1;
                  }
                } else {
                  _L___1: /* CIL Label */ 
#line 1487
                  if (verbose == 7) {
                    {
#line 1488
                    printf((char const   */* __restrict  */)"No point 2 point connectivity\n");
                    }
                  }
#line 1490
                  return_status = (int )ERROR_STATUS;
                }
              } else
#line 1494
              if ((int )record2.rsc_id == (int )rsc_desc.resource_id) {
#line 1494
                if (filetype2 == ((int )(port_desc + j)->remote_resource_id & 15)) {
                  {
#line 1498
                  tmp___8 = strcmp((char const   *)option, "unmatch");
                  }
#line 1498
                  if (! (tmp___8 == 0)) {
                    {
#line 1499
                    tmp___6 = val2str((uint16_t )filetype1, ipmi_ekanalyzer_module_type);
#line 1499
                    tmp___7 = val2str((uint16_t )filetype2, ipmi_ekanalyzer_module_type);
#line 1499
                    printf((char const   */* __restrict  */)"%s port %d ==> %s port %d\n",
                           tmp___7, (record1.ch_desc + index1)->lane0port, tmp___6,
                           (record2.ch_desc + index2)->lane0port);
                    }
                  }
#line 1505
                  return_status = (int )OK_STATUS;
#line 1506
                  goto while_break___0;
                } else {
#line 1494
                  goto _L___4;
                }
              } else
              _L___4: /* CIL Label */ 
#line 1508
              if (filetype2 == ((int )rsc_desc.resource_id & 15)) {
#line 1508
                if ((int )record2.rsc_id == (int )(port_desc + j)->remote_resource_id) {
                  {
#line 1512
                  tmp___11 = strcmp((char const   *)option, "unmatch");
                  }
#line 1512
                  if (! (tmp___11 == 0)) {
                    {
#line 1513
                    tmp___9 = val2str((uint16_t )filetype1, ipmi_ekanalyzer_module_type);
#line 1513
                    tmp___10 = val2str((uint16_t )filetype2, ipmi_ekanalyzer_module_type);
#line 1513
                    printf((char const   */* __restrict  */)"%s port %d ==> %s %x port %d\n",
                           tmp___10, (record1.ch_desc + index1)->lane0port, tmp___9,
                           (int )record2.rsc_id, (record2.ch_desc + index2)->lane0port);
                    }
                  }
#line 1519
                  return_status = (int )OK_STATUS;
#line 1520
                  goto while_break___0;
                } else {
#line 1508
                  goto _L___3;
                }
              } else {
                _L___3: /* CIL Label */ 
#line 1523
                if (verbose == 7) {
                  {
#line 1524
                  printf((char const   */* __restrict  */)"No point 2 point connectivity\n");
                  }
                }
#line 1526
                return_status = (int )ERROR_STATUS;
              }
            } else {
#line 1531
              if (verbose == 7) {
                {
#line 1532
                printf((char const   */* __restrict  */)"No point 2 point connectivity\n");
                }
              }
#line 1534
              return_status = (int )ERROR_STATUS;
            }
          } else {
#line 1538
            return_status = (int )OK_STATUS;
          }
#line 1451
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 1448
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */ 
#line 1543
      if (verbose == 4) {
        {
#line 1544
        printf((char const   */* __restrict  */)"Invalid Carrier p2p connectivity record\n");
        }
      }
#line 1546
      return_status = (int )ERROR_STATUS;
    }
#line 1548
    if ((unsigned long )port_desc != (unsigned long )((void *)0)) {
      {
#line 1549
      free((void *)port_desc);
#line 1550
      port_desc = (struct fru_picmgext_carrier_p2p_descriptor *)((void *)0);
      }
    }
  }
#line 1553
  return (return_status);
}
}
#line 1606 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int flag_first_link1  ;
#line 1609 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int flag_first_link2  ;
#line 1667 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int flag_first_link1___0  ;
#line 1670 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int flag_first_link2___0  ;
#line 1579 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_compare_link(struct ipmi_ek_multi_header *physic_record , struct ipmi_ek_amc_p2p_connectivity_record record1 ,
                                struct ipmi_ek_amc_p2p_connectivity_record record2 ,
                                char *opt , int file_type1 , int file_type2 ) 
{ 
  int result ;
  int index1 ;
  int index2 ;
  void *tmp ;
  void *tmp___0 ;
  int index_ch_desc1 ;
  int index_ch_desc2 ;
  int isOEMtype ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int index_ch_desc1___0 ;
  int index_ch_desc2___0 ;
  int isOEMtype___0 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int isOEMtype___1 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 1585
  result = (int )ERROR_STATUS;
#line 1586
  index1 = 0;
#line 1587
  index2 = 0;
#line 1589
  tmp = malloc((unsigned long )record1.link_desc_count * sizeof(int ));
#line 1589
  record1.matching_result = (int *)tmp;
#line 1590
  tmp___0 = malloc((unsigned long )record2.link_desc_count * sizeof(int ));
#line 1590
  record2.matching_result = (int *)tmp___0;
#line 1592
  index2 = 0;
  }
  {
#line 1592
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1592
    if (! (index2 < (int )record2.link_desc_count)) {
#line 1592
      goto while_break;
    }
#line 1593
    *(record2.matching_result + index2) = 0;
#line 1592
    index2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1595
  index1 = 0;
  {
#line 1595
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1595
    if (! (index1 < (int )record1.link_desc_count)) {
#line 1595
      goto while_break___0;
    }
#line 1596
    index2 = 0;
    {
#line 1596
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1596
      if (! (index2 < (int )record2.link_desc_count)) {
#line 1596
        goto while_break___1;
      }
#line 1597
      if ((record1.link_desc + index1)->group_id == 0U) {
#line 1598
        if ((record2.link_desc + index2)->group_id == 0U) {
          {
#line 1599
          result = ipmi_ek_compare_link_descriptor(record1, index1, record2, index2);
          }
#line 1601
          if (result == (int )OK_STATUS) {
#line 1612
            if (index1 == 0) {
#line 1613
              flag_first_link1 = (int )(record1.link_desc + index1)->channel_id;
            }
#line 1615
            index_ch_desc1 = (int )((record1.link_desc + index1)->channel_id - (unsigned int )flag_first_link1);
#line 1617
            if (index2 == 0) {
#line 1618
              flag_first_link2 = (int )(record2.link_desc + index2)->channel_id;
            }
            {
#line 1620
            index_ch_desc2 = (int )((record2.link_desc + index2)->channel_id - (unsigned int )flag_first_link2);
#line 1623
            result = ipmi_ek_check_physical_connectivity(record1, index_ch_desc1,
                                                         record2, index_ch_desc2,
                                                         physic_record, file_type1,
                                                         file_type2, opt);
            }
#line 1626
            if (result == (int )OK_STATUS) {
              {
#line 1628
              tmp___1 = strcmp((char const   *)opt, "match");
              }
#line 1628
              if (tmp___1 == 0) {
#line 1628
                goto _L;
              } else {
                {
#line 1628
                tmp___2 = strcmp((char const   *)opt, "all");
                }
#line 1628
                if (tmp___2 == 0) {
#line 1628
                  goto _L;
                } else {
                  {
#line 1628
                  tmp___3 = strcmp((char const   *)opt, "default");
                  }
#line 1628
                  if (tmp___3 == 0) {
                    _L: /* CIL Label */ 
                    {
#line 1632
                    isOEMtype = 0;
#line 1633
                    printf((char const   */* __restrict  */)" Matching Result\n");
#line 1634
                    isOEMtype = ipmi_ek_display_link_descriptor(file_type1, record2.rsc_id,
                                                                (char *)"From", *(record2.link_desc + index2));
                    }
#line 1637
                    if (isOEMtype) {
                      {
#line 1638
                      ipmi_ek_display_oem_guid(record2);
                      }
                    }
                    {
#line 1640
                    isOEMtype = ipmi_ek_display_link_descriptor(file_type2, record1.rsc_id,
                                                                (char *)"To", *(record1.link_desc + index1));
                    }
#line 1643
                    if (isOEMtype) {
                      {
#line 1644
                      ipmi_ek_display_oem_guid(record1);
                      }
                    }
                    {
#line 1646
                    printf((char const   */* __restrict  */)"  %s\n", STAR_LINE_LIMITER);
                    }
                  }
                }
              }
#line 1648
              *(record2.matching_result + index2) = 1;
#line 1649
              *(record1.matching_result + index1) = 1;
#line 1651
              index2 = (int )record2.link_desc_count;
            }
          }
        }
      } else
#line 1659
      if ((record2.link_desc + index2)->group_id != 0U) {
        {
#line 1660
        result = ipmi_ek_compare_link_descriptor(record1, index1, record2, index2);
        }
#line 1662
        if (result == (int )OK_STATUS) {
#line 1673
          if (index1 == 0) {
#line 1674
            flag_first_link1___0 = (int )(record1.link_desc + index1)->channel_id;
          }
#line 1676
          index_ch_desc1___0 = (int )((record1.link_desc + index1)->channel_id - (unsigned int )flag_first_link1___0);
#line 1678
          if (index2 == 0) {
#line 1679
            flag_first_link2___0 = (int )(record2.link_desc + index2)->channel_id;
          }
          {
#line 1681
          index_ch_desc2___0 = (int )((record2.link_desc + index2)->channel_id - (unsigned int )flag_first_link2___0);
#line 1684
          result = ipmi_ek_check_physical_connectivity(record1, index_ch_desc1___0,
                                                       record2, index_ch_desc2___0,
                                                       physic_record, file_type1,
                                                       file_type2, opt);
          }
#line 1687
          if (result == (int )OK_STATUS) {
            {
#line 1688
            tmp___4 = strcmp((char const   *)opt, "match");
            }
#line 1688
            if (tmp___4 == 0) {
#line 1688
              goto _L___0;
            } else {
              {
#line 1688
              tmp___5 = strcmp((char const   *)opt, "all");
              }
#line 1688
              if (tmp___5 == 0) {
#line 1688
                goto _L___0;
              } else {
                {
#line 1688
                tmp___6 = strcmp((char const   *)opt, "default");
                }
#line 1688
                if (tmp___6 == 0) {
                  _L___0: /* CIL Label */ 
                  {
#line 1692
                  isOEMtype___0 = 0;
#line 1693
                  printf((char const   */* __restrict  */)"  Matching Result\n");
#line 1694
                  isOEMtype___0 = ipmi_ek_display_link_descriptor(file_type1, record2.rsc_id,
                                                                  (char *)"From",
                                                                  *(record2.link_desc + index2));
                  }
#line 1697
                  if (isOEMtype___0) {
                    {
#line 1698
                    ipmi_ek_display_oem_guid(record2);
                    }
                  }
                  {
#line 1700
                  isOEMtype___0 = ipmi_ek_display_link_descriptor(file_type2, record1.rsc_id,
                                                                  (char *)"To", *(record1.link_desc + index1));
                  }
#line 1703
                  if (isOEMtype___0) {
                    {
#line 1704
                    ipmi_ek_display_oem_guid(record1);
                    }
                  }
                  {
#line 1706
                  printf((char const   */* __restrict  */)"  %s\n", STAR_LINE_LIMITER);
                  }
                }
              }
            }
#line 1708
            *(record2.matching_result + index2) = 1;
#line 1709
            *(record1.matching_result + index1) = 1;
#line 1711
            index2 = (int )record2.link_desc_count;
          }
        }
      }
#line 1596
      index2 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1595
    index1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1719
  tmp___7 = strcmp((char const   *)opt, "unmatch");
  }
#line 1719
  if (tmp___7 == 0) {
#line 1719
    goto _L___1;
  } else {
    {
#line 1719
    tmp___8 = strcmp((char const   *)opt, "all");
    }
#line 1719
    if (tmp___8 == 0) {
      _L___1: /* CIL Label */ 
      {
#line 1720
      isOEMtype___1 = 0;
#line 1721
      printf((char const   */* __restrict  */)"  Unmatching result\n");
#line 1722
      index1 = 0;
      }
      {
#line 1722
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1722
        if (! (index1 < (int )record1.link_desc_count)) {
#line 1722
          goto while_break___2;
        }
        {
#line 1723
        isOEMtype___1 = ipmi_ek_display_link_descriptor(file_type2, record1.rsc_id,
                                                        (char *)"", *(record1.link_desc + index1));
        }
#line 1725
        if (isOEMtype___1) {
          {
#line 1726
          ipmi_ek_display_oem_guid(record1);
          }
        }
        {
#line 1728
        printf((char const   */* __restrict  */)"   %s\n", STAR_LINE_LIMITER);
#line 1722
        index1 ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1730
      index2 = 0;
      {
#line 1730
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1730
        if (! (index2 < (int )record2.link_desc_count)) {
#line 1730
          goto while_break___3;
        }
#line 1731
        if (! *(record2.matching_result + index2)) {
          {
#line 1732
          isOEMtype___1 = ipmi_ek_display_link_descriptor(file_type1, record2.rsc_id,
                                                          (char *)"", *(record2.link_desc + index2));
          }
#line 1734
          if (isOEMtype___1) {
            {
#line 1735
            ipmi_ek_display_oem_guid(record2);
            }
          }
          {
#line 1737
          printf((char const   */* __restrict  */)"   %s\n", STAR_LINE_LIMITER);
          }
        }
#line 1730
        index2 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
  {
#line 1742
  free((void *)record1.matching_result);
#line 1743
  record1.matching_result = (int *)((void *)0);
#line 1744
  free((void *)record2.matching_result);
#line 1745
  record2.matching_result = (int *)((void *)0);
  }
#line 1747
  return (result);
}
}
#line 1778 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_compare_channel_descriptor(struct fru_picmgext_amc_channel_desc_record ch_desc1 ,
                                              struct fru_picmgext_amc_channel_desc_record ch_desc2 ,
                                              struct fru_picmgext_carrier_p2p_descriptor *port_desc ,
                                              int index_port , unsigned char rsc_id ) 
{ 
  int match_lane ;

  {
#line 1785
  match_lane = 0;
#line 1788
  if (((int )rsc_id & (int )AMC_MODULE) == (int )AMC_MODULE) {
#line 1789
    if (ch_desc1.lane0port == (unsigned int )(port_desc + index_port)->local_port) {
#line 1789
      if (ch_desc2.lane0port == (unsigned int )(port_desc + index_port)->remote_port) {
#line 1794
        if (ch_desc1.lane1port != (unsigned int )DISABLE_PORT) {
#line 1795
          index_port ++;
#line 1796
          if (ch_desc1.lane1port == (unsigned int )(port_desc + index_port)->local_port) {
#line 1796
            if (ch_desc2.lane1port == (unsigned int )(port_desc + index_port)->remote_port) {
#line 1800
              if (ch_desc1.lane2port != (unsigned int )DISABLE_PORT) {
#line 1801
                index_port ++;
#line 1802
                if (ch_desc1.lane2port == (unsigned int )(port_desc + index_port)->local_port) {
#line 1802
                  if (ch_desc2.lane2port == (unsigned int )(port_desc + index_port)->remote_port) {
#line 1806
                    if (ch_desc1.lane3port != (unsigned int )DISABLE_PORT) {
#line 1807
                      index_port ++;
#line 1808
                      if (ch_desc1.lane3port == (unsigned int )(port_desc + index_port)->local_port) {
#line 1808
                        if (ch_desc2.lane3port == (unsigned int )(port_desc + index_port)->remote_port) {
#line 1814
                          match_lane = 1;
                        }
                      }
                    } else {
#line 1818
                      match_lane = 1;
                    }
                  }
                }
              } else {
#line 1823
                match_lane = 1;
              }
            }
          }
        } else {
#line 1828
          match_lane = 1;
        }
      }
    }
  } else
#line 1834
  if (ch_desc1.lane0port == (unsigned int )(port_desc + index_port)->remote_port) {
#line 1834
    if (ch_desc2.lane0port == (unsigned int )(port_desc + index_port)->local_port) {
#line 1838
      if (ch_desc1.lane1port != (unsigned int )DISABLE_PORT) {
#line 1839
        index_port ++;
#line 1840
        if (ch_desc1.lane1port == (unsigned int )(port_desc + index_port)->remote_port) {
#line 1840
          if (ch_desc2.lane1port == (unsigned int )(port_desc + index_port)->local_port) {
#line 1844
            if (ch_desc1.lane2port != (unsigned int )DISABLE_PORT) {
#line 1845
              index_port ++;
#line 1846
              if (ch_desc1.lane2port == (unsigned int )(port_desc + index_port)->remote_port) {
#line 1846
                if (ch_desc2.lane2port == (unsigned int )(port_desc + index_port)->local_port) {
#line 1850
                  if (ch_desc1.lane3port != (unsigned int )DISABLE_PORT) {
#line 1851
                    index_port ++;
#line 1852
                    if (ch_desc1.lane3port == (unsigned int )(port_desc + index_port)->remote_port) {
#line 1852
                      if (ch_desc2.lane3port == (unsigned int )(port_desc + index_port)->local_port) {
#line 1858
                        match_lane = 1;
                      }
                    }
                  } else {
#line 1862
                    match_lane = 1;
                  }
                }
              }
            } else {
#line 1867
              match_lane = 1;
            }
          }
        }
      } else {
#line 1872
        match_lane = 1;
      }
    }
  }
#line 1877
  return (match_lane);
}
}
#line 1902 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_compare_link_descriptor(struct ipmi_ek_amc_p2p_connectivity_record record1 ,
                                           int index1 , struct ipmi_ek_amc_p2p_connectivity_record record2 ,
                                           int index2 ) 
{ 
  int result ;
  int i ;
  int j ;
  int tmp ;
  unsigned char *asym ;
  unsigned long __lengthofasym ;
  void *tmp___0 ;
  int offset ;
  int tmp___1 ;
  struct fru_picmgext_amc_link_desc_record *link ;
  unsigned long __lengthoflink ;
  void *tmp___2 ;
  int index___0 ;
  int tmp___3 ;

  {
#line 1907
  result = (int )ERROR_STATUS;
#line 1909
  if ((record1.link_desc + index1)->type == (record2.link_desc + index2)->type) {
#line 1911
    if ((record1.link_desc + index1)->type >= (unsigned int )LOWER_OEM_TYPE) {
#line 1911
      if ((record1.link_desc + index1)->type <= (unsigned int )UPPER_OEM_TYPE) {
#line 1914
        if ((int )record1.guid_count == 0) {
#line 1914
          if ((int )record2.guid_count == 0) {
#line 1916
            result = (int )OK_STATUS;
          } else {
#line 1914
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 1919
          i = 0;
#line 1920
          j = 0;
#line 1922
          i = 0;
          {
#line 1922
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1922
            if (! (i < (int )record1.guid_count)) {
#line 1922
              goto while_break;
            }
#line 1923
            j = 0;
            {
#line 1923
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 1923
              if (! (j < (int )record2.guid_count)) {
#line 1923
                goto while_break___0;
              }
              {
#line 1924
              tmp = memcmp((void const   *)(record1.oem_guid + i), (void const   *)(record2.oem_guid + j),
                           (size_t )16);
              }
#line 1924
              if (tmp == 0) {
#line 1928
                result = (int )OK_STATUS;
#line 1929
                goto while_break___0;
              }
#line 1923
              j ++;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 1922
            i ++;
          }
          while_break: /* CIL Label */ ;
          }
        }
      } else {
#line 1936
        result = (int )OK_STATUS;
      }
    } else {
#line 1936
      result = (int )OK_STATUS;
    }
#line 1938
    if (result == (int )OK_STATUS) {
#line 1939
      if ((record1.link_desc + index1)->type_ext == (record2.link_desc + index2)->type_ext) {
        {
#line 1942
        __lengthofasym = (unsigned long )COMPARE_CANDIDATE;
#line 1942
        tmp___0 = __builtin_alloca(sizeof(*asym) * __lengthofasym);
#line 1942
        asym = (unsigned char *)tmp___0;
#line 1943
        offset = 0;
#line 1945
        tmp___1 = offset;
#line 1945
        offset ++;
#line 1945
        *(asym + tmp___1) = (unsigned char )(record1.link_desc + index1)->asym_match;
#line 1946
        *(asym + offset) = (unsigned char )(record2.link_desc + index2)->asym_match;
#line 1947
        result = ipmi_ek_compare_asym((unsigned char *)asym);
        }
#line 1948
        if (result == (int )OK_STATUS) {
          {
#line 1949
          __lengthoflink = (unsigned long )COMPARE_CANDIDATE;
#line 1949
          tmp___2 = __builtin_alloca(sizeof(*link) * __lengthoflink);
#line 1949
          link = (struct fru_picmgext_amc_link_desc_record *)tmp___2;
#line 1950
          index___0 = 0;
#line 1952
          tmp___3 = index___0;
#line 1952
          index___0 ++;
#line 1952
          *(link + tmp___3) = *(record1.link_desc + index1);
#line 1953
          *(link + index___0) = *(record2.link_desc + index2);
#line 1954
          result = ipmi_ek_compare_number_of_enable_port((struct fru_picmgext_amc_link_desc_record *)link);
          }
        } else {
#line 1957
          result = (int )ERROR_STATUS;
        }
      } else {
#line 1961
        result = (int )ERROR_STATUS;
      }
    }
  } else {
#line 1966
    result = (int )ERROR_STATUS;
  }
#line 1969
  return (result);
}
}
#line 1991 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_compare_asym(unsigned char *asym ) 
{ 
  int return_value ;
  int first_index ;
  int second_index ;

  {
#line 1994
  return_value = (int )ERROR_STATUS;
#line 1995
  first_index = 0;
#line 1996
  second_index = 1;
#line 1998
  if ((int )*(asym + first_index) == 0) {
#line 1998
    if ((int )*(asym + second_index) == 0) {
#line 1999
      return_value = (int )OK_STATUS;
    } else {
#line 1998
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2001
  if (((int )*(asym + first_index) & (int )*(asym + second_index)) == 0) {
#line 2002
    return_value = (int )OK_STATUS;
  } else {
#line 2005
    return_value = (int )ERROR_STATUS;
  }
#line 2007
  return (return_value);
}
}
#line 2028 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_compare_number_of_enable_port(struct fru_picmgext_amc_link_desc_record *link_desc ) 
{ 
  int amc_port_count ;
  int carrier_port_count ;
  int return_value ;
  int index___0 ;
  int tmp ;

  {
#line 2032
  amc_port_count = 0;
#line 2033
  carrier_port_count = 0;
#line 2034
  return_value = (int )ERROR_STATUS;
#line 2035
  index___0 = 0;
#line 2037
  if ((link_desc + index___0)->port_flag_0) {
#line 2038
    amc_port_count ++;
  }
#line 2040
  if ((link_desc + index___0)->port_flag_1) {
#line 2041
    amc_port_count ++;
  }
#line 2043
  if ((link_desc + index___0)->port_flag_2) {
#line 2044
    amc_port_count ++;
  }
#line 2046
  tmp = index___0;
#line 2046
  index___0 ++;
#line 2046
  if ((link_desc + tmp)->port_flag_3) {
#line 2047
    amc_port_count ++;
  }
#line 2051
  if ((link_desc + index___0)->port_flag_0) {
#line 2052
    carrier_port_count ++;
  }
#line 2054
  if ((link_desc + index___0)->port_flag_1) {
#line 2055
    carrier_port_count ++;
  }
#line 2057
  if ((link_desc + index___0)->port_flag_2) {
#line 2058
    carrier_port_count ++;
  }
#line 2060
  if ((link_desc + index___0)->port_flag_3) {
#line 2061
    carrier_port_count ++;
  }
#line 2064
  if (carrier_port_count == amc_port_count) {
#line 2066
    return_value = (int )OK_STATUS;
  } else {
#line 2069
    return_value = (int )ERROR_STATUS;
  }
#line 2072
  return (return_value);
}
}
#line 2098 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_display_link_descriptor(int file_type , unsigned char rsc_id ,
                                           char *str___1 , struct fru_picmgext_amc_link_desc_record link_desc ) 
{ 
  int isOEMtype ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;

  {
#line 2102
  isOEMtype = 0;
#line 2104
  if (file_type == 9) {
    {
#line 2105
    printf((char const   */* __restrict  */)"  - %s On-Carrier Device ID %d\n", str___1,
           (int )rsc_id & 15);
    }
  } else {
    {
#line 2108
    tmp = val2str((uint16_t )file_type, ipmi_ekanalyzer_module_type);
#line 2108
    printf((char const   */* __restrict  */)"  - %s %s\n", str___1, tmp);
    }
  }
  {
#line 2112
  printf((char const   */* __restrict  */)"    - Channel ID %d || ", link_desc.channel_id);
  }
#line 2113
  if (link_desc.port_flag_0) {
#line 2113
    tmp___0 = "Lane 0: enable";
  } else {
#line 2113
    tmp___0 = "";
  }
  {
#line 2113
  printf((char const   */* __restrict  */)"%s", tmp___0);
  }
#line 2114
  if (link_desc.port_flag_1) {
#line 2114
    tmp___1 = ", Lane 1: enable";
  } else {
#line 2114
    tmp___1 = "";
  }
  {
#line 2114
  printf((char const   */* __restrict  */)"%s", tmp___1);
  }
#line 2115
  if (link_desc.port_flag_2) {
#line 2115
    tmp___2 = ", Lane 2: enable";
  } else {
#line 2115
    tmp___2 = "";
  }
  {
#line 2115
  printf((char const   */* __restrict  */)"%s", tmp___2);
  }
#line 2116
  if (link_desc.port_flag_3) {
#line 2116
    tmp___3 = ", Lane 3: enable";
  } else {
#line 2116
    tmp___3 = "";
  }
  {
#line 2116
  printf((char const   */* __restrict  */)"%s", tmp___3);
#line 2118
  printf((char const   */* __restrict  */)"\n");
#line 2119
  tmp___4 = val2str((uint16_t )link_desc.type, ipmi_ekanalyzer_link_type);
#line 2119
  printf((char const   */* __restrict  */)"    - Link Type: %s \n", tmp___4);
  }
  {
#line 2124
  if (link_desc.type == 4U) {
#line 2124
    goto case_4;
  }
#line 2124
  if (link_desc.type == 3U) {
#line 2124
    goto case_4;
  }
#line 2124
  if (link_desc.type == 2U) {
#line 2124
    goto case_4;
  }
#line 2132
  if (link_desc.type == 5U) {
#line 2132
    goto case_5;
  }
#line 2140
  if (link_desc.type == 7U) {
#line 2140
    goto case_7;
  }
#line 2148
  goto switch_default;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 2125
  tmp___5 = val2str((uint16_t )link_desc.type_ext, ipmi_ekanalyzer_extension_PCIE);
#line 2125
  printf((char const   */* __restrict  */)"    - Link Type extension: %s\n", tmp___5);
#line 2127
  printf((char const   */* __restrict  */)"    - Link Group ID: %d || ", link_desc.group_id);
#line 2128
  tmp___6 = val2str((uint16_t )link_desc.asym_match, ipmi_ekanalyzer_asym_PCIE);
#line 2128
  printf((char const   */* __restrict  */)"Link Asym. Match: %d - %s\n", link_desc.asym_match,
         tmp___6);
  }
#line 2131
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 2133
  tmp___7 = val2str((uint16_t )link_desc.type_ext, ipmi_ekanalyzer_extension_ETHERNET);
#line 2133
  printf((char const   */* __restrict  */)"    - Link Type extension: %s\n", tmp___7);
#line 2135
  printf((char const   */* __restrict  */)"    - Link Group ID: %d || ", link_desc.group_id);
#line 2136
  tmp___8 = val2str((uint16_t )link_desc.asym_match, ipmi_ekanalyzer_asym_PCIE);
#line 2136
  printf((char const   */* __restrict  */)"Link Asym. Match: %d - %s\n", link_desc.asym_match,
         tmp___8);
  }
#line 2139
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 2141
  tmp___9 = val2str((uint16_t )link_desc.type_ext, ipmi_ekanalyzer_extension_STORAGE);
#line 2141
  printf((char const   */* __restrict  */)"    - Link Type extension: %s\n", tmp___9);
#line 2143
  printf((char const   */* __restrict  */)"    - Link Group ID: %d || ", link_desc.group_id);
#line 2144
  tmp___10 = val2str((uint16_t )link_desc.asym_match, ipmi_ekanalyzer_asym_STORAGE);
#line 2144
  printf((char const   */* __restrict  */)"Link Asym. Match: %d - %s\n", link_desc.asym_match,
         tmp___10);
  }
#line 2147
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2149
  printf((char const   */* __restrict  */)"    - Link Type extension: %i\n", link_desc.type_ext);
#line 2150
  printf((char const   */* __restrict  */)"    - Link Group ID: %d || ", link_desc.group_id);
#line 2151
  printf((char const   */* __restrict  */)"Link Asym. Match: %i\n", link_desc.asym_match);
  }
#line 2152
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2155
  if (link_desc.type >= (unsigned int )LOWER_OEM_TYPE) {
#line 2155
    if (link_desc.type <= (unsigned int )UPPER_OEM_TYPE) {
#line 2159
      isOEMtype = 1;
    }
  }
#line 2162
  return (isOEMtype);
}
}
#line 2182 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_oem_guid(struct ipmi_ek_amc_p2p_connectivity_record amc_record ) 
{ 
  int index_oem ;
  int index___0 ;

  {
#line 2186
  index_oem = 0;
#line 2187
  index___0 = 0;
#line 2189
  if ((int )amc_record.guid_count == 0) {
    {
#line 2190
    printf((char const   */* __restrict  */)"\tThere is no OEM GUID for this module\n");
    }
  }
#line 2192
  index_oem = 0;
  {
#line 2192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2192
    if (! (index_oem < (int )amc_record.guid_count)) {
#line 2192
      goto while_break;
    }
    {
#line 2193
    printf((char const   */* __restrict  */)"    - GUID: ");
#line 2194
    index___0 = 0;
    }
    {
#line 2194
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2194
      if (! (index___0 < 16)) {
#line 2194
        goto while_break___0;
      }
      {
#line 2195
      printf((char const   */* __restrict  */)"%02x", (int )(amc_record.oem_guid + index_oem)->guid[index___0]);
      }
#line 2197
      if (! (index___0 % 4)) {
        {
#line 2198
        printf((char const   */* __restrict  */)"-");
        }
      }
#line 2194
      index___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2201
    printf((char const   */* __restrict  */)"\n");
#line 2192
    index_oem ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2203
  return;
}
}
#line 2224 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_create_amc_p2p_record(struct ipmi_ek_multi_header *record , struct ipmi_ek_amc_p2p_connectivity_record *amc_record ) 
{ 
  int index_data ;
  int return_status ;
  int tmp ;
  int index_oem ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int ch_index ;
  void *tmp___5 ;
  unsigned int data ;
  struct fru_picmgext_amc_channel_desc_record *src ;
  struct fru_picmgext_amc_channel_desc_record *dst ;
  int i ;
  void *tmp___6 ;
  unsigned int data___0[2] ;
  struct fru_picmgext_amc_link_desc_record *src___0 ;
  struct fru_picmgext_amc_link_desc_record *dst___0 ;

  {
#line 2228
  index_data = (int )START_DATA_OFFSET;
#line 2229
  return_status = (int )OK_STATUS;
#line 2231
  tmp = index_data;
#line 2231
  index_data ++;
#line 2231
  amc_record->guid_count = *(record->data + tmp);
#line 2232
  if ((int )amc_record->guid_count > 0) {
    {
#line 2233
    index_oem = 0;
#line 2234
    tmp___0 = malloc((unsigned long )amc_record->guid_count * sizeof(struct fru_picmgext_guid ));
#line 2234
    amc_record->oem_guid = (struct fru_picmgext_guid *)tmp___0;
#line 2236
    index_oem = 0;
    }
    {
#line 2236
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2236
      if (! (index_oem < (int )amc_record->guid_count)) {
#line 2236
        goto while_break;
      }
      {
#line 2238
      memcpy((void */* __restrict  */)(& (amc_record->oem_guid + index_oem)->guid),
             (void const   */* __restrict  */)(record->data + index_data), (size_t )16);
#line 2241
      index_data += 16;
#line 2236
      index_oem ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2243
    tmp___1 = index_data;
#line 2243
    index_data ++;
#line 2243
    amc_record->rsc_id = *(record->data + tmp___1);
#line 2244
    tmp___2 = index_data;
#line 2244
    index_data ++;
#line 2244
    amc_record->ch_count = *(record->data + tmp___2);
#line 2246
    amc_record->link_desc_count = (unsigned char )(((((int )record->header.len - 8) - 16 * (int )amc_record->guid_count) - 3 * (int )amc_record->ch_count) / 5);
  } else {
#line 2251
    tmp___3 = index_data;
#line 2251
    index_data ++;
#line 2251
    amc_record->rsc_id = *(record->data + tmp___3);
#line 2252
    tmp___4 = index_data;
#line 2252
    index_data ++;
#line 2252
    amc_record->ch_count = *(record->data + tmp___4);
#line 2254
    amc_record->link_desc_count = (unsigned char )((((int )record->header.len - 8) - 3 * (int )amc_record->ch_count) / 5);
  }
#line 2259
  if ((int )amc_record->ch_count > 0) {
    {
#line 2260
    ch_index = 0;
#line 2261
    tmp___5 = malloc((unsigned long )amc_record->ch_count * sizeof(struct fru_picmgext_amc_channel_desc_record ));
#line 2261
    amc_record->ch_desc = (struct fru_picmgext_amc_channel_desc_record *)tmp___5;
#line 2263
    ch_index = 0;
    }
    {
#line 2263
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2263
      if (! (ch_index < (int )amc_record->ch_count)) {
#line 2263
        goto while_break___0;
      }
#line 2267
      data = (unsigned int )(((int )*(record->data + index_data) | ((int )*(record->data + (index_data + 1)) << 8)) | ((int )*(record->data + (index_data + 2)) << 16));
#line 2271
      src = (struct fru_picmgext_amc_channel_desc_record *)(& data);
#line 2272
      dst = amc_record->ch_desc + ch_index;
#line 2275
      dst->lane0port = src->lane0port;
#line 2276
      dst->lane1port = src->lane1port;
#line 2277
      dst->lane2port = src->lane2port;
#line 2278
      dst->lane3port = src->lane3port;
#line 2279
      index_data += 3;
#line 2263
      ch_index ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2282
  if ((int )amc_record->link_desc_count > 0) {
    {
#line 2283
    i = 0;
#line 2284
    tmp___6 = malloc((unsigned long )amc_record->link_desc_count * sizeof(struct fru_picmgext_amc_link_desc_record ));
#line 2284
    amc_record->link_desc = (struct fru_picmgext_amc_link_desc_record *)tmp___6;
#line 2286
    i = 0;
    }
    {
#line 2286
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2286
      if (! (i < (int )amc_record->link_desc_count)) {
#line 2286
        goto while_break___1;
      }
#line 2289
      data___0[0] = (unsigned int )((((int )*(record->data + index_data) | ((int )*(record->data + (index_data + 1)) << 8)) | ((int )*(record->data + (index_data + 2)) << 16)) | ((int )*(record->data + (index_data + 3)) << 24));
#line 2294
      data___0[1] = (unsigned int )*(record->data + (index_data + 4));
#line 2295
      src___0 = (struct fru_picmgext_amc_link_desc_record *)(& data___0);
#line 2296
      dst___0 = amc_record->link_desc + i;
#line 2299
      dst___0->channel_id = src___0->channel_id;
#line 2300
      dst___0->port_flag_0 = src___0->port_flag_0;
#line 2301
      dst___0->port_flag_1 = src___0->port_flag_1;
#line 2302
      dst___0->port_flag_2 = src___0->port_flag_2;
#line 2303
      dst___0->port_flag_3 = src___0->port_flag_3;
#line 2304
      dst___0->type = src___0->type;
#line 2305
      dst___0->type_ext = src___0->type_ext;
#line 2306
      dst___0->group_id = src___0->group_id;
#line 2307
      dst___0->asym_match = src___0->asym_match;
#line 2308
      index_data += 5;
#line 2286
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 2311
    return_status = (int )ERROR_STATUS;
  }
#line 2313
  return (return_status);
}
}
#line 2336 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_get_resource_descriptor(int port_count , int index___0 , struct fru_picmgext_carrier_p2p_descriptor *port_desc ,
                                           struct ipmi_ek_multi_header *record ) 
{ 
  int num_port ;

  {
#line 2341
  num_port = 0;
  {
#line 2343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2343
    if (! (num_port < port_count)) {
#line 2343
      goto while_break;
    }
    {
#line 2344
    memcpy((void */* __restrict  */)(port_desc + num_port), (void const   */* __restrict  */)(record->data + index___0),
           sizeof(struct fru_picmgext_carrier_p2p_descriptor ));
#line 2346
    index___0 = (int )((unsigned long )index___0 + sizeof(struct fru_picmgext_carrier_p2p_descriptor ));
#line 2347
    num_port ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2350
  return (index___0);
}
}
#line 2371 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_display_fru_header(char *filename ) 
{ 
  FILE *input_file ;
  struct fru_header header ;
  int ret ;
  size_t tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 2376
  ret = 0;
#line 2378
  input_file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 2379
  if ((unsigned long )input_file == (unsigned long )((void *)0)) {
    {
#line 2380
    lprintf(3, "File \'%s\' not found.", filename);
    }
#line 2381
    return ((int )ERROR_STATUS);
  }
  {
#line 2383
  tmp = fread((void */* __restrict  */)(& header), sizeof(struct fru_header ), (size_t )1,
              (FILE */* __restrict  */)input_file);
#line 2383
  ret = (int )tmp;
  }
#line 2384
  if (ret != 1) {
    {
#line 2385
    lprintf(3, "Failed to read FRU header!");
#line 2386
    fclose(input_file);
    }
#line 2387
    return ((int )ERROR_STATUS);
  } else {
    {
#line 2384
    tmp___0 = ferror(input_file);
    }
#line 2384
    if (tmp___0) {
      {
#line 2385
      lprintf(3, "Failed to read FRU header!");
#line 2386
      fclose(input_file);
      }
#line 2387
      return ((int )ERROR_STATUS);
    }
  }
  {
#line 2389
  printf((char const   */* __restrict  */)"%s\n", EQUAL_LINE_LIMITER);
#line 2390
  printf((char const   */* __restrict  */)"FRU Header Info\n");
#line 2391
  printf((char const   */* __restrict  */)"%s\n", EQUAL_LINE_LIMITER);
  }
#line 2392
  if (((int )header.version & 15) == 1) {
#line 2392
    tmp___1 = "";
  } else {
#line 2392
    tmp___1 = "{unsupported}";
  }
  {
#line 2392
  printf((char const   */* __restrict  */)"Format Version          :0x%02x %s\n",
         (int )header.version & 15, tmp___1);
#line 2395
  printf((char const   */* __restrict  */)"Internal Use Offset     :0x%02x\n", (int )header.offset.internal);
#line 2396
  printf((char const   */* __restrict  */)"Chassis Info Offset     :0x%02x\n", (int )header.offset.chassis);
#line 2397
  printf((char const   */* __restrict  */)"Board Info Offset       :0x%02x\n", (int )header.offset.board);
#line 2398
  printf((char const   */* __restrict  */)"Product Info Offset     :0x%02x\n", (int )header.offset.product);
#line 2399
  printf((char const   */* __restrict  */)"MultiRecord Offset      :0x%02x\n", (int )header.offset.multi);
#line 2400
  printf((char const   */* __restrict  */)"Common header Checksum  :0x%02x\n", (int )header.checksum);
#line 2402
  fclose(input_file);
  }
#line 2403
  return ((int )OK_STATUS);
}
}
#line 2426 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_display_fru_header_detail(char *filename ) 
{ 
  FILE *input_file ;
  size_t file_offset ;
  struct fru_header header ;
  time_t tval ;
  int ret ;
  unsigned char data ;
  unsigned char lan_code ;
  unsigned char mfg_date[3] ;
  unsigned int board_length ;
  size_t tmp ;
  int tmp___0 ;
  unsigned char format_version ;
  unsigned long len ;
  size_t tmp___1 ;
  int tmp___2 ;
  unsigned char data___0 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long offset ;
  int tmp___7 ;
  long tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  struct tm *tmp___19 ;
  char *tmp___20 ;
  long offset___0 ;
  int tmp___21 ;

  {
  {
#line 2432
  file_offset = (size_t )0;
#line 2435
  ret = 0;
#line 2436
  data = (unsigned char)0;
#line 2437
  lan_code = (unsigned char)0;
#line 2439
  board_length = 0U;
#line 2441
  input_file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 2442
  if ((unsigned long )input_file == (unsigned long )((void *)0)) {
    {
#line 2443
    lprintf(3, "File \'%s\' not found.", filename);
    }
#line 2444
    return (-1);
  }
  {
#line 2450
  tmp = fread((void */* __restrict  */)(& header), sizeof(struct fru_header ), (size_t )1,
              (FILE */* __restrict  */)input_file);
#line 2450
  ret = (int )tmp;
  }
#line 2451
  if (ret != 1) {
    {
#line 2452
    lprintf(3, "Failed to read FRU header!");
#line 2453
    fclose(input_file);
    }
#line 2454
    return (-1);
  } else {
    {
#line 2451
    tmp___0 = ferror(input_file);
    }
#line 2451
    if (tmp___0) {
      {
#line 2452
      lprintf(3, "Failed to read FRU header!");
#line 2453
      fclose(input_file);
      }
#line 2454
      return (-1);
    }
  }
  {
#line 2457
  tmp___6 = feof(input_file);
  }
#line 2457
  if (! tmp___6) {
    {
#line 2459
    len = 0UL;
#line 2461
    printf((char const   */* __restrict  */)"%s\n", EQUAL_LINE_LIMITER);
#line 2462
    printf((char const   */* __restrict  */)"FRU Internal Use Info\n");
#line 2463
    printf((char const   */* __restrict  */)"%s\n", EQUAL_LINE_LIMITER);
#line 2465
    tmp___1 = fread((void */* __restrict  */)(& format_version), (size_t )1, (size_t )1,
                    (FILE */* __restrict  */)input_file);
#line 2465
    ret = (int )tmp___1;
    }
#line 2466
    if (ret != 1) {
      {
#line 2467
      lprintf(3, "Invalid format version!");
#line 2468
      fclose(input_file);
      }
#line 2469
      return (-1);
    } else {
      {
#line 2466
      tmp___2 = ferror(input_file);
      }
#line 2466
      if (tmp___2) {
        {
#line 2467
        lprintf(3, "Invalid format version!");
#line 2468
        fclose(input_file);
        }
#line 2469
        return (-1);
      }
    }
    {
#line 2471
    printf((char const   */* __restrict  */)"Format Version: %d\n", (int )format_version & 15);
    }
#line 2473
    if ((int )header.offset.chassis > 0) {
#line 2474
      len = (unsigned long )((int )header.offset.chassis * 8 - (int )header.offset.internal * 8);
    } else {
#line 2477
      len = (unsigned long )((int )header.offset.board * 8 - (int )header.offset.internal * 8);
    }
    {
#line 2480
    printf((char const   */* __restrict  */)"Length: %ld\n", len);
#line 2481
    printf((char const   */* __restrict  */)"Data dump:\n");
    }
    {
#line 2482
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2482
      if (len > 0UL) {
        {
#line 2482
        tmp___5 = feof(input_file);
        }
#line 2482
        if (tmp___5) {
#line 2482
          goto while_break;
        }
      } else {
#line 2482
        goto while_break;
      }
      {
#line 2484
      tmp___3 = fread((void */* __restrict  */)(& data___0), (size_t )1, (size_t )1,
                      (FILE */* __restrict  */)input_file);
#line 2484
      ret = (int )tmp___3;
      }
#line 2485
      if (ret != 1) {
        {
#line 2486
        lprintf(3, "Invalid data!");
#line 2487
        fclose(input_file);
        }
#line 2488
        return (-1);
      } else {
        {
#line 2485
        tmp___4 = ferror(input_file);
        }
#line 2485
        if (tmp___4) {
          {
#line 2486
          lprintf(3, "Invalid data!");
#line 2487
          fclose(input_file);
          }
#line 2488
          return (-1);
        }
      }
      {
#line 2490
      printf((char const   */* __restrict  */)"0x%02x ", (int )data___0);
#line 2491
      len --;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2493
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 2496
  if ((int )header.offset.chassis != 0) {
    {
#line 2497
    offset = 0L;
#line 2498
    offset = (long )((int )header.offset.chassis * 8);
#line 2499
    ret = ipmi_ek_display_chassis_info_area(input_file, offset);
    }
  }
  {
#line 2502
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2503
    if ((int )header.offset.board == 0) {
#line 2504
      goto while_break___0;
    }
    {
#line 2506
    ret = fseek(input_file, (long )((int )header.offset.board * 8), 0);
#line 2509
    tmp___7 = feof(input_file);
    }
#line 2509
    if (tmp___7) {
#line 2510
      goto while_break___0;
    }
    {
#line 2512
    tmp___8 = ftell(input_file);
#line 2512
    file_offset = (size_t )tmp___8;
#line 2513
    printf((char const   */* __restrict  */)"%s\n", EQUAL_LINE_LIMITER);
#line 2514
    printf((char const   */* __restrict  */)"FRU Board Info Area\n");
#line 2515
    printf((char const   */* __restrict  */)"%s\n", EQUAL_LINE_LIMITER);
#line 2517
    tmp___9 = fread((void */* __restrict  */)(& data), (size_t )1, (size_t )1, (FILE */* __restrict  */)input_file);
#line 2517
    ret = (int )tmp___9;
    }
#line 2518
    if (ret != 1) {
      {
#line 2519
      lprintf(3, "Invalid FRU Format Version!");
#line 2520
      fclose(input_file);
      }
#line 2521
      return (-1);
    } else {
      {
#line 2518
      tmp___10 = ferror(input_file);
      }
#line 2518
      if (tmp___10) {
        {
#line 2519
        lprintf(3, "Invalid FRU Format Version!");
#line 2520
        fclose(input_file);
        }
#line 2521
        return (-1);
      }
    }
    {
#line 2523
    printf((char const   */* __restrict  */)"Format Version: %d\n", (int )data & 15);
#line 2524
    tmp___11 = feof(input_file);
    }
#line 2524
    if (tmp___11) {
#line 2525
      goto while_break___0;
    }
    {
#line 2527
    tmp___12 = fread((void */* __restrict  */)(& data), (size_t )1, (size_t )1, (FILE */* __restrict  */)input_file);
#line 2527
    ret = (int )tmp___12;
    }
#line 2528
    if (ret != 1) {
      {
#line 2529
      lprintf(3, "Invalid Board Area Length!");
#line 2530
      fclose(input_file);
      }
#line 2531
      return (-1);
    } else {
      {
#line 2528
      tmp___13 = ferror(input_file);
      }
#line 2528
      if (tmp___13) {
        {
#line 2529
        lprintf(3, "Invalid Board Area Length!");
#line 2530
        fclose(input_file);
        }
#line 2531
        return (-1);
      }
    }
    {
#line 2533
    board_length = (unsigned int )((int )data * 8);
#line 2534
    printf((char const   */* __restrict  */)"Area Length: %d\n", board_length);
#line 2539
    board_length -= 2U;
#line 2540
    tmp___14 = feof(input_file);
    }
#line 2540
    if (tmp___14) {
#line 2541
      goto while_break___0;
    }
    {
#line 2543
    tmp___15 = fread((void */* __restrict  */)(& lan_code), (size_t )1, (size_t )1,
                     (FILE */* __restrict  */)input_file);
#line 2543
    ret = (int )tmp___15;
    }
#line 2544
    if (ret != 1) {
      {
#line 2545
      lprintf(3, "Invalid Language Code in input");
#line 2546
      fclose(input_file);
      }
#line 2547
      return (-1);
    } else {
      {
#line 2544
      tmp___16 = ferror(input_file);
      }
#line 2544
      if (tmp___16) {
        {
#line 2545
        lprintf(3, "Invalid Language Code in input");
#line 2546
        fclose(input_file);
        }
#line 2547
        return (-1);
      }
    }
    {
#line 2549
    printf((char const   */* __restrict  */)"Language Code: %d\n", (int )lan_code);
#line 2550
    board_length --;
#line 2552
    tmp___17 = feof(input_file);
    }
#line 2552
    if (tmp___17) {
#line 2553
      goto while_break___0;
    }
    {
#line 2556
    tmp___18 = fread((void */* __restrict  */)(mfg_date), (size_t )3, (size_t )1,
                     (FILE */* __restrict  */)input_file);
#line 2556
    ret = (int )tmp___18;
    }
#line 2557
    if (ret != 1) {
      {
#line 2558
      lprintf(3, "Invalid Board Data.");
#line 2559
      fclose(input_file);
      }
#line 2560
      return (-1);
    }
    {
#line 2562
    tval = (time_t )((((int )mfg_date[2] << 16) + ((int )mfg_date[1] << 8)) + (int )mfg_date[0]);
#line 2564
    tval *= 60L;
#line 2565
    tval = (time_t )((unsigned long const   )tval + secs_from_1970_1996___0);
#line 2566
    tmp___19 = localtime((time_t const   *)(& tval));
#line 2566
    tmp___20 = asctime((struct tm  const  *)tmp___19);
#line 2566
    printf((char const   */* __restrict  */)"Board Mfg Date: %ld, %s", tval, tmp___20);
#line 2568
    board_length -= 3U;
#line 2570
    file_offset = ipmi_ek_display_board_info_area(input_file, (char *)"Board Manufacture Data",
                                                  & board_length);
#line 2572
    ret = fseek(input_file, (long )file_offset, 0);
#line 2574
    file_offset = ipmi_ek_display_board_info_area(input_file, (char *)"Board Product Name",
                                                  & board_length);
#line 2576
    ret = fseek(input_file, (long )file_offset, 0);
#line 2578
    file_offset = ipmi_ek_display_board_info_area(input_file, (char *)"Board Serial Number",
                                                  & board_length);
#line 2580
    ret = fseek(input_file, (long )file_offset, 0);
#line 2582
    file_offset = ipmi_ek_display_board_info_area(input_file, (char *)"Board Part Number",
                                                  & board_length);
#line 2584
    ret = fseek(input_file, (long )file_offset, 0);
#line 2586
    file_offset = ipmi_ek_display_board_info_area(input_file, (char *)"FRU File ID",
                                                  & board_length);
#line 2588
    ret = fseek(input_file, (long )file_offset, 0);
#line 2590
    file_offset = ipmi_ek_display_board_info_area(input_file, (char *)"Custom", & board_length);
    }
#line 2592
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2595
  if (header.offset.product) {
    {
#line 2595
    tmp___21 = feof(input_file);
    }
#line 2595
    if (! tmp___21) {
      {
#line 2596
      offset___0 = 0L;
#line 2597
      offset___0 = (long )((int )header.offset.product * 8);
#line 2598
      ret = ipmi_ek_display_product_info_area(input_file, offset___0);
      }
    }
  }
  {
#line 2601
  fclose(input_file);
  }
#line 2602
  return (0);
}
}
#line 2625 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_display_chassis_info_area(FILE *input_file , long offset ) 
{ 
  size_t file_offset ;
  int ret ;
  unsigned char data ;
  unsigned char ch_len ;
  unsigned char ch_type ;
  unsigned int len ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
#line 2629
  ret = 0;
#line 2630
  data = (unsigned char)0;
#line 2631
  ch_len = (unsigned char)0;
#line 2632
  ch_type = (unsigned char)0;
#line 2635
  if ((unsigned long )input_file == (unsigned long )((void *)0)) {
    {
#line 2636
    lprintf(3, "No file stream to read.");
    }
#line 2637
    return (-1);
  }
  {
#line 2639
  printf((char const   */* __restrict  */)"%s\n", EQUAL_LINE_LIMITER);
#line 2640
  printf((char const   */* __restrict  */)"Chassis Info Area\n");
#line 2641
  printf((char const   */* __restrict  */)"%s\n", EQUAL_LINE_LIMITER);
#line 2642
  ret = fseek(input_file, offset, 0);
#line 2643
  tmp = feof(input_file);
  }
#line 2643
  if (tmp) {
    {
#line 2644
    lprintf(3, "Invalid Chassis Info Area!");
    }
#line 2645
    return (-1);
  }
  {
#line 2647
  tmp___0 = fread((void */* __restrict  */)(& data), (size_t )1, (size_t )1, (FILE */* __restrict  */)input_file);
#line 2647
  ret = (int )tmp___0;
  }
#line 2648
  if (ret != 1) {
    {
#line 2649
    lprintf(3, "Invalid Version Number!");
    }
#line 2650
    return (-1);
  } else {
    {
#line 2648
    tmp___1 = ferror(input_file);
    }
#line 2648
    if (tmp___1) {
      {
#line 2649
      lprintf(3, "Invalid Version Number!");
      }
#line 2650
      return (-1);
    }
  }
  {
#line 2652
  printf((char const   */* __restrict  */)"Format Version Number: %d\n", (int )data & 15);
#line 2653
  tmp___2 = fread((void */* __restrict  */)(& ch_len), (size_t )1, (size_t )1, (FILE */* __restrict  */)input_file);
#line 2653
  ret = (int )tmp___2;
  }
#line 2654
  if (ret != 1) {
    {
#line 2655
    lprintf(3, "Invalid length!");
    }
#line 2656
    return (-1);
  } else {
    {
#line 2654
    tmp___3 = ferror(input_file);
    }
#line 2654
    if (tmp___3) {
      {
#line 2655
      lprintf(3, "Invalid length!");
      }
#line 2656
      return (-1);
    }
  }
  {
#line 2659
  len = (unsigned int )((int )ch_len * 8);
#line 2660
  printf((char const   */* __restrict  */)"Area Length: %d\n", len);
#line 2661
  len -= 2U;
#line 2662
  tmp___4 = feof(input_file);
  }
#line 2662
  if (tmp___4) {
#line 2663
    return (-1);
  }
  {
#line 2666
  tmp___5 = fread((void */* __restrict  */)(& ch_type), (size_t )1, (size_t )1, (FILE */* __restrict  */)input_file);
#line 2666
  ret = (int )tmp___5;
  }
#line 2667
  if (ret != 1) {
    {
#line 2668
    lprintf(3, "Invalid Chassis Type!");
    }
#line 2669
    return (-1);
  } else {
    {
#line 2667
    tmp___6 = ferror(input_file);
    }
#line 2667
    if (tmp___6) {
      {
#line 2668
      lprintf(3, "Invalid Chassis Type!");
      }
#line 2669
      return (-1);
    }
  }
  {
#line 2671
  printf((char const   */* __restrict  */)"Chassis Type: %d\n", (int )ch_type);
#line 2672
  len --;
#line 2674
  file_offset = ipmi_ek_display_board_info_area(input_file, (char *)"Chassis Part Number",
                                                & len);
#line 2676
  ret = fseek(input_file, (long )file_offset, 0);
#line 2678
  file_offset = ipmi_ek_display_board_info_area(input_file, (char *)"Chassis Serial Number",
                                                & len);
#line 2680
  ret = fseek(input_file, (long )file_offset, 0);
#line 2682
  file_offset = ipmi_ek_display_board_info_area(input_file, (char *)"Custom", & len);
  }
#line 2684
  return (0);
}
}
#line 2709 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static size_t ipmi_ek_display_board_info_area(FILE *input_file , char *board_type ,
                                              unsigned int *board_length ) 
{ 
  size_t file_offset ;
  int ret ;
  unsigned char len ;
  unsigned int size_board ;
  long tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  unsigned char *data ;
  unsigned int i ;
  void *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned char padding___1 ;
  unsigned char checksum ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  unsigned char *additional_data ;
  unsigned int i___0 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;

  {
#line 2714
  ret = 0;
#line 2715
  len = (unsigned char)0;
#line 2716
  size_board = 0U;
#line 2717
  if ((unsigned long )input_file == (unsigned long )((void *)0)) {
#line 2719
    return ((size_t )-1);
  } else
#line 2717
  if ((unsigned long )board_type == (unsigned long )((void *)0)) {
#line 2719
    return ((size_t )-1);
  } else
#line 2717
  if ((unsigned long )board_length == (unsigned long )((void *)0)) {
#line 2719
    return ((size_t )-1);
  }
  {
#line 2721
  tmp = ftell(input_file);
#line 2721
  file_offset = (size_t )tmp;
#line 2724
  tmp___0 = fread((void */* __restrict  */)(& len), (size_t )1, (size_t )1, (FILE */* __restrict  */)input_file);
#line 2724
  ret = (int )tmp___0;
  }
#line 2725
  if (ret != 1) {
    {
#line 2726
    lprintf(3, "Invalid Length!");
    }
#line 2727
    goto out;
  } else {
    {
#line 2725
    tmp___1 = ferror(input_file);
    }
#line 2725
    if (tmp___1) {
      {
#line 2726
      lprintf(3, "Invalid Length!");
      }
#line 2727
      goto out;
    }
  }
#line 2729
  (*board_length) --;
#line 2732
  size_board = (unsigned int )((int )len & 63);
#line 2733
  if (size_board == 0U) {
    {
#line 2734
    printf((char const   */* __restrict  */)"%s: None\n", board_type);
    }
#line 2735
    goto out;
  }
  {
#line 2737
  tmp___5 = strncmp((char const   *)board_type, "Custom", (size_t )6);
  }
#line 2737
  if (tmp___5 != 0) {
    {
#line 2739
    i = 0U;
#line 2740
    tmp___2 = malloc((size_t )size_board);
#line 2740
    data = (unsigned char *)tmp___2;
    }
#line 2741
    if ((unsigned long )data == (unsigned long )((void *)0)) {
      {
#line 2742
      lprintf(3, "ipmitool: malloc failure");
      }
#line 2743
      return ((size_t )-1);
    }
    {
#line 2745
    tmp___3 = fread((void */* __restrict  */)data, (size_t )size_board, (size_t )1,
                    (FILE */* __restrict  */)input_file);
#line 2745
    ret = (int )tmp___3;
    }
#line 2746
    if (ret != 1) {
      {
#line 2747
      lprintf(3, "Invalid board type size!");
      }
#line 2748
      goto out;
    } else {
      {
#line 2746
      tmp___4 = ferror(input_file);
      }
#line 2746
      if (tmp___4) {
        {
#line 2747
        lprintf(3, "Invalid board type size!");
        }
#line 2748
        goto out;
      }
    }
    {
#line 2750
    printf((char const   */* __restrict  */)"%s type: 0x%02x\n", board_type, (int )len);
#line 2751
    printf((char const   */* __restrict  */)"%s: ", board_type);
#line 2752
    i = 0U;
    }
    {
#line 2752
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2752
      if (! (i < size_board)) {
#line 2752
        goto while_break;
      }
#line 2753
      if (((int )len & 192) == 192) {
        {
#line 2754
        printf((char const   */* __restrict  */)"%c", (int )*(data + i));
        }
      } else {
        {
#line 2759
        printf((char const   */* __restrict  */)"%02x", (int )*(data + i));
        }
      }
#line 2752
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2762
    printf((char const   */* __restrict  */)"\n");
#line 2763
    free((void *)data);
#line 2764
    *board_length -= size_board;
    }
#line 2765
    goto out;
  }
  {
#line 2767
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 2767
    tmp___12 = feof(input_file);
    }
#line 2767
    if (tmp___12) {
#line 2767
      goto while_break___0;
    }
#line 2768
    if ((int )len == 193) {
      {
#line 2770
      checksum = (unsigned char)0;
#line 2774
      printf((char const   */* __restrict  */)"Additional Custom Mfg. length: 0x%02x\n",
             (int )len);
#line 2775
      padding___1 = (unsigned char )(*board_length - 1U);
      }
#line 2776
      if ((int )padding___1 > 0) {
        {
#line 2776
        tmp___6 = feof(input_file);
        }
#line 2776
        if (! tmp___6) {
          {
#line 2777
          printf((char const   */* __restrict  */)"Unused space: %d (bytes)\n", (int )padding___1);
#line 2778
          fseek(input_file, (long )padding___1, 1);
          }
        }
      }
      {
#line 2780
      tmp___7 = fread((void */* __restrict  */)(& checksum), (size_t )1, (size_t )1,
                      (FILE */* __restrict  */)input_file);
#line 2780
      ret = (int )tmp___7;
      }
#line 2781
      if (ret != 1) {
        {
#line 2782
        lprintf(3, "Invalid Checksum!");
        }
#line 2783
        goto out;
      } else {
        {
#line 2781
        tmp___8 = ferror(input_file);
        }
#line 2781
        if (tmp___8) {
          {
#line 2782
          lprintf(3, "Invalid Checksum!");
          }
#line 2783
          goto out;
        }
      }
      {
#line 2785
      printf((char const   */* __restrict  */)"Checksum: 0x%02x\n", (int )checksum);
      }
#line 2786
      goto out;
    }
    {
#line 2788
    printf((char const   */* __restrict  */)"Additional Custom Mfg. length: 0x%02x\n",
           (int )len);
    }
#line 2789
    if (size_board > 0U) {
#line 2789
      if (size_board < *board_length) {
        {
#line 2790
        additional_data = (unsigned char *)((void *)0);
#line 2791
        i___0 = 0U;
#line 2792
        tmp___9 = malloc((size_t )size_board);
#line 2792
        additional_data = (unsigned char *)tmp___9;
        }
#line 2793
        if ((unsigned long )additional_data == (unsigned long )((void *)0)) {
          {
#line 2794
          lprintf(3, "ipmitool: malloc failure");
          }
#line 2795
          return ((size_t )-1);
        }
        {
#line 2798
        tmp___10 = fread((void */* __restrict  */)additional_data, (size_t )size_board,
                         (size_t )1, (FILE */* __restrict  */)input_file);
#line 2798
        ret = (int )tmp___10;
        }
#line 2799
        if (ret != 1) {
          {
#line 2800
          lprintf(3, "Invalid Additional Data!");
          }
#line 2801
          goto out;
        } else {
          {
#line 2799
          tmp___11 = ferror(input_file);
          }
#line 2799
          if (tmp___11) {
            {
#line 2800
            lprintf(3, "Invalid Additional Data!");
            }
#line 2801
            goto out;
          }
        }
        {
#line 2803
        printf((char const   */* __restrict  */)"Additional Custom Mfg. Data: %02x",
               (int )*(additional_data + 0));
#line 2805
        i___0 = 1U;
        }
        {
#line 2805
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2805
          if (! (i___0 < size_board)) {
#line 2805
            goto while_break___1;
          }
          {
#line 2806
          printf((char const   */* __restrict  */)"-%02x", (int )*(additional_data + i___0));
#line 2805
          i___0 ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 2808
        printf((char const   */* __restrict  */)"\n");
#line 2809
        free((void *)additional_data);
#line 2810
        *board_length -= size_board;
        }
      } else {
        {
#line 2813
        printf((char const   */* __restrict  */)"No Additional Custom Mfg. %d\n",
               *board_length);
        }
#line 2814
        goto out;
      }
    } else {
      {
#line 2813
      printf((char const   */* __restrict  */)"No Additional Custom Mfg. %d\n", *board_length);
      }
#line 2814
      goto out;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  out: 
  {
#line 2819
  tmp___13 = ftell(input_file);
#line 2819
  file_offset = (size_t )tmp___13;
  }
#line 2820
  return (file_offset);
}
}
#line 2843 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_display_product_info_area(FILE *input_file , long offset ) 
{ 
  size_t file_offset ;
  long tmp ;
  int ret ;
  unsigned char ch_len ;
  unsigned char data ;
  unsigned int len ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;

  {
  {
#line 2846
  tmp = ftell(input_file);
#line 2846
  file_offset = (size_t )tmp;
#line 2847
  ret = 0;
#line 2848
  ch_len = (unsigned char)0;
#line 2849
  data = (unsigned char)0;
#line 2850
  len = 0U;
  }
#line 2852
  if ((unsigned long )input_file == (unsigned long )((void *)0)) {
    {
#line 2853
    lprintf(3, "No file stream to read.");
    }
#line 2854
    return (-1);
  }
  {
#line 2856
  printf((char const   */* __restrict  */)"%s\n", EQUAL_LINE_LIMITER);
#line 2857
  printf((char const   */* __restrict  */)"Product Info Area\n");
#line 2858
  printf((char const   */* __restrict  */)"%s\n", EQUAL_LINE_LIMITER);
#line 2859
  ret = fseek(input_file, offset, 0);
#line 2860
  tmp___0 = feof(input_file);
  }
#line 2860
  if (tmp___0) {
    {
#line 2861
    lprintf(3, "Invalid Product Info Area!");
    }
#line 2862
    return (-1);
  }
  {
#line 2864
  tmp___1 = fread((void */* __restrict  */)(& data), (size_t )1, (size_t )1, (FILE */* __restrict  */)input_file);
#line 2864
  ret = (int )tmp___1;
  }
#line 2865
  if (ret != 1) {
    {
#line 2866
    lprintf(3, "Invalid Data!");
    }
#line 2867
    return (-1);
  } else {
    {
#line 2865
    tmp___2 = ferror(input_file);
    }
#line 2865
    if (tmp___2) {
      {
#line 2866
      lprintf(3, "Invalid Data!");
      }
#line 2867
      return (-1);
    }
  }
  {
#line 2869
  printf((char const   */* __restrict  */)"Format Version Number: %d\n", (int )data & 15);
#line 2870
  tmp___3 = feof(input_file);
  }
#line 2870
  if (tmp___3) {
#line 2871
    return (-1);
  }
  {
#line 2875
  tmp___4 = fread((void */* __restrict  */)(& ch_len), (size_t )1, (size_t )1, (FILE */* __restrict  */)input_file);
#line 2875
  ret = (int )tmp___4;
  }
#line 2876
  if (ret != 1) {
    {
#line 2877
    lprintf(3, "Invalid Length!");
    }
#line 2878
    return (-1);
  } else {
    {
#line 2876
    tmp___5 = ferror(input_file);
    }
#line 2876
    if (tmp___5) {
      {
#line 2877
      lprintf(3, "Invalid Length!");
      }
#line 2878
      return (-1);
    }
  }
  {
#line 2881
  len = (unsigned int )((int )ch_len * 8);
#line 2882
  printf((char const   */* __restrict  */)"Area Length: %d\n", len);
#line 2883
  len -= 2U;
#line 2885
  tmp___6 = fread((void */* __restrict  */)(& data), (size_t )1, (size_t )1, (FILE */* __restrict  */)input_file);
#line 2885
  ret = (int )tmp___6;
  }
#line 2886
  if (ret != 1) {
    {
#line 2887
    lprintf(3, "Invalid Length!");
    }
#line 2888
    return (-1);
  } else {
    {
#line 2886
    tmp___7 = ferror(input_file);
    }
#line 2886
    if (tmp___7) {
      {
#line 2887
      lprintf(3, "Invalid Length!");
      }
#line 2888
      return (-1);
    }
  }
  {
#line 2891
  fread((void */* __restrict  */)(& data), (size_t )1, (size_t )1, (FILE */* __restrict  */)input_file);
#line 2892
  printf((char const   */* __restrict  */)"Language Code: %d\n", (int )data);
#line 2893
  len --;
#line 2895
  file_offset = ipmi_ek_display_board_info_area(input_file, (char *)"Product Manufacture Data",
                                                & len);
#line 2897
  ret = fseek(input_file, (long )file_offset, 0);
#line 2899
  file_offset = ipmi_ek_display_board_info_area(input_file, (char *)"Product Name",
                                                & len);
#line 2901
  ret = fseek(input_file, (long )file_offset, 0);
#line 2903
  file_offset = ipmi_ek_display_board_info_area(input_file, (char *)"Product Part/Model Number",
                                                & len);
#line 2905
  ret = fseek(input_file, (long )file_offset, 0);
#line 2907
  file_offset = ipmi_ek_display_board_info_area(input_file, (char *)"Product Version",
                                                & len);
#line 2909
  ret = fseek(input_file, (long )file_offset, 0);
#line 2911
  file_offset = ipmi_ek_display_board_info_area(input_file, (char *)"Product Serial Number",
                                                & len);
#line 2913
  ret = fseek(input_file, (long )file_offset, 0);
#line 2915
  file_offset = ipmi_ek_display_board_info_area(input_file, (char *)"Asset Tag", & len);
#line 2917
  ret = fseek(input_file, (long )file_offset, 0);
#line 2919
  file_offset = ipmi_ek_display_board_info_area(input_file, (char *)"FRU File ID",
                                                & len);
#line 2921
  ret = fseek(input_file, (long )file_offset, 0);
#line 2923
  file_offset = ipmi_ek_display_board_info_area(input_file, (char *)"Custom", & len);
  }
#line 2925
  return (0);
}
}
#line 2947 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_record(struct ipmi_ek_multi_header *record , struct ipmi_ek_multi_header *list_head ,
                                   struct ipmi_ek_multi_header *list_last ) 
{ 
  unsigned char picmg_id ;
  char const   *tmp ;
  int i ;

  {
#line 2952
  if ((unsigned long )list_head == (unsigned long )((void *)0)) {
    {
#line 2953
    printf((char const   */* __restrict  */)"***empty list***\n");
    }
  } else {
    {
#line 2956
    printf((char const   */* __restrict  */)"%s\n", EQUAL_LINE_LIMITER);
#line 2957
    printf((char const   */* __restrict  */)"FRU Multi Info area\n");
#line 2958
    printf((char const   */* __restrict  */)"%s\n", EQUAL_LINE_LIMITER);
#line 2959
    record = list_head;
    }
    {
#line 2959
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2959
      if (! ((unsigned long )record != (unsigned long )((void *)0))) {
#line 2959
        goto while_break;
      }
      {
#line 2960
      printf((char const   */* __restrict  */)"Record Type ID: 0x%02x\n", (int )record->header.type);
#line 2961
      printf((char const   */* __restrict  */)"Record Format version: 0x%02x\n", (int )record->header.format);
      }
#line 2962
      if ((int )record->header.len > (int )PICMG_ID_OFFSET) {
        {
#line 2970
        picmg_id = *(record->data + PICMG_ID_OFFSET);
#line 2971
        printf((char const   */* __restrict  */)"Manufacturer ID: %02x%02x%02x h\n",
               (int )*(record->data + 2), (int )*(record->data + 1), (int )*(record->data + 0));
        }
#line 2973
        if ((int )picmg_id < 4) {
          {
#line 2976
          printf((char const   */* __restrict  */)"Picmg record ID: Unsupported {0x%02x}\n",
                 (int )picmg_id);
          }
        } else
#line 2973
        if ((int )picmg_id > 45) {
          {
#line 2976
          printf((char const   */* __restrict  */)"Picmg record ID: Unsupported {0x%02x}\n",
                 (int )picmg_id);
          }
        } else {
          {
#line 2979
          tmp = val2str((uint16_t )picmg_id, ipmi_ekanalyzer_picmg_record_id);
#line 2979
          printf((char const   */* __restrict  */)"Picmg record ID: %s {0x%02x}\n",
                 tmp, (int )picmg_id);
          }
        }
        {
#line 2984
        if ((int )picmg_id == 4) {
#line 2984
          goto case_4;
        }
#line 2987
        if ((int )picmg_id == 16) {
#line 2987
          goto case_16;
        }
#line 2990
        if ((int )picmg_id == 17) {
#line 2990
          goto case_17;
        }
#line 2993
        if ((int )picmg_id == 18) {
#line 2993
          goto case_18;
        }
#line 2996
        if ((int )picmg_id == 19) {
#line 2996
          goto case_19;
        }
#line 2999
        if ((int )picmg_id == 20) {
#line 2999
          goto case_20;
        }
#line 3002
        if ((int )picmg_id == 21) {
#line 3002
          goto case_21;
        }
#line 3005
        if ((int )picmg_id == 22) {
#line 3005
          goto case_22;
        }
#line 3008
        if ((int )picmg_id == 23) {
#line 3008
          goto case_23;
        }
#line 3011
        if ((int )picmg_id == 24) {
#line 3011
          goto case_24;
        }
#line 3014
        if ((int )picmg_id == 25) {
#line 3014
          goto case_25;
        }
#line 3017
        if ((int )picmg_id == 26) {
#line 3017
          goto case_26;
        }
#line 3020
        if ((int )picmg_id == 44) {
#line 3020
          goto case_44;
        }
#line 3023
        if ((int )picmg_id == 45) {
#line 3023
          goto case_45;
        }
#line 3026
        goto switch_default;
        case_4: /* CIL Label */ 
        {
#line 2985
        ipmi_ek_display_backplane_p2p_record(record);
        }
#line 2986
        goto switch_break;
        case_16: /* CIL Label */ 
        {
#line 2988
        ipmi_ek_display_address_table_record(record);
        }
#line 2989
        goto switch_break;
        case_17: /* CIL Label */ 
        {
#line 2991
        ipmi_ek_display_shelf_power_distribution_record(record);
        }
#line 2992
        goto switch_break;
        case_18: /* CIL Label */ 
        {
#line 2994
        ipmi_ek_display_shelf_activation_record(record);
        }
#line 2995
        goto switch_break;
        case_19: /* CIL Label */ 
        {
#line 2997
        ipmi_ek_display_shelf_ip_connection_record(record);
        }
#line 2998
        goto switch_break;
        case_20: /* CIL Label */ 
        {
#line 3000
        ipmi_ek_display_board_p2p_record(record);
        }
#line 3001
        goto switch_break;
        case_21: /* CIL Label */ 
        {
#line 3003
        ipmi_ek_display_radial_ipmb0_record(record);
        }
#line 3004
        goto switch_break;
        case_22: /* CIL Label */ 
        {
#line 3006
        ipmi_ek_display_amc_current_record(record);
        }
#line 3007
        goto switch_break;
        case_23: /* CIL Label */ 
        {
#line 3009
        ipmi_ek_display_amc_activation_record(record);
        }
#line 3010
        goto switch_break;
        case_24: /* CIL Label */ 
        {
#line 3012
        ipmi_ek_display_carrier_connectivity(record);
        }
#line 3013
        goto switch_break;
        case_25: /* CIL Label */ 
        {
#line 3015
        ipmi_ek_display_amc_p2p_record(record);
        }
#line 3016
        goto switch_break;
        case_26: /* CIL Label */ 
        {
#line 3018
        ipmi_ek_display_amc_carrier_info_record(record);
        }
#line 3019
        goto switch_break;
        case_44: /* CIL Label */ 
        {
#line 3021
        ipmi_ek_display_clock_carrier_p2p_record(record);
        }
#line 3022
        goto switch_break;
        case_45: /* CIL Label */ 
        {
#line 3024
        ipmi_ek_display_clock_config_record(record);
        }
#line 3025
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 3027
        if (verbose > 0) {
          {
#line 3029
          printf((char const   */* __restrict  */)"%02x %02x %02x %02x %02x ", (int )record->header.type,
                 (int )record->header.format, (int )record->header.len, (int )record->header.record_checksum,
                 (int )record->header.header_checksum);
#line 3033
          i = 0;
          }
          {
#line 3033
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 3033
            if (! (i < (int )record->header.len)) {
#line 3033
              goto while_break___0;
            }
            {
#line 3034
            printf((char const   */* __restrict  */)"%02x ", (int )*(record->data + i));
#line 3033
            i ++;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 3036
          printf((char const   */* __restrict  */)"\n");
          }
        }
#line 3038
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        {
#line 3040
        printf((char const   */* __restrict  */)"%s\n", STAR_LINE_LIMITER);
        }
      }
#line 2959
      record = record->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3044
  return;
}
}
#line 3063 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_backplane_p2p_record(struct ipmi_ek_multi_header *record ) 
{ 
  uint8_t index___0 ;
  int offset ;
  struct fru_picmgext_slot_desc *slot_d ;
  struct fru_picmgext_chn_desc *d ;

  {
#line 3067
  offset = (int )START_DATA_OFFSET;
#line 3068
  slot_d = (struct fru_picmgext_slot_desc *)(record->data + offset);
#line 3071
  offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_slot_desc ));
  {
#line 3073
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3073
    if (! (offset <= (int )record->header.len)) {
#line 3073
      goto while_break;
    }
    {
#line 3074
    printf((char const   */* __restrict  */)"   Channel Type: ");
    }
    {
#line 3078
    if ((int )slot_d->chan_type == 7) {
#line 3078
      goto case_7;
    }
#line 3078
    if ((int )slot_d->chan_type == 0) {
#line 3078
      goto case_7;
    }
#line 3081
    if ((int )slot_d->chan_type == 8) {
#line 3081
      goto case_8;
    }
#line 3084
    if ((int )slot_d->chan_type == 9) {
#line 3084
      goto case_9;
    }
#line 3087
    if ((int )slot_d->chan_type == 10) {
#line 3087
      goto case_10;
    }
#line 3090
    if ((int )slot_d->chan_type == 11) {
#line 3090
      goto case_11;
    }
#line 3093
    if ((int )slot_d->chan_type == 12) {
#line 3093
      goto case_12;
    }
#line 3096
    goto switch_default;
    case_7: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 3079
    printf((char const   */* __restrict  */)"PICMG 2.9\n");
    }
#line 3080
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 3082
    printf((char const   */* __restrict  */)"Single Port Fabric IF\n");
    }
#line 3083
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 3085
    printf((char const   */* __restrict  */)"Double Port Fabric IF\n");
    }
#line 3086
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 3088
    printf((char const   */* __restrict  */)"Full Channel Fabric IF\n");
    }
#line 3089
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 3091
    printf((char const   */* __restrict  */)"Base IF\n");
    }
#line 3092
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 3094
    printf((char const   */* __restrict  */)"Update Channel IF\n");
    }
#line 3095
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 3097
    printf((char const   */* __restrict  */)"Unknown IF\n");
    }
#line 3098
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 3100
    printf((char const   */* __restrict  */)"   Slot Address:  %02x\n", (int )slot_d->slot_addr);
#line 3101
    printf((char const   */* __restrict  */)"   Channel Count: %i\n", (int )slot_d->chn_count);
#line 3103
    index___0 = (uint8_t )0;
    }
    {
#line 3103
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3103
      if (! ((int )index___0 < (int )slot_d->chn_count)) {
#line 3103
        goto while_break___0;
      }
#line 3104
      d = (struct fru_picmgext_chn_desc *)(record->data + offset);
#line 3107
      if (verbose) {
        {
#line 3108
        printf((char const   */* __restrict  */)"\tChn: %02x   -->   Chn: %02x in Slot: %02x\n",
               d->local_chn, d->remote_chn, d->remote_slot);
        }
      }
#line 3115
      offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_chn_desc ));
#line 3103
      index___0 = (uint8_t )((int )index___0 + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3117
    slot_d = (struct fru_picmgext_slot_desc *)(record->data + offset);
#line 3118
    offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_slot_desc ));
  }
  while_break: /* CIL Label */ ;
  }
#line 3120
  return;
}
}
#line 3139 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_address_table_record(struct ipmi_ek_multi_header *record ) 
{ 
  unsigned char entries ;
  unsigned char i ;
  int offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 3142
  entries = (unsigned char)0;
#line 3144
  offset = (int )START_DATA_OFFSET;
#line 3147
  tmp = offset;
#line 3147
  offset ++;
#line 3147
  printf((char const   */* __restrict  */)"   Type/Len:    0x%02x\n", (int )*(record->data + tmp));
#line 3148
  printf((char const   */* __restrict  */)"   Shelf Addr: ");
#line 3149
  i = (unsigned char)0;
  }
  {
#line 3149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3149
    if (! ((int )i < 20)) {
#line 3149
      goto while_break;
    }
    {
#line 3150
    tmp___0 = offset;
#line 3150
    offset ++;
#line 3150
    printf((char const   */* __restrict  */)"0x%02x ", (int )*(record->data + tmp___0));
#line 3149
    i = (unsigned char )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3152
  printf((char const   */* __restrict  */)"\n");
#line 3154
  tmp___1 = offset;
#line 3154
  offset ++;
#line 3154
  entries = *(record->data + tmp___1);
#line 3155
  printf((char const   */* __restrict  */)"   Addr Table Entries count: 0x%02x\n",
         (int )entries);
#line 3157
  i = (unsigned char)0;
  }
  {
#line 3157
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3157
    if (! ((int )i < (int )entries)) {
#line 3157
      goto while_break___0;
    }
    {
#line 3158
    printf((char const   */* __restrict  */)"\tHWAddr: 0x%02x  - SiteNum: 0x%02x - SiteType: 0x%02x \n",
           (int )*(record->data + offset), (int )*(record->data + (offset + 1)), (int )*(record->data + (offset + 2)));
#line 3162
    offset += 3;
#line 3157
    i = (unsigned char )((int )i + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3164
  return;
}
}
#line 3183 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_shelf_power_distribution_record(struct ipmi_ek_multi_header *record ) 
{ 
  int offset ;
  unsigned char i ;
  unsigned char j ;
  unsigned char feeds ;
  int tmp ;
  unsigned char entries ;
  unsigned long max_ext ;
  unsigned long max_int ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 3187
  offset = (int )START_DATA_OFFSET;
#line 3189
  feeds = (unsigned char)0;
#line 3191
  tmp = offset;
#line 3191
  offset ++;
#line 3191
  feeds = *(record->data + tmp);
#line 3192
  printf((char const   */* __restrict  */)"   Number of Power Feeds: 0x%02x\n", (int )feeds);
#line 3194
  i = (unsigned char)0;
  }
  {
#line 3194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3194
    if (! ((int )i < (int )feeds)) {
#line 3194
      goto while_break;
    }
    {
#line 3196
    max_ext = 0UL;
#line 3197
    max_int = 0UL;
#line 3198
    max_ext = (unsigned long )((int )*(record->data + offset) | ((int )*(record->data + (offset + 1)) << 8));
#line 3199
    printf((char const   */* __restrict  */)"   Max External Available Current: %ld Amps\n",
           max_ext * 10UL);
#line 3201
    offset += 2;
#line 3203
    max_int = (unsigned long )((int )*(record->data + offset) | ((int )*(record->data + (offset + 1)) << 8));
#line 3204
    printf((char const   */* __restrict  */)"   Max Internal Current:\t   %ld Amps\n",
           max_int * 10UL);
#line 3205
    offset += 2;
#line 3206
    tmp___0 = offset;
#line 3206
    offset ++;
#line 3206
    printf((char const   */* __restrict  */)"   Min Expected Operating Voltage: %d Volts\n",
           (int )*(record->data + tmp___0) / 2);
#line 3208
    tmp___1 = offset;
#line 3208
    offset ++;
#line 3208
    entries = *(record->data + tmp___1);
#line 3209
    printf((char const   */* __restrict  */)"   Feed to FRU count: 0x%02x\n", (int )entries);
#line 3210
    j = (unsigned char)0;
    }
    {
#line 3210
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3210
      if (! ((int )j < (int )entries)) {
#line 3210
        goto while_break___0;
      }
      {
#line 3211
      tmp___2 = offset;
#line 3211
      offset ++;
#line 3211
      printf((char const   */* __restrict  */)"\tHW: 0x%02x", (int )*(record->data + tmp___2));
#line 3212
      tmp___3 = offset;
#line 3212
      offset ++;
#line 3212
      printf((char const   */* __restrict  */)"\tFRU ID: 0x%02x\n", (int )*(record->data + tmp___3));
#line 3210
      j = (unsigned char )((int )j + 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3194
    i = (unsigned char )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 3215
  return;
}
}
#line 3234 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_shelf_activation_record(struct ipmi_ek_multi_header *record ) 
{ 
  unsigned char count ;
  int offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 3238
  count = (unsigned char)0;
#line 3239
  offset = (int )START_DATA_OFFSET;
#line 3241
  tmp = offset;
#line 3241
  offset ++;
#line 3241
  printf((char const   */* __restrict  */)"   Allowance for FRU Act Readiness: 0x%02x\n",
         (int )*(record->data + tmp));
#line 3243
  tmp___0 = offset;
#line 3243
  offset ++;
#line 3243
  count = *(record->data + tmp___0);
#line 3244
  printf((char const   */* __restrict  */)"   FRU activation and Power Desc Cnt: 0x%02x\n",
         (int )count);
  }
  {
#line 3246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3246
    if (! ((int )count > 0)) {
#line 3246
      goto while_break;
    }
    {
#line 3247
    printf((char const   */* __restrict  */)"   FRU activation and Power descriptor:\n");
#line 3248
    tmp___1 = offset;
#line 3248
    offset ++;
#line 3248
    printf((char const   */* __restrict  */)"\tHardware Address:\t\t0x%02x\n", (int )*(record->data + tmp___1));
#line 3249
    tmp___2 = offset;
#line 3249
    offset ++;
#line 3249
    printf((char const   */* __restrict  */)"\tFRU Device ID:\t\t\t0x%02x\n", (int )*(record->data + tmp___2));
#line 3250
    printf((char const   */* __restrict  */)"\tMax FRU Power Capability:\t0x%04x Watts\n",
           (int )*(record->data + offset) | ((int )*(record->data + (offset + 1)) << 8));
#line 3252
    offset += 2;
#line 3253
    tmp___3 = offset;
#line 3253
    offset ++;
#line 3253
    printf((char const   */* __restrict  */)"\tConfiguration parameter:\t0x%02x\n",
           (int )*(record->data + tmp___3));
#line 3254
    count = (unsigned char )((int )count - 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3256
  return;
}
}
#line 3276 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_shelf_ip_connection_record(struct ipmi_ek_multi_header *record ) 
{ 
  int ioffset ;

  {
#line 3280
  ioffset = (int )START_DATA_OFFSET;
#line 3281
  if (ioffset > (int )record->header.len) {
    {
#line 3282
    printf((char const   */* __restrict  */)"   Shelf Manager IP Address: %d.%d.%d.%d\n",
           (int )*(record->data + ioffset), (int )*(record->data + (ioffset + 1)),
           (int )*(record->data + (ioffset + 2)), (int )*(record->data + (ioffset + 3)));
#line 3285
    ioffset += 4;
    }
  }
#line 3287
  if (ioffset > (int )record->header.len) {
    {
#line 3288
    printf((char const   */* __restrict  */)"   Default Gateway Address: %d.%d.%d.%d\n",
           (int )*(record->data + ioffset), (int )*(record->data + (ioffset + 1)),
           (int )*(record->data + (ioffset + 2)), (int )*(record->data + (ioffset + 3)));
#line 3291
    ioffset += 4;
    }
  }
#line 3293
  if (ioffset > (int )record->header.len) {
    {
#line 3294
    printf((char const   */* __restrict  */)"   Subnet Mask: %d.%d.%d.%d\n", (int )*(record->data + ioffset),
           (int )*(record->data + (ioffset + 1)), (int )*(record->data + (ioffset + 2)),
           (int )*(record->data + (ioffset + 3)));
#line 3297
    ioffset += 4;
    }
  }
#line 3299
  return;
}
}
#line 3361 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_board_p2p_record(struct ipmi_ek_multi_header *record ) 
{ 
  unsigned char guid_count ;
  int offset ;
  int i ;
  int tmp ;
  int j ;
  unsigned long data ;
  struct fru_picmgext_link_desc *d ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
  {
#line 3365
  offset = (int )START_DATA_OFFSET;
#line 3366
  i = 0;
#line 3368
  tmp = offset;
#line 3368
  offset ++;
#line 3368
  guid_count = *(record->data + tmp);
#line 3369
  printf((char const   */* __restrict  */)"   GUID count: %2d\n", (int )guid_count);
#line 3371
  i = 0;
  }
  {
#line 3371
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3371
    if (! (i < (int )guid_count)) {
#line 3371
      goto while_break;
    }
    {
#line 3373
    printf((char const   */* __restrict  */)"\tGUID: ");
#line 3374
    j = 0;
    }
    {
#line 3374
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3374
      if (! ((unsigned long )j < sizeof(struct fru_picmgext_guid ))) {
#line 3374
        goto while_break___0;
      }
      {
#line 3375
      printf((char const   */* __restrict  */)"%02x", (int )*(record->data + (offset + j)));
#line 3374
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3377
    printf((char const   */* __restrict  */)"\n");
#line 3378
    offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_guid ));
#line 3371
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3381
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3381
    if (! (offset < (int )record->header.len)) {
#line 3381
      goto while_break___1;
    }
    {
#line 3389
    data = (unsigned long )((((int )*(record->data + offset) | ((int )*(record->data + (offset + 1)) << 8)) | ((int )*(record->data + (offset + 2)) << 16)) | ((int )*(record->data + (offset + 3)) << 24));
#line 3393
    d = (struct fru_picmgext_link_desc *)(& data);
#line 3395
    printf((char const   */* __restrict  */)"   Link Descriptor\n");
#line 3396
    printf((char const   */* __restrict  */)"\tLink Grouping ID:\t0x%02x\n", d->grouping);
#line 3397
    printf((char const   */* __restrict  */)"\tLink Type Extension:\t0x%02x - ", d->ext);
    }
#line 3399
    if (d->type == 1U) {
      {
#line 3401
      if (d->ext == 0U) {
#line 3401
        goto case_0;
      }
#line 3404
      if (d->ext == 1U) {
#line 3404
        goto case_1;
      }
#line 3407
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 3402
      printf((char const   */* __restrict  */)"10/100/1000BASE-T Link (four-pair)\n");
      }
#line 3403
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 3405
      printf((char const   */* __restrict  */)"ShMC Cross-connect (two-pair)\n");
      }
#line 3406
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 3408
      printf((char const   */* __restrict  */)"Unknwon\n");
      }
#line 3409
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else
#line 3412
    if (d->type == 2U) {
      {
#line 3414
      if (d->ext == 0U) {
#line 3414
        goto case_0___0;
      }
#line 3417
      if (d->ext == 1U) {
#line 3417
        goto case_1___0;
      }
#line 3420
      if (d->ext == 2U) {
#line 3420
        goto case_2;
      }
#line 3423
      goto switch_default___0;
      case_0___0: /* CIL Label */ 
      {
#line 3415
      printf((char const   */* __restrict  */)"Fixed 1000Base-BX\n");
      }
#line 3416
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 3418
      printf((char const   */* __restrict  */)"Fixed 10GBASE-BX4 [XAUI]\n");
      }
#line 3419
      goto switch_break___0;
      case_2: /* CIL Label */ 
      {
#line 3421
      printf((char const   */* __restrict  */)"FC-PI\n");
      }
#line 3422
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 3424
      printf((char const   */* __restrict  */)"Unknwon\n");
      }
#line 3425
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    } else
#line 3428
    if (d->type == 3U) {
      {
#line 3429
      printf((char const   */* __restrict  */)"Unknwon\n");
      }
    } else
#line 3431
    if (d->type == 4U) {
      {
#line 3432
      printf((char const   */* __restrict  */)"Unknwon\n");
      }
    } else
#line 3434
    if (d->type == 5U) {
      {
#line 3435
      printf((char const   */* __restrict  */)"Unknwon\n");
      }
    } else {
      {
#line 3438
      printf((char const   */* __restrict  */)"Unknwon\n");
      }
    }
    {
#line 3441
    printf((char const   */* __restrict  */)"\tLink Type:\t\t0x%02x - ", d->type);
    }
#line 3442
    if (d->type == 0U) {
      {
#line 3443
      printf((char const   */* __restrict  */)"Reserved\n");
      }
    } else
#line 3442
    if (d->type == 255U) {
      {
#line 3443
      printf((char const   */* __restrict  */)"Reserved\n");
      }
    } else
#line 3445
    if (d->type >= 6U) {
#line 3445
      if (d->type <= 239U) {
        {
#line 3446
        printf((char const   */* __restrict  */)"Reserved\n");
        }
      } else {
#line 3445
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 3448
    if (d->type >= (unsigned int )LOWER_OEM_TYPE) {
#line 3448
      if (d->type <= (unsigned int )UPPER_OEM_TYPE) {
        {
#line 3449
        printf((char const   */* __restrict  */)"OEM GUID Definition\n");
        }
      } else {
#line 3448
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 3453
      if (d->type == 1U) {
#line 3453
        goto case_1___1;
      }
#line 3456
      if (d->type == 2U) {
#line 3456
        goto case_2___0;
      }
#line 3459
      if (d->type == 3U) {
#line 3459
        goto case_3;
      }
#line 3462
      if (d->type == 4U) {
#line 3462
        goto case_4;
      }
#line 3465
      if (d->type == 5U) {
#line 3465
        goto case_5;
      }
#line 3468
      goto switch_default___1;
      case_1___1: /* CIL Label */ 
      {
#line 3454
      printf((char const   */* __restrict  */)"PICMG 3.0 Base Interface 10/100/1000\n");
      }
#line 3455
      goto switch_break___1;
      case_2___0: /* CIL Label */ 
      {
#line 3457
      printf((char const   */* __restrict  */)"PICMG 3.1 Ethernet Fabric Interface\n");
      }
#line 3458
      goto switch_break___1;
      case_3: /* CIL Label */ 
      {
#line 3460
      printf((char const   */* __restrict  */)"PICMG 3.2 Infiniband Fabric Interface\n");
      }
#line 3461
      goto switch_break___1;
      case_4: /* CIL Label */ 
      {
#line 3463
      printf((char const   */* __restrict  */)"PICMG 3.3 Star Fabric Interface\n");
      }
#line 3464
      goto switch_break___1;
      case_5: /* CIL Label */ 
      {
#line 3466
      printf((char const   */* __restrict  */)"PICMG 3.4 PCI Express Fabric Interface\n");
      }
#line 3467
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
      {
#line 3469
      printf((char const   */* __restrict  */)"Invalid\n");
      }
#line 3470
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    }
    {
#line 3473
    printf((char const   */* __restrict  */)"\tLink Designator: \n");
    }
#line 3474
    if (d->desig_port & 1U) {
#line 3474
      tmp___0 = "enable";
    } else {
#line 3474
      tmp___0 = "disable";
    }
    {
#line 3474
    printf((char const   */* __restrict  */)"\t   Port 0 Flag:   %s\n", tmp___0);
    }
#line 3476
    if (d->desig_port & 2U) {
#line 3476
      tmp___1 = "enable";
    } else {
#line 3476
      tmp___1 = "disable";
    }
    {
#line 3476
    printf((char const   */* __restrict  */)"\t   Port 1 Flag:   %s\n", tmp___1);
    }
#line 3478
    if (d->desig_port & 4U) {
#line 3478
      tmp___2 = "enable";
    } else {
#line 3478
      tmp___2 = "disable";
    }
    {
#line 3478
    printf((char const   */* __restrict  */)"\t   Port 2 Flag:   %s\n", tmp___2);
    }
#line 3480
    if (d->desig_port & 8U) {
#line 3480
      tmp___3 = "enable";
    } else {
#line 3480
      tmp___3 = "disable";
    }
    {
#line 3480
    printf((char const   */* __restrict  */)"\t   Port 3 Flag:   %s\n", tmp___3);
#line 3483
    printf((char const   */* __restrict  */)"\t   Interface:    0x%02x - ", d->desig_if);
    }
    {
#line 3485
    if (d->desig_if == 0U) {
#line 3485
      goto case_0___1;
    }
#line 3488
    if (d->desig_if == 1U) {
#line 3488
      goto case_1___2;
    }
#line 3491
    if (d->desig_if == 2U) {
#line 3491
      goto case_2___1;
    }
#line 3494
    if (d->desig_if == 3U) {
#line 3494
      goto case_3___0;
    }
#line 3497
    goto switch_default___2;
    case_0___1: /* CIL Label */ 
    {
#line 3486
    printf((char const   */* __restrict  */)"Base Interface\n");
    }
#line 3487
    goto switch_break___2;
    case_1___2: /* CIL Label */ 
    {
#line 3489
    printf((char const   */* __restrict  */)"Fabric Interface\n");
    }
#line 3490
    goto switch_break___2;
    case_2___1: /* CIL Label */ 
    {
#line 3492
    printf((char const   */* __restrict  */)"Update Channel\n");
    }
#line 3493
    goto switch_break___2;
    case_3___0: /* CIL Label */ 
    {
#line 3495
    printf((char const   */* __restrict  */)"Reserved\n");
    }
#line 3496
    goto switch_break___2;
    switch_default___2: /* CIL Label */ 
    {
#line 3498
    printf((char const   */* __restrict  */)"Invalid");
    }
#line 3499
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
    {
#line 3501
    printf((char const   */* __restrict  */)"\t   Channel Number:    0x%02x\n", d->desig_channel);
#line 3381
    offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_link_desc ));
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3503
  return;
}
}
#line 3522 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_radial_ipmb0_record(struct ipmi_ek_multi_header *record ) 
{ 
  int offset ;
  int tmp ;
  unsigned char entry_count ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 3525
  offset = (int )START_DATA_OFFSET;
#line 3529
  printf((char const   */* __restrict  */)"   IPMB-0 Connector Definer: ");
#line 3531
  printf((char const   */* __restrict  */)"%02x %02x %02x h\n", (int )*(record->data + offset),
         (int )*(record->data + (offset + 1)), (int )*(record->data + (offset + 2)));
#line 3538
  offset += 3;
#line 3540
  printf((char const   */* __restrict  */)"   IPMB-0 Connector version ID: ");
#line 3542
  printf((char const   */* __restrict  */)"%02x %02x h\n", (int )*(record->data + offset),
         (int )*(record->data + (offset + 1)));
#line 3546
  offset += 2;
#line 3548
  tmp = offset;
#line 3548
  offset ++;
#line 3548
  printf((char const   */* __restrict  */)"   IPMB-0 Hub Descriptor Count: 0x%02x",
         (int )*(record->data + tmp));
  }
#line 3549
  if ((int )*(record->data + offset) > 0) {
    {
#line 3550
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3550
      if (! (offset < (int )record->header.len)) {
#line 3550
        goto while_break;
      }
      {
#line 3551
      entry_count = (unsigned char)0;
#line 3552
      printf((char const   */* __restrict  */)"   IPMB-0 Hub Descriptor\n");
#line 3553
      tmp___0 = offset;
#line 3553
      offset ++;
#line 3553
      printf((char const   */* __restrict  */)"\tHardware Address: 0x%02x\n", (int )*(record->data + tmp___0));
#line 3554
      printf((char const   */* __restrict  */)"\tHub Info {0x%02x}: ", (int )*(record->data + offset));
      }
#line 3556
      if (((int )*(record->data + offset) & 1) == 1) {
        {
#line 3557
        printf((char const   */* __restrict  */)"IPMB-A only\n");
        }
      } else
#line 3559
      if (((int )*(record->data + offset) & 2) == 2) {
        {
#line 3560
        printf((char const   */* __restrict  */)"IPMB-B only\n");
        }
      } else
#line 3562
      if (((int )*(record->data + offset) & 3) == 3) {
        {
#line 3563
        printf((char const   */* __restrict  */)"IPMB-A and IPMB-B\n");
        }
      } else {
        {
#line 3566
        printf((char const   */* __restrict  */)"Reserved.\n");
        }
      }
      {
#line 3568
      offset ++;
#line 3570
      tmp___1 = offset;
#line 3570
      offset ++;
#line 3570
      entry_count = *(record->data + tmp___1);
#line 3571
      printf((char const   */* __restrict  */)"\tAddress Entry count: 0x%02x", (int )entry_count);
      }
      {
#line 3572
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3572
        if (! ((int )entry_count > 0)) {
#line 3572
          goto while_break___0;
        }
        {
#line 3573
        tmp___2 = offset;
#line 3573
        offset ++;
#line 3573
        printf((char const   */* __restrict  */)"\t   Hardware Address: 0x%02x\n",
               (int )*(record->data + tmp___2));
#line 3574
        tmp___3 = offset;
#line 3574
        offset ++;
#line 3574
        printf((char const   */* __restrict  */)"\t   IPMB-0 Link Entry: 0x%02x\n",
               (int )*(record->data + tmp___3));
#line 3575
        entry_count = (unsigned char )((int )entry_count - 1);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3580
  return;
}
}
#line 3599 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_amc_current_record(struct ipmi_ek_multi_header *record ) 
{ 
  unsigned char current ;

  {
  {
#line 3603
  current = *(record->data + START_DATA_OFFSET);
#line 3604
  printf((char const   */* __restrict  */)"   Current draw: %.1f A @ 12V => %.2f Watt\n",
         (double )((float )current) / 10.0, ((double )((float )current) / 10.0) * 12.0);
#line 3606
  printf((char const   */* __restrict  */)"\n");
  }
#line 3607
  return;
}
}
#line 3627 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_amc_activation_record(struct ipmi_ek_multi_header *record ) 
{ 
  uint16_t max_current ;
  int offset ;
  struct fru_picmgext_activation_record *a ;

  {
  {
#line 3631
  offset = (int )START_DATA_OFFSET;
#line 3633
  max_current = (uint16_t )*(record->data + offset);
#line 3634
  offset ++;
#line 3634
  max_current = (uint16_t )((int )max_current | ((int )*(record->data + offset) << 8));
#line 3635
  printf((char const   */* __restrict  */)"   Maximum Internal Current(@12V): %.2f A [ %.2f Watt ]\n",
         (double )((float )max_current / (float )10), (double )(((float )max_current / (float )10) * (float )12));
#line 3638
  offset ++;
#line 3638
  printf((char const   */* __restrict  */)"   Module Activation Readiness:    %i sec.\n",
         (int )*(record->data + offset));
#line 3641
  offset ++;
#line 3641
  printf((char const   */* __restrict  */)"   Descriptor Count: %i\n", (int )*(record->data + offset));
#line 3642
  offset ++;
  }
  {
#line 3642
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3642
    if (! (offset < (int )record->header.len)) {
#line 3642
      goto while_break;
    }
    {
#line 3644
    a = (struct fru_picmgext_activation_record *)(record->data + offset);
#line 3647
    printf((char const   */* __restrict  */)"\tIPMB-Address:\t\t0x%x\n", (int )a->ibmb_addr);
#line 3648
    printf((char const   */* __restrict  */)"\tMax. Module Current:\t%.2f A\n", (double )((float )a->max_module_curr / (float )10));
#line 3649
    printf((char const   */* __restrict  */)"\n");
#line 3642
    offset += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3651
  return;
}
}
#line 3671 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_amc_p2p_record(struct ipmi_ek_multi_header *record ) 
{ 
  int index_data ;
  int oem_count ;
  int ch_count ;
  int index___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int data ;
  struct fru_picmgext_amc_channel_desc_record *ch_desc ;
  unsigned int data___0[2] ;
  struct fru_picmgext_amc_link_desc_record *link_desc ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;

  {
  {
#line 3674
  index_data = (int )START_DATA_OFFSET;
#line 3675
  oem_count = 0;
#line 3676
  ch_count = 0;
#line 3677
  index___0 = 0;
#line 3679
  tmp = index_data;
#line 3679
  index_data ++;
#line 3679
  oem_count = (int )*(record->data + tmp);
#line 3680
  printf((char const   */* __restrict  */)"OEM GUID count: %02x\n", oem_count);
  }
#line 3682
  if (oem_count > 0) {
    {
#line 3683
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3683
      if (! (oem_count > 0)) {
#line 3683
        goto while_break;
      }
      {
#line 3684
      printf((char const   */* __restrict  */)"OEM GUID: ");
#line 3685
      index___0 = 1;
      }
      {
#line 3685
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3685
        if (! (index___0 <= 16)) {
#line 3685
          goto while_break___0;
        }
        {
#line 3686
        tmp___0 = index_data;
#line 3686
        index_data ++;
#line 3686
        printf((char const   */* __restrict  */)"%02x", (int )*(record->data + tmp___0));
        }
#line 3689
        if (! (index___0 % 5)) {
          {
#line 3690
          printf((char const   */* __restrict  */)"-");
          }
        }
#line 3685
        index___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 3693
      printf((char const   */* __restrict  */)"\n");
#line 3694
      oem_count --;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3697
  if (((int )*(record->data + index_data) & (int )AMC_MODULE) == (int )AMC_MODULE) {
    {
#line 3698
    printf((char const   */* __restrict  */)"AMC module connection\n");
    }
  } else {
    {
#line 3701
    printf((char const   */* __restrict  */)"On-Carrier Device %02x h\n", (int )*(record->data + index_data) & 15);
    }
  }
  {
#line 3703
  index_data ++;
#line 3704
  tmp___1 = index_data;
#line 3704
  index_data ++;
#line 3704
  ch_count = (int )*(record->data + tmp___1);
#line 3705
  printf((char const   */* __restrict  */)"AMC Channel Descriptor count: %02x h\n",
         ch_count);
  }
#line 3707
  if (ch_count > 0) {
#line 3708
    index___0 = 0;
    {
#line 3708
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3708
      if (! (index___0 < ch_count)) {
#line 3708
        goto while_break___1;
      }
      {
#line 3711
      printf((char const   */* __restrict  */)"   AMC Channel Descriptor {%02x%02x%02x}\n",
             (int )*(record->data + (index_data + 2)), (int )*(record->data + (index_data + 1)),
             (int )*(record->data + index_data));
#line 3715
      data = (unsigned int )(((int )*(record->data + index_data) | ((int )*(record->data + (index_data + 1)) << 8)) | ((int )*(record->data + (index_data + 2)) << 16));
#line 3718
      ch_desc = (struct fru_picmgext_amc_channel_desc_record *)(& data);
#line 3719
      printf((char const   */* __restrict  */)"      Lane 0 Port: %d\n", ch_desc->lane0port);
#line 3720
      printf((char const   */* __restrict  */)"      Lane 1 Port: %d\n", ch_desc->lane1port);
#line 3721
      printf((char const   */* __restrict  */)"      Lane 2 Port: %d\n", ch_desc->lane2port);
#line 3722
      printf((char const   */* __restrict  */)"      Lane 3 Port: %d\n\n", ch_desc->lane3port);
#line 3723
      index_data += 3;
#line 3708
      index___0 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 3726
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3726
    if (! (index_data < (int )record->header.len)) {
#line 3726
      goto while_break___2;
    }
    {
#line 3730
    data___0[0] = (unsigned int )((((int )*(record->data + index_data) | ((int )*(record->data + (index_data + 1)) << 8)) | ((int )*(record->data + (index_data + 2)) << 16)) | ((int )*(record->data + (index_data + 3)) << 24));
#line 3734
    data___0[1] = (unsigned int )*(record->data + (index_data + 4));
#line 3736
    link_desc = (struct fru_picmgext_amc_link_desc_record *)(& data___0[0]);
#line 3738
    printf((char const   */* __restrict  */)"   AMC Link Descriptor:\n");
#line 3740
    tmp___2 = val2str((uint16_t )link_desc->type, ipmi_ekanalyzer_link_type);
#line 3740
    printf((char const   */* __restrict  */)"\t- Link Type: %s \n", tmp___2);
    }
    {
#line 3745
    if (link_desc->type == 4U) {
#line 3745
      goto case_4;
    }
#line 3745
    if (link_desc->type == 3U) {
#line 3745
      goto case_4;
    }
#line 3745
    if (link_desc->type == 2U) {
#line 3745
      goto case_4;
    }
#line 3753
    if (link_desc->type == 5U) {
#line 3753
      goto case_5;
    }
#line 3762
    if (link_desc->type == 7U) {
#line 3762
      goto case_7;
    }
#line 3771
    goto switch_default;
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 3746
    tmp___3 = val2str((uint16_t )link_desc->type_ext, ipmi_ekanalyzer_extension_PCIE);
#line 3746
    printf((char const   */* __restrict  */)"\t- Link Type extension: %s\n", tmp___3);
#line 3748
    printf((char const   */* __restrict  */)"\t- Link Group ID: %d\n ", link_desc->group_id);
#line 3749
    tmp___4 = val2str((uint16_t )link_desc->asym_match, ipmi_ekanalyzer_asym_PCIE);
#line 3749
    printf((char const   */* __restrict  */)"\t- Link Asym. Match: %d - %s\n", link_desc->asym_match,
           tmp___4);
    }
#line 3752
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 3754
    tmp___5 = val2str((uint16_t )link_desc->type_ext, ipmi_ekanalyzer_extension_ETHERNET);
#line 3754
    printf((char const   */* __restrict  */)"\t- Link Type extension: %s\n", tmp___5);
#line 3757
    printf((char const   */* __restrict  */)"\t- Link Group ID: %d \n", link_desc->group_id);
#line 3758
    tmp___6 = val2str((uint16_t )link_desc->asym_match, ipmi_ekanalyzer_asym_PCIE);
#line 3758
    printf((char const   */* __restrict  */)"\t- Link Asym. Match: %d - %s\n", link_desc->asym_match,
           tmp___6);
    }
#line 3761
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 3763
    tmp___7 = val2str((uint16_t )link_desc->type_ext, ipmi_ekanalyzer_extension_STORAGE);
#line 3763
    printf((char const   */* __restrict  */)"\t- Link Type extension: %s\n", tmp___7);
#line 3766
    printf((char const   */* __restrict  */)"\t- Link Group ID: %d \n", link_desc->group_id);
#line 3767
    tmp___8 = val2str((uint16_t )link_desc->asym_match, ipmi_ekanalyzer_asym_STORAGE);
#line 3767
    printf((char const   */* __restrict  */)"\t- Link Asym. Match: %d - %s\n", link_desc->asym_match,
           tmp___8);
    }
#line 3770
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 3772
    printf((char const   */* __restrict  */)"\t- Link Type extension: %i (Unknown)\n",
           link_desc->type_ext);
#line 3773
    printf((char const   */* __restrict  */)"\t- Link Group ID: %d \n", link_desc->group_id);
#line 3774
    printf((char const   */* __restrict  */)"\t- Link Asym. Match: %i\n", link_desc->asym_match);
    }
#line 3775
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 3777
    printf((char const   */* __restrict  */)"\t- AMC Link Designator:\n");
#line 3778
    printf((char const   */* __restrict  */)"\t    Channel ID: %i\n", link_desc->channel_id);
    }
#line 3779
    if (link_desc->port_flag_0) {
#line 3779
      tmp___9 = "enable";
    } else {
#line 3779
      tmp___9 = "disable";
    }
    {
#line 3779
    printf((char const   */* __restrict  */)"\t\t Lane 0: %s\n", tmp___9);
    }
#line 3780
    if (link_desc->port_flag_1) {
#line 3780
      tmp___10 = "enable";
    } else {
#line 3780
      tmp___10 = "disable";
    }
    {
#line 3780
    printf((char const   */* __restrict  */)"\t\t Lane 1: %s\n", tmp___10);
    }
#line 3781
    if (link_desc->port_flag_2) {
#line 3781
      tmp___11 = "enable";
    } else {
#line 3781
      tmp___11 = "disable";
    }
    {
#line 3781
    printf((char const   */* __restrict  */)"\t\t Lane 2: %s\n", tmp___11);
    }
#line 3782
    if (link_desc->port_flag_3) {
#line 3782
      tmp___12 = "enable";
    } else {
#line 3782
      tmp___12 = "disable";
    }
    {
#line 3782
    printf((char const   */* __restrict  */)"\t\t Lane 3: %s\n", tmp___12);
#line 3783
    index_data += 5;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3785
  return;
}
}
#line 3804 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_amc_carrier_info_record(struct ipmi_ek_multi_header *record ) 
{ 
  unsigned char extVersion ;
  unsigned char siteCount ;
  int offset ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 3809
  offset = (int )START_DATA_OFFSET;
#line 3811
  tmp = offset;
#line 3811
  offset ++;
#line 3811
  extVersion = *(record->data + tmp);
#line 3812
  tmp___0 = offset;
#line 3812
  offset ++;
#line 3812
  siteCount = *(record->data + tmp___0);
#line 3814
  printf((char const   */* __restrict  */)"   AMC.0 extension version: R%d.%d\n",
         (int )extVersion & 15, ((int )extVersion >> 4) & 15);
#line 3816
  printf((char const   */* __restrict  */)"   Carrier Sie Number Count: %d\n", (int )siteCount);
  }
  {
#line 3818
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3818
    if (! ((int )siteCount > 0)) {
#line 3818
      goto while_break;
    }
    {
#line 3819
    tmp___1 = val2str((uint16_t )*(record->data + offset), ipmi_ekanalyzer_module_type);
#line 3819
    printf((char const   */* __restrict  */)"\tSite ID (%d): %s \n", (int )*(record->data + offset),
           tmp___1);
#line 3821
    offset ++;
#line 3822
    siteCount = (unsigned char )((int )siteCount - 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3824
  printf((char const   */* __restrict  */)"\n");
  }
#line 3825
  return;
}
}
#line 3846 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_clock_carrier_p2p_record(struct ipmi_ek_multi_header *record ) 
{ 
  unsigned char desc_count ;
  int i ;
  int j ;
  int offset ;
  int tmp ;
  unsigned char resource_id ;
  unsigned char channel_count ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned char loc_channel ;
  unsigned char rem_channel ;
  unsigned char rem_resource ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 3852
  offset = (int )START_DATA_OFFSET;
#line 3854
  tmp = offset;
#line 3854
  offset ++;
#line 3854
  desc_count = *(record->data + tmp);
#line 3856
  i = 0;
  {
#line 3856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3856
    if (! (i < (int )desc_count)) {
#line 3856
      goto while_break;
    }
    {
#line 3860
    tmp___0 = offset;
#line 3860
    offset ++;
#line 3860
    resource_id = *(record->data + tmp___0);
#line 3861
    tmp___1 = offset;
#line 3861
    offset ++;
#line 3861
    channel_count = *(record->data + tmp___1);
#line 3863
    printf((char const   */* __restrict  */)"   Clock Resource ID: 0x%02x\n", (int )resource_id);
#line 3864
    printf((char const   */* __restrict  */)"   Type: ");
    }
#line 3865
    if (((int )resource_id & 192) >> 6 == 0) {
      {
#line 3866
      printf((char const   */* __restrict  */)"On-Carrier-Device\n");
      }
    } else
#line 3868
    if (((int )resource_id & 192) >> 6 == 1) {
      {
#line 3869
      printf((char const   */* __restrict  */)"AMC slot\n");
      }
    } else
#line 3871
    if (((int )resource_id & 192) >> 6 == 2) {
      {
#line 3872
      printf((char const   */* __restrict  */)"Backplane\n");
      }
    } else {
      {
#line 3875
      printf((char const   */* __restrict  */)"reserved\n");
      }
    }
    {
#line 3877
    printf((char const   */* __restrict  */)"   Channel Count: 0x%02x\n", (int )channel_count);
#line 3879
    j = 0;
    }
    {
#line 3879
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3879
      if (! (j < (int )channel_count)) {
#line 3879
        goto while_break___0;
      }
      {
#line 3882
      tmp___2 = offset;
#line 3882
      offset ++;
#line 3882
      loc_channel = *(record->data + tmp___2);
#line 3883
      tmp___3 = offset;
#line 3883
      offset ++;
#line 3883
      rem_channel = *(record->data + tmp___3);
#line 3884
      tmp___4 = offset;
#line 3884
      offset ++;
#line 3884
      rem_resource = *(record->data + tmp___4);
#line 3886
      printf((char const   */* __restrict  */)"\tCLK-ID: 0x%02x   --->  ", (int )loc_channel);
#line 3887
      printf((char const   */* __restrict  */)" remote CLKID: 0x%02x   ", (int )rem_channel);
      }
#line 3888
      if (((int )rem_resource & 192) >> 6 == 0) {
        {
#line 3889
        printf((char const   */* __restrict  */)"[ Carrier-Dev");
        }
      } else
#line 3891
      if (((int )rem_resource & 192) >> 6 == 1) {
        {
#line 3892
        printf((char const   */* __restrict  */)"[ AMC slot    ");
        }
      } else
#line 3894
      if (((int )rem_resource & 192) >> 6 == 2) {
        {
#line 3895
        printf((char const   */* __restrict  */)"[ Backplane    ");
        }
      } else {
        {
#line 3898
        printf((char const   */* __restrict  */)"reserved          ");
        }
      }
      {
#line 3900
      printf((char const   */* __restrict  */)" 0x%02x ]\n", (int )rem_resource & 15);
#line 3879
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3856
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3903
  printf((char const   */* __restrict  */)"\n");
  }
#line 3904
  return;
}
}
#line 3924 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_clock_config_record(struct ipmi_ek_multi_header *record ) 
{ 
  unsigned char resource_id ;
  unsigned char descr_count ;
  int i ;
  int offset ;
  int tmp ;
  int tmp___0 ;
  unsigned char channel_id ;
  unsigned char control ;
  unsigned char indirect_cnt ;
  unsigned char direct_cnt ;
  int j ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned char feature ;
  unsigned char dep_chn_id ;
  int tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  unsigned char feature___0 ;
  unsigned char family ;
  unsigned char accuracy ;
  unsigned long freq ;
  unsigned long min_freq ;
  unsigned long max_freq ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;

  {
  {
#line 3929
  offset = (int )START_DATA_OFFSET;
#line 3931
  tmp = offset;
#line 3931
  offset ++;
#line 3931
  resource_id = *(record->data + tmp);
#line 3932
  tmp___0 = offset;
#line 3932
  offset ++;
#line 3932
  descr_count = *(record->data + tmp___0);
#line 3933
  printf((char const   */* __restrict  */)"   Clock Resource ID: 0x%02x\n", (int )resource_id);
#line 3934
  printf((char const   */* __restrict  */)"   Clock Configuration Descriptor Count: 0x%02x\n",
         (int )descr_count);
#line 3936
  i = 0;
  }
  {
#line 3936
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3936
    if (! (i < (int )descr_count)) {
#line 3936
      goto while_break;
    }
    {
#line 3939
    j = 0;
#line 3941
    tmp___1 = offset;
#line 3941
    offset ++;
#line 3941
    channel_id = *(record->data + tmp___1);
#line 3942
    tmp___2 = offset;
#line 3942
    offset ++;
#line 3942
    control = *(record->data + tmp___2);
#line 3943
    printf((char const   */* __restrict  */)"\tCLK-ID: 0x%02x  -  ", (int )channel_id);
    }
#line 3944
    if (((int )control & 1) == 0) {
#line 3944
      tmp___3 = "Carrier IPMC";
    } else {
#line 3944
      tmp___3 = "Application";
    }
    {
#line 3944
    printf((char const   */* __restrict  */)"CTRL 0x%02x [ %12s ]\n", (int )control,
           tmp___3);
#line 3947
    tmp___4 = offset;
#line 3947
    offset ++;
#line 3947
    indirect_cnt = *(record->data + tmp___4);
#line 3948
    tmp___5 = offset;
#line 3948
    offset ++;
#line 3948
    direct_cnt = *(record->data + tmp___5);
#line 3949
    printf((char const   */* __restrict  */)"\t   Count: Indirect 0x%02x   / Direct 0x%02x\n",
           (int )indirect_cnt, (int )direct_cnt);
#line 3953
    j = 0;
    }
    {
#line 3953
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3953
      if (! (j < (int )indirect_cnt)) {
#line 3953
        goto while_break___0;
      }
#line 3957
      tmp___6 = offset;
#line 3957
      offset ++;
#line 3957
      feature = *(record->data + tmp___6);
#line 3958
      tmp___7 = offset;
#line 3958
      offset ++;
#line 3958
      dep_chn_id = *(record->data + tmp___7);
#line 3959
      if (((int )feature & 1) == 1) {
#line 3959
        tmp___8 = "Source";
      } else {
#line 3959
        tmp___8 = "Receiver";
      }
      {
#line 3959
      printf((char const   */* __restrict  */)"\t\tFeature: 0x%02x [%8s] - ", (int )feature,
             tmp___8);
#line 3961
      printf((char const   */* __restrict  */)" Dep. CLK-ID: 0x%02x\n", (int )dep_chn_id);
#line 3953
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3965
    j = 0;
    {
#line 3965
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3965
      if (! (j < (int )direct_cnt)) {
#line 3965
        goto while_break___1;
      }
#line 3969
      tmp___9 = offset;
#line 3969
      offset ++;
#line 3969
      feature___0 = *(record->data + tmp___9);
#line 3970
      tmp___10 = offset;
#line 3970
      offset ++;
#line 3970
      family = *(record->data + tmp___10);
#line 3971
      tmp___11 = offset;
#line 3971
      offset ++;
#line 3971
      accuracy = *(record->data + tmp___11);
#line 3972
      freq = (unsigned long )((((int )*(record->data + offset) | ((int )*(record->data + (offset + 1)) << 8)) | ((int )*(record->data + (offset + 2)) << 16)) | ((int )*(record->data + (offset + 3)) << 24));
#line 3976
      offset += 4;
#line 3977
      min_freq = (unsigned long )((((int )*(record->data + offset) | ((int )*(record->data + (offset + 1)) << 8)) | ((int )*(record->data + (offset + 2)) << 16)) | ((int )*(record->data + (offset + 3)) << 24));
#line 3981
      offset += 4;
#line 3982
      max_freq = (unsigned long )((((int )*(record->data + offset) | ((int )*(record->data + (offset + 1)) << 8)) | ((int )*(record->data + (offset + 2)) << 16)) | ((int )*(record->data + (offset + 3)) << 24));
#line 3986
      offset += 4;
#line 3988
      if ((int )feature___0 & 1) {
#line 3988
        tmp___12 = "Source";
      } else {
#line 3988
        tmp___12 = "Receiver";
      }
      {
#line 3988
      printf((char const   */* __restrict  */)"\t- Feature: 0x%02x    - PLL: %x / Asym: %s\n",
             (int )feature___0, ((int )feature___0 > 1) & 1, tmp___12);
#line 3992
      printf((char const   */* __restrict  */)"\tFamily:  0x%02x    - AccLVL: 0x%02x\n",
             (int )family, (int )accuracy);
#line 3993
      printf((char const   */* __restrict  */)"\tFRQ: %-9ld - min: %-9ld - max: %-9ld\n",
             freq, min_freq, max_freq);
#line 3965
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3996
    printf((char const   */* __restrict  */)"\n");
#line 3936
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3998
  return;
}
}
#line 4019 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ekanalyzer_fru_file2structure(char *filename , struct ipmi_ek_multi_header **list_head ,
                                              struct ipmi_ek_multi_header **list_record ,
                                              struct ipmi_ek_multi_header **list_last ) 
{ 
  FILE *input_file ;
  unsigned char data ;
  unsigned char last_record ;
  unsigned int multi_offset ;
  int record_count ;
  int ret ;
  size_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int i ;
  int tmp___7 ;

  {
  {
#line 4027
  last_record = (unsigned char)0;
#line 4028
  multi_offset = 0U;
#line 4029
  record_count = 0;
#line 4030
  ret = 0;
#line 4032
  input_file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 4033
  if ((unsigned long )input_file == (unsigned long )((void *)0)) {
    {
#line 4034
    lprintf(3, "File: \'%s\' is not found", filename);
    }
#line 4035
    return ((int )ERROR_STATUS);
  }
  {
#line 4038
  fseek(input_file, (long )START_DATA_OFFSET, 0);
#line 4039
  data = (unsigned char)0;
#line 4040
  tmp = fread((void */* __restrict  */)(& data), (size_t )1, (size_t )1, (FILE */* __restrict  */)input_file);
#line 4040
  ret = (int )tmp;
  }
#line 4041
  if (ret != 1) {
    {
#line 4042
    lprintf(3, "Invalid Offset!");
#line 4043
    fclose(input_file);
    }
#line 4044
    return ((int )ERROR_STATUS);
  } else {
    {
#line 4041
    tmp___0 = ferror(input_file);
    }
#line 4041
    if (tmp___0) {
      {
#line 4042
      lprintf(3, "Invalid Offset!");
#line 4043
      fclose(input_file);
      }
#line 4044
      return ((int )ERROR_STATUS);
    }
  }
#line 4046
  if ((int )data == 0) {
    {
#line 4047
    lprintf(3, "There is no multi record in the file \'%s\'", filename);
#line 4049
    fclose(input_file);
    }
#line 4050
    return ((int )ERROR_STATUS);
  }
  {
#line 4053
  multi_offset = (unsigned int )((int )data * 8);
#line 4054
  lprintf(7, "start multi offset = 0x%02x", multi_offset);
#line 4057
  fseek(input_file, (long )multi_offset, 0);
  }
  {
#line 4058
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4058
    tmp___7 = feof(input_file);
    }
#line 4058
    if (tmp___7) {
#line 4058
      goto while_break;
    }
    {
#line 4059
    tmp___1 = malloc(sizeof(struct ipmi_ek_multi_header ));
#line 4059
    *list_record = (struct ipmi_ek_multi_header *)tmp___1;
#line 4060
    tmp___2 = fread((void */* __restrict  */)(& (*list_record)->header), (size_t )START_DATA_OFFSET,
                    (size_t )1, (FILE */* __restrict  */)input_file);
#line 4060
    ret = (int )tmp___2;
    }
#line 4062
    if (ret != 1) {
      {
#line 4063
      lprintf(3, "Invalid Header!");
#line 4064
      fclose(input_file);
      }
#line 4065
      return ((int )ERROR_STATUS);
    } else {
      {
#line 4062
      tmp___3 = ferror(input_file);
      }
#line 4062
      if (tmp___3) {
        {
#line 4063
        lprintf(3, "Invalid Header!");
#line 4064
        fclose(input_file);
        }
#line 4065
        return ((int )ERROR_STATUS);
      }
    }
#line 4067
    if ((int )(*list_record)->header.len == 0) {
#line 4068
      record_count ++;
#line 4069
      goto while_continue;
    }
    {
#line 4071
    tmp___4 = malloc((size_t )(*list_record)->header.len);
#line 4071
    (*list_record)->data = (unsigned char *)tmp___4;
    }
#line 4072
    if ((unsigned long )(*list_record)->data == (unsigned long )((void *)0)) {
      {
#line 4073
      lprintf(3, "Failed to allocation memory size %d\n", (int )(*list_record)->header.len);
#line 4075
      record_count ++;
      }
#line 4076
      goto while_continue;
    }
    {
#line 4079
    tmp___5 = fread((void */* __restrict  */)(*list_record)->data, (size_t )(*list_record)->header.len,
                    (size_t )1, (FILE */* __restrict  */)input_file);
#line 4079
    ret = (int )tmp___5;
    }
#line 4081
    if (ret != 1) {
      {
#line 4082
      lprintf(3, "Invalid Record Data!");
#line 4083
      fclose(input_file);
      }
#line 4084
      return ((int )ERROR_STATUS);
    } else {
      {
#line 4081
      tmp___6 = ferror(input_file);
      }
#line 4081
      if (tmp___6) {
        {
#line 4082
        lprintf(3, "Invalid Record Data!");
#line 4083
        fclose(input_file);
        }
#line 4084
        return ((int )ERROR_STATUS);
      }
    }
#line 4086
    if (verbose > 0) {
      {
#line 4087
      printf((char const   */* __restrict  */)"Record %d has length = %02x\n", record_count,
             (int )(*list_record)->header.len);
      }
    }
#line 4089
    if (verbose > 1) {
      {
#line 4091
      printf((char const   */* __restrict  */)"Type: %02x", (int )(*list_record)->header.type);
#line 4092
      i = 0;
      }
      {
#line 4092
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 4092
        if (! (i < (int )(*list_record)->header.len)) {
#line 4092
          goto while_break___0;
        }
#line 4093
        if (! (i % 8)) {
          {
#line 4094
          printf((char const   */* __restrict  */)"\n0x%02x: ", i);
          }
        }
        {
#line 4096
        printf((char const   */* __restrict  */)"%02x ", (int )*((*list_record)->data + i));
#line 4092
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 4099
      printf((char const   */* __restrict  */)"\n\n");
      }
    }
    {
#line 4101
    ipmi_ek_add_record2list(list_record, list_head, list_last);
#line 4103
    last_record = (unsigned char )((int )(*list_record)->header.format & 128);
    }
#line 4104
    if (last_record) {
#line 4105
      goto while_break;
    }
#line 4107
    record_count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4109
  fclose(input_file);
  }
#line 4110
  return ((int )OK_STATUS);
}
}
#line 4132 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_add_record2list(struct ipmi_ek_multi_header **record , struct ipmi_ek_multi_header **list_head ,
                                    struct ipmi_ek_multi_header **list_last ) 
{ 


  {
#line 4137
  if ((unsigned long )*list_head == (unsigned long )((void *)0)) {
#line 4138
    *list_head = *record;
#line 4139
    (*record)->prev = (struct ipmi_ek_multi_header *)((void *)0);
#line 4140
    if (verbose > 2) {
      {
#line 4141
      printf((char const   */* __restrict  */)"Adding first record to list\n");
      }
    }
  } else {
#line 4144
    (*list_last)->next = *record;
#line 4145
    (*record)->prev = *list_last;
#line 4146
    if (verbose > 2) {
      {
#line 4147
      printf((char const   */* __restrict  */)"Add 1 record to list\n");
      }
    }
  }
#line 4149
  *list_last = *record;
#line 4150
  (*record)->next = (struct ipmi_ek_multi_header *)((void *)0);
#line 4151
  return;
}
}
#line 4171 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_remove_record_from_list(struct ipmi_ek_multi_header *record ,
                                            struct ipmi_ek_multi_header **list_head ,
                                            struct ipmi_ek_multi_header **list_last ) 
{ 


  {
#line 4176
  if ((unsigned long )record->prev == (unsigned long )((void *)0)) {
#line 4177
    *list_head = record->next;
  } else {
#line 4179
    (record->prev)->next = record->next;
  }
#line 4180
  if ((unsigned long )record->next == (unsigned long )((void *)0)) {
#line 4181
    *list_last = record->prev;
  } else {
#line 4183
    (record->next)->prev = record->prev;
  }
  {
#line 4184
  free((void *)record);
#line 4185
  record = (struct ipmi_ek_multi_header *)((void *)0);
  }
#line 4186
  return;
}
}
#line 106 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ldexp)(double __x ,
                                                                               int __exponent ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/dimm_spd.c"
struct valstr  const  spd_memtype_vals[11]  = 
#line 55 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/dimm_spd.c"
  {      {(uint16_t )1, "STD FPM DRAM"}, 
        {(uint16_t )2, "EDO"}, 
        {(uint16_t )4, "SDRAM"}, 
        {(uint16_t )5, "ROM"}, 
        {(uint16_t )6, "DDR SGRAM"}, 
        {(uint16_t )7, "DDR SDRAM"}, 
        {(uint16_t )8, "DDR2 SDRAM"}, 
        {(uint16_t )9, "DDR2 SDRAM FB-DIMM"}, 
        {(uint16_t )10, "DDR2 SDRAM FB-DIMM Probe"}, 
        {(uint16_t )11, "DDR3 SDRAM"}, 
        {(uint16_t )0, (char const   *)((void *)0)}};
#line 69 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/dimm_spd.c"
struct valstr  const  ddr3_density_vals[8]  = 
#line 69
  {      {(uint16_t )0, "256 Mb"}, 
        {(uint16_t )1, "512 Mb"}, 
        {(uint16_t )2, "1 Gb"}, 
        {(uint16_t )3, "2 Gb"}, 
        {(uint16_t )4, "4 Gb"}, 
        {(uint16_t )5, "8 Gb"}, 
        {(uint16_t )6, "16 Gb"}, 
        {(uint16_t )0, (char const   *)((void *)0)}};
#line 81 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/dimm_spd.c"
struct valstr  const  ddr3_banks_vals[5]  = {      {(uint16_t )0, "3 (8 Banks)"}, 
        {(uint16_t )1, "4 (16 Banks)"}, 
        {(uint16_t )2, "5 (32 Banks)"}, 
        {(uint16_t )3, "6 (64 Banks)"}, 
        {(uint16_t )0, (char const   *)((void *)0)}};
#line 90 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/dimm_spd.c"
struct valstr  const  ddr3_ecc_vals[3]  = {      {(uint16_t )0, "0 bits"}, 
        {(uint16_t )1, "8 bits"}, 
        {(uint16_t )0, (char const   *)((void *)0)}};
#line 97 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/dimm_spd.c"
struct valstr  const  spd_config_vals[5]  = {      {(uint16_t )0, "None"}, 
        {(uint16_t )1, "Parity"}, 
        {(uint16_t )2, "ECC"}, 
        {(uint16_t )4, "Addr Cmd Parity"}, 
        {(uint16_t )0, (char const   *)((void *)0)}};
#line 105 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/dimm_spd.c"
struct valstr  const  spd_voltage_vals[7]  = {      {(uint16_t )0, "5.0V TTL"}, 
        {(uint16_t )1, "LVTTL"}, 
        {(uint16_t )2, "HSTL 1.5V"}, 
        {(uint16_t )3, "SSTL 3.3V"}, 
        {(uint16_t )4, "SSTL 2.5V"}, 
        {(uint16_t )5, "SSTL 1.8V"}, 
        {(uint16_t )0, (char const   *)((void *)0)}};
#line 120 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/dimm_spd.c"
struct valstr  const  jedec_id1_vals[127]  = 
#line 120
  {      {(uint16_t )1, "AMD"}, 
        {(uint16_t )2, "AMI"}, 
        {(uint16_t )131, "Fairchild"}, 
        {(uint16_t )4, "Fujitsu"}, 
        {(uint16_t )133, "GTE"}, 
        {(uint16_t )134, "Harris"}, 
        {(uint16_t )7, "Hitachi"}, 
        {(uint16_t )8, "Inmos"}, 
        {(uint16_t )137, "Intel"}, 
        {(uint16_t )138, "I.T.T."}, 
        {(uint16_t )11, "Intersil"}, 
        {(uint16_t )140, "Monolithic Memories"}, 
        {(uint16_t )13, "Mostek"}, 
        {(uint16_t )14, "Motorola"}, 
        {(uint16_t )143, "National"}, 
        {(uint16_t )16, "NEC"}, 
        {(uint16_t )145, "RCA"}, 
        {(uint16_t )146, "Raytheon"}, 
        {(uint16_t )19, "Conexant (Rockwell)"}, 
        {(uint16_t )148, "Seeq"}, 
        {(uint16_t )21, "Philips Semi. (Signetics)"}, 
        {(uint16_t )22, "Synertek"}, 
        {(uint16_t )151, "Texas Instruments"}, 
        {(uint16_t )152, "Toshiba"}, 
        {(uint16_t )25, "Xicor"}, 
        {(uint16_t )26, "Zilog"}, 
        {(uint16_t )155, "Eurotechnique"}, 
        {(uint16_t )28, "Mitsubishi"}, 
        {(uint16_t )157, "Lucent (AT&T)"}, 
        {(uint16_t )158, "Exel"}, 
        {(uint16_t )31, "Atmel"}, 
        {(uint16_t )32, "SGS/Thomson"}, 
        {(uint16_t )161, "Lattice Semi."}, 
        {(uint16_t )162, "NCR"}, 
        {(uint16_t )35, "Wafer Scale Integration"}, 
        {(uint16_t )164, "IBM"}, 
        {(uint16_t )37, "Tristar"}, 
        {(uint16_t )38, "Visic"}, 
        {(uint16_t )167, "Intl. CMOS Technology"}, 
        {(uint16_t )168, "SSSI"}, 
        {(uint16_t )41, "Microchip Technology"}, 
        {(uint16_t )42, "Ricoh Ltd."}, 
        {(uint16_t )171, "VLSI"}, 
        {(uint16_t )44, "Micron Technology"}, 
        {(uint16_t )173, "Hyundai Electronics"}, 
        {(uint16_t )174, "OKI Semiconductor"}, 
        {(uint16_t )47, "ACTEL"}, 
        {(uint16_t )176, "Sharp"}, 
        {(uint16_t )49, "Catalyst"}, 
        {(uint16_t )50, "Panasonic"}, 
        {(uint16_t )179, "IDT"}, 
        {(uint16_t )52, "Cypress"}, 
        {(uint16_t )181, "DEC"}, 
        {(uint16_t )182, "LSI Logic"}, 
        {(uint16_t )55, "Zarlink"}, 
        {(uint16_t )56, "UTMC"}, 
        {(uint16_t )185, "Thinking Machine"}, 
        {(uint16_t )186, "Thomson CSF"}, 
        {(uint16_t )59, "Integrated CMOS(Vertex)"}, 
        {(uint16_t )188, "Honeywell"}, 
        {(uint16_t )61, "Tektronix"}, 
        {(uint16_t )62, "Sun Microsystems"}, 
        {(uint16_t )191, "SST"}, 
        {(uint16_t )64, "MOSEL"}, 
        {(uint16_t )193, "Infineon"}, 
        {(uint16_t )194, "Macronix"}, 
        {(uint16_t )67, "Xerox"}, 
        {(uint16_t )196, "Plus Logic"}, 
        {(uint16_t )69, "SunDisk"}, 
        {(uint16_t )70, "Elan Circuit Tech."}, 
        {(uint16_t )199, "European Silicon Str."}, 
        {(uint16_t )200, "Apple Computer"}, 
        {(uint16_t )201, "Xilinx"}, 
        {(uint16_t )74, "Compaq"}, 
        {(uint16_t )203, "Protocol Engines"}, 
        {(uint16_t )76, "SCI"}, 
        {(uint16_t )205, "Seiko Instruments"}, 
        {(uint16_t )206, "Samsung"}, 
        {(uint16_t )79, "I3 Design System"}, 
        {(uint16_t )208, "Klic"}, 
        {(uint16_t )81, "Crosspoint Solutions"}, 
        {(uint16_t )82, "Alliance Semiconductor"}, 
        {(uint16_t )211, "Tandem"}, 
        {(uint16_t )84, "Hewlett-Packard"}, 
        {(uint16_t )213, "Intg. Silicon Solutions"}, 
        {(uint16_t )214, "Brooktree"}, 
        {(uint16_t )87, "New Media"}, 
        {(uint16_t )88, "MHS Electronic"}, 
        {(uint16_t )217, "Performance Semi."}, 
        {(uint16_t )218, "Winbond Electronic"}, 
        {(uint16_t )91, "Kawasaki Steel"}, 
        {(uint16_t )220, "Bright Micro"}, 
        {(uint16_t )93, "TECMAR"}, 
        {(uint16_t )94, "Exar"}, 
        {(uint16_t )223, "PCMCIA"}, 
        {(uint16_t )224, "LG Semiconductor"}, 
        {(uint16_t )97, "Northern Telecom"}, 
        {(uint16_t )98, "Sanyo"}, 
        {(uint16_t )227, "Array Microsystems"}, 
        {(uint16_t )100, "Crystal Semiconductor"}, 
        {(uint16_t )229, "Analog Devices"}, 
        {(uint16_t )230, "PMC-Sierra"}, 
        {(uint16_t )103, "Asparix"}, 
        {(uint16_t )104, "Convex Computer"}, 
        {(uint16_t )233, "Quality Semiconductor"}, 
        {(uint16_t )234, "Nimbus Technology"}, 
        {(uint16_t )107, "Transwitch"}, 
        {(uint16_t )236, "Micronas (ITT Intermetall)"}, 
        {(uint16_t )109, "Cannon"}, 
        {(uint16_t )110, "Altera"}, 
        {(uint16_t )239, "NEXCOM"}, 
        {(uint16_t )112, "QUALCOMM"}, 
        {(uint16_t )241, "Sony"}, 
        {(uint16_t )242, "Cray Research"}, 
        {(uint16_t )115, "AMS (Austria Micro)"}, 
        {(uint16_t )244, "Vitesse"}, 
        {(uint16_t )117, "Aster Electronics"}, 
        {(uint16_t )118, "Bay Networks (Synoptic)"}, 
        {(uint16_t )247, "Zentrum"}, 
        {(uint16_t )248, "TRW"}, 
        {(uint16_t )121, "Thesys"}, 
        {(uint16_t )122, "Solbourne Computer"}, 
        {(uint16_t )251, "Allied-Signal"}, 
        {(uint16_t )124, "Dialog"}, 
        {(uint16_t )253, "Media Vision"}, 
        {(uint16_t )254, "Level One Communication"}, 
        {(uint16_t )0, (char const   *)((void *)0)}};
#line 250 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/dimm_spd.c"
struct valstr  const  jedec_id2_vals[127]  = 
#line 250
  {      {(uint16_t )1, "Cirrus Logic"}, 
        {(uint16_t )2, "National Instruments"}, 
        {(uint16_t )131, "ILC Data Device"}, 
        {(uint16_t )4, "Alcatel Mietec"}, 
        {(uint16_t )133, "Micro Linear"}, 
        {(uint16_t )134, "Univ. of NC"}, 
        {(uint16_t )7, "JTAG Technologies"}, 
        {(uint16_t )8, "Loral"}, 
        {(uint16_t )137, "Nchip"}, 
        {(uint16_t )138, "Galileo Tech"}, 
        {(uint16_t )11, "Bestlink Systems"}, 
        {(uint16_t )140, "Graychip"}, 
        {(uint16_t )13, "GENNUM"}, 
        {(uint16_t )14, "VideoLogic"}, 
        {(uint16_t )143, "Robert Bosch"}, 
        {(uint16_t )16, "Chip Express"}, 
        {(uint16_t )145, "DATARAM"}, 
        {(uint16_t )146, "United Microelec Corp."}, 
        {(uint16_t )19, "TCSI"}, 
        {(uint16_t )148, "Smart Modular"}, 
        {(uint16_t )21, "Hughes Aircraft"}, 
        {(uint16_t )22, "Lanstar Semiconductor"}, 
        {(uint16_t )151, "Qlogic"}, 
        {(uint16_t )152, "Kingston"}, 
        {(uint16_t )25, "Music Semi"}, 
        {(uint16_t )26, "Ericsson Components"}, 
        {(uint16_t )155, "SpaSE"}, 
        {(uint16_t )28, "Eon Silicon Devices"}, 
        {(uint16_t )157, "Programmable Micro Corp"}, 
        {(uint16_t )158, "DoD"}, 
        {(uint16_t )31, "Integ. Memories Tech."}, 
        {(uint16_t )32, "Corollary Inc."}, 
        {(uint16_t )161, "Dallas Semiconductor"}, 
        {(uint16_t )162, "Omnivision"}, 
        {(uint16_t )35, "EIV(Switzerland)"}, 
        {(uint16_t )164, "Novatel Wireless"}, 
        {(uint16_t )37, "Zarlink (formerly Mitel)"}, 
        {(uint16_t )38, "Clearpoint"}, 
        {(uint16_t )167, "Cabletron"}, 
        {(uint16_t )168, "Silicon Technology"}, 
        {(uint16_t )41, "Vanguard"}, 
        {(uint16_t )42, "Hagiwara Sys-Com"}, 
        {(uint16_t )171, "Vantis"}, 
        {(uint16_t )44, "Celestica"}, 
        {(uint16_t )173, "Century"}, 
        {(uint16_t )174, "Hal Computers"}, 
        {(uint16_t )47, "Rohm Company Ltd."}, 
        {(uint16_t )176, "Juniper Networks"}, 
        {(uint16_t )49, "Libit Signal Processing"}, 
        {(uint16_t )50, "Enhanced Memories Inc."}, 
        {(uint16_t )179, "Tundra Semiconductor"}, 
        {(uint16_t )52, "Adaptec Inc."}, 
        {(uint16_t )181, "LightSpeed Semi."}, 
        {(uint16_t )182, "ZSP Corp."}, 
        {(uint16_t )55, "AMIC Technology"}, 
        {(uint16_t )56, "Adobe Systems"}, 
        {(uint16_t )185, "Dynachip"}, 
        {(uint16_t )186, "PNY Electronics"}, 
        {(uint16_t )59, "Newport Digital"}, 
        {(uint16_t )188, "MMC Networks"}, 
        {(uint16_t )61, "T Square"}, 
        {(uint16_t )62, "Seiko Epson"}, 
        {(uint16_t )191, "Broadcom"}, 
        {(uint16_t )64, "Viking Components"}, 
        {(uint16_t )193, "V3 Semiconductor"}, 
        {(uint16_t )194, "Flextronics (formerly Orbit)"}, 
        {(uint16_t )67, "Suwa Electronics"}, 
        {(uint16_t )196, "Transmeta"}, 
        {(uint16_t )69, "Micron CMS"}, 
        {(uint16_t )70, "American Computer & Digital Components Inc"}, 
        {(uint16_t )199, "Enhance 3000 Inc"}, 
        {(uint16_t )200, "Tower Semiconductor"}, 
        {(uint16_t )73, "CPU Design"}, 
        {(uint16_t )74, "Price Point"}, 
        {(uint16_t )203, "Maxim Integrated Product"}, 
        {(uint16_t )76, "Tellabs"}, 
        {(uint16_t )205, "Centaur Technology"}, 
        {(uint16_t )206, "Unigen Corporation"}, 
        {(uint16_t )79, "Transcend Information"}, 
        {(uint16_t )208, "Memory Card Technology"}, 
        {(uint16_t )81, "CKD Corporation Ltd."}, 
        {(uint16_t )82, "Capital Instruments, Inc."}, 
        {(uint16_t )211, "Aica Kogyo, Ltd."}, 
        {(uint16_t )84, "Linvex Technology"}, 
        {(uint16_t )213, "MSC Vertriebs GmbH"}, 
        {(uint16_t )214, "AKM Company, Ltd."}, 
        {(uint16_t )87, "Dynamem, Inc."}, 
        {(uint16_t )88, "NERA ASA"}, 
        {(uint16_t )217, "GSI Technology"}, 
        {(uint16_t )218, "Dane-Elec (C Memory)"}, 
        {(uint16_t )91, "Acorn Computers"}, 
        {(uint16_t )220, "Lara Technology"}, 
        {(uint16_t )93, "Oak Technology, Inc."}, 
        {(uint16_t )94, "Itec Memory"}, 
        {(uint16_t )223, "Tanisys Technology"}, 
        {(uint16_t )224, "Truevision"}, 
        {(uint16_t )97, "Wintec Industries"}, 
        {(uint16_t )98, "Super PC Memory"}, 
        {(uint16_t )227, "MGV Memory"}, 
        {(uint16_t )100, "Galvantech"}, 
        {(uint16_t )229, "Gadzoox Nteworks"}, 
        {(uint16_t )230, "Multi Dimensional Cons."}, 
        {(uint16_t )103, "GateField"}, 
        {(uint16_t )104, "Integrated Memory System"}, 
        {(uint16_t )233, "Triscend"}, 
        {(uint16_t )234, "XaQti"}, 
        {(uint16_t )107, "Goldenram"}, 
        {(uint16_t )236, "Clear Logic"}, 
        {(uint16_t )109, "Cimaron Communications"}, 
        {(uint16_t )110, "Nippon Steel Semi. Corp."}, 
        {(uint16_t )239, "Advantage Memory"}, 
        {(uint16_t )112, "AMCC"}, 
        {(uint16_t )241, "LeCroy"}, 
        {(uint16_t )242, "Yamaha Corporation"}, 
        {(uint16_t )115, "Digital Microwave"}, 
        {(uint16_t )244, "NetLogic Microsystems"}, 
        {(uint16_t )117, "MIMOS Semiconductor"}, 
        {(uint16_t )118, "Advanced Fibre"}, 
        {(uint16_t )247, "BF Goodrich Data."}, 
        {(uint16_t )248, "Epigram"}, 
        {(uint16_t )121, "Acbel Polytech Inc."}, 
        {(uint16_t )122, "Apacer Technology"}, 
        {(uint16_t )251, "Admor Memory"}, 
        {(uint16_t )124, "FOXCONN"}, 
        {(uint16_t )253, "Quadratics Superconductor"}, 
        {(uint16_t )254, "3COM"}, 
        {(uint16_t )0, (char const   *)((void *)0)}};
#line 380 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/dimm_spd.c"
struct valstr  const  jedec_id3_vals[127]  = 
#line 380
  {      {(uint16_t )1, "Camintonn Corporation"}, 
        {(uint16_t )2, "ISOA Incorporated"}, 
        {(uint16_t )131, "Agate Semiconductor"}, 
        {(uint16_t )4, "ADMtek Incorporated"}, 
        {(uint16_t )133, "HYPERTEC"}, 
        {(uint16_t )134, "Adhoc Technologies"}, 
        {(uint16_t )7, "MOSAID Technologies"}, 
        {(uint16_t )8, "Ardent Technologies"}, 
        {(uint16_t )137, "Switchcore"}, 
        {(uint16_t )138, "Cisco Systems, Inc."}, 
        {(uint16_t )11, "Allayer Technologies"}, 
        {(uint16_t )140, "WorkX AG"}, 
        {(uint16_t )13, "Oasis Semiconductor"}, 
        {(uint16_t )14, "Novanet Semiconductor"}, 
        {(uint16_t )143, "E-M Solutions"}, 
        {(uint16_t )16, "Power General"}, 
        {(uint16_t )145, "Advanced Hardware Arch."}, 
        {(uint16_t )146, "Inova Semiconductors GmbH"}, 
        {(uint16_t )19, "Telocity"}, 
        {(uint16_t )148, "Delkin Devices"}, 
        {(uint16_t )21, "Symagery Microsystems"}, 
        {(uint16_t )22, "C-Port Corporation"}, 
        {(uint16_t )151, "SiberCore Technologies"}, 
        {(uint16_t )152, "Southland Microsystems"}, 
        {(uint16_t )25, "Malleable Technologies"}, 
        {(uint16_t )26, "Kendin Communications"}, 
        {(uint16_t )155, "Great Technology Microcomputer"}, 
        {(uint16_t )28, "Sanmina Corporation"}, 
        {(uint16_t )157, "HADCO Corporation"}, 
        {(uint16_t )158, "Corsair"}, 
        {(uint16_t )31, "Actrans System Inc."}, 
        {(uint16_t )32, "ALPHA Technologies"}, 
        {(uint16_t )161, "Cygnal Integrated Products Incorporated"}, 
        {(uint16_t )162, "Artesyn Technologies"}, 
        {(uint16_t )35, "Align Manufacturing"}, 
        {(uint16_t )164, "Peregrine Semiconductor"}, 
        {(uint16_t )37, "Chameleon Systems"}, 
        {(uint16_t )38, "Aplus Flash Technology"}, 
        {(uint16_t )167, "MIPS Technologies"}, 
        {(uint16_t )168, "Chrysalis ITS"}, 
        {(uint16_t )41, "ADTEC Corporation"}, 
        {(uint16_t )42, "Kentron Technologies"}, 
        {(uint16_t )171, "Win Technologies"}, 
        {(uint16_t )44, "ASIC Designs Inc"}, 
        {(uint16_t )173, "Extreme Packet Devices"}, 
        {(uint16_t )174, "RF Micro Devices"}, 
        {(uint16_t )47, "Siemens AG"}, 
        {(uint16_t )176, "Sarnoff Corporation"}, 
        {(uint16_t )49, "Itautec Philco SA"}, 
        {(uint16_t )50, "Radiata Inc."}, 
        {(uint16_t )179, "Benchmark Elect. (AVEX)"}, 
        {(uint16_t )52, "Legend"}, 
        {(uint16_t )181, "SpecTek Incorporated"}, 
        {(uint16_t )182, "Hi/fn"}, 
        {(uint16_t )55, "Enikia Incorporated"}, 
        {(uint16_t )56, "SwitchOn Networks"}, 
        {(uint16_t )185, "AANetcom Incorporated"}, 
        {(uint16_t )186, "Micro Memory Bank"}, 
        {(uint16_t )59, "ESS Technology"}, 
        {(uint16_t )188, "Virata Corporation"}, 
        {(uint16_t )61, "Excess Bandwidth"}, 
        {(uint16_t )62, "West Bay Semiconductor"}, 
        {(uint16_t )191, "DSP Group"}, 
        {(uint16_t )64, "Newport Communications"}, 
        {(uint16_t )193, "Chip2Chip Incorporated"}, 
        {(uint16_t )194, "Phobos Corporation"}, 
        {(uint16_t )67, "Intellitech Corporation"}, 
        {(uint16_t )196, "Nordic VLSI ASA"}, 
        {(uint16_t )69, "Ishoni Networks"}, 
        {(uint16_t )70, "Silicon Spice"}, 
        {(uint16_t )199, "Alchemy Semiconductor"}, 
        {(uint16_t )200, "Agilent Technologies"}, 
        {(uint16_t )73, "Centillium Communications"}, 
        {(uint16_t )74, "W.L. Gore"}, 
        {(uint16_t )203, "HanBit Electronics"}, 
        {(uint16_t )76, "GlobeSpan"}, 
        {(uint16_t )205, "Element 14"}, 
        {(uint16_t )206, "Pycon"}, 
        {(uint16_t )79, "Saifun Semiconductors"}, 
        {(uint16_t )208, "Sibyte, Incorporated"}, 
        {(uint16_t )81, "MetaLink Technologies"}, 
        {(uint16_t )82, "Feiya Technology"}, 
        {(uint16_t )211, "I & C Technology"}, 
        {(uint16_t )84, "Shikatronics"}, 
        {(uint16_t )213, "Elektrobit"}, 
        {(uint16_t )214, "Megic"}, 
        {(uint16_t )87, "Com-Tier"}, 
        {(uint16_t )88, "Malaysia Micro Solutions"}, 
        {(uint16_t )217, "Hyperchip"}, 
        {(uint16_t )218, "Gemstone Communications"}, 
        {(uint16_t )91, "Anadyne Microelectronics"}, 
        {(uint16_t )220, "3ParData"}, 
        {(uint16_t )93, "Mellanox Technologies"}, 
        {(uint16_t )94, "Tenx Technologies"}, 
        {(uint16_t )223, "Helix AG"}, 
        {(uint16_t )224, "Domosys"}, 
        {(uint16_t )97, "Skyup Technology"}, 
        {(uint16_t )98, "HiNT Corporation"}, 
        {(uint16_t )227, "Chiaro"}, 
        {(uint16_t )100, "MCI Computer GMBH"}, 
        {(uint16_t )229, "Exbit Technology A/S"}, 
        {(uint16_t )230, "Integrated Technology Express"}, 
        {(uint16_t )103, "AVED Memory"}, 
        {(uint16_t )104, "Legerity"}, 
        {(uint16_t )233, "Jasmine Networks"}, 
        {(uint16_t )234, "Caspian Networks"}, 
        {(uint16_t )107, "nCUBE"}, 
        {(uint16_t )236, "Silicon Access Networks"}, 
        {(uint16_t )109, "FDK Corporation"}, 
        {(uint16_t )110, "High Bandwidth Access"}, 
        {(uint16_t )239, "MultiLink Technology"}, 
        {(uint16_t )112, "BRECIS"}, 
        {(uint16_t )241, "World Wide Packets"}, 
        {(uint16_t )242, "APW"}, 
        {(uint16_t )115, "Chicory Systems"}, 
        {(uint16_t )244, "Xstream Logic"}, 
        {(uint16_t )117, "Fast-Chip"}, 
        {(uint16_t )118, "Zucotto Wireless"}, 
        {(uint16_t )247, "Realchip"}, 
        {(uint16_t )248, "Galaxy Power"}, 
        {(uint16_t )121, "eSilicon"}, 
        {(uint16_t )122, "Morphics Technology"}, 
        {(uint16_t )251, "Accelerant Networks"}, 
        {(uint16_t )124, "Silicon Wave"}, 
        {(uint16_t )253, "SandCraft"}, 
        {(uint16_t )254, "Elpida"}, 
        {(uint16_t )0, (char const   *)((void *)0)}};
#line 510 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/dimm_spd.c"
struct valstr  const  jedec_id4_vals[126]  = 
#line 510
  {      {(uint16_t )1, "Solectron"}, 
        {(uint16_t )2, "Optosys Technologies"}, 
        {(uint16_t )131, "Buffalo (Formerly Melco)"}, 
        {(uint16_t )4, "TriMedia Technologies"}, 
        {(uint16_t )133, "Cyan Technologies"}, 
        {(uint16_t )134, "Global Locate"}, 
        {(uint16_t )7, "Optillion"}, 
        {(uint16_t )8, "Terago Communications"}, 
        {(uint16_t )137, "Ikanos Communications"}, 
        {(uint16_t )138, "Princeton Technology"}, 
        {(uint16_t )11, "Nanya Technology"}, 
        {(uint16_t )140, "Elite Flash Storage"}, 
        {(uint16_t )13, "Mysticom"}, 
        {(uint16_t )14, "LightSand Communications"}, 
        {(uint16_t )143, "ATI Technologies"}, 
        {(uint16_t )16, "Agere Systems"}, 
        {(uint16_t )145, "NeoMagic"}, 
        {(uint16_t )146, "AuroraNetics"}, 
        {(uint16_t )19, "Golden Empire"}, 
        {(uint16_t )148, "Muskin"}, 
        {(uint16_t )21, "Tioga Technologies"}, 
        {(uint16_t )22, "Netlist"}, 
        {(uint16_t )151, "TeraLogic"}, 
        {(uint16_t )152, "Cicada Semiconductor"}, 
        {(uint16_t )25, "Centon Electronics"}, 
        {(uint16_t )26, "Tyco Electronics"}, 
        {(uint16_t )155, "Magis Works"}, 
        {(uint16_t )28, "Zettacom"}, 
        {(uint16_t )157, "Cogency Semiconductor"}, 
        {(uint16_t )158, "Chipcon AS"}, 
        {(uint16_t )31, "Aspex Technology"}, 
        {(uint16_t )32, "F5 Networks"}, 
        {(uint16_t )161, "Programmable Silicon Solutions"}, 
        {(uint16_t )162, "ChipWrights"}, 
        {(uint16_t )35, "Acorn Networks"}, 
        {(uint16_t )164, "Quicklogic"}, 
        {(uint16_t )37, "Kingmax Semiconductor"}, 
        {(uint16_t )38, "BOPS"}, 
        {(uint16_t )167, "Flasys"}, 
        {(uint16_t )168, "BitBlitz Communications"}, 
        {(uint16_t )41, "eMemory Technology"}, 
        {(uint16_t )42, "Procket Networks"}, 
        {(uint16_t )171, "Purple Ray"}, 
        {(uint16_t )44, "Trebia Networks"}, 
        {(uint16_t )173, "Delta Electronics"}, 
        {(uint16_t )174, "Onex Communications"}, 
        {(uint16_t )47, "Ample Communications"}, 
        {(uint16_t )176, "Memory Experts Intl"}, 
        {(uint16_t )49, "Astute Networks"}, 
        {(uint16_t )50, "Azanda Network Devices"}, 
        {(uint16_t )179, "Dibcom"}, 
        {(uint16_t )52, "Tekmos"}, 
        {(uint16_t )181, "API NetWorks"}, 
        {(uint16_t )182, "Bay Microsystems"}, 
        {(uint16_t )55, "Firecron Ltd"}, 
        {(uint16_t )56, "Resonext Communications"}, 
        {(uint16_t )185, "Tachys Technologies"}, 
        {(uint16_t )186, "Equator Technology"}, 
        {(uint16_t )59, "Concept Computer"}, 
        {(uint16_t )188, "SILCOM"}, 
        {(uint16_t )61, "3Dlabs"}, 
        {(uint16_t )62, "ct Magazine"}, 
        {(uint16_t )191, "Sanera Systems"}, 
        {(uint16_t )64, "Silicon Packets"}, 
        {(uint16_t )193, "Viasystems Group"}, 
        {(uint16_t )194, "Simtek"}, 
        {(uint16_t )67, "Semicon Devices Singapore"}, 
        {(uint16_t )196, "Satron Handelsges"}, 
        {(uint16_t )69, "Improv Systems"}, 
        {(uint16_t )70, "INDUSYS GmbH"}, 
        {(uint16_t )199, "Corrent"}, 
        {(uint16_t )200, "Infrant Technologies"}, 
        {(uint16_t )73, "Ritek Corp"}, 
        {(uint16_t )74, "empowerTel Networks"}, 
        {(uint16_t )203, "Hypertec"}, 
        {(uint16_t )76, "Cavium Networks"}, 
        {(uint16_t )205, "PLX Technology"}, 
        {(uint16_t )206, "Massana Design"}, 
        {(uint16_t )79, "Intrinsity"}, 
        {(uint16_t )208, "Valence Semiconductor"}, 
        {(uint16_t )81, "Terawave Communications"}, 
        {(uint16_t )82, "IceFyre Semiconductor"}, 
        {(uint16_t )211, "Primarion"}, 
        {(uint16_t )84, "Picochip Designs Ltd"}, 
        {(uint16_t )213, "Silverback Systems"}, 
        {(uint16_t )214, "Jade Star Technologies"}, 
        {(uint16_t )87, "Pijnenburg Securealink"}, 
        {(uint16_t )88, "MemorySolutioN"}, 
        {(uint16_t )217, "Cambridge Silicon Radio"}, 
        {(uint16_t )218, "Swissbit"}, 
        {(uint16_t )91, "Nazomi Communications"}, 
        {(uint16_t )220, "eWave System"}, 
        {(uint16_t )93, "Rockwell Collins"}, 
        {(uint16_t )94, "PAION"}, 
        {(uint16_t )223, "Alphamosaic Ltd"}, 
        {(uint16_t )224, "Sandburst"}, 
        {(uint16_t )97, "SiCon Video"}, 
        {(uint16_t )98, "NanoAmp Solutions"}, 
        {(uint16_t )227, "Ericsson Technology"}, 
        {(uint16_t )100, "PrairieComm"}, 
        {(uint16_t )229, "Mitac International"}, 
        {(uint16_t )230, "Layer N Networks"}, 
        {(uint16_t )103, "Atsana Semiconductor"}, 
        {(uint16_t )104, "Allegro Networks"}, 
        {(uint16_t )233, "Marvell Semiconductors"}, 
        {(uint16_t )234, "Netergy Microelectronic"}, 
        {(uint16_t )107, "NVIDIA"}, 
        {(uint16_t )236, "Internet Machines"}, 
        {(uint16_t )109, "Peak Electronics"}, 
        {(uint16_t )239, "Accton Technology"}, 
        {(uint16_t )112, "Teradiant Networks"}, 
        {(uint16_t )241, "Europe Technologies"}, 
        {(uint16_t )242, "Cortina Systems"}, 
        {(uint16_t )115, "RAM Components"}, 
        {(uint16_t )244, "Raqia Networks"}, 
        {(uint16_t )117, "ClearSpeed"}, 
        {(uint16_t )118, "Matsushita Battery"}, 
        {(uint16_t )247, "Xelerated"}, 
        {(uint16_t )248, "SimpleTech"}, 
        {(uint16_t )121, "Utron Technology"}, 
        {(uint16_t )122, "Astec International"}, 
        {(uint16_t )251, "AVM gmbH"}, 
        {(uint16_t )124, "Redux Communications"}, 
        {(uint16_t )253, "Dot Hill Systems"}, 
        {(uint16_t )254, "TeraChip"}, 
        {(uint16_t )0, (char const   *)((void *)0)}};
#line 639 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/dimm_spd.c"
struct valstr  const  jedec_id5_vals[77]  = 
#line 639
  {      {(uint16_t )1, "T-RAM Incorporated"}, 
        {(uint16_t )2, "Innovics Wireless"}, 
        {(uint16_t )131, "Teknovus"}, 
        {(uint16_t )4, "KeyEye Communications"}, 
        {(uint16_t )133, "Runcom Technologies"}, 
        {(uint16_t )134, "RedSwitch"}, 
        {(uint16_t )7, "Dotcast"}, 
        {(uint16_t )8, "Silicon Mountain Memory"}, 
        {(uint16_t )137, "Signia Technologies"}, 
        {(uint16_t )138, "Pixim"}, 
        {(uint16_t )11, "Galazar Networks"}, 
        {(uint16_t )140, "White Electronic Designs"}, 
        {(uint16_t )13, "Patriot Scientific"}, 
        {(uint16_t )14, "Neoaxiom Corporation"}, 
        {(uint16_t )143, "3Y Power Technology"}, 
        {(uint16_t )16, "Europe Technologies"}, 
        {(uint16_t )145, "Potentia Power Systems"}, 
        {(uint16_t )146, "C-guys Incorporated"}, 
        {(uint16_t )19, "Digital Communications Technology Incorporated"}, 
        {(uint16_t )148, "Silicon-Based Technology"}, 
        {(uint16_t )21, "Fulcrum Microsystems"}, 
        {(uint16_t )22, "Positivo Informatica Ltd"}, 
        {(uint16_t )151, "XIOtech Corporation"}, 
        {(uint16_t )152, "PortalPlayer"}, 
        {(uint16_t )25, "Zhiying Software"}, 
        {(uint16_t )26, "Direct2Data"}, 
        {(uint16_t )155, "Phonex Broadband"}, 
        {(uint16_t )28, "Skyworks Solutions"}, 
        {(uint16_t )157, "Entropic Communications"}, 
        {(uint16_t )158, "Pacific Force Technology"}, 
        {(uint16_t )31, "Zensys A/S"}, 
        {(uint16_t )32, "Legend Silicon Corp."}, 
        {(uint16_t )161, "sci-worx GmbH"}, 
        {(uint16_t )162, "Oasis Silicon Systems"}, 
        {(uint16_t )35, "Renesas Technology"}, 
        {(uint16_t )164, "Raza Microelectronics"}, 
        {(uint16_t )37, "Phyworks"}, 
        {(uint16_t )38, "MediaTek"}, 
        {(uint16_t )167, "Non-cents Productions"}, 
        {(uint16_t )168, "US Modular"}, 
        {(uint16_t )41, "Wintegra Ltd"}, 
        {(uint16_t )42, "Mathstar"}, 
        {(uint16_t )171, "StarCore"}, 
        {(uint16_t )44, "Oplus Technologies"}, 
        {(uint16_t )173, "Mindspeed"}, 
        {(uint16_t )174, "Just Young Computer"}, 
        {(uint16_t )47, "Radia Communications"}, 
        {(uint16_t )176, "OCZ"}, 
        {(uint16_t )49, "Emuzed"}, 
        {(uint16_t )50, "LOGIC Devices"}, 
        {(uint16_t )179, "Inphi Corporation"}, 
        {(uint16_t )52, "Quake Technologies"}, 
        {(uint16_t )181, "Vixel"}, 
        {(uint16_t )182, "SolusTek"}, 
        {(uint16_t )55, "Kongsberg Maritime"}, 
        {(uint16_t )56, "Faraday Technology"}, 
        {(uint16_t )185, "Altium Ltd."}, 
        {(uint16_t )186, "Insyte"}, 
        {(uint16_t )59, "ARM Ltd."}, 
        {(uint16_t )188, "DigiVision"}, 
        {(uint16_t )61, "Vativ Technologies"}, 
        {(uint16_t )62, "Endicott Interconnect Technologies"}, 
        {(uint16_t )191, "Pericom"}, 
        {(uint16_t )64, "Bandspeed"}, 
        {(uint16_t )193, "LeWiz Communications"}, 
        {(uint16_t )194, "CPU Technology"}, 
        {(uint16_t )67, "Ramaxel Technology"}, 
        {(uint16_t )196, "DSP Group"}, 
        {(uint16_t )69, "Axis Communications"}, 
        {(uint16_t )70, "Legacy Electronics"}, 
        {(uint16_t )199, "Chrontel"}, 
        {(uint16_t )200, "Powerchip Semiconductor"}, 
        {(uint16_t )73, "MobilEye Technologies"}, 
        {(uint16_t )74, "Excel Semiconductor"}, 
        {(uint16_t )203, "A-DATA Technology"}, 
        {(uint16_t )76, "VirtualDigm"}, 
        {(uint16_t )0, (char const   *)((void *)0)}};
#line 719 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/dimm_spd.c"
int ipmi_spd_print(uint8_t *spd_data , int len ) 
{ 
  int size ;
  char const   *tmp ;
  int iPN ;
  char *pchPN ;
  int sdram_cap ;
  int pri_bus_width ;
  int sdram_width ;
  int ranks ;
  int mem_size ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char part[19] ;

  {
#line 724
  if (len < 92) {
#line 725
    return (-1);
  }
  {
#line 727
  tmp = val2str((uint16_t )*(spd_data + 2), spd_memtype_vals);
#line 727
  printf((char const   */* __restrict  */)" Memory Type           : %s\n", tmp);
  }
#line 730
  if ((int )*(spd_data + 2) == 11) {
#line 733
    pchPN = (char *)(spd_data + 128);
#line 734
    sdram_cap = 0;
#line 735
    pri_bus_width = 0;
#line 736
    sdram_width = 0;
#line 737
    ranks = 0;
#line 738
    mem_size = 0;
#line 740
    if (len < 148) {
#line 741
      return (-1);
    }
    {
#line 744
    tmp___0 = ldexp((double )256, (int )*(spd_data + 4) & 15);
#line 744
    sdram_cap = (int )tmp___0;
#line 745
    tmp___1 = ldexp((double )8, (int )*(spd_data + 8) & 7);
#line 745
    pri_bus_width = (int )tmp___1;
#line 746
    tmp___2 = ldexp((double )4, (int )*(spd_data + 7) & 7);
#line 746
    sdram_width = (int )tmp___2;
#line 747
    tmp___3 = ldexp((double )1, ((int )*(spd_data + 7) & 63) >> 3);
#line 747
    ranks = (int )tmp___3;
#line 748
    mem_size = ((sdram_cap / 8) * (pri_bus_width / sdram_width)) * ranks;
#line 749
    printf((char const   */* __restrict  */)" SDRAM Capacity        : %d MB\n", sdram_cap);
#line 750
    tmp___4 = val2str((uint16_t )((int )*(spd_data + 4) >> 4), ddr3_banks_vals);
#line 750
    printf((char const   */* __restrict  */)" Memory Banks          : %s\n", tmp___4);
#line 751
    printf((char const   */* __restrict  */)" Primary Bus Width     : %d bits\n",
           pri_bus_width);
#line 752
    printf((char const   */* __restrict  */)" SDRAM Device Width    : %d bits\n",
           sdram_width);
#line 753
    printf((char const   */* __restrict  */)" Number of Ranks       : %d\n", ranks);
#line 754
    printf((char const   */* __restrict  */)" Memory size           : %d MB\n", mem_size);
    }
#line 757
    if (((int )*(spd_data + 6) & 1) != 0) {
#line 757
      tmp___5 = "No";
    } else {
#line 757
      tmp___5 = "Yes";
    }
    {
#line 757
    printf((char const   */* __restrict  */)" 1.5 V Nominal Op      : %s\n", tmp___5);
    }
#line 758
    if (((int )*(spd_data + 6) & 2) != 0) {
#line 758
      tmp___6 = "No";
    } else {
#line 758
      tmp___6 = "Yes";
    }
    {
#line 758
    printf((char const   */* __restrict  */)" 1.35 V Nominal Op     : %s\n", tmp___6);
    }
#line 759
    if (((int )*(spd_data + 6) & 4) != 0) {
#line 759
      tmp___7 = "No";
    } else {
#line 759
      tmp___7 = "Yes";
    }
    {
#line 759
    printf((char const   */* __restrict  */)" 1.2X V Nominal Op     : %s\n", tmp___7);
#line 760
    tmp___8 = val2str((uint16_t )((int )*(spd_data + 8) >> 3), ddr3_ecc_vals);
#line 760
    printf((char const   */* __restrict  */)" Error Detect/Cor      : %s\n", tmp___8);
#line 762
    printf((char const   */* __restrict  */)" Manufacturer          : ");
    }
    {
#line 765
    if (((int )*(spd_data + 117) & 127) == 0) {
#line 765
      goto case_0;
    }
#line 769
    if (((int )*(spd_data + 117) & 127) == 1) {
#line 769
      goto case_1;
    }
#line 773
    if (((int )*(spd_data + 117) & 127) == 2) {
#line 773
      goto case_2;
    }
#line 777
    if (((int )*(spd_data + 117) & 127) == 3) {
#line 777
      goto case_3;
    }
#line 781
    if (((int )*(spd_data + 117) & 127) == 4) {
#line 781
      goto case_4;
    }
#line 785
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 766
    tmp___9 = val2str((uint16_t )*(spd_data + 118), jedec_id1_vals);
#line 766
    printf((char const   */* __restrict  */)"%s\n", tmp___9);
    }
#line 767
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 770
    tmp___10 = val2str((uint16_t )*(spd_data + 118), jedec_id2_vals);
#line 770
    printf((char const   */* __restrict  */)"%s\n", tmp___10);
    }
#line 771
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 774
    tmp___11 = val2str((uint16_t )*(spd_data + 118), jedec_id3_vals);
#line 774
    printf((char const   */* __restrict  */)"%s\n", tmp___11);
    }
#line 775
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 778
    tmp___12 = val2str((uint16_t )*(spd_data + 118), jedec_id4_vals);
#line 778
    printf((char const   */* __restrict  */)"%s\n", tmp___12);
    }
#line 779
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 782
    tmp___13 = val2str((uint16_t )*(spd_data + 118), jedec_id5_vals);
#line 782
    printf((char const   */* __restrict  */)"%s\n", tmp___13);
    }
#line 783
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 786
    printf((char const   */* __restrict  */)"%s\n", "JEDEC JEP106 update required");
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 790
    printf((char const   */* __restrict  */)" Manufacture Date      : year %c%c week %c%c\n",
           48 + ((int )*(spd_data + 120) >> 4), 48 + ((int )*(spd_data + 120) & 15),
           48 + ((int )*(spd_data + 121) >> 4), 48 + ((int )*(spd_data + 121) & 15));
#line 793
    printf((char const   */* __restrict  */)" Serial Number         : %02x%02x%02x%02x\n",
           (int )*(spd_data + 122), (int )*(spd_data + 123), (int )*(spd_data + 124),
           (int )*(spd_data + 125));
#line 796
    printf((char const   */* __restrict  */)" Part Number           : ");
#line 797
    iPN = 0;
    }
    {
#line 797
    while (1) {
      while_continue: /* CIL Label */ ;
#line 797
      if (! (iPN < 19)) {
#line 797
        goto while_break;
      }
      {
#line 799
      tmp___14 = pchPN;
#line 799
      pchPN ++;
#line 799
      printf((char const   */* __restrict  */)"%c", (int )*tmp___14);
#line 797
      iPN ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 801
    printf((char const   */* __restrict  */)"\n");
    }
  } else {
    {
#line 805
    size = (int )*(spd_data + 5) * ((int )*(spd_data + 31) << 2);
#line 806
    printf((char const   */* __restrict  */)" Memory Size           : %d MB\n", size);
#line 807
    tmp___15 = val2str((uint16_t )*(spd_data + 8), spd_voltage_vals);
#line 807
    printf((char const   */* __restrict  */)" Voltage Intf          : %s\n", tmp___15);
#line 809
    tmp___16 = val2str((uint16_t )*(spd_data + 11), spd_config_vals);
#line 809
    printf((char const   */* __restrict  */)" Error Detect/Cor      : %s\n", tmp___16);
#line 813
    printf((char const   */* __restrict  */)" Manufacturer          : ");
    }
#line 814
    if ((int )*(spd_data + 64) != 127) {
      {
#line 815
      tmp___17 = val2str((uint16_t )*(spd_data + 64), jedec_id1_vals);
#line 815
      printf((char const   */* __restrict  */)"%s\n", tmp___17);
      }
    } else
#line 818
    if ((int )*(spd_data + 65) != 127) {
      {
#line 819
      tmp___18 = val2str((uint16_t )*(spd_data + 65), jedec_id2_vals);
#line 819
      printf((char const   */* __restrict  */)"%s\n", tmp___18);
      }
    } else
#line 822
    if ((int )*(spd_data + 66) != 127) {
      {
#line 823
      tmp___19 = val2str((uint16_t )*(spd_data + 66), jedec_id3_vals);
#line 823
      printf((char const   */* __restrict  */)"%s\n", tmp___19);
      }
    } else
#line 826
    if ((int )*(spd_data + 67) != 127) {
      {
#line 827
      tmp___20 = val2str((uint16_t )*(spd_data + 67), jedec_id4_vals);
#line 827
      printf((char const   */* __restrict  */)"%s\n", tmp___20);
      }
    } else {
      {
#line 831
      tmp___21 = val2str((uint16_t )*(spd_data + 68), jedec_id5_vals);
#line 831
      printf((char const   */* __restrict  */)"%s\n", tmp___21);
      }
    }
#line 838
    if (*(spd_data + 73)) {
      {
#line 840
      memcpy((void */* __restrict  */)(part), (void const   */* __restrict  */)(spd_data + 73),
             (size_t )18);
#line 841
      part[18] = (char)0;
#line 842
      printf((char const   */* __restrict  */)" Part Number           : %s\n", part);
      }
    }
    {
#line 845
    printf((char const   */* __restrict  */)" Serial Number         : %02x%02x%02x%02x\n",
           (int )*(spd_data + 95), (int )*(spd_data + 96), (int )*(spd_data + 97),
           (int )*(spd_data + 98));
    }
  }
#line 849
  if (verbose) {
    {
#line 850
    printf((char const   */* __restrict  */)"\n");
#line 851
    printbuf((uint8_t const   *)spd_data, len, "SPD DATA");
    }
  }
#line 854
  return (0);
}
}
#line 857 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/dimm_spd.c"
int ipmi_spd_print_fru(struct ipmi_intf *intf , uint8_t id ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct fru_info fru ;
  uint8_t spd_data[256] ;
  uint8_t msg_data[4] ;
  int len ;
  int offset ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 866
  msg_data[0] = id;
#line 868
  memset((void *)(& req), 0, sizeof(req));
#line 869
  req.msg.netfn = (uint8_t )10;
#line 870
  req.msg.cmd = (uint8_t )16;
#line 871
  req.msg.data = msg_data;
#line 872
  req.msg.data_len = (uint16_t )1;
#line 874
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 875
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 876
    printf((char const   */* __restrict  */)" Device not present (No Response)\n");
    }
#line 877
    return (-1);
  }
#line 879
  if ((int )rsp->ccode > 0) {
    {
#line 880
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 880
    printf((char const   */* __restrict  */)" Device not present (%s)\n", tmp);
    }
#line 882
    return (-1);
  }
#line 885
  fru.size = (uint16_t )(((int )rsp->data[1] << 8) | (int )rsp->data[0]);
#line 886
  fru.access = (uint8_t )((int )rsp->data[2] & 1);
#line 888
  if (fru.access) {
#line 888
    tmp___0 = "words";
  } else {
#line 888
    tmp___0 = "bytes";
  }
  {
#line 888
  lprintf(7, "fru.size = %d bytes (accessed by %s)", (int )fru.size, tmp___0);
  }
#line 891
  if ((int )fru.size < 1) {
    {
#line 892
    lprintf(3, " Invalid FRU size %d", (int )fru.size);
    }
#line 893
    return (-1);
  }
  {
#line 896
  memset((void *)(& req), 0, sizeof(req));
#line 897
  req.msg.netfn = (uint8_t )10;
#line 898
  req.msg.cmd = (uint8_t )17;
#line 899
  req.msg.data = msg_data;
#line 900
  req.msg.data_len = (uint16_t )4;
#line 902
  offset = 0;
#line 903
  memset((void *)(spd_data), 0, (size_t )256);
  }
  {
#line 904
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 905
    msg_data[0] = id;
#line 906
    msg_data[1] = (uint8_t )offset;
#line 907
    msg_data[2] = (uint8_t )0;
#line 908
    msg_data[3] = (uint8_t )16;
#line 910
    rsp = (*(intf->sendrecv))(intf, & req);
    }
#line 911
    if ((unsigned long )rsp == (unsigned long )((void *)0)) {
      {
#line 912
      printf((char const   */* __restrict  */)" Device not present (No Response)\n");
      }
#line 913
      return (-1);
    }
#line 915
    if ((int )rsp->ccode > 0) {
      {
#line 916
      tmp___1 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 916
      printf((char const   */* __restrict  */)" Device not present (%s)\n", tmp___1);
      }
#line 920
      if ((int )rsp->ccode == 195) {
#line 921
        return (1);
      }
#line 923
      return (-1);
    }
    {
#line 926
    len = (int )rsp->data[0];
#line 927
    memcpy((void */* __restrict  */)(& spd_data[offset]), (void const   */* __restrict  */)(rsp->data + 1),
           (size_t )len);
#line 928
    offset += len;
    }
#line 904
    if (! (offset < (int )fru.size)) {
#line 904
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 932
  ipmi_spd_print(spd_data, offset);
  }
#line 934
  return (0);
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int errorCount___1  ;
#line 276 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int const   HPMFWUPG_SUCCESS___0  =    (int const   )0;
#line 277 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int const   HPMFWUPG_ERROR___0  =    (int const   )-1;
#line 279 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int const   HPMFWUPG_UPLOAD_BLOCK_LENGTH___0  =    (int const   )1;
#line 280 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int const   HPMFWUPG_UPLOAD_RETRY___0  =    (int const   )2;
#line 1037
static int HpmfwupgUpgrade___0(struct ipmi_intf *intf , char *imageFilename , int activate ,
                               int componentToUpload , int option ) ;
#line 1038
static int HpmfwupgValidateImageIntegrity___0(struct HpmfwupgUpgradeCtx *pFwupgCtx ) ;
#line 1039
static int HpmfwupgPreparationStage___0(struct ipmi_intf *intf , struct HpmfwupgUpgradeCtx *pFwupgCtx ,
                                        int option ) ;
#line 1041
static int HpmfwupgUpgradeStage___0(struct ipmi_intf *intf , struct HpmfwupgUpgradeCtx *pFwupgCtx ,
                                    int componentToUpload , int option ) ;
#line 1043
static int HpmfwupgActivationStage___0(struct ipmi_intf *intf , struct HpmfwupgUpgradeCtx *pFwupgCtx ) ;
#line 1045
static int HpmfwupgGetTargetUpgCapabilities___0(struct ipmi_intf *intf , struct HpmfwupgGetTargetUpgCapabilitiesCtx *pCtx ) ;
#line 1047
static int HpmfwupgGetComponentProperties___0(struct ipmi_intf *intf , struct HpmfwupgGetComponentPropertiesCtx *pCtx ) ;
#line 1049
static int HpmfwupgQuerySelftestResult___0(struct ipmi_intf *intf , struct HpmfwupgQuerySelftestResultCtx *pCtx ,
                                           struct HpmfwupgUpgradeCtx *pFwupgCtx ) ;
#line 1052
static int HpmfwupgQueryRollbackStatus___0(struct ipmi_intf *intf , struct HpmfwupgQueryRollbackStatusCtx *pCtx ,
                                           struct HpmfwupgUpgradeCtx *pFwupgCtx ) ;
#line 1055
static int HpmfwupgAbortUpgrade___0(struct ipmi_intf *intf , struct HpmfwupgAbortUpgradeCtx *pCtx ) ;
#line 1057
static int HpmfwupgInitiateUpgradeAction___0(struct ipmi_intf *intf , struct HpmfwupgInitiateUpgradeActionCtx *pCtx ,
                                             struct HpmfwupgUpgradeCtx *pFwupgCtx ) ;
#line 1060
static int HpmfwupgUploadFirmwareBlock___0(struct ipmi_intf *intf , struct HpmfwupgUploadFirmwareBlockCtx *pCtx ,
                                           struct HpmfwupgUpgradeCtx *pFwupgCtx ,
                                           int count , unsigned int *imageOffset ,
                                           unsigned int *blockLength ) ;
#line 1064
static int HpmfwupgFinishFirmwareUpload___0(struct ipmi_intf *intf , struct HpmfwupgFinishFirmwareUploadCtx *pCtx ,
                                            struct HpmfwupgUpgradeCtx *pFwupgCtx ) ;
#line 1067
static int HpmfwupgActivateFirmware___0(struct ipmi_intf *intf , struct HpmfwupgActivateFirmwareCtx *pCtx ,
                                        struct HpmfwupgUpgradeCtx *pFwupgCtx ) ;
#line 1070
static int HpmfwupgGetUpgradeStatus___0(struct ipmi_intf *intf , struct HpmfwupgGetUpgradeStatusCtx *pCtx ,
                                        struct HpmfwupgUpgradeCtx *pFwupgCtx , int silent ) ;
#line 1071
static int HpmfwupgManualFirmwareRollback___0(struct ipmi_intf *intf , struct HpmfwupgManualFirmwareRollbackCtx *pCtx ,
                                              struct HpmfwupgUpgradeCtx *pFwupgCtx ) ;
#line 1074
static void HpmfwupgPrintUsage___0(void) ;
#line 1075
static unsigned char HpmfwupgCalculateChecksum___0(unsigned char *pData , unsigned int length ) ;
#line 1076
static int HpmfwupgGetDeviceId___0(struct ipmi_intf *intf , struct ipm_devid_rsp *pGetDevId ) ;
#line 1077
static int HpmfwupgGetBufferFromFile___0(char *imageFilename , struct HpmfwupgUpgradeCtx *pFwupgCtx ) ;
#line 1078
static int HpmfwupgWaitLongDurationCmd___0(struct ipmi_intf *intf , struct HpmfwupgUpgradeCtx *pFwupgCtx ) ;
#line 1080
static struct ipmi_rs *HpmfwupgSendCmd___0(struct ipmi_intf *intf , struct ipmi_rq req ,
                                           struct HpmfwupgUpgradeCtx *pFwupgCtx ) ;
#line 1084
static int HpmFwupgActionUploadFirmware___0(struct HpmfwupgComponentBitMask components ,
                                            struct HpmfwupgUpgradeCtx *pFwupgCtx ,
                                            unsigned char **pImagePtr , int componentToUpload ,
                                            struct ipmi_intf *intf , int option ,
                                            int *pFlagColdReset ) ;
#line 1164 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int old_percent___0  =    1;
#line 1504 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgUpgrade___0(struct ipmi_intf *intf , char *imageFilename , int activate ,
                               int componentToUpload , int option ) 
{ 
  int rc ;
  struct HpmfwupgUpgradeCtx fwupgCtx ;

  {
  {
#line 1507
  rc = (int )HPMFWUPG_SUCCESS___0;
#line 1515
  rc = HpmfwupgGetBufferFromFile___0(imageFilename, & fwupgCtx);
  }
#line 1521
  if (rc == (int )HPMFWUPG_SUCCESS___0) {
    {
#line 1523
    printf((char const   */* __restrict  */)"Validating firmware image integrity...");
#line 1524
    fflush(stdout);
#line 1525
    rc = HpmfwupgValidateImageIntegrity___0(& fwupgCtx);
    }
#line 1526
    if (rc == (int )HPMFWUPG_SUCCESS___0) {
      {
#line 1528
      printf((char const   */* __restrict  */)"OK\n");
#line 1529
      fflush(stdout);
      }
    } else {
      {
#line 1533
      free((void *)fwupgCtx.pImageData);
#line 1534
      fwupgCtx.pImageData = (unsigned char *)((void *)0);
      }
    }
  }
#line 1542
  if (rc == (int )HPMFWUPG_SUCCESS___0) {
    {
#line 1544
    printf((char const   */* __restrict  */)"Performing preparation stage...");
#line 1545
    fflush(stdout);
#line 1546
    rc = HpmfwupgPreparationStage___0(intf, & fwupgCtx, option);
    }
#line 1547
    if (rc == (int )HPMFWUPG_SUCCESS___0) {
      {
#line 1549
      printf((char const   */* __restrict  */)"OK\n");
#line 1550
      fflush(stdout);
      }
    } else {
      {
#line 1554
      free((void *)fwupgCtx.pImageData);
#line 1555
      fwupgCtx.pImageData = (unsigned char *)((void *)0);
      }
    }
  }
#line 1563
  if (rc == (int )HPMFWUPG_SUCCESS___0) {
#line 1565
    if (option & 2) {
      {
#line 1567
      lprintf(5, "\nComparing Target & Image File version");
      }
    } else {
      {
#line 1571
      lprintf(5, "\nPerforming upgrade stage:");
      }
    }
#line 1573
    if (option & 2) {
      {
#line 1575
      rc = HpmfwupgPreUpgradeCheck(intf, & fwupgCtx, componentToUpload, 2);
      }
    } else {
      {
#line 1579
      rc = HpmfwupgPreUpgradeCheck(intf, & fwupgCtx, componentToUpload, option);
      }
#line 1580
      if (rc == (int )HPMFWUPG_SUCCESS___0) {
#line 1582
        if (verbose) {
          {
#line 1583
          printf((char const   */* __restrict  */)"Component update mask : 0x%02x\n",
                 (int )fwupgCtx.compUpdateMask.ComponentBits.byte);
          }
        }
        {
#line 1585
        rc = HpmfwupgUpgradeStage___0(intf, & fwupgCtx, componentToUpload, option);
        }
      }
    }
#line 1589
    if (rc != (int )HPMFWUPG_SUCCESS___0) {
      {
#line 1591
      free((void *)fwupgCtx.pImageData);
#line 1592
      fwupgCtx.pImageData = (unsigned char *)((void *)0);
      }
    }
  }
#line 1599
  if (rc == (int )HPMFWUPG_SUCCESS___0) {
#line 1599
    if (activate) {
      {
#line 1601
      lprintf(5, "Performing activation stage: ");
#line 1602
      rc = HpmfwupgActivationStage___0(intf, & fwupgCtx);
      }
#line 1603
      if (rc != (int )HPMFWUPG_SUCCESS___0) {
        {
#line 1605
        free((void *)fwupgCtx.pImageData);
#line 1606
        fwupgCtx.pImageData = (unsigned char *)((void *)0);
        }
      }
    }
  }
#line 1610
  if (rc == (int )HPMFWUPG_SUCCESS___0) {
#line 1612
    if (option & 2) {
      {
#line 1615
      lprintf(5, " ");
      }
    } else {
      {
#line 1619
      lprintf(5, "\nFirmware upgrade procedure successful\n");
      }
    }
    {
#line 1621
    free((void *)fwupgCtx.pImageData);
#line 1622
    fwupgCtx.pImageData = (unsigned char *)((void *)0);
    }
  } else {
    {
#line 1626
    lprintf(5, "Firmware upgrade procedure failed\n");
    }
  }
#line 1629
  return (rc);
}
}
#line 1647 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static unsigned char md___0[16]  ;
#line 1641 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgValidateImageIntegrity___0(struct HpmfwupgUpgradeCtx *pFwupgCtx ) 
{ 
  int rc ;
  struct HpmfwupgImageHeader *pImageHeader ;
  md5_state_t ctx ;
  unsigned char *pMd5Sig ;
  int tmp ;
  unsigned char tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1643
  rc = (int )HPMFWUPG_SUCCESS___0;
#line 1644
  pImageHeader = (struct HpmfwupgImageHeader *)pFwupgCtx->pImageData;
#line 1648
  pMd5Sig = pFwupgCtx->pImageData + (pFwupgCtx->imageSize - 16U);
#line 1653
  memset((void *)(md___0), 0, (size_t )16);
#line 1654
  memset((void *)(& ctx), 0, sizeof(md5_state_t ));
#line 1655
  md5_init(& ctx);
#line 1656
  md5_append(& ctx, (md5_byte_t const   *)pFwupgCtx->pImageData, (int )(pFwupgCtx->imageSize - 16U));
#line 1658
  md5_finish(& ctx, (md5_byte_t *)(md___0));
#line 1659
  tmp = memcmp((void const   *)(md___0), (void const   *)pMd5Sig, (size_t )16);
  }
#line 1659
  if (tmp != 0) {
    {
#line 1661
    lprintf(5, "\n    Invalid MD5 signature");
#line 1662
    rc = (int )HPMFWUPG_ERROR___0;
    }
  }
#line 1665
  if (rc == (int )HPMFWUPG_SUCCESS___0) {
    {
#line 1668
    tmp___1 = strncmp((char const   *)(pImageHeader->signature), "PICMGFWU", (size_t )8);
    }
#line 1668
    if (tmp___1 == 0) {
#line 1671
      if ((int )pImageHeader->formatVersion == 0) {
        {
#line 1674
        tmp___0 = HpmfwupgCalculateChecksum___0((unsigned char *)pImageHeader, (unsigned int )((sizeof(struct HpmfwupgImageHeader ) + (unsigned long )pImageHeader->oemDataLength) + sizeof(unsigned char )));
        }
#line 1674
        if ((int )tmp___0 != 0) {
          {
#line 1679
          lprintf(5, "\n    Invalid header checksum");
#line 1680
          rc = (int )HPMFWUPG_ERROR___0;
          }
        }
      } else {
        {
#line 1685
        lprintf(5, "\n    Unrecognized image version");
#line 1686
        rc = (int )HPMFWUPG_ERROR___0;
        }
      }
    } else {
      {
#line 1691
      lprintf(5, "\n    Invalid image signature");
#line 1692
      rc = (int )HPMFWUPG_ERROR___0;
      }
    }
  }
#line 1695
  return (rc);
}
}
#line 1707 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgPreparationStage___0(struct ipmi_intf *intf , struct HpmfwupgUpgradeCtx *pFwupgCtx ,
                                        int option ) 
{ 
  int rc ;
  struct HpmfwupgImageHeader *pImageHeader ;
  uint16_t tmp ;
  int tmp___0 ;
  uint16_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct HpmfwupgGetTargetUpgCapabilitiesCtx targetCapCmd ;
  int tmp___5 ;
  int componentId ;
  struct HpmfwupgGetComponentPropertiesCtx getCompPropCmd ;

  {
  {
#line 1709
  rc = (int )HPMFWUPG_SUCCESS___0;
#line 1710
  pImageHeader = (struct HpmfwupgImageHeader *)pFwupgCtx->pImageData;
#line 1714
  rc = HpmfwupgGetDeviceId___0(intf, & pFwupgCtx->devId);
  }
#line 1717
  if (rc == (int )HPMFWUPG_SUCCESS___0) {
#line 1720
    if ((int )pImageHeader->deviceId == (int )pFwupgCtx->devId.device_id) {
      {
#line 1723
      tmp___2 = memcmp((void const   *)(pImageHeader->prodId), (void const   *)(pFwupgCtx->devId.product_id),
                       (size_t )2);
      }
#line 1723
      if (tmp___2 == 0) {
        {
#line 1726
        tmp___0 = memcmp((void const   *)(pImageHeader->manId), (void const   *)(pFwupgCtx->devId.manufacturer_id),
                         (size_t )3);
        }
#line 1726
        if (tmp___0 != 0) {
          {
#line 1729
          tmp = buf2short(pFwupgCtx->devId.manufacturer_id);
#line 1729
          lprintf(5, "\n    Invalid image file for manufacturer %u", (int )tmp);
#line 1731
          rc = (int )HPMFWUPG_ERROR___0;
          }
        }
      } else {
        {
#line 1736
        tmp___1 = buf2short(pFwupgCtx->devId.product_id);
#line 1736
        lprintf(5, "\n    Invalid image file for product %u", (int )tmp___1);
#line 1738
        rc = (int )HPMFWUPG_ERROR___0;
        }
      }
    } else {
      {
#line 1744
      lprintf(5, "\n    Invalid device ID %x", (int )pFwupgCtx->devId.device_id);
#line 1745
      rc = (int )HPMFWUPG_ERROR___0;
      }
    }
#line 1748
    if (rc != (int )HPMFWUPG_SUCCESS___0) {
#line 1756
      if (option & 24) {
#line 1756
        goto _L;
      } else
#line 1756
      if (option & 2) {
        _L: /* CIL Label */ 
        {
#line 1758
        printf((char const   */* __restrict  */)"\n    Image Information");
#line 1759
        printf((char const   */* __restrict  */)"\n        Device Id : 0x%x", (int )pImageHeader->deviceId);
#line 1760
        printf((char const   */* __restrict  */)"\n        Prod   Id : 0x%02x%02x",
               (int )pImageHeader->prodId[1], (int )pImageHeader->prodId[0]);
#line 1761
        printf((char const   */* __restrict  */)"\n        Manuf  Id : 0x%02x%02x%02x",
               (int )pImageHeader->manId[2], (int )pImageHeader->manId[1], (int )pImageHeader->manId[0]);
#line 1763
        printf((char const   */* __restrict  */)"\n    Board Information");
#line 1764
        printf((char const   */* __restrict  */)"\n        Device Id : 0x%x", (int )pFwupgCtx->devId.device_id);
#line 1765
        printf((char const   */* __restrict  */)"\n        Prod   Id : 0x%02x%02x",
               (int )pFwupgCtx->devId.product_id[1], (int )pFwupgCtx->devId.product_id[0]);
#line 1766
        printf((char const   */* __restrict  */)"\n        Manuf  Id : 0x%02x%02x%02x",
               (int )pFwupgCtx->devId.manufacturer_id[2], (int )pFwupgCtx->devId.manufacturer_id[1],
               (int )pFwupgCtx->devId.manufacturer_id[0]);
#line 1768
        tmp___3 = HpmGetUserInput((char *)"\n Continue ignoring DeviceID/ProductID/ManufacturingID (Y/N) :");
        }
#line 1768
        if (tmp___3) {
#line 1769
          rc = (int )HPMFWUPG_SUCCESS___0;
        }
      } else {
        {
#line 1773
        printf((char const   */* __restrict  */)"\n\n Use \"force\" option for copying all the components\n");
        }
      }
    }
  }
#line 1779
  if (rc == (int )HPMFWUPG_SUCCESS___0) {
#line 1782
    if (! ((int )pImageHeader->compRevision[0] < (int )pFwupgCtx->devId.fw_rev1)) {
#line 1786
      if ((int )pImageHeader->compRevision[0] == (int )pFwupgCtx->devId.fw_rev1) {
#line 1789
        if ((int )pImageHeader->compRevision[1] > (int )pFwupgCtx->devId.fw_rev2) {
          {
#line 1792
          lprintf(5, "\n    Version: Major: %d", (int )pImageHeader->compRevision[0]);
#line 1793
          lprintf(5, "             Minor: %x", (int )pImageHeader->compRevision[1]);
#line 1794
          lprintf(5, "    Not compatible with ");
#line 1795
          lprintf(5, "    Version: Major: %d", (int )pFwupgCtx->devId.fw_rev1);
#line 1796
          lprintf(5, "             Minor: %x", (int )pFwupgCtx->devId.fw_rev2);
#line 1797
          rc = (int )HPMFWUPG_ERROR___0;
          }
        }
      } else {
        {
#line 1803
        lprintf(5, "\n    Version: Major: %d", (int )pImageHeader->compRevision[0]);
#line 1804
        lprintf(5, "             Minor: %x", (int )pImageHeader->compRevision[1]);
#line 1805
        lprintf(5, "    Not compatible with ");
#line 1806
        lprintf(5, "    Version: Major: %d", (int )pFwupgCtx->devId.fw_rev1);
#line 1807
        lprintf(5, "             Minor: %x", (int )pFwupgCtx->devId.fw_rev2);
#line 1808
        rc = (int )HPMFWUPG_ERROR___0;
        }
      }
    }
#line 1811
    if (rc != (int )HPMFWUPG_SUCCESS___0) {
#line 1814
      if (option & 24) {
#line 1814
        goto _L___0;
      } else
#line 1814
      if (option & 2) {
        _L___0: /* CIL Label */ 
        {
#line 1816
        tmp___4 = HpmGetUserInput((char *)"\n Continue IGNORING Earliest compatibility (Y/N) :");
        }
#line 1816
        if (tmp___4) {
#line 1817
          rc = (int )HPMFWUPG_SUCCESS___0;
        }
      }
    }
  }
#line 1823
  if (rc == (int )HPMFWUPG_SUCCESS___0) {
    {
#line 1827
    rc = HpmfwupgGetTargetUpgCapabilities___0(intf, & targetCapCmd);
    }
#line 1829
    if (rc == (int )HPMFWUPG_SUCCESS___0) {
      {
#line 1832
      memcpy((void */* __restrict  */)(& pFwupgCtx->targetCap), (void const   */* __restrict  */)(& targetCapCmd.resp),
             sizeof(struct HpmfwupgGetTargetUpgCapabilitiesResp ));
      }
#line 1836
      if (option & 2) {
#line 1838
        return (rc);
      } else {
#line 1844
        if (((int )pImageHeader->components.ComponentBits.byte & (int )pFwupgCtx->targetCap.componentsPresent.ComponentBits.byte) != (int )pImageHeader->components.ComponentBits.byte) {
          {
#line 1848
          lprintf(5, "\n    Some components present in the image file are not supported by the IPMC");
#line 1849
          rc = (int )HPMFWUPG_ERROR___0;
          }
        }
#line 1853
        if ((int )pFwupgCtx->targetCap.GlobalCapabilities.bitField.fwUpgUndesirable == 1) {
          {
#line 1855
          lprintf(5, "\n    Upgrade undesirable at this moment");
#line 1856
          rc = (int )HPMFWUPG_ERROR___0;
          }
        }
#line 1861
        if ((int )pFwupgCtx->targetCap.GlobalCapabilities.bitField.servAffectDuringUpg == 1) {
#line 1861
          goto _L___1;
        } else
#line 1861
        if ((int )pImageHeader->imageCapabilities.bitField.servAffected == 1) {
          _L___1: /* CIL Label */ 
          {
#line 1864
          tmp___5 = HpmGetUserInput((char *)"\nServices may be affected during upgrade. Do you wish to continue? y/n ");
          }
#line 1864
          if (tmp___5) {
#line 1866
            rc = (int )HPMFWUPG_SUCCESS___0;
          } else {
#line 1870
            rc = (int )HPMFWUPG_ERROR___0;
          }
        }
      }
    }
  }
#line 1878
  if (rc == (int )HPMFWUPG_SUCCESS___0) {
#line 1882
    componentId = 0;
    {
#line 1882
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1882
      if (! (componentId < 8)) {
#line 1882
        goto while_break;
      }
      {
#line 1887
      memset((void *)(& pFwupgCtx->genCompProp[componentId]), 0, sizeof(struct HpmfwupgGetGeneralPropResp ));
      }
#line 1889
      if ((1 << componentId) & (int )pImageHeader->components.ComponentBits.byte) {
        {
#line 1894
        getCompPropCmd.req.componentId = (unsigned char )componentId;
#line 1895
        getCompPropCmd.req.selector = (unsigned char)0;
#line 1897
        rc = HpmfwupgGetComponentProperties___0(intf, & getCompPropCmd);
        }
#line 1899
        if (rc == (int )HPMFWUPG_SUCCESS___0) {
          {
#line 1902
          memcpy((void */* __restrict  */)(& pFwupgCtx->genCompProp[componentId]),
                 (void const   */* __restrict  */)(& getCompPropCmd.resp), sizeof(struct HpmfwupgGetGeneralPropResp ));
          }
        }
      }
#line 1882
      componentId ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1910
  return (rc);
}
}
#line 1913 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int image_version_upgradable___0(VERSIONINFO *pVersionInfo ) 
{ 


  {
#line 1917
  if ((int )pVersionInfo->imageMajor != (int )pVersionInfo->targetMajor) {
#line 1923
    return (1);
  } else
#line 1917
  if ((int )pVersionInfo->imageMinor != (int )pVersionInfo->targetMinor) {
#line 1923
    return (1);
  } else
#line 1917
  if ((int )pVersionInfo->imageAux[0] != (int )pVersionInfo->targetAux[0]) {
#line 1923
    return (1);
  } else
#line 1917
  if ((int )pVersionInfo->imageAux[1] != (int )pVersionInfo->targetAux[1]) {
#line 1923
    return (1);
  } else
#line 1917
  if ((int )pVersionInfo->imageAux[2] != (int )pVersionInfo->targetAux[2]) {
#line 1923
    return (1);
  } else
#line 1917
  if ((int )pVersionInfo->imageAux[3] != (int )pVersionInfo->targetAux[3]) {
#line 1923
    return (1);
  }
#line 1927
  if (! pVersionInfo->rollbackSupported) {
#line 1928
    return (0);
  }
#line 1932
  if ((int )pVersionInfo->imageMajor != (int )pVersionInfo->rollbackMajor) {
#line 1938
    return (1);
  } else
#line 1932
  if ((int )pVersionInfo->imageMinor != (int )pVersionInfo->rollbackMinor) {
#line 1938
    return (1);
  } else
#line 1932
  if ((int )pVersionInfo->imageAux[0] != (int )pVersionInfo->rollbackAux[0]) {
#line 1938
    return (1);
  } else
#line 1932
  if ((int )pVersionInfo->imageAux[1] != (int )pVersionInfo->rollbackAux[1]) {
#line 1938
    return (1);
  } else
#line 1932
  if ((int )pVersionInfo->imageAux[2] != (int )pVersionInfo->rollbackAux[2]) {
#line 1938
    return (1);
  } else
#line 1932
  if ((int )pVersionInfo->imageAux[3] != (int )pVersionInfo->rollbackAux[3]) {
#line 1938
    return (1);
  }
#line 1941
  return (0);
}
}
#line 2113 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgUpgradeStage___0(struct ipmi_intf *intf , struct HpmfwupgUpgradeCtx *pFwupgCtx ,
                                    int componentToUpload , int option ) 
{ 
  struct HpmfwupgImageHeader *pImageHeader ;
  struct HpmfwupgActionRecord *pActionRecord ;
  int rc ;
  unsigned char *pImagePtr ;
  unsigned int actionsSize ;
  int flagColdReset ;
  unsigned char tmp ;
  struct HpmfwupgInitiateUpgradeActionCtx initUpgActionCmd ;
  int componentId ;
  struct HpmfwupgInitiateUpgradeActionCtx initUpgActionCmd___0 ;

  {
#line 2116
  pImageHeader = (struct HpmfwupgImageHeader *)pFwupgCtx->pImageData;
#line 2120
  rc = (int )HPMFWUPG_SUCCESS___0;
#line 2123
  flagColdReset = 0;
#line 2127
  pImagePtr = ((pFwupgCtx->pImageData + sizeof(struct HpmfwupgImageHeader )) + (int )pImageHeader->oemDataLength) + sizeof(unsigned char );
#line 2132
  actionsSize = (unsigned int )((unsigned long )pFwupgCtx->imageSize - sizeof(struct HpmfwupgImageHeader ));
#line 2134
  if (option & 1) {
    {
#line 2136
    HpmDisplayUpgradeHeader();
    }
  } else
#line 2134
  if (option & 24) {
    {
#line 2136
    HpmDisplayUpgradeHeader();
    }
  }
  {
#line 2140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2140
    if ((unsigned long )pImagePtr < (unsigned long )((pFwupgCtx->pImageData + pFwupgCtx->imageSize) - 16)) {
#line 2140
      if (! (rc == (int )HPMFWUPG_SUCCESS___0)) {
#line 2140
        goto while_break;
      }
    } else {
#line 2140
      goto while_break;
    }
    {
#line 2145
    pActionRecord = (struct HpmfwupgActionRecord *)pImagePtr;
#line 2148
    tmp = HpmfwupgCalculateChecksum___0((unsigned char *)pActionRecord, (unsigned int )sizeof(struct HpmfwupgActionRecord ));
    }
#line 2148
    if ((int )tmp != 0) {
      {
#line 2151
      lprintf(5, "    Invalid Action record.");
#line 2152
      rc = (int )HPMFWUPG_ERROR___0;
      }
    }
#line 2155
    if (rc == (int )HPMFWUPG_SUCCESS___0) {
      {
#line 2159
      if ((int )pActionRecord->actionType == 0) {
#line 2159
        goto case_0;
      }
#line 2172
      if ((int )pActionRecord->actionType == 1) {
#line 2172
        goto case_1;
      }
#line 2212
      if ((int )pActionRecord->actionType == 2) {
#line 2212
        goto case_2;
      }
#line 2226
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 2164
      initUpgActionCmd.req.componentsMask = pFwupgCtx->compUpdateMask;
#line 2166
      initUpgActionCmd.req.upgradeAction = (unsigned char)0;
#line 2167
      rc = HpmfwupgInitiateUpgradeAction___0(intf, & initUpgActionCmd, pFwupgCtx);
#line 2168
      pImagePtr += sizeof(struct HpmfwupgActionRecord );
      }
#line 2171
      goto switch_break;
      case_1: /* CIL Label */ 
#line 2180
      componentId = 0;
      {
#line 2180
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2180
        if (! (componentId < 8)) {
#line 2180
          goto while_break___0;
        }
#line 2184
        if ((1 << componentId) & (int )pFwupgCtx->compUpdateMask.ComponentBits.byte) {
#line 2186
          if ((int )pFwupgCtx->genCompProp[componentId].GeneralCompProperties.bitfield.preparationSupport == 0) {
            {
#line 2188
            lprintf(5, "    Prepare component not supported by component ID %d", componentId);
#line 2189
            rc = (int )HPMFWUPG_ERROR___0;
            }
#line 2190
            goto while_break___0;
          }
        }
#line 2180
        componentId ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2195
      if (rc == (int )HPMFWUPG_SUCCESS___0) {
#line 2197
        if ((int )pFwupgCtx->compUpdateMask.ComponentBits.byte != 0) {
          {
#line 2201
          initUpgActionCmd___0.req.componentsMask = pFwupgCtx->compUpdateMask;
#line 2203
          initUpgActionCmd___0.req.upgradeAction = (unsigned char)1;
#line 2204
          rc = HpmfwupgInitiateUpgradeAction___0(intf, & initUpgActionCmd___0, pFwupgCtx);
          }
        }
#line 2207
        pImagePtr += sizeof(struct HpmfwupgActionRecord );
      }
#line 2210
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 2214
      rc = HpmFwupgActionUploadFirmware___0(pActionRecord->components, pFwupgCtx,
                                            & pImagePtr, componentToUpload, intf,
                                            option, & flagColdReset);
      }
#line 2225
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 2227
      lprintf(5, "    Invalid Action type. Cannot continue");
#line 2228
      rc = (int )HPMFWUPG_ERROR___0;
      }
#line 2229
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2234
  HpmDisplayLine((char *)"-", 79);
#line 2236
  fflush(stdout);
#line 2237
  lprintf(5, "(*) Component requires Payload Cold Reset");
  }
#line 2239
  return (rc);
}
}
#line 2242 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmFwupgActionUploadFirmware___0(struct HpmfwupgComponentBitMask components ,
                                            struct HpmfwupgUpgradeCtx *pFwupgCtx ,
                                            unsigned char **pImagePtr , int componentToUpload ,
                                            struct ipmi_intf *intf , int option ,
                                            int *pFlagColdReset ) 
{ 
  struct HpmfwupgFirmwareImage *pFwImage ;
  struct HpmfwupgInitiateUpgradeActionCtx initUpgActionCmd ;
  struct HpmfwupgUploadFirmwareBlockCtx uploadCmd ;
  struct HpmfwupgFinishFirmwareUploadCtx finishCmd ;
  VERSIONINFO *pVersionInfo ;
  time_t start ;
  time_t end ;
  int rc ;
  int skip ;
  unsigned char *pData ;
  unsigned char *pDataInitial ;
  unsigned char count ;
  unsigned int totalSent ;
  unsigned char bufLength ;
  unsigned int firmwareLength ;
  unsigned int displayFWLength ;
  unsigned char *pDataTemp ;
  unsigned int imageOffset ;
  unsigned int blockLength ;
  unsigned int lengthOfBlock ;
  unsigned int numTxPkts ;
  unsigned int numRxPkts ;
  unsigned char mode ;
  unsigned char componentId ;
  unsigned char componentIdByte ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 2261
  rc = (int )HPMFWUPG_SUCCESS___0;
#line 2262
  skip = 1;
#line 2265
  totalSent = 0U;
#line 2266
  bufLength = (unsigned char)0;
#line 2267
  firmwareLength = 0U;
#line 2269
  displayFWLength = 0U;
#line 2271
  imageOffset = 0U;
#line 2272
  blockLength = 0U;
#line 2273
  lengthOfBlock = 0U;
#line 2274
  numTxPkts = 0U;
#line 2275
  numRxPkts = 0U;
#line 2276
  mode = (unsigned char)0;
#line 2277
  componentId = (unsigned char)0;
#line 2278
  componentIdByte = (unsigned char)0;
#line 2281
  componentIdByte = components.ComponentBits.byte;
  {
#line 2282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2282
    componentIdByte = (unsigned char )((int )componentIdByte >> 1);
#line 2282
    if (! ((int )componentIdByte != 0)) {
#line 2282
      goto while_break;
    }
#line 2284
    componentId = (unsigned char )((int )componentId + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 2286
  pFwupgCtx->componentId = componentId;
#line 2288
  pVersionInfo = & gVersionInfo[componentId];
#line 2290
  pFwImage = (struct HpmfwupgFirmwareImage *)(*pImagePtr + sizeof(struct HpmfwupgActionRecord ));
#line 2293
  pDataInitial = (unsigned char *)pFwImage + sizeof(struct HpmfwupgFirmwareImage );
#line 2294
  pData = pDataInitial;
#line 2297
  firmwareLength = (unsigned int )pFwImage->length[0];
#line 2298
  firmwareLength |= (unsigned int )(((int )pFwImage->length[1] << 8) & 65280);
#line 2299
  firmwareLength |= (unsigned int )(((int )pFwImage->length[2] << 16) & 16711680);
#line 2300
  firmwareLength |= (unsigned int )((int )pFwImage->length[3] << 24) & 4278190080U;
#line 2302
  mode = (unsigned char)5;
#line 2304
  if (pVersionInfo->rollbackSupported) {
#line 2306
    mode = (unsigned char )((int )mode | 2);
  }
#line 2309
  if (option & 4) {
    {
#line 2311
    printf((char const   */* __restrict  */)"\n\n Comp ID : %d\t [%-20s]\n", (int )pVersionInfo->componentId,
           pFwImage->desc);
    }
  } else {
    {
#line 2315
    HpmDisplayVersion((int )mode, pVersionInfo, 0);
    }
  }
#line 2318
  if ((1 << (int )componentId) & (int )pFwupgCtx->compUpdateMask.ComponentBits.byte) {
#line 2320
    if (verbose) {
      {
#line 2321
      lprintf(5, "Do not skip %d", (int )componentId);
      }
    }
#line 2323
    skip = 0;
  }
#line 2326
  if (! skip) {
    {
#line 2328
    HpmDisplayUpgrade(0, 0U, 1U, (time_t )0);
#line 2330
    uploadCmd.req.blockNumber = (unsigned char)0;
    }
#line 2333
    if ((int )intf->channel_buf_size != 0) {
#line 2335
      if (intf->target_addr == intf->my_addr) {
#line 2337
        bufLength = (unsigned char )((int )intf->channel_buf_size - 9);
      } else {
#line 2341
        bufLength = (unsigned char )((int )intf->channel_buf_size - 11);
      }
    } else {
      {
#line 2347
      tmp___0 = strstr((char const   *)(intf->name), "lan");
      }
#line 2347
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 2349
        bufLength = (unsigned char)23;
#line 2350
        if (intf->transit_addr != intf->my_addr) {
#line 2350
          if (intf->transit_addr != 0U) {
#line 2351
            bufLength = (unsigned char )((int )bufLength - 8);
          }
        }
      } else {
        {
#line 2355
        tmp = strstr((char const   *)(intf->name), "open");
        }
#line 2355
        if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 2355
          if (intf->target_addr == intf->my_addr) {
#line 2364
            bufLength = (unsigned char)28;
          } else {
#line 2355
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 2368
        if ((int )intf->target_channel == 7) {
#line 2370
          bufLength = (unsigned char)26;
        } else {
#line 2374
          bufLength = (unsigned char)26;
        }
      }
    }
    {
#line 2381
    initUpgActionCmd.req.componentsMask = components;
#line 2383
    initUpgActionCmd.req.upgradeAction = (unsigned char)2;
#line 2384
    rc = HpmfwupgInitiateUpgradeAction___0(intf, & initUpgActionCmd, pFwupgCtx);
    }
#line 2386
    if (rc != (int )HPMFWUPG_SUCCESS___0) {
#line 2388
      skip = 1;
    }
#line 2391
    if (pVersionInfo->coldResetRequired) {
#line 2391
      if (! skip) {
#line 2393
        *pFlagColdReset = 1;
      }
    }
    {
#line 2397
    pData = pDataInitial;
#line 2398
    pDataTemp = pDataInitial;
#line 2399
    lengthOfBlock = firmwareLength;
#line 2400
    totalSent = 0U;
#line 2401
    displayFWLength = firmwareLength;
#line 2402
    time(& start);
    }
    {
#line 2405
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2405
      if ((unsigned long )pData < (unsigned long )(pDataTemp + lengthOfBlock)) {
#line 2405
        if (! (rc == (int )HPMFWUPG_SUCCESS___0)) {
#line 2405
          goto while_break___0;
        }
      } else {
#line 2405
        goto while_break___0;
      }
#line 2407
      if ((unsigned long )(pData + (int )bufLength) <= (unsigned long )(pDataTemp + lengthOfBlock)) {
#line 2409
        count = bufLength;
      } else {
#line 2413
        count = (unsigned char )((pDataTemp + lengthOfBlock) - pData);
      }
      {
#line 2415
      memcpy((void */* __restrict  */)(& uploadCmd.req.data), (void const   */* __restrict  */)pData,
             (size_t )bufLength);
#line 2417
      imageOffset = 0U;
#line 2418
      blockLength = 0U;
#line 2419
      numTxPkts ++;
#line 2420
      rc = HpmfwupgUploadFirmwareBlock___0(intf, & uploadCmd, pFwupgCtx, (int )count,
                                           & imageOffset, & blockLength);
#line 2422
      numRxPkts ++;
      }
#line 2424
      if (rc != (int )HPMFWUPG_SUCCESS___0) {
#line 2426
        if (rc == (int )HPMFWUPG_UPLOAD_BLOCK_LENGTH___0) {
          {
#line 2429
          tmp___1 = strstr((char const   *)(intf->name), "lan");
          }
#line 2429
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
            {
#line 2431
            bufLength = (unsigned char )((int )bufLength - 8);
#line 2432
            lprintf(6, "Trying reduced buffer length: %d", (int )bufLength);
            }
          } else {
            {
#line 2436
            bufLength = (unsigned char )((int )bufLength - 1);
#line 2437
            lprintf(6, "Trying reduced buffer length: %d", (int )bufLength);
            }
          }
#line 2439
          rc = (int )HPMFWUPG_SUCCESS___0;
        } else
#line 2441
        if (rc == (int )HPMFWUPG_UPLOAD_RETRY___0) {
#line 2443
          rc = (int )HPMFWUPG_SUCCESS___0;
        } else {
          {
#line 2447
          fflush(stdout);
#line 2448
          lprintf(5, "\n Error in Upload FIRMWARE command [rc=%d]\n", rc);
#line 2449
          lprintf(5, "\n TotalSent:0x%x ", totalSent);
#line 2451
          rc = (int )HPMFWUPG_ERROR___0;
          }
        }
      } else {
#line 2456
        if (blockLength > firmwareLength) {
          {
#line 2462
          lprintf(5, "\n Error in Upload FIRMWARE command [rc=%d]\n", rc);
#line 2463
          lprintf(5, "\n TotalSent:0x%x Img offset:0x%x  Blk length:0x%x  Fwlen:0x%x\n",
                  totalSent, imageOffset, blockLength, firmwareLength);
#line 2465
          rc = (int )HPMFWUPG_ERROR___0;
          }
        }
#line 2467
        totalSent += (unsigned int )count;
#line 2468
        if (imageOffset != 0U) {
#line 2471
          lengthOfBlock = blockLength;
#line 2472
          pDataTemp = pDataInitial + imageOffset;
#line 2473
          pData = pDataTemp;
#line 2474
          if (displayFWLength == firmwareLength) {
#line 2477
            displayFWLength = blockLength + totalSent;
          }
        } else {
#line 2482
          pData += (int )count;
        }
        {
#line 2484
        time(& end);
        }
#line 2489
        if (option & 4) {
          {
#line 2491
          fflush(stdout);
#line 2492
          printf((char const   */* __restrict  */)" Blk Num : %02x        Bytes : %05x ",
                 (int )uploadCmd.req.blockNumber, totalSent);
          }
#line 2494
          if (imageOffset) {
            {
#line 2496
            printf((char const   */* __restrict  */)"\n--> ImgOff : %x BlkLen : %x\n",
                   imageOffset, blockLength);
            }
          } else
#line 2494
          if (blockLength) {
            {
#line 2496
            printf((char const   */* __restrict  */)"\n--> ImgOff : %x BlkLen : %x\n",
                   imageOffset, blockLength);
            }
          }
#line 2498
          if (displayFWLength == totalSent) {
            {
#line 2500
            printf((char const   */* __restrict  */)"\n Time Taken %02ld:%02ld", (end - start) / 60L,
                   (end - start) % 60L);
#line 2501
            printf((char const   */* __restrict  */)"\n\n");
            }
          }
        } else {
          {
#line 2506
          HpmDisplayUpgrade(0, totalSent, displayFWLength, end - start);
          }
        }
#line 2508
        uploadCmd.req.blockNumber = (unsigned char )((int )uploadCmd.req.blockNumber + 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2513
  if (skip) {
    {
#line 2516
    HpmDisplayUpgrade(1, 0U, 0U, (time_t )0);
#line 2517
    *pImagePtr = pDataInitial + firmwareLength;
    }
  }
#line 2520
  if (rc == (int )HPMFWUPG_SUCCESS___0) {
#line 2520
    if (! skip) {
      {
#line 2529
      finishCmd.req.componentId = componentId;
#line 2533
      finishCmd.req.imageLength[0] = (unsigned char )(totalSent & 255U);
#line 2534
      finishCmd.req.imageLength[1] = (unsigned char )((totalSent >> 8) & 255U);
#line 2535
      finishCmd.req.imageLength[2] = (unsigned char )((totalSent >> 16) & 255U);
#line 2536
      finishCmd.req.imageLength[3] = (unsigned char )((totalSent >> 24) & 255U);
#line 2537
      rc = HpmfwupgFinishFirmwareUpload___0(intf, & finishCmd, pFwupgCtx);
#line 2538
      *pImagePtr = pDataInitial + firmwareLength;
      }
    }
  }
#line 2541
  return (rc);
}
}
#line 2553 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgActivationStage___0(struct ipmi_intf *intf , struct HpmfwupgUpgradeCtx *pFwupgCtx ) 
{ 
  int rc ;
  struct HpmfwupgActivateFirmwareCtx activateCmd ;
  struct HpmfwupgImageHeader *pImageHeader ;
  struct HpmfwupgQuerySelftestResultCtx selfTestCmd ;
  struct HpmfwupgQueryRollbackStatusCtx rollCmd ;

  {
  {
#line 2555
  rc = (int )HPMFWUPG_SUCCESS___0;
#line 2557
  pImageHeader = (struct HpmfwupgImageHeader *)pFwupgCtx->pImageData;
#line 2561
  printf((char const   */* __restrict  */)"    ");
#line 2562
  fflush(stdout);
#line 2564
  rc = HpmfwupgActivateFirmware___0(intf, & activateCmd, pFwupgCtx);
  }
#line 2566
  if (rc == (int )HPMFWUPG_SUCCESS___0) {
#line 2569
    if ((int )pFwupgCtx->targetCap.GlobalCapabilities.bitField.ipmcSelftestCap == 1) {
#line 2569
      goto _L;
    } else
#line 2569
    if ((int )pImageHeader->imageCapabilities.bitField.imageSelfTest == 1) {
      _L: /* CIL Label */ 
      {
#line 2573
      rc = HpmfwupgQuerySelftestResult___0(intf, & selfTestCmd, pFwupgCtx);
      }
#line 2575
      if (rc == (int )HPMFWUPG_SUCCESS___0) {
#line 2578
        if ((int )selfTestCmd.resp.result1 != 85) {
          {
#line 2582
          lprintf(5, "    Self test failed:");
#line 2583
          lprintf(5, "    Result1 = %x", (int )selfTestCmd.resp.result1);
#line 2584
          lprintf(5, "    Result2 = %x", (int )selfTestCmd.resp.result2);
#line 2585
          rc = (int )HPMFWUPG_ERROR___0;
          }
        }
      } else {
        {
#line 2592
        lprintf(5, "    Self test failed.");
        }
      }
    }
  }
#line 2598
  if (rc == (int )HPMFWUPG_ERROR___0) {
#line 2600
    if ((int )pFwupgCtx->targetCap.GlobalCapabilities.bitField.autRollback == 1) {
#line 2600
      if ((int )pFwupgCtx->genCompProp[pFwupgCtx->componentId].GeneralCompProperties.bitfield.rollbackBackup != 0) {
        {
#line 2604
        lprintf(5, "    Getting rollback status...");
#line 2605
        fflush(stdout);
#line 2606
        rc = HpmfwupgQueryRollbackStatus___0(intf, & rollCmd, pFwupgCtx);
        }
      }
    }
  }
#line 2610
  return (rc);
}
}
#line 2613 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgGetBufferFromFile___0(char *imageFilename , struct HpmfwupgUpgradeCtx *pFwupgCtx ) 
{ 
  int rc ;
  int ret ;
  FILE *pImageFile ;
  FILE *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 2615
  rc = (int )HPMFWUPG_SUCCESS___0;
#line 2616
  ret = 0;
#line 2617
  tmp = fopen((char const   */* __restrict  */)imageFilename, (char const   */* __restrict  */)"rb");
#line 2617
  pImageFile = tmp;
  }
#line 2619
  if ((unsigned long )pImageFile == (unsigned long )((void *)0)) {
    {
#line 2621
    lprintf(5, "Cannot open image file %s", imageFilename);
#line 2622
    rc = (int )HPMFWUPG_ERROR___0;
    }
  }
#line 2625
  if (rc == (int )HPMFWUPG_SUCCESS___0) {
    {
#line 2628
    fseek(pImageFile, 0L, 2);
#line 2629
    tmp___0 = ftell(pImageFile);
#line 2629
    pFwupgCtx->imageSize = (unsigned int )tmp___0;
#line 2630
    tmp___1 = malloc(sizeof(unsigned char ) * (unsigned long )pFwupgCtx->imageSize);
#line 2630
    pFwupgCtx->pImageData = (unsigned char *)tmp___1;
#line 2631
    pFwupgCtx->compUpdateMask.ComponentBits.byte = (unsigned char)0;
#line 2632
    rewind(pImageFile);
    }
#line 2633
    if ((unsigned long )pFwupgCtx->pImageData != (unsigned long )((void *)0)) {
      {
#line 2635
      tmp___2 = fread((void */* __restrict  */)pFwupgCtx->pImageData, sizeof(unsigned char ),
                      (size_t )pFwupgCtx->imageSize, (FILE */* __restrict  */)pImageFile);
#line 2635
      ret = (int )tmp___2;
      }
#line 2637
      if ((unsigned int )ret != pFwupgCtx->imageSize) {
        {
#line 2638
        lprintf(3, "Failed to read file %s size %d", imageFilename, pFwupgCtx->imageSize);
#line 2640
        rc = (int )HPMFWUPG_ERROR___0;
        }
      }
    } else {
#line 2645
      rc = (int )HPMFWUPG_ERROR___0;
    }
    {
#line 2648
    fclose(pImageFile);
    }
  }
#line 2651
  return (rc);
}
}
#line 2654 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgGetDeviceId___0(struct ipmi_intf *intf , struct ipm_devid_rsp *pGetDevId ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;

  {
  {
#line 2656
  rc = (int )HPMFWUPG_SUCCESS___0;
#line 2660
  memset((void *)(& req), 0, sizeof(req));
#line 2661
  req.msg.netfn = (uint8_t )6;
#line 2662
  req.msg.cmd = (uint8_t )1;
#line 2663
  req.msg.data_len = (uint16_t )0;
#line 2665
  rsp = HpmfwupgSendCmd___0(intf, req, (struct HpmfwupgUpgradeCtx *)((void *)0));
  }
#line 2667
  if (rsp) {
#line 2669
    if ((int )rsp->ccode == 0) {
      {
#line 2671
      memcpy((void */* __restrict  */)pGetDevId, (void const   */* __restrict  */)(rsp->data),
             sizeof(struct ipm_devid_rsp ));
      }
    } else {
      {
#line 2675
      lprintf(5, "Error getting device ID");
#line 2676
      tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2676
      lprintf(5, "compcode=0x%x: %s", (int )rsp->ccode, tmp);
#line 2679
      rc = (int )HPMFWUPG_ERROR___0;
      }
    }
  } else {
    {
#line 2684
    lprintf(5, "Error getting device ID\n");
#line 2685
    rc = (int )HPMFWUPG_ERROR___0;
    }
  }
#line 2687
  return (rc);
}
}
#line 2690 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgGetTargetUpgCapabilities___0(struct ipmi_intf *intf , struct HpmfwupgGetTargetUpgCapabilitiesCtx *pCtx ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 2693
  rc = (int )HPMFWUPG_SUCCESS___0;
#line 2697
  pCtx->req.picmgId = (unsigned char)0;
#line 2699
  memset((void *)(& req), 0, sizeof(req));
#line 2700
  req.msg.netfn = (uint8_t )44;
#line 2701
  req.msg.cmd = (uint8_t )46;
#line 2702
  req.msg.data = (unsigned char *)(& pCtx->req);
#line 2703
  req.msg.data_len = (uint16_t )sizeof(struct HpmfwupgGetTargetUpgCapabilitiesReq );
#line 2705
  rsp = HpmfwupgSendCmd___0(intf, req, (struct HpmfwupgUpgradeCtx *)((void *)0));
  }
#line 2707
  if (rsp) {
#line 2709
    if ((int )rsp->ccode == 0) {
      {
#line 2711
      memcpy((void */* __restrict  */)(& pCtx->resp), (void const   */* __restrict  */)(rsp->data),
             sizeof(struct HpmfwupgGetTargetUpgCapabilitiesResp ));
      }
#line 2712
      if (verbose) {
        {
#line 2714
        lprintf(5, "TARGET UPGRADE CAPABILITIES");
#line 2715
        lprintf(5, "-------------------------------");
#line 2716
        lprintf(5, "HPM.1 version............%d    ", (int )pCtx->resp.hpmVersion);
        }
#line 2717
        if (pCtx->resp.componentsPresent.ComponentBits.bitField.component0) {
#line 2717
          tmp = 'y';
        } else {
#line 2717
          tmp = 'n';
        }
        {
#line 2717
        lprintf(5, "Component 0 presence....[%c]   ", tmp);
        }
#line 2719
        if (pCtx->resp.componentsPresent.ComponentBits.bitField.component1) {
#line 2719
          tmp___0 = 'y';
        } else {
#line 2719
          tmp___0 = 'n';
        }
        {
#line 2719
        lprintf(5, "Component 1 presence....[%c]   ", tmp___0);
        }
#line 2721
        if (pCtx->resp.componentsPresent.ComponentBits.bitField.component2) {
#line 2721
          tmp___1 = 'y';
        } else {
#line 2721
          tmp___1 = 'n';
        }
        {
#line 2721
        lprintf(5, "Component 2 presence....[%c]   ", tmp___1);
        }
#line 2723
        if (pCtx->resp.componentsPresent.ComponentBits.bitField.component3) {
#line 2723
          tmp___2 = 'y';
        } else {
#line 2723
          tmp___2 = 'n';
        }
        {
#line 2723
        lprintf(5, "Component 3 presence....[%c]   ", tmp___2);
        }
#line 2725
        if (pCtx->resp.componentsPresent.ComponentBits.bitField.component4) {
#line 2725
          tmp___3 = 'y';
        } else {
#line 2725
          tmp___3 = 'n';
        }
        {
#line 2725
        lprintf(5, "Component 4 presence....[%c]   ", tmp___3);
        }
#line 2727
        if (pCtx->resp.componentsPresent.ComponentBits.bitField.component5) {
#line 2727
          tmp___4 = 'y';
        } else {
#line 2727
          tmp___4 = 'n';
        }
        {
#line 2727
        lprintf(5, "Component 5 presence....[%c]   ", tmp___4);
        }
#line 2729
        if (pCtx->resp.componentsPresent.ComponentBits.bitField.component6) {
#line 2729
          tmp___5 = 'y';
        } else {
#line 2729
          tmp___5 = 'n';
        }
        {
#line 2729
        lprintf(5, "Component 6 presence....[%c]   ", tmp___5);
        }
#line 2731
        if (pCtx->resp.componentsPresent.ComponentBits.bitField.component7) {
#line 2731
          tmp___6 = 'y';
        } else {
#line 2731
          tmp___6 = 'n';
        }
        {
#line 2731
        lprintf(5, "Component 7 presence....[%c]   ", tmp___6);
        }
#line 2733
        if (pCtx->resp.GlobalCapabilities.bitField.fwUpgUndesirable) {
#line 2733
          tmp___7 = 'y';
        } else {
#line 2733
          tmp___7 = 'n';
        }
        {
#line 2733
        lprintf(5, "Upgrade undesirable.....[%c]   ", tmp___7);
        }
#line 2735
        if (pCtx->resp.GlobalCapabilities.bitField.autRollbackOverride) {
#line 2735
          tmp___8 = 'y';
        } else {
#line 2735
          tmp___8 = 'n';
        }
        {
#line 2735
        lprintf(5, "Aut rollback override...[%c]   ", tmp___8);
        }
#line 2737
        if (pCtx->resp.GlobalCapabilities.bitField.ipmcDegradedDurinUpg) {
#line 2737
          tmp___9 = 'y';
        } else {
#line 2737
          tmp___9 = 'n';
        }
        {
#line 2737
        lprintf(5, "IPMC degraded...........[%c]   ", tmp___9);
        }
#line 2739
        if (pCtx->resp.GlobalCapabilities.bitField.deferActivation) {
#line 2739
          tmp___10 = 'y';
        } else {
#line 2739
          tmp___10 = 'n';
        }
        {
#line 2739
        lprintf(5, "Defered activation......[%c]   ", tmp___10);
        }
#line 2741
        if (pCtx->resp.GlobalCapabilities.bitField.servAffectDuringUpg) {
#line 2741
          tmp___11 = 'y';
        } else {
#line 2741
          tmp___11 = 'n';
        }
        {
#line 2741
        lprintf(5, "Service affected........[%c]   ", tmp___11);
        }
#line 2743
        if (pCtx->resp.GlobalCapabilities.bitField.manualRollback) {
#line 2743
          tmp___12 = 'y';
        } else {
#line 2743
          tmp___12 = 'n';
        }
        {
#line 2743
        lprintf(5, "Manual rollback.........[%c]   ", tmp___12);
        }
#line 2745
        if (pCtx->resp.GlobalCapabilities.bitField.autRollback) {
#line 2745
          tmp___13 = 'y';
        } else {
#line 2745
          tmp___13 = 'n';
        }
        {
#line 2745
        lprintf(5, "Automatic rollback......[%c]   ", tmp___13);
        }
#line 2747
        if (pCtx->resp.GlobalCapabilities.bitField.ipmcSelftestCap) {
#line 2747
          tmp___14 = 'y';
        } else {
#line 2747
          tmp___14 = 'n';
        }
        {
#line 2747
        lprintf(5, "Self test...............[%c]   ", tmp___14);
#line 2749
        lprintf(5, "Upgrade timeout.........[%d sec] ", (int )pCtx->resp.upgradeTimeout * 5);
#line 2750
        lprintf(5, "Self test timeout.......[%d sec] ", (int )pCtx->resp.selftestTimeout * 5);
#line 2751
        lprintf(5, "Rollback timeout........[%d sec] ", (int )pCtx->resp.rollbackTimeout * 5);
#line 2752
        lprintf(5, "Inaccessibility timeout.[%d sec] \n", (int )pCtx->resp.inaccessTimeout * 5);
        }
      }
    } else {
      {
#line 2757
      lprintf(5, "Error getting target upgrade capabilities\n", (int )rsp->ccode);
#line 2758
      rc = (int )HPMFWUPG_ERROR___0;
      }
    }
  } else {
    {
#line 2763
    lprintf(5, "Error getting target upgrade capabilities\n");
#line 2764
    rc = (int )HPMFWUPG_ERROR___0;
    }
  }
#line 2769
  return (rc);
}
}
#line 2773 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgGetComponentProperties___0(struct ipmi_intf *intf , struct HpmfwupgGetComponentPropertiesCtx *pCtx ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned char i ;
  char const   *tmp___4 ;

  {
  {
#line 2775
  rc = (int )HPMFWUPG_SUCCESS___0;
#line 2779
  pCtx->req.picmgId = (unsigned char)0;
#line 2781
  memset((void *)(& req), 0, sizeof(req));
#line 2782
  req.msg.netfn = (uint8_t )44;
#line 2783
  req.msg.cmd = (uint8_t )47;
#line 2784
  req.msg.data = (unsigned char *)(& pCtx->req);
#line 2785
  req.msg.data_len = (uint16_t )sizeof(struct HpmfwupgGetComponentPropertiesReq );
#line 2787
  rsp = HpmfwupgSendCmd___0(intf, req, (struct HpmfwupgUpgradeCtx *)((void *)0));
  }
#line 2789
  if (rsp) {
#line 2791
    if ((int )rsp->ccode == 0) {
      {
#line 2795
      if ((int )pCtx->req.selector == 0) {
#line 2795
        goto case_0;
      }
#line 2813
      if ((int )pCtx->req.selector == 1) {
#line 2813
        goto case_1;
      }
#line 2826
      if ((int )pCtx->req.selector == 2) {
#line 2826
        goto case_2;
      }
#line 2833
      if ((int )pCtx->req.selector == 3) {
#line 2833
        goto case_3;
      }
#line 2846
      if ((int )pCtx->req.selector == 4) {
#line 2846
        goto case_4;
      }
#line 2860
      if ((int )pCtx->req.selector == 192) {
#line 2860
        goto case_192;
      }
#line 2872
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 2796
      memcpy((void */* __restrict  */)(& pCtx->resp), (void const   */* __restrict  */)(rsp->data),
             sizeof(struct HpmfwupgGetGeneralPropResp ));
      }
#line 2797
      if (verbose) {
        {
#line 2799
        lprintf(5, "GENERAL PROPERTIES");
#line 2800
        lprintf(5, "-------------------------------");
        }
#line 2801
        if (pCtx->resp.Response.generalPropResp.GeneralCompProperties.bitfield.payloadColdReset) {
#line 2801
          tmp = 'y';
        } else {
#line 2801
          tmp = 'n';
        }
        {
#line 2801
        lprintf(5, "Payload cold reset req....[%c]   ", tmp);
        }
#line 2803
        if (pCtx->resp.Response.generalPropResp.GeneralCompProperties.bitfield.deferredActivation) {
#line 2803
          tmp___0 = 'y';
        } else {
#line 2803
          tmp___0 = 'n';
        }
        {
#line 2803
        lprintf(5, "Def. activation supported.[%c]   ", tmp___0);
        }
#line 2805
        if (pCtx->resp.Response.generalPropResp.GeneralCompProperties.bitfield.comparisonSupport) {
#line 2805
          tmp___1 = 'y';
        } else {
#line 2805
          tmp___1 = 'n';
        }
        {
#line 2805
        lprintf(5, "Comparison supported......[%c]   ", tmp___1);
        }
#line 2807
        if (pCtx->resp.Response.generalPropResp.GeneralCompProperties.bitfield.preparationSupport) {
#line 2807
          tmp___2 = 'y';
        } else {
#line 2807
          tmp___2 = 'n';
        }
        {
#line 2807
        lprintf(5, "Preparation supported.....[%c]   ", tmp___2);
        }
#line 2809
        if (pCtx->resp.Response.generalPropResp.GeneralCompProperties.bitfield.rollbackBackup) {
#line 2809
          tmp___3 = 'y';
        } else {
#line 2809
          tmp___3 = 'n';
        }
        {
#line 2809
        lprintf(5, "Rollback supported........[%c]   \n", tmp___3);
        }
      }
#line 2812
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 2814
      memcpy((void */* __restrict  */)(& pCtx->resp), (void const   */* __restrict  */)(rsp->data),
             sizeof(struct HpmfwupgGetCurrentVersionResp ));
      }
#line 2815
      if (verbose) {
        {
#line 2817
        lprintf(5, "Current Version: ");
#line 2818
        lprintf(5, " Major: %d", (int )pCtx->resp.Response.currentVersionResp.currentVersion[0]);
#line 2819
        lprintf(5, " Minor: %x", (int )pCtx->resp.Response.currentVersionResp.currentVersion[1]);
#line 2820
        lprintf(5, " Aux  : %03d %03d %03d %03d\n", (int )pCtx->resp.Response.currentVersionResp.currentVersion[2],
                (int )pCtx->resp.Response.currentVersionResp.currentVersion[3], (int )pCtx->resp.Response.currentVersionResp.currentVersion[4],
                (int )pCtx->resp.Response.currentVersionResp.currentVersion[5]);
        }
      }
#line 2825
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 2827
      memcpy((void */* __restrict  */)(& pCtx->resp), (void const   */* __restrict  */)(rsp->data),
             sizeof(struct HpmfwupgGetDescStringResp ));
      }
#line 2828
      if (verbose) {
        {
#line 2830
        lprintf(5, "Description string: %s\n", pCtx->resp.Response.descStringResp.descString);
        }
      }
#line 2832
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 2834
      memcpy((void */* __restrict  */)(& pCtx->resp), (void const   */* __restrict  */)(rsp->data),
             sizeof(struct HpmfwupgGetRollbackFwVersionResp ));
      }
#line 2835
      if (verbose) {
        {
#line 2837
        lprintf(5, "Rollback FW Version: ");
#line 2838
        lprintf(5, " Major: %d", (int )pCtx->resp.Response.rollbackFwVersionResp.rollbackFwVersion[0]);
#line 2839
        lprintf(5, " Minor: %x", (int )pCtx->resp.Response.rollbackFwVersionResp.rollbackFwVersion[1]);
#line 2840
        lprintf(5, " Aux  : %03d %03d %03d %03d\n", (int )pCtx->resp.Response.rollbackFwVersionResp.rollbackFwVersion[2],
                (int )pCtx->resp.Response.rollbackFwVersionResp.rollbackFwVersion[3],
                (int )pCtx->resp.Response.rollbackFwVersionResp.rollbackFwVersion[4],
                (int )pCtx->resp.Response.rollbackFwVersionResp.rollbackFwVersion[5]);
        }
      }
#line 2845
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 2847
      memcpy((void */* __restrict  */)(& pCtx->resp), (void const   */* __restrict  */)(rsp->data),
             sizeof(struct HpmfwupgGetDeferredFwVersionResp ));
      }
#line 2848
      if (verbose) {
        {
#line 2850
        lprintf(5, "Deferred FW Version: ");
#line 2851
        lprintf(5, " Major: %d", (int )pCtx->resp.Response.deferredFwVersionResp.deferredFwVersion[0]);
#line 2852
        lprintf(5, " Minor: %x", (int )pCtx->resp.Response.deferredFwVersionResp.deferredFwVersion[1]);
#line 2853
        lprintf(5, " Aux  : %03d %03d %03d %03d\n", (int )pCtx->resp.Response.deferredFwVersionResp.deferredFwVersion[2],
                (int )pCtx->resp.Response.deferredFwVersionResp.deferredFwVersion[3],
                (int )pCtx->resp.Response.deferredFwVersionResp.deferredFwVersion[4],
                (int )pCtx->resp.Response.deferredFwVersionResp.deferredFwVersion[5]);
        }
      }
#line 2858
      goto switch_break;
      case_192: /* CIL Label */ 
      {
#line 2861
      memcpy((void */* __restrict  */)(& pCtx->resp), (void const   */* __restrict  */)(rsp->data),
             sizeof(struct HpmfwupgGetOemProperties ));
      }
#line 2862
      if (verbose) {
        {
#line 2864
        i = (unsigned char)0;
#line 2865
        lprintf(5, "OEM Properties: ");
#line 2866
        i = (unsigned char)0;
        }
        {
#line 2866
        while (1) {
          while_continue: /* CIL Label */ ;
#line 2866
          if (! ((int )i < 4)) {
#line 2866
            goto while_break;
          }
          {
#line 2868
          lprintf(5, " 0x%x ", (int )pCtx->resp.Response.oemProperties.oemRspData[i]);
#line 2866
          i = (unsigned char )((int )i + 1);
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 2871
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 2873
      lprintf(5, "Unsupported component selector");
#line 2874
      rc = (int )HPMFWUPG_ERROR___0;
      }
#line 2875
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 2880
      lprintf(5, "Error getting component properties");
#line 2881
      tmp___4 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2881
      lprintf(5, "compcode=0x%x: %s", (int )rsp->ccode, tmp___4);
#line 2884
      rc = (int )HPMFWUPG_ERROR___0;
      }
    }
  } else {
    {
#line 2889
    lprintf(5, "Error getting component properties\n");
#line 2890
    rc = (int )HPMFWUPG_ERROR___0;
    }
  }
#line 2894
  return (rc);
}
}
#line 2897 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgAbortUpgrade___0(struct ipmi_intf *intf , struct HpmfwupgAbortUpgradeCtx *pCtx ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;

  {
  {
#line 2899
  rc = (int )HPMFWUPG_SUCCESS___0;
#line 2903
  pCtx->req.picmgId = (unsigned char)0;
#line 2905
  memset((void *)(& req), 0, sizeof(req));
#line 2906
  req.msg.netfn = (uint8_t )44;
#line 2907
  req.msg.cmd = (uint8_t )48;
#line 2908
  req.msg.data = (unsigned char *)(& pCtx->req);
#line 2909
  req.msg.data_len = (uint16_t )sizeof(struct HpmfwupgAbortUpgradeReq );
#line 2911
  rsp = HpmfwupgSendCmd___0(intf, req, (struct HpmfwupgUpgradeCtx *)((void *)0));
  }
#line 2913
  if (rsp) {
#line 2915
    if ((int )rsp->ccode != 0) {
      {
#line 2917
      lprintf(5, "Error aborting upgrade");
#line 2918
      tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2918
      lprintf(5, "compcode=0x%x: %s", (int )rsp->ccode, tmp);
#line 2921
      rc = (int )HPMFWUPG_ERROR___0;
      }
    }
  } else {
    {
#line 2926
    lprintf(5, "Error aborting upgrade\n");
#line 2927
    rc = (int )HPMFWUPG_ERROR___0;
    }
  }
#line 2929
  return (rc);
}
}
#line 2932 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgInitiateUpgradeAction___0(struct ipmi_intf *intf , struct HpmfwupgInitiateUpgradeActionCtx *pCtx ,
                                             struct HpmfwupgUpgradeCtx *pFwupgCtx ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;

  {
  {
#line 2935
  rc = (int )HPMFWUPG_SUCCESS___0;
#line 2939
  pCtx->req.picmgId = (unsigned char)0;
#line 2941
  memset((void *)(& req), 0, sizeof(req));
#line 2942
  req.msg.netfn = (uint8_t )44;
#line 2943
  req.msg.cmd = (uint8_t )49;
#line 2944
  req.msg.data = (unsigned char *)(& pCtx->req);
#line 2945
  req.msg.data_len = (uint16_t )sizeof(struct HpmfwupgInitiateUpgradeActionReq );
#line 2947
  rsp = HpmfwupgSendCmd___0(intf, req, pFwupgCtx);
  }
#line 2949
  if (rsp) {
#line 2952
    if ((int )rsp->ccode == 128) {
      {
#line 2954
      rc = HpmfwupgWaitLongDurationCmd___0(intf, pFwupgCtx);
      }
    } else
#line 2956
    if ((int )rsp->ccode != 0) {
      {
#line 2958
      lprintf(5, "Error initiating upgrade action");
#line 2959
      tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2959
      lprintf(5, "compcode=0x%x: %s", (int )rsp->ccode, tmp);
#line 2962
      rc = (int )HPMFWUPG_ERROR___0;
      }
    }
  } else {
    {
#line 2967
    lprintf(5, "Error initiating upgrade action\n");
#line 2968
    rc = (int )HPMFWUPG_ERROR___0;
    }
  }
#line 2971
  return (rc);
}
}
#line 2974 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgUploadFirmwareBlock___0(struct ipmi_intf *intf , struct HpmfwupgUploadFirmwareBlockCtx *pCtx ,
                                           struct HpmfwupgUpgradeCtx *pFwupgCtx ,
                                           int count , unsigned int *imageOffset ,
                                           unsigned int *blockLength ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2978
  rc = (int )HPMFWUPG_SUCCESS___0;
#line 2982
  pCtx->req.picmgId = (unsigned char)0;
#line 2984
  memset((void *)(& req), 0, sizeof(req));
#line 2985
  req.msg.netfn = (uint8_t )44;
#line 2986
  req.msg.cmd = (uint8_t )50;
#line 2987
  req.msg.data = (unsigned char *)(& pCtx->req);
#line 2989
  req.msg.data_len = (uint16_t )(2 + count);
#line 2991
  rsp = HpmfwupgSendCmd___0(intf, req, pFwupgCtx);
  }
#line 2993
  if (rsp) {
#line 2995
    if ((int )rsp->ccode == 128) {
#line 2995
      goto _L;
    } else
#line 2995
    if ((int )rsp->ccode == 0) {
      _L: /* CIL Label */ 
#line 3002
      if (rsp->data_len > 1) {
#line 3009
        if (rsp->data_len == 9) {
#line 3012
          *imageOffset = (unsigned int )(((((int )rsp->data[4] << 24) + ((int )rsp->data[3] << 16)) + ((int )rsp->data[2] << 8)) + (int )rsp->data[1]);
#line 3013
          *blockLength = (unsigned int )(((((int )rsp->data[8] << 24) + ((int )rsp->data[7] << 16)) + ((int )rsp->data[6] << 8)) + (int )rsp->data[5]);
        } else {
          {
#line 3022
          lprintf(5, "Error wrong rsp->datalen %d for Upload Firmware block command\n",
                  rsp->data_len);
#line 3023
          rsp->ccode = (uint8_t )130;
          }
        }
      }
    }
#line 3028
    if ((int )rsp->ccode == 128) {
      {
#line 3030
      rc = HpmfwupgWaitLongDurationCmd___0(intf, pFwupgCtx);
      }
    } else
#line 3032
    if ((int )rsp->ccode != 0) {
#line 3039
      if ((int )rsp->ccode == 131) {
#line 3039
        goto _L___0;
      } else
#line 3039
      if ((int )rsp->ccode == 130) {
#line 3039
        goto _L___0;
      } else
#line 3039
      if ((int )rsp->ccode == 128) {
        _L___0: /* CIL Label */ 
#line 3039
        tmp___2 = errorCount___1;
#line 3039
        errorCount___1 ++;
#line 3039
        if (tmp___2 < 3) {
#line 3039
          tmp___1 = 1;
        } else {
#line 3039
          tmp___1 = 0;
        }
      } else {
#line 3039
        tmp___1 = 0;
      }
#line 3039
      if (tmp___1) {
        {
#line 3041
        lprintf(7, "HPM: [PATCH]Retryable error detected");
#line 3042
        rc = (int )HPMFWUPG_UPLOAD_RETRY___0;
        }
      } else
#line 3048
      if ((int )rsp->ccode == 199) {
#line 3050
        rc = (int )HPMFWUPG_UPLOAD_BLOCK_LENGTH___0;
      } else {
        {
#line 3054
        lprintf(5, "Error uploading firmware block");
#line 3055
        tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3055
        lprintf(5, "compcode=0x%x: %s", (int )rsp->ccode, tmp);
#line 3058
        rc = (int )HPMFWUPG_ERROR___0;
        }
      }
    }
  } else {
    {
#line 3064
    lprintf(5, "Error uploading firmware block\n");
#line 3065
    rc = (int )HPMFWUPG_ERROR___0;
    }
  }
#line 3068
  return (rc);
}
}
#line 3071 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgFinishFirmwareUpload___0(struct ipmi_intf *intf , struct HpmfwupgFinishFirmwareUploadCtx *pCtx ,
                                            struct HpmfwupgUpgradeCtx *pFwupgCtx ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;

  {
  {
#line 3074
  rc = (int )HPMFWUPG_SUCCESS___0;
#line 3078
  pCtx->req.picmgId = (unsigned char)0;
#line 3080
  memset((void *)(& req), 0, sizeof(req));
#line 3081
  req.msg.netfn = (uint8_t )44;
#line 3082
  req.msg.cmd = (uint8_t )51;
#line 3083
  req.msg.data = (unsigned char *)(& pCtx->req);
#line 3084
  req.msg.data_len = (uint16_t )sizeof(struct HpmfwupgFinishFirmwareUploadReq );
#line 3086
  rsp = HpmfwupgSendCmd___0(intf, req, pFwupgCtx);
  }
#line 3088
  if (rsp) {
#line 3091
    if ((int )rsp->ccode == 128) {
      {
#line 3093
      rc = HpmfwupgWaitLongDurationCmd___0(intf, pFwupgCtx);
      }
    } else
#line 3095
    if ((int )rsp->ccode != 0) {
      {
#line 3097
      lprintf(5, "Error finishing firmware upload");
#line 3098
      tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3098
      lprintf(5, "compcode=0x%x: %s", (int )rsp->ccode, tmp);
#line 3101
      rc = (int )HPMFWUPG_ERROR___0;
      }
    }
  } else {
    {
#line 3106
    lprintf(5, "Error fininshing firmware upload\n");
#line 3107
    rc = (int )HPMFWUPG_ERROR___0;
    }
  }
#line 3110
  return (rc);
}
}
#line 3113 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgActivateFirmware___0(struct ipmi_intf *intf , struct HpmfwupgActivateFirmwareCtx *pCtx ,
                                        struct HpmfwupgUpgradeCtx *pFwupgCtx ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 3116
  rc = (int )HPMFWUPG_SUCCESS___0;
#line 3120
  pCtx->req.picmgId = (unsigned char)0;
#line 3122
  memset((void *)(& req), 0, sizeof(req));
#line 3123
  req.msg.netfn = (uint8_t )44;
#line 3124
  req.msg.cmd = (uint8_t )53;
#line 3125
  req.msg.data = (unsigned char *)(& pCtx->req);
  }
#line 3126
  if (! pCtx->req.rollback_override) {
#line 3126
    tmp = 1;
  } else {
#line 3126
    tmp = 0;
  }
  {
#line 3126
  req.msg.data_len = (uint16_t )(sizeof(struct HpmfwupgActivateFirmwareReq ) - (unsigned long )tmp);
#line 3129
  rsp = HpmfwupgSendCmd___0(intf, req, pFwupgCtx);
  }
#line 3131
  if (rsp) {
#line 3134
    if ((int )rsp->ccode == 128) {
      {
#line 3136
      printf((char const   */* __restrict  */)"Waiting firmware activation...");
#line 3137
      fflush(stdout);
#line 3139
      rc = HpmfwupgWaitLongDurationCmd___0(intf, pFwupgCtx);
      }
#line 3141
      if (rc == (int )HPMFWUPG_SUCCESS___0) {
        {
#line 3143
        lprintf(5, "OK");
        }
      } else {
        {
#line 3147
        lprintf(5, "Failed");
        }
      }
    } else
#line 3150
    if ((int )rsp->ccode != 0) {
      {
#line 3152
      lprintf(5, "Error activating firmware");
#line 3153
      tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3153
      lprintf(5, "compcode=0x%x: %s", (int )rsp->ccode, tmp___0);
#line 3156
      rc = (int )HPMFWUPG_ERROR___0;
      }
    }
  } else {
    {
#line 3161
    lprintf(5, "Error activating firmware\n");
#line 3162
    rc = (int )HPMFWUPG_ERROR___0;
    }
  }
#line 3165
  return (rc);
}
}
#line 3168 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgGetUpgradeStatus___0(struct ipmi_intf *intf , struct HpmfwupgGetUpgradeStatusCtx *pCtx ,
                                        struct HpmfwupgUpgradeCtx *pFwupgCtx , int silent ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 3173
  rc = (int )HPMFWUPG_SUCCESS___0;
#line 3177
  pCtx->req.picmgId = (unsigned char)0;
#line 3179
  memset((void *)(& req), 0, sizeof(req));
#line 3180
  req.msg.netfn = (uint8_t )44;
#line 3181
  req.msg.cmd = (uint8_t )52;
#line 3182
  req.msg.data = (unsigned char *)(& pCtx->req);
#line 3183
  req.msg.data_len = (uint16_t )sizeof(struct HpmfwupgGetUpgradeStatusReq );
#line 3185
  rsp = HpmfwupgSendCmd___0(intf, req, pFwupgCtx);
  }
#line 3186
  if (! rsp) {
    {
#line 3187
    lprintf(5, "Error getting upgrade status. Failed to get response.");
    }
#line 3189
    return ((int )HPMFWUPG_ERROR___0);
  }
#line 3192
  if ((int )rsp->ccode == 0) {
    {
#line 3193
    memcpy((void */* __restrict  */)(& pCtx->resp), (void const   */* __restrict  */)(rsp->data),
           sizeof(struct HpmfwupgGetUpgradeStatusResp ));
    }
#line 3195
    if (! silent) {
      {
#line 3197
      lprintf(5, "Upgrade status:");
#line 3198
      lprintf(5, " Command in progress:          %x", (int )pCtx->resp.cmdInProcess);
#line 3200
      lprintf(5, " Last command completion code: %x", (int )pCtx->resp.lastCmdCompCode);
      }
    }
  } else {
#line 3203
    if ((int )rsp->ccode == 131) {
#line 3203
      goto _L;
    } else
#line 3203
    if ((int )rsp->ccode == 130) {
#line 3203
      goto _L;
    } else
#line 3203
    if ((int )rsp->ccode == 128) {
      _L: /* CIL Label */ 
#line 3203
      tmp___2 = errorCount___1;
#line 3203
      errorCount___1 ++;
#line 3203
      if (tmp___2 < 3) {
#line 3203
        tmp___1 = 1;
      } else {
#line 3203
        tmp___1 = 0;
      }
    } else {
#line 3203
      tmp___1 = 0;
    }
#line 3203
    if (tmp___1) {
#line 3211
      if (! silent) {
        {
#line 3213
        lprintf(7, "HPM: Retryable error detected");
        }
      }
#line 3215
      pCtx->resp.lastCmdCompCode = (unsigned char)128;
    } else {
      {
#line 3217
      lprintf(5, "Error getting upgrade status");
#line 3218
      tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3218
      lprintf(5, "compcode=0x%x: %s", (int )rsp->ccode, tmp);
      }
#line 3221
      return ((int )HPMFWUPG_ERROR___0);
    }
  }
#line 3224
  return ((int )HPMFWUPG_SUCCESS___0);
}
}
#line 3227 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgManualFirmwareRollback___0(struct ipmi_intf *intf , struct HpmfwupgManualFirmwareRollbackCtx *pCtx ,
                                              struct HpmfwupgUpgradeCtx *pFwupgCtx ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct HpmfwupgQueryRollbackStatusCtx resCmd ;
  char const   *tmp ;

  {
  {
#line 3230
  rc = (int )HPMFWUPG_SUCCESS___0;
#line 3234
  pCtx->req.picmgId = (unsigned char)0;
#line 3236
  memset((void *)(& req), 0, sizeof(req));
#line 3237
  req.msg.netfn = (uint8_t )44;
#line 3238
  req.msg.cmd = (uint8_t )56;
#line 3239
  req.msg.data = (unsigned char *)(& pCtx->req);
#line 3240
  req.msg.data_len = (uint16_t )sizeof(struct HpmfwupgManualFirmwareRollbackReq );
#line 3242
  rsp = HpmfwupgSendCmd___0(intf, req, pFwupgCtx);
  }
#line 3244
  if (rsp) {
#line 3247
    if ((int )rsp->ccode == 128) {
      {
#line 3250
      printf((char const   */* __restrict  */)"Waiting firmware rollback...");
#line 3251
      fflush(stdout);
#line 3252
      rc = HpmfwupgQueryRollbackStatus___0(intf, & resCmd, pFwupgCtx);
      }
    } else
#line 3254
    if ((int )rsp->ccode != 0) {
      {
#line 3256
      lprintf(5, "Error sending manual rollback");
#line 3257
      tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3257
      lprintf(5, "compcode=0x%x: %s", (int )rsp->ccode, tmp);
#line 3260
      rc = (int )HPMFWUPG_ERROR___0;
      }
    }
  } else {
    {
#line 3265
    lprintf(5, "Error sending manual rollback\n");
#line 3266
    rc = (int )HPMFWUPG_ERROR___0;
    }
  }
#line 3268
  return (rc);
}
}
#line 3271 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgQueryRollbackStatus___0(struct ipmi_intf *intf , struct HpmfwupgQueryRollbackStatusCtx *pCtx ,
                                           struct HpmfwupgUpgradeCtx *pFwupgCtx ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned int rollbackTimeout ;
  unsigned int timeoutSec1 ;
  unsigned int timeoutSec2 ;
  struct HpmfwupgGetTargetUpgCapabilitiesCtx targetCapCmd ;
  time_t tmp ;
  time_t tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  time_t tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 3274
  rc = (int )HPMFWUPG_SUCCESS___0;
#line 3277
  rollbackTimeout = 0U;
#line 3280
  pCtx->req.picmgId = (unsigned char)0;
#line 3282
  memset((void *)(& req), 0, sizeof(req));
#line 3283
  req.msg.netfn = (uint8_t )44;
#line 3284
  req.msg.cmd = (uint8_t )55;
#line 3285
  req.msg.data = (unsigned char *)(& pCtx->req);
#line 3286
  req.msg.data_len = (uint16_t )sizeof(struct HpmfwupgQueryRollbackStatusReq );
  }
#line 3291
  if ((unsigned long )pFwupgCtx != (unsigned long )((void *)0)) {
#line 3293
    rollbackTimeout = (unsigned int )((int )pFwupgCtx->targetCap.rollbackTimeout * 5);
  } else {
    {
#line 3298
    verbose --;
#line 3299
    rc = HpmfwupgGetTargetUpgCapabilities___0(intf, & targetCapCmd);
#line 3300
    verbose ++;
    }
#line 3301
    if (rc == (int )HPMFWUPG_SUCCESS___0) {
#line 3303
      rollbackTimeout = (unsigned int )((int )targetCapCmd.resp.rollbackTimeout * 5);
    } else {
#line 3307
      rollbackTimeout = 60U;
    }
  }
  {
#line 3312
  tmp = time((time_t *)((void *)0));
#line 3312
  timeoutSec1 = (unsigned int )tmp;
#line 3313
  tmp___0 = time((time_t *)((void *)0));
#line 3313
  timeoutSec2 = (unsigned int )tmp___0;
  }
  {
#line 3314
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3317
    usleep(100000);
#line 3318
    rsp = HpmfwupgSendCmd___0(intf, req, pFwupgCtx);
    }
#line 3324
    if (rsp) {
#line 3326
      if ((int )rsp->ccode == 131) {
#line 3326
        goto _L;
      } else
#line 3326
      if ((int )rsp->ccode == 130) {
#line 3326
        goto _L;
      } else
#line 3326
      if ((int )rsp->ccode == 128) {
        _L: /* CIL Label */ 
#line 3326
        tmp___3 = errorCount___1;
#line 3326
        errorCount___1 ++;
#line 3326
        if (tmp___3 < 3) {
#line 3326
          tmp___2 = 1;
        } else {
#line 3326
          tmp___2 = 0;
        }
      } else {
#line 3326
        tmp___2 = 0;
      }
#line 3326
      if (tmp___2) {
        {
#line 3328
        lprintf(7, "HPM: [PATCH]Retryable error detected");
#line 3329
        rsp->ccode = (uint8_t )128;
        }
      }
    }
    {
#line 3332
    tmp___4 = time((time_t *)((void *)0));
#line 3332
    timeoutSec2 = (unsigned int )tmp___4;
    }
#line 3314
    if (rsp) {
#line 3314
      if ((int )rsp->ccode == 128) {
#line 3314
        goto _L___0;
      } else
#line 3314
      if ((int )rsp->ccode == 195) {
        _L___0: /* CIL Label */ 
#line 3314
        if (! (timeoutSec2 - timeoutSec1 < rollbackTimeout)) {
#line 3314
          goto while_break;
        }
      } else {
#line 3314
        goto while_break;
      }
    } else {
#line 3314
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3339
  if (rsp) {
#line 3341
    if ((int )rsp->ccode == 0) {
      {
#line 3343
      memcpy((void */* __restrict  */)(& pCtx->resp), (void const   */* __restrict  */)(rsp->data),
             sizeof(struct HpmfwupgQueryRollbackStatusResp ));
      }
#line 3344
      if ((int )pCtx->resp.rollbackComp.ComponentBits.byte != 0) {
        {
#line 3347
        lprintf(5, "Rollback occured on component mask: 0x%02x", (int )pCtx->resp.rollbackComp.ComponentBits.byte);
        }
      } else {
        {
#line 3352
        lprintf(5, "No Firmware rollback occured");
        }
      }
    } else
#line 3355
    if ((int )rsp->ccode == 129) {
      {
#line 3357
      lprintf(5, "Rollback failed on component mask: 0x%02x", (int )pCtx->resp.rollbackComp.ComponentBits.byte);
#line 3359
      rc = (int )HPMFWUPG_ERROR___0;
      }
    } else {
      {
#line 3363
      lprintf(5, "Error getting rollback status");
#line 3364
      tmp___5 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3364
      lprintf(5, "compcode=0x%x: %s", (int )rsp->ccode, tmp___5);
#line 3367
      rc = (int )HPMFWUPG_ERROR___0;
      }
    }
  } else {
    {
#line 3372
    lprintf(5, "Error getting upgrade status\n");
#line 3373
    rc = (int )HPMFWUPG_ERROR___0;
    }
  }
#line 3376
  return (rc);
}
}
#line 3379 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgQuerySelftestResult___0(struct ipmi_intf *intf , struct HpmfwupgQuerySelftestResultCtx *pCtx ,
                                           struct HpmfwupgUpgradeCtx *pFwupgCtx ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char selfTestTimeout ;
  unsigned int timeoutSec1 ;
  unsigned int timeoutSec2 ;
  struct HpmfwupgImageHeader *pImageHeader ;
  time_t tmp ;
  time_t tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  time_t tmp___4 ;
  char const   *tmp___5 ;

  {
#line 3382
  rc = (int )HPMFWUPG_SUCCESS___0;
#line 3385
  selfTestTimeout = (unsigned char)0;
#line 3388
  pCtx->req.picmgId = (unsigned char)0;
#line 3393
  if ((unsigned long )pFwupgCtx != (unsigned long )((void *)0)) {
#line 3396
    pImageHeader = (struct HpmfwupgImageHeader *)pFwupgCtx->pImageData;
#line 3398
    selfTestTimeout = pImageHeader->selfTestTimeout;
  } else {
#line 3402
    selfTestTimeout = (unsigned char)60;
  }
  {
#line 3405
  memset((void *)(& req), 0, sizeof(req));
#line 3406
  req.msg.netfn = (uint8_t )44;
#line 3407
  req.msg.cmd = (uint8_t )54;
#line 3408
  req.msg.data = (unsigned char *)(& pCtx->req);
#line 3409
  req.msg.data_len = (uint16_t )sizeof(struct HpmfwupgQuerySelftestResultReq );
#line 3413
  tmp = time((time_t *)((void *)0));
#line 3413
  timeoutSec1 = (unsigned int )tmp;
#line 3414
  tmp___0 = time((time_t *)((void *)0));
#line 3414
  timeoutSec2 = (unsigned int )tmp___0;
  }
  {
#line 3415
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3418
    usleep(100000);
#line 3419
    rsp = HpmfwupgSendCmd___0(intf, req, pFwupgCtx);
    }
#line 3425
    if (rsp) {
#line 3427
      if ((int )rsp->ccode == 131) {
#line 3427
        goto _L;
      } else
#line 3427
      if ((int )rsp->ccode == 130) {
#line 3427
        goto _L;
      } else
#line 3427
      if ((int )rsp->ccode == 128) {
        _L: /* CIL Label */ 
#line 3427
        tmp___3 = errorCount___1;
#line 3427
        errorCount___1 ++;
#line 3427
        if (tmp___3 < 3) {
#line 3427
          tmp___2 = 1;
        } else {
#line 3427
          tmp___2 = 0;
        }
      } else {
#line 3427
        tmp___2 = 0;
      }
#line 3427
      if (tmp___2) {
        {
#line 3429
        lprintf(7, "HPM: [PATCH]Retryable error detected");
#line 3430
        rsp->ccode = (uint8_t )128;
        }
      }
    }
    {
#line 3433
    tmp___4 = time((time_t *)((void *)0));
#line 3433
    timeoutSec2 = (unsigned int )tmp___4;
    }
#line 3415
    if (rsp) {
#line 3415
      if ((int )rsp->ccode == 128) {
#line 3415
        if (! (timeoutSec2 - timeoutSec1 < (unsigned int )selfTestTimeout)) {
#line 3415
          goto while_break;
        }
      } else {
#line 3415
        goto while_break;
      }
    } else {
#line 3415
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3439
  if (rsp) {
#line 3441
    if ((int )rsp->ccode == 0) {
      {
#line 3443
      memcpy((void */* __restrict  */)(& pCtx->resp), (void const   */* __restrict  */)(rsp->data),
             sizeof(struct HpmfwupgQuerySelftestResultResp ));
      }
#line 3444
      if (verbose) {
        {
#line 3446
        lprintf(5, "Self test results:");
#line 3447
        lprintf(5, "Result1 = %x", (int )pCtx->resp.result1);
#line 3448
        lprintf(5, "Result2 = %x", (int )pCtx->resp.result2);
        }
      }
    } else {
      {
#line 3453
      lprintf(5, "Error getting self test results");
#line 3454
      tmp___5 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3454
      lprintf(5, "compcode=0x%x: %s", (int )rsp->ccode, tmp___5);
#line 3457
      rc = (int )HPMFWUPG_ERROR___0;
      }
    }
  } else {
    {
#line 3462
    lprintf(5, "Error getting upgrade status\n");
#line 3463
    rc = (int )HPMFWUPG_ERROR___0;
    }
  }
#line 3466
  return (rc);
}
}
#line 3501 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static unsigned char isValidSize___0  =    (unsigned char)0;
#line 3510 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int errorCount___2  =    0;
#line 3511 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static struct ipmi_rs fakeRsp___0  ;
#line 3469 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static struct ipmi_rs *HpmfwupgSendCmd___0(struct ipmi_intf *intf , struct ipmi_rq req ,
                                           struct HpmfwupgUpgradeCtx *pFwupgCtx ) 
{ 
  struct ipmi_rs *rsp ;
  unsigned int inaccessTimeout ;
  unsigned int inaccessTimeoutCounter ;
  unsigned int upgradeTimeout ;
  unsigned int upgradeTimeoutCounter ;
  unsigned int timeoutSec1 ;
  unsigned int timeoutSec2 ;
  unsigned char retry ;
  time_t tmp ;
  time_t tmp___0 ;
  time_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  time_t tmp___4 ;
  time_t tmp___5 ;
  time_t tmp___6 ;
  time_t tmp___7 ;

  {
#line 3473
  inaccessTimeout = 0U;
#line 3473
  inaccessTimeoutCounter = 0U;
#line 3474
  upgradeTimeout = 0U;
#line 3474
  upgradeTimeoutCounter = 0U;
#line 3476
  retry = (unsigned char)0;
#line 3481
  if ((unsigned long )pFwupgCtx != (unsigned long )((void *)0)) {
#line 3483
    inaccessTimeout = (unsigned int )((int )pFwupgCtx->targetCap.inaccessTimeout * 5);
#line 3484
    upgradeTimeout = (unsigned int )((int )pFwupgCtx->targetCap.upgradeTimeout * 5);
  } else {
#line 3493
    inaccessTimeout = 60U;
#line 3494
    upgradeTimeout = 60U;
  }
  {
#line 3497
  tmp = time((time_t *)((void *)0));
#line 3497
  timeoutSec1 = (unsigned int )tmp;
  }
  {
#line 3499
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3502
    rsp = (*(intf->sendrecv))(intf, & req);
    }
#line 3504
    if ((unsigned long )rsp == (unsigned long )((void *)0)) {
      {
#line 3508
      tmp___3 = strstr((char const   *)(intf->name), "lan");
      }
#line 3508
      if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
        {
#line 3513
        lprintf(7, "HPM: no response available");
#line 3514
        lprintf(7, "HPM: the command may be rejected for security reasons");
        }
#line 3517
        if ((int )req.msg.netfn == 44) {
#line 3517
          if ((int )req.msg.cmd == 50) {
#line 3517
            if (errorCount___2 < 6) {
#line 3517
              if (! isValidSize___0) {
                {
#line 3528
                lprintf(7, "HPM: upload firmware block API called");
#line 3529
                lprintf(7, "HPM: returning length error to force resize");
#line 3531
                fakeRsp___0.ccode = (uint8_t )199;
#line 3532
                rsp = & fakeRsp___0;
#line 3533
                errorCount___2 ++;
                }
              } else {
#line 3517
                goto _L___3;
              }
            } else {
#line 3517
              goto _L___3;
            }
          } else {
#line 3517
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 3535
        if ((int )req.msg.netfn == 44) {
#line 3535
          if ((int )req.msg.cmd == 53) {
            {
#line 3548
            lprintf(7, "HPM: activate/rollback firmware API called");
#line 3549
            lprintf(7, "HPM: returning in progress to handle IOL session lost");
#line 3551
            fakeRsp___0.ccode = (uint8_t )128;
#line 3552
            rsp = & fakeRsp___0;
            }
          } else
#line 3535
          if ((int )req.msg.cmd == 56) {
            {
#line 3548
            lprintf(7, "HPM: activate/rollback firmware API called");
#line 3549
            lprintf(7, "HPM: returning in progress to handle IOL session lost");
#line 3551
            fakeRsp___0.ccode = (uint8_t )128;
#line 3552
            rsp = & fakeRsp___0;
            }
          } else {
#line 3535
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 3554
        if ((int )req.msg.netfn == 44) {
#line 3554
          if ((int )req.msg.cmd == 55) {
#line 3554
            goto _L;
          } else
#line 3554
          if ((int )req.msg.cmd == 52) {
            _L: /* CIL Label */ 
            {
#line 3569
            lprintf(7, "HPM: upg/rollback status firmware API called");
#line 3570
            lprintf(7, "HPM: try to re-open IOL session");
#line 3574
            intf->opened = 0;
#line 3575
            (intf->session)->authtype = (uint8_t )0;
#line 3576
            (intf->session)->session_id = (uint32_t )0;
#line 3577
            (intf->session)->in_seq = (uint32_t )0;
#line 3578
            (intf->session)->out_seq = (uint32_t )0;
#line 3579
            (intf->session)->active = 0;
#line 3580
            (intf->session)->retry = 10;
            }
            {
#line 3582
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 3582
              tmp___2 = (*(intf->open))(intf);
              }
#line 3582
              if (tmp___2 == (int )HPMFWUPG_ERROR___0) {
#line 3582
                if (! (inaccessTimeoutCounter < inaccessTimeout)) {
#line 3582
                  goto while_break___0;
                }
              } else {
#line 3582
                goto while_break___0;
              }
              {
#line 3589
              tmp___0 = time((time_t *)((void *)0));
#line 3589
              inaccessTimeoutCounter = (unsigned int )((time_t )inaccessTimeoutCounter + (tmp___0 - (time_t )timeoutSec1));
#line 3590
              tmp___1 = time((time_t *)((void *)0));
#line 3590
              timeoutSec1 = (unsigned int )tmp___1;
              }
            }
            while_break___0: /* CIL Label */ ;
            }
#line 3593
            fakeRsp___0.ccode = (uint8_t )195;
#line 3594
            rsp = & fakeRsp___0;
          }
        }
      }
    }
#line 3601
    if ((unsigned long )rsp == (unsigned long )((void *)0)) {
#line 3601
      goto _L___4;
    } else
#line 3601
    if ((int )rsp->ccode == 255) {
#line 3601
      goto _L___4;
    } else
#line 3601
    if ((int )rsp->ccode == 195) {
#line 3601
      goto _L___4;
    } else
#line 3601
    if ((int )rsp->ccode == 211) {
      _L___4: /* CIL Label */ 
#line 3603
      if (inaccessTimeoutCounter < inaccessTimeout) {
        {
#line 3605
        tmp___4 = time((time_t *)((void *)0));
#line 3605
        timeoutSec2 = (unsigned int )tmp___4;
        }
#line 3606
        if (timeoutSec2 > timeoutSec1) {
          {
#line 3608
          inaccessTimeoutCounter += timeoutSec2 - timeoutSec1;
#line 3609
          tmp___5 = time((time_t *)((void *)0));
#line 3609
          timeoutSec1 = (unsigned int )tmp___5;
          }
        }
        {
#line 3611
        usleep(100000);
#line 3612
        retry = (unsigned char)1;
        }
      } else {
#line 3616
        retry = (unsigned char)0;
      }
    } else
#line 3620
    if ((int )rsp->ccode == 192) {
#line 3622
      if (upgradeTimeoutCounter < upgradeTimeout) {
        {
#line 3624
        tmp___6 = time((time_t *)((void *)0));
#line 3624
        timeoutSec2 = (unsigned int )tmp___6;
        }
#line 3625
        if (timeoutSec2 > timeoutSec1) {
          {
#line 3627
          tmp___7 = time((time_t *)((void *)0));
#line 3627
          timeoutSec1 = (unsigned int )tmp___7;
#line 3628
          upgradeTimeoutCounter += timeoutSec2 - timeoutSec1;
          }
        }
        {
#line 3630
        usleep(100000);
#line 3631
        retry = (unsigned char)1;
        }
      } else {
#line 3635
        retry = (unsigned char)0;
      }
    } else {
#line 3641
      if ((int )rsp->ccode == 0) {
#line 3643
        errorCount___1 = 0;
      }
#line 3646
      retry = (unsigned char)0;
#line 3648
      if ((int )req.msg.netfn == 44) {
#line 3648
        if ((int )req.msg.cmd == 50) {
#line 3648
          if (! isValidSize___0) {
            {
#line 3657
            lprintf(6, "Buffer length is now considered valid");
#line 3659
            isValidSize___0 = (unsigned char)1;
            }
          }
        }
      }
    }
#line 3499
    if (! retry) {
#line 3499
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3663
  return (rsp);
}
}
#line 3666 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static int HpmfwupgWaitLongDurationCmd___0(struct ipmi_intf *intf , struct HpmfwupgUpgradeCtx *pFwupgCtx ) 
{ 
  int rc ;
  unsigned int upgradeTimeout ;
  unsigned int timeoutSec1 ;
  unsigned int timeoutSec2 ;
  struct HpmfwupgGetUpgradeStatusCtx upgStatusCmd ;
  struct HpmfwupgGetTargetUpgCapabilitiesCtx targetCapCmd ;
  int tmp ;
  time_t tmp___0 ;
  time_t tmp___1 ;
  time_t tmp___2 ;

  {
#line 3668
  rc = (int )HPMFWUPG_SUCCESS___0;
#line 3669
  upgradeTimeout = 0U;
#line 3676
  if ((unsigned long )pFwupgCtx != (unsigned long )((void *)0)) {
#line 3678
    upgradeTimeout = (unsigned int )((int )pFwupgCtx->targetCap.upgradeTimeout * 5);
#line 3679
    if (verbose) {
      {
#line 3680
      printf((char const   */* __restrict  */)"Use File Upgrade Capabilities: %i seconds\n",
             upgradeTimeout);
      }
    }
  } else {
    {
#line 3687
    tmp = HpmfwupgGetTargetUpgCapabilities___0(intf, & targetCapCmd);
    }
#line 3687
    if (tmp != (int )HPMFWUPG_SUCCESS___0) {
#line 3689
      upgradeTimeout = 60U;
#line 3691
      if (verbose) {
        {
#line 3692
        printf((char const   */* __restrict  */)"Use default timeout: %i seconds\n",
               upgradeTimeout);
        }
      }
    } else {
#line 3696
      upgradeTimeout = (unsigned int )((int )targetCapCmd.resp.upgradeTimeout * 5);
#line 3697
      if (verbose) {
        {
#line 3698
        printf((char const   */* __restrict  */)"Use Command Upgrade Capabilities Timeout: %i seconds\n",
               upgradeTimeout);
        }
      }
    }
  }
#line 3702
  if (rc == (int )HPMFWUPG_SUCCESS___0) {
    {
#line 3705
    tmp___0 = time((time_t *)((void *)0));
#line 3705
    timeoutSec1 = (unsigned int )tmp___0;
#line 3706
    tmp___1 = time((time_t *)((void *)0));
#line 3706
    timeoutSec2 = (unsigned int )tmp___1;
#line 3707
    rc = HpmfwupgGetUpgradeStatus___0(intf, & upgStatusCmd, pFwupgCtx, 1);
    }
  }
  {
#line 3710
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3710
    if ((int )upgStatusCmd.resp.lastCmdCompCode != 0) {
#line 3710
      if (timeoutSec2 - timeoutSec1 < upgradeTimeout) {
#line 3710
        if (! (rc == (int )HPMFWUPG_SUCCESS___0)) {
#line 3710
          goto while_break;
        }
      } else {
#line 3710
        goto while_break;
      }
    } else {
#line 3710
      goto while_break;
    }
    {
#line 3718
    usleep(1000000);
#line 3719
    tmp___2 = time((time_t *)((void *)0));
#line 3719
    timeoutSec2 = (unsigned int )tmp___2;
#line 3720
    rc = HpmfwupgGetUpgradeStatus___0(intf, & upgStatusCmd, pFwupgCtx, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3724
  if ((int )upgStatusCmd.resp.lastCmdCompCode != 0) {
#line 3726
    if (verbose) {
      {
#line 3728
      lprintf(5, "Error waiting for command %x, compcode = %x", (int )upgStatusCmd.resp.cmdInProcess,
              (int )upgStatusCmd.resp.lastCmdCompCode);
      }
    }
#line 3732
    rc = (int )HPMFWUPG_ERROR___0;
  }
#line 3735
  return (rc);
}
}
#line 3738 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static unsigned char HpmfwupgCalculateChecksum___0(unsigned char *pData , unsigned int length ) 
{ 
  unsigned char checksum ;
  int dataIdx ;

  {
#line 3740
  checksum = (unsigned char)0;
#line 3741
  dataIdx = 0;
#line 3743
  dataIdx = 0;
  {
#line 3743
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3743
    if (! ((unsigned int )dataIdx < length)) {
#line 3743
      goto while_break;
    }
#line 3745
    checksum = (unsigned char )((int )checksum + (int )*(pData + dataIdx));
#line 3743
    dataIdx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3747
  return (checksum);
}
}
#line 3750 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_hpmfwupg.c"
static void HpmfwupgPrintUsage___0(void) 
{ 


  {
  {
#line 3752
  lprintf(5, "help                    - This help menu.");
#line 3753
  lprintf(5, "");
#line 3754
  lprintf(5, "check                   - Check the target information.");
#line 3755
  lprintf(5, "check <file>            - If the user is unsure of what update is going to be ");
#line 3756
  lprintf(5, "                          This will display the existing target version and");
#line 3757
  lprintf(5, "                          image version on the screen");
#line 3758
  lprintf(5, "");
#line 3759
  lprintf(5, "upgrade <file>          - Copies all the components from a valid HPM.1");
#line 3760
  lprintf(5, "                          image <file> to the target.");
#line 3761
  lprintf(5, "                          This compares the versions from both the target");
#line 3762
  lprintf(5, "                          and image and will only perform the copy");
#line 3763
  lprintf(5, "                          if the versions differ.");
#line 3764
  lprintf(5, "upgrade <file> activate - Copy and activate the firmware using a valid HPM.1");
#line 3765
  lprintf(5, "                          image <file>.");
#line 3766
  lprintf(5, "                          This compares the versions from both the target");
#line 3767
  lprintf(5, "                          and image and will only perform the copy and");
#line 3768
  lprintf(5, "                          activation if the versions differ.");
#line 3769
  lprintf(5, "upgrade <file> force    - Copies all the components present in <file>");
#line 3770
  lprintf(5, "                          to the target board without checking the versions.");
#line 3771
  lprintf(5, "                          Make sure to check the versions first using the");
#line 3772
  lprintf(5, "                          \"check <file>\" command.");
#line 3773
  lprintf(5, "upgrade <file> component x - Copy only component <x> from the given <file>");
#line 3774
  lprintf(5, "                          without checking if the versions differ.");
#line 3775
  lprintf(5, "                          For example:");
#line 3776
  lprintf(5, "                          component 0 = Bootloader");
#line 3777
  lprintf(5, "                          component 1 = Firmware");
#line 3778
  lprintf(5, "                          Make sure to check the versions first using the");
#line 3779
  lprintf(5, "                          \"check <file>\" command.");
#line 3780
  lprintf(5, "upgstatus               - Returns the status of the last long duration command.");
#line 3781
  lprintf(5, "");
#line 3782
  lprintf(5, "activate                - Activate the newly uploaded firmware.");
#line 3783
  lprintf(5, "activate norollback     - Activate the newly uploaded firmware but inform");
#line 3784
  lprintf(5, "                          the target to not automatically rollback if ");
#line 3785
  lprintf(5, "                          the upgrade fails.");
#line 3786
  lprintf(5, "");
#line 3787
  lprintf(5, "targetcap               - Get the target upgrade capabilities.");
#line 3788
  lprintf(5, "");
#line 3789
  lprintf(5, "compprop <id> <prop>    - Get specified component properties from the target.");
#line 3790
  lprintf(5, "                          Valid component <id>: 0-7 ");
#line 3791
  lprintf(5, "                          Properties <prop> can be one of the following: ");
#line 3792
  lprintf(5, "                          0- General properties");
#line 3793
  lprintf(5, "                          1- Current firmware version");
#line 3794
  lprintf(5, "                          2- Description string");
#line 3795
  lprintf(5, "                          3- Rollback firmware version");
#line 3796
  lprintf(5, "                          4- Deferred firmware version");
#line 3797
  lprintf(5, "");
#line 3798
  lprintf(5, "abort                   - Abort the on-going firmware upgrade.");
#line 3799
  lprintf(5, "");
#line 3800
  lprintf(5, "rollback                - Performs a manual rollback on the IPM Controller.");
#line 3801
  lprintf(5, "                          firmware");
#line 3802
  lprintf(5, "rollbackstatus          - Query the rollback status.");
#line 3803
  lprintf(5, "");
#line 3804
  lprintf(5, "selftestresult          - Query the self test results.\n");
  }
#line 3805
  return;
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static struct termios _saved_tio___0  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static int _in_raw_mode___0  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static int ipmi_get_isol_info___0(struct ipmi_intf *intf , struct isol_config_parameters *params ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char data[6] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 71
  memset((void *)(& req), 0, sizeof(req));
#line 72
  req.msg.netfn = (uint8_t )52;
#line 73
  req.msg.cmd = (uint8_t )4;
#line 74
  req.msg.data = data;
#line 75
  req.msg.data_len = (uint16_t )4;
#line 79
  memset((void *)(data), 0, (size_t )6);
#line 80
  data[0] = (unsigned char)0;
#line 81
  data[1] = (unsigned char)1;
#line 82
  data[2] = (unsigned char)0;
#line 83
  data[3] = (unsigned char)0;
#line 85
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 86
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 87
    lprintf(3, "Error in Get ISOL Config Command");
    }
#line 88
    return (-1);
  }
#line 90
  if ((int )rsp->ccode == 193) {
    {
#line 91
    lprintf(3, "IPMI v1.5 Serial Over Lan (ISOL) not supported!");
    }
#line 92
    return (-1);
  }
#line 94
  if ((int )rsp->ccode > 0) {
    {
#line 95
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 95
    lprintf(3, "Error in Get ISOL Config Command: %s", tmp);
    }
#line 97
    return (-1);
  }
  {
#line 99
  params->enabled = rsp->data[1];
#line 103
  memset((void *)(data), 0, (size_t )6);
#line 104
  data[0] = (unsigned char)0;
#line 105
  data[1] = (unsigned char)2;
#line 106
  data[2] = (unsigned char)0;
#line 107
  data[3] = (unsigned char)0;
#line 109
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 110
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 111
    lprintf(3, "Error in Get ISOL Config Command");
    }
#line 112
    return (-1);
  }
#line 114
  if ((int )rsp->ccode > 0) {
    {
#line 115
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 115
    lprintf(3, "Error in Get ISOL Config Command: %s", tmp___0);
    }
#line 117
    return (-1);
  }
  {
#line 119
  params->privilege_level = rsp->data[1];
#line 123
  memset((void *)(data), 0, (size_t )6);
#line 124
  data[0] = (unsigned char)0;
#line 125
  data[1] = (unsigned char)5;
#line 126
  data[2] = (unsigned char)0;
#line 127
  data[3] = (unsigned char)0;
#line 129
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 130
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 131
    lprintf(3, "Error in Get ISOL Config Command");
    }
#line 132
    return (-1);
  }
#line 134
  if ((int )rsp->ccode > 0) {
    {
#line 135
    tmp___1 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 135
    lprintf(3, "Error in Get ISOL Config Command: %s", tmp___1);
    }
#line 137
    return (-1);
  }
#line 139
  params->bit_rate = rsp->data[1];
#line 141
  return (0);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static int ipmi_print_isol_info___0(struct ipmi_intf *intf ) 
{ 
  struct isol_config_parameters params ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 146
  params.enabled = (uint8_t )0;
#line 146
  params.privilege_level = (unsigned char)0;
#line 146
  params.bit_rate = (unsigned char)0;
#line 147
  tmp = ipmi_get_isol_info___0(intf, & params);
  }
#line 147
  if (tmp) {
#line 148
    return (-1);
  }
#line 150
  if (csv_output) {
#line 152
    if ((int )params.enabled & 1) {
#line 152
      tmp___0 = "true";
    } else {
#line 152
      tmp___0 = "false";
    }
    {
#line 152
    printf((char const   */* __restrict  */)"%s,", tmp___0);
#line 153
    tmp___1 = val2str((uint16_t )((int )params.privilege_level & 15), ipmi_privlvl_vals);
#line 153
    printf((char const   */* __restrict  */)"%s,", tmp___1);
#line 155
    tmp___2 = val2str((uint16_t )((int )params.bit_rate & 15), ipmi_bit_rate_vals);
#line 155
    printf((char const   */* __restrict  */)"%s,", tmp___2);
    }
  } else {
#line 160
    if ((int )params.enabled & 1) {
#line 160
      tmp___3 = "true";
    } else {
#line 160
      tmp___3 = "false";
    }
    {
#line 160
    printf((char const   */* __restrict  */)"Enabled                         : %s\n",
           tmp___3);
#line 162
    tmp___4 = val2str((uint16_t )((int )params.privilege_level & 15), ipmi_privlvl_vals);
#line 162
    printf((char const   */* __restrict  */)"Privilege Level                 : %s\n",
           tmp___4);
#line 164
    tmp___5 = val2str((uint16_t )((int )params.bit_rate & 15), ipmi_bit_rate_vals);
#line 164
    printf((char const   */* __restrict  */)"Bit Rate (kbps)                 : %s\n",
           tmp___5);
    }
  }
#line 168
  return (0);
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static int ipmi_isol_set_param___0(struct ipmi_intf *intf , char const   *param ,
                                   char const   *value ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char data[6] ;
  struct isol_config_parameters params ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;

  {
  {
#line 178
  params.enabled = (uint8_t )0;
#line 178
  params.privilege_level = (unsigned char)0;
#line 178
  params.bit_rate = (unsigned char)0;
#line 181
  tmp = ipmi_get_isol_info___0(intf, & params);
  }
#line 181
  if (tmp) {
#line 182
    return (-1);
  }
  {
#line 184
  memset((void *)(& req), 0, sizeof(req));
#line 185
  req.msg.netfn = (uint8_t )52;
#line 186
  req.msg.cmd = (uint8_t )3;
#line 187
  req.msg.data = data;
#line 188
  req.msg.data_len = (uint16_t )3;
#line 190
  memset((void *)(data), 0, (size_t )6);
#line 195
  tmp___14 = strcmp(param, "enabled");
  }
#line 195
  if (tmp___14 == 0) {
    {
#line 197
    data[1] = (unsigned char)1;
#line 198
    tmp___1 = strcmp(value, "true");
    }
#line 198
    if (tmp___1 == 0) {
#line 199
      data[2] = (unsigned char)1;
    } else {
      {
#line 200
      tmp___0 = strcmp(value, "false");
      }
#line 200
      if (tmp___0 == 0) {
#line 201
        data[2] = (unsigned char)0;
      } else {
        {
#line 203
        lprintf(3, "Invalid value %s for parameter %s", value, param);
#line 205
        lprintf(3, "Valid values are true and false");
        }
#line 206
        return (-1);
      }
    }
  } else {
    {
#line 213
    tmp___13 = strcmp(param, "privilege-level");
    }
#line 213
    if (tmp___13 == 0) {
      {
#line 215
      data[1] = (unsigned char)2;
#line 216
      tmp___5 = strcmp(value, "user");
      }
#line 216
      if (tmp___5) {
        {
#line 218
        tmp___4 = strcmp(value, "operator");
        }
#line 218
        if (tmp___4) {
          {
#line 220
          tmp___3 = strcmp(value, "admin");
          }
#line 220
          if (tmp___3) {
            {
#line 222
            tmp___2 = strcmp(value, "oem");
            }
#line 222
            if (tmp___2) {
              {
#line 226
              lprintf(3, "Invalid value %s for parameter %s", value, param);
#line 228
              lprintf(3, "Valid values are user, operator, admin, and oem");
              }
#line 229
              return (-1);
            } else {
#line 223
              data[2] = (unsigned char)5;
            }
          } else {
#line 221
            data[2] = (unsigned char)4;
          }
        } else {
#line 219
          data[2] = (unsigned char)3;
        }
      } else {
#line 217
        data[2] = (unsigned char)2;
      }
#line 232
      if ((int )params.privilege_level & 128) {
#line 232
        tmp___6 = 128;
      } else {
#line 232
        tmp___6 = 0;
      }
#line 232
      data[2] = (unsigned char )((int )data[2] | tmp___6);
    } else {
      {
#line 238
      tmp___12 = strcmp(param, "bit-rate");
      }
#line 238
      if (tmp___12 == 0) {
        {
#line 240
        data[1] = (unsigned char)5;
#line 241
        tmp___11 = strncmp(value, "9.6", (size_t )3);
        }
#line 241
        if (tmp___11 == 0) {
#line 242
          data[2] = (unsigned char)6;
        } else {
          {
#line 244
          tmp___10 = strncmp(value, "19.2", (size_t )4);
          }
#line 244
          if (tmp___10 == 0) {
#line 245
            data[2] = (unsigned char)7;
          } else {
            {
#line 247
            tmp___9 = strncmp(value, "38.4", (size_t )4);
            }
#line 247
            if (tmp___9 == 0) {
#line 248
              data[2] = (unsigned char)8;
            } else {
              {
#line 250
              tmp___8 = strncmp(value, "57.6", (size_t )4);
              }
#line 250
              if (tmp___8 == 0) {
#line 251
                data[2] = (unsigned char)9;
              } else {
                {
#line 253
                tmp___7 = strncmp(value, "115.2", (size_t )5);
                }
#line 253
                if (tmp___7 == 0) {
#line 254
                  data[2] = (unsigned char)10;
                } else {
                  {
#line 257
                  lprintf(3, "ISOL - Unsupported baud rate: %s", value);
#line 258
                  lprintf(3, "Valid values are 9.6, 19.2, 38.4, 57.6 and 115.2");
                  }
#line 259
                  return (-1);
                }
              }
            }
          }
        }
      } else {
        {
#line 264
        lprintf(3, "Error: invalid ISOL parameter %s", param);
        }
#line 265
        return (-1);
      }
    }
  }
  {
#line 273
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 274
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 275
    lprintf(3, "Error setting ISOL parameter \'%s\'", param);
    }
#line 276
    return (-1);
  }
#line 278
  if ((int )rsp->ccode > 0) {
    {
#line 279
    tmp___15 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 279
    lprintf(3, "Error setting ISOL parameter \'%s\': %s", param, tmp___15);
    }
#line 281
    return (-1);
  }
#line 284
  return (0);
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static void leave_raw_mode___0(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 290
  if (! _in_raw_mode___0) {
#line 291
    return;
  }
  {
#line 292
  tmp = fileno(stdin);
#line 292
  tmp___0 = tcsetattr(tmp, 1, (struct termios  const  *)(& _saved_tio___0));
  }
#line 292
  if (tmp___0 == -1) {
    {
#line 293
    perror("tcsetattr");
    }
  } else {
#line 295
    _in_raw_mode___0 = 0;
  }
#line 296
  return;
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static void enter_raw_mode___0(void) 
{ 
  struct termios tio ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 304
  tmp = fileno(stdin);
#line 304
  tmp___0 = tcgetattr(tmp, & tio);
  }
#line 304
  if (tmp___0 == -1) {
    {
#line 305
    perror("tcgetattr");
    }
#line 306
    return;
  }
  {
#line 308
  _saved_tio___0 = tio;
#line 309
  tio.c_iflag |= 4U;
#line 310
  tio.c_iflag &= 4294959647U;
#line 312
  tio.c_lflag &= 4294967172U;
#line 314
  tio.c_lflag &= 4294934527U;
#line 316
  tio.c_oflag &= 4294967294U;
#line 317
  tio.c_cc[6] = (cc_t )1;
#line 318
  tio.c_cc[5] = (cc_t )0;
#line 319
  tmp___1 = fileno(stdin);
#line 319
  tmp___2 = tcsetattr(tmp___1, 1, (struct termios  const  *)(& tio));
  }
#line 319
  if (tmp___2 == -1) {
    {
#line 320
    perror("tcsetattr");
    }
  } else {
#line 322
    _in_raw_mode___0 = 1;
  }
#line 323
  return;
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static void sendBreak___0(struct ipmi_intf *intf ) 
{ 
  struct ipmi_v2_payload v2_payload ;

  {
  {
#line 331
  memset((void *)(& v2_payload), 0, sizeof(v2_payload));
#line 333
  v2_payload.payload.sol_packet.character_count = (uint16_t )0;
#line 334
  v2_payload.payload.sol_packet.generate_break = (uint8_t )1;
#line 336
  (*(intf->send_sol))(intf, & v2_payload);
  }
#line 337
  return;
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static void suspendSelf___0(int bRestoreTty ) 
{ 
  __pid_t tmp ;

  {
  {
#line 350
  leave_raw_mode___0();
#line 351
  tmp = getpid();
#line 351
  kill(tmp, 20);
  }
#line 353
  if (bRestoreTty) {
    {
#line 354
    enter_raw_mode___0();
    }
  }
#line 355
  return;
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static void printiSolEscapeSequences___0(void) 
{ 


  {
  {
#line 367
  printf((char const   */* __restrict  */)"%c?\n\tSupported escape sequences:\n\t%c.  - terminate connection\n\t%c^Z - suspend ipmitool\n\t%c^X - suspend ipmitool, but don\'t restore tty on restart\n\t%cB  - send break\n\t%c?  - this message\n\t%c%c  - send the escape character by typing it twice\n\t(Note that escapes are only recognized immediately after newline.)\n",
         '~', '~', '~', '~', '~', '~', '~', '~');
  }
#line 385
  return;
}
}
#line 394 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static void output___0(struct ipmi_rs *rsp ) 
{ 
  int i ;

  {
#line 397
  if (rsp) {
#line 400
    i = 0;
    {
#line 400
    while (1) {
      while_continue: /* CIL Label */ ;
#line 400
      if (! (i < rsp->data_len)) {
#line 400
        goto while_break;
      }
      {
#line 401
      _IO_putc((int )rsp->data[i], stdout);
#line 400
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 403
    fflush(stdout);
    }
  }
#line 405
  return;
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static int ipmi_isol_deactivate___0(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t data[6] ;
  char const   *tmp ;

  {
  {
#line 418
  memset((void *)(& req), 0, sizeof(req));
#line 419
  req.msg.netfn = (uint8_t )52;
#line 420
  req.msg.cmd = (uint8_t )1;
#line 421
  req.msg.data = data;
#line 422
  req.msg.data_len = (uint16_t )5;
#line 424
  memset((void *)(data), 0, (size_t )6);
#line 425
  data[0] = (uint8_t )0;
#line 426
  data[1] = (uint8_t )0;
#line 427
  data[2] = (uint8_t )0;
#line 428
  data[3] = (uint8_t )0;
#line 429
  data[5] = (uint8_t )0;
#line 431
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 432
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 433
    lprintf(3, "Error deactivating ISOL");
    }
#line 434
    return (-1);
  }
#line 436
  if ((int )rsp->ccode > 0) {
    {
#line 437
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 437
    lprintf(3, "Error deactivating ISOL: %s", tmp);
    }
#line 439
    return (-1);
  }
#line 443
  return (0);
}
}
#line 461
static int processiSolUserInput___0(struct ipmi_intf *intf , uint8_t *input , uint16_t buffer_length ) ;
#line 461 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static int escape_pending___0  =    0;
#line 462 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static int last_was_cr___0  =    1;
#line 456 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static int processiSolUserInput___0(struct ipmi_intf *intf , uint8_t *input , uint16_t buffer_length ) 
{ 
  struct ipmi_v2_payload v2_payload ;
  int length ;
  int retval ;
  char ch ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct ipmi_rs *rsp ;

  {
  {
#line 464
  length = 0;
#line 465
  retval = 0;
#line 469
  memset((void *)(& v2_payload), 0, sizeof(v2_payload));
#line 475
  i = 0;
  }
  {
#line 475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 475
    if (! (i < (int )buffer_length)) {
#line 475
      goto while_break;
    }
#line 477
    ch = (char )*(input + i);
#line 479
    if (escape_pending___0) {
#line 480
      escape_pending___0 = 0;
      {
#line 486
      if ((int )ch == 46) {
#line 486
        goto case_46;
      }
#line 490
      if ((int )ch == 26) {
#line 490
        goto case_26;
      }
#line 495
      if ((int )ch == 24) {
#line 495
        goto case_24;
      }
#line 500
      if ((int )ch == 66) {
#line 500
        goto case_66;
      }
#line 505
      if ((int )ch == 63) {
#line 505
        goto case_63;
      }
#line 508
      goto switch_default;
      case_46: /* CIL Label */ 
      {
#line 487
      printf((char const   */* __restrict  */)"%c. [terminated ipmitool]\n", '~');
#line 488
      retval = 1;
      }
#line 489
      goto switch_break;
      case_26: /* CIL Label */ 
      {
#line 491
      printf((char const   */* __restrict  */)"%c^Z [suspend ipmitool]\n", '~');
#line 492
      suspendSelf___0(1);
      }
#line 493
      goto __Cont;
      case_24: /* CIL Label */ 
      {
#line 496
      printf((char const   */* __restrict  */)"%c^X [suspend ipmitool]\n", '~');
#line 497
      suspendSelf___0(0);
      }
#line 498
      goto __Cont;
      case_66: /* CIL Label */ 
      {
#line 501
      printf((char const   */* __restrict  */)"%cb [send break]\n", '~');
#line 502
      sendBreak___0(intf);
      }
#line 503
      goto __Cont;
      case_63: /* CIL Label */ 
      {
#line 506
      printiSolEscapeSequences___0();
      }
#line 507
      goto __Cont;
      switch_default: /* CIL Label */ 
#line 509
      if ((int )ch != 126) {
#line 510
        tmp = length;
#line 510
        length ++;
#line 510
        v2_payload.payload.sol_packet.data[tmp] = (uint8_t )'~';
      }
#line 512
      tmp___0 = length;
#line 512
      length ++;
#line 512
      v2_payload.payload.sol_packet.data[tmp___0] = (uint8_t )ch;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 518
      if (last_was_cr___0) {
#line 518
        if ((int )ch == 126) {
#line 519
          escape_pending___0 = 1;
#line 520
          goto __Cont;
        }
      }
#line 523
      tmp___1 = length;
#line 523
      length ++;
#line 523
      v2_payload.payload.sol_packet.data[tmp___1] = (uint8_t )ch;
    }
#line 530
    if ((int )ch == 13) {
#line 530
      tmp___2 = 1;
    } else
#line 530
    if ((int )ch == 10) {
#line 530
      tmp___2 = 1;
    } else {
#line 530
      tmp___2 = 0;
    }
#line 530
    last_was_cr___0 = tmp___2;
    __Cont: /* CIL Label */ 
#line 475
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 538
  if (length) {
    {
#line 542
    v2_payload.payload.sol_packet.flush_outbound = (uint8_t )1;
#line 543
    v2_payload.payload.sol_packet.character_count = (uint16_t )length;
#line 544
    rsp = (*(intf->send_sol))(intf, & v2_payload);
    }
#line 546
    if (! rsp) {
      {
#line 547
      lprintf(3, "Error sending SOL data");
#line 548
      retval = -1;
      }
    } else
#line 552
    if ((int )rsp->session.payloadtype == 1) {
#line 552
      if (rsp->payload.sol_packet.packet_sequence_number) {
        {
#line 554
        output___0(rsp);
        }
      }
    }
  }
#line 556
  return (retval);
}
}
#line 562 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static int ipmi_isol_red_pill___0(struct ipmi_intf *intf ) 
{ 
  char *buffer ;
  int numRead ;
  int bShouldExit ;
  int bBmcClosedSession ;
  fd_set read_fds ;
  struct timeval tv ;
  int retval ;
  int buffer_size ;
  int timedout ;
  void *tmp ;
  int __d0 ;
  int __d1 ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int rc ;
  int tmp___2 ;
  struct ipmi_rs *rs ;
  struct ipmi_rs *tmp___3 ;

  {
  {
#line 567
  bShouldExit = 0;
#line 568
  bBmcClosedSession = 0;
#line 572
  buffer_size = 255;
#line 573
  timedout = 0;
#line 575
  tmp = malloc((size_t )buffer_size);
#line 575
  buffer = (char *)tmp;
  }
#line 576
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 577
    lprintf(3, "ipmitool: malloc failure");
    }
#line 578
    return (-1);
  }
  {
#line 581
  enter_raw_mode___0();
  }
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;
#line 583
    if (! (! bShouldExit)) {
#line 583
      goto while_break;
    }
    {
#line 585
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 585
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& read_fds.__fds_bits[0]): "memory");
#line 585
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 586
    read_fds.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 587
    read_fds.__fds_bits[intf->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << intf->fd % (8 * (int )sizeof(__fd_mask ));
#line 590
    tv.tv_sec = (__time_t )0;
#line 591
    tv.tv_usec = (__suseconds_t )500000;
#line 593
    retval = select(intf->fd + 1, (fd_set */* __restrict  */)(& read_fds), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 595
    if (retval) {
#line 597
      if (retval == -1) {
        {
#line 600
        perror("select");
        }
#line 601
        return (-1);
      }
#line 604
      timedout = 0;
#line 609
      if ((read_fds.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] & (1L << 0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 611
        memset((void *)buffer, 0, (size_t )buffer_size);
#line 612
        tmp___0 = fileno(stdin);
#line 612
        tmp___1 = read(tmp___0, (void *)buffer, (size_t )buffer_size);
#line 612
        numRead = (int )tmp___1;
        }
#line 616
        if (numRead > 0) {
          {
#line 618
          tmp___2 = processiSolUserInput___0(intf, (uint8_t *)buffer, (uint16_t )numRead);
#line 618
          rc = tmp___2;
          }
#line 620
          if (rc) {
#line 622
            if (rc < 0) {
#line 623
              bBmcClosedSession = 1;
#line 623
              bShouldExit = bBmcClosedSession;
            } else {
#line 625
              bShouldExit = 1;
            }
          }
        } else {
#line 630
          bShouldExit = 1;
        }
      } else
#line 638
      if ((read_fds.__fds_bits[intf->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << intf->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 640
        tmp___3 = (*(intf->recv_sol))(intf);
#line 640
        rs = tmp___3;
        }
#line 641
        if (! rs) {
#line 643
          bBmcClosedSession = 1;
#line 643
          bShouldExit = bBmcClosedSession;
        } else {
          {
#line 646
          output___0(rs);
          }
        }
      } else {
        {
#line 655
        lprintf(3, "Error: Select returned with nothing to read");
#line 656
        bShouldExit = 1;
        }
      }
    } else {
#line 661
      timedout ++;
#line 661
      if (timedout == 20) {
        {
#line 663
        (*(intf->keepalive))(intf);
#line 664
        timedout = 0;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 669
  leave_raw_mode___0();
  }
#line 671
  if (bBmcClosedSession) {
    {
#line 673
    lprintf(3, "SOL session closed by BMC");
    }
  } else {
    {
#line 676
    ipmi_isol_deactivate___0(intf);
    }
  }
#line 678
  return (0);
}
}
#line 684 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static int ipmi_isol_activate___0(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t data[6] ;
  struct isol_config_parameters params ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 692
  tmp = ipmi_get_isol_info___0(intf, & params);
  }
#line 692
  if (tmp) {
#line 693
    return (-1);
  }
#line 695
  if (! ((int )params.enabled & 1)) {
    {
#line 696
    lprintf(3, "ISOL is not enabled!");
    }
#line 697
    return (-1);
  }
  {
#line 705
  (intf->session)->sol_data.sol_input_handler = & output___0;
#line 707
  memset((void *)(& req), 0, sizeof(req));
#line 708
  req.msg.netfn = (uint8_t )52;
#line 709
  req.msg.cmd = (uint8_t )1;
#line 710
  req.msg.data = data;
#line 711
  req.msg.data_len = (uint16_t )5;
#line 713
  memset((void *)(data), 0, (size_t )6);
#line 714
  data[0] = (uint8_t )1;
#line 715
  data[1] = (uint8_t )0;
#line 716
  data[2] = (uint8_t )0;
#line 717
  data[3] = (uint8_t )0;
#line 718
  data[5] = (uint8_t )0;
#line 720
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 721
  if ((unsigned long )((void *)0) != (unsigned long )rsp) {
    {
#line 723
    if ((int )rsp->ccode == 0) {
#line 723
      goto case_0;
    }
#line 733
    if ((int )rsp->ccode == 128) {
#line 733
      goto case_128;
    }
#line 736
    if ((int )rsp->ccode == 129) {
#line 736
      goto case_129;
    }
#line 739
    if ((int )rsp->ccode == 130) {
#line 739
      goto case_130;
    }
#line 742
    goto switch_default;
    case_0: /* CIL Label */ 
#line 724
    if (rsp->data_len == 4) {
#line 725
      goto switch_break;
    } else {
      {
#line 727
      lprintf(3, "Error: Unexpected data length (%d) received in ISOL activation response",
              rsp->data_len);
      }
#line 730
      return (-1);
    }
#line 732
    goto switch_break;
    case_128: /* CIL Label */ 
    {
#line 734
    lprintf(3, "Info: ISOL already active on another session");
    }
#line 735
    return (-1);
    case_129: /* CIL Label */ 
    {
#line 737
    lprintf(3, "Info: ISOL disabled");
    }
#line 738
    return (-1);
    case_130: /* CIL Label */ 
    {
#line 740
    lprintf(3, "Info: ISOL activation limit reached");
    }
#line 741
    return (-1);
    switch_default: /* CIL Label */ 
    {
#line 743
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 743
    lprintf(3, "Error activating ISOL: %s", tmp___0);
    }
#line 745
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 748
    lprintf(3, "Error: No response activating ISOL");
    }
#line 749
    return (-1);
  }
  {
#line 755
  printf((char const   */* __restrict  */)"[SOL Session operational.  Use %c? for help]\n",
         '~');
#line 764
  tmp___1 = ipmi_isol_red_pill___0(intf);
  }
#line 764
  if (tmp___1) {
    {
#line 765
    lprintf(3, "Error in SOL session");
    }
#line 766
    return (-1);
  }
#line 769
  return (0);
}
}
#line 772 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static void print_isol_set_usage___0(void) 
{ 


  {
  {
#line 773
  lprintf(5, "\nISOL set parameters and values: \n");
#line 774
  lprintf(5, "  enabled                     true | false");
#line 775
  lprintf(5, "  privilege-level             user | operator | admin | oem");
#line 776
  lprintf(5, "  bit-rate                    9.6 | 19.2 | 38.4 | 57.6 | 115.2");
#line 778
  lprintf(5, "");
  }
#line 779
  return;
}
}
#line 781 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_isol.c"
static void print_isol_usage___0(void) 
{ 


  {
  {
#line 782
  lprintf(5, "ISOL Commands: info");
#line 783
  lprintf(5, "               set <parameter> <setting>");
#line 784
  lprintf(5, "               activate");
  }
#line 785
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static unsigned char fileName___0[512]  ;
#line 145 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static unsigned char firmBuf___0[524288]  ;
#line 146 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_SaveFirmwareInfo saveFirmwareInfo___0  ;
#line 148
static void KfwumOutputHelp___0(void) ;
#line 149
static void KfwumMain___0(struct ipmi_intf *intf , tKFWUM_Task task ) ;
#line 150
static tKFWUM_Status KfwumGetFileSize___0(unsigned char *pFileName , unsigned long *pFileSize ) ;
#line 152
static tKFWUM_Status KfwumSetupBuffersFromFile___0(unsigned char *pFileName , unsigned long fileSize ) ;
#line 154
static void KfwumShowProgress___0(unsigned char const   *task , unsigned long current ,
                                  unsigned long total ) ;
#line 156
static unsigned short KfwumCalculateChecksumPadding___0(unsigned char *pBuffer , unsigned long totalSize ) ;
#line 160
static tKFWUM_Status KfwumGetInfo___0(struct ipmi_intf *intf , unsigned char output___1 ,
                                      unsigned char *pNumBank ) ;
#line 162
static tKFWUM_Status KfwumGetDeviceInfo___0(struct ipmi_intf *intf , unsigned char output___1 ,
                                            tKFWUM_BoardInfo *pBoardInfo ) ;
#line 164
static tKFWUM_Status KfwumGetStatus___0(struct ipmi_intf *intf ) ;
#line 165
static tKFWUM_Status KfwumManualRollback___0(struct ipmi_intf *intf ) ;
#line 166
static tKFWUM_Status KfwumStartFirmwareImage___0(struct ipmi_intf *intf , unsigned long length ,
                                                 unsigned short padding___1 ) ;
#line 168
static tKFWUM_Status KfwumSaveFirmwareImage___0(struct ipmi_intf *intf , unsigned char sequenceNumber ,
                                                unsigned long address , unsigned char *pFirmBuf ,
                                                unsigned char *pInBufLength ) ;
#line 171
static tKFWUM_Status KfwumFinishFirmwareImage___0(struct ipmi_intf *intf , tKFWUM_InFirmwareInfo firmInfo ) ;
#line 173
static tKFWUM_Status KfwumUploadFirmware___0(struct ipmi_intf *intf , unsigned char *pBuffer ,
                                             unsigned long totalSize ) ;
#line 175
static tKFWUM_Status KfwumStartFirmwareUpgrade___0(struct ipmi_intf *intf ) ;
#line 177
static tKFWUM_Status KfwumGetInfoFromFirmware___0(unsigned char *pBuf , unsigned long bufSize ,
                                                  tKFWUM_InFirmwareInfo *pInfo ) ;
#line 179
static void KfwumFixTableVersionForOldFirmware___0(tKFWUM_InFirmwareInfo *pInfo ) ;
#line 181
static tKFWUM_Status KfwumGetTraceLog___0(struct ipmi_intf *intf ) ;
#line 185
static void KfwumOutputInfo___0(tKFWUM_BoardInfo boardInfo , tKFWUM_InFirmwareInfo firmInfo ) ;
#line 276 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static void KfwumOutputHelp___0(void) 
{ 


  {
  {
#line 278
  printf((char const   */* __restrict  */)"KFWUM Commands:  info status download upgrade rollback tracelog\n");
  }
#line 279
  return;
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static unsigned short padding___0  ;
#line 333 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static void KfwumMain___0(struct ipmi_intf *intf , tKFWUM_Task task ) 
{ 
  tKFWUM_Status status ;
  tKFWUM_BoardInfo boardInfo ;
  tKFWUM_InFirmwareInfo firmInfo ;
  unsigned long fileSize ;
  unsigned char notUsed ;
  unsigned char notUsed___0 ;

  {
#line 335
  status = (tKFWUM_Status )0;
#line 337
  firmInfo.fileSize = 0UL;
#line 337
  firmInfo.checksum = (unsigned short)0;
#line 337
  firmInfo.sumToRemoveFromChecksum = (unsigned short)0;
#line 337
  firmInfo.boardId = 0U;
#line 337
  firmInfo.deviceId = (unsigned char)0;
#line 337
  firmInfo.tableVers = (unsigned char)0;
#line 337
  firmInfo.implRev = (unsigned char)0;
#line 337
  firmInfo.versMajor = (unsigned char)0;
#line 337
  firmInfo.versMinor = (unsigned char)0;
#line 337
  firmInfo.versSubMinor = (unsigned char)0;
#line 337
  firmInfo.sdrRev = (unsigned char)0;
#line 337
  firmInfo.iana = 0U;
#line 338
  fileSize = 0UL;
#line 341
  if ((unsigned int )status == 0U) {
#line 341
    if ((unsigned int )task == 0U) {
#line 344
      if (verbose) {
        {
#line 346
        printf((char const   */* __restrict  */)"Getting Kontron FWUM Info\n");
        }
      }
      {
#line 348
      KfwumGetDeviceInfo___0(intf, (unsigned char)1, & boardInfo);
#line 349
      KfwumGetInfo___0(intf, (unsigned char)1, & notUsed);
      }
    }
  }
#line 354
  if ((unsigned int )status == 0U) {
#line 354
    if ((unsigned int )task == 1U) {
#line 356
      if (verbose) {
        {
#line 358
        printf((char const   */* __restrict  */)"Getting Kontron FWUM Status\n");
        }
      }
      {
#line 360
      KfwumGetStatus___0(intf);
      }
    }
  }
#line 363
  if ((unsigned int )status == 0U) {
#line 363
    if ((unsigned int )task == 5U) {
      {
#line 365
      status = KfwumManualRollback___0(intf);
      }
    }
  }
#line 368
  if ((unsigned int )status == 0U) {
#line 368
    if ((unsigned int )task == 3U) {
#line 368
      goto _L;
    } else
#line 368
    if ((unsigned int )task == 2U) {
      _L: /* CIL Label */ 
      {
#line 375
      status = KfwumGetFileSize___0(fileName___0, & fileSize);
      }
#line 376
      if ((unsigned int )status == 0U) {
        {
#line 378
        status = KfwumSetupBuffersFromFile___0(fileName___0, fileSize);
        }
#line 379
        if ((unsigned int )status == 0U) {
          {
#line 381
          padding___0 = KfwumCalculateChecksumPadding___0(firmBuf___0, fileSize);
          }
        }
      }
#line 384
      if ((unsigned int )status == 0U) {
        {
#line 386
        status = KfwumGetInfoFromFirmware___0(firmBuf___0, fileSize, & firmInfo);
        }
      }
#line 388
      if ((unsigned int )status == 0U) {
        {
#line 390
        status = KfwumGetDeviceInfo___0(intf, (unsigned char)0, & boardInfo);
        }
      }
#line 393
      if ((unsigned int )status == 0U) {
        {
#line 395
        status = KfwumValidFirmwareForBoard(boardInfo, firmInfo);
        }
      }
#line 398
      if ((unsigned int )status == 0U) {
        {
#line 401
        KfwumGetInfo___0(intf, (unsigned char)0, & notUsed___0);
        }
      }
      {
#line 404
      KfwumOutputInfo___0(boardInfo, firmInfo);
      }
    }
  }
#line 407
  if ((unsigned int )status == 0U) {
#line 407
    if ((unsigned int )task == 3U) {
      {
#line 414
      status = KfwumStartFirmwareImage___0(intf, fileSize, padding___0);
      }
    } else
#line 407
    if ((unsigned int )task == 2U) {
      {
#line 414
      status = KfwumStartFirmwareImage___0(intf, fileSize, padding___0);
      }
    }
  }
#line 418
  if ((unsigned int )status == 0U) {
#line 418
    if ((unsigned int )task == 3U) {
      {
#line 425
      status = KfwumUploadFirmware___0(intf, firmBuf___0, fileSize);
      }
    } else
#line 418
    if ((unsigned int )task == 2U) {
      {
#line 425
      status = KfwumUploadFirmware___0(intf, firmBuf___0, fileSize);
      }
    }
  }
#line 428
  if ((unsigned int )status == 0U) {
#line 428
    if ((unsigned int )task == 3U) {
      {
#line 435
      status = KfwumFinishFirmwareImage___0(intf, firmInfo);
      }
    } else
#line 428
    if ((unsigned int )task == 2U) {
      {
#line 435
      status = KfwumFinishFirmwareImage___0(intf, firmInfo);
      }
    }
  }
#line 438
  if ((unsigned int )status == 0U) {
#line 438
    if ((unsigned int )task == 3U) {
      {
#line 445
      status = KfwumGetStatus___0(intf);
      }
    } else
#line 438
    if ((unsigned int )task == 2U) {
      {
#line 445
      status = KfwumGetStatus___0(intf);
      }
    }
  }
#line 448
  if ((unsigned int )status == 0U) {
#line 448
    if ((unsigned int )task == 3U) {
      {
#line 455
      status = KfwumStartFirmwareUpgrade___0(intf);
      }
    } else
#line 448
    if ((unsigned int )task == 4U) {
      {
#line 455
      status = KfwumStartFirmwareUpgrade___0(intf);
      }
    }
  }
#line 458
  if ((unsigned int )status == 0U) {
#line 458
    if ((unsigned int )task == 6U) {
      {
#line 460
      status = KfwumGetTraceLog___0(intf);
      }
    }
  }
#line 464
  return;
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumGetFileSize___0(unsigned char *pFileName , unsigned long *pFileSize ) 
{ 
  tKFWUM_Status status ;
  FILE *pFileHandle ;
  long tmp ;
  int tmp___0 ;

  {
  {
#line 476
  status = (tKFWUM_Status )1;
#line 479
  pFileHandle = fopen((char const   */* __restrict  */)((char const   *)pFileName),
                      (char const   */* __restrict  */)"rb");
  }
#line 481
  if (pFileHandle) {
    {
#line 483
    tmp___0 = fseek(pFileHandle, 0L, 2);
    }
#line 483
    if (tmp___0 == 0) {
      {
#line 485
      tmp = ftell(pFileHandle);
#line 485
      *pFileSize = (unsigned long )tmp;
      }
#line 487
      if (*pFileSize != 0UL) {
#line 489
        status = (tKFWUM_Status )0;
      }
    }
    {
#line 492
    fclose(pFileHandle);
    }
  }
#line 495
  return (status);
}
}
#line 506 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumSetupBuffersFromFile___0(unsigned char *pFileName , unsigned long fileSize ) 
{ 
  tKFWUM_Status status ;
  FILE *pFileHandle ;
  int count ;
  int modulus ;
  int qty ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 509
  status = (tKFWUM_Status )1;
#line 510
  pFileHandle = (FILE *)((void *)0);
#line 513
  qty = 0;
#line 515
  pFileHandle = fopen((char const   */* __restrict  */)((char const   *)pFileName),
                      (char const   */* __restrict  */)"rb");
  }
#line 516
  if ((unsigned long )pFileHandle == (unsigned long )((void *)0)) {
    {
#line 517
    lprintf(3, "Failed to open \'%s\' for reading.", (char *)pFileName);
    }
#line 519
    return ((tKFWUM_Status )1);
  }
  {
#line 521
  count = (int )((fileSize / 1024UL) * 16UL);
#line 522
  modulus = (int )((fileSize % 1024UL) * 16UL);
#line 524
  rewind(pFileHandle);
#line 525
  qty = 0;
  }
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    if (! (qty < count)) {
#line 525
      goto while_break;
    }
    {
#line 526
    KfwumShowProgress___0((unsigned char const   *)"Reading Firmware from File", (unsigned long )qty,
                          (unsigned long )count);
#line 528
    tmp = fread((void */* __restrict  */)(& firmBuf___0[(qty * 1024) * 16]), (size_t )1,
                (size_t )16384, (FILE */* __restrict  */)pFileHandle);
    }
#line 528
    if (tmp == 16384UL) {
#line 531
      status = (tKFWUM_Status )0;
    }
#line 525
    qty ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 534
  if (modulus) {
    {
#line 535
    tmp___0 = fread((void */* __restrict  */)(& firmBuf___0[(qty * 1024) * 16]), (size_t )1,
                    (size_t )modulus, (FILE */* __restrict  */)pFileHandle);
    }
#line 535
    if (tmp___0 == (size_t )modulus) {
#line 537
      status = (tKFWUM_Status )0;
    }
  }
#line 540
  if ((unsigned int )status == 0U) {
    {
#line 541
    KfwumShowProgress___0((unsigned char const   *)"Reading Firmware from File", 100UL,
                          100UL);
    }
  }
  {
#line 544
  fclose(pFileHandle);
  }
#line 545
  return (status);
}
}
#line 560 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static unsigned long staticProgress___0  =    4294967295UL;
#line 557 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static void KfwumShowProgress___0(unsigned char const   *task , unsigned long current ,
                                  unsigned long total ) 
{ 
  unsigned char spaces[43] ;
  unsigned short hash ;
  float percent ;
  unsigned long progress ;

  {
#line 564
  percent = (float )current / (float )total;
#line 565
  progress = (unsigned long )((float )100 * percent);
#line 567
  if (! (staticProgress___0 == progress)) {
    {
#line 573
    staticProgress___0 = progress;
#line 576
    printf((char const   */* __restrict  */)"%-25s : ", task);
#line 578
    hash = (unsigned short )(percent * (float )42);
#line 579
    memset((void *)(spaces), '#', (size_t )hash);
#line 580
    spaces[hash] = (unsigned char )'\000';
#line 581
    printf((char const   */* __restrict  */)"%s", spaces);
#line 583
    memset((void *)(spaces), ' ', (size_t )(42 - (int )hash));
#line 584
    spaces[42 - (int )hash] = (unsigned char )'\000';
#line 585
    printf((char const   */* __restrict  */)"%s", spaces);
#line 588
    printf((char const   */* __restrict  */)" %3ld %%\r", progress);
    }
#line 590
    if (progress == 100UL) {
      {
#line 592
      printf((char const   */* __restrict  */)"\n");
      }
    }
    {
#line 594
    fflush(stdout);
    }
  }
#line 596
  return;
}
}
#line 603 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static unsigned short KfwumCalculateChecksumPadding___0(unsigned char *pBuffer , unsigned long totalSize ) 
{ 
  unsigned short sumOfBytes ;
  unsigned short padding___1 ;
  unsigned long counter ;

  {
#line 606
  sumOfBytes = (unsigned short)0;
#line 610
  counter = 0UL;
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 610
    if (! (counter < totalSize)) {
#line 610
      goto while_break;
    }
#line 612
    sumOfBytes = (unsigned short )((int )sumOfBytes + (int )*(pBuffer + counter));
#line 610
    counter ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 615
  padding___1 = (unsigned short )(0 - (int )sumOfBytes);
#line 616
  return (padding___1);
}
}
#line 654 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static struct KfwumGetInfoResp *pGetInfo___0  ;
#line 650 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumGetInfo___0(struct ipmi_intf *intf , unsigned char output___1 ,
                                      unsigned char *pNumBank ) 
{ 
  tKFWUM_Status status ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 653
  status = (tKFWUM_Status )0;
#line 658
  memset((void *)(& req), 0, sizeof(req));
#line 659
  req.msg.netfn = (uint8_t )8;
#line 660
  req.msg.cmd = (uint8_t )0;
#line 661
  req.msg.data_len = (uint16_t )0;
#line 663
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 665
  if (! rsp) {
    {
#line 667
    printf((char const   */* __restrict  */)"Error in FWUM Firmware Get Info Command\n");
#line 668
    status = (tKFWUM_Status )1;
    }
  } else
#line 670
  if (rsp->ccode) {
    {
#line 672
    printf((char const   */* __restrict  */)"FWUM Firmware Get Info returned %x\n",
           (int )rsp->ccode);
#line 673
    status = (tKFWUM_Status )1;
    }
  }
#line 676
  if ((unsigned int )status == 0U) {
#line 678
    pGetInfo___0 = (struct KfwumGetInfoResp *)(rsp->data);
#line 679
    if (output___1) {
      {
#line 681
      printf((char const   */* __restrict  */)"\nFWUM info\n");
#line 682
      printf((char const   */* __restrict  */)"=========\n");
#line 683
      printf((char const   */* __restrict  */)"Protocol Revision         : %02Xh\n",
             (int )pGetInfo___0->protocolRevision);
#line 685
      printf((char const   */* __restrict  */)"Controller Device Id      : %02Xh\n",
             (int )pGetInfo___0->controllerDeviceId);
#line 687
      printf((char const   */* __restrict  */)"Firmware Revision         : %u.%u%u",
             (int )pGetInfo___0->firmRev1, (int )pGetInfo___0->firmRev2 >> 4, (int )pGetInfo___0->firmRev2 & 15);
      }
#line 690
      if ((int )pGetInfo___0->byte.mode != 0) {
        {
#line 692
        printf((char const   */* __restrict  */)" - DEBUG BUILD\n");
        }
      } else {
        {
#line 696
        printf((char const   */* __restrict  */)"\n");
        }
      }
      {
#line 698
      printf((char const   */* __restrict  */)"Number Of Memory Bank     : %u\n",
             (int )pGetInfo___0->numBank);
      }
    }
#line 700
    *pNumBank = pGetInfo___0->numBank;
#line 705
    if ((int )pGetInfo___0->protocolRevision <= 5) {
#line 705
      goto _L___1;
    } else
#line 705
    if (rsp->data_len < 7) {
      _L___1: /* CIL Label */ 
#line 707
      saveFirmwareInfo___0.downloadType = (tKFWUM_DownloadType )0;
#line 708
      saveFirmwareInfo___0.bufferSize = (unsigned char)32;
#line 709
      saveFirmwareInfo___0.overheadSize = (unsigned char)6;
#line 711
      if (verbose) {
        {
#line 713
        printf((char const   */* __restrict  */)"Protocol Revision          :");
#line 714
        printf((char const   */* __restrict  */)" <= 5 detected, adjusting buffers\n");
        }
      }
    } else {
#line 719
      saveFirmwareInfo___0.downloadType = (tKFWUM_DownloadType )1;
#line 720
      saveFirmwareInfo___0.overheadSize = (unsigned char)4;
#line 724
      if (verbose) {
        {
#line 726
        printf((char const   */* __restrict  */)"Protocol Revision          :");
#line 727
        printf((char const   */* __restrict  */)" > 5 optimizing buffers\n");
        }
      }
      {
#line 730
      tmp___0 = strstr((char const   *)(intf->name), "lan");
      }
#line 730
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 732
        saveFirmwareInfo___0.bufferSize = (unsigned char)32;
#line 733
        if (verbose) {
          {
#line 735
          printf((char const   */* __restrict  */)"IOL payload size           : %d\n",
                 (int )saveFirmwareInfo___0.bufferSize);
          }
        }
      } else {
        {
#line 739
        tmp = strstr((char const   *)(intf->name), "open");
        }
#line 739
        if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 739
          if (intf->target_addr != 32U) {
#line 739
            if (intf->target_addr != intf->my_addr) {
#line 750
              saveFirmwareInfo___0.bufferSize = (unsigned char)32;
#line 751
              if (verbose) {
                {
#line 753
                printf((char const   */* __restrict  */)"IPMB payload size          : %d\n",
                       (int )saveFirmwareInfo___0.bufferSize);
                }
              }
            } else {
#line 739
              goto _L___0;
            }
          } else {
#line 739
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 759
          saveFirmwareInfo___0.bufferSize = (unsigned char)32;
#line 760
          if (verbose) {
            {
#line 762
            printf((char const   */* __restrict  */)"SMI payload size           : %d\n",
                   (int )saveFirmwareInfo___0.bufferSize);
            }
          }
        }
      }
    }
  }
#line 768
  return (status);
}
}
#line 777 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumGetDeviceInfo___0(struct ipmi_intf *intf , unsigned char output___1 ,
                                            tKFWUM_BoardInfo *pBoardInfo ) 
{ 
  struct ipm_devid_rsp *pGetDevId ;
  tKFWUM_Status status ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint16_t tmp ;
  tKFWUM_BoardList tmp___0 ;

  {
#line 781
  status = (tKFWUM_Status )0;
#line 786
  if ((unsigned int )status == 0U) {
    {
#line 788
    memset((void *)(& req), 0, sizeof(req));
#line 789
    req.msg.netfn = (uint8_t )6;
#line 790
    req.msg.cmd = (uint8_t )1;
#line 791
    req.msg.data_len = (uint16_t )0;
#line 793
    rsp = (*(intf->sendrecv))(intf, & req);
    }
#line 794
    if (! rsp) {
      {
#line 796
      printf((char const   */* __restrict  */)"Error in Get Device Id Command\n");
#line 797
      status = (tKFWUM_Status )1;
      }
    } else
#line 799
    if (rsp->ccode) {
      {
#line 801
      printf((char const   */* __restrict  */)"Get Device Id returned %x\n", (int )rsp->ccode);
#line 802
      status = (tKFWUM_Status )1;
      }
    }
  }
#line 806
  if ((unsigned int )status == 0U) {
    {
#line 808
    pGetDevId = (struct ipm_devid_rsp *)(rsp->data);
#line 809
    pBoardInfo->iana = (tKFWUM_IanaList )((uint32_t )(((((int )pGetDevId->manufacturer_id[2] & 15) << 16) | ((int )pGetDevId->manufacturer_id[1] << 8)) | (int )pGetDevId->manufacturer_id[0]));
#line 810
    tmp = buf2short(pGetDevId->product_id);
#line 810
    pBoardInfo->boardId = (tKFWUM_BoardList )tmp;
    }
#line 811
    if (output___1) {
      {
#line 813
      printf((char const   */* __restrict  */)"\nIPMC Info\n");
#line 814
      printf((char const   */* __restrict  */)"=========\n");
#line 815
      printf((char const   */* __restrict  */)"Manufacturer Id           : %u\n",
             (unsigned int )pBoardInfo->iana);
#line 816
      printf((char const   */* __restrict  */)"Board Id                  : %u\n",
             (unsigned int )pBoardInfo->boardId);
#line 817
      printf((char const   */* __restrict  */)"Firmware Revision         : %u.%u%u",
             (int )pGetDevId->fw_rev1, (int )pGetDevId->fw_rev2 >> 4, (int )pGetDevId->fw_rev2 & 15);
      }
#line 820
      if ((unsigned int )pBoardInfo->iana == 15000U) {
#line 820
        tmp___0 = (tKFWUM_BoardList )5002;
#line 820
        pBoardInfo->boardId = tmp___0;
#line 820
        if (tmp___0) {
          {
#line 828
          printf((char const   */* __restrict  */)" SDR %u\n", (int )pGetDevId->aux_fw_rev[0]);
          }
        } else {
          {
#line 832
          printf((char const   */* __restrict  */)"\n");
          }
        }
      } else {
        {
#line 832
        printf((char const   */* __restrict  */)"\n");
        }
      }
    }
  }
#line 837
  return (status);
}
}
#line 870 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumGetStatus___0(struct ipmi_intf *intf ) 
{ 
  tKFWUM_Status status ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct KfwumGetStatusResp *pGetStatus ;
  unsigned char numBank ;
  unsigned char counter ;
  char const   *tmp ;
  unsigned long firmLength ;

  {
#line 872
  status = (tKFWUM_Status )0;
#line 879
  if (verbose) {
    {
#line 881
    printf((char const   */* __restrict  */)" Getting Status!\n");
    }
  }
  {
#line 885
  status = KfwumGetInfo___0(intf, (unsigned char)0, & numBank);
#line 887
  counter = (unsigned char)0;
  }
  {
#line 887
  while (1) {
    while_continue: /* CIL Label */ ;
#line 887
    if ((int )counter < (int )numBank) {
#line 887
      if (! ((unsigned int )status == 0U)) {
#line 887
        goto while_break;
      }
    } else {
#line 887
      goto while_break;
    }
    {
#line 894
    memset((void *)(& req), 0, sizeof(req));
#line 895
    req.msg.netfn = (uint8_t )8;
#line 896
    req.msg.cmd = (uint8_t )7;
#line 897
    req.msg.data = & counter;
#line 898
    req.msg.data_len = (uint16_t )1;
#line 900
    rsp = (*(intf->sendrecv))(intf, & req);
    }
#line 902
    if (! rsp) {
      {
#line 904
      printf((char const   */* __restrict  */)"Error in FWUM Firmware Get Status Command\n");
#line 905
      status = (tKFWUM_Status )1;
      }
    } else
#line 907
    if (rsp->ccode) {
      {
#line 909
      printf((char const   */* __restrict  */)"FWUM Firmware Get Status returned %x\n",
             (int )rsp->ccode);
#line 910
      status = (tKFWUM_Status )1;
      }
    }
#line 914
    if ((unsigned int )status == 0U) {
      {
#line 916
      pGetStatus = (struct KfwumGetStatusResp *)(rsp->data);
#line 917
      tmp = val2str((uint16_t )pGetStatus->bankState, bankStateValS);
#line 917
      printf((char const   */* __restrict  */)"\nBank State %d               : %s\n",
             (int )counter, tmp);
      }
#line 919
      if (pGetStatus->bankState) {
        {
#line 922
        firmLength = (unsigned long )pGetStatus->firmLengthMSB;
#line 923
        firmLength <<= 8;
#line 924
        firmLength |= (unsigned long )pGetStatus->firmLengthMid;
#line 925
        firmLength <<= 8;
#line 926
        firmLength |= (unsigned long )pGetStatus->firmLengthLSB;
#line 928
        printf((char const   */* __restrict  */)"Firmware Length            : %ld bytes\n",
               firmLength);
#line 929
        printf((char const   */* __restrict  */)"Firmware Revision          : %u.%u%u SDR %u\n",
               (int )pGetStatus->firmRev1, (int )pGetStatus->firmRev2 >> 4, (int )pGetStatus->firmRev2 & 15,
               (int )pGetStatus->firmRev3);
        }
      }
    }
#line 887
    counter = (unsigned char )((int )counter + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 935
  printf((char const   */* __restrict  */)"\n");
  }
#line 936
  return (status);
}
}
#line 954 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumManualRollback___0(struct ipmi_intf *intf ) 
{ 
  tKFWUM_Status status ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct KfwumManualRollbackReq thisReq ;

  {
  {
#line 956
  status = (tKFWUM_Status )0;
#line 962
  memset((void *)(& req), 0, sizeof(req));
#line 963
  req.msg.netfn = (uint8_t )8;
#line 964
  req.msg.cmd = (uint8_t )14;
#line 966
  thisReq.type = (unsigned char)0;
#line 968
  req.msg.data = (unsigned char *)(& thisReq);
#line 969
  req.msg.data_len = (uint16_t )1;
#line 971
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 973
  if (! rsp) {
    {
#line 975
    printf((char const   */* __restrict  */)"Error in FWUM Manual Rollback Command\n");
#line 976
    status = (tKFWUM_Status )1;
    }
  } else
#line 978
  if (rsp->ccode) {
    {
#line 980
    printf((char const   */* __restrict  */)"Error in FWUM Manual Rollback Command returned %x\n",
           (int )rsp->ccode);
#line 982
    status = (tKFWUM_Status )1;
    }
  }
#line 985
  if ((unsigned int )status == 0U) {
    {
#line 987
    printf((char const   */* __restrict  */)"FWUM Starting Manual Rollback \n");
    }
  }
#line 989
  return (status);
}
}
#line 1017 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumStartFirmwareImage___0(struct ipmi_intf *intf , unsigned long length ,
                                                 unsigned short padding___1 ) 
{ 
  tKFWUM_Status status ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct KfwumStartFirmwareDownloadResp *pResp ;
  struct KfwumStartFirmwareDownloadReq thisReq ;

  {
  {
#line 1020
  status = (tKFWUM_Status )0;
#line 1026
  thisReq.lengthLSB = (unsigned char )(length & 255UL);
#line 1027
  thisReq.lengthMid = (unsigned char )((length >> 8) & 255UL);
#line 1028
  thisReq.lengthMSB = (unsigned char )((length >> 16) & 255UL);
#line 1029
  thisReq.paddingLSB = (unsigned char )((int )padding___1 & 255);
#line 1030
  thisReq.paddingMSB = (unsigned char )(((int )padding___1 >> 8) & 255);
#line 1031
  thisReq.useSequence = (unsigned char)1;
#line 1033
  memset((void *)(& req), 0, sizeof(req));
#line 1034
  req.msg.netfn = (uint8_t )8;
#line 1035
  req.msg.cmd = (uint8_t )10;
#line 1036
  req.msg.data = (unsigned char *)(& thisReq);
  }
#line 1039
  if ((unsigned int )saveFirmwareInfo___0.downloadType == 0U) {
#line 1041
    req.msg.data_len = (uint16_t )5;
  } else {
#line 1045
    req.msg.data_len = (uint16_t )6;
  }
  {
#line 1048
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 1050
  if (! rsp) {
    {
#line 1052
    printf((char const   */* __restrict  */)"Error in FWUM Firmware Start Firmware Image Download Command\n");
#line 1053
    status = (tKFWUM_Status )1;
    }
  } else
#line 1055
  if (rsp->ccode) {
    {
#line 1057
    printf((char const   */* __restrict  */)"FWUM Firmware Start Firmware Image Download returned %x\n",
           (int )rsp->ccode);
#line 1059
    status = (tKFWUM_Status )1;
    }
  }
#line 1062
  if ((unsigned int )status == 0U) {
    {
#line 1064
    pResp = (struct KfwumStartFirmwareDownloadResp *)(rsp->data);
#line 1065
    printf((char const   */* __restrict  */)"Bank holding new firmware  : %d\n", (int )pResp->bank);
#line 1066
    sleep(5U);
    }
  }
#line 1068
  return (status);
}
}
#line 1101 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumSaveFirmwareImage___0(struct ipmi_intf *intf , unsigned char sequenceNumber ,
                                                unsigned long address , unsigned char *pFirmBuf ,
                                                unsigned char *pInBufLength ) 
{ 
  tKFWUM_Status status ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char out ;
  unsigned char retry ;
  unsigned char noResponse ;
  struct KfwumSaveFirmwareAddressReq addressReq ;
  struct KfwumSaveFirmwareSequenceReq sequenceReq ;
  char *tmp ;

  {
#line 1105
  status = (tKFWUM_Status )0;
#line 1108
  out = (unsigned char)0;
#line 1109
  retry = (unsigned char)0;
#line 1110
  noResponse = (unsigned char)0;
  {
#line 1115
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1117
    memset((void *)(& req), 0, sizeof(req));
#line 1118
    req.msg.netfn = (uint8_t )8;
#line 1119
    req.msg.cmd = (uint8_t )11;
    }
#line 1121
    if ((unsigned int )saveFirmwareInfo___0.downloadType == 0U) {
      {
#line 1123
      addressReq.addressLSB = (unsigned char )(address & 255UL);
#line 1124
      addressReq.addressMid = (unsigned char )((address >> 8) & 255UL);
#line 1125
      addressReq.addressMSB = (unsigned char )((address >> 16) & 255UL);
#line 1126
      addressReq.numBytes = *pInBufLength;
#line 1127
      memcpy((void */* __restrict  */)(addressReq.txBuf), (void const   */* __restrict  */)pFirmBuf,
             (size_t )*pInBufLength);
#line 1128
      req.msg.data = (unsigned char *)(& addressReq);
#line 1129
      req.msg.data_len = (uint16_t )((int )*pInBufLength + 4);
      }
    } else {
      {
#line 1133
      sequenceReq.sequenceNumber = sequenceNumber;
#line 1134
      memcpy((void */* __restrict  */)(sequenceReq.txBuf), (void const   */* __restrict  */)pFirmBuf,
             (size_t )*pInBufLength);
#line 1135
      req.msg.data = (unsigned char *)(& sequenceReq);
#line 1136
      req.msg.data_len = (uint16_t )((unsigned long )*pInBufLength + sizeof(unsigned char ));
      }
    }
    {
#line 1139
    rsp = (*(intf->sendrecv))(intf, & req);
    }
#line 1141
    if (! rsp) {
      {
#line 1143
      printf((char const   */* __restrict  */)"Error in FWUM Firmware Save Firmware Image Download Command\n");
#line 1145
      out = (unsigned char)0;
#line 1146
      status = (tKFWUM_Status )0;
#line 1150
      tmp = strstr((char const   *)(intf->name), "lan");
      }
#line 1150
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 1152
        noResponse = (unsigned char )((int )noResponse + 1);
#line 1154
        if ((int )noResponse < 6) {
#line 1156
          *pInBufLength = (unsigned char )((int )*pInBufLength - 1);
#line 1157
          out = (unsigned char)0;
        } else {
          {
#line 1161
          printf((char const   */* __restrict  */)"Error, too many commands without response\n");
#line 1162
          *pInBufLength = (unsigned char)0;
#line 1163
          out = (unsigned char)1;
          }
        }
      }
    } else
#line 1167
    if (rsp->ccode) {
#line 1169
      if ((int )rsp->ccode == 192) {
        {
#line 1171
        status = (tKFWUM_Status )0;
#line 1172
        sleep(1U);
        }
      } else
#line 1174
      if ((int )rsp->ccode == 199) {
#line 1183
        *pInBufLength = (unsigned char )((int )*pInBufLength - 1);
#line 1184
        status = (tKFWUM_Status )0;
#line 1185
        retry = (unsigned char)1;
      } else
#line 1174
      if ((int )rsp->ccode == 195) {
#line 1174
        if ((int )sequenceNumber == 0) {
#line 1183
          *pInBufLength = (unsigned char )((int )*pInBufLength - 1);
#line 1184
          status = (tKFWUM_Status )0;
#line 1185
          retry = (unsigned char)1;
        } else {
#line 1174
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1187
      if ((int )rsp->ccode == 130) {
#line 1190
        status = (tKFWUM_Status )0;
#line 1191
        out = (unsigned char)1;
      } else
#line 1193
      if ((int )rsp->ccode == 131) {
#line 1195
        if ((int )retry == 0) {
#line 1197
          retry = (unsigned char)1;
#line 1198
          status = (tKFWUM_Status )0;
        } else {
#line 1202
          status = (tKFWUM_Status )1;
#line 1203
          out = (unsigned char)1;
        }
      } else
#line 1206
      if ((int )rsp->ccode == 207) {
#line 1208
        retry = (unsigned char)1;
#line 1209
        status = (tKFWUM_Status )0;
      } else
#line 1211
      if ((int )rsp->ccode == 195) {
#line 1213
        if ((int )retry == 0) {
#line 1215
          retry = (unsigned char)1;
#line 1216
          status = (tKFWUM_Status )0;
        } else {
#line 1220
          status = (tKFWUM_Status )1;
#line 1221
          out = (unsigned char)1;
        }
      } else {
        {
#line 1226
        printf((char const   */* __restrict  */)"FWUM Firmware Save Firmware Image Download returned %x\n",
               (int )rsp->ccode);
#line 1228
        status = (tKFWUM_Status )1;
#line 1229
        out = (unsigned char)1;
        }
      }
    } else {
#line 1234
      out = (unsigned char)1;
    }
#line 1115
    if (! ((int )out == 0)) {
#line 1115
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1237
  return (status);
}
}
#line 1253 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumFinishFirmwareImage___0(struct ipmi_intf *intf , tKFWUM_InFirmwareInfo firmInfo ) 
{ 
  tKFWUM_Status status ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct KfwumFinishFirmwareDownloadReq thisReq ;

  {
  {
#line 1256
  status = (tKFWUM_Status )0;
#line 1261
  thisReq.versionMaj = firmInfo.versMajor;
#line 1262
  thisReq.versionMinSub = (unsigned char )(((int )firmInfo.versMinor << 4) | (int )firmInfo.versSubMinor);
#line 1263
  thisReq.versionSdr = firmInfo.sdrRev;
#line 1264
  thisReq.reserved = (unsigned char)0;
#line 1267
  memset((void *)(& req), 0, sizeof(req));
#line 1268
  req.msg.netfn = (uint8_t )8;
#line 1269
  req.msg.cmd = (uint8_t )12;
#line 1270
  req.msg.data = (unsigned char *)(& thisReq);
#line 1271
  req.msg.data_len = (uint16_t )4;
  }
  {
#line 1273
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1275
    rsp = (*(intf->sendrecv))(intf, & req);
    }
#line 1273
    if (! ((unsigned long )rsp == (unsigned long )((void *)0))) {
#line 1273
      if (! ((int )rsp->ccode == 192)) {
#line 1273
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1278
  if (! rsp) {
    {
#line 1280
    printf((char const   */* __restrict  */)"Error in FWUM Firmware Finish Firmware Image Download Command\n");
#line 1281
    status = (tKFWUM_Status )1;
    }
  } else
#line 1283
  if (rsp->ccode) {
    {
#line 1285
    printf((char const   */* __restrict  */)"FWUM Firmware Finish Firmware Image Download returned %x\n",
           (int )rsp->ccode);
#line 1287
    status = (tKFWUM_Status )1;
    }
  }
#line 1290
  return (status);
}
}
#line 1295 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumUploadFirmware___0(struct ipmi_intf *intf , unsigned char *pBuffer ,
                                             unsigned long totalSize ) 
{ 
  tKFWUM_Status status ;
  unsigned long address ;
  unsigned char writeSize ;
  unsigned char oldWriteSize ;
  unsigned long lastAddress ;
  unsigned char sequenceNumber ;
  unsigned char retry ;
  unsigned char isLengthValid ;
  unsigned char tmp ;

  {
#line 1298
  status = (tKFWUM_Status )1;
#line 1299
  address = 0UL;
#line 1302
  lastAddress = 0UL;
#line 1303
  sequenceNumber = (unsigned char)0;
#line 1304
  retry = (unsigned char)6;
#line 1305
  isLengthValid = (unsigned char)1;
  {
#line 1307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1309
    writeSize = (unsigned char )((int )saveFirmwareInfo___0.bufferSize - (int )saveFirmwareInfo___0.overheadSize);
#line 1312
    if (address + (unsigned long )writeSize > totalSize) {
#line 1314
      writeSize = (unsigned char )(totalSize - address);
    } else
#line 1317
    if (address % 256UL + (unsigned long )writeSize > 256UL) {
#line 1319
      writeSize = (unsigned char )(256UL - address % 256UL);
    }
    {
#line 1322
    oldWriteSize = writeSize;
#line 1323
    status = KfwumSaveFirmwareImage___0(intf, sequenceNumber, address, pBuffer + address,
                                        & writeSize);
    }
#line 1326
    if ((unsigned int )status != 0U) {
#line 1326
      tmp = retry;
#line 1326
      retry = (unsigned char )((int )retry - 1);
#line 1326
      if ((int )tmp != 0) {
#line 1328
        address = lastAddress;
#line 1329
        status = (tKFWUM_Status )0;
      } else {
#line 1326
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1331
    if ((int )writeSize == 0) {
#line 1333
      status = (tKFWUM_Status )1;
    } else {
#line 1337
      if ((int )writeSize != (int )oldWriteSize) {
        {
#line 1339
        printf((char const   */* __restrict  */)"Adjusting length to %d bytes \n",
               (int )writeSize);
#line 1340
        saveFirmwareInfo___0.bufferSize = (unsigned char )((int )saveFirmwareInfo___0.bufferSize - ((int )oldWriteSize - (int )writeSize));
        }
      }
#line 1343
      retry = (unsigned char)6;
#line 1344
      lastAddress = address;
#line 1345
      address += (unsigned long )writeSize;
    }
#line 1348
    if ((unsigned int )status == 0U) {
#line 1350
      if (address % 1024UL == 0UL) {
        {
#line 1352
        KfwumShowProgress___0((unsigned char const   *)"Writting Firmware in Flash",
                              address, totalSize);
        }
      }
#line 1355
      sequenceNumber = (unsigned char )((int )sequenceNumber + 1);
    }
#line 1307
    if ((unsigned int )status == 0U) {
#line 1307
      if (! (address < totalSize)) {
#line 1307
        goto while_break;
      }
    } else {
#line 1307
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1360
  if ((unsigned int )status == 0U) {
    {
#line 1362
    KfwumShowProgress___0((unsigned char const   *)"Writting Firmware in Flash", 100UL,
                          100UL);
    }
  }
#line 1366
  return (status);
}
}
#line 1369 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumStartFirmwareUpgrade___0(struct ipmi_intf *intf ) 
{ 
  tKFWUM_Status status ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char upgType ;

  {
  {
#line 1371
  status = (tKFWUM_Status )0;
#line 1374
  upgType = (unsigned char)0;
#line 1376
  memset((void *)(& req), 0, sizeof(req));
#line 1377
  req.msg.netfn = (uint8_t )8;
#line 1378
  req.msg.cmd = (uint8_t )9;
#line 1379
  req.msg.data = & upgType;
#line 1380
  req.msg.data_len = (uint16_t )1;
#line 1382
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 1384
  if (! rsp) {
    {
#line 1386
    printf((char const   */* __restrict  */)"Error in FWUM Firmware Start Firmware Upgrade Command\n");
#line 1387
    status = (tKFWUM_Status )1;
    }
  } else
#line 1389
  if (rsp->ccode) {
#line 1391
    if ((int )rsp->ccode == 213) {
      {
#line 1393
      printf((char const   */* __restrict  */)"No firmware available for upgrade.  Download Firmware first\n");
      }
    } else {
      {
#line 1397
      printf((char const   */* __restrict  */)"FWUM Firmware Start Firmware Upgrade returned %x\n",
             (int )rsp->ccode);
      }
    }
#line 1400
    status = (tKFWUM_Status )1;
  }
#line 1403
  return (status);
}
}
#line 1411 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static char const   *CMD_ID_STRING___0[16]  = 
#line 1411
  {      "GetFwInfo",      "KickWatchdog",      "GetLastAnswer",      "BootHandshake", 
        "ReportStatus",      "CtrlIPMBLine",      "SetFwState",      "GetFwStatus", 
        "GetSpiMemStatus",      "StartFwUpdate",      "StartFwImage",      "SaveFwImage", 
        "FinishFwImage",      "ReadFwImage",      "ManualRollback",      "GetTraceLog"};
#line 1429 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static char const   *EXT_CMD_ID_STRING___0[6]  = {      "FwUpgradeLock",      "ProcessFwUpg",      "ProcessFwRb",      "WaitHSAfterUpg", 
        "WaitFirstHSUpg",      "FwInfoStateChange"};
#line 1438 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static char const   *CMD_STATE_STRING___0[4]  = {      "Invalid",      "Begin",      "Progress",      "Completed"};
#line 1445 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumGetTraceLog___0(struct ipmi_intf *intf ) 
{ 
  tKFWUM_Status status ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char chunkIdx ;
  unsigned char cmdIdx ;

  {
#line 1447
  status = (tKFWUM_Status )0;
#line 1453
  if (verbose) {
    {
#line 1455
    printf((char const   */* __restrict  */)" Getting Trace Log!\n");
    }
  }
#line 1458
  chunkIdx = (unsigned char)0;
  {
#line 1458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1458
    if ((int )chunkIdx < 7) {
#line 1458
      if (! ((unsigned int )status == 0U)) {
#line 1458
        goto while_break;
      }
    } else {
#line 1458
      goto while_break;
    }
    {
#line 1461
    memset((void *)(& req), 0, sizeof(req));
#line 1462
    req.msg.netfn = (uint8_t )8;
#line 1463
    req.msg.cmd = (uint8_t )15;
#line 1464
    req.msg.data = & chunkIdx;
#line 1465
    req.msg.data_len = (uint16_t )1;
#line 1467
    rsp = (*(intf->sendrecv))(intf, & req);
    }
#line 1469
    if (! rsp) {
      {
#line 1471
      printf((char const   */* __restrict  */)"Error in FWUM Firmware Get Trace Log Command\n");
#line 1472
      status = (tKFWUM_Status )1;
      }
    } else
#line 1474
    if (rsp->ccode) {
      {
#line 1476
      printf((char const   */* __restrict  */)"FWUM Firmware Get Trace Log returned %x\n",
             (int )rsp->ccode);
#line 1477
      status = (tKFWUM_Status )1;
      }
    }
#line 1480
    if ((unsigned int )status == 0U) {
#line 1482
      cmdIdx = (unsigned char)0;
      {
#line 1482
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1482
        if (! ((int )cmdIdx < 7)) {
#line 1482
          goto while_break___0;
        }
#line 1485
        if ((int )rsp->data[3 * (int )cmdIdx + 1] != 0) {
#line 1485
          if ((int )rsp->data[3 * (int )cmdIdx] < 16) {
            {
#line 1488
            printf((char const   */* __restrict  */)"  Cmd ID: %17s -- CmdState: %10s -- CompCode: %2x\n",
                   CMD_ID_STRING___0[rsp->data[3 * (int )cmdIdx]], CMD_STATE_STRING___0[rsp->data[3 * (int )cmdIdx + 1]],
                   (int )rsp->data[3 * (int )cmdIdx + 2]);
            }
          } else {
#line 1485
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 1493
        if ((int )rsp->data[3 * (int )cmdIdx + 1] != 0) {
#line 1493
          if ((int )rsp->data[3 * (int )cmdIdx] >= 192) {
            {
#line 1496
            printf((char const   */* __restrict  */)"  Cmd ID: %17s -- CmdState: %10s -- CompCode: %2x\n",
                   EXT_CMD_ID_STRING___0[(int )rsp->data[3 * (int )cmdIdx] - 192],
                   CMD_STATE_STRING___0[rsp->data[3 * (int )cmdIdx + 1]], (int )rsp->data[3 * (int )cmdIdx + 2]);
            }
          }
        }
#line 1482
        cmdIdx = (unsigned char )((int )cmdIdx + 1);
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1458
    chunkIdx = (unsigned char )((int )chunkIdx + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1504
  printf((char const   */* __restrict  */)"\n");
  }
#line 1505
  return (status);
}
}
#line 1549 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static tKFWUM_Status KfwumGetInfoFromFirmware___0(unsigned char *pBuf , unsigned long bufSize ,
                                                  tKFWUM_InFirmwareInfo *pInfo ) 
{ 
  tKFWUM_Status status ;
  unsigned long offset ;

  {
#line 1552
  status = (tKFWUM_Status )1;
#line 1554
  if (bufSize >= 1460UL) {
    {
#line 1556
    offset = 1440UL;
#line 1559
    pInfo->checksum = (unsigned short )((int )((unsigned short )*(pBuf + (offset + 4UL))) << 8);
#line 1561
    pInfo->checksum = (unsigned short )((int )pInfo->checksum | (int )((unsigned short )*(pBuf + ((offset + 1UL) + 4UL))));
#line 1565
    pInfo->sumToRemoveFromChecksum = (unsigned short )*(pBuf + (offset + 4UL));
#line 1569
    pInfo->sumToRemoveFromChecksum = (unsigned short )((int )pInfo->sumToRemoveFromChecksum + (int )*(pBuf + ((offset + 4UL) + 1UL)));
#line 1573
    pInfo->fileSize = (unsigned long )((int )*(pBuf + offset) << 24);
#line 1576
    pInfo->fileSize |= (unsigned long )*(pBuf + (offset + 1UL)) << 16;
#line 1579
    pInfo->fileSize |= (unsigned long )*(pBuf + (offset + 2UL)) << 8;
#line 1582
    pInfo->fileSize |= (unsigned long )*(pBuf + (offset + 3UL));
#line 1586
    pInfo->boardId = (tKFWUM_BoardList )((int )*(pBuf + (offset + 6UL)) << 8);
#line 1589
    pInfo->boardId = (tKFWUM_BoardList )((unsigned int )pInfo->boardId | (unsigned int )*(pBuf + ((offset + 6UL) + 1UL)));
#line 1593
    pInfo->deviceId = *(pBuf + (offset + 8UL));
#line 1597
    pInfo->tableVers = *(pBuf + (offset + 9UL));
#line 1600
    pInfo->implRev = *(pBuf + (offset + 10UL));
#line 1603
    pInfo->versMajor = (unsigned char )((int )*(pBuf + (offset + 11UL)) & 15);
#line 1606
    pInfo->versMinor = (unsigned char )(((int )*(pBuf + (offset + 12UL)) >> 4) & 15);
#line 1609
    pInfo->versSubMinor = (unsigned char )((int )*(pBuf + (offset + 12UL)) & 15);
#line 1612
    pInfo->sdrRev = *(pBuf + (offset + 13UL));
#line 1615
    pInfo->iana = (tKFWUM_IanaList )((int )*(pBuf + (offset + 16UL)) << 16);
#line 1618
    pInfo->iana = (tKFWUM_IanaList )((unsigned long )pInfo->iana | ((unsigned long )*(pBuf + (offset + 15UL)) << 8));
#line 1621
    pInfo->iana = (tKFWUM_IanaList )((unsigned long )pInfo->iana | (unsigned long )*(pBuf + (offset + 14UL)));
#line 1625
    KfwumFixTableVersionForOldFirmware___0(pInfo);
#line 1627
    status = (tKFWUM_Status )0;
    }
  }
#line 1629
  return (status);
}
}
#line 1633 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static void KfwumFixTableVersionForOldFirmware___0(tKFWUM_InFirmwareInfo *pInfo ) 
{ 


  {
  {
#line 1637
  if ((unsigned int )pInfo->boardId == 0U) {
#line 1637
    goto case_0;
  }
#line 1640
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1638
  pInfo->tableVers = (unsigned char)255;
#line 1639
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1642
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1644
  return;
}
}
#line 1673 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fwum.c"
static void KfwumOutputInfo___0(tKFWUM_BoardInfo boardInfo , tKFWUM_InFirmwareInfo firmInfo ) 
{ 


  {
  {
#line 1676
  printf((char const   */* __restrict  */)"Target Board Id            : %u\n", (unsigned int )boardInfo.boardId);
#line 1677
  printf((char const   */* __restrict  */)"Target IANA number         : %u\n", (unsigned int )boardInfo.iana);
#line 1678
  printf((char const   */* __restrict  */)"File Size                  : %lu bytes\n",
         firmInfo.fileSize);
#line 1679
  printf((char const   */* __restrict  */)"Firmware Version           : %d.%d%d SDR %d\n",
         (int )firmInfo.versMajor, (int )firmInfo.versMinor, (int )firmInfo.versSubMinor,
         (int )firmInfo.sdrRev);
  }
#line 1681
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_print_sensor_info___0(struct ipmi_intf *intf , uint16_t rec_id ) ;
#line 351 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static char un_str___3[32]  ;
#line 369 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int chk_rsp___0(struct ipmi_rs *rsp ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 375
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 376
    lprintf(3, "\n    Unable to get DCMI information");
    }
#line 377
    return (1);
  }
#line 383
  if ((int )rsp->ccode >= 128) {
#line 383
    if ((int )rsp->ccode <= 143) {
      {
#line 384
      tmp = val2str((uint16_t )rsp->ccode, dcmi_ccode_vals);
#line 384
      lprintf(3, "\n    DCMI request failed because: %s (%x)", tmp, (int )rsp->ccode);
      }
#line 386
      return (1);
    } else {
#line 383
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 387
  if ((int )rsp->ccode > 0) {
    {
#line 388
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 388
    lprintf(3, "\n    DCMI request failed because: %s (%x)", tmp___0, (int )rsp->ccode);
    }
#line 390
    return (1);
  }
#line 393
  if ((int )rsp->data[0] != 220) {
    {
#line 394
    printf((char const   */* __restrict  */)"\n    A valid DCMI command was not returned! (%x)",
           (int )rsp->data[0]);
    }
#line 395
    return (1);
  }
#line 397
  return (0);
}
}
#line 447 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_prnt_oobDiscover___0(struct ipmi_intf *intf ) 
{ 


  {
  {
#line 451
  lprintf(3, "DCMI Discovery is available only when LANplus(IPMI v2.0) is enabled.");
  }
#line 453
  return (-1);
}
}
#line 540 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_prnt_getcapabilities___0(struct ipmi_intf *intf , uint8_t selector ) 
{ 
  uint8_t bit_shifter ;
  struct capabilities cape ;
  struct ipmi_rs *rsp ;
  int tmp ;
  uint16_t sel_entries ;

  {
  {
#line 544
  bit_shifter = (uint8_t )0;
#line 547
  rsp = ipmi_dcmi_getcapabilities(intf, selector);
#line 549
  tmp = chk_rsp___0(rsp);
  }
#line 549
  if (tmp) {
#line 550
    return (-1);
  }
  {
#line 553
  memcpy((void */* __restrict  */)(& cape), (void const   */* __restrict  */)(rsp->data),
         sizeof(cape));
  }
#line 555
  if ((int )cape.conformance != 1) {
#line 555
    if ((int )cape.conformance != 257) {
#line 555
      if ((int )cape.conformance != 1281) {
        {
#line 558
        lprintf(3, "ERROR!  This command is not available on this platform");
        }
#line 560
        return (-1);
      }
    }
  }
#line 563
  if ((int )cape.revision != 1) {
#line 563
    if ((int )cape.revision != 2) {
      {
#line 564
      lprintf(3, "ERROR!  This command is not compatible with this version");
      }
#line 566
      return (-1);
    }
  }
  {
#line 576
  if ((int )selector == 1) {
#line 576
    goto case_1;
  }
#line 597
  if ((int )selector == 2) {
#line 597
    goto case_2;
  }
#line 626
  if ((int )selector == 3) {
#line 626
    goto case_3;
  }
#line 648
  if ((int )selector == 4) {
#line 648
    goto case_4;
  }
#line 671
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 577
  printf((char const   */* __restrict  */)"    Supported DCMI capabilities:\n");
#line 581
  printf((char const   */* __restrict  */)"\n         Mandatory platform capabilties\n");
#line 582
  display_capabilities_attributes(dcmi_mandatory_platform_capabilities, cape.data_byte1);
#line 587
  printf((char const   */* __restrict  */)"\n         Optional platform capabilties\n");
#line 588
  display_capabilities_attributes(dcmi_optional_platform_capabilities, cape.data_byte2);
#line 593
  printf((char const   */* __restrict  */)"\n         Managebility access capabilties\n");
#line 594
  display_capabilities_attributes(dcmi_management_access_capabilities, cape.data_byte3);
  }
#line 596
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 598
  printf((char const   */* __restrict  */)"\n    Mandatory platform attributes:\n");
#line 600
  printf((char const   */* __restrict  */)"\n         SEL Attributes: ");
#line 601
  printf((char const   */* __restrict  */)"\n               SEL automatic rollover is ");
  }
#line 605
  if ((int )cape.data_byte2 & 128) {
    {
#line 606
    printf((char const   */* __restrict  */)"enabled");
    }
  } else {
    {
#line 608
    printf((char const   */* __restrict  */)"not present");
    }
  }
  {
#line 613
  sel_entries = (uint16_t )cape.data_byte1;
#line 615
  sel_entries = (uint16_t )((int )sel_entries | ((int )((uint16_t )cape.data_byte2) << 8));
#line 616
  printf((char const   */* __restrict  */)"\n               %d SEL entries\n", (int )sel_entries & 4095);
#line 618
  printf((char const   */* __restrict  */)"\n         Identification Attributes: \n");
#line 619
  display_capabilities_attributes(dcmi_id_capabilities_vals, cape.data_byte3);
#line 622
  printf((char const   */* __restrict  */)"\n         Temperature Monitoring Attributes: \n");
#line 623
  display_capabilities_attributes(dcmi_temp_monitoring_vals, cape.data_byte4);
  }
#line 625
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 627
  printf((char const   */* __restrict  */)"\n    Optional Platform Attributes: \n");
#line 629
  printf((char const   */* __restrict  */)"\n         Power Management:\n");
  }
#line 630
  if ((int )cape.data_byte1 == 64) {
    {
#line 631
    printf((char const   */* __restrict  */)"                Slave address of device: 20h (BMC)\n");
    }
  } else {
    {
#line 633
    printf((char const   */* __restrict  */)"                Slave address of device: %xh (8bits)(Satellite/External controller)\n",
           (int )cape.data_byte1);
    }
  }
#line 638
  if ((int )cape.data_byte2 >> 4 == 0) {
    {
#line 639
    printf((char const   */* __restrict  */)"                Channel number is 0h (Primary BMC)\n");
    }
  } else {
    {
#line 641
    printf((char const   */* __restrict  */)"                Channel number is %xh \n",
           (int )cape.data_byte2 >> 4);
    }
  }
  {
#line 645
  printf((char const   */* __restrict  */)"                    Device revision is %d \n",
         (int )cape.data_byte2 & 15);
  }
#line 647
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 650
  printf((char const   */* __restrict  */)"\n    Manageability Access Attributes: \n");
  }
#line 651
  if ((int )cape.data_byte1 == 255) {
    {
#line 652
    printf((char const   */* __restrict  */)"         Primary LAN channel is not available for OOB\n");
    }
  } else {
    {
#line 654
    printf((char const   */* __restrict  */)"         Primary LAN channel number: %d is available\n",
           (int )cape.data_byte1);
    }
  }
#line 657
  if ((int )cape.data_byte2 == 255) {
    {
#line 658
    printf((char const   */* __restrict  */)"         Secondary LAN channel is not available for OOB\n");
    }
  } else {
    {
#line 660
    printf((char const   */* __restrict  */)"         Secondary LAN channel number: %d is available\n",
           (int )cape.data_byte2);
    }
  }
#line 664
  if ((int )cape.data_byte3 == 255) {
    {
#line 665
    printf((char const   */* __restrict  */)"         No serial channel is available\n");
    }
  } else {
    {
#line 667
    printf((char const   */* __restrict  */)"         Serial channel number: %d is available\n",
           (int )cape.data_byte3);
    }
  }
#line 670
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 672
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 674
  return (0);
}
}
#line 716 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_prnt_getassettag___0(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  uint8_t taglength ;
  uint8_t getlength ;
  uint8_t offset ;
  uint8_t i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 721
  taglength = (uint8_t )0;
#line 722
  getlength = (uint8_t )0;
#line 723
  offset = (uint8_t )0;
#line 726
  rsp = ipmi_dcmi_getassettag(intf, (uint8_t )0, (uint8_t )0);
#line 727
  tmp = chk_rsp___0(rsp);
  }
#line 727
  if (tmp) {
#line 728
    return (-1);
  }
  {
#line 730
  taglength = rsp->data[1];
#line 731
  printf((char const   */* __restrict  */)"\n Asset tag: ");
  }
  {
#line 732
  while (1) {
    while_continue: /* CIL Label */ ;
#line 732
    if (! taglength) {
#line 732
      goto while_break;
    }
#line 733
    if ((int )taglength / 16) {
#line 733
      getlength = (uint8_t )16;
    } else {
#line 733
      getlength = (uint8_t )((int )taglength % 16);
    }
    {
#line 735
    rsp = ipmi_dcmi_getassettag(intf, offset, getlength);
    }
#line 739
    if ((unsigned long )rsp != (unsigned long )((void *)0)) {
#line 740
      if ((int )rsp->ccode == 128) {
#line 740
        rsp->ccode = (uint8_t )0;
      } else
#line 740
      if ((int )rsp->ccode == 129) {
#line 740
        rsp->ccode = (uint8_t )0;
      } else
#line 740
      if ((int )rsp->ccode == 130) {
#line 740
        rsp->ccode = (uint8_t )0;
      } else
#line 740
      if ((int )rsp->ccode == 131) {
#line 740
        rsp->ccode = (uint8_t )0;
      } else {
#line 740
        rsp->ccode = rsp->ccode;
      }
    }
    {
#line 742
    tmp___0 = chk_rsp___0(rsp);
    }
#line 742
    if (tmp___0) {
#line 743
      return (-1);
    }
#line 745
    i = (uint8_t )0;
    {
#line 745
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 745
      if (! ((int )i < (int )getlength)) {
#line 745
        goto while_break___0;
      }
      {
#line 746
      printf((char const   */* __restrict  */)"%c", (int )rsp->data[(int )i + 2]);
#line 745
      i = (uint8_t )((int )i + 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 748
    offset = (uint8_t )((int )offset + (int )getlength);
#line 749
    taglength = (uint8_t )((int )taglength - (int )getlength);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 751
  printf((char const   */* __restrict  */)"\n");
  }
#line 752
  return (0);
}
}
#line 788 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_prnt_setassettag___0(struct ipmi_intf *intf , uint8_t *data ) 
{ 
  struct ipmi_rs *rsp ;
  uint8_t tmpData[16] ;
  uint8_t taglength ;
  uint8_t getlength ;
  uint8_t offset ;
  uint8_t i ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 794
  taglength = (uint8_t )0;
#line 795
  getlength = (uint8_t )0;
#line 796
  offset = (uint8_t )0;
#line 800
  tmp = strlen((char const   *)data);
#line 800
  taglength = (uint8_t )tmp;
  }
#line 801
  if ((int )taglength > 64) {
    {
#line 802
    lprintf(3, "\nValue is too long.");
    }
#line 803
    return (-1);
  }
  {
#line 805
  printf((char const   */* __restrict  */)"\n Set Asset Tag: ");
  }
  {
#line 806
  while (1) {
    while_continue: /* CIL Label */ ;
#line 806
    if (! taglength) {
#line 806
      goto while_break;
    }
#line 807
    if ((int )taglength / 16) {
#line 807
      getlength = (uint8_t )16;
    } else {
#line 807
      getlength = (uint8_t )((int )taglength % 16);
    }
    {
#line 809
    memcpy((void */* __restrict  */)(tmpData), (void const   */* __restrict  */)(data + (int )offset),
           (size_t )getlength);
#line 810
    rsp = ipmi_dcmi_setassettag(intf, offset, getlength, tmpData);
#line 811
    tmp___0 = chk_rsp___0(rsp);
    }
#line 811
    if (tmp___0) {
#line 812
      return (-1);
    }
#line 814
    i = (uint8_t )0;
    {
#line 814
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 814
      if (! ((int )i < (int )getlength)) {
#line 814
        goto while_break___0;
      }
      {
#line 815
      printf((char const   */* __restrict  */)"%c", (int )tmpData[i]);
#line 814
      i = (uint8_t )((int )i + 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 817
    offset = (uint8_t )((int )offset + (int )getlength);
#line 818
    taglength = (uint8_t )((int )taglength - (int )getlength);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 820
  printf((char const   */* __restrict  */)"\n");
  }
#line 821
  return (0);
}
}
#line 852 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_prnt_getmngctrlids___0(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  uint8_t taglength ;
  uint8_t getlength ;
  uint8_t offset ;
  uint8_t i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 857
  taglength = (uint8_t )0;
#line 858
  getlength = (uint8_t )0;
#line 859
  offset = (uint8_t )0;
#line 863
  rsp = ipmi_dcmi_getmngctrlids(intf, (uint8_t )0, (uint8_t )1);
#line 865
  tmp = chk_rsp___0(rsp);
  }
#line 865
  if (tmp) {
#line 866
    return (-1);
  }
  {
#line 869
  taglength = rsp->data[1];
#line 871
  printf((char const   */* __restrict  */)"\n Get Management Controller Identifier String: ");
  }
  {
#line 872
  while (1) {
    while_continue: /* CIL Label */ ;
#line 872
    if (! taglength) {
#line 872
      goto while_break;
    }
#line 873
    if ((int )taglength / 16) {
#line 873
      getlength = (uint8_t )16;
    } else {
#line 873
      getlength = (uint8_t )((int )taglength % 16);
    }
    {
#line 875
    rsp = ipmi_dcmi_getmngctrlids(intf, offset, getlength);
#line 877
    tmp___0 = chk_rsp___0(rsp);
    }
#line 877
    if (tmp___0) {
#line 878
      return (-1);
    }
#line 880
    i = (uint8_t )0;
    {
#line 880
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 880
      if (! ((int )i < (int )getlength)) {
#line 880
        goto while_break___0;
      }
      {
#line 881
      printf((char const   */* __restrict  */)"%c", (int )rsp->data[(int )i + 2]);
#line 880
      i = (uint8_t )((int )i + 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 883
    offset = (uint8_t )((int )offset + (int )getlength);
#line 884
    taglength = (uint8_t )((int )taglength - (int )getlength);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 886
  printf((char const   */* __restrict  */)"\n");
  }
#line 887
  return (0);
}
}
#line 930 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_prnt_setmngctrlids___0(struct ipmi_intf *intf , uint8_t *data ) 
{ 
  struct ipmi_rs *rsp ;
  uint8_t tmpData[16] ;
  uint8_t taglength ;
  uint8_t getlength ;
  uint8_t offset ;
  uint8_t i ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 936
  taglength = (uint8_t )0;
#line 937
  getlength = (uint8_t )0;
#line 938
  offset = (uint8_t )0;
#line 941
  data += 0;
#line 942
  tmp = strlen((char const   *)data);
#line 942
  taglength = (uint8_t )(tmp + 1UL);
  }
#line 944
  if ((int )taglength > 64) {
    {
#line 945
    lprintf(3, "\nValue is too long.");
    }
#line 946
    return (-1);
  }
  {
#line 949
  printf((char const   */* __restrict  */)"\n Set Management Controller Identifier String Command: ");
  }
  {
#line 950
  while (1) {
    while_continue: /* CIL Label */ ;
#line 950
    if (! taglength) {
#line 950
      goto while_break;
    }
#line 951
    if ((int )taglength / 16) {
#line 951
      getlength = (uint8_t )16;
    } else {
#line 951
      getlength = (uint8_t )((int )taglength % 16);
    }
    {
#line 953
    memcpy((void */* __restrict  */)(tmpData), (void const   */* __restrict  */)(data + (int )offset),
           (size_t )getlength);
#line 954
    rsp = ipmi_dcmi_setmngctrlids(intf, offset, getlength, tmpData);
#line 958
    tmp___1 = strncmp((char const   *)(intf->name), "lanplus", (size_t )7);
    }
#line 958
    if (tmp___1) {
      {
#line 959
      tmp___0 = chk_rsp___0(rsp);
      }
#line 959
      if (tmp___0) {
#line 960
        return (-1);
      }
    }
#line 963
    i = (uint8_t )0;
    {
#line 963
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 963
      if (! ((int )i < (int )getlength)) {
#line 963
        goto while_break___0;
      }
      {
#line 964
      printf((char const   */* __restrict  */)"%c", (int )tmpData[i]);
#line 963
      i = (uint8_t )((int )i + 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 966
    offset = (uint8_t )((int )offset + (int )getlength);
#line 967
    taglength = (uint8_t )((int )taglength - (int )getlength);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 969
  printf((char const   */* __restrict  */)"\n");
  }
#line 970
  return (0);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_prnt_discvry_snsr___0(struct ipmi_intf *intf , uint8_t isnsr ) 
{ 
  int i ;
  struct ipmi_rs *rsp ;
  uint8_t records ;
  int8_t instances ;
  uint8_t offset ;
  uint16_t record_id ;
  uint8_t id_buff[16] ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1014
  i = 0;
#line 1016
  records = (uint8_t )0;
#line 1017
  instances = (int8_t )0;
#line 1018
  offset = (uint8_t )0;
#line 1019
  record_id = (uint16_t )0;
#line 1021
  rsp = ipmi_dcmi_discvry_snsr(intf, isnsr, (uint8_t )0);
#line 1022
  tmp = chk_rsp___0(rsp);
  }
#line 1022
  if (tmp) {
#line 1023
    return (-1);
  }
#line 1025
  instances = (int8_t )rsp->data[1];
#line 1026
  if ((int )instances > 1) {
#line 1026
    tmp___0 = "s";
  } else {
#line 1026
    tmp___0 = "";
  }
  {
#line 1026
  tmp___1 = val2str2((uint16_t )isnsr, dcmi_discvry_snsr_vals);
#line 1026
  printf((char const   */* __restrict  */)"\n%s: %d temperature sensor%s found:\n",
         tmp___1, (int )instances, tmp___0);
  }
  {
#line 1030
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1030
    if (! ((int )instances > 0)) {
#line 1030
      goto while_break;
    }
    {
#line 1031
    ipmi_dcmi_discvry_snsr(intf, isnsr, offset);
#line 1032
    tmp___2 = chk_rsp___0(rsp);
    }
#line 1032
    if (tmp___2) {
#line 1033
      return (-1);
    }
    {
#line 1035
    records = rsp->data[2];
#line 1039
    memcpy((void */* __restrict  */)(id_buff), (void const   */* __restrict  */)(& rsp->data[3]),
           (size_t )16);
#line 1040
    i = 0;
    }
    {
#line 1040
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1040
      if (! (i < (int )records)) {
#line 1040
        goto while_break___0;
      }
      {
#line 1042
      record_id = (uint16_t )(((int )id_buff[2 * i + 1] << 8) + (int )id_buff[2 * i]);
#line 1043
      printf((char const   */* __restrict  */)"Record ID 0x%04x: ", (int )record_id);
#line 1044
      ipmi_print_sensor_info___0(intf, record_id);
#line 1040
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1046
    offset = (uint8_t )((int )offset + 8);
#line 1047
    instances = (int8_t )((int )instances - (int )records);
  }
  while_break: /* CIL Label */ ;
  }
#line 1049
  return (0);
}
}
#line 1057 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_pwr_rd___0(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct power_reading val ;
  struct tm tm_t ;
  time_t t ;
  uint8_t msg_data[4] ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 1066
  memset((void *)(& tm_t), 0, sizeof(tm_t));
#line 1067
  memset((void *)(& t), 0, sizeof(t));
#line 1069
  msg_data[0] = (uint8_t )220;
#line 1070
  msg_data[1] = (uint8_t )1;
#line 1071
  msg_data[2] = (uint8_t )0;
#line 1072
  msg_data[3] = (uint8_t )0;
#line 1074
  memset((void *)(& req), 0, sizeof(req));
#line 1075
  req.msg.netfn = (uint8_t )44;
#line 1076
  req.msg.cmd = (uint8_t )2;
#line 1077
  req.msg.data = msg_data;
#line 1078
  req.msg.data_len = (uint16_t )4;
#line 1080
  rsp = (*(intf->sendrecv))(intf, & req);
#line 1082
  tmp = chk_rsp___0(rsp);
  }
#line 1082
  if (tmp) {
#line 1083
    return (-1);
  }
  {
#line 1087
  memcpy((void */* __restrict  */)(& val), (void const   */* __restrict  */)(rsp->data),
         sizeof(val));
#line 1088
  t = (time_t )val.time_stamp;
#line 1089
  gmtime_r((time_t const   */* __restrict  */)(& t), (struct tm */* __restrict  */)(& tm_t));
#line 1090
  printf((char const   */* __restrict  */)"\n");
#line 1091
  printf((char const   */* __restrict  */)"    Instantaneous power reading:              %8d Watts\n",
         (int )val.curr_pwr);
#line 1093
  printf((char const   */* __restrict  */)"    Minimum during sampling period:           %8d Watts\n",
         (int )val.min_sample);
#line 1095
  printf((char const   */* __restrict  */)"    Maximum during sampling period:           %8d Watts\n",
         (int )val.max_sample);
#line 1097
  printf((char const   */* __restrict  */)"    Average power reading over sample period: %8d Watts\n",
         (int )val.avg_pwr);
#line 1099
  tmp___0 = asctime((struct tm  const  *)(& tm_t));
#line 1099
  printf((char const   */* __restrict  */)"    IPMI timestamp:                           %s",
         tmp___0);
#line 1101
  printf((char const   */* __restrict  */)"    Sampling period:                          %08d Milliseconds\n",
         val.sample);
#line 1103
  printf((char const   */* __restrict  */)"    Power reading state is:                   ");
  }
#line 1105
  if (((int )val.state & 64) == 64) {
    {
#line 1106
    printf((char const   */* __restrict  */)"activated");
    }
  } else {
    {
#line 1108
    printf((char const   */* __restrict  */)"deactivated");
    }
  }
  {
#line 1110
  printf((char const   */* __restrict  */)"\n\n");
  }
#line 1111
  return (0);
}
}
#line 1240 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_prnt_get_temp_readings___0(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  int i ;
  int j ;
  int tota_inst ;
  int get_inst ;
  int offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1244
  offset = 0;
#line 1246
  printf((char const   */* __restrict  */)"\n\tEntity ID\t\t\tEntity Instance\t   Temp. Readings");
#line 1247
  i = 0;
  }
  {
#line 1247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1247
    if (! ((unsigned long )dcmi_temp_read_vals[i].str != (unsigned long )((void *)0))) {
#line 1247
      goto while_break;
    }
    {
#line 1249
    rsp = ipmi_dcmi_get_temp_readings(intf, (uint8_t )dcmi_temp_read_vals[i].val,
                                      (uint8_t )0, (uint8_t )0);
#line 1251
    tmp = chk_rsp___0(rsp);
    }
#line 1251
    if (tmp) {
#line 1252
      goto __Cont;
    }
#line 1255
    offset = 0;
#line 1256
    tota_inst = (int )rsp->data[1];
    {
#line 1257
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1257
      if (! (tota_inst > 0)) {
#line 1257
        goto while_break___0;
      }
#line 1258
      if (tota_inst / 8) {
#line 1258
        get_inst = 8;
      } else {
#line 1258
        get_inst = tota_inst % 8;
      }
      {
#line 1261
      rsp = ipmi_dcmi_get_temp_readings(intf, (uint8_t )dcmi_temp_read_vals[i].val,
                                        (uint8_t )offset, (uint8_t )0);
#line 1263
      tmp___0 = chk_rsp___0(rsp);
      }
#line 1263
      if (tmp___0) {
#line 1264
        goto while_continue___0;
      }
#line 1269
      j = 0;
      {
#line 1269
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1269
        if (! (j < (int )rsp->data[2] * 2)) {
#line 1269
          goto while_break___1;
        }
        {
#line 1271
        printf((char const   */* __restrict  */)"\n%s", dcmi_temp_read_vals[i].desc);
        }
#line 1272
        if ((int )rsp->data[j + 3] >> 7) {
#line 1272
          tmp___1 = '-';
        } else {
#line 1272
          tmp___1 = '+';
        }
        {
#line 1272
        printf((char const   */* __restrict  */)"\t\t%i\t\t%c%i C", (int )rsp->data[j + 4],
               tmp___1, (int )rsp->data[j + 3] & 127);
#line 1269
        j += 2;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1276
      offset += get_inst;
#line 1277
      tota_inst -= get_inst;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1247
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1280
  return (0);
}
}
#line 1311 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_prnt_getconfparam___0(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  int dcmi_conf_params ;
  int param_selector ;
  uint16_t tmp_value ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 1315
  dcmi_conf_params = 5;
#line 1317
  tmp_value = (uint16_t )0;
#line 1319
  param_selector = 2;
  {
#line 1319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1319
    if (! (param_selector <= dcmi_conf_params)) {
#line 1319
      goto while_break;
    }
    {
#line 1321
    rsp = ipmi_dcmi_getconfparam(intf, param_selector);
#line 1322
    tmp = chk_rsp___0(rsp);
    }
#line 1322
    if (tmp) {
#line 1323
      return (-1);
    }
    {
#line 1327
    if (param_selector == 2) {
#line 1327
      goto case_2;
    }
#line 1335
    if (param_selector == 3) {
#line 1335
      goto case_3;
    }
#line 1339
    if (param_selector == 4) {
#line 1339
      goto case_4;
    }
#line 1343
    if (param_selector == 5) {
#line 1343
      goto case_5;
    }
#line 1347
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 1328
    tmp_value = (uint16_t )((int )rsp->data[4] & 1);
#line 1329
    printf((char const   */* __restrict  */)"\n\tDHCP Discovery method\t: ");
    }
#line 1330
    if (tmp_value) {
#line 1330
      tmp___0 = "enabled";
    } else {
#line 1330
      tmp___0 = "disabled";
    }
    {
#line 1330
    printf((char const   */* __restrict  */)"\n\t\tManagement Controller ID String is %s",
           tmp___0);
    }
#line 1332
    if ((int )rsp->data[4] & 2) {
#line 1332
      tmp___1 = "enabled";
    } else {
#line 1332
      tmp___1 = "disabled";
    }
    {
#line 1332
    printf((char const   */* __restrict  */)"\n\t\tVendor class identifier DCMI IANA and Vendor class-specific Informationa are %s",
           tmp___1);
    }
#line 1334
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1336
    printf((char const   */* __restrict  */)"\n\tInitial timeout interval\t: %i seconds",
           (int )rsp->data[4]);
    }
#line 1338
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1340
    printf((char const   */* __restrict  */)"\n\tServer contact timeout interval\t: %i seconds",
           (int )rsp->data[4] + ((int )rsp->data[5] << 8));
    }
#line 1342
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 1344
    printf((char const   */* __restrict  */)"\n\tServer contact retry interval\t: %i seconds",
           (int )rsp->data[4] + ((int )rsp->data[5] << 8));
    }
#line 1346
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1348
    printf((char const   */* __restrict  */)"\n\tConfiguration Parameter not supported.");
    }
    switch_break: /* CIL Label */ ;
    }
#line 1319
    param_selector ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1351
  return (0);
}
}
#line 1433 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_pwr_prnt_glimit___0(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct power_limit val ;
  uint8_t realCc ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 1438
  realCc = (uint8_t )255;
#line 1440
  rsp = ipmi_dcmi_pwr_glimit(intf);
  }
#line 1444
  if ((unsigned long )rsp != (unsigned long )((void *)0)) {
#line 1445
    realCc = rsp->ccode;
#line 1446
    if ((int )rsp->ccode == 128) {
#line 1446
      rsp->ccode = (uint8_t )0;
    } else {
#line 1446
      rsp->ccode = rsp->ccode;
    }
  }
  {
#line 1448
  tmp = chk_rsp___0(rsp);
  }
#line 1448
  if (tmp) {
#line 1449
    return (-1);
  }
  {
#line 1453
  memcpy((void */* __restrict  */)(& val), (void const   */* __restrict  */)(rsp->data),
         sizeof(val));
  }
#line 1454
  if ((int )realCc == 0) {
#line 1454
    tmp___0 = "Power Limit Active";
  } else {
#line 1454
    tmp___0 = "No Active Power Limit";
  }
  {
#line 1454
  printf((char const   */* __restrict  */)"\n    Current Limit State: %s\n", tmp___0);
#line 1457
  tmp___1 = val2str2((uint16_t )val.action, dcmi_pwrmgmt_action_vals);
#line 1457
  printf((char const   */* __restrict  */)"    Exception actions:   %s\n", tmp___1);
#line 1459
  printf((char const   */* __restrict  */)"    Power Limit:         %i Watts\n", (int )val.limit);
#line 1460
  printf((char const   */* __restrict  */)"    Correction time:     %i milliseconds\n",
         val.correction);
#line 1461
  printf((char const   */* __restrict  */)"    Sampling period:     %i seconds\n",
         (int )val.sample);
#line 1462
  printf((char const   */* __restrict  */)"\n");
  }
#line 1463
  return (0);
}
}
#line 1478 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_pwr_slimit___0(struct ipmi_intf *intf , char const   *option ,
                                    char const   *value ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct power_limit val ;
  uint8_t msg_data[15] ;
  uint32_t lvalue ;
  int tmp ;
  int tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1486
  lvalue = (uint32_t )0;
#line 1489
  tmp = str2uint(value, & lvalue);
  }
#line 1489
  if (tmp != 0) {
    {
#line 1490
    lprintf(3, "Given %s \'%s\' is invalid.", option, value);
    }
#line 1492
    return (-1);
  }
  {
#line 1495
  rsp = ipmi_dcmi_pwr_glimit(intf);
  }
#line 1509
  if ((unsigned long )rsp != (unsigned long )((void *)0)) {
#line 1510
    if ((int )rsp->ccode == 128) {
#line 1510
      rsp->ccode = (uint8_t )0;
    } else {
#line 1510
      rsp->ccode = rsp->ccode;
    }
  }
  {
#line 1512
  tmp___0 = chk_rsp___0(rsp);
  }
#line 1512
  if (tmp___0) {
#line 1513
    return (-1);
  }
  {
#line 1515
  memcpy((void */* __restrict  */)(& val), (void const   */* __restrict  */)(rsp->data),
         sizeof(val));
#line 1532
  tmp___1 = str2val2(option, dcmi_pwrmgmt_set_usage_vals);
  }
  {
#line 1533
  if ((int )tmp___1 == 0) {
#line 1533
    goto case_0;
  }
#line 1549
  if ((int )tmp___1 == 1) {
#line 1549
    goto case_1___0;
  }
#line 1553
  if ((int )tmp___1 == 2) {
#line 1553
    goto case_2;
  }
#line 1557
  if ((int )tmp___1 == 3) {
#line 1557
    goto case_3;
  }
#line 1561
  if ((int )tmp___1 == 255) {
#line 1561
    goto case_255___0;
  }
#line 1532
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1535
  tmp___2 = str2val2(value, dcmi_pwrmgmt_action_vals);
  }
  {
#line 1536
  if ((int )tmp___2 == 1) {
#line 1536
    goto case_1;
  }
#line 1540
  if ((int )tmp___2 == 17) {
#line 1540
    goto case_17;
  }
#line 1544
  if ((int )tmp___2 == 255) {
#line 1544
    goto case_255;
  }
#line 1535
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 1538
  val.action = (uint8_t )1;
#line 1539
  goto switch_break___0;
  case_17: /* CIL Label */ 
#line 1542
  val.action = (uint8_t )17;
#line 1543
  goto switch_break___0;
  case_255: /* CIL Label */ 
#line 1546
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
#line 1548
  goto switch_break;
  case_1___0: /* CIL Label */ 
#line 1551
  val.limit = *((uint16_t *)(& lvalue));
#line 1552
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1555
  val.correction = lvalue;
#line 1556
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1559
  val.sample = *((uint16_t *)(& lvalue));
#line 1560
  goto switch_break;
  case_255___0: /* CIL Label */ 
#line 1563
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1566
  msg_data[0] = val.grp_id;
#line 1567
  msg_data[1] = (uint8_t )0;
#line 1568
  msg_data[2] = (uint8_t )0;
#line 1569
  msg_data[3] = (uint8_t )0;
#line 1570
  msg_data[4] = val.action;
#line 1573
  *((uint16_t *)(& msg_data[5])) = val.limit;
#line 1578
  *((uint32_t *)(& msg_data[7])) = val.correction;
#line 1584
  msg_data[11] = (uint8_t )0;
#line 1585
  msg_data[12] = (uint8_t )0;
#line 1587
  *((uint16_t *)(& msg_data[13])) = val.sample;
#line 1589
  memset((void *)(& req), 0, sizeof(req));
#line 1590
  req.msg.netfn = (uint8_t )44;
#line 1591
  req.msg.cmd = (uint8_t )4;
#line 1592
  req.msg.data = msg_data;
#line 1594
  req.msg.data_len = (uint16_t )15;
#line 1596
  rsp = (*(intf->sendrecv))(intf, & req);
#line 1598
  tmp___3 = chk_rsp___0(rsp);
  }
#line 1598
  if (tmp___3) {
#line 1599
    return (-1);
  }
#line 1601
  return (0);
}
}
#line 1610 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_dcmi_pwr_actdeact___0(struct ipmi_intf *intf , uint8_t option ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[4] ;
  int tmp ;

  {
  {
#line 1617
  msg_data[0] = (uint8_t )220;
#line 1618
  msg_data[1] = option;
#line 1619
  msg_data[2] = (uint8_t )0;
#line 1620
  msg_data[3] = (uint8_t )0;
#line 1622
  memset((void *)(& req), 0, sizeof(req));
#line 1623
  req.msg.netfn = (uint8_t )44;
#line 1624
  req.msg.cmd = (uint8_t )5;
#line 1625
  req.msg.data = msg_data;
#line 1626
  req.msg.data_len = (uint16_t )4;
#line 1628
  rsp = (*(intf->sendrecv))(intf, & req);
#line 1629
  tmp = chk_rsp___0(rsp);
  }
#line 1629
  if (tmp) {
#line 1630
    return (-1);
  }
  {
#line 1632
  printf((char const   */* __restrict  */)"\n    Power limit successfully ");
  }
#line 1633
  if ((int )option == 0) {
    {
#line 1634
    printf((char const   */* __restrict  */)"deactivated");
    }
  } else {
    {
#line 1636
    printf((char const   */* __restrict  */)"activated");
    }
  }
  {
#line 1638
  printf((char const   */* __restrict  */)"\n");
  }
#line 1639
  return (0);
}
}
#line 2054 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_dcmi.c"
static int ipmi_print_sensor_info___0(struct ipmi_intf *intf , uint16_t rec_id ) 
{ 
  struct sdr_get_rs *header ;
  struct ipmi_sdr_iterator *itr ;
  int rc ;
  uint8_t *rec ;

  {
  {
#line 2059
  rc = 0;
#line 2060
  rec = (uint8_t *)((void *)0);
#line 2062
  itr = ipmi_sdr_start(intf, 0);
  }
#line 2063
  if ((unsigned long )itr == (unsigned long )((void *)0)) {
    {
#line 2064
    lprintf(3, "Unable to open SDR for reading");
    }
#line 2065
    return (-1);
  }
  {
#line 2068
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2068
    header = ipmi_sdr_get_next_header(intf, itr);
    }
#line 2068
    if (! ((unsigned long )header != (unsigned long )((void *)0))) {
#line 2068
      goto while_break;
    }
#line 2069
    if ((int )header->id == (int )rec_id) {
#line 2070
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2073
  if ((unsigned long )header == (unsigned long )((void *)0)) {
    {
#line 2074
    lprintf(7, "header == NULL");
#line 2075
    ipmi_sdr_end(intf, itr);
    }
#line 2076
    return (-1);
  }
  {
#line 2079
  rec = ipmi_sdr_get_record(intf, header, itr);
  }
#line 2080
  if ((unsigned long )rec == (unsigned long )((void *)0)) {
    {
#line 2081
    lprintf(7, "rec == NULL");
#line 2082
    ipmi_sdr_end(intf, itr);
    }
#line 2083
    return (-1);
  }
#line 2085
  if ((int )header->type == 1) {
    {
#line 2087
    rc = ipmi_sdr_print_rawentry(intf, header->type, rec, (int )header->length);
    }
  } else
#line 2085
  if ((int )header->type == 2) {
    {
#line 2087
    rc = ipmi_sdr_print_rawentry(intf, header->type, rec, (int )header->length);
    }
  } else {
#line 2090
    rc = -1;
  }
  {
#line 2092
  free((void *)rec);
#line 2093
  rec = (uint8_t *)((void *)0);
#line 2094
  ipmi_sdr_end(intf, itr);
  }
#line 2095
  return (rc);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
static int ipmi_chassis_print_power_status___0(struct ipmi_intf *intf ) 
{ 
  int ps ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 76
  tmp = ipmi_chassis_power_status(intf);
#line 76
  ps = tmp;
  }
#line 78
  if (ps < 0) {
#line 79
    return (-1);
  }
#line 81
  if (ps) {
#line 81
    tmp___0 = "on";
  } else {
#line 81
    tmp___0 = "off";
  }
  {
#line 81
  printf((char const   */* __restrict  */)"Chassis Power is %s\n", tmp___0);
  }
#line 83
  return (0);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
static int ipmi_chassis_identify___0(struct ipmi_intf *intf , char *arg ) 
{ 
  struct ipmi_rq req ;
  struct ipmi_rs *rsp ;
  int rc ;
  struct __anonstruct_identify_data_53___0 identify_data ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 127
  rc = -3;
#line 129
  identify_data.interval = (uint8_t )0;
#line 129
  identify_data.force_on = (uint8_t )0;
#line 134
  memset((void *)(& req), 0, sizeof(req));
#line 135
  req.msg.netfn = (uint8_t )0;
#line 136
  req.msg.cmd = (uint8_t )4;
  }
#line 138
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
    {
#line 139
    tmp = strncmp((char const   *)arg, "force", (size_t )5);
    }
#line 139
    if (tmp == 0) {
#line 140
      identify_data.force_on = (uint8_t )1;
    } else {
      {
#line 142
      rc = str2uchar((char const   *)arg, & identify_data.interval);
      }
#line 142
      if (rc != 0) {
#line 143
        if (rc == -2) {
          {
#line 144
          lprintf(3, "Invalid interval given.");
          }
        } else {
          {
#line 146
          lprintf(3, "Given interval is too big.");
          }
        }
#line 148
        return (-1);
      }
    }
#line 151
    req.msg.data = (uint8_t *)(& identify_data);
#line 157
    if (identify_data.force_on) {
#line 157
      req.msg.data_len = (uint16_t )2;
    } else {
#line 157
      req.msg.data_len = (uint16_t )1;
    }
  }
  {
#line 160
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 161
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 162
    lprintf(3, "Unable to set Chassis Identify");
    }
#line 163
    return (-1);
  }
#line 165
  if ((int )rsp->ccode > 0) {
    {
#line 166
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 166
    lprintf(3, "Set Chassis Identify failed: %s", tmp___0);
    }
#line 168
    if ((int )identify_data.force_on != 0) {
      {
#line 173
      lprintf(4, "Chassis may not support Force Identify On\n");
      }
    }
#line 175
    return (-1);
  }
  {
#line 178
  printf((char const   */* __restrict  */)"Chassis identify interval: ");
  }
#line 179
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    {
#line 180
    printf((char const   */* __restrict  */)"default (15 seconds)\n");
    }
  } else
#line 182
  if ((int )identify_data.force_on != 0) {
    {
#line 183
    printf((char const   */* __restrict  */)"indefinite\n");
    }
  } else
#line 185
  if ((int )identify_data.interval == 0) {
    {
#line 186
    printf((char const   */* __restrict  */)"off\n");
    }
  } else {
    {
#line 188
    printf((char const   */* __restrict  */)"%i seconds\n", (int )identify_data.interval);
    }
  }
#line 191
  return (0);
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
static int ipmi_chassis_poh___0(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t mins_per_count ;
  uint32_t count ;
  float minutes ;
  uint32_t days ;
  uint32_t hours ;
  char const   *tmp ;

  {
  {
#line 204
  memset((void *)(& req), 0, sizeof(req));
#line 205
  req.msg.netfn = (uint8_t )0;
#line 206
  req.msg.cmd = (uint8_t )15;
#line 208
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 209
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 210
    lprintf(3, "Unable to get Chassis Power-On-Hours");
    }
#line 211
    return (-1);
  }
#line 213
  if ((int )rsp->ccode > 0) {
    {
#line 214
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 214
    lprintf(3, "Get Chassis Power-On-Hours failed: %s", tmp);
    }
#line 216
    return (-1);
  }
  {
#line 219
  mins_per_count = rsp->data[0];
#line 220
  memcpy((void */* __restrict  */)(& count), (void const   */* __restrict  */)(rsp->data + 1),
         (size_t )4);
#line 225
  minutes = (float )count * (float )mins_per_count;
#line 226
  days = (uint32_t )(minutes / (float )1440);
#line 227
  minutes -= (float )days * (float )1440;
#line 228
  hours = (uint32_t )(minutes / (float )60);
#line 229
  minutes -= (float )(hours * 60U);
  }
#line 231
  if ((int )mins_per_count < 60) {
    {
#line 232
    printf((char const   */* __restrict  */)"POH Counter  : %i days, %i hours, %li minutes\n",
           days, hours, (long )minutes);
    }
  } else {
    {
#line 235
    printf((char const   */* __restrict  */)"POH Counter  : %i days, %i hours\n",
           days, hours);
    }
  }
#line 238
  return (0);
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
static int ipmi_chassis_restart_cause___0(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;

  {
  {
#line 247
  memset((void *)(& req), 0, sizeof(req));
#line 248
  req.msg.netfn = (uint8_t )0;
#line 249
  req.msg.cmd = (uint8_t )7;
#line 251
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 252
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 253
    lprintf(3, "Unable to get Chassis Restart Cause");
    }
#line 254
    return (-1);
  }
#line 256
  if ((int )rsp->ccode > 0) {
    {
#line 257
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 257
    lprintf(3, "Get Chassis Restart Cause failed: %s", tmp);
    }
#line 259
    return (-1);
  }
  {
#line 262
  printf((char const   */* __restrict  */)"System restart cause: ");
  }
  {
#line 265
  if (((int )rsp->data[0] & 15) == 0) {
#line 265
    goto case_0;
  }
#line 268
  if (((int )rsp->data[0] & 15) == 1) {
#line 268
    goto case_1;
  }
#line 271
  if (((int )rsp->data[0] & 15) == 2) {
#line 271
    goto case_2;
  }
#line 274
  if (((int )rsp->data[0] & 15) == 3) {
#line 274
    goto case_3;
  }
#line 277
  if (((int )rsp->data[0] & 15) == 4) {
#line 277
    goto case_4;
  }
#line 280
  if (((int )rsp->data[0] & 15) == 5) {
#line 280
    goto case_5;
  }
#line 283
  if (((int )rsp->data[0] & 15) == 6) {
#line 283
    goto case_6;
  }
#line 286
  if (((int )rsp->data[0] & 15) == 7) {
#line 286
    goto case_7;
  }
#line 289
  if (((int )rsp->data[0] & 15) == 8) {
#line 289
    goto case_8;
  }
#line 292
  if (((int )rsp->data[0] & 15) == 9) {
#line 292
    goto case_9;
  }
#line 295
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 266
  printf((char const   */* __restrict  */)"unknown\n");
  }
#line 267
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 269
  printf((char const   */* __restrict  */)"chassis power control command\n");
  }
#line 270
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 272
  printf((char const   */* __restrict  */)"reset via pushbutton\n");
  }
#line 273
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 275
  printf((char const   */* __restrict  */)"power-up via pushbutton\n");
  }
#line 276
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 278
  printf((char const   */* __restrict  */)"watchdog expired\n");
  }
#line 279
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 281
  printf((char const   */* __restrict  */)"OEM\n");
  }
#line 282
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 284
  printf((char const   */* __restrict  */)"power-up due to always-restore power policy\n");
  }
#line 285
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 287
  printf((char const   */* __restrict  */)"power-up due to restore-previous power policy\n");
  }
#line 288
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 290
  printf((char const   */* __restrict  */)"reset via PEF\n");
  }
#line 291
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 293
  printf((char const   */* __restrict  */)"power-cycle via PEF\n");
  }
#line 294
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 296
  printf((char const   */* __restrict  */)"invalid\n");
  }
  switch_break: /* CIL Label */ ;
  }
#line 299
  return (0);
}
}
#line 385 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
static int ipmi_chassis_selftest___0(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;
  int i ;
  struct valstr broken_dev_vals[9] ;
  char const   *tmp___0 ;

  {
  {
#line 391
  memset((void *)(& req), 0, sizeof(req));
#line 392
  req.msg.netfn = (uint8_t )6;
#line 393
  req.msg.cmd = (uint8_t )4;
#line 395
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 396
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 397
    lprintf(3, "Error sending Get Self Test command");
    }
#line 398
    return (-1);
  }
#line 400
  if ((int )rsp->ccode > 0) {
    {
#line 401
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 401
    lprintf(3, "Error sending Get Self Test command: %s", tmp);
    }
#line 403
    return (-1);
  }
  {
#line 406
  printf((char const   */* __restrict  */)"Self Test Results    : ");
  }
  {
#line 408
  if ((int )rsp->data[0] == 85) {
#line 408
    goto case_85;
  }
#line 412
  if ((int )rsp->data[0] == 86) {
#line 412
    goto case_86;
  }
#line 416
  if ((int )rsp->data[0] == 87) {
#line 416
    goto case_87;
  }
#line 440
  if ((int )rsp->data[0] == 88) {
#line 440
    goto case_88;
  }
#line 444
  goto switch_default;
  case_85: /* CIL Label */ 
  {
#line 409
  printf((char const   */* __restrict  */)"passed\n");
  }
#line 410
  goto switch_break;
  case_86: /* CIL Label */ 
  {
#line 413
  printf((char const   */* __restrict  */)"not implemented\n");
  }
#line 414
  goto switch_break;
  case_87: /* CIL Label */ 
  {
#line 419
  broken_dev_vals[0].val = (uint16_t )0;
#line 419
  broken_dev_vals[0].str = "firmware corrupted";
#line 419
  broken_dev_vals[1].val = (uint16_t )1;
#line 419
  broken_dev_vals[1].str = "boot block corrupted";
#line 419
  broken_dev_vals[2].val = (uint16_t )2;
#line 419
  broken_dev_vals[2].str = "FRU Internal Use Area corrupted";
#line 419
  broken_dev_vals[3].val = (uint16_t )3;
#line 419
  broken_dev_vals[3].str = "SDR Repository empty";
#line 419
  broken_dev_vals[4].val = (uint16_t )4;
#line 419
  broken_dev_vals[4].str = "IPMB not responding";
#line 419
  broken_dev_vals[5].val = (uint16_t )5;
#line 419
  broken_dev_vals[5].str = "cannot access BMC FRU";
#line 419
  broken_dev_vals[6].val = (uint16_t )6;
#line 419
  broken_dev_vals[6].str = "cannot access SDR Repository";
#line 419
  broken_dev_vals[7].val = (uint16_t )7;
#line 419
  broken_dev_vals[7].str = "cannot access SEL Device";
#line 419
  broken_dev_vals[8].val = (uint16_t )255;
#line 419
  broken_dev_vals[8].str = (char const   *)((void *)0);
#line 430
  printf((char const   */* __restrict  */)"device error\n");
#line 431
  i = 0;
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! (i < 8)) {
#line 431
      goto while_break;
    }
#line 432
    if ((int )rsp->data[1] & (1 << i)) {
      {
#line 433
      tmp___0 = val2str((uint16_t )i, (struct valstr  const  *)(broken_dev_vals));
#line 433
      printf((char const   */* __restrict  */)"                       [%s]\n", tmp___0);
      }
    }
#line 431
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 438
  goto switch_break;
  case_88: /* CIL Label */ 
  {
#line 441
  printf((char const   */* __restrict  */)"Fatal hardware error: %02xh\n", (int )rsp->data[1]);
  }
#line 442
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 445
  printf((char const   */* __restrict  */)"Device-specific failure %02xh:%02xh\n",
         (int )rsp->data[0], (int )rsp->data[1]);
  }
#line 447
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 450
  return (0);
}
}
#line 453 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
static int ipmi_chassis_set_bootparam___0(struct ipmi_intf *intf , uint8_t param ,
                                          uint8_t *data , int len ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[16] ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 460
  memset((void *)(msg_data), 0, (size_t )16);
#line 461
  msg_data[0] = (uint8_t )((int )param & 127);
#line 462
  memcpy((void */* __restrict  */)(msg_data + 1), (void const   */* __restrict  */)data,
         (size_t )len);
#line 464
  memset((void *)(& req), 0, sizeof(req));
#line 465
  req.msg.netfn = (uint8_t )0;
#line 466
  req.msg.cmd = (uint8_t )8;
#line 467
  req.msg.data = msg_data;
#line 468
  req.msg.data_len = (uint16_t )(len + 1);
#line 470
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 471
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 472
    lprintf(3, "Error setting Chassis Boot Parameter %d", (int )param);
    }
#line 473
    return (-1);
  }
#line 475
  if ((int )rsp->ccode > 0) {
#line 476
    if ((int )param != 0) {
      {
#line 477
      tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 477
      lprintf(3, "Set Chassis Boot Parameter %d failed: %s", (int )param, tmp);
      }
    }
#line 480
    return (-1);
  }
  {
#line 483
  tmp___0 = buf2str(data, len);
#line 483
  lprintf(7, "Chassis Set Boot Parameter %d to %s", (int )param, tmp___0);
  }
#line 484
  return (0);
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
static int ipmi_chassis_get_bootparam___0(struct ipmi_intf *intf , char *arg ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[3] ;
  uint8_t param_id ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  unsigned long session_id ;
  unsigned long timestamp ;
  char time_buf[40] ;
  time_t out_time ;
  struct tm *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 493
  param_id = (uint8_t )0;
#line 495
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 496
    return (-1);
  }
  {
#line 498
  tmp = str2uchar((char const   *)arg, & param_id);
  }
#line 498
  if (tmp != 0) {
    {
#line 499
    lprintf(3, "Invalid parameter \'%s\' given instead of bootparam.", arg);
    }
#line 501
    return (-1);
  }
  {
#line 504
  memset((void *)(msg_data), 0, (size_t )3);
#line 506
  msg_data[0] = (uint8_t )((int )param_id & 127);
#line 507
  msg_data[1] = (uint8_t )0;
#line 508
  msg_data[2] = (uint8_t )0;
#line 510
  memset((void *)(& req), 0, sizeof(req));
#line 511
  req.msg.netfn = (uint8_t )0;
#line 512
  req.msg.cmd = (uint8_t )9;
#line 513
  req.msg.data = msg_data;
#line 514
  req.msg.data_len = (uint16_t )3;
#line 516
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 517
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 518
    lprintf(3, "Error Getting Chassis Boot Parameter %s", arg);
    }
#line 519
    return (-1);
  }
#line 521
  if ((int )rsp->ccode > 0) {
    {
#line 522
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 522
    lprintf(3, "Get Chassis Boot Parameter %s failed: %s", arg, tmp___0);
    }
#line 524
    return (-1);
  }
#line 527
  if (verbose > 2) {
    {
#line 528
    printbuf((uint8_t const   *)(rsp->data), rsp->data_len, "Boot Option");
    }
  }
  {
#line 530
  param_id = (uint8_t )0;
#line 531
  param_id = (uint8_t )((int )rsp->data[1] & 127);
#line 533
  printf((char const   */* __restrict  */)"Boot parameter version: %d\n", (int )rsp->data[0]);
  }
#line 534
  if ((int )rsp->data[1] & 128) {
#line 534
    tmp___1 = "invalid/locked";
  } else {
#line 534
    tmp___1 = "valid/unlocked";
  }
  {
#line 534
  printf((char const   */* __restrict  */)"Boot parameter %d is %s\n", (int )rsp->data[1] & 127,
         tmp___1);
#line 536
  tmp___2 = buf2str(rsp->data + 2, rsp->data_len - 2);
#line 536
  printf((char const   */* __restrict  */)"Boot parameter data: %s\n", tmp___2);
  }
  {
#line 540
  if ((int )param_id == 0) {
#line 540
    goto case_0;
  }
#line 552
  if ((int )param_id == 1) {
#line 552
    goto case_1___0;
  }
#line 565
  if ((int )param_id == 2) {
#line 565
    goto case_2___0;
  }
#line 581
  if ((int )param_id == 3) {
#line 581
    goto case_3;
  }
#line 603
  if ((int )param_id == 4) {
#line 603
    goto case_4;
  }
#line 625
  if ((int )param_id == 5) {
#line 625
    goto case_5;
  }
#line 705
  if ((int )param_id == 6) {
#line 705
    goto case_6___0;
  }
#line 743
  if ((int )param_id == 7) {
#line 743
    goto case_7;
  }
#line 749
  goto switch_default___4;
  case_0: /* CIL Label */ 
  {
#line 542
  printf((char const   */* __restrict  */)" Set In Progress : ");
  }
  {
#line 545
  if (((int )rsp->data[2] & 3) == 0) {
#line 545
    goto case_0___0;
  }
#line 546
  if (((int )rsp->data[2] & 3) == 1) {
#line 546
    goto case_1;
  }
#line 547
  if (((int )rsp->data[2] & 3) == 2) {
#line 547
    goto case_2;
  }
#line 548
  goto switch_default;
  case_0___0: /* CIL Label */ 
  {
#line 545
  printf((char const   */* __restrict  */)"set complete\n");
  }
#line 545
  goto switch_break___0;
  case_1: /* CIL Label */ 
  {
#line 546
  printf((char const   */* __restrict  */)"set in progress\n");
  }
#line 546
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 547
  printf((char const   */* __restrict  */)"commit write\n");
  }
#line 547
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 548
  printf((char const   */* __restrict  */)"error, reserved bit\n");
  }
#line 548
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 551
  goto switch_break;
  case_1___0: /* CIL Label */ 
  {
#line 554
  printf((char const   */* __restrict  */)" Service Partition Selector : ");
  }
#line 555
  if ((int )rsp->data[2] == 0) {
    {
#line 557
    printf((char const   */* __restrict  */)"unspecified\n");
    }
  } else {
    {
#line 561
    printf((char const   */* __restrict  */)"%d\n", (int )rsp->data[2]);
    }
  }
#line 564
  goto switch_break;
  case_2___0: /* CIL Label */ 
  {
#line 567
  printf((char const   */* __restrict  */)" Service Partition Scan :\n");
  }
#line 568
  if (((int )rsp->data[2] & 3) != 0) {
#line 570
    if (((int )rsp->data[2] & 1) == 1) {
      {
#line 571
      printf((char const   */* __restrict  */)"     - Request BIOS to scan\n");
      }
    }
#line 572
    if (((int )rsp->data[2] & 2) == 2) {
      {
#line 573
      printf((char const   */* __restrict  */)"     - Service Partition Discovered\n");
      }
    }
  } else {
    {
#line 577
    printf((char const   */* __restrict  */)"     No flag set\n");
    }
  }
#line 580
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 583
  printf((char const   */* __restrict  */)" BMC boot flag valid bit clearing :\n");
  }
#line 584
  if (((int )rsp->data[2] & 31) != 0) {
#line 586
    if (((int )rsp->data[2] & 16) == 16) {
      {
#line 587
      printf((char const   */* __restrict  */)"     - Don\'t clear valid bit on reset/power cycle cause by PEF\n");
      }
    }
#line 588
    if (((int )rsp->data[2] & 8) == 8) {
      {
#line 589
      printf((char const   */* __restrict  */)"     - Don\'t automatically clear boot flag valid bit on timeout\n");
      }
    }
#line 590
    if (((int )rsp->data[2] & 4) == 4) {
      {
#line 591
      printf((char const   */* __restrict  */)"     - Don\'t clear valid bit on reset/power cycle cause by watchdog\n");
      }
    }
#line 592
    if (((int )rsp->data[2] & 2) == 2) {
      {
#line 593
      printf((char const   */* __restrict  */)"     - Don\'t clear valid bit on push button reset // soft reset\n");
      }
    }
#line 594
    if (((int )rsp->data[2] & 1) == 1) {
      {
#line 595
      printf((char const   */* __restrict  */)"     - Don\'t clear valid bit on power up via power push button or wake event\n");
      }
    }
  } else {
    {
#line 599
    printf((char const   */* __restrict  */)"     No flag set\n");
    }
  }
#line 602
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 605
  printf((char const   */* __restrict  */)" Boot Info Acknowledge :\n");
  }
#line 606
  if (((int )rsp->data[3] & 31) != 0) {
#line 608
    if (((int )rsp->data[3] & 16) == 16) {
      {
#line 609
      printf((char const   */* __restrict  */)"    - OEM has handled boot info\n");
      }
    }
#line 610
    if (((int )rsp->data[3] & 8) == 8) {
      {
#line 611
      printf((char const   */* __restrict  */)"    - SMS has handled boot info\n");
      }
    }
#line 612
    if (((int )rsp->data[3] & 4) == 4) {
      {
#line 613
      printf((char const   */* __restrict  */)"    - OS // service partition has handled boot info\n");
      }
    }
#line 614
    if (((int )rsp->data[3] & 2) == 2) {
      {
#line 615
      printf((char const   */* __restrict  */)"    - OS Loader has handled boot info\n");
      }
    }
#line 616
    if (((int )rsp->data[3] & 1) == 1) {
      {
#line 617
      printf((char const   */* __restrict  */)"    - BIOS/POST has handled boot info\n");
      }
    }
  } else {
    {
#line 621
    printf((char const   */* __restrict  */)"     No flag set\n");
    }
  }
#line 624
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 627
  printf((char const   */* __restrict  */)" Boot Flags :\n");
  }
#line 629
  if (((int )rsp->data[2] & 128) == 128) {
    {
#line 630
    printf((char const   */* __restrict  */)"   - Boot Flag Valid\n");
    }
  } else {
    {
#line 632
    printf((char const   */* __restrict  */)"   - Boot Flag Invalid\n");
    }
  }
#line 634
  if (((int )rsp->data[2] & 64) == 64) {
    {
#line 635
    printf((char const   */* __restrict  */)"   - Options apply to all future boots\n");
    }
  } else {
    {
#line 637
    printf((char const   */* __restrict  */)"   - Options apply to only next boot\n");
    }
  }
#line 639
  if (((int )rsp->data[2] & 32) == 32) {
    {
#line 640
    printf((char const   */* __restrict  */)"   - BIOS EFI boot \n");
    }
  } else {
    {
#line 642
    printf((char const   */* __restrict  */)"   - BIOS PC Compatible (legacy) boot \n");
    }
  }
#line 644
  if (((int )rsp->data[3] & 128) == 128) {
    {
#line 645
    printf((char const   */* __restrict  */)"   - CMOS Clear\n");
    }
  }
#line 646
  if (((int )rsp->data[3] & 64) == 64) {
    {
#line 647
    printf((char const   */* __restrict  */)"   - Lock Keyboard\n");
    }
  }
  {
#line 648
  printf((char const   */* __restrict  */)"   - Boot Device Selector : ");
  }
  {
#line 651
  if ((((int )rsp->data[3] >> 2) & 15) == 0) {
#line 651
    goto case_0___1;
  }
#line 652
  if ((((int )rsp->data[3] >> 2) & 15) == 1) {
#line 652
    goto case_1___1;
  }
#line 653
  if ((((int )rsp->data[3] >> 2) & 15) == 2) {
#line 653
    goto case_2___1;
  }
#line 654
  if ((((int )rsp->data[3] >> 2) & 15) == 3) {
#line 654
    goto case_3___0;
  }
#line 655
  if ((((int )rsp->data[3] >> 2) & 15) == 4) {
#line 655
    goto case_4___0;
  }
#line 656
  if ((((int )rsp->data[3] >> 2) & 15) == 5) {
#line 656
    goto case_5___0;
  }
#line 657
  if ((((int )rsp->data[3] >> 2) & 15) == 6) {
#line 657
    goto case_6;
  }
#line 658
  if ((((int )rsp->data[3] >> 2) & 15) == 15) {
#line 658
    goto case_15;
  }
#line 659
  goto switch_default___0;
  case_0___1: /* CIL Label */ 
  {
#line 651
  printf((char const   */* __restrict  */)"No override\n");
  }
#line 651
  goto switch_break___1;
  case_1___1: /* CIL Label */ 
  {
#line 652
  printf((char const   */* __restrict  */)"Force PXE\n");
  }
#line 652
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
  {
#line 653
  printf((char const   */* __restrict  */)"Force Boot from default Hard-Drive\n");
  }
#line 653
  goto switch_break___1;
  case_3___0: /* CIL Label */ 
  {
#line 654
  printf((char const   */* __restrict  */)"Force Boot from default Hard-Drive, request Safe-Mode\n");
  }
#line 654
  goto switch_break___1;
  case_4___0: /* CIL Label */ 
  {
#line 655
  printf((char const   */* __restrict  */)"Force Boot from Diagnostic Partition\n");
  }
#line 655
  goto switch_break___1;
  case_5___0: /* CIL Label */ 
  {
#line 656
  printf((char const   */* __restrict  */)"Force Boot from CD/DVD\n");
  }
#line 656
  goto switch_break___1;
  case_6: /* CIL Label */ 
  {
#line 657
  printf((char const   */* __restrict  */)"Force Boot into BIOS Setup\n");
  }
#line 657
  goto switch_break___1;
  case_15: /* CIL Label */ 
  {
#line 658
  printf((char const   */* __restrict  */)"Force Boot from Floppy/primary removable media\n");
  }
#line 658
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
  {
#line 659
  printf((char const   */* __restrict  */)"Flag error\n");
  }
#line 659
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 661
  if (((int )rsp->data[3] & 2) == 2) {
    {
#line 662
    printf((char const   */* __restrict  */)"   - Screen blank\n");
    }
  }
#line 663
  if (((int )rsp->data[3] & 1) == 1) {
    {
#line 664
    printf((char const   */* __restrict  */)"   - Lock out Reset buttons\n");
    }
  }
#line 666
  if (((int )rsp->data[4] & 128) == 128) {
    {
#line 667
    printf((char const   */* __restrict  */)"   - Lock out (power off/sleep request) vi Power Button\n");
    }
  }
  {
#line 668
  printf((char const   */* __restrict  */)"   - Console Redirection control : ");
  }
  {
#line 671
  if ((((int )rsp->data[4] >> 5) & 3) == 0) {
#line 671
    goto case_0___2;
  }
#line 672
  if ((((int )rsp->data[4] >> 5) & 3) == 1) {
#line 672
    goto case_1___2;
  }
#line 673
  if ((((int )rsp->data[4] >> 5) & 3) == 2) {
#line 673
    goto case_2___2;
  }
#line 674
  goto switch_default___1;
  case_0___2: /* CIL Label */ 
  {
#line 671
  printf((char const   */* __restrict  */)"System Default\n");
  }
#line 671
  goto switch_break___2;
  case_1___2: /* CIL Label */ 
  {
#line 672
  printf((char const   */* __restrict  */)"Request Quiet Display\n");
  }
#line 672
  goto switch_break___2;
  case_2___2: /* CIL Label */ 
  {
#line 673
  printf((char const   */* __restrict  */)"Request Verbose Display\n");
  }
#line 673
  goto switch_break___2;
  switch_default___1: /* CIL Label */ 
  {
#line 674
  printf((char const   */* __restrict  */)"Flag error\n");
  }
#line 674
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 676
  if (((int )rsp->data[4] & 16) == 16) {
    {
#line 677
    printf((char const   */* __restrict  */)"   - Force progress event traps\n");
    }
  }
#line 678
  if (((int )rsp->data[4] & 8) == 8) {
    {
#line 679
    printf((char const   */* __restrict  */)"   - User password bypass\n");
    }
  }
#line 680
  if (((int )rsp->data[4] & 4) == 4) {
    {
#line 681
    printf((char const   */* __restrict  */)"   - Lock Out Sleep Button\n");
    }
  }
#line 682
  if (((int )rsp->data[4] & 2) == 2) {
    {
#line 683
    printf((char const   */* __restrict  */)"   - Lock Out Sleep Button\n");
    }
  }
  {
#line 684
  printf((char const   */* __restrict  */)"   - BIOS verbosity : ");
  }
  {
#line 687
  if (((int )rsp->data[4] & 3) == 0) {
#line 687
    goto case_0___3;
  }
#line 688
  if (((int )rsp->data[4] & 3) == 1) {
#line 688
    goto case_1___3;
  }
#line 689
  if (((int )rsp->data[4] & 3) == 2) {
#line 689
    goto case_2___3;
  }
#line 690
  goto switch_default___2;
  case_0___3: /* CIL Label */ 
  {
#line 687
  printf((char const   */* __restrict  */)"Console redirection occurs per BIOS configuration setting (default)\n");
  }
#line 687
  goto switch_break___3;
  case_1___3: /* CIL Label */ 
  {
#line 688
  printf((char const   */* __restrict  */)"Suppress (skip) console redirection if enabled\n");
  }
#line 688
  goto switch_break___3;
  case_2___3: /* CIL Label */ 
  {
#line 689
  printf((char const   */* __restrict  */)"Request console redirection be enabled\n");
  }
#line 689
  goto switch_break___3;
  switch_default___2: /* CIL Label */ 
  {
#line 690
  printf((char const   */* __restrict  */)"Flag error\n");
  }
#line 690
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 693
  if (((int )rsp->data[5] & 8) == 8) {
    {
#line 694
    printf((char const   */* __restrict  */)"   - BIOS Shared Mode Override\n");
    }
  }
  {
#line 695
  printf((char const   */* __restrict  */)"   - BIOS Mux Control Override : ");
  }
  {
#line 698
  if (((int )rsp->data[5] & 7) == 0) {
#line 698
    goto case_0___4;
  }
#line 699
  if (((int )rsp->data[5] & 7) == 1) {
#line 699
    goto case_1___4;
  }
#line 700
  if (((int )rsp->data[5] & 7) == 2) {
#line 700
    goto case_2___4;
  }
#line 701
  goto switch_default___3;
  case_0___4: /* CIL Label */ 
  {
#line 698
  printf((char const   */* __restrict  */)"BIOS uses recommended setting of the mux at the end of POST\n");
  }
#line 698
  goto switch_break___4;
  case_1___4: /* CIL Label */ 
  {
#line 699
  printf((char const   */* __restrict  */)"Requests BIOS to force mux to BMC at conclusion of POST/start of OS boot\n");
  }
#line 699
  goto switch_break___4;
  case_2___4: /* CIL Label */ 
  {
#line 700
  printf((char const   */* __restrict  */)"Requests BIOS to force mux to system at conclusion of POST/start of OS boot\n");
  }
#line 700
  goto switch_break___4;
  switch_default___3: /* CIL Label */ 
  {
#line 701
  printf((char const   */* __restrict  */)"Flag error\n");
  }
#line 701
  goto switch_break___4;
  switch_break___4: /* CIL Label */ ;
  }
#line 704
  goto switch_break;
  case_6___0: /* CIL Label */ 
  {
#line 712
  session_id = (unsigned long )rsp->data[3];
#line 713
  session_id |= (unsigned long )rsp->data[4] << 8;
#line 714
  session_id |= (unsigned long )rsp->data[5] << 16;
#line 715
  session_id |= (unsigned long )rsp->data[6] << 24;
#line 717
  timestamp = (unsigned long )rsp->data[7];
#line 718
  timestamp |= (unsigned long )rsp->data[8] << 8;
#line 719
  timestamp |= (unsigned long )rsp->data[9] << 16;
#line 720
  timestamp |= (unsigned long )rsp->data[10] << 24;
#line 722
  memset((void *)(time_buf), 0, (size_t )40);
#line 723
  tmp___3 = localtime((time_t const   *)(& out_time));
#line 723
  strftime((char */* __restrict  */)(time_buf), sizeof(time_buf), (char const   */* __restrict  */)"%m/%d/%Y %H:%M:%S",
           (struct tm  const  */* __restrict  */)tmp___3);
#line 729
  printf((char const   */* __restrict  */)" Boot Initiator Info :\n");
#line 730
  printf((char const   */* __restrict  */)"    Channel Number : %d\n", (int )rsp->data[2] & 15);
#line 731
  printf((char const   */* __restrict  */)"    Session Id     : %08lXh\n", session_id);
  }
#line 732
  if (timestamp != 0UL) {
    {
#line 734
    printf((char const   */* __restrict  */)"    Timestamp      : %08lXh, %s\n", timestamp,
           time_buf);
    }
  } else {
    {
#line 738
    printf((char const   */* __restrict  */)"    Timestamp      : %08lXh, undefined\n",
           timestamp);
    }
  }
#line 742
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 745
  printf((char const   */* __restrict  */)" Selector   : %d\n", (int )rsp->data[2]);
#line 746
  tmp___4 = buf2str(rsp->data + 3, rsp->data_len - 2);
#line 746
  printf((char const   */* __restrict  */)" Block Data : %s\n", tmp___4);
  }
#line 748
  goto switch_break;
  switch_default___4: /* CIL Label */ 
  {
#line 750
  printf((char const   */* __restrict  */)" Undefined byte\n");
  }
#line 751
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 754
  return (0);
}
}
#line 757 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
static int ipmi_chassis_set_bootdev___0(struct ipmi_intf *intf , char *arg , uint8_t *iflags ) 
{ 
  uint8_t flags[5] ;
  int rc ;
  int use_progress ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 761
  rc = 0;
#line 762
  use_progress = 1;
#line 764
  if (use_progress) {
    {
#line 766
    memset((void *)(flags), 0, (size_t )5);
#line 767
    flags[0] = (uint8_t )1;
#line 768
    rc = ipmi_chassis_set_bootparam___0(intf, (uint8_t )0, flags, 1);
    }
#line 770
    if (rc < 0) {
#line 771
      use_progress = 0;
    }
  }
  {
#line 774
  memset((void *)(flags), 0, (size_t )5);
#line 775
  flags[0] = (uint8_t )1;
#line 776
  flags[1] = (uint8_t )1;
#line 777
  rc = ipmi_chassis_set_bootparam___0(intf, (uint8_t )4, flags, 2);
  }
#line 780
  if (rc < 0) {
#line 781
    if (use_progress) {
      {
#line 783
      memset((void *)(flags), 0, (size_t )5);
#line 784
      ipmi_chassis_set_bootparam___0(intf, (uint8_t )0, flags, 1);
      }
    }
#line 788
    return (-1);
  }
#line 791
  if ((unsigned long )iflags == (unsigned long )((void *)0)) {
    {
#line 792
    memset((void *)(flags), 0, (size_t )5);
    }
  } else {
    {
#line 794
    memcpy((void */* __restrict  */)(flags), (void const   */* __restrict  */)iflags,
           sizeof(flags));
    }
  }
#line 796
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 797
    flags[1] = (uint8_t )((int )flags[1]);
  } else {
    {
#line 798
    tmp___13 = strncmp((char const   *)arg, "none", (size_t )4);
    }
#line 798
    if (tmp___13 == 0) {
#line 799
      flags[1] = (uint8_t )((int )flags[1]);
    } else {
      {
#line 800
      tmp___11 = strncmp((char const   *)arg, "pxe", (size_t )3);
      }
#line 800
      if (tmp___11 == 0) {
#line 802
        flags[1] = (uint8_t )((int )flags[1] | 4);
      } else {
        {
#line 800
        tmp___12 = strncmp((char const   *)arg, "force_pxe", (size_t )9);
        }
#line 800
        if (tmp___12 == 0) {
#line 802
          flags[1] = (uint8_t )((int )flags[1] | 4);
        } else {
          {
#line 803
          tmp___9 = strncmp((char const   *)arg, "disk", (size_t )4);
          }
#line 803
          if (tmp___9 == 0) {
#line 805
            flags[1] = (uint8_t )((int )flags[1] | 8);
          } else {
            {
#line 803
            tmp___10 = strncmp((char const   *)arg, "force_disk", (size_t )10);
            }
#line 803
            if (tmp___10 == 0) {
#line 805
              flags[1] = (uint8_t )((int )flags[1] | 8);
            } else {
              {
#line 806
              tmp___7 = strncmp((char const   *)arg, "safe", (size_t )4);
              }
#line 806
              if (tmp___7 == 0) {
#line 808
                flags[1] = (uint8_t )((int )flags[1] | 12);
              } else {
                {
#line 806
                tmp___8 = strncmp((char const   *)arg, "force_safe", (size_t )10);
                }
#line 806
                if (tmp___8 == 0) {
#line 808
                  flags[1] = (uint8_t )((int )flags[1] | 12);
                } else {
                  {
#line 809
                  tmp___5 = strncmp((char const   *)arg, "diag", (size_t )4);
                  }
#line 809
                  if (tmp___5 == 0) {
#line 811
                    flags[1] = (uint8_t )((int )flags[1] | 16);
                  } else {
                    {
#line 809
                    tmp___6 = strncmp((char const   *)arg, "force_diag", (size_t )10);
                    }
#line 809
                    if (tmp___6 == 0) {
#line 811
                      flags[1] = (uint8_t )((int )flags[1] | 16);
                    } else {
                      {
#line 812
                      tmp___3 = strncmp((char const   *)arg, "cdrom", (size_t )5);
                      }
#line 812
                      if (tmp___3 == 0) {
#line 814
                        flags[1] = (uint8_t )((int )flags[1] | 20);
                      } else {
                        {
#line 812
                        tmp___4 = strncmp((char const   *)arg, "force_cdrom", (size_t )11);
                        }
#line 812
                        if (tmp___4 == 0) {
#line 814
                          flags[1] = (uint8_t )((int )flags[1] | 20);
                        } else {
                          {
#line 815
                          tmp___1 = strncmp((char const   *)arg, "floppy", (size_t )6);
                          }
#line 815
                          if (tmp___1 == 0) {
#line 817
                            flags[1] = (uint8_t )((int )flags[1] | 60);
                          } else {
                            {
#line 815
                            tmp___2 = strncmp((char const   *)arg, "force_floppy",
                                              (size_t )12);
                            }
#line 815
                            if (tmp___2 == 0) {
#line 817
                              flags[1] = (uint8_t )((int )flags[1] | 60);
                            } else {
                              {
#line 818
                              tmp = strncmp((char const   *)arg, "bios", (size_t )4);
                              }
#line 818
                              if (tmp == 0) {
#line 820
                                flags[1] = (uint8_t )((int )flags[1] | 24);
                              } else {
                                {
#line 818
                                tmp___0 = strncmp((char const   *)arg, "force_bios",
                                                  (size_t )10);
                                }
#line 818
                                if (tmp___0 == 0) {
#line 820
                                  flags[1] = (uint8_t )((int )flags[1] | 24);
                                } else {
                                  {
#line 822
                                  lprintf(3, "Invalid argument: %s", arg);
                                  }
#line 823
                                  if (use_progress) {
                                    {
#line 825
                                    memset((void *)(flags), 0, (size_t )5);
#line 826
                                    ipmi_chassis_set_bootparam___0(intf, (uint8_t )0,
                                                                   flags, 1);
                                    }
                                  }
#line 830
                                  return (-1);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 834
  flags[0] = (uint8_t )((int )flags[0] | 128);
#line 836
  rc = ipmi_chassis_set_bootparam___0(intf, (uint8_t )5, flags, 5);
  }
#line 838
  if (rc == 0) {
#line 839
    if (use_progress) {
      {
#line 841
      memset((void *)(flags), 0, (size_t )5);
#line 842
      flags[0] = (uint8_t )2;
#line 843
      ipmi_chassis_set_bootparam___0(intf, (uint8_t )0, flags, 1);
      }
    }
    {
#line 848
    printf((char const   */* __restrict  */)"Set Boot Device to %s\n", arg);
    }
  }
#line 851
  if (use_progress) {
    {
#line 853
    memset((void *)(flags), 0, (size_t )5);
#line 854
    ipmi_chassis_set_bootparam___0(intf, (uint8_t )0, flags, 1);
    }
  }
#line 859
  return (rc);
}
}
#line 862 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
static int ipmi_chassis_power_policy___0(struct ipmi_intf *intf , uint8_t policy ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;

  {
  {
#line 868
  memset((void *)(& req), 0, sizeof(req));
#line 869
  req.msg.netfn = (uint8_t )0;
#line 870
  req.msg.cmd = (uint8_t )6;
#line 871
  req.msg.data = & policy;
#line 872
  req.msg.data_len = (uint16_t )1;
#line 874
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 875
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 876
    lprintf(3, "Error in Power Restore Policy command");
    }
#line 877
    return (-1);
  }
#line 879
  if ((int )rsp->ccode > 0) {
    {
#line 880
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 880
    lprintf(3, "Power Restore Policy command failed: %s", tmp);
    }
#line 882
    return (-1);
  }
#line 885
  if ((int )policy == 3) {
    {
#line 886
    printf((char const   */* __restrict  */)"Supported chassis power policy:  ");
    }
#line 887
    if ((int )rsp->data[0] & 1) {
      {
#line 888
      printf((char const   */* __restrict  */)"always-off ");
      }
    }
#line 889
    if ((int )rsp->data[0] & (1 << 2)) {
      {
#line 890
      printf((char const   */* __restrict  */)"always-on ");
      }
    }
#line 891
    if ((int )rsp->data[0] & (1 << 1)) {
      {
#line 892
      printf((char const   */* __restrict  */)"previous");
      }
    }
    {
#line 893
    printf((char const   */* __restrict  */)"\n");
    }
  } else {
    {
#line 896
    printf((char const   */* __restrict  */)"Set chassis power restore policy to ");
    }
    {
#line 898
    if ((int )policy == 2) {
#line 898
      goto case_2;
    }
#line 901
    if ((int )policy == 0) {
#line 901
      goto case_0;
    }
#line 904
    if ((int )policy == 1) {
#line 904
      goto case_1;
    }
#line 907
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 899
    printf((char const   */* __restrict  */)"always-on\n");
    }
#line 900
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 902
    printf((char const   */* __restrict  */)"always-off\n");
    }
#line 903
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 905
    printf((char const   */* __restrict  */)"previous\n");
    }
#line 906
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 908
    printf((char const   */* __restrict  */)"unknown\n");
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 911
  return (0);
}
}
#line 1092 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
static struct __anonstruct_options_54___0 options___0[18]  = 
#line 1092
  {      {(char *)"valid", 0, (unsigned char )(1 << 7), (unsigned char )(1 << 7), (char *)"Boot flags valid"}, 
        {(char *)"persistent",
      0, (unsigned char )(1 << 6), (unsigned char )(1 << 6), (char *)"Changes are persistent for all future boots"}, 
        {(char *)"efiboot",
      0, (unsigned char )(1 << 5), (unsigned char )(1 << 5), (char *)"Extensible Firmware Interface Boot (EFI)"}, 
        {(char *)"clear-cmos",
      1, (unsigned char )(1 << 7), (unsigned char )(1 << 7), (char *)"CMOS clear"}, 
        {(char *)"lockkbd",
      1, (unsigned char )(1 << 6), (unsigned char )(1 << 6), (char *)"Lock Keyboard"}, 
        {(char *)"screenblank",
      1, (unsigned char )(1 << 1), (unsigned char )(1 << 1), (char *)"Screen Blank"}, 
        {(char *)"lockoutreset",
      1, (unsigned char)1, (unsigned char)1, (char *)"Lock out Resetbuttons"}, 
        {(char *)"lockout_power", 2, (unsigned char )(1 << 7), (unsigned char )(1 << 7),
      (char *)"Lock out (power off/sleep request) via Power Button"}, 
        {(char *)"verbose=default", 2, (unsigned char )(3 << 5), (unsigned char)0, (char *)"Request quiet BIOS display"}, 
        {(char *)"verbose=no",
      2, (unsigned char )(3 << 5), (unsigned char )(1 << 5), (char *)"Request quiet BIOS display"}, 
        {(char *)"verbose=yes",
      2, (unsigned char )(3 << 5), (unsigned char )(2 << 5), (char *)"Request verbose BIOS display"}, 
        {(char *)"force_pet",
      2, (unsigned char )(1 << 4), (unsigned char )(1 << 4), (char *)"Force progress event traps"}, 
        {(char *)"upw_bypass",
      2, (unsigned char )(1 << 3), (unsigned char )(1 << 3), (char *)"User password bypass"}, 
        {(char *)"lockout_sleep",
      2, (unsigned char )(1 << 2), (unsigned char )(1 << 2), (char *)"Log Out Sleep Button"}, 
        {(char *)"cons_redirect=default",
      2, (unsigned char)3, (unsigned char)0, (char *)"Console redirection occurs per BIOS configuration setting"}, 
        {(char *)"cons_redirect=skip",
      2, (unsigned char)3, (unsigned char)1, (char *)"Suppress (skip) console redirection if enabled"}, 
        {(char *)"cons_redirect=enable",
      2, (unsigned char)3, (unsigned char)2, (char *)"Suppress (skip) console redirection if enabled"}, 
        {(char *)((void *)0),
      0, (unsigned char)0, (unsigned char)0, (char *)0}};
#line 1092 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_chassis.c"
static struct __anonstruct_options_54___0 *op___0  ;
#line 587 "../include/ipmitool/ipmi_fru.h"
static unsigned long const   secs_from_1970_1996___1  =    (uint64_t const   )820454400;
#line 205 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ekanalyzer_print___0(int argc , char *opt , char **filename , int *file_type ) ;
#line 208
static int ipmi_ekanalyzer_ekeying_match___0(int argc , char *opt , char **filename ,
                                             int *file_type ) ;
#line 214
static void ipmi_ek_add_record2list___0(struct ipmi_ek_multi_header **record , struct ipmi_ek_multi_header **list_head ,
                                        struct ipmi_ek_multi_header **list_last ) ;
#line 218
static void ipmi_ek_display_record___0(struct ipmi_ek_multi_header *record , struct ipmi_ek_multi_header *list_head ,
                                       struct ipmi_ek_multi_header *list_last ) ;
#line 222
static void ipmi_ek_remove_record_from_list___0(struct ipmi_ek_multi_header *record ,
                                                struct ipmi_ek_multi_header **list_head ,
                                                struct ipmi_ek_multi_header **list_last ) ;
#line 227
static int ipmi_ekanalyzer_fru_file2structure___0(char *filename , struct ipmi_ek_multi_header **list_head ,
                                                  struct ipmi_ek_multi_header **list_record ,
                                                  struct ipmi_ek_multi_header **list_last ) ;
#line 235
static int ipmi_ek_matching_process___0(int *file_type , int index1 , int index2 ,
                                        struct ipmi_ek_multi_header **list_head ,
                                        struct ipmi_ek_multi_header **list_last ,
                                        char *opt , struct ipmi_ek_multi_header *pphysical ) ;
#line 240
static int ipmi_ek_get_resource_descriptor___0(int port_count , int index___0 , struct fru_picmgext_carrier_p2p_descriptor *port_desc ,
                                               struct ipmi_ek_multi_header *record ) ;
#line 244
static int ipmi_ek_create_amc_p2p_record___0(struct ipmi_ek_multi_header *record ,
                                             struct ipmi_ek_amc_p2p_connectivity_record *amc_record ) ;
#line 247
static int ipmi_ek_compare_link___0(struct ipmi_ek_multi_header *physic_record , struct ipmi_ek_amc_p2p_connectivity_record record1 ,
                                    struct ipmi_ek_amc_p2p_connectivity_record record2 ,
                                    char *opt , int file_type1 , int file_type2 ) ;
#line 252
static int ipmi_ek_compare_channel_descriptor___0(struct fru_picmgext_amc_channel_desc_record ch_desc1 ,
                                                  struct fru_picmgext_amc_channel_desc_record ch_desc2 ,
                                                  struct fru_picmgext_carrier_p2p_descriptor *port_desc ,
                                                  int index_port , unsigned char rsc_id ) ;
#line 258
static int ipmi_ek_compare_link_descriptor___0(struct ipmi_ek_amc_p2p_connectivity_record record1 ,
                                               int index1 , struct ipmi_ek_amc_p2p_connectivity_record record2 ,
                                               int index2 ) ;
#line 262
static int ipmi_ek_compare_asym___0(unsigned char *asym ) ;
#line 264
static int ipmi_ek_compare_number_of_enable_port___0(struct fru_picmgext_amc_link_desc_record *link_desc ) ;
#line 267
static int ipmi_ek_check_physical_connectivity___0(struct ipmi_ek_amc_p2p_connectivity_record record1 ,
                                                   int index1 , struct ipmi_ek_amc_p2p_connectivity_record record2 ,
                                                   int index2 , struct ipmi_ek_multi_header *record ,
                                                   int filetype1 , int filetype2 ,
                                                   char *option ) ;
#line 276
static int ipmi_ek_display_fru_header___0(char *filename ) ;
#line 278
static int ipmi_ek_display_fru_header_detail___0(char *filename ) ;
#line 280
static int ipmi_ek_display_chassis_info_area___0(FILE *input_file , long offset ) ;
#line 282
static size_t ipmi_ek_display_board_info_area___0(FILE *input_file , char *board_type ,
                                                  unsigned int *board_length ) ;
#line 285
static int ipmi_ek_display_product_info_area___0(FILE *input_file , long offset ) ;
#line 287
static int ipmi_ek_display_link_descriptor___0(int file_type , unsigned char rsc_id ,
                                               char *str___1 , struct fru_picmgext_amc_link_desc_record link_desc ) ;
#line 291
static void ipmi_ek_display_oem_guid___0(struct ipmi_ek_amc_p2p_connectivity_record amc_record ) ;
#line 294
static int ipmi_ek_display_carrier_connectivity___0(struct ipmi_ek_multi_header *record ) ;
#line 297
static int ipmi_ek_display_power___0(int argc , char *opt , char **filename , int *file_type ) ;
#line 300
static void ipmi_ek_display_current_descriptor___0(struct fru_picmgext_carrier_activation_record car ,
                                                   struct fru_picmgext_activation_record *cur_desc ,
                                                   char *filename ) ;
#line 304
static void ipmi_ek_display_backplane_p2p_record___0(struct ipmi_ek_multi_header *record ) ;
#line 307
static void ipmi_ek_display_address_table_record___0(struct ipmi_ek_multi_header *record ) ;
#line 310
static void ipmi_ek_display_shelf_power_distribution_record___0(struct ipmi_ek_multi_header *record ) ;
#line 313
static void ipmi_ek_display_shelf_activation_record___0(struct ipmi_ek_multi_header *record ) ;
#line 316
static void ipmi_ek_display_shelf_ip_connection_record___0(struct ipmi_ek_multi_header *record ) ;
#line 322
static void ipmi_ek_display_board_p2p_record___0(struct ipmi_ek_multi_header *record ) ;
#line 325
static void ipmi_ek_display_radial_ipmb0_record___0(struct ipmi_ek_multi_header *record ) ;
#line 328
static void ipmi_ek_display_amc_current_record___0(struct ipmi_ek_multi_header *record ) ;
#line 331
static void ipmi_ek_display_amc_activation_record___0(struct ipmi_ek_multi_header *record ) ;
#line 334
static void ipmi_ek_display_amc_p2p_record___0(struct ipmi_ek_multi_header *record ) ;
#line 337
static void ipmi_ek_display_amc_carrier_info_record___0(struct ipmi_ek_multi_header *record ) ;
#line 340
static void ipmi_ek_display_clock_carrier_p2p_record___0(struct ipmi_ek_multi_header *record ) ;
#line 343
static void ipmi_ek_display_clock_config_record___0(struct ipmi_ek_multi_header *record ) ;
#line 363 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ekanalyzer_usage___0(void) 
{ 


  {
  {
#line 366
  lprintf(5, "Ekeying analyzer tool version 1.00");
#line 367
  lprintf(5, "ekanalyzer Commands:");
#line 368
  lprintf(5, "      print    [carrier | power | all] <oc=filename1> <b1=filename2>...");
#line 370
  lprintf(5, "      frushow  <b2=filename>");
#line 372
  lprintf(5, "      summary  [match | unmatch | all] <oc=filename1> <b1=filename2>...");
  }
#line 374
  return;
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_get_file_type___0(char *argument ) 
{ 
  int index_name ;
  int filetype ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;

  {
  {
#line 400
  index_name = 0;
#line 401
  filetype = (int )ERROR_STATUS;
#line 403
  tmp___11 = strlen((char const   *)argument);
  }
#line 403
  if (tmp___11 > 2UL) {
    {
#line 404
    tmp___10 = strncmp((char const   *)argument, "oc=", (size_t )SIZE_OF_FILE_TYPE);
    }
#line 404
    if (tmp___10 == 0) {
#line 405
      filetype = 9;
    } else {
      {
#line 407
      tmp___9 = strncmp((char const   *)argument, "a1=", (size_t )SIZE_OF_FILE_TYPE);
      }
#line 407
      if (tmp___9 == 0) {
#line 408
        filetype = 1;
      } else {
        {
#line 410
        tmp___8 = strncmp((char const   *)argument, "a2=", (size_t )SIZE_OF_FILE_TYPE);
        }
#line 410
        if (tmp___8 == 0) {
#line 411
          filetype = 2;
        } else {
          {
#line 413
          tmp___7 = strncmp((char const   *)argument, "a3=", (size_t )SIZE_OF_FILE_TYPE);
          }
#line 413
          if (tmp___7 == 0) {
#line 414
            filetype = 3;
          } else {
            {
#line 416
            tmp___6 = strncmp((char const   *)argument, "a4=", (size_t )SIZE_OF_FILE_TYPE);
            }
#line 416
            if (tmp___6 == 0) {
#line 417
              filetype = 4;
            } else {
              {
#line 419
              tmp___5 = strncmp((char const   *)argument, "b1=", (size_t )SIZE_OF_FILE_TYPE);
              }
#line 419
              if (tmp___5 == 0) {
#line 420
                filetype = 5;
              } else {
                {
#line 422
                tmp___4 = strncmp((char const   *)argument, "b2=", (size_t )SIZE_OF_FILE_TYPE);
                }
#line 422
                if (tmp___4 == 0) {
#line 423
                  filetype = 6;
                } else {
                  {
#line 425
                  tmp___3 = strncmp((char const   *)argument, "b3=", (size_t )SIZE_OF_FILE_TYPE);
                  }
#line 425
                  if (tmp___3 == 0) {
#line 426
                    filetype = 7;
                  } else {
                    {
#line 428
                    tmp___2 = strncmp((char const   *)argument, "b4=", (size_t )SIZE_OF_FILE_TYPE);
                    }
#line 428
                    if (tmp___2 == 0) {
#line 429
                      filetype = 8;
                    } else {
                      {
#line 431
                      tmp___1 = strncmp((char const   *)argument, "rt=", (size_t )SIZE_OF_FILE_TYPE);
                      }
#line 431
                      if (tmp___1 == 0) {
#line 432
                        filetype = 0;
                      } else {
                        {
#line 434
                        tmp___0 = strncmp((char const   *)argument, "rc=", (size_t )SIZE_OF_FILE_TYPE);
                        }
#line 434
                        if (tmp___0 == 0) {
#line 435
                          filetype = 10;
                        } else {
                          {
#line 437
                          tmp = strncmp((char const   *)argument, "sm=", (size_t )SIZE_OF_FILE_TYPE);
                          }
#line 437
                          if (tmp == 0) {
#line 438
                            filetype = 11;
                          } else {
#line 441
                            filetype = (int )ERROR_STATUS;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 444
  return (filetype);
}
}
#line 687 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ekanalyzer_print___0(int argc , char *opt , char **filename , int *file_type ) 
{ 
  int return_value ;
  int found_flag ;
  int index___0 ;
  int *index_name ;
  unsigned long __lengthofindex_name ;
  void *tmp ;
  int list ;
  struct ipmi_ek_multi_header **list_head ;
  unsigned long __lengthoflist_head ;
  void *tmp___0 ;
  struct ipmi_ek_multi_header **list_record ;
  unsigned long __lengthoflist_record ;
  void *tmp___1 ;
  struct ipmi_ek_multi_header **list_last ;
  unsigned long __lengthoflist_last ;
  void *tmp___2 ;
  int i ;
  int first_data ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 690
  return_value = (int )OK_STATUS;
#line 693
  tmp___5 = strcmp((char const   *)opt, "carrier");
  }
#line 693
  if (tmp___5 == 0) {
#line 693
    goto _L;
  } else {
    {
#line 693
    tmp___6 = strcmp((char const   *)opt, "default");
    }
#line 693
    if (tmp___6 == 0) {
      _L: /* CIL Label */ 
      {
#line 694
      found_flag = 0;
#line 695
      index___0 = 0;
#line 696
      __lengthofindex_name = (unsigned long )argc;
#line 696
      tmp = __builtin_alloca(sizeof(*index_name) * __lengthofindex_name);
#line 696
      index_name = (int *)tmp;
#line 697
      list = 0;
#line 699
      __lengthoflist_head = (unsigned long )argc;
#line 699
      tmp___0 = __builtin_alloca(sizeof(*list_head) * __lengthoflist_head);
#line 699
      list_head = (struct ipmi_ek_multi_header **)tmp___0;
#line 700
      __lengthoflist_record = (unsigned long )argc;
#line 700
      tmp___1 = __builtin_alloca(sizeof(*list_record) * __lengthoflist_record);
#line 700
      list_record = (struct ipmi_ek_multi_header **)tmp___1;
#line 701
      __lengthoflist_last = (unsigned long )argc;
#line 701
      tmp___2 = __builtin_alloca(sizeof(*list_last) * __lengthoflist_last);
#line 701
      list_last = (struct ipmi_ek_multi_header **)tmp___2;
#line 703
      list = 0;
      }
      {
#line 703
      while (1) {
        while_continue: /* CIL Label */ ;
#line 703
        if (! (list < argc)) {
#line 703
          goto while_break;
        }
#line 704
        *(list_head + list) = (struct ipmi_ek_multi_header *)((void *)0);
#line 705
        *(list_record + list) = (struct ipmi_ek_multi_header *)((void *)0);
#line 706
        *(list_last + list) = (struct ipmi_ek_multi_header *)((void *)0);
#line 703
        list ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 709
      list = 0;
#line 710
      index___0 = 0;
      {
#line 710
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 710
        if (! (index___0 < argc)) {
#line 710
          goto while_break___0;
        }
#line 711
        if (*(file_type + index___0) == 9) {
          {
#line 712
          *(index_name + list) = index___0;
#line 713
          return_value = ipmi_ekanalyzer_fru_file2structure___0(*(filename + index___0),
                                                                list_head + list,
                                                                list_record + list,
                                                                list_last + list);
#line 715
          list ++;
#line 716
          found_flag = 1;
          }
        }
#line 710
        index___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 719
      if (! found_flag) {
        {
#line 720
        printf((char const   */* __restrict  */)"No carrier file has been found\n");
#line 721
        return_value = (int )ERROR_STATUS;
        }
      } else {
#line 724
        i = 0;
#line 725
        i = 0;
        {
#line 725
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 725
          if (! (i < argc)) {
#line 725
            goto while_break___1;
          }
#line 727
          first_data = 1;
#line 728
          *(list_record + i) = *(list_head + i);
          {
#line 728
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 728
            if (! ((unsigned long )*(list_record + i) != (unsigned long )((void *)0))) {
#line 728
              goto while_break___2;
            }
#line 731
            if ((int )*((*(list_record + i))->data + PICMG_ID_OFFSET) == 24) {
#line 734
              if (first_data) {
                {
#line 735
                printf((char const   */* __restrict  */)"%s\n", STAR_LINE_LIMITER);
#line 736
                printf((char const   */* __restrict  */)"From Carrier file: %s\n",
                       *(filename + *(index_name + i)));
#line 737
                first_data = 0;
                }
              }
              {
#line 739
              return_value = ipmi_ek_display_carrier_connectivity___0(*(list_record + i));
              }
            } else
#line 742
            if ((int )*((*(list_record + i))->data + PICMG_ID_OFFSET) == 26) {
#line 747
              if (first_data) {
                {
#line 748
                printf((char const   */* __restrict  */)"From Carrier file: %s\n",
                       *(filename + *(index_name + i)));
#line 749
                first_data = 0;
                }
              }
              {
#line 751
              printf((char const   */* __restrict  */)"   Number of AMC bays supported by Carrier: %d\n",
                     (int )*((*(list_record + i))->data + 6));
              }
            }
#line 728
            *(list_record + i) = (*(list_record + i))->next;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 725
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 757
        i = 0;
        {
#line 757
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 757
          if (! (i < argc)) {
#line 757
            goto while_break___3;
          }
          {
#line 758
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 758
            if (! ((unsigned long )*(list_head + i) != (unsigned long )((void *)0))) {
#line 758
              goto while_break___4;
            }
            {
#line 759
            ipmi_ek_remove_record_from_list___0(*(list_head + i), list_head + i, list_last + i);
            }
          }
          while_break___4: /* CIL Label */ ;
          }
#line 763
          if (i == list - 1) {
#line 763
            if (verbose) {
              {
#line 764
              printf((char const   */* __restrict  */)"Record list has been removed successfully\n");
              }
            }
          }
#line 757
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 768
      tmp___4 = strcmp((char const   *)opt, "power");
      }
#line 768
      if (tmp___4 == 0) {
        {
#line 769
        printf((char const   */* __restrict  */)"Print power information\n");
#line 770
        return_value = ipmi_ek_display_power___0(argc, opt, filename, file_type);
        }
      } else {
        {
#line 772
        tmp___3 = strcmp((char const   *)opt, "all");
        }
#line 772
        if (tmp___3 == 0) {
          {
#line 773
          printf((char const   */* __restrict  */)"Print all information\n");
#line 774
          return_value = ipmi_ek_display_power___0(argc, opt, filename, file_type);
          }
        } else {
          {
#line 777
          lprintf(3, "Invalid option %s", opt);
#line 778
          return_value = (int )ERROR_STATUS;
          }
        }
      }
    }
  }
#line 780
  return (return_value);
}
}
#line 802 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_display_carrier_connectivity___0(struct ipmi_ek_multi_header *record ) 
{ 
  int return_value ;
  struct fru_picmgext_carrier_p2p_record rsc_desc ;
  struct fru_picmgext_carrier_p2p_descriptor *port_desc ;
  int offset ;
  int k ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  unsigned char data[3] ;
  char const   *tmp___3 ;

  {
#line 805
  return_value = (int )ERROR_STATUS;
#line 809
  if ((unsigned long )record == (unsigned long )((void *)0)) {
    {
#line 810
    lprintf(3, "P2P connectivity record is invalid\n");
#line 811
    return_value = (int )ERROR_STATUS;
    }
  } else {
#line 814
    offset = (int )START_DATA_OFFSET;
#line 815
    if (verbose > 1) {
      {
#line 816
      k = 0;
#line 817
      printf((char const   */* __restrict  */)"Binary data of Carrier p2p connectivity record starting from mfg id\n");
#line 819
      k = 0;
      }
      {
#line 819
      while (1) {
        while_continue: /* CIL Label */ ;
#line 819
        if (! (k < (int )record->header.len)) {
#line 819
          goto while_break;
        }
        {
#line 820
        printf((char const   */* __restrict  */)"%02x   ", (int )*(record->data + k));
#line 819
        k ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 822
      printf((char const   */* __restrict  */)"\n");
      }
    }
    {
#line 824
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 824
      if (! (offset <= (int )record->header.len - (int )START_DATA_OFFSET)) {
#line 824
        goto while_break___0;
      }
#line 825
      tmp = offset;
#line 825
      offset ++;
#line 825
      rsc_desc.resource_id = *(record->data + tmp);
#line 826
      tmp___0 = offset;
#line 826
      offset ++;
#line 826
      rsc_desc.p2p_count = *(record->data + tmp___0);
#line 827
      if (verbose > 0) {
        {
#line 828
        printf((char const   */* __restrict  */)"resource id= %02x  port count= %d\n",
               (int )rsc_desc.resource_id, (int )rsc_desc.p2p_count);
        }
      }
#line 832
      if (((int )rsc_desc.resource_id & (int )AMC_MODULE) == (int )AMC_MODULE) {
#line 834
        if ((int )rsc_desc.resource_id == (int )AMC_MODULE) {
          {
#line 835
          tmp___1 = val2str((uint16_t )144, ipmi_ekanalyzer_IPMBL_addr);
#line 835
          printf((char const   */* __restrict  */)"   %s topology:\n", tmp___1);
          }
        } else {
          {
#line 842
          tmp___2 = val2str((uint16_t )((int )rsc_desc.resource_id & 15), ipmi_ekanalyzer_module_type);
#line 842
          printf((char const   */* __restrict  */)"   %s topology:\n", tmp___2);
          }
        }
      } else {
        {
#line 848
        printf((char const   */* __restrict  */)"   On Carrier Device ID %d topology: \n",
               (int )rsc_desc.resource_id & 15);
        }
      }
      {
#line 851
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 851
        if (! ((int )rsc_desc.p2p_count > 0)) {
#line 851
          goto while_break___1;
        }
#line 854
        data[0] = *(record->data + offset);
#line 855
        data[1] = *(record->data + (offset + 1));
#line 856
        data[2] = *(record->data + (offset + 2));
#line 862
        port_desc = (struct fru_picmgext_carrier_p2p_descriptor *)(data);
#line 863
        offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_carrier_p2p_descriptor ));
#line 864
        if (((int )port_desc->remote_resource_id & (int )AMC_MODULE) == (int )AMC_MODULE) {
          {
#line 865
          tmp___3 = val2str((uint16_t )((int )port_desc->remote_resource_id & 15),
                            ipmi_ekanalyzer_module_type);
#line 865
          printf((char const   */* __restrict  */)"\tPort %d =====> %s, Port %d\n",
                 (int )port_desc->local_port, tmp___3, (int )port_desc->remote_port);
          }
        } else {
          {
#line 872
          printf((char const   */* __restrict  */)"\tPort %d =====> On Carrier Device ID %d, Port %d\n",
                 (int )port_desc->local_port, (int )port_desc->remote_resource_id & 15,
                 (int )port_desc->remote_port);
          }
        }
#line 877
        rsc_desc.p2p_count = (unsigned char )((int )rsc_desc.p2p_count - 1);
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 880
    return_value = (int )OK_STATUS;
  }
#line 882
  return (return_value);
}
}
#line 908 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_display_power___0(int argc , char *opt , char **filename , int *file_type ) 
{ 
  int num_file ;
  int return_value ;
  int index___0 ;
  struct ipmi_ek_multi_header **list_head ;
  unsigned long __lengthoflist_head ;
  void *tmp ;
  struct ipmi_ek_multi_header **list_record ;
  unsigned long __lengthoflist_record ;
  void *tmp___0 ;
  struct ipmi_ek_multi_header **list_last ;
  unsigned long __lengthoflist_last ;
  void *tmp___1 ;
  int is_first_data ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int index_data ;
  struct fru_picmgext_carrier_activation_record car ;
  struct fru_picmgext_activation_record *cur_desc ;
  void *tmp___4 ;
  float power_in_watt ;
  float current_in_amp ;
  char const   *tmp___5 ;

  {
  {
#line 911
  num_file = 0;
#line 912
  return_value = (int )ERROR_STATUS;
#line 913
  index___0 = 0;
#line 916
  __lengthoflist_head = (unsigned long )argc;
#line 916
  tmp = __builtin_alloca(sizeof(*list_head) * __lengthoflist_head);
#line 916
  list_head = (struct ipmi_ek_multi_header **)tmp;
#line 917
  __lengthoflist_record = (unsigned long )argc;
#line 917
  tmp___0 = __builtin_alloca(sizeof(*list_record) * __lengthoflist_record);
#line 917
  list_record = (struct ipmi_ek_multi_header **)tmp___0;
#line 918
  __lengthoflist_last = (unsigned long )argc;
#line 918
  tmp___1 = __builtin_alloca(sizeof(*list_last) * __lengthoflist_last);
#line 918
  list_last = (struct ipmi_ek_multi_header **)tmp___1;
#line 920
  num_file = 0;
  }
  {
#line 920
  while (1) {
    while_continue: /* CIL Label */ ;
#line 920
    if (! (num_file < argc)) {
#line 920
      goto while_break;
    }
#line 921
    *(list_head + num_file) = (struct ipmi_ek_multi_header *)((void *)0);
#line 922
    *(list_record + num_file) = (struct ipmi_ek_multi_header *)((void *)0);
#line 923
    *(list_last + num_file) = (struct ipmi_ek_multi_header *)((void *)0);
#line 920
    num_file ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 926
  num_file = 0;
  {
#line 926
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 926
    if (! (num_file < argc)) {
#line 926
      goto while_break___0;
    }
#line 927
    is_first_data = 1;
#line 928
    if (*(file_type + num_file) == 10) {
#line 929
      num_file ++;
    }
#line 932
    if (is_first_data) {
      {
#line 933
      printf((char const   */* __restrict  */)"%s\n", STAR_LINE_LIMITER);
#line 934
      tmp___2 = val2str((uint16_t )*(file_type + num_file), ipmi_ekanalyzer_module_type);
#line 934
      printf((char const   */* __restrict  */)"\nFrom %s file \'%s\'\n", tmp___2,
             *(filename + num_file));
#line 937
      is_first_data = 0;
      }
    }
    {
#line 940
    return_value = ipmi_ekanalyzer_fru_file2structure___0(*(filename + num_file),
                                                          list_head + num_file, list_record + num_file,
                                                          list_last + num_file);
    }
#line 943
    if ((unsigned long )*(list_head + num_file) != (unsigned long )((void *)0)) {
#line 944
      *(list_record + num_file) = *(list_head + num_file);
      {
#line 944
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 944
        if (! ((unsigned long )*(list_record + num_file) != (unsigned long )((void *)0))) {
#line 944
          goto while_break___1;
        }
        {
#line 948
        tmp___3 = strcmp((char const   *)opt, "all");
        }
#line 948
        if (tmp___3 == 0) {
#line 948
          if (*(file_type + num_file) == 9) {
#line 951
            if ((int )*((*(list_record + num_file))->data + PICMG_ID_OFFSET) == 24) {
              {
#line 955
              return_value = ipmi_ek_display_carrier_connectivity___0(*(list_record + num_file));
              }
            } else
#line 958
            if ((int )*((*(list_record + num_file))->data + PICMG_ID_OFFSET) == 26) {
              {
#line 965
              printf((char const   */* __restrict  */)"   Number of AMC bays supported by Carrier: %d\n",
                     (int )*((*(list_record + num_file))->data + (START_DATA_OFFSET + 1)));
              }
            }
          }
        }
#line 972
        if ((int )*((*(list_record + num_file))->data + PICMG_ID_OFFSET) == 23) {
          {
#line 976
          index_data = (int )START_DATA_OFFSET;
#line 980
          memcpy((void */* __restrict  */)(& car), (void const   */* __restrict  */)((*(list_record + num_file))->data + index_data),
                 sizeof(struct fru_picmgext_carrier_activation_record ));
#line 982
          index_data = (int )((unsigned long )index_data + sizeof(struct fru_picmgext_carrier_activation_record ));
#line 984
          tmp___4 = malloc((unsigned long )car.module_activation_record_count * sizeof(struct fru_picmgext_activation_record ));
#line 984
          cur_desc = (struct fru_picmgext_activation_record *)tmp___4;
#line 986
          index___0 = 0;
          }
          {
#line 986
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 986
            if (! (index___0 < (int )car.module_activation_record_count)) {
#line 986
              goto while_break___2;
            }
            {
#line 987
            memcpy((void */* __restrict  */)(cur_desc + index___0), (void const   */* __restrict  */)((*(list_record + num_file))->data + index_data),
                   sizeof(struct fru_picmgext_activation_record ));
#line 991
            index_data = (int )((unsigned long )index_data + sizeof(struct fru_picmgext_activation_record ));
#line 986
            index___0 ++;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 994
          ipmi_ek_display_current_descriptor___0(car, cur_desc, *(filename + num_file));
#line 996
          free((void *)cur_desc);
#line 997
          cur_desc = (struct fru_picmgext_activation_record *)((void *)0);
          }
        } else
#line 1000
        if ((int )*((*(list_record + num_file))->data + PICMG_ID_OFFSET) == 22) {
          {
#line 1003
          power_in_watt = (float )0;
#line 1004
          current_in_amp = (float )0;
#line 1006
          tmp___5 = val2str((uint16_t )*(file_type + num_file), ipmi_ekanalyzer_module_type);
#line 1006
          printf((char const   */* __restrict  */)"   %s power required (Current Draw): ",
                 tmp___5);
#line 1008
          current_in_amp = (float )((double )*((*(list_record + num_file))->data + START_DATA_OFFSET) * 0.1);
#line 1010
          power_in_watt = current_in_amp * (float )12;
#line 1011
          printf((char const   */* __restrict  */)"%.2f Watts (%.2f Amps)\n", (double )power_in_watt,
                 (double )current_in_amp);
          }
        }
#line 944
        *(list_record + num_file) = (*(list_record + num_file))->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1014
      return_value = (int )OK_STATUS;
#line 1016
      index___0 = 0;
      {
#line 1016
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1016
        if (! (index___0 < argc)) {
#line 1016
          goto while_break___3;
        }
        {
#line 1017
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1017
          if (! ((unsigned long )*(list_head + index___0) != (unsigned long )((void *)0))) {
#line 1017
            goto while_break___4;
          }
          {
#line 1018
          ipmi_ek_remove_record_from_list___0(*(list_head + index___0), list_head + index___0,
                                              list_last + index___0);
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1021
        if (verbose > 1) {
          {
#line 1022
          printf((char const   */* __restrict  */)"Record list has been removed successfully\n");
          }
        }
#line 1016
        index___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 926
    num_file ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1026
  printf((char const   */* __restrict  */)"%s\n", STAR_LINE_LIMITER);
  }
#line 1027
  return (return_value);
}
}
#line 1051 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_current_descriptor___0(struct fru_picmgext_carrier_activation_record car ,
                                                   struct fru_picmgext_activation_record *cur_desc ,
                                                   char *filename ) 
{ 
  int index___0 ;
  float power_in_watt ;
  float current_in_amp ;
  char const   *tmp ;

  {
#line 1056
  index___0 = 0;
#line 1057
  power_in_watt = (float )0.0;
#line 1058
  current_in_amp = (float )0.0;
#line 1060
  index___0 = 0;
  {
#line 1060
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1060
    if (! (index___0 < (int )car.module_activation_record_count)) {
#line 1060
      goto while_break;
    }
    {
#line 1062
    current_in_amp = (float )((double )((float )(cur_desc + index___0)->max_module_curr) * 0.1);
#line 1063
    power_in_watt = current_in_amp * (float )12;
#line 1065
    tmp = val2str((uint16_t )(cur_desc + index___0)->ibmb_addr, ipmi_ekanalyzer_IPMBL_addr);
#line 1065
    printf((char const   */* __restrict  */)"   Carrier AMC power available on %s:\n",
           tmp);
#line 1067
    printf((char const   */* __restrict  */)"\t- Local IPMB Address    \t: %02x\n",
           (int )(cur_desc + index___0)->ibmb_addr);
#line 1068
    printf((char const   */* __restrict  */)"\t- Maximum module Current\t: %.2f Watts (%.2f Amps)\n",
           (double )power_in_watt, (double )current_in_amp);
#line 1060
    index___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1072
  current_in_amp = (float )((double )((float )car.max_internal_curr) * 0.1);
#line 1073
  power_in_watt = current_in_amp * (float )12;
#line 1074
  printf((char const   */* __restrict  */)"   Carrier AMC total power available for all bays from file \'%s\':",
         filename);
#line 1076
  printf((char const   */* __restrict  */)" %.2f Watts (%.2f Amps)\n", (double )power_in_watt,
         (double )current_in_amp);
  }
#line 1077
  return;
}
}
#line 1100 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ekanalyzer_ekeying_match___0(int argc , char *opt , char **filename ,
                                             int *file_type ) 
{ 
  int return_value ;
  int num_file ;
  int amc_file ;
  int oc_file ;
  struct ipmi_ek_multi_header **list_head ;
  unsigned long __lengthoflist_head ;
  void *tmp ;
  struct ipmi_ek_multi_header **list_record ;
  unsigned long __lengthoflist_record ;
  void *tmp___0 ;
  struct ipmi_ek_multi_header **list_last ;
  unsigned long __lengthoflist_last ;
  void *tmp___1 ;
  struct ipmi_ek_multi_header *pcarrier_p2p ;
  int list ;
  int match_pair ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1104
  return_value = 0;
#line 1106
  tmp___4 = strcmp((char const   *)opt, "carrier");
  }
#line 1106
  if (tmp___4 == 0) {
    {
#line 1107
    lprintf(3, "   ekanalyzer summary [match/ unmatch/ all] <xx=frufile> <xx=frufile> [xx=frufile]");
#line 1109
    return_value = (int )ERROR_STATUS;
    }
  } else {
    {
#line 1106
    tmp___5 = strcmp((char const   *)opt, "power");
    }
#line 1106
    if (tmp___5 == 0) {
      {
#line 1107
      lprintf(3, "   ekanalyzer summary [match/ unmatch/ all] <xx=frufile> <xx=frufile> [xx=frufile]");
#line 1109
      return_value = (int )ERROR_STATUS;
      }
    } else {
#line 1112
      num_file = 0;
#line 1113
      amc_file = 0;
#line 1114
      oc_file = 0;
#line 1117
      num_file = 0;
      {
#line 1117
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1117
        if (! (num_file < argc)) {
#line 1117
          goto while_break;
        }
#line 1118
        if (*(file_type + num_file) == 9) {
#line 1122
          amc_file = 0;
        } else
#line 1118
        if (*(file_type + num_file) == 10) {
#line 1122
          amc_file = 0;
        } else
#line 1118
        if (*(file_type + num_file) == 11) {
#line 1122
          amc_file = 0;
        } else {
#line 1125
          amc_file = 1;
#line 1126
          goto while_break;
        }
#line 1117
        num_file ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1129
      if (amc_file == 0) {
        {
#line 1130
        printf((char const   */* __restrict  */)"\nNo AMC FRU file is provided ---> No possible ekeying match!\n");
#line 1132
        return_value = (int )ERROR_STATUS;
        }
      } else {
#line 1136
        num_file = 0;
        {
#line 1136
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1136
          if (! (num_file < argc)) {
#line 1136
            goto while_break___0;
          }
#line 1137
          if (*(file_type + num_file) == 9) {
#line 1141
            oc_file = 1;
#line 1142
            goto while_break___0;
          } else
#line 1137
          if (*(file_type + num_file) == 10) {
#line 1141
            oc_file = 1;
#line 1142
            goto while_break___0;
          } else
#line 1137
          if (*(file_type + num_file) == 11) {
#line 1141
            oc_file = 1;
#line 1142
            goto while_break___0;
          }
#line 1136
          num_file ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1145
        if (! oc_file) {
          {
#line 1146
          printf((char const   */* __restrict  */)"\nNo Carrier FRU file is provided ---> No possible ekeying match!\n");
#line 1148
          return_value = (int )ERROR_STATUS;
          }
        } else {
          {
#line 1152
          __lengthoflist_head = (unsigned long )argc;
#line 1152
          tmp = __builtin_alloca(sizeof(*list_head) * __lengthoflist_head);
#line 1152
          list_head = (struct ipmi_ek_multi_header **)tmp;
#line 1153
          __lengthoflist_record = (unsigned long )argc;
#line 1153
          tmp___0 = __builtin_alloca(sizeof(*list_record) * __lengthoflist_record);
#line 1153
          list_record = (struct ipmi_ek_multi_header **)tmp___0;
#line 1154
          __lengthoflist_last = (unsigned long )argc;
#line 1154
          tmp___1 = __builtin_alloca(sizeof(*list_last) * __lengthoflist_last);
#line 1154
          list_last = (struct ipmi_ek_multi_header **)tmp___1;
#line 1156
          list = 0;
#line 1157
          match_pair = 0;
#line 1160
          list = 0;
          }
          {
#line 1160
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1160
            if (! (list < argc)) {
#line 1160
              goto while_break___1;
            }
#line 1161
            *(list_head + list) = (struct ipmi_ek_multi_header *)((void *)0);
#line 1162
            *(list_record + list) = (struct ipmi_ek_multi_header *)((void *)0);
#line 1163
            *(list_last + list) = (struct ipmi_ek_multi_header *)((void *)0);
#line 1160
            list ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 1165
          list = 0;
#line 1167
          num_file = 0;
          {
#line 1167
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1167
            if (! (num_file < argc)) {
#line 1167
              goto while_break___2;
            }
#line 1168
            if (*(file_type + num_file) != 10) {
              {
#line 1169
              return_value = ipmi_ekanalyzer_fru_file2structure___0(*(filename + num_file),
                                                                    list_head + num_file,
                                                                    list_record + num_file,
                                                                    list_last + num_file);
              }
            }
#line 1167
            num_file ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1175
          num_file = 0;
          {
#line 1175
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1175
            if (! (num_file < argc)) {
#line 1175
              goto while_break___3;
            }
#line 1176
            if (*(file_type + num_file) == 9) {
#line 1177
              pcarrier_p2p = *(list_head + num_file);
              {
#line 1177
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 1177
                if (! ((unsigned long )pcarrier_p2p != (unsigned long )((void *)0))) {
#line 1177
                  goto while_break___4;
                }
#line 1181
                if ((int )*(pcarrier_p2p->data + PICMG_ID_OFFSET) == 24) {
#line 1184
                  goto while_break___4;
                }
#line 1177
                pcarrier_p2p = pcarrier_p2p->next;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 1187
              goto while_break___3;
            }
#line 1175
            num_file ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 1191
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1191
            if (! (match_pair < argc)) {
#line 1191
              goto while_break___5;
            }
#line 1192
            num_file = match_pair + 1;
            {
#line 1192
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 1192
              if (! (num_file < argc)) {
#line 1192
                goto while_break___6;
              }
#line 1193
              if (*(file_type + match_pair) != 10) {
#line 1193
                if (*(file_type + num_file) != 10) {
#line 1196
                  if (*(file_type + match_pair) != 9) {
#line 1196
                    goto _L;
                  } else
#line 1196
                  if (*(file_type + num_file) != 9) {
                    _L: /* CIL Label */ 
                    {
#line 1199
                    tmp___2 = val2str((uint16_t )*(file_type + num_file), ipmi_ekanalyzer_module_type);
#line 1199
                    tmp___3 = val2str((uint16_t )*(file_type + match_pair), ipmi_ekanalyzer_module_type);
#line 1199
                    printf((char const   */* __restrict  */)"%s vs %s\n", tmp___3,
                           tmp___2);
                    }
#line 1205
                    if (verbose > 0) {
                      {
#line 1206
                      printf((char const   */* __restrict  */)"Start matching process\n");
                      }
                    }
                    {
#line 1208
                    return_value = ipmi_ek_matching_process___0(file_type, match_pair,
                                                                num_file, list_head,
                                                                list_last, opt, pcarrier_p2p);
                    }
                  }
                }
              }
#line 1192
              num_file ++;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 1214
            match_pair ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 1216
          num_file = 0;
          {
#line 1216
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 1216
            if (! (num_file < argc)) {
#line 1216
              goto while_break___7;
            }
#line 1217
            if ((unsigned long )*(list_head + num_file) != (unsigned long )((void *)0)) {
              {
#line 1218
              ipmi_ek_remove_record_from_list___0(*(list_head + num_file), list_record + num_file,
                                                  list_last + num_file);
              }
            }
#line 1221
            if (num_file == argc - 1) {
#line 1221
              if (verbose) {
                {
#line 1222
                printf((char const   */* __restrict  */)"Record list has been removed successfully\n");
                }
              }
            }
#line 1216
            num_file ++;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 1224
          return_value = (int )OK_STATUS;
        }
      }
    }
  }
#line 1228
  return (return_value);
}
}
#line 1261 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_matching_process___0(int *file_type , int index1 , int index2 ,
                                        struct ipmi_ek_multi_header **list_head ,
                                        struct ipmi_ek_multi_header **list_last ,
                                        char *opt , struct ipmi_ek_multi_header *pphysical ) 
{ 
  int result ;
  struct ipmi_ek_multi_header *record ;
  int num_amc_record1 ;
  int num_amc_record2 ;
  int index_temp ;
  int index_record1 ;
  int index_record2 ;
  struct ipmi_ek_amc_p2p_connectivity_record *amc_record1 ;
  struct ipmi_ek_amc_p2p_connectivity_record *amc_record2 ;
  void *tmp ;
  void *tmp___0 ;
  struct ipmi_ek_multi_header *current_record ;

  {
#line 1266
  result = (int )ERROR_STATUS;
#line 1268
  num_amc_record1 = 0;
#line 1269
  num_amc_record2 = 0;
#line 1272
  if (*(file_type + index2) == 9) {
#line 1273
    index_temp = 0;
#line 1274
    index_temp = index1;
#line 1275
    index1 = index2;
#line 1276
    index2 = index_temp;
  }
#line 1279
  record = *(list_head + index1);
  {
#line 1279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1279
    if (! ((unsigned long )record != (unsigned long )((void *)0))) {
#line 1279
      goto while_break;
    }
#line 1280
    if ((int )*(record->data + PICMG_ID_OFFSET) == 25) {
#line 1281
      num_amc_record2 ++;
    }
#line 1279
    record = record->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1285
  record = *(list_head + index2);
  {
#line 1285
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1285
    if (! ((unsigned long )record != (unsigned long )((void *)0))) {
#line 1285
      goto while_break___0;
    }
#line 1286
    if ((int )*(record->data + PICMG_ID_OFFSET) == 25) {
#line 1287
      num_amc_record1 ++;
    }
#line 1285
    record = record->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1290
  if (num_amc_record1 > 0) {
#line 1290
    if (num_amc_record2 > 0) {
      {
#line 1291
      index_record1 = 0;
#line 1292
      index_record2 = 0;
#line 1294
      amc_record1 = (struct ipmi_ek_amc_p2p_connectivity_record *)((void *)0);
#line 1296
      amc_record2 = (struct ipmi_ek_amc_p2p_connectivity_record *)((void *)0);
#line 1298
      tmp = malloc((unsigned long )num_amc_record1 * sizeof(struct ipmi_ek_amc_p2p_connectivity_record ));
#line 1298
      amc_record1 = (struct ipmi_ek_amc_p2p_connectivity_record *)tmp;
#line 1300
      tmp___0 = malloc((unsigned long )num_amc_record2 * sizeof(struct ipmi_ek_amc_p2p_connectivity_record ));
#line 1300
      amc_record2 = (struct ipmi_ek_amc_p2p_connectivity_record *)tmp___0;
#line 1303
      record = *(list_head + index2);
      }
      {
#line 1303
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1303
        if (! ((unsigned long )record != (unsigned long )((void *)0))) {
#line 1303
          goto while_break___1;
        }
#line 1304
        if ((int )*(record->data + PICMG_ID_OFFSET) == 25) {
          {
#line 1305
          result = ipmi_ek_create_amc_p2p_record___0(record, amc_record1 + index_record1);
          }
#line 1307
          if (result != (int )ERROR_STATUS) {
#line 1308
            current_record = (struct ipmi_ek_multi_header *)((void *)0);
#line 1310
            current_record = *(list_head + index1);
            {
#line 1310
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 1310
              if (! ((unsigned long )current_record != (unsigned long )((void *)0))) {
#line 1310
                goto while_break___2;
              }
#line 1314
              if ((int )*(current_record->data + PICMG_ID_OFFSET) == 25) {
                {
#line 1315
                result = ipmi_ek_create_amc_p2p_record___0(current_record, amc_record2 + index_record2);
                }
#line 1317
                if (result != (int )ERROR_STATUS) {
#line 1318
                  if (result == (int )OK_STATUS) {
                    {
#line 1320
                    result = ipmi_ek_compare_link___0(pphysical, *(amc_record1 + index_record1),
                                                      *(amc_record2 + index_record2),
                                                      opt, *(file_type + index1),
                                                      *(file_type + index2));
                    }
                  }
#line 1325
                  index_record2 ++;
                }
              }
#line 1310
              current_record = current_record->next;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 1329
            index_record1 ++;
          }
        }
#line 1303
        record = record->next;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1333
      free((void *)amc_record1);
#line 1334
      amc_record1 = (struct ipmi_ek_amc_p2p_connectivity_record *)((void *)0);
#line 1335
      free((void *)amc_record2);
#line 1336
      amc_record2 = (struct ipmi_ek_amc_p2p_connectivity_record *)((void *)0);
      }
    } else {
      {
#line 1339
      printf((char const   */* __restrict  */)"No amc record is found!\n");
      }
    }
  } else {
    {
#line 1339
    printf((char const   */* __restrict  */)"No amc record is found!\n");
    }
  }
#line 1342
  return (result);
}
}
#line 1374 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_check_physical_connectivity___0(struct ipmi_ek_amc_p2p_connectivity_record record1 ,
                                                   int index1 , struct ipmi_ek_amc_p2p_connectivity_record record2 ,
                                                   int index2 , struct ipmi_ek_multi_header *record ,
                                                   int filetype1 , int filetype2 ,
                                                   char *option ) 
{ 
  int return_status ;
  int index___0 ;
  int amc_site ;
  struct fru_picmgext_carrier_p2p_record rsc_desc ;
  struct fru_picmgext_carrier_p2p_descriptor *port_desc ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int j ;
  int match_lane ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;

  {
#line 1381
  return_status = (int )OK_STATUS;
#line 1383
  if ((unsigned long )record == (unsigned long )((void *)0)) {
    {
#line 1384
    printf((char const   */* __restrict  */)"NO Carrier p2p connectivity !\n");
#line 1385
    return_status = (int )ERROR_STATUS;
    }
  } else {
#line 1389
    index___0 = (int )START_DATA_OFFSET;
#line 1390
    amc_site = -1;
#line 1392
    port_desc = (struct fru_picmgext_carrier_p2p_descriptor *)((void *)0);
    {
#line 1395
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1395
      if (! (index___0 < (int )record->header.len)) {
#line 1395
        goto while_break;
      }
#line 1396
      tmp = index___0;
#line 1396
      index___0 ++;
#line 1396
      rsc_desc.resource_id = *(record->data + tmp);
#line 1397
      tmp___0 = index___0;
#line 1397
      index___0 ++;
#line 1397
      rsc_desc.p2p_count = *(record->data + tmp___0);
#line 1399
      if ((int )rsc_desc.resource_id == (int )record1.rsc_id) {
#line 1399
        goto _L;
      } else
#line 1399
      if ((int )rsc_desc.resource_id == (int )record2.rsc_id) {
        _L: /* CIL Label */ 
#line 1403
        if ((int )rsc_desc.p2p_count <= 0) {
          {
#line 1404
          printf((char const   */* __restrict  */)"No p2p count\n");
#line 1405
          return_status = (int )ERROR_STATUS;
          }
        } else {
          {
#line 1408
          tmp___1 = malloc((unsigned long )rsc_desc.p2p_count * sizeof(struct fru_picmgext_carrier_p2p_descriptor ));
#line 1408
          port_desc = (struct fru_picmgext_carrier_p2p_descriptor *)tmp___1;
#line 1410
          index___0 = ipmi_ek_get_resource_descriptor___0((int )rsc_desc.p2p_count,
                                                          index___0, port_desc, record);
#line 1412
          amc_site = -1;
          }
#line 1413
          goto while_break;
        }
      } else {
#line 1417
        if ((int )rsc_desc.resource_id == (int )AMC_MODULE) {
#line 1418
          if (filetype1 != 9) {
#line 1419
            amc_site = filetype1;
          } else {
#line 1422
            amc_site = filetype2;
          }
        } else {
#line 1426
          amc_site = (int )rsc_desc.resource_id & 15;
        }
#line 1428
        if (amc_site > 0) {
#line 1429
          if (amc_site == filetype1) {
            {
#line 1430
            tmp___2 = malloc((unsigned long )rsc_desc.p2p_count * sizeof(struct fru_picmgext_carrier_p2p_descriptor ));
#line 1430
            port_desc = (struct fru_picmgext_carrier_p2p_descriptor *)tmp___2;
#line 1432
            index___0 = ipmi_ek_get_resource_descriptor___0((int )rsc_desc.p2p_count,
                                                            index___0, port_desc,
                                                            record);
            }
#line 1434
            goto while_break;
          } else
#line 1429
          if (amc_site == filetype2) {
            {
#line 1430
            tmp___2 = malloc((unsigned long )rsc_desc.p2p_count * sizeof(struct fru_picmgext_carrier_p2p_descriptor ));
#line 1430
            port_desc = (struct fru_picmgext_carrier_p2p_descriptor *)tmp___2;
#line 1432
            index___0 = ipmi_ek_get_resource_descriptor___0((int )rsc_desc.p2p_count,
                                                            index___0, port_desc,
                                                            record);
            }
#line 1434
            goto while_break;
          }
        } else {
#line 1438
          return_status = (int )ERROR_STATUS;
        }
      }
#line 1444
      index___0 = (int )((unsigned long )index___0 + sizeof(struct fru_picmgext_carrier_p2p_descriptor ) * (unsigned long )rsc_desc.p2p_count);
    }
    while_break: /* CIL Label */ ;
    }
#line 1448
    if ((unsigned long )port_desc != (unsigned long )((void *)0)) {
#line 1448
      if (return_status != (int )ERROR_STATUS) {
#line 1449
        j = 0;
#line 1451
        j = 0;
        {
#line 1451
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1451
          if (! (j < (int )rsc_desc.p2p_count)) {
#line 1451
            goto while_break___0;
          }
#line 1453
          if ((record1.ch_desc + index1)->lane0port != (unsigned int )DISABLE_PORT) {
            {
#line 1455
            match_lane = 0;
#line 1457
            match_lane = ipmi_ek_compare_channel_descriptor___0(*(record1.ch_desc + index1),
                                                                *(record2.ch_desc + index2),
                                                                port_desc, j, rsc_desc.resource_id);
            }
#line 1461
            if (match_lane) {
#line 1462
              if (filetype1 != 9) {
#line 1463
                if (filetype1 == ((int )rsc_desc.resource_id & 15)) {
#line 1463
                  if (filetype2 == ((int )(port_desc + j)->remote_resource_id & 15)) {
#line 1463
                    goto _L___0;
                  } else {
#line 1463
                    goto _L___2;
                  }
                } else
                _L___2: /* CIL Label */ 
#line 1463
                if (filetype2 == ((int )rsc_desc.resource_id & 15)) {
#line 1463
                  if (filetype1 == ((int )(port_desc + j)->remote_resource_id & 15)) {
                    _L___0: /* CIL Label */ 
                    {
#line 1475
                    tmp___5 = strcmp((char const   *)option, "unmatch");
                    }
#line 1475
                    if (! (tmp___5 == 0)) {
                      {
#line 1476
                      tmp___3 = val2str((uint16_t )filetype1, ipmi_ekanalyzer_module_type);
#line 1476
                      tmp___4 = val2str((uint16_t )filetype2, ipmi_ekanalyzer_module_type);
#line 1476
                      printf((char const   */* __restrict  */)"%s port %d ==> %s port %d\n",
                             tmp___4, (record1.ch_desc + index1)->lane0port, tmp___3,
                             (record2.ch_desc + index2)->lane0port);
                      }
                    }
#line 1482
                    return_status = (int )OK_STATUS;
#line 1484
                    goto while_break___0;
                  } else {
#line 1463
                    goto _L___1;
                  }
                } else {
                  _L___1: /* CIL Label */ 
#line 1487
                  if (verbose == 7) {
                    {
#line 1488
                    printf((char const   */* __restrict  */)"No point 2 point connectivity\n");
                    }
                  }
#line 1490
                  return_status = (int )ERROR_STATUS;
                }
              } else
#line 1494
              if ((int )record2.rsc_id == (int )rsc_desc.resource_id) {
#line 1494
                if (filetype2 == ((int )(port_desc + j)->remote_resource_id & 15)) {
                  {
#line 1498
                  tmp___8 = strcmp((char const   *)option, "unmatch");
                  }
#line 1498
                  if (! (tmp___8 == 0)) {
                    {
#line 1499
                    tmp___6 = val2str((uint16_t )filetype1, ipmi_ekanalyzer_module_type);
#line 1499
                    tmp___7 = val2str((uint16_t )filetype2, ipmi_ekanalyzer_module_type);
#line 1499
                    printf((char const   */* __restrict  */)"%s port %d ==> %s port %d\n",
                           tmp___7, (record1.ch_desc + index1)->lane0port, tmp___6,
                           (record2.ch_desc + index2)->lane0port);
                    }
                  }
#line 1505
                  return_status = (int )OK_STATUS;
#line 1506
                  goto while_break___0;
                } else {
#line 1494
                  goto _L___4;
                }
              } else
              _L___4: /* CIL Label */ 
#line 1508
              if (filetype2 == ((int )rsc_desc.resource_id & 15)) {
#line 1508
                if ((int )record2.rsc_id == (int )(port_desc + j)->remote_resource_id) {
                  {
#line 1512
                  tmp___11 = strcmp((char const   *)option, "unmatch");
                  }
#line 1512
                  if (! (tmp___11 == 0)) {
                    {
#line 1513
                    tmp___9 = val2str((uint16_t )filetype1, ipmi_ekanalyzer_module_type);
#line 1513
                    tmp___10 = val2str((uint16_t )filetype2, ipmi_ekanalyzer_module_type);
#line 1513
                    printf((char const   */* __restrict  */)"%s port %d ==> %s %x port %d\n",
                           tmp___10, (record1.ch_desc + index1)->lane0port, tmp___9,
                           (int )record2.rsc_id, (record2.ch_desc + index2)->lane0port);
                    }
                  }
#line 1519
                  return_status = (int )OK_STATUS;
#line 1520
                  goto while_break___0;
                } else {
#line 1508
                  goto _L___3;
                }
              } else {
                _L___3: /* CIL Label */ 
#line 1523
                if (verbose == 7) {
                  {
#line 1524
                  printf((char const   */* __restrict  */)"No point 2 point connectivity\n");
                  }
                }
#line 1526
                return_status = (int )ERROR_STATUS;
              }
            } else {
#line 1531
              if (verbose == 7) {
                {
#line 1532
                printf((char const   */* __restrict  */)"No point 2 point connectivity\n");
                }
              }
#line 1534
              return_status = (int )ERROR_STATUS;
            }
          } else {
#line 1538
            return_status = (int )OK_STATUS;
          }
#line 1451
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 1448
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */ 
#line 1543
      if (verbose == 4) {
        {
#line 1544
        printf((char const   */* __restrict  */)"Invalid Carrier p2p connectivity record\n");
        }
      }
#line 1546
      return_status = (int )ERROR_STATUS;
    }
#line 1548
    if ((unsigned long )port_desc != (unsigned long )((void *)0)) {
      {
#line 1549
      free((void *)port_desc);
#line 1550
      port_desc = (struct fru_picmgext_carrier_p2p_descriptor *)((void *)0);
      }
    }
  }
#line 1553
  return (return_status);
}
}
#line 1606 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int flag_first_link1___1  ;
#line 1609 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int flag_first_link2___1  ;
#line 1667 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int flag_first_link1___2  ;
#line 1670 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int flag_first_link2___2  ;
#line 1579 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_compare_link___0(struct ipmi_ek_multi_header *physic_record , struct ipmi_ek_amc_p2p_connectivity_record record1 ,
                                    struct ipmi_ek_amc_p2p_connectivity_record record2 ,
                                    char *opt , int file_type1 , int file_type2 ) 
{ 
  int result ;
  int index1 ;
  int index2 ;
  void *tmp ;
  void *tmp___0 ;
  int index_ch_desc1 ;
  int index_ch_desc2 ;
  int isOEMtype ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int index_ch_desc1___0 ;
  int index_ch_desc2___0 ;
  int isOEMtype___0 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int isOEMtype___1 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 1585
  result = (int )ERROR_STATUS;
#line 1586
  index1 = 0;
#line 1587
  index2 = 0;
#line 1589
  tmp = malloc((unsigned long )record1.link_desc_count * sizeof(int ));
#line 1589
  record1.matching_result = (int *)tmp;
#line 1590
  tmp___0 = malloc((unsigned long )record2.link_desc_count * sizeof(int ));
#line 1590
  record2.matching_result = (int *)tmp___0;
#line 1592
  index2 = 0;
  }
  {
#line 1592
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1592
    if (! (index2 < (int )record2.link_desc_count)) {
#line 1592
      goto while_break;
    }
#line 1593
    *(record2.matching_result + index2) = 0;
#line 1592
    index2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1595
  index1 = 0;
  {
#line 1595
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1595
    if (! (index1 < (int )record1.link_desc_count)) {
#line 1595
      goto while_break___0;
    }
#line 1596
    index2 = 0;
    {
#line 1596
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1596
      if (! (index2 < (int )record2.link_desc_count)) {
#line 1596
        goto while_break___1;
      }
#line 1597
      if ((record1.link_desc + index1)->group_id == 0U) {
#line 1598
        if ((record2.link_desc + index2)->group_id == 0U) {
          {
#line 1599
          result = ipmi_ek_compare_link_descriptor___0(record1, index1, record2, index2);
          }
#line 1601
          if (result == (int )OK_STATUS) {
#line 1612
            if (index1 == 0) {
#line 1613
              flag_first_link1___1 = (int )(record1.link_desc + index1)->channel_id;
            }
#line 1615
            index_ch_desc1 = (int )((record1.link_desc + index1)->channel_id - (unsigned int )flag_first_link1___1);
#line 1617
            if (index2 == 0) {
#line 1618
              flag_first_link2___1 = (int )(record2.link_desc + index2)->channel_id;
            }
            {
#line 1620
            index_ch_desc2 = (int )((record2.link_desc + index2)->channel_id - (unsigned int )flag_first_link2___1);
#line 1623
            result = ipmi_ek_check_physical_connectivity___0(record1, index_ch_desc1,
                                                             record2, index_ch_desc2,
                                                             physic_record, file_type1,
                                                             file_type2, opt);
            }
#line 1626
            if (result == (int )OK_STATUS) {
              {
#line 1628
              tmp___1 = strcmp((char const   *)opt, "match");
              }
#line 1628
              if (tmp___1 == 0) {
#line 1628
                goto _L;
              } else {
                {
#line 1628
                tmp___2 = strcmp((char const   *)opt, "all");
                }
#line 1628
                if (tmp___2 == 0) {
#line 1628
                  goto _L;
                } else {
                  {
#line 1628
                  tmp___3 = strcmp((char const   *)opt, "default");
                  }
#line 1628
                  if (tmp___3 == 0) {
                    _L: /* CIL Label */ 
                    {
#line 1632
                    isOEMtype = 0;
#line 1633
                    printf((char const   */* __restrict  */)" Matching Result\n");
#line 1634
                    isOEMtype = ipmi_ek_display_link_descriptor___0(file_type1, record2.rsc_id,
                                                                    (char *)"From",
                                                                    *(record2.link_desc + index2));
                    }
#line 1637
                    if (isOEMtype) {
                      {
#line 1638
                      ipmi_ek_display_oem_guid___0(record2);
                      }
                    }
                    {
#line 1640
                    isOEMtype = ipmi_ek_display_link_descriptor___0(file_type2, record1.rsc_id,
                                                                    (char *)"To",
                                                                    *(record1.link_desc + index1));
                    }
#line 1643
                    if (isOEMtype) {
                      {
#line 1644
                      ipmi_ek_display_oem_guid___0(record1);
                      }
                    }
                    {
#line 1646
                    printf((char const   */* __restrict  */)"  %s\n", STAR_LINE_LIMITER);
                    }
                  }
                }
              }
#line 1648
              *(record2.matching_result + index2) = 1;
#line 1649
              *(record1.matching_result + index1) = 1;
#line 1651
              index2 = (int )record2.link_desc_count;
            }
          }
        }
      } else
#line 1659
      if ((record2.link_desc + index2)->group_id != 0U) {
        {
#line 1660
        result = ipmi_ek_compare_link_descriptor___0(record1, index1, record2, index2);
        }
#line 1662
        if (result == (int )OK_STATUS) {
#line 1673
          if (index1 == 0) {
#line 1674
            flag_first_link1___2 = (int )(record1.link_desc + index1)->channel_id;
          }
#line 1676
          index_ch_desc1___0 = (int )((record1.link_desc + index1)->channel_id - (unsigned int )flag_first_link1___2);
#line 1678
          if (index2 == 0) {
#line 1679
            flag_first_link2___2 = (int )(record2.link_desc + index2)->channel_id;
          }
          {
#line 1681
          index_ch_desc2___0 = (int )((record2.link_desc + index2)->channel_id - (unsigned int )flag_first_link2___2);
#line 1684
          result = ipmi_ek_check_physical_connectivity___0(record1, index_ch_desc1___0,
                                                           record2, index_ch_desc2___0,
                                                           physic_record, file_type1,
                                                           file_type2, opt);
          }
#line 1687
          if (result == (int )OK_STATUS) {
            {
#line 1688
            tmp___4 = strcmp((char const   *)opt, "match");
            }
#line 1688
            if (tmp___4 == 0) {
#line 1688
              goto _L___0;
            } else {
              {
#line 1688
              tmp___5 = strcmp((char const   *)opt, "all");
              }
#line 1688
              if (tmp___5 == 0) {
#line 1688
                goto _L___0;
              } else {
                {
#line 1688
                tmp___6 = strcmp((char const   *)opt, "default");
                }
#line 1688
                if (tmp___6 == 0) {
                  _L___0: /* CIL Label */ 
                  {
#line 1692
                  isOEMtype___0 = 0;
#line 1693
                  printf((char const   */* __restrict  */)"  Matching Result\n");
#line 1694
                  isOEMtype___0 = ipmi_ek_display_link_descriptor___0(file_type1,
                                                                      record2.rsc_id,
                                                                      (char *)"From",
                                                                      *(record2.link_desc + index2));
                  }
#line 1697
                  if (isOEMtype___0) {
                    {
#line 1698
                    ipmi_ek_display_oem_guid___0(record2);
                    }
                  }
                  {
#line 1700
                  isOEMtype___0 = ipmi_ek_display_link_descriptor___0(file_type2,
                                                                      record1.rsc_id,
                                                                      (char *)"To",
                                                                      *(record1.link_desc + index1));
                  }
#line 1703
                  if (isOEMtype___0) {
                    {
#line 1704
                    ipmi_ek_display_oem_guid___0(record1);
                    }
                  }
                  {
#line 1706
                  printf((char const   */* __restrict  */)"  %s\n", STAR_LINE_LIMITER);
                  }
                }
              }
            }
#line 1708
            *(record2.matching_result + index2) = 1;
#line 1709
            *(record1.matching_result + index1) = 1;
#line 1711
            index2 = (int )record2.link_desc_count;
          }
        }
      }
#line 1596
      index2 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1595
    index1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1719
  tmp___7 = strcmp((char const   *)opt, "unmatch");
  }
#line 1719
  if (tmp___7 == 0) {
#line 1719
    goto _L___1;
  } else {
    {
#line 1719
    tmp___8 = strcmp((char const   *)opt, "all");
    }
#line 1719
    if (tmp___8 == 0) {
      _L___1: /* CIL Label */ 
      {
#line 1720
      isOEMtype___1 = 0;
#line 1721
      printf((char const   */* __restrict  */)"  Unmatching result\n");
#line 1722
      index1 = 0;
      }
      {
#line 1722
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1722
        if (! (index1 < (int )record1.link_desc_count)) {
#line 1722
          goto while_break___2;
        }
        {
#line 1723
        isOEMtype___1 = ipmi_ek_display_link_descriptor___0(file_type2, record1.rsc_id,
                                                            (char *)"", *(record1.link_desc + index1));
        }
#line 1725
        if (isOEMtype___1) {
          {
#line 1726
          ipmi_ek_display_oem_guid___0(record1);
          }
        }
        {
#line 1728
        printf((char const   */* __restrict  */)"   %s\n", STAR_LINE_LIMITER);
#line 1722
        index1 ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1730
      index2 = 0;
      {
#line 1730
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1730
        if (! (index2 < (int )record2.link_desc_count)) {
#line 1730
          goto while_break___3;
        }
#line 1731
        if (! *(record2.matching_result + index2)) {
          {
#line 1732
          isOEMtype___1 = ipmi_ek_display_link_descriptor___0(file_type1, record2.rsc_id,
                                                              (char *)"", *(record2.link_desc + index2));
          }
#line 1734
          if (isOEMtype___1) {
            {
#line 1735
            ipmi_ek_display_oem_guid___0(record2);
            }
          }
          {
#line 1737
          printf((char const   */* __restrict  */)"   %s\n", STAR_LINE_LIMITER);
          }
        }
#line 1730
        index2 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
  {
#line 1742
  free((void *)record1.matching_result);
#line 1743
  record1.matching_result = (int *)((void *)0);
#line 1744
  free((void *)record2.matching_result);
#line 1745
  record2.matching_result = (int *)((void *)0);
  }
#line 1747
  return (result);
}
}
#line 1778 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_compare_channel_descriptor___0(struct fru_picmgext_amc_channel_desc_record ch_desc1 ,
                                                  struct fru_picmgext_amc_channel_desc_record ch_desc2 ,
                                                  struct fru_picmgext_carrier_p2p_descriptor *port_desc ,
                                                  int index_port , unsigned char rsc_id ) 
{ 
  int match_lane ;

  {
#line 1785
  match_lane = 0;
#line 1788
  if (((int )rsc_id & (int )AMC_MODULE) == (int )AMC_MODULE) {
#line 1789
    if (ch_desc1.lane0port == (unsigned int )(port_desc + index_port)->local_port) {
#line 1789
      if (ch_desc2.lane0port == (unsigned int )(port_desc + index_port)->remote_port) {
#line 1794
        if (ch_desc1.lane1port != (unsigned int )DISABLE_PORT) {
#line 1795
          index_port ++;
#line 1796
          if (ch_desc1.lane1port == (unsigned int )(port_desc + index_port)->local_port) {
#line 1796
            if (ch_desc2.lane1port == (unsigned int )(port_desc + index_port)->remote_port) {
#line 1800
              if (ch_desc1.lane2port != (unsigned int )DISABLE_PORT) {
#line 1801
                index_port ++;
#line 1802
                if (ch_desc1.lane2port == (unsigned int )(port_desc + index_port)->local_port) {
#line 1802
                  if (ch_desc2.lane2port == (unsigned int )(port_desc + index_port)->remote_port) {
#line 1806
                    if (ch_desc1.lane3port != (unsigned int )DISABLE_PORT) {
#line 1807
                      index_port ++;
#line 1808
                      if (ch_desc1.lane3port == (unsigned int )(port_desc + index_port)->local_port) {
#line 1808
                        if (ch_desc2.lane3port == (unsigned int )(port_desc + index_port)->remote_port) {
#line 1814
                          match_lane = 1;
                        }
                      }
                    } else {
#line 1818
                      match_lane = 1;
                    }
                  }
                }
              } else {
#line 1823
                match_lane = 1;
              }
            }
          }
        } else {
#line 1828
          match_lane = 1;
        }
      }
    }
  } else
#line 1834
  if (ch_desc1.lane0port == (unsigned int )(port_desc + index_port)->remote_port) {
#line 1834
    if (ch_desc2.lane0port == (unsigned int )(port_desc + index_port)->local_port) {
#line 1838
      if (ch_desc1.lane1port != (unsigned int )DISABLE_PORT) {
#line 1839
        index_port ++;
#line 1840
        if (ch_desc1.lane1port == (unsigned int )(port_desc + index_port)->remote_port) {
#line 1840
          if (ch_desc2.lane1port == (unsigned int )(port_desc + index_port)->local_port) {
#line 1844
            if (ch_desc1.lane2port != (unsigned int )DISABLE_PORT) {
#line 1845
              index_port ++;
#line 1846
              if (ch_desc1.lane2port == (unsigned int )(port_desc + index_port)->remote_port) {
#line 1846
                if (ch_desc2.lane2port == (unsigned int )(port_desc + index_port)->local_port) {
#line 1850
                  if (ch_desc1.lane3port != (unsigned int )DISABLE_PORT) {
#line 1851
                    index_port ++;
#line 1852
                    if (ch_desc1.lane3port == (unsigned int )(port_desc + index_port)->remote_port) {
#line 1852
                      if (ch_desc2.lane3port == (unsigned int )(port_desc + index_port)->local_port) {
#line 1858
                        match_lane = 1;
                      }
                    }
                  } else {
#line 1862
                    match_lane = 1;
                  }
                }
              }
            } else {
#line 1867
              match_lane = 1;
            }
          }
        }
      } else {
#line 1872
        match_lane = 1;
      }
    }
  }
#line 1877
  return (match_lane);
}
}
#line 1902 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_compare_link_descriptor___0(struct ipmi_ek_amc_p2p_connectivity_record record1 ,
                                               int index1 , struct ipmi_ek_amc_p2p_connectivity_record record2 ,
                                               int index2 ) 
{ 
  int result ;
  int i ;
  int j ;
  int tmp ;
  unsigned char *asym ;
  unsigned long __lengthofasym ;
  void *tmp___0 ;
  int offset ;
  int tmp___1 ;
  struct fru_picmgext_amc_link_desc_record *link ;
  unsigned long __lengthoflink ;
  void *tmp___2 ;
  int index___0 ;
  int tmp___3 ;

  {
#line 1907
  result = (int )ERROR_STATUS;
#line 1909
  if ((record1.link_desc + index1)->type == (record2.link_desc + index2)->type) {
#line 1911
    if ((record1.link_desc + index1)->type >= (unsigned int )LOWER_OEM_TYPE) {
#line 1911
      if ((record1.link_desc + index1)->type <= (unsigned int )UPPER_OEM_TYPE) {
#line 1914
        if ((int )record1.guid_count == 0) {
#line 1914
          if ((int )record2.guid_count == 0) {
#line 1916
            result = (int )OK_STATUS;
          } else {
#line 1914
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 1919
          i = 0;
#line 1920
          j = 0;
#line 1922
          i = 0;
          {
#line 1922
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1922
            if (! (i < (int )record1.guid_count)) {
#line 1922
              goto while_break;
            }
#line 1923
            j = 0;
            {
#line 1923
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 1923
              if (! (j < (int )record2.guid_count)) {
#line 1923
                goto while_break___0;
              }
              {
#line 1924
              tmp = memcmp((void const   *)(record1.oem_guid + i), (void const   *)(record2.oem_guid + j),
                           (size_t )16);
              }
#line 1924
              if (tmp == 0) {
#line 1928
                result = (int )OK_STATUS;
#line 1929
                goto while_break___0;
              }
#line 1923
              j ++;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 1922
            i ++;
          }
          while_break: /* CIL Label */ ;
          }
        }
      } else {
#line 1936
        result = (int )OK_STATUS;
      }
    } else {
#line 1936
      result = (int )OK_STATUS;
    }
#line 1938
    if (result == (int )OK_STATUS) {
#line 1939
      if ((record1.link_desc + index1)->type_ext == (record2.link_desc + index2)->type_ext) {
        {
#line 1942
        __lengthofasym = (unsigned long )COMPARE_CANDIDATE;
#line 1942
        tmp___0 = __builtin_alloca(sizeof(*asym) * __lengthofasym);
#line 1942
        asym = (unsigned char *)tmp___0;
#line 1943
        offset = 0;
#line 1945
        tmp___1 = offset;
#line 1945
        offset ++;
#line 1945
        *(asym + tmp___1) = (unsigned char )(record1.link_desc + index1)->asym_match;
#line 1946
        *(asym + offset) = (unsigned char )(record2.link_desc + index2)->asym_match;
#line 1947
        result = ipmi_ek_compare_asym___0((unsigned char *)asym);
        }
#line 1948
        if (result == (int )OK_STATUS) {
          {
#line 1949
          __lengthoflink = (unsigned long )COMPARE_CANDIDATE;
#line 1949
          tmp___2 = __builtin_alloca(sizeof(*link) * __lengthoflink);
#line 1949
          link = (struct fru_picmgext_amc_link_desc_record *)tmp___2;
#line 1950
          index___0 = 0;
#line 1952
          tmp___3 = index___0;
#line 1952
          index___0 ++;
#line 1952
          *(link + tmp___3) = *(record1.link_desc + index1);
#line 1953
          *(link + index___0) = *(record2.link_desc + index2);
#line 1954
          result = ipmi_ek_compare_number_of_enable_port___0((struct fru_picmgext_amc_link_desc_record *)link);
          }
        } else {
#line 1957
          result = (int )ERROR_STATUS;
        }
      } else {
#line 1961
        result = (int )ERROR_STATUS;
      }
    }
  } else {
#line 1966
    result = (int )ERROR_STATUS;
  }
#line 1969
  return (result);
}
}
#line 1991 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_compare_asym___0(unsigned char *asym ) 
{ 
  int return_value ;
  int first_index ;
  int second_index ;

  {
#line 1994
  return_value = (int )ERROR_STATUS;
#line 1995
  first_index = 0;
#line 1996
  second_index = 1;
#line 1998
  if ((int )*(asym + first_index) == 0) {
#line 1998
    if ((int )*(asym + second_index) == 0) {
#line 1999
      return_value = (int )OK_STATUS;
    } else {
#line 1998
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2001
  if (((int )*(asym + first_index) & (int )*(asym + second_index)) == 0) {
#line 2002
    return_value = (int )OK_STATUS;
  } else {
#line 2005
    return_value = (int )ERROR_STATUS;
  }
#line 2007
  return (return_value);
}
}
#line 2028 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_compare_number_of_enable_port___0(struct fru_picmgext_amc_link_desc_record *link_desc ) 
{ 
  int amc_port_count ;
  int carrier_port_count ;
  int return_value ;
  int index___0 ;
  int tmp ;

  {
#line 2032
  amc_port_count = 0;
#line 2033
  carrier_port_count = 0;
#line 2034
  return_value = (int )ERROR_STATUS;
#line 2035
  index___0 = 0;
#line 2037
  if ((link_desc + index___0)->port_flag_0) {
#line 2038
    amc_port_count ++;
  }
#line 2040
  if ((link_desc + index___0)->port_flag_1) {
#line 2041
    amc_port_count ++;
  }
#line 2043
  if ((link_desc + index___0)->port_flag_2) {
#line 2044
    amc_port_count ++;
  }
#line 2046
  tmp = index___0;
#line 2046
  index___0 ++;
#line 2046
  if ((link_desc + tmp)->port_flag_3) {
#line 2047
    amc_port_count ++;
  }
#line 2051
  if ((link_desc + index___0)->port_flag_0) {
#line 2052
    carrier_port_count ++;
  }
#line 2054
  if ((link_desc + index___0)->port_flag_1) {
#line 2055
    carrier_port_count ++;
  }
#line 2057
  if ((link_desc + index___0)->port_flag_2) {
#line 2058
    carrier_port_count ++;
  }
#line 2060
  if ((link_desc + index___0)->port_flag_3) {
#line 2061
    carrier_port_count ++;
  }
#line 2064
  if (carrier_port_count == amc_port_count) {
#line 2066
    return_value = (int )OK_STATUS;
  } else {
#line 2069
    return_value = (int )ERROR_STATUS;
  }
#line 2072
  return (return_value);
}
}
#line 2098 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_display_link_descriptor___0(int file_type , unsigned char rsc_id ,
                                               char *str___1 , struct fru_picmgext_amc_link_desc_record link_desc ) 
{ 
  int isOEMtype ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;

  {
#line 2102
  isOEMtype = 0;
#line 2104
  if (file_type == 9) {
    {
#line 2105
    printf((char const   */* __restrict  */)"  - %s On-Carrier Device ID %d\n", str___1,
           (int )rsc_id & 15);
    }
  } else {
    {
#line 2108
    tmp = val2str((uint16_t )file_type, ipmi_ekanalyzer_module_type);
#line 2108
    printf((char const   */* __restrict  */)"  - %s %s\n", str___1, tmp);
    }
  }
  {
#line 2112
  printf((char const   */* __restrict  */)"    - Channel ID %d || ", link_desc.channel_id);
  }
#line 2113
  if (link_desc.port_flag_0) {
#line 2113
    tmp___0 = "Lane 0: enable";
  } else {
#line 2113
    tmp___0 = "";
  }
  {
#line 2113
  printf((char const   */* __restrict  */)"%s", tmp___0);
  }
#line 2114
  if (link_desc.port_flag_1) {
#line 2114
    tmp___1 = ", Lane 1: enable";
  } else {
#line 2114
    tmp___1 = "";
  }
  {
#line 2114
  printf((char const   */* __restrict  */)"%s", tmp___1);
  }
#line 2115
  if (link_desc.port_flag_2) {
#line 2115
    tmp___2 = ", Lane 2: enable";
  } else {
#line 2115
    tmp___2 = "";
  }
  {
#line 2115
  printf((char const   */* __restrict  */)"%s", tmp___2);
  }
#line 2116
  if (link_desc.port_flag_3) {
#line 2116
    tmp___3 = ", Lane 3: enable";
  } else {
#line 2116
    tmp___3 = "";
  }
  {
#line 2116
  printf((char const   */* __restrict  */)"%s", tmp___3);
#line 2118
  printf((char const   */* __restrict  */)"\n");
#line 2119
  tmp___4 = val2str((uint16_t )link_desc.type, ipmi_ekanalyzer_link_type);
#line 2119
  printf((char const   */* __restrict  */)"    - Link Type: %s \n", tmp___4);
  }
  {
#line 2124
  if (link_desc.type == 4U) {
#line 2124
    goto case_4;
  }
#line 2124
  if (link_desc.type == 3U) {
#line 2124
    goto case_4;
  }
#line 2124
  if (link_desc.type == 2U) {
#line 2124
    goto case_4;
  }
#line 2132
  if (link_desc.type == 5U) {
#line 2132
    goto case_5;
  }
#line 2140
  if (link_desc.type == 7U) {
#line 2140
    goto case_7;
  }
#line 2148
  goto switch_default;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 2125
  tmp___5 = val2str((uint16_t )link_desc.type_ext, ipmi_ekanalyzer_extension_PCIE);
#line 2125
  printf((char const   */* __restrict  */)"    - Link Type extension: %s\n", tmp___5);
#line 2127
  printf((char const   */* __restrict  */)"    - Link Group ID: %d || ", link_desc.group_id);
#line 2128
  tmp___6 = val2str((uint16_t )link_desc.asym_match, ipmi_ekanalyzer_asym_PCIE);
#line 2128
  printf((char const   */* __restrict  */)"Link Asym. Match: %d - %s\n", link_desc.asym_match,
         tmp___6);
  }
#line 2131
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 2133
  tmp___7 = val2str((uint16_t )link_desc.type_ext, ipmi_ekanalyzer_extension_ETHERNET);
#line 2133
  printf((char const   */* __restrict  */)"    - Link Type extension: %s\n", tmp___7);
#line 2135
  printf((char const   */* __restrict  */)"    - Link Group ID: %d || ", link_desc.group_id);
#line 2136
  tmp___8 = val2str((uint16_t )link_desc.asym_match, ipmi_ekanalyzer_asym_PCIE);
#line 2136
  printf((char const   */* __restrict  */)"Link Asym. Match: %d - %s\n", link_desc.asym_match,
         tmp___8);
  }
#line 2139
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 2141
  tmp___9 = val2str((uint16_t )link_desc.type_ext, ipmi_ekanalyzer_extension_STORAGE);
#line 2141
  printf((char const   */* __restrict  */)"    - Link Type extension: %s\n", tmp___9);
#line 2143
  printf((char const   */* __restrict  */)"    - Link Group ID: %d || ", link_desc.group_id);
#line 2144
  tmp___10 = val2str((uint16_t )link_desc.asym_match, ipmi_ekanalyzer_asym_STORAGE);
#line 2144
  printf((char const   */* __restrict  */)"Link Asym. Match: %d - %s\n", link_desc.asym_match,
         tmp___10);
  }
#line 2147
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2149
  printf((char const   */* __restrict  */)"    - Link Type extension: %i\n", link_desc.type_ext);
#line 2150
  printf((char const   */* __restrict  */)"    - Link Group ID: %d || ", link_desc.group_id);
#line 2151
  printf((char const   */* __restrict  */)"Link Asym. Match: %i\n", link_desc.asym_match);
  }
#line 2152
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2155
  if (link_desc.type >= (unsigned int )LOWER_OEM_TYPE) {
#line 2155
    if (link_desc.type <= (unsigned int )UPPER_OEM_TYPE) {
#line 2159
      isOEMtype = 1;
    }
  }
#line 2162
  return (isOEMtype);
}
}
#line 2182 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_oem_guid___0(struct ipmi_ek_amc_p2p_connectivity_record amc_record ) 
{ 
  int index_oem ;
  int index___0 ;

  {
#line 2186
  index_oem = 0;
#line 2187
  index___0 = 0;
#line 2189
  if ((int )amc_record.guid_count == 0) {
    {
#line 2190
    printf((char const   */* __restrict  */)"\tThere is no OEM GUID for this module\n");
    }
  }
#line 2192
  index_oem = 0;
  {
#line 2192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2192
    if (! (index_oem < (int )amc_record.guid_count)) {
#line 2192
      goto while_break;
    }
    {
#line 2193
    printf((char const   */* __restrict  */)"    - GUID: ");
#line 2194
    index___0 = 0;
    }
    {
#line 2194
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2194
      if (! (index___0 < 16)) {
#line 2194
        goto while_break___0;
      }
      {
#line 2195
      printf((char const   */* __restrict  */)"%02x", (int )(amc_record.oem_guid + index_oem)->guid[index___0]);
      }
#line 2197
      if (! (index___0 % 4)) {
        {
#line 2198
        printf((char const   */* __restrict  */)"-");
        }
      }
#line 2194
      index___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2201
    printf((char const   */* __restrict  */)"\n");
#line 2192
    index_oem ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2203
  return;
}
}
#line 2224 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_create_amc_p2p_record___0(struct ipmi_ek_multi_header *record ,
                                             struct ipmi_ek_amc_p2p_connectivity_record *amc_record ) 
{ 
  int index_data ;
  int return_status ;
  int tmp ;
  int index_oem ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int ch_index ;
  void *tmp___5 ;
  unsigned int data ;
  struct fru_picmgext_amc_channel_desc_record *src ;
  struct fru_picmgext_amc_channel_desc_record *dst ;
  int i ;
  void *tmp___6 ;
  unsigned int data___0[2] ;
  struct fru_picmgext_amc_link_desc_record *src___0 ;
  struct fru_picmgext_amc_link_desc_record *dst___0 ;

  {
#line 2228
  index_data = (int )START_DATA_OFFSET;
#line 2229
  return_status = (int )OK_STATUS;
#line 2231
  tmp = index_data;
#line 2231
  index_data ++;
#line 2231
  amc_record->guid_count = *(record->data + tmp);
#line 2232
  if ((int )amc_record->guid_count > 0) {
    {
#line 2233
    index_oem = 0;
#line 2234
    tmp___0 = malloc((unsigned long )amc_record->guid_count * sizeof(struct fru_picmgext_guid ));
#line 2234
    amc_record->oem_guid = (struct fru_picmgext_guid *)tmp___0;
#line 2236
    index_oem = 0;
    }
    {
#line 2236
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2236
      if (! (index_oem < (int )amc_record->guid_count)) {
#line 2236
        goto while_break;
      }
      {
#line 2238
      memcpy((void */* __restrict  */)(& (amc_record->oem_guid + index_oem)->guid),
             (void const   */* __restrict  */)(record->data + index_data), (size_t )16);
#line 2241
      index_data += 16;
#line 2236
      index_oem ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2243
    tmp___1 = index_data;
#line 2243
    index_data ++;
#line 2243
    amc_record->rsc_id = *(record->data + tmp___1);
#line 2244
    tmp___2 = index_data;
#line 2244
    index_data ++;
#line 2244
    amc_record->ch_count = *(record->data + tmp___2);
#line 2246
    amc_record->link_desc_count = (unsigned char )(((((int )record->header.len - 8) - 16 * (int )amc_record->guid_count) - 3 * (int )amc_record->ch_count) / 5);
  } else {
#line 2251
    tmp___3 = index_data;
#line 2251
    index_data ++;
#line 2251
    amc_record->rsc_id = *(record->data + tmp___3);
#line 2252
    tmp___4 = index_data;
#line 2252
    index_data ++;
#line 2252
    amc_record->ch_count = *(record->data + tmp___4);
#line 2254
    amc_record->link_desc_count = (unsigned char )((((int )record->header.len - 8) - 3 * (int )amc_record->ch_count) / 5);
  }
#line 2259
  if ((int )amc_record->ch_count > 0) {
    {
#line 2260
    ch_index = 0;
#line 2261
    tmp___5 = malloc((unsigned long )amc_record->ch_count * sizeof(struct fru_picmgext_amc_channel_desc_record ));
#line 2261
    amc_record->ch_desc = (struct fru_picmgext_amc_channel_desc_record *)tmp___5;
#line 2263
    ch_index = 0;
    }
    {
#line 2263
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2263
      if (! (ch_index < (int )amc_record->ch_count)) {
#line 2263
        goto while_break___0;
      }
#line 2267
      data = (unsigned int )(((int )*(record->data + index_data) | ((int )*(record->data + (index_data + 1)) << 8)) | ((int )*(record->data + (index_data + 2)) << 16));
#line 2271
      src = (struct fru_picmgext_amc_channel_desc_record *)(& data);
#line 2272
      dst = amc_record->ch_desc + ch_index;
#line 2275
      dst->lane0port = src->lane0port;
#line 2276
      dst->lane1port = src->lane1port;
#line 2277
      dst->lane2port = src->lane2port;
#line 2278
      dst->lane3port = src->lane3port;
#line 2279
      index_data += 3;
#line 2263
      ch_index ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2282
  if ((int )amc_record->link_desc_count > 0) {
    {
#line 2283
    i = 0;
#line 2284
    tmp___6 = malloc((unsigned long )amc_record->link_desc_count * sizeof(struct fru_picmgext_amc_link_desc_record ));
#line 2284
    amc_record->link_desc = (struct fru_picmgext_amc_link_desc_record *)tmp___6;
#line 2286
    i = 0;
    }
    {
#line 2286
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2286
      if (! (i < (int )amc_record->link_desc_count)) {
#line 2286
        goto while_break___1;
      }
#line 2289
      data___0[0] = (unsigned int )((((int )*(record->data + index_data) | ((int )*(record->data + (index_data + 1)) << 8)) | ((int )*(record->data + (index_data + 2)) << 16)) | ((int )*(record->data + (index_data + 3)) << 24));
#line 2294
      data___0[1] = (unsigned int )*(record->data + (index_data + 4));
#line 2295
      src___0 = (struct fru_picmgext_amc_link_desc_record *)(& data___0);
#line 2296
      dst___0 = amc_record->link_desc + i;
#line 2299
      dst___0->channel_id = src___0->channel_id;
#line 2300
      dst___0->port_flag_0 = src___0->port_flag_0;
#line 2301
      dst___0->port_flag_1 = src___0->port_flag_1;
#line 2302
      dst___0->port_flag_2 = src___0->port_flag_2;
#line 2303
      dst___0->port_flag_3 = src___0->port_flag_3;
#line 2304
      dst___0->type = src___0->type;
#line 2305
      dst___0->type_ext = src___0->type_ext;
#line 2306
      dst___0->group_id = src___0->group_id;
#line 2307
      dst___0->asym_match = src___0->asym_match;
#line 2308
      index_data += 5;
#line 2286
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 2311
    return_status = (int )ERROR_STATUS;
  }
#line 2313
  return (return_status);
}
}
#line 2336 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_get_resource_descriptor___0(int port_count , int index___0 , struct fru_picmgext_carrier_p2p_descriptor *port_desc ,
                                               struct ipmi_ek_multi_header *record ) 
{ 
  int num_port ;

  {
#line 2341
  num_port = 0;
  {
#line 2343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2343
    if (! (num_port < port_count)) {
#line 2343
      goto while_break;
    }
    {
#line 2344
    memcpy((void */* __restrict  */)(port_desc + num_port), (void const   */* __restrict  */)(record->data + index___0),
           sizeof(struct fru_picmgext_carrier_p2p_descriptor ));
#line 2346
    index___0 = (int )((unsigned long )index___0 + sizeof(struct fru_picmgext_carrier_p2p_descriptor ));
#line 2347
    num_port ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2350
  return (index___0);
}
}
#line 2371 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_display_fru_header___0(char *filename ) 
{ 
  FILE *input_file ;
  struct fru_header header ;
  int ret ;
  size_t tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 2376
  ret = 0;
#line 2378
  input_file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 2379
  if ((unsigned long )input_file == (unsigned long )((void *)0)) {
    {
#line 2380
    lprintf(3, "File \'%s\' not found.", filename);
    }
#line 2381
    return ((int )ERROR_STATUS);
  }
  {
#line 2383
  tmp = fread((void */* __restrict  */)(& header), sizeof(struct fru_header ), (size_t )1,
              (FILE */* __restrict  */)input_file);
#line 2383
  ret = (int )tmp;
  }
#line 2384
  if (ret != 1) {
    {
#line 2385
    lprintf(3, "Failed to read FRU header!");
#line 2386
    fclose(input_file);
    }
#line 2387
    return ((int )ERROR_STATUS);
  } else {
    {
#line 2384
    tmp___0 = ferror(input_file);
    }
#line 2384
    if (tmp___0) {
      {
#line 2385
      lprintf(3, "Failed to read FRU header!");
#line 2386
      fclose(input_file);
      }
#line 2387
      return ((int )ERROR_STATUS);
    }
  }
  {
#line 2389
  printf((char const   */* __restrict  */)"%s\n", EQUAL_LINE_LIMITER);
#line 2390
  printf((char const   */* __restrict  */)"FRU Header Info\n");
#line 2391
  printf((char const   */* __restrict  */)"%s\n", EQUAL_LINE_LIMITER);
  }
#line 2392
  if (((int )header.version & 15) == 1) {
#line 2392
    tmp___1 = "";
  } else {
#line 2392
    tmp___1 = "{unsupported}";
  }
  {
#line 2392
  printf((char const   */* __restrict  */)"Format Version          :0x%02x %s\n",
         (int )header.version & 15, tmp___1);
#line 2395
  printf((char const   */* __restrict  */)"Internal Use Offset     :0x%02x\n", (int )header.offset.internal);
#line 2396
  printf((char const   */* __restrict  */)"Chassis Info Offset     :0x%02x\n", (int )header.offset.chassis);
#line 2397
  printf((char const   */* __restrict  */)"Board Info Offset       :0x%02x\n", (int )header.offset.board);
#line 2398
  printf((char const   */* __restrict  */)"Product Info Offset     :0x%02x\n", (int )header.offset.product);
#line 2399
  printf((char const   */* __restrict  */)"MultiRecord Offset      :0x%02x\n", (int )header.offset.multi);
#line 2400
  printf((char const   */* __restrict  */)"Common header Checksum  :0x%02x\n", (int )header.checksum);
#line 2402
  fclose(input_file);
  }
#line 2403
  return ((int )OK_STATUS);
}
}
#line 2426 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_display_fru_header_detail___0(char *filename ) 
{ 
  FILE *input_file ;
  size_t file_offset ;
  struct fru_header header ;
  time_t tval ;
  int ret ;
  unsigned char data ;
  unsigned char lan_code ;
  unsigned char mfg_date[3] ;
  unsigned int board_length ;
  size_t tmp ;
  int tmp___0 ;
  unsigned char format_version ;
  unsigned long len ;
  size_t tmp___1 ;
  int tmp___2 ;
  unsigned char data___0 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long offset ;
  int tmp___7 ;
  long tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  struct tm *tmp___19 ;
  char *tmp___20 ;
  long offset___0 ;
  int tmp___21 ;

  {
  {
#line 2432
  file_offset = (size_t )0;
#line 2435
  ret = 0;
#line 2436
  data = (unsigned char)0;
#line 2437
  lan_code = (unsigned char)0;
#line 2439
  board_length = 0U;
#line 2441
  input_file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 2442
  if ((unsigned long )input_file == (unsigned long )((void *)0)) {
    {
#line 2443
    lprintf(3, "File \'%s\' not found.", filename);
    }
#line 2444
    return (-1);
  }
  {
#line 2450
  tmp = fread((void */* __restrict  */)(& header), sizeof(struct fru_header ), (size_t )1,
              (FILE */* __restrict  */)input_file);
#line 2450
  ret = (int )tmp;
  }
#line 2451
  if (ret != 1) {
    {
#line 2452
    lprintf(3, "Failed to read FRU header!");
#line 2453
    fclose(input_file);
    }
#line 2454
    return (-1);
  } else {
    {
#line 2451
    tmp___0 = ferror(input_file);
    }
#line 2451
    if (tmp___0) {
      {
#line 2452
      lprintf(3, "Failed to read FRU header!");
#line 2453
      fclose(input_file);
      }
#line 2454
      return (-1);
    }
  }
  {
#line 2457
  tmp___6 = feof(input_file);
  }
#line 2457
  if (! tmp___6) {
    {
#line 2459
    len = 0UL;
#line 2461
    printf((char const   */* __restrict  */)"%s\n", EQUAL_LINE_LIMITER);
#line 2462
    printf((char const   */* __restrict  */)"FRU Internal Use Info\n");
#line 2463
    printf((char const   */* __restrict  */)"%s\n", EQUAL_LINE_LIMITER);
#line 2465
    tmp___1 = fread((void */* __restrict  */)(& format_version), (size_t )1, (size_t )1,
                    (FILE */* __restrict  */)input_file);
#line 2465
    ret = (int )tmp___1;
    }
#line 2466
    if (ret != 1) {
      {
#line 2467
      lprintf(3, "Invalid format version!");
#line 2468
      fclose(input_file);
      }
#line 2469
      return (-1);
    } else {
      {
#line 2466
      tmp___2 = ferror(input_file);
      }
#line 2466
      if (tmp___2) {
        {
#line 2467
        lprintf(3, "Invalid format version!");
#line 2468
        fclose(input_file);
        }
#line 2469
        return (-1);
      }
    }
    {
#line 2471
    printf((char const   */* __restrict  */)"Format Version: %d\n", (int )format_version & 15);
    }
#line 2473
    if ((int )header.offset.chassis > 0) {
#line 2474
      len = (unsigned long )((int )header.offset.chassis * 8 - (int )header.offset.internal * 8);
    } else {
#line 2477
      len = (unsigned long )((int )header.offset.board * 8 - (int )header.offset.internal * 8);
    }
    {
#line 2480
    printf((char const   */* __restrict  */)"Length: %ld\n", len);
#line 2481
    printf((char const   */* __restrict  */)"Data dump:\n");
    }
    {
#line 2482
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2482
      if (len > 0UL) {
        {
#line 2482
        tmp___5 = feof(input_file);
        }
#line 2482
        if (tmp___5) {
#line 2482
          goto while_break;
        }
      } else {
#line 2482
        goto while_break;
      }
      {
#line 2484
      tmp___3 = fread((void */* __restrict  */)(& data___0), (size_t )1, (size_t )1,
                      (FILE */* __restrict  */)input_file);
#line 2484
      ret = (int )tmp___3;
      }
#line 2485
      if (ret != 1) {
        {
#line 2486
        lprintf(3, "Invalid data!");
#line 2487
        fclose(input_file);
        }
#line 2488
        return (-1);
      } else {
        {
#line 2485
        tmp___4 = ferror(input_file);
        }
#line 2485
        if (tmp___4) {
          {
#line 2486
          lprintf(3, "Invalid data!");
#line 2487
          fclose(input_file);
          }
#line 2488
          return (-1);
        }
      }
      {
#line 2490
      printf((char const   */* __restrict  */)"0x%02x ", (int )data___0);
#line 2491
      len --;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2493
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 2496
  if ((int )header.offset.chassis != 0) {
    {
#line 2497
    offset = 0L;
#line 2498
    offset = (long )((int )header.offset.chassis * 8);
#line 2499
    ret = ipmi_ek_display_chassis_info_area___0(input_file, offset);
    }
  }
  {
#line 2502
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2503
    if ((int )header.offset.board == 0) {
#line 2504
      goto while_break___0;
    }
    {
#line 2506
    ret = fseek(input_file, (long )((int )header.offset.board * 8), 0);
#line 2509
    tmp___7 = feof(input_file);
    }
#line 2509
    if (tmp___7) {
#line 2510
      goto while_break___0;
    }
    {
#line 2512
    tmp___8 = ftell(input_file);
#line 2512
    file_offset = (size_t )tmp___8;
#line 2513
    printf((char const   */* __restrict  */)"%s\n", EQUAL_LINE_LIMITER);
#line 2514
    printf((char const   */* __restrict  */)"FRU Board Info Area\n");
#line 2515
    printf((char const   */* __restrict  */)"%s\n", EQUAL_LINE_LIMITER);
#line 2517
    tmp___9 = fread((void */* __restrict  */)(& data), (size_t )1, (size_t )1, (FILE */* __restrict  */)input_file);
#line 2517
    ret = (int )tmp___9;
    }
#line 2518
    if (ret != 1) {
      {
#line 2519
      lprintf(3, "Invalid FRU Format Version!");
#line 2520
      fclose(input_file);
      }
#line 2521
      return (-1);
    } else {
      {
#line 2518
      tmp___10 = ferror(input_file);
      }
#line 2518
      if (tmp___10) {
        {
#line 2519
        lprintf(3, "Invalid FRU Format Version!");
#line 2520
        fclose(input_file);
        }
#line 2521
        return (-1);
      }
    }
    {
#line 2523
    printf((char const   */* __restrict  */)"Format Version: %d\n", (int )data & 15);
#line 2524
    tmp___11 = feof(input_file);
    }
#line 2524
    if (tmp___11) {
#line 2525
      goto while_break___0;
    }
    {
#line 2527
    tmp___12 = fread((void */* __restrict  */)(& data), (size_t )1, (size_t )1, (FILE */* __restrict  */)input_file);
#line 2527
    ret = (int )tmp___12;
    }
#line 2528
    if (ret != 1) {
      {
#line 2529
      lprintf(3, "Invalid Board Area Length!");
#line 2530
      fclose(input_file);
      }
#line 2531
      return (-1);
    } else {
      {
#line 2528
      tmp___13 = ferror(input_file);
      }
#line 2528
      if (tmp___13) {
        {
#line 2529
        lprintf(3, "Invalid Board Area Length!");
#line 2530
        fclose(input_file);
        }
#line 2531
        return (-1);
      }
    }
    {
#line 2533
    board_length = (unsigned int )((int )data * 8);
#line 2534
    printf((char const   */* __restrict  */)"Area Length: %d\n", board_length);
#line 2539
    board_length -= 2U;
#line 2540
    tmp___14 = feof(input_file);
    }
#line 2540
    if (tmp___14) {
#line 2541
      goto while_break___0;
    }
    {
#line 2543
    tmp___15 = fread((void */* __restrict  */)(& lan_code), (size_t )1, (size_t )1,
                     (FILE */* __restrict  */)input_file);
#line 2543
    ret = (int )tmp___15;
    }
#line 2544
    if (ret != 1) {
      {
#line 2545
      lprintf(3, "Invalid Language Code in input");
#line 2546
      fclose(input_file);
      }
#line 2547
      return (-1);
    } else {
      {
#line 2544
      tmp___16 = ferror(input_file);
      }
#line 2544
      if (tmp___16) {
        {
#line 2545
        lprintf(3, "Invalid Language Code in input");
#line 2546
        fclose(input_file);
        }
#line 2547
        return (-1);
      }
    }
    {
#line 2549
    printf((char const   */* __restrict  */)"Language Code: %d\n", (int )lan_code);
#line 2550
    board_length --;
#line 2552
    tmp___17 = feof(input_file);
    }
#line 2552
    if (tmp___17) {
#line 2553
      goto while_break___0;
    }
    {
#line 2556
    tmp___18 = fread((void */* __restrict  */)(mfg_date), (size_t )3, (size_t )1,
                     (FILE */* __restrict  */)input_file);
#line 2556
    ret = (int )tmp___18;
    }
#line 2557
    if (ret != 1) {
      {
#line 2558
      lprintf(3, "Invalid Board Data.");
#line 2559
      fclose(input_file);
      }
#line 2560
      return (-1);
    }
    {
#line 2562
    tval = (time_t )((((int )mfg_date[2] << 16) + ((int )mfg_date[1] << 8)) + (int )mfg_date[0]);
#line 2564
    tval *= 60L;
#line 2565
    tval = (time_t )((unsigned long const   )tval + secs_from_1970_1996___1);
#line 2566
    tmp___19 = localtime((time_t const   *)(& tval));
#line 2566
    tmp___20 = asctime((struct tm  const  *)tmp___19);
#line 2566
    printf((char const   */* __restrict  */)"Board Mfg Date: %ld, %s", tval, tmp___20);
#line 2568
    board_length -= 3U;
#line 2570
    file_offset = ipmi_ek_display_board_info_area___0(input_file, (char *)"Board Manufacture Data",
                                                      & board_length);
#line 2572
    ret = fseek(input_file, (long )file_offset, 0);
#line 2574
    file_offset = ipmi_ek_display_board_info_area___0(input_file, (char *)"Board Product Name",
                                                      & board_length);
#line 2576
    ret = fseek(input_file, (long )file_offset, 0);
#line 2578
    file_offset = ipmi_ek_display_board_info_area___0(input_file, (char *)"Board Serial Number",
                                                      & board_length);
#line 2580
    ret = fseek(input_file, (long )file_offset, 0);
#line 2582
    file_offset = ipmi_ek_display_board_info_area___0(input_file, (char *)"Board Part Number",
                                                      & board_length);
#line 2584
    ret = fseek(input_file, (long )file_offset, 0);
#line 2586
    file_offset = ipmi_ek_display_board_info_area___0(input_file, (char *)"FRU File ID",
                                                      & board_length);
#line 2588
    ret = fseek(input_file, (long )file_offset, 0);
#line 2590
    file_offset = ipmi_ek_display_board_info_area___0(input_file, (char *)"Custom",
                                                      & board_length);
    }
#line 2592
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2595
  if (header.offset.product) {
    {
#line 2595
    tmp___21 = feof(input_file);
    }
#line 2595
    if (! tmp___21) {
      {
#line 2596
      offset___0 = 0L;
#line 2597
      offset___0 = (long )((int )header.offset.product * 8);
#line 2598
      ret = ipmi_ek_display_product_info_area___0(input_file, offset___0);
      }
    }
  }
  {
#line 2601
  fclose(input_file);
  }
#line 2602
  return (0);
}
}
#line 2625 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_display_chassis_info_area___0(FILE *input_file , long offset ) 
{ 
  size_t file_offset ;
  int ret ;
  unsigned char data ;
  unsigned char ch_len ;
  unsigned char ch_type ;
  unsigned int len ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
#line 2629
  ret = 0;
#line 2630
  data = (unsigned char)0;
#line 2631
  ch_len = (unsigned char)0;
#line 2632
  ch_type = (unsigned char)0;
#line 2635
  if ((unsigned long )input_file == (unsigned long )((void *)0)) {
    {
#line 2636
    lprintf(3, "No file stream to read.");
    }
#line 2637
    return (-1);
  }
  {
#line 2639
  printf((char const   */* __restrict  */)"%s\n", EQUAL_LINE_LIMITER);
#line 2640
  printf((char const   */* __restrict  */)"Chassis Info Area\n");
#line 2641
  printf((char const   */* __restrict  */)"%s\n", EQUAL_LINE_LIMITER);
#line 2642
  ret = fseek(input_file, offset, 0);
#line 2643
  tmp = feof(input_file);
  }
#line 2643
  if (tmp) {
    {
#line 2644
    lprintf(3, "Invalid Chassis Info Area!");
    }
#line 2645
    return (-1);
  }
  {
#line 2647
  tmp___0 = fread((void */* __restrict  */)(& data), (size_t )1, (size_t )1, (FILE */* __restrict  */)input_file);
#line 2647
  ret = (int )tmp___0;
  }
#line 2648
  if (ret != 1) {
    {
#line 2649
    lprintf(3, "Invalid Version Number!");
    }
#line 2650
    return (-1);
  } else {
    {
#line 2648
    tmp___1 = ferror(input_file);
    }
#line 2648
    if (tmp___1) {
      {
#line 2649
      lprintf(3, "Invalid Version Number!");
      }
#line 2650
      return (-1);
    }
  }
  {
#line 2652
  printf((char const   */* __restrict  */)"Format Version Number: %d\n", (int )data & 15);
#line 2653
  tmp___2 = fread((void */* __restrict  */)(& ch_len), (size_t )1, (size_t )1, (FILE */* __restrict  */)input_file);
#line 2653
  ret = (int )tmp___2;
  }
#line 2654
  if (ret != 1) {
    {
#line 2655
    lprintf(3, "Invalid length!");
    }
#line 2656
    return (-1);
  } else {
    {
#line 2654
    tmp___3 = ferror(input_file);
    }
#line 2654
    if (tmp___3) {
      {
#line 2655
      lprintf(3, "Invalid length!");
      }
#line 2656
      return (-1);
    }
  }
  {
#line 2659
  len = (unsigned int )((int )ch_len * 8);
#line 2660
  printf((char const   */* __restrict  */)"Area Length: %d\n", len);
#line 2661
  len -= 2U;
#line 2662
  tmp___4 = feof(input_file);
  }
#line 2662
  if (tmp___4) {
#line 2663
    return (-1);
  }
  {
#line 2666
  tmp___5 = fread((void */* __restrict  */)(& ch_type), (size_t )1, (size_t )1, (FILE */* __restrict  */)input_file);
#line 2666
  ret = (int )tmp___5;
  }
#line 2667
  if (ret != 1) {
    {
#line 2668
    lprintf(3, "Invalid Chassis Type!");
    }
#line 2669
    return (-1);
  } else {
    {
#line 2667
    tmp___6 = ferror(input_file);
    }
#line 2667
    if (tmp___6) {
      {
#line 2668
      lprintf(3, "Invalid Chassis Type!");
      }
#line 2669
      return (-1);
    }
  }
  {
#line 2671
  printf((char const   */* __restrict  */)"Chassis Type: %d\n", (int )ch_type);
#line 2672
  len --;
#line 2674
  file_offset = ipmi_ek_display_board_info_area___0(input_file, (char *)"Chassis Part Number",
                                                    & len);
#line 2676
  ret = fseek(input_file, (long )file_offset, 0);
#line 2678
  file_offset = ipmi_ek_display_board_info_area___0(input_file, (char *)"Chassis Serial Number",
                                                    & len);
#line 2680
  ret = fseek(input_file, (long )file_offset, 0);
#line 2682
  file_offset = ipmi_ek_display_board_info_area___0(input_file, (char *)"Custom",
                                                    & len);
  }
#line 2684
  return (0);
}
}
#line 2709 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static size_t ipmi_ek_display_board_info_area___0(FILE *input_file , char *board_type ,
                                                  unsigned int *board_length ) 
{ 
  size_t file_offset ;
  int ret ;
  unsigned char len ;
  unsigned int size_board ;
  long tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  unsigned char *data ;
  unsigned int i ;
  void *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned char padding___1 ;
  unsigned char checksum ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  unsigned char *additional_data ;
  unsigned int i___0 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;

  {
#line 2714
  ret = 0;
#line 2715
  len = (unsigned char)0;
#line 2716
  size_board = 0U;
#line 2717
  if ((unsigned long )input_file == (unsigned long )((void *)0)) {
#line 2719
    return ((size_t )-1);
  } else
#line 2717
  if ((unsigned long )board_type == (unsigned long )((void *)0)) {
#line 2719
    return ((size_t )-1);
  } else
#line 2717
  if ((unsigned long )board_length == (unsigned long )((void *)0)) {
#line 2719
    return ((size_t )-1);
  }
  {
#line 2721
  tmp = ftell(input_file);
#line 2721
  file_offset = (size_t )tmp;
#line 2724
  tmp___0 = fread((void */* __restrict  */)(& len), (size_t )1, (size_t )1, (FILE */* __restrict  */)input_file);
#line 2724
  ret = (int )tmp___0;
  }
#line 2725
  if (ret != 1) {
    {
#line 2726
    lprintf(3, "Invalid Length!");
    }
#line 2727
    goto out;
  } else {
    {
#line 2725
    tmp___1 = ferror(input_file);
    }
#line 2725
    if (tmp___1) {
      {
#line 2726
      lprintf(3, "Invalid Length!");
      }
#line 2727
      goto out;
    }
  }
#line 2729
  (*board_length) --;
#line 2732
  size_board = (unsigned int )((int )len & 63);
#line 2733
  if (size_board == 0U) {
    {
#line 2734
    printf((char const   */* __restrict  */)"%s: None\n", board_type);
    }
#line 2735
    goto out;
  }
  {
#line 2737
  tmp___5 = strncmp((char const   *)board_type, "Custom", (size_t )6);
  }
#line 2737
  if (tmp___5 != 0) {
    {
#line 2739
    i = 0U;
#line 2740
    tmp___2 = malloc((size_t )size_board);
#line 2740
    data = (unsigned char *)tmp___2;
    }
#line 2741
    if ((unsigned long )data == (unsigned long )((void *)0)) {
      {
#line 2742
      lprintf(3, "ipmitool: malloc failure");
      }
#line 2743
      return ((size_t )-1);
    }
    {
#line 2745
    tmp___3 = fread((void */* __restrict  */)data, (size_t )size_board, (size_t )1,
                    (FILE */* __restrict  */)input_file);
#line 2745
    ret = (int )tmp___3;
    }
#line 2746
    if (ret != 1) {
      {
#line 2747
      lprintf(3, "Invalid board type size!");
      }
#line 2748
      goto out;
    } else {
      {
#line 2746
      tmp___4 = ferror(input_file);
      }
#line 2746
      if (tmp___4) {
        {
#line 2747
        lprintf(3, "Invalid board type size!");
        }
#line 2748
        goto out;
      }
    }
    {
#line 2750
    printf((char const   */* __restrict  */)"%s type: 0x%02x\n", board_type, (int )len);
#line 2751
    printf((char const   */* __restrict  */)"%s: ", board_type);
#line 2752
    i = 0U;
    }
    {
#line 2752
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2752
      if (! (i < size_board)) {
#line 2752
        goto while_break;
      }
#line 2753
      if (((int )len & 192) == 192) {
        {
#line 2754
        printf((char const   */* __restrict  */)"%c", (int )*(data + i));
        }
      } else {
        {
#line 2759
        printf((char const   */* __restrict  */)"%02x", (int )*(data + i));
        }
      }
#line 2752
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2762
    printf((char const   */* __restrict  */)"\n");
#line 2763
    free((void *)data);
#line 2764
    *board_length -= size_board;
    }
#line 2765
    goto out;
  }
  {
#line 2767
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 2767
    tmp___12 = feof(input_file);
    }
#line 2767
    if (tmp___12) {
#line 2767
      goto while_break___0;
    }
#line 2768
    if ((int )len == 193) {
      {
#line 2770
      checksum = (unsigned char)0;
#line 2774
      printf((char const   */* __restrict  */)"Additional Custom Mfg. length: 0x%02x\n",
             (int )len);
#line 2775
      padding___1 = (unsigned char )(*board_length - 1U);
      }
#line 2776
      if ((int )padding___1 > 0) {
        {
#line 2776
        tmp___6 = feof(input_file);
        }
#line 2776
        if (! tmp___6) {
          {
#line 2777
          printf((char const   */* __restrict  */)"Unused space: %d (bytes)\n", (int )padding___1);
#line 2778
          fseek(input_file, (long )padding___1, 1);
          }
        }
      }
      {
#line 2780
      tmp___7 = fread((void */* __restrict  */)(& checksum), (size_t )1, (size_t )1,
                      (FILE */* __restrict  */)input_file);
#line 2780
      ret = (int )tmp___7;
      }
#line 2781
      if (ret != 1) {
        {
#line 2782
        lprintf(3, "Invalid Checksum!");
        }
#line 2783
        goto out;
      } else {
        {
#line 2781
        tmp___8 = ferror(input_file);
        }
#line 2781
        if (tmp___8) {
          {
#line 2782
          lprintf(3, "Invalid Checksum!");
          }
#line 2783
          goto out;
        }
      }
      {
#line 2785
      printf((char const   */* __restrict  */)"Checksum: 0x%02x\n", (int )checksum);
      }
#line 2786
      goto out;
    }
    {
#line 2788
    printf((char const   */* __restrict  */)"Additional Custom Mfg. length: 0x%02x\n",
           (int )len);
    }
#line 2789
    if (size_board > 0U) {
#line 2789
      if (size_board < *board_length) {
        {
#line 2790
        additional_data = (unsigned char *)((void *)0);
#line 2791
        i___0 = 0U;
#line 2792
        tmp___9 = malloc((size_t )size_board);
#line 2792
        additional_data = (unsigned char *)tmp___9;
        }
#line 2793
        if ((unsigned long )additional_data == (unsigned long )((void *)0)) {
          {
#line 2794
          lprintf(3, "ipmitool: malloc failure");
          }
#line 2795
          return ((size_t )-1);
        }
        {
#line 2798
        tmp___10 = fread((void */* __restrict  */)additional_data, (size_t )size_board,
                         (size_t )1, (FILE */* __restrict  */)input_file);
#line 2798
        ret = (int )tmp___10;
        }
#line 2799
        if (ret != 1) {
          {
#line 2800
          lprintf(3, "Invalid Additional Data!");
          }
#line 2801
          goto out;
        } else {
          {
#line 2799
          tmp___11 = ferror(input_file);
          }
#line 2799
          if (tmp___11) {
            {
#line 2800
            lprintf(3, "Invalid Additional Data!");
            }
#line 2801
            goto out;
          }
        }
        {
#line 2803
        printf((char const   */* __restrict  */)"Additional Custom Mfg. Data: %02x",
               (int )*(additional_data + 0));
#line 2805
        i___0 = 1U;
        }
        {
#line 2805
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2805
          if (! (i___0 < size_board)) {
#line 2805
            goto while_break___1;
          }
          {
#line 2806
          printf((char const   */* __restrict  */)"-%02x", (int )*(additional_data + i___0));
#line 2805
          i___0 ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 2808
        printf((char const   */* __restrict  */)"\n");
#line 2809
        free((void *)additional_data);
#line 2810
        *board_length -= size_board;
        }
      } else {
        {
#line 2813
        printf((char const   */* __restrict  */)"No Additional Custom Mfg. %d\n",
               *board_length);
        }
#line 2814
        goto out;
      }
    } else {
      {
#line 2813
      printf((char const   */* __restrict  */)"No Additional Custom Mfg. %d\n", *board_length);
      }
#line 2814
      goto out;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  out: 
  {
#line 2819
  tmp___13 = ftell(input_file);
#line 2819
  file_offset = (size_t )tmp___13;
  }
#line 2820
  return (file_offset);
}
}
#line 2843 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ek_display_product_info_area___0(FILE *input_file , long offset ) 
{ 
  size_t file_offset ;
  long tmp ;
  int ret ;
  unsigned char ch_len ;
  unsigned char data ;
  unsigned int len ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;

  {
  {
#line 2846
  tmp = ftell(input_file);
#line 2846
  file_offset = (size_t )tmp;
#line 2847
  ret = 0;
#line 2848
  ch_len = (unsigned char)0;
#line 2849
  data = (unsigned char)0;
#line 2850
  len = 0U;
  }
#line 2852
  if ((unsigned long )input_file == (unsigned long )((void *)0)) {
    {
#line 2853
    lprintf(3, "No file stream to read.");
    }
#line 2854
    return (-1);
  }
  {
#line 2856
  printf((char const   */* __restrict  */)"%s\n", EQUAL_LINE_LIMITER);
#line 2857
  printf((char const   */* __restrict  */)"Product Info Area\n");
#line 2858
  printf((char const   */* __restrict  */)"%s\n", EQUAL_LINE_LIMITER);
#line 2859
  ret = fseek(input_file, offset, 0);
#line 2860
  tmp___0 = feof(input_file);
  }
#line 2860
  if (tmp___0) {
    {
#line 2861
    lprintf(3, "Invalid Product Info Area!");
    }
#line 2862
    return (-1);
  }
  {
#line 2864
  tmp___1 = fread((void */* __restrict  */)(& data), (size_t )1, (size_t )1, (FILE */* __restrict  */)input_file);
#line 2864
  ret = (int )tmp___1;
  }
#line 2865
  if (ret != 1) {
    {
#line 2866
    lprintf(3, "Invalid Data!");
    }
#line 2867
    return (-1);
  } else {
    {
#line 2865
    tmp___2 = ferror(input_file);
    }
#line 2865
    if (tmp___2) {
      {
#line 2866
      lprintf(3, "Invalid Data!");
      }
#line 2867
      return (-1);
    }
  }
  {
#line 2869
  printf((char const   */* __restrict  */)"Format Version Number: %d\n", (int )data & 15);
#line 2870
  tmp___3 = feof(input_file);
  }
#line 2870
  if (tmp___3) {
#line 2871
    return (-1);
  }
  {
#line 2875
  tmp___4 = fread((void */* __restrict  */)(& ch_len), (size_t )1, (size_t )1, (FILE */* __restrict  */)input_file);
#line 2875
  ret = (int )tmp___4;
  }
#line 2876
  if (ret != 1) {
    {
#line 2877
    lprintf(3, "Invalid Length!");
    }
#line 2878
    return (-1);
  } else {
    {
#line 2876
    tmp___5 = ferror(input_file);
    }
#line 2876
    if (tmp___5) {
      {
#line 2877
      lprintf(3, "Invalid Length!");
      }
#line 2878
      return (-1);
    }
  }
  {
#line 2881
  len = (unsigned int )((int )ch_len * 8);
#line 2882
  printf((char const   */* __restrict  */)"Area Length: %d\n", len);
#line 2883
  len -= 2U;
#line 2885
  tmp___6 = fread((void */* __restrict  */)(& data), (size_t )1, (size_t )1, (FILE */* __restrict  */)input_file);
#line 2885
  ret = (int )tmp___6;
  }
#line 2886
  if (ret != 1) {
    {
#line 2887
    lprintf(3, "Invalid Length!");
    }
#line 2888
    return (-1);
  } else {
    {
#line 2886
    tmp___7 = ferror(input_file);
    }
#line 2886
    if (tmp___7) {
      {
#line 2887
      lprintf(3, "Invalid Length!");
      }
#line 2888
      return (-1);
    }
  }
  {
#line 2891
  fread((void */* __restrict  */)(& data), (size_t )1, (size_t )1, (FILE */* __restrict  */)input_file);
#line 2892
  printf((char const   */* __restrict  */)"Language Code: %d\n", (int )data);
#line 2893
  len --;
#line 2895
  file_offset = ipmi_ek_display_board_info_area___0(input_file, (char *)"Product Manufacture Data",
                                                    & len);
#line 2897
  ret = fseek(input_file, (long )file_offset, 0);
#line 2899
  file_offset = ipmi_ek_display_board_info_area___0(input_file, (char *)"Product Name",
                                                    & len);
#line 2901
  ret = fseek(input_file, (long )file_offset, 0);
#line 2903
  file_offset = ipmi_ek_display_board_info_area___0(input_file, (char *)"Product Part/Model Number",
                                                    & len);
#line 2905
  ret = fseek(input_file, (long )file_offset, 0);
#line 2907
  file_offset = ipmi_ek_display_board_info_area___0(input_file, (char *)"Product Version",
                                                    & len);
#line 2909
  ret = fseek(input_file, (long )file_offset, 0);
#line 2911
  file_offset = ipmi_ek_display_board_info_area___0(input_file, (char *)"Product Serial Number",
                                                    & len);
#line 2913
  ret = fseek(input_file, (long )file_offset, 0);
#line 2915
  file_offset = ipmi_ek_display_board_info_area___0(input_file, (char *)"Asset Tag",
                                                    & len);
#line 2917
  ret = fseek(input_file, (long )file_offset, 0);
#line 2919
  file_offset = ipmi_ek_display_board_info_area___0(input_file, (char *)"FRU File ID",
                                                    & len);
#line 2921
  ret = fseek(input_file, (long )file_offset, 0);
#line 2923
  file_offset = ipmi_ek_display_board_info_area___0(input_file, (char *)"Custom",
                                                    & len);
  }
#line 2925
  return (0);
}
}
#line 2947 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_record___0(struct ipmi_ek_multi_header *record , struct ipmi_ek_multi_header *list_head ,
                                       struct ipmi_ek_multi_header *list_last ) 
{ 
  unsigned char picmg_id ;
  char const   *tmp ;
  int i ;

  {
#line 2952
  if ((unsigned long )list_head == (unsigned long )((void *)0)) {
    {
#line 2953
    printf((char const   */* __restrict  */)"***empty list***\n");
    }
  } else {
    {
#line 2956
    printf((char const   */* __restrict  */)"%s\n", EQUAL_LINE_LIMITER);
#line 2957
    printf((char const   */* __restrict  */)"FRU Multi Info area\n");
#line 2958
    printf((char const   */* __restrict  */)"%s\n", EQUAL_LINE_LIMITER);
#line 2959
    record = list_head;
    }
    {
#line 2959
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2959
      if (! ((unsigned long )record != (unsigned long )((void *)0))) {
#line 2959
        goto while_break;
      }
      {
#line 2960
      printf((char const   */* __restrict  */)"Record Type ID: 0x%02x\n", (int )record->header.type);
#line 2961
      printf((char const   */* __restrict  */)"Record Format version: 0x%02x\n", (int )record->header.format);
      }
#line 2962
      if ((int )record->header.len > (int )PICMG_ID_OFFSET) {
        {
#line 2970
        picmg_id = *(record->data + PICMG_ID_OFFSET);
#line 2971
        printf((char const   */* __restrict  */)"Manufacturer ID: %02x%02x%02x h\n",
               (int )*(record->data + 2), (int )*(record->data + 1), (int )*(record->data + 0));
        }
#line 2973
        if ((int )picmg_id < 4) {
          {
#line 2976
          printf((char const   */* __restrict  */)"Picmg record ID: Unsupported {0x%02x}\n",
                 (int )picmg_id);
          }
        } else
#line 2973
        if ((int )picmg_id > 45) {
          {
#line 2976
          printf((char const   */* __restrict  */)"Picmg record ID: Unsupported {0x%02x}\n",
                 (int )picmg_id);
          }
        } else {
          {
#line 2979
          tmp = val2str((uint16_t )picmg_id, ipmi_ekanalyzer_picmg_record_id);
#line 2979
          printf((char const   */* __restrict  */)"Picmg record ID: %s {0x%02x}\n",
                 tmp, (int )picmg_id);
          }
        }
        {
#line 2984
        if ((int )picmg_id == 4) {
#line 2984
          goto case_4;
        }
#line 2987
        if ((int )picmg_id == 16) {
#line 2987
          goto case_16;
        }
#line 2990
        if ((int )picmg_id == 17) {
#line 2990
          goto case_17;
        }
#line 2993
        if ((int )picmg_id == 18) {
#line 2993
          goto case_18;
        }
#line 2996
        if ((int )picmg_id == 19) {
#line 2996
          goto case_19;
        }
#line 2999
        if ((int )picmg_id == 20) {
#line 2999
          goto case_20;
        }
#line 3002
        if ((int )picmg_id == 21) {
#line 3002
          goto case_21;
        }
#line 3005
        if ((int )picmg_id == 22) {
#line 3005
          goto case_22;
        }
#line 3008
        if ((int )picmg_id == 23) {
#line 3008
          goto case_23;
        }
#line 3011
        if ((int )picmg_id == 24) {
#line 3011
          goto case_24;
        }
#line 3014
        if ((int )picmg_id == 25) {
#line 3014
          goto case_25;
        }
#line 3017
        if ((int )picmg_id == 26) {
#line 3017
          goto case_26;
        }
#line 3020
        if ((int )picmg_id == 44) {
#line 3020
          goto case_44;
        }
#line 3023
        if ((int )picmg_id == 45) {
#line 3023
          goto case_45;
        }
#line 3026
        goto switch_default;
        case_4: /* CIL Label */ 
        {
#line 2985
        ipmi_ek_display_backplane_p2p_record___0(record);
        }
#line 2986
        goto switch_break;
        case_16: /* CIL Label */ 
        {
#line 2988
        ipmi_ek_display_address_table_record___0(record);
        }
#line 2989
        goto switch_break;
        case_17: /* CIL Label */ 
        {
#line 2991
        ipmi_ek_display_shelf_power_distribution_record___0(record);
        }
#line 2992
        goto switch_break;
        case_18: /* CIL Label */ 
        {
#line 2994
        ipmi_ek_display_shelf_activation_record___0(record);
        }
#line 2995
        goto switch_break;
        case_19: /* CIL Label */ 
        {
#line 2997
        ipmi_ek_display_shelf_ip_connection_record___0(record);
        }
#line 2998
        goto switch_break;
        case_20: /* CIL Label */ 
        {
#line 3000
        ipmi_ek_display_board_p2p_record___0(record);
        }
#line 3001
        goto switch_break;
        case_21: /* CIL Label */ 
        {
#line 3003
        ipmi_ek_display_radial_ipmb0_record___0(record);
        }
#line 3004
        goto switch_break;
        case_22: /* CIL Label */ 
        {
#line 3006
        ipmi_ek_display_amc_current_record___0(record);
        }
#line 3007
        goto switch_break;
        case_23: /* CIL Label */ 
        {
#line 3009
        ipmi_ek_display_amc_activation_record___0(record);
        }
#line 3010
        goto switch_break;
        case_24: /* CIL Label */ 
        {
#line 3012
        ipmi_ek_display_carrier_connectivity___0(record);
        }
#line 3013
        goto switch_break;
        case_25: /* CIL Label */ 
        {
#line 3015
        ipmi_ek_display_amc_p2p_record___0(record);
        }
#line 3016
        goto switch_break;
        case_26: /* CIL Label */ 
        {
#line 3018
        ipmi_ek_display_amc_carrier_info_record___0(record);
        }
#line 3019
        goto switch_break;
        case_44: /* CIL Label */ 
        {
#line 3021
        ipmi_ek_display_clock_carrier_p2p_record___0(record);
        }
#line 3022
        goto switch_break;
        case_45: /* CIL Label */ 
        {
#line 3024
        ipmi_ek_display_clock_config_record___0(record);
        }
#line 3025
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 3027
        if (verbose > 0) {
          {
#line 3029
          printf((char const   */* __restrict  */)"%02x %02x %02x %02x %02x ", (int )record->header.type,
                 (int )record->header.format, (int )record->header.len, (int )record->header.record_checksum,
                 (int )record->header.header_checksum);
#line 3033
          i = 0;
          }
          {
#line 3033
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 3033
            if (! (i < (int )record->header.len)) {
#line 3033
              goto while_break___0;
            }
            {
#line 3034
            printf((char const   */* __restrict  */)"%02x ", (int )*(record->data + i));
#line 3033
            i ++;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 3036
          printf((char const   */* __restrict  */)"\n");
          }
        }
#line 3038
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        {
#line 3040
        printf((char const   */* __restrict  */)"%s\n", STAR_LINE_LIMITER);
        }
      }
#line 2959
      record = record->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3044
  return;
}
}
#line 3063 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_backplane_p2p_record___0(struct ipmi_ek_multi_header *record ) 
{ 
  uint8_t index___0 ;
  int offset ;
  struct fru_picmgext_slot_desc *slot_d ;
  struct fru_picmgext_chn_desc *d ;

  {
#line 3067
  offset = (int )START_DATA_OFFSET;
#line 3068
  slot_d = (struct fru_picmgext_slot_desc *)(record->data + offset);
#line 3071
  offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_slot_desc ));
  {
#line 3073
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3073
    if (! (offset <= (int )record->header.len)) {
#line 3073
      goto while_break;
    }
    {
#line 3074
    printf((char const   */* __restrict  */)"   Channel Type: ");
    }
    {
#line 3078
    if ((int )slot_d->chan_type == 7) {
#line 3078
      goto case_7;
    }
#line 3078
    if ((int )slot_d->chan_type == 0) {
#line 3078
      goto case_7;
    }
#line 3081
    if ((int )slot_d->chan_type == 8) {
#line 3081
      goto case_8;
    }
#line 3084
    if ((int )slot_d->chan_type == 9) {
#line 3084
      goto case_9;
    }
#line 3087
    if ((int )slot_d->chan_type == 10) {
#line 3087
      goto case_10;
    }
#line 3090
    if ((int )slot_d->chan_type == 11) {
#line 3090
      goto case_11;
    }
#line 3093
    if ((int )slot_d->chan_type == 12) {
#line 3093
      goto case_12;
    }
#line 3096
    goto switch_default;
    case_7: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 3079
    printf((char const   */* __restrict  */)"PICMG 2.9\n");
    }
#line 3080
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 3082
    printf((char const   */* __restrict  */)"Single Port Fabric IF\n");
    }
#line 3083
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 3085
    printf((char const   */* __restrict  */)"Double Port Fabric IF\n");
    }
#line 3086
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 3088
    printf((char const   */* __restrict  */)"Full Channel Fabric IF\n");
    }
#line 3089
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 3091
    printf((char const   */* __restrict  */)"Base IF\n");
    }
#line 3092
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 3094
    printf((char const   */* __restrict  */)"Update Channel IF\n");
    }
#line 3095
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 3097
    printf((char const   */* __restrict  */)"Unknown IF\n");
    }
#line 3098
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 3100
    printf((char const   */* __restrict  */)"   Slot Address:  %02x\n", (int )slot_d->slot_addr);
#line 3101
    printf((char const   */* __restrict  */)"   Channel Count: %i\n", (int )slot_d->chn_count);
#line 3103
    index___0 = (uint8_t )0;
    }
    {
#line 3103
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3103
      if (! ((int )index___0 < (int )slot_d->chn_count)) {
#line 3103
        goto while_break___0;
      }
#line 3104
      d = (struct fru_picmgext_chn_desc *)(record->data + offset);
#line 3107
      if (verbose) {
        {
#line 3108
        printf((char const   */* __restrict  */)"\tChn: %02x   -->   Chn: %02x in Slot: %02x\n",
               d->local_chn, d->remote_chn, d->remote_slot);
        }
      }
#line 3115
      offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_chn_desc ));
#line 3103
      index___0 = (uint8_t )((int )index___0 + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3117
    slot_d = (struct fru_picmgext_slot_desc *)(record->data + offset);
#line 3118
    offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_slot_desc ));
  }
  while_break: /* CIL Label */ ;
  }
#line 3120
  return;
}
}
#line 3139 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_address_table_record___0(struct ipmi_ek_multi_header *record ) 
{ 
  unsigned char entries ;
  unsigned char i ;
  int offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 3142
  entries = (unsigned char)0;
#line 3144
  offset = (int )START_DATA_OFFSET;
#line 3147
  tmp = offset;
#line 3147
  offset ++;
#line 3147
  printf((char const   */* __restrict  */)"   Type/Len:    0x%02x\n", (int )*(record->data + tmp));
#line 3148
  printf((char const   */* __restrict  */)"   Shelf Addr: ");
#line 3149
  i = (unsigned char)0;
  }
  {
#line 3149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3149
    if (! ((int )i < 20)) {
#line 3149
      goto while_break;
    }
    {
#line 3150
    tmp___0 = offset;
#line 3150
    offset ++;
#line 3150
    printf((char const   */* __restrict  */)"0x%02x ", (int )*(record->data + tmp___0));
#line 3149
    i = (unsigned char )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3152
  printf((char const   */* __restrict  */)"\n");
#line 3154
  tmp___1 = offset;
#line 3154
  offset ++;
#line 3154
  entries = *(record->data + tmp___1);
#line 3155
  printf((char const   */* __restrict  */)"   Addr Table Entries count: 0x%02x\n",
         (int )entries);
#line 3157
  i = (unsigned char)0;
  }
  {
#line 3157
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3157
    if (! ((int )i < (int )entries)) {
#line 3157
      goto while_break___0;
    }
    {
#line 3158
    printf((char const   */* __restrict  */)"\tHWAddr: 0x%02x  - SiteNum: 0x%02x - SiteType: 0x%02x \n",
           (int )*(record->data + offset), (int )*(record->data + (offset + 1)), (int )*(record->data + (offset + 2)));
#line 3162
    offset += 3;
#line 3157
    i = (unsigned char )((int )i + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3164
  return;
}
}
#line 3183 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_shelf_power_distribution_record___0(struct ipmi_ek_multi_header *record ) 
{ 
  int offset ;
  unsigned char i ;
  unsigned char j ;
  unsigned char feeds ;
  int tmp ;
  unsigned char entries ;
  unsigned long max_ext ;
  unsigned long max_int ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 3187
  offset = (int )START_DATA_OFFSET;
#line 3189
  feeds = (unsigned char)0;
#line 3191
  tmp = offset;
#line 3191
  offset ++;
#line 3191
  feeds = *(record->data + tmp);
#line 3192
  printf((char const   */* __restrict  */)"   Number of Power Feeds: 0x%02x\n", (int )feeds);
#line 3194
  i = (unsigned char)0;
  }
  {
#line 3194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3194
    if (! ((int )i < (int )feeds)) {
#line 3194
      goto while_break;
    }
    {
#line 3196
    max_ext = 0UL;
#line 3197
    max_int = 0UL;
#line 3198
    max_ext = (unsigned long )((int )*(record->data + offset) | ((int )*(record->data + (offset + 1)) << 8));
#line 3199
    printf((char const   */* __restrict  */)"   Max External Available Current: %ld Amps\n",
           max_ext * 10UL);
#line 3201
    offset += 2;
#line 3203
    max_int = (unsigned long )((int )*(record->data + offset) | ((int )*(record->data + (offset + 1)) << 8));
#line 3204
    printf((char const   */* __restrict  */)"   Max Internal Current:\t   %ld Amps\n",
           max_int * 10UL);
#line 3205
    offset += 2;
#line 3206
    tmp___0 = offset;
#line 3206
    offset ++;
#line 3206
    printf((char const   */* __restrict  */)"   Min Expected Operating Voltage: %d Volts\n",
           (int )*(record->data + tmp___0) / 2);
#line 3208
    tmp___1 = offset;
#line 3208
    offset ++;
#line 3208
    entries = *(record->data + tmp___1);
#line 3209
    printf((char const   */* __restrict  */)"   Feed to FRU count: 0x%02x\n", (int )entries);
#line 3210
    j = (unsigned char)0;
    }
    {
#line 3210
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3210
      if (! ((int )j < (int )entries)) {
#line 3210
        goto while_break___0;
      }
      {
#line 3211
      tmp___2 = offset;
#line 3211
      offset ++;
#line 3211
      printf((char const   */* __restrict  */)"\tHW: 0x%02x", (int )*(record->data + tmp___2));
#line 3212
      tmp___3 = offset;
#line 3212
      offset ++;
#line 3212
      printf((char const   */* __restrict  */)"\tFRU ID: 0x%02x\n", (int )*(record->data + tmp___3));
#line 3210
      j = (unsigned char )((int )j + 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3194
    i = (unsigned char )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 3215
  return;
}
}
#line 3234 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_shelf_activation_record___0(struct ipmi_ek_multi_header *record ) 
{ 
  unsigned char count ;
  int offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 3238
  count = (unsigned char)0;
#line 3239
  offset = (int )START_DATA_OFFSET;
#line 3241
  tmp = offset;
#line 3241
  offset ++;
#line 3241
  printf((char const   */* __restrict  */)"   Allowance for FRU Act Readiness: 0x%02x\n",
         (int )*(record->data + tmp));
#line 3243
  tmp___0 = offset;
#line 3243
  offset ++;
#line 3243
  count = *(record->data + tmp___0);
#line 3244
  printf((char const   */* __restrict  */)"   FRU activation and Power Desc Cnt: 0x%02x\n",
         (int )count);
  }
  {
#line 3246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3246
    if (! ((int )count > 0)) {
#line 3246
      goto while_break;
    }
    {
#line 3247
    printf((char const   */* __restrict  */)"   FRU activation and Power descriptor:\n");
#line 3248
    tmp___1 = offset;
#line 3248
    offset ++;
#line 3248
    printf((char const   */* __restrict  */)"\tHardware Address:\t\t0x%02x\n", (int )*(record->data + tmp___1));
#line 3249
    tmp___2 = offset;
#line 3249
    offset ++;
#line 3249
    printf((char const   */* __restrict  */)"\tFRU Device ID:\t\t\t0x%02x\n", (int )*(record->data + tmp___2));
#line 3250
    printf((char const   */* __restrict  */)"\tMax FRU Power Capability:\t0x%04x Watts\n",
           (int )*(record->data + offset) | ((int )*(record->data + (offset + 1)) << 8));
#line 3252
    offset += 2;
#line 3253
    tmp___3 = offset;
#line 3253
    offset ++;
#line 3253
    printf((char const   */* __restrict  */)"\tConfiguration parameter:\t0x%02x\n",
           (int )*(record->data + tmp___3));
#line 3254
    count = (unsigned char )((int )count - 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3256
  return;
}
}
#line 3276 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_shelf_ip_connection_record___0(struct ipmi_ek_multi_header *record ) 
{ 
  int ioffset ;

  {
#line 3280
  ioffset = (int )START_DATA_OFFSET;
#line 3281
  if (ioffset > (int )record->header.len) {
    {
#line 3282
    printf((char const   */* __restrict  */)"   Shelf Manager IP Address: %d.%d.%d.%d\n",
           (int )*(record->data + ioffset), (int )*(record->data + (ioffset + 1)),
           (int )*(record->data + (ioffset + 2)), (int )*(record->data + (ioffset + 3)));
#line 3285
    ioffset += 4;
    }
  }
#line 3287
  if (ioffset > (int )record->header.len) {
    {
#line 3288
    printf((char const   */* __restrict  */)"   Default Gateway Address: %d.%d.%d.%d\n",
           (int )*(record->data + ioffset), (int )*(record->data + (ioffset + 1)),
           (int )*(record->data + (ioffset + 2)), (int )*(record->data + (ioffset + 3)));
#line 3291
    ioffset += 4;
    }
  }
#line 3293
  if (ioffset > (int )record->header.len) {
    {
#line 3294
    printf((char const   */* __restrict  */)"   Subnet Mask: %d.%d.%d.%d\n", (int )*(record->data + ioffset),
           (int )*(record->data + (ioffset + 1)), (int )*(record->data + (ioffset + 2)),
           (int )*(record->data + (ioffset + 3)));
#line 3297
    ioffset += 4;
    }
  }
#line 3299
  return;
}
}
#line 3361 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_board_p2p_record___0(struct ipmi_ek_multi_header *record ) 
{ 
  unsigned char guid_count ;
  int offset ;
  int i ;
  int tmp ;
  int j ;
  unsigned long data ;
  struct fru_picmgext_link_desc *d ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
  {
#line 3365
  offset = (int )START_DATA_OFFSET;
#line 3366
  i = 0;
#line 3368
  tmp = offset;
#line 3368
  offset ++;
#line 3368
  guid_count = *(record->data + tmp);
#line 3369
  printf((char const   */* __restrict  */)"   GUID count: %2d\n", (int )guid_count);
#line 3371
  i = 0;
  }
  {
#line 3371
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3371
    if (! (i < (int )guid_count)) {
#line 3371
      goto while_break;
    }
    {
#line 3373
    printf((char const   */* __restrict  */)"\tGUID: ");
#line 3374
    j = 0;
    }
    {
#line 3374
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3374
      if (! ((unsigned long )j < sizeof(struct fru_picmgext_guid ))) {
#line 3374
        goto while_break___0;
      }
      {
#line 3375
      printf((char const   */* __restrict  */)"%02x", (int )*(record->data + (offset + j)));
#line 3374
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3377
    printf((char const   */* __restrict  */)"\n");
#line 3378
    offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_guid ));
#line 3371
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3381
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3381
    if (! (offset < (int )record->header.len)) {
#line 3381
      goto while_break___1;
    }
    {
#line 3389
    data = (unsigned long )((((int )*(record->data + offset) | ((int )*(record->data + (offset + 1)) << 8)) | ((int )*(record->data + (offset + 2)) << 16)) | ((int )*(record->data + (offset + 3)) << 24));
#line 3393
    d = (struct fru_picmgext_link_desc *)(& data);
#line 3395
    printf((char const   */* __restrict  */)"   Link Descriptor\n");
#line 3396
    printf((char const   */* __restrict  */)"\tLink Grouping ID:\t0x%02x\n", d->grouping);
#line 3397
    printf((char const   */* __restrict  */)"\tLink Type Extension:\t0x%02x - ", d->ext);
    }
#line 3399
    if (d->type == 1U) {
      {
#line 3401
      if (d->ext == 0U) {
#line 3401
        goto case_0;
      }
#line 3404
      if (d->ext == 1U) {
#line 3404
        goto case_1;
      }
#line 3407
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 3402
      printf((char const   */* __restrict  */)"10/100/1000BASE-T Link (four-pair)\n");
      }
#line 3403
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 3405
      printf((char const   */* __restrict  */)"ShMC Cross-connect (two-pair)\n");
      }
#line 3406
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 3408
      printf((char const   */* __restrict  */)"Unknwon\n");
      }
#line 3409
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else
#line 3412
    if (d->type == 2U) {
      {
#line 3414
      if (d->ext == 0U) {
#line 3414
        goto case_0___0;
      }
#line 3417
      if (d->ext == 1U) {
#line 3417
        goto case_1___0;
      }
#line 3420
      if (d->ext == 2U) {
#line 3420
        goto case_2;
      }
#line 3423
      goto switch_default___0;
      case_0___0: /* CIL Label */ 
      {
#line 3415
      printf((char const   */* __restrict  */)"Fixed 1000Base-BX\n");
      }
#line 3416
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 3418
      printf((char const   */* __restrict  */)"Fixed 10GBASE-BX4 [XAUI]\n");
      }
#line 3419
      goto switch_break___0;
      case_2: /* CIL Label */ 
      {
#line 3421
      printf((char const   */* __restrict  */)"FC-PI\n");
      }
#line 3422
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 3424
      printf((char const   */* __restrict  */)"Unknwon\n");
      }
#line 3425
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    } else
#line 3428
    if (d->type == 3U) {
      {
#line 3429
      printf((char const   */* __restrict  */)"Unknwon\n");
      }
    } else
#line 3431
    if (d->type == 4U) {
      {
#line 3432
      printf((char const   */* __restrict  */)"Unknwon\n");
      }
    } else
#line 3434
    if (d->type == 5U) {
      {
#line 3435
      printf((char const   */* __restrict  */)"Unknwon\n");
      }
    } else {
      {
#line 3438
      printf((char const   */* __restrict  */)"Unknwon\n");
      }
    }
    {
#line 3441
    printf((char const   */* __restrict  */)"\tLink Type:\t\t0x%02x - ", d->type);
    }
#line 3442
    if (d->type == 0U) {
      {
#line 3443
      printf((char const   */* __restrict  */)"Reserved\n");
      }
    } else
#line 3442
    if (d->type == 255U) {
      {
#line 3443
      printf((char const   */* __restrict  */)"Reserved\n");
      }
    } else
#line 3445
    if (d->type >= 6U) {
#line 3445
      if (d->type <= 239U) {
        {
#line 3446
        printf((char const   */* __restrict  */)"Reserved\n");
        }
      } else {
#line 3445
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 3448
    if (d->type >= (unsigned int )LOWER_OEM_TYPE) {
#line 3448
      if (d->type <= (unsigned int )UPPER_OEM_TYPE) {
        {
#line 3449
        printf((char const   */* __restrict  */)"OEM GUID Definition\n");
        }
      } else {
#line 3448
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 3453
      if (d->type == 1U) {
#line 3453
        goto case_1___1;
      }
#line 3456
      if (d->type == 2U) {
#line 3456
        goto case_2___0;
      }
#line 3459
      if (d->type == 3U) {
#line 3459
        goto case_3;
      }
#line 3462
      if (d->type == 4U) {
#line 3462
        goto case_4;
      }
#line 3465
      if (d->type == 5U) {
#line 3465
        goto case_5;
      }
#line 3468
      goto switch_default___1;
      case_1___1: /* CIL Label */ 
      {
#line 3454
      printf((char const   */* __restrict  */)"PICMG 3.0 Base Interface 10/100/1000\n");
      }
#line 3455
      goto switch_break___1;
      case_2___0: /* CIL Label */ 
      {
#line 3457
      printf((char const   */* __restrict  */)"PICMG 3.1 Ethernet Fabric Interface\n");
      }
#line 3458
      goto switch_break___1;
      case_3: /* CIL Label */ 
      {
#line 3460
      printf((char const   */* __restrict  */)"PICMG 3.2 Infiniband Fabric Interface\n");
      }
#line 3461
      goto switch_break___1;
      case_4: /* CIL Label */ 
      {
#line 3463
      printf((char const   */* __restrict  */)"PICMG 3.3 Star Fabric Interface\n");
      }
#line 3464
      goto switch_break___1;
      case_5: /* CIL Label */ 
      {
#line 3466
      printf((char const   */* __restrict  */)"PICMG 3.4 PCI Express Fabric Interface\n");
      }
#line 3467
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
      {
#line 3469
      printf((char const   */* __restrict  */)"Invalid\n");
      }
#line 3470
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    }
    {
#line 3473
    printf((char const   */* __restrict  */)"\tLink Designator: \n");
    }
#line 3474
    if (d->desig_port & 1U) {
#line 3474
      tmp___0 = "enable";
    } else {
#line 3474
      tmp___0 = "disable";
    }
    {
#line 3474
    printf((char const   */* __restrict  */)"\t   Port 0 Flag:   %s\n", tmp___0);
    }
#line 3476
    if (d->desig_port & 2U) {
#line 3476
      tmp___1 = "enable";
    } else {
#line 3476
      tmp___1 = "disable";
    }
    {
#line 3476
    printf((char const   */* __restrict  */)"\t   Port 1 Flag:   %s\n", tmp___1);
    }
#line 3478
    if (d->desig_port & 4U) {
#line 3478
      tmp___2 = "enable";
    } else {
#line 3478
      tmp___2 = "disable";
    }
    {
#line 3478
    printf((char const   */* __restrict  */)"\t   Port 2 Flag:   %s\n", tmp___2);
    }
#line 3480
    if (d->desig_port & 8U) {
#line 3480
      tmp___3 = "enable";
    } else {
#line 3480
      tmp___3 = "disable";
    }
    {
#line 3480
    printf((char const   */* __restrict  */)"\t   Port 3 Flag:   %s\n", tmp___3);
#line 3483
    printf((char const   */* __restrict  */)"\t   Interface:    0x%02x - ", d->desig_if);
    }
    {
#line 3485
    if (d->desig_if == 0U) {
#line 3485
      goto case_0___1;
    }
#line 3488
    if (d->desig_if == 1U) {
#line 3488
      goto case_1___2;
    }
#line 3491
    if (d->desig_if == 2U) {
#line 3491
      goto case_2___1;
    }
#line 3494
    if (d->desig_if == 3U) {
#line 3494
      goto case_3___0;
    }
#line 3497
    goto switch_default___2;
    case_0___1: /* CIL Label */ 
    {
#line 3486
    printf((char const   */* __restrict  */)"Base Interface\n");
    }
#line 3487
    goto switch_break___2;
    case_1___2: /* CIL Label */ 
    {
#line 3489
    printf((char const   */* __restrict  */)"Fabric Interface\n");
    }
#line 3490
    goto switch_break___2;
    case_2___1: /* CIL Label */ 
    {
#line 3492
    printf((char const   */* __restrict  */)"Update Channel\n");
    }
#line 3493
    goto switch_break___2;
    case_3___0: /* CIL Label */ 
    {
#line 3495
    printf((char const   */* __restrict  */)"Reserved\n");
    }
#line 3496
    goto switch_break___2;
    switch_default___2: /* CIL Label */ 
    {
#line 3498
    printf((char const   */* __restrict  */)"Invalid");
    }
#line 3499
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
    {
#line 3501
    printf((char const   */* __restrict  */)"\t   Channel Number:    0x%02x\n", d->desig_channel);
#line 3381
    offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_link_desc ));
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3503
  return;
}
}
#line 3522 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_radial_ipmb0_record___0(struct ipmi_ek_multi_header *record ) 
{ 
  int offset ;
  int tmp ;
  unsigned char entry_count ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 3525
  offset = (int )START_DATA_OFFSET;
#line 3529
  printf((char const   */* __restrict  */)"   IPMB-0 Connector Definer: ");
#line 3531
  printf((char const   */* __restrict  */)"%02x %02x %02x h\n", (int )*(record->data + offset),
         (int )*(record->data + (offset + 1)), (int )*(record->data + (offset + 2)));
#line 3538
  offset += 3;
#line 3540
  printf((char const   */* __restrict  */)"   IPMB-0 Connector version ID: ");
#line 3542
  printf((char const   */* __restrict  */)"%02x %02x h\n", (int )*(record->data + offset),
         (int )*(record->data + (offset + 1)));
#line 3546
  offset += 2;
#line 3548
  tmp = offset;
#line 3548
  offset ++;
#line 3548
  printf((char const   */* __restrict  */)"   IPMB-0 Hub Descriptor Count: 0x%02x",
         (int )*(record->data + tmp));
  }
#line 3549
  if ((int )*(record->data + offset) > 0) {
    {
#line 3550
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3550
      if (! (offset < (int )record->header.len)) {
#line 3550
        goto while_break;
      }
      {
#line 3551
      entry_count = (unsigned char)0;
#line 3552
      printf((char const   */* __restrict  */)"   IPMB-0 Hub Descriptor\n");
#line 3553
      tmp___0 = offset;
#line 3553
      offset ++;
#line 3553
      printf((char const   */* __restrict  */)"\tHardware Address: 0x%02x\n", (int )*(record->data + tmp___0));
#line 3554
      printf((char const   */* __restrict  */)"\tHub Info {0x%02x}: ", (int )*(record->data + offset));
      }
#line 3556
      if (((int )*(record->data + offset) & 1) == 1) {
        {
#line 3557
        printf((char const   */* __restrict  */)"IPMB-A only\n");
        }
      } else
#line 3559
      if (((int )*(record->data + offset) & 2) == 2) {
        {
#line 3560
        printf((char const   */* __restrict  */)"IPMB-B only\n");
        }
      } else
#line 3562
      if (((int )*(record->data + offset) & 3) == 3) {
        {
#line 3563
        printf((char const   */* __restrict  */)"IPMB-A and IPMB-B\n");
        }
      } else {
        {
#line 3566
        printf((char const   */* __restrict  */)"Reserved.\n");
        }
      }
      {
#line 3568
      offset ++;
#line 3570
      tmp___1 = offset;
#line 3570
      offset ++;
#line 3570
      entry_count = *(record->data + tmp___1);
#line 3571
      printf((char const   */* __restrict  */)"\tAddress Entry count: 0x%02x", (int )entry_count);
      }
      {
#line 3572
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3572
        if (! ((int )entry_count > 0)) {
#line 3572
          goto while_break___0;
        }
        {
#line 3573
        tmp___2 = offset;
#line 3573
        offset ++;
#line 3573
        printf((char const   */* __restrict  */)"\t   Hardware Address: 0x%02x\n",
               (int )*(record->data + tmp___2));
#line 3574
        tmp___3 = offset;
#line 3574
        offset ++;
#line 3574
        printf((char const   */* __restrict  */)"\t   IPMB-0 Link Entry: 0x%02x\n",
               (int )*(record->data + tmp___3));
#line 3575
        entry_count = (unsigned char )((int )entry_count - 1);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3580
  return;
}
}
#line 3599 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_amc_current_record___0(struct ipmi_ek_multi_header *record ) 
{ 
  unsigned char current ;

  {
  {
#line 3603
  current = *(record->data + START_DATA_OFFSET);
#line 3604
  printf((char const   */* __restrict  */)"   Current draw: %.1f A @ 12V => %.2f Watt\n",
         (double )((float )current) / 10.0, ((double )((float )current) / 10.0) * 12.0);
#line 3606
  printf((char const   */* __restrict  */)"\n");
  }
#line 3607
  return;
}
}
#line 3627 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_amc_activation_record___0(struct ipmi_ek_multi_header *record ) 
{ 
  uint16_t max_current ;
  int offset ;
  struct fru_picmgext_activation_record *a ;

  {
  {
#line 3631
  offset = (int )START_DATA_OFFSET;
#line 3633
  max_current = (uint16_t )*(record->data + offset);
#line 3634
  offset ++;
#line 3634
  max_current = (uint16_t )((int )max_current | ((int )*(record->data + offset) << 8));
#line 3635
  printf((char const   */* __restrict  */)"   Maximum Internal Current(@12V): %.2f A [ %.2f Watt ]\n",
         (double )((float )max_current / (float )10), (double )(((float )max_current / (float )10) * (float )12));
#line 3638
  offset ++;
#line 3638
  printf((char const   */* __restrict  */)"   Module Activation Readiness:    %i sec.\n",
         (int )*(record->data + offset));
#line 3641
  offset ++;
#line 3641
  printf((char const   */* __restrict  */)"   Descriptor Count: %i\n", (int )*(record->data + offset));
#line 3642
  offset ++;
  }
  {
#line 3642
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3642
    if (! (offset < (int )record->header.len)) {
#line 3642
      goto while_break;
    }
    {
#line 3644
    a = (struct fru_picmgext_activation_record *)(record->data + offset);
#line 3647
    printf((char const   */* __restrict  */)"\tIPMB-Address:\t\t0x%x\n", (int )a->ibmb_addr);
#line 3648
    printf((char const   */* __restrict  */)"\tMax. Module Current:\t%.2f A\n", (double )((float )a->max_module_curr / (float )10));
#line 3649
    printf((char const   */* __restrict  */)"\n");
#line 3642
    offset += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3651
  return;
}
}
#line 3671 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_amc_p2p_record___0(struct ipmi_ek_multi_header *record ) 
{ 
  int index_data ;
  int oem_count ;
  int ch_count ;
  int index___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int data ;
  struct fru_picmgext_amc_channel_desc_record *ch_desc ;
  unsigned int data___0[2] ;
  struct fru_picmgext_amc_link_desc_record *link_desc ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;

  {
  {
#line 3674
  index_data = (int )START_DATA_OFFSET;
#line 3675
  oem_count = 0;
#line 3676
  ch_count = 0;
#line 3677
  index___0 = 0;
#line 3679
  tmp = index_data;
#line 3679
  index_data ++;
#line 3679
  oem_count = (int )*(record->data + tmp);
#line 3680
  printf((char const   */* __restrict  */)"OEM GUID count: %02x\n", oem_count);
  }
#line 3682
  if (oem_count > 0) {
    {
#line 3683
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3683
      if (! (oem_count > 0)) {
#line 3683
        goto while_break;
      }
      {
#line 3684
      printf((char const   */* __restrict  */)"OEM GUID: ");
#line 3685
      index___0 = 1;
      }
      {
#line 3685
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3685
        if (! (index___0 <= 16)) {
#line 3685
          goto while_break___0;
        }
        {
#line 3686
        tmp___0 = index_data;
#line 3686
        index_data ++;
#line 3686
        printf((char const   */* __restrict  */)"%02x", (int )*(record->data + tmp___0));
        }
#line 3689
        if (! (index___0 % 5)) {
          {
#line 3690
          printf((char const   */* __restrict  */)"-");
          }
        }
#line 3685
        index___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 3693
      printf((char const   */* __restrict  */)"\n");
#line 3694
      oem_count --;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3697
  if (((int )*(record->data + index_data) & (int )AMC_MODULE) == (int )AMC_MODULE) {
    {
#line 3698
    printf((char const   */* __restrict  */)"AMC module connection\n");
    }
  } else {
    {
#line 3701
    printf((char const   */* __restrict  */)"On-Carrier Device %02x h\n", (int )*(record->data + index_data) & 15);
    }
  }
  {
#line 3703
  index_data ++;
#line 3704
  tmp___1 = index_data;
#line 3704
  index_data ++;
#line 3704
  ch_count = (int )*(record->data + tmp___1);
#line 3705
  printf((char const   */* __restrict  */)"AMC Channel Descriptor count: %02x h\n",
         ch_count);
  }
#line 3707
  if (ch_count > 0) {
#line 3708
    index___0 = 0;
    {
#line 3708
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3708
      if (! (index___0 < ch_count)) {
#line 3708
        goto while_break___1;
      }
      {
#line 3711
      printf((char const   */* __restrict  */)"   AMC Channel Descriptor {%02x%02x%02x}\n",
             (int )*(record->data + (index_data + 2)), (int )*(record->data + (index_data + 1)),
             (int )*(record->data + index_data));
#line 3715
      data = (unsigned int )(((int )*(record->data + index_data) | ((int )*(record->data + (index_data + 1)) << 8)) | ((int )*(record->data + (index_data + 2)) << 16));
#line 3718
      ch_desc = (struct fru_picmgext_amc_channel_desc_record *)(& data);
#line 3719
      printf((char const   */* __restrict  */)"      Lane 0 Port: %d\n", ch_desc->lane0port);
#line 3720
      printf((char const   */* __restrict  */)"      Lane 1 Port: %d\n", ch_desc->lane1port);
#line 3721
      printf((char const   */* __restrict  */)"      Lane 2 Port: %d\n", ch_desc->lane2port);
#line 3722
      printf((char const   */* __restrict  */)"      Lane 3 Port: %d\n\n", ch_desc->lane3port);
#line 3723
      index_data += 3;
#line 3708
      index___0 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 3726
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3726
    if (! (index_data < (int )record->header.len)) {
#line 3726
      goto while_break___2;
    }
    {
#line 3730
    data___0[0] = (unsigned int )((((int )*(record->data + index_data) | ((int )*(record->data + (index_data + 1)) << 8)) | ((int )*(record->data + (index_data + 2)) << 16)) | ((int )*(record->data + (index_data + 3)) << 24));
#line 3734
    data___0[1] = (unsigned int )*(record->data + (index_data + 4));
#line 3736
    link_desc = (struct fru_picmgext_amc_link_desc_record *)(& data___0[0]);
#line 3738
    printf((char const   */* __restrict  */)"   AMC Link Descriptor:\n");
#line 3740
    tmp___2 = val2str((uint16_t )link_desc->type, ipmi_ekanalyzer_link_type);
#line 3740
    printf((char const   */* __restrict  */)"\t- Link Type: %s \n", tmp___2);
    }
    {
#line 3745
    if (link_desc->type == 4U) {
#line 3745
      goto case_4;
    }
#line 3745
    if (link_desc->type == 3U) {
#line 3745
      goto case_4;
    }
#line 3745
    if (link_desc->type == 2U) {
#line 3745
      goto case_4;
    }
#line 3753
    if (link_desc->type == 5U) {
#line 3753
      goto case_5;
    }
#line 3762
    if (link_desc->type == 7U) {
#line 3762
      goto case_7;
    }
#line 3771
    goto switch_default;
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 3746
    tmp___3 = val2str((uint16_t )link_desc->type_ext, ipmi_ekanalyzer_extension_PCIE);
#line 3746
    printf((char const   */* __restrict  */)"\t- Link Type extension: %s\n", tmp___3);
#line 3748
    printf((char const   */* __restrict  */)"\t- Link Group ID: %d\n ", link_desc->group_id);
#line 3749
    tmp___4 = val2str((uint16_t )link_desc->asym_match, ipmi_ekanalyzer_asym_PCIE);
#line 3749
    printf((char const   */* __restrict  */)"\t- Link Asym. Match: %d - %s\n", link_desc->asym_match,
           tmp___4);
    }
#line 3752
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 3754
    tmp___5 = val2str((uint16_t )link_desc->type_ext, ipmi_ekanalyzer_extension_ETHERNET);
#line 3754
    printf((char const   */* __restrict  */)"\t- Link Type extension: %s\n", tmp___5);
#line 3757
    printf((char const   */* __restrict  */)"\t- Link Group ID: %d \n", link_desc->group_id);
#line 3758
    tmp___6 = val2str((uint16_t )link_desc->asym_match, ipmi_ekanalyzer_asym_PCIE);
#line 3758
    printf((char const   */* __restrict  */)"\t- Link Asym. Match: %d - %s\n", link_desc->asym_match,
           tmp___6);
    }
#line 3761
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 3763
    tmp___7 = val2str((uint16_t )link_desc->type_ext, ipmi_ekanalyzer_extension_STORAGE);
#line 3763
    printf((char const   */* __restrict  */)"\t- Link Type extension: %s\n", tmp___7);
#line 3766
    printf((char const   */* __restrict  */)"\t- Link Group ID: %d \n", link_desc->group_id);
#line 3767
    tmp___8 = val2str((uint16_t )link_desc->asym_match, ipmi_ekanalyzer_asym_STORAGE);
#line 3767
    printf((char const   */* __restrict  */)"\t- Link Asym. Match: %d - %s\n", link_desc->asym_match,
           tmp___8);
    }
#line 3770
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 3772
    printf((char const   */* __restrict  */)"\t- Link Type extension: %i (Unknown)\n",
           link_desc->type_ext);
#line 3773
    printf((char const   */* __restrict  */)"\t- Link Group ID: %d \n", link_desc->group_id);
#line 3774
    printf((char const   */* __restrict  */)"\t- Link Asym. Match: %i\n", link_desc->asym_match);
    }
#line 3775
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 3777
    printf((char const   */* __restrict  */)"\t- AMC Link Designator:\n");
#line 3778
    printf((char const   */* __restrict  */)"\t    Channel ID: %i\n", link_desc->channel_id);
    }
#line 3779
    if (link_desc->port_flag_0) {
#line 3779
      tmp___9 = "enable";
    } else {
#line 3779
      tmp___9 = "disable";
    }
    {
#line 3779
    printf((char const   */* __restrict  */)"\t\t Lane 0: %s\n", tmp___9);
    }
#line 3780
    if (link_desc->port_flag_1) {
#line 3780
      tmp___10 = "enable";
    } else {
#line 3780
      tmp___10 = "disable";
    }
    {
#line 3780
    printf((char const   */* __restrict  */)"\t\t Lane 1: %s\n", tmp___10);
    }
#line 3781
    if (link_desc->port_flag_2) {
#line 3781
      tmp___11 = "enable";
    } else {
#line 3781
      tmp___11 = "disable";
    }
    {
#line 3781
    printf((char const   */* __restrict  */)"\t\t Lane 2: %s\n", tmp___11);
    }
#line 3782
    if (link_desc->port_flag_3) {
#line 3782
      tmp___12 = "enable";
    } else {
#line 3782
      tmp___12 = "disable";
    }
    {
#line 3782
    printf((char const   */* __restrict  */)"\t\t Lane 3: %s\n", tmp___12);
#line 3783
    index_data += 5;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3785
  return;
}
}
#line 3804 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_amc_carrier_info_record___0(struct ipmi_ek_multi_header *record ) 
{ 
  unsigned char extVersion ;
  unsigned char siteCount ;
  int offset ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 3809
  offset = (int )START_DATA_OFFSET;
#line 3811
  tmp = offset;
#line 3811
  offset ++;
#line 3811
  extVersion = *(record->data + tmp);
#line 3812
  tmp___0 = offset;
#line 3812
  offset ++;
#line 3812
  siteCount = *(record->data + tmp___0);
#line 3814
  printf((char const   */* __restrict  */)"   AMC.0 extension version: R%d.%d\n",
         (int )extVersion & 15, ((int )extVersion >> 4) & 15);
#line 3816
  printf((char const   */* __restrict  */)"   Carrier Sie Number Count: %d\n", (int )siteCount);
  }
  {
#line 3818
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3818
    if (! ((int )siteCount > 0)) {
#line 3818
      goto while_break;
    }
    {
#line 3819
    tmp___1 = val2str((uint16_t )*(record->data + offset), ipmi_ekanalyzer_module_type);
#line 3819
    printf((char const   */* __restrict  */)"\tSite ID (%d): %s \n", (int )*(record->data + offset),
           tmp___1);
#line 3821
    offset ++;
#line 3822
    siteCount = (unsigned char )((int )siteCount - 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3824
  printf((char const   */* __restrict  */)"\n");
  }
#line 3825
  return;
}
}
#line 3846 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_clock_carrier_p2p_record___0(struct ipmi_ek_multi_header *record ) 
{ 
  unsigned char desc_count ;
  int i ;
  int j ;
  int offset ;
  int tmp ;
  unsigned char resource_id ;
  unsigned char channel_count ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned char loc_channel ;
  unsigned char rem_channel ;
  unsigned char rem_resource ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 3852
  offset = (int )START_DATA_OFFSET;
#line 3854
  tmp = offset;
#line 3854
  offset ++;
#line 3854
  desc_count = *(record->data + tmp);
#line 3856
  i = 0;
  {
#line 3856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3856
    if (! (i < (int )desc_count)) {
#line 3856
      goto while_break;
    }
    {
#line 3860
    tmp___0 = offset;
#line 3860
    offset ++;
#line 3860
    resource_id = *(record->data + tmp___0);
#line 3861
    tmp___1 = offset;
#line 3861
    offset ++;
#line 3861
    channel_count = *(record->data + tmp___1);
#line 3863
    printf((char const   */* __restrict  */)"   Clock Resource ID: 0x%02x\n", (int )resource_id);
#line 3864
    printf((char const   */* __restrict  */)"   Type: ");
    }
#line 3865
    if (((int )resource_id & 192) >> 6 == 0) {
      {
#line 3866
      printf((char const   */* __restrict  */)"On-Carrier-Device\n");
      }
    } else
#line 3868
    if (((int )resource_id & 192) >> 6 == 1) {
      {
#line 3869
      printf((char const   */* __restrict  */)"AMC slot\n");
      }
    } else
#line 3871
    if (((int )resource_id & 192) >> 6 == 2) {
      {
#line 3872
      printf((char const   */* __restrict  */)"Backplane\n");
      }
    } else {
      {
#line 3875
      printf((char const   */* __restrict  */)"reserved\n");
      }
    }
    {
#line 3877
    printf((char const   */* __restrict  */)"   Channel Count: 0x%02x\n", (int )channel_count);
#line 3879
    j = 0;
    }
    {
#line 3879
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3879
      if (! (j < (int )channel_count)) {
#line 3879
        goto while_break___0;
      }
      {
#line 3882
      tmp___2 = offset;
#line 3882
      offset ++;
#line 3882
      loc_channel = *(record->data + tmp___2);
#line 3883
      tmp___3 = offset;
#line 3883
      offset ++;
#line 3883
      rem_channel = *(record->data + tmp___3);
#line 3884
      tmp___4 = offset;
#line 3884
      offset ++;
#line 3884
      rem_resource = *(record->data + tmp___4);
#line 3886
      printf((char const   */* __restrict  */)"\tCLK-ID: 0x%02x   --->  ", (int )loc_channel);
#line 3887
      printf((char const   */* __restrict  */)" remote CLKID: 0x%02x   ", (int )rem_channel);
      }
#line 3888
      if (((int )rem_resource & 192) >> 6 == 0) {
        {
#line 3889
        printf((char const   */* __restrict  */)"[ Carrier-Dev");
        }
      } else
#line 3891
      if (((int )rem_resource & 192) >> 6 == 1) {
        {
#line 3892
        printf((char const   */* __restrict  */)"[ AMC slot    ");
        }
      } else
#line 3894
      if (((int )rem_resource & 192) >> 6 == 2) {
        {
#line 3895
        printf((char const   */* __restrict  */)"[ Backplane    ");
        }
      } else {
        {
#line 3898
        printf((char const   */* __restrict  */)"reserved          ");
        }
      }
      {
#line 3900
      printf((char const   */* __restrict  */)" 0x%02x ]\n", (int )rem_resource & 15);
#line 3879
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3856
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3903
  printf((char const   */* __restrict  */)"\n");
  }
#line 3904
  return;
}
}
#line 3924 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_display_clock_config_record___0(struct ipmi_ek_multi_header *record ) 
{ 
  unsigned char resource_id ;
  unsigned char descr_count ;
  int i ;
  int offset ;
  int tmp ;
  int tmp___0 ;
  unsigned char channel_id ;
  unsigned char control ;
  unsigned char indirect_cnt ;
  unsigned char direct_cnt ;
  int j ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned char feature ;
  unsigned char dep_chn_id ;
  int tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  unsigned char feature___0 ;
  unsigned char family ;
  unsigned char accuracy ;
  unsigned long freq ;
  unsigned long min_freq ;
  unsigned long max_freq ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;

  {
  {
#line 3929
  offset = (int )START_DATA_OFFSET;
#line 3931
  tmp = offset;
#line 3931
  offset ++;
#line 3931
  resource_id = *(record->data + tmp);
#line 3932
  tmp___0 = offset;
#line 3932
  offset ++;
#line 3932
  descr_count = *(record->data + tmp___0);
#line 3933
  printf((char const   */* __restrict  */)"   Clock Resource ID: 0x%02x\n", (int )resource_id);
#line 3934
  printf((char const   */* __restrict  */)"   Clock Configuration Descriptor Count: 0x%02x\n",
         (int )descr_count);
#line 3936
  i = 0;
  }
  {
#line 3936
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3936
    if (! (i < (int )descr_count)) {
#line 3936
      goto while_break;
    }
    {
#line 3939
    j = 0;
#line 3941
    tmp___1 = offset;
#line 3941
    offset ++;
#line 3941
    channel_id = *(record->data + tmp___1);
#line 3942
    tmp___2 = offset;
#line 3942
    offset ++;
#line 3942
    control = *(record->data + tmp___2);
#line 3943
    printf((char const   */* __restrict  */)"\tCLK-ID: 0x%02x  -  ", (int )channel_id);
    }
#line 3944
    if (((int )control & 1) == 0) {
#line 3944
      tmp___3 = "Carrier IPMC";
    } else {
#line 3944
      tmp___3 = "Application";
    }
    {
#line 3944
    printf((char const   */* __restrict  */)"CTRL 0x%02x [ %12s ]\n", (int )control,
           tmp___3);
#line 3947
    tmp___4 = offset;
#line 3947
    offset ++;
#line 3947
    indirect_cnt = *(record->data + tmp___4);
#line 3948
    tmp___5 = offset;
#line 3948
    offset ++;
#line 3948
    direct_cnt = *(record->data + tmp___5);
#line 3949
    printf((char const   */* __restrict  */)"\t   Count: Indirect 0x%02x   / Direct 0x%02x\n",
           (int )indirect_cnt, (int )direct_cnt);
#line 3953
    j = 0;
    }
    {
#line 3953
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3953
      if (! (j < (int )indirect_cnt)) {
#line 3953
        goto while_break___0;
      }
#line 3957
      tmp___6 = offset;
#line 3957
      offset ++;
#line 3957
      feature = *(record->data + tmp___6);
#line 3958
      tmp___7 = offset;
#line 3958
      offset ++;
#line 3958
      dep_chn_id = *(record->data + tmp___7);
#line 3959
      if (((int )feature & 1) == 1) {
#line 3959
        tmp___8 = "Source";
      } else {
#line 3959
        tmp___8 = "Receiver";
      }
      {
#line 3959
      printf((char const   */* __restrict  */)"\t\tFeature: 0x%02x [%8s] - ", (int )feature,
             tmp___8);
#line 3961
      printf((char const   */* __restrict  */)" Dep. CLK-ID: 0x%02x\n", (int )dep_chn_id);
#line 3953
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3965
    j = 0;
    {
#line 3965
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3965
      if (! (j < (int )direct_cnt)) {
#line 3965
        goto while_break___1;
      }
#line 3969
      tmp___9 = offset;
#line 3969
      offset ++;
#line 3969
      feature___0 = *(record->data + tmp___9);
#line 3970
      tmp___10 = offset;
#line 3970
      offset ++;
#line 3970
      family = *(record->data + tmp___10);
#line 3971
      tmp___11 = offset;
#line 3971
      offset ++;
#line 3971
      accuracy = *(record->data + tmp___11);
#line 3972
      freq = (unsigned long )((((int )*(record->data + offset) | ((int )*(record->data + (offset + 1)) << 8)) | ((int )*(record->data + (offset + 2)) << 16)) | ((int )*(record->data + (offset + 3)) << 24));
#line 3976
      offset += 4;
#line 3977
      min_freq = (unsigned long )((((int )*(record->data + offset) | ((int )*(record->data + (offset + 1)) << 8)) | ((int )*(record->data + (offset + 2)) << 16)) | ((int )*(record->data + (offset + 3)) << 24));
#line 3981
      offset += 4;
#line 3982
      max_freq = (unsigned long )((((int )*(record->data + offset) | ((int )*(record->data + (offset + 1)) << 8)) | ((int )*(record->data + (offset + 2)) << 16)) | ((int )*(record->data + (offset + 3)) << 24));
#line 3986
      offset += 4;
#line 3988
      if ((int )feature___0 & 1) {
#line 3988
        tmp___12 = "Source";
      } else {
#line 3988
        tmp___12 = "Receiver";
      }
      {
#line 3988
      printf((char const   */* __restrict  */)"\t- Feature: 0x%02x    - PLL: %x / Asym: %s\n",
             (int )feature___0, ((int )feature___0 > 1) & 1, tmp___12);
#line 3992
      printf((char const   */* __restrict  */)"\tFamily:  0x%02x    - AccLVL: 0x%02x\n",
             (int )family, (int )accuracy);
#line 3993
      printf((char const   */* __restrict  */)"\tFRQ: %-9ld - min: %-9ld - max: %-9ld\n",
             freq, min_freq, max_freq);
#line 3965
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3996
    printf((char const   */* __restrict  */)"\n");
#line 3936
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3998
  return;
}
}
#line 4019 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static int ipmi_ekanalyzer_fru_file2structure___0(char *filename , struct ipmi_ek_multi_header **list_head ,
                                                  struct ipmi_ek_multi_header **list_record ,
                                                  struct ipmi_ek_multi_header **list_last ) 
{ 
  FILE *input_file ;
  unsigned char data ;
  unsigned char last_record ;
  unsigned int multi_offset ;
  int record_count ;
  int ret ;
  size_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int i ;
  int tmp___7 ;

  {
  {
#line 4027
  last_record = (unsigned char)0;
#line 4028
  multi_offset = 0U;
#line 4029
  record_count = 0;
#line 4030
  ret = 0;
#line 4032
  input_file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 4033
  if ((unsigned long )input_file == (unsigned long )((void *)0)) {
    {
#line 4034
    lprintf(3, "File: \'%s\' is not found", filename);
    }
#line 4035
    return ((int )ERROR_STATUS);
  }
  {
#line 4038
  fseek(input_file, (long )START_DATA_OFFSET, 0);
#line 4039
  data = (unsigned char)0;
#line 4040
  tmp = fread((void */* __restrict  */)(& data), (size_t )1, (size_t )1, (FILE */* __restrict  */)input_file);
#line 4040
  ret = (int )tmp;
  }
#line 4041
  if (ret != 1) {
    {
#line 4042
    lprintf(3, "Invalid Offset!");
#line 4043
    fclose(input_file);
    }
#line 4044
    return ((int )ERROR_STATUS);
  } else {
    {
#line 4041
    tmp___0 = ferror(input_file);
    }
#line 4041
    if (tmp___0) {
      {
#line 4042
      lprintf(3, "Invalid Offset!");
#line 4043
      fclose(input_file);
      }
#line 4044
      return ((int )ERROR_STATUS);
    }
  }
#line 4046
  if ((int )data == 0) {
    {
#line 4047
    lprintf(3, "There is no multi record in the file \'%s\'", filename);
#line 4049
    fclose(input_file);
    }
#line 4050
    return ((int )ERROR_STATUS);
  }
  {
#line 4053
  multi_offset = (unsigned int )((int )data * 8);
#line 4054
  lprintf(7, "start multi offset = 0x%02x", multi_offset);
#line 4057
  fseek(input_file, (long )multi_offset, 0);
  }
  {
#line 4058
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4058
    tmp___7 = feof(input_file);
    }
#line 4058
    if (tmp___7) {
#line 4058
      goto while_break;
    }
    {
#line 4059
    tmp___1 = malloc(sizeof(struct ipmi_ek_multi_header ));
#line 4059
    *list_record = (struct ipmi_ek_multi_header *)tmp___1;
#line 4060
    tmp___2 = fread((void */* __restrict  */)(& (*list_record)->header), (size_t )START_DATA_OFFSET,
                    (size_t )1, (FILE */* __restrict  */)input_file);
#line 4060
    ret = (int )tmp___2;
    }
#line 4062
    if (ret != 1) {
      {
#line 4063
      lprintf(3, "Invalid Header!");
#line 4064
      fclose(input_file);
      }
#line 4065
      return ((int )ERROR_STATUS);
    } else {
      {
#line 4062
      tmp___3 = ferror(input_file);
      }
#line 4062
      if (tmp___3) {
        {
#line 4063
        lprintf(3, "Invalid Header!");
#line 4064
        fclose(input_file);
        }
#line 4065
        return ((int )ERROR_STATUS);
      }
    }
#line 4067
    if ((int )(*list_record)->header.len == 0) {
#line 4068
      record_count ++;
#line 4069
      goto while_continue;
    }
    {
#line 4071
    tmp___4 = malloc((size_t )(*list_record)->header.len);
#line 4071
    (*list_record)->data = (unsigned char *)tmp___4;
    }
#line 4072
    if ((unsigned long )(*list_record)->data == (unsigned long )((void *)0)) {
      {
#line 4073
      lprintf(3, "Failed to allocation memory size %d\n", (int )(*list_record)->header.len);
#line 4075
      record_count ++;
      }
#line 4076
      goto while_continue;
    }
    {
#line 4079
    tmp___5 = fread((void */* __restrict  */)(*list_record)->data, (size_t )(*list_record)->header.len,
                    (size_t )1, (FILE */* __restrict  */)input_file);
#line 4079
    ret = (int )tmp___5;
    }
#line 4081
    if (ret != 1) {
      {
#line 4082
      lprintf(3, "Invalid Record Data!");
#line 4083
      fclose(input_file);
      }
#line 4084
      return ((int )ERROR_STATUS);
    } else {
      {
#line 4081
      tmp___6 = ferror(input_file);
      }
#line 4081
      if (tmp___6) {
        {
#line 4082
        lprintf(3, "Invalid Record Data!");
#line 4083
        fclose(input_file);
        }
#line 4084
        return ((int )ERROR_STATUS);
      }
    }
#line 4086
    if (verbose > 0) {
      {
#line 4087
      printf((char const   */* __restrict  */)"Record %d has length = %02x\n", record_count,
             (int )(*list_record)->header.len);
      }
    }
#line 4089
    if (verbose > 1) {
      {
#line 4091
      printf((char const   */* __restrict  */)"Type: %02x", (int )(*list_record)->header.type);
#line 4092
      i = 0;
      }
      {
#line 4092
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 4092
        if (! (i < (int )(*list_record)->header.len)) {
#line 4092
          goto while_break___0;
        }
#line 4093
        if (! (i % 8)) {
          {
#line 4094
          printf((char const   */* __restrict  */)"\n0x%02x: ", i);
          }
        }
        {
#line 4096
        printf((char const   */* __restrict  */)"%02x ", (int )*((*list_record)->data + i));
#line 4092
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 4099
      printf((char const   */* __restrict  */)"\n\n");
      }
    }
    {
#line 4101
    ipmi_ek_add_record2list___0(list_record, list_head, list_last);
#line 4103
    last_record = (unsigned char )((int )(*list_record)->header.format & 128);
    }
#line 4104
    if (last_record) {
#line 4105
      goto while_break;
    }
#line 4107
    record_count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4109
  fclose(input_file);
  }
#line 4110
  return ((int )OK_STATUS);
}
}
#line 4132 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_add_record2list___0(struct ipmi_ek_multi_header **record , struct ipmi_ek_multi_header **list_head ,
                                        struct ipmi_ek_multi_header **list_last ) 
{ 


  {
#line 4137
  if ((unsigned long )*list_head == (unsigned long )((void *)0)) {
#line 4138
    *list_head = *record;
#line 4139
    (*record)->prev = (struct ipmi_ek_multi_header *)((void *)0);
#line 4140
    if (verbose > 2) {
      {
#line 4141
      printf((char const   */* __restrict  */)"Adding first record to list\n");
      }
    }
  } else {
#line 4144
    (*list_last)->next = *record;
#line 4145
    (*record)->prev = *list_last;
#line 4146
    if (verbose > 2) {
      {
#line 4147
      printf((char const   */* __restrict  */)"Add 1 record to list\n");
      }
    }
  }
#line 4149
  *list_last = *record;
#line 4150
  (*record)->next = (struct ipmi_ek_multi_header *)((void *)0);
#line 4151
  return;
}
}
#line 4171 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ekanalyzer.c"
static void ipmi_ek_remove_record_from_list___0(struct ipmi_ek_multi_header *record ,
                                                struct ipmi_ek_multi_header **list_head ,
                                                struct ipmi_ek_multi_header **list_last ) 
{ 


  {
#line 4176
  if ((unsigned long )record->prev == (unsigned long )((void *)0)) {
#line 4177
    *list_head = record->next;
  } else {
#line 4179
    (record->prev)->next = record->next;
  }
#line 4180
  if ((unsigned long )record->next == (unsigned long )((void *)0)) {
#line 4181
    *list_last = record->prev;
  } else {
#line 4183
    (record->next)->prev = record->prev;
  }
  {
#line 4184
  free((void *)record);
#line 4185
  record = (struct ipmi_ek_multi_header *)((void *)0);
  }
#line 4186
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int const   IME_SUCCESS___0  =    (int const   )0;
#line 97 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int const   IME_ERROR___0  =    (int const   )-1;
#line 98 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int const   IME_RESTART___0  =    (int const   )-2;
#line 159
static void ImePrintUsage___0(void) ;
#line 160
static int ImeGetInfo___0(struct ipmi_intf *intf ) ;
#line 161
static int ImeUpgrade___0(struct ipmi_intf *intf , char *imageFilename ) ;
#line 162
static int ImeManualRollback___0(struct ipmi_intf *intf ) ;
#line 163
static int ImeUpdatePrepare___0(struct ipmi_intf *intf ) ;
#line 164
static int ImeUpdateOpenArea___0(struct ipmi_intf *intf ) ;
#line 165
static int ImeUpdateWriteArea___0(struct ipmi_intf *intf , uint8_t sequence , uint8_t length ,
                                  uint8_t *pBuf ) ;
#line 171
static int ImeUpdateCloseArea___0(struct ipmi_intf *intf , uint32_t size , uint16_t checksum ) ;
#line 177
static int ImeUpdateGetStatus___0(struct ipmi_intf *intf , tImeStatus *pStatus ) ;
#line 178
static int ImeUpdateGetCapabilities___0(struct ipmi_intf *intf , tImeCaps *pCaps ) ;
#line 179
static int ImeUpdateRegisterUpdate___0(struct ipmi_intf *intf , tImeUpdateType type ) ;
#line 181
static int ImeImageCtxFromFile___0(char *imageFilename , tImeUpdateImageCtx *pImageCtx ) ;
#line 186
static uint8_t ImeCrc8___0(uint32_t length , uint8_t *pBuf ) ;
#line 189 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int ImeGetInfo___0(struct ipmi_intf *intf ) 
{ 
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct ipm_devid_rsp *devid ;
  char const   *product ;
  tImeStatus status ;
  tImeCaps caps ;
  char const   *tmp ;
  char const   *tmp___0 ;
  uint16_t tmp___1 ;
  uint8_t newImage ;
  uint8_t rollImage ;
  uint8_t runArea ;
  uint8_t rollSup ;
  uint8_t recovSup ;
  uint8_t operSup ;
  uint8_t piaSup ;
  uint8_t sdrSup ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 191
  rc = (int )IME_ERROR___0;
#line 195
  product = (char const   *)((void *)0);
#line 199
  memset((void *)(& req), 0, sizeof(req));
#line 200
  req.msg.netfn = (uint8_t )6;
#line 201
  req.msg.cmd = (uint8_t )1;
#line 202
  req.msg.data_len = (uint16_t )0;
#line 204
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 205
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 206
    lprintf(3, "Get Device ID command failed");
    }
#line 207
    return ((int )IME_ERROR___0);
  }
#line 209
  if ((int )rsp->ccode > 0) {
    {
#line 210
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 210
    lprintf(3, "Get Device ID command failed: %s", tmp);
    }
#line 212
    return ((int )IME_ERROR___0);
  }
  {
#line 215
  devid = (struct ipm_devid_rsp *)(rsp->data);
#line 217
  lprintf(7, "Device ID                 : %i", (int )devid->device_id);
#line 218
  lprintf(7, "Device Revision           : %i", (int )devid->device_revision & 15);
  }
#line 221
  if ((int )devid->device_id == 0) {
#line 221
    if (((int )devid->device_revision & 15) == 0) {
#line 221
      if ((int )devid->manufacturer_id[0] == 87) {
#line 221
        if ((int )devid->manufacturer_id[1] == 1) {
#line 221
          if ((int )devid->manufacturer_id[2] == 0) {
#line 221
            if ((int )devid->product_id[1] == 11) {
#line 221
              if ((int )devid->product_id[0] == 0) {
                {
#line 241
                rc = (int )IME_SUCCESS___0;
#line 242
                tmp___0 = val2str((uint16_t )((long )((uint32_t )(((((int )devid->manufacturer_id[2] & 15) << 16) | ((int )devid->manufacturer_id[1] << 8)) | (int )devid->manufacturer_id[0]))),
                                  ipmi_oem_info);
#line 242
                printf((char const   */* __restrict  */)"Manufacturer Name          : %s\n",
                       tmp___0);
#line 246
                tmp___1 = buf2short(devid->product_id);
#line 246
                printf((char const   */* __restrict  */)"Product ID                 : %u (0x%02x%02x)\n",
                       (int )tmp___1, (int )devid->product_id[1], (int )devid->product_id[0]);
#line 250
                product = oemval2str((uint32_t )(((((int )devid->manufacturer_id[2] & 15) << 16) | ((int )devid->manufacturer_id[1] << 8)) | (int )devid->manufacturer_id[0]),
                                     (uint16_t )(((int )devid->product_id[1] << 8) + (int )devid->product_id[0]),
                                     ipmi_oem_product_info);
                }
#line 254
                if ((unsigned long )product != (unsigned long )((void *)0)) {
                  {
#line 256
                  printf((char const   */* __restrict  */)"Product Name               : %s\n",
                         product);
                  }
                }
                {
#line 259
                printf((char const   */* __restrict  */)"Intel ME Firmware Revision : %x.%02x.%02x.%x%x%x.%x\n",
                       (int )devid->fw_rev1 & 63, (int )devid->fw_rev2 >> 4, (int )devid->fw_rev2 & 15,
                       (int )devid->aux_fw_rev[1] >> 4, (int )devid->aux_fw_rev[1] & 15,
                       (int )devid->aux_fw_rev[2] >> 4, (int )devid->aux_fw_rev[2] & 15);
#line 269
                printf((char const   */* __restrict  */)"SPS FW IPMI cmd version    : %x.%x\n",
                       (int )devid->aux_fw_rev[0] >> 4, (int )devid->aux_fw_rev[0] & 15);
#line 273
                lprintf(7, "Flags: %xh", (int )devid->aux_fw_rev[3]);
#line 275
                printf((char const   */* __restrict  */)"Current Image Type         : ");
                }
                {
#line 278
                if (((int )devid->aux_fw_rev[3] & 3) == 0) {
#line 278
                  goto case_0;
                }
#line 282
                if (((int )devid->aux_fw_rev[3] & 3) == 1) {
#line 282
                  goto case_1;
                }
#line 286
                if (((int )devid->aux_fw_rev[3] & 3) == 2) {
#line 286
                  goto case_2;
                }
#line 291
                goto switch_default;
                case_0: /* CIL Label */ 
                {
#line 279
                printf((char const   */* __restrict  */)"Recovery\n");
                }
#line 280
                goto switch_break;
                case_1: /* CIL Label */ 
                {
#line 283
                printf((char const   */* __restrict  */)"Operational Image 1\n");
                }
#line 284
                goto switch_break;
                case_2: /* CIL Label */ 
                {
#line 287
                printf((char const   */* __restrict  */)"Operational Image 2\n");
                }
#line 288
                goto switch_break;
                switch_default: /* CIL Label */ 
                {
#line 292
                printf((char const   */* __restrict  */)"Unknown\n");
                }
#line 293
                goto switch_break;
                switch_break: /* CIL Label */ ;
                }
              } else {
                {
#line 298
                printf((char const   */* __restrict  */)"Supported ME not found\n");
                }
              }
            } else {
              {
#line 298
              printf((char const   */* __restrict  */)"Supported ME not found\n");
              }
            }
          } else {
            {
#line 298
            printf((char const   */* __restrict  */)"Supported ME not found\n");
            }
          }
        } else {
          {
#line 298
          printf((char const   */* __restrict  */)"Supported ME not found\n");
          }
        }
      } else {
        {
#line 298
        printf((char const   */* __restrict  */)"Supported ME not found\n");
        }
      }
    } else {
      {
#line 298
      printf((char const   */* __restrict  */)"Supported ME not found\n");
      }
    }
  } else {
    {
#line 298
    printf((char const   */* __restrict  */)"Supported ME not found\n");
    }
  }
#line 301
  if (rc == (int )IME_SUCCESS___0) {
    {
#line 303
    rc = ImeUpdateGetStatus___0(intf, & status);
    }
#line 305
    if (rc == (int )IME_SUCCESS___0) {
      {
#line 307
      rc = ImeUpdateGetCapabilities___0(intf, & caps);
      }
    }
  }
#line 312
  if (rc == (int )IME_SUCCESS___0) {
    {
#line 314
    newImage = (uint8_t )(((int )status.image_status >> 1) & 1);
#line 315
    rollImage = (uint8_t )(((int )status.image_status >> 2) & 1);
#line 316
    runArea = (uint8_t )(((int )status.image_status >> 3) & 3);
#line 317
    rollSup = (uint8_t )((int )caps.special_caps & 1);
#line 318
    recovSup = (uint8_t )(((int )caps.special_caps >> 1) & 1);
#line 320
    operSup = (uint8_t )(((int )caps.area_supported >> 1) & 1);
#line 321
    piaSup = (uint8_t )(((int )caps.area_supported >> 2) & 1);
#line 322
    sdrSup = (uint8_t )(((int )caps.area_supported >> 3) & 1);
#line 324
    printf((char const   */* __restrict  */)"\nSupported Area\n");
    }
#line 325
    if (operSup) {
#line 325
      tmp___2 = "Supported";
    } else {
#line 325
      tmp___2 = "Unsupported";
    }
    {
#line 325
    printf((char const   */* __restrict  */)"   Operation Code          : %s\n", tmp___2);
    }
#line 326
    if (piaSup) {
#line 326
      tmp___3 = "Supported";
    } else {
#line 326
      tmp___3 = "Unsupported";
    }
    {
#line 326
    printf((char const   */* __restrict  */)"   PIA                     : %s\n", tmp___3);
    }
#line 327
    if (sdrSup) {
#line 327
      tmp___4 = "Supported";
    } else {
#line 327
      tmp___4 = "Unsupported";
    }
    {
#line 327
    printf((char const   */* __restrict  */)"   SDR                     : %s\n", tmp___4);
#line 329
    printf((char const   */* __restrict  */)"\nSpecial Capabilities\n");
    }
#line 330
    if (rollSup) {
#line 330
      tmp___5 = "Supported";
    } else {
#line 330
      tmp___5 = "Unsupported";
    }
    {
#line 330
    printf((char const   */* __restrict  */)"   Rollback                : %s\n", tmp___5);
    }
#line 331
    if (recovSup) {
#line 331
      tmp___6 = "Supported";
    } else {
#line 331
      tmp___6 = "Unsupported";
    }
    {
#line 331
    printf((char const   */* __restrict  */)"   Recovery                : %s\n", tmp___6);
#line 333
    printf((char const   */* __restrict  */)"\nImage Status\n");
    }
#line 334
    if (newImage) {
#line 334
      tmp___7 = "Valid";
    } else {
#line 334
      tmp___7 = "Invalid";
    }
    {
#line 334
    printf((char const   */* __restrict  */)"   Staging (new)           : %s\n", tmp___7);
    }
#line 335
    if (rollImage) {
#line 335
      tmp___8 = "Valid";
    } else {
#line 335
      tmp___8 = "Invalid";
    }
    {
#line 335
    printf((char const   */* __restrict  */)"   Rollback                : %s\n", tmp___8);
    }
#line 336
    if ((int )runArea == 0) {
      {
#line 337
      printf((char const   */* __restrict  */)"   Running Image Area      : CODE\n");
      }
    } else {
      {
#line 339
      printf((char const   */* __restrict  */)"   Running Image Area      : CODE%d\n",
             (int )runArea);
      }
    }
  }
#line 343
  return (rc);
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int ImeUpgrade___0(struct ipmi_intf *intf , char *imageFilename ) 
{ 
  int rc ;
  tImeUpdateImageCtx imgCtx ;
  tImeStatus imeStatus ;
  time_t start ;
  time_t end ;
  time_t current ;
  uint8_t sequence ;
  uint32_t counter ;
  uint8_t retry ;
  uint8_t shownPercent ;
  uint8_t length ;
  uint8_t currentPercent ;
  uint16_t timeElapsedSecond ;

  {
  {
#line 349
  rc = (int )IME_SUCCESS___0;
#line 354
  time(& start);
#line 356
  memset((void *)(& imgCtx), 0, sizeof(tImeUpdateImageCtx ));
#line 358
  rc = ImeImageCtxFromFile___0(imageFilename, & imgCtx);
  }
#line 360
  if (rc == (int )IME_ERROR___0) {
#line 366
    return ((int )IME_ERROR___0);
  } else
#line 360
  if ((unsigned long )imgCtx.pData == (unsigned long )((void *)0)) {
#line 366
    return ((int )IME_ERROR___0);
  } else
#line 360
  if (imgCtx.size == 0U) {
#line 366
    return ((int )IME_ERROR___0);
  }
  {
#line 369
  ImeUpdateGetStatus___0(intf, & imeStatus);
  }
#line 371
  if (rc == (int )IME_SUCCESS___0) {
    {
#line 373
    rc = ImeUpdatePrepare___0(intf);
#line 374
    ImeUpdateGetStatus___0(intf, & imeStatus);
    }
  }
#line 377
  if (rc == (int )IME_SUCCESS___0) {
#line 377
    if ((unsigned int )imeStatus.update_state == 1U) {
      {
#line 382
      rc = ImeUpdateOpenArea___0(intf);
#line 383
      ImeUpdateGetStatus___0(intf, & imeStatus);
      }
    } else {
#line 377
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 385
  if (rc == (int )IME_SUCCESS___0) {
    {
#line 387
    lprintf(3, "ME state error (%i), aborting", (unsigned int )imeStatus.update_state);
#line 388
    rc = (int )IME_ERROR___0;
    }
  }
#line 392
  if (rc == (int )IME_SUCCESS___0) {
#line 392
    if ((unsigned int )imeStatus.update_state == 2U) {
#line 397
      sequence = (uint8_t )0;
#line 398
      counter = (uint32_t )0;
#line 399
      retry = (uint8_t )0;
#line 400
      shownPercent = (uint8_t )255;
      {
#line 402
      while (1) {
        while_continue: /* CIL Label */ ;
#line 402
        if (counter < imgCtx.size) {
#line 402
          if (rc == (int )IME_SUCCESS___0) {
#line 402
            if (! ((int )retry < 5)) {
#line 402
              goto while_break;
            }
          } else {
#line 402
            goto while_break;
          }
        } else {
#line 402
          goto while_break;
        }
#line 408
        length = (uint8_t )22;
#line 411
        if (imgCtx.size - counter < 22U) {
#line 413
          length = (uint8_t )(imgCtx.size - counter);
        }
        {
#line 416
        rc = ImeUpdateWriteArea___0(intf, sequence, length, imgCtx.pData + counter);
#line 425
        counter += (uint32_t )length;
#line 426
        sequence = (uint8_t )((int )sequence + 1);
#line 429
        currentPercent = (uint8_t )(((float )counter / (float )imgCtx.size) * (float )100);
        }
#line 431
        if ((int )currentPercent != (int )shownPercent) {
          {
#line 435
          shownPercent = currentPercent;
#line 436
          printf((char const   */* __restrict  */)"Percent: %02i,  ", (int )shownPercent);
#line 437
          time(& current);
#line 438
          timeElapsedSecond = (uint16_t )((current - start) + (current - start) % 60L);
#line 439
          printf((char const   */* __restrict  */)"Elapsed time %02ld:%02ld\r", (current - start) / 60L,
                 (current - start) % 60L);
#line 440
          fflush(stdout);
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 444
      ImeUpdateGetStatus___0(intf, & imeStatus);
#line 445
      printf((char const   */* __restrict  */)"\n");
      }
    } else {
#line 392
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 447
  if (rc == (int )IME_SUCCESS___0) {
    {
#line 449
    lprintf(3, "ME state error (%i), aborting", (unsigned int )imeStatus.update_state);
#line 450
    rc = (int )IME_ERROR___0;
    }
  }
#line 453
  if (rc == (int )IME_SUCCESS___0) {
#line 453
    if ((unsigned int )imeStatus.update_state == 2U) {
      {
#line 458
      rc = ImeUpdateCloseArea___0(intf, imgCtx.size, (uint16_t )imgCtx.crc8);
#line 459
      ImeUpdateGetStatus___0(intf, & imeStatus);
      }
    } else {
#line 453
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 461
  if (rc == (int )IME_SUCCESS___0) {
    {
#line 463
    lprintf(3, "ME state error, aborting");
#line 464
    rc = (int )IME_ERROR___0;
    }
  }
#line 467
  if (rc == (int )IME_SUCCESS___0) {
#line 467
    if ((unsigned int )imeStatus.update_state == 1U) {
      {
#line 472
      printf((char const   */* __restrict  */)"UpdateCompleted, Activate now\n");
#line 473
      rc = ImeUpdateRegisterUpdate___0(intf, (tImeUpdateType )1);
#line 474
      ImeUpdateGetStatus___0(intf, & imeStatus);
      }
    } else {
#line 467
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 476
  if (rc == (int )IME_SUCCESS___0) {
    {
#line 478
    lprintf(3, "ME state error, aborting");
#line 479
    rc = (int )IME_ERROR___0;
    }
  }
#line 482
  if (rc == (int )IME_SUCCESS___0) {
#line 482
    if ((unsigned int )imeStatus.update_state == 3U) {
      {
#line 487
      time(& end);
#line 488
      printf((char const   */* __restrict  */)"Update Completed in %02ld:%02ld\n",
             (end - start) / 60L, (end - start) % 60L);
      }
    } else {
      {
#line 492
      time(& end);
#line 493
      printf((char const   */* __restrict  */)"Update Error\n");
#line 494
      printf((char const   */* __restrict  */)"\nTime Taken %02ld:%02ld\n", (end - start) / 60L,
             (end - start) % 60L);
      }
    }
  } else {
    {
#line 492
    time(& end);
#line 493
    printf((char const   */* __restrict  */)"Update Error\n");
#line 494
    printf((char const   */* __restrict  */)"\nTime Taken %02ld:%02ld\n", (end - start) / 60L,
           (end - start) % 60L);
    }
  }
#line 497
  return (rc);
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int ImeUpdatePrepare___0(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  char const   *tmp ;

  {
  {
#line 510
  memset((void *)(& req), 0, sizeof(req));
#line 511
  req.msg.netfn = (uint8_t )48;
#line 512
  req.msg.cmd = (uint8_t )160;
#line 513
  req.msg.data_len = (uint16_t )0;
#line 515
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 516
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 517
    lprintf(3, "UpdatePrepare command failed");
    }
#line 518
    return ((int )IME_ERROR___0);
  }
#line 520
  if ((int )rsp->ccode > 0) {
    {
#line 521
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 521
    lprintf(3, "UpdatePrepare command failed: %s", tmp);
    }
#line 523
    return ((int )IME_ERROR___0);
  }
  {
#line 526
  lprintf(7, "UpdatePrepare command succeed");
  }
#line 527
  return ((int )IME_SUCCESS___0);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int ImeUpdateOpenArea___0(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t buffer[2] ;
  char const   *tmp ;

  {
  {
#line 540
  memset((void *)(& req), 0, sizeof(req));
#line 541
  req.msg.netfn = (uint8_t )48;
#line 542
  req.msg.cmd = (uint8_t )161;
#line 544
  buffer[0] = (uint8_t )1;
#line 545
  buffer[1] = (uint8_t )0;
#line 546
  req.msg.data = buffer;
#line 548
  req.msg.data_len = (uint16_t )2;
#line 550
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 551
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 552
    lprintf(3, "UpdateOpenArea command failed");
    }
#line 553
    return ((int )IME_ERROR___0);
  }
#line 555
  if ((int )rsp->ccode > 0) {
    {
#line 556
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 556
    lprintf(3, "UpdateOpenArea command failed: %s", tmp);
    }
#line 558
    return ((int )IME_ERROR___0);
  }
  {
#line 561
  lprintf(7, "UpdateOpenArea command succeed");
  }
#line 562
  return ((int )IME_SUCCESS___0);
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int ImeUpdateWriteArea___0(struct ipmi_intf *intf , uint8_t sequence , uint8_t length ,
                                  uint8_t *pBuf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t buffer[23] ;
  char const   *tmp ;

  {
#line 578
  if ((int )length > 22) {
#line 579
    return ((int )IME_ERROR___0);
  }
  {
#line 581
  buffer[0] = sequence;
#line 582
  memcpy((void */* __restrict  */)(& buffer[1]), (void const   */* __restrict  */)pBuf,
         (size_t )length);
#line 584
  memset((void *)(& req), 0, sizeof(req));
#line 585
  req.msg.netfn = (uint8_t )48;
#line 586
  req.msg.cmd = (uint8_t )162;
#line 587
  req.msg.data = buffer;
#line 588
  req.msg.data_len = (uint16_t )((int )length + 1);
#line 590
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 591
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 592
    lprintf(3, "UpdateWriteArea command failed");
    }
#line 593
    return ((int )IME_ERROR___0);
  }
#line 595
  if ((int )rsp->ccode > 0) {
    {
#line 596
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 596
    lprintf(3, "UpdateWriteArea command failed: %s", tmp);
    }
#line 598
    if ((int )rsp->ccode == 128) {
#line 599
      return ((int )IME_RESTART___0);
    } else {
#line 601
      return ((int )IME_ERROR___0);
    }
  }
  {
#line 604
  lprintf(7, "UpdateWriteArea command succeed");
  }
#line 605
  return ((int )IME_SUCCESS___0);
}
}
#line 608 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int ImeUpdateCloseArea___0(struct ipmi_intf *intf , uint32_t size , uint16_t checksum ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t length ;
  uint8_t buffer[sizeof(uint32_t ) + sizeof(uint16_t )] ;
  char const   *tmp ;

  {
  {
#line 616
  length = (uint8_t )(sizeof(uint32_t ) + sizeof(uint16_t ));
#line 623
  buffer[0] = (uint8_t )(size & 255U);
#line 624
  buffer[1] = (uint8_t )((size & 65280U) >> 8);
#line 625
  buffer[2] = (uint8_t )((size & 16711680U) >> 16);
#line 626
  buffer[3] = (uint8_t )((size & 4278190080U) >> 24);
#line 628
  buffer[4] = (uint8_t )((int )checksum & 255);
#line 629
  buffer[5] = (uint8_t )(((int )checksum & 65280) >> 8);
#line 631
  memset((void *)(& req), 0, sizeof(req));
#line 632
  req.msg.netfn = (uint8_t )48;
#line 633
  req.msg.cmd = (uint8_t )163;
#line 634
  req.msg.data = buffer;
#line 635
  req.msg.data_len = (uint16_t )length;
#line 637
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 638
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 639
    lprintf(3, "UpdateCloseArea command failed");
    }
#line 640
    return ((int )IME_ERROR___0);
  }
#line 642
  if ((int )rsp->ccode > 0) {
    {
#line 643
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 643
    lprintf(3, "UpdateCloseArea command failed: %s", tmp);
    }
#line 645
    return ((int )IME_ERROR___0);
  }
  {
#line 648
  lprintf(7, "UpdateCloseArea command succeed");
  }
#line 649
  return ((int )IME_SUCCESS___0);
}
}
#line 652 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int ImeUpdateGetStatus___0(struct ipmi_intf *intf , tImeStatus *pStatus ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  tImeStatus *pGetStatus ;
  char const   *tmp ;

  {
  {
#line 658
  memset((void *)pStatus, 0, sizeof(tImeStatus ));
#line 659
  pStatus->update_state = (tImeStateEnum )6;
#line 666
  memset((void *)(& req), 0, sizeof(req));
#line 667
  req.msg.netfn = (uint8_t )48;
#line 668
  req.msg.cmd = (uint8_t )166;
#line 669
  req.msg.data_len = (uint16_t )0;
#line 671
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 672
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 673
    lprintf(3, "UpdatePrepare command failed");
    }
#line 674
    return ((int )IME_ERROR___0);
  }
#line 676
  if ((int )rsp->ccode > 0) {
    {
#line 677
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 677
    lprintf(3, "UpdatePrepare command failed: %s", tmp);
    }
#line 679
    return ((int )IME_ERROR___0);
  }
  {
#line 682
  lprintf(7, "UpdatePrepare command succeed");
#line 684
  pGetStatus = (tImeStatus *)(rsp->data);
#line 686
  memcpy((void */* __restrict  */)pStatus, (void const   */* __restrict  */)pGetStatus,
         sizeof(tImeStatus ));
  }
#line 723
  return ((int )IME_SUCCESS___0);
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int ImeUpdateGetCapabilities___0(struct ipmi_intf *intf , tImeCaps *pCaps ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  tImeCaps *pGetCaps ;
  char const   *tmp ;

  {
  {
#line 732
  memset((void *)pCaps, 0, sizeof(tImeCaps ));
#line 739
  memset((void *)(& req), 0, sizeof(req));
#line 740
  req.msg.netfn = (uint8_t )48;
#line 741
  req.msg.cmd = (uint8_t )167;
#line 742
  req.msg.data_len = (uint16_t )0;
#line 744
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 745
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 746
    lprintf(3, "UpdatePrepare command failed");
    }
#line 747
    return ((int )IME_ERROR___0);
  }
#line 749
  if ((int )rsp->ccode > 0) {
    {
#line 750
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 750
    lprintf(3, "UpdatePrepare command failed: %s", tmp);
    }
#line 752
    return ((int )IME_ERROR___0);
  }
  {
#line 755
  lprintf(7, "UpdatePrepare command succeed");
#line 757
  pGetCaps = (tImeCaps *)(rsp->data);
#line 759
  memcpy((void */* __restrict  */)pCaps, (void const   */* __restrict  */)pGetCaps,
         sizeof(tImeCaps ));
  }
#line 761
  return ((int )IME_SUCCESS___0);
}
}
#line 765 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int ImeUpdateRegisterUpdate___0(struct ipmi_intf *intf , tImeUpdateType type ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t buffer[2] ;
  char const   *tmp ;

  {
  {
#line 775
  buffer[0] = (uint8_t )type;
#line 776
  buffer[1] = (uint8_t )0;
#line 778
  memset((void *)(& req), 0, sizeof(req));
#line 779
  req.msg.netfn = (uint8_t )48;
#line 780
  req.msg.cmd = (uint8_t )164;
#line 781
  req.msg.data = buffer;
#line 782
  req.msg.data_len = (uint16_t )2;
#line 784
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 785
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 786
    lprintf(3, "ImeUpdateRegisterUpdate command failed");
    }
#line 787
    return ((int )IME_ERROR___0);
  }
#line 789
  if ((int )rsp->ccode > 0) {
    {
#line 790
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 790
    lprintf(3, "ImeUpdateRegisterUpdate command failed: %s", tmp);
    }
#line 792
    return ((int )IME_ERROR___0);
  }
  {
#line 795
  lprintf(7, "ImeUpdateRegisterUpdate command succeed");
  }
#line 796
  return ((int )IME_SUCCESS___0);
}
}
#line 878 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int ImeImageCtxFromFile___0(char *imageFilename , tImeUpdateImageCtx *pImageCtx ) 
{ 
  int rc ;
  FILE *pImageFile ;
  FILE *tmp ;
  long tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 883
  rc = (int )IME_SUCCESS___0;
#line 884
  tmp = fopen((char const   */* __restrict  */)imageFilename, (char const   */* __restrict  */)"rb");
#line 884
  pImageFile = tmp;
  }
#line 886
  if ((unsigned long )pImageFile == (unsigned long )((void *)0)) {
    {
#line 888
    lprintf(5, "Cannot open image file %s", imageFilename);
#line 889
    rc = (int )IME_ERROR___0;
    }
  }
#line 892
  if (rc == (int )IME_SUCCESS___0) {
    {
#line 895
    fseek(pImageFile, 0L, 2);
#line 896
    tmp___0 = ftell(pImageFile);
#line 896
    pImageCtx->size = (uint32_t )tmp___0;
    }
#line 897
    if (pImageCtx->size <= 0U) {
#line 898
      if (pImageCtx->size < 0U) {
        {
#line 899
        tmp___1 = __errno_location();
#line 899
        tmp___2 = strerror(*tmp___1);
#line 899
        lprintf(3, "Error seeking %s. %s\n", imageFilename, tmp___2);
        }
      }
      {
#line 900
      rc = (int )IME_ERROR___0;
#line 901
      fclose(pImageFile);
      }
#line 902
      return (rc);
    }
    {
#line 904
    tmp___3 = malloc(sizeof(unsigned char ) * (unsigned long )pImageCtx->size);
#line 904
    pImageCtx->pData = (uint8_t *)tmp___3;
#line 905
    rewind(pImageFile);
    }
#line 907
    if ((unsigned long )pImageCtx->pData != (unsigned long )((void *)0)) {
      {
#line 909
      tmp___4 = fread((void */* __restrict  */)pImageCtx->pData, sizeof(unsigned char ),
                      (size_t )pImageCtx->size, (FILE */* __restrict  */)pImageFile);
      }
#line 909
      if ((size_t )pImageCtx->size < tmp___4) {
#line 911
        rc = (int )IME_ERROR___0;
      }
    } else {
#line 915
      rc = (int )IME_ERROR___0;
    }
  }
#line 920
  if (rc == (int )IME_SUCCESS___0) {
    {
#line 922
    pImageCtx->crc8 = ImeCrc8___0(pImageCtx->size, pImageCtx->pData);
    }
  }
#line 926
  if ((unsigned long )pImageFile != (unsigned long )((void *)0)) {
    {
#line 928
    fclose(pImageFile);
    }
  }
#line 931
  return (rc);
}
}
#line 934 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static uint8_t ImeCrc8___0(uint32_t length , uint8_t *pBuf ) 
{ 
  uint8_t crc ;
  uint32_t bufCount ;
  uint8_t count ;

  {
#line 936
  crc = (uint8_t )0;
#line 939
  bufCount = (uint32_t )0;
  {
#line 939
  while (1) {
    while_continue: /* CIL Label */ ;
#line 939
    if (! (bufCount < length)) {
#line 939
      goto while_break;
    }
#line 943
    crc = (uint8_t )((int )crc ^ (int )*(pBuf + bufCount));
#line 945
    count = (uint8_t )0;
    {
#line 945
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 945
      if (! ((int )count < 8)) {
#line 945
        goto while_break___0;
      }
#line 947
      if (((int )crc & 128) != 0) {
#line 949
        crc = (uint8_t )((int )crc << 1);
#line 950
        crc = (uint8_t )((int )crc ^ 7);
      } else {
#line 954
        crc = (uint8_t )((int )crc << 1);
      }
#line 945
      count = (uint8_t )((int )count + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 939
    bufCount ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 959
  lprintf(7, "CRC8: %02xh\n", (int )crc);
  }
#line 960
  return (crc);
}
}
#line 964 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static int ImeManualRollback___0(struct ipmi_intf *intf ) 
{ 
  int rc ;
  tImeStatus imeStatus ;

  {
  {
#line 966
  rc = (int )IME_SUCCESS___0;
#line 971
  rc = ImeUpdateRegisterUpdate___0(intf, (tImeUpdateType )3);
#line 972
  ImeUpdateGetStatus___0(intf, & imeStatus);
  }
#line 975
  if (rc == (int )IME_SUCCESS___0) {
#line 975
    if ((unsigned int )imeStatus.update_state == 5U) {
      {
#line 980
      printf((char const   */* __restrict  */)"Manual Rollback Succeed\n");
      }
#line 981
      return ((int )IME_SUCCESS___0);
    } else {
      {
#line 985
      printf((char const   */* __restrict  */)"Manual Rollback Completed With Error\n");
      }
#line 986
      return ((int )IME_ERROR___0);
    }
  } else {
    {
#line 985
    printf((char const   */* __restrict  */)"Manual Rollback Completed With Error\n");
    }
#line 986
    return ((int )IME_ERROR___0);
  }
}
}
#line 992 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_ime.c"
static void ImePrintUsage___0(void) 
{ 


  {
  {
#line 994
  lprintf(5, "help                    - This help menu");
#line 995
  lprintf(5, "info                    - Information about the present Intel ME");
#line 996
  lprintf(5, "update <file>           - Upgrade the ME firmware from received image <file>");
#line 997
  lprintf(5, "rollback                - Manual Rollback ME");
  }
#line 999
  return;
}
}
#line 57 "/usr/include/x86_64-linux-gnu/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 58
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_pton)(int __af ,
                                                                                char const   * __restrict  __cp ,
                                                                                void * __restrict  __buf ) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_tsol.c"
static struct timeval _start_keepalive  ;
#line 71 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_tsol.c"
static struct termios _saved_tio___1  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_tsol.c"
static struct winsize _saved_winsize  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_tsol.c"
static int _in_raw_mode___1  =    0;
#line 74 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_tsol.c"
static int _altterm  =    0;
#line 78 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_tsol.c"
static int ipmi_tsol_command(struct ipmi_intf *intf , char *recvip , int port , unsigned char cmd ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char data[6] ;
  unsigned int ip1 ;
  unsigned int ip2 ;
  unsigned int ip3 ;
  unsigned int ip4 ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 86
  tmp = sscanf((char const   */* __restrict  */)recvip, (char const   */* __restrict  */)"%d.%d.%d.%d",
               & ip1, & ip2, & ip3, & ip4);
  }
#line 86
  if (tmp != 4) {
    {
#line 87
    lprintf(3, "Invalid IP address: %s", recvip);
    }
#line 88
    return (-1);
  }
  {
#line 91
  memset((void *)(& req), 0, sizeof(struct ipmi_rq ));
#line 92
  req.msg.netfn = (uint8_t )48;
#line 93
  req.msg.cmd = cmd;
#line 94
  req.msg.data_len = (uint16_t )6;
#line 95
  req.msg.data = data;
#line 97
  memset((void *)(data), 0, sizeof(data));
#line 98
  data[0] = (unsigned char )ip1;
#line 99
  data[1] = (unsigned char )ip2;
#line 100
  data[2] = (unsigned char )ip3;
#line 101
  data[3] = (unsigned char )ip4;
#line 102
  data[4] = (unsigned char )((port & 65280) >> 8);
#line 103
  data[5] = (unsigned char )(port & 255);
#line 105
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 106
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 107
    lprintf(3, "Unable to perform TSOL command");
    }
#line 108
    return (-1);
  }
#line 110
  if ((int )rsp->ccode > 0) {
    {
#line 111
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 111
    lprintf(3, "Unable to perform TSOL command: %s", tmp___0);
    }
#line 113
    return (-1);
  }
#line 116
  return (0);
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_tsol.c"
static int ipmi_tsol_start(struct ipmi_intf *intf , char *recvip , int port ) 
{ 
  int tmp ;

  {
  {
#line 122
  tmp = ipmi_tsol_command(intf, recvip, port, (unsigned char)6);
  }
#line 122
  return (tmp);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_tsol.c"
static int ipmi_tsol_stop(struct ipmi_intf *intf , char *recvip , int port ) 
{ 
  int tmp ;

  {
  {
#line 128
  tmp = ipmi_tsol_command(intf, recvip, port, (unsigned char)2);
  }
#line 128
  return (tmp);
}
}
#line 137
static int ipmi_tsol_send_keystroke(struct ipmi_intf *intf , char *buff , int length ) ;
#line 137 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_tsol.c"
static unsigned char keyseq  =    (unsigned char)0;
#line 131 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_tsol.c"
static int ipmi_tsol_send_keystroke(struct ipmi_intf *intf , char *buff , int length ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char data[16] ;
  unsigned char tmp ;
  char const   *tmp___0 ;

  {
  {
#line 139
  memset((void *)(& req), 0, sizeof(struct ipmi_rq ));
#line 140
  req.msg.netfn = (uint8_t )48;
#line 141
  req.msg.cmd = (uint8_t )3;
#line 142
  req.msg.data_len = (uint16_t )(length + 2);
#line 143
  req.msg.data = data;
#line 145
  memset((void *)(data), 0, sizeof(data));
#line 146
  data[0] = (unsigned char )(length + 1);
#line 147
  memcpy((void */* __restrict  */)(data + 1), (void const   */* __restrict  */)buff,
         (size_t )length);
#line 148
  tmp = keyseq;
#line 148
  keyseq = (unsigned char )((int )keyseq + 1);
#line 148
  data[length + 1] = tmp;
#line 150
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 151
  if (verbose) {
#line 152
    if ((unsigned long )rsp == (unsigned long )((void *)0)) {
      {
#line 153
      lprintf(3, "Unable to send keystroke");
      }
#line 154
      return (-1);
    }
#line 156
    if ((int )rsp->ccode > 0) {
      {
#line 157
      tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 157
      lprintf(3, "Unable to send keystroke: %s", tmp___0);
      }
#line 159
      return (-1);
    }
  }
#line 163
  return (length);
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_tsol.c"
static int tsol_keepalive(struct ipmi_intf *intf ) 
{ 
  struct timeval end ;

  {
  {
#line 171
  gettimeofday((struct timeval */* __restrict  */)(& end), (__timezone_ptr_t )0);
  }
#line 173
  if (end.tv_sec - _start_keepalive.tv_sec <= 30L) {
#line 174
    return (0);
  }
  {
#line 176
  (*(intf->keepalive))(intf);
#line 178
  gettimeofday((struct timeval */* __restrict  */)(& _start_keepalive), (__timezone_ptr_t )0);
  }
#line 180
  return (0);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_tsol.c"
static void print_escape_seq(struct ipmi_intf *intf ) 
{ 


  {
  {
#line 186
  lprintf(5, "       %c.  - terminate connection\n       %c^Z - suspend ipmitool\n       %c^X - suspend ipmitool, but don\'t restore tty on restart\n       %c?  - this message\n       %c%c  - send the escape character by typing it twice\n       (Note that escapes are only recognized immediately after newline.)",
          (int )(intf->session)->sol_escape_char, (int )(intf->session)->sol_escape_char,
          (int )(intf->session)->sol_escape_char, (int )(intf->session)->sol_escape_char,
          (int )(intf->session)->sol_escape_char, (int )(intf->session)->sol_escape_char);
  }
#line 199
  return;
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_tsol.c"
static int leave_raw_mode___1(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 204
  if (! _in_raw_mode___1) {
#line 205
    return (-1);
  } else {
    {
#line 206
    tmp___1 = fileno(stdin);
#line 206
    tmp___2 = tcsetattr(tmp___1, 1, (struct termios  const  *)(& _saved_tio___1));
    }
#line 206
    if (tmp___2 == -1) {
      {
#line 207
      lperror(3, "tcsetattr(stdin)");
      }
    } else {
      {
#line 208
      tmp = fileno(stdout);
#line 208
      tmp___0 = tcsetattr(tmp, 1, (struct termios  const  *)(& _saved_tio___1));
      }
#line 208
      if (tmp___0 == -1) {
        {
#line 209
        lperror(3, "tcsetattr(stdout)");
        }
      } else {
#line 211
        _in_raw_mode___1 = 0;
      }
    }
  }
#line 213
  return (0);
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_tsol.c"
static int enter_raw_mode___1(void) 
{ 
  struct termios tio ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 221
  tmp = fileno(stdout);
#line 221
  tmp___0 = tcgetattr(tmp, & _saved_tio___1);
  }
#line 221
  if (tmp___0 < 0) {
    {
#line 222
    lperror(3, "tcgetattr failed");
    }
#line 223
    return (-1);
  }
#line 226
  tio = _saved_tio___1;
#line 228
  if (_altterm) {
#line 229
    tio.c_iflag &= 33U;
#line 230
    tio.c_cflag &= 4294959823U;
#line 231
    tio.c_cflag |= 7344U;
#line 232
    tio.c_lflag = 0U;
#line 233
    tio.c_cc[6] = (cc_t )1;
#line 234
    tio.c_cc[5] = (cc_t )0;
  } else {
#line 236
    tio.c_iflag |= 4U;
#line 237
    tio.c_iflag &= 4294959647U;
#line 238
    tio.c_lflag &= 4294934404U;
#line 239
    tio.c_oflag &= 4294967294U;
#line 240
    tio.c_cc[6] = (cc_t )1;
#line 241
    tio.c_cc[5] = (cc_t )0;
  }
  {
#line 244
  tmp___3 = fileno(stdin);
#line 244
  tmp___4 = tcsetattr(tmp___3, 1, (struct termios  const  *)(& tio));
  }
#line 244
  if (tmp___4 < 0) {
    {
#line 245
    lperror(3, "tcsetattr(stdin)");
    }
  } else {
    {
#line 246
    tmp___1 = fileno(stdout);
#line 246
    tmp___2 = tcsetattr(tmp___1, 1, (struct termios  const  *)(& tio));
    }
#line 246
    if (tmp___2 < 0) {
      {
#line 247
      lperror(3, "tcsetattr(stdout)");
      }
    } else {
#line 249
      _in_raw_mode___1 = 1;
    }
  }
#line 251
  return (0);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_tsol.c"
static void suspend_self(int restore_tty ) 
{ 
  __pid_t tmp ;

  {
  {
#line 257
  leave_raw_mode___1();
#line 259
  tmp = getpid();
#line 259
  kill(tmp, 20);
  }
#line 261
  if (restore_tty) {
    {
#line 262
    enter_raw_mode___1();
    }
  }
#line 263
  return;
}
}
#line 268
static int do_inbuf_actions(struct ipmi_intf *intf , char *in_buff , int len ) ;
#line 268 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_tsol.c"
static int in_esc  =    0;
#line 269 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_tsol.c"
static int last_was_cr___1  =    1;
#line 265 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_tsol.c"
static int do_inbuf_actions(struct ipmi_intf *intf , char *in_buff , int len ) 
{ 
  int i ;
  int tmp ;

  {
#line 272
  i = 0;
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! (i < len)) {
#line 272
      goto while_break;
    }
#line 273
    if (! in_esc) {
#line 274
      if (last_was_cr___1) {
#line 274
        if ((int )*(in_buff + i) == (int )(intf->session)->sol_escape_char) {
          {
#line 276
          in_esc = 1;
#line 277
          memmove((void *)in_buff, (void const   *)(in_buff + 1), (size_t )((len - i) - 1));
#line 278
          len --;
          }
#line 279
          goto __Cont;
        }
      }
    }
#line 282
    if (in_esc) {
#line 283
      if ((int )*(in_buff + i) == (int )(intf->session)->sol_escape_char) {
#line 284
        in_esc = 0;
#line 285
        i ++;
#line 286
        goto __Cont;
      }
      {
#line 290
      if ((int )*(in_buff + i) == 46) {
#line 290
        goto case_46;
      }
#line 295
      if ((int )*(in_buff + i) == 26) {
#line 295
        goto case_26;
      }
#line 301
      if ((int )*(in_buff + i) == 24) {
#line 301
        goto case_24;
      }
#line 307
      if ((int )*(in_buff + i) == 63) {
#line 307
        goto case_63;
      }
#line 289
      goto switch_break;
      case_46: /* CIL Label */ 
      {
#line 291
      printf((char const   */* __restrict  */)"%c. [terminated ipmitool]\n", (int )(intf->session)->sol_escape_char);
      }
#line 293
      return (-1);
      case_26: /* CIL Label */ 
      {
#line 296
      printf((char const   */* __restrict  */)"%c^Z [suspend ipmitool]\n", (int )(intf->session)->sol_escape_char);
#line 298
      suspend_self(1);
      }
#line 299
      goto switch_break;
      case_24: /* CIL Label */ 
      {
#line 302
      printf((char const   */* __restrict  */)"%c^X [suspend ipmitool]\n", (int )(intf->session)->sol_escape_char);
#line 304
      suspend_self(0);
      }
#line 305
      goto switch_break;
      case_63: /* CIL Label */ 
      {
#line 308
      printf((char const   */* __restrict  */)"%c? [ipmitool help]\n", (int )(intf->session)->sol_escape_char);
#line 310
      print_escape_seq(intf);
      }
#line 311
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 314
      memmove((void *)in_buff, (void const   *)(in_buff + 1), (size_t )((len - i) - 1));
#line 315
      len --;
#line 316
      in_esc = 0;
      }
#line 318
      goto __Cont;
    }
#line 321
    if ((int )*(in_buff + i) == 13) {
#line 321
      tmp = 1;
    } else
#line 321
    if ((int )*(in_buff + i) == 10) {
#line 321
      tmp = 1;
    } else {
#line 321
      tmp = 0;
    }
#line 321
    last_was_cr___1 = tmp;
#line 323
    i ++;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  return (len);
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_tsol.c"
static void do_terminal_cleanup(void) 
{ 
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 333
  if ((int )_saved_winsize.ws_row > 0) {
#line 333
    if ((int )_saved_winsize.ws_col > 0) {
      {
#line 334
      tmp = fileno(stdout);
#line 334
      ioctl(tmp, 21524UL, & _saved_winsize);
      }
    }
  }
  {
#line 336
  leave_raw_mode___1();
#line 338
  tmp___3 = __errno_location();
  }
#line 338
  if (*tmp___3) {
    {
#line 339
    tmp___0 = __errno_location();
#line 339
    tmp___1 = strerror(*tmp___0);
#line 339
    tmp___2 = __errno_location();
#line 339
    lprintf(3, "Exiting due to error %d -> %s", *tmp___2, tmp___1);
    }
  }
#line 341
  return;
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_tsol.c"
static void set_terminal_size(int rows , int cols ) 
{ 
  struct winsize winsize ;
  int tmp ;
  int tmp___0 ;

  {
#line 348
  if (rows <= 0) {
#line 349
    return;
  } else
#line 348
  if (cols <= 0) {
#line 349
    return;
  }
  {
#line 352
  tmp = fileno(stdout);
#line 352
  ioctl(tmp, 21523UL, & _saved_winsize);
#line 355
  winsize.ws_row = (unsigned short )rows;
#line 356
  winsize.ws_col = (unsigned short )cols;
#line 357
  tmp___0 = fileno(stdout);
#line 357
  ioctl(tmp___0, 21524UL, & winsize);
  }
#line 358
  return;
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_tsol.c"
static void print_tsol_usage(void) 
{ 
  struct winsize winsize ;
  int tmp ;

  {
  {
#line 365
  lprintf(5, "Usage: tsol [recvip] [port=NUM] [ro|rw] [rows=NUM] [cols=NUM] [altterm]");
#line 366
  lprintf(5, "       recvip       Receiver IP Address             [default=local]");
#line 367
  lprintf(5, "       port=NUM     Receiver UDP Port               [default=%d]", 6230);
#line 369
  lprintf(5, "       ro|rw        Set Read-Only or Read-Write     [default=rw]");
#line 371
  tmp = fileno(stdout);
#line 371
  ioctl(tmp, 21523UL, & winsize);
#line 372
  lprintf(5, "       rows=NUM     Set terminal rows               [default=%d]", (int )winsize.ws_row);
#line 374
  lprintf(5, "       cols=NUM     Set terminal columns            [default=%d]", (int )winsize.ws_col);
#line 377
  lprintf(5, "       altterm      Alternate terminal setup        [default=off]");
  }
#line 378
  return;
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_tsol.c"
int ipmi_tsol_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  struct pollfd fds_wait[3] ;
  struct pollfd fds_data_wait[3] ;
  struct pollfd *fds ;
  struct sockaddr_in sin ;
  struct sockaddr_in myaddr ;
  socklen_t mylen ;
  char *recvip ;
  char out_buff[8192] ;
  char in_buff[1024] ;
  char buff[1028] ;
  int fd_socket ;
  int result ;
  int i ;
  int out_buff_fill ;
  int in_buff_fill ;
  int ip1 ;
  int ip2 ;
  int ip3 ;
  int ip4 ;
  int read_only ;
  int rows ;
  int cols ;
  int port ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  struct hostent *host ;
  struct hostent *tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  socklen_t sin_len ;
  ssize_t tmp___18 ;
  int length ;
  int tmp___19 ;
  ssize_t tmp___20 ;
  int bytes ;
  int tmp___21 ;
  ssize_t tmp___22 ;
  int tmp___23 ;

  {
  {
#line 386
  recvip = (char *)((void *)0);
#line 392
  read_only = 0;
#line 392
  rows = 0;
#line 392
  cols = 0;
#line 393
  port = 6230;
#line 395
  tmp = strlen((char const   *)(intf->name));
  }
#line 395
  if (tmp < 3UL) {
    {
#line 396
    lprintf(3, "Error: Tyan SOL is only available over lan interface");
    }
#line 397
    return (-1);
  } else {
    {
#line 395
    tmp___0 = strncmp((char const   *)(intf->name), "lan", (size_t )3);
    }
#line 395
    if (tmp___0 != 0) {
      {
#line 396
      lprintf(3, "Error: Tyan SOL is only available over lan interface");
      }
#line 397
      return (-1);
    }
  }
#line 400
  i = 0;
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! (i < argc)) {
#line 400
      goto while_break;
    }
    {
#line 401
    tmp___12 = sscanf((char const   */* __restrict  */)*(argv + i), (char const   */* __restrict  */)"%d.%d.%d.%d",
                      & ip1, & ip2, & ip3, & ip4);
    }
#line 401
    if (tmp___12 == 4) {
      {
#line 402
      recvip = strdup((char const   *)*(argv + i));
      }
    } else {
      {
#line 403
      tmp___11 = sscanf((char const   */* __restrict  */)*(argv + i), (char const   */* __restrict  */)"port=%d",
                        & ip1);
      }
#line 403
      if (tmp___11 == 1) {
#line 404
        port = ip1;
      } else {
        {
#line 405
        tmp___10 = sscanf((char const   */* __restrict  */)*(argv + i), (char const   */* __restrict  */)"rows=%d",
                          & ip1);
        }
#line 405
        if (tmp___10 == 1) {
#line 406
          rows = ip1;
        } else {
          {
#line 407
          tmp___9 = sscanf((char const   */* __restrict  */)*(argv + i), (char const   */* __restrict  */)"cols=%d",
                           & ip1);
          }
#line 407
          if (tmp___9 == 1) {
#line 408
            cols = ip1;
          } else {
            {
#line 409
            tmp___7 = strlen((char const   *)*(argv + i));
            }
#line 409
            if (tmp___7 == 2UL) {
              {
#line 409
              tmp___8 = strncmp((char const   *)*(argv + i), "ro", (size_t )2);
              }
#line 409
              if (tmp___8 == 0) {
#line 410
                read_only = 1;
              } else {
#line 409
                goto _L___1;
              }
            } else {
              _L___1: /* CIL Label */ 
              {
#line 411
              tmp___5 = strlen((char const   *)*(argv + i));
              }
#line 411
              if (tmp___5 == 2UL) {
                {
#line 411
                tmp___6 = strncmp((char const   *)*(argv + i), "rw", (size_t )2);
                }
#line 411
                if (tmp___6 == 0) {
#line 412
                  read_only = 0;
                } else {
#line 411
                  goto _L___0;
                }
              } else {
                _L___0: /* CIL Label */ 
                {
#line 413
                tmp___3 = strlen((char const   *)*(argv + i));
                }
#line 413
                if (tmp___3 == 7UL) {
                  {
#line 413
                  tmp___4 = strncmp((char const   *)*(argv + i), "altterm", (size_t )7);
                  }
#line 413
                  if (tmp___4 == 0) {
#line 414
                    _altterm = 1;
                  } else {
#line 413
                    goto _L;
                  }
                } else {
                  _L: /* CIL Label */ 
                  {
#line 415
                  tmp___1 = strlen((char const   *)*(argv + i));
                  }
#line 415
                  if (tmp___1 == 4UL) {
                    {
#line 415
                    tmp___2 = strncmp((char const   *)*(argv + i), "help", (size_t )4);
                    }
#line 415
                    if (tmp___2 == 0) {
                      {
#line 416
                      print_tsol_usage();
                      }
#line 417
                      return (0);
                    } else {
                      {
#line 420
                      print_tsol_usage();
                      }
#line 421
                      return (0);
                    }
                  } else {
                    {
#line 420
                    print_tsol_usage();
                    }
#line 421
                    return (0);
                  }
                }
              }
            }
          }
        }
      }
    }
#line 400
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 426
  memset((void *)(& sin), 0, sizeof(sin));
#line 427
  sin.sin_family = (sa_family_t )2;
#line 428
  sin.sin_port = htons((uint16_t )port);
#line 430
  result = inet_pton(2, (char const   */* __restrict  */)((char const   *)((intf->session)->hostname)),
                     (void */* __restrict  */)(& (intf->session)->addr.sin_addr));
  }
#line 433
  if (result <= 0) {
    {
#line 434
    tmp___13 = gethostbyname((char const   *)((intf->session)->hostname));
#line 434
    host = tmp___13;
    }
#line 435
    if ((unsigned long )host == (unsigned long )((void *)0)) {
      {
#line 436
      lprintf(3, "Address lookup for %s failed", (intf->session)->hostname);
      }
#line 438
      return (-1);
    }
#line 440
    if (host->h_addrtype != 2) {
#line 441
      if (host->h_addrtype == 10) {
#line 441
        tmp___14 = "IPv6";
      } else {
#line 441
        tmp___14 = "Unknown";
      }
      {
#line 441
      lprintf(3, "Address lookup for %s failed. Got %s, expected IPv4 address.", (intf->session)->hostname,
              tmp___14);
      }
#line 445
      return (-1);
    }
    {
#line 447
    (intf->session)->addr.sin_family = (sa_family_t )host->h_addrtype;
#line 448
    memcpy((void */* __restrict  */)(& (intf->session)->addr.sin_addr), (void const   */* __restrict  */)*(host->h_addr_list + 0),
           (size_t )host->h_length);
    }
  }
  {
#line 451
  fd_socket = socket(2, 2, 17);
  }
#line 452
  if (fd_socket < 0) {
    {
#line 453
    lprintf(3, "Can\'t open port %d", port);
    }
#line 454
    return (-1);
  }
  {
#line 456
  tmp___15 = bind(fd_socket, (struct sockaddr  const  *)((struct sockaddr *)(& sin)),
                  (socklen_t )sizeof(sin));
  }
#line 456
  if (-1 == tmp___15) {
    {
#line 457
    lprintf(3, "Failed to bind socket.");
    }
#line 458
    return (-1);
  }
#line 464
  if ((unsigned long )recvip == (unsigned long )((void *)0)) {
    {
#line 465
    result = (*(intf->open))(intf);
    }
#line 466
    if (result < 0) {
      {
#line 467
      close(fd_socket);
      }
#line 468
      return (-1);
    }
    {
#line 471
    mylen = (socklen_t )sizeof(myaddr);
#line 472
    tmp___16 = getsockname(intf->fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& myaddr)),
                           (socklen_t */* __restrict  */)(& mylen));
    }
#line 472
    if (tmp___16 < 0) {
      {
#line 473
      lperror(3, "getsockname failed");
#line 474
      close(fd_socket);
      }
#line 475
      return (-1);
    }
    {
#line 478
    recvip = inet_ntoa(myaddr.sin_addr);
    }
#line 479
    if ((unsigned long )recvip == (unsigned long )((void *)0)) {
      {
#line 480
      lprintf(3, "Unable to find local IP address");
#line 481
      close(fd_socket);
      }
#line 482
      return (-1);
    }
  }
#line 486
  if (read_only) {
#line 486
    tmp___17 = "Read-only ";
  } else {
#line 486
    tmp___17 = "";
  }
  {
#line 486
  printf((char const   */* __restrict  */)"[Starting %sSOL with receiving address %s:%d]\n",
         tmp___17, recvip, port);
#line 489
  set_terminal_size(rows, cols);
#line 490
  enter_raw_mode___1();
#line 496
  result = ipmi_tsol_start(intf, recvip, port);
  }
#line 497
  if (result < 0) {
    {
#line 498
    lprintf(3, "Error starting SOL");
#line 499
    close(fd_socket);
    }
#line 500
    return (-1);
  }
  {
#line 503
  printf((char const   */* __restrict  */)"[SOL Session operational.  Use %c? for help]\n",
         (int )(intf->session)->sol_escape_char);
#line 506
  gettimeofday((struct timeval */* __restrict  */)(& _start_keepalive), (__timezone_ptr_t )0);
#line 508
  fds_wait[0].fd = fd_socket;
#line 509
  fds_wait[0].events = (short)1;
#line 510
  fds_wait[0].revents = (short)0;
#line 511
  fds_wait[1].fd = fileno(stdin);
#line 512
  fds_wait[1].events = (short)1;
#line 513
  fds_wait[1].revents = (short)0;
#line 514
  fds_wait[2].fd = -1;
#line 515
  fds_wait[2].events = (short)0;
#line 516
  fds_wait[2].revents = (short)0;
#line 518
  fds_data_wait[0].fd = fd_socket;
#line 519
  fds_data_wait[0].events = (short)5;
#line 520
  fds_data_wait[0].revents = (short)0;
#line 521
  fds_data_wait[1].fd = fileno(stdin);
#line 522
  fds_data_wait[1].events = (short)1;
#line 523
  fds_data_wait[1].revents = (short)0;
#line 524
  fds_data_wait[2].fd = fileno(stdout);
#line 525
  fds_data_wait[2].events = (short)4;
#line 526
  fds_data_wait[2].revents = (short)0;
#line 528
  out_buff_fill = 0;
#line 529
  in_buff_fill = 0;
#line 530
  fds = fds_wait;
  }
  {
#line 532
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 533
    result = poll(fds, (nfds_t )3, 15000);
    }
#line 534
    if (result < 0) {
#line 535
      goto while_break___0;
    }
    {
#line 538
    tsol_keepalive(intf);
    }
#line 540
    if ((int )(fds + 0)->revents & 1) {
#line 540
      if (sizeof(out_buff) > (unsigned long )out_buff_fill) {
        {
#line 541
        sin_len = (socklen_t )sizeof(sin);
#line 542
        tmp___18 = recvfrom(fd_socket, (void */* __restrict  */)(buff), (sizeof(out_buff) - (unsigned long )out_buff_fill) + 4UL,
                            0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& sin)),
                            (socklen_t */* __restrict  */)(& sin_len));
#line 542
        result = (int )tmp___18;
        }
#line 546
        if (result - 4 > 0) {
#line 547
          length = result - 4;
#line 549
          length = (int )((unsigned char )buff[2]) & 255;
#line 550
          length *= 256;
#line 551
          length += (int )((unsigned char )buff[3]) & 255;
#line 552
          if (length <= 0) {
#line 553
            length = result - 4;
          } else
#line 552
          if (length > result - 4) {
#line 553
            length = result - 4;
          }
          {
#line 555
          memcpy((void */* __restrict  */)(out_buff + out_buff_fill), (void const   */* __restrict  */)(buff + 4),
                 (size_t )length);
#line 556
          out_buff_fill += length;
          }
        }
      }
    }
#line 559
    if ((int )(fds + 1)->revents & 1) {
#line 559
      if (sizeof(in_buff) > (unsigned long )in_buff_fill) {
        {
#line 560
        tmp___19 = fileno(stdin);
#line 560
        tmp___20 = read(tmp___19, (void *)(in_buff + in_buff_fill), sizeof(in_buff) - (unsigned long )in_buff_fill);
#line 560
        result = (int )tmp___20;
        }
#line 562
        if (result > 0) {
          {
#line 564
          bytes = do_inbuf_actions(intf, in_buff + in_buff_fill, result);
          }
#line 565
          if (bytes < 0) {
            {
#line 566
            result = ipmi_tsol_stop(intf, recvip, port);
#line 567
            do_terminal_cleanup();
            }
#line 568
            return (result);
          }
#line 570
          if (read_only) {
#line 571
            bytes = 0;
          }
#line 572
          in_buff_fill += bytes;
        }
      }
    }
#line 575
    if ((int )(fds + 2)->revents & 4) {
#line 575
      if (out_buff_fill) {
        {
#line 576
        tmp___21 = fileno(stdout);
#line 576
        tmp___22 = write(tmp___21, (void const   *)(out_buff), (size_t )out_buff_fill);
#line 576
        result = (int )tmp___22;
        }
#line 577
        if (result > 0) {
#line 578
          out_buff_fill -= result;
#line 579
          if (out_buff_fill) {
            {
#line 580
            memmove((void *)(out_buff), (void const   *)(out_buff + result), (size_t )out_buff_fill);
            }
          }
        }
      }
    }
#line 584
    if ((int )(fds + 0)->revents & 4) {
#line 584
      if (in_buff_fill) {
#line 589
        if (in_buff_fill < 14) {
#line 589
          tmp___23 = in_buff_fill;
        } else {
#line 589
          tmp___23 = 14;
        }
        {
#line 589
        result = ipmi_tsol_send_keystroke(intf, in_buff, tmp___23);
        }
#line 590
        if (result > 0) {
          {
#line 591
          gettimeofday((struct timeval */* __restrict  */)(& _start_keepalive), (__timezone_ptr_t )0);
#line 592
          in_buff_fill -= result;
          }
#line 593
          if (in_buff_fill) {
            {
#line 594
            memmove((void *)(in_buff), (void const   *)(in_buff + result), (size_t )in_buff_fill);
            }
          }
        }
      }
    }
#line 598
    if (in_buff_fill) {
#line 598
      fds = fds_data_wait;
    } else
#line 598
    if (out_buff_fill) {
#line 598
      fds = fds_data_wait;
    } else {
#line 598
      fds = fds_wait;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 602
  return (0);
}
}
#line 191 "../include/ipmitool/ipmi_fru.h"
static char const   *combined_voltage_desc___0[4]  __attribute__((__unused__))  = {      "12 V",      "-12 V",      "5 V",      "3.3 V"};
#line 587 "../include/ipmitool/ipmi_fru.h"
static unsigned long const   secs_from_1970_1996___2  =    (uint64_t const   )820454400;
#line 588 "../include/ipmitool/ipmi_fru.h"
static char const   *chassis_type_desc___0[30]  __attribute__((__unused__))  = 
#line 588
  {      "Unspecified",      "Other",      "Unknown",      "Desktop", 
        "Low Profile Desktop",      "Pizza Box",      "Mini Tower",      "Tower", 
        "Portable",      "LapTop",      "Notebook",      "Hand Held", 
        "Docking Station",      "All in One",      "Sub Notebook",      "Space-saving", 
        "Lunch Box",      "Main Server Chassis",      "Expansion Chassis",      "SubChassis", 
        "Bus Expansion Chassis",      "Peripheral Chassis",      "RAID Chassis",      "Rack Mount Chassis", 
        "Sealed-case PC",      "Multi-system Chassis",      "CompactPCI",      "AdvancedTCA", 
        "Blade",      "Blade Enclosure"};
#line 65 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static void ipmi_fru_read_to_bin___0(struct ipmi_intf *intf , char *pFileName , uint8_t fruId ) ;
#line 66
static void ipmi_fru_write_from_bin___0(struct ipmi_intf *intf , char *pFileName ,
                                        uint8_t fruId ) ;
#line 67
static int ipmi_fru_upg_ekeying___0(struct ipmi_intf *intf , char *pFileName , uint8_t fruId ) ;
#line 68
static int ipmi_fru_get_multirec_location_from_fru___0(struct ipmi_intf *intf , uint8_t fruId ,
                                                       struct fru_info *pFruInfo ,
                                                       uint32_t *pRetLocation , uint32_t *pRetSize ) ;
#line 71
static int ipmi_fru_get_multirec_from_file___0(char *pFileName , uint8_t *pBufArea ,
                                               uint32_t size , uint32_t offset ) ;
#line 73
static int ipmi_fru_get_multirec_size_from_file___0(char *pFileName , uint32_t *pSize ,
                                                    uint32_t *pOffset ) ;
#line 75
static void ipmi_fru_picmg_ext_print___0(uint8_t *fru_data , int off , int length ) ;
#line 77
static int ipmi_fru_set_field_string___0(struct ipmi_intf *intf , unsigned char fruId ,
                                         uint8_t f_type , uint8_t f_index , char *f_string ) ;
#line 79
static int ipmi_fru_set_field_string_rebuild___0(struct ipmi_intf *intf , uint8_t fruId ,
                                                 struct fru_info fru , struct fru_header header ,
                                                 uint8_t f_type , uint8_t f_index ,
                                                 char *f_string ) ;
#line 100 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static char const   bcd_plus___0[17]  = 
#line 100
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )' ',      (char const   )'-', 
        (char const   )'.',      (char const   )':',      (char const   )',',      (char const   )'_', 
        (char const   )'\000'};
#line 521 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static uint16_t fru_data_rqst_size___2  =    (uint16_t )32;
#line 752 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static uint32_t fru_data_rqst_size___3  =    (uint32_t )20;
#line 857 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static uint32_t fru_data_rqst_size___4  =    (uint32_t )20;
#line 1007 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static void fru_area_print_chassis___0(struct ipmi_intf *intf , struct fru_info *fru ,
                                       uint8_t id , uint32_t offset ) 
{ 
  char *fru_area ;
  uint8_t *fru_data ;
  uint32_t fru_len ;
  uint32_t area_len ;
  uint32_t i ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int j ;
  size_t tmp___6 ;

  {
  {
#line 1012
  fru_data = (uint8_t *)((void *)0);
#line 1015
  i = offset;
#line 1016
  fru_len = (uint32_t )0;
#line 1018
  tmp = malloc((size_t )((int )fru->size + 1));
#line 1018
  fru_data = (uint8_t *)tmp;
  }
#line 1019
  if ((unsigned long )fru_data == (unsigned long )((void *)0)) {
    {
#line 1020
    lprintf(3, " Out of memory!");
    }
#line 1021
    return;
  }
  {
#line 1023
  memset((void *)fru_data, 0, (size_t )((int )fru->size + 1));
#line 1026
  tmp___0 = read_fru_area(intf, fru, id, i, (uint32_t )2, fru_data);
  }
#line 1026
  if (tmp___0 == 0) {
#line 1027
    fru_len = (uint32_t )(8 * (int )*(fru_data + (i + 1U)));
  }
#line 1028
  if (fru_len <= 0U) {
    {
#line 1029
    free((void *)fru_data);
#line 1030
    fru_data = (uint8_t *)((void *)0);
    }
#line 1031
    return;
  }
  {
#line 1035
  tmp___1 = read_fru_area(intf, fru, id, i, fru_len, fru_data);
  }
#line 1035
  if (tmp___1 < 0) {
    {
#line 1036
    free((void *)fru_data);
#line 1037
    fru_data = (uint8_t *)((void *)0);
    }
#line 1038
    return;
  }
  {
#line 1041
  i ++;
#line 1042
  tmp___2 = i;
#line 1042
  i ++;
#line 1042
  area_len = (uint32_t )((int )*(fru_data + tmp___2) * 8);
#line 1044
  tmp___3 = i;
#line 1044
  i ++;
#line 1044
  printf((char const   */* __restrict  */)" Chassis Type          : %s\n", chassis_type_desc___0[*(fru_data + tmp___3)]);
#line 1047
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1048
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1049
    tmp___4 = strlen((char const   *)fru_area);
    }
#line 1049
    if (tmp___4 > 0UL) {
      {
#line 1050
      printf((char const   */* __restrict  */)" Chassis Part Number   : %s\n", fru_area);
      }
    }
    {
#line 1052
    free((void *)fru_area);
#line 1053
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1056
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1057
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1058
    tmp___5 = strlen((char const   *)fru_area);
    }
#line 1058
    if (tmp___5 > 0UL) {
      {
#line 1059
      printf((char const   */* __restrict  */)" Chassis Serial        : %s\n", fru_area);
      }
    }
    {
#line 1061
    free((void *)fru_area);
#line 1062
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1066
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1066
    if ((int )*(fru_data + i) != 193) {
#line 1066
      if (! (i < offset + area_len)) {
#line 1066
        goto while_break;
      }
    } else {
#line 1066
      goto while_break;
    }
    {
#line 1068
    j = (int )i;
#line 1069
    fru_area = get_fru_area_str(fru_data, & i);
    }
#line 1070
    if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
      {
#line 1071
      tmp___6 = strlen((char const   *)fru_area);
      }
#line 1071
      if (tmp___6 > 0UL) {
        {
#line 1072
        printf((char const   */* __restrict  */)" Chassis Extra         : %s\n", fru_area);
        }
      }
      {
#line 1074
      free((void *)fru_area);
#line 1075
      fru_area = (char *)((void *)0);
      }
    }
#line 1077
    if (i == (uint32_t )j) {
#line 1078
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1081
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1082
    free((void *)fru_data);
#line 1083
    fru_data = (uint8_t *)((void *)0);
    }
  }
#line 1085
  return;
}
}
#line 1094 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static void fru_area_print_board___0(struct ipmi_intf *intf , struct fru_info *fru ,
                                     uint8_t id , uint32_t offset ) 
{ 
  char *fru_area ;
  uint8_t *fru_data ;
  uint32_t fru_len ;
  uint32_t area_len ;
  uint32_t i ;
  time_t tval ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  uint32_t tmp___2 ;
  struct tm *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int j ;
  size_t tmp___10 ;

  {
  {
#line 1099
  fru_data = (uint8_t *)((void *)0);
#line 1103
  i = offset;
#line 1104
  fru_len = (uint32_t )0;
#line 1106
  tmp = malloc((size_t )((int )fru->size + 1));
#line 1106
  fru_data = (uint8_t *)tmp;
  }
#line 1107
  if ((unsigned long )fru_data == (unsigned long )((void *)0)) {
    {
#line 1108
    lprintf(3, " Out of memory!");
    }
#line 1109
    return;
  }
  {
#line 1111
  memset((void *)fru_data, 0, (size_t )((int )fru->size + 1));
#line 1114
  tmp___0 = read_fru_area(intf, fru, id, i, (uint32_t )2, fru_data);
  }
#line 1114
  if (tmp___0 == 0) {
#line 1115
    fru_len = (uint32_t )(8 * (int )*(fru_data + (i + 1U)));
  }
#line 1116
  if (fru_len <= 0U) {
    {
#line 1117
    free((void *)fru_data);
#line 1118
    fru_data = (uint8_t *)((void *)0);
    }
#line 1119
    return;
  }
  {
#line 1123
  tmp___1 = read_fru_area(intf, fru, id, i, fru_len, fru_data);
  }
#line 1123
  if (tmp___1 < 0) {
    {
#line 1124
    free((void *)fru_data);
#line 1125
    fru_data = (uint8_t *)((void *)0);
    }
#line 1126
    return;
  }
  {
#line 1129
  i ++;
#line 1130
  tmp___2 = i;
#line 1130
  i ++;
#line 1130
  area_len = (uint32_t )((int )*(fru_data + tmp___2) * 8);
#line 1131
  i ++;
#line 1132
  tval = (time_t )((((int )*(fru_data + (i + 2U)) << 16) + ((int )*(fru_data + (i + 1U)) << 8)) + (int )*(fru_data + i));
#line 1133
  tval *= 60L;
#line 1134
  tval = (time_t )((unsigned long const   )tval + secs_from_1970_1996___2);
#line 1135
  tmp___3 = localtime((time_t const   *)(& tval));
#line 1135
  tmp___4 = asctime((struct tm  const  *)tmp___3);
#line 1135
  printf((char const   */* __restrict  */)" Board Mfg Date        : %s", tmp___4);
#line 1136
  i += 3U;
#line 1138
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1139
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1140
    tmp___5 = strlen((char const   *)fru_area);
    }
#line 1140
    if (tmp___5 > 0UL) {
      {
#line 1141
      printf((char const   */* __restrict  */)" Board Mfg             : %s\n", fru_area);
      }
    }
    {
#line 1143
    free((void *)fru_area);
#line 1144
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1147
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1148
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1149
    tmp___6 = strlen((char const   *)fru_area);
    }
#line 1149
    if (tmp___6 > 0UL) {
      {
#line 1150
      printf((char const   */* __restrict  */)" Board Product         : %s\n", fru_area);
      }
    }
    {
#line 1152
    free((void *)fru_area);
#line 1153
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1156
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1157
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1158
    tmp___7 = strlen((char const   *)fru_area);
    }
#line 1158
    if (tmp___7 > 0UL) {
      {
#line 1159
      printf((char const   */* __restrict  */)" Board Serial          : %s\n", fru_area);
      }
    }
    {
#line 1161
    free((void *)fru_area);
#line 1162
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1165
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1166
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1167
    tmp___8 = strlen((char const   *)fru_area);
    }
#line 1167
    if (tmp___8 > 0UL) {
      {
#line 1168
      printf((char const   */* __restrict  */)" Board Part Number     : %s\n", fru_area);
      }
    }
    {
#line 1170
    free((void *)fru_area);
#line 1171
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1174
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1175
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1176
    tmp___9 = strlen((char const   *)fru_area);
    }
#line 1176
    if (tmp___9 > 0UL) {
#line 1176
      if (verbose > 0) {
        {
#line 1177
        printf((char const   */* __restrict  */)" Board FRU ID          : %s\n", fru_area);
        }
      }
    }
    {
#line 1179
    free((void *)fru_area);
#line 1180
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1184
    if ((int )*(fru_data + i) != 193) {
#line 1184
      if (! (i < offset + area_len)) {
#line 1184
        goto while_break;
      }
    } else {
#line 1184
      goto while_break;
    }
    {
#line 1186
    j = (int )i;
#line 1187
    fru_area = get_fru_area_str(fru_data, & i);
    }
#line 1188
    if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
      {
#line 1189
      tmp___10 = strlen((char const   *)fru_area);
      }
#line 1189
      if (tmp___10 > 0UL) {
        {
#line 1190
        printf((char const   */* __restrict  */)" Board Extra           : %s\n", fru_area);
        }
      }
      {
#line 1192
      free((void *)fru_area);
#line 1193
      fru_area = (char *)((void *)0);
      }
    }
#line 1195
    if (i == (uint32_t )j) {
#line 1196
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1199
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1200
    free((void *)fru_data);
#line 1201
    fru_data = (uint8_t *)((void *)0);
    }
  }
#line 1203
  return;
}
}
#line 1212 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static void fru_area_print_product___0(struct ipmi_intf *intf , struct fru_info *fru ,
                                       uint8_t id , uint32_t offset ) 
{ 
  char *fru_area ;
  uint8_t *fru_data ;
  uint32_t fru_len ;
  uint32_t area_len ;
  uint32_t i ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  uint32_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int j ;
  size_t tmp___10 ;

  {
  {
#line 1216
  fru_area = (char *)((void *)0);
#line 1217
  fru_data = (uint8_t *)((void *)0);
#line 1220
  i = offset;
#line 1221
  fru_len = (uint32_t )0;
#line 1223
  tmp = malloc((size_t )((int )fru->size + 1));
#line 1223
  fru_data = (uint8_t *)tmp;
  }
#line 1224
  if ((unsigned long )fru_data == (unsigned long )((void *)0)) {
    {
#line 1225
    lprintf(3, " Out of memory!");
    }
#line 1226
    return;
  }
  {
#line 1228
  memset((void *)fru_data, 0, (size_t )((int )fru->size + 1));
#line 1231
  tmp___0 = read_fru_area(intf, fru, id, i, (uint32_t )2, fru_data);
  }
#line 1231
  if (tmp___0 == 0) {
#line 1232
    fru_len = (uint32_t )(8 * (int )*(fru_data + (i + 1U)));
  }
#line 1233
  if (fru_len <= 0U) {
    {
#line 1234
    free((void *)fru_data);
#line 1235
    fru_data = (uint8_t *)((void *)0);
    }
#line 1236
    return;
  }
  {
#line 1240
  tmp___1 = read_fru_area(intf, fru, id, i, fru_len, fru_data);
  }
#line 1240
  if (tmp___1 < 0) {
    {
#line 1241
    free((void *)fru_data);
#line 1242
    fru_data = (uint8_t *)((void *)0);
    }
#line 1243
    return;
  }
  {
#line 1246
  i ++;
#line 1247
  tmp___2 = i;
#line 1247
  i ++;
#line 1247
  area_len = (uint32_t )((int )*(fru_data + tmp___2) * 8);
#line 1248
  i ++;
#line 1250
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1251
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1252
    tmp___3 = strlen((char const   *)fru_area);
    }
#line 1252
    if (tmp___3 > 0UL) {
      {
#line 1253
      printf((char const   */* __restrict  */)" Product Manufacturer  : %s\n", fru_area);
      }
    }
    {
#line 1255
    free((void *)fru_area);
#line 1256
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1259
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1260
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1261
    tmp___4 = strlen((char const   *)fru_area);
    }
#line 1261
    if (tmp___4 > 0UL) {
      {
#line 1262
      printf((char const   */* __restrict  */)" Product Name          : %s\n", fru_area);
      }
    }
    {
#line 1264
    free((void *)fru_area);
#line 1265
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1268
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1269
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1270
    tmp___5 = strlen((char const   *)fru_area);
    }
#line 1270
    if (tmp___5 > 0UL) {
      {
#line 1271
      printf((char const   */* __restrict  */)" Product Part Number   : %s\n", fru_area);
      }
    }
    {
#line 1273
    free((void *)fru_area);
#line 1274
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1277
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1278
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1279
    tmp___6 = strlen((char const   *)fru_area);
    }
#line 1279
    if (tmp___6 > 0UL) {
      {
#line 1280
      printf((char const   */* __restrict  */)" Product Version       : %s\n", fru_area);
      }
    }
    {
#line 1282
    free((void *)fru_area);
#line 1283
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1286
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1287
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1288
    tmp___7 = strlen((char const   *)fru_area);
    }
#line 1288
    if (tmp___7 > 0UL) {
      {
#line 1289
      printf((char const   */* __restrict  */)" Product Serial        : %s\n", fru_area);
      }
    }
    {
#line 1291
    free((void *)fru_area);
#line 1292
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1295
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1296
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1297
    tmp___8 = strlen((char const   *)fru_area);
    }
#line 1297
    if (tmp___8 > 0UL) {
      {
#line 1298
      printf((char const   */* __restrict  */)" Product Asset Tag     : %s\n", fru_area);
      }
    }
    {
#line 1300
    free((void *)fru_area);
#line 1301
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1304
  fru_area = get_fru_area_str(fru_data, & i);
  }
#line 1305
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1306
    tmp___9 = strlen((char const   *)fru_area);
    }
#line 1306
    if (tmp___9 > 0UL) {
#line 1306
      if (verbose > 0) {
        {
#line 1307
        printf((char const   */* __restrict  */)" Product FRU ID        : %s\n", fru_area);
        }
      }
    }
    {
#line 1309
    free((void *)fru_area);
#line 1310
    fru_area = (char *)((void *)0);
    }
  }
  {
#line 1314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1314
    if ((int )*(fru_data + i) != 193) {
#line 1314
      if (! (i < offset + area_len)) {
#line 1314
        goto while_break;
      }
    } else {
#line 1314
      goto while_break;
    }
    {
#line 1316
    j = (int )i;
#line 1317
    fru_area = get_fru_area_str(fru_data, & i);
    }
#line 1318
    if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
      {
#line 1319
      tmp___10 = strlen((char const   *)fru_area);
      }
#line 1319
      if (tmp___10 > 0UL) {
        {
#line 1320
        printf((char const   */* __restrict  */)" Product Extra         : %s\n", fru_area);
        }
      }
      {
#line 1322
      free((void *)fru_area);
#line 1323
      fru_area = (char *)((void *)0);
      }
    }
#line 1325
    if (i == (uint32_t )j) {
#line 1326
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1329
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 1330
    free((void *)fru_data);
#line 1331
    fru_data = (uint8_t *)((void *)0);
    }
  }
#line 1333
  return;
}
}
#line 1342 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static void fru_area_print_multirec___0(struct ipmi_intf *intf , struct fru_info *fru ,
                                        uint8_t id , uint32_t offset ) 
{ 
  uint8_t *fru_data ;
  uint32_t fru_len ;
  uint32_t i ;
  struct fru_multirec_header *h ;
  struct fru_multirec_powersupply *ps ;
  struct fru_multirec_dcoutput *dc ;
  struct fru_multirec_dcload *dl ;
  uint16_t peak_capacity ;
  uint8_t peak_hold_up_time ;
  uint32_t last_off ;
  uint32_t len ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  struct fru_multirec_oem_header *oh ;
  uint32_t iana ;
  char const   *tmp___10 ;

  {
  {
#line 1356
  last_off = offset;
#line 1356
  i = last_off;
#line 1357
  fru_len = (uint32_t )0;
#line 1359
  tmp = malloc((size_t )((int )fru->size + 1));
#line 1359
  fru_data = (uint8_t *)tmp;
  }
#line 1360
  if ((unsigned long )fru_data == (unsigned long )((void *)0)) {
    {
#line 1361
    lprintf(3, " Out of memory!");
    }
#line 1362
    return;
  }
  {
#line 1364
  memset((void *)fru_data, 0, (size_t )((int )fru->size + 1));
  }
  {
#line 1366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1367
    h = (struct fru_multirec_header *)(fru_data + i);
#line 1370
    if ((unsigned long )last_off < (unsigned long )i + sizeof(*h)) {
#line 1370
      goto _L;
    } else
#line 1370
    if (last_off < i + (uint32_t )h->len) {
      _L: /* CIL Label */ 
#line 1372
      len = (uint32_t )fru->size - last_off;
#line 1373
      if ((unsigned long )len > 255UL + sizeof(struct fru_multirec_header )) {
#line 1374
        len = (uint32_t )(255UL + sizeof(struct fru_multirec_header ));
      }
      {
#line 1376
      tmp___0 = read_fru_area(intf, fru, id, last_off, len, fru_data);
      }
#line 1376
      if (tmp___0 < 0) {
#line 1377
        goto while_break;
      }
#line 1379
      last_off += len;
    }
    {
#line 1384
    if ((int )h->type == 0) {
#line 1384
      goto case_0;
    }
#line 1442
    if ((int )h->type == 1) {
#line 1442
      goto case_1;
    }
#line 1474
    if ((int )h->type == 2) {
#line 1474
      goto case_2;
    }
#line 1503
    if ((int )h->type == 192) {
#line 1503
      goto case_192;
    }
#line 1382
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 1385
    ps = (struct fru_multirec_powersupply *)((fru_data + i) + sizeof(struct fru_multirec_header ));
#line 1398
    peak_hold_up_time = (uint8_t )(((int )ps->peak_cap_ht & 61440) >> 12);
#line 1399
    peak_capacity = (uint16_t )((int )ps->peak_cap_ht & 4095);
#line 1401
    printf((char const   */* __restrict  */)" Power Supply Record\n");
#line 1402
    printf((char const   */* __restrict  */)"  Capacity                   : %d W\n",
           (int )ps->capacity);
#line 1404
    printf((char const   */* __restrict  */)"  Peak VA                    : %d VA\n",
           (int )ps->peak_va);
#line 1406
    printf((char const   */* __restrict  */)"  Inrush Current             : %d A\n",
           (int )ps->inrush_current);
#line 1408
    printf((char const   */* __restrict  */)"  Inrush Interval            : %d ms\n",
           (int )ps->inrush_interval);
#line 1410
    printf((char const   */* __restrict  */)"  Input Voltage Range 1      : %d-%d V\n",
           (int )ps->lowend_input1 / 100, (int )ps->highend_input1 / 100);
#line 1412
    printf((char const   */* __restrict  */)"  Input Voltage Range 2      : %d-%d V\n",
           (int )ps->lowend_input2 / 100, (int )ps->highend_input2 / 100);
#line 1414
    printf((char const   */* __restrict  */)"  Input Frequency Range      : %d-%d Hz\n",
           (int )ps->lowend_freq, (int )ps->highend_freq);
#line 1416
    printf((char const   */* __restrict  */)"  A/C Dropout Tolerance      : %d ms\n",
           (int )ps->dropout_tolerance);
    }
#line 1418
    if (ps->predictive_fail) {
#line 1418
      if (ps->rps_threshold) {
#line 1418
        if (ps->tach) {
#line 1418
          tmp___1 = "\'Two pulses per rotation\'";
        } else {
#line 1418
          tmp___1 = "\'One pulse per rotation\'";
        }
#line 1418
        tmp___3 = tmp___1;
      } else {
#line 1418
        if (ps->tach) {
#line 1418
          tmp___2 = "\'Failure on pin de-assertion\'";
        } else {
#line 1418
          tmp___2 = "\'Failure on pin assertion\'";
        }
#line 1418
        tmp___3 = tmp___2;
      }
#line 1418
      tmp___4 = tmp___3;
    } else {
#line 1418
      tmp___4 = "";
    }
#line 1418
    if (ps->hotswap) {
#line 1418
      tmp___5 = "\'Hot swap\' ";
    } else {
#line 1418
      tmp___5 = "";
    }
#line 1418
    if (ps->autoswitch) {
#line 1418
      tmp___6 = "\'Autoswitch voltage\' ";
    } else {
#line 1418
      tmp___6 = "";
    }
#line 1418
    if (ps->pfc) {
#line 1418
      tmp___7 = "\'Power factor correction\' ";
    } else {
#line 1418
      tmp___7 = "";
    }
#line 1418
    if (ps->predictive_fail) {
#line 1418
      tmp___8 = "\'Predictive fail\' ";
    } else {
#line 1418
      tmp___8 = "";
    }
    {
#line 1418
    printf((char const   */* __restrict  */)"  Flags                      : %s%s%s%s%s\n",
           tmp___8, tmp___7, tmp___6, tmp___5, tmp___4);
#line 1426
    printf((char const   */* __restrict  */)"  Peak capacity              : %d W\n",
           (int )peak_capacity);
#line 1428
    printf((char const   */* __restrict  */)"  Peak capacity holdup       : %d s\n",
           (int )peak_hold_up_time);
    }
#line 1430
    if ((int )ps->combined_capacity == 0) {
      {
#line 1431
      printf((char const   */* __restrict  */)"  Combined capacity          : not specified\n");
      }
    } else {
      {
#line 1433
      printf((char const   */* __restrict  */)"  Combined capacity          : %d W (%s and %s)\n",
             (int )ps->combined_capacity, combined_voltage_desc___0[ps->combined_voltage1],
             combined_voltage_desc___0[ps->combined_voltage2]);
      }
    }
#line 1437
    if (ps->predictive_fail) {
      {
#line 1438
      printf((char const   */* __restrict  */)"  Fan lower threshold        : %d RPS\n",
             (int )ps->rps_threshold);
      }
    }
#line 1440
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1443
    dc = (struct fru_multirec_dcoutput *)((fru_data + i) + sizeof(struct fru_multirec_header ));
#line 1455
    printf((char const   */* __restrict  */)" DC Output Record\n");
#line 1456
    printf((char const   */* __restrict  */)"  Output Number              : %d\n",
           (int )dc->output_number);
    }
#line 1458
    if (dc->standby) {
#line 1458
      tmp___9 = "Yes";
    } else {
#line 1458
      tmp___9 = "No";
    }
    {
#line 1458
    printf((char const   */* __restrict  */)"  Standby power              : %s\n",
           tmp___9);
#line 1460
    printf((char const   */* __restrict  */)"  Nominal voltage            : %.2f V\n",
           (double )dc->nominal_voltage / (double )100);
#line 1462
    printf((char const   */* __restrict  */)"  Max negative deviation     : %.2f V\n",
           (double )dc->max_neg_dev / (double )100);
#line 1464
    printf((char const   */* __restrict  */)"  Max positive deviation     : %.2f V\n",
           (double )dc->max_pos_dev / (double )100);
#line 1466
    printf((char const   */* __restrict  */)"  Ripple and noise pk-pk     : %d mV\n",
           (int )dc->ripple_and_noise);
#line 1468
    printf((char const   */* __restrict  */)"  Minimum current draw       : %.3f A\n",
           (double )dc->min_current / (double )1000);
#line 1470
    printf((char const   */* __restrict  */)"  Maximum current draw       : %.3f A\n",
           (double )dc->max_current / (double )1000);
    }
#line 1472
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1475
    dl = (struct fru_multirec_dcload *)((fru_data + i) + sizeof(struct fru_multirec_header ));
#line 1487
    printf((char const   */* __restrict  */)" DC Load Record\n");
#line 1488
    printf((char const   */* __restrict  */)"  Output Number              : %d\n",
           (int )dl->output_number);
#line 1490
    printf((char const   */* __restrict  */)"  Nominal voltage            : %.2f V\n",
           (double )dl->nominal_voltage / (double )100);
#line 1492
    printf((char const   */* __restrict  */)"  Min voltage allowed        : %.2f V\n",
           (double )dl->min_voltage / (double )100);
#line 1494
    printf((char const   */* __restrict  */)"  Max voltage allowed        : %.2f V\n",
           (double )dl->max_voltage / (double )100);
#line 1496
    printf((char const   */* __restrict  */)"  Ripple and noise pk-pk     : %d mV\n",
           (int )dl->ripple_and_noise);
#line 1498
    printf((char const   */* __restrict  */)"  Minimum current load       : %.3f A\n",
           (double )dl->min_current / (double )1000);
#line 1500
    printf((char const   */* __restrict  */)"  Maximum current load       : %.3f A\n",
           (double )dl->max_current / (double )1000);
    }
#line 1502
    goto switch_break;
    case_192: /* CIL Label */ 
#line 1505
    oh = (struct fru_multirec_oem_header *)(fru_data + ((unsigned long )i + sizeof(struct fru_multirec_header )));
#line 1507
    iana = (uint32_t )(((int )oh->mfg_id[0] | ((int )oh->mfg_id[1] << 8)) | ((int )oh->mfg_id[2] << 16));
#line 1511
    if (iana == 12634U) {
      {
#line 1512
      printf((char const   */* __restrict  */)"  PICMG Extension Record\n");
#line 1513
      ipmi_fru_picmg_ext_print___0(fru_data, (int )((unsigned long )i + sizeof(struct fru_multirec_header )),
                                   (int )h->len);
      }
    } else {
      {
#line 1519
      tmp___10 = val2str((uint16_t )iana, ipmi_oem_info);
#line 1519
      printf((char const   */* __restrict  */)"  OEM (%s) Record\n", tmp___10);
      }
    }
#line 1522
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1524
    i = (uint32_t )((unsigned long )i + ((unsigned long )h->len + sizeof(struct fru_multirec_header )));
#line 1366
    if (! (! ((int )h->format & 128))) {
#line 1366
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1527
  lprintf(7, "Multi-Record area ends at: %i (%xh)", i, i);
#line 1529
  free((void *)fru_data);
#line 1530
  fru_data = (uint8_t *)((void *)0);
  }
#line 1531
  return;
}
}
#line 1679
static void ipmi_fru_oemkontron_get___0(int argc , char **argv , uint8_t *fru_data ,
                                        int off , int len , struct fru_multirec_header *h ,
                                        struct fru_multirec_oem_header *oh ) ;
#line 1679 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int badParams___1  =    0;
#line 1674 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static void ipmi_fru_oemkontron_get___0(int argc , char **argv , uint8_t *fru_data ,
                                        int off , int len , struct fru_multirec_header *h ,
                                        struct fru_multirec_oem_header *oh ) 
{ 
  int start ;
  int offset ;
  int length ;
  int tmp ;
  uint8_t version ;
  int blockstart ;
  uint8_t blockCount ;
  uint8_t blockIndex ;
  unsigned int matchInstance ;
  uint8_t instance ;
  int tmp___0 ;
  int tmp___1 ;
  void *pRecordData ;
  uint8_t nameLen ;
  int tmp___2 ;
  uint8_t tmp___3 ;

  {
#line 1680
  start = off;
#line 1681
  offset = start;
#line 1682
  length = len;
#line 1684
  offset = (int )((unsigned long )offset + sizeof(struct fru_multirec_oem_header ));
#line 1686
  if (! badParams___1) {
#line 1688
    if (argc > 2) {
      {
#line 1689
      tmp = strncmp("oem", (char const   *)*(argv + 2), (size_t )3);
      }
#line 1689
      if (tmp) {
        {
#line 1690
        printf((char const   */* __restrict  */)"usage: fru get <id> <oem>\n");
#line 1691
        badParams___1 = 1;
        }
#line 1692
        return;
      }
    }
#line 1695
    if (argc < 5) {
      {
#line 1696
      printf((char const   */* __restrict  */)"usage: oem <iana> <recordid>\n");
#line 1697
      printf((char const   */* __restrict  */)"usage: oem 15000 3\n");
#line 1698
      badParams___1 = 1;
      }
#line 1699
      return;
    }
  }
#line 1703
  if (! badParams___1) {
#line 1705
    if ((int )oh->record_id == 3) {
      {
#line 1709
      printf((char const   */* __restrict  */)"Kontron OEM Information Record\n");
#line 1710
      version = oh->record_version;
#line 1714
      blockIndex = (uint8_t )0;
#line 1716
      matchInstance = 0U;
#line 1717
      instance = (uint8_t )0;
#line 1719
      tmp___0 = str2uchar((char const   *)*(argv + 7), & instance);
      }
#line 1719
      if (tmp___0 != 0) {
        {
#line 1720
        lprintf(3, "Instance argument \'%s\' is either invalid or out of range.",
                *(argv + 7));
#line 1723
        badParams___1 = 1;
        }
#line 1724
        return;
      }
#line 1727
      tmp___1 = offset;
#line 1727
      offset ++;
#line 1727
      blockCount = *(fru_data + tmp___1);
#line 1729
      blockIndex = (uint8_t )0;
      {
#line 1729
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1729
        if (! ((int )blockIndex < (int )blockCount)) {
#line 1729
          goto while_break;
        }
        {
#line 1733
        blockstart = offset;
#line 1734
        tmp___2 = offset;
#line 1734
        offset ++;
#line 1734
        tmp___3 = (uint8_t )((int )*(fru_data + tmp___2) & 63);
#line 1734
        *(fru_data + tmp___2) = tmp___3;
#line 1734
        nameLen = tmp___3;
#line 1735
        printf((char const   */* __restrict  */)"  Name: %*.*s\n", (int )nameLen,
               (int )nameLen, (char const   *)(fru_data + offset));
#line 1737
        offset += (int )nameLen;
#line 1739
        pRecordData = (void *)(fru_data + offset);
#line 1741
        printf((char const   */* __restrict  */)"  Record Version: %d\n", (int )version);
        }
#line 1742
        if ((int )version == 0) {
          {
#line 1744
          printf((char const   */* __restrict  */)"  Version: %*.*s\n", 8, 8, ((tOemKontronInformationRecordV0 *)pRecordData)->field1);
#line 1748
          printf((char const   */* __restrict  */)"  Build Date: %*.*s\n", 8, 8, ((tOemKontronInformationRecordV0 *)pRecordData)->field2);
#line 1752
          printf((char const   */* __restrict  */)"  Update Date: %*.*s\n", 8, 8,
                 ((tOemKontronInformationRecordV0 *)pRecordData)->field3);
#line 1756
          printf((char const   */* __restrict  */)"  Checksum: %*.*s\n\n", 8, 8, ((tOemKontronInformationRecordV0 *)pRecordData)->crc32);
#line 1760
          matchInstance ++;
#line 1761
          offset = (int )((unsigned long )offset + sizeof(tOemKontronInformationRecordV0 ));
#line 1762
          offset ++;
          }
        } else
#line 1764
        if ((int )version == 1) {
          {
#line 1766
          printf((char const   */* __restrict  */)"  Version: %*.*s\n", 10, 10, ((tOemKontronInformationRecordV1 *)pRecordData)->field1);
#line 1770
          printf((char const   */* __restrict  */)"  Build Date: %*.*s\n", 8, 8, ((tOemKontronInformationRecordV1 *)pRecordData)->field2);
#line 1774
          printf((char const   */* __restrict  */)"  Update Date: %*.*s\n", 8, 8,
                 ((tOemKontronInformationRecordV1 *)pRecordData)->field3);
#line 1778
          printf((char const   */* __restrict  */)"  Checksum: %*.*s\n\n", 8, 8, ((tOemKontronInformationRecordV1 *)pRecordData)->crc32);
#line 1782
          matchInstance ++;
#line 1783
          offset = (int )((unsigned long )offset + sizeof(tOemKontronInformationRecordV1 ));
#line 1784
          offset ++;
          }
        } else {
          {
#line 1788
          printf((char const   */* __restrict  */)"  Unsupported version %d\n", (int )version);
          }
        }
#line 1729
        blockIndex = (uint8_t )((int )blockIndex + 1);
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1793
  return;
}
}
#line 1800
static int ipmi_fru_oemkontron_edit___0(int argc , char **argv , uint8_t *fru_data ,
                                        int off , int len , struct fru_multirec_header *h ,
                                        struct fru_multirec_oem_header *oh ) ;
#line 1800 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int badParams___2  =    0;
#line 1795 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_oemkontron_edit___0(int argc , char **argv , uint8_t *fru_data ,
                                        int off , int len , struct fru_multirec_header *h ,
                                        struct fru_multirec_oem_header *oh ) 
{ 
  int hasChanged ;
  int start ;
  int offset ;
  int length ;
  int i ;
  uint8_t record_id ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  uint8_t formatVersion ;
  uint8_t version ;
  int tmp___3 ;
  int blockstart ;
  uint8_t blockCount ;
  uint8_t blockIndex ;
  uint8_t matchInstance ;
  uint8_t instance ;
  int tmp___4 ;
  int tmp___5 ;
  void *pRecordData ;
  uint8_t nameLen ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  uint8_t record_checksum ;
  uint8_t header_checksum ;
  int index___0 ;
  uint8_t data ;

  {
#line 1801
  hasChanged = 0;
#line 1802
  start = off;
#line 1803
  offset = start;
#line 1804
  length = len;
#line 1806
  record_id = (uint8_t )0;
#line 1807
  offset = (int )((unsigned long )offset + sizeof(struct fru_multirec_oem_header ));
#line 1809
  if (! badParams___2) {
#line 1811
    if (argc > 2) {
      {
#line 1812
      tmp = strncmp("oem", (char const   *)*(argv + 2), (size_t )3);
      }
#line 1812
      if (tmp) {
        {
#line 1813
        printf((char const   */* __restrict  */)"usage: fru edit <id> <oem> <args...>\n");
#line 1814
        badParams___2 = 1;
        }
#line 1815
        return (hasChanged);
      }
    }
#line 1818
    if (argc < 12) {
      {
#line 1819
      printf((char const   */* __restrict  */)"usage: oem <iana> <recordid> <format> <args...>\n");
#line 1820
      printf((char const   */* __restrict  */)"usage: oem 15000 3 0 <name> <instance> <field1> <field2> <field3> <crc32>\n");
#line 1822
      badParams___2 = 1;
      }
#line 1823
      return (hasChanged);
    }
    {
#line 1825
    tmp___0 = str2uchar((char const   *)*(argv + 4), & record_id);
    }
#line 1825
    if (tmp___0 != 0) {
      {
#line 1826
      lprintf(3, "Record ID argument \'%s\' is either invalid or out of range.", *(argv + 4));
#line 1829
      badParams___2 = 1;
      }
#line 1830
      return (hasChanged);
    }
#line 1832
    if ((int )record_id == 3) {
#line 1833
      i = 8;
      {
#line 1833
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1833
        if (! (i <= 11)) {
#line 1833
          goto while_break;
        }
        {
#line 1834
        tmp___1 = strlen((char const   *)*(argv + i));
        }
#line 1834
        if (tmp___1 != 8UL) {
          {
#line 1834
          tmp___2 = strlen((char const   *)*(argv + i));
          }
#line 1834
          if (tmp___2 != 10UL) {
            {
#line 1836
            printf((char const   */* __restrict  */)"error: version fields must have %d characters\n",
                   8);
#line 1838
            badParams___2 = 1;
            }
#line 1839
            return (hasChanged);
          }
        }
#line 1833
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1845
  if (! badParams___2) {
#line 1847
    if ((int )oh->record_id == 3) {
      {
#line 1848
      formatVersion = (uint8_t )0;
#line 1851
      tmp___3 = str2uchar((char const   *)*(argv + 5), & formatVersion);
      }
#line 1851
      if (tmp___3 != 0) {
        {
#line 1852
        lprintf(3, "Format argument \'%s\' is either invalid or out of range.", *(argv + 5));
#line 1855
        badParams___2 = 1;
        }
#line 1856
        return (hasChanged);
      }
      {
#line 1859
      printf((char const   */* __restrict  */)"   Kontron OEM Information Record\n");
#line 1860
      version = oh->record_version;
      }
#line 1862
      if ((int )version == (int )formatVersion) {
        {
#line 1865
        blockIndex = (uint8_t )0;
#line 1867
        matchInstance = (uint8_t )0;
#line 1868
        instance = (uint8_t )0;
#line 1870
        tmp___4 = str2uchar((char const   *)*(argv + 7), & instance);
        }
#line 1870
        if (tmp___4 != 0) {
          {
#line 1871
          lprintf(3, "Instance argument \'%s\' is either invalid or out of range.",
                  *(argv + 7));
#line 1874
          badParams___2 = 1;
          }
#line 1875
          return (hasChanged);
        }
        {
#line 1878
        tmp___5 = offset;
#line 1878
        offset ++;
#line 1878
        blockCount = *(fru_data + tmp___5);
#line 1879
        printf((char const   */* __restrict  */)"   blockCount: %d\n", (int )blockCount);
#line 1881
        blockIndex = (uint8_t )0;
        }
        {
#line 1881
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1881
          if (! ((int )blockIndex < (int )blockCount)) {
#line 1881
            goto while_break___0;
          }
#line 1885
          blockstart = offset;
#line 1887
          tmp___6 = offset;
#line 1887
          offset ++;
#line 1887
          nameLen = (uint8_t )((int )*(fru_data + tmp___6) & 63);
#line 1889
          if ((int )version == 0) {
#line 1889
            goto _L___0;
          } else
#line 1889
          if ((int )version == 1) {
            _L___0: /* CIL Label */ 
            {
#line 1891
            tmp___8 = strncmp((char const   *)*(argv + 6), (char const   *)(fru_data + offset),
                              (size_t )nameLen);
            }
#line 1891
            if (tmp___8) {
              _L: /* CIL Label */ 
              {
#line 1941
              tmp___7 = strncmp((char const   *)*(argv + 6), (char const   *)(fru_data + offset),
                                (size_t )nameLen);
              }
#line 1941
              if (tmp___7) {
#line 1949
                offset += (int )nameLen;
              } else {
                {
#line 1943
                printf((char const   */* __restrict  */)"Skipped : %s  [instance %d]\n",
                       *(argv + 6), (unsigned int )matchInstance);
#line 1945
                matchInstance = (uint8_t )((int )matchInstance + 1);
#line 1946
                offset += (int )nameLen;
                }
              }
            } else
#line 1891
            if ((int )matchInstance == (int )instance) {
              {
#line 1894
              printf((char const   */* __restrict  */)"Found : %s\n", *(argv + 6));
#line 1895
              offset += (int )nameLen;
#line 1897
              pRecordData = (void *)(fru_data + offset);
              }
#line 1899
              if ((int )version == 0) {
                {
#line 1901
                memcpy((void */* __restrict  */)(((tOemKontronInformationRecordV0 *)pRecordData)->field1),
                       (void const   */* __restrict  */)*(argv + 8), (size_t )8);
#line 1905
                memcpy((void */* __restrict  */)(((tOemKontronInformationRecordV0 *)pRecordData)->field2),
                       (void const   */* __restrict  */)*(argv + 9), (size_t )8);
#line 1909
                memcpy((void */* __restrict  */)(((tOemKontronInformationRecordV0 *)pRecordData)->field3),
                       (void const   */* __restrict  */)*(argv + 10), (size_t )8);
#line 1913
                memcpy((void */* __restrict  */)(((tOemKontronInformationRecordV0 *)pRecordData)->crc32),
                       (void const   */* __restrict  */)*(argv + 11), (size_t )8);
                }
              } else {
                {
#line 1920
                memcpy((void */* __restrict  */)(((tOemKontronInformationRecordV1 *)pRecordData)->field1),
                       (void const   */* __restrict  */)*(argv + 8), (size_t )10);
#line 1924
                memcpy((void */* __restrict  */)(((tOemKontronInformationRecordV1 *)pRecordData)->field2),
                       (void const   */* __restrict  */)*(argv + 9), (size_t )8);
#line 1928
                memcpy((void */* __restrict  */)(((tOemKontronInformationRecordV1 *)pRecordData)->field3),
                       (void const   */* __restrict  */)*(argv + 10), (size_t )8);
#line 1932
                memcpy((void */* __restrict  */)(((tOemKontronInformationRecordV1 *)pRecordData)->crc32),
                       (void const   */* __restrict  */)*(argv + 11), (size_t )8);
                }
              }
#line 1938
              matchInstance = (uint8_t )((int )matchInstance + 1);
#line 1939
              hasChanged = 1;
            } else {
#line 1891
              goto _L;
            }
#line 1952
            if ((int )version == 0) {
#line 1954
              offset = (int )((unsigned long )offset + sizeof(tOemKontronInformationRecordV0 ));
            } else {
#line 1958
              offset = (int )((unsigned long )offset + sizeof(tOemKontronInformationRecordV1 ));
            }
#line 1960
            offset ++;
          } else {
            {
#line 1964
            printf((char const   */* __restrict  */)"  Unsupported version %d\n",
                   (int )version);
            }
          }
#line 1881
          blockIndex = (uint8_t )((int )blockIndex + 1);
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 1969
        printf((char const   */* __restrict  */)"   Version: %d\n", (int )version);
        }
      }
    }
#line 1972
    if (hasChanged) {
      {
#line 1974
      record_checksum = (uint8_t )0;
#line 1975
      header_checksum = (uint8_t )0;
#line 1978
      lprintf(7, "Initial record checksum : %x", (int )h->record_checksum);
#line 1979
      lprintf(7, "Initial header checksum : %x", (int )h->header_checksum);
#line 1980
      index___0 = 0;
      }
      {
#line 1980
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1980
        if (! (index___0 < length)) {
#line 1980
          goto while_break___1;
        }
#line 1981
        record_checksum = (uint8_t )((int )record_checksum + (int )*(fru_data + (start + index___0)));
#line 1980
        index___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1984
      h->record_checksum = (uint8_t )(~ ((int )record_checksum) + 1);
#line 1987
      index___0 = 0;
      {
#line 1987
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1987
        if (! ((unsigned long )index___0 < sizeof(struct fru_multirec_header ) - 1UL)) {
#line 1987
          goto while_break___2;
        }
#line 1988
        data = *((uint8_t *)h + index___0);
#line 1989
        header_checksum = (uint8_t )((int )header_checksum + (int )data);
#line 1987
        index___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1992
      h->header_checksum = (uint8_t )(~ ((int )header_checksum) + 1);
#line 1994
      lprintf(7, "Final record checksum : %x", (int )h->record_checksum);
#line 1995
      lprintf(7, "Final header checksum : %x", (int )h->header_checksum);
      }
    }
  }
#line 2001
  return (hasChanged);
}
}
#line 2015 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_picmg_ext_edit___0(uint8_t *fru_data , int off , int len , struct fru_multirec_header *h ,
                                       struct fru_multirec_oem_header *oh ) 
{ 
  int hasChanged ;
  int start ;
  int offset ;
  int length ;
  int index___0 ;
  uint16_t max_current ;
  int tmp ;
  struct fru_picmgext_activation_record *a ;
  int index___1 ;
  unsigned char current ;
  int tmp___0 ;
  uint8_t record_checksum ;
  uint8_t header_checksum ;
  int index___2 ;
  uint8_t data ;

  {
#line 2020
  hasChanged = 0;
#line 2021
  start = off;
#line 2022
  offset = start;
#line 2023
  length = len;
#line 2024
  offset = (int )((unsigned long )offset + sizeof(struct fru_multirec_oem_header ));
  {
#line 2028
  if ((int )oh->record_id == 23) {
#line 2028
    goto case_23;
  }
#line 2067
  if ((int )oh->record_id == 22) {
#line 2067
    goto case_22;
  }
#line 2026
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 2029
  printf((char const   */* __restrict  */)"    FRU_AMC_ACTIVATION\n");
#line 2031
  index___0 = offset;
#line 2034
  max_current = (uint16_t )*(fru_data + offset);
#line 2035
  offset ++;
#line 2035
  max_current = (uint16_t )((int )max_current | ((int )*(fru_data + offset) << 8));
#line 2037
  printf((char const   */* __restrict  */)"      Maximum Internal Current(@12V): %.2f A (0x%02x)\n",
         (double )((float )max_current / 10.0f), (int )max_current);
#line 2040
  tmp = ipmi_fru_query_new_value(fru_data, index___0, (size_t )2);
  }
#line 2040
  if (tmp) {
    {
#line 2041
    max_current = (uint16_t )*(fru_data + index___0);
#line 2042
    index___0 ++;
#line 2042
    max_current = (uint16_t )((int )max_current | ((int )*(fru_data + index___0) << 8));
#line 2043
    printf((char const   */* __restrict  */)"      New Maximum Internal Current(@12V): %.2f A (0x%02x)\n",
           (double )((float )max_current / 10.0f), (int )max_current);
#line 2045
    hasChanged = 1;
    }
  }
  {
#line 2049
  offset ++;
#line 2049
  printf((char const   */* __restrict  */)"      Module Activation Readiness:       %i sec.\n",
         (int )*(fru_data + offset));
#line 2050
  offset ++;
#line 2050
  printf((char const   */* __restrict  */)"      Descriptor Count: %i\n", (int )*(fru_data + offset));
#line 2051
  printf((char const   */* __restrict  */)"\n");
#line 2053
  offset ++;
  }
  {
#line 2053
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2053
    if (! (offset < off + length)) {
#line 2053
      goto while_break;
    }
    {
#line 2056
    a = (struct fru_picmgext_activation_record *)(fru_data + offset);
#line 2059
    printf((char const   */* __restrict  */)"        IPMB-Address:         0x%x\n",
           (int )a->ibmb_addr);
#line 2060
    printf((char const   */* __restrict  */)"        Max. Module Current:  %.2f A\n",
           (double )((float )a->max_module_curr / 10.0f));
#line 2062
    printf((char const   */* __restrict  */)"\n");
#line 2053
    offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_activation_record ));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2065
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 2068
  printf((char const   */* __restrict  */)"    FRU_AMC_CURRENT\n");
#line 2070
  index___1 = offset;
#line 2073
  current = *(fru_data + index___1);
#line 2075
  printf((char const   */* __restrict  */)"      Current draw(@12V): %.2f A (0x%02x)\n",
         (double )((float )current / 10.0f), (int )current);
#line 2078
  tmp___0 = ipmi_fru_query_new_value(fru_data, index___1, (size_t )1);
  }
#line 2078
  if (tmp___0) {
    {
#line 2079
    current = *(fru_data + index___1);
#line 2081
    printf((char const   */* __restrict  */)"      New Current draw(@12V): %.2f A (0x%02x)\n",
           (double )((float )current / 10.0f), (int )current);
#line 2083
    hasChanged = 1;
    }
  }
#line 2086
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2089
  if (hasChanged) {
    {
#line 2091
    record_checksum = (uint8_t )0;
#line 2092
    header_checksum = (uint8_t )0;
#line 2095
    lprintf(7, "Initial record checksum : %x", (int )h->record_checksum);
#line 2096
    lprintf(7, "Initial header checksum : %x", (int )h->header_checksum);
#line 2097
    index___2 = 0;
    }
    {
#line 2097
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2097
      if (! (index___2 < length)) {
#line 2097
        goto while_break___0;
      }
#line 2098
      record_checksum = (uint8_t )((int )record_checksum + (int )*(fru_data + (start + index___2)));
#line 2097
      index___2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2101
    h->record_checksum = (uint8_t )(~ ((int )record_checksum) + 1);
#line 2104
    index___2 = 0;
    {
#line 2104
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2104
      if (! ((unsigned long )index___2 < sizeof(struct fru_multirec_header ) - 1UL)) {
#line 2104
        goto while_break___1;
      }
#line 2105
      data = *((uint8_t *)h + index___2);
#line 2106
      header_checksum = (uint8_t )((int )header_checksum + (int )data);
#line 2104
      index___2 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2109
    h->header_checksum = (uint8_t )(~ ((int )header_checksum) + 1);
#line 2111
    lprintf(7, "Final record checksum : %x", (int )h->record_checksum);
#line 2112
    lprintf(7, "Final header checksum : %x", (int )h->header_checksum);
    }
  }
#line 2117
  return (hasChanged);
}
}
#line 2128 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static void ipmi_fru_picmg_ext_print___0(uint8_t *fru_data , int off , int length ) 
{ 
  struct fru_multirec_oem_header *h ;
  int guid_count ;
  int offset ;
  int start_offset ;
  int i ;
  uint8_t index___0 ;
  unsigned int data ;
  struct fru_picmgext_slot_desc *slot_d ;
  struct fru_picmgext_chn_desc *d ;
  unsigned int hwaddr ;
  unsigned int sitetype ;
  unsigned int sitenum ;
  unsigned int entries ;
  unsigned int i___0 ;
  char *picmg_site_type_strings[10] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  unsigned int entries___0 ;
  unsigned int feeds ;
  unsigned int hwaddr___0 ;
  unsigned int i___1 ;
  unsigned int id ;
  unsigned int j ;
  unsigned int maxext ;
  unsigned int maxint ;
  unsigned int minexp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int i___2 ;
  unsigned int count ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int j___0 ;
  struct fru_picmgext_link_desc *d___0 ;
  unsigned int data___0 ;
  unsigned char current ;
  uint16_t max_current ;
  struct fru_picmgext_activation_record *a ;
  uint16_t index___1 ;
  struct fru_picmgext_carrier_p2p_record *h___0 ;
  unsigned char data___1[3] ;
  struct fru_picmgext_carrier_p2p_descriptor *desc ;
  unsigned int index___2 ;
  unsigned char channel_count ;
  struct fru_picmgext_amc_p2p_record *h___1 ;
  int j___1 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  unsigned int data___2 ;
  struct fru_picmgext_amc_channel_desc_record *d___1 ;
  unsigned int data___3[2] ;
  struct fru_picmgext_amc_link_desc_record *l ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  unsigned char extVersion ;
  unsigned char siteCount ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  unsigned char desc_count ;
  int i___3 ;
  int j___2 ;
  int tmp___21 ;
  unsigned char resource_id ;
  unsigned char channel_count___0 ;
  int tmp___22 ;
  int tmp___23 ;
  unsigned char loc_channel ;
  unsigned char rem_channel ;
  unsigned char rem_resource ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  unsigned char resource_id___0 ;
  unsigned char descr_count ;
  int i___4 ;
  int j___3 ;
  int tmp___27 ;
  int tmp___28 ;
  unsigned char channel_id ;
  unsigned char control ;
  unsigned char indirect_cnt ;
  unsigned char direct_cnt ;
  int tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  unsigned char feature ;
  unsigned char dep_chn_id ;
  int tmp___34 ;
  int tmp___35 ;
  char const   *tmp___36 ;
  unsigned char feature___0 ;
  unsigned char family ;
  unsigned char accuracy ;
  unsigned int freq ;
  unsigned int min_freq ;
  unsigned int max_freq ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  char const   *tmp___40 ;

  {
#line 2132
  offset = off;
#line 2133
  start_offset = off;
#line 2136
  h = (struct fru_multirec_oem_header *)(fru_data + offset);
#line 2137
  offset = (int )((unsigned long )offset + sizeof(struct fru_multirec_oem_header ));
  {
#line 2141
  if ((int )h->record_id == 4) {
#line 2141
    goto case_4;
  }
#line 2214
  if ((int )h->record_id == 16) {
#line 2214
    goto case_16;
  }
#line 2261
  if ((int )h->record_id == 17) {
#line 2261
    goto case_17;
  }
#line 2329
  if ((int )h->record_id == 18) {
#line 2329
    goto case_18;
  }
#line 2359
  if ((int )h->record_id == 19) {
#line 2359
    goto case_19;
  }
#line 2363
  if ((int )h->record_id == 20) {
#line 2363
    goto case_20;
  }
#line 2500
  if ((int )h->record_id == 22) {
#line 2500
    goto case_22;
  }
#line 2513
  if ((int )h->record_id == 23) {
#line 2513
    goto case_23;
  }
#line 2542
  if ((int )h->record_id == 24) {
#line 2542
    goto case_24;
  }
#line 2590
  if ((int )h->record_id == 25) {
#line 2590
    goto case_25;
  }
#line 2782
  if ((int )h->record_id == 26) {
#line 2782
    goto case_26;
  }
#line 2803
  if ((int )h->record_id == 44) {
#line 2803
    goto case_44;
  }
#line 2846
  if ((int )h->record_id == 45) {
#line 2846
    goto case_45;
  }
#line 2932
  if ((int )h->record_id == 43) {
#line 2932
    goto case_43;
  }
#line 2932
  if ((int )h->record_id == 42) {
#line 2932
    goto case_43;
  }
#line 2932
  if ((int )h->record_id == 41) {
#line 2932
    goto case_43;
  }
#line 2932
  if ((int )h->record_id == 40) {
#line 2932
    goto case_43;
  }
#line 2932
  if ((int )h->record_id == 39) {
#line 2932
    goto case_43;
  }
#line 2932
  if ((int )h->record_id == 38) {
#line 2932
    goto case_43;
  }
#line 2932
  if ((int )h->record_id == 37) {
#line 2932
    goto case_43;
  }
#line 2932
  if ((int )h->record_id == 36) {
#line 2932
    goto case_43;
  }
#line 2932
  if ((int )h->record_id == 35) {
#line 2932
    goto case_43;
  }
#line 2932
  if ((int )h->record_id == 34) {
#line 2932
    goto case_43;
  }
#line 2932
  if ((int )h->record_id == 33) {
#line 2932
    goto case_43;
  }
#line 2932
  if ((int )h->record_id == 32) {
#line 2932
    goto case_43;
  }
#line 2937
  goto switch_default___8;
  case_4: /* CIL Label */ 
  {
#line 2147
  slot_d = (struct fru_picmgext_slot_desc *)(fru_data + offset);
#line 2149
  offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_slot_desc ));
#line 2150
  printf((char const   */* __restrict  */)"    FRU_PICMG_BACKPLANE_P2P\n");
  }
  {
#line 2152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2152
    if (! (offset <= start_offset + length)) {
#line 2152
      goto while_break;
    }
    {
#line 2153
    printf((char const   */* __restrict  */)"\n");
#line 2154
    printf((char const   */* __restrict  */)"    Channel Type:  ");
    }
    {
#line 2158
    if ((int )slot_d->chan_type == 7) {
#line 2158
      goto case_7;
    }
#line 2158
    if ((int )slot_d->chan_type == 0) {
#line 2158
      goto case_7;
    }
#line 2161
    if ((int )slot_d->chan_type == 8) {
#line 2161
      goto case_8;
    }
#line 2164
    if ((int )slot_d->chan_type == 9) {
#line 2164
      goto case_9;
    }
#line 2167
    if ((int )slot_d->chan_type == 10) {
#line 2167
      goto case_10;
    }
#line 2170
    if ((int )slot_d->chan_type == 11) {
#line 2170
      goto case_11;
    }
#line 2173
    if ((int )slot_d->chan_type == 12) {
#line 2173
      goto case_12;
    }
#line 2176
    if ((int )slot_d->chan_type == 13) {
#line 2176
      goto case_13;
    }
#line 2179
    goto switch_default;
    case_7: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 2159
    printf((char const   */* __restrict  */)"PICMG 2.9\n");
    }
#line 2160
    goto switch_break___0;
    case_8: /* CIL Label */ 
    {
#line 2162
    printf((char const   */* __restrict  */)"Single Port Fabric IF\n");
    }
#line 2163
    goto switch_break___0;
    case_9: /* CIL Label */ 
    {
#line 2165
    printf((char const   */* __restrict  */)"Double Port Fabric IF\n");
    }
#line 2166
    goto switch_break___0;
    case_10: /* CIL Label */ 
    {
#line 2168
    printf((char const   */* __restrict  */)"Full Channel Fabric IF\n");
    }
#line 2169
    goto switch_break___0;
    case_11: /* CIL Label */ 
    {
#line 2171
    printf((char const   */* __restrict  */)"Base IF\n");
    }
#line 2172
    goto switch_break___0;
    case_12: /* CIL Label */ 
    {
#line 2174
    printf((char const   */* __restrict  */)"Update Channel IF\n");
    }
#line 2175
    goto switch_break___0;
    case_13: /* CIL Label */ 
    {
#line 2177
    printf((char const   */* __restrict  */)"ShMC Cross Connect\n");
    }
#line 2178
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 2180
    printf((char const   */* __restrict  */)"Unknown IF (0x%x)\n", (int )slot_d->chan_type);
    }
#line 2182
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 2184
    printf((char const   */* __restrict  */)"    Slot Addr.   : %02x\n", (int )slot_d->slot_addr);
#line 2186
    printf((char const   */* __restrict  */)"    Channel Count: %i\n", (int )slot_d->chn_count);
#line 2189
    index___0 = (uint8_t )0;
    }
    {
#line 2189
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2189
      if (! ((int )index___0 < (int )slot_d->chn_count)) {
#line 2189
        goto while_break___0;
      }
#line 2193
      data = (unsigned int )(((int )*(fru_data + offset) | ((int )*(fru_data + (offset + 1)) << 8)) | ((int )*(fru_data + (offset + 2)) << 16));
#line 2196
      d = (struct fru_picmgext_chn_desc *)(& data);
#line 2197
      if (verbose) {
        {
#line 2198
        printf((char const   */* __restrict  */)"       Chn: %02x  ->  Chn: %02x in Slot: %02x\n",
               d->local_chn, d->remote_chn, d->remote_slot);
        }
      }
#line 2206
      offset += 3;
#line 2189
      index___0 = (uint8_t )((int )index___0 + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2208
    slot_d = (struct fru_picmgext_slot_desc *)(fru_data + offset);
#line 2209
    offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_slot_desc ));
  }
  while_break: /* CIL Label */ ;
  }
#line 2212
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 2221
  picmg_site_type_strings[0] = (char *)"AdvancedTCA Board";
#line 2221
  picmg_site_type_strings[1] = (char *)"Power Entry";
#line 2221
  picmg_site_type_strings[2] = (char *)"Shelf FRU Information";
#line 2221
  picmg_site_type_strings[3] = (char *)"Dedicated ShMC";
#line 2221
  picmg_site_type_strings[4] = (char *)"Fan Tray";
#line 2221
  picmg_site_type_strings[5] = (char *)"Fan Filter Tray";
#line 2221
  picmg_site_type_strings[6] = (char *)"Alarm";
#line 2221
  picmg_site_type_strings[7] = (char *)"AdvancedMC Module";
#line 2221
  picmg_site_type_strings[8] = (char *)"PMC";
#line 2221
  picmg_site_type_strings[9] = (char *)"Rear Transition Module";
#line 2234
  printf((char const   */* __restrict  */)"    FRU_PICMG_ADDRESS_TABLE\n");
#line 2235
  tmp = offset;
#line 2235
  offset ++;
#line 2235
  printf((char const   */* __restrict  */)"      Type/Len:  0x%02x\n", (int )*(fru_data + tmp));
#line 2236
  printf((char const   */* __restrict  */)"      Shelf Addr: ");
#line 2237
  i___0 = 0U;
  }
  {
#line 2237
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2237
    if (! (i___0 < 20U)) {
#line 2237
      goto while_break___1;
    }
    {
#line 2238
    tmp___0 = offset;
#line 2238
    offset ++;
#line 2238
    printf((char const   */* __restrict  */)"0x%02x ", (int )*(fru_data + tmp___0));
#line 2237
    i___0 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2240
  printf((char const   */* __restrict  */)"\n");
#line 2242
  tmp___1 = offset;
#line 2242
  offset ++;
#line 2242
  entries = (unsigned int )*(fru_data + tmp___1);
#line 2243
  printf((char const   */* __restrict  */)"      Addr Table Entries: 0x%02x\n", entries);
#line 2245
  i___0 = 0U;
  }
  {
#line 2245
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2245
    if (! (i___0 < entries)) {
#line 2245
      goto while_break___2;
    }
#line 2246
    hwaddr = (unsigned int )*(fru_data + offset);
#line 2247
    sitenum = (unsigned int )*(fru_data + (offset + 1));
#line 2248
    sitetype = (unsigned int )*(fru_data + (offset + 2));
#line 2249
    if (sitetype < 10U) {
#line 2249
      tmp___2 = (char const   *)picmg_site_type_strings[sitetype];
    } else {
#line 2249
      tmp___2 = "Reserved";
    }
    {
#line 2249
    printf((char const   */* __restrict  */)"        HWAddr: 0x%02x (0x%02x) SiteNum: %d SiteType: 0x%02x %s\n",
           hwaddr, hwaddr * 2U, sitenum, sitetype, tmp___2);
#line 2256
    offset += 3;
#line 2245
    i___0 ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2259
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 2274
  printf((char const   */* __restrict  */)"    FRU_PICMG_SHELF_POWER_DIST\n");
#line 2276
  tmp___3 = offset;
#line 2276
  offset ++;
#line 2276
  feeds = (unsigned int )*(fru_data + tmp___3);
#line 2277
  printf((char const   */* __restrict  */)"      Number of Power Feeds:   0x%02x\n",
         feeds);
#line 2280
  i___1 = 0U;
  }
  {
#line 2280
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2280
    if (! (i___1 < feeds)) {
#line 2280
      goto while_break___3;
    }
    {
#line 2281
    printf((char const   */* __restrict  */)"    Feed %d:\n", i___1);
#line 2282
    maxext = (unsigned int )((int )*(fru_data + offset) | ((int )*(fru_data + (offset + 1)) << 8));
#line 2284
    offset += 2;
#line 2285
    maxint = (unsigned int )((int )*(fru_data + offset) | ((int )*(fru_data + (offset + 1)) << 8));
#line 2287
    offset += 2;
#line 2288
    minexp = (unsigned int )*(fru_data + offset);
#line 2289
    offset ++;
#line 2290
    entries___0 = (unsigned int )*(fru_data + offset);
#line 2291
    offset ++;
#line 2293
    printf((char const   */* __restrict  */)"      Max External Current:   %d.%d Amps (0x%04x)\n",
           maxext / 10U, maxext % 10U, maxext);
    }
#line 2296
    if (maxint < 65535U) {
      {
#line 2297
      printf((char const   */* __restrict  */)"      Max Internal Current:   %d.%d Amps (0x%04x)\n",
             maxint / 10U, maxint % 10U, maxint);
      }
    } else {
      {
#line 2302
      printf((char const   */* __restrict  */)"      Max Internal Current:   Not Specified\n");
      }
    }
#line 2306
    if (minexp >= 72U) {
#line 2306
      if (minexp <= 144U) {
        {
#line 2307
        printf((char const   */* __restrict  */)"      Min Expected Voltage:   -%02d.%dV\n",
               minexp / 2U, (minexp % 2U) * 5U);
        }
      } else {
        {
#line 2311
        printf((char const   */* __restrict  */)"      Min Expected Voltage:   -36V (actual invalid value 0x%x)\n",
               36, minexp);
        }
      }
    } else {
      {
#line 2311
      printf((char const   */* __restrict  */)"      Min Expected Voltage:   -36V (actual invalid value 0x%x)\n",
             36, minexp);
      }
    }
#line 2315
    j = 0U;
    {
#line 2315
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2315
      if (! (j < entries___0)) {
#line 2315
        goto while_break___4;
      }
      {
#line 2316
      tmp___4 = offset;
#line 2316
      offset ++;
#line 2316
      hwaddr___0 = (unsigned int )*(fru_data + tmp___4);
#line 2317
      tmp___5 = offset;
#line 2317
      offset ++;
#line 2317
      id = (unsigned int )*(fru_data + tmp___5);
#line 2318
      printf((char const   */* __restrict  */)"        FRU HW Addr: 0x%02x (0x%02x)",
             hwaddr___0, hwaddr___0 * 2U);
#line 2321
      printf((char const   */* __restrict  */)"   FRU ID: 0x%02x\n", id);
#line 2315
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2280
    i___1 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2327
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 2332
  count = 0U;
#line 2334
  printf((char const   */* __restrict  */)"    FRU_PICMG_SHELF_ACTIVATION\n");
#line 2335
  tmp___6 = offset;
#line 2335
  offset ++;
#line 2335
  printf((char const   */* __restrict  */)"      Allowance for FRU Act Readiness:   0x%02x\n",
         (int )*(fru_data + tmp___6));
#line 2339
  tmp___7 = offset;
#line 2339
  offset ++;
#line 2339
  count = (unsigned int )*(fru_data + tmp___7);
#line 2340
  printf((char const   */* __restrict  */)"      FRU activation and Power Desc Cnt: 0x%02x\n",
         count);
#line 2344
  i___2 = 0U;
  }
  {
#line 2344
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2344
    if (! (i___2 < count)) {
#line 2344
      goto while_break___5;
    }
    {
#line 2345
    tmp___8 = offset;
#line 2345
    offset ++;
#line 2345
    printf((char const   */* __restrict  */)"         HW Addr: 0x%02x ", (int )*(fru_data + tmp___8));
#line 2347
    tmp___9 = offset;
#line 2347
    offset ++;
#line 2347
    printf((char const   */* __restrict  */)"         FRU ID: 0x%02x ", (int )*(fru_data + tmp___9));
#line 2349
    printf((char const   */* __restrict  */)"         Max FRU Power: 0x%04x ", (int )*(fru_data + offset) | ((int )*(fru_data + (offset + 1)) << 8));
#line 2352
    offset += 2;
#line 2353
    tmp___10 = offset;
#line 2353
    offset ++;
#line 2353
    printf((char const   */* __restrict  */)"         Config: 0x%02x \n", (int )*(fru_data + tmp___10));
#line 2344
    i___2 ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2357
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 2360
  printf((char const   */* __restrict  */)"    FRU_PICMG_SHMC_IP_CONN\n");
  }
#line 2361
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 2364
  printf((char const   */* __restrict  */)"    FRU_PICMG_BOARD_P2P\n");
#line 2366
  tmp___11 = offset;
#line 2366
  offset ++;
#line 2366
  guid_count = (int )*(fru_data + tmp___11);
#line 2367
  printf((char const   */* __restrict  */)"      GUID count: %2d\n", guid_count);
#line 2368
  i = 0;
  }
  {
#line 2368
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 2368
    if (! (i < guid_count)) {
#line 2368
      goto while_break___6;
    }
    {
#line 2370
    printf((char const   */* __restrict  */)"        GUID [%2d]: 0x", i);
#line 2372
    j___0 = 0;
    }
    {
#line 2372
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2372
      if (! ((unsigned long )j___0 < sizeof(struct fru_picmgext_guid ))) {
#line 2372
        goto while_break___7;
      }
      {
#line 2374
      printf((char const   */* __restrict  */)"%02x", (int )*(fru_data + (offset + j___0)));
#line 2372
      j___0 ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 2377
    printf((char const   */* __restrict  */)"\n");
#line 2378
    offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_guid ));
#line 2368
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 2380
  printf((char const   */* __restrict  */)"\n");
  }
  {
#line 2382
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 2382
    if (! (offset < off + length)) {
#line 2382
      goto while_break___8;
    }
    {
#line 2387
    data___0 = (unsigned int )((((int )*(fru_data + offset) | ((int )*(fru_data + (offset + 1)) << 8)) | ((int )*(fru_data + (offset + 2)) << 16)) | ((int )*(fru_data + (offset + 3)) << 24));
#line 2391
    d___0 = (struct fru_picmgext_link_desc *)(& data___0);
#line 2393
    printf((char const   */* __restrict  */)"      Link Grouping ID:     0x%02x\n",
           d___0->grouping);
#line 2395
    printf((char const   */* __restrict  */)"      Link Type Extension:  0x%02x - ",
           d___0->ext);
    }
#line 2397
    if (d___0->type == 1U) {
      {
#line 2400
      if (d___0->ext == 0U) {
#line 2400
        goto case_0___0;
      }
#line 2403
      if (d___0->ext == 1U) {
#line 2403
        goto case_1;
      }
#line 2406
      goto switch_default___0;
      case_0___0: /* CIL Label */ 
      {
#line 2401
      printf((char const   */* __restrict  */)"10/100/1000BASE-T Link (four-pair)\n");
      }
#line 2402
      goto switch_break___1;
      case_1: /* CIL Label */ 
      {
#line 2404
      printf((char const   */* __restrict  */)"ShMC Cross-connect (two-pair)\n");
      }
#line 2405
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
      {
#line 2407
      printf((char const   */* __restrict  */)"Unknwon\n");
      }
#line 2408
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    } else
#line 2410
    if (d___0->type == 2U) {
      {
#line 2413
      if (d___0->ext == 0U) {
#line 2413
        goto case_0___1;
      }
#line 2416
      if (d___0->ext == 1U) {
#line 2416
        goto case_1___0;
      }
#line 2419
      if (d___0->ext == 2U) {
#line 2419
        goto case_2;
      }
#line 2422
      goto switch_default___1;
      case_0___1: /* CIL Label */ 
      {
#line 2414
      printf((char const   */* __restrict  */)"Fixed 1000Base-BX\n");
      }
#line 2415
      goto switch_break___2;
      case_1___0: /* CIL Label */ 
      {
#line 2417
      printf((char const   */* __restrict  */)"Fixed 10GBASE-BX4 [XAUI]\n");
      }
#line 2418
      goto switch_break___2;
      case_2: /* CIL Label */ 
      {
#line 2420
      printf((char const   */* __restrict  */)"FC-PI\n");
      }
#line 2421
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
      {
#line 2423
      printf((char const   */* __restrict  */)"Unknwon\n");
      }
#line 2424
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
    } else
#line 2426
    if (d___0->type == 3U) {
      {
#line 2427
      printf((char const   */* __restrict  */)"Unknwon\n");
      }
    } else
#line 2428
    if (d___0->type == 4U) {
      {
#line 2429
      printf((char const   */* __restrict  */)"Unknwon\n");
      }
    } else
#line 2430
    if (d___0->type == 5U) {
      {
#line 2431
      printf((char const   */* __restrict  */)"Unknwon\n");
      }
    } else {
      {
#line 2433
      printf((char const   */* __restrict  */)"Unknwon\n");
      }
    }
    {
#line 2436
    printf((char const   */* __restrict  */)"      Link Type:            0x%02x - ",
           d___0->type);
    }
#line 2438
    if (d___0->type == 0U) {
      {
#line 2439
      printf((char const   */* __restrict  */)"Reserved\n");
      }
    } else
#line 2438
    if (d___0->type == 255U) {
      {
#line 2439
      printf((char const   */* __restrict  */)"Reserved\n");
      }
    } else
#line 2441
    if (d___0->type >= 6U) {
#line 2441
      if (d___0->type <= 239U) {
        {
#line 2442
        printf((char const   */* __restrict  */)"Reserved\n");
        }
      } else {
#line 2441
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2444
    if (d___0->type >= 240U) {
#line 2444
      if (d___0->type <= 254U) {
        {
#line 2445
        printf((char const   */* __restrict  */)"OEM GUID Definition\n");
        }
      } else {
#line 2444
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 2450
      if (d___0->type == 1U) {
#line 2450
        goto case_1___1;
      }
#line 2453
      if (d___0->type == 2U) {
#line 2453
        goto case_2___0;
      }
#line 2456
      if (d___0->type == 3U) {
#line 2456
        goto case_3;
      }
#line 2459
      if (d___0->type == 4U) {
#line 2459
        goto case_4___0;
      }
#line 2462
      if (d___0->type == 5U) {
#line 2462
        goto case_5;
      }
#line 2465
      goto switch_default___2;
      case_1___1: /* CIL Label */ 
      {
#line 2451
      printf((char const   */* __restrict  */)"PICMG 3.0 Base Interface 10/100/1000\n");
      }
#line 2452
      goto switch_break___3;
      case_2___0: /* CIL Label */ 
      {
#line 2454
      printf((char const   */* __restrict  */)"PICMG 3.1 Ethernet Fabric Interface\n");
      }
#line 2455
      goto switch_break___3;
      case_3: /* CIL Label */ 
      {
#line 2457
      printf((char const   */* __restrict  */)"PICMG 3.2 Infiniband Fabric Interface\n");
      }
#line 2458
      goto switch_break___3;
      case_4___0: /* CIL Label */ 
      {
#line 2460
      printf((char const   */* __restrict  */)"PICMG 3.3 Star Fabric Interface\n");
      }
#line 2461
      goto switch_break___3;
      case_5: /* CIL Label */ 
      {
#line 2463
      printf((char const   */* __restrict  */)"PICMG 3.4 PCI Express Fabric Interface\n");
      }
#line 2464
      goto switch_break___3;
      switch_default___2: /* CIL Label */ 
      {
#line 2466
      printf((char const   */* __restrict  */)"Invalid\n");
      }
#line 2467
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
    }
    {
#line 2470
    printf((char const   */* __restrict  */)"      Link Designator: \n");
#line 2471
    printf((char const   */* __restrict  */)"        Port Flag:            0x%02x\n",
           d___0->desig_port);
#line 2473
    printf((char const   */* __restrict  */)"        Interface:            0x%02x - ",
           d___0->desig_if);
    }
    {
#line 2477
    if (d___0->desig_if == 0U) {
#line 2477
      goto case_0___2;
    }
#line 2480
    if (d___0->desig_if == 1U) {
#line 2480
      goto case_1___2;
    }
#line 2483
    if (d___0->desig_if == 2U) {
#line 2483
      goto case_2___1;
    }
#line 2486
    if (d___0->desig_if == 3U) {
#line 2486
      goto case_3___0;
    }
#line 2489
    goto switch_default___3;
    case_0___2: /* CIL Label */ 
    {
#line 2478
    printf((char const   */* __restrict  */)"Base Interface\n");
    }
#line 2479
    goto switch_break___4;
    case_1___2: /* CIL Label */ 
    {
#line 2481
    printf((char const   */* __restrict  */)"Fabric Interface\n");
    }
#line 2482
    goto switch_break___4;
    case_2___1: /* CIL Label */ 
    {
#line 2484
    printf((char const   */* __restrict  */)"Update Channel\n");
    }
#line 2485
    goto switch_break___4;
    case_3___0: /* CIL Label */ 
    {
#line 2487
    printf((char const   */* __restrict  */)"Reserved\n");
    }
#line 2488
    goto switch_break___4;
    switch_default___3: /* CIL Label */ 
    {
#line 2490
    printf((char const   */* __restrict  */)"Invalid");
    }
#line 2491
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
    {
#line 2493
    printf((char const   */* __restrict  */)"        Channel Number:       0x%02x\n",
           d___0->desig_channel);
#line 2495
    printf((char const   */* __restrict  */)"\n");
#line 2382
    offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_link_desc ));
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 2498
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 2503
  printf((char const   */* __restrict  */)"    FRU_AMC_CURRENT\n");
#line 2505
  current = *(fru_data + offset);
#line 2506
  printf((char const   */* __restrict  */)"      Current draw(@12V): %.2f A [ %.2f Watt ]\n",
         (double )((float )current / 10.0f), (double )(((float )current / 10.0f) * 12.0f));
#line 2509
  printf((char const   */* __restrict  */)"\n");
  }
#line 2511
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 2514
  printf((char const   */* __restrict  */)"    FRU_AMC_ACTIVATION\n");
#line 2518
  max_current = (uint16_t )*(fru_data + offset);
#line 2519
  offset ++;
#line 2519
  max_current = (uint16_t )((int )max_current | ((int )*(fru_data + offset) << 8));
#line 2520
  printf((char const   */* __restrict  */)"      Maximum Internal Current(@12V): %.2f A [ %.2f Watt ]\n",
         (double )((float )max_current / 10.0f), (double )(((float )max_current / 10.0f) * 12.0f));
#line 2524
  offset ++;
#line 2524
  printf((char const   */* __restrict  */)"      Module Activation Readiness:    %i sec.\n",
         (int )*(fru_data + offset));
#line 2525
  offset ++;
#line 2525
  printf((char const   */* __restrict  */)"      Descriptor Count: %i\n", (int )*(fru_data + offset));
#line 2526
  printf((char const   */* __restrict  */)"\n");
#line 2528
  offset ++;
  }
  {
#line 2528
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 2528
    if (! (offset < off + length)) {
#line 2528
      goto while_break___9;
    }
    {
#line 2532
    a = (struct fru_picmgext_activation_record *)(fru_data + offset);
#line 2533
    printf((char const   */* __restrict  */)"        IPMB-Address:         0x%x\n",
           (int )a->ibmb_addr);
#line 2535
    printf((char const   */* __restrict  */)"        Max. Module Current:  %.2f A\n",
           (double )((float )a->max_module_curr / 10.0f));
#line 2537
    printf((char const   */* __restrict  */)"\n");
#line 2528
    offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_activation_record ));
    }
  }
  while_break___9: /* CIL Label */ ;
  }
#line 2540
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 2545
  printf((char const   */* __restrict  */)"    FRU_CARRIER_P2P\n");
  }
  {
#line 2546
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 2546
    if (! (offset < off + length)) {
#line 2546
      goto while_break___10;
    }
    {
#line 2547
    h___0 = (struct fru_picmgext_carrier_p2p_record *)(fru_data + offset);
#line 2549
    printf((char const   */* __restrict  */)"\n");
#line 2550
    printf((char const   */* __restrict  */)"      Resource ID:      %i", (int )h___0->resource_id & 7);
#line 2552
    printf((char const   */* __restrict  */)"  Type: ");
    }
#line 2553
    if ((int )h___0->resource_id >> 7 == 1) {
      {
#line 2554
      printf((char const   */* __restrict  */)"AMC\n");
      }
    } else {
      {
#line 2556
      printf((char const   */* __restrict  */)"Local\n");
      }
    }
    {
#line 2558
    printf((char const   */* __restrict  */)"      Descriptor Count: %i\n", (int )h___0->p2p_count);
#line 2560
    offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_carrier_p2p_record ));
#line 2561
    index___1 = (uint16_t )0;
    }
    {
#line 2561
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 2561
      if (! ((int )index___1 < (int )h___0->p2p_count)) {
#line 2561
        goto while_break___11;
      }
      {
#line 2566
      data___1[0] = *(fru_data + offset);
#line 2567
      data___1[1] = *(fru_data + (offset + 1));
#line 2568
      data___1[2] = *(fru_data + (offset + 2));
#line 2574
      desc = (struct fru_picmgext_carrier_p2p_descriptor *)(& data___1);
#line 2575
      printf((char const   */* __restrict  */)"        Port: %02d\t->  Remote Port: %02d\t",
             (int )desc->local_port, (int )desc->remote_port);
      }
#line 2577
      if ((int )desc->remote_resource_id >> 7 == 1) {
        {
#line 2578
        printf((char const   */* __restrict  */)"[ AMC   ID: %02d ]\n", (int )desc->remote_resource_id & 15);
        }
      } else {
        {
#line 2581
        printf((char const   */* __restrict  */)"[ local ID: %02d ]\n", (int )desc->remote_resource_id & 15);
        }
      }
#line 2584
      offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_carrier_p2p_descriptor ));
#line 2561
      index___1 = (uint16_t )((int )index___1 + 1);
    }
    while_break___11: /* CIL Label */ ;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
#line 2588
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 2595
  printf((char const   */* __restrict  */)"    FRU_AMC_P2P\n");
#line 2596
  guid_count = (int )*(fru_data + offset);
#line 2597
  printf((char const   */* __restrict  */)"      GUID count: %2d\n", guid_count);
#line 2598
  i = 0;
  }
  {
#line 2598
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 2598
    if (! (i < guid_count)) {
#line 2598
      goto while_break___12;
    }
    {
#line 2600
    printf((char const   */* __restrict  */)"        GUID %2d: ", i);
#line 2601
    j___1 = 0;
    }
    {
#line 2601
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 2601
      if (! ((unsigned long )j___1 < sizeof(struct fru_picmgext_guid ))) {
#line 2601
        goto while_break___13;
      }
      {
#line 2603
      printf((char const   */* __restrict  */)"%02x", (int )*(fru_data + (offset + j___1)));
#line 2604
      offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_guid ));
#line 2605
      printf((char const   */* __restrict  */)"\n");
#line 2601
      j___1 ++;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
#line 2607
    offset ++;
#line 2607
    h___1 = (struct fru_picmgext_amc_p2p_record *)(fru_data + offset);
#line 2608
    if (h___1->record_type) {
#line 2608
      tmp___12 = "AMC Module:";
    } else {
#line 2608
      tmp___12 = "On-Carrier Device";
    }
    {
#line 2608
    printf((char const   */* __restrict  */)"      %s", tmp___12);
#line 2611
    printf((char const   */* __restrict  */)"   Resource ID: %i\n", (int )h___1->resource_id);
#line 2612
    offset = (int )((unsigned long )offset + sizeof(struct fru_picmgext_amc_p2p_record ));
#line 2613
    tmp___13 = offset;
#line 2613
    offset ++;
#line 2613
    channel_count = *(fru_data + tmp___13);
#line 2614
    printf((char const   */* __restrict  */)"       Descriptor Count: %i\n", (int )channel_count);
#line 2616
    index___2 = 0U;
    }
    {
#line 2616
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 2616
      if (! (index___2 < (unsigned int )channel_count)) {
#line 2616
        goto while_break___14;
      }
      {
#line 2622
      data___2 = (unsigned int )(((int )*(fru_data + offset) | ((int )*(fru_data + (offset + 1)) << 8)) | ((int )*(fru_data + (offset + 2)) << 16));
#line 2625
      d___1 = (struct fru_picmgext_amc_channel_desc_record *)(& data___2);
#line 2626
      printf((char const   */* __restrict  */)"        Lane 0 Port: %i\n", d___1->lane0port);
#line 2628
      printf((char const   */* __restrict  */)"        Lane 1 Port: %i\n", d___1->lane1port);
#line 2630
      printf((char const   */* __restrict  */)"        Lane 2 Port: %i\n", d___1->lane2port);
#line 2632
      printf((char const   */* __restrict  */)"        Lane 3 Port: %i\n\n", d___1->lane3port);
#line 2634
      offset += 3;
#line 2616
      index___2 ++;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 2636
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 2636
      if (! (offset < off + length)) {
#line 2636
        goto while_break___15;
      }
#line 2639
      l = (struct fru_picmgext_amc_link_desc_record *)(& data___3[0]);
#line 2640
      data___3[0] = (unsigned int )((((int )*(fru_data + offset) | ((int )*(fru_data + (offset + 1)) << 8)) | ((int )*(fru_data + (offset + 2)) << 16)) | ((int )*(fru_data + (offset + 3)) << 24));
#line 2644
      data___3[1] = (unsigned int )*(fru_data + (offset + 4));
#line 2645
      if (l->port_flag_3) {
#line 2645
        tmp___14 = "o";
      } else {
#line 2645
        tmp___14 = "-";
      }
#line 2645
      if (l->port_flag_2) {
#line 2645
        tmp___15 = "o";
      } else {
#line 2645
        tmp___15 = "-";
      }
#line 2645
      if (l->port_flag_1) {
#line 2645
        tmp___16 = "o";
      } else {
#line 2645
        tmp___16 = "-";
      }
#line 2645
      if (l->port_flag_0) {
#line 2645
        tmp___17 = "o";
      } else {
#line 2645
        tmp___17 = "-";
      }
      {
#line 2645
      printf((char const   */* __restrict  */)"      Link Designator:  Channel ID: %i\n            Port Flag 0: %s%s%s%s\n",
             l->channel_id, tmp___17, tmp___16, tmp___15, tmp___14);
      }
      {
#line 2653
      if (l->type == 2U) {
#line 2653
        goto case_2___2;
      }
#line 2687
      if (l->type == 4U) {
#line 2687
        goto case_4___1;
      }
#line 2687
      if (l->type == 3U) {
#line 2687
        goto case_4___1;
      }
#line 2696
      if (l->type == 5U) {
#line 2696
        goto case_5___0;
      }
#line 2722
      if (l->type == 7U) {
#line 2722
        goto case_7___0;
      }
#line 2754
      if (l->type == 6U) {
#line 2754
        goto case_6;
      }
#line 2763
      goto switch_default___7;
      case_2___2: /* CIL Label */ 
      {
#line 2655
      printf((char const   */* __restrict  */)"        Link Type:       %02x - AMC.1 PCI Express\n",
             l->type);
      }
      {
#line 2658
      if (l->type_ext == 0U) {
#line 2658
        goto case_0___3;
      }
#line 2663
      if (l->type_ext == 1U) {
#line 2663
        goto case_1___3;
      }
#line 2668
      if (l->type_ext == 2U) {
#line 2668
        goto case_2___3;
      }
#line 2673
      if (l->type_ext == 3U) {
#line 2673
        goto case_3___1;
      }
#line 2678
      goto switch_default___4;
      case_0___3: /* CIL Label */ 
      {
#line 2659
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i -  Gen 1 capable - non SSC\n",
             l->type_ext);
      }
#line 2662
      goto switch_break___6;
      case_1___3: /* CIL Label */ 
      {
#line 2664
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i -  Gen 1 capable - SSC\n",
             l->type_ext);
      }
#line 2667
      goto switch_break___6;
      case_2___3: /* CIL Label */ 
      {
#line 2669
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i -  Gen 2 capable - non SSC\n",
             l->type_ext);
      }
#line 2672
      goto switch_break___6;
      case_3___1: /* CIL Label */ 
      {
#line 2674
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i -  Gen 2 capable - SSC\n",
             l->type_ext);
      }
#line 2677
      goto switch_break___6;
      switch_default___4: /* CIL Label */ 
      {
#line 2679
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i -  Invalid\n",
             l->type_ext);
      }
#line 2682
      goto switch_break___6;
      switch_break___6: /* CIL Label */ ;
      }
#line 2684
      goto switch_break___5;
      case_4___1: /* CIL Label */ 
      case_3___2: /* CIL Label */ 
      {
#line 2689
      printf((char const   */* __restrict  */)"        Link Type:       %02x - AMC.1 PCI Express Advanced Switching\n",
             l->type);
#line 2692
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i\n", l->type_ext);
      }
#line 2694
      goto switch_break___5;
      case_5___0: /* CIL Label */ 
      {
#line 2698
      printf((char const   */* __restrict  */)"        Link Type:       %02x - AMC.2 Ethernet\n",
             l->type);
      }
      {
#line 2702
      if (l->type_ext == 0U) {
#line 2702
        goto case_0___4;
      }
#line 2708
      if (l->type_ext == 1U) {
#line 2708
        goto case_1___4;
      }
#line 2714
      goto switch_default___5;
      case_0___4: /* CIL Label */ 
      {
#line 2703
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i -  1000Base-Bx (SerDES Gigabit) Ethernet Link\n",
             l->type_ext);
      }
#line 2706
      goto switch_break___7;
      case_1___4: /* CIL Label */ 
      {
#line 2709
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i -  10Gbit XAUI Ethernet Link\n",
             l->type_ext);
      }
#line 2712
      goto switch_break___7;
      switch_default___5: /* CIL Label */ 
      {
#line 2715
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i -  Invalid\n",
             l->type_ext);
      }
#line 2718
      goto switch_break___7;
      switch_break___7: /* CIL Label */ ;
      }
#line 2720
      goto switch_break___5;
      case_7___0: /* CIL Label */ 
      {
#line 2724
      printf((char const   */* __restrict  */)"        Link Type:       %02x - AMC.3 Storage\n",
             l->type);
      }
      {
#line 2728
      if (l->type_ext == 0U) {
#line 2728
        goto case_0___5;
      }
#line 2734
      if (l->type_ext == 1U) {
#line 2734
        goto case_1___5;
      }
#line 2740
      if (l->type_ext == 2U) {
#line 2740
        goto case_2___4;
      }
#line 2746
      goto switch_default___6;
      case_0___5: /* CIL Label */ 
      {
#line 2729
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i -  Fibre Channel\n",
             l->type_ext);
      }
#line 2732
      goto switch_break___8;
      case_1___5: /* CIL Label */ 
      {
#line 2735
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i -  Serial ATA\n",
             l->type_ext);
      }
#line 2738
      goto switch_break___8;
      case_2___4: /* CIL Label */ 
      {
#line 2741
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i -  Serial Attached SCSI\n",
             l->type_ext);
      }
#line 2744
      goto switch_break___8;
      switch_default___6: /* CIL Label */ 
      {
#line 2747
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i -  Invalid\n",
             l->type_ext);
      }
#line 2750
      goto switch_break___8;
      switch_break___8: /* CIL Label */ ;
      }
#line 2752
      goto switch_break___5;
      case_6: /* CIL Label */ 
      {
#line 2756
      printf((char const   */* __restrict  */)"        Link Type:       %02x - AMC.4 Serial Rapid IO\n",
             l->type);
#line 2759
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i\n", l->type_ext);
      }
#line 2761
      goto switch_break___5;
      switch_default___7: /* CIL Label */ 
      {
#line 2764
      printf((char const   */* __restrict  */)"        Link Type:       %02x - reserved or OEM GUID",
             l->type);
#line 2767
      printf((char const   */* __restrict  */)"        Link Type Ext:   %i\n", l->type_ext);
      }
#line 2769
      goto switch_break___5;
      switch_break___5: /* CIL Label */ ;
      }
      {
#line 2772
      printf((char const   */* __restrict  */)"        Link group Id:   %i\n", l->group_id);
#line 2774
      printf((char const   */* __restrict  */)"        Link Asym Match: %i\n\n", l->asym_match);
#line 2776
      offset += 5;
      }
    }
    while_break___15: /* CIL Label */ ;
    }
#line 2598
    i ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 2780
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 2787
  printf((char const   */* __restrict  */)"    FRU_CARRIER_INFO\n");
#line 2789
  tmp___18 = offset;
#line 2789
  offset ++;
#line 2789
  extVersion = *(fru_data + tmp___18);
#line 2790
  tmp___19 = offset;
#line 2790
  offset ++;
#line 2790
  siteCount = *(fru_data + tmp___19);
#line 2792
  printf((char const   */* __restrict  */)"      AMC.0 extension version: R%d.%d\n",
         (int )extVersion & 15, ((int )extVersion >> 4) & 15);
#line 2795
  printf((char const   */* __restrict  */)"      Carrier Sie Number Cnt: %d\n", (int )siteCount);
#line 2797
  i = 0;
  }
  {
#line 2797
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 2797
    if (! (i < (int )siteCount)) {
#line 2797
      goto while_break___16;
    }
    {
#line 2798
    tmp___20 = offset;
#line 2798
    offset ++;
#line 2798
    printf((char const   */* __restrict  */)"       Site ID: %i \n", (int )*(fru_data + tmp___20));
#line 2797
    i ++;
    }
  }
  while_break___16: /* CIL Label */ ;
  }
  {
#line 2800
  printf((char const   */* __restrict  */)"\n");
  }
#line 2802
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 2808
  printf((char const   */* __restrict  */)"    FRU_PICMG_CLK_CARRIER_P2P\n");
#line 2810
  tmp___21 = offset;
#line 2810
  offset ++;
#line 2810
  desc_count = *(fru_data + tmp___21);
#line 2812
  i___3 = 0;
  }
  {
#line 2812
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 2812
    if (! (i___3 < (int )desc_count)) {
#line 2812
      goto while_break___17;
    }
    {
#line 2816
    tmp___22 = offset;
#line 2816
    offset ++;
#line 2816
    resource_id = *(fru_data + tmp___22);
#line 2817
    tmp___23 = offset;
#line 2817
    offset ++;
#line 2817
    channel_count___0 = *(fru_data + tmp___23);
#line 2819
    printf((char const   */* __restrict  */)"\n");
#line 2820
    printf((char const   */* __restrict  */)"      Clock Resource ID: 0x%02x  Type: ",
           (int )resource_id);
    }
#line 2821
    if (((int )resource_id & 192) >> 6 == 0) {
      {
#line 2821
      printf((char const   */* __restrict  */)"On-Carrier-Device\n");
      }
    } else
#line 2822
    if (((int )resource_id & 192) >> 6 == 1) {
      {
#line 2822
      printf((char const   */* __restrict  */)"AMC slot\n");
      }
    } else
#line 2823
    if (((int )resource_id & 192) >> 6 == 2) {
      {
#line 2823
      printf((char const   */* __restrict  */)"Backplane\n");
      }
    } else {
      {
#line 2824
      printf((char const   */* __restrict  */)"reserved\n");
      }
    }
    {
#line 2825
    printf((char const   */* __restrict  */)"      Channel Count: 0x%02x\n", (int )channel_count___0);
#line 2827
    j___2 = 0;
    }
    {
#line 2827
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 2827
      if (! (j___2 < (int )channel_count___0)) {
#line 2827
        goto while_break___18;
      }
      {
#line 2830
      tmp___24 = offset;
#line 2830
      offset ++;
#line 2830
      loc_channel = *(fru_data + tmp___24);
#line 2831
      tmp___25 = offset;
#line 2831
      offset ++;
#line 2831
      rem_channel = *(fru_data + tmp___25);
#line 2832
      tmp___26 = offset;
#line 2832
      offset ++;
#line 2832
      rem_resource = *(fru_data + tmp___26);
#line 2834
      printf((char const   */* __restrict  */)"        CLK-ID: 0x%02x    ->", (int )loc_channel);
#line 2835
      printf((char const   */* __restrict  */)" remote CLKID: 0x%02x   ", (int )rem_channel);
      }
#line 2836
      if (((int )rem_resource & 192) >> 6 == 0) {
        {
#line 2836
        printf((char const   */* __restrict  */)"[ Carrier-Dev");
        }
      } else
#line 2837
      if (((int )rem_resource & 192) >> 6 == 1) {
        {
#line 2837
        printf((char const   */* __restrict  */)"[ AMC slot   ");
        }
      } else
#line 2838
      if (((int )rem_resource & 192) >> 6 == 2) {
        {
#line 2838
        printf((char const   */* __restrict  */)"[ Backplane  ");
        }
      } else {
        {
#line 2839
        printf((char const   */* __restrict  */)"reserved         ");
        }
      }
      {
#line 2840
      printf((char const   */* __restrict  */)" 0x%02x ]\n", (int )rem_resource & 15);
#line 2827
      j___2 ++;
      }
    }
    while_break___18: /* CIL Label */ ;
    }
#line 2812
    i___3 ++;
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 2843
  printf((char const   */* __restrict  */)"\n");
  }
#line 2845
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 2851
  printf((char const   */* __restrict  */)"    FRU_PICMG_CLK_CONFIG\n");
#line 2853
  tmp___27 = offset;
#line 2853
  offset ++;
#line 2853
  resource_id___0 = *(fru_data + tmp___27);
#line 2854
  tmp___28 = offset;
#line 2854
  offset ++;
#line 2854
  descr_count = *(fru_data + tmp___28);
#line 2856
  printf((char const   */* __restrict  */)"\n");
#line 2857
  printf((char const   */* __restrict  */)"      Clock Resource ID: 0x%02x\n", (int )resource_id___0);
#line 2858
  printf((char const   */* __restrict  */)"      Descr. Count:      0x%02x\n", (int )descr_count);
#line 2860
  i___4 = 0;
  }
  {
#line 2860
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 2860
    if (! (i___4 < (int )descr_count)) {
#line 2860
      goto while_break___19;
    }
    {
#line 2864
    tmp___29 = offset;
#line 2864
    offset ++;
#line 2864
    channel_id = *(fru_data + tmp___29);
#line 2865
    tmp___30 = offset;
#line 2865
    offset ++;
#line 2865
    control = *(fru_data + tmp___30);
#line 2866
    printf((char const   */* __restrict  */)"        CLK-ID: 0x%02x  -  ", (int )channel_id);
    }
#line 2867
    if (((int )control & 1) == 0) {
#line 2867
      tmp___31 = "Carrier IPMC";
    } else {
#line 2867
      tmp___31 = "Application";
    }
    {
#line 2867
    printf((char const   */* __restrict  */)"CTRL 0x%02x [ %12s ]\n", (int )control,
           tmp___31);
#line 2871
    tmp___32 = offset;
#line 2871
    offset ++;
#line 2871
    indirect_cnt = *(fru_data + tmp___32);
#line 2872
    tmp___33 = offset;
#line 2872
    offset ++;
#line 2872
    direct_cnt = *(fru_data + tmp___33);
#line 2873
    printf((char const   */* __restrict  */)"         Cnt: Indirect 0x%02x  /  Direct 0x%02x\n",
           (int )indirect_cnt, (int )direct_cnt);
#line 2878
    j___3 = 0;
    }
    {
#line 2878
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 2878
      if (! (j___3 < (int )indirect_cnt)) {
#line 2878
        goto while_break___20;
      }
#line 2882
      tmp___34 = offset;
#line 2882
      offset ++;
#line 2882
      feature = *(fru_data + tmp___34);
#line 2883
      tmp___35 = offset;
#line 2883
      offset ++;
#line 2883
      dep_chn_id = *(fru_data + tmp___35);
#line 2885
      if (((int )feature & 1) == 1) {
#line 2885
        tmp___36 = "Source";
      } else {
#line 2885
        tmp___36 = "Receiver";
      }
      {
#line 2885
      printf((char const   */* __restrict  */)"          Feature: 0x%02x [%8s] - ",
             (int )feature, tmp___36);
#line 2886
      printf((char const   */* __restrict  */)"          Dep. CLK-ID: 0x%02x\n", (int )dep_chn_id);
#line 2878
      j___3 ++;
      }
    }
    while_break___20: /* CIL Label */ ;
    }
#line 2890
    j___3 = 0;
    {
#line 2890
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 2890
      if (! (j___3 < (int )direct_cnt)) {
#line 2890
        goto while_break___21;
      }
#line 2894
      tmp___37 = offset;
#line 2894
      offset ++;
#line 2894
      feature___0 = *(fru_data + tmp___37);
#line 2895
      tmp___38 = offset;
#line 2895
      offset ++;
#line 2895
      family = *(fru_data + tmp___38);
#line 2896
      tmp___39 = offset;
#line 2896
      offset ++;
#line 2896
      accuracy = *(fru_data + tmp___39);
#line 2897
      freq = (unsigned int )((((int )*(fru_data + offset) | ((int )*(fru_data + (offset + 1)) << 8)) | ((int )*(fru_data + (offset + 2)) << 16)) | ((int )*(fru_data + (offset + 3)) << 24));
#line 2899
      offset += 4;
#line 2900
      min_freq = (unsigned int )((((int )*(fru_data + offset) | ((int )*(fru_data + (offset + 1)) << 8)) | ((int )*(fru_data + (offset + 2)) << 16)) | ((int )*(fru_data + (offset + 3)) << 24));
#line 2902
      offset += 4;
#line 2903
      max_freq = (unsigned int )((((int )*(fru_data + offset) | ((int )*(fru_data + (offset + 1)) << 8)) | ((int )*(fru_data + (offset + 2)) << 16)) | ((int )*(fru_data + (offset + 3)) << 24));
#line 2905
      offset += 4;
#line 2907
      if ((int )feature___0 & 1) {
#line 2907
        tmp___40 = "Source";
      } else {
#line 2907
        tmp___40 = "Receiver";
      }
      {
#line 2907
      printf((char const   */* __restrict  */)"          - Feature: 0x%02x  - PLL: %x / Asym: %s\n",
             (int )feature___0, ((int )feature___0 > 1) & 1, tmp___40);
#line 2911
      printf((char const   */* __restrict  */)"            Family:  0x%02x  - AccLVL: 0x%02x\n",
             (int )family, (int )accuracy);
#line 2912
      printf((char const   */* __restrict  */)"            FRQ: %-9ld - min: %-9ld - max: %-9ld\n",
             freq, min_freq, max_freq);
#line 2890
      j___3 ++;
      }
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 2915
    printf((char const   */* __restrict  */)"\n");
#line 2860
    i___4 ++;
    }
  }
  while_break___19: /* CIL Label */ ;
  }
  {
#line 2917
  printf((char const   */* __restrict  */)"\n");
  }
#line 2919
  goto switch_break;
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_32: /* CIL Label */ 
  {
#line 2933
  printf((char const   */* __restrict  */)"    Not implemented yet. uTCA specific record found!!\n");
#line 2934
  printf((char const   */* __restrict  */)"     - Record ID: 0x%02x\n", (int )h->record_id);
  }
#line 2935
  goto switch_break;
  switch_default___8: /* CIL Label */ 
  {
#line 2938
  printf((char const   */* __restrict  */)"    Unknown OEM Extension Record ID: %x\n",
         (int )h->record_id);
  }
#line 2939
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2942
  return;
}
}
#line 2954 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int __ipmi_fru_print___0(struct ipmi_intf *intf , uint8_t id ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct fru_info fru ;
  struct fru_header header ;
  uint8_t msg_data[4] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 2963
  memset((void *)(& fru), 0, sizeof(struct fru_info ));
#line 2964
  memset((void *)(& header), 0, sizeof(struct fru_header ));
#line 2969
  memset((void *)(msg_data), 0, (size_t )4);
#line 2970
  msg_data[0] = id;
#line 2972
  memset((void *)(& req), 0, sizeof(req));
#line 2973
  req.msg.netfn = (uint8_t )10;
#line 2974
  req.msg.cmd = (uint8_t )16;
#line 2975
  req.msg.data = msg_data;
#line 2976
  req.msg.data_len = (uint16_t )1;
#line 2978
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2979
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2980
    printf((char const   */* __restrict  */)" Device not present (No Response)\n");
    }
#line 2981
    return (-1);
  }
#line 2983
  if ((int )rsp->ccode > 0) {
    {
#line 2984
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2984
    printf((char const   */* __restrict  */)" Device not present (%s)\n", tmp);
    }
#line 2986
    return (-1);
  }
#line 2989
  fru.size = (uint16_t )(((int )rsp->data[1] << 8) | (int )rsp->data[0]);
#line 2990
  fru.access = (uint8_t )((int )rsp->data[2] & 1);
#line 2992
  if (fru.access) {
#line 2992
    tmp___0 = "words";
  } else {
#line 2992
    tmp___0 = "bytes";
  }
  {
#line 2992
  lprintf(7, "fru.size = %d bytes (accessed by %s)", (int )fru.size, tmp___0);
  }
#line 2995
  if ((int )fru.size < 1) {
    {
#line 2996
    lprintf(3, " Invalid FRU size %d", (int )fru.size);
    }
#line 2997
    return (-1);
  }
  {
#line 3003
  msg_data[0] = id;
#line 3004
  msg_data[1] = (uint8_t )0;
#line 3005
  msg_data[2] = (uint8_t )0;
#line 3006
  msg_data[3] = (uint8_t )8;
#line 3008
  memset((void *)(& req), 0, sizeof(req));
#line 3009
  req.msg.netfn = (uint8_t )10;
#line 3010
  req.msg.cmd = (uint8_t )17;
#line 3011
  req.msg.data = msg_data;
#line 3012
  req.msg.data_len = (uint16_t )4;
#line 3014
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 3015
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 3016
    printf((char const   */* __restrict  */)" Device not present (No Response)\n");
    }
#line 3017
    return (1);
  }
#line 3019
  if ((int )rsp->ccode > 0) {
    {
#line 3020
    tmp___1 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3020
    printf((char const   */* __restrict  */)" Device not present (%s)\n", tmp___1);
    }
#line 3022
    return (1);
  }
#line 3025
  if (verbose > 1) {
    {
#line 3026
    printbuf((uint8_t const   *)(rsp->data), rsp->data_len, "FRU DATA");
    }
  }
  {
#line 3028
  memcpy((void */* __restrict  */)(& header), (void const   */* __restrict  */)(rsp->data + 1),
         (size_t )8);
  }
#line 3030
  if ((int )header.version != 1) {
    {
#line 3031
    lprintf(3, " Unknown FRU header version 0x%02x", (int )header.version);
    }
#line 3033
    return (-1);
  }
  {
#line 3041
  lprintf(7, "fru.header.version:         0x%x", (int )header.version);
#line 3043
  lprintf(7, "fru.header.offset.internal: 0x%x", (int )header.offset.internal * 8);
#line 3045
  lprintf(7, "fru.header.offset.chassis:  0x%x", (int )header.offset.chassis * 8);
#line 3047
  lprintf(7, "fru.header.offset.board:    0x%x", (int )header.offset.board * 8);
#line 3049
  lprintf(7, "fru.header.offset.product:  0x%x", (int )header.offset.product * 8);
#line 3051
  lprintf(7, "fru.header.offset.multi:    0x%x", (int )header.offset.multi * 8);
  }
#line 3059
  if ((unsigned long )((int )header.offset.chassis * 8) >= sizeof(struct fru_header )) {
    {
#line 3060
    fru_area_print_chassis___0(intf, & fru, id, (uint32_t )((int )header.offset.chassis * 8));
    }
  }
#line 3063
  if ((unsigned long )((int )header.offset.board * 8) >= sizeof(struct fru_header )) {
    {
#line 3064
    fru_area_print_board___0(intf, & fru, id, (uint32_t )((int )header.offset.board * 8));
    }
  }
#line 3067
  if ((unsigned long )((int )header.offset.product * 8) >= sizeof(struct fru_header )) {
    {
#line 3068
    fru_area_print_product___0(intf, & fru, id, (uint32_t )((int )header.offset.product * 8));
    }
  }
#line 3071
  if (verbose == 0) {
#line 3072
    return (0);
  }
#line 3074
  if ((unsigned long )((int )header.offset.multi * 8) >= sizeof(struct fru_header )) {
    {
#line 3075
    fru_area_print_multirec___0(intf, & fru, id, (uint32_t )((int )header.offset.multi * 8));
    }
  }
#line 3077
  return (0);
}
}
#line 3169 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_print_all___0(struct ipmi_intf *intf ) 
{ 
  struct ipmi_sdr_iterator *itr ;
  struct sdr_get_rs *header ;
  struct sdr_record_fru_locator *fru ;
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct ipm_devid_rsp *devid ;
  struct sdr_record_mc_locator *mc ;
  uint32_t save_addr ;
  char const   *tmp ;
  uint8_t *tmp___0 ;
  uint8_t *tmp___1 ;

  {
  {
#line 3182
  printf((char const   */* __restrict  */)"FRU Device Description : Builtin FRU Device (ID 0)\n");
#line 3186
  memset((void *)(& req), 0, sizeof(req));
#line 3187
  req.msg.netfn = (uint8_t )6;
#line 3188
  req.msg.cmd = (uint8_t )1;
#line 3189
  req.msg.data_len = (uint16_t )0;
#line 3191
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 3192
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 3193
    lprintf(3, "Get Device ID command failed");
    }
#line 3194
    return (-1);
  }
#line 3196
  if ((int )rsp->ccode > 0) {
    {
#line 3197
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3197
    lprintf(3, "Get Device ID command failed: %s", tmp);
    }
#line 3199
    return (-1);
  }
#line 3202
  devid = (struct ipm_devid_rsp *)(rsp->data);
#line 3207
  if ((int )devid->adtl_device_support & 8) {
    {
#line 3208
    rc = ipmi_fru_print(intf, (struct sdr_record_fru_locator *)((void *)0));
#line 3209
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 3212
  itr = ipmi_sdr_start(intf, 0);
  }
#line 3212
  if ((unsigned long )itr == (unsigned long )((void *)0)) {
#line 3213
    return (-1);
  }
  {
#line 3219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3219
    header = ipmi_sdr_get_next_header(intf, itr);
    }
#line 3219
    if (! ((unsigned long )header != (unsigned long )((void *)0))) {
#line 3219
      goto while_break;
    }
#line 3221
    if ((int )header->type == 18) {
      {
#line 3223
      tmp___0 = ipmi_sdr_get_record(intf, header, itr);
#line 3223
      mc = (struct sdr_record_mc_locator *)tmp___0;
      }
#line 3226
      if (mc) {
#line 3226
        if ((int )mc->dev_support & 8) {
          {
#line 3231
          save_addr = intf->target_addr;
#line 3234
          intf->target_addr = (uint32_t )mc->dev_slave_addr;
#line 3236
          printf((char const   */* __restrict  */)"FRU Device Description : %-16s\n",
                 mc->id_string);
#line 3240
          rc = __ipmi_fru_print___0(intf, (uint8_t )0);
#line 3242
          printf((char const   */* __restrict  */)"\n");
#line 3245
          intf->target_addr = save_addr;
          }
        }
      }
#line 3248
      if (mc) {
        {
#line 3249
        free((void *)mc);
#line 3250
        mc = (struct sdr_record_mc_locator *)((void *)0);
        }
      }
#line 3253
      goto while_continue;
    }
#line 3256
    if ((int )header->type != 17) {
#line 3257
      goto while_continue;
    }
    {
#line 3260
    tmp___1 = ipmi_sdr_get_record(intf, header, itr);
#line 3260
    fru = (struct sdr_record_fru_locator *)tmp___1;
    }
#line 3262
    if ((unsigned long )fru == (unsigned long )((void *)0)) {
#line 3262
      goto _L;
    } else
#line 3262
    if (! fru->logical) {
      _L: /* CIL Label */ 
#line 3263
      if (fru) {
        {
#line 3264
        free((void *)fru);
#line 3265
        fru = (struct sdr_record_fru_locator *)((void *)0);
        }
      }
#line 3267
      goto while_continue;
    }
    {
#line 3269
    rc = ipmi_fru_print(intf, fru);
#line 3270
    free((void *)fru);
#line 3271
    fru = (struct sdr_record_fru_locator *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3274
  ipmi_sdr_end(intf, itr);
  }
#line 3276
  return (rc);
}
}
#line 3291 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static void ipmi_fru_read_to_bin___0(struct ipmi_intf *intf , char *pFileName , uint8_t fruId ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct fru_info fru ;
  uint8_t msg_data[4] ;
  uint8_t *pFruBuf ;
  void *tmp ;
  FILE *pFile ;

  {
  {
#line 3302
  msg_data[0] = fruId;
#line 3304
  memset((void *)(& req), 0, sizeof(req));
#line 3305
  req.msg.netfn = (uint8_t )10;
#line 3306
  req.msg.cmd = (uint8_t )16;
#line 3307
  req.msg.data = msg_data;
#line 3308
  req.msg.data_len = (uint16_t )1;
#line 3310
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 3311
  if (! rsp) {
#line 3312
    return;
  }
#line 3314
  if ((int )rsp->ccode > 0) {
#line 3315
    if ((int )rsp->ccode == 195) {
      {
#line 3316
      printf((char const   */* __restrict  */)"  Timeout accessing FRU info. (Device not present?)\n");
      }
    }
#line 3317
    return;
  }
#line 3319
  fru.size = (uint16_t )(((int )rsp->data[1] << 8) | (int )rsp->data[0]);
#line 3320
  fru.access = (uint8_t )((int )rsp->data[2] & 1);
#line 3322
  if (verbose) {
    {
#line 3323
    printf((char const   */* __restrict  */)"Fru Size   = %d bytes\n", (int )fru.size);
#line 3324
    printf((char const   */* __restrict  */)"Fru Access = %xh\n", (int )fru.access);
    }
  }
  {
#line 3327
  tmp = malloc((size_t )fru.size);
#line 3327
  pFruBuf = (uint8_t *)tmp;
  }
#line 3328
  if ((unsigned long )pFruBuf != (unsigned long )((void *)0)) {
    {
#line 3329
    printf((char const   */* __restrict  */)"Fru Size         : %d bytes\n", (int )fru.size);
#line 3330
    read_fru_area(intf, & fru, fruId, (uint32_t )0, (uint32_t )fru.size, pFruBuf);
    }
  } else {
    {
#line 3332
    lprintf(3, "Cannot allocate %d bytes\n", (int )fru.size);
    }
#line 3333
    return;
  }
#line 3336
  if ((unsigned long )pFruBuf != (unsigned long )((void *)0)) {
    {
#line 3339
    pFile = fopen((char const   */* __restrict  */)pFileName, (char const   */* __restrict  */)"wb");
    }
#line 3340
    if (pFile) {
      {
#line 3341
      fwrite((void const   */* __restrict  */)pFruBuf, (size_t )fru.size, (size_t )1,
             (FILE */* __restrict  */)pFile);
#line 3342
      printf((char const   */* __restrict  */)"Done\n");
      }
    } else {
      {
#line 3344
      lprintf(3, "Error opening file %s\n", pFileName);
#line 3345
      free((void *)pFruBuf);
#line 3346
      pFruBuf = (uint8_t *)((void *)0);
      }
#line 3347
      return;
    }
    {
#line 3349
    fclose(pFile);
    }
  }
  {
#line 3351
  free((void *)pFruBuf);
#line 3352
  pFruBuf = (uint8_t *)((void *)0);
  }
#line 3353
  return;
}
}
#line 3355 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static void ipmi_fru_write_from_bin___0(struct ipmi_intf *intf , char *pFileName ,
                                        uint8_t fruId ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct fru_info fru ;
  uint8_t msg_data[4] ;
  uint8_t *pFruBuf ;
  uint16_t len ;
  FILE *pFile ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 3365
  len = (uint16_t )0;
#line 3368
  msg_data[0] = fruId;
#line 3370
  memset((void *)(& req), 0, sizeof(req));
#line 3371
  req.msg.netfn = (uint8_t )10;
#line 3372
  req.msg.cmd = (uint8_t )16;
#line 3373
  req.msg.data = msg_data;
#line 3374
  req.msg.data_len = (uint16_t )1;
#line 3376
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 3377
  if (! rsp) {
#line 3378
    return;
  }
#line 3380
  if (rsp->ccode) {
#line 3381
    if ((int )rsp->ccode == 195) {
      {
#line 3382
      printf((char const   */* __restrict  */)"  Timeout accessing FRU info. (Device not present?)\n");
      }
    }
#line 3383
    return;
  }
#line 3385
  fru.size = (uint16_t )(((int )rsp->data[1] << 8) | (int )rsp->data[0]);
#line 3386
  fru.access = (uint8_t )((int )rsp->data[2] & 1);
#line 3388
  if (verbose) {
    {
#line 3389
    printf((char const   */* __restrict  */)"Fru Size   = %d bytes\n", (int )fru.size);
#line 3390
    printf((char const   */* __restrict  */)"Fru Access = %xh\n", (int )fru.access);
    }
  }
  {
#line 3393
  tmp = malloc((size_t )fru.size);
#line 3393
  pFruBuf = (uint8_t *)tmp;
  }
#line 3394
  if ((unsigned long )pFruBuf == (unsigned long )((void *)0)) {
    {
#line 3395
    lprintf(3, "Cannot allocate %d bytes\n", (int )fru.size);
    }
#line 3396
    return;
  }
  {
#line 3399
  pFile = fopen((char const   */* __restrict  */)pFileName, (char const   */* __restrict  */)"rb");
  }
#line 3400
  if ((unsigned long )pFile != (unsigned long )((void *)0)) {
    {
#line 3401
    tmp___0 = fread((void */* __restrict  */)pFruBuf, (size_t )1, (size_t )fru.size,
                    (FILE */* __restrict  */)pFile);
#line 3401
    len = (uint16_t )tmp___0;
#line 3402
    printf((char const   */* __restrict  */)"Fru Size         : %d bytes\n", (int )fru.size);
#line 3403
    printf((char const   */* __restrict  */)"Size to Write    : %d bytes\n", (int )len);
#line 3404
    fclose(pFile);
    }
  } else {
    {
#line 3406
    lprintf(3, "Error opening file %s\n", pFileName);
    }
  }
#line 3409
  if ((int )len != 0) {
    {
#line 3410
    write_fru_area(intf, & fru, fruId, (uint16_t )0, (uint16_t )0, len, pFruBuf);
#line 3411
    lprintf(6, "Done");
    }
  }
  {
#line 3414
  free((void *)pFruBuf);
#line 3415
  pFruBuf = (uint8_t *)((void *)0);
  }
#line 3416
  return;
}
}
#line 3452 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_edit_multirec___0(struct ipmi_intf *intf , uint8_t id , int argc ,
                                      char **argv ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct fru_info fru ;
  struct fru_header header ;
  uint8_t msg_data[4] ;
  uint16_t retStatus ;
  uint32_t offFruMultiRec ;
  uint32_t fruMultiRecSize ;
  struct fru_info fruInfo ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  uint8_t *fru_data ;
  uint32_t fru_len ;
  uint32_t i ;
  uint32_t offset ;
  struct fru_multirec_header *h ;
  uint32_t last_off ;
  uint32_t len ;
  uint8_t error ;
  void *tmp___2 ;
  int tmp___3 ;
  struct fru_multirec_oem_header *oh ;
  uint32_t iana ;
  uint32_t suppliedIana ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 3463
  retStatus = (uint16_t )0;
#line 3465
  fruMultiRecSize = (uint32_t )0;
#line 3467
  tmp = ipmi_fru_get_multirec_location_from_fru___0(intf, id, & fruInfo, & offFruMultiRec,
                                                    & fruMultiRecSize);
#line 3467
  retStatus = (uint16_t )tmp;
#line 3472
  lprintf(7, "FRU Size        : %lu\n", fruMultiRecSize);
#line 3473
  lprintf(7, "Multi Rec offset: %lu\n", offFruMultiRec);
#line 3478
  memset((void *)(& fru), 0, sizeof(struct fru_info ));
#line 3479
  memset((void *)(& header), 0, sizeof(struct fru_header ));
#line 3484
  memset((void *)(msg_data), 0, (size_t )4);
#line 3485
  msg_data[0] = id;
#line 3487
  memset((void *)(& req), 0, sizeof(req));
#line 3488
  req.msg.netfn = (uint8_t )10;
#line 3489
  req.msg.cmd = (uint8_t )16;
#line 3490
  req.msg.data = msg_data;
#line 3491
  req.msg.data_len = (uint16_t )1;
#line 3493
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 3494
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 3495
    printf((char const   */* __restrict  */)" Device not present (No Response)\n");
    }
#line 3496
    return (-1);
  }
#line 3498
  if ((int )rsp->ccode > 0) {
    {
#line 3499
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3499
    printf((char const   */* __restrict  */)" Device not present (%s)\n", tmp___0);
    }
#line 3501
    return (-1);
  }
#line 3504
  fru.size = (uint16_t )(((int )rsp->data[1] << 8) | (int )rsp->data[0]);
#line 3505
  fru.access = (uint8_t )((int )rsp->data[2] & 1);
#line 3507
  if (fru.access) {
#line 3507
    tmp___1 = "words";
  } else {
#line 3507
    tmp___1 = "bytes";
  }
  {
#line 3507
  lprintf(7, "fru.size = %d bytes (accessed by %s)", (int )fru.size, tmp___1);
  }
#line 3510
  if ((int )fru.size < 1) {
    {
#line 3511
    lprintf(3, " Invalid FRU size %d", (int )fru.size);
    }
#line 3512
    return (-1);
  }
  {
#line 3519
  offset = offFruMultiRec;
#line 3522
  error = (uint8_t )0;
#line 3524
  last_off = offset;
#line 3524
  i = last_off;
#line 3525
  fru_len = (uint32_t )0;
#line 3527
  tmp___2 = malloc((size_t )((int )fru.size + 1));
#line 3527
  fru_data = (uint8_t *)tmp___2;
  }
#line 3528
  if ((unsigned long )fru_data == (unsigned long )((void *)0)) {
    {
#line 3529
    lprintf(3, " Out of memory!");
    }
#line 3530
    return (-1);
  }
  {
#line 3532
  memset((void *)fru_data, 0, (size_t )((int )fru.size + 1));
  }
  {
#line 3534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3535
    h = (struct fru_multirec_header *)(fru_data + i);
#line 3538
    if ((unsigned long )last_off < (unsigned long )i + sizeof(*h)) {
#line 3538
      goto _L;
    } else
#line 3538
    if (last_off < i + (uint32_t )h->len) {
      _L: /* CIL Label */ 
#line 3540
      len = (uint32_t )fru.size - last_off;
#line 3541
      if ((unsigned long )len > 255UL + sizeof(struct fru_multirec_header )) {
#line 3542
        len = (uint32_t )(255UL + sizeof(struct fru_multirec_header ));
      }
      {
#line 3544
      tmp___3 = read_fru_area(intf, & fru, id, last_off, len, fru_data);
      }
#line 3544
      if (tmp___3 < 0) {
#line 3545
        goto while_break;
      }
#line 3547
      last_off += len;
    }
#line 3549
    if ((int )h->type == 192) {
#line 3551
      oh = (struct fru_multirec_oem_header *)(fru_data + ((unsigned long )i + sizeof(struct fru_multirec_header )));
#line 3553
      iana = (uint32_t )(((int )oh->mfg_id[0] | ((int )oh->mfg_id[1] << 8)) | ((int )oh->mfg_id[2] << 16));
#line 3555
      suppliedIana = (uint32_t )0;
#line 3559
      if (argc <= 2) {
#line 3560
        suppliedIana = (uint32_t )12634;
      } else {
        {
#line 3562
        tmp___5 = strncmp((char const   *)*(argv + 2), "oem", (size_t )3);
        }
#line 3562
        if (! tmp___5) {
#line 3564
          if (argc <= 3) {
            {
#line 3565
            lprintf(3, "oem iana <record> <format> [<args>]");
#line 3566
            error = (uint8_t )1;
            }
          } else {
            {
#line 3568
            tmp___4 = str2uint((char const   *)*(argv + 3), & suppliedIana);
            }
#line 3568
            if (tmp___4 == 0) {
              {
#line 3569
              lprintf(7, "using iana: %d", suppliedIana);
              }
            } else {
              {
#line 3573
              lprintf(3, "Given IANA \'%s\' is invalid.", *(argv + 3));
#line 3576
              error = (uint8_t )1;
              }
            }
          }
        }
      }
#line 3582
      if (suppliedIana == iana) {
        {
#line 3583
        lprintf(7, "Matching record found");
        }
#line 3585
        if (iana == 12634U) {
          {
#line 3586
          tmp___6 = ipmi_fru_picmg_ext_edit___0(fru_data, (int )((unsigned long )i + sizeof(struct fru_multirec_header )),
                                                (int )h->len, h, oh);
          }
#line 3586
          if (tmp___6) {
            {
#line 3590
            write_fru_area(intf, & fru, id, (uint16_t )i, (uint16_t )i, (uint16_t )((unsigned long )h->len + sizeof(struct fru_multirec_header )),
                           fru_data);
            }
          }
        } else
#line 3594
        if (iana == 15000U) {
          {
#line 3595
          tmp___7 = ipmi_fru_oemkontron_edit___0(argc, argv, fru_data, (int )((unsigned long )i + sizeof(struct fru_multirec_header )),
                                                 (int )h->len, h, oh);
          }
#line 3595
          if (tmp___7) {
            {
#line 3599
            write_fru_area(intf, & fru, id, (uint16_t )i, (uint16_t )i, (uint16_t )((unsigned long )h->len + sizeof(struct fru_multirec_header )),
                           fru_data);
            }
          }
        } else {
          {
#line 3605
          tmp___8 = val2str((uint16_t )iana, ipmi_oem_info);
#line 3605
          printf((char const   */* __restrict  */)"  OEM IANA (%s) Record not support in this mode\n",
                 tmp___8);
#line 3607
          error = (uint8_t )1;
          }
        }
      }
    }
#line 3611
    i = (uint32_t )((unsigned long )i + ((unsigned long )h->len + sizeof(struct fru_multirec_header )));
#line 3534
    if (! ((int )h->format & 128)) {
#line 3534
      if (! ((int )error != 1)) {
#line 3534
        goto while_break;
      }
    } else {
#line 3534
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3614
  free((void *)fru_data);
#line 3615
  fru_data = (uint8_t *)((void *)0);
  }
#line 3617
  return (0);
}
}
#line 3653 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_get_multirec___0(struct ipmi_intf *intf , uint8_t id , int argc ,
                                     char **argv ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct fru_info fru ;
  struct fru_header header ;
  uint8_t msg_data[4] ;
  uint16_t retStatus ;
  uint32_t offFruMultiRec ;
  uint32_t fruMultiRecSize ;
  struct fru_info fruInfo ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  uint8_t *fru_data ;
  uint32_t fru_len ;
  uint32_t i ;
  uint32_t offset ;
  struct fru_multirec_header *h ;
  uint32_t last_off ;
  uint32_t len ;
  uint8_t error ;
  void *tmp___2 ;
  int tmp___3 ;
  struct fru_multirec_oem_header *oh ;
  uint32_t iana ;
  uint32_t suppliedIana ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;

  {
  {
#line 3664
  retStatus = (uint16_t )0;
#line 3666
  fruMultiRecSize = (uint32_t )0;
#line 3668
  tmp = ipmi_fru_get_multirec_location_from_fru___0(intf, id, & fruInfo, & offFruMultiRec,
                                                    & fruMultiRecSize);
#line 3668
  retStatus = (uint16_t )tmp;
#line 3673
  lprintf(7, "FRU Size        : %lu\n", fruMultiRecSize);
#line 3674
  lprintf(7, "Multi Rec offset: %lu\n", offFruMultiRec);
#line 3679
  memset((void *)(& fru), 0, sizeof(struct fru_info ));
#line 3680
  memset((void *)(& header), 0, sizeof(struct fru_header ));
#line 3685
  memset((void *)(msg_data), 0, (size_t )4);
#line 3686
  msg_data[0] = id;
#line 3688
  memset((void *)(& req), 0, sizeof(req));
#line 3689
  req.msg.netfn = (uint8_t )10;
#line 3690
  req.msg.cmd = (uint8_t )16;
#line 3691
  req.msg.data = msg_data;
#line 3692
  req.msg.data_len = (uint16_t )1;
#line 3694
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 3695
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 3696
    printf((char const   */* __restrict  */)" Device not present (No Response)\n");
    }
#line 3697
    return (-1);
  }
#line 3699
  if ((int )rsp->ccode > 0) {
    {
#line 3700
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3700
    printf((char const   */* __restrict  */)" Device not present (%s)\n", tmp___0);
    }
#line 3702
    return (-1);
  }
#line 3705
  fru.size = (uint16_t )(((int )rsp->data[1] << 8) | (int )rsp->data[0]);
#line 3706
  fru.access = (uint8_t )((int )rsp->data[2] & 1);
#line 3708
  if (fru.access) {
#line 3708
    tmp___1 = "words";
  } else {
#line 3708
    tmp___1 = "bytes";
  }
  {
#line 3708
  lprintf(7, "fru.size = %d bytes (accessed by %s)", (int )fru.size, tmp___1);
  }
#line 3711
  if ((int )fru.size < 1) {
    {
#line 3712
    lprintf(3, " Invalid FRU size %d", (int )fru.size);
    }
#line 3713
    return (-1);
  }
  {
#line 3720
  offset = offFruMultiRec;
#line 3723
  error = (uint8_t )0;
#line 3725
  last_off = offset;
#line 3725
  i = last_off;
#line 3726
  fru_len = (uint32_t )0;
#line 3728
  tmp___2 = malloc((size_t )((int )fru.size + 1));
#line 3728
  fru_data = (uint8_t *)tmp___2;
  }
#line 3729
  if ((unsigned long )fru_data == (unsigned long )((void *)0)) {
    {
#line 3730
    lprintf(3, " Out of memory!");
    }
#line 3731
    return (-1);
  }
  {
#line 3733
  memset((void *)fru_data, 0, (size_t )((int )fru.size + 1));
  }
  {
#line 3735
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3736
    h = (struct fru_multirec_header *)(fru_data + i);
#line 3739
    if ((unsigned long )last_off < (unsigned long )i + sizeof(*h)) {
#line 3739
      goto _L;
    } else
#line 3739
    if (last_off < i + (uint32_t )h->len) {
      _L: /* CIL Label */ 
#line 3741
      len = (uint32_t )fru.size - last_off;
#line 3742
      if ((unsigned long )len > 255UL + sizeof(struct fru_multirec_header )) {
#line 3743
        len = (uint32_t )(255UL + sizeof(struct fru_multirec_header ));
      }
      {
#line 3745
      tmp___3 = read_fru_area(intf, & fru, id, last_off, len, fru_data);
      }
#line 3745
      if (tmp___3 < 0) {
#line 3746
        goto while_break;
      }
#line 3748
      last_off += len;
    }
#line 3750
    if ((int )h->type == 192) {
      {
#line 3752
      oh = (struct fru_multirec_oem_header *)(fru_data + ((unsigned long )i + sizeof(struct fru_multirec_header )));
#line 3754
      iana = (uint32_t )(((int )oh->mfg_id[0] | ((int )oh->mfg_id[1] << 8)) | ((int )oh->mfg_id[2] << 16));
#line 3756
      suppliedIana = (uint32_t )0;
#line 3758
      tmp___5 = strncmp((char const   *)*(argv + 2), "oem", (size_t )3);
      }
#line 3758
      if (! tmp___5) {
#line 3760
        if (argc <= 3) {
          {
#line 3761
          lprintf(3, "oem iana <record> <format>");
#line 3762
          error = (uint8_t )1;
          }
        } else {
          {
#line 3764
          tmp___4 = str2uint((char const   *)*(argv + 3), & suppliedIana);
          }
#line 3764
          if (tmp___4 == 0) {
            {
#line 3765
            lprintf(7, "using iana: %d", suppliedIana);
            }
          } else {
            {
#line 3769
            lprintf(3, "Given IANA \'%s\' is invalid.", *(argv + 3));
#line 3772
            error = (uint8_t )1;
            }
          }
        }
      }
#line 3777
      if (suppliedIana == iana) {
        {
#line 3778
        lprintf(7, "Matching record found");
        }
#line 3780
        if (iana == 15000U) {
          {
#line 3781
          ipmi_fru_oemkontron_get___0(argc, argv, fru_data, (int )((unsigned long )i + sizeof(struct fru_multirec_header )),
                                      (int )h->len, h, oh);
          }
        } else {
          {
#line 3787
          tmp___6 = val2str((uint16_t )iana, ipmi_oem_info);
#line 3787
          printf((char const   */* __restrict  */)"  OEM IANA (%s) Record not supported in this mode\n",
                 tmp___6);
#line 3789
          error = (uint8_t )1;
          }
        }
      }
    }
#line 3793
    i = (uint32_t )((unsigned long )i + ((unsigned long )h->len + sizeof(struct fru_multirec_header )));
#line 3735
    if (! ((int )h->format & 128)) {
#line 3735
      if (! ((int )error != 1)) {
#line 3735
        goto while_break;
      }
    } else {
#line 3735
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3796
  free((void *)fru_data);
#line 3797
  fru_data = (uint8_t *)((void *)0);
  }
#line 3799
  return (0);
}
}
#line 3802 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_upg_ekeying___0(struct ipmi_intf *intf , char *pFileName , uint8_t fruId ) 
{ 
  struct fru_info fruInfo ;
  uint8_t *buf ;
  uint32_t offFruMultiRec ;
  uint32_t fruMultiRecSize ;
  uint32_t offFileMultiRec ;
  uint32_t fileMultiRecSize ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 3808
  buf = (uint8_t *)((void *)0);
#line 3809
  offFruMultiRec = (uint32_t )0;
#line 3810
  fruMultiRecSize = (uint32_t )0;
#line 3811
  offFileMultiRec = (uint32_t )0;
#line 3812
  fileMultiRecSize = (uint32_t )0;
#line 3813
  if ((unsigned long )pFileName == (unsigned long )((void *)0)) {
    {
#line 3814
    lprintf(3, "File expected, but none given.");
    }
#line 3815
    return (-1);
  }
  {
#line 3817
  tmp = ipmi_fru_get_multirec_location_from_fru___0(intf, fruId, & fruInfo, & offFruMultiRec,
                                                    & fruMultiRecSize);
  }
#line 3817
  if (tmp != 0) {
    {
#line 3819
    lprintf(3, "Failed to get multirec location from FRU.");
    }
#line 3820
    return (-1);
  }
  {
#line 3822
  lprintf(7, "FRU Size        : %lu\n", fruMultiRecSize);
#line 3823
  lprintf(7, "Multi Rec offset: %lu\n", offFruMultiRec);
#line 3824
  tmp___0 = ipmi_fru_get_multirec_size_from_file___0(pFileName, & fileMultiRecSize,
                                                     & offFileMultiRec);
  }
#line 3824
  if (tmp___0 != 0) {
    {
#line 3826
    lprintf(3, "Failed to get multirec size from file \'%s\'.", pFileName);
    }
#line 3827
    return (-1);
  }
  {
#line 3829
  tmp___1 = malloc((size_t )fileMultiRecSize);
#line 3829
  buf = (uint8_t *)tmp___1;
  }
#line 3830
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 3831
    lprintf(3, "ipmitool: malloc failure");
    }
#line 3832
    return (-1);
  }
  {
#line 3834
  tmp___2 = ipmi_fru_get_multirec_from_file___0(pFileName, buf, fileMultiRecSize,
                                                offFileMultiRec);
  }
#line 3834
  if (tmp___2 != 0) {
    {
#line 3836
    lprintf(3, "Failed to get multirec from file \'%s\'.", pFileName);
    }
#line 3837
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
      {
#line 3838
      free((void *)buf);
#line 3839
      buf = (uint8_t *)((void *)0);
      }
    }
#line 3841
    return (-1);
  }
  {
#line 3843
  tmp___3 = ipmi_fru_get_adjust_size_from_buffer(buf, & fileMultiRecSize);
  }
#line 3843
  if (tmp___3 != 0) {
    {
#line 3844
    lprintf(3, "Failed to adjust size from buffer.");
    }
#line 3845
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
      {
#line 3846
      free((void *)buf);
#line 3847
      buf = (uint8_t *)((void *)0);
      }
    }
#line 3849
    return (-1);
  }
  {
#line 3851
  tmp___4 = write_fru_area(intf, & fruInfo, fruId, (uint16_t )0, (uint16_t )offFruMultiRec,
                           (uint16_t )fileMultiRecSize, buf);
  }
#line 3851
  if (tmp___4 != 0) {
    {
#line 3853
    lprintf(3, "Failed to write FRU area.");
    }
#line 3854
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
      {
#line 3855
      free((void *)buf);
#line 3856
      buf = (uint8_t *)((void *)0);
      }
    }
#line 3858
    return (-1);
  }
#line 3860
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
    {
#line 3861
    free((void *)buf);
#line 3862
    buf = (uint8_t *)((void *)0);
    }
  }
  {
#line 3864
  lprintf(6, "Done upgrading Ekey.");
  }
#line 3865
  return (0);
}
}
#line 3880 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_get_multirec_size_from_file___0(char *pFileName , uint32_t *pSize ,
                                                    uint32_t *pOffset ) 
{ 
  struct fru_header header ;
  FILE *pFile ;
  uint8_t len ;
  uint32_t end ;
  size_t tmp ;
  long tmp___0 ;

  {
  {
#line 3887
  len = (uint8_t )0;
#line 3888
  end = (uint32_t )0;
#line 3889
  *pSize = (uint32_t )0;
#line 3891
  pFile = fopen((char const   */* __restrict  */)pFileName, (char const   */* __restrict  */)"rb");
  }
#line 3892
  if (pFile) {
    {
#line 3893
    rewind(pFile);
#line 3894
    tmp = fread((void */* __restrict  */)(& header), (size_t )1, (size_t )8, (FILE */* __restrict  */)pFile);
#line 3894
    len = (uint8_t )tmp;
#line 3895
    fseek(pFile, 0L, 2);
#line 3896
    tmp___0 = ftell(pFile);
#line 3896
    end = (uint32_t )tmp___0;
#line 3897
    fclose(pFile);
    }
  }
  {
#line 3900
  lprintf(7, "File Size = %lu\n", end);
#line 3901
  lprintf(7, "Len = %u\n", (int )len);
  }
#line 3903
  if ((int )len != 8) {
    {
#line 3904
    printf((char const   */* __restrict  */)"Error with file %s in getting size\n",
           pFileName);
    }
#line 3905
    return (-1);
  }
#line 3908
  if ((int )header.version != 1) {
    {
#line 3909
    printf((char const   */* __restrict  */)"Unknown FRU header version %02x.\n",
           (int )header.version);
    }
#line 3910
    return (-1);
  }
#line 3914
  if ((int )header.offset.internal * 8 > (int )header.offset.internal * 8) {
#line 3914
    if ((uint32_t )((int )header.offset.internal * 8) < end) {
#line 3916
      end = (uint32_t )((int )header.offset.internal * 8);
    }
  }
#line 3918
  if ((int )header.offset.chassis * 8 > (int )header.offset.chassis * 8) {
#line 3918
    if ((uint32_t )((int )header.offset.chassis * 8) < end) {
#line 3920
      end = (uint32_t )((int )header.offset.chassis * 8);
    }
  }
#line 3922
  if ((int )header.offset.board * 8 > (int )header.offset.board * 8) {
#line 3922
    if ((uint32_t )((int )header.offset.board * 8) < end) {
#line 3924
      end = (uint32_t )((int )header.offset.board * 8);
    }
  }
#line 3926
  if ((int )header.offset.product * 8 > (int )header.offset.product * 8) {
#line 3926
    if ((uint32_t )((int )header.offset.product * 8) < end) {
#line 3928
      end = (uint32_t )((int )header.offset.product * 8);
    }
  }
#line 3930
  *pSize = end - (uint32_t )((int )header.offset.multi * 8);
#line 3931
  *pOffset = (uint32_t )((int )header.offset.multi * 8);
#line 3933
  return (0);
}
}
#line 3985 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_get_multirec_from_file___0(char *pFileName , uint8_t *pBufArea ,
                                               uint32_t size , uint32_t offset ) 
{ 
  FILE *pFile ;
  uint32_t len ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;

  {
#line 3990
  len = (uint32_t )0;
#line 3991
  if ((unsigned long )pFileName == (unsigned long )((void *)0)) {
    {
#line 3992
    lprintf(3, "Invalid file name given.");
    }
#line 3993
    return (-1);
  }
  {
#line 3996
  tmp = __errno_location();
#line 3996
  *tmp = 0;
#line 3997
  pFile = fopen((char const   */* __restrict  */)pFileName, (char const   */* __restrict  */)"rb");
  }
#line 3998
  if (! pFile) {
    {
#line 3999
    tmp___0 = __errno_location();
#line 3999
    tmp___1 = strerror(*tmp___0);
#line 3999
    tmp___2 = __errno_location();
#line 3999
    lprintf(3, "Error opening file \'%s\': %i -> %s.", pFileName, *tmp___2, tmp___1);
    }
#line 4001
    return (-1);
  }
  {
#line 4003
  tmp___3 = __errno_location();
#line 4003
  *tmp___3 = 0;
#line 4004
  tmp___7 = fseek(pFile, (long )offset, 0);
  }
#line 4004
  if (tmp___7 != 0) {
    {
#line 4005
    tmp___4 = __errno_location();
#line 4005
    tmp___5 = strerror(*tmp___4);
#line 4005
    tmp___6 = __errno_location();
#line 4005
    lprintf(3, "Failed to seek in file \'%s\': %i -> %s.", pFileName, *tmp___6, tmp___5);
#line 4007
    fclose(pFile);
    }
#line 4008
    return (-1);
  }
  {
#line 4010
  tmp___8 = fread((void */* __restrict  */)pBufArea, (size_t )size, (size_t )1, (FILE */* __restrict  */)pFile);
#line 4010
  len = (uint32_t )tmp___8;
#line 4011
  fclose(pFile);
  }
#line 4013
  if (len != 1U) {
    {
#line 4014
    lprintf(3, "Error in file \'%s\'.", pFileName);
    }
#line 4015
    return (-1);
  }
#line 4017
  return (0);
}
}
#line 4020 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_get_multirec_location_from_fru___0(struct ipmi_intf *intf , uint8_t fruId ,
                                                       struct fru_info *pFruInfo ,
                                                       uint32_t *pRetLocation , uint32_t *pRetSize ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[4] ;
  uint32_t end ;
  struct fru_header header ;
  char const   *tmp ;

  {
  {
#line 4033
  *pRetLocation = (uint32_t )0;
#line 4035
  msg_data[0] = fruId;
#line 4037
  memset((void *)(& req), 0, sizeof(req));
#line 4038
  req.msg.netfn = (uint8_t )10;
#line 4039
  req.msg.cmd = (uint8_t )16;
#line 4040
  req.msg.data = msg_data;
#line 4041
  req.msg.data_len = (uint16_t )1;
#line 4043
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 4044
  if (! rsp) {
#line 4045
    if (verbose > 1) {
      {
#line 4046
      printf((char const   */* __restrict  */)"no response\n");
      }
    }
#line 4047
    return (-1);
  }
#line 4050
  if ((int )rsp->ccode > 0) {
#line 4051
    if ((int )rsp->ccode == 195) {
      {
#line 4052
      printf((char const   */* __restrict  */)"  Timeout accessing FRU info. (Device not present?)\n");
      }
    } else {
      {
#line 4054
      printf((char const   */* __restrict  */)"   CCODE = 0x%02x\n", (int )rsp->ccode);
      }
    }
#line 4055
    return (-1);
  }
#line 4057
  pFruInfo->size = (uint16_t )(((int )rsp->data[1] << 8) | (int )rsp->data[0]);
#line 4058
  pFruInfo->access = (uint8_t )((int )rsp->data[2] & 1);
#line 4060
  if (verbose > 1) {
#line 4061
    if (pFruInfo->access) {
#line 4061
      tmp = "words";
    } else {
#line 4061
      tmp = "bytes";
    }
    {
#line 4061
    printf((char const   */* __restrict  */)"pFruInfo->size = %d bytes (accessed by %s)\n",
           (int )pFruInfo->size, tmp);
    }
  }
#line 4064
  if (! pFruInfo->size) {
#line 4065
    return (-1);
  }
  {
#line 4067
  msg_data[0] = fruId;
#line 4068
  msg_data[1] = (uint8_t )0;
#line 4069
  msg_data[2] = (uint8_t )0;
#line 4070
  msg_data[3] = (uint8_t )8;
#line 4072
  memset((void *)(& req), 0, sizeof(req));
#line 4073
  req.msg.netfn = (uint8_t )10;
#line 4074
  req.msg.cmd = (uint8_t )17;
#line 4075
  req.msg.data = msg_data;
#line 4076
  req.msg.data_len = (uint16_t )4;
#line 4078
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 4080
  if (! rsp) {
#line 4081
    return (-1);
  }
#line 4082
  if ((int )rsp->ccode > 0) {
#line 4083
    if ((int )rsp->ccode == 195) {
      {
#line 4084
      printf((char const   */* __restrict  */)"  Timeout while reading FRU data. (Device not present?)\n");
      }
    }
#line 4085
    return (-1);
  }
#line 4088
  if (verbose > 1) {
    {
#line 4089
    printbuf((uint8_t const   *)(rsp->data), rsp->data_len, "FRU DATA");
    }
  }
  {
#line 4091
  memcpy((void */* __restrict  */)(& header), (void const   */* __restrict  */)(rsp->data + 1),
         (size_t )8);
  }
#line 4093
  if ((int )header.version != 1) {
    {
#line 4094
    printf((char const   */* __restrict  */)"  Unknown FRU header version %02x.\n",
           (int )header.version);
    }
#line 4095
    return (-1);
  }
#line 4098
  end = (uint32_t )pFruInfo->size;
#line 4101
  if ((int )header.offset.internal * 8 > (int )header.offset.internal * 8) {
#line 4101
    if ((uint32_t )((int )header.offset.internal * 8) < end) {
#line 4103
      end = (uint32_t )((int )header.offset.internal * 8);
    }
  }
#line 4105
  if ((int )header.offset.chassis * 8 > (int )header.offset.chassis * 8) {
#line 4105
    if ((uint32_t )((int )header.offset.chassis * 8) < end) {
#line 4107
      end = (uint32_t )((int )header.offset.chassis * 8);
    }
  }
#line 4109
  if ((int )header.offset.board * 8 > (int )header.offset.board * 8) {
#line 4109
    if ((uint32_t )((int )header.offset.board * 8) < end) {
#line 4111
      end = (uint32_t )((int )header.offset.board * 8);
    }
  }
#line 4113
  if ((int )header.offset.product * 8 > (int )header.offset.product * 8) {
#line 4113
    if ((uint32_t )((int )header.offset.product * 8) < end) {
#line 4115
      end = (uint32_t )((int )header.offset.product * 8);
    }
  }
#line 4117
  *pRetSize = end;
#line 4118
  *pRetLocation = (uint32_t )(8 * (int )header.offset.multi);
#line 4120
  return (0);
}
}
#line 4132 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_get_internal_use_info___0(struct ipmi_intf *intf , uint8_t id ,
                                              struct fru_info *fru , uint16_t *size ,
                                              uint16_t *offset ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct fru_header header ;
  uint8_t msg_data[4] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 4145
  *offset = (uint16_t )0;
#line 4146
  *size = (uint16_t )0;
#line 4148
  memset((void *)fru, 0, sizeof(struct fru_info ));
#line 4149
  memset((void *)(& header), 0, sizeof(struct fru_header ));
#line 4154
  memset((void *)(msg_data), 0, (size_t )4);
#line 4155
  msg_data[0] = id;
#line 4157
  memset((void *)(& req), 0, sizeof(req));
#line 4158
  req.msg.netfn = (uint8_t )10;
#line 4159
  req.msg.cmd = (uint8_t )16;
#line 4160
  req.msg.data = msg_data;
#line 4161
  req.msg.data_len = (uint16_t )1;
#line 4163
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 4164
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 4165
    printf((char const   */* __restrict  */)" Device not present (No Response)\n");
    }
#line 4166
    return (-1);
  }
#line 4168
  if ((int )rsp->ccode > 0) {
    {
#line 4169
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 4169
    printf((char const   */* __restrict  */)" Device not present (%s)\n", tmp);
    }
#line 4171
    return (-1);
  }
#line 4174
  fru->size = (uint16_t )(((int )rsp->data[1] << 8) | (int )rsp->data[0]);
#line 4175
  fru->access = (uint8_t )((int )rsp->data[2] & 1);
#line 4177
  if (fru->access) {
#line 4177
    tmp___0 = "words";
  } else {
#line 4177
    tmp___0 = "bytes";
  }
  {
#line 4177
  lprintf(7, "fru.size = %d bytes (accessed by %s)", (int )fru->size, tmp___0);
  }
#line 4180
  if ((int )fru->size < 1) {
    {
#line 4181
    lprintf(3, " Invalid FRU size %d", (int )fru->size);
    }
#line 4182
    return (-1);
  }
  {
#line 4188
  msg_data[0] = id;
#line 4189
  msg_data[1] = (uint8_t )0;
#line 4190
  msg_data[2] = (uint8_t )0;
#line 4191
  msg_data[3] = (uint8_t )8;
#line 4193
  memset((void *)(& req), 0, sizeof(req));
#line 4194
  req.msg.netfn = (uint8_t )10;
#line 4195
  req.msg.cmd = (uint8_t )17;
#line 4196
  req.msg.data = msg_data;
#line 4197
  req.msg.data_len = (uint16_t )4;
#line 4199
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 4200
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 4201
    printf((char const   */* __restrict  */)" Device not present (No Response)\n");
    }
#line 4202
    return (1);
  }
#line 4204
  if ((int )rsp->ccode > 0) {
    {
#line 4205
    tmp___1 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 4205
    printf((char const   */* __restrict  */)" Device not present (%s)\n", tmp___1);
    }
#line 4207
    return (1);
  }
#line 4210
  if (verbose > 1) {
    {
#line 4211
    printbuf((uint8_t const   *)(rsp->data), rsp->data_len, "FRU DATA");
    }
  }
  {
#line 4213
  memcpy((void */* __restrict  */)(& header), (void const   */* __restrict  */)(rsp->data + 1),
         (size_t )8);
  }
#line 4215
  if ((int )header.version != 1) {
    {
#line 4216
    lprintf(3, " Unknown FRU header version 0x%02x", (int )header.version);
    }
#line 4218
    return (-1);
  }
  {
#line 4221
  lprintf(7, "fru.header.version:         0x%x", (int )header.version);
#line 4223
  lprintf(7, "fru.header.offset.internal: 0x%x", (int )header.offset.internal * 8);
#line 4225
  lprintf(7, "fru.header.offset.chassis:  0x%x", (int )header.offset.chassis * 8);
#line 4227
  lprintf(7, "fru.header.offset.board:    0x%x", (int )header.offset.board * 8);
#line 4229
  lprintf(7, "fru.header.offset.product:  0x%x", (int )header.offset.product * 8);
#line 4231
  lprintf(7, "fru.header.offset.multi:    0x%x", (int )header.offset.multi * 8);
  }
#line 4234
  if ((int )header.offset.internal * 8 == 0) {
#line 4236
    *size = (uint16_t )0;
#line 4237
    *offset = (uint16_t )0;
  } else {
#line 4241
    *offset = (uint16_t )((int )header.offset.internal * 8);
#line 4243
    if ((int )header.offset.chassis != 0) {
#line 4245
      *size = (uint16_t )((int )header.offset.chassis * 8 - (int )*offset);
    } else
#line 4247
    if ((int )header.offset.board != 0) {
#line 4249
      *size = (uint16_t )((int )header.offset.board * 8 - (int )*offset);
    } else
#line 4251
    if ((int )header.offset.product != 0) {
#line 4253
      *size = (uint16_t )((int )header.offset.product * 8 - (int )*offset);
    } else
#line 4255
    if ((int )header.offset.multi != 0) {
#line 4257
      *size = (uint16_t )((int )header.offset.multi * 8 - (int )*offset);
    } else {
#line 4261
      *size = (uint16_t )((int )fru->size - (int )*offset);
    }
  }
#line 4264
  return (0);
}
}
#line 4276 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_info_internal_use___0(struct ipmi_intf *intf , uint8_t id ) 
{ 
  struct fru_info fru ;
  uint16_t size ;
  uint16_t offset ;
  int rc ;

  {
  {
#line 4282
  rc = 0;
#line 4284
  rc = ipmi_fru_get_internal_use_info___0(intf, id, & fru, & size, & offset);
  }
#line 4286
  if (rc == 0) {
    {
#line 4288
    lprintf(7, "Internal Use Area Offset: %i", (int )offset);
#line 4289
    printf((char const   */* __restrict  */)"Internal Use Area Size  : %i\n", (int )size);
    }
  } else {
    {
#line 4293
    lprintf(3, "Cannot access internal use area");
    }
#line 4294
    return (-1);
  }
#line 4296
  return (0);
}
}
#line 4319 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_read_internal_use___0(struct ipmi_intf *intf , uint8_t id , char *pFileName ) 
{ 
  struct fru_info fru ;
  uint16_t size ;
  uint16_t offset ;
  int rc ;
  uint8_t *frubuf ;
  void *tmp ;
  uint16_t counter ;
  FILE *pFile ;

  {
  {
#line 4325
  rc = 0;
#line 4327
  rc = ipmi_fru_get_internal_use_info___0(intf, id, & fru, & size, & offset);
  }
#line 4329
  if (rc == 0) {
    {
#line 4333
    lprintf(7, "Internal Use Area Offset: %i", (int )offset);
#line 4334
    printf((char const   */* __restrict  */)"Internal Use Area Size  : %i\n", (int )size);
#line 4336
    tmp = malloc((size_t )size);
#line 4336
    frubuf = (uint8_t *)tmp;
    }
#line 4337
    if (frubuf) {
      {
#line 4339
      rc = read_fru_area_section(intf, & fru, id, (uint32_t )offset, (uint32_t )size,
                                 frubuf);
      }
#line 4341
      if (rc == 0) {
#line 4343
        if ((unsigned long )pFileName == (unsigned long )((void *)0)) {
#line 4346
          counter = (uint16_t )0;
          {
#line 4346
          while (1) {
            while_continue: /* CIL Label */ ;
#line 4346
            if (! ((int )counter < (int )size)) {
#line 4346
              goto while_break;
            }
#line 4348
            if ((int )counter % 16 == 0) {
              {
#line 4349
              printf((char const   */* __restrict  */)"\n%02i- ", (int )counter / 16);
              }
            }
            {
#line 4350
            printf((char const   */* __restrict  */)"%02X ", (int )*(frubuf + counter));
#line 4346
            counter = (uint16_t )((int )counter + 1);
            }
          }
          while_break: /* CIL Label */ ;
          }
        } else {
          {
#line 4356
          pFile = fopen((char const   */* __restrict  */)pFileName, (char const   */* __restrict  */)"wb");
          }
#line 4357
          if (pFile) {
            {
#line 4359
            fwrite((void const   */* __restrict  */)frubuf, (size_t )size, (size_t )1,
                   (FILE */* __restrict  */)pFile);
#line 4360
            printf((char const   */* __restrict  */)"Done\n");
            }
          } else {
            {
#line 4364
            lprintf(3, "Error opening file %s\n", pFileName);
#line 4365
            free((void *)frubuf);
#line 4366
            frubuf = (uint8_t *)((void *)0);
            }
#line 4367
            return (-1);
          }
          {
#line 4369
          fclose(pFile);
          }
        }
      }
      {
#line 4372
      printf((char const   */* __restrict  */)"\n");
#line 4374
      free((void *)frubuf);
#line 4375
      frubuf = (uint8_t *)((void *)0);
      }
    }
  } else {
    {
#line 4381
    lprintf(3, "Cannot access internal use area");
    }
  }
#line 4383
  return (0);
}
}
#line 4395 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_write_internal_use___0(struct ipmi_intf *intf , uint8_t id , char *pFileName ) 
{ 
  struct fru_info fru ;
  uint16_t size ;
  uint16_t offset ;
  int rc ;
  uint8_t *frubuf ;
  FILE *fp ;
  uint32_t fileLength ;
  long tmp ;
  void *tmp___0 ;
  uint16_t fru_read_size ;
  size_t tmp___1 ;

  {
  {
#line 4401
  rc = 0;
#line 4403
  rc = ipmi_fru_get_internal_use_info___0(intf, id, & fru, & size, & offset);
  }
#line 4405
  if (rc == 0) {
    {
#line 4409
    fileLength = (uint32_t )0;
#line 4411
    lprintf(7, "Internal Use Area Offset: %i", (int )offset);
#line 4412
    printf((char const   */* __restrict  */)"Internal Use Area Size  : %i\n", (int )size);
#line 4414
    fp = fopen((char const   */* __restrict  */)pFileName, (char const   */* __restrict  */)"r");
    }
#line 4416
    if (fp) {
      {
#line 4419
      fseek(fp, 0L, 2);
#line 4420
      tmp = ftell(fp);
#line 4420
      fileLength = (uint32_t )tmp;
#line 4422
      lprintf(3, "File Size: %i", fileLength);
#line 4423
      lprintf(3, "Area Size: %i", (int )size);
      }
#line 4424
      if (fileLength != (uint32_t )size) {
        {
#line 4426
        lprintf(3, "File size does not fit Eeprom Size");
#line 4427
        fclose(fp);
#line 4428
        fp = (FILE *)((void *)0);
        }
      } else {
        {
#line 4432
        fseek(fp, 0L, 0);
        }
      }
    }
#line 4436
    if (fp) {
      {
#line 4438
      tmp___0 = malloc((size_t )size);
#line 4438
      frubuf = (uint8_t *)tmp___0;
      }
#line 4439
      if (frubuf) {
        {
#line 4442
        tmp___1 = fread((void */* __restrict  */)frubuf, (size_t )1, (size_t )size,
                        (FILE */* __restrict  */)fp);
#line 4442
        fru_read_size = (uint16_t )tmp___1;
        }
#line 4444
        if ((int )fru_read_size == (int )size) {
          {
#line 4446
          rc = write_fru_area(intf, & fru, id, (uint16_t )0, offset, size, frubuf);
          }
#line 4448
          if (rc == 0) {
            {
#line 4450
            lprintf(6, "Done\n");
            }
          }
        } else {
          {
#line 4455
          lprintf(3, "Unable to read file: %i\n", (int )fru_read_size);
          }
        }
        {
#line 4458
        free((void *)frubuf);
#line 4459
        frubuf = (uint8_t *)((void *)0);
        }
      }
      {
#line 4461
      fclose(fp);
#line 4462
      fp = (FILE *)((void *)0);
      }
    }
  } else {
    {
#line 4467
    lprintf(3, "Cannot access internal use area");
    }
  }
#line 4469
  return (0);
}
}
#line 4718 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_set_field_string___0(struct ipmi_intf *intf , unsigned char fruId ,
                                         uint8_t f_type , uint8_t f_index , char *f_string ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct fru_info fru ;
  struct fru_header header ;
  uint8_t msg_data[4] ;
  uint8_t checksum ;
  int i ;
  int rc ;
  uint8_t *fru_data ;
  uint8_t *fru_area ;
  uint32_t fru_field_offset ;
  uint32_t fru_field_offset_tmp ;
  uint32_t fru_section_len ;
  uint32_t header_offset ;
  char const   *tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;

  {
  {
#line 4729
  i = 0;
#line 4730
  rc = 1;
#line 4731
  fru_data = (uint8_t *)((void *)0);
#line 4732
  fru_area = (uint8_t *)((void *)0);
#line 4736
  memset((void *)(msg_data), 0, (size_t )4);
#line 4737
  msg_data[0] = fruId;
#line 4739
  memset((void *)(& req), 0, sizeof(req));
#line 4740
  req.msg.netfn = (uint8_t )10;
#line 4741
  req.msg.cmd = (uint8_t )16;
#line 4742
  req.msg.data = msg_data;
#line 4743
  req.msg.data_len = (uint16_t )1;
#line 4745
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 4746
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 4747
    printf((char const   */* __restrict  */)" Device not present (No Response)\n");
#line 4748
    rc = -1;
    }
#line 4749
    goto ipmi_fru_set_field_string_out;
  }
#line 4751
  if ((int )rsp->ccode > 0) {
    {
#line 4752
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 4752
    printf((char const   */* __restrict  */)" Device not present (%s)\n", tmp);
#line 4754
    rc = -1;
    }
#line 4755
    goto ipmi_fru_set_field_string_out;
  }
#line 4758
  fru.size = (uint16_t )(((int )rsp->data[1] << 8) | (int )rsp->data[0]);
#line 4759
  fru.access = (uint8_t )((int )rsp->data[2] & 1);
#line 4761
  if ((int )fru.size < 1) {
    {
#line 4762
    printf((char const   */* __restrict  */)" Invalid FRU size %d", (int )fru.size);
#line 4763
    rc = -1;
    }
#line 4764
    goto ipmi_fru_set_field_string_out;
  }
  {
#line 4769
  msg_data[0] = fruId;
#line 4770
  msg_data[1] = (uint8_t )0;
#line 4771
  msg_data[2] = (uint8_t )0;
#line 4772
  msg_data[3] = (uint8_t )8;
#line 4774
  memset((void *)(& req), 0, sizeof(req));
#line 4775
  req.msg.netfn = (uint8_t )10;
#line 4776
  req.msg.cmd = (uint8_t )17;
#line 4777
  req.msg.data = msg_data;
#line 4778
  req.msg.data_len = (uint16_t )4;
#line 4780
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 4781
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 4783
    printf((char const   */* __restrict  */)" Device not present (No Response)\n");
#line 4784
    rc = -1;
    }
#line 4785
    goto ipmi_fru_set_field_string_out;
  }
#line 4787
  if ((int )rsp->ccode > 0) {
    {
#line 4789
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 4789
    printf((char const   */* __restrict  */)" Device not present (%s)\n", tmp___0);
#line 4791
    rc = -1;
    }
#line 4792
    goto ipmi_fru_set_field_string_out;
  }
#line 4795
  if (verbose > 1) {
    {
#line 4796
    printbuf((uint8_t const   *)(rsp->data), rsp->data_len, "FRU DATA");
    }
  }
  {
#line 4798
  memcpy((void */* __restrict  */)(& header), (void const   */* __restrict  */)(rsp->data + 1),
         (size_t )8);
  }
#line 4800
  if ((int )header.version != 1) {
    {
#line 4802
    printf((char const   */* __restrict  */)" Unknown FRU header version 0x%02x",
           (int )header.version);
#line 4804
    rc = -1;
    }
#line 4805
    goto ipmi_fru_set_field_string_out;
  }
  {
#line 4808
  tmp___1 = malloc((size_t )fru.size);
#line 4808
  fru_data = (uint8_t *)tmp___1;
  }
#line 4810
  if ((unsigned long )fru_data == (unsigned long )((void *)0)) {
    {
#line 4812
    printf((char const   */* __restrict  */)"Out of memory!\n");
#line 4813
    rc = -1;
    }
#line 4814
    goto ipmi_fru_set_field_string_out;
  }
#line 4820
  if ((int )f_type == 99) {
    {
#line 4821
    header_offset = (uint32_t )((int )header.offset.chassis * 8);
#line 4822
    read_fru_area(intf, & fru, fruId, header_offset, (uint32_t )3, fru_data);
#line 4823
    fru_field_offset = (uint32_t )((int )header.offset.chassis * 8 + 3);
#line 4824
    fru_section_len = (uint32_t )((int )*((fru_data + header_offset) + 1) * 8);
    }
  } else
#line 4827
  if ((int )f_type == 98) {
    {
#line 4828
    header_offset = (uint32_t )((int )header.offset.board * 8);
#line 4829
    read_fru_area(intf, & fru, fruId, header_offset, (uint32_t )3, fru_data);
#line 4830
    fru_field_offset = (uint32_t )((int )header.offset.board * 8 + 6);
#line 4831
    fru_section_len = (uint32_t )((int )*((fru_data + header_offset) + 1) * 8);
    }
  } else
#line 4834
  if ((int )f_type == 112) {
    {
#line 4835
    header_offset = (uint32_t )((int )header.offset.product * 8);
#line 4836
    read_fru_area(intf, & fru, fruId, header_offset, (uint32_t )3, fru_data);
#line 4837
    fru_field_offset = (uint32_t )((int )header.offset.product * 8 + 3);
#line 4838
    fru_section_len = (uint32_t )((int )*((fru_data + header_offset) + 1) * 8);
    }
  } else {
    {
#line 4842
    printf((char const   */* __restrict  */)"Wrong field type.");
#line 4843
    rc = -1;
    }
#line 4844
    goto ipmi_fru_set_field_string_out;
  }
  {
#line 4846
  memset((void *)fru_data, 0, (size_t )fru.size);
#line 4847
  tmp___2 = read_fru_area(intf, & fru, fruId, header_offset, fru_section_len, fru_data);
  }
#line 4847
  if (tmp___2 < 0) {
#line 4850
    rc = -1;
#line 4851
    goto ipmi_fru_set_field_string_out;
  }
#line 4854
  f_index = (uint8_t )((int )f_index - 48);
#line 4857
  i = 0;
  {
#line 4857
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4857
    if (! (i <= (int )f_index)) {
#line 4857
      goto while_break;
    }
#line 4858
    fru_field_offset_tmp = fru_field_offset;
#line 4859
    if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
      {
#line 4860
      free((void *)fru_area);
#line 4861
      fru_area = (uint8_t *)((void *)0);
      }
    }
    {
#line 4863
    tmp___3 = get_fru_area_str(fru_data, & fru_field_offset);
#line 4863
    fru_area = (uint8_t *)tmp___3;
#line 4857
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4866
  if ((unsigned long )fru_area == (unsigned long )((void *)0)) {
    {
#line 4867
    printf((char const   */* __restrict  */)"Field not found !\n");
#line 4868
    rc = -1;
    }
#line 4869
    goto ipmi_fru_set_field_string_out;
  } else {
    {
#line 4866
    tmp___4 = strlen((char const   *)fru_area);
    }
#line 4866
    if (tmp___4 == 0UL) {
      {
#line 4867
      printf((char const   */* __restrict  */)"Field not found !\n");
#line 4868
      rc = -1;
      }
#line 4869
      goto ipmi_fru_set_field_string_out;
    }
  }
  {
#line 4872
  tmp___8 = strlen((char const   *)fru_area);
#line 4872
  tmp___9 = strlen((char const   *)f_string);
  }
#line 4872
  if (tmp___8 == tmp___9) {
    {
#line 4874
    printf((char const   */* __restrict  */)"Updating Field \'%s\' with \'%s\' ...\n",
           fru_area, f_string);
#line 4875
    tmp___5 = strlen((char const   *)f_string);
#line 4875
    memcpy((void */* __restrict  */)((fru_data + fru_field_offset_tmp) + 1), (void const   */* __restrict  */)f_string,
           tmp___5);
#line 4878
    checksum = (uint8_t )0;
#line 4880
    i = (int )header_offset;
    }
    {
#line 4880
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4880
      if (! ((uint32_t )i < (header_offset + fru_section_len) - 1U)) {
#line 4880
        goto while_break___0;
      }
#line 4883
      checksum = (uint8_t )((int )checksum + (int )*(fru_data + i));
#line 4880
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 4885
    checksum = (uint8_t )(~ ((int )checksum) + 1);
#line 4886
    *(fru_data + ((header_offset + fru_section_len) - 1U)) = checksum;
#line 4889
    tmp___6 = write_fru_area(intf, & fru, fruId, (uint16_t )header_offset, (uint16_t )header_offset,
                             (uint16_t )fru_section_len, fru_data);
    }
#line 4889
    if (tmp___6 < 0) {
      {
#line 4892
      printf((char const   */* __restrict  */)"Write to FRU data failed.\n");
#line 4893
      rc = -1;
      }
#line 4894
      goto ipmi_fru_set_field_string_out;
    }
  } else {
    {
#line 4898
    printf((char const   */* __restrict  */)"String size are not equal, resizing fru to fit new string\n");
#line 4899
    tmp___7 = ipmi_fru_set_field_string_rebuild___0(intf, fruId, fru, header, f_type,
                                                    f_index, f_string);
    }
#line 4899
    if (tmp___7) {
#line 4903
      rc = -1;
#line 4904
      goto ipmi_fru_set_field_string_out;
    }
  }
  ipmi_fru_set_field_string_out: 
#line 4909
  if ((unsigned long )fru_data != (unsigned long )((void *)0)) {
    {
#line 4910
    free((void *)fru_data);
#line 4911
    fru_data = (uint8_t *)((void *)0);
    }
  }
#line 4913
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 4914
    free((void *)fru_area);
#line 4915
    fru_area = (uint8_t *)((void *)0);
    }
  }
#line 4918
  return (rc);
}
}
#line 4950 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_fru.c"
static int ipmi_fru_set_field_string_rebuild___0(struct ipmi_intf *intf , uint8_t fruId ,
                                                 struct fru_info fru , struct fru_header header ,
                                                 uint8_t f_type , uint8_t f_index ,
                                                 char *f_string ) 
{ 
  int i ;
  uint8_t *fru_data_old ;
  uint8_t *fru_data_new ;
  uint8_t *fru_area ;
  uint32_t fru_field_offset ;
  uint32_t fru_field_offset_tmp ;
  uint32_t fru_section_len ;
  uint32_t old_section_len ;
  uint32_t header_offset ;
  uint32_t chassis_offset ;
  uint32_t board_offset ;
  uint32_t product_offset ;
  uint32_t chassis_len ;
  uint32_t board_len ;
  uint32_t product_len ;
  uint32_t product_len_new ;
  int num_byte_change ;
  int padding_len ;
  uint32_t counter ;
  unsigned char cksum ;
  int rc ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  uint32_t remaining_offset ;
  int change_size_by_8 ;
  unsigned char *pfru_header ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;

  {
  {
#line 4957
  i = 0;
#line 4958
  fru_data_old = (uint8_t *)((void *)0);
#line 4959
  fru_data_new = (uint8_t *)((void *)0);
#line 4960
  fru_area = (uint8_t *)((void *)0);
#line 4965
  num_byte_change = 0;
#line 4965
  padding_len = 0;
#line 4968
  rc = 1;
#line 4970
  tmp = calloc((size_t )fru.size, sizeof(uint8_t ));
#line 4970
  fru_data_old = (uint8_t *)tmp;
#line 4972
  tmp___0 = malloc((size_t )fru.size);
#line 4972
  fru_data_new = (uint8_t *)tmp___0;
  }
#line 4974
  if ((unsigned long )fru_data_old == (unsigned long )((void *)0)) {
    {
#line 4976
    printf((char const   */* __restrict  */)"Out of memory!\n");
#line 4977
    rc = -1;
    }
#line 4978
    goto ipmi_fru_set_field_string_rebuild_out;
  } else
#line 4974
  if ((unsigned long )fru_data_new == (unsigned long )((void *)0)) {
    {
#line 4976
    printf((char const   */* __restrict  */)"Out of memory!\n");
#line 4977
    rc = -1;
    }
#line 4978
    goto ipmi_fru_set_field_string_rebuild_out;
  }
  {
#line 4983
  printf((char const   */* __restrict  */)"Read All FRU area\n");
#line 4984
  printf((char const   */* __restrict  */)"Fru Size       : %u bytes\n", (int )fru.size);
#line 4987
  read_fru_area(intf, & fru, fruId, (uint32_t )0, (uint32_t )fru.size, fru_data_old);
#line 4990
  printf((char const   */* __restrict  */)"Copy to new FRU\n");
#line 4995
  memcpy((void */* __restrict  */)fru_data_new, (void const   */* __restrict  */)fru_data_old,
         (size_t )fru.size);
#line 4998
  chassis_offset = (uint32_t )((int )header.offset.chassis * 8);
#line 4999
  board_offset = (uint32_t )((int )header.offset.board * 8);
#line 5000
  product_offset = (uint32_t )((int )header.offset.product * 8);
#line 5003
  chassis_len = (uint32_t )((int )*((fru_data_old + chassis_offset) + 1) * 8);
#line 5004
  board_len = (uint32_t )((int )*((fru_data_old + board_offset) + 1) * 8);
#line 5005
  product_len = (uint32_t )((int )*((fru_data_old + product_offset) + 1) * 8);
#line 5006
  product_len_new = product_len;
  }
#line 5009
  if ((int )f_type == 99) {
#line 5011
    header_offset = chassis_offset;
#line 5012
    fru_field_offset = chassis_offset + 3U;
#line 5013
    fru_section_len = chassis_len;
  } else
#line 5016
  if ((int )f_type == 98) {
#line 5018
    header_offset = board_offset;
#line 5019
    fru_field_offset = board_offset + 6U;
#line 5020
    fru_section_len = board_len;
  } else
#line 5023
  if ((int )f_type == 112) {
#line 5025
    header_offset = product_offset;
#line 5026
    fru_field_offset = product_offset + 3U;
#line 5027
    fru_section_len = product_len;
  } else {
    {
#line 5031
    printf((char const   */* __restrict  */)"Wrong field type.");
#line 5032
    rc = -1;
    }
#line 5033
    goto ipmi_fru_set_field_string_rebuild_out;
  }
#line 5037
  old_section_len = fru_section_len;
#line 5041
  i = 0;
  {
#line 5041
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5041
    if (! (i <= (int )f_index)) {
#line 5041
      goto while_break;
    }
#line 5042
    fru_field_offset_tmp = fru_field_offset;
#line 5043
    if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
      {
#line 5044
      free((void *)fru_area);
#line 5045
      fru_area = (uint8_t *)((void *)0);
      }
    }
    {
#line 5047
    tmp___1 = get_fru_area_str(fru_data_old, & fru_field_offset);
#line 5047
    fru_area = (uint8_t *)tmp___1;
#line 5041
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5050
  if ((unsigned long )fru_area == (unsigned long )((void *)0)) {
    {
#line 5051
    printf((char const   */* __restrict  */)"Field not found (1)!\n");
#line 5052
    rc = -1;
    }
#line 5053
    goto ipmi_fru_set_field_string_rebuild_out;
  } else {
    {
#line 5050
    tmp___2 = strlen((char const   *)fru_area);
    }
#line 5050
    if (tmp___2 == 0UL) {
      {
#line 5051
      printf((char const   */* __restrict  */)"Field not found (1)!\n");
#line 5052
      rc = -1;
      }
#line 5053
      goto ipmi_fru_set_field_string_rebuild_out;
    }
  }
  {
#line 5057
  printf((char const   */* __restrict  */)"Section Length: %u\n", fru_section_len);
#line 5062
  counter = (uint32_t )2;
  }
  {
#line 5062
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5062
    if (! (counter < fru_section_len)) {
#line 5062
      goto while_break___0;
    }
#line 5064
    if ((int )*(fru_data_old + ((header_offset + fru_section_len) - counter)) == 0) {
#line 5065
      padding_len ++;
    } else {
#line 5067
      goto while_break___0;
    }
#line 5062
    counter ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 5069
  tmp___3 = strlen((char const   *)f_string);
#line 5069
  tmp___4 = strlen((char const   *)fru_area);
#line 5069
  num_byte_change = (int )(tmp___3 - tmp___4);
#line 5072
  printf((char const   */* __restrict  */)"Padding Length: %u\n", padding_len);
#line 5073
  printf((char const   */* __restrict  */)"NumByte Change: %i\n", num_byte_change);
#line 5074
  printf((char const   */* __restrict  */)"Start SecChnge: %x\n", (int )*(fru_data_old + fru_field_offset_tmp));
#line 5075
  tmp___5 = strlen((char const   *)f_string);
#line 5075
  printf((char const   */* __restrict  */)"End SecChnge  : %x\n", (int )*(((fru_data_old + fru_field_offset_tmp) + tmp___5) + 1));
#line 5077
  printf((char const   */* __restrict  */)"Start Section : %x\n", (int )*(fru_data_old + header_offset));
#line 5078
  printf((char const   */* __restrict  */)"End Sec wo Pad: %x\n", (int )*((((fru_data_old + header_offset) + fru_section_len) - 2) - padding_len));
#line 5079
  printf((char const   */* __restrict  */)"End Section   : %x\n", (int )*(((fru_data_old + header_offset) + fru_section_len) - 1));
#line 5083
  padding_len -= num_byte_change;
#line 5086
  printf((char const   */* __restrict  */)"New Padding Length: %i\n", padding_len);
  }
#line 5091
  if (padding_len < 0) {
#line 5091
    goto _L;
  } else
#line 5091
  if (padding_len >= 8) {
    _L: /* CIL Label */ 
#line 5093
    remaining_offset = (uint32_t )((int )header.offset.product * 8) + product_len;
#line 5096
    if (padding_len >= 8) {
#line 5099
      change_size_by_8 = (padding_len / 8) * -1;
    } else {
#line 5104
      change_size_by_8 = 1 + ((padding_len + 1) / 8) * -1;
    }
    {
#line 5108
    fru_section_len += (uint32_t )(change_size_by_8 * 8);
#line 5109
    padding_len += change_size_by_8 * 8;
#line 5112
    printf((char const   */* __restrict  */)"change_size_by_8: %i\n", change_size_by_8);
#line 5113
    printf((char const   */* __restrict  */)"New Padding Length: %i\n", padding_len);
#line 5114
    printf((char const   */* __restrict  */)"change_size_by_8: %i\n", change_size_by_8);
#line 5115
    printf((char const   */* __restrict  */)"header.offset.board: %i\n", (int )header.offset.board);
    }
#line 5125
    if ((int )f_type == 99) {
      {
#line 5127
      printf((char const   */* __restrict  */)"Moving Section Chassis, from %i to %i\n",
             (int )header.offset.board * 8, ((int )header.offset.board + change_size_by_8) * 8);
#line 5131
      memcpy((void */* __restrict  */)(fru_data_new + ((int )header.offset.board + change_size_by_8) * 8),
             (void const   */* __restrict  */)(fru_data_old + (int )header.offset.board * 8),
             (size_t )board_len);
#line 5136
      header.offset.board = (uint8_t )((int )header.offset.board + change_size_by_8);
      }
    }
#line 5139
    if ((int )f_type == 99) {
      {
#line 5141
      printf((char const   */* __restrict  */)"Moving Section Product, from %i to %i\n",
             (int )header.offset.product * 8, ((int )header.offset.product + change_size_by_8) * 8);
#line 5145
      memcpy((void */* __restrict  */)(fru_data_new + ((int )header.offset.product + change_size_by_8) * 8),
             (void const   */* __restrict  */)(fru_data_old + (int )header.offset.product * 8),
             (size_t )product_len);
#line 5150
      header.offset.product = (uint8_t )((int )header.offset.product + change_size_by_8);
      }
    } else
#line 5139
    if ((int )f_type == 98) {
      {
#line 5141
      printf((char const   */* __restrict  */)"Moving Section Product, from %i to %i\n",
             (int )header.offset.product * 8, ((int )header.offset.product + change_size_by_8) * 8);
#line 5145
      memcpy((void */* __restrict  */)(fru_data_new + ((int )header.offset.product + change_size_by_8) * 8),
             (void const   */* __restrict  */)(fru_data_old + (int )header.offset.product * 8),
             (size_t )product_len);
#line 5150
      header.offset.product = (uint8_t )((int )header.offset.product + change_size_by_8);
      }
    }
#line 5154
    if ((int )f_type == 99) {
#line 5156
      *((fru_data_new + chassis_offset) + 1) = (uint8_t )((int )*((fru_data_new + chassis_offset) + 1) + change_size_by_8);
    } else
#line 5158
    if ((int )f_type == 98) {
#line 5160
      *((fru_data_new + board_offset) + 1) = (uint8_t )((int )*((fru_data_new + board_offset) + 1) + change_size_by_8);
    } else
#line 5162
    if ((int )f_type == 112) {
#line 5164
      *((fru_data_new + product_offset) + 1) = (uint8_t )((int )*((fru_data_new + product_offset) + 1) + change_size_by_8);
#line 5165
      product_len_new = (uint32_t )((int )*((fru_data_new + product_offset) + 1) * 8);
    }
#line 5170
    pfru_header = (unsigned char *)(& header);
#line 5171
    header.checksum = (uint8_t )0;
#line 5172
    counter = (uint32_t )0;
    {
#line 5172
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 5172
      if (! ((unsigned long )counter < sizeof(struct fru_header ) - 1UL)) {
#line 5172
        goto while_break___1;
      }
#line 5174
      header.checksum = (uint8_t )((int )header.checksum + (int )*(pfru_header + counter));
#line 5172
      counter ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 5176
    header.checksum = (uint8_t )(0 - (int )header.checksum);
#line 5177
    memcpy((void */* __restrict  */)fru_data_new, (void const   */* __restrict  */)pfru_header,
           sizeof(struct fru_header ));
#line 5181
    printf((char const   */* __restrict  */)"Moving Remaining Bytes (Multi-Rec , etc..), from %i to %i\n",
           remaining_offset, (uint32_t )((int )header.offset.product * 8) + product_len_new);
    }
#line 5185
    if (((uint32_t )((int )header.offset.product * 8) + product_len_new) - remaining_offset < 0U) {
      {
#line 5187
      memcpy((void */* __restrict  */)((fru_data_new + (int )header.offset.product * 8) + product_len_new),
             (void const   */* __restrict  */)(fru_data_old + remaining_offset), (size_t )((uint32_t )fru.size - remaining_offset));
      }
    } else {
      {
#line 5195
      memcpy((void */* __restrict  */)((fru_data_new + (int )header.offset.product * 8) + product_len_new),
             (void const   */* __restrict  */)(fru_data_old + remaining_offset), (size_t )((uint32_t )fru.size - ((uint32_t )((int )header.offset.product * 8) + product_len_new)));
      }
    }
  }
#line 5207
  if (padding_len >= 0) {
#line 5207
    if (padding_len < 8) {
      {
#line 5212
      tmp___6 = strlen((char const   *)f_string);
#line 5212
      printf((char const   */* __restrict  */)"Updating Field : \'%s\' with \'%s\' ... (Length from \'%d\' to \'%d\')\n",
             fru_area, f_string, (int )*(fru_data_old + fru_field_offset_tmp), (int )(192UL + tmp___6));
#line 5217
      tmp___7 = strlen((char const   *)f_string);
#line 5217
      *(fru_data_new + fru_field_offset_tmp) = (uint8_t )(192UL + tmp___7);
#line 5218
      tmp___8 = strlen((char const   *)f_string);
#line 5218
      memcpy((void */* __restrict  */)((fru_data_new + fru_field_offset_tmp) + 1),
             (void const   */* __restrict  */)f_string, tmp___8);
#line 5222
      tmp___9 = strlen((char const   *)f_string);
#line 5222
      printf((char const   */* __restrict  */)"Copying remaining of sections: %d \n",
             (int )((((fru_data_old + header_offset) + fru_section_len) - 1) - (((fru_data_old + fru_field_offset_tmp) + tmp___9) + 1)));
#line 5227
      tmp___10 = strlen((char const   *)f_string);
#line 5227
      tmp___11 = strlen((char const   *)fru_area);
#line 5227
      tmp___12 = strlen((char const   *)f_string);
#line 5227
      memcpy((void */* __restrict  */)(((fru_data_new + fru_field_offset_tmp) + 1) + tmp___12),
             (void const   */* __restrict  */)(((fru_data_old + fru_field_offset_tmp) + 1) + tmp___11),
             (size_t )((((fru_data_old + header_offset) + fru_section_len) - 1) - (((fru_data_old + fru_field_offset_tmp) + tmp___10) + 1)));
#line 5235
      counter = (uint32_t )0;
      }
      {
#line 5235
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 5235
        if (! (counter < (uint32_t )padding_len)) {
#line 5235
          goto while_break___2;
        }
#line 5237
        *(((((fru_data_new + header_offset) + fru_section_len) - 1) - padding_len) + counter) = (uint8_t )0;
#line 5235
        counter ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 5242
      cksum = (unsigned char)0;
#line 5243
      counter = (uint32_t )0;
      {
#line 5243
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 5243
        if (! (counter < fru_section_len - 1U)) {
#line 5243
          goto while_break___3;
        }
#line 5245
        cksum = (unsigned char )((int )cksum + (int )*((fru_data_new + header_offset) + counter));
#line 5243
        counter ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 5247
      *(((fru_data_new + header_offset) + fru_section_len) - 1) = (uint8_t )(0 - (int )cksum);
#line 5250
      printf((char const   */* __restrict  */)"Calculate New Checksum: %x\n", 0 - (int )cksum);
      }
    } else {
      {
#line 5280
      printf((char const   */* __restrict  */)"Internal error, padding length %i (must be from 0 to 7) ",
             padding_len);
#line 5281
      rc = -1;
      }
#line 5282
      goto ipmi_fru_set_field_string_rebuild_out;
    }
  } else {
    {
#line 5280
    printf((char const   */* __restrict  */)"Internal error, padding length %i (must be from 0 to 7) ",
           padding_len);
#line 5281
    rc = -1;
    }
#line 5282
    goto ipmi_fru_set_field_string_rebuild_out;
  }
  {
#line 5287
  printf((char const   */* __restrict  */)"Writing new FRU.\n");
#line 5288
  tmp___13 = write_fru_area(intf, & fru, fruId, (uint16_t )0, (uint16_t )0, fru.size,
                            fru_data_new);
  }
#line 5288
  if (tmp___13 < 0) {
    {
#line 5290
    printf((char const   */* __restrict  */)"Write to FRU data failed.\n");
#line 5291
    rc = -1;
    }
#line 5292
    goto ipmi_fru_set_field_string_rebuild_out;
  }
  {
#line 5295
  printf((char const   */* __restrict  */)"Done.\n");
  }
  ipmi_fru_set_field_string_rebuild_out: 
#line 5298
  if ((unsigned long )fru_area != (unsigned long )((void *)0)) {
    {
#line 5299
    free((void *)fru_area);
#line 5300
    fru_area = (uint8_t *)((void *)0);
    }
  }
#line 5302
  if ((unsigned long )fru_data_new != (unsigned long )((void *)0)) {
    {
#line 5303
    free((void *)fru_data_new);
#line 5304
    fru_data_new = (uint8_t *)((void *)0);
    }
  }
#line 5306
  if ((unsigned long )fru_data_old != (unsigned long )((void *)0)) {
    {
#line 5307
    free((void *)fru_data_old);
#line 5308
    fru_data_old = (uint8_t *)((void *)0);
    }
  }
#line 5311
  return (rc);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
static char str___0[2049]  ;
#line 114 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
static char un_str___4[32]  ;
#line 131 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/helper.c"
static char un_str___5[32]  ;
#line 124 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int current_arg___0  =    0;
#line 127 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static uint8_t LcdSupported___0  =    (uint8_t )0;
#line 128 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static uint8_t SetLEDSupported___0  =    (uint8_t )0;
#line 137
static void usage___0(void) ;
#line 139
static int ipmi_delloem_lcd_main___0(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 143
static int ipmi_idracvalidator_command___0(struct ipmi_intf *intf ) ;
#line 144
static int ipmi_lcd_get_configure_command_wh___0(struct ipmi_intf *intf ) ;
#line 145
static int ipmi_lcd_get_configure_command___0(struct ipmi_intf *intf , uint8_t *command ) ;
#line 147
static int ipmi_lcd_set_configure_command___0(struct ipmi_intf *intf , int command ) ;
#line 148
static int ipmi_lcd_set_configure_command_wh___0(struct ipmi_intf *intf , uint32_t mode ,
                                                 uint16_t lcdquallifier , uint8_t errordisp ) ;
#line 150
static int ipmi_lcd_get_single_line_text___0(struct ipmi_intf *intf , char *lcdstring ,
                                             uint8_t max_length ) ;
#line 152
static int ipmi_lcd_get_info_wh___0(struct ipmi_intf *intf ) ;
#line 153
static int ipmi_lcd_get_info___0(struct ipmi_intf *intf ) ;
#line 154
static int ipmi_lcd_get_status_val___0(struct ipmi_intf *intf , LCD_STATUS *lcdstatus ) ;
#line 156
static int IsLCDSupported___0(void) ;
#line 157
static void CheckLCDSupport___0(struct ipmi_intf *intf ) ;
#line 158
static void ipmi_lcd_status_print___0(LCD_STATUS lcdstatus ) ;
#line 159
static int ipmi_lcd_get_status___0(struct ipmi_intf *intf ) ;
#line 160
static int ipmi_lcd_set_kvm___0(struct ipmi_intf *intf , char status ) ;
#line 161
static int ipmi_lcd_set_lock___0(struct ipmi_intf *intf , char lock ) ;
#line 162
static int ipmi_lcd_set_single_line_text___0(struct ipmi_intf *intf , char *text ) ;
#line 163
static int ipmi_lcd_set_text___0(struct ipmi_intf *intf , char *text , int line_number ) ;
#line 165
static int ipmi_lcd_configure_wh___0(struct ipmi_intf *intf , uint32_t mode , uint16_t lcdquallifier ,
                                     uint8_t errordisp , int8_t line_number , char *text ) ;
#line 167
static int ipmi_lcd_configure___0(struct ipmi_intf *intf , int command , int8_t line_number ,
                                  char *text ) ;
#line 169
static void ipmi_lcd_usage___0(void) ;
#line 171
static int ipmi_delloem_mac_main___0(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 172
static void InitEmbeddedNICMacAddressValues___0(void) ;
#line 173
static int ipmi_macinfo_drac_idrac_virtual_mac___0(struct ipmi_intf *intf , uint8_t NicNum ) ;
#line 175
static int ipmi_macinfo_drac_idrac_mac___0(struct ipmi_intf *intf , uint8_t NicNum ) ;
#line 176
static int ipmi_macinfo_10g___0(struct ipmi_intf *intf , uint8_t NicNum ) ;
#line 177
static int ipmi_macinfo_11g___0(struct ipmi_intf *intf , uint8_t NicNum ) ;
#line 178
static int ipmi_macinfo___0(struct ipmi_intf *intf , uint8_t NicNum ) ;
#line 179
static void ipmi_mac_usage___0(void) ;
#line 181
static int ipmi_delloem_lan_main___0(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 182
static int IsLANSupported___0(void) ;
#line 183
static int get_nic_selection_mode___0(int current_arg___1 , char **argv ) ;
#line 184
static int ipmi_lan_set_nic_selection___0(struct ipmi_intf *intf , uint8_t nic_selection ) ;
#line 186
static int ipmi_lan_get_nic_selection___0(struct ipmi_intf *intf ) ;
#line 187
static int ipmi_lan_get_active_nic___0(struct ipmi_intf *intf ) ;
#line 188
static void ipmi_lan_usage___0(void) ;
#line 189
static int ipmi_lan_set_nic_selection_12g___0(struct ipmi_intf *intf , uint8_t *nic_selection ) ;
#line 192
static int ipmi_delloem_powermonitor_main___0(struct ipmi_intf *intf , int argc ,
                                              char **argv ) ;
#line 194
static void ipmi_time_to_str___0(time_t rawTime , char *strTime ) ;
#line 195
static int ipmi_get_sensor_reading___0(struct ipmi_intf *intf , unsigned char sensorNumber ,
                                       SensorReadingType *pSensorReadingData ) ;
#line 197
static int ipmi_get_power_capstatus_command___0(struct ipmi_intf *intf ) ;
#line 198
static int ipmi_set_power_capstatus_command___0(struct ipmi_intf *intf , uint8_t val ) ;
#line 200
static int ipmi_powermgmt___0(struct ipmi_intf *intf ) ;
#line 201
static int ipmi_powermgmt_clear___0(struct ipmi_intf *intf , uint8_t clearValue ) ;
#line 202
static uint64_t watt_to_btuphr_conversion___0(uint32_t powerinwatt ) ;
#line 203
static uint32_t btuphr_to_watt_conversion___0(uint64_t powerinbtuphr ) ;
#line 204
static int ipmi_get_power_headroom_command___0(struct ipmi_intf *intf , uint8_t unit ) ;
#line 205
static int ipmi_get_power_consumption_data___0(struct ipmi_intf *intf , uint8_t unit ) ;
#line 206
static int ipmi_get_instan_power_consmpt_data___0(struct ipmi_intf *intf , IPMI_INST_POWER_CONSUMPTION_DATA *instpowerconsumptiondata ) ;
#line 208
static void ipmi_print_get_instan_power_Amps_data___0(IPMI_INST_POWER_CONSUMPTION_DATA instpowerconsumptiondata ) ;
#line 210
static int ipmi_print_get_power_consmpt_data___0(struct ipmi_intf *intf , uint8_t unit ) ;
#line 212
static int ipmi_get_avgpower_consmpt_history___0(struct ipmi_intf *intf , IPMI_AVGPOWER_CONSUMP_HISTORY *pavgpower ) ;
#line 214
static int ipmi_get_peakpower_consmpt_history___0(struct ipmi_intf *intf , IPMI_POWER_CONSUMP_HISTORY *pstPeakpower ) ;
#line 216
static int ipmi_get_minpower_consmpt_history___0(struct ipmi_intf *intf , IPMI_POWER_CONSUMP_HISTORY *pstMinpower ) ;
#line 218
static int ipmi_print_power_consmpt_history___0(struct ipmi_intf *intf , int unit ) ;
#line 219
static int ipmi_get_power_cap___0(struct ipmi_intf *intf , IPMI_POWER_CAP *ipmipowercap ) ;
#line 221
static int ipmi_print_power_cap___0(struct ipmi_intf *intf , uint8_t unit ) ;
#line 222
static int ipmi_set_power_cap___0(struct ipmi_intf *intf , int unit , int val ) ;
#line 223
static void ipmi_powermonitor_usage___0(void) ;
#line 225
static int ipmi_delloem_vFlash_main___0(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 229
static int ipmi_get_sd_card_info___0(struct ipmi_intf *intf ) ;
#line 230
static int ipmi_delloem_vFlash_process___0(struct ipmi_intf *intf , int current_arg___1 ,
                                           char **argv ) ;
#line 232
static void ipmi_vFlash_usage___0(void) ;
#line 234
static int ipmi_getsesmask___0(int argc , char **argv ) ;
#line 235
static void CheckSetLEDSupport___0(struct ipmi_intf *intf ) ;
#line 236
static int IsSetLEDSupported___0(void) ;
#line 237
static void ipmi_setled_usage___0(void) ;
#line 238
static int ipmi_delloem_setled_main___0(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 240
static int ipmi_setled_state___0(struct ipmi_intf *intf , int bayId , int slotId ,
                                 int state ) ;
#line 242
static int ipmi_getdrivemap___0(struct ipmi_intf *intf , int b , int d , int f , int *bay ,
                                int *slot ) ;
#line 298 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void usage___0(void) 
{ 


  {
  {
#line 301
  lprintf(5, "");
#line 303
  lprintf(5, "usage: delloem <command> [option...]");
#line 305
  lprintf(5, "");
#line 307
  lprintf(5, "commands:");
#line 309
  lprintf(5, "    lcd");
#line 311
  lprintf(5, "    mac");
#line 313
  lprintf(5, "    lan");
#line 315
  lprintf(5, "    setled");
#line 317
  lprintf(5, "    powermonitor");
#line 319
  lprintf(5, "    vFlash");
#line 321
  lprintf(5, "");
#line 323
  lprintf(5, "For help on individual commands type:");
#line 325
  lprintf(5, "delloem <command> help");
  }
#line 327
  return;
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_delloem_lcd_main___0(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int rc ;
  int tmp ;
  uint8_t line_number ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;

  {
#line 344
  rc = 0;
#line 345
  current_arg___0 ++;
#line 346
  if (argc < current_arg___0) {
    {
#line 347
    usage___0();
    }
#line 348
    return (-1);
  }
#line 351
  if (argc == 1) {
    {
#line 352
    ipmi_lcd_usage___0();
    }
#line 353
    return (0);
  } else {
    {
#line 351
    tmp = strcmp((char const   *)*(argv + current_arg___0), "help");
    }
#line 351
    if (tmp == 0) {
      {
#line 352
      ipmi_lcd_usage___0();
      }
#line 353
      return (0);
    }
  }
  {
#line 355
  CheckLCDSupport___0(intf);
#line 356
  ipmi_idracvalidator_command___0(intf);
#line 357
  tmp___41 = IsLCDSupported___0();
  }
#line 357
  if (tmp___41) {
    {
#line 360
    tmp___40 = strncmp((char const   *)*(argv + current_arg___0), "info\000", (size_t )5);
    }
#line 360
    if (tmp___40 == 0) {
#line 361
      if ((int )iDRAC_FLAG == 1) {
        {
#line 362
        rc = ipmi_lcd_get_info_wh___0(intf);
        }
      } else
#line 361
      if ((int )iDRAC_FLAG == 2) {
        {
#line 362
        rc = ipmi_lcd_get_info_wh___0(intf);
        }
      } else {
        {
#line 364
        rc = ipmi_lcd_get_info___0(intf);
        }
      }
    } else {
      {
#line 366
      tmp___39 = strncmp((char const   *)*(argv + current_arg___0), "status\000",
                         (size_t )7);
      }
#line 366
      if (tmp___39 == 0) {
        {
#line 367
        rc = ipmi_lcd_get_status___0(intf);
        }
      } else {
        {
#line 368
        tmp___38 = strncmp((char const   *)*(argv + current_arg___0), "set\000", (size_t )4);
        }
#line 368
        if (tmp___38 == 0) {
#line 370
          line_number = (uint8_t )0;
#line 371
          current_arg___0 ++;
#line 372
          if (argc <= current_arg___0) {
            {
#line 373
            ipmi_lcd_usage___0();
            }
#line 374
            return (-1);
          }
          {
#line 376
          tmp___1 = strncmp((char const   *)*(argv + current_arg___0), "line\000",
                            (size_t )5);
          }
#line 376
          if (tmp___1 == 0) {
#line 377
            current_arg___0 ++;
#line 378
            if (argc <= current_arg___0) {
              {
#line 379
              usage___0();
              }
#line 380
              return (-1);
            }
            {
#line 382
            tmp___0 = str2uchar((char const   *)*(argv + current_arg___0), & line_number);
            }
#line 382
            if (tmp___0 != 0) {
              {
#line 383
              lprintf(3, "Argument \'%s\' is either not a number or out of range.",
                      *(argv + current_arg___0));
              }
#line 386
              return (-1);
            }
#line 388
            current_arg___0 ++;
#line 389
            if (argc <= current_arg___0) {
              {
#line 390
              usage___0();
              }
#line 391
              return (-1);
            }
          }
          {
#line 394
          tmp___37 = strncmp((char const   *)*(argv + current_arg___0), "mode\000",
                             (size_t )5);
          }
#line 394
          if (tmp___37 == 0) {
#line 394
            if ((int )iDRAC_FLAG == 1) {
#line 394
              goto _L___7;
            } else
#line 394
            if ((int )iDRAC_FLAG == 2) {
              _L___7: /* CIL Label */ 
#line 396
              current_arg___0 ++;
#line 397
              if (argc <= current_arg___0) {
                {
#line 398
                ipmi_lcd_usage___0();
                }
#line 399
                return (-1);
              }
#line 401
              if ((unsigned long )*(argv + current_arg___0) == (unsigned long )((void *)0)) {
                {
#line 402
                ipmi_lcd_usage___0();
                }
#line 403
                return (-1);
              }
              {
#line 405
              tmp___13 = strncmp((char const   *)*(argv + current_arg___0), "none\000",
                                 (size_t )5);
              }
#line 405
              if (tmp___13 == 0) {
                {
#line 406
                rc = ipmi_lcd_configure_wh___0(intf, (uint32_t )2, (uint16_t )255,
                                               (uint8_t )255, (int8_t )0, (char *)((void *)0));
                }
              } else {
                {
#line 408
                tmp___12 = strncmp((char const   *)*(argv + current_arg___0), "modelname\000",
                                   (size_t )10);
                }
#line 408
                if (tmp___12 == 0) {
                  {
#line 409
                  rc = ipmi_lcd_configure_wh___0(intf, (uint32_t )1, (uint16_t )255,
                                                 (uint8_t )255, (int8_t )0, (char *)((void *)0));
                  }
                } else {
                  {
#line 411
                  tmp___11 = strncmp((char const   *)*(argv + current_arg___0), "userdefined\000",
                                     (size_t )12);
                  }
#line 411
                  if (tmp___11 == 0) {
#line 412
                    current_arg___0 ++;
#line 413
                    if (argc <= current_arg___0) {
                      {
#line 414
                      ipmi_lcd_usage___0();
                      }
#line 415
                      return (-1);
                    }
                    {
#line 417
                    rc = ipmi_lcd_configure_wh___0(intf, (uint32_t )0, (uint16_t )255,
                                                   (uint8_t )255, (int8_t )line_number,
                                                   *(argv + current_arg___0));
                    }
                  } else {
                    {
#line 419
                    tmp___10 = strncmp((char const   *)*(argv + current_arg___0),
                                       "ipv4address\000", (size_t )12);
                    }
#line 419
                    if (tmp___10 == 0) {
                      {
#line 420
                      rc = ipmi_lcd_configure_wh___0(intf, (uint32_t )4, (uint16_t )255,
                                                     (uint8_t )255, (int8_t )0, (char *)((void *)0));
                      }
                    } else {
                      {
#line 422
                      tmp___9 = strncmp((char const   *)*(argv + current_arg___0),
                                        "macaddress\000", (size_t )11);
                      }
#line 422
                      if (tmp___9 == 0) {
                        {
#line 423
                        rc = ipmi_lcd_configure_wh___0(intf, (uint32_t )8, (uint16_t )255,
                                                       (uint8_t )255, (int8_t )0,
                                                       (char *)((void *)0));
                        }
                      } else {
                        {
#line 425
                        tmp___8 = strncmp((char const   *)*(argv + current_arg___0),
                                          "systemname\000", (size_t )11);
                        }
#line 425
                        if (tmp___8 == 0) {
                          {
#line 426
                          rc = ipmi_lcd_configure_wh___0(intf, (uint32_t )16, (uint16_t )255,
                                                         (uint8_t )255, (int8_t )0,
                                                         (char *)((void *)0));
                          }
                        } else {
                          {
#line 428
                          tmp___7 = strncmp((char const   *)*(argv + current_arg___0),
                                            "servicetag\000", (size_t )11);
                          }
#line 428
                          if (tmp___7 == 0) {
                            {
#line 429
                            rc = ipmi_lcd_configure_wh___0(intf, (uint32_t )32, (uint16_t )255,
                                                           (uint8_t )255, (int8_t )0,
                                                           (char *)((void *)0));
                            }
                          } else {
                            {
#line 431
                            tmp___6 = strncmp((char const   *)*(argv + current_arg___0),
                                              "ipv6address\000", (size_t )12);
                            }
#line 431
                            if (tmp___6 == 0) {
                              {
#line 432
                              rc = ipmi_lcd_configure_wh___0(intf, (uint32_t )64,
                                                             (uint16_t )255, (uint8_t )255,
                                                             (int8_t )0, (char *)((void *)0));
                              }
                            } else {
                              {
#line 434
                              tmp___5 = strncmp((char const   *)*(argv + current_arg___0),
                                                "ambienttemp\000", (size_t )12);
                              }
#line 434
                              if (tmp___5 == 0) {
                                {
#line 435
                                rc = ipmi_lcd_configure_wh___0(intf, (uint32_t )128,
                                                               (uint16_t )255, (uint8_t )255,
                                                               (int8_t )0, (char *)((void *)0));
                                }
                              } else {
                                {
#line 437
                                tmp___4 = strncmp((char const   *)*(argv + current_arg___0),
                                                  "systemwatt\000", (size_t )11);
                                }
#line 437
                                if (tmp___4 == 0) {
                                  {
#line 438
                                  rc = ipmi_lcd_configure_wh___0(intf, (uint32_t )256,
                                                                 (uint16_t )255, (uint8_t )255,
                                                                 (int8_t )0, (char *)((void *)0));
                                  }
                                } else {
                                  {
#line 440
                                  tmp___3 = strncmp((char const   *)*(argv + current_arg___0),
                                                    "assettag\000", (size_t )9);
                                  }
#line 440
                                  if (tmp___3 == 0) {
                                    {
#line 441
                                    rc = ipmi_lcd_configure_wh___0(intf, (uint32_t )512,
                                                                   (uint16_t )255,
                                                                   (uint8_t )255,
                                                                   (int8_t )0, (char *)((void *)0));
                                    }
                                  } else {
                                    {
#line 443
                                    tmp___2 = strncmp((char const   *)*(argv + current_arg___0),
                                                      "help\000", (size_t )5);
                                    }
#line 443
                                    if (tmp___2 == 0) {
                                      {
#line 444
                                      ipmi_lcd_usage___0();
                                      }
                                    } else {
                                      {
#line 446
                                      ipmi_lcd_usage___0();
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
#line 394
              goto _L___6;
            }
          } else {
            _L___6: /* CIL Label */ 
            {
#line 448
            tmp___36 = strncmp((char const   *)*(argv + current_arg___0), "lcdqualifier\000",
                               (size_t )13);
            }
#line 448
            if (tmp___36 == 0) {
#line 448
              if ((int )iDRAC_FLAG == 1) {
#line 448
                goto _L___5;
              } else
#line 448
              if ((int )iDRAC_FLAG == 2) {
                _L___5: /* CIL Label */ 
#line 450
                current_arg___0 ++;
#line 451
                if (argc <= current_arg___0) {
                  {
#line 452
                  ipmi_lcd_usage___0();
                  }
#line 453
                  return (-1);
                }
#line 455
                if ((unsigned long )*(argv + current_arg___0) == (unsigned long )((void *)0)) {
                  {
#line 456
                  ipmi_lcd_usage___0();
                  }
#line 457
                  return (-1);
                }
                {
#line 459
                tmp___18 = strncmp((char const   *)*(argv + current_arg___0), "watt\000",
                                   (size_t )5);
                }
#line 459
                if (tmp___18 == 0) {
                  {
#line 460
                  rc = ipmi_lcd_configure_wh___0(intf, (uint32_t )255, (uint16_t )0,
                                                 (uint8_t )255, (int8_t )0, (char *)((void *)0));
                  }
                } else {
                  {
#line 461
                  tmp___17 = strncmp((char const   *)*(argv + current_arg___0), "btuphr\000",
                                     (size_t )7);
                  }
#line 461
                  if (tmp___17 == 0) {
                    {
#line 462
                    rc = ipmi_lcd_configure_wh___0(intf, (uint32_t )255, (uint16_t )1,
                                                   (uint8_t )255, (int8_t )0, (char *)((void *)0));
                    }
                  } else {
                    {
#line 463
                    tmp___16 = strncmp((char const   *)*(argv + current_arg___0),
                                       "celsius\000", (size_t )8);
                    }
#line 463
                    if (tmp___16 == 0) {
                      {
#line 464
                      rc = ipmi_lcd_configure_wh___0(intf, (uint32_t )255, (uint16_t )2,
                                                     (uint8_t )255, (int8_t )0, (char *)((void *)0));
                      }
                    } else {
                      {
#line 465
                      tmp___15 = strncmp((char const   *)*(argv + current_arg___0),
                                         "fahrenheit", (size_t )11);
                      }
#line 465
                      if (tmp___15 == 0) {
                        {
#line 466
                        rc = ipmi_lcd_configure_wh___0(intf, (uint32_t )255, (uint16_t )3,
                                                       (uint8_t )255, (int8_t )0,
                                                       (char *)((void *)0));
                        }
                      } else {
                        {
#line 467
                        tmp___14 = strncmp((char const   *)*(argv + current_arg___0),
                                           "help\000", (size_t )5);
                        }
#line 467
                        if (tmp___14 == 0) {
                          {
#line 468
                          ipmi_lcd_usage___0();
                          }
                        } else {
                          {
#line 470
                          ipmi_lcd_usage___0();
                          }
                        }
                      }
                    }
                  }
                }
              } else {
#line 448
                goto _L___4;
              }
            } else {
              _L___4: /* CIL Label */ 
              {
#line 472
              tmp___35 = strncmp((char const   *)*(argv + current_arg___0), "errordisplay\000",
                                 (size_t )13);
              }
#line 472
              if (tmp___35 == 0) {
#line 472
                if ((int )iDRAC_FLAG == 1) {
#line 472
                  goto _L___3;
                } else
#line 472
                if ((int )iDRAC_FLAG == 2) {
                  _L___3: /* CIL Label */ 
#line 474
                  current_arg___0 ++;
#line 475
                  if (argc <= current_arg___0) {
                    {
#line 476
                    ipmi_lcd_usage___0();
                    }
#line 477
                    return (-1);
                  }
#line 479
                  if ((unsigned long )*(argv + current_arg___0) == (unsigned long )((void *)0)) {
                    {
#line 480
                    ipmi_lcd_usage___0();
                    }
#line 481
                    return (-1);
                  }
                  {
#line 483
                  tmp___21 = strncmp((char const   *)*(argv + current_arg___0), "sel\000",
                                     (size_t )4);
                  }
#line 483
                  if (tmp___21 == 0) {
                    {
#line 484
                    rc = ipmi_lcd_configure_wh___0(intf, (uint32_t )255, (uint16_t )255,
                                                   (uint8_t )1, (int8_t )0, (char *)((void *)0));
                    }
                  } else {
                    {
#line 486
                    tmp___20 = strncmp((char const   *)*(argv + current_arg___0),
                                       "simple\000", (size_t )7);
                    }
#line 486
                    if (tmp___20 == 0) {
                      {
#line 487
                      rc = ipmi_lcd_configure_wh___0(intf, (uint32_t )255, (uint16_t )255,
                                                     (uint8_t )2, (int8_t )0, (char *)((void *)0));
                      }
                    } else {
                      {
#line 489
                      tmp___19 = strncmp((char const   *)*(argv + current_arg___0),
                                         "help\000", (size_t )5);
                      }
#line 489
                      if (tmp___19 == 0) {
                        {
#line 490
                        ipmi_lcd_usage___0();
                        }
                      } else {
                        {
#line 492
                        ipmi_lcd_usage___0();
                        }
                      }
                    }
                  }
                } else {
#line 472
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
                {
#line 494
                tmp___34 = strncmp((char const   *)*(argv + current_arg___0), "none\000",
                                   (size_t )5);
                }
#line 494
                if (tmp___34 == 0) {
#line 494
                  if ((int )iDRAC_FLAG == 0) {
                    {
#line 496
                    rc = ipmi_lcd_configure___0(intf, 2, (int8_t )0, (char *)((void *)0));
                    }
                  } else {
#line 494
                    goto _L___1;
                  }
                } else {
                  _L___1: /* CIL Label */ 
                  {
#line 497
                  tmp___33 = strncmp((char const   *)*(argv + current_arg___0), "default\000",
                                     (size_t )8);
                  }
#line 497
                  if (tmp___33 == 0) {
#line 497
                    if ((int )iDRAC_FLAG == 0) {
                      {
#line 499
                      rc = ipmi_lcd_configure___0(intf, 1, (int8_t )0, (char *)((void *)0));
                      }
                    } else {
#line 497
                      goto _L___0;
                    }
                  } else {
                    _L___0: /* CIL Label */ 
                    {
#line 500
                    tmp___32 = strncmp((char const   *)*(argv + current_arg___0),
                                       "custom\000", (size_t )7);
                    }
#line 500
                    if (tmp___32 == 0) {
#line 500
                      if ((int )iDRAC_FLAG == 0) {
#line 502
                        current_arg___0 ++;
#line 503
                        if (argc <= current_arg___0) {
                          {
#line 504
                          ipmi_lcd_usage___0();
                          }
#line 505
                          return (-1);
                        }
                        {
#line 507
                        rc = ipmi_lcd_configure___0(intf, 0, (int8_t )line_number,
                                                    *(argv + current_arg___0));
                        }
                      } else {
#line 500
                        goto _L;
                      }
                    } else {
                      _L: /* CIL Label */ 
                      {
#line 509
                      tmp___31 = strncmp((char const   *)*(argv + current_arg___0),
                                         "vkvm\000", (size_t )5);
                      }
#line 509
                      if (tmp___31 == 0) {
#line 510
                        current_arg___0 ++;
#line 511
                        if (argc <= current_arg___0) {
                          {
#line 512
                          ipmi_lcd_usage___0();
                          }
#line 513
                          return (-1);
                        }
                        {
#line 515
                        tmp___24 = strncmp((char const   *)*(argv + current_arg___0),
                                           "active\000", (size_t )7);
                        }
#line 515
                        if (tmp___24 == 0) {
                          {
#line 516
                          rc = ipmi_lcd_set_kvm___0(intf, (char)1);
                          }
                        } else {
                          {
#line 517
                          tmp___23 = strncmp((char const   *)*(argv + current_arg___0),
                                             "inactive\000", (size_t )9);
                          }
#line 517
                          if (tmp___23 == 0) {
                            {
#line 518
                            rc = ipmi_lcd_set_kvm___0(intf, (char)0);
                            }
                          } else {
                            {
#line 519
                            tmp___22 = strncmp((char const   *)*(argv + current_arg___0),
                                               "help\000", (size_t )5);
                            }
#line 519
                            if (tmp___22 == 0) {
                              {
#line 520
                              ipmi_lcd_usage___0();
                              }
                            } else {
                              {
#line 522
                              ipmi_lcd_usage___0();
                              }
                            }
                          }
                        }
                      } else {
                        {
#line 524
                        tmp___30 = strncmp((char const   *)*(argv + current_arg___0),
                                           "frontpanelaccess\000", (size_t )17);
                        }
#line 524
                        if (tmp___30 == 0) {
#line 525
                          current_arg___0 ++;
#line 526
                          if (argc <= current_arg___0) {
                            {
#line 527
                            ipmi_lcd_usage___0();
                            }
#line 528
                            return (-1);
                          }
                          {
#line 530
                          tmp___28 = strncmp((char const   *)*(argv + current_arg___0),
                                             "viewandmodify\000", (size_t )14);
                          }
#line 530
                          if (tmp___28 == 0) {
                            {
#line 531
                            rc = ipmi_lcd_set_lock___0(intf, (char)0);
                            }
                          } else {
                            {
#line 532
                            tmp___27 = strncmp((char const   *)*(argv + current_arg___0),
                                               "viewonly\000", (size_t )9);
                            }
#line 532
                            if (tmp___27 == 0) {
                              {
#line 533
                              rc = ipmi_lcd_set_lock___0(intf, (char)1);
                              }
                            } else {
                              {
#line 534
                              tmp___26 = strncmp((char const   *)*(argv + current_arg___0),
                                                 "disabled\000", (size_t )9);
                              }
#line 534
                              if (tmp___26 == 0) {
                                {
#line 535
                                rc = ipmi_lcd_set_lock___0(intf, (char)2);
                                }
                              } else {
                                {
#line 536
                                tmp___25 = strncmp((char const   *)*(argv + current_arg___0),
                                                   "help\000", (size_t )5);
                                }
#line 536
                                if (tmp___25 == 0) {
                                  {
#line 537
                                  ipmi_lcd_usage___0();
                                  }
                                } else {
                                  {
#line 539
                                  ipmi_lcd_usage___0();
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          {
#line 541
                          tmp___29 = strncmp((char const   *)*(argv + current_arg___0),
                                             "help\000", (size_t )5);
                          }
#line 541
                          if (tmp___29 == 0) {
#line 541
                            if ((int )iDRAC_FLAG == 0) {
                              {
#line 543
                              ipmi_lcd_usage___0();
                              }
                            } else {
                              {
#line 545
                              ipmi_lcd_usage___0();
                              }
#line 546
                              return (-1);
                            }
                          } else {
                            {
#line 545
                            ipmi_lcd_usage___0();
                            }
#line 546
                            return (-1);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          {
#line 549
          ipmi_lcd_usage___0();
          }
#line 550
          return (-1);
        }
      }
    }
  } else {
    {
#line 358
    lprintf(3, "lcd is not supported on this system.");
    }
#line 359
    return (-1);
  }
#line 552
  return (rc);
}
}
#line 623 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_idracvalidator_command___0(struct ipmi_intf *intf ) 
{ 
  int rc ;
  uint8_t data[11] ;

  {
  {
#line 628
  rc = ipmi_mc_getsysinfo(intf, 221, 2, 0, (int )sizeof(data), (void *)(data));
  }
#line 630
  if (rc < 0) {
#line 632
    return (-1);
  } else
#line 633
  if (rc > 0) {
#line 636
    return (-1);
  }
#line 639
  if (10 == (int )data[10]) {
#line 643
    iDRAC_FLAG = (uint8_t )1;
  } else
#line 639
  if (11 == (int )data[10]) {
#line 643
    iDRAC_FLAG = (uint8_t )1;
  } else
#line 639
  if (13 == (int )data[10]) {
#line 643
    iDRAC_FLAG = (uint8_t )1;
  } else
#line 639
  if (14 == (int )data[10]) {
#line 643
    iDRAC_FLAG = (uint8_t )1;
  } else
#line 644
  if (16 == (int )data[10]) {
#line 646
    iDRAC_FLAG = (uint8_t )2;
  } else
#line 644
  if (17 == (int )data[10]) {
#line 646
    iDRAC_FLAG = (uint8_t )2;
  } else {
#line 648
    iDRAC_FLAG = (uint8_t )0;
  }
#line 650
  IMC_Type = (unsigned char volatile   )data[10];
#line 651
  return (0);
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_get_configure_command_wh___0(struct ipmi_intf *intf ) 
{ 
  int rc ;
  char const   *tmp ;

  {
  {
#line 671
  rc = ipmi_mc_getsysinfo(intf, 194, 0, 0, (int )sizeof(lcd_mode), (void *)(& lcd_mode));
  }
#line 673
  if (rc < 0) {
    {
#line 674
    lprintf(3, "Error getting LCD configuration");
    }
#line 675
    return (-1);
  } else
#line 676
  if (rc == 193) {
    {
#line 677
    lprintf(3, "Error getting LCD configuration: Command not supported on this system.");
    }
  } else
#line 676
  if (rc == 203) {
    {
#line 677
    lprintf(3, "Error getting LCD configuration: Command not supported on this system.");
    }
  } else
#line 679
  if (rc > 0) {
    {
#line 680
    tmp = val2str((uint16_t )rc, completion_code_vals);
#line 680
    lprintf(3, "Error getting LCD configuration: %s", tmp);
    }
#line 682
    return (-1);
  }
#line 684
  return (0);
}
}
#line 697 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_get_configure_command___0(struct ipmi_intf *intf , uint8_t *command ) 
{ 
  uint8_t data[4] ;
  int rc ;
  char const   *tmp ;

  {
  {
#line 702
  rc = ipmi_mc_getsysinfo(intf, 194, 0, 0, (int )sizeof(data), (void *)(data));
  }
#line 704
  if (rc < 0) {
    {
#line 705
    lprintf(3, "Error getting LCD configuration");
    }
#line 706
    return (-1);
  } else
#line 707
  if (rc == 193) {
    {
#line 708
    lprintf(3, "Error getting LCD configuration: Command not supported on this system.");
    }
#line 710
    return (-1);
  } else
#line 707
  if (rc == 203) {
    {
#line 708
    lprintf(3, "Error getting LCD configuration: Command not supported on this system.");
    }
#line 710
    return (-1);
  } else
#line 711
  if (rc > 0) {
    {
#line 712
    tmp = val2str((uint16_t )rc, completion_code_vals);
#line 712
    lprintf(3, "Error getting LCD configuration: %s", tmp);
    }
#line 714
    return (-1);
  }
#line 717
  *command = data[1];
#line 718
  return (0);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_set_configure_command___0(struct ipmi_intf *intf , int command ) 
{ 
  uint8_t data[2] ;
  int rc ;
  char const   *tmp ;

  {
  {
#line 736
  data[0] = (uint8_t )194;
#line 737
  data[1] = (uint8_t )command;
#line 738
  rc = ipmi_mc_setsysinfo(intf, 2, (void *)(data));
  }
#line 739
  if (rc < 0) {
    {
#line 740
    lprintf(3, "Error setting LCD configuration");
    }
#line 741
    return (-1);
  } else
#line 742
  if (rc == 193) {
    {
#line 743
    lprintf(3, "Error setting LCD configuration: Command not supported on this system.");
    }
  } else
#line 742
  if (rc == 203) {
    {
#line 743
    lprintf(3, "Error setting LCD configuration: Command not supported on this system.");
    }
  } else
#line 745
  if (rc > 0) {
    {
#line 746
    tmp = val2str((uint16_t )rc, completion_code_vals);
#line 746
    lprintf(3, "Error setting LCD configuration: %s", tmp);
    }
#line 748
    return (-1);
  }
#line 750
  return (0);
}
}
#line 763 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_set_configure_command_wh___0(struct ipmi_intf *intf , uint32_t mode ,
                                                 uint16_t lcdquallifier , uint8_t errordisp ) 
{ 
  uint8_t data[13] ;
  int rc ;
  char const   *tmp ;

  {
  {
#line 770
  ipmi_lcd_get_configure_command_wh___0(intf);
#line 771
  data[0] = (uint8_t )194;
  }
#line 772
  if (mode != 255U) {
#line 773
    data[1] = (uint8_t )(mode & 255U);
#line 774
    data[2] = (uint8_t )((mode & 65280U) >> 8);
#line 775
    data[3] = (uint8_t )((mode & 16711680U) >> 16);
#line 776
    data[4] = (uint8_t )((mode & 4278190080U) >> 24);
  } else {
#line 778
    data[1] = (uint8_t )(lcd_mode.lcdmode & 255U);
#line 779
    data[2] = (uint8_t )((lcd_mode.lcdmode & 65280U) >> 8);
#line 780
    data[3] = (uint8_t )((lcd_mode.lcdmode & 16711680U) >> 16);
#line 781
    data[4] = (uint8_t )((lcd_mode.lcdmode & 4278190080U) >> 24);
  }
#line 783
  if ((int )lcdquallifier != 255) {
#line 784
    if ((int )lcdquallifier == 1) {
#line 785
      data[5] = (uint8_t )((int )lcd_mode.lcdquallifier | 1);
    } else
#line 786
    if ((int )lcdquallifier == 0) {
#line 787
      data[5] = (uint8_t )((int )lcd_mode.lcdquallifier & 254);
    } else
#line 788
    if ((int )lcdquallifier == 3) {
#line 789
      data[5] = (uint8_t )((int )lcd_mode.lcdquallifier | 2);
    } else
#line 790
    if ((int )lcdquallifier == 2) {
#line 791
      data[5] = (uint8_t )((int )lcd_mode.lcdquallifier & 253);
    }
  } else {
#line 794
    data[5] = (uint8_t )lcd_mode.lcdquallifier;
  }
#line 796
  if ((int )errordisp != 255) {
#line 797
    data[11] = errordisp;
  } else {
#line 799
    data[11] = lcd_mode.error_display;
  }
  {
#line 801
  rc = ipmi_mc_setsysinfo(intf, 13, (void *)(data));
  }
#line 802
  if (rc < 0) {
    {
#line 803
    lprintf(3, "Error setting LCD configuration");
    }
#line 804
    return (-1);
  } else
#line 805
  if (rc == 193) {
    {
#line 806
    lprintf(3, "Error setting LCD configuration: Command not supported on this system.");
    }
  } else
#line 805
  if (rc == 203) {
    {
#line 806
    lprintf(3, "Error setting LCD configuration: Command not supported on this system.");
    }
  } else
#line 808
  if (rc > 0) {
    {
#line 809
    tmp = val2str((uint16_t )rc, completion_code_vals);
#line 809
    lprintf(3, "Error setting LCD configuration: %s", tmp);
    }
#line 811
    return (-1);
  }
#line 813
  return (0);
}
}
#line 825 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_get_single_line_text___0(struct ipmi_intf *intf , char *lcdstring ,
                                             uint8_t max_length ) 
{ 
  IPMI_DELL_LCD_STRING lcdstringblock ;
  int lcdstring_len ;
  int bytes_copied ;
  int ii ;
  int rc ;
  int bytes_to_copy ;
  char const   *tmp ;
  int string_offset ;

  {
#line 830
  lcdstring_len = 0;
#line 831
  bytes_copied = 0;
#line 833
  ii = 0;
  {
#line 833
  while (1) {
    while_continue: /* CIL Label */ ;
#line 833
    if (! (ii < 4)) {
#line 833
      goto while_break;
    }
    {
#line 835
    rc = ipmi_mc_getsysinfo(intf, 193, ii, 0, (int )sizeof(lcdstringblock), (void *)(& lcdstringblock));
    }
#line 837
    if (rc < 0) {
      {
#line 838
      lprintf(3, "Error getting text data");
      }
#line 839
      return (-1);
    } else
#line 840
    if (rc > 0) {
      {
#line 841
      tmp = val2str((uint16_t )rc, completion_code_vals);
#line 841
      lprintf(3, "Error getting text data: %s", tmp);
      }
#line 843
      return (-1);
    }
#line 846
    if (0 == ii) {
#line 847
      lcdstring_len = (int )lcdstringblock.lcd_string.selector_0_string.length;
#line 848
      if (lcdstring_len < 1) {
#line 849
        goto while_break;
      } else
#line 848
      if (lcdstring_len > (int )max_length) {
#line 849
        goto while_break;
      }
#line 851
      if (lcdstring_len < 14) {
#line 851
        bytes_to_copy = lcdstring_len;
      } else {
#line 851
        bytes_to_copy = 14;
      }
      {
#line 852
      memcpy((void */* __restrict  */)lcdstring, (void const   */* __restrict  */)(lcdstringblock.lcd_string.selector_0_string.data),
             (size_t )bytes_to_copy);
      }
    } else {
#line 856
      if (lcdstring_len - bytes_copied < 16) {
#line 856
        bytes_to_copy = lcdstring_len - bytes_copied;
      } else {
#line 856
        bytes_to_copy = 16;
      }
#line 858
      if (bytes_to_copy < 1) {
#line 859
        goto while_break;
      }
      {
#line 861
      string_offset = 14 + 16 * (ii - 1);
#line 863
      memcpy((void */* __restrict  */)(lcdstring + string_offset), (void const   */* __restrict  */)(lcdstringblock.lcd_string.selector_n_data),
             (size_t )bytes_to_copy);
      }
    }
#line 866
    bytes_copied += bytes_to_copy;
#line 867
    if (bytes_copied >= lcdstring_len) {
#line 868
      goto while_break;
    }
#line 833
    ii ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 871
  return (0);
}
}
#line 881 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_get_info_wh___0(struct ipmi_intf *intf ) 
{ 
  IPMI_DELL_LCD_CAPS lcd_caps ;
  char lcdstring[63] ;
  unsigned int tmp ;
  int rc ;
  int tmp___0 ;
  char text[63] ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;

  {
#line 885
  lcdstring[0] = (char)0;
#line 885
  tmp = 1U;
  {
#line 885
  while (1) {
    while_continue: /* CIL Label */ ;
#line 885
    if (tmp >= 63U) {
#line 885
      goto while_break;
    }
#line 885
    lcdstring[tmp] = (char)0;
#line 885
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 887
  printf((char const   */* __restrict  */)"LCD info\n");
#line 888
  tmp___0 = ipmi_lcd_get_configure_command_wh___0(intf);
  }
#line 888
  if (tmp___0 != 0) {
#line 889
    return (-1);
  }
#line 891
  if (lcd_mode.lcdmode == 1U) {
#line 892
    text[0] = (char)0;
#line 892
    tmp___1 = 1U;
    {
#line 892
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 892
      if (tmp___1 >= 63U) {
#line 892
        goto while_break___0;
      }
#line 892
      text[tmp___1] = (char)0;
#line 892
      tmp___1 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 893
    tmp___2 = ipmi_lcd_get_platform_model_name(intf, text, (uint8_t )62, (uint8_t )209);
    }
#line 893
    if (tmp___2 != 0) {
#line 896
      return (-1);
    }
    {
#line 898
    printf((char const   */* __restrict  */)"    Setting:Model name\n");
#line 899
    printf((char const   */* __restrict  */)"    Line 1:  %s\n", text);
    }
  } else
#line 900
  if (lcd_mode.lcdmode == 2U) {
    {
#line 901
    printf((char const   */* __restrict  */)"    Setting:   none\n");
    }
  } else
#line 902
  if (lcd_mode.lcdmode == 0U) {
    {
#line 903
    printf((char const   */* __restrict  */)"    Setting: User defined\n");
#line 904
    rc = ipmi_mc_getsysinfo(intf, 207, 0, 0, (int )sizeof(lcd_caps), (void *)(& lcd_caps));
    }
#line 906
    if (rc < 0) {
      {
#line 907
      lprintf(3, "Error getting LCD capabilities.");
      }
#line 908
      return (-1);
    } else
#line 909
    if (rc == 193) {
      {
#line 910
      lprintf(3, "Error getting LCD capabilities: Command not supported on this system.");
      }
    } else
#line 909
    if (rc == 203) {
      {
#line 910
      lprintf(3, "Error getting LCD capabilities: Command not supported on this system.");
      }
    } else
#line 912
    if (rc > 0) {
      {
#line 913
      tmp___3 = val2str((uint16_t )rc, completion_code_vals);
#line 913
      lprintf(3, "Error getting LCD capabilities: %s", tmp___3);
      }
#line 915
      return (-1);
    }
#line 917
    if ((int )lcd_caps.number_lines > 0) {
      {
#line 918
      memset((void *)(lcdstring), 0, (size_t )63);
#line 919
      rc = ipmi_lcd_get_single_line_text___0(intf, lcdstring, lcd_caps.max_chars[0]);
#line 921
      printf((char const   */* __restrict  */)"    Text:    %s\n", lcdstring);
      }
    } else {
      {
#line 923
      printf((char const   */* __restrict  */)"    No lines to show\n");
      }
    }
  } else
#line 925
  if (lcd_mode.lcdmode == 4U) {
    {
#line 926
    printf((char const   */* __restrict  */)"    Setting:   IPV4 Address\n");
    }
  } else
#line 927
  if (lcd_mode.lcdmode == 8U) {
    {
#line 928
    printf((char const   */* __restrict  */)"    Setting:   MAC Address\n");
    }
  } else
#line 929
  if (lcd_mode.lcdmode == 16U) {
    {
#line 930
    printf((char const   */* __restrict  */)"    Setting:   OS System Name\n");
    }
  } else
#line 931
  if (lcd_mode.lcdmode == 32U) {
    {
#line 932
    printf((char const   */* __restrict  */)"    Setting:   System Tag\n");
    }
  } else
#line 933
  if (lcd_mode.lcdmode == 64U) {
    {
#line 934
    printf((char const   */* __restrict  */)"    Setting:  IPV6 Address\n");
    }
  } else
#line 935
  if (lcd_mode.lcdmode == 512U) {
    {
#line 936
    printf((char const   */* __restrict  */)"    Setting:  Asset Tag\n");
    }
  } else
#line 937
  if (lcd_mode.lcdmode == 128U) {
    {
#line 938
    printf((char const   */* __restrict  */)"    Setting:  Ambient Temp\n");
    }
#line 939
    if ((int )lcd_mode.lcdquallifier & 2) {
      {
#line 940
      printf((char const   */* __restrict  */)"    Unit:  F\n");
      }
    } else {
      {
#line 942
      printf((char const   */* __restrict  */)"    Unit:  C\n");
      }
    }
  } else
#line 944
  if (lcd_mode.lcdmode == 256U) {
    {
#line 945
    printf((char const   */* __restrict  */)"    Setting:  System Watts\n");
    }
#line 946
    if ((int )lcd_mode.lcdquallifier & 1) {
      {
#line 947
      printf((char const   */* __restrict  */)"    Unit:  BTU/hr\n");
      }
    } else {
      {
#line 949
      printf((char const   */* __restrict  */)"    Unit:  Watt\n");
      }
    }
  }
#line 952
  if ((int )lcd_mode.error_display == 1) {
    {
#line 953
    printf((char const   */* __restrict  */)"    Error Display:  SEL\n");
    }
  } else
#line 954
  if ((int )lcd_mode.error_display == 2) {
    {
#line 955
    printf((char const   */* __restrict  */)"    Error Display:  Simple\n");
    }
  }
#line 957
  return (0);
}
}
#line 967 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_get_info___0(struct ipmi_intf *intf ) 
{ 
  IPMI_DELL_LCD_CAPS lcd_caps ;
  uint8_t command ;
  char lcdstring[63] ;
  unsigned int tmp ;
  int rc ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
#line 971
  command = (uint8_t )0;
#line 972
  lcdstring[0] = (char)0;
#line 972
  tmp = 1U;
  {
#line 972
  while (1) {
    while_continue: /* CIL Label */ ;
#line 972
    if (tmp >= 63U) {
#line 972
      goto while_break;
    }
#line 972
    lcdstring[tmp] = (char)0;
#line 972
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 975
  printf((char const   */* __restrict  */)"LCD info\n");
#line 977
  tmp___0 = ipmi_lcd_get_configure_command___0(intf, & command);
  }
#line 977
  if (tmp___0 != 0) {
#line 978
    return (-1);
  }
#line 980
  if ((int )command == 1) {
    {
#line 981
    memset((void *)(lcdstring), 0, (size_t )63);
#line 982
    tmp___1 = ipmi_lcd_get_platform_model_name(intf, lcdstring, (uint8_t )62, (uint8_t )209);
    }
#line 982
    if (tmp___1 != 0) {
#line 985
      return (-1);
    }
    {
#line 987
    printf((char const   */* __restrict  */)"    Setting: default\n");
#line 988
    printf((char const   */* __restrict  */)"    Line 1:  %s\n", lcdstring);
    }
  } else
#line 989
  if ((int )command == 2) {
    {
#line 990
    printf((char const   */* __restrict  */)"    Setting:   none\n");
    }
  } else
#line 991
  if ((int )command == 0) {
    {
#line 992
    printf((char const   */* __restrict  */)"    Setting: custom\n");
#line 993
    rc = ipmi_mc_getsysinfo(intf, 207, 0, 0, (int )sizeof(lcd_caps), (void *)(& lcd_caps));
    }
#line 995
    if (rc < 0) {
      {
#line 996
      lprintf(3, "Error getting LCD capabilities.");
      }
#line 997
      return (-1);
    } else
#line 998
    if (rc == 193) {
      {
#line 999
      lprintf(3, "Error getting LCD capabilities: Command not supported on this system.");
      }
    } else
#line 998
    if (rc == 203) {
      {
#line 999
      lprintf(3, "Error getting LCD capabilities: Command not supported on this system.");
      }
    } else
#line 1001
    if (rc > 0) {
      {
#line 1002
      tmp___2 = val2str((uint16_t )rc, completion_code_vals);
#line 1002
      lprintf(3, "Error getting LCD capabilities: %s", tmp___2);
      }
#line 1004
      return (-1);
    }
#line 1006
    if ((int )lcd_caps.number_lines > 0) {
      {
#line 1007
      memset((void *)(lcdstring), 0, (size_t )63);
#line 1008
      rc = ipmi_lcd_get_single_line_text___0(intf, lcdstring, lcd_caps.max_chars[0]);
#line 1010
      printf((char const   */* __restrict  */)"    Text:    %s\n", lcdstring);
      }
    } else {
      {
#line 1012
      printf((char const   */* __restrict  */)"    No lines to show\n");
      }
    }
  }
#line 1015
  return (0);
}
}
#line 1025 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_get_status_val___0(struct ipmi_intf *intf , LCD_STATUS *lcdstatus ) 
{ 
  int rc ;
  char const   *tmp ;

  {
  {
#line 1029
  rc = ipmi_mc_getsysinfo(intf, 231, 0, 0, (int )sizeof(*lcdstatus), (void *)lcdstatus);
  }
#line 1031
  if (rc < 0) {
    {
#line 1032
    lprintf(3, "Error getting LCD Status");
    }
#line 1033
    return (-1);
  } else
#line 1034
  if (rc == 193) {
    {
#line 1035
    lprintf(3, "Error getting LCD status: Command not supported on this system.");
    }
#line 1037
    return (-1);
  } else
#line 1034
  if (rc == 203) {
    {
#line 1035
    lprintf(3, "Error getting LCD status: Command not supported on this system.");
    }
#line 1037
    return (-1);
  } else
#line 1038
  if (rc > 0) {
    {
#line 1039
    tmp = val2str((uint16_t )rc, completion_code_vals);
#line 1039
    lprintf(3, "Error getting LCD Status: %s", tmp);
    }
#line 1041
    return (-1);
  }
#line 1043
  return (0);
}
}
#line 1053 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int IsLCDSupported___0(void) 
{ 


  {
#line 1056
  return ((int )LcdSupported___0);
}
}
#line 1066 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void CheckLCDSupport___0(struct ipmi_intf *intf ) 
{ 
  int rc ;

  {
  {
#line 1070
  LcdSupported___0 = (uint8_t )0;
#line 1071
  rc = ipmi_mc_getsysinfo(intf, 231, 0, 0, 0, (void *)0);
  }
#line 1072
  if (rc == 0) {
#line 1073
    LcdSupported___0 = (uint8_t )1;
  }
#line 1075
  return;
}
}
#line 1084 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void ipmi_lcd_status_print___0(LCD_STATUS lcdstatus ) 
{ 


  {
  {
#line 1088
  if ((int )lcdstatus.vKVM_status == 0) {
#line 1088
    goto case_0;
  }
#line 1091
  if ((int )lcdstatus.vKVM_status == 1) {
#line 1091
    goto case_1;
  }
#line 1094
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1089
  printf((char const   */* __restrict  */)"LCD KVM Status :Inactive\n");
  }
#line 1090
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1092
  printf((char const   */* __restrict  */)"LCD KVM Status :Active\n");
  }
#line 1093
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1095
  printf((char const   */* __restrict  */)"LCD KVM Status :Invalid Status\n");
  }
#line 1096
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1099
  if ((int )lcdstatus.lock_status == 0) {
#line 1099
    goto case_0___0;
  }
#line 1102
  if ((int )lcdstatus.lock_status == 1) {
#line 1102
    goto case_1___0;
  }
#line 1105
  if ((int )lcdstatus.lock_status == 2) {
#line 1105
    goto case_2;
  }
#line 1108
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
  {
#line 1100
  printf((char const   */* __restrict  */)"LCD lock Status :View and modify\n");
  }
#line 1101
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 1103
  printf((char const   */* __restrict  */)"LCD lock Status :View only\n");
  }
#line 1104
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 1106
  printf((char const   */* __restrict  */)"LCD lock Status :disabled\n");
  }
#line 1107
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 1109
  printf((char const   */* __restrict  */)"LCD lock Status :Invalid\n");
  }
#line 1110
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1112
  return;
}
}
#line 1122 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_get_status___0(struct ipmi_intf *intf ) 
{ 
  int rc ;
  LCD_STATUS lcdstatus ;

  {
  {
#line 1125
  rc = 0;
#line 1127
  rc = ipmi_lcd_get_status_val___0(intf, & lcdstatus);
  }
#line 1128
  if (rc < 0) {
#line 1129
    return (-1);
  }
  {
#line 1131
  ipmi_lcd_status_print___0(lcdstatus);
  }
#line 1132
  return (rc);
}
}
#line 1144 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_set_kvm___0(struct ipmi_intf *intf , char status ) 
{ 
  LCD_STATUS lcdstatus ;
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t data[5] ;
  char const   *tmp ;

  {
  {
#line 1149
  rc = 0;
#line 1150
  rsp = (struct ipmi_rs *)((void *)0);
#line 1151
  req.msg.netfn = (uint8_t )0;
#line 1151
  req.msg.lun = (unsigned char)0;
#line 1151
  req.msg.cmd = (unsigned char)0;
#line 1151
  req.msg.target_cmd = (unsigned char)0;
#line 1151
  req.msg.data_len = (unsigned short)0;
#line 1151
  req.msg.data = (uint8_t *)0;
#line 1153
  rc = ipmi_lcd_get_status_val___0(intf, & lcdstatus);
  }
#line 1154
  if (rc < 0) {
#line 1155
    return (-1);
  }
  {
#line 1157
  req.msg.netfn = (uint8_t )6;
#line 1158
  req.msg.lun = (uint8_t )0;
#line 1159
  req.msg.cmd = (uint8_t )88;
#line 1160
  req.msg.data_len = (uint16_t )5;
#line 1161
  req.msg.data = data;
#line 1162
  data[0] = (uint8_t )231;
#line 1163
  data[1] = (uint8_t )status;
#line 1164
  data[2] = (uint8_t )lcdstatus.lock_status;
#line 1165
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 1166
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 1167
    lprintf(3, "Error setting LCD status");
#line 1168
    rc = -1;
    }
  } else
#line 1169
  if ((int )rsp->ccode == 193) {
    {
#line 1170
    lprintf(3, "Error getting LCD status: Command not supported on this system.");
    }
#line 1172
    return (-1);
  } else
#line 1169
  if ((int )rsp->ccode == 203) {
    {
#line 1170
    lprintf(3, "Error getting LCD status: Command not supported on this system.");
    }
#line 1172
    return (-1);
  } else
#line 1173
  if ((int )rsp->ccode > 0) {
    {
#line 1174
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 1174
    lprintf(3, "Error setting LCD status: %s", tmp);
#line 1176
    rc = -1;
    }
  }
#line 1178
  return (rc);
}
}
#line 1190 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_set_lock___0(struct ipmi_intf *intf , char lock ) 
{ 
  LCD_STATUS lcdstatus ;
  int rc ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t data[5] ;
  char const   *tmp ;

  {
  {
#line 1195
  rc = 0;
#line 1196
  rsp = (struct ipmi_rs *)((void *)0);
#line 1197
  req.msg.netfn = (uint8_t )0;
#line 1197
  req.msg.lun = (unsigned char)0;
#line 1197
  req.msg.cmd = (unsigned char)0;
#line 1197
  req.msg.target_cmd = (unsigned char)0;
#line 1197
  req.msg.data_len = (unsigned short)0;
#line 1197
  req.msg.data = (uint8_t *)0;
#line 1199
  rc = ipmi_lcd_get_status_val___0(intf, & lcdstatus);
  }
#line 1200
  if (rc < 0) {
#line 1201
    return (-1);
  }
  {
#line 1203
  req.msg.netfn = (uint8_t )6;
#line 1204
  req.msg.lun = (uint8_t )0;
#line 1205
  req.msg.cmd = (uint8_t )88;
#line 1206
  req.msg.data_len = (uint16_t )5;
#line 1207
  req.msg.data = data;
#line 1208
  data[0] = (uint8_t )231;
#line 1209
  data[1] = (uint8_t )lcdstatus.vKVM_status;
#line 1210
  data[2] = (uint8_t )lock;
#line 1211
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 1212
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 1213
    lprintf(3, "Error setting LCD status");
#line 1214
    rc = -1;
    }
  } else
#line 1215
  if ((int )rsp->ccode == 193) {
    {
#line 1216
    lprintf(3, "Error getting LCD status: Command not supported on this system.");
#line 1218
    rc = -1;
    }
  } else
#line 1215
  if ((int )rsp->ccode == 203) {
    {
#line 1216
    lprintf(3, "Error getting LCD status: Command not supported on this system.");
#line 1218
    rc = -1;
    }
  } else
#line 1219
  if ((int )rsp->ccode > 0) {
    {
#line 1220
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 1220
    lprintf(3, "Error setting LCD status: %s", tmp);
#line 1222
    rc = -1;
    }
  }
#line 1224
  return (rc);
}
}
#line 1236 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_set_single_line_text___0(struct ipmi_intf *intf , char *text ) 
{ 
  uint8_t data[18] ;
  int bytes_to_store ;
  size_t tmp ;
  int bytes_stored ;
  int ii ;
  int rc ;
  int size_of_copy ;
  int tmp___0 ;
  int size_of_copy___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 1240
  tmp = strlen((char const   *)text);
#line 1240
  bytes_to_store = (int )tmp;
#line 1241
  bytes_stored = 0;
#line 1243
  rc = 0;
  }
#line 1244
  if (bytes_to_store > 62) {
    {
#line 1245
    lprintf(3, "Out of range Max limit is 62 characters");
    }
#line 1246
    return (-1);
  } else {
#line 1248
    if (bytes_to_store < 62) {
#line 1248
      bytes_to_store = bytes_to_store;
    } else {
#line 1248
      bytes_to_store = 62;
    }
#line 1249
    ii = 0;
    {
#line 1249
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1249
      if (! (ii < 4)) {
#line 1249
        goto while_break;
      }
#line 1251
      if (0 == ii) {
#line 1252
        if (bytes_to_store - bytes_stored < 14) {
#line 1252
          tmp___0 = bytes_to_store - bytes_stored;
        } else {
#line 1252
          tmp___0 = 14;
        }
#line 1252
        size_of_copy = tmp___0;
#line 1254
        if (size_of_copy < 0) {
#line 1256
          goto while_break;
        }
        {
#line 1258
        data[0] = (uint8_t )193;
#line 1259
        data[1] = (uint8_t )ii;
#line 1260
        data[2] = (uint8_t )0;
#line 1261
        data[3] = (uint8_t )bytes_to_store;
#line 1262
        memcpy((void */* __restrict  */)(data + 4), (void const   */* __restrict  */)(text + bytes_stored),
               (size_t )size_of_copy);
#line 1263
        bytes_stored += size_of_copy;
        }
      } else {
#line 1265
        if (bytes_to_store - bytes_stored < 16) {
#line 1265
          tmp___1 = bytes_to_store - bytes_stored;
        } else {
#line 1265
          tmp___1 = 16;
        }
#line 1265
        size_of_copy___0 = tmp___1;
#line 1267
        if (size_of_copy___0 <= 0) {
#line 1268
          goto while_break;
        }
        {
#line 1270
        data[0] = (uint8_t )193;
#line 1271
        data[1] = (uint8_t )ii;
#line 1272
        memcpy((void */* __restrict  */)(data + 2), (void const   */* __restrict  */)(text + bytes_stored),
               (size_t )size_of_copy___0);
#line 1273
        bytes_stored += size_of_copy___0;
        }
      }
      {
#line 1275
      rc = ipmi_mc_setsysinfo(intf, 18, (void *)(data));
      }
#line 1276
      if (rc < 0) {
        {
#line 1277
        lprintf(3, "Error setting text data");
#line 1278
        rc = -1;
        }
      } else
#line 1279
      if (rc > 0) {
        {
#line 1280
        tmp___2 = val2str((uint16_t )rc, completion_code_vals);
#line 1280
        lprintf(3, "Error setting text data: %s", tmp___2);
#line 1282
        rc = -1;
        }
      }
#line 1249
      ii ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1286
  return (rc);
}
}
#line 1299 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_set_text___0(struct ipmi_intf *intf , char *text , int line_number ) 
{ 
  int rc ;
  IPMI_DELL_LCD_CAPS lcd_caps ;
  char const   *tmp ;

  {
  {
#line 1302
  rc = 0;
#line 1304
  rc = ipmi_mc_getsysinfo(intf, 207, 0, 0, (int )sizeof(lcd_caps), (void *)(& lcd_caps));
  }
#line 1306
  if (rc < 0) {
    {
#line 1307
    lprintf(3, "Error getting LCD capabilities");
    }
#line 1308
    return (-1);
  } else
#line 1309
  if (rc > 0) {
    {
#line 1310
    tmp = val2str((uint16_t )rc, completion_code_vals);
#line 1310
    lprintf(3, "Error getting LCD capabilities: %s", tmp);
    }
#line 1312
    return (-1);
  }
#line 1314
  if ((int )lcd_caps.number_lines > 0) {
    {
#line 1315
    rc = ipmi_lcd_set_single_line_text___0(intf, text);
    }
  } else {
    {
#line 1317
    lprintf(3, "LCD does not have any lines that can be set");
#line 1318
    rc = -1;
    }
  }
#line 1320
  return (rc);
}
}
#line 1335 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_configure_wh___0(struct ipmi_intf *intf , uint32_t mode , uint16_t lcdquallifier ,
                                     uint8_t errordisp , int8_t line_number , char *text ) 
{ 
  int rc ;

  {
#line 1339
  rc = 0;
#line 1340
  if (0U == mode) {
    {
#line 1342
    rc = ipmi_lcd_set_text___0(intf, text, (int )line_number);
    }
  }
#line 1344
  if (rc == 0) {
    {
#line 1345
    rc = ipmi_lcd_set_configure_command_wh___0(intf, mode, lcdquallifier, errordisp);
    }
  }
#line 1347
  return (rc);
}
}
#line 1361 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lcd_configure___0(struct ipmi_intf *intf , int command , int8_t line_number ,
                                  char *text ) 
{ 
  int rc ;

  {
#line 1365
  rc = 0;
#line 1366
  if (0 == command) {
    {
#line 1367
    rc = ipmi_lcd_set_text___0(intf, text, (int )line_number);
    }
  }
#line 1369
  if (rc == 0) {
    {
#line 1370
    rc = ipmi_lcd_set_configure_command___0(intf, command);
    }
  }
#line 1372
  return (rc);
}
}
#line 1383 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void ipmi_lcd_usage___0(void) 
{ 


  {
  {
#line 1386
  lprintf(5, "");
#line 1388
  lprintf(5, "Generic DELL HW:");
#line 1390
  lprintf(5, "   lcd set {none}|{default}|{custom <text>}");
#line 1392
  lprintf(5, "      Set LCD text displayed during non-fault conditions");
#line 1394
  lprintf(5, "");
#line 1396
  lprintf(5, "iDRAC 11g or iDRAC 12g:");
#line 1398
  lprintf(5, "   lcd set {mode}|{lcdqualifier}|{errordisplay}");
#line 1400
  lprintf(5, "      Allows you to set the LCD mode and user-defined string.");
#line 1402
  lprintf(5, "");
#line 1404
  lprintf(5, "   lcd set mode {none}|{modelname}|{ipv4address}|{macaddress}|");
#line 1406
  lprintf(5, "   {systemname}|{servicetag}|{ipv6address}|{ambienttemp}");
#line 1408
  lprintf(5, "   {systemwatt }|{assettag}|{userdefined}<text>");
#line 1410
  lprintf(5, "\t   Allows you to set the LCD display mode to any of the preceding");
#line 1412
  lprintf(5, "      parameters");
#line 1414
  lprintf(5, "");
#line 1416
  lprintf(5, "   lcd set lcdqualifier {watt}|{btuphr}|{celsius}|{fahrenheit}");
#line 1418
  lprintf(5, "      Allows you to set the unit for the system ambient temperature mode.");
#line 1420
  lprintf(5, "");
#line 1422
  lprintf(5, "   lcd set errordisplay {sel}|{simple}");
#line 1424
  lprintf(5, "      Allows you to set the error display.");
#line 1426
  lprintf(5, "");
#line 1428
  lprintf(5, "   lcd info");
#line 1430
  lprintf(5, "      Show LCD text that is displayed during non-fault conditions");
#line 1432
  lprintf(5, "");
#line 1434
  lprintf(5, "");
#line 1436
  lprintf(5, "   lcd set vkvm{active}|{inactive}");
#line 1438
  lprintf(5, "      Set vKVM active and inactive, message will be displayed on lcd");
#line 1440
  lprintf(5, "      when vKVM is active and vKVM session is in progress");
#line 1442
  lprintf(5, "");
#line 1444
  lprintf(5, "   lcd set frontpanelaccess {viewandmodify}|{viewonly}|{disabled}");
#line 1446
  lprintf(5, "      Set LCD mode to view and modify, view only or disabled ");
#line 1448
  lprintf(5, "");
#line 1450
  lprintf(5, "   lcd status");
#line 1452
  lprintf(5, "      Show LCD Status for vKVM display<active|inactive>");
#line 1454
  lprintf(5, "      and Front Panel access mode {viewandmodify}|{viewonly}|{disabled}");
#line 1456
  lprintf(5, "");
  }
#line 1458
  return;
}
}
#line 1471 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_delloem_mac_main___0(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int rc ;
  int currIdInt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1474
  rc = 0;
#line 1475
  currIdInt = -1;
#line 1476
  current_arg___0 ++;
#line 1477
  if (argc > 1) {
    {
#line 1477
    tmp = strcmp((char const   *)*(argv + current_arg___0), "help");
    }
#line 1477
    if (tmp == 0) {
      {
#line 1478
      ipmi_mac_usage___0();
      }
#line 1479
      return (0);
    }
  }
  {
#line 1481
  ipmi_idracvalidator_command___0(intf);
  }
#line 1482
  if (argc == 1) {
    {
#line 1483
    rc = ipmi_macinfo___0(intf, (uint8_t )255);
    }
  } else {
    {
#line 1484
    tmp___2 = strncmp((char const   *)*(argv + current_arg___0), "list\000", (size_t )5);
    }
#line 1484
    if (tmp___2 == 0) {
      {
#line 1485
      rc = ipmi_macinfo___0(intf, (uint8_t )255);
      }
    } else {
      {
#line 1486
      tmp___1 = strncmp((char const   *)*(argv + current_arg___0), "get\000", (size_t )4);
      }
#line 1486
      if (tmp___1 == 0) {
#line 1487
        current_arg___0 ++;
#line 1488
        if ((unsigned long )*(argv + current_arg___0) == (unsigned long )((void *)0)) {
          {
#line 1489
          ipmi_mac_usage___0();
          }
#line 1490
          return (-1);
        }
        {
#line 1492
        tmp___0 = str2int((char const   *)*(argv + current_arg___0), & currIdInt);
        }
#line 1492
        if (tmp___0 != 0) {
          {
#line 1493
          lprintf(3, "Invalid NIC number. The NIC number should be between 0-8");
          }
#line 1495
          return (-1);
        }
#line 1497
        if (currIdInt > 8) {
          {
#line 1498
          lprintf(3, "Invalid NIC number. The NIC number should be between 0-8");
          }
#line 1500
          return (-1);
        } else
#line 1497
        if (currIdInt < 0) {
          {
#line 1498
          lprintf(3, "Invalid NIC number. The NIC number should be between 0-8");
          }
#line 1500
          return (-1);
        }
        {
#line 1502
        rc = ipmi_macinfo___0(intf, (uint8_t )currIdInt);
        }
      } else {
        {
#line 1504
        ipmi_mac_usage___0();
        }
      }
    }
  }
#line 1506
  return (rc);
}
}
#line 1513 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void InitEmbeddedNICMacAddressValues___0(void) 
{ 
  uint8_t i ;
  uint8_t j ;

  {
#line 1518
  i = (uint8_t )0;
  {
#line 1518
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1518
    if (! ((int )i < 8)) {
#line 1518
      goto while_break;
    }
#line 1519
    EmbeddedNICMacAddress.LOMMacAddress[i].BladSlotNumber = 0U;
#line 1520
    EmbeddedNICMacAddress.LOMMacAddress[i].MacType = 3U;
#line 1521
    EmbeddedNICMacAddress.LOMMacAddress[i].EthernetStatus = 3U;
#line 1523
    EmbeddedNICMacAddress.LOMMacAddress[i].NICNumber = 0U;
#line 1524
    EmbeddedNICMacAddress.LOMMacAddress[i].Reserved = 0U;
#line 1525
    j = (uint8_t )0;
    {
#line 1525
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1525
      if (! ((int )j < 6)) {
#line 1525
        goto while_break___0;
      }
#line 1526
      EmbeddedNICMacAddress.LOMMacAddress[i].MacAddressByte[j] = (uint8_t )0;
#line 1527
      EmbeddedNICMacAddress_10G.MacAddress[i].MacAddressByte[j] = (uint8_t )0;
#line 1525
      j = (uint8_t )((int )j + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1518
    i = (uint8_t )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 1530
  return;
}
}
#line 1533 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_macinfo_drac_idrac_virtual_mac___0(struct ipmi_intf *intf , uint8_t NicNum ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[30] ;
  uint8_t VirtualMacAddress[6] ;
  uint8_t input_length ;
  uint8_t j ;
  uint8_t i ;
  uint8_t tmp ;

  {
#line 1540
  input_length = (uint8_t )0;
#line 1543
  if ((int )NicNum != 255) {
#line 1543
    if ((int )NicNum != 8) {
#line 1544
      return (0);
    }
  }
  {
#line 1546
  UseVirtualMacAddress = (uint8_t )0;
#line 1547
  input_length = (uint8_t )0;
#line 1548
  tmp = input_length;
#line 1548
  input_length = (uint8_t )((int )input_length + 1);
#line 1548
  msg_data[tmp] = (uint8_t )1;
#line 1550
  req.msg.netfn = (uint8_t )48;
#line 1551
  req.msg.lun = (uint8_t )0;
#line 1552
  req.msg.cmd = (uint8_t )201;
#line 1553
  req.msg.data = msg_data;
#line 1554
  req.msg.data_len = (uint16_t )input_length;
#line 1556
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 1557
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
#line 1558
    return (-1);
  }
#line 1560
  if ((int )rsp->ccode > 0) {
#line 1561
    return (-1);
  }
#line 1563
  if (17 == (int )IMC_Type) {
#line 1563
    goto _L;
  } else
#line 1563
  if (16 == (int )IMC_Type) {
    _L: /* CIL Label */ 
    {
#line 1566
    memcpy((void */* __restrict  */)(VirtualMacAddress), (void const   */* __restrict  */)(rsp->data + 1),
           (size_t )6);
#line 1567
    i = (uint8_t )0;
    }
    {
#line 1567
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1567
      if (! ((int )i < 6)) {
#line 1567
        goto while_break;
      }
#line 1568
      if ((int )VirtualMacAddress[i] != 0) {
#line 1569
        UseVirtualMacAddress = (uint8_t )1;
      }
#line 1567
      i = (uint8_t )((int )i + 1);
    }
    while_break: /* CIL Label */ ;
    }
#line 1573
    if (! UseVirtualMacAddress) {
      {
#line 1574
      memcpy((void */* __restrict  */)(VirtualMacAddress), (void const   */* __restrict  */)((rsp->data + 1) + 6),
             (size_t )6);
#line 1576
      i = (uint8_t )0;
      }
      {
#line 1576
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1576
        if (! ((int )i < 6)) {
#line 1576
          goto while_break___0;
        }
#line 1577
        if ((int )VirtualMacAddress[i] != 0) {
#line 1578
          UseVirtualMacAddress = (uint8_t )1;
        }
#line 1576
        i = (uint8_t )((int )i + 1);
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 1583
    memcpy((void */* __restrict  */)(VirtualMacAddress), (void const   */* __restrict  */)(rsp->data + 1),
           (size_t )6);
#line 1585
    i = (uint8_t )0;
    }
    {
#line 1585
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1585
      if (! ((int )i < 6)) {
#line 1585
        goto while_break___1;
      }
#line 1586
      if ((int )VirtualMacAddress[i] != 0) {
#line 1587
        UseVirtualMacAddress = (uint8_t )1;
      }
#line 1585
      i = (uint8_t )((int )i + 1);
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1591
  if ((int )UseVirtualMacAddress == 0) {
#line 1592
    return (-1);
  }
#line 1594
  if (8 == (int )IMC_Type) {
    {
#line 1595
    printf((char const   */* __restrict  */)"\nDRAC MAC Address ");
    }
  } else
#line 1596
  if (11 == (int )IMC_Type) {
    {
#line 1598
    printf((char const   */* __restrict  */)"\niDRAC6 MAC Address ");
    }
  } else
#line 1596
  if (10 == (int )IMC_Type) {
    {
#line 1598
    printf((char const   */* __restrict  */)"\niDRAC6 MAC Address ");
    }
  } else
#line 1599
  if (17 == (int )IMC_Type) {
    {
#line 1601
    printf((char const   */* __restrict  */)"\niDRAC7 MAC Address ");
    }
  } else
#line 1599
  if (16 == (int )IMC_Type) {
    {
#line 1601
    printf((char const   */* __restrict  */)"\niDRAC7 MAC Address ");
    }
  } else
#line 1602
  if (13 == (int )IMC_Type) {
    {
#line 1604
    printf((char const   */* __restrict  */)"\nBMC MAC Address ");
    }
  } else
#line 1602
  if (14 == (int )IMC_Type) {
    {
#line 1604
    printf((char const   */* __restrict  */)"\nBMC MAC Address ");
    }
  } else {
    {
#line 1606
    printf((char const   */* __restrict  */)"\niDRAC6 MAC Address ");
    }
  }
#line 1609
  j = (uint8_t )0;
  {
#line 1609
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1609
    if (! ((int )j < 5)) {
#line 1609
      goto while_break___2;
    }
    {
#line 1610
    printf((char const   */* __restrict  */)"%02x:", (int )VirtualMacAddress[j]);
#line 1609
    j = (uint8_t )((int )j + 1);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1612
  printf((char const   */* __restrict  */)"%02x", (int )VirtualMacAddress[j]);
#line 1613
  printf((char const   */* __restrict  */)"\n");
  }
#line 1614
  return (0);
}
}
#line 1624 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_macinfo_drac_idrac_mac___0(struct ipmi_intf *intf , uint8_t NicNum ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[30] ;
  uint8_t input_length ;
  uint8_t iDRAC6MacAddressByte[6] ;
  uint8_t j ;
  uint8_t tmp ;
  uint8_t tmp___0 ;
  uint8_t tmp___1 ;
  uint8_t tmp___2 ;
  char const   *tmp___3 ;

  {
  {
#line 1630
  input_length = (uint8_t )0;
#line 1633
  ipmi_macinfo_drac_idrac_virtual_mac___0(intf, NicNum);
  }
#line 1634
  if ((int )NicNum != 255) {
#line 1634
    if ((int )NicNum != 8) {
#line 1636
      return (0);
    } else {
#line 1634
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1634
  if ((int )UseVirtualMacAddress != 0) {
#line 1636
    return (0);
  }
  {
#line 1638
  input_length = (uint8_t )0;
#line 1639
  tmp = input_length;
#line 1639
  input_length = (uint8_t )((int )input_length + 1);
#line 1639
  msg_data[tmp] = (uint8_t )1;
#line 1640
  tmp___0 = input_length;
#line 1640
  input_length = (uint8_t )((int )input_length + 1);
#line 1640
  msg_data[tmp___0] = (uint8_t )5;
#line 1641
  tmp___1 = input_length;
#line 1641
  input_length = (uint8_t )((int )input_length + 1);
#line 1641
  msg_data[tmp___1] = (uint8_t )0;
#line 1642
  tmp___2 = input_length;
#line 1642
  input_length = (uint8_t )((int )input_length + 1);
#line 1642
  msg_data[tmp___2] = (uint8_t )0;
#line 1644
  req.msg.netfn = (uint8_t )12;
#line 1645
  req.msg.lun = (uint8_t )0;
#line 1646
  req.msg.cmd = (uint8_t )2;
#line 1647
  req.msg.data = msg_data;
#line 1648
  req.msg.data_len = (uint16_t )input_length;
#line 1650
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 1651
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 1652
    lprintf(3, "Error in getting MAC Address");
    }
#line 1653
    return (-1);
  }
#line 1655
  if ((int )rsp->ccode > 0) {
    {
#line 1656
    tmp___3 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 1656
    lprintf(3, "Error in getting MAC Address (%s)", tmp___3);
    }
#line 1658
    return (-1);
  }
  {
#line 1660
  memcpy((void */* __restrict  */)(iDRAC6MacAddressByte), (void const   */* __restrict  */)(rsp->data + 1),
         (size_t )6);
  }
#line 1663
  if (8 == (int )IMC_Type) {
    {
#line 1664
    printf((char const   */* __restrict  */)"\nDRAC MAC Address ");
    }
  } else
#line 1665
  if (11 == (int )IMC_Type) {
    {
#line 1667
    printf((char const   */* __restrict  */)"\niDRAC6 MAC Address ");
    }
  } else
#line 1665
  if (10 == (int )IMC_Type) {
    {
#line 1667
    printf((char const   */* __restrict  */)"\niDRAC6 MAC Address ");
    }
  } else
#line 1668
  if (17 == (int )IMC_Type) {
    {
#line 1670
    printf((char const   */* __restrict  */)"\niDRAC7 MAC Address ");
    }
  } else
#line 1668
  if (16 == (int )IMC_Type) {
    {
#line 1670
    printf((char const   */* __restrict  */)"\niDRAC7 MAC Address ");
    }
  } else
#line 1671
  if (13 == (int )IMC_Type) {
    {
#line 1673
    printf((char const   */* __restrict  */)"\n\rBMC MAC Address ");
    }
  } else
#line 1671
  if (14 == (int )IMC_Type) {
    {
#line 1673
    printf((char const   */* __restrict  */)"\n\rBMC MAC Address ");
    }
  } else {
    {
#line 1675
    printf((char const   */* __restrict  */)"\niDRAC6 MAC Address ");
    }
  }
#line 1678
  j = (uint8_t )0;
  {
#line 1678
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1678
    if (! ((int )j < 5)) {
#line 1678
      goto while_break;
    }
    {
#line 1679
    printf((char const   */* __restrict  */)"%02x:", (int )iDRAC6MacAddressByte[j]);
#line 1678
    j = (uint8_t )((int )j + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1681
  printf((char const   */* __restrict  */)"%02x", (int )iDRAC6MacAddressByte[j]);
#line 1682
  printf((char const   */* __restrict  */)"\n");
  }
#line 1683
  return (0);
}
}
#line 1694 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_macinfo_10g___0(struct ipmi_intf *intf , uint8_t NicNum ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[30] ;
  uint8_t input_length ;
  uint8_t j ;
  uint8_t i ;
  uint8_t Total_No_NICs ;
  uint8_t tmp ;
  uint8_t tmp___0 ;
  uint8_t tmp___1 ;
  uint8_t tmp___2 ;
  char const   *tmp___3 ;

  {
  {
#line 1700
  input_length = (uint8_t )0;
#line 1703
  Total_No_NICs = (uint8_t )0;
#line 1704
  InitEmbeddedNICMacAddressValues___0();
#line 1705
  memset((void *)(msg_data), 0, sizeof(msg_data));
#line 1706
  input_length = (uint8_t )0;
#line 1707
  tmp = input_length;
#line 1707
  input_length = (uint8_t )((int )input_length + 1);
#line 1707
  msg_data[tmp] = (uint8_t )0;
#line 1708
  tmp___0 = input_length;
#line 1708
  input_length = (uint8_t )((int )input_length + 1);
#line 1708
  msg_data[tmp___0] = (uint8_t )203;
#line 1709
  tmp___1 = input_length;
#line 1709
  input_length = (uint8_t )((int )input_length + 1);
#line 1709
  msg_data[tmp___1] = (uint8_t )0;
#line 1710
  tmp___2 = input_length;
#line 1710
  input_length = (uint8_t )((int )input_length + 1);
#line 1710
  msg_data[tmp___2] = (uint8_t )0;
#line 1711
  memset((void *)(& req), 0, sizeof(req));
#line 1712
  req.msg.netfn = (uint8_t )6;
#line 1713
  req.msg.lun = (uint8_t )0;
#line 1714
  req.msg.cmd = (uint8_t )89;
#line 1715
  req.msg.data = msg_data;
#line 1716
  req.msg.data_len = (uint16_t )input_length;
#line 1717
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 1718
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 1719
    lprintf(3, "Error in getting MAC Address");
    }
#line 1720
    return (-1);
  }
#line 1722
  if ((int )rsp->ccode > 0) {
    {
#line 1723
    tmp___3 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 1723
    lprintf(3, "Error in getting MAC Address (%s)", tmp___3);
    }
#line 1725
    return (-1);
  }
#line 1727
  Total_No_NICs = rsp->data[1];
#line 1728
  if (8 != (int )NicNum) {
#line 1729
    if (255 == (int )NicNum) {
      {
#line 1730
      printf((char const   */* __restrict  */)"\nSystem LOMs");
      }
    }
    {
#line 1732
    printf((char const   */* __restrict  */)"\nNIC Number\tMAC Address\n");
#line 1733
    memcpy((void */* __restrict  */)(& EmbeddedNICMacAddress_10G), (void const   */* __restrict  */)((rsp->data + 1) + 1),
           (size_t )((int )Total_No_NICs * 6));
#line 1737
    i = (uint8_t )0;
    }
    {
#line 1737
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1737
      if (! ((int )i < (int )Total_No_NICs)) {
#line 1737
        goto while_break;
      }
#line 1738
      if (255 == (int )NicNum) {
#line 1738
        goto _L;
      } else
#line 1738
      if ((int )i == (int )NicNum) {
        _L: /* CIL Label */ 
        {
#line 1739
        printf((char const   */* __restrict  */)"\n%d", (int )i);
#line 1740
        printf((char const   */* __restrict  */)"\t\t");
#line 1741
        j = (uint8_t )0;
        }
        {
#line 1741
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1741
          if (! ((int )j < 5)) {
#line 1741
            goto while_break___0;
          }
          {
#line 1742
          printf((char const   */* __restrict  */)"%02x:", (int )EmbeddedNICMacAddress_10G.MacAddress[i].MacAddressByte[j]);
#line 1741
          j = (uint8_t )((int )j + 1);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1745
        printf((char const   */* __restrict  */)"%02x", (int )EmbeddedNICMacAddress_10G.MacAddress[i].MacAddressByte[j]);
        }
      }
#line 1737
      i = (uint8_t )((int )i + 1);
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1749
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 1751
  ipmi_macinfo_drac_idrac_mac___0(intf, NicNum);
  }
#line 1752
  return (0);
}
}
#line 1762 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_macinfo_11g___0(struct ipmi_intf *intf , uint8_t NicNum ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t input_length ;
  uint8_t i ;
  uint8_t j ;
  uint8_t len ;
  uint8_t loop_count ;
  uint8_t maxlen ;
  uint8_t msg_data[30] ;
  uint8_t offset ;
  uint8_t tmp ;
  uint8_t tmp___0 ;
  uint8_t tmp___1 ;
  uint8_t tmp___2 ;
  uint8_t tmp___3 ;
  uint8_t tmp___4 ;
  char const   *tmp___5 ;
  uint8_t tmp___6 ;
  uint8_t tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 1767
  input_length = (uint8_t )0;
#line 1775
  offset = (uint8_t )0;
#line 1776
  len = (uint8_t )8;
#line 1777
  maxlen = (uint8_t )64;
#line 1778
  loop_count = (uint8_t )((int )maxlen / (int )len);
#line 1779
  InitEmbeddedNICMacAddressValues___0();
#line 1780
  memset((void *)(msg_data), 0, sizeof(msg_data));
#line 1781
  input_length = (uint8_t )0;
#line 1782
  tmp = input_length;
#line 1782
  input_length = (uint8_t )((int )input_length + 1);
#line 1782
  msg_data[tmp] = (uint8_t )0;
#line 1783
  tmp___0 = input_length;
#line 1783
  input_length = (uint8_t )((int )input_length + 1);
#line 1783
  msg_data[tmp___0] = (uint8_t )218;
#line 1784
  tmp___1 = input_length;
#line 1784
  input_length = (uint8_t )((int )input_length + 1);
#line 1784
  msg_data[tmp___1] = (uint8_t )0;
#line 1785
  tmp___2 = input_length;
#line 1785
  input_length = (uint8_t )((int )input_length + 1);
#line 1785
  msg_data[tmp___2] = (uint8_t )0;
#line 1786
  tmp___3 = input_length;
#line 1786
  input_length = (uint8_t )((int )input_length + 1);
#line 1786
  msg_data[tmp___3] = (uint8_t )0;
#line 1787
  tmp___4 = input_length;
#line 1787
  input_length = (uint8_t )((int )input_length + 1);
#line 1787
  msg_data[tmp___4] = (uint8_t )0;
#line 1789
  memset((void *)(& req), 0, sizeof(req));
#line 1790
  req.msg.netfn = (uint8_t )6;
#line 1791
  req.msg.lun = (uint8_t )0;
#line 1792
  req.msg.cmd = (uint8_t )89;
#line 1793
  req.msg.data = msg_data;
#line 1794
  req.msg.data_len = (uint16_t )input_length;
#line 1796
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 1797
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 1798
    lprintf(3, "Error in getting MAC Address");
    }
#line 1799
    return (-1);
  }
#line 1801
  if ((int )rsp->ccode > 0) {
    {
#line 1802
    tmp___5 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 1802
    lprintf(3, "Error in getting MAC Address (%s)", tmp___5);
    }
#line 1804
    return (-1);
  }
#line 1806
  len = (uint8_t )8;
#line 1807
  maxlen = rsp->data[1];
#line 1808
  loop_count = (uint8_t )((int )maxlen / (int )len);
#line 1809
  if (8 != (int )NicNum) {
#line 1810
    if (255 == (int )NicNum) {
      {
#line 1811
      printf((char const   */* __restrict  */)"\nSystem LOMs");
      }
    }
    {
#line 1813
    printf((char const   */* __restrict  */)"\nNIC Number\tMAC Address\t\tStatus\n");
#line 1815
    offset = (uint8_t )0;
#line 1816
    i = (uint8_t )0;
    }
    {
#line 1816
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1816
      if (! ((int )i < (int )loop_count)) {
#line 1816
        goto while_break;
      }
      {
#line 1817
      input_length = (uint8_t )4;
#line 1818
      tmp___6 = input_length;
#line 1818
      input_length = (uint8_t )((int )input_length + 1);
#line 1818
      msg_data[tmp___6] = offset;
#line 1819
      tmp___7 = input_length;
#line 1819
      input_length = (uint8_t )((int )input_length + 1);
#line 1819
      msg_data[tmp___7] = len;
#line 1821
      req.msg.netfn = (uint8_t )6;
#line 1822
      req.msg.lun = (uint8_t )0;
#line 1823
      req.msg.cmd = (uint8_t )89;
#line 1824
      req.msg.data = msg_data;
#line 1825
      req.msg.data_len = (uint16_t )input_length;
#line 1827
      rsp = (*(intf->sendrecv))(intf, & req);
      }
#line 1828
      if ((unsigned long )rsp == (unsigned long )((void *)0)) {
        {
#line 1829
        lprintf(3, "Error in getting MAC Address");
        }
#line 1830
        return (-1);
      }
#line 1832
      if ((int )rsp->ccode > 0) {
        {
#line 1833
        tmp___8 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 1833
        lprintf(3, "Error in getting MAC Address (%s)", tmp___8);
        }
#line 1835
        return (-1);
      }
      {
#line 1837
      memcpy((void */* __restrict  */)(& EmbeddedNICMacAddress.LOMMacAddress[i]),
             (void const   */* __restrict  */)(rsp->data + 1), (size_t )len);
      }
#line 1839
      if (0U == EmbeddedNICMacAddress.LOMMacAddress[i].MacType) {
#line 1840
        if (255 == (int )NicNum) {
#line 1840
          goto _L;
        } else
#line 1840
        if ((unsigned int )NicNum == EmbeddedNICMacAddress.LOMMacAddress[i].NICNumber) {
          _L: /* CIL Label */ 
          {
#line 1842
          printf((char const   */* __restrict  */)"\n%d", EmbeddedNICMacAddress.LOMMacAddress[i].NICNumber);
#line 1843
          printf((char const   */* __restrict  */)"\t\t");
#line 1844
          j = (uint8_t )0;
          }
          {
#line 1844
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1844
            if (! ((int )j < 5)) {
#line 1844
              goto while_break___0;
            }
            {
#line 1845
            printf((char const   */* __restrict  */)"%02x:", (int )EmbeddedNICMacAddress.LOMMacAddress[i].MacAddressByte[j]);
#line 1844
            j = (uint8_t )((int )j + 1);
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 1848
          printf((char const   */* __restrict  */)"%02x", (int )EmbeddedNICMacAddress.LOMMacAddress[i].MacAddressByte[j]);
          }
#line 1851
          if (0U == EmbeddedNICMacAddress.LOMMacAddress[i].EthernetStatus) {
            {
#line 1853
            printf((char const   */* __restrict  */)"\tEnabled");
            }
          } else {
            {
#line 1855
            printf((char const   */* __restrict  */)"\tDisabled");
            }
          }
        }
      }
#line 1816
      i = (uint8_t )((int )i + 1);
#line 1816
      offset = (uint8_t )((int )offset + (int )len);
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1860
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 1862
  ipmi_macinfo_drac_idrac_mac___0(intf, NicNum);
  }
#line 1863
  return (0);
}
}
#line 1873 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_macinfo___0(struct ipmi_intf *intf , uint8_t NicNum ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1876
  if (8 == (int )IMC_Type) {
    {
#line 1877
    tmp = ipmi_macinfo_10g___0(intf, NicNum);
    }
#line 1877
    return (tmp);
  } else
#line 1878
  if (11 == (int )IMC_Type) {
    {
#line 1883
    tmp___0 = ipmi_macinfo_11g___0(intf, NicNum);
    }
#line 1883
    return (tmp___0);
  } else
#line 1878
  if (10 == (int )IMC_Type) {
    {
#line 1883
    tmp___0 = ipmi_macinfo_11g___0(intf, NicNum);
    }
#line 1883
    return (tmp___0);
  } else
#line 1878
  if (17 == (int )IMC_Type) {
    {
#line 1883
    tmp___0 = ipmi_macinfo_11g___0(intf, NicNum);
    }
#line 1883
    return (tmp___0);
  } else
#line 1878
  if (16 == (int )IMC_Type) {
    {
#line 1883
    tmp___0 = ipmi_macinfo_11g___0(intf, NicNum);
    }
#line 1883
    return (tmp___0);
  } else
#line 1878
  if (14 == (int )IMC_Type) {
    {
#line 1883
    tmp___0 = ipmi_macinfo_11g___0(intf, NicNum);
    }
#line 1883
    return (tmp___0);
  } else
#line 1878
  if (13 == (int )IMC_Type) {
    {
#line 1883
    tmp___0 = ipmi_macinfo_11g___0(intf, NicNum);
    }
#line 1883
    return (tmp___0);
  } else {
    {
#line 1885
    lprintf(3, "Error in getting MAC Address : Not supported platform");
    }
#line 1886
    return (-1);
  }
}
}
#line 1898 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void ipmi_mac_usage___0(void) 
{ 


  {
  {
#line 1901
  lprintf(5, "");
#line 1903
  lprintf(5, "   mac list");
#line 1905
  lprintf(5, "      Lists the MAC address of LOMs");
#line 1907
  lprintf(5, "");
#line 1909
  lprintf(5, "   mac get <NIC number>");
#line 1911
  lprintf(5, "      Shows the MAC address of specified LOM. 0-7 System LOM, 8- DRAC/iDRAC.");
#line 1913
  lprintf(5, "");
  }
#line 1915
  return;
}
}
#line 1928 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_delloem_lan_main___0(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int rc ;
  int nic_selection ;
  char nic_set[2] ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1931
  rc = 0;
#line 1932
  nic_selection = 0;
#line 1933
  nic_set[0] = (char)0;
#line 1933
  tmp = 1U;
  {
#line 1933
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1933
    if (tmp >= 2U) {
#line 1933
      goto while_break;
    }
#line 1933
    nic_set[tmp] = (char)0;
#line 1933
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1934
  current_arg___0 ++;
#line 1935
  if ((unsigned long )*(argv + current_arg___0) == (unsigned long )((void *)0)) {
    {
#line 1936
    ipmi_lan_usage___0();
    }
#line 1937
    return (0);
  } else {
    {
#line 1935
    tmp___0 = strcmp((char const   *)*(argv + current_arg___0), "help");
    }
#line 1935
    if (tmp___0 == 0) {
      {
#line 1936
      ipmi_lan_usage___0();
      }
#line 1937
      return (0);
    }
  }
  {
#line 1939
  ipmi_idracvalidator_command___0(intf);
#line 1940
  tmp___4 = IsLANSupported___0();
  }
#line 1940
  if (tmp___4) {
    {
#line 1943
    tmp___3 = strncmp((char const   *)*(argv + current_arg___0), "set\000", (size_t )4);
    }
#line 1943
    if (tmp___3 == 0) {
#line 1944
      current_arg___0 ++;
#line 1945
      if ((unsigned long )*(argv + current_arg___0) == (unsigned long )((void *)0)) {
        {
#line 1946
        ipmi_lan_usage___0();
        }
#line 1947
        return (-1);
      }
#line 1949
      if ((int )iDRAC_FLAG == 2) {
        {
#line 1950
        nic_selection = get_nic_selection_mode_12g(intf, current_arg___0, argv, nic_set);
        }
#line 1952
        if (-1 == nic_selection) {
          {
#line 1953
          ipmi_lan_usage___0();
          }
#line 1954
          return (-1);
        } else
#line 1955
        if (-2 == nic_selection) {
          {
#line 1956
          lprintf(3, "ERROR: Cannot set shared with failover lom same as current shared lom.");
          }
#line 1957
          return (-1);
        } else
#line 1958
        if (-3 == nic_selection) {
          {
#line 1959
          lprintf(3, "ERROR: Cannot set shared with failover loms when NIC is set to dedicated Mode.");
          }
#line 1960
          return (-1);
        } else
#line 1961
        if (-4 == nic_selection) {
          {
#line 1962
          lprintf(3, "ERROR: Cannot set shared Mode for Blades.");
          }
#line 1963
          return (-1);
        }
        {
#line 1965
        rc = ipmi_lan_set_nic_selection_12g___0(intf, (uint8_t *)(nic_set));
        }
      } else {
        {
#line 1967
        nic_selection = get_nic_selection_mode___0(current_arg___0, argv);
        }
#line 1968
        if (-1 == nic_selection) {
          {
#line 1969
          ipmi_lan_usage___0();
          }
#line 1970
          return (-1);
        }
#line 1972
        if (11 == (int )IMC_Type) {
          {
#line 1973
          lprintf(3, "ERROR: Cannot set shared Mode for Blades.");
          }
#line 1974
          return (-1);
        }
        {
#line 1976
        rc = ipmi_lan_set_nic_selection___0(intf, (uint8_t )nic_selection);
        }
      }
#line 1978
      return (0);
    } else {
      {
#line 1979
      tmp___2 = strncmp((char const   *)*(argv + current_arg___0), "get\000", (size_t )4);
      }
#line 1979
      if (tmp___2 == 0) {
#line 1980
        current_arg___0 ++;
#line 1981
        if ((unsigned long )*(argv + current_arg___0) == (unsigned long )((void *)0)) {
          {
#line 1982
          rc = ipmi_lan_get_nic_selection___0(intf);
          }
#line 1983
          return (rc);
        } else {
          {
#line 1984
          tmp___1 = strncmp((char const   *)*(argv + current_arg___0), "active\000",
                            (size_t )7);
          }
#line 1984
          if (tmp___1 == 0) {
            {
#line 1985
            rc = ipmi_lan_get_active_nic___0(intf);
            }
#line 1986
            return (rc);
          } else {
            {
#line 1988
            ipmi_lan_usage___0();
            }
          }
        }
      } else {
        {
#line 1991
        ipmi_lan_usage___0();
        }
#line 1992
        return (-1);
      }
    }
  } else {
    {
#line 1941
    lprintf(3, "lan is not supported on this system.");
    }
#line 1942
    return (-1);
  }
#line 1994
  return (rc);
}
}
#line 1997 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int IsLANSupported___0(void) 
{ 


  {
#line 2000
  if (11 == (int )IMC_Type) {
#line 2001
    return (0);
  }
#line 2003
  return (1);
}
}
#line 2174 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int get_nic_selection_mode___0(int current_arg___1 , char **argv ) 
{ 
  int nic_selection_mode ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 2177
  nic_selection_mode = 0;
#line 2178
  if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
    {
#line 2178
    tmp = strncmp((char const   *)*(argv + current_arg___1), "dedicated\000", (size_t )10);
    }
#line 2178
    if (tmp == 0) {
#line 2180
      return (2);
    }
  }
#line 2182
  if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
    {
#line 2182
    tmp___0 = strncmp((char const   *)*(argv + current_arg___1), "shared\000", (size_t )7);
    }
#line 2182
    if (tmp___0 == 0) {
#line 2184
      if ((unsigned long )*(argv + (current_arg___1 + 1)) == (unsigned long )((void *)0)) {
#line 2185
        return (0);
      }
    }
  }
#line 2189
  current_arg___1 ++;
#line 2190
  if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
    {
#line 2190
    tmp___1 = strncmp((char const   *)*(argv + current_arg___1), "with\000", (size_t )5);
    }
#line 2190
    if (! (tmp___1 == 0)) {
#line 2194
      return (-1);
    }
  } else {
#line 2194
    return (-1);
  }
#line 2197
  current_arg___1 ++;
#line 2198
  if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
    {
#line 2198
    tmp___2 = strncmp((char const   *)*(argv + current_arg___1), "failover\000", (size_t )9);
    }
#line 2198
    if (! (tmp___2 == 0)) {
#line 2202
      return (-1);
    }
  } else {
#line 2202
    return (-1);
  }
#line 2205
  current_arg___1 ++;
#line 2206
  if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
    {
#line 2206
    tmp___4 = strncmp((char const   *)*(argv + current_arg___1), "lom2\000", (size_t )5);
    }
#line 2206
    if (tmp___4 == 0) {
#line 2208
      return (1);
    } else {
#line 2206
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2209
  if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
    {
#line 2209
    tmp___3 = strncmp((char const   *)*(argv + current_arg___1), "all\000", (size_t )4);
    }
#line 2209
    if (! (tmp___3 == 0)) {
#line 2213
      return (-1);
    }
  } else {
#line 2213
    return (-1);
  }
#line 2216
  current_arg___1 ++;
#line 2217
  if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
    {
#line 2217
    tmp___5 = strncmp((char const   *)*(argv + current_arg___1), "loms\000", (size_t )5);
    }
#line 2217
    if (tmp___5 == 0) {
#line 2219
      return (3);
    }
  }
#line 2221
  return (-1);
}
}
#line 2224 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lan_set_nic_selection_12g___0(struct ipmi_intf *intf , uint8_t *nic_selection ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t input_length ;
  uint8_t msg_data[30] ;
  uint8_t tmp ;
  uint8_t tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 2229
  input_length = (uint8_t )0;
#line 2232
  input_length = (uint8_t )0;
#line 2233
  tmp = input_length;
#line 2233
  input_length = (uint8_t )((int )input_length + 1);
#line 2233
  msg_data[tmp] = *(nic_selection + 0);
#line 2234
  tmp___0 = input_length;
#line 2234
  input_length = (uint8_t )((int )input_length + 1);
#line 2234
  msg_data[tmp___0] = *(nic_selection + 1);
#line 2235
  req.msg.netfn = (uint8_t )48;
#line 2236
  req.msg.lun = (uint8_t )0;
#line 2237
  req.msg.cmd = (uint8_t )40;
#line 2238
  req.msg.data = msg_data;
#line 2239
  req.msg.data_len = (uint16_t )input_length;
#line 2240
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2241
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2242
    lprintf(3, "Error in setting nic selection");
    }
#line 2243
    return (-1);
  } else
#line 2244
  if ((int )*(nic_selection + 0) == 1) {
#line 2244
    if ((int )iDRAC_FLAG == 2) {
#line 2244
      if ((int )rsp->ccode == 111) {
        {
#line 2247
        lprintf(3, "FM001 : A required license is missing or expired");
        }
#line 2249
        return (-1);
      } else {
#line 2244
        goto _L;
      }
    } else {
#line 2244
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2250
  if ((int )rsp->ccode > 0) {
    {
#line 2251
    tmp___1 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2251
    lprintf(3, "Error in setting nic selection (%s)", tmp___1);
    }
#line 2253
    return (-1);
  }
  {
#line 2255
  printf((char const   */* __restrict  */)"configured successfully");
  }
#line 2256
  return (0);
}
}
#line 2259 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lan_set_nic_selection___0(struct ipmi_intf *intf , uint8_t nic_selection ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t input_length ;
  uint8_t msg_data[30] ;
  uint8_t tmp ;
  char const   *tmp___0 ;

  {
  {
#line 2264
  input_length = (uint8_t )0;
#line 2267
  input_length = (uint8_t )0;
#line 2268
  tmp = input_length;
#line 2268
  input_length = (uint8_t )((int )input_length + 1);
#line 2268
  msg_data[tmp] = nic_selection;
#line 2269
  req.msg.netfn = (uint8_t )48;
#line 2270
  req.msg.lun = (uint8_t )0;
#line 2271
  req.msg.cmd = (uint8_t )36;
#line 2272
  req.msg.data = msg_data;
#line 2273
  req.msg.data_len = (uint16_t )input_length;
#line 2274
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2275
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2276
    lprintf(3, "Error in setting nic selection");
    }
#line 2277
    return (-1);
  } else
#line 2278
  if ((int )rsp->ccode > 0) {
    {
#line 2279
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2279
    lprintf(3, "Error in setting nic selection (%s)", tmp___0);
    }
#line 2281
    return (-1);
  }
  {
#line 2283
  printf((char const   */* __restrict  */)"configured successfully");
  }
#line 2284
  return (0);
}
}
#line 2287 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lan_get_nic_selection___0(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t input_length ;
  uint8_t msg_data[30] ;
  uint8_t nic_selection ;
  uint8_t nic_selection_failover ;
  char const   *tmp ;

  {
#line 2292
  input_length = (uint8_t )0;
#line 2294
  nic_selection = (uint8_t )-1;
#line 2295
  nic_selection_failover = (uint8_t )0;
#line 2297
  input_length = (uint8_t )0;
#line 2298
  req.msg.netfn = (uint8_t )48;
#line 2299
  req.msg.lun = (uint8_t )0;
#line 2300
  if ((int )iDRAC_FLAG == 2) {
#line 2301
    req.msg.cmd = (uint8_t )41;
  } else {
#line 2303
    req.msg.cmd = (uint8_t )37;
  }
  {
#line 2305
  req.msg.data = msg_data;
#line 2306
  req.msg.data_len = (uint16_t )input_length;
#line 2307
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2308
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2309
    lprintf(3, "Error in getting nic selection");
    }
#line 2310
    return (-1);
  } else
#line 2311
  if ((int )rsp->ccode > 0) {
    {
#line 2312
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2312
    lprintf(3, "Error in getting nic selection (%s)", tmp);
    }
#line 2314
    return (-1);
  }
#line 2316
  nic_selection = rsp->data[0];
#line 2317
  if ((int )iDRAC_FLAG == 2) {
#line 2318
    nic_selection_failover = rsp->data[1];
#line 2319
    if ((int )nic_selection < 6) {
#line 2319
      if ((int )nic_selection > 0) {
#line 2319
        if ((int )nic_selection_failover < 7) {
#line 2321
          if ((int )nic_selection == 1) {
            {
#line 2322
            printf((char const   */* __restrict  */)"%s\n", NIC_Selection_Mode_String_12g[(int )nic_selection - 1]);
            }
          } else
#line 2323
          if (nic_selection) {
            {
#line 2324
            printf((char const   */* __restrict  */)"Shared LOM   :  %s\n", NIC_Selection_Mode_String_12g[(int )nic_selection - 1]);
            }
#line 2326
            if ((int )nic_selection_failover == 0) {
              {
#line 2327
              printf((char const   */* __restrict  */)"Failover LOM :  None\n");
              }
            } else
#line 2328
            if ((int )nic_selection_failover >= 2) {
#line 2328
              if ((int )nic_selection_failover <= 6) {
                {
#line 2329
                printf((char const   */* __restrict  */)"Failover LOM :  %s\n", NIC_Selection_Mode_String_12g[(int )nic_selection_failover + 3]);
                }
              }
            }
          }
        } else {
          {
#line 2334
          lprintf(3, "Error Outof bond Value received (%d) (%d)", (int )nic_selection,
                  (int )nic_selection_failover);
          }
#line 2336
          return (-1);
        }
      } else {
        {
#line 2334
        lprintf(3, "Error Outof bond Value received (%d) (%d)", (int )nic_selection,
                (int )nic_selection_failover);
        }
#line 2336
        return (-1);
      }
    } else {
      {
#line 2334
      lprintf(3, "Error Outof bond Value received (%d) (%d)", (int )nic_selection,
              (int )nic_selection_failover);
      }
#line 2336
      return (-1);
    }
  } else {
    {
#line 2339
    printf((char const   */* __restrict  */)"%s\n", NIC_Selection_Mode_String[nic_selection]);
    }
  }
#line 2341
  return (0);
}
}
#line 2344 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_lan_get_active_nic___0(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t active_nic ;
  uint8_t current_lom ;
  uint8_t input_length ;
  uint8_t msg_data[30] ;
  uint8_t tmp ;
  uint8_t tmp___0 ;
  uint8_t tmp___1 ;
  char const   *tmp___2 ;
  uint8_t tmp___3 ;
  uint8_t tmp___4 ;
  uint8_t tmp___5 ;
  char const   *tmp___6 ;

  {
  {
#line 2349
  active_nic = (uint8_t )0;
#line 2350
  current_lom = (uint8_t )0;
#line 2351
  input_length = (uint8_t )0;
#line 2354
  input_length = (uint8_t )0;
#line 2355
  tmp = input_length;
#line 2355
  input_length = (uint8_t )((int )input_length + 1);
#line 2355
  msg_data[tmp] = (uint8_t )0;
#line 2356
  tmp___0 = input_length;
#line 2356
  input_length = (uint8_t )((int )input_length + 1);
#line 2356
  msg_data[tmp___0] = (uint8_t )0;
#line 2357
  tmp___1 = input_length;
#line 2357
  input_length = (uint8_t )((int )input_length + 1);
#line 2357
  msg_data[tmp___1] = (uint8_t )0;
#line 2358
  req.msg.netfn = (uint8_t )48;
#line 2359
  req.msg.lun = (uint8_t )0;
#line 2360
  req.msg.cmd = (uint8_t )193;
#line 2361
  req.msg.data = msg_data;
#line 2362
  req.msg.data_len = (uint16_t )input_length;
#line 2363
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2364
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2365
    lprintf(3, "Error in getting Active LOM Status");
    }
#line 2366
    return (-1);
  } else
#line 2367
  if ((int )rsp->ccode > 0) {
    {
#line 2368
    tmp___2 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2368
    lprintf(3, "Error in getting Active LOM Status (%s)", tmp___2);
    }
#line 2370
    return (-1);
  }
  {
#line 2372
  current_lom = rsp->data[0];
#line 2373
  input_length = (uint8_t )0;
#line 2374
  tmp___3 = input_length;
#line 2374
  input_length = (uint8_t )((int )input_length + 1);
#line 2374
  msg_data[tmp___3] = (uint8_t )1;
#line 2375
  tmp___4 = input_length;
#line 2375
  input_length = (uint8_t )((int )input_length + 1);
#line 2375
  msg_data[tmp___4] = (uint8_t )0;
#line 2376
  tmp___5 = input_length;
#line 2376
  input_length = (uint8_t )((int )input_length + 1);
#line 2376
  msg_data[tmp___5] = (uint8_t )0;
#line 2377
  req.msg.netfn = (uint8_t )48;
#line 2378
  req.msg.lun = (uint8_t )0;
#line 2379
  req.msg.cmd = (uint8_t )193;
#line 2380
  req.msg.data = msg_data;
#line 2381
  req.msg.data_len = (uint16_t )input_length;
#line 2382
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2383
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2384
    lprintf(3, "Error in getting Active LOM Status");
    }
#line 2385
    return (-1);
  } else
#line 2386
  if ((int )rsp->ccode > 0) {
    {
#line 2387
    tmp___6 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2387
    lprintf(3, "Error in getting Active LOM Status (%s)", tmp___6);
    }
#line 2389
    return (-1);
  }
#line 2391
  active_nic = rsp->data[1];
#line 2392
  if ((int )current_lom < 6) {
#line 2392
    if (active_nic) {
      {
#line 2393
      printf((char const   */* __restrict  */)"\n%s\n", AciveLOM_String[current_lom]);
      }
    } else {
      {
#line 2395
      printf((char const   */* __restrict  */)"\n%s\n", AciveLOM_String[0]);
      }
    }
  } else {
    {
#line 2395
    printf((char const   */* __restrict  */)"\n%s\n", AciveLOM_String[0]);
    }
  }
#line 2397
  return (0);
}
}
#line 2400 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void ipmi_lan_usage___0(void) 
{ 


  {
  {
#line 2409
  lprintf(5, "");
#line 2411
  lprintf(5, "   lan set <Mode>");
#line 2413
  lprintf(5, "      sets the NIC Selection Mode :");
#line 2415
  lprintf(5, "          on iDRAC12g :");
#line 2417
  lprintf(5, "              dedicated, shared with lom1, shared with lom2,shared with lom3,shared");
#line 2419
  lprintf(5, "              with lom4,shared with failover lom1,shared with failover lom2,shared");
#line 2421
  lprintf(5, "              with failover lom3,shared with failover lom4,shared with Failover all");
#line 2423
  lprintf(5, "              loms, shared with Failover None).");
#line 2425
  lprintf(5, "          on other systems :");
#line 2427
  lprintf(5, "              dedicated, shared, shared with failover lom2,");
#line 2429
  lprintf(5, "              shared with Failover all loms.");
#line 2431
  lprintf(5, "");
#line 2433
  lprintf(5, "   lan get ");
#line 2435
  lprintf(5, "          on iDRAC12g :");
#line 2437
  lprintf(5, "              returns the current NIC Selection Mode (dedicated, shared with lom1, shared");
#line 2439
  lprintf(5, "              with lom2, shared with lom3, shared with lom4,shared with failover lom1,");
#line 2441
  lprintf(5, "              shared with failover lom2,shared with failover lom3,shared with failover");
#line 2443
  lprintf(5, "              lom4,shared with Failover all loms,shared with Failover None).");
#line 2445
  lprintf(5, "          on other systems :");
#line 2447
  lprintf(5, "              dedicated, shared, shared with failover,");
#line 2449
  lprintf(5, "              lom2, shared with Failover all loms.");
#line 2451
  lprintf(5, "");
#line 2453
  lprintf(5, "   lan get active");
#line 2455
  lprintf(5, "      returns the current active NIC (dedicated, LOM1, LOM2, LOM3, LOM4).");
#line 2457
  lprintf(5, "");
  }
#line 2459
  return;
}
}
#line 2472 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_delloem_powermonitor_main___0(struct ipmi_intf *intf , int argc ,
                                              char **argv ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int val ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
#line 2475
  rc = 0;
#line 2476
  current_arg___0 ++;
#line 2477
  if (argc > 1) {
    {
#line 2477
    tmp = strcmp((char const   *)*(argv + current_arg___0), "help");
    }
#line 2477
    if (tmp == 0) {
      {
#line 2478
      ipmi_powermonitor_usage___0();
      }
#line 2479
      return (0);
    }
  }
  {
#line 2481
  ipmi_idracvalidator_command___0(intf);
  }
#line 2482
  if (argc == 1) {
    {
#line 2483
    rc = ipmi_powermgmt___0(intf);
    }
  } else {
    {
#line 2484
    tmp___20 = strncmp((char const   *)*(argv + current_arg___0), "status\000", (size_t )7);
    }
#line 2484
    if (tmp___20 == 0) {
      {
#line 2485
      rc = ipmi_powermgmt___0(intf);
      }
    } else {
      {
#line 2486
      tmp___19 = strncmp((char const   *)*(argv + current_arg___0), "clear\000", (size_t )6);
      }
#line 2486
      if (tmp___19 == 0) {
#line 2487
        current_arg___0 ++;
#line 2488
        if ((unsigned long )*(argv + current_arg___0) == (unsigned long )((void *)0)) {
          {
#line 2489
          ipmi_powermonitor_usage___0();
          }
#line 2490
          return (-1);
        } else {
          {
#line 2491
          tmp___1 = strncmp((char const   *)*(argv + current_arg___0), "peakpower\000",
                            (size_t )10);
          }
#line 2491
          if (tmp___1 == 0) {
            {
#line 2492
            rc = ipmi_powermgmt_clear___0(intf, (uint8_t )1);
            }
          } else {
            {
#line 2493
            tmp___0 = strncmp((char const   *)*(argv + current_arg___0), "cumulativepower\000",
                              (size_t )16);
            }
#line 2493
            if (tmp___0 == 0) {
              {
#line 2494
              rc = ipmi_powermgmt_clear___0(intf, (uint8_t )0);
              }
            } else {
              {
#line 2496
              ipmi_powermonitor_usage___0();
              }
#line 2497
              return (-1);
            }
          }
        }
      } else {
        {
#line 2499
        tmp___18 = strncmp((char const   *)*(argv + current_arg___0), "powerconsumption\000",
                           (size_t )17);
        }
#line 2499
        if (tmp___18 == 0) {
#line 2500
          current_arg___0 ++;
#line 2501
          if ((unsigned long )*(argv + current_arg___0) == (unsigned long )((void *)0)) {
            {
#line 2502
            rc = ipmi_print_get_power_consmpt_data___0(intf, (uint8_t )0);
            }
          } else {
            {
#line 2503
            tmp___3 = strncmp((char const   *)*(argv + current_arg___0), "watt\000",
                              (size_t )5);
            }
#line 2503
            if (tmp___3 == 0) {
              {
#line 2504
              rc = ipmi_print_get_power_consmpt_data___0(intf, (uint8_t )0);
              }
            } else {
              {
#line 2505
              tmp___2 = strncmp((char const   *)*(argv + current_arg___0), "btuphr\000",
                                (size_t )7);
              }
#line 2505
              if (tmp___2 == 0) {
                {
#line 2506
                rc = ipmi_print_get_power_consmpt_data___0(intf, (uint8_t )1);
                }
              } else {
                {
#line 2508
                ipmi_powermonitor_usage___0();
                }
#line 2509
                return (-1);
              }
            }
          }
        } else {
          {
#line 2511
          tmp___17 = strncmp((char const   *)*(argv + current_arg___0), "powerconsumptionhistory\000",
                             (size_t )23);
          }
#line 2511
          if (tmp___17 == 0) {
#line 2512
            current_arg___0 ++;
#line 2513
            if ((unsigned long )*(argv + current_arg___0) == (unsigned long )((void *)0)) {
              {
#line 2514
              rc = ipmi_print_power_consmpt_history___0(intf, 0);
              }
            } else {
              {
#line 2515
              tmp___5 = strncmp((char const   *)*(argv + current_arg___0), "watt\000",
                                (size_t )5);
              }
#line 2515
              if (tmp___5 == 0) {
                {
#line 2516
                rc = ipmi_print_power_consmpt_history___0(intf, 0);
                }
              } else {
                {
#line 2517
                tmp___4 = strncmp((char const   *)*(argv + current_arg___0), "btuphr\000",
                                  (size_t )7);
                }
#line 2517
                if (tmp___4 == 0) {
                  {
#line 2518
                  rc = ipmi_print_power_consmpt_history___0(intf, 1);
                  }
                } else {
                  {
#line 2520
                  ipmi_powermonitor_usage___0();
                  }
#line 2521
                  return (-1);
                }
              }
            }
          } else {
            {
#line 2523
            tmp___16 = strncmp((char const   *)*(argv + current_arg___0), "getpowerbudget\000",
                               (size_t )15);
            }
#line 2523
            if (tmp___16 == 0) {
#line 2524
              current_arg___0 ++;
#line 2525
              if ((unsigned long )*(argv + current_arg___0) == (unsigned long )((void *)0)) {
                {
#line 2526
                rc = ipmi_print_power_cap___0(intf, (uint8_t )0);
                }
              } else {
                {
#line 2527
                tmp___7 = strncmp((char const   *)*(argv + current_arg___0), "watt\000",
                                  (size_t )5);
                }
#line 2527
                if (tmp___7 == 0) {
                  {
#line 2528
                  rc = ipmi_print_power_cap___0(intf, (uint8_t )0);
                  }
                } else {
                  {
#line 2529
                  tmp___6 = strncmp((char const   *)*(argv + current_arg___0), "btuphr\000",
                                    (size_t )7);
                  }
#line 2529
                  if (tmp___6 == 0) {
                    {
#line 2530
                    rc = ipmi_print_power_cap___0(intf, (uint8_t )1);
                    }
                  } else {
                    {
#line 2532
                    ipmi_powermonitor_usage___0();
                    }
#line 2533
                    return (-1);
                  }
                }
              }
            } else {
              {
#line 2535
              tmp___15 = strncmp((char const   *)*(argv + current_arg___0), "setpowerbudget\000",
                                 (size_t )15);
              }
#line 2535
              if (tmp___15 == 0) {
#line 2537
                current_arg___0 ++;
#line 2538
                if ((unsigned long )*(argv + current_arg___0) == (unsigned long )((void *)0)) {
                  {
#line 2539
                  ipmi_powermonitor_usage___0();
                  }
#line 2540
                  return (-1);
                }
                {
#line 2542
                tmp___8 = strchr((char const   *)*(argv + current_arg___0), '.');
                }
#line 2542
                if (tmp___8) {
                  {
#line 2543
                  lprintf(3, "Cap value in Watts, Btu/hr or percent should be whole number");
                  }
#line 2545
                  return (-1);
                }
                {
#line 2547
                tmp___9 = str2int((char const   *)*(argv + current_arg___0), & val);
                }
#line 2547
                if (tmp___9 != 0) {
                  {
#line 2548
                  lprintf(3, "Given capacity value \'%s\' is invalid.", *(argv + current_arg___0));
                  }
#line 2550
                  return (-1);
                }
#line 2552
                current_arg___0 ++;
#line 2553
                if ((unsigned long )*(argv + current_arg___0) == (unsigned long )((void *)0)) {
                  {
#line 2554
                  ipmi_powermonitor_usage___0();
                  }
                } else {
                  {
#line 2555
                  tmp___12 = strncmp((char const   *)*(argv + current_arg___0), "watt\000",
                                     (size_t )5);
                  }
#line 2555
                  if (tmp___12 == 0) {
                    {
#line 2556
                    rc = ipmi_set_power_cap___0(intf, 0, val);
                    }
                  } else {
                    {
#line 2557
                    tmp___11 = strncmp((char const   *)*(argv + current_arg___0),
                                       "btuphr\000", (size_t )7);
                    }
#line 2557
                    if (tmp___11 == 0) {
                      {
#line 2558
                      rc = ipmi_set_power_cap___0(intf, 1, val);
                      }
                    } else {
                      {
#line 2559
                      tmp___10 = strncmp((char const   *)*(argv + current_arg___0),
                                         "percent\000", (size_t )8);
                      }
#line 2559
                      if (tmp___10 == 0) {
                        {
#line 2560
                        rc = ipmi_set_power_cap___0(intf, 3, val);
                        }
                      } else {
                        {
#line 2562
                        ipmi_powermonitor_usage___0();
                        }
#line 2563
                        return (-1);
                      }
                    }
                  }
                }
              } else {
                {
#line 2565
                tmp___14 = strncmp((char const   *)*(argv + current_arg___0), "enablepowercap\000",
                                   (size_t )15);
                }
#line 2565
                if (tmp___14 == 0) {
                  {
#line 2566
                  ipmi_set_power_capstatus_command___0(intf, (uint8_t )1);
                  }
                } else {
                  {
#line 2567
                  tmp___13 = strncmp((char const   *)*(argv + current_arg___0), "disablepowercap\000",
                                     (size_t )16);
                  }
#line 2567
                  if (tmp___13 == 0) {
                    {
#line 2568
                    ipmi_set_power_capstatus_command___0(intf, (uint8_t )0);
                    }
                  } else {
                    {
#line 2570
                    ipmi_powermonitor_usage___0();
                    }
#line 2571
                    return (-1);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 2573
  return (rc);
}
}
#line 2584 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void ipmi_time_to_str___0(time_t rawTime , char *strTime ) 
{ 
  struct tm *tm ;
  char *temp ;

  {
  {
#line 2589
  tm = gmtime((time_t const   *)(& rawTime));
#line 2590
  temp = asctime((struct tm  const  *)tm);
#line 2591
  strcpy((char */* __restrict  */)strTime, (char const   */* __restrict  */)temp);
  }
#line 2592
  return;
}
}
#line 2604 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_get_sensor_reading___0(struct ipmi_intf *intf , unsigned char sensorNumber ,
                                       SensorReadingType *pSensorReadingData ) 
{ 
  struct ipmi_rq req ;
  struct ipmi_rs *rsp ;
  int rc ;

  {
  {
#line 2610
  rc = 0;
#line 2611
  memset((void *)(& req), 0, sizeof(req));
#line 2612
  req.msg.netfn = (uint8_t )4;
#line 2613
  req.msg.lun = (uint8_t )0;
#line 2614
  req.msg.cmd = (uint8_t )45;
#line 2615
  req.msg.data = & sensorNumber;
#line 2616
  req.msg.data_len = (uint16_t )1;
  }
#line 2617
  if ((unsigned long )pSensorReadingData == (unsigned long )((void *)0)) {
#line 2618
    return (-1);
  }
  {
#line 2620
  memset((void *)pSensorReadingData, 0, sizeof(SensorReadingType ));
#line 2621
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2622
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
#line 2623
    return (1);
  } else
#line 2624
  if ((int )rsp->ccode > 0) {
#line 2625
    return (1);
  }
  {
#line 2627
  memcpy((void */* __restrict  */)pSensorReadingData, (void const   */* __restrict  */)(rsp->data),
         sizeof(SensorReadingType ));
  }
#line 2629
  if ((int )rsp->ccode != 0) {
#line 2630
    rc = 1;
  }
#line 2633
  if (! ((int )rsp->data[1] & 192)) {
#line 2634
    rc = 1;
  } else
#line 2633
  if ((int )rsp->data[1] & 32) {
#line 2634
    rc = 1;
  }
#line 2636
  return (rc);
}
}
#line 2648 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_get_power_capstatus_command___0(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t data[2] ;
  char const   *tmp ;

  {
  {
#line 2651
  rsp = (struct ipmi_rs *)((void *)0);
#line 2652
  req.msg.netfn = (uint8_t )0;
#line 2652
  req.msg.lun = (unsigned char)0;
#line 2652
  req.msg.cmd = (unsigned char)0;
#line 2652
  req.msg.target_cmd = (unsigned char)0;
#line 2652
  req.msg.data_len = (unsigned short)0;
#line 2652
  req.msg.data = (uint8_t *)0;
#line 2654
  req.msg.netfn = (uint8_t )48;
#line 2655
  req.msg.lun = (uint8_t )0;
#line 2656
  req.msg.cmd = (uint8_t )186;
#line 2657
  req.msg.data_len = (uint16_t )2;
#line 2658
  req.msg.data = data;
#line 2659
  data[0] = (uint8_t )1;
#line 2660
  data[1] = (uint8_t )255;
#line 2661
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2662
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2663
    lprintf(3, "Error getting powercap status");
    }
#line 2664
    return (-1);
  } else
#line 2665
  if ((int )iDRAC_FLAG == 2) {
#line 2665
    if ((int )rsp->ccode == 111) {
      {
#line 2666
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 2668
      return (-1);
    } else {
#line 2665
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2669
  if ((int )rsp->ccode > 0) {
    {
#line 2670
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2670
    lprintf(3, "Error getting powercap statusr: %s", tmp);
    }
#line 2672
    return (-1);
  }
#line 2674
  if ((int )rsp->data[0] & 2) {
#line 2675
    PowercapSetable_flag = (uint8_t )1;
  }
#line 2677
  if ((int )rsp->data[0] & 1) {
#line 2678
    PowercapstatusFlag = (uint8_t )1;
  }
#line 2680
  return (0);
}
}
#line 2692 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_set_power_capstatus_command___0(struct ipmi_intf *intf , uint8_t val ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t data[2] ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 2695
  rsp = (struct ipmi_rs *)((void *)0);
#line 2696
  req.msg.netfn = (uint8_t )0;
#line 2696
  req.msg.lun = (unsigned char)0;
#line 2696
  req.msg.cmd = (unsigned char)0;
#line 2696
  req.msg.target_cmd = (unsigned char)0;
#line 2696
  req.msg.data_len = (unsigned short)0;
#line 2696
  req.msg.data = (uint8_t *)0;
#line 2698
  tmp = ipmi_get_power_capstatus_command___0(intf);
  }
#line 2698
  if (tmp < 0) {
#line 2699
    return (-1);
  }
#line 2701
  if ((int )PowercapSetable_flag != 1) {
    {
#line 2702
    lprintf(3, "Can not set powercap on this system");
    }
#line 2703
    return (-1);
  }
  {
#line 2705
  req.msg.netfn = (uint8_t )48;
#line 2706
  req.msg.lun = (uint8_t )0;
#line 2707
  req.msg.cmd = (uint8_t )186;
#line 2708
  req.msg.data_len = (uint16_t )2;
#line 2709
  req.msg.data = data;
#line 2710
  data[0] = (uint8_t )0;
#line 2711
  data[1] = val;
#line 2712
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2713
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2714
    lprintf(3, "Error setting powercap status");
    }
#line 2715
    return (-1);
  } else
#line 2716
  if ((int )iDRAC_FLAG == 2) {
#line 2716
    if ((int )rsp->ccode == 111) {
      {
#line 2717
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 2719
      return (-1);
    } else {
#line 2716
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2720
  if ((int )rsp->ccode > 0) {
    {
#line 2721
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2721
    lprintf(3, "Error setting powercap statusr: %s", tmp___0);
    }
#line 2723
    return (-1);
  }
#line 2725
  return (0);
}
}
#line 2736 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_powermgmt___0(struct ipmi_intf *intf ) 
{ 
  time_t now ;
  struct tm *tm ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[2] ;
  uint32_t cumStartTimeConv ;
  uint32_t cumReadingConv ;
  uint32_t maxPeakStartTimeConv ;
  uint32_t ampPeakTimeConv ;
  uint16_t ampReadingConv ;
  uint32_t wattPeakTimeConv ;
  uint32_t wattReadingConv ;
  uint32_t bmctimeconv ;
  uint32_t *bmctimeconvval ;
  IPMI_POWER_MONITOR *pwrMonitorInfo ;
  char cumStartTime[26] ;
  char maxPeakStartTime[26] ;
  char ampPeakTime[26] ;
  char wattPeakTime[26] ;
  char bmctime[26] ;
  int ampReading ;
  int ampReadingRemainder ;
  int remainder___0 ;
  int wattReading ;

  {
  {
#line 2767
  now = time((time_t *)0);
#line 2768
  tm = gmtime((time_t const   *)(& now));
#line 2770
  memset((void *)(& req), 0, sizeof(req));
#line 2771
  req.msg.netfn = (uint8_t )10;
#line 2772
  req.msg.lun = (uint8_t )0;
#line 2773
  req.msg.cmd = (uint8_t )72;
#line 2775
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2776
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2777
    lprintf(3, "Error getting BMC time info.");
    }
#line 2778
    return (-1);
  }
#line 2780
  if ((int )rsp->ccode != 0) {
    {
#line 2781
    lprintf(3, "Error getting power management information, return code %x", (int )rsp->ccode);
    }
#line 2784
    return (-1);
  }
  {
#line 2786
  bmctimeconvval = (uint32_t *)(rsp->data);
#line 2790
  bmctimeconv = *bmctimeconvval;
#line 2794
  req.msg.netfn = (uint8_t )48;
#line 2795
  req.msg.lun = (uint8_t )0;
#line 2796
  req.msg.cmd = (uint8_t )156;
#line 2797
  req.msg.data = msg_data;
#line 2798
  req.msg.data_len = (uint16_t )2;
#line 2800
  memset((void *)(msg_data), 0, (size_t )2);
#line 2801
  msg_data[0] = (uint8_t )7;
#line 2802
  msg_data[1] = (uint8_t )1;
#line 2804
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2805
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2806
    lprintf(3, "Error getting power management information.");
    }
#line 2807
    return (-1);
  }
#line 2810
  if ((int )iDRAC_FLAG == 2) {
#line 2810
    if ((int )rsp->ccode == 111) {
      {
#line 2811
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 2813
      return (-1);
    } else {
#line 2810
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2814
  if ((int )rsp->ccode == 193) {
    {
#line 2815
    lprintf(3, "Error getting power management information: Command not supported on this system.");
    }
#line 2817
    return (-1);
  } else
#line 2814
  if ((int )rsp->ccode == 203) {
    {
#line 2815
    lprintf(3, "Error getting power management information: Command not supported on this system.");
    }
#line 2817
    return (-1);
  } else
#line 2818
  if ((int )rsp->ccode != 0) {
    {
#line 2819
    lprintf(3, "Error getting power management information, return code %x", (int )rsp->ccode);
    }
#line 2822
    return (-1);
  }
  {
#line 2825
  pwrMonitorInfo = (IPMI_POWER_MONITOR *)(rsp->data);
#line 2835
  cumStartTimeConv = pwrMonitorInfo->cumStartTime;
#line 2836
  cumReadingConv = pwrMonitorInfo->cumReading;
#line 2837
  maxPeakStartTimeConv = pwrMonitorInfo->maxPeakStartTime;
#line 2838
  ampPeakTimeConv = pwrMonitorInfo->ampPeakTime;
#line 2839
  ampReadingConv = pwrMonitorInfo->ampReading;
#line 2840
  wattPeakTimeConv = pwrMonitorInfo->wattPeakTime;
#line 2841
  wattReadingConv = (uint32_t )pwrMonitorInfo->wattReading;
#line 2844
  ipmi_time_to_str___0((time_t )cumStartTimeConv, cumStartTime);
#line 2845
  ipmi_time_to_str___0((time_t )maxPeakStartTimeConv, maxPeakStartTime);
#line 2846
  ipmi_time_to_str___0((time_t )ampPeakTimeConv, ampPeakTime);
#line 2847
  ipmi_time_to_str___0((time_t )wattPeakTimeConv, wattPeakTime);
#line 2848
  ipmi_time_to_str___0((time_t )bmctimeconv, bmctime);
#line 2849
  now = time((time_t *)0);
#line 2851
  remainder___0 = (int )(cumReadingConv % 1000U);
#line 2852
  cumReadingConv /= 1000U;
#line 2853
  remainder___0 = (remainder___0 + 50) / 100;
#line 2855
  ampReading = (int )ampReadingConv;
#line 2856
  ampReadingRemainder = ampReading % 10;
#line 2857
  ampReading /= 10;
#line 2859
  wattReading = (int )wattReadingConv;
#line 2861
  printf((char const   */* __restrict  */)"Power Tracking Statistics\n");
#line 2862
  printf((char const   */* __restrict  */)"Statistic      : Cumulative Energy Consumption\n");
#line 2863
  printf((char const   */* __restrict  */)"Start Time     : %s", cumStartTime);
#line 2864
  printf((char const   */* __restrict  */)"Finish Time    : %s", bmctime);
#line 2865
  printf((char const   */* __restrict  */)"Reading        : %d.%d kWh\n\n", cumReadingConv,
         remainder___0);
#line 2867
  printf((char const   */* __restrict  */)"Statistic      : System Peak Power\n");
#line 2868
  printf((char const   */* __restrict  */)"Start Time     : %s", maxPeakStartTime);
#line 2869
  printf((char const   */* __restrict  */)"Peak Time      : %s", wattPeakTime);
#line 2870
  printf((char const   */* __restrict  */)"Peak Reading   : %d W\n\n", wattReading);
#line 2872
  printf((char const   */* __restrict  */)"Statistic      : System Peak Amperage\n");
#line 2873
  printf((char const   */* __restrict  */)"Start Time     : %s", maxPeakStartTime);
#line 2874
  printf((char const   */* __restrict  */)"Peak Time      : %s", ampPeakTime);
#line 2875
  printf((char const   */* __restrict  */)"Peak Reading   : %d.%d A\n", ampReading,
         ampReadingRemainder);
  }
#line 2876
  return (0);
}
}
#line 2888 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_powermgmt_clear___0(struct ipmi_intf *intf , uint8_t clearValue ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t clearType ;
  uint8_t msg_data[3] ;
  char const   *tmp ;

  {
#line 2893
  clearType = (uint8_t )1;
#line 2895
  if (clearValue) {
#line 2896
    clearType = (uint8_t )2;
  }
  {
#line 2899
  req.msg.netfn = (uint8_t )48;
#line 2900
  req.msg.lun = (uint8_t )0;
#line 2901
  req.msg.cmd = (uint8_t )157;
#line 2902
  req.msg.data = msg_data;
#line 2903
  req.msg.data_len = (uint16_t )3;
#line 2904
  memset((void *)(msg_data), 0, (size_t )3);
#line 2905
  msg_data[0] = (uint8_t )7;
#line 2906
  msg_data[1] = (uint8_t )1;
#line 2907
  msg_data[2] = clearType;
#line 2909
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2910
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2911
    lprintf(3, "Error clearing power values.");
    }
#line 2912
    return (-1);
  } else
#line 2913
  if ((int )iDRAC_FLAG == 2) {
#line 2913
    if ((int )rsp->ccode == 111) {
      {
#line 2915
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 2917
      return (-1);
    } else {
#line 2913
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2918
  if ((int )rsp->ccode == 193) {
    {
#line 2919
    lprintf(3, "Error clearing power values, command not supported on this system.");
    }
#line 2921
    return (-1);
  } else
#line 2922
  if ((int )rsp->ccode != 0) {
    {
#line 2923
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 2923
    lprintf(3, "Error clearing power values: %s", tmp);
    }
#line 2925
    return (-1);
  }
#line 2927
  return (0);
}
}
#line 2939 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static uint64_t watt_to_btuphr_conversion___0(uint32_t powerinwatt ) 
{ 
  uint64_t powerinbtuphr ;

  {
#line 2943
  powerinbtuphr = (uint64_t )(3.413 * (double )powerinwatt);
#line 2944
  return (powerinbtuphr);
}
}
#line 2956 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static uint32_t btuphr_to_watt_conversion___0(uint64_t powerinbtuphr ) 
{ 
  uint32_t powerinwatt ;

  {
#line 2961
  powerinwatt = (uint32_t )((double )powerinbtuphr / 3.413);
#line 2962
  return (powerinwatt);
}
}
#line 2974 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_get_power_headroom_command___0(struct ipmi_intf *intf , uint8_t unit ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint64_t peakpowerheadroombtuphr ;
  uint64_t instantpowerhearoom ;
  char const   *tmp ;

  {
  {
#line 2977
  rsp = (struct ipmi_rs *)((void *)0);
#line 2978
  req.msg.netfn = (uint8_t )0;
#line 2978
  req.msg.lun = (unsigned char)0;
#line 2978
  req.msg.cmd = (unsigned char)0;
#line 2978
  req.msg.target_cmd = (unsigned char)0;
#line 2978
  req.msg.data_len = (unsigned short)0;
#line 2978
  req.msg.data = (uint8_t *)0;
#line 2982
  req.msg.netfn = (uint8_t )48;
#line 2983
  req.msg.lun = (uint8_t )0;
#line 2984
  req.msg.cmd = (uint8_t )187;
#line 2985
  req.msg.data_len = (uint16_t )0;
#line 2987
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 2988
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 2989
    lprintf(3, "Error getting power headroom status");
    }
#line 2990
    return (-1);
  } else
#line 2991
  if ((int )iDRAC_FLAG == 2) {
#line 2991
    if ((int )rsp->ccode == 111) {
      {
#line 2993
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 2995
      return (-1);
    } else {
#line 2991
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2996
  if ((int )rsp->ccode == 193) {
    {
#line 2997
    lprintf(3, "Error getting power headroom status: Command not supported on this system ");
    }
#line 2999
    return (-1);
  } else
#line 2996
  if ((int )rsp->ccode == 203) {
    {
#line 2997
    lprintf(3, "Error getting power headroom status: Command not supported on this system ");
    }
#line 2999
    return (-1);
  } else
#line 3000
  if ((int )rsp->ccode > 0) {
    {
#line 3001
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3001
    lprintf(3, "Error getting power headroom status: %s", tmp);
    }
#line 3003
    return (-1);
  }
#line 3005
  if (verbose > 1) {
    {
#line 3007
    printf((char const   */* __restrict  */)"power headroom  Data               : %x %x %x %x ",
           (int )rsp->data[0], (int )rsp->data[1], (int )rsp->data[2], (int )rsp->data[3]);
    }
  }
  {
#line 3010
  powerheadroom = *((POWER_HEADROOM *)(rsp->data));
#line 3015
  printf((char const   */* __restrict  */)"Headroom\n");
#line 3016
  printf((char const   */* __restrict  */)"Statistic                     Reading\n");
  }
#line 3017
  if ((int )unit == 1) {
    {
#line 3018
    peakpowerheadroombtuphr = watt_to_btuphr_conversion___0((uint32_t )powerheadroom.peakheadroom);
#line 3019
    instantpowerhearoom = watt_to_btuphr_conversion___0((uint32_t )powerheadroom.instheadroom);
#line 3020
    printf((char const   */* __restrict  */)"System Instantaneous Headroom : %lld BTU/hr\n",
           instantpowerhearoom);
#line 3022
    printf((char const   */* __restrict  */)"System Peak Headroom          : %lld BTU/hr\n",
           peakpowerheadroombtuphr);
    }
  } else {
    {
#line 3025
    printf((char const   */* __restrict  */)"System Instantaneous Headroom : %d W\n",
           (int )powerheadroom.instheadroom);
#line 3027
    printf((char const   */* __restrict  */)"System Peak Headroom          : %d W\n",
           (int )powerheadroom.peakheadroom);
    }
  }
#line 3030
  return (0);
}
}
#line 3042 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_get_power_consumption_data___0(struct ipmi_intf *intf , uint8_t unit ) 
{ 
  SensorReadingType sensorReadingData ;
  struct ipmi_rs *rsp ;
  struct sdr_record_list *sdr ;
  int readingbtuphr ;
  int warning_threshbtuphr ;
  int failure_threshbtuphr ;
  int status ;
  int sensor_number ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  uint64_t tmp___2 ;
  uint64_t tmp___3 ;
  uint64_t tmp___4 ;

  {
  {
#line 3047
  rsp = (struct ipmi_rs *)((void *)0);
#line 3049
  readingbtuphr = 0;
#line 3050
  warning_threshbtuphr = 0;
#line 3051
  failure_threshbtuphr = 0;
#line 3052
  status = 0;
#line 3053
  sensor_number = 0;
#line 3054
  sdr = ipmi_sdr_find_sdr_byid(intf, (char *)"System Level");
  }
#line 3055
  if ((unsigned long )sdr == (unsigned long )((void *)0)) {
    {
#line 3056
    lprintf(3, "Error : Can not access the System Level sensor data");
    }
#line 3058
    return (-1);
  }
  {
#line 3060
  sensor_number = (int )(sdr->record.common)->keys.sensor_num;
#line 3061
  ipmi_get_sensor_reading___0(intf, (unsigned char )sensor_number, & sensorReadingData);
#line 3062
  rsp = ipmi_sdr_get_sensor_thresholds(intf, (sdr->record.common)->keys.sensor_num,
                                       (sdr->record.common)->keys.owner_id, (sdr->record.common)->keys.lun,
                                       (sdr->record.common)->keys.channel);
  }
#line 3067
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 3068
    lprintf(3, "Error : Can not access the System Level sensor data");
    }
#line 3070
    return (-1);
  } else
#line 3067
  if ((int )rsp->ccode != 0) {
    {
#line 3068
    lprintf(3, "Error : Can not access the System Level sensor data");
    }
#line 3070
    return (-1);
  }
  {
#line 3072
  tmp = sdr_convert_sensor_reading(sdr->record.full, sensorReadingData.sensorReading);
#line 3072
  readingbtuphr = (int )tmp;
#line 3074
  tmp___0 = sdr_convert_sensor_reading(sdr->record.full, rsp->data[4]);
#line 3074
  warning_threshbtuphr = (int )tmp___0;
#line 3076
  tmp___1 = sdr_convert_sensor_reading(sdr->record.full, rsp->data[5]);
#line 3076
  failure_threshbtuphr = (int )tmp___1;
#line 3079
  printf((char const   */* __restrict  */)"System Board System Level\n");
  }
#line 3080
  if ((int )unit == 1) {
    {
#line 3081
    tmp___2 = watt_to_btuphr_conversion___0((uint32_t )readingbtuphr);
#line 3081
    readingbtuphr = (int )tmp___2;
#line 3082
    tmp___3 = watt_to_btuphr_conversion___0((uint32_t )warning_threshbtuphr);
#line 3082
    warning_threshbtuphr = (int )tmp___3;
#line 3083
    tmp___4 = watt_to_btuphr_conversion___0((uint32_t )failure_threshbtuphr);
#line 3083
    failure_threshbtuphr = (int )tmp___4;
#line 3085
    printf((char const   */* __restrict  */)"Reading                        : %d BTU/hr\n",
           readingbtuphr);
#line 3086
    printf((char const   */* __restrict  */)"Warning threshold      : %d BTU/hr\n",
           warning_threshbtuphr);
#line 3087
    printf((char const   */* __restrict  */)"Failure threshold      : %d BTU/hr\n",
           failure_threshbtuphr);
    }
  } else {
    {
#line 3089
    printf((char const   */* __restrict  */)"Reading                        : %d W \n",
           readingbtuphr);
#line 3090
    printf((char const   */* __restrict  */)"Warning threshold      : %d W \n", warning_threshbtuphr);
#line 3091
    printf((char const   */* __restrict  */)"Failure threshold      : %d W \n", failure_threshbtuphr);
    }
  }
#line 3093
  return (status);
}
}
#line 3104 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_get_instan_power_consmpt_data___0(struct ipmi_intf *intf , IPMI_INST_POWER_CONSUMPTION_DATA *instpowerconsumptiondata ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[2] ;
  char const   *tmp ;

  {
  {
#line 3109
  req.msg.netfn = (uint8_t )0;
#line 3109
  req.msg.lun = (unsigned char)0;
#line 3109
  req.msg.cmd = (unsigned char)0;
#line 3109
  req.msg.target_cmd = (unsigned char)0;
#line 3109
  req.msg.data_len = (unsigned short)0;
#line 3109
  req.msg.data = (uint8_t *)0;
#line 3112
  req.msg.netfn = (uint8_t )48;
#line 3113
  req.msg.lun = (uint8_t )0;
#line 3114
  req.msg.cmd = (uint8_t )179;
#line 3115
  req.msg.data = msg_data;
#line 3116
  req.msg.data_len = (uint16_t )2;
#line 3117
  memset((void *)(msg_data), 0, (size_t )2);
#line 3118
  msg_data[0] = (uint8_t )10;
#line 3119
  msg_data[1] = (uint8_t )0;
#line 3121
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 3122
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 3123
    lprintf(3, "Error getting instantaneous power consumption data .");
    }
#line 3124
    return (-1);
  } else
#line 3125
  if ((int )iDRAC_FLAG == 2) {
#line 3125
    if ((int )rsp->ccode == 111) {
      {
#line 3127
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 3129
      return (-1);
    } else {
#line 3125
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3130
  if ((int )rsp->ccode == 193) {
    {
#line 3131
    lprintf(3, "Error getting instantaneous power consumption data: Command not supported on this system.");
    }
#line 3133
    return (-1);
  } else
#line 3130
  if ((int )rsp->ccode == 203) {
    {
#line 3131
    lprintf(3, "Error getting instantaneous power consumption data: Command not supported on this system.");
    }
#line 3133
    return (-1);
  } else
#line 3134
  if ((int )rsp->ccode != 0) {
    {
#line 3135
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3135
    lprintf(3, "Error getting instantaneous power consumption data: %s", tmp);
    }
#line 3137
    return (-1);
  }
#line 3139
  *instpowerconsumptiondata = *((IPMI_INST_POWER_CONSUMPTION_DATA *)(rsp->data));
#line 3145
  return (0);
}
}
#line 3156 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void ipmi_print_get_instan_power_Amps_data___0(IPMI_INST_POWER_CONSUMPTION_DATA instpowerconsumptiondata ) 
{ 
  uint16_t intampsval ;
  uint16_t decimalampsval ;

  {
#line 3159
  intampsval = (uint16_t )0;
#line 3160
  decimalampsval = (uint16_t )0;
#line 3161
  if ((int )instpowerconsumptiondata.instanApms > 0) {
#line 3162
    decimalampsval = (uint16_t )((int )instpowerconsumptiondata.instanApms % 10);
#line 3163
    intampsval = (uint16_t )((int )instpowerconsumptiondata.instanApms / 10);
  }
  {
#line 3165
  printf((char const   */* __restrict  */)"\nAmperage value: %d.%d A \n", (int )intampsval,
         (int )decimalampsval);
  }
#line 3166
  return;
}
}
#line 3177 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_print_get_power_consmpt_data___0(struct ipmi_intf *intf , uint8_t unit ) 
{ 
  int rc ;
  IPMI_INST_POWER_CONSUMPTION_DATA instpowerconsumptiondata ;

  {
  {
#line 3180
  rc = 0;
#line 3181
  instpowerconsumptiondata.instanpowerconsumption = (uint16_t )0;
#line 3181
  instpowerconsumptiondata.instanApms = (uint16_t )0;
#line 3181
  instpowerconsumptiondata.resv1 = (uint16_t )0;
#line 3181
  instpowerconsumptiondata.resv = (uint8_t )0;
#line 3182
  printf((char const   */* __restrict  */)"\nPower consumption information\n");
#line 3183
  rc = ipmi_get_power_consumption_data___0(intf, unit);
  }
#line 3184
  if (rc == -1) {
#line 3185
    return (rc);
  }
  {
#line 3187
  rc = ipmi_get_instan_power_consmpt_data___0(intf, & instpowerconsumptiondata);
  }
#line 3188
  if (rc == -1) {
#line 3189
    return (rc);
  }
  {
#line 3191
  ipmi_print_get_instan_power_Amps_data___0(instpowerconsumptiondata);
#line 3192
  rc = ipmi_get_power_headroom_command___0(intf, unit);
  }
#line 3193
  if (rc == -1) {
#line 3194
    return (rc);
  }
#line 3196
  return (rc);
}
}
#line 3207 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_get_avgpower_consmpt_history___0(struct ipmi_intf *intf , IPMI_AVGPOWER_CONSUMP_HISTORY *pavgpower ) 
{ 
  int rc ;
  uint8_t *rdata ;
  char const   *tmp ;

  {
  {
#line 3213
  rc = ipmi_mc_getsysinfo(intf, 235, 0, 0, (int )sizeof(*pavgpower), (void *)pavgpower);
  }
#line 3214
  if (rc < 0) {
    {
#line 3215
    lprintf(3, "Error getting average power consumption history data.");
    }
#line 3217
    return (-1);
  } else
#line 3218
  if ((int )iDRAC_FLAG == 2) {
#line 3218
    if (rc == 111) {
      {
#line 3219
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 3221
      return (-1);
    } else {
#line 3218
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3222
  if (rc == 193) {
    {
#line 3223
    lprintf(3, "Error getting average power consumption history data: Command not supported on this system.");
    }
#line 3225
    return (-1);
  } else
#line 3222
  if (rc == 203) {
    {
#line 3223
    lprintf(3, "Error getting average power consumption history data: Command not supported on this system.");
    }
#line 3225
    return (-1);
  } else
#line 3226
  if (rc != 0) {
    {
#line 3227
    tmp = val2str((uint16_t )rc, completion_code_vals);
#line 3227
    lprintf(3, "Error getting average power consumption history data: %s", tmp);
    }
#line 3230
    return (-1);
  }
#line 3232
  if (verbose > 1) {
    {
#line 3233
    rdata = (uint8_t *)((void *)pavgpower);
#line 3234
    printf((char const   */* __restrict  */)"Average power consumption history data       :%x %x %x %x %x %x %x\n\n",
           (int )*(rdata + 0), (int )*(rdata + 1), (int )*(rdata + 2), (int )*(rdata + 3),
           (int )*(rdata + 4), (int )*(rdata + 5), (int )*(rdata + 6), (int )*(rdata + 7));
    }
  }
#line 3245
  return (0);
}
}
#line 3256 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_get_peakpower_consmpt_history___0(struct ipmi_intf *intf , IPMI_POWER_CONSUMP_HISTORY *pstPeakpower ) 
{ 
  uint8_t *rdata ;
  int rc ;
  char const   *tmp ;

  {
  {
#line 3262
  rc = ipmi_mc_getsysinfo(intf, 236, 0, 0, (int )sizeof(*pstPeakpower), (void *)pstPeakpower);
  }
#line 3264
  if (rc < 0) {
    {
#line 3265
    lprintf(3, "Error getting  peak power consumption history data.");
    }
#line 3266
    return (-1);
  } else
#line 3267
  if ((int )iDRAC_FLAG == 2) {
#line 3267
    if (rc == 111) {
      {
#line 3268
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 3270
      return (-1);
    } else {
#line 3267
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3271
  if (rc == 193) {
    {
#line 3272
    lprintf(3, "Error getting peak power consumption history data: Command not supported on this system.");
    }
#line 3274
    return (-1);
  } else
#line 3271
  if (rc == 203) {
    {
#line 3272
    lprintf(3, "Error getting peak power consumption history data: Command not supported on this system.");
    }
#line 3274
    return (-1);
  } else
#line 3275
  if (rc != 0) {
    {
#line 3276
    tmp = val2str((uint16_t )rc, completion_code_vals);
#line 3276
    lprintf(3, "Error getting peak power consumption history data: %s", tmp);
    }
#line 3278
    return (-1);
  }
#line 3280
  if (verbose > 1) {
    {
#line 3281
    rdata = (uint8_t *)((void *)pstPeakpower);
#line 3282
    printf((char const   */* __restrict  */)"Peak power consmhistory  Data               : %x %x %x %x %x %x %x %x %x %x\n   %x %x %x %x %x %x %x %x %x %x %x %x %x\n\n",
           (int )*(rdata + 0), (int )*(rdata + 1), (int )*(rdata + 2), (int )*(rdata + 3),
           (int )*(rdata + 4), (int )*(rdata + 5), (int )*(rdata + 6), (int )*(rdata + 7),
           (int )*(rdata + 8), (int )*(rdata + 9), (int )*(rdata + 10), (int )*(rdata + 11),
           (int )*(rdata + 12), (int )*(rdata + 13), (int )*(rdata + 14), (int )*(rdata + 15),
           (int )*(rdata + 16), (int )*(rdata + 17), (int )*(rdata + 18), (int )*(rdata + 19),
           (int )*(rdata + 20), (int )*(rdata + 21), (int )*(rdata + 22), (int )*(rdata + 23));
    }
  }
#line 3302
  return (0);
}
}
#line 3313 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_get_minpower_consmpt_history___0(struct ipmi_intf *intf , IPMI_POWER_CONSUMP_HISTORY *pstMinpower ) 
{ 
  uint8_t *rdata ;
  int rc ;
  char const   *tmp ;

  {
  {
#line 3319
  rc = ipmi_mc_getsysinfo(intf, 237, 0, 0, (int )sizeof(*pstMinpower), (void *)pstMinpower);
  }
#line 3321
  if (rc < 0) {
    {
#line 3322
    lprintf(3, "Error getting  peak power consumption history data .");
    }
#line 3323
    return (-1);
  } else
#line 3324
  if ((int )iDRAC_FLAG == 2) {
#line 3324
    if (rc == 111) {
      {
#line 3325
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 3327
      return (-1);
    } else {
#line 3324
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3328
  if (rc == 193) {
    {
#line 3329
    lprintf(3, "Error getting peak power consumption history data: Command not supported on this system.");
    }
#line 3331
    return (-1);
  } else
#line 3328
  if (rc == 203) {
    {
#line 3329
    lprintf(3, "Error getting peak power consumption history data: Command not supported on this system.");
    }
#line 3331
    return (-1);
  } else
#line 3332
  if (rc != 0) {
    {
#line 3333
    tmp = val2str((uint16_t )rc, completion_code_vals);
#line 3333
    lprintf(3, "Error getting peak power consumption history data: %s", tmp);
    }
#line 3335
    return (-1);
  }
#line 3337
  if (verbose > 1) {
    {
#line 3338
    rdata = (uint8_t *)((void *)pstMinpower);
#line 3339
    printf((char const   */* __restrict  */)"Peak power consmhistory  Data               : %x %x %x %x %x %x %x %x %x %x\n   %x %x %x %x %x %x %x %x %x %x %x %x %x\n\n",
           (int )*(rdata + 0), (int )*(rdata + 1), (int )*(rdata + 2), (int )*(rdata + 3),
           (int )*(rdata + 4), (int )*(rdata + 5), (int )*(rdata + 6), (int )*(rdata + 7),
           (int )*(rdata + 8), (int )*(rdata + 9), (int )*(rdata + 10), (int )*(rdata + 11),
           (int )*(rdata + 12), (int )*(rdata + 13), (int )*(rdata + 14), (int )*(rdata + 15),
           (int )*(rdata + 16), (int )*(rdata + 17), (int )*(rdata + 18), (int )*(rdata + 19),
           (int )*(rdata + 20), (int )*(rdata + 21), (int )*(rdata + 22), (int )*(rdata + 23));
    }
  }
#line 3359
  return (0);
}
}
#line 3371 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_print_power_consmpt_history___0(struct ipmi_intf *intf , int unit ) 
{ 
  char timestr[30] ;
  uint32_t lastminutepeakpower ;
  uint32_t lasthourpeakpower ;
  uint32_t lastdaypeakpower ;
  uint32_t lastweekpeakpower ;
  uint64_t tempbtuphrconv ;
  int rc ;
  IPMI_AVGPOWER_CONSUMP_HISTORY avgpower ;
  IPMI_POWER_CONSUMP_HISTORY stMinpower ;
  IPMI_POWER_CONSUMP_HISTORY stPeakpower ;

  {
  {
#line 3380
  rc = 0;
#line 3386
  rc = ipmi_get_avgpower_consmpt_history___0(intf, & avgpower);
  }
#line 3387
  if (rc == -1) {
#line 3388
    return (rc);
  }
  {
#line 3391
  rc = ipmi_get_peakpower_consmpt_history___0(intf, & stPeakpower);
  }
#line 3392
  if (rc == -1) {
#line 3393
    return (rc);
  }
  {
#line 3396
  rc = ipmi_get_minpower_consmpt_history___0(intf, & stMinpower);
  }
#line 3397
  if (rc == -1) {
#line 3398
    return (rc);
  }
#line 3400
  if (rc != 0) {
#line 3401
    return (rc);
  }
  {
#line 3403
  printf((char const   */* __restrict  */)"Power Consumption History\n\n");
#line 3406
  printf((char const   */* __restrict  */)"Statistic                   Last Minute     Last Hour     Last Day     Last Week\n\n");
  }
#line 3408
  if (unit == 1) {
    {
#line 3409
    printf((char const   */* __restrict  */)"Average Power Consumption  ");
#line 3410
    tempbtuphrconv = watt_to_btuphr_conversion___0((uint32_t )avgpower.lastminutepower);
#line 3411
    printf((char const   */* __restrict  */)"%4lld BTU/hr     ", tempbtuphrconv);
#line 3412
    tempbtuphrconv = watt_to_btuphr_conversion___0((uint32_t )avgpower.lasthourpower);
#line 3413
    printf((char const   */* __restrict  */)"%4lld BTU/hr   ", tempbtuphrconv);
#line 3414
    tempbtuphrconv = watt_to_btuphr_conversion___0((uint32_t )avgpower.lastdaypower);
#line 3415
    printf((char const   */* __restrict  */)"%4lld BTU/hr  ", tempbtuphrconv);
#line 3416
    tempbtuphrconv = watt_to_btuphr_conversion___0((uint32_t )avgpower.lastweakpower);
#line 3417
    printf((char const   */* __restrict  */)"%4lld BTU/hr\n", tempbtuphrconv);
#line 3419
    printf((char const   */* __restrict  */)"Max Power Consumption      ");
#line 3420
    tempbtuphrconv = watt_to_btuphr_conversion___0((uint32_t )stPeakpower.lastminutepower);
#line 3421
    printf((char const   */* __restrict  */)"%4lld BTU/hr     ", tempbtuphrconv);
#line 3422
    tempbtuphrconv = watt_to_btuphr_conversion___0((uint32_t )stPeakpower.lasthourpower);
#line 3423
    printf((char const   */* __restrict  */)"%4lld BTU/hr   ", tempbtuphrconv);
#line 3424
    tempbtuphrconv = watt_to_btuphr_conversion___0((uint32_t )stPeakpower.lastdaypower);
#line 3425
    printf((char const   */* __restrict  */)"%4lld BTU/hr  ", tempbtuphrconv);
#line 3426
    tempbtuphrconv = watt_to_btuphr_conversion___0((uint32_t )stPeakpower.lastweakpower);
#line 3427
    printf((char const   */* __restrict  */)"%4lld BTU/hr\n", tempbtuphrconv);
#line 3429
    printf((char const   */* __restrict  */)"Min Power Consumption      ");
#line 3430
    tempbtuphrconv = watt_to_btuphr_conversion___0((uint32_t )stMinpower.lastminutepower);
#line 3431
    printf((char const   */* __restrict  */)"%4lld BTU/hr     ", tempbtuphrconv);
#line 3432
    tempbtuphrconv = watt_to_btuphr_conversion___0((uint32_t )stMinpower.lasthourpower);
#line 3433
    printf((char const   */* __restrict  */)"%4lld BTU/hr   ", tempbtuphrconv);
#line 3434
    tempbtuphrconv = watt_to_btuphr_conversion___0((uint32_t )stMinpower.lastdaypower);
#line 3435
    printf((char const   */* __restrict  */)"%4lld BTU/hr  ", tempbtuphrconv);
#line 3436
    tempbtuphrconv = watt_to_btuphr_conversion___0((uint32_t )stMinpower.lastweakpower);
#line 3437
    printf((char const   */* __restrict  */)"%4lld BTU/hr\n\n", tempbtuphrconv);
    }
  } else {
    {
#line 3439
    printf((char const   */* __restrict  */)"Average Power Consumption  ");
#line 3440
    tempbtuphrconv = (uint64_t )avgpower.lastminutepower;
#line 3441
    printf((char const   */* __restrict  */)"%4lld W          ", tempbtuphrconv);
#line 3442
    tempbtuphrconv = (uint64_t )avgpower.lasthourpower;
#line 3443
    printf((char const   */* __restrict  */)"%4lld W        ", tempbtuphrconv);
#line 3444
    tempbtuphrconv = (uint64_t )avgpower.lastdaypower;
#line 3445
    printf((char const   */* __restrict  */)"%4lld W       ", tempbtuphrconv);
#line 3446
    tempbtuphrconv = (uint64_t )avgpower.lastweakpower;
#line 3447
    printf((char const   */* __restrict  */)"%4lld W   \n", tempbtuphrconv);
#line 3449
    printf((char const   */* __restrict  */)"Max Power Consumption      ");
#line 3450
    tempbtuphrconv = (uint64_t )stPeakpower.lastminutepower;
#line 3451
    printf((char const   */* __restrict  */)"%4lld W          ", tempbtuphrconv);
#line 3452
    tempbtuphrconv = (uint64_t )stPeakpower.lasthourpower;
#line 3453
    printf((char const   */* __restrict  */)"%4lld W        ", tempbtuphrconv);
#line 3454
    tempbtuphrconv = (uint64_t )stPeakpower.lastdaypower;
#line 3455
    printf((char const   */* __restrict  */)"%4lld W       ", tempbtuphrconv);
#line 3456
    tempbtuphrconv = (uint64_t )stPeakpower.lastweakpower;
#line 3457
    printf((char const   */* __restrict  */)"%4lld W   \n", tempbtuphrconv);
#line 3459
    printf((char const   */* __restrict  */)"Min Power Consumption      ");
#line 3460
    tempbtuphrconv = (uint64_t )stMinpower.lastminutepower;
#line 3461
    printf((char const   */* __restrict  */)"%4lld W          ", tempbtuphrconv);
#line 3462
    tempbtuphrconv = (uint64_t )stMinpower.lasthourpower;
#line 3463
    printf((char const   */* __restrict  */)"%4lld W        ", tempbtuphrconv);
#line 3464
    tempbtuphrconv = (uint64_t )stMinpower.lastdaypower;
#line 3465
    printf((char const   */* __restrict  */)"%4lld W       ", tempbtuphrconv);
#line 3466
    tempbtuphrconv = (uint64_t )stMinpower.lastweakpower;
#line 3467
    printf((char const   */* __restrict  */)"%4lld W   \n\n", tempbtuphrconv);
    }
  }
  {
#line 3470
  lastminutepeakpower = stPeakpower.lastminutepowertime;
#line 3471
  lasthourpeakpower = stPeakpower.lasthourpowertime;
#line 3472
  lastdaypeakpower = stPeakpower.lastdaypowertime;
#line 3473
  lastweekpeakpower = stPeakpower.lastweekpowertime;
#line 3475
  printf((char const   */* __restrict  */)"Max Power Time\n");
#line 3476
  ipmi_time_to_str___0((time_t )lastminutepeakpower, timestr);
#line 3477
  printf((char const   */* __restrict  */)"Last Minute     : %s", timestr);
#line 3478
  ipmi_time_to_str___0((time_t )lasthourpeakpower, timestr);
#line 3479
  printf((char const   */* __restrict  */)"Last Hour       : %s", timestr);
#line 3480
  ipmi_time_to_str___0((time_t )lastdaypeakpower, timestr);
#line 3481
  printf((char const   */* __restrict  */)"Last Day        : %s", timestr);
#line 3482
  ipmi_time_to_str___0((time_t )lastweekpeakpower, timestr);
#line 3483
  printf((char const   */* __restrict  */)"Last Week       : %s", timestr);
#line 3485
  lastminutepeakpower = stMinpower.lastminutepowertime;
#line 3486
  lasthourpeakpower = stMinpower.lasthourpowertime;
#line 3487
  lastdaypeakpower = stMinpower.lastdaypowertime;
#line 3488
  lastweekpeakpower = stMinpower.lastweekpowertime;
#line 3490
  printf((char const   */* __restrict  */)"Min Power Time\n");
#line 3491
  ipmi_time_to_str___0((time_t )lastminutepeakpower, timestr);
#line 3492
  printf((char const   */* __restrict  */)"Last Minute     : %s", timestr);
#line 3493
  ipmi_time_to_str___0((time_t )lasthourpeakpower, timestr);
#line 3494
  printf((char const   */* __restrict  */)"Last Hour       : %s", timestr);
#line 3495
  ipmi_time_to_str___0((time_t )lastdaypeakpower, timestr);
#line 3496
  printf((char const   */* __restrict  */)"Last Day        : %s", timestr);
#line 3497
  ipmi_time_to_str___0((time_t )lastweekpeakpower, timestr);
#line 3498
  printf((char const   */* __restrict  */)"Last Week       : %s", timestr);
  }
#line 3499
  return (rc);
}
}
#line 3510 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_get_power_cap___0(struct ipmi_intf *intf , IPMI_POWER_CAP *ipmipowercap ) 
{ 
  uint8_t *rdata ;
  int rc ;
  char const   *tmp ;

  {
  {
#line 3516
  rc = ipmi_mc_getsysinfo(intf, 234, 0, 0, (int )sizeof(*ipmipowercap), (void *)ipmipowercap);
  }
#line 3518
  if (rc < 0) {
    {
#line 3519
    lprintf(3, "Error getting power cap.");
    }
#line 3520
    return (-1);
  } else
#line 3521
  if ((int )iDRAC_FLAG == 2) {
#line 3521
    if (rc == 111) {
      {
#line 3522
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 3524
      return (-1);
    } else {
#line 3521
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3525
  if (rc == 193) {
    {
#line 3526
    lprintf(3, "Error getting power cap: Command not supported on this system.");
    }
#line 3528
    return (-1);
  } else
#line 3525
  if (rc == 203) {
    {
#line 3526
    lprintf(3, "Error getting power cap: Command not supported on this system.");
    }
#line 3528
    return (-1);
  } else
#line 3529
  if (rc != 0) {
    {
#line 3530
    tmp = val2str((uint16_t )rc, completion_code_vals);
#line 3530
    lprintf(3, "Error getting power cap: %s", tmp);
    }
#line 3532
    return (-1);
  }
#line 3534
  if (verbose > 1) {
    {
#line 3535
    rdata = (uint8_t *)((void *)ipmipowercap);
#line 3536
    printf((char const   */* __restrict  */)"power cap  Data               :%x %x %x %x %x %x %x %x %x %x ",
           (int )*(rdata + 1), (int )*(rdata + 2), (int )*(rdata + 3), (int )*(rdata + 4),
           (int )*(rdata + 5), (int )*(rdata + 6), (int )*(rdata + 7), (int )*(rdata + 8),
           (int )*(rdata + 9), (int )*(rdata + 10), (int )*(rdata + 11));
    }
  }
#line 3550
  return (0);
}
}
#line 3561 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_print_power_cap___0(struct ipmi_intf *intf , uint8_t unit ) 
{ 
  uint64_t tempbtuphrconv ;
  int rc ;
  IPMI_POWER_CAP ipmipowercap ;

  {
  {
#line 3567
  memset((void *)(& ipmipowercap), 0, sizeof(ipmipowercap));
#line 3568
  rc = ipmi_get_power_cap___0(intf, & ipmipowercap);
  }
#line 3569
  if (rc == 0) {
#line 3570
    if ((int )unit == 1) {
      {
#line 3571
      tempbtuphrconv = watt_to_btuphr_conversion___0((uint32_t )ipmipowercap.MaximumPowerConsmp);
#line 3572
      printf((char const   */* __restrict  */)"Maximum power: %lld  BTU/hr\n", tempbtuphrconv);
#line 3573
      tempbtuphrconv = watt_to_btuphr_conversion___0((uint32_t )ipmipowercap.MinimumPowerConsmp);
#line 3574
      printf((char const   */* __restrict  */)"Minimum power: %lld  BTU/hr\n", tempbtuphrconv);
#line 3575
      tempbtuphrconv = watt_to_btuphr_conversion___0((uint32_t )ipmipowercap.PowerCap);
#line 3576
      printf((char const   */* __restrict  */)"Power cap    : %lld  BTU/hr\n", tempbtuphrconv);
      }
    } else {
      {
#line 3578
      printf((char const   */* __restrict  */)"Maximum power: %d Watt\n", (int )ipmipowercap.MaximumPowerConsmp);
#line 3579
      printf((char const   */* __restrict  */)"Minimum power: %d Watt\n", (int )ipmipowercap.MinimumPowerConsmp);
#line 3580
      printf((char const   */* __restrict  */)"Power cap    : %d Watt\n", (int )ipmipowercap.PowerCap);
      }
    }
  }
#line 3583
  return (rc);
}
}
#line 3595 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_set_power_cap___0(struct ipmi_intf *intf , int unit , int val ) 
{ 
  int rc ;
  uint8_t data[13] ;
  uint8_t *rdata ;
  uint16_t powercapval ;
  uint64_t maxpowerbtuphr ;
  uint64_t maxpowerbtuphr1 ;
  uint64_t minpowerbtuphr ;
  IPMI_POWER_CAP ipmipowercap ;
  int tmp ;
  char const   *tmp___0 ;
  uint32_t tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 3606
  tmp = ipmi_get_power_capstatus_command___0(intf);
  }
#line 3606
  if (tmp < 0) {
#line 3607
    return (-1);
  }
#line 3609
  if ((int )PowercapSetable_flag != 1) {
    {
#line 3610
    lprintf(3, "Can not set powercap on this system");
    }
#line 3611
    return (-1);
  } else
#line 3612
  if ((int )PowercapstatusFlag != 1) {
    {
#line 3613
    lprintf(3, "Power cap set feature is not enabled");
    }
#line 3614
    return (-1);
  }
  {
#line 3616
  rc = ipmi_mc_getsysinfo(intf, 234, 0, 0, (int )sizeof(ipmipowercap), (void *)(& ipmipowercap));
  }
#line 3618
  if (rc < 0) {
    {
#line 3619
    lprintf(3, "Error getting power cap.");
    }
#line 3620
    return (-1);
  } else
#line 3621
  if ((int )iDRAC_FLAG == 2) {
#line 3621
    if (rc == 111) {
      {
#line 3622
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 3624
      return (-1);
    } else {
#line 3621
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3625
  if (rc == 193) {
    {
#line 3626
    lprintf(3, "Error getting power cap, command not supported on this system.");
    }
#line 3628
    return (-1);
  } else
#line 3629
  if (rc != 0) {
    {
#line 3630
    tmp___0 = val2str((uint16_t )rc, completion_code_vals);
#line 3630
    lprintf(3, "Error getting power cap: %s", tmp___0);
    }
#line 3632
    return (-1);
  }
#line 3634
  if (verbose > 1) {
    {
#line 3635
    rdata = (uint8_t *)((void *)(& ipmipowercap));
#line 3636
    printf((char const   */* __restrict  */)"power cap  Data               :%x %x %x %x %x %x %x %x %x %x ",
           (int )*(rdata + 1), (int )*(rdata + 2), (int )*(rdata + 3), (int )*(rdata + 4),
           (int )*(rdata + 5), (int )*(rdata + 6), (int )*(rdata + 7), (int )*(rdata + 8),
           (int )*(rdata + 9), (int )*(rdata + 10), (int )*(rdata + 11));
    }
  }
  {
#line 3648
  memset((void *)(data), 0, (size_t )13);
#line 3649
  data[0] = (uint8_t )234;
#line 3650
  powercapval = (uint16_t )val;
#line 3651
  data[1] = (uint8_t )((int )powercapval & 255);
#line 3652
  data[2] = (uint8_t )(((int )powercapval & 65280) >> 8);
#line 3653
  data[3] = (uint8_t )unit;
#line 3654
  data[4] = (uint8_t )((int )ipmipowercap.MaximumPowerConsmp & 255);
#line 3655
  data[5] = (uint8_t )(((int )ipmipowercap.MaximumPowerConsmp & 65280) >> 8);
#line 3656
  data[6] = (uint8_t )((int )ipmipowercap.MinimumPowerConsmp & 255);
#line 3657
  data[7] = (uint8_t )(((int )ipmipowercap.MinimumPowerConsmp & 65280) >> 8);
#line 3658
  data[8] = (uint8_t )ipmipowercap.totalnumpowersupp;
#line 3659
  data[9] = (uint8_t )((int )ipmipowercap.AvailablePower & 255);
#line 3660
  data[10] = (uint8_t )(((int )ipmipowercap.AvailablePower & 65280) >> 8);
#line 3661
  data[11] = (uint8_t )ipmipowercap.SystemThrottling;
#line 3662
  data[12] = (uint8_t )0;
  }
#line 3664
  if (unit == 1) {
    {
#line 3665
    tmp___1 = btuphr_to_watt_conversion___0((uint64_t )val);
#line 3665
    val = (int )tmp___1;
    }
  } else
#line 3666
  if (unit == 3) {
#line 3667
    if (val < 0) {
      {
#line 3668
      lprintf(3, "Cap value is out of boundary conditon it should be between 0  - 100");
      }
#line 3670
      return (-1);
    } else
#line 3667
    if (val > 100) {
      {
#line 3668
      lprintf(3, "Cap value is out of boundary conditon it should be between 0  - 100");
      }
#line 3670
      return (-1);
    }
    {
#line 3672
    val = (val * ((int )ipmipowercap.MaximumPowerConsmp - (int )ipmipowercap.MinimumPowerConsmp)) / 100 + (int )ipmipowercap.MinimumPowerConsmp;
#line 3675
    lprintf(3, "Cap value in percentage is  %d ", val);
#line 3676
    data[1] = (uint8_t )(val & 255);
#line 3677
    data[2] = (uint8_t )((val & 65280) >> 8);
#line 3678
    data[3] = (uint8_t )0;
    }
  }
#line 3680
  if (val < (int )ipmipowercap.MinimumPowerConsmp) {
#line 3680
    goto _L___2;
  } else
#line 3680
  if (val > (int )ipmipowercap.MaximumPowerConsmp) {
    _L___2: /* CIL Label */ 
#line 3680
    if (unit == 0) {
      {
#line 3682
      lprintf(3, "Cap value is out of boundary conditon it should be between %d  - %d",
              (int )ipmipowercap.MinimumPowerConsmp, (int )ipmipowercap.MaximumPowerConsmp);
      }
#line 3685
      return (-1);
    } else {
#line 3680
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 3686
  if (val < (int )ipmipowercap.MinimumPowerConsmp) {
#line 3686
    goto _L___0;
  } else
#line 3686
  if (val > (int )ipmipowercap.MaximumPowerConsmp) {
    _L___0: /* CIL Label */ 
#line 3686
    if (unit == 1) {
      {
#line 3688
      minpowerbtuphr = watt_to_btuphr_conversion___0((uint32_t )ipmipowercap.MinimumPowerConsmp);
#line 3689
      maxpowerbtuphr = watt_to_btuphr_conversion___0((uint32_t )ipmipowercap.MaximumPowerConsmp);
#line 3690
      maxpowerbtuphr1 = watt_to_btuphr_conversion___0((uint32_t )ipmipowercap.MaximumPowerConsmp);
#line 3691
      lprintf(3, "Cap value is out of boundary conditon it should be between %d",
              minpowerbtuphr);
#line 3694
      lprintf(3, " -%d", maxpowerbtuphr1);
      }
#line 3695
      return (-1);
    }
  }
  {
#line 3697
  rc = ipmi_mc_setsysinfo(intf, 13, (void *)(data));
  }
#line 3698
  if (rc < 0) {
    {
#line 3699
    lprintf(3, "Error setting power cap");
    }
#line 3700
    return (-1);
  } else
#line 3701
  if ((int )iDRAC_FLAG == 2) {
#line 3701
    if (rc == 111) {
      {
#line 3702
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 3704
      return (-1);
    } else {
#line 3701
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 3705
  if (rc > 0) {
    {
#line 3706
    tmp___2 = val2str((uint16_t )rc, completion_code_vals);
#line 3706
    lprintf(3, "Error setting power cap: %s", tmp___2);
    }
#line 3708
    return (-1);
  }
#line 3710
  if (verbose > 1) {
    {
#line 3711
    printf((char const   */* __restrict  */)"CC for setpowercap :%d ", rc);
    }
  }
#line 3713
  return (0);
}
}
#line 3724 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void ipmi_powermonitor_usage___0(void) 
{ 


  {
  {
#line 3727
  lprintf(5, "");
#line 3729
  lprintf(5, "   powermonitor");
#line 3731
  lprintf(5, "      Shows power tracking statistics ");
#line 3733
  lprintf(5, "");
#line 3735
  lprintf(5, "   powermonitor clear cumulativepower");
#line 3737
  lprintf(5, "      Reset cumulative power reading");
#line 3739
  lprintf(5, "");
#line 3741
  lprintf(5, "   powermonitor clear peakpower");
#line 3743
  lprintf(5, "      Reset peak power reading");
#line 3745
  lprintf(5, "");
#line 3747
  lprintf(5, "   powermonitor powerconsumption");
#line 3749
  lprintf(5, "      Displays power consumption in <watt|btuphr>");
#line 3751
  lprintf(5, "");
#line 3753
  lprintf(5, "   powermonitor powerconsumptionhistory <watt|btuphr>");
#line 3755
  lprintf(5, "      Displays power consumption history ");
#line 3757
  lprintf(5, "");
#line 3759
  lprintf(5, "   powermonitor getpowerbudget");
#line 3761
  lprintf(5, "      Displays power cap in <watt|btuphr>");
#line 3763
  lprintf(5, "");
#line 3765
  lprintf(5, "   powermonitor setpowerbudget <val><watt|btuphr|percent>");
#line 3767
  lprintf(5, "      Allows user to set the  power cap in <watt|BTU/hr|percentage>");
#line 3769
  lprintf(5, "");
#line 3771
  lprintf(5, "   powermonitor enablepowercap ");
#line 3773
  lprintf(5, "      To enable set power cap");
#line 3775
  lprintf(5, "");
#line 3777
  lprintf(5, "   powermonitor disablepowercap ");
#line 3779
  lprintf(5, "      To disable set power cap");
#line 3781
  lprintf(5, "");
  }
#line 3783
  return;
}
}
#line 3796 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_delloem_vFlash_main___0(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int rc ;

  {
  {
#line 3799
  rc = 0;
#line 3800
  current_arg___0 ++;
#line 3801
  rc = ipmi_delloem_vFlash_process___0(intf, current_arg___0, argv);
  }
#line 3802
  return (rc);
}
}
#line 3816 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static char un_str___6[32]  ;
#line 3834 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_get_sd_card_info___0(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[2] ;
  uint8_t input_length ;
  uint8_t cardstatus ;
  IPMI_DELL_SDCARD_INFO *sdcardinfoblock ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 3839
  input_length = (uint8_t )0;
#line 3840
  cardstatus = (uint8_t )0;
#line 3843
  input_length = (uint8_t )2;
#line 3844
  msg_data[1] = (uint8_t )0;
#line 3844
  msg_data[0] = msg_data[1];
#line 3845
  req.msg.netfn = (uint8_t )48;
#line 3846
  req.msg.lun = (uint8_t )0;
#line 3847
  req.msg.cmd = (uint8_t )164;
#line 3848
  req.msg.data = msg_data;
#line 3849
  req.msg.data_len = (uint16_t )input_length;
#line 3851
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 3852
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 3853
    lprintf(3, "Error in getting SD Card Extended Information");
    }
#line 3854
    return (-1);
  } else
#line 3855
  if ((int )rsp->ccode > 0) {
    {
#line 3856
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 3856
    lprintf(3, "Error in getting SD Card Extended Information (%s)", tmp);
    }
#line 3858
    return (-1);
  }
#line 3861
  sdcardinfoblock = (IPMI_DELL_SDCARD_INFO *)((void *)(rsp->data));
#line 3863
  if ((int )iDRAC_FLAG == 2) {
#line 3863
    if ((int )sdcardinfoblock->vflashcompcode == 51) {
      {
#line 3865
      lprintf(3, "FM001 : A required license is missing or expired");
      }
#line 3867
      return (-1);
    } else {
#line 3863
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3868
  if ((int )sdcardinfoblock->vflashcompcode != 0) {
    {
#line 3869
    tmp___0 = get_vFlash_compcode_str(sdcardinfoblock->vflashcompcode, vFlash_completion_code_vals);
#line 3869
    lprintf(3, "Error in getting SD Card Extended Information (%s)", tmp___0);
    }
#line 3872
    return (-1);
  }
#line 3875
  if (! ((int )sdcardinfoblock->sdcardstatus & 4)) {
    {
#line 3876
    lprintf(3, "vFlash SD card is unavailable, please insert the card of");
#line 3878
    lprintf(3, "size 256MB or greater");
    }
#line 3880
    return (-1);
  }
  {
#line 3883
  printf((char const   */* __restrict  */)"vFlash SD Card Properties\n");
#line 3884
  printf((char const   */* __restrict  */)"SD Card size       : %8dMB\n", sdcardinfoblock->sdcardsize);
#line 3885
  printf((char const   */* __restrict  */)"Available size     : %8dMB\n", sdcardinfoblock->sdcardavailsize);
  }
#line 3886
  if ((int )sdcardinfoblock->sdcardstatus & 128) {
#line 3886
    tmp___1 = "Yes";
  } else {
#line 3886
    tmp___1 = "No";
  }
  {
#line 3886
  printf((char const   */* __restrict  */)"Initialized        : %10s\n", tmp___1);
  }
#line 3888
  if ((int )sdcardinfoblock->sdcardstatus & 64) {
#line 3888
    tmp___2 = "Yes";
  } else {
#line 3888
    tmp___2 = "No";
  }
  {
#line 3888
  printf((char const   */* __restrict  */)"Licensed           : %10s\n", tmp___2);
  }
#line 3890
  if ((int )sdcardinfoblock->sdcardstatus & 32) {
#line 3890
    tmp___3 = "Yes";
  } else {
#line 3890
    tmp___3 = "No";
  }
  {
#line 3890
  printf((char const   */* __restrict  */)"Attached           : %10s\n", tmp___3);
  }
#line 3892
  if ((int )sdcardinfoblock->sdcardstatus & 16) {
#line 3892
    tmp___4 = "Yes";
  } else {
#line 3892
    tmp___4 = "No";
  }
  {
#line 3892
  printf((char const   */* __restrict  */)"Enabled            : %10s\n", tmp___4);
  }
#line 3894
  if ((int )sdcardinfoblock->sdcardstatus & 8) {
#line 3894
    tmp___5 = "Yes";
  } else {
#line 3894
    tmp___5 = "No";
  }
  {
#line 3894
  printf((char const   */* __restrict  */)"Write Protected    : %10s\n", tmp___5);
#line 3896
  cardstatus = (uint8_t )((int )sdcardinfoblock->sdcardstatus & 3);
  }
#line 3897
  if (0 == (int )cardstatus) {
#line 3897
    tmp___8 = "OK";
  } else {
#line 3897
    if ((int )cardstatus == 3) {
#line 3897
      tmp___7 = "Undefined";
    } else {
#line 3897
      if ((int )cardstatus == 2) {
#line 3897
        tmp___6 = "Critical";
      } else {
#line 3897
        tmp___6 = "Warning";
      }
#line 3897
      tmp___7 = tmp___6;
    }
#line 3897
    tmp___8 = tmp___7;
  }
  {
#line 3897
  printf((char const   */* __restrict  */)"Health             : %10s\n", tmp___8);
#line 3901
  printf((char const   */* __restrict  */)"Bootable partition : %10d\n", (int )sdcardinfoblock->bootpartion);
  }
#line 3902
  return (0);
}
}
#line 3912 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_delloem_vFlash_process___0(struct ipmi_intf *intf , int current_arg___1 ,
                                           char **argv ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 3916
  tmp = strncmp((char const   *)(intf->name), "wmi\000", (size_t )4);
  }
#line 3916
  if (tmp) {
    {
#line 3916
    tmp___0 = strncmp((char const   *)(intf->name), "open\000", (size_t )5);
    }
#line 3916
    if (tmp___0) {
      {
#line 3917
      lprintf(3, "vFlash support is enabled only for wmi and open interface.");
#line 3919
      lprintf(3, "Its not enabled for lan and lanplus interface.");
      }
#line 3920
      return (-1);
    }
  }
#line 3923
  if ((unsigned long )*(argv + current_arg___1) == (unsigned long )((void *)0)) {
    {
#line 3924
    ipmi_vFlash_usage___0();
    }
#line 3925
    return (0);
  } else {
    {
#line 3923
    tmp___1 = strcmp((char const   *)*(argv + current_arg___1), "help");
    }
#line 3923
    if (tmp___1 == 0) {
      {
#line 3924
      ipmi_vFlash_usage___0();
      }
#line 3925
      return (0);
    }
  }
  {
#line 3927
  ipmi_idracvalidator_command___0(intf);
#line 3928
  tmp___3 = strncmp((char const   *)*(argv + current_arg___1), "info\000", (size_t )5);
  }
#line 3928
  if (tmp___3) {
    {
#line 3948
    ipmi_vFlash_usage___0();
    }
#line 3949
    return (-1);
  } else {
#line 3929
    current_arg___1 ++;
#line 3930
    if ((unsigned long )*(argv + current_arg___1) == (unsigned long )((void *)0)) {
      {
#line 3931
      ipmi_vFlash_usage___0();
      }
#line 3932
      return (-1);
    } else {
      {
#line 3933
      tmp___2 = strncmp((char const   *)*(argv + current_arg___1), "Card\000", (size_t )5);
      }
#line 3933
      if (tmp___2 == 0) {
#line 3934
        current_arg___1 ++;
#line 3935
        if ((unsigned long )*(argv + current_arg___1) != (unsigned long )((void *)0)) {
          {
#line 3936
          ipmi_vFlash_usage___0();
          }
#line 3937
          return (-1);
        }
        {
#line 3939
        rc = ipmi_get_sd_card_info___0(intf);
        }
#line 3940
        return (rc);
      } else {
        {
#line 3943
        ipmi_vFlash_usage___0();
        }
#line 3944
        return (-1);
      }
    }
  }
}
}
#line 3960 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void ipmi_vFlash_usage___0(void) 
{ 


  {
  {
#line 3963
  lprintf(5, "");
#line 3965
  lprintf(5, "   vFlash info Card");
#line 3967
  lprintf(5, "      Shows Extended SD Card information");
#line 3969
  lprintf(5, "");
  }
#line 3971
  return;
}
}
#line 3981 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void ipmi_setled_usage___0(void) 
{ 


  {
  {
#line 3984
  lprintf(5, "");
#line 3986
  lprintf(5, "   setled <b:d.f> <state..>");
#line 3988
  lprintf(5, "      Set backplane LED state");
#line 3990
  lprintf(5, "      b:d.f = PCI Bus:Device.Function of drive (lspci format)");
#line 3992
  lprintf(5, "      state = present|online|hotspare|identify|rebuilding|");
#line 3994
  lprintf(5, "              fault|predict|critical|failed");
#line 3996
  lprintf(5, "");
  }
#line 3998
  return;
}
}
#line 4000 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int IsSetLEDSupported___0(void) 
{ 


  {
#line 4003
  return ((int )SetLEDSupported___0);
}
}
#line 4006 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static void CheckSetLEDSupport___0(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t data[10] ;

  {
  {
#line 4009
  rsp = (struct ipmi_rs *)((void *)0);
#line 4010
  req.msg.netfn = (uint8_t )0;
#line 4010
  req.msg.lun = (unsigned char)0;
#line 4010
  req.msg.cmd = (unsigned char)0;
#line 4010
  req.msg.target_cmd = (unsigned char)0;
#line 4010
  req.msg.data_len = (unsigned short)0;
#line 4010
  req.msg.data = (uint8_t *)0;
#line 4013
  SetLEDSupported___0 = (uint8_t )0;
#line 4014
  req.msg.netfn = (uint8_t )48;
#line 4015
  req.msg.lun = (uint8_t )0;
#line 4016
  req.msg.cmd = (uint8_t )213;
#line 4017
  req.msg.data_len = (uint16_t )10;
#line 4018
  req.msg.data = data;
#line 4020
  memset((void *)(data), 0, sizeof(data));
#line 4021
  data[0] = (uint8_t )1;
#line 4022
  data[1] = (uint8_t )0;
#line 4023
  data[2] = (uint8_t )8;
#line 4024
  data[3] = (uint8_t )0;
#line 4025
  data[4] = (uint8_t )0;
#line 4026
  data[5] = (uint8_t )0;
#line 4027
  data[6] = (uint8_t )0;
#line 4028
  data[7] = (uint8_t )0;
#line 4029
  data[8] = (uint8_t )0;
#line 4030
  data[9] = (uint8_t )0;
#line 4032
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 4033
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
#line 4034
    return;
  } else
#line 4033
  if ((int )rsp->ccode != 0) {
#line 4034
    return;
  }
#line 4036
  SetLEDSupported___0 = (uint8_t )1;
#line 4037
  return;
}
}
#line 4050 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_getdrivemap___0(struct ipmi_intf *intf , int b , int d , int f , int *bay ,
                                int *slot ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t data[8] ;
  char const   *tmp ;

  {
  {
#line 4054
  rsp = (struct ipmi_rs *)((void *)0);
#line 4055
  req.msg.netfn = (uint8_t )0;
#line 4055
  req.msg.lun = (unsigned char)0;
#line 4055
  req.msg.cmd = (unsigned char)0;
#line 4055
  req.msg.target_cmd = (unsigned char)0;
#line 4055
  req.msg.data_len = (unsigned short)0;
#line 4055
  req.msg.data = (uint8_t *)0;
#line 4058
  req.msg.netfn = (uint8_t )48;
#line 4059
  req.msg.lun = (uint8_t )0;
#line 4060
  req.msg.cmd = (uint8_t )213;
#line 4061
  req.msg.data_len = (uint16_t )8;
#line 4062
  req.msg.data = data;
#line 4064
  memset((void *)(data), 0, sizeof(data));
#line 4065
  data[0] = (uint8_t )1;
#line 4066
  data[1] = (uint8_t )7;
#line 4067
  data[2] = (uint8_t )6;
#line 4068
  data[3] = (uint8_t )0;
#line 4069
  data[4] = (uint8_t )0;
#line 4070
  data[5] = (uint8_t )0;
#line 4071
  data[6] = (uint8_t )b;
#line 4072
  data[7] = (uint8_t )((d << 3) + f);
#line 4074
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 4075
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 4076
    lprintf(3, "Error issuing getdrivemap command.");
    }
#line 4077
    return (-1);
  } else
#line 4078
  if ((int )rsp->ccode != 0) {
    {
#line 4079
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 4079
    lprintf(3, "Error issuing getdrivemap command: %s", tmp);
    }
#line 4081
    return (-1);
  }
#line 4083
  *bay = (int )rsp->data[7];
#line 4084
  *slot = (int )rsp->data[8];
#line 4085
  if (*bay == 255) {
    {
#line 4086
    lprintf(3, "Error could not get drive bay:slot mapping");
    }
#line 4087
    return (-1);
  } else
#line 4085
  if (*slot == 255) {
    {
#line 4086
    lprintf(3, "Error could not get drive bay:slot mapping");
    }
#line 4087
    return (-1);
  }
#line 4089
  return (0);
}
}
#line 4102 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_setled_state___0(struct ipmi_intf *intf , int bayId , int slotId ,
                                 int state ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t data[20] ;
  char const   *tmp ;

  {
  {
#line 4105
  rsp = (struct ipmi_rs *)((void *)0);
#line 4106
  req.msg.netfn = (uint8_t )0;
#line 4106
  req.msg.lun = (unsigned char)0;
#line 4106
  req.msg.cmd = (unsigned char)0;
#line 4106
  req.msg.target_cmd = (unsigned char)0;
#line 4106
  req.msg.data_len = (unsigned short)0;
#line 4106
  req.msg.data = (uint8_t *)0;
#line 4109
  req.msg.netfn = (uint8_t )48;
#line 4110
  req.msg.lun = (uint8_t )0;
#line 4111
  req.msg.cmd = (uint8_t )213;
#line 4112
  req.msg.data_len = (uint16_t )20;
#line 4113
  req.msg.data = data;
#line 4115
  memset((void *)(data), 0, sizeof(data));
#line 4116
  data[0] = (uint8_t )0;
#line 4117
  data[1] = (uint8_t )4;
#line 4118
  data[2] = (uint8_t )14;
#line 4119
  data[3] = (uint8_t )0;
#line 4120
  data[4] = (uint8_t )0;
#line 4121
  data[5] = (uint8_t )0;
#line 4122
  data[6] = (uint8_t )14;
#line 4123
  data[7] = (uint8_t )0;
#line 4124
  data[8] = (uint8_t )bayId;
#line 4125
  data[9] = (uint8_t )slotId;
#line 4126
  data[10] = (uint8_t )(state & 255);
#line 4127
  data[11] = (uint8_t )(state >> 8);
#line 4129
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 4130
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 4131
    lprintf(3, "Error issuing setled command.");
    }
#line 4132
    return (-1);
  } else
#line 4133
  if ((int )rsp->ccode != 0) {
    {
#line 4134
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 4134
    lprintf(3, "Error issuing setled command: %s", tmp);
    }
#line 4136
    return (-1);
  }
#line 4138
  return (0);
}
}
#line 4146 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_getsesmask___0(int argc , char **argv ) 
{ 
  int mask ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 4149
  mask = 0;
  {
#line 4150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4150
    if (! (current_arg___0 < argc)) {
#line 4150
      goto while_break;
    }
    {
#line 4151
    tmp = strcmp((char const   *)*(argv + current_arg___0), "present");
    }
#line 4151
    if (! tmp) {
#line 4152
      mask = (int )((long )mask | 1L);
    }
    {
#line 4153
    tmp___0 = strcmp((char const   *)*(argv + current_arg___0), "online");
    }
#line 4153
    if (! tmp___0) {
#line 4154
      mask = (int )((long )mask | (1L << 1));
    }
    {
#line 4155
    tmp___1 = strcmp((char const   *)*(argv + current_arg___0), "hotspare");
    }
#line 4155
    if (! tmp___1) {
#line 4156
      mask = (int )((long )mask | (1L << 2));
    }
    {
#line 4157
    tmp___2 = strcmp((char const   *)*(argv + current_arg___0), "identify");
    }
#line 4157
    if (! tmp___2) {
#line 4158
      mask = (int )((long )mask | (1L << 3));
    }
    {
#line 4159
    tmp___3 = strcmp((char const   *)*(argv + current_arg___0), "rebuilding");
    }
#line 4159
    if (! tmp___3) {
#line 4160
      mask = (int )((long )mask | (1L << 4));
    }
    {
#line 4161
    tmp___4 = strcmp((char const   *)*(argv + current_arg___0), "fault");
    }
#line 4161
    if (! tmp___4) {
#line 4162
      mask = (int )((long )mask | (1L << 5));
    }
    {
#line 4163
    tmp___5 = strcmp((char const   *)*(argv + current_arg___0), "predict");
    }
#line 4163
    if (! tmp___5) {
#line 4164
      mask = (int )((long )mask | (1L << 6));
    }
    {
#line 4165
    tmp___6 = strcmp((char const   *)*(argv + current_arg___0), "critical");
    }
#line 4165
    if (! tmp___6) {
#line 4166
      mask = (int )((long )mask | (1L << 9));
    }
    {
#line 4167
    tmp___7 = strcmp((char const   *)*(argv + current_arg___0), "failed");
    }
#line 4167
    if (! tmp___7) {
#line 4168
      mask = (int )((long )mask | (1L << 10));
    }
#line 4169
    current_arg___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4171
  return (mask);
}
}
#line 4185 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_delloem.c"
static int ipmi_delloem_setled_main___0(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int b ;
  int d ;
  int f ;
  int mask ;
  int bayId ;
  int slotId ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 4190
  bayId = 255;
#line 4191
  slotId = 255;
#line 4192
  current_arg___0 ++;
#line 4193
  if (argc < current_arg___0) {
    {
#line 4194
    usage___0();
    }
#line 4195
    return (-1);
  }
#line 4198
  if (argc == 1) {
    {
#line 4199
    ipmi_setled_usage___0();
    }
#line 4200
    return (0);
  } else {
    {
#line 4198
    tmp = strcmp((char const   *)*(argv + current_arg___0), "help");
    }
#line 4198
    if (tmp == 0) {
      {
#line 4199
      ipmi_setled_usage___0();
      }
#line 4200
      return (0);
    }
  }
  {
#line 4202
  CheckSetLEDSupport___0(intf);
#line 4203
  tmp___2 = IsSetLEDSupported___0();
  }
#line 4203
  if (tmp___2) {
    {
#line 4206
    tmp___1 = sscanf((char const   */* __restrict  */)*(argv + current_arg___0), (char const   */* __restrict  */)"%*x:%x:%x.%x",
                     & b, & d, & f);
    }
#line 4206
    if (tmp___1 == 3) {
      {
#line 4208
      current_arg___0 ++;
#line 4209
      ipmi_getdrivemap___0(intf, b, d, f, & bayId, & slotId);
      }
    } else {
      {
#line 4210
      tmp___0 = sscanf((char const   */* __restrict  */)*(argv + current_arg___0),
                       (char const   */* __restrict  */)"%x:%x.%x", & b, & d, & f);
      }
#line 4210
      if (tmp___0 == 3) {
#line 4212
        current_arg___0 ++;
      } else {
        {
#line 4214
        ipmi_setled_usage___0();
        }
#line 4215
        return (-1);
      }
    }
  } else {
    {
#line 4204
    lprintf(3, "\'setled\' is not supported on this system.");
    }
#line 4205
    return (-1);
  }
  {
#line 4218
  mask = ipmi_getsesmask___0(argc, argv);
#line 4220
  tmp___3 = ipmi_getdrivemap___0(intf, b, d, f, & bayId, & slotId);
  }
#line 4220
  if (tmp___3) {
#line 4221
    return (-1);
  }
  {
#line 4224
  tmp___4 = ipmi_setled_state___0(intf, bayId, slotId, mask);
  }
#line 4224
  return (tmp___4);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_channel.c"
static char supportedTypes___0[128]  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_channel.c"
static char const   *ipmi_1_5_authtypes___0(uint8_t n ) 
{ 
  uint32_t i ;

  {
  {
#line 71
  bzero((void *)(supportedTypes___0), (size_t )128);
#line 73
  i = (uint32_t )0;
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! ((int const   )ipmi_authtype_vals[i].val != 0)) {
#line 73
      goto while_break;
    }
#line 74
    if ((int )n & (int )ipmi_authtype_vals[i].val) {
      {
#line 75
      strcat((char */* __restrict  */)(supportedTypes___0), (char const   */* __restrict  */)ipmi_authtype_vals[i].str);
#line 76
      strcat((char */* __restrict  */)(supportedTypes___0), (char const   */* __restrict  */)" ");
      }
    }
#line 73
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return ((char const   *)(supportedTypes___0));
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_channel.c"
static int ipmi_get_user_access___0(struct ipmi_intf *intf , uint8_t channel , uint8_t userid ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req1 ;
  struct ipmi_rq req2 ;
  uint8_t rqdata[2] ;
  struct get_user_access_rsp user_access ;
  int curr_uid ;
  int max_uid ;
  int init ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;

  {
#line 361
  max_uid = 0;
#line 361
  init = 1;
#line 363
  tmp = (int )userid;
#line 363
  if (! tmp) {
#line 363
    tmp = 1;
  }
  {
#line 363
  curr_uid = tmp;
#line 365
  memset((void *)(& req1), 0, sizeof(req1));
#line 366
  req1.msg.netfn = (uint8_t )6;
#line 367
  req1.msg.cmd = (uint8_t )68;
#line 368
  req1.msg.data = rqdata;
#line 369
  req1.msg.data_len = (uint16_t )2;
#line 371
  memset((void *)(& req2), 0, sizeof(req2));
#line 372
  req2.msg.netfn = (uint8_t )6;
#line 373
  req2.msg.cmd = (uint8_t )70;
#line 374
  req2.msg.data = rqdata;
#line 375
  req2.msg.data_len = (uint16_t )1;
  }
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 379
    rqdata[0] = (uint8_t )((int )channel & 15);
#line 380
    rqdata[1] = (uint8_t )(curr_uid & 63);
#line 382
    rsp = (*(intf->sendrecv))(intf, & req1);
    }
#line 383
    if ((unsigned long )rsp == (unsigned long )((void *)0)) {
      {
#line 384
      lprintf(3, "Unable to Get User Access (channel %d id %d)", (int )rqdata[0],
              (int )rqdata[1]);
      }
#line 386
      return (-1);
    }
#line 388
    if ((int )rsp->ccode > 0) {
      {
#line 389
      tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 389
      lprintf(3, "Get User Access (channel %d id %d) failed: %s", (int )rqdata[0],
              (int )rqdata[1], tmp___0);
      }
#line 392
      return (-1);
    }
    {
#line 395
    memcpy((void */* __restrict  */)(& user_access), (void const   */* __restrict  */)(rsp->data),
           sizeof(struct get_user_access_rsp ));
#line 397
    rqdata[0] = (uint8_t )(curr_uid & 63);
#line 399
    rsp = (*(intf->sendrecv))(intf, & req2);
    }
#line 400
    if ((unsigned long )rsp == (unsigned long )((void *)0)) {
      {
#line 401
      lprintf(3, "Unable to Get User Name (id %d)", (int )rqdata[0]);
      }
#line 402
      return (-1);
    }
#line 404
    if ((int )rsp->ccode > 0) {
      {
#line 405
      tmp___1 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 405
      lprintf(3, "Get User Name (id %d) failed: %s", (int )rqdata[0], tmp___1);
      }
#line 407
      return (-1);
    }
#line 410
    if (init) {
      {
#line 411
      printf((char const   */* __restrict  */)"Maximum User IDs     : %d\n", (int )user_access.max_user_ids);
#line 412
      printf((char const   */* __restrict  */)"Enabled User IDs     : %d\n", (int )user_access.enabled_user_ids);
#line 413
      max_uid = (int )user_access.max_user_ids;
#line 414
      init = 0;
      }
    }
    {
#line 417
    printf((char const   */* __restrict  */)"\n");
#line 418
    printf((char const   */* __restrict  */)"User ID              : %d\n", curr_uid);
#line 419
    printf((char const   */* __restrict  */)"User Name            : %s\n", rsp->data);
    }
#line 420
    if (curr_uid <= (int )user_access.fixed_user_ids) {
#line 420
      tmp___2 = "Yes";
    } else {
#line 420
      tmp___2 = "No";
    }
    {
#line 420
    printf((char const   */* __restrict  */)"Fixed Name           : %s\n", tmp___2);
    }
#line 422
    if (user_access.callin_callback) {
#line 422
      tmp___3 = "callback";
    } else {
#line 422
      tmp___3 = "call-in / callback";
    }
    {
#line 422
    printf((char const   */* __restrict  */)"Access Available     : %s\n", tmp___3);
    }
#line 424
    if (user_access.link_auth) {
#line 424
      tmp___4 = "en";
    } else {
#line 424
      tmp___4 = "dis";
    }
    {
#line 424
    printf((char const   */* __restrict  */)"Link Authentication  : %sabled\n", tmp___4);
    }
#line 426
    if (user_access.ipmi_messaging) {
#line 426
      tmp___5 = "en";
    } else {
#line 426
      tmp___5 = "dis";
    }
    {
#line 426
    printf((char const   */* __restrict  */)"IPMI Messaging       : %sabled\n", tmp___5);
#line 428
    tmp___6 = val2str((uint16_t )user_access.privilege_limit, ipmi_privlvl_vals);
#line 428
    printf((char const   */* __restrict  */)"Privilege Level      : %s\n", tmp___6);
#line 431
    curr_uid ++;
    }
#line 377
    if (! userid) {
#line 377
      if (! (curr_uid <= max_uid)) {
#line 377
        goto while_break;
      }
    } else {
#line 377
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  return (0);
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_channel.c"
static int ipmi_set_user_access___0(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  uint8_t channel ;
  uint8_t privilege_limit ;
  uint8_t userid ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t rqdata[2] ;
  struct get_user_access_rsp user_access ;
  struct set_user_access_data set_access ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;

  {
#line 449
  if (argc < 3) {
    {
#line 450
    printf_channel_usage();
    }
#line 451
    return (0);
  } else {
    {
#line 449
    tmp = strncmp((char const   *)*(argv + 0), "help", (size_t )4);
    }
#line 449
    if (tmp == 0) {
      {
#line 450
      printf_channel_usage();
      }
#line 451
      return (0);
    }
  }
  {
#line 454
  tmp___0 = str2uchar((char const   *)*(argv + 0), & channel);
  }
#line 454
  if (tmp___0 != 0) {
    {
#line 455
    lprintf(3, "Numeric value expected, but \'%s\' given.", *(argv + 0));
    }
#line 456
    return (-1);
  }
  {
#line 458
  tmp___1 = str2uchar((char const   *)*(argv + 1), & userid);
  }
#line 458
  if (tmp___1 != 0) {
    {
#line 459
    lprintf(3, "Numeric value expected, but \'%s\' given.", *(argv + 1));
    }
#line 460
    return (-1);
  }
  {
#line 463
  memset((void *)(& req), 0, sizeof(req));
#line 464
  req.msg.netfn = (uint8_t )6;
#line 465
  req.msg.cmd = (uint8_t )68;
#line 466
  req.msg.data = rqdata;
#line 467
  req.msg.data_len = (uint16_t )2;
#line 469
  rqdata[0] = (uint8_t )((int )channel & 15);
#line 470
  rqdata[1] = (uint8_t )((int )userid & 63);
#line 472
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 473
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 474
    lprintf(3, "Unable to Get User Access (channel %d id %d)", (int )rqdata[0], (int )rqdata[1]);
    }
#line 476
    return (-1);
  }
#line 478
  if ((int )rsp->ccode > 0) {
    {
#line 479
    tmp___2 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 479
    lprintf(3, "Get User Access (channel %d id %d) failed: %s", (int )rqdata[0], (int )rqdata[1],
            tmp___2);
    }
#line 482
    return (-1);
  }
  {
#line 485
  memcpy((void */* __restrict  */)(& user_access), (void const   */* __restrict  */)(rsp->data),
         sizeof(struct get_user_access_rsp ));
#line 487
  memset((void *)(& set_access), 0, sizeof(set_access));
#line 488
  set_access.change_bits = (uint8_t )1;
#line 489
  set_access.callin_callback = user_access.callin_callback;
#line 490
  set_access.link_auth = user_access.link_auth;
#line 491
  set_access.ipmi_messaging = user_access.ipmi_messaging;
#line 492
  set_access.channel = channel;
#line 493
  set_access.user_id = userid;
#line 494
  set_access.privilege_limit = user_access.privilege_limit;
#line 495
  set_access.session_limit = (uint8_t )0;
#line 497
  i = 2;
  }
  {
#line 497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 497
    if (! (i < argc)) {
#line 497
      goto while_break;
    }
    {
#line 499
    tmp___11 = strncmp((char const   *)*(argv + i), "callin=", (size_t )7);
    }
#line 499
    if (tmp___11 == 0) {
      {
#line 500
      tmp___3 = strncmp((char const   *)(*(argv + i) + 7), "off", (size_t )3);
      }
#line 500
      if (tmp___3) {
#line 500
        tmp___4 = 0;
      } else {
#line 500
        tmp___4 = 1;
      }
#line 500
      set_access.callin_callback = (uint8_t )tmp___4;
    } else {
      {
#line 502
      tmp___10 = strncmp((char const   *)*(argv + i), "link=", (size_t )5);
      }
#line 502
      if (tmp___10 == 0) {
        {
#line 503
        tmp___5 = strncmp((char const   *)(*(argv + i) + 5), "off", (size_t )3);
#line 503
        set_access.link_auth = (uint8_t )tmp___5;
        }
      } else {
        {
#line 505
        tmp___9 = strncmp((char const   *)*(argv + i), "ipmi=", (size_t )5);
        }
#line 505
        if (tmp___9 == 0) {
          {
#line 506
          tmp___6 = strncmp((char const   *)(*(argv + i) + 5), "off", (size_t )3);
#line 506
          set_access.ipmi_messaging = (uint8_t )tmp___6;
          }
        } else {
          {
#line 508
          tmp___8 = strncmp((char const   *)*(argv + i), "privilege=", (size_t )10);
          }
#line 508
          if (tmp___8 == 0) {
            {
#line 509
            tmp___7 = str2uchar((char const   *)(*(argv + i) + 10), & privilege_limit);
            }
#line 509
            if (tmp___7 != 0) {
              {
#line 510
              lprintf(3, "Numeric value expected, but \'%s\' given.", *(argv + i) + 10);
              }
#line 511
              return (-1);
            }
#line 513
            set_access.privilege_limit = privilege_limit;
          } else {
            {
#line 516
            printf((char const   */* __restrict  */)"Invalid option: %s\n", *(argv + i));
            }
#line 517
            return (-1);
          }
        }
      }
    }
#line 497
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 521
  memset((void *)(& req), 0, sizeof(req));
#line 522
  req.msg.netfn = (uint8_t )6;
#line 523
  req.msg.cmd = (uint8_t )67;
#line 524
  req.msg.data = (uint8_t *)(& set_access);
#line 525
  req.msg.data_len = (uint16_t )4;
#line 527
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 528
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 529
    lprintf(3, "Unable to Set User Access (channel %d id %d)", (int )set_access.channel,
            (int )set_access.user_id);
    }
#line 531
    return (-1);
  }
#line 533
  if ((int )rsp->ccode > 0) {
    {
#line 534
    tmp___12 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 534
    lprintf(3, "Set User Access (channel %d id %d) failed: %s", (int )set_access.channel,
            (int )set_access.user_id, tmp___12);
    }
#line 537
    return (-1);
  }
#line 540
  return (0);
}
}
#line 547 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_channel.c"
static char s___0[10]  ;
#line 544 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_channel.c"
static char const   *iana_string___0(uint32_t iana ) 
{ 


  {
#line 549
  if (iana) {
    {
#line 551
    sprintf((char */* __restrict  */)(s___0), (char const   */* __restrict  */)"%06x",
            iana);
    }
#line 552
    return ((char const   *)(s___0));
  } else {
#line 555
    return ("N/A");
  }
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_channel.c"
static int ipmi_get_channel_cipher_suites___0(struct ipmi_intf *intf , char const   *payload_type ,
                                              uint8_t channel ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t oem_record ;
  uint8_t rqdata[3] ;
  uint32_t iana ;
  uint8_t auth_alg ;
  uint8_t integrity_alg ;
  uint8_t crypt_alg ;
  uint8_t cipher_suite_id ;
  uint8_t list_index ;
  uint8_t cipher_suite_data[1024] ;
  uint16_t offset ;
  uint16_t cipher_suite_data_length ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  uint16_t tmp___3 ;
  uint16_t tmp___4 ;
  uint16_t tmp___5 ;
  uint16_t tmp___6 ;
  uint16_t tmp___7 ;
  uint16_t tmp___8 ;
  uint16_t tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;

  {
  {
#line 572
  list_index = (uint8_t )0;
#line 574
  offset = (uint16_t )0;
#line 575
  cipher_suite_data_length = (uint16_t )0;
#line 577
  memset((void *)(cipher_suite_data), 0, sizeof(cipher_suite_data));
#line 579
  memset((void *)(& req), 0, sizeof(req));
#line 580
  req.msg.netfn = (uint8_t )6;
#line 581
  req.msg.cmd = (uint8_t )84;
#line 582
  req.msg.data = rqdata;
#line 583
  req.msg.data_len = (uint16_t )3;
#line 585
  rqdata[0] = channel;
#line 586
  tmp___0 = strncmp(payload_type, "ipmi", (size_t )4);
  }
#line 586
  if (tmp___0 == 0) {
#line 586
    rqdata[1] = (uint8_t )0;
  } else {
#line 586
    rqdata[1] = (uint8_t )1;
  }
  {
#line 587
  rqdata[2] = (uint8_t )128;
#line 589
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 590
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 591
    lprintf(3, "Unable to Get Channel Cipher Suites");
    }
#line 592
    return (-1);
  }
#line 594
  if ((int )rsp->ccode > 0) {
    {
#line 595
    tmp___1 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 595
    lprintf(3, "Get Channel Cipher Suites failed: %s", tmp___1);
    }
#line 597
    return (-1);
  }
#line 603
  if (rsp->data_len >= 1) {
#line 604
    channel = rsp->data[0];
  }
  {
#line 606
  while (1) {
    while_continue: /* CIL Label */ ;
#line 606
    if (rsp->data_len > 1) {
#line 606
      if (rsp->data_len == 17) {
#line 606
        if (! ((int )list_index < 63)) {
#line 606
          goto while_break;
        }
      } else {
#line 606
        goto while_break;
      }
    } else {
#line 606
      goto while_break;
    }
    {
#line 612
    memcpy((void */* __restrict  */)(cipher_suite_data + (int )offset), (void const   */* __restrict  */)(rsp->data + 1),
           (size_t )(rsp->data_len - 1));
#line 613
    offset = (uint16_t )((int )offset + (rsp->data_len - 1));
#line 618
    list_index = (uint8_t )((int )list_index + 1);
#line 619
    rqdata[2] = (uint8_t )(((int )rqdata[2] & 128) + (int )list_index);
#line 621
    rsp = (*(intf->sendrecv))(intf, & req);
    }
#line 622
    if ((unsigned long )rsp == (unsigned long )((void *)0)) {
      {
#line 623
      lprintf(3, "Unable to Get Channel Cipher Suites");
      }
#line 624
      return (-1);
    }
#line 626
    if ((int )rsp->ccode > 0) {
      {
#line 627
      tmp___2 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 627
      lprintf(3, "Get Channel Cipher Suites failed: %s", tmp___2);
      }
#line 629
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 634
  if (rsp->data_len > 1) {
    {
#line 640
    memcpy((void */* __restrict  */)(cipher_suite_data + (int )offset), (void const   */* __restrict  */)(rsp->data + 1),
           (size_t )(rsp->data_len - 1));
#line 641
    offset = (uint16_t )((int )offset + (rsp->data_len - 1));
    }
  }
#line 647
  cipher_suite_data_length = offset;
#line 648
  offset = (uint16_t )0;
#line 650
  if (! csv_output) {
    {
#line 651
    printf((char const   */* __restrict  */)"ID   IANA    Auth Alg        Integrity Alg   Confidentiality Alg\n");
    }
  }
  {
#line 653
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 653
    if (! ((int )offset < (int )cipher_suite_data_length)) {
#line 653
      goto while_break___0;
    }
#line 655
    tmp___6 = offset;
#line 655
    offset = (uint16_t )((int )offset + 1);
#line 655
    if ((int )cipher_suite_data[tmp___6] == 192) {
#line 657
      oem_record = (uint8_t )0;
#line 658
      iana = (uint32_t )0;
#line 661
      if ((int )cipher_suite_data_length - (int )offset < 4) {
        {
#line 663
        lprintf(3, "Incomplete data record in cipher suite data");
        }
#line 664
        return (-1);
      }
#line 667
      tmp___3 = offset;
#line 667
      offset = (uint16_t )((int )offset + 1);
#line 667
      cipher_suite_id = cipher_suite_data[tmp___3];
    } else {
#line 670
      tmp___5 = offset;
#line 670
      offset = (uint16_t )((int )offset + 1);
#line 670
      if ((int )cipher_suite_data[tmp___5] == 193) {
#line 672
        oem_record = (uint8_t )1;
#line 675
        if ((int )cipher_suite_data_length - (int )offset < 4) {
          {
#line 677
          lprintf(3, "Incomplete data record in cipher suite data");
          }
#line 678
          return (-1);
        }
#line 681
        tmp___4 = offset;
#line 681
        offset = (uint16_t )((int )offset + 1);
#line 681
        cipher_suite_id = cipher_suite_data[tmp___4];
#line 686
        iana = (uint32_t )(((int )cipher_suite_data[offset] | ((int )cipher_suite_data[(int )offset + 1] << 8)) | ((int )cipher_suite_data[(int )offset + 2] << 16));
#line 690
        offset = (uint16_t )((int )offset + 3);
      } else {
        {
#line 694
        lprintf(3, "Bad start of record byte in cipher suite data");
        }
#line 695
        return (-1);
      }
    }
#line 706
    auth_alg = (uint8_t )0;
#line 707
    integrity_alg = (uint8_t )0;
#line 708
    crypt_alg = (uint8_t )0;
    {
#line 710
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 710
      if (((int )cipher_suite_data[offset] & 192) != 192) {
#line 710
        if (! ((int )cipher_suite_data_length - (int )offset > 0)) {
#line 710
          goto while_break___1;
        }
      } else {
#line 710
        goto while_break___1;
      }
      {
#line 715
      if (((int )cipher_suite_data[offset] & 192) == 0) {
#line 715
        goto case_0;
      }
#line 719
      if (((int )cipher_suite_data[offset] & 192) == 64) {
#line 719
        goto case_64;
      }
#line 723
      if (((int )cipher_suite_data[offset] & 192) == 128) {
#line 723
        goto case_128;
      }
#line 713
      goto switch_break;
      case_0: /* CIL Label */ 
#line 717
      tmp___7 = offset;
#line 717
      offset = (uint16_t )((int )offset + 1);
#line 717
      auth_alg = (uint8_t )((int )cipher_suite_data[tmp___7] & 63);
#line 718
      goto switch_break;
      case_64: /* CIL Label */ 
#line 721
      tmp___8 = offset;
#line 721
      offset = (uint16_t )((int )offset + 1);
#line 721
      integrity_alg = (uint8_t )((int )cipher_suite_data[tmp___8] & 63);
#line 722
      goto switch_break;
      case_128: /* CIL Label */ 
#line 725
      tmp___9 = offset;
#line 725
      offset = (uint16_t )((int )offset + 1);
#line 725
      crypt_alg = (uint8_t )((int )cipher_suite_data[tmp___9] & 63);
#line 726
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 734
    tmp___10 = val2str((uint16_t )crypt_alg, ipmi_encryption_algorithms);
#line 734
    tmp___11 = val2str((uint16_t )integrity_alg, ipmi_integrity_algorithms);
#line 734
    tmp___12 = val2str((uint16_t )auth_alg, ipmi_auth_algorithms);
#line 734
    tmp___13 = iana_string___0(iana);
    }
#line 734
    if (csv_output) {
#line 734
      tmp___14 = "%d,%s,%s,%s,%s\n";
    } else {
#line 734
      tmp___14 = "%-4d %-7s %-15s %-15s %-15s\n";
    }
    {
#line 734
    printf((char const   */* __restrict  */)tmp___14, (int )cipher_suite_id, tmp___13,
           tmp___12, tmp___11, tmp___10);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 744
  return (0);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_gendev.c"
static int ipmi_gendev_get_eeprom_size___0(struct ipmi_intf *intf , struct sdr_record_generic_locator *dev ,
                                           t_gendev_eeprom_info *info ) 
{ 
  int eeprom_size ;

  {
#line 79
  eeprom_size = 0;
#line 91
  if ((unsigned long )info != (unsigned long )((void *)0)) {
    {
#line 95
    if ((int )dev->dev_type == 8) {
#line 95
      goto case_8;
    }
#line 101
    if ((int )dev->dev_type == 9) {
#line 101
      goto case_9;
    }
#line 107
    if ((int )dev->dev_type == 10) {
#line 107
      goto case_10;
    }
#line 113
    if ((int )dev->dev_type == 11) {
#line 113
      goto case_11;
    }
#line 119
    if ((int )dev->dev_type == 12) {
#line 119
      goto case_12;
    }
#line 125
    if ((int )dev->dev_type == 13) {
#line 125
      goto case_13;
    }
#line 131
    if ((int )dev->dev_type == 14) {
#line 131
      goto case_14;
    }
#line 137
    if ((int )dev->dev_type == 15) {
#line 137
      goto case_15;
    }
#line 143
    if ((int )dev->dev_type == 192) {
#line 143
      goto case_192;
    }
#line 149
    if ((int )dev->dev_type == 193) {
#line 149
      goto case_193;
    }
#line 155
    if ((int )dev->dev_type == 194) {
#line 155
      goto case_194;
    }
#line 161
    if ((int )dev->dev_type == 195) {
#line 161
      goto case_195;
    }
#line 168
    goto switch_default;
    case_8: /* CIL Label */ 
#line 96
    info->size = (uint32_t )128;
#line 97
    info->page_size = (uint16_t )8;
#line 98
    info->address_span = dev->addr_span;
#line 99
    info->address_length = (uint8_t )1;
#line 100
    goto switch_break;
    case_9: /* CIL Label */ 
#line 102
    info->size = (uint32_t )256;
#line 103
    info->page_size = (uint16_t )8;
#line 104
    info->address_span = dev->addr_span;
#line 105
    info->address_length = (uint8_t )1;
#line 106
    goto switch_break;
    case_10: /* CIL Label */ 
#line 108
    info->size = (uint32_t )512;
#line 109
    info->page_size = (uint16_t )8;
#line 110
    info->address_span = dev->addr_span;
#line 111
    info->address_length = (uint8_t )2;
#line 112
    goto switch_break;
    case_11: /* CIL Label */ 
#line 114
    info->size = (uint32_t )1024;
#line 115
    info->page_size = (uint16_t )8;
#line 116
    info->address_span = dev->addr_span;
#line 117
    info->address_length = (uint8_t )2;
#line 118
    goto switch_break;
    case_12: /* CIL Label */ 
#line 120
    info->size = (uint32_t )2048;
#line 121
    info->page_size = (uint16_t )256;
#line 122
    info->address_span = dev->addr_span;
#line 123
    info->address_length = (uint8_t )2;
#line 124
    goto switch_break;
    case_13: /* CIL Label */ 
#line 126
    info->size = (uint32_t )2048;
#line 127
    info->page_size = (uint16_t )256;
#line 128
    info->address_span = dev->addr_span;
#line 129
    info->address_length = (uint8_t )2;
#line 130
    goto switch_break;
    case_14: /* CIL Label */ 
#line 132
    info->size = (uint32_t )4096;
#line 133
    info->page_size = (uint16_t )8;
#line 134
    info->address_span = dev->addr_span;
#line 135
    info->address_length = (uint8_t )2;
#line 136
    goto switch_break;
    case_15: /* CIL Label */ 
#line 138
    info->size = (uint32_t )8192;
#line 139
    info->page_size = (uint16_t )32;
#line 140
    info->address_span = dev->addr_span;
#line 141
    info->address_length = (uint8_t )2;
#line 142
    goto switch_break;
    case_192: /* CIL Label */ 
#line 144
    info->size = (uint32_t )16384;
#line 145
    info->page_size = (uint16_t )64;
#line 146
    info->address_span = dev->addr_span;
#line 147
    info->address_length = (uint8_t )2;
#line 148
    goto switch_break;
    case_193: /* CIL Label */ 
#line 150
    info->size = (uint32_t )32748;
#line 151
    info->page_size = (uint16_t )64;
#line 152
    info->address_span = dev->addr_span;
#line 153
    info->address_length = (uint8_t )2;
#line 154
    goto switch_break;
    case_194: /* CIL Label */ 
#line 156
    info->size = (uint32_t )65536;
#line 157
    info->page_size = (uint16_t )128;
#line 158
    info->address_span = dev->addr_span;
#line 159
    info->address_length = (uint8_t )2;
#line 160
    goto switch_break;
    case_195: /* CIL Label */ 
#line 162
    info->size = (uint32_t )131072;
#line 163
    info->page_size = (uint16_t )128;
#line 164
    info->address_span = dev->addr_span;
#line 165
    info->address_length = (uint8_t )2;
#line 166
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 169
    info->size = (uint32_t )0;
#line 170
    info->page_size = (uint16_t )0;
#line 171
    info->address_span = (uint8_t )0;
#line 172
    info->address_length = (uint8_t )0;
#line 173
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 176
    eeprom_size = (int )info->size;
  }
#line 179
  return (eeprom_size);
}
}
#line 304
static int ipmi_gendev_read_file___0(struct ipmi_intf *intf , struct sdr_record_generic_locator *dev ,
                                     char const   *ofile ) ;
#line 304 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_gendev.c"
static uint8_t previousCompleted___1  =    (uint8_t )101;
#line 184 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_gendev.c"
static int ipmi_gendev_read_file___0(struct ipmi_intf *intf , struct sdr_record_generic_locator *dev ,
                                     char const   *ofile ) 
{ 
  int rc ;
  int eeprom_size ;
  t_gendev_eeprom_info eeprom_info ;
  FILE *fp ;
  struct ipmi_rs *rsp ;
  int numWrite ;
  uint32_t counter ;
  uint8_t msize ;
  uint8_t channel ;
  uint8_t i2cbus ;
  uint8_t i2caddr ;
  uint8_t privatebus ;
  uint32_t address_span_size ;
  uint8_t percentCompleted ;
  uint8_t retryCounter ;
  uint8_t wrByte[18] ;
  size_t tmp ;

  {
  {
#line 191
  rc = 0;
#line 195
  eeprom_size = ipmi_gendev_get_eeprom_size___0(intf, dev, & eeprom_info);
  }
#line 197
  if (eeprom_size > 0) {
    {
#line 202
    fp = ipmi_open_file(ofile, 1);
    }
#line 204
    if (fp) {
#line 210
      channel = dev->channel_num;
#line 211
      i2cbus = dev->bus;
#line 212
      i2caddr = dev->dev_slave_addr;
#line 213
      privatebus = (uint8_t )1;
#line 215
      percentCompleted = (uint8_t )0;
#line 219
      if ((int )eeprom_info.address_span != 0) {
#line 221
        address_span_size = eeprom_info.size / (uint32_t )((int )eeprom_info.address_span + 1);
      } else {
#line 226
        address_span_size = eeprom_info.size;
      }
#line 230
      if ((int )eeprom_info.page_size < 16) {
#line 232
        msize = (uint8_t )eeprom_info.page_size;
      } else {
#line 236
        msize = (uint8_t )16;
      }
#line 242
      i2cbus = (uint8_t )(((((int )channel & 15) << 4) | (((int )i2cbus & 7) << 1)) | (int )privatebus);
#line 250
      counter = (uint32_t )0;
      {
#line 250
      while (1) {
        while_continue: /* CIL Label */ ;
#line 250
        if (counter < eeprom_info.size) {
#line 250
          if (! (rc == 0)) {
#line 250
            goto while_break;
          }
        } else {
#line 250
          goto while_break;
        }
#line 258
        retryCounter = (uint8_t )0;
        {
#line 258
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 258
          if (! ((int )retryCounter < 5)) {
#line 258
            goto while_break___0;
          }
#line 266
          wrByte[0] = (uint8_t )counter;
#line 267
          if ((int )eeprom_info.address_length > 1) {
#line 269
            wrByte[1] = (uint8_t )(counter >> 8);
          }
          {
#line 272
          i2caddr = (uint8_t )((unsigned int )i2caddr + (eeprom_info.size % address_span_size) * 2U);
#line 274
          rsp = ipmi_master_write_read(intf, i2cbus, i2caddr, wrByte, eeprom_info.address_length,
                                       msize);
          }
#line 283
          if ((unsigned long )rsp != (unsigned long )((void *)0)) {
#line 285
            retryCounter = (uint8_t )5;
#line 286
            rc = 0;
          } else
#line 288
          if ((int )retryCounter < 5) {
            {
#line 290
            retryCounter = (uint8_t )((int )retryCounter + 1);
#line 291
            lprintf(3, "Retry");
#line 292
            sleep(1U);
#line 293
            rc = -1;
            }
          } else {
            {
#line 297
            lprintf(3, "Unable to perform I2C Master Write-Read");
#line 298
            rc = -1;
            }
          }
#line 258
          retryCounter = (uint8_t )((int )retryCounter + 1);
        }
        while_break___0: /* CIL Label */ ;
        }
#line 302
        if (rc == 0) {
          {
#line 305
          tmp = fwrite((void const   */* __restrict  */)(rsp->data), (size_t )1, (size_t )msize,
                       (FILE */* __restrict  */)fp);
#line 305
          numWrite = (int )tmp;
          }
#line 306
          if (numWrite != (int )msize) {
            {
#line 308
            lprintf(3, "Error writing file %s", ofile);
#line 309
            rc = -1;
            }
#line 310
            goto while_break;
          }
#line 313
          percentCompleted = (uint8_t )((counter * 100U) / eeprom_info.size);
#line 315
          if ((int )percentCompleted != (int )previousCompleted___1) {
            {
#line 317
            printf((char const   */* __restrict  */)"\r%i percent completed", (int )percentCompleted);
#line 318
            previousCompleted___1 = percentCompleted;
            }
          }
        }
#line 250
        counter += (uint32_t )msize;
      }
      while_break: /* CIL Label */ ;
      }
#line 324
      if (counter == eeprom_info.size) {
        {
#line 326
        printf((char const   */* __restrict  */)"\r%%100 percent completed\n");
        }
      } else {
        {
#line 330
        printf((char const   */* __restrict  */)"\rError: %i percent completed, read not completed \n",
               (int )percentCompleted);
        }
      }
      {
#line 333
      fclose(fp);
      }
    }
  } else {
    {
#line 338
    lprintf(3, "The selected generic device is not an eeprom");
    }
  }
#line 341
  return (rc);
}
}
#line 500
static int ipmi_gendev_write_file___0(struct ipmi_intf *intf , struct sdr_record_generic_locator *dev ,
                                      char const   *ofile ) ;
#line 500 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_gendev.c"
static uint8_t previousCompleted___2  =    (uint8_t )101;
#line 356 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_gendev.c"
static int ipmi_gendev_write_file___0(struct ipmi_intf *intf , struct sdr_record_generic_locator *dev ,
                                      char const   *ofile ) 
{ 
  int rc ;
  int eeprom_size ;
  t_gendev_eeprom_info eeprom_info ;
  FILE *fp ;
  uint32_t fileLength ;
  long tmp ;
  struct ipmi_rs *rsp ;
  int numRead ;
  uint32_t counter ;
  uint8_t msize ;
  uint8_t channel ;
  uint8_t i2cbus ;
  uint8_t i2caddr ;
  uint8_t privatebus ;
  uint32_t address_span_size ;
  uint8_t percentCompleted ;
  uint8_t retryCounter ;
  uint8_t readByte[16] ;
  size_t tmp___0 ;
  uint8_t wrByte[18] ;

  {
  {
#line 363
  rc = 0;
#line 367
  eeprom_size = ipmi_gendev_get_eeprom_size___0(intf, dev, & eeprom_info);
  }
#line 369
  if (eeprom_size > 0) {
    {
#line 372
    fileLength = (uint32_t )0;
#line 375
    fp = ipmi_open_file(ofile, 0);
    }
#line 377
    if (fp) {
      {
#line 380
      fseek(fp, 0L, 2);
#line 381
      tmp = ftell(fp);
#line 381
      fileLength = (uint32_t )tmp;
#line 383
      lprintf(3, "File   Size: %i", fileLength);
#line 384
      lprintf(3, "Eeprom Size: %i", eeprom_size);
      }
#line 385
      if (fileLength != (uint32_t )eeprom_size) {
        {
#line 387
        lprintf(3, "File size does not fit Eeprom Size");
#line 388
        fclose(fp);
#line 389
        fp = (FILE *)((void *)0);
        }
      } else {
        {
#line 393
        fseek(fp, 0L, 0);
        }
      }
    }
#line 397
    if (fp) {
#line 403
      channel = dev->channel_num;
#line 404
      i2cbus = dev->bus;
#line 405
      i2caddr = dev->dev_slave_addr;
#line 406
      privatebus = (uint8_t )1;
#line 408
      percentCompleted = (uint8_t )0;
#line 412
      if ((int )eeprom_info.address_span != 0) {
#line 414
        address_span_size = eeprom_info.size / (uint32_t )((int )eeprom_info.address_span + 1);
      } else {
#line 419
        address_span_size = eeprom_info.size;
      }
#line 423
      if ((int )eeprom_info.page_size < 16) {
#line 425
        msize = (uint8_t )eeprom_info.page_size;
      } else {
#line 429
        msize = (uint8_t )16;
      }
#line 435
      i2cbus = (uint8_t )(((((int )channel & 15) << 4) | (((int )i2cbus & 7) << 1)) | (int )privatebus);
#line 443
      counter = (uint32_t )0;
      {
#line 443
      while (1) {
        while_continue: /* CIL Label */ ;
#line 443
        if (counter < eeprom_info.size) {
#line 443
          if (! (rc == 0)) {
#line 443
            goto while_break;
          }
        } else {
#line 443
          goto while_break;
        }
        {
#line 452
        tmp___0 = fread((void */* __restrict  */)(readByte), (size_t )1, (size_t )msize,
                        (FILE */* __restrict  */)fp);
#line 452
        numRead = (int )tmp___0;
        }
#line 453
        if (numRead != (int )msize) {
          {
#line 455
          lprintf(3, "Error reading file %s", ofile);
#line 456
          rc = -1;
          }
#line 457
          goto while_break;
        }
#line 462
        retryCounter = (uint8_t )0;
        {
#line 462
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 462
          if (! ((int )retryCounter < 5)) {
#line 462
            goto while_break___0;
          }
#line 469
          wrByte[0] = (uint8_t )counter;
#line 470
          if ((int )eeprom_info.address_length > 1) {
#line 472
            wrByte[1] = (uint8_t )(counter >> 8);
          }
          {
#line 474
          memcpy((void */* __restrict  */)(& wrByte[eeprom_info.address_length]),
                 (void const   */* __restrict  */)(readByte), (size_t )msize);
#line 476
          i2caddr = (uint8_t )((unsigned int )i2caddr + (eeprom_info.size % address_span_size) * 2U);
#line 478
          rsp = ipmi_master_write_read(intf, i2cbus, i2caddr, wrByte, (uint8_t )((int )eeprom_info.address_length + (int )msize),
                                       (uint8_t )0);
          }
#line 479
          if ((unsigned long )rsp != (unsigned long )((void *)0)) {
#line 481
            retryCounter = (uint8_t )5;
#line 482
            rc = 0;
          } else
#line 484
          if ((int )retryCounter < 5) {
            {
#line 486
            retryCounter = (uint8_t )((int )retryCounter + 1);
#line 487
            lprintf(3, "Retry");
#line 488
            sleep(1U);
#line 489
            rc = -1;
            }
          } else {
            {
#line 493
            lprintf(3, "Unable to perform I2C Master Write-Read");
#line 494
            rc = -1;
            }
          }
#line 462
          retryCounter = (uint8_t )((int )retryCounter + 1);
        }
        while_break___0: /* CIL Label */ ;
        }
#line 498
        if (rc == 0) {
#line 501
          percentCompleted = (uint8_t )((counter * 100U) / eeprom_info.size);
#line 503
          if ((int )percentCompleted != (int )previousCompleted___2) {
            {
#line 505
            printf((char const   */* __restrict  */)"\r%i percent completed", (int )percentCompleted);
#line 506
            previousCompleted___2 = percentCompleted;
            }
          }
        }
#line 443
        counter += (uint32_t )msize;
      }
      while_break: /* CIL Label */ ;
      }
#line 511
      if (counter == eeprom_info.size) {
        {
#line 513
        printf((char const   */* __restrict  */)"\r%%100 percent completed\n");
        }
      } else {
        {
#line 517
        printf((char const   */* __restrict  */)"\rError: %i percent completed, read not completed \n",
               (int )percentCompleted);
        }
      }
      {
#line 520
      fclose(fp);
      }
    }
  } else {
    {
#line 525
    lprintf(3, "The selected generic device is not an eeprom");
    }
  }
#line 528
  return (rc);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static void printf_firewall_usage___0(void) 
{ 


  {
  {
#line 50
  lprintf(5, "Firmware Firewall Commands:");
#line 52
  lprintf(5, "\tinfo [channel H] [lun L]");
#line 54
  lprintf(5, "\tinfo [channel H] [lun L [netfn N [command C [subfn S]]]]");
#line 56
  lprintf(5, "\tenable [channel H] [lun L [netfn N [command C [subfn S]]]]");
#line 58
  lprintf(5, "\tdisable [channel H] [lun L [netfn N [command C [subfn S]]]] [force])");
#line 60
  lprintf(5, "\treset [channel H]");
#line 62
  lprintf(5, "\t\twhere H is a Channel, L is a LUN, N is a NetFn,");
#line 64
  lprintf(5, "\t\tC is a Command and S is a Sub-Function");
  }
#line 66
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static void print_bitfield___0(unsigned char const   *bf , int n , int invert , int loglevel ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 101
  i = 0;
#line 102
  if (loglevel < 0) {
    {
#line 103
    while (1) {
      while_continue: /* CIL Label */ ;
#line 103
      if (! (i < n)) {
#line 103
        goto while_break;
      }
#line 104
      if (invert) {
#line 104
        tmp = ~ ((int const   )*(bf + i));
      } else {
#line 104
        tmp = (int const   )*(bf + i);
      }
      {
#line 104
      printf((char const   */* __restrict  */)"%02x", (int )((unsigned char )tmp));
#line 105
      i ++;
      }
#line 105
      if (i % 4 == 0) {
        {
#line 106
        printf((char const   */* __restrict  */)" ");
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 108
    printf((char const   */* __restrict  */)"\n");
    }
  } else {
    {
#line 110
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 110
      if (! (i < n)) {
#line 110
        goto while_break___0;
      }
#line 111
      if (invert) {
#line 111
        tmp___0 = ~ ((int const   )*(bf + i));
      } else {
#line 111
        tmp___0 = (int const   )*(bf + i);
      }
      {
#line 111
      lprintf(loglevel, "%02x", (int )((unsigned char )tmp___0));
#line 112
      i ++;
      }
#line 112
      if (i % 4 == 0) {
        {
#line 113
        lprintf(loglevel, " ");
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 115
    lprintf(loglevel, "\n");
    }
  }
#line 118
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int ipmi_firewall_parse_args___0(int argc , char **argv , struct ipmi_function_params *p ) 
{ 
  int i ;
  uint8_t conv_err ;
  uint8_t channel_tmp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 124
  conv_err = (uint8_t )0;
#line 126
  if (! p) {
    {
#line 127
    lprintf(3, "ipmi_firewall_parse_args: p is NULL");
    }
#line 128
    return (-1);
  }
#line 130
  i = 0;
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! (i < argc)) {
#line 130
      goto while_break;
    }
    {
#line 131
    tmp___9 = strncmp((char const   *)*(argv + i), "channel", (size_t )7);
    }
#line 131
    if (tmp___9 == 0) {
#line 131
      i ++;
#line 131
      if (i < argc) {
        {
#line 132
        channel_tmp = (uint8_t )0;
#line 133
        tmp = is_ipmi_channel_num((char const   *)*(argv + i), & channel_tmp);
        }
#line 133
        if (tmp != 0) {
#line 134
          conv_err = (uint8_t )1;
#line 135
          goto while_break;
        } else {
#line 137
          p->channel = (int )channel_tmp;
        }
      } else {
#line 131
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      {
#line 140
      tmp___8 = strncmp((char const   *)*(argv + i), "lun", (size_t )3);
      }
#line 140
      if (tmp___8 == 0) {
#line 140
        i ++;
#line 140
        if (i < argc) {
          {
#line 141
          tmp___0 = str2int((char const   *)*(argv + i), & p->lun);
          }
#line 141
          if (tmp___0 != 0) {
            {
#line 142
            lprintf(3, "Given lun \'%s\' is invalid.", *(argv + i));
#line 143
            conv_err = (uint8_t )1;
            }
#line 144
            goto while_break;
          }
        } else {
#line 140
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        {
#line 147
        tmp___7 = strncmp((char const   *)*(argv + i), "force", (size_t )5);
        }
#line 147
        if (tmp___7 == 0) {
#line 148
          p->force = (unsigned char)1;
        } else {
          {
#line 150
          tmp___6 = strncmp((char const   *)*(argv + i), "netfn", (size_t )5);
          }
#line 150
          if (tmp___6 == 0) {
#line 150
            i ++;
#line 150
            if (i < argc) {
              {
#line 151
              tmp___1 = str2int((char const   *)*(argv + i), & p->netfn);
              }
#line 151
              if (tmp___1 != 0) {
                {
#line 152
                lprintf(3, "Given netfn \'%s\' is invalid.", *(argv + i));
#line 153
                conv_err = (uint8_t )1;
                }
#line 154
                goto while_break;
              }
            } else {
#line 150
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
            {
#line 157
            tmp___5 = strncmp((char const   *)*(argv + i), "command", (size_t )7);
            }
#line 157
            if (tmp___5 == 0) {
#line 157
              i ++;
#line 157
              if (i < argc) {
                {
#line 158
                tmp___2 = str2int((char const   *)*(argv + i), & p->command);
                }
#line 158
                if (tmp___2 != 0) {
                  {
#line 159
                  lprintf(3, "Given command \'%s\' is invalid.", *(argv + i));
#line 160
                  conv_err = (uint8_t )1;
                  }
#line 161
                  goto while_break;
                }
              } else {
#line 157
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              {
#line 164
              tmp___4 = strncmp((char const   *)*(argv + i), "subfn", (size_t )5);
              }
#line 164
              if (tmp___4 == 0) {
#line 164
                i ++;
#line 164
                if (i < argc) {
                  {
#line 165
                  tmp___3 = str2int((char const   *)*(argv + i), & p->subfn);
                  }
#line 165
                  if (tmp___3 != 0) {
                    {
#line 166
                    lprintf(3, "Given subfn \'%s\' is invalid.", *(argv + i));
#line 167
                    conv_err = (uint8_t )1;
                    }
#line 168
                    goto while_break;
                  }
                }
              }
            }
          }
        }
      }
    }
#line 130
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  if ((int )conv_err != 0) {
#line 173
    return (-1);
  }
#line 175
  if (p->subfn >= 32) {
    {
#line 176
    lprintf(3, "subfn is out of range (0-%d)", 31);
    }
#line 177
    return (-1);
  }
#line 179
  if (p->command >= 256) {
    {
#line 180
    lprintf(3, "command is out of range (0-%d)", 255);
    }
#line 181
    return (-1);
  }
#line 183
  if (p->netfn >= 64) {
    {
#line 184
    lprintf(3, "netfn is out of range (0-%d)", 63);
    }
#line 185
    return (-1);
  }
#line 187
  if (p->lun >= 4) {
    {
#line 188
    lprintf(3, "lun is out of range (0-%d)", 3);
    }
#line 189
    return (-1);
  }
#line 191
  if (p->netfn >= 0) {
#line 191
    if (p->lun < 0) {
      {
#line 192
      lprintf(3, "if netfn is set, so must be lun");
      }
#line 193
      return (-1);
    }
  }
#line 195
  if (p->command >= 0) {
#line 195
    if (p->netfn < 0) {
      {
#line 196
      lprintf(3, "if command is set, so must be netfn");
      }
#line 197
      return (-1);
    }
  }
#line 199
  if (p->subfn >= 0) {
#line 199
    if (p->command < 0) {
      {
#line 200
      lprintf(3, "if subfn is set, so must be command");
      }
#line 201
      return (-1);
    }
  }
#line 203
  return (0);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int _get_netfn_support___0(struct ipmi_intf *intf , int channel , unsigned char *lun ,
                                  unsigned char *netfn ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char *d ;
  unsigned char rqdata ;
  unsigned int l ;
  char const   *tmp ;

  {
#line 225
  if (! lun) {
    {
#line 226
    lprintf(3, "_get_netfn_suport: lun or netfn is NULL");
    }
#line 227
    return (-1);
  } else
#line 225
  if (! netfn) {
    {
#line 226
    lprintf(3, "_get_netfn_suport: lun or netfn is NULL");
    }
#line 227
    return (-1);
  }
  {
#line 230
  memset((void *)(& req), 0, sizeof(req));
#line 231
  req.msg.netfn = (uint8_t )6;
#line 232
  req.msg.cmd = (uint8_t )9;
#line 233
  rqdata = (unsigned char )channel;
#line 234
  req.msg.data = & rqdata;
#line 235
  req.msg.data_len = (uint16_t )1;
#line 237
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 238
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 239
    lprintf(3, "Get NetFn Support command failed");
    }
#line 240
    return (-1);
  }
#line 242
  if ((int )rsp->ccode > 0) {
    {
#line 243
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 243
    lprintf(3, "Get NetFn Support command failed: %s", tmp);
    }
#line 245
    return (-1);
  }
#line 248
  d = rsp->data;
#line 249
  l = 0U;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! (l < 4U)) {
#line 249
      goto while_break;
    }
#line 250
    *(lun + l) = (unsigned char )(((int )*d >> 2U * l) & 3);
#line 249
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 252
  d ++;
#line 254
  memcpy((void */* __restrict  */)netfn, (void const   */* __restrict  */)d, (size_t )16);
  }
#line 256
  return (0);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int _get_command_support___0(struct ipmi_intf *intf , struct ipmi_function_params *p ,
                                    struct lun_netfn_support *lnfn ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char *d ;
  unsigned char rqdata[3] ;
  unsigned int c ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 277
  if (! p) {
    {
#line 278
    lprintf(3, "_get_netfn_suport: p or lnfn is NULL");
    }
#line 279
    return (-1);
  } else
#line 277
  if (! lnfn) {
    {
#line 278
    lprintf(3, "_get_netfn_suport: p or lnfn is NULL");
    }
#line 279
    return (-1);
  }
  {
#line 282
  memset((void *)(& req), 0, sizeof(req));
#line 283
  req.msg.netfn = (uint8_t )6;
#line 284
  req.msg.cmd = (uint8_t )10;
#line 285
  rqdata[0] = (unsigned char )p->channel;
#line 286
  rqdata[1] = (unsigned char )p->netfn;
#line 287
  rqdata[2] = (unsigned char )p->lun;
#line 288
  req.msg.data = rqdata;
#line 289
  req.msg.data_len = (uint16_t )3;
#line 291
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 292
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 293
    lprintf(3, "Get Command Support (LUN=%d, NetFn=%d, op=0) command failed", p->lun,
            p->netfn);
    }
#line 294
    return (-1);
  }
#line 296
  if ((int )rsp->ccode > 0) {
    {
#line 297
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 297
    lprintf(3, "Get Command Support (LUN=%d, NetFn=%d, op=0) command failed: %s",
            p->lun, p->netfn, tmp);
    }
#line 299
    return (-1);
  }
#line 302
  d = rsp->data;
#line 303
  c = 0U;
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    if (! (c < 128U)) {
#line 303
      goto while_break;
    }
#line 304
    if (! ((int )*(d + (c >> 3)) & (1 << c % 8U))) {
#line 305
      lnfn->command[c].support = (unsigned char )((int )lnfn->command[c].support | 1);
    }
#line 303
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 307
  memcpy((void */* __restrict  */)(lnfn->command_mask), (void const   */* __restrict  */)d,
         (size_t )((256 >> 3) / 2));
#line 309
  memset((void *)(& req), 0, sizeof(req));
#line 310
  req.msg.netfn = (uint8_t )6;
#line 311
  req.msg.cmd = (uint8_t )10;
#line 312
  rqdata[0] = (unsigned char )p->channel;
#line 313
  rqdata[1] = (unsigned char )(64 | p->netfn);
#line 314
  rqdata[2] = (unsigned char )p->lun;
#line 315
  req.msg.data = rqdata;
#line 316
  req.msg.data_len = (uint16_t )3;
#line 318
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 319
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 320
    lprintf(3, "Get Command Support (LUN=%d, NetFn=%d, op=1) command failed", p->lun,
            p->netfn);
    }
#line 321
    return (-1);
  }
#line 323
  if ((int )rsp->ccode > 0) {
    {
#line 324
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 324
    lprintf(3, "Get Command Support (LUN=%d, NetFn=%d, op=1) command failed: %s",
            p->lun, p->netfn, tmp___0);
    }
#line 326
    return (-1);
  }
#line 329
  d = rsp->data;
#line 330
  c = 0U;
  {
#line 330
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 330
    if (! (c < 128U)) {
#line 330
      goto while_break___0;
    }
#line 331
    if (! ((int )*(d + (c >> 3)) & (1 << c % 8U))) {
#line 332
      lnfn->command[128U + c].support = (unsigned char )((int )lnfn->command[128U + c].support | 1);
    }
#line 330
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 334
  memcpy((void */* __restrict  */)(lnfn->command_mask + (256 >> 3) / 2), (void const   */* __restrict  */)d,
         (size_t )((256 >> 3) / 2));
  }
#line 335
  return (0);
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int _get_command_configurable___0(struct ipmi_intf *intf , struct ipmi_function_params *p ,
                                         struct lun_netfn_support *lnfn ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char *d ;
  unsigned char rqdata[3] ;
  unsigned int c ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 356
  if (! p) {
    {
#line 357
    lprintf(3, "_get_command_configurable: p or lnfn is NULL");
    }
#line 358
    return (-1);
  } else
#line 356
  if (! lnfn) {
    {
#line 357
    lprintf(3, "_get_command_configurable: p or lnfn is NULL");
    }
#line 358
    return (-1);
  }
  {
#line 361
  memset((void *)(& req), 0, sizeof(req));
#line 362
  req.msg.netfn = (uint8_t )6;
#line 363
  req.msg.cmd = (uint8_t )12;
#line 364
  rqdata[0] = (unsigned char )p->channel;
#line 365
  rqdata[1] = (unsigned char )p->netfn;
#line 366
  rqdata[2] = (unsigned char )p->lun;
#line 367
  req.msg.data = rqdata;
#line 368
  req.msg.data_len = (uint16_t )3;
#line 370
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 371
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 372
    lprintf(3, "Get Configurable Command (LUN=%d, NetFn=%d, op=0) command failed",
            p->lun, p->netfn);
    }
#line 373
    return (-1);
  }
#line 375
  if ((int )rsp->ccode > 0) {
    {
#line 376
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 376
    lprintf(3, "Get Configurable Command (LUN=%d, NetFn=%d, op=0) command failed: %s",
            p->lun, p->netfn, tmp);
    }
#line 378
    return (-1);
  }
#line 381
  d = rsp->data;
#line 382
  c = 0U;
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 382
    if (! (c < 128U)) {
#line 382
      goto while_break;
    }
#line 383
    if ((int )*(d + (c >> 3)) & (1 << c % 8U)) {
#line 384
      lnfn->command[c].support = (unsigned char )((int )lnfn->command[c].support | 2);
    }
#line 382
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 386
  memcpy((void */* __restrict  */)(lnfn->config_mask), (void const   */* __restrict  */)d,
         (size_t )((256 >> 3) / 2));
#line 388
  memset((void *)(& req), 0, sizeof(req));
#line 389
  req.msg.netfn = (uint8_t )6;
#line 390
  req.msg.cmd = (uint8_t )12;
#line 391
  rqdata[0] = (unsigned char )p->channel;
#line 392
  rqdata[1] = (unsigned char )(64 | p->netfn);
#line 393
  rqdata[2] = (unsigned char )p->lun;
#line 394
  req.msg.data = rqdata;
#line 395
  req.msg.data_len = (uint16_t )3;
#line 397
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 398
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 399
    lprintf(3, "Get Configurable Command (LUN=%d, NetFn=%d, op=1) command failed",
            p->lun, p->netfn);
    }
#line 400
    return (-1);
  }
#line 402
  if ((int )rsp->ccode > 0) {
    {
#line 403
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 403
    lprintf(3, "Get Configurable Command (LUN=%d, NetFn=%d, op=1) command failed: %s",
            p->lun, p->netfn, tmp___0);
    }
#line 405
    return (-1);
  }
#line 408
  d = rsp->data;
#line 409
  c = 0U;
  {
#line 409
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 409
    if (! (c < 128U)) {
#line 409
      goto while_break___0;
    }
#line 410
    if ((int )*(d + (c >> 3)) & (1 << c % 8U)) {
#line 411
      lnfn->command[128U + c].support = (unsigned char )((int )lnfn->command[128U + c].support | 2);
    }
#line 409
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 413
  memcpy((void */* __restrict  */)(lnfn->config_mask + (256 >> 3) / 2), (void const   */* __restrict  */)d,
         (size_t )((256 >> 3) / 2));
  }
#line 414
  return (0);
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int _get_command_enables___0(struct ipmi_intf *intf , struct ipmi_function_params *p ,
                                    struct lun_netfn_support *lnfn ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char *d ;
  unsigned char rqdata[3] ;
  unsigned int c ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 435
  if (! p) {
    {
#line 436
    lprintf(3, "_get_command_enables: p or lnfn is NULL");
    }
#line 437
    return (-1);
  } else
#line 435
  if (! lnfn) {
    {
#line 436
    lprintf(3, "_get_command_enables: p or lnfn is NULL");
    }
#line 437
    return (-1);
  }
  {
#line 440
  memset((void *)(& req), 0, sizeof(req));
#line 441
  req.msg.netfn = (uint8_t )6;
#line 442
  req.msg.cmd = (uint8_t )97;
#line 443
  rqdata[0] = (unsigned char )p->channel;
#line 444
  rqdata[1] = (unsigned char )p->netfn;
#line 445
  rqdata[2] = (unsigned char )p->lun;
#line 446
  req.msg.data = rqdata;
#line 447
  req.msg.data_len = (uint16_t )3;
#line 449
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 450
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 451
    lprintf(3, "Get Command Enables (LUN=%d, NetFn=%d, op=0) command failed", p->lun,
            p->netfn);
    }
#line 452
    return (-1);
  }
#line 454
  if ((int )rsp->ccode > 0) {
    {
#line 455
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 455
    lprintf(3, "Get Command Enables (LUN=%d, NetFn=%d, op=0) command failed: %s",
            p->lun, p->netfn, tmp);
    }
#line 457
    return (-1);
  }
#line 460
  d = rsp->data;
#line 461
  c = 0U;
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    if (! (c < 128U)) {
#line 461
      goto while_break;
    }
#line 462
    if ((int )*(d + (c >> 3)) & (1 << c % 8U)) {
#line 463
      lnfn->command[c].support = (unsigned char )((int )lnfn->command[c].support | 4);
    }
#line 461
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 465
  memcpy((void */* __restrict  */)(lnfn->enable_mask), (void const   */* __restrict  */)d,
         (size_t )((256 >> 3) / 2));
#line 467
  memset((void *)(& req), 0, sizeof(req));
#line 468
  req.msg.netfn = (uint8_t )6;
#line 469
  req.msg.cmd = (uint8_t )97;
#line 470
  rqdata[0] = (unsigned char )p->channel;
#line 471
  rqdata[1] = (unsigned char )(64 | p->netfn);
#line 472
  rqdata[2] = (unsigned char )p->lun;
#line 473
  req.msg.data = rqdata;
#line 474
  req.msg.data_len = (uint16_t )3;
#line 476
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 477
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 478
    lprintf(3, "Get Command Enables (LUN=%d, NetFn=%d, op=1) command failed", p->lun,
            p->netfn);
    }
#line 479
    return (-1);
  }
#line 481
  if ((int )rsp->ccode > 0) {
    {
#line 482
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 482
    lprintf(3, "Get Command Enables (LUN=%d, NetFn=%d, op=1) command failed: %s",
            p->lun, p->netfn, tmp___0);
    }
#line 484
    return (-1);
  }
#line 487
  d = rsp->data;
#line 488
  c = 0U;
  {
#line 488
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 488
    if (! (c < 128U)) {
#line 488
      goto while_break___0;
    }
#line 489
    if ((int )*(d + (c >> 3)) & (1 << c % 8U)) {
#line 490
      lnfn->command[128U + c].support = (unsigned char )((int )lnfn->command[128U + c].support | 4);
    }
#line 488
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 492
  memcpy((void */* __restrict  */)(lnfn->enable_mask + (256 >> 3) / 2), (void const   */* __restrict  */)d,
         (size_t )((256 >> 3) / 2));
  }
#line 493
  return (0);
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int _set_command_enables___0(struct ipmi_intf *intf , struct ipmi_function_params *p ,
                                    struct lun_netfn_support *lnfn , unsigned char *enable ,
                                    int gun ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char *d ;
  unsigned char rqdata[19] ;
  unsigned int c ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 518
  if (! p) {
    {
#line 519
    lprintf(3, "_set_command_enables: p or lnfn is NULL");
    }
#line 520
    return (-1);
  } else
#line 518
  if (! lnfn) {
    {
#line 519
    lprintf(3, "_set_command_enables: p or lnfn is NULL");
    }
#line 520
    return (-1);
  }
  {
#line 523
  lprintf(6, "support:            ");
#line 524
  print_bitfield___0((unsigned char const   *)(lnfn->command_mask), 256 >> 3, 1, 6);
#line 525
  lprintf(6, "configurable:       ");
#line 526
  print_bitfield___0((unsigned char const   *)(lnfn->config_mask), 256 >> 3, 0, 6);
#line 527
  lprintf(6, "enabled:            ");
#line 528
  print_bitfield___0((unsigned char const   *)(lnfn->enable_mask), 256 >> 3, 0, 6);
#line 529
  lprintf(6, "enable mask before: ");
#line 530
  print_bitfield___0((unsigned char const   *)enable, 256 >> 3, 0, 6);
#line 534
  c = 0U;
  }
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 534
    if (! (c < (unsigned int )(256 >> 3))) {
#line 534
      goto while_break;
    }
#line 535
    *(enable + c) = (unsigned char )(((int )lnfn->config_mask[c] & (int )*(enable + c)) | (~ ((int )lnfn->config_mask[c]) & (int )lnfn->enable_mask[c]));
#line 534
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 540
  if (! gun) {
#line 541
    *(enable + 12) = (unsigned char )(~ ((int )lnfn->config_mask[12]) & (int )lnfn->enable_mask[12]);
  }
  {
#line 547
  lprintf(6, "enable mask after: ");
#line 548
  print_bitfield___0((unsigned char const   *)enable, 256 >> 3, 0, 6);
#line 550
  memset((void *)(& req), 0, sizeof(req));
#line 551
  req.msg.netfn = (uint8_t )6;
#line 552
  req.msg.cmd = (uint8_t )96;
#line 553
  rqdata[0] = (unsigned char )p->channel;
#line 554
  rqdata[1] = (unsigned char )p->netfn;
#line 555
  rqdata[2] = (unsigned char )p->lun;
#line 556
  memcpy((void */* __restrict  */)(& rqdata[3]), (void const   */* __restrict  */)enable,
         (size_t )((256 >> 3) / 2));
#line 557
  req.msg.data = rqdata;
#line 558
  req.msg.data_len = (uint16_t )19;
#line 560
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 561
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 562
    lprintf(3, "Set Command Enables (LUN=%d, NetFn=%d, op=0) command failed", p->lun,
            p->netfn);
    }
#line 563
    return (-1);
  }
#line 565
  if ((int )rsp->ccode > 0) {
    {
#line 566
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 566
    lprintf(3, "Set Command Enables (LUN=%d, NetFn=%d, op=0) command failed: %s",
            p->lun, p->netfn, tmp);
    }
#line 568
    return (-1);
  }
  {
#line 571
  d = rsp->data;
#line 573
  memset((void *)(& req), 0, sizeof(req));
#line 574
  req.msg.netfn = (uint8_t )6;
#line 575
  req.msg.cmd = (uint8_t )96;
#line 576
  rqdata[0] = (unsigned char )p->channel;
#line 577
  rqdata[1] = (unsigned char )(64 | p->netfn);
#line 578
  rqdata[2] = (unsigned char )p->lun;
#line 579
  memcpy((void */* __restrict  */)(& rqdata[3]), (void const   */* __restrict  */)(enable + (256 >> 3) / 2),
         (size_t )((256 >> 3) / 2));
#line 580
  req.msg.data = rqdata;
#line 581
  req.msg.data_len = (uint16_t )19;
#line 583
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 584
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 585
    lprintf(3, "Set Command Enables (LUN=%d, NetFn=%d, op=1) command failed", p->lun,
            p->netfn);
    }
#line 586
    return (-1);
  }
#line 588
  if ((int )rsp->ccode > 0) {
    {
#line 589
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 589
    lprintf(3, "Set Command Enables (LUN=%d, NetFn=%d, op=1) command failed: %s",
            p->lun, p->netfn, tmp___0);
    }
#line 591
    return (-1);
  }
#line 594
  d = rsp->data;
#line 595
  return (0);
}
}
#line 607 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int _get_subfn_support___0(struct ipmi_intf *intf , struct ipmi_function_params *p ,
                                  struct command_support *cmd ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char rqdata[4] ;
  char const   *tmp ;

  {
#line 615
  if (! p) {
    {
#line 616
    lprintf(3, "_get_subfn_support: p or cmd is NULL");
    }
#line 617
    return (-1);
  } else
#line 615
  if (! cmd) {
    {
#line 616
    lprintf(3, "_get_subfn_support: p or cmd is NULL");
    }
#line 617
    return (-1);
  }
  {
#line 620
  memset((void *)(& req), 0, sizeof(req));
#line 621
  req.msg.netfn = (uint8_t )6;
#line 622
  req.msg.cmd = (uint8_t )11;
#line 623
  rqdata[0] = (unsigned char )p->channel;
#line 624
  rqdata[1] = (unsigned char )p->netfn;
#line 625
  rqdata[2] = (unsigned char )p->lun;
#line 626
  rqdata[3] = (unsigned char )p->command;
#line 627
  req.msg.data = rqdata;
#line 628
  req.msg.data_len = (uint16_t )4;
#line 630
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 631
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 632
    lprintf(3, "Get Command Sub-function Support (LUN=%d, NetFn=%d, command=%d) command failed",
            p->lun, p->netfn, p->command);
    }
#line 633
    return (-1);
  }
#line 635
  if ((int )rsp->ccode > 0) {
    {
#line 636
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 636
    lprintf(3, "Get Command Sub-function Support (LUN=%d, NetFn=%d, command=%d) command failed: %s",
            p->lun, p->netfn, p->command, tmp);
    }
#line 638
    return (-1);
  }
  {
#line 641
  memcpy((void */* __restrict  */)(cmd->subfn_support), (void const   */* __restrict  */)(rsp->data),
         sizeof(cmd->subfn_support));
  }
#line 642
  return (0);
}
}
#line 654 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int _get_subfn_configurable___0(struct ipmi_intf *intf , struct ipmi_function_params *p ,
                                       struct command_support *cmd ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char rqdata[4] ;
  char const   *tmp ;

  {
#line 662
  if (! p) {
    {
#line 663
    lprintf(3, "_get_subfn_configurable: p or cmd is NULL");
    }
#line 664
    return (-1);
  } else
#line 662
  if (! cmd) {
    {
#line 663
    lprintf(3, "_get_subfn_configurable: p or cmd is NULL");
    }
#line 664
    return (-1);
  }
  {
#line 667
  memset((void *)(& req), 0, sizeof(req));
#line 668
  req.msg.netfn = (uint8_t )6;
#line 669
  req.msg.cmd = (uint8_t )13;
#line 670
  rqdata[0] = (unsigned char )p->channel;
#line 671
  rqdata[1] = (unsigned char )p->netfn;
#line 672
  rqdata[2] = (unsigned char )p->lun;
#line 673
  rqdata[3] = (unsigned char )p->command;
#line 674
  req.msg.data = rqdata;
#line 675
  req.msg.data_len = (uint16_t )4;
#line 677
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 678
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 679
    lprintf(3, "Get Configurable Command Sub-function (LUN=%d, NetFn=%d, command=%d) command failed",
            p->lun, p->netfn, p->command);
    }
#line 680
    return (-1);
  }
#line 682
  if ((int )rsp->ccode > 0) {
    {
#line 683
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 683
    lprintf(3, "Get Configurable Command Sub-function (LUN=%d, NetFn=%d, command=%d) command failed: %s",
            p->lun, p->netfn, p->command, tmp);
    }
#line 685
    return (-1);
  }
  {
#line 688
  memcpy((void */* __restrict  */)(cmd->subfn_config), (void const   */* __restrict  */)(rsp->data),
         sizeof(cmd->subfn_config));
  }
#line 689
  return (0);
}
}
#line 701 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int _get_subfn_enables___0(struct ipmi_intf *intf , struct ipmi_function_params *p ,
                                  struct command_support *cmd ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char rqdata[4] ;
  char const   *tmp ;

  {
#line 709
  if (! p) {
    {
#line 710
    lprintf(3, "_get_subfn_enables: p or cmd is NULL");
    }
#line 711
    return (-1);
  } else
#line 709
  if (! cmd) {
    {
#line 710
    lprintf(3, "_get_subfn_enables: p or cmd is NULL");
    }
#line 711
    return (-1);
  }
  {
#line 714
  memset((void *)(& req), 0, sizeof(req));
#line 715
  req.msg.netfn = (uint8_t )6;
#line 716
  req.msg.cmd = (uint8_t )99;
#line 717
  rqdata[0] = (unsigned char )p->channel;
#line 718
  rqdata[1] = (unsigned char )p->netfn;
#line 719
  rqdata[2] = (unsigned char )p->lun;
#line 720
  rqdata[3] = (unsigned char )p->command;
#line 721
  req.msg.data = rqdata;
#line 722
  req.msg.data_len = (uint16_t )4;
#line 724
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 725
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 726
    lprintf(3, "Get Command Sub-function Enables (LUN=%d, NetFn=%d, command=%d) command failed",
            p->lun, p->netfn, p->command);
    }
#line 727
    return (-1);
  }
#line 729
  if ((int )rsp->ccode > 0) {
    {
#line 730
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 730
    lprintf(3, "Get Command Sub-function Enables (LUN=%d, NetFn=%d, command=%d) command failed: %s",
            p->lun, p->netfn, p->command, tmp);
    }
#line 732
    return (-1);
  }
  {
#line 735
  memcpy((void */* __restrict  */)(cmd->subfn_enable), (void const   */* __restrict  */)(rsp->data),
         sizeof(cmd->subfn_enable));
  }
#line 736
  return (0);
}
}
#line 749 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int _set_subfn_enables___0(struct ipmi_intf *intf , struct ipmi_function_params *p ,
                                  struct command_support *cmd , unsigned char *enable ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  unsigned char rqdata[8] ;
  unsigned int c ;
  char const   *tmp ;

  {
#line 759
  if (! p) {
    {
#line 760
    lprintf(3, "_set_subfn_enables: p or cmd is NULL");
    }
#line 761
    return (-1);
  } else
#line 759
  if (! cmd) {
    {
#line 760
    lprintf(3, "_set_subfn_enables: p or cmd is NULL");
    }
#line 761
    return (-1);
  }
  {
#line 764
  lprintf(6, "support:            ");
#line 765
  print_bitfield___0((unsigned char const   *)(cmd->subfn_support), 32 >> 3, 1, 6);
#line 766
  lprintf(6, "configurable:       ");
#line 767
  print_bitfield___0((unsigned char const   *)(cmd->subfn_config), 32 >> 3, 0, 6);
#line 768
  lprintf(6, "enabled:            ");
#line 769
  print_bitfield___0((unsigned char const   *)(cmd->subfn_enable), 32 >> 3, 0, 6);
#line 770
  lprintf(6, "enable mask before: ");
#line 771
  print_bitfield___0((unsigned char const   *)enable, 32 >> 3, 0, 6);
#line 774
  c = 0U;
  }
  {
#line 774
  while (1) {
    while_continue: /* CIL Label */ ;
#line 774
    if (! ((unsigned long )c < sizeof(cmd->subfn_enable))) {
#line 774
      goto while_break;
    }
#line 775
    *(enable + c) = (unsigned char )(((int )cmd->subfn_config[c] & (int )*(enable + c)) | (~ ((int )cmd->subfn_config[c]) & (int )cmd->subfn_enable[c]));
#line 774
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 778
  lprintf(6, "enable mask after: ");
#line 779
  print_bitfield___0((unsigned char const   *)enable, 32 >> 3, 0, 6);
#line 781
  memset((void *)(& req), 0, sizeof(req));
#line 782
  req.msg.netfn = (uint8_t )6;
#line 783
  req.msg.cmd = (uint8_t )98;
#line 784
  rqdata[0] = (unsigned char )p->channel;
#line 785
  rqdata[1] = (unsigned char )p->netfn;
#line 786
  rqdata[2] = (unsigned char )p->lun;
#line 787
  rqdata[3] = (unsigned char )p->command;
#line 788
  memcpy((void */* __restrict  */)(& rqdata[4]), (void const   */* __restrict  */)enable,
         (size_t )(32 >> 3));
#line 789
  req.msg.data = rqdata;
#line 790
  req.msg.data_len = (uint16_t )8;
#line 792
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 793
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 794
    lprintf(3, "Set Command Sub-function Enables (LUN=%d, NetFn=%d, command=%d) command failed",
            p->lun, p->netfn, p->command);
    }
#line 795
    return (-1);
  }
#line 797
  if ((int )rsp->ccode > 0) {
    {
#line 798
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 798
    lprintf(3, "Set Command Sub-function Enables (LUN=%d, NetFn=%d, command=%d) command failed: %s",
            p->lun, p->netfn, p->command, tmp);
    }
#line 800
    return (-1);
  }
#line 803
  return (0);
}
}
#line 816 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int _gather_info___0(struct ipmi_intf *intf , struct ipmi_function_params *p ,
                            struct bmc_fn_support *bmc ) 
{ 
  int ret ;
  int l ;
  int n ;
  unsigned char lun[4] ;
  unsigned char netfn[16] ;
  int offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 821
  ret = _get_netfn_support___0(intf, p->channel, lun, netfn);
  }
#line 822
  if (! ret) {
#line 823
    l = 0;
    {
#line 823
    while (1) {
      while_continue: /* CIL Label */ ;
#line 823
      if (! (l < 4)) {
#line 823
        goto while_break;
      }
#line 824
      if (p->lun >= 0) {
#line 824
        if (p->lun != l) {
#line 825
          goto __Cont;
        }
      }
#line 826
      bmc->lun[l].support = lun[l];
#line 827
      if (lun[l]) {
#line 828
        n = 0;
        {
#line 828
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 828
          if (! (n < 32)) {
#line 828
            goto while_break___0;
          }
#line 829
          offset = l * 32 + n;
#line 830
          bmc->lun[l].netfn[n].support = (unsigned char )(! (! ((int )netfn[offset >> 3] & (1 << offset % 8))));
#line 828
          n ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      __Cont: /* CIL Label */ 
#line 823
      l ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 836
  if (p->netfn >= 0) {
#line 837
    if (p->lun < 0) {
#line 837
      goto _L;
    } else
#line 837
    if (bmc->lun[p->lun].support) {
      _L: /* CIL Label */ 
#line 837
      if (! (p->netfn < 0)) {
#line 837
        if (! bmc->lun[p->lun].netfn[p->netfn >> 1].support) {
          {
#line 839
          lprintf(3, "LUN or LUN/NetFn pair %d,%d not supported", p->lun, p->netfn);
          }
#line 840
          return (0);
        }
      }
    } else {
      {
#line 839
      lprintf(3, "LUN or LUN/NetFn pair %d,%d not supported", p->lun, p->netfn);
      }
#line 840
      return (0);
    }
    {
#line 842
    ret = _get_command_support___0(intf, p, & bmc->lun[p->lun].netfn[p->netfn >> 1]);
#line 843
    tmp = _get_command_configurable___0(intf, p, & bmc->lun[p->lun].netfn[p->netfn >> 1]);
#line 843
    ret |= tmp;
#line 844
    tmp___0 = _get_command_enables___0(intf, p, & bmc->lun[p->lun].netfn[p->netfn >> 1]);
#line 844
    ret |= tmp___0;
    }
#line 845
    if (! ret) {
#line 845
      if (p->command >= 0) {
        {
#line 846
        ret = _get_subfn_support___0(intf, p, & bmc->lun[p->lun].netfn[p->netfn >> 1].command[p->command]);
#line 848
        tmp___1 = _get_subfn_configurable___0(intf, p, & bmc->lun[p->lun].netfn[p->netfn >> 1].command[p->command]);
#line 848
        ret |= tmp___1;
#line 850
        tmp___2 = _get_subfn_enables___0(intf, p, & bmc->lun[p->lun].netfn[p->netfn >> 1].command[p->command]);
#line 850
        ret |= tmp___2;
        }
      }
    }
  } else
#line 854
  if (p->lun >= 0) {
#line 855
    l = p->lun;
#line 856
    if (bmc->lun[l].support) {
#line 857
      n = 0;
      {
#line 857
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 857
        if (! (n < 32)) {
#line 857
          goto while_break___1;
        }
#line 858
        p->netfn = n * 2;
#line 859
        if (bmc->lun[l].netfn[n].support) {
          {
#line 860
          ret = _get_command_support___0(intf, p, & bmc->lun[l].netfn[n]);
#line 861
          tmp___3 = _get_command_configurable___0(intf, p, & bmc->lun[l].netfn[n]);
#line 861
          ret |= tmp___3;
#line 862
          tmp___4 = _get_command_enables___0(intf, p, & bmc->lun[l].netfn[n]);
#line 862
          ret |= tmp___4;
          }
        }
#line 864
        if (ret) {
#line 865
          bmc->lun[l].netfn[n].support = (unsigned char)0;
        }
#line 857
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 868
    p->netfn = -1;
  } else {
#line 870
    l = 0;
    {
#line 870
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 870
      if (! (l < 4)) {
#line 870
        goto while_break___2;
      }
#line 871
      p->lun = l;
#line 872
      if (bmc->lun[l].support) {
#line 873
        n = 0;
        {
#line 873
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 873
          if (! (n < 32)) {
#line 873
            goto while_break___3;
          }
#line 874
          p->netfn = n * 2;
#line 875
          if (bmc->lun[l].netfn[n].support) {
            {
#line 876
            ret = _get_command_support___0(intf, p, & bmc->lun[l].netfn[n]);
#line 877
            tmp___5 = _get_command_configurable___0(intf, p, & bmc->lun[l].netfn[n]);
#line 877
            ret |= tmp___5;
#line 878
            tmp___6 = _get_command_enables___0(intf, p, & bmc->lun[l].netfn[n]);
#line 878
            ret |= tmp___6;
            }
          }
#line 880
          if (ret) {
#line 881
            bmc->lun[l].netfn[n].support = (unsigned char)0;
          }
#line 873
          n ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 870
      l ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 885
    p->lun = -1;
#line 886
    p->netfn = -1;
  }
#line 889
  return (0);
}
}
#line 901 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int ipmi_firewall_info___0(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int ret ;
  struct ipmi_function_params p ;
  struct bmc_fn_support *bmc_fn_support ;
  unsigned int l ;
  unsigned int n ;
  unsigned int c ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  struct command_support *cmd ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 904
  ret = 0;
#line 905
  p.channel = 14;
#line 905
  p.lun = -1;
#line 905
  p.netfn = -1;
#line 905
  p.command = -1;
#line 905
  p.subfn = -1;
#line 905
  p.force = (unsigned char)0;
#line 909
  if (argc > 0) {
    {
#line 909
    tmp = strncmp((char const   *)*(argv + 0), "help", (size_t )4);
    }
#line 909
    if (tmp == 0) {
      {
#line 911
      printf_firewall_info_usage();
      }
#line 912
      return (0);
    } else {
#line 909
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 909
    tmp___0 = ipmi_firewall_parse_args___0(argc, argv, & p);
    }
#line 909
    if (tmp___0 < 0) {
      {
#line 911
      printf_firewall_info_usage();
      }
#line 912
      return (0);
    }
  }
  {
#line 915
  tmp___1 = malloc(sizeof(struct bmc_fn_support ));
#line 915
  bmc_fn_support = (struct bmc_fn_support *)tmp___1;
  }
#line 916
  if (! bmc_fn_support) {
    {
#line 917
    lprintf(3, "malloc struct bmc_fn_support failed");
    }
#line 918
    return (-1);
  }
  {
#line 921
  ret = _gather_info___0(intf, & p, bmc_fn_support);
  }
#line 923
  if (p.command >= 0) {
#line 925
    if (p.lun < 0) {
#line 925
      goto _L___1;
    } else
#line 925
    if (bmc_fn_support->lun[p.lun].support) {
      _L___1: /* CIL Label */ 
#line 925
      if (p.netfn < 0) {
#line 925
        goto _L___0;
      } else
#line 925
      if (bmc_fn_support->lun[p.lun].netfn[p.netfn >> 1].support) {
        _L___0: /* CIL Label */ 
#line 925
        if (! bmc_fn_support->lun[p.lun].netfn[p.netfn >> 1].command[p.command].support) {
          {
#line 929
          lprintf(3, "Command 0x%02x not supported on LUN/NetFn pair %02x,%02x", p.command,
                  p.lun, p.netfn);
#line 931
          free((void *)bmc_fn_support);
#line 932
          bmc_fn_support = (struct bmc_fn_support *)((void *)0);
          }
#line 933
          return (0);
        }
      } else {
        {
#line 929
        lprintf(3, "Command 0x%02x not supported on LUN/NetFn pair %02x,%02x", p.command,
                p.lun, p.netfn);
#line 931
        free((void *)bmc_fn_support);
#line 932
        bmc_fn_support = (struct bmc_fn_support *)((void *)0);
        }
#line 933
        return (0);
      }
    } else {
      {
#line 929
      lprintf(3, "Command 0x%02x not supported on LUN/NetFn pair %02x,%02x", p.command,
              p.lun, p.netfn);
#line 931
      free((void *)bmc_fn_support);
#line 932
      bmc_fn_support = (struct bmc_fn_support *)((void *)0);
      }
#line 933
      return (0);
    }
    {
#line 935
    cmd = & bmc_fn_support->lun[p.lun].netfn[p.netfn >> 1].command[p.command];
#line 937
    c = (unsigned int )cmd->support;
#line 938
    printf((char const   */* __restrict  */)"(A)vailable, (C)onfigurable, (E)nabled: | A | C | E |\n");
#line 939
    printf((char const   */* __restrict  */)"-----------------------------------------------------\n");
    }
#line 940
    if (c & 4U) {
#line 940
      tmp___2 = 'X';
    } else {
#line 940
      tmp___2 = ' ';
    }
#line 940
    if (c & 2U) {
#line 940
      tmp___3 = 'X';
    } else {
#line 940
      tmp___3 = ' ';
    }
#line 940
    if (c & 1U) {
#line 940
      tmp___4 = 'X';
    } else {
#line 940
      tmp___4 = ' ';
    }
    {
#line 940
    printf((char const   */* __restrict  */)"LUN %01d, NetFn 0x%02x, Command 0x%02x:        | %c | %c | %c |\n",
           p.lun, p.netfn, p.command, tmp___4, tmp___3, tmp___2);
#line 946
    n = 0U;
    }
    {
#line 946
    while (1) {
      while_continue: /* CIL Label */ ;
#line 946
      if (! (n < 32U)) {
#line 946
        goto while_break;
      }
      {
#line 947
      tmp___7 = bit_test((unsigned char const   *)(cmd->subfn_enable), (int )n);
      }
#line 947
      if (tmp___7) {
#line 947
        tmp___6 = 'X';
      } else {
#line 947
        tmp___6 = ' ';
      }
      {
#line 947
      tmp___10 = bit_test((unsigned char const   *)(cmd->subfn_config), (int )n);
      }
#line 947
      if (tmp___10) {
#line 947
        tmp___9 = 'X';
      } else {
#line 947
        tmp___9 = ' ';
      }
      {
#line 947
      tmp___13 = bit_test((unsigned char const   *)(cmd->subfn_support), (int )n);
      }
#line 947
      if (tmp___13) {
#line 947
        tmp___12 = ' ';
      } else {
#line 947
        tmp___12 = 'X';
      }
      {
#line 947
      printf((char const   */* __restrict  */)"sub-function 0x%02x:                      | %c | %c | %c |\n",
             n, tmp___12, tmp___9, tmp___6);
#line 946
      n ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 953
  if (p.netfn >= 0) {
#line 954
    if (p.lun < 0) {
#line 954
      goto _L___2;
    } else
#line 954
    if (bmc_fn_support->lun[p.lun].support) {
      _L___2: /* CIL Label */ 
#line 954
      if (! bmc_fn_support->lun[p.lun].netfn[p.netfn >> 1].support) {
        {
#line 957
        lprintf(3, "LUN or LUN/NetFn pair %02x,%02x not supported", p.lun, p.netfn);
#line 959
        free((void *)bmc_fn_support);
#line 960
        bmc_fn_support = (struct bmc_fn_support *)((void *)0);
        }
#line 961
        return (0);
      }
    } else {
      {
#line 957
      lprintf(3, "LUN or LUN/NetFn pair %02x,%02x not supported", p.lun, p.netfn);
#line 959
      free((void *)bmc_fn_support);
#line 960
      bmc_fn_support = (struct bmc_fn_support *)((void *)0);
      }
#line 961
      return (0);
    }
    {
#line 963
    n = (unsigned int )(p.netfn >> 1);
#line 964
    l = (unsigned int )p.lun;
#line 965
    printf((char const   */* __restrict  */)"Commands on LUN 0x%02x, NetFn 0x%02x\n",
           p.lun, p.netfn);
#line 966
    printf((char const   */* __restrict  */)"support:      ");
#line 967
    print_bitfield___0((unsigned char const   *)(bmc_fn_support->lun[l].netfn[n].command_mask),
                       256 >> 3, 1, -1);
#line 969
    printf((char const   */* __restrict  */)"configurable: ");
#line 970
    print_bitfield___0((unsigned char const   *)(bmc_fn_support->lun[l].netfn[n].config_mask),
                       256 >> 3, 0, -1);
#line 972
    printf((char const   */* __restrict  */)"enabled:      ");
#line 973
    print_bitfield___0((unsigned char const   *)(bmc_fn_support->lun[l].netfn[n].enable_mask),
                       256 >> 3, 0, -1);
    }
  } else {
#line 977
    l = 0U;
    {
#line 977
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 977
      if (! (l < 4U)) {
#line 977
        goto while_break___0;
      }
#line 978
      p.lun = (int )l;
#line 979
      if (bmc_fn_support->lun[l].support) {
#line 980
        n = 0U;
        {
#line 980
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 980
          if (! (n < 32U)) {
#line 980
            goto while_break___1;
          }
#line 981
          p.netfn = (int )(n * 2U);
#line 982
          if (bmc_fn_support->lun[l].netfn[n].support) {
            {
#line 983
            printf((char const   */* __restrict  */)"%02x,%02x support:      ", p.lun,
                   p.netfn);
#line 984
            print_bitfield___0((unsigned char const   *)(bmc_fn_support->lun[l].netfn[n].command_mask),
                               256 >> 3, 1, -1);
#line 986
            printf((char const   */* __restrict  */)"%02x,%02x configurable: ", p.lun,
                   p.netfn);
#line 987
            print_bitfield___0((unsigned char const   *)(bmc_fn_support->lun[l].netfn[n].config_mask),
                               256 >> 3, 0, -1);
#line 989
            printf((char const   */* __restrict  */)"%02x,%02x enabled:      ", p.lun,
                   p.netfn);
#line 990
            print_bitfield___0((unsigned char const   *)(bmc_fn_support->lun[l].netfn[n].enable_mask),
                               256 >> 3, 0, -1);
            }
          }
#line 980
          n ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 977
      l ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 996
    p.lun = -1;
#line 997
    p.netfn = -1;
  }
  {
#line 1000
  free((void *)bmc_fn_support);
#line 1001
  bmc_fn_support = (struct bmc_fn_support *)((void *)0);
  }
#line 1002
  return (ret);
}
}
#line 1015 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int ipmi_firewall_enable_disable___0(struct ipmi_intf *intf , int enable ,
                                            int argc , char **argv ) 
{ 
  struct ipmi_function_params p ;
  struct bmc_fn_support *bmc_fn_support ;
  unsigned int l ;
  unsigned int n ;
  unsigned int c ;
  unsigned int ret ;
  unsigned char enables[256 >> 3] ;
  char *s1 ;
  char const   *tmp ;
  char *s2 ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1018
  p.channel = 14;
#line 1018
  p.lun = -1;
#line 1018
  p.netfn = -1;
#line 1018
  p.command = -1;
#line 1018
  p.subfn = -1;
#line 1018
  p.force = (unsigned char)0;
#line 1023
  if (argc < 1) {
#line 1023
    goto _L;
  } else {
    {
#line 1023
    tmp___1 = strncmp((char const   *)*(argv + 0), "help", (size_t )4);
    }
#line 1023
    if (tmp___1 == 0) {
      _L: /* CIL Label */ 
#line 1024
      if (enable) {
#line 1024
        tmp = "en";
      } else {
#line 1024
        tmp = "dis";
      }
#line 1024
      s1 = (char *)tmp;
#line 1025
      if (enable) {
#line 1025
        tmp___0 = "";
      } else {
#line 1025
        tmp___0 = " [force]";
      }
      {
#line 1025
      s2 = (char *)tmp___0;
#line 1026
      printf((char const   */* __restrict  */)"%sable [channel H] lun L netfn N%s\n",
             s1, s2);
#line 1027
      printf((char const   */* __restrict  */)"\t%sable all commands on this LUN/NetFn pair\n",
             s1);
#line 1028
      printf((char const   */* __restrict  */)"%sable [channel H] lun L netfn N command C%s\n",
             s1, s2);
#line 1029
      printf((char const   */* __restrict  */)"\t%sable Command C and all its Sub-functions for this LUN/NetFn pair\n",
             s1);
#line 1030
      printf((char const   */* __restrict  */)"%sable [channel H] lun L netfn N command C subfn S\n",
             s1);
#line 1031
      printf((char const   */* __restrict  */)"\t%sable Sub-function S for Command C for this LUN/NetFn pair\n",
             s1);
      }
#line 1032
      if (! enable) {
        {
#line 1033
        printf((char const   */* __restrict  */)"* force will allow you to disable the \"Command Set Enable\" command\n");
#line 1034
        printf((char const   */* __restrict  */)"\tthereby letting you shoot yourself in the foot\n");
#line 1035
        printf((char const   */* __restrict  */)"\tthis is only recommended for advanced users\n");
        }
      }
#line 1037
      return (0);
    }
  }
  {
#line 1039
  tmp___2 = ipmi_firewall_parse_args___0(argc, argv, & p);
  }
#line 1039
  if (tmp___2 < 0) {
#line 1040
    return (-1);
  }
  {
#line 1042
  tmp___3 = malloc(sizeof(struct bmc_fn_support ));
#line 1042
  bmc_fn_support = (struct bmc_fn_support *)tmp___3;
  }
#line 1043
  if (! bmc_fn_support) {
    {
#line 1044
    lprintf(3, "malloc struct bmc_fn_support failed");
    }
#line 1045
    return (-1);
  }
  {
#line 1048
  tmp___4 = _gather_info___0(intf, & p, bmc_fn_support);
#line 1048
  ret = (unsigned int )tmp___4;
  }
#line 1049
  if (ret < 0U) {
    {
#line 1050
    free((void *)bmc_fn_support);
#line 1051
    bmc_fn_support = (struct bmc_fn_support *)((void *)0);
    }
#line 1052
    return ((int )ret);
  }
#line 1055
  l = (unsigned int )p.lun;
#line 1056
  n = (unsigned int )(p.netfn >> 1);
#line 1057
  c = (unsigned int )p.command;
#line 1058
  if (p.subfn >= 0) {
    {
#line 1061
    memcpy((void */* __restrict  */)(enables), (void const   */* __restrict  */)(bmc_fn_support->lun[l].netfn[n].command[c].subfn_enable),
           (size_t )(32 >> 3));
#line 1064
    bit_set(enables, p.subfn, enable);
#line 1065
    tmp___5 = _set_subfn_enables___0(intf, & p, & bmc_fn_support->lun[l].netfn[n].command[c],
                                     enables);
#line 1065
    ret = (unsigned int )tmp___5;
    }
  } else
#line 1068
  if (p.command >= 0) {
#line 1071
    if (enable) {
#line 1071
      tmp___6 = 255;
    } else {
#line 1071
      tmp___6 = 0;
    }
    {
#line 1071
    memset((void *)(enables), tmp___6, (size_t )(32 >> 3));
#line 1072
    tmp___7 = _set_subfn_enables___0(intf, & p, & bmc_fn_support->lun[l].netfn[n].command[c],
                                     enables);
#line 1072
    ret = (unsigned int )tmp___7;
#line 1074
    memcpy((void */* __restrict  */)(enables), (void const   */* __restrict  */)(& bmc_fn_support->lun[l].netfn[n].enable_mask),
           sizeof(enables));
#line 1076
    bit_set(enables, p.command, enable);
#line 1077
    tmp___8 = _set_command_enables___0(intf, & p, & bmc_fn_support->lun[l].netfn[n],
                                       enables, (int )p.force);
#line 1077
    ret |= (unsigned int )tmp___8;
    }
  } else
#line 1079
  if (p.netfn >= 0) {
#line 1082
    if (enable) {
#line 1082
      tmp___9 = 255;
    } else {
#line 1082
      tmp___9 = 0;
    }
    {
#line 1082
    memset((void *)(enables), tmp___9, sizeof(enables));
#line 1083
    tmp___10 = _set_command_enables___0(intf, & p, & bmc_fn_support->lun[l].netfn[n],
                                        enables, (int )p.force);
#line 1083
    ret = (unsigned int )tmp___10;
    }
  }
  {
#line 1091
  free((void *)bmc_fn_support);
#line 1092
  bmc_fn_support = (struct bmc_fn_support *)((void *)0);
  }
#line 1093
  return ((int )ret);
}
}
#line 1105 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_firewall.c"
static int ipmi_firewall_reset___0(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  struct ipmi_function_params p ;
  struct bmc_fn_support *bmc_fn_support ;
  unsigned int l ;
  unsigned int n ;
  unsigned int c ;
  unsigned int ret ;
  unsigned char enables[256 >> 3] ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1108
  p.channel = 14;
#line 1108
  p.lun = -1;
#line 1108
  p.netfn = -1;
#line 1108
  p.command = -1;
#line 1108
  p.subfn = -1;
#line 1108
  p.force = (unsigned char)0;
#line 1113
  if (argc > 0) {
    {
#line 1114
    printf_firewall_usage___0();
    }
#line 1115
    return (0);
  } else
#line 1113
  if (argc > 0) {
    {
#line 1113
    tmp = strncmp((char const   *)*(argv + 0), "help", (size_t )4);
    }
#line 1113
    if (tmp == 0) {
      {
#line 1114
      printf_firewall_usage___0();
      }
#line 1115
      return (0);
    }
  }
  {
#line 1117
  tmp___0 = ipmi_firewall_parse_args___0(argc, argv, & p);
  }
#line 1117
  if (tmp___0 < 0) {
#line 1118
    return (-1);
  }
  {
#line 1120
  tmp___1 = malloc(sizeof(struct bmc_fn_support ));
#line 1120
  bmc_fn_support = (struct bmc_fn_support *)tmp___1;
  }
#line 1121
  if (! bmc_fn_support) {
    {
#line 1122
    lprintf(3, "malloc struct bmc_fn_support failed");
    }
#line 1123
    return (-1);
  }
  {
#line 1126
  tmp___2 = _gather_info___0(intf, & p, bmc_fn_support);
#line 1126
  ret = (unsigned int )tmp___2;
  }
#line 1127
  if (ret < 0U) {
    {
#line 1128
    free((void *)bmc_fn_support);
#line 1129
    bmc_fn_support = (struct bmc_fn_support *)((void *)0);
    }
#line 1130
    return ((int )ret);
  }
#line 1133
  l = 0U;
  {
#line 1133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1133
    if (! (l < 4U)) {
#line 1133
      goto while_break;
    }
#line 1134
    p.lun = (int )l;
#line 1135
    n = 0U;
    {
#line 1135
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1135
      if (! (n < 64U)) {
#line 1135
        goto while_break___0;
      }
#line 1136
      p.netfn = (int )n;
#line 1137
      c = 0U;
      {
#line 1137
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1137
        if (! (c < 256U)) {
#line 1137
          goto while_break___1;
        }
        {
#line 1138
        p.command = (int )c;
#line 1139
        printf((char const   */* __restrict  */)"reset lun %d, netfn %d, command %d, subfn\n",
               l, n, c);
#line 1140
        memset((void *)(enables), 255, (size_t )(32 >> 3));
#line 1141
        tmp___3 = _set_subfn_enables___0(intf, & p, & bmc_fn_support->lun[l].netfn[n].command[c],
                                         enables);
#line 1141
        ret = (unsigned int )tmp___3;
#line 1137
        c ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1144
      printf((char const   */* __restrict  */)"reset lun %d, netfn %d, command\n",
             l, n);
#line 1145
      memset((void *)(enables), 255, sizeof(enables));
#line 1146
      tmp___4 = _set_command_enables___0(intf, & p, & bmc_fn_support->lun[l].netfn[n],
                                         enables, 0);
#line 1146
      ret = (unsigned int )tmp___4;
#line 1135
      n += 2U;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1133
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1151
  free((void *)bmc_fn_support);
#line 1152
  bmc_fn_support = (struct bmc_fn_support *)((void *)0);
  }
#line 1153
  return ((int )ret);
}
}
#line 227 "../include/ipmitool/ipmi_sel.h"
static struct ipmi_event_sensor_types generic_event_types___0[58]  __attribute__((__unused__))  = 
#line 227 "../include/ipmitool/ipmi_sel.h"
  {      {(uint8_t )1, (uint8_t )0, (uint8_t )255, (uint8_t )2, "Threshold", "Lower Non-critical going low "}, 
        {(uint8_t )1,
      (uint8_t )1, (uint8_t )255, (uint8_t )2, "Threshold", "Lower Non-critical going high"}, 
        {(uint8_t )1,
      (uint8_t )2, (uint8_t )255, (uint8_t )2, "Threshold", "Lower Critical going low "}, 
        {(uint8_t )1,
      (uint8_t )3, (uint8_t )255, (uint8_t )2, "Threshold", "Lower Critical going high"}, 
        {(uint8_t )1,
      (uint8_t )4, (uint8_t )255, (uint8_t )2, "Threshold", "Lower Non-recoverable going low "}, 
        {(uint8_t )1,
      (uint8_t )5, (uint8_t )255, (uint8_t )2, "Threshold", "Lower Non-recoverable going high"}, 
        {(uint8_t )1,
      (uint8_t )6, (uint8_t )255, (uint8_t )2, "Threshold", "Upper Non-critical going low "}, 
        {(uint8_t )1,
      (uint8_t )7, (uint8_t )255, (uint8_t )2, "Threshold", "Upper Non-critical going high"}, 
        {(uint8_t )1,
      (uint8_t )8, (uint8_t )255, (uint8_t )2, "Threshold", "Upper Critical going low "}, 
        {(uint8_t )1,
      (uint8_t )9, (uint8_t )255, (uint8_t )2, "Threshold", "Upper Critical going high"}, 
        {(uint8_t )1,
      (uint8_t )10, (uint8_t )255, (uint8_t )2, "Threshold", "Upper Non-recoverable going low "}, 
        {(uint8_t )1,
      (uint8_t )11, (uint8_t )255, (uint8_t )2, "Threshold", "Upper Non-recoverable going high"}, 
        {(uint8_t )2,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Usage State", "Transition to Idle"}, 
        {(uint8_t )2,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Usage State", "Transition to Active"}, 
        {(uint8_t )2,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Usage State", "Transition to Busy"}, 
        {(uint8_t )3,
      (uint8_t )0, (uint8_t )255, (uint8_t )1, "Digital State", "State Deasserted"}, 
        {(uint8_t )3,
      (uint8_t )1, (uint8_t )255, (uint8_t )1, "Digital State", "State Asserted"}, 
        {(uint8_t )4,
      (uint8_t )0, (uint8_t )255, (uint8_t )1, "Digital State", "Predictive Failure Deasserted"}, 
        {(uint8_t )4,
      (uint8_t )1, (uint8_t )255, (uint8_t )1, "Digital State", "Predictive Failure Asserted"}, 
        {(uint8_t )5,
      (uint8_t )0, (uint8_t )255, (uint8_t )1, "Digital State", "Limit Not Exceeded"}, 
        {(uint8_t )5,
      (uint8_t )1, (uint8_t )255, (uint8_t )1, "Digital State", "Limit Exceeded"}, 
        {(uint8_t )6,
      (uint8_t )0, (uint8_t )255, (uint8_t )1, "Digital State", "Performance Met"}, 
        {(uint8_t )6,
      (uint8_t )1, (uint8_t )255, (uint8_t )1, "Digital State", "Performance Lags"}, 
        {(uint8_t )7,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Severity State", "Transition to OK"}, 
        {(uint8_t )7,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Severity State", "Transition to Non-critical from OK"}, 
        {(uint8_t )7,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Severity State", "Transition to Critical from less severe"}, 
        {(uint8_t )7,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Severity State", "Transition to Non-recoverable from less severe"}, 
        {(uint8_t )7,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Severity State", "Transition to Non-critical from more severe"}, 
        {(uint8_t )7,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Severity State", "Transition to Critical from Non-recoverable"}, 
        {(uint8_t )7,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "Severity State", "Transition to Non-recoverable"}, 
        {(uint8_t )7,
      (uint8_t )7, (uint8_t )255, (uint8_t )0, "Severity State", "Monitor"}, 
        {(uint8_t )7, (uint8_t )8, (uint8_t )255, (uint8_t )0, "Severity State", "Informational"}, 
        {(uint8_t )8,
      (uint8_t )0, (uint8_t )255, (uint8_t )1, "Availability State", "Device Absent"}, 
        {(uint8_t )8,
      (uint8_t )1, (uint8_t )255, (uint8_t )1, "Availability State", "Device Present"}, 
        {(uint8_t )9,
      (uint8_t )0, (uint8_t )255, (uint8_t )1, "Availability State", "Device Disabled"}, 
        {(uint8_t )9,
      (uint8_t )1, (uint8_t )255, (uint8_t )1, "Availability State", "Device Enabled"}, 
        {(uint8_t )10,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Availability State", "Transition to Running"}, 
        {(uint8_t )10,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Availability State", "Transition to In Test"}, 
        {(uint8_t )10,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Availability State", "Transition to Power Off"}, 
        {(uint8_t )10,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Availability State", "Transition to On Line"}, 
        {(uint8_t )10,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Availability State", "Transition to Off Line"}, 
        {(uint8_t )10,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Availability State", "Transition to Off Duty"}, 
        {(uint8_t )10,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "Availability State", "Transition to Degraded"}, 
        {(uint8_t )10,
      (uint8_t )7, (uint8_t )255, (uint8_t )0, "Availability State", "Transition to Power Save"}, 
        {(uint8_t )10,
      (uint8_t )8, (uint8_t )255, (uint8_t )0, "Availability State", "Install Error"}, 
        {(uint8_t )11,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Redundancy State", "Fully Redundant"}, 
        {(uint8_t )11,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Redundancy State", "Redundancy Lost"}, 
        {(uint8_t )11,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Redundancy State", "Redundancy Degraded"}, 
        {(uint8_t )11,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Redundancy State", "Non-Redundant: Sufficient from Redundant"}, 
        {(uint8_t )11,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Redundancy State", "Non-Redundant: Sufficient from Insufficient"}, 
        {(uint8_t )11,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Redundancy State", "Non-Redundant: Insufficient Resources"}, 
        {(uint8_t )11,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "Redundancy State", "Redundancy Degraded from Fully Redundant"}, 
        {(uint8_t )11,
      (uint8_t )7, (uint8_t )255, (uint8_t )0, "Redundancy State", "Redundancy Degraded from Non-Redundant"}, 
        {(uint8_t )12,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "ACPI Device Power State", "D0 Power State"}, 
        {(uint8_t )12,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "ACPI Device Power State", "D1 Power State"}, 
        {(uint8_t )12,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "ACPI Device Power State", "D2 Power State"}, 
        {(uint8_t )12,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "ACPI Device Power State", "D3 Power State"}, 
        {(uint8_t )0,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 296 "../include/ipmitool/ipmi_sel.h"
static struct ipmi_event_sensor_types sensor_specific_types___0[340]  __attribute__((__unused__))  = 
#line 296
  {      {(uint8_t )0, (uint8_t )0, (uint8_t )255, (uint8_t )0, "Reserved", (char const   *)((void *)0)}, 
        {(uint8_t )1,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Temperature", (char const   *)((void *)0)}, 
        {(uint8_t )2,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Voltage", (char const   *)((void *)0)}, 
        {(uint8_t )3,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Current", (char const   *)((void *)0)}, 
        {(uint8_t )4,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Fan", (char const   *)((void *)0)}, 
        {(uint8_t )5,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Physical Security", "General Chassis intrusion"}, 
        {(uint8_t )5,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Physical Security", "Drive Bay intrusion"}, 
        {(uint8_t )5,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Physical Security", "I/O Card area intrusion"}, 
        {(uint8_t )5,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Physical Security", "Processor area intrusion"}, 
        {(uint8_t )5,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Physical Security", "System unplugged from LAN"}, 
        {(uint8_t )5,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Physical Security", "Unauthorized dock"}, 
        {(uint8_t )5,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "Physical Security", "FAN area intrusion"}, 
        {(uint8_t )6,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Platform Security", "Front Panel Lockout violation attempted"}, 
        {(uint8_t )6,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Platform Security", "Pre-boot password violation - user password"}, 
        {(uint8_t )6,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Platform Security", "Pre-boot password violation - setup password"}, 
        {(uint8_t )6,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Platform Security", "Pre-boot password violation - network boot password"}, 
        {(uint8_t )6,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Platform Security", "Other pre-boot password violation"}, 
        {(uint8_t )6,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Platform Security", "Out-of-band access password violation"}, 
        {(uint8_t )7,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Processor", "IERR"}, 
        {(uint8_t )7, (uint8_t )1, (uint8_t )255, (uint8_t )0, "Processor", "Thermal Trip"}, 
        {(uint8_t )7,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Processor", "FRB1/BIST failure"}, 
        {(uint8_t )7, (uint8_t )3, (uint8_t )255, (uint8_t )0, "Processor", "FRB2/Hang in POST failure"}, 
        {(uint8_t )7,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Processor", "FRB3/Processor startup/init failure"}, 
        {(uint8_t )7,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Processor", "Configuration Error"}, 
        {(uint8_t )7,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "Processor", "SM BIOS Uncorrectable CPU-complex Error"}, 
        {(uint8_t )7,
      (uint8_t )7, (uint8_t )255, (uint8_t )0, "Processor", "Presence detected"}, 
        {(uint8_t )7, (uint8_t )8, (uint8_t )255, (uint8_t )0, "Processor", "Disabled"}, 
        {(uint8_t )7,
      (uint8_t )9, (uint8_t )255, (uint8_t )0, "Processor", "Terminator presence detected"}, 
        {(uint8_t )7,
      (uint8_t )10, (uint8_t )255, (uint8_t )0, "Processor", "Throttled"}, 
        {(uint8_t )8, (uint8_t )0, (uint8_t )255, (uint8_t )0, "Power Supply", "Presence detected"}, 
        {(uint8_t )8,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Power Supply", "Failure detected"}, 
        {(uint8_t )8,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Power Supply", "Predictive failure"}, 
        {(uint8_t )8,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Power Supply", "Power Supply AC lost"}, 
        {(uint8_t )8,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Power Supply", "AC lost or out-of-range"}, 
        {(uint8_t )8,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Power Supply", "AC out-of-range, but present"}, 
        {(uint8_t )8,
      (uint8_t )6, (uint8_t )0, (uint8_t )0, "Power Supply", "Config Error: Vendor Mismatch"}, 
        {(uint8_t )8,
      (uint8_t )6, (uint8_t )1, (uint8_t )0, "Power Supply", "Config Error: Revision Mismatch"}, 
        {(uint8_t )8,
      (uint8_t )6, (uint8_t )2, (uint8_t )0, "Power Supply", "Config Error: Processor Missing"}, 
        {(uint8_t )8,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "Power Supply", "Config Error"}, 
        {(uint8_t )9, (uint8_t )0, (uint8_t )255, (uint8_t )0, "Power Unit", "Power off/down"}, 
        {(uint8_t )9,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Power Unit", "Power cycle"}, 
        {(uint8_t )9, (uint8_t )2, (uint8_t )255, (uint8_t )0, "Power Unit", "240VA power down"}, 
        {(uint8_t )9,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Power Unit", "Interlock power down"}, 
        {(uint8_t )9,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Power Unit", "AC lost"}, 
        {(uint8_t )9, (uint8_t )5, (uint8_t )255, (uint8_t )0, "Power Unit", "Soft-power control failure"}, 
        {(uint8_t )9,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "Power Unit", "Failure detected"}, 
        {(uint8_t )9, (uint8_t )7, (uint8_t )255, (uint8_t )0, "Power Unit", "Predictive failure"}, 
        {(uint8_t )10,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Cooling Device", (char const   *)((void *)0)}, 
        {(uint8_t )11,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Other Units-based Sensor", (char const   *)((void *)0)}, 
        {(uint8_t )12,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Memory", "Correctable ECC"}, 
        {(uint8_t )12, (uint8_t )1, (uint8_t )255, (uint8_t )0, "Memory", "Uncorrectable ECC"}, 
        {(uint8_t )12,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Memory", "Parity"}, 
        {(uint8_t )12, (uint8_t )3, (uint8_t )255, (uint8_t )0, "Memory", "Memory Scrub Failed"}, 
        {(uint8_t )12,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Memory", "Memory Device Disabled"}, 
        {(uint8_t )12,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Memory", "Correctable ECC logging limit reached"}, 
        {(uint8_t )12,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "Memory", "Presence Detected"}, 
        {(uint8_t )12, (uint8_t )7, (uint8_t )255, (uint8_t )0, "Memory", "Configuration Error"}, 
        {(uint8_t )12,
      (uint8_t )8, (uint8_t )255, (uint8_t )0, "Memory", "Spare"}, 
        {(uint8_t )12, (uint8_t )9, (uint8_t )255, (uint8_t )0, "Memory", "Throttled"}, 
        {(uint8_t )13,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Drive Slot", "Drive Present"}, 
        {(uint8_t )13, (uint8_t )1, (uint8_t )255, (uint8_t )0, "Drive Slot", "Drive Fault"}, 
        {(uint8_t )13,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Drive Slot", "Predictive Failure"}, 
        {(uint8_t )13,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Drive Slot", "Hot Spare"}, 
        {(uint8_t )13, (uint8_t )4, (uint8_t )255, (uint8_t )0, "Drive Slot", "Parity Check In Progress"}, 
        {(uint8_t )13,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Drive Slot", "In Critical Array"}, 
        {(uint8_t )13,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "Drive Slot", "In Failed Array"}, 
        {(uint8_t )13, (uint8_t )7, (uint8_t )255, (uint8_t )0, "Drive Slot", "Rebuild In Progress"}, 
        {(uint8_t )13,
      (uint8_t )8, (uint8_t )255, (uint8_t )0, "Drive Slot", "Rebuild Aborted"}, 
        {(uint8_t )14, (uint8_t )0, (uint8_t )255, (uint8_t )0, "POST Memory Resize",
      (char const   *)((void *)0)}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )0, (uint8_t )0, "System Firmware Error",
      "Unspecified"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )1, (uint8_t )0, "System Firmware Error",
      "No system memory installed"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )2, (uint8_t )0, "System Firmware Error",
      "No usable system memory"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )3, (uint8_t )0, "System Firmware Error",
      "Unrecoverable IDE device failure"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )4, (uint8_t )0, "System Firmware Error",
      "Unrecoverable system-board failure"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )5, (uint8_t )0, "System Firmware Error",
      "Unrecoverable diskette failure"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )6, (uint8_t )0, "System Firmware Error",
      "Unrecoverable hard-disk controller failure"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )7, (uint8_t )0, "System Firmware Error",
      "Unrecoverable PS/2 or USB keyboard failure"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )8, (uint8_t )0, "System Firmware Error",
      "Removable boot media not found"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )9, (uint8_t )0, "System Firmware Error",
      "Unrecoverable video controller failure"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )10, (uint8_t )0, "System Firmware Error",
      "No video device selected"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )11, (uint8_t )0, "System Firmware Error",
      "BIOS corruption detected"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )12, (uint8_t )0, "System Firmware Error",
      "CPU voltage mismatch"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )13, (uint8_t )0, "System Firmware Error",
      "CPU speed mismatch failure"}, 
        {(uint8_t )15, (uint8_t )0, (uint8_t )255, (uint8_t )0, "System Firmware Error",
      "Unknown Error"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )0, (uint8_t )0, "System Firmware Hang",
      "Unspecified"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )1, (uint8_t )0, "System Firmware Hang",
      "Memory initialization"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )2, (uint8_t )0, "System Firmware Hang",
      "Hard-disk initialization"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )3, (uint8_t )0, "System Firmware Hang",
      "Secondary CPU Initialization"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )4, (uint8_t )0, "System Firmware Hang",
      "User authentication"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )5, (uint8_t )0, "System Firmware Hang",
      "User-initiated system setup"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )6, (uint8_t )0, "System Firmware Hang",
      "USB resource configuration"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )7, (uint8_t )0, "System Firmware Hang",
      "PCI resource configuration"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )8, (uint8_t )0, "System Firmware Hang",
      "Option ROM initialization"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )9, (uint8_t )0, "System Firmware Hang",
      "Video initialization"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )10, (uint8_t )0, "System Firmware Hang",
      "Cache initialization"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )11, (uint8_t )0, "System Firmware Hang",
      "SMBus initialization"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )12, (uint8_t )0, "System Firmware Hang",
      "Keyboard controller initialization"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )13, (uint8_t )0, "System Firmware Hang",
      "Management controller initialization"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )14, (uint8_t )0, "System Firmware Hang",
      "Docking station attachment"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )15, (uint8_t )0, "System Firmware Hang",
      "Enabling docking station"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )16, (uint8_t )0, "System Firmware Hang",
      "Docking station ejection"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )17, (uint8_t )0, "System Firmware Hang",
      "Disabling docking station"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )18, (uint8_t )0, "System Firmware Hang",
      "Calling operating system wake-up vector"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )19, (uint8_t )0, "System Firmware Hang",
      "System boot initiated"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )20, (uint8_t )0, "System Firmware Hang",
      "Motherboard initialization"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )21, (uint8_t )0, "System Firmware Hang",
      "reserved"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )22, (uint8_t )0, "System Firmware Hang",
      "Floppy initialization"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )23, (uint8_t )0, "System Firmware Hang",
      "Keyboard test"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )24, (uint8_t )0, "System Firmware Hang",
      "Pointing device test"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )25, (uint8_t )0, "System Firmware Hang",
      "Primary CPU initialization"}, 
        {(uint8_t )15, (uint8_t )1, (uint8_t )255, (uint8_t )0, "System Firmware Hang",
      "Unknown Hang"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )0, (uint8_t )0, "System Firmware Progress",
      "Unspecified"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )1, (uint8_t )0, "System Firmware Progress",
      "Memory initialization"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )2, (uint8_t )0, "System Firmware Progress",
      "Hard-disk initialization"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )3, (uint8_t )0, "System Firmware Progress",
      "Secondary CPU Initialization"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )4, (uint8_t )0, "System Firmware Progress",
      "User authentication"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )5, (uint8_t )0, "System Firmware Progress",
      "User-initiated system setup"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )6, (uint8_t )0, "System Firmware Progress",
      "USB resource configuration"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )7, (uint8_t )0, "System Firmware Progress",
      "PCI resource configuration"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )8, (uint8_t )0, "System Firmware Progress",
      "Option ROM initialization"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )9, (uint8_t )0, "System Firmware Progress",
      "Video initialization"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )10, (uint8_t )0, "System Firmware Progress",
      "Cache initialization"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )11, (uint8_t )0, "System Firmware Progress",
      "SMBus initialization"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )12, (uint8_t )0, "System Firmware Progress",
      "Keyboard controller initialization"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )13, (uint8_t )0, "System Firmware Progress",
      "Management controller initialization"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )14, (uint8_t )0, "System Firmware Progress",
      "Docking station attachment"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )15, (uint8_t )0, "System Firmware Progress",
      "Enabling docking station"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )16, (uint8_t )0, "System Firmware Progress",
      "Docking station ejection"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )17, (uint8_t )0, "System Firmware Progress",
      "Disabling docking station"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )18, (uint8_t )0, "System Firmware Progress",
      "Calling operating system wake-up vector"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )19, (uint8_t )0, "System Firmware Progress",
      "System boot initiated"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )20, (uint8_t )0, "System Firmware Progress",
      "Motherboard initialization"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )21, (uint8_t )0, "System Firmware Progress",
      "reserved"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )22, (uint8_t )0, "System Firmware Progress",
      "Floppy initialization"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )23, (uint8_t )0, "System Firmware Progress",
      "Keyboard test"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )24, (uint8_t )0, "System Firmware Progress",
      "Pointing device test"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )25, (uint8_t )0, "System Firmware Progress",
      "Primary CPU initialization"}, 
        {(uint8_t )15, (uint8_t )2, (uint8_t )255, (uint8_t )0, "System Firmware Progress",
      "Unknown Progress"}, 
        {(uint8_t )16, (uint8_t )0, (uint8_t )255, (uint8_t )0, "Event Logging Disabled",
      "Correctable memory error logging disabled"}, 
        {(uint8_t )16, (uint8_t )1, (uint8_t )255, (uint8_t )0, "Event Logging Disabled",
      "Event logging disabled"}, 
        {(uint8_t )16, (uint8_t )2, (uint8_t )255, (uint8_t )0, "Event Logging Disabled",
      "Log area reset/cleared"}, 
        {(uint8_t )16, (uint8_t )3, (uint8_t )255, (uint8_t )0, "Event Logging Disabled",
      "All event logging disabled"}, 
        {(uint8_t )16, (uint8_t )4, (uint8_t )255, (uint8_t )0, "Event Logging Disabled",
      "Log full"}, 
        {(uint8_t )16, (uint8_t )5, (uint8_t )255, (uint8_t )0, "Event Logging Disabled",
      "Log almost full"}, 
        {(uint8_t )17, (uint8_t )0, (uint8_t )255, (uint8_t )0, "Watchdog 1", "BIOS Reset"}, 
        {(uint8_t )17,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Watchdog 1", "OS Reset"}, 
        {(uint8_t )17, (uint8_t )2, (uint8_t )255, (uint8_t )0, "Watchdog 1", "OS Shut Down"}, 
        {(uint8_t )17,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Watchdog 1", "OS Power Down"}, 
        {(uint8_t )17, (uint8_t )4, (uint8_t )255, (uint8_t )0, "Watchdog 1", "OS Power Cycle"}, 
        {(uint8_t )17,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Watchdog 1", "OS NMI/Diag Interrupt"}, 
        {(uint8_t )17,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "Watchdog 1", "OS Expired"}, 
        {(uint8_t )17, (uint8_t )7, (uint8_t )255, (uint8_t )0, "Watchdog 1", "OS pre-timeout Interrupt"}, 
        {(uint8_t )18,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "System Event", "System Reconfigured"}, 
        {(uint8_t )18,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "System Event", "OEM System boot event"}, 
        {(uint8_t )18,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "System Event", "Undetermined system hardware failure"}, 
        {(uint8_t )18,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "System Event", "Entry added to auxiliary log"}, 
        {(uint8_t )18,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "System Event", "PEF Action"}, 
        {(uint8_t )18, (uint8_t )5, (uint8_t )255, (uint8_t )0, "System Event", "Timestamp Clock Sync"}, 
        {(uint8_t )19,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Critical Interrupt", "NMI/Diag Interrupt"}, 
        {(uint8_t )19,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Critical Interrupt", "Bus Timeout"}, 
        {(uint8_t )19,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Critical Interrupt", "I/O Channel check NMI"}, 
        {(uint8_t )19,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Critical Interrupt", "Software NMI"}, 
        {(uint8_t )19,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Critical Interrupt", "PCI PERR"}, 
        {(uint8_t )19, (uint8_t )5, (uint8_t )255, (uint8_t )0, "Critical Interrupt",
      "PCI SERR"}, 
        {(uint8_t )19, (uint8_t )6, (uint8_t )255, (uint8_t )0, "Critical Interrupt",
      "EISA failsafe timeout"}, 
        {(uint8_t )19, (uint8_t )7, (uint8_t )255, (uint8_t )0, "Critical Interrupt",
      "Bus Correctable error"}, 
        {(uint8_t )19, (uint8_t )8, (uint8_t )255, (uint8_t )0, "Critical Interrupt",
      "Bus Uncorrectable error"}, 
        {(uint8_t )19, (uint8_t )9, (uint8_t )255, (uint8_t )0, "Critical Interrupt",
      "Fatal NMI"}, 
        {(uint8_t )19, (uint8_t )10, (uint8_t )255, (uint8_t )0, "Critical Interrupt",
      "Bus Fatal Error"}, 
        {(uint8_t )20, (uint8_t )0, (uint8_t )255, (uint8_t )0, "Button", "Power Button pressed"}, 
        {(uint8_t )20,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Button", "Sleep Button pressed"}, 
        {(uint8_t )20, (uint8_t )2, (uint8_t )255, (uint8_t )0, "Button", "Reset Button pressed"}, 
        {(uint8_t )20,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Button", "FRU Latch"}, 
        {(uint8_t )20, (uint8_t )4, (uint8_t )255, (uint8_t )0, "Button", "FRU Service"}, 
        {(uint8_t )21,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Module/Board", (char const   *)((void *)0)}, 
        {(uint8_t )22,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Microcontroller/Coprocessor", (char const   *)((void *)0)}, 
        {(uint8_t )23,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Add-in Card", (char const   *)((void *)0)}, 
        {(uint8_t )24,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Chassis", (char const   *)((void *)0)}, 
        {(uint8_t )25,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Chip Set", (char const   *)((void *)0)}, 
        {(uint8_t )26,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Other FRU", (char const   *)((void *)0)}, 
        {(uint8_t )27,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Cable/Interconnect", "Connected"}, 
        {(uint8_t )27,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Cable/Interconnect", "Config Error"}, 
        {(uint8_t )28,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Terminator", (char const   *)((void *)0)}, 
        {(uint8_t )29,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "System Boot Initiated", "Initiated by power up"}, 
        {(uint8_t )29,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "System Boot Initiated", "Initiated by hard reset"}, 
        {(uint8_t )29,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "System Boot Initiated", "Initiated by warm reset"}, 
        {(uint8_t )29,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "System Boot Initiated", "User requested PXE boot"}, 
        {(uint8_t )29,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "System Boot Initiated", "Automatic boot to diagnostic"}, 
        {(uint8_t )29,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "System Boot Initiated", "OS initiated hard reset"}, 
        {(uint8_t )29,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "System Boot Initiated", "OS initiated warm reset"}, 
        {(uint8_t )29,
      (uint8_t )7, (uint8_t )255, (uint8_t )0, "System Boot Initiated", "System Restart"}, 
        {(uint8_t )30,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Boot Error", "No bootable media"}, 
        {(uint8_t )30,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Boot Error", "Non-bootable disk in drive"}, 
        {(uint8_t )30,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Boot Error", "PXE server not found"}, 
        {(uint8_t )30,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Boot Error", "Invalid boot sector"}, 
        {(uint8_t )30,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Boot Error", "Timeout waiting for selection"}, 
        {(uint8_t )31,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "OS Boot", "A: boot completed"}, 
        {(uint8_t )31, (uint8_t )1, (uint8_t )255, (uint8_t )0, "OS Boot", "C: boot completed"}, 
        {(uint8_t )31,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "OS Boot", "PXE boot completed"}, 
        {(uint8_t )31, (uint8_t )3, (uint8_t )255, (uint8_t )0, "OS Boot", "Diagnostic boot completed"}, 
        {(uint8_t )31,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "OS Boot", "CD-ROM boot completed"}, 
        {(uint8_t )31,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "OS Boot", "ROM boot completed"}, 
        {(uint8_t )31, (uint8_t )6, (uint8_t )255, (uint8_t )0, "OS Boot", "boot completed - device not specified"}, 
        {(uint8_t )32,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "OS Stop/Shutdown", "Error during system startup"}, 
        {(uint8_t )32,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "OS Stop/Shutdown", "Run-time critical stop"}, 
        {(uint8_t )32,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "OS Stop/Shutdown", "OS graceful stop"}, 
        {(uint8_t )32,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "OS Stop/Shutdown", "OS graceful shutdown"}, 
        {(uint8_t )32,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "OS Stop/Shutdown", "PEF initiated soft shutdown"}, 
        {(uint8_t )32,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "OS Stop/Shutdown", "Agent not responding"}, 
        {(uint8_t )33,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Slot/Connector", "Fault Status"}, 
        {(uint8_t )33, (uint8_t )1, (uint8_t )255, (uint8_t )0, "Slot/Connector", "Identify Status"}, 
        {(uint8_t )33,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Slot/Connector", "Device Installed"}, 
        {(uint8_t )33,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Slot/Connector", "Ready for Device Installation"}, 
        {(uint8_t )33,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Slot/Connector", "Ready for Device Removal"}, 
        {(uint8_t )33,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Slot/Connector", "Slot Power is Off"}, 
        {(uint8_t )33,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "Slot/Connector", "Device Removal Request"}, 
        {(uint8_t )33,
      (uint8_t )7, (uint8_t )255, (uint8_t )0, "Slot/Connector", "Interlock"}, 
        {(uint8_t )33, (uint8_t )8, (uint8_t )255, (uint8_t )0, "Slot/Connector", "Slot is Disabled"}, 
        {(uint8_t )33,
      (uint8_t )9, (uint8_t )255, (uint8_t )0, "Slot/Connector", "Spare Device"}, 
        {(uint8_t )34, (uint8_t )0, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "S0/G0: working"}, 
        {(uint8_t )34, (uint8_t )1, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "S1: sleeping with system hw & processor context maintained"}, 
        {(uint8_t )34, (uint8_t )2, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "S2: sleeping, processor context lost"}, 
        {(uint8_t )34, (uint8_t )3, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "S3: sleeping, processor & hw context lost, memory retained"}, 
        {(uint8_t )34, (uint8_t )4, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "S4: non-volatile sleep/suspend-to-disk"}, 
        {(uint8_t )34, (uint8_t )5, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "S5/G2: soft-off"}, 
        {(uint8_t )34, (uint8_t )6, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "S4/S5: soft-off"}, 
        {(uint8_t )34, (uint8_t )7, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "G3: mechanical off"}, 
        {(uint8_t )34, (uint8_t )8, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "Sleeping in S1/S2/S3 state"}, 
        {(uint8_t )34, (uint8_t )9, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "G1: sleeping"}, 
        {(uint8_t )34, (uint8_t )10, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "S5: entered by override"}, 
        {(uint8_t )34, (uint8_t )11, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "Legacy ON state"}, 
        {(uint8_t )34, (uint8_t )12, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "Legacy OFF state"}, 
        {(uint8_t )34, (uint8_t )14, (uint8_t )255, (uint8_t )0, "System ACPI Power State",
      "Unknown"}, 
        {(uint8_t )35, (uint8_t )0, (uint8_t )255, (uint8_t )0, "Watchdog 2", "Timer expired"}, 
        {(uint8_t )35,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Watchdog 2", "Hard reset"}, 
        {(uint8_t )35, (uint8_t )2, (uint8_t )255, (uint8_t )0, "Watchdog 2", "Power down"}, 
        {(uint8_t )35,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Watchdog 2", "Power cycle"}, 
        {(uint8_t )35, (uint8_t )4, (uint8_t )255, (uint8_t )0, "Watchdog 2", "reserved"}, 
        {(uint8_t )35,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Watchdog 2", "reserved"}, 
        {(uint8_t )35, (uint8_t )6, (uint8_t )255, (uint8_t )0, "Watchdog 2", "reserved"}, 
        {(uint8_t )35,
      (uint8_t )7, (uint8_t )255, (uint8_t )0, "Watchdog 2", "reserved"}, 
        {(uint8_t )35, (uint8_t )8, (uint8_t )255, (uint8_t )0, "Watchdog 2", "Timer interrupt"}, 
        {(uint8_t )36,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Platform Alert", "Platform generated page"}, 
        {(uint8_t )36,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Platform Alert", "Platform generated LAN alert"}, 
        {(uint8_t )36,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Platform Alert", "Platform Event Trap generated"}, 
        {(uint8_t )36,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Platform Alert", "Platform generated SNMP trap, OEM format"}, 
        {(uint8_t )37,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Entity Presence", "Present"}, 
        {(uint8_t )37, (uint8_t )1, (uint8_t )255, (uint8_t )0, "Entity Presence", "Absent"}, 
        {(uint8_t )37,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Entity Presence", "Disabled"}, 
        {(uint8_t )38, (uint8_t )0, (uint8_t )255, (uint8_t )0, "Monitor ASIC/IC", (char const   *)((void *)0)}, 
        {(uint8_t )39,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "LAN", "Heartbeat Lost"}, 
        {(uint8_t )39, (uint8_t )1, (uint8_t )255, (uint8_t )0, "LAN", "Heartbeat"}, 
        {(uint8_t )40, (uint8_t )0, (uint8_t )255, (uint8_t )0, "Management Subsystem Health",
      "Sensor access degraded or unavailable"}, 
        {(uint8_t )40, (uint8_t )1, (uint8_t )255, (uint8_t )0, "Management Subsystem Health",
      "Controller access degraded or unavailable"}, 
        {(uint8_t )40, (uint8_t )2, (uint8_t )255, (uint8_t )0, "Management Subsystem Health",
      "Management controller off-line"}, 
        {(uint8_t )40, (uint8_t )3, (uint8_t )255, (uint8_t )0, "Management Subsystem Health",
      "Management controller unavailable"}, 
        {(uint8_t )40, (uint8_t )4, (uint8_t )255, (uint8_t )0, "Management Subsystem Health",
      "Sensor failure"}, 
        {(uint8_t )40, (uint8_t )5, (uint8_t )255, (uint8_t )0, "Management Subsystem Health",
      "FRU failure"}, 
        {(uint8_t )41, (uint8_t )0, (uint8_t )255, (uint8_t )0, "Battery", "Low"}, 
        {(uint8_t )41, (uint8_t )1, (uint8_t )255, (uint8_t )0, "Battery", "Failed"}, 
        {(uint8_t )41,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Battery", "Presence Detected"}, 
        {(uint8_t )43, (uint8_t )0, (uint8_t )255, (uint8_t )0, "Version Change", "Hardware change detected"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )0, (uint8_t )0, "Version Change", "Firmware or software change detected"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )1, (uint8_t )0, "Version Change", "Firmware or software change detected, Mngmt Ctrl Dev Id"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )2, (uint8_t )0, "Version Change", "Firmware or software change detected, Mngmt Ctrl Firm Rev"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )3, (uint8_t )0, "Version Change", "Firmware or software change detected, Mngmt Ctrl Dev Rev"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )4, (uint8_t )0, "Version Change", "Firmware or software change detected, Mngmt Ctrl Manuf Id"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )5, (uint8_t )0, "Version Change", "Firmware or software change detected, Mngmt Ctrl IPMI Vers"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )6, (uint8_t )0, "Version Change", "Firmware or software change detected, Mngmt Ctrl Aux Firm Id"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )7, (uint8_t )0, "Version Change", "Firmware or software change detected, Mngmt Ctrl Firm Boot Block"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )8, (uint8_t )0, "Version Change", "Firmware or software change detected, Mngmt Ctrl Other"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )9, (uint8_t )0, "Version Change", "Firmware or software change detected, BIOS/EFI change"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )10, (uint8_t )0, "Version Change", "Firmware or software change detected, SMBIOS change"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )11, (uint8_t )0, "Version Change", "Firmware or software change detected, O/S change"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )12, (uint8_t )0, "Version Change", "Firmware or software change detected, O/S loader change"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )13, (uint8_t )0, "Version Change", "Firmware or software change detected, Service Diag change"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )14, (uint8_t )0, "Version Change", "Firmware or software change detected, Mngmt SW agent change"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )15, (uint8_t )0, "Version Change", "Firmware or software change detected, Mngmt SW App change"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )16, (uint8_t )0, "Version Change", "Firmware or software change detected, Mngmt SW Middle"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )17, (uint8_t )0, "Version Change", "Firmware or software change detected, Prog HW Change (FPGA)"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )18, (uint8_t )0, "Version Change", "Firmware or software change detected, board/FRU module change"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )19, (uint8_t )0, "Version Change", "Firmware or software change detected, board/FRU component change"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )20, (uint8_t )0, "Version Change", "Firmware or software change detected, board/FRU replace equ ver"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )21, (uint8_t )0, "Version Change", "Firmware or software change detected, board/FRU replace new ver"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )22, (uint8_t )0, "Version Change", "Firmware or software change detected, board/FRU replace old ver"}, 
        {(uint8_t )43,
      (uint8_t )1, (uint8_t )23, (uint8_t )0, "Version Change", "Firmware or software change detected, board/FRU HW conf change"}, 
        {(uint8_t )43,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Version Change", "Hardware incompatibility detected"}, 
        {(uint8_t )43,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "Version Change", "Firmware or software incompatibility detected"}, 
        {(uint8_t )43,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "Version Change", "Invalid or unsupported hardware version"}, 
        {(uint8_t )43,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "Version Change", "Invalid or unsupported firmware or software version"}, 
        {(uint8_t )43,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "Version Change", "Hardware change success"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )0, (uint8_t )0, "Version Change", "Firmware or software change success"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )1, (uint8_t )0, "Version Change", "Firmware or software change success, Mngmt Ctrl Dev Id"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )2, (uint8_t )0, "Version Change", "Firmware or software change success, Mngmt Ctrl Firm Rev"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )3, (uint8_t )0, "Version Change", "Firmware or software change success, Mngmt Ctrl Dev Rev"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )4, (uint8_t )0, "Version Change", "Firmware or software change success, Mngmt Ctrl Manuf Id"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )5, (uint8_t )0, "Version Change", "Firmware or software change success, Mngmt Ctrl IPMI Vers"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )6, (uint8_t )0, "Version Change", "Firmware or software change success, Mngmt Ctrl Aux Firm Id"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )7, (uint8_t )0, "Version Change", "Firmware or software change success, Mngmt Ctrl Firm Boot Block"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )8, (uint8_t )0, "Version Change", "Firmware or software change success, Mngmt Ctrl Other"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )9, (uint8_t )0, "Version Change", "Firmware or software change success, BIOS/EFI change"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )10, (uint8_t )0, "Version Change", "Firmware or software change success, SMBIOS change"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )11, (uint8_t )0, "Version Change", "Firmware or software change success, O/S change"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )12, (uint8_t )0, "Version Change", "Firmware or software change success, O/S loader change"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )13, (uint8_t )0, "Version Change", "Firmware or software change success, Service Diag change"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )14, (uint8_t )0, "Version Change", "Firmware or software change success, Mngmt SW agent change"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )15, (uint8_t )0, "Version Change", "Firmware or software change success, Mngmt SW App change"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )16, (uint8_t )0, "Version Change", "Firmware or software change success, Mngmt SW Middle"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )17, (uint8_t )0, "Version Change", "Firmware or software change success, Prog HW Change (FPGA)"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )18, (uint8_t )0, "Version Change", "Firmware or software change success, board/FRU module change"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )19, (uint8_t )0, "Version Change", "Firmware or software change success, board/FRU component change"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )20, (uint8_t )0, "Version Change", "Firmware or software change success, board/FRU replace equ ver"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )21, (uint8_t )0, "Version Change", "Firmware or software change success, board/FRU replace new ver"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )22, (uint8_t )0, "Version Change", "Firmware or software change success, board/FRU replace old ver"}, 
        {(uint8_t )43,
      (uint8_t )7, (uint8_t )23, (uint8_t )0, "Version Change", "Firmware or software change success, board/FRU HW conf change"}, 
        {(uint8_t )44,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "FRU State", "Not Installed"}, 
        {(uint8_t )44, (uint8_t )1, (uint8_t )255, (uint8_t )0, "FRU State", "Inactive"}, 
        {(uint8_t )44,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "FRU State", "Activation Requested"}, 
        {(uint8_t )44,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "FRU State", "Activation in Progress"}, 
        {(uint8_t )44,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "FRU State", "Active"}, 
        {(uint8_t )44, (uint8_t )5, (uint8_t )255, (uint8_t )0, "FRU State", "Deactivation Requested"}, 
        {(uint8_t )44,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "FRU State", "Deactivation in Progress"}, 
        {(uint8_t )44,
      (uint8_t )7, (uint8_t )255, (uint8_t )0, "FRU State", "Communication lost"}, 
        {(uint8_t )240,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "FRU Hot Swap", "Transition to M0"}, 
        {(uint8_t )240,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "FRU Hot Swap", "Transition to M1"}, 
        {(uint8_t )240,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "FRU Hot Swap", "Transition to M2"}, 
        {(uint8_t )240,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "FRU Hot Swap", "Transition to M3"}, 
        {(uint8_t )240,
      (uint8_t )4, (uint8_t )255, (uint8_t )0, "FRU Hot Swap", "Transition to M4"}, 
        {(uint8_t )240,
      (uint8_t )5, (uint8_t )255, (uint8_t )0, "FRU Hot Swap", "Transition to M5"}, 
        {(uint8_t )240,
      (uint8_t )6, (uint8_t )255, (uint8_t )0, "FRU Hot Swap", "Transition to M6"}, 
        {(uint8_t )240,
      (uint8_t )7, (uint8_t )255, (uint8_t )0, "FRU Hot Swap", "Transition to M7"}, 
        {(uint8_t )241,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "IPMB-0 Status", "IPMB-A disabled, IPMB-B disabled"}, 
        {(uint8_t )241,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "IPMB-0 Status", "IPMB-A enabled, IPMB-B disabled"}, 
        {(uint8_t )241,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "IPMB-0 Status", "IPMB-A disabled, IPMB-B enabled"}, 
        {(uint8_t )241,
      (uint8_t )3, (uint8_t )255, (uint8_t )0, "IPMB-0 Status", "IPMB-A enabled, IPMP-B enabled"}, 
        {(uint8_t )242,
      (uint8_t )0, (uint8_t )255, (uint8_t )0, "Module Hot Swap", "Module Handle Closed"}, 
        {(uint8_t )242,
      (uint8_t )1, (uint8_t )255, (uint8_t )0, "Module Hot Swap", "Module Handle Opened"}, 
        {(uint8_t )242,
      (uint8_t )2, (uint8_t )255, (uint8_t )0, "Module Hot Swap", "Quiesced"}, 
        {(uint8_t )192, (uint8_t )0, (uint8_t )255, (uint8_t )0, "OEM", "OEM Specific"}, 
        {(uint8_t )0,
      (uint8_t )0, (uint8_t )0, (uint8_t )0, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 56 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_event.c"
static void ipmi_event_msg_print___0(struct ipmi_intf *intf , struct platform_event_msg *pmsg ) 
{ 
  struct sel_event_record sel_event ;

  {
  {
#line 61
  memset((void *)(& sel_event), 0, sizeof(struct sel_event_record ));
#line 63
  sel_event.record_id = (uint16_t )0;
#line 64
  sel_event.sel_type.standard_type.gen_id = (uint16_t )2;
#line 66
  sel_event.sel_type.standard_type.evm_rev = pmsg->evm_rev;
#line 67
  sel_event.sel_type.standard_type.sensor_type = pmsg->sensor_type;
#line 68
  sel_event.sel_type.standard_type.sensor_num = pmsg->sensor_num;
#line 69
  sel_event.sel_type.standard_type.event_type = pmsg->event_type;
#line 70
  sel_event.sel_type.standard_type.event_dir = pmsg->event_dir;
#line 71
  sel_event.sel_type.standard_type.event_data[0] = pmsg->event_data[0];
#line 72
  sel_event.sel_type.standard_type.event_data[1] = pmsg->event_data[1];
#line 73
  sel_event.sel_type.standard_type.event_data[2] = pmsg->event_data[2];
  }
#line 75
  if (verbose) {
    {
#line 76
    ipmi_sel_print_extended_entry_verbose(intf, & sel_event);
    }
  } else {
    {
#line 78
    ipmi_sel_print_extended_entry(intf, & sel_event);
    }
  }
#line 79
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_event.c"
static int ipmi_send_platform_event___0(struct ipmi_intf *intf , struct platform_event_msg *emsg ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t rqdata[8] ;
  uint8_t chmed ;
  char const   *tmp ;

  {
  {
#line 89
  memset((void *)(& req), 0, sizeof(req));
#line 90
  memset((void *)(rqdata), 0, (size_t )8);
#line 92
  req.msg.netfn = (uint8_t )4;
#line 93
  req.msg.cmd = (uint8_t )2;
#line 94
  req.msg.data = rqdata;
#line 96
  chmed = ipmi_current_channel_medium(intf);
  }
#line 97
  if ((int )chmed == 12) {
    {
#line 99
    req.msg.data_len = (uint16_t )8;
#line 100
    rqdata[0] = (uint8_t )65;
#line 101
    memcpy((void */* __restrict  */)(rqdata + 1), (void const   */* __restrict  */)emsg,
           sizeof(struct platform_event_msg ));
    }
  } else {
    {
#line 104
    req.msg.data_len = (uint16_t )7;
#line 105
    memcpy((void */* __restrict  */)(rqdata), (void const   */* __restrict  */)emsg,
           sizeof(struct platform_event_msg ));
    }
  }
  {
#line 108
  ipmi_event_msg_print___0(intf, emsg);
#line 110
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 111
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 112
    lprintf(3, "Platform Event Message command failed");
    }
#line 113
    return (-1);
  } else
#line 115
  if ((int )rsp->ccode > 0) {
    {
#line 116
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 116
    lprintf(3, "Platform Event Message command failed: %s", tmp);
    }
#line 118
    return (-1);
  }
#line 121
  return (0);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_event.c"
static struct valstr  const  ipmi_event_thresh_lo___0[7]  = {      {(uint16_t )0, "lnc"}, 
        {(uint16_t )2, "lcr"}, 
        {(uint16_t )4, "lnr"}, 
        {(uint16_t )6, "unc"}, 
        {(uint16_t )8, "ucr"}, 
        {(uint16_t )10, "unr"}, 
        {(uint16_t )0, (char const   *)((void *)0)}};
#line 146 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_event.c"
static struct valstr  const  ipmi_event_thresh_hi___0[7]  = {      {(uint16_t )1, "lnc"}, 
        {(uint16_t )3, "lcr"}, 
        {(uint16_t )5, "lnr"}, 
        {(uint16_t )7, "unc"}, 
        {(uint16_t )9, "ucr"}, 
        {(uint16_t )11, "unr"}, 
        {(uint16_t )0, (char const   *)((void *)0)}};
#line 156 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_event.c"
static int ipmi_send_platform_event_num___0(struct ipmi_intf *intf , int num ) 
{ 
  struct platform_event_msg emsg ;
  int tmp ;

  {
  {
#line 161
  memset((void *)(& emsg), 0, sizeof(struct platform_event_msg ));
  }
  {
#line 165
  if (num == 1) {
#line 165
    goto case_1;
  }
#line 177
  if (num == 2) {
#line 177
    goto case_2;
  }
#line 189
  if (num == 3) {
#line 189
    goto case_3;
  }
#line 200
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 166
  printf((char const   */* __restrict  */)"Sending SAMPLE event: Temperature - Upper Critical - Going High\n");
#line 168
  emsg.evm_rev = (uint8_t )4;
#line 169
  emsg.sensor_type = (uint8_t )1;
#line 170
  emsg.sensor_num = (uint8_t )48;
#line 171
  emsg.event_dir = (uint8_t )0;
#line 172
  emsg.event_type = (uint8_t )1;
#line 173
  emsg.event_data[0] = (uint8_t )9;
#line 174
  emsg.event_data[1] = (uint8_t )255;
#line 175
  emsg.event_data[2] = (uint8_t )255;
  }
#line 176
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 178
  printf((char const   */* __restrict  */)"Sending SAMPLE event: Voltage Threshold - Lower Critical - Going Low\n");
#line 180
  emsg.evm_rev = (uint8_t )4;
#line 181
  emsg.sensor_type = (uint8_t )2;
#line 182
  emsg.sensor_num = (uint8_t )96;
#line 183
  emsg.event_dir = (uint8_t )0;
#line 184
  emsg.event_type = (uint8_t )1;
#line 185
  emsg.event_data[0] = (uint8_t )2;
#line 186
  emsg.event_data[1] = (uint8_t )255;
#line 187
  emsg.event_data[2] = (uint8_t )255;
  }
#line 188
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 190
  printf((char const   */* __restrict  */)"Sending SAMPLE event: Memory - Correctable ECC\n");
#line 191
  emsg.evm_rev = (uint8_t )4;
#line 192
  emsg.sensor_type = (uint8_t )12;
#line 193
  emsg.sensor_num = (uint8_t )83;
#line 194
  emsg.event_dir = (uint8_t )0;
#line 195
  emsg.event_type = (uint8_t )111;
#line 196
  emsg.event_data[0] = (uint8_t )0;
#line 197
  emsg.event_data[1] = (uint8_t )255;
#line 198
  emsg.event_data[2] = (uint8_t )255;
  }
#line 199
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 201
  lprintf(3, "Invalid event number: %d", num);
  }
#line 202
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 205
  tmp = ipmi_send_platform_event___0(intf, & emsg);
  }
#line 205
  return (tmp);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_event.c"
static int ipmi_event_find_offset___0(uint8_t code , struct ipmi_event_sensor_types *evt ,
                                      char *desc ) 
{ 
  int x ;
  size_t tmp ;
  int y ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 213
  if ((unsigned long )desc == (unsigned long )((void *)0)) {
#line 214
    return (0);
  } else
#line 213
  if ((int )code == 0) {
#line 214
    return (0);
  }
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! evt->type) {
#line 216
      goto while_break;
    }
#line 218
    if ((int )evt->code == (int )code) {
#line 218
      if ((unsigned long )evt->desc != (unsigned long )((void *)0)) {
        {
#line 218
        tmp = strlen((char const   *)desc);
#line 218
        x = (int )tmp;
#line 218
        tmp___0 = strlen(evt->desc);
#line 218
        y = (int )tmp___0;
        }
#line 218
        if (x > y) {
#line 218
          tmp___1 = x;
        } else {
#line 218
          tmp___1 = y;
        }
        {
#line 218
        tmp___2 = strncasecmp((char const   *)desc, evt->desc, (size_t )tmp___1);
        }
#line 218
        if (tmp___2 == 0) {
#line 219
          return ((int )evt->offset);
        }
      }
    }
#line 220
    evt ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 223
  lprintf(4, "Unable to find matching event offset for \'%s\'", desc);
  }
#line 224
  return (-1);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_event.c"
static void print_sensor_states___0(uint8_t sensor_type , uint8_t event_type ) 
{ 


  {
  {
#line 230
  ipmi_sdr_print_discrete_state_mini("Sensor States: \n  ", "\n  ", sensor_type, event_type,
                                     (uint8_t )255, (uint8_t )255);
#line 233
  printf((char const   */* __restrict  */)"\n");
  }
#line 234
  return;
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_event.c"
static int ipmi_event_fromsensor___0(struct ipmi_intf *intf , char *id , char *state ,
                                     char *evdir ) 
{ 
  struct ipmi_rs *rsp ;
  struct sdr_record_list *sdr ;
  struct platform_event_msg emsg ;
  int off ;
  uint8_t target ;
  uint8_t lun ;
  uint8_t channel ;
  int tmp ;
  int tmp___0 ;
  int dir ;
  int hilo ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  uint16_t tmp___8 ;
  uint16_t tmp___9 ;
  char const   *tmp___10 ;
  int x ;
  char const   *digi_on[7] ;
  char const   *digi_off[7] ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 246
  if ((unsigned long )id == (unsigned long )((void *)0)) {
    {
#line 247
    lprintf(3, "No sensor ID supplied");
    }
#line 248
    return (-1);
  }
  {
#line 251
  memset((void *)(& emsg), 0, sizeof(struct platform_event_msg ));
#line 252
  emsg.evm_rev = (uint8_t )4;
  }
#line 254
  if ((unsigned long )evdir == (unsigned long )((void *)0)) {
#line 255
    emsg.event_dir = (uint8_t )0;
  } else {
    {
#line 256
    tmp___0 = strncasecmp((char const   *)evdir, "assert", (size_t )6);
    }
#line 256
    if (tmp___0 == 0) {
#line 257
      emsg.event_dir = (uint8_t )0;
    } else {
      {
#line 258
      tmp = strncasecmp((char const   *)evdir, "deassert", (size_t )8);
      }
#line 258
      if (tmp == 0) {
#line 259
        emsg.event_dir = (uint8_t )1;
      } else {
        {
#line 261
        lprintf(3, "Invalid event direction %s.  Must be \'assert\' or \'deassert\'",
                evdir);
        }
#line 262
        return (-1);
      }
    }
  }
  {
#line 265
  printf((char const   */* __restrict  */)"Finding sensor %s... ", id);
#line 266
  sdr = ipmi_sdr_find_sdr_byid(intf, id);
  }
#line 267
  if ((unsigned long )sdr == (unsigned long )((void *)0)) {
    {
#line 268
    printf((char const   */* __restrict  */)"not found!\n");
    }
#line 269
    return (-1);
  }
  {
#line 271
  printf((char const   */* __restrict  */)"ok\n");
  }
  {
#line 276
  if ((int )sdr->type == 2) {
#line 276
    goto case_2;
  }
#line 276
  if ((int )sdr->type == 1) {
#line 276
    goto case_2;
  }
#line 285
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 278
  emsg.sensor_type = (sdr->record.common)->sensor.type;
#line 279
  emsg.sensor_num = (sdr->record.common)->keys.sensor_num;
#line 280
  emsg.event_type = (sdr->record.common)->event_type;
#line 281
  target = (sdr->record.common)->keys.owner_id;
#line 282
  lun = (sdr->record.common)->keys.lun;
#line 283
  channel = (sdr->record.common)->keys.channel;
#line 284
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 286
  lprintf(3, "Unknown sensor type for id \'%s\'", id);
  }
#line 287
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 290
  emsg.event_data[1] = (uint8_t )255;
#line 291
  emsg.event_data[2] = (uint8_t )255;
  {
#line 298
  if ((int )emsg.event_type == 1) {
#line 298
    goto case_1___0;
  }
#line 391
  if ((int )emsg.event_type == 9) {
#line 391
    goto case_9;
  }
#line 391
  if ((int )emsg.event_type == 8) {
#line 391
    goto case_9;
  }
#line 391
  if ((int )emsg.event_type == 6) {
#line 391
    goto case_9;
  }
#line 391
  if ((int )emsg.event_type == 5) {
#line 391
    goto case_9;
  }
#line 391
  if ((int )emsg.event_type == 4) {
#line 391
    goto case_9;
  }
#line 391
  if ((int )emsg.event_type == 3) {
#line 391
    goto case_9;
  }
#line 436
  if ((int )emsg.event_type == 12) {
#line 436
    goto case_12;
  }
#line 436
  if ((int )emsg.event_type == 11) {
#line 436
    goto case_12;
  }
#line 436
  if ((int )emsg.event_type == 10) {
#line 436
    goto case_12;
  }
#line 436
  if ((int )emsg.event_type == 7) {
#line 436
    goto case_12;
  }
#line 436
  if ((int )emsg.event_type == 2) {
#line 436
    goto case_12;
  }
#line 456
  if ((int )emsg.event_type == 111) {
#line 456
    goto case_111;
  }
#line 473
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
#line 300
  dir = 0;
#line 301
  hilo = 0;
#line 302
  off = 1;
#line 304
  if ((unsigned long )state == (unsigned long )((void *)0)) {
#line 304
    goto _L;
  } else {
    {
#line 304
    tmp___1 = strncasecmp((char const   *)state, "list", (size_t )4);
    }
#line 304
    if (tmp___1 == 0) {
      _L: /* CIL Label */ 
      {
#line 305
      printf((char const   */* __restrict  */)"Sensor States:\n");
#line 306
      printf((char const   */* __restrict  */)"  lnr : Lower Non-Recoverable \n");
#line 307
      printf((char const   */* __restrict  */)"  lcr : Lower Critical\n");
#line 308
      printf((char const   */* __restrict  */)"  lnc : Lower Non-Critical\n");
#line 309
      printf((char const   */* __restrict  */)"  unc : Upper Non-Critical\n");
#line 310
      printf((char const   */* __restrict  */)"  ucr : Upper Critical\n");
#line 311
      printf((char const   */* __restrict  */)"  unr : Upper Non-Recoverable\n");
      }
#line 312
      return (-1);
    }
  }
  {
#line 315
  tmp___2 = strncasecmp((char const   *)state, "lnr", (size_t )3);
  }
#line 315
  if (0 != tmp___2) {
    {
#line 315
    tmp___3 = strncasecmp((char const   *)state, "lcr", (size_t )3);
    }
#line 315
    if (0 != tmp___3) {
      {
#line 315
      tmp___4 = strncasecmp((char const   *)state, "lnc", (size_t )3);
      }
#line 315
      if (0 != tmp___4) {
        {
#line 315
        tmp___5 = strncasecmp((char const   *)state, "unc", (size_t )3);
        }
#line 315
        if (0 != tmp___5) {
          {
#line 315
          tmp___6 = strncasecmp((char const   *)state, "ucr", (size_t )3);
          }
#line 315
          if (0 != tmp___6) {
            {
#line 315
            tmp___7 = strncasecmp((char const   *)state, "unr", (size_t )3);
            }
#line 315
            if (0 != tmp___7) {
              {
#line 322
              lprintf(3, "Invalid threshold identifier %s", state);
              }
#line 323
              return (-1);
            }
          }
        }
      }
    }
  }
#line 326
  if ((int )*(state + 0) == 117) {
#line 327
    hilo = 1;
  } else {
#line 329
    hilo = 0;
  }
#line 331
  if ((int )emsg.event_dir == 0) {
#line 332
    dir = hilo;
  } else {
#line 334
    dir = ! hilo;
  }
#line 336
  if ((int )emsg.event_dir == 0) {
#line 336
    if (hilo == 1) {
      {
#line 338
      tmp___8 = str2val((char const   *)state, ipmi_event_thresh_hi___0);
#line 338
      emsg.event_data[0] = (uint8_t )((int )tmp___8 & 15);
      }
    } else {
#line 336
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 336
  if ((int )emsg.event_dir == 1) {
#line 336
    if (hilo == 0) {
      {
#line 338
      tmp___8 = str2val((char const   *)state, ipmi_event_thresh_hi___0);
#line 338
      emsg.event_data[0] = (uint8_t )((int )tmp___8 & 15);
      }
    } else {
#line 336
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 339
  if ((int )emsg.event_dir == 0) {
#line 339
    if (hilo == 0) {
      {
#line 341
      tmp___9 = str2val((char const   *)state, ipmi_event_thresh_lo___0);
#line 341
      emsg.event_data[0] = (uint8_t )((int )tmp___9 & 15);
      }
    } else {
#line 339
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 339
  if ((int )emsg.event_dir == 1) {
#line 339
    if (hilo == 1) {
      {
#line 341
      tmp___9 = str2val((char const   *)state, ipmi_event_thresh_lo___0);
#line 341
      emsg.event_data[0] = (uint8_t )((int )tmp___9 & 15);
      }
    } else {
      {
#line 343
      lprintf(3, "Invalid Event");
      }
#line 344
      return (-1);
    }
  } else {
    {
#line 343
    lprintf(3, "Invalid Event");
    }
#line 344
    return (-1);
  }
  {
#line 347
  rsp = ipmi_sdr_get_sensor_thresholds(intf, emsg.sensor_num, target, lun, channel);
  }
#line 349
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 350
    lprintf(3, "Command Get Sensor Thresholds failed: invalid response.");
    }
#line 352
    return (-1);
  } else
#line 353
  if ((int )rsp->ccode != 0) {
    {
#line 354
    tmp___10 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 354
    lprintf(3, "Command Get Sensor Thresholds failed: %s", tmp___10);
    }
#line 356
    return (-1);
  }
  {
#line 360
  emsg.event_data[2] = rsp->data[(int )emsg.event_data[0] / 2 + 1];
#line 362
  rsp = ipmi_sdr_get_sensor_hysteresis(intf, emsg.sensor_num, target, lun, channel);
  }
#line 364
  if ((unsigned long )rsp != (unsigned long )((void *)0)) {
#line 364
    if ((int )rsp->ccode == 0) {
#line 365
      if (dir) {
#line 365
        off = (int )rsp->data[0];
      } else {
#line 365
        off = (int )rsp->data[1];
      }
    }
  }
#line 366
  if (off <= 0) {
#line 367
    off = 1;
  }
#line 370
  if (dir) {
#line 371
    if ((int )emsg.event_data[2] + off > 255) {
#line 372
      emsg.event_data[1] = (uint8_t )255;
    } else {
#line 374
      emsg.event_data[1] = (uint8_t )((int )emsg.event_data[2] + off);
    }
  } else
#line 377
  if ((int )emsg.event_data[2] - off < 0) {
#line 378
    emsg.event_data[1] = (uint8_t )0;
  } else {
#line 380
    emsg.event_data[1] = (uint8_t )((int )emsg.event_data[2] - off);
  }
#line 384
  emsg.event_data[0] = (uint8_t )((int )emsg.event_data[0] | 80);
#line 386
  goto switch_break___0;
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 394
  digi_on[0] = "present";
#line 394
  digi_on[1] = "assert";
#line 394
  digi_on[2] = "limit";
#line 394
  digi_on[3] = "fail";
#line 394
  digi_on[4] = "yes";
#line 394
  digi_on[5] = "on";
#line 394
  digi_on[6] = "up";
#line 396
  digi_off[0] = "absent";
#line 396
  digi_off[1] = "deassert";
#line 396
  digi_off[2] = "nolimit";
#line 396
  digi_off[3] = "nofail";
#line 396
  digi_off[4] = "no";
#line 396
  digi_off[5] = "off";
#line 396
  digi_off[6] = "down";
#line 401
  if ((unsigned long )state == (unsigned long )((void *)0)) {
#line 401
    goto _L___3;
  } else {
    {
#line 401
    tmp___11 = strncasecmp((char const   *)state, "list", (size_t )4);
    }
#line 401
    if (tmp___11 == 0) {
      _L___3: /* CIL Label */ 
      {
#line 402
      print_sensor_states___0(emsg.sensor_type, emsg.event_type);
#line 403
      printf((char const   */* __restrict  */)"Sensor State Shortcuts:\n");
#line 404
      x = 0;
      }
      {
#line 404
      while (1) {
        while_continue: /* CIL Label */ ;
#line 404
        if (! ((unsigned long )x < sizeof(digi_on) / sizeof(digi_on[0]))) {
#line 404
          goto while_break;
        }
        {
#line 405
        printf((char const   */* __restrict  */)"  %-9s  %-9s\n", digi_on[x], digi_off[x]);
#line 404
        x ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 407
      return (0);
    }
  }
#line 410
  off = 0;
#line 411
  x = 0;
  {
#line 411
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 411
    if (! ((unsigned long )x < sizeof(digi_on) / sizeof(digi_on[0]))) {
#line 411
      goto while_break___0;
    }
    {
#line 412
    tmp___14 = strlen(digi_on[x]);
#line 412
    tmp___15 = strncasecmp((char const   *)state, digi_on[x], tmp___14);
    }
#line 412
    if (tmp___15 == 0) {
#line 413
      emsg.event_data[0] = (uint8_t )1;
#line 414
      off = 1;
#line 415
      goto while_break___0;
    } else {
      {
#line 417
      tmp___12 = strlen(digi_off[x]);
#line 417
      tmp___13 = strncasecmp((char const   *)state, digi_off[x], tmp___12);
      }
#line 417
      if (tmp___13 == 0) {
#line 418
        emsg.event_data[0] = (uint8_t )0;
#line 419
        off = 1;
#line 420
        goto while_break___0;
      }
    }
#line 411
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 423
  if (off == 0) {
    {
#line 424
    off = ipmi_event_find_offset___0(emsg.event_type, generic_event_types___0, state);
    }
#line 426
    if (off < 0) {
#line 427
      return (-1);
    }
#line 428
    emsg.event_data[0] = (uint8_t )off;
  }
#line 431
  goto switch_break___0;
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
#line 441
  if ((unsigned long )state == (unsigned long )((void *)0)) {
    {
#line 442
    print_sensor_states___0(emsg.sensor_type, emsg.event_type);
    }
#line 443
    return (0);
  } else {
    {
#line 441
    tmp___16 = strncasecmp((char const   *)state, "list", (size_t )4);
    }
#line 441
    if (tmp___16 == 0) {
      {
#line 442
      print_sensor_states___0(emsg.sensor_type, emsg.event_type);
      }
#line 443
      return (0);
    }
  }
  {
#line 445
  off = ipmi_event_find_offset___0(emsg.event_type, generic_event_types___0, state);
  }
#line 447
  if (off < 0) {
#line 448
    return (-1);
  }
#line 449
  emsg.event_data[0] = (uint8_t )off;
#line 451
  goto switch_break___0;
  case_111: /* CIL Label */ 
#line 461
  if ((unsigned long )state == (unsigned long )((void *)0)) {
    {
#line 462
    print_sensor_states___0(emsg.sensor_type, emsg.event_type);
    }
#line 463
    return (0);
  } else {
    {
#line 461
    tmp___17 = strncasecmp((char const   *)state, "list", (size_t )4);
    }
#line 461
    if (tmp___17 == 0) {
      {
#line 462
      print_sensor_states___0(emsg.sensor_type, emsg.event_type);
      }
#line 463
      return (0);
    }
  }
  {
#line 465
  off = ipmi_event_find_offset___0(emsg.sensor_type, sensor_specific_types___0, state);
  }
#line 467
  if (off < 0) {
#line 468
    return (-1);
  }
#line 469
  emsg.event_data[0] = (uint8_t )off;
#line 471
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 474
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 478
  tmp___18 = ipmi_send_platform_event___0(intf, & emsg);
  }
#line 478
  return (tmp___18);
}
}
#line 481 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_event.c"
static int ipmi_event_fromfile___0(struct ipmi_intf *intf , char *file ) 
{ 
  FILE *fp ;
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct sel_event_record sel_event ;
  uint8_t rqdata[8] ;
  char buf[1024] ;
  char *ptr ;
  char *tok ;
  int i ;
  int j ;
  uint8_t chmed ;
  int rc ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  int tmp___16 ;

  {
#line 493
  rc = 0;
#line 495
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 496
    return (-1);
  }
  {
#line 498
  memset((void *)(rqdata), 0, (size_t )8);
#line 501
  memset((void *)(& req), 0, sizeof(req));
#line 502
  req.msg.netfn = (uint8_t )4;
#line 503
  req.msg.cmd = (uint8_t )2;
#line 504
  req.msg.data = rqdata;
#line 505
  req.msg.data_len = (uint16_t )7;
#line 507
  chmed = ipmi_current_channel_medium(intf);
  }
#line 508
  if ((int )chmed == 12) {
#line 510
    rqdata[0] = (uint8_t )65;
#line 511
    req.msg.data_len = (uint16_t )8;
  }
  {
#line 514
  fp = ipmi_open_file((char const   *)file, 0);
  }
#line 515
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 516
    return (-1);
  }
  {
#line 518
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 518
    tmp___16 = feof(fp);
    }
#line 518
    if (! (tmp___16 == 0)) {
#line 518
      goto while_break;
    }
    {
#line 519
    tmp = fgets((char */* __restrict  */)(buf), 1024, (FILE */* __restrict  */)fp);
    }
#line 519
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 520
      goto while_continue;
    }
    {
#line 523
    ptr = strchr((char const   *)(buf), '#');
    }
#line 524
    if (ptr) {
#line 525
      *ptr = (char )'\000';
    } else {
      {
#line 527
      tmp___0 = strlen((char const   *)(buf));
#line 527
      ptr = buf + tmp___0;
      }
    }
#line 530
    ptr --;
    {
#line 531
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 531
      tmp___2 = __ctype_b_loc();
      }
#line 531
      if ((int const   )*(*tmp___2 + (int )*ptr) & 8192) {
#line 531
        if (! ((unsigned long )ptr >= (unsigned long )(buf))) {
#line 531
          goto while_break___0;
        }
      } else {
#line 531
        goto while_break___0;
      }
#line 532
      tmp___1 = ptr;
#line 532
      ptr --;
#line 532
      *tmp___1 = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 533
    ptr = buf;
    {
#line 534
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 534
      tmp___3 = __ctype_b_loc();
      }
#line 534
      if (! ((int const   )*(*tmp___3 + (int )*ptr) & 8192)) {
#line 534
        goto while_break___1;
      }
#line 535
      ptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 536
    tmp___4 = strlen((char const   *)ptr);
    }
#line 536
    if (tmp___4 == 0UL) {
#line 537
      goto while_continue;
    }
    {
#line 541
    i = 0;
#line 542
    tok = strtok((char */* __restrict  */)ptr, (char const   */* __restrict  */)" ");
    }
    {
#line 543
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 543
      if (! tok) {
#line 543
        goto while_break___2;
      }
#line 544
      if (i == 7) {
#line 545
        goto while_break___2;
      }
#line 546
      tmp___5 = i;
#line 546
      i ++;
#line 546
      j = tmp___5;
#line 547
      if ((int )chmed == 12) {
#line 548
        j ++;
      }
      {
#line 549
      tmp___6 = strtol((char const   */* __restrict  */)tok, (char **/* __restrict  */)((void *)0),
                       0);
#line 549
      rqdata[j] = (uint8_t )tmp___6;
#line 550
      tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 552
    if (i < 7) {
      {
#line 553
      tmp___7 = buf2str(rqdata, (int )sizeof(rqdata));
#line 553
      lprintf(3, "Invalid Event: %s", tmp___7);
      }
#line 555
      goto while_continue;
    }
    {
#line 558
    memset((void *)(& sel_event), 0, sizeof(struct sel_event_record ));
#line 559
    sel_event.record_id = (uint16_t )0;
#line 560
    sel_event.sel_type.standard_type.gen_id = (uint16_t )2;
    }
#line 562
    if ((int )chmed == 12) {
#line 562
      j = 1;
    } else {
#line 562
      j = 0;
    }
    {
#line 563
    tmp___8 = j;
#line 563
    j ++;
#line 563
    sel_event.sel_type.standard_type.evm_rev = rqdata[tmp___8];
#line 564
    tmp___9 = j;
#line 564
    j ++;
#line 564
    sel_event.sel_type.standard_type.sensor_type = rqdata[tmp___9];
#line 565
    tmp___10 = j;
#line 565
    j ++;
#line 565
    sel_event.sel_type.standard_type.sensor_num = rqdata[tmp___10];
#line 566
    sel_event.sel_type.standard_type.event_type = (uint8_t )((int )rqdata[j] & 127);
#line 567
    tmp___11 = j;
#line 567
    j ++;
#line 567
    sel_event.sel_type.standard_type.event_dir = (uint8_t )(((int )rqdata[tmp___11] & 128) >> 7);
#line 568
    tmp___12 = j;
#line 568
    j ++;
#line 568
    sel_event.sel_type.standard_type.event_data[0] = rqdata[tmp___12];
#line 569
    tmp___13 = j;
#line 569
    j ++;
#line 569
    sel_event.sel_type.standard_type.event_data[1] = rqdata[tmp___13];
#line 570
    tmp___14 = j;
#line 570
    j ++;
#line 570
    sel_event.sel_type.standard_type.event_data[2] = rqdata[tmp___14];
#line 572
    ipmi_sel_print_std_entry(intf, & sel_event);
#line 574
    rsp = (*(intf->sendrecv))(intf, & req);
    }
#line 575
    if ((unsigned long )rsp == (unsigned long )((void *)0)) {
      {
#line 576
      lprintf(3, "Platform Event Message command failed");
#line 577
      rc = -1;
      }
    } else
#line 579
    if ((int )rsp->ccode > 0) {
      {
#line 580
      tmp___15 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 580
      lprintf(3, "Platform Event Message command failed: %s", tmp___15);
#line 582
      rc = -1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 586
  fclose(fp);
  }
#line 587
  return (rc);
}
}
#line 590 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_event.c"
static void ipmi_event_usage___0(void) 
{ 


  {
  {
#line 593
  lprintf(5, "");
#line 594
  lprintf(5, "usage: event <num>");
#line 595
  lprintf(5, "   Send generic test events");
#line 596
  lprintf(5, "   1 : Temperature - Upper Critical - Going High");
#line 597
  lprintf(5, "   2 : Voltage Threshold - Lower Critical - Going Low");
#line 598
  lprintf(5, "   3 : Memory - Correctable ECC");
#line 599
  lprintf(5, "");
#line 600
  lprintf(5, "usage: event file <filename>");
#line 601
  lprintf(5, "   Read and generate events from file");
#line 602
  lprintf(5, "   Use the \'sel save\' command to generate from SEL");
#line 603
  lprintf(5, "");
#line 604
  lprintf(5, "usage: event <sensorid> <state> [event_dir]");
#line 605
  lprintf(5, "   sensorid  : Sensor ID string to use for event data");
#line 606
  lprintf(5, "   state     : Sensor state, use \'list\' to see possible states for sensor");
#line 607
  lprintf(5, "   event_dir : assert, deassert [default=assert]");
#line 608
  lprintf(5, "");
  }
#line 609
  return;
}
}
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 259 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 55 "../include/ipmitool/log.h"
extern void log_init(char const   *name , int isdaemon , int verbose ) ;
#line 56
extern void log_halt(void) ;
#line 882 "../include/ipmitool/ipmi_sdr.h"
extern char const   *ipmi_sdr_get_unit_string(uint8_t pct , uint8_t type , uint8_t base ,
                                              uint8_t modifier ) ;
#line 930
extern struct sdr_record_list *ipmi_sdr_find_sdr_bynumtype(struct ipmi_intf *intf ,
                                                           uint16_t gen_id , uint8_t num ,
                                                           uint8_t type ) ;
#line 938
extern int ipmi_sdr_list_cache(struct ipmi_intf *intf ) ;
#line 684 "../include/ipmitool/ipmi_sel.h"
extern void ipmi_get_event_desc(struct ipmi_intf *intf , struct sel_event_record *rec ,
                                char **desc ) ;
#line 686
extern char const   *ipmi_sel_get_sensor_type_offset(uint8_t code , uint8_t offset ) ;
#line 687
extern uint16_t ipmi_sel_get_std_entry(struct ipmi_intf *intf , uint16_t id , struct sel_event_record *evt ) ;
#line 86 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
char pidfile[64]  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
uint16_t selwatch_count  =    (uint16_t )0;
#line 92 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
uint16_t selwatch_lastid  =    (uint16_t )0;
#line 93 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
int selwatch_pctused  =    0;
#line 94 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
int selwatch_overflow  =    0;
#line 95 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
int selwatch_timeout  =    10;
#line 117
static void log_event(struct ipmi_event_intf *eintf , struct sel_event_record *evt ) ;
#line 121
static int openipmi_setup(struct ipmi_event_intf *eintf ) ;
#line 122
static int openipmi_wait(struct ipmi_event_intf *eintf ) ;
#line 123
static int openipmi_read(struct ipmi_event_intf *eintf ) ;
#line 124 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
static struct ipmi_event_intf openipmi_event_intf  = 
#line 124
     {{(char )'o', (char )'p', (char )'e', (char )'n', (char )'\000'}, {(char )'O',
                                                                      (char )'p',
                                                                      (char )'e',
                                                                      (char )'n',
                                                                      (char )'I',
                                                                      (char )'P',
                                                                      (char )'M',
                                                                      (char )'I',
                                                                      (char )' ',
                                                                      (char )'a',
                                                                      (char )'s',
                                                                      (char )'y',
                                                                      (char )'n',
                                                                      (char )'c',
                                                                      (char )'r',
                                                                      (char )'o',
                                                                      (char )'n',
                                                                      (char )'o',
                                                                      (char )'u',
                                                                      (char )'s',
                                                                      (char )' ',
                                                                      (char )'n',
                                                                      (char )'o',
                                                                      (char )'t',
                                                                      (char )'i',
                                                                      (char )'f',
                                                                      (char )'i',
                                                                      (char )'c',
                                                                      (char )'a',
                                                                      (char )'t',
                                                                      (char )'i',
                                                                      (char )'o',
                                                                      (char )'n',
                                                                      (char )' ',
                                                                      (char )'o',
                                                                      (char )'f',
                                                                      (char )' ',
                                                                      (char )'e',
                                                                      (char )'v',
                                                                      (char )'e',
                                                                      (char )'n',
                                                                      (char )'t',
                                                                      (char )'s',
                                                                      (char )'\000'},
    {(char )'\000'}, & openipmi_setup, & openipmi_wait, & openipmi_read, (int (*)(struct ipmi_event_intf *eintf ))0,
    & log_event, (struct ipmi_intf *)0};
#line 137
static int selwatch_setup(struct ipmi_event_intf *eintf ) ;
#line 138
static int selwatch_wait(struct ipmi_event_intf *eintf ) ;
#line 139
static int selwatch_read(struct ipmi_event_intf *eintf ) ;
#line 140
static int selwatch_check(struct ipmi_event_intf *eintf ) ;
#line 141 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
static struct ipmi_event_intf selwatch_event_intf  = 
#line 141
     {{(char )'s', (char )'e', (char )'l', (char )'\000'}, {(char )'P', (char )'o',
                                                          (char )'l', (char )'l',
                                                          (char )' ', (char )'S',
                                                          (char )'E', (char )'L',
                                                          (char )' ', (char )'f',
                                                          (char )'o', (char )'r',
                                                          (char )' ', (char )'n',
                                                          (char )'o', (char )'t',
                                                          (char )'i', (char )'f',
                                                          (char )'i', (char )'c',
                                                          (char )'a', (char )'t',
                                                          (char )'i', (char )'o',
                                                          (char )'n', (char )' ',
                                                          (char )'o', (char )'f',
                                                          (char )' ', (char )'e',
                                                          (char )'v', (char )'e',
                                                          (char )'n', (char )'t',
                                                          (char )'s', (char )'\000'},
    {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
     (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
     (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
     (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
     (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
     (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
     (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
     (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0},
    & selwatch_setup, & selwatch_wait, & selwatch_read, & selwatch_check, & log_event,
    (struct ipmi_intf *)0};
#line 152 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
struct ipmi_event_intf *ipmi_event_intf_table[3]  = {      & openipmi_event_intf,      & selwatch_event_intf,      (struct ipmi_event_intf *)((void *)0)};
#line 162 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
static void ipmievd_usage(void) 
{ 


  {
  {
#line 165
  lprintf(5, "Options:");
#line 166
  lprintf(5, "\ttimeout=#     Time between checks for SEL polling method [default=10]");
#line 167
  lprintf(5, "\tdaemon        Become a daemon [default]");
#line 168
  lprintf(5, "\tnodaemon      Do NOT become a daemon");
  }
#line 169
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
static struct ipmi_event_intf *ipmi_event_intf_load(char *name ) 
{ 
  struct ipmi_event_intf **intf ;
  struct ipmi_event_intf *i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 185
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 186
    i = ipmi_event_intf_table[0];
#line 187
    return (i);
  }
#line 190
  intf = ipmi_event_intf_table;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if ((unsigned long )intf != (unsigned long )((void *)0)) {
#line 190
      if (! ((unsigned long )*intf != (unsigned long )((void *)0))) {
#line 190
        goto while_break;
      }
    } else {
#line 190
      goto while_break;
    }
    {
#line 193
    i = *intf;
#line 194
    tmp = strlen((char const   *)name);
#line 194
    tmp___0 = strncmp((char const   *)name, (char const   *)(i->name), tmp);
    }
#line 194
    if (tmp___0 == 0) {
#line 195
      return (i);
    }
#line 190
    intf ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  return ((struct ipmi_event_intf *)((void *)0));
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
static int compute_pctfull(uint16_t entries , uint16_t freespace ) 
{ 
  int pctfull ;

  {
#line 205
  pctfull = 0;
#line 207
  if (entries) {
#line 208
    entries = (uint16_t )((int )entries * 16);
#line 209
    freespace = (uint16_t )((int )freespace + (int )entries);
#line 210
    pctfull = (int )((double )100 * ((double )entries / (double )freespace));
  }
#line 212
  return (pctfull);
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
static void log_event(struct ipmi_event_intf *eintf , struct sel_event_record *evt ) 
{ 
  char *desc ;
  char const   *type ;
  struct sdr_record_list *sdr ;
  struct ipmi_intf *intf ;
  float trigger_reading ;
  float threshold_reading ;
  double tmp ;
  double tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;

  {
#line 222
  intf = eintf->intf;
#line 223
  trigger_reading = (float )0.0;
#line 224
  threshold_reading = (float )0.0;
#line 226
  if ((unsigned long )evt == (unsigned long )((void *)0)) {
#line 227
    return;
  }
#line 229
  if ((int )evt->record_type == 240) {
    {
#line 230
    lprintf(1, "%sLinux kernel panic: %.11s", eintf->prefix, (char *)evt + 5);
    }
#line 232
    return;
  } else
#line 234
  if ((int )evt->record_type >= 192) {
    {
#line 235
    lprintf(5, "%sIPMI Event OEM Record %02x", eintf->prefix, (int )evt->record_type);
    }
#line 237
    return;
  }
  {
#line 240
  type = ipmi_sel_get_sensor_type_offset(evt->sel_type.standard_type.sensor_type,
                                         evt->sel_type.standard_type.event_data[0]);
#line 243
  ipmi_get_event_desc(intf, evt, & desc);
#line 245
  sdr = ipmi_sdr_find_sdr_bynumtype(intf, evt->sel_type.standard_type.gen_id, evt->sel_type.standard_type.sensor_num,
                                    evt->sel_type.standard_type.sensor_type);
  }
#line 248
  if ((unsigned long )sdr == (unsigned long )((void *)0)) {
#line 250
    if (desc) {
      {
#line 251
      lprintf(5, "%s%s sensor - %s", eintf->prefix, type, desc);
#line 253
      free((void *)desc);
#line 254
      desc = (char *)((void *)0);
      }
    } else {
      {
#line 256
      lprintf(5, "%s%s sensor %02x", eintf->prefix, type, (int )evt->sel_type.standard_type.sensor_num);
      }
    }
#line 260
    return;
  }
  {
#line 264
  if ((int )sdr->type == 1) {
#line 264
    goto case_1;
  }
#line 325
  if ((int )sdr->type == 2) {
#line 325
    goto case_2;
  }
#line 333
  goto switch_default;
  case_1: /* CIL Label */ 
#line 265
  if ((int )evt->sel_type.standard_type.event_type == 1) {
#line 271
    if ((((int )evt->sel_type.standard_type.event_data[0] >> 6) & 3) == 1) {
      {
#line 272
      tmp = sdr_convert_sensor_reading(sdr->record.full, evt->sel_type.standard_type.event_data[1]);
#line 272
      trigger_reading = (float )tmp;
      }
    }
#line 277
    if ((((int )evt->sel_type.standard_type.event_data[0] >> 4) & 3) == 1) {
      {
#line 278
      tmp___0 = sdr_convert_sensor_reading(sdr->record.full, evt->sel_type.standard_type.event_data[2]);
#line 278
      threshold_reading = (float )tmp___0;
      }
    }
    {
#line 282
    tmp___1 = ipmi_sdr_get_unit_string((sdr->record.common)->unit.pct, (sdr->record.common)->unit.modifier,
                                       (sdr->record.common)->unit.type.base, (sdr->record.common)->unit.type.modifier);
    }
#line 282
    if (threshold_reading == (float )((int )threshold_reading)) {
#line 282
      tmp___2 = 0;
    } else {
#line 282
      tmp___2 = 2;
    }
#line 282
    if (((int )evt->sel_type.standard_type.event_data[0] & 15) % 2) {
#line 282
      tmp___3 = ">";
    } else {
#line 282
      tmp___3 = "<";
    }
#line 282
    if (trigger_reading == (float )((int )trigger_reading)) {
#line 282
      tmp___4 = 0;
    } else {
#line 282
      tmp___4 = 2;
    }
#line 282
    if (evt->sel_type.standard_type.event_dir) {
#line 282
      tmp___5 = "Deasserted";
    } else {
#line 282
      tmp___5 = "Asserted";
    }
#line 282
    tmp___6 = (char const   *)desc;
#line 282
    if (! tmp___6) {
#line 282
      tmp___6 = "";
    }
    {
#line 282
    lprintf(5, "%s%s sensor %s %s %s (Reading %.*f %s Threshold %.*f %s)", eintf->prefix,
            type, (sdr->record.full)->id_string, tmp___6, tmp___5, tmp___4, (double )trigger_reading,
            tmp___3, tmp___2, (double )threshold_reading, tmp___1);
    }
  } else
#line 299
  if ((int )evt->sel_type.standard_type.event_type >= 2) {
#line 299
    if ((int )evt->sel_type.standard_type.event_type <= 12) {
#line 299
      goto _L;
    } else {
#line 299
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 299
  if ((int )evt->sel_type.standard_type.event_type == 111) {
    _L: /* CIL Label */ 
#line 304
    if (evt->sel_type.standard_type.event_dir) {
#line 304
      tmp___7 = "Deasserted";
    } else {
#line 304
      tmp___7 = "Asserted";
    }
#line 304
    tmp___8 = (char const   *)desc;
#line 304
    if (! tmp___8) {
#line 304
      tmp___8 = "";
    }
    {
#line 304
    lprintf(5, "%s%s sensor %s %s %s", eintf->prefix, type, (sdr->record.full)->id_string,
            tmp___8, tmp___7);
    }
  } else
#line 313
  if ((int )evt->sel_type.standard_type.event_type >= 112) {
#line 313
    if ((int )evt->sel_type.standard_type.event_type <= 127) {
#line 317
      if (evt->sel_type.standard_type.event_dir) {
#line 317
        tmp___9 = "Deasserted";
      } else {
#line 317
        tmp___9 = "Asserted";
      }
#line 317
      tmp___10 = (char const   *)desc;
#line 317
      if (! tmp___10) {
#line 317
        tmp___10 = "";
      }
      {
#line 317
      lprintf(5, "%s%s sensor %s %s %s", eintf->prefix, type, (sdr->record.full)->id_string,
              tmp___10, tmp___9);
      }
    }
  }
#line 323
  goto switch_break;
  case_2: /* CIL Label */ 
#line 326
  if (evt->sel_type.standard_type.event_dir) {
#line 326
    tmp___11 = "Deasserted";
  } else {
#line 326
    tmp___11 = "Asserted";
  }
#line 326
  tmp___12 = (char const   *)desc;
#line 326
  if (! tmp___12) {
#line 326
    tmp___12 = "";
  }
  {
#line 326
  lprintf(5, "%s%s sensor %s - %s %s", eintf->prefix, type, (sdr->record.compact)->id_string,
          tmp___12, tmp___11);
  }
#line 331
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 334
  tmp___13 = (char const   *)desc;
#line 334
  if (! tmp___13) {
#line 334
    tmp___13 = "";
  }
  {
#line 334
  lprintf(5, "%s%s sensor - %s", eintf->prefix, type, (int )evt->sel_type.standard_type.sensor_num,
          tmp___13);
  }
#line 337
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 340
  if (desc) {
    {
#line 341
    free((void *)desc);
#line 342
    desc = (char *)((void *)0);
    }
  }
#line 344
  return;
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
static int openipmi_enable_event_msg_buffer(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t bmc_global_enables ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 360
  memset((void *)(& req), 0, sizeof(req));
#line 361
  req.msg.netfn = (uint8_t )6;
#line 362
  req.msg.cmd = (uint8_t )47;
#line 364
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 365
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 366
    lprintf(3, "Get BMC Global Enables command failed");
    }
#line 367
    return (-1);
  } else
#line 369
  if ((int )rsp->ccode > 0) {
    {
#line 370
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 370
    lprintf(3, "Get BMC Global Enables command failed: %s", tmp);
    }
#line 372
    return (-1);
  }
  {
#line 375
  bmc_global_enables = (uint8_t )((int )rsp->data[0] | 4);
#line 376
  req.msg.cmd = (uint8_t )46;
#line 377
  req.msg.data = & bmc_global_enables;
#line 378
  req.msg.data_len = (uint16_t )1;
#line 380
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 381
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 382
    lprintf(3, "Set BMC Global Enables command failed");
    }
#line 383
    return (-1);
  } else
#line 385
  if ((int )rsp->ccode > 0) {
    {
#line 386
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 386
    lprintf(3, "Set BMC Global Enables command failed: %s", tmp___0);
    }
#line 388
    return (-1);
  }
  {
#line 391
  lprintf(7, "BMC Event Message Buffer enabled");
  }
#line 393
  return (0);
}
}
#line 396 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
static int openipmi_setup(struct ipmi_event_intf *eintf ) 
{ 
  int i ;
  int r ;

  {
  {
#line 402
  lprintf(7, "Enabling event message buffer");
#line 403
  r = openipmi_enable_event_msg_buffer(eintf->intf);
  }
#line 404
  if (r < 0) {
    {
#line 405
    lprintf(3, "Could not enable event message buffer");
    }
#line 406
    return (-1);
  }
  {
#line 410
  lprintf(7, "Enabling event receiver");
#line 411
  i = 1;
#line 412
  r = ioctl((eintf->intf)->fd, (unsigned long )(((2U << 30) | (unsigned int )(105 << 8)) | 16U) | (sizeof(int ) << 16),
            & i);
  }
#line 413
  if (r != 0) {
    {
#line 414
    lperror(3, "Could not enable event receiver");
    }
#line 415
    return (-1);
  }
#line 418
  return (0);
}
}
#line 421 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
static int openipmi_read(struct ipmi_event_intf *eintf ) 
{ 
  struct ipmi_addr addr ;
  struct ipmi_recv recv___0 ;
  uint8_t data[80] ;
  int rv ;
  int *tmp ;

  {
  {
#line 429
  recv___0.addr = (unsigned char *)(& addr);
#line 430
  recv___0.addr_len = (unsigned int )sizeof(addr);
#line 431
  recv___0.msg.data = data;
#line 432
  recv___0.msg.data_len = (unsigned short )sizeof(data);
#line 434
  rv = ioctl((eintf->intf)->fd, (unsigned long )(((3U << 30) | (unsigned int )(105 << 8)) | 11U) | (sizeof(struct ipmi_recv ) << 16),
             & recv___0);
  }
#line 435
  if (rv < 0) {
    {
#line 436
    tmp = __errno_location();
    }
    {
#line 437
    if (*tmp == 4) {
#line 437
      goto case_4;
    }
#line 439
    if (*tmp == 90) {
#line 439
      goto case_90;
    }
#line 442
    goto switch_default;
    case_4: /* CIL Label */ 
#line 438
    return (0);
    case_90: /* CIL Label */ 
#line 440
    recv___0.msg.data_len = (unsigned short )sizeof(data);
#line 441
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 443
    lperror(3, "Unable to receive IPMI message");
    }
#line 444
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
#line 448
  if (! recv___0.msg.data) {
    {
#line 449
    lprintf(3, "No data in event");
    }
#line 450
    return (-1);
  } else
#line 448
  if ((int )recv___0.msg.data_len == 0) {
    {
#line 449
    lprintf(3, "No data in event");
    }
#line 450
    return (-1);
  }
#line 452
  if (recv___0.recv_type != 2) {
    {
#line 453
    lprintf(3, "Type %x is not an event", recv___0.recv_type);
    }
#line 454
    return (-1);
  }
  {
#line 457
  lprintf(7, "netfn:%x cmd:%x ccode:%d", (int )recv___0.msg.netfn, (int )recv___0.msg.cmd,
          (int )*(recv___0.msg.data + 0));
#line 460
  (*(eintf->log))(eintf, (struct sel_event_record *)recv___0.msg.data);
  }
#line 462
  return (0);
}
}
#line 465 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
static int openipmi_wait(struct ipmi_event_intf *eintf ) 
{ 
  struct pollfd pfd ;
  int r ;

  {
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 472
    pfd.fd = (eintf->intf)->fd;
#line 473
    pfd.events = (short)1;
#line 474
    r = poll(& pfd, (nfds_t )1, -1);
    }
    {
#line 477
    if (r == 0) {
#line 477
      goto case_0;
    }
#line 480
    if (r == -1) {
#line 480
      goto case_neg_1;
    }
#line 483
    goto switch_default;
    case_0: /* CIL Label */ 
#line 479
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 481
    lperror(2, "Unable to read from IPMI device");
    }
#line 482
    return (-1);
    switch_default: /* CIL Label */ 
#line 484
    if ((int )pfd.revents & 1) {
      {
#line 485
      (*(eintf->read))(eintf);
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 489
  return (0);
}
}
#line 498 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
static int selwatch_get_data(struct ipmi_intf *intf , struct sel_data *data ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint16_t freespace ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 505
  memset((void *)(& req), 0, sizeof(req));
#line 506
  req.msg.netfn = (uint8_t )10;
#line 507
  req.msg.cmd = (uint8_t )64;
#line 509
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 510
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 511
    lprintf(3, "Get SEL Info command failed");
    }
#line 512
    return (0);
  }
#line 514
  if ((int )rsp->ccode > 0) {
    {
#line 515
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 515
    lprintf(3, "Get SEL Info command failed: %s", tmp);
    }
#line 517
    return (0);
  }
  {
#line 520
  freespace = buf2short(rsp->data + 3);
#line 521
  data->entries = buf2short(rsp->data + 1);
#line 522
  data->pctused = compute_pctfull(data->entries, freespace);
#line 523
  data->overflow = (int )rsp->data[13] & 128;
#line 525
  lprintf(7, "SEL count is %d", (int )data->entries);
#line 526
  lprintf(7, "SEL freespace is %d", (int )freespace);
#line 527
  lprintf(7, "SEL Percent Used: %d%%\n", data->pctused);
  }
#line 528
  if (data->overflow) {
#line 528
    tmp___0 = "true";
  } else {
#line 528
    tmp___0 = "false";
  }
  {
#line 528
  lprintf(7, "SEL Overflow: %s", tmp___0);
  }
#line 530
  return (1);
}
}
#line 533 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
static uint16_t selwatch_get_lastid(struct ipmi_intf *intf ) 
{ 
  int next_id ;
  uint16_t curr_id ;
  struct sel_event_record evt ;
  uint16_t tmp ;
  uint16_t tmp___0 ;

  {
#line 536
  next_id = 0;
#line 537
  curr_id = (uint16_t )0;
#line 540
  if ((int )selwatch_count == 0) {
#line 541
    return ((uint16_t )0);
  }
  {
#line 543
  while (1) {
    while_continue: /* CIL Label */ ;
#line 543
    if (! (next_id != 65535)) {
#line 543
      goto while_break;
    }
    {
#line 544
    curr_id = (uint16_t )next_id;
#line 545
    lprintf(7, "SEL Next ID: %04x", (int )curr_id);
#line 547
    tmp = ipmi_sel_get_std_entry(intf, curr_id, & evt);
#line 547
    next_id = (int )tmp;
    }
#line 548
    if (next_id < 0) {
#line 549
      goto while_break;
    }
#line 550
    if (next_id == 0) {
      {
#line 556
      tmp___0 = ipmi_sel_get_std_entry(intf, curr_id, & evt);
#line 556
      next_id = (int )tmp___0;
      }
#line 557
      if (next_id <= 0) {
#line 558
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 562
  lprintf(7, "SEL lastid is %04x", (int )curr_id);
  }
#line 564
  return (curr_id);
}
}
#line 567 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
static int selwatch_setup(struct ipmi_event_intf *eintf ) 
{ 
  struct sel_data data ;
  int tmp ;

  {
  {
#line 573
  tmp = selwatch_get_data(eintf->intf, & data);
  }
#line 573
  if (tmp) {
    {
#line 574
    selwatch_count = data.entries;
#line 575
    selwatch_pctused = data.pctused;
#line 576
    selwatch_overflow = data.overflow;
#line 577
    lprintf(7, "Current SEL count is %d", (int )selwatch_count);
#line 579
    selwatch_lastid = selwatch_get_lastid(eintf->intf);
#line 580
    lprintf(7, "Current SEL lastid is %04x", (int )selwatch_lastid);
    }
#line 582
    if (selwatch_pctused >= 80) {
      {
#line 583
      lprintf(4, "SEL buffer used at %d%%, please consider clearing the SEL buffer",
              selwatch_pctused);
      }
    }
#line 585
    if (selwatch_overflow) {
      {
#line 586
      lprintf(1, "SEL buffer overflow, no SEL message can be logged until the SEL buffer is cleared");
      }
    }
#line 589
    return (1);
  }
  {
#line 592
  lprintf(3, "Unable to retrieve SEL data");
  }
#line 593
  return (0);
}
}
#line 601 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
static int selwatch_check(struct ipmi_event_intf *eintf ) 
{ 
  uint16_t old_count ;
  int old_pctused ;
  int old_overflow ;
  struct sel_data data ;
  int tmp ;

  {
  {
#line 604
  old_count = selwatch_count;
#line 605
  old_pctused = selwatch_pctused;
#line 606
  old_overflow = selwatch_overflow;
#line 609
  tmp = selwatch_get_data(eintf->intf, & data);
  }
#line 609
  if (tmp) {
#line 610
    selwatch_count = data.entries;
#line 611
    selwatch_pctused = data.pctused;
#line 612
    selwatch_overflow = data.overflow;
#line 613
    if (old_overflow) {
#line 613
      if (! selwatch_overflow) {
        {
#line 614
        lprintf(5, "SEL overflow is cleared");
        }
      } else {
#line 613
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 615
    if (! old_overflow) {
#line 615
      if (selwatch_overflow) {
        {
#line 616
        lprintf(1, "SEL buffer overflow, no new SEL message will be logged until the SEL buffer is cleared");
        }
      }
    }
#line 618
    if (selwatch_pctused >= 80) {
#line 618
      if (selwatch_pctused > old_pctused) {
        {
#line 619
        lprintf(4, "SEL buffer is %d%% full, please consider clearing the SEL buffer",
                selwatch_pctused);
        }
      }
    }
#line 621
    if ((int )selwatch_count == 0) {
      {
#line 622
      lprintf(7, "SEL count is 0 (old=%d), resetting lastid to 0", (int )old_count);
#line 623
      selwatch_lastid = (uint16_t )0;
      }
    } else
#line 624
    if ((int )selwatch_count < (int )old_count) {
      {
#line 625
      selwatch_lastid = selwatch_get_lastid(eintf->intf);
#line 626
      lprintf(7, "SEL count lowered, new SEL lastid is %04x", (int )selwatch_lastid);
      }
    }
  }
#line 629
  return ((int )selwatch_count > (int )old_count);
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
static int selwatch_read(struct ipmi_event_intf *eintf ) 
{ 
  uint16_t curr_id ;
  int next_id ;
  struct sel_event_record evt ;
  uint16_t tmp ;
  uint16_t tmp___0 ;

  {
#line 635
  curr_id = (uint16_t )0;
#line 636
  next_id = (int )selwatch_lastid;
#line 639
  if ((int )selwatch_count == 0) {
#line 640
    return (-1);
  }
  {
#line 642
  while (1) {
    while_continue: /* CIL Label */ ;
#line 642
    if (! (next_id != 65535)) {
#line 642
      goto while_break;
    }
    {
#line 643
    curr_id = (uint16_t )next_id;
#line 644
    lprintf(7, "SEL Read ID: %04x", (int )curr_id);
#line 646
    tmp = ipmi_sel_get_std_entry(eintf->intf, curr_id, & evt);
#line 646
    next_id = (int )tmp;
    }
#line 647
    if (next_id < 0) {
#line 648
      goto while_break;
    }
#line 649
    if (next_id == 0) {
      {
#line 655
      tmp___0 = ipmi_sel_get_std_entry(eintf->intf, curr_id, & evt);
#line 655
      next_id = (int )tmp___0;
      }
#line 656
      if (next_id <= 0) {
#line 657
        goto while_break;
      }
    }
#line 660
    if ((int )curr_id != (int )selwatch_lastid) {
      {
#line 661
      (*(eintf->log))(eintf, & evt);
      }
    } else
#line 662
    if ((int )curr_id == 0) {
      {
#line 663
      (*(eintf->log))(eintf, & evt);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 666
  selwatch_lastid = curr_id;
#line 667
  return (0);
}
}
#line 670 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
static int selwatch_wait(struct ipmi_event_intf *eintf ) 
{ 
  int tmp ;

  {
  {
#line 673
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 674
    tmp = (*(eintf->check))(eintf);
    }
#line 674
    if (tmp > 0) {
      {
#line 675
      lprintf(7, "New Events");
#line 676
      (*(eintf->read))(eintf);
      }
    }
    {
#line 678
    sleep((unsigned int )selwatch_timeout);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 680
  return (0);
}
}
#line 684 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
static void ipmievd_cleanup(int signal___0 ) 
{ 
  struct stat st1 ;
  int tmp ;

  {
  {
#line 689
  tmp = lstat((char const   */* __restrict  */)(pidfile), (struct stat */* __restrict  */)(& st1));
  }
#line 689
  if (tmp == 0) {
    {
#line 691
    unlink((char const   *)(pidfile));
    }
  }
  {
#line 694
  exit(0);
  }
}
}
#line 697 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
int ipmievd_main(struct ipmi_event_intf *eintf , int argc , char **argv ) 
{ 
  int i ;
  int rc ;
  int daemon___0 ;
  struct sigaction act ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  FILE *fp ;
  struct stat st1 ;
  int tmp___15 ;
  __pid_t tmp___16 ;

  {
  {
#line 701
  daemon___0 = 1;
#line 704
  memset((void *)(pidfile), 0, (size_t )64);
#line 705
  sprintf((char */* __restrict  */)(pidfile), (char const   */* __restrict  */)"%s%d",
          "/var/run/ipmievd.pid", (int )(eintf->intf)->devnum);
#line 706
  lprintf(5, "ipmievd: using pidfile %s", pidfile);
#line 708
  i = 0;
  }
  {
#line 708
  while (1) {
    while_continue: /* CIL Label */ ;
#line 708
    if (! (i < argc)) {
#line 708
      goto while_break;
    }
    {
#line 709
    tmp = strncasecmp((char const   *)*(argv + i), "help", (size_t )4);
    }
#line 709
    if (tmp == 0) {
      {
#line 710
      ipmievd_usage();
      }
#line 711
      return (0);
    }
    {
#line 713
    tmp___13 = strncasecmp((char const   *)*(argv + i), "daemon", (size_t )6);
    }
#line 713
    if (tmp___13 == 0) {
#line 714
      daemon___0 = 1;
    } else {
      {
#line 716
      tmp___12 = strncasecmp((char const   *)*(argv + i), "nodaemon", (size_t )8);
      }
#line 716
      if (tmp___12 == 0) {
#line 717
        daemon___0 = 0;
      } else {
        {
#line 719
        tmp___11 = strncasecmp((char const   *)*(argv + i), "daemon=", (size_t )7);
        }
#line 719
        if (tmp___11 == 0) {
          {
#line 720
          tmp___2 = strncasecmp((char const   *)(*(argv + i) + 7), "on", (size_t )2);
          }
#line 720
          if (tmp___2 == 0) {
#line 722
            daemon___0 = 1;
          } else {
            {
#line 720
            tmp___3 = strncasecmp((char const   *)(*(argv + i) + 7), "yes", (size_t )3);
            }
#line 720
            if (tmp___3 == 0) {
#line 722
              daemon___0 = 1;
            } else {
              {
#line 723
              tmp___0 = strncasecmp((char const   *)(*(argv + i) + 7), "off", (size_t )3);
              }
#line 723
              if (tmp___0 == 0) {
#line 725
                daemon___0 = 0;
              } else {
                {
#line 723
                tmp___1 = strncasecmp((char const   *)(*(argv + i) + 7), "no", (size_t )2);
                }
#line 723
                if (tmp___1 == 0) {
#line 725
                  daemon___0 = 0;
                }
              }
            }
          }
        } else {
          {
#line 727
          tmp___10 = strncasecmp((char const   *)*(argv + i), "timeout=", (size_t )8);
          }
#line 727
          if (tmp___10 == 0) {
            {
#line 728
            tmp___4 = str2int((char const   *)(*(argv + i) + 8), & selwatch_timeout);
            }
#line 728
            if (tmp___4 != 0) {
              {
#line 730
              lprintf(3, "Invalid input given or out of range for time-out.");
              }
#line 731
              return (-1);
            } else
#line 728
            if (selwatch_timeout < 0) {
              {
#line 730
              lprintf(3, "Invalid input given or out of range for time-out.");
              }
#line 731
              return (-1);
            }
          } else {
            {
#line 734
            tmp___9 = strncasecmp((char const   *)*(argv + i), "pidfile=", (size_t )8);
            }
#line 734
            if (tmp___9 == 0) {
              {
#line 735
              memset((void *)(pidfile), 0, (size_t )64);
#line 736
              tmp___8 = strlen((char const   *)(*(argv + i) + 8));
              }
#line 736
              if (tmp___8 < 63UL) {
                {
#line 736
                tmp___6 = strlen((char const   *)(*(argv + i) + 8));
#line 736
                tmp___7 = tmp___6;
                }
              } else {
#line 736
                tmp___7 = (size_t )63;
              }
              {
#line 736
              strncpy((char */* __restrict  */)(pidfile), (char const   */* __restrict  */)(*(argv + i) + 8),
                      tmp___7);
              }
            }
          }
        }
      }
    }
#line 708
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 746
  tmp___14 = (*((eintf->intf)->open))(eintf->intf);
  }
#line 746
  if (tmp___14 < 0) {
    {
#line 747
    lprintf(3, "Unable to open interface");
    }
#line 748
    return (-1);
  }
#line 751
  if (daemon___0) {
    {
#line 755
    tmp___15 = lstat((char const   */* __restrict  */)(pidfile), (struct stat */* __restrict  */)(& st1));
    }
#line 755
    if (tmp___15 == 0) {
      {
#line 757
      lprintf(3, "PID file \'%s\' already exists.", pidfile);
#line 758
      lprintf(3, "Perhaps another instance is already running.");
      }
#line 759
      return (-1);
    }
    {
#line 762
    ipmi_start_daemon(eintf->intf);
#line 764
    umask((__mode_t )18);
#line 765
    fp = ipmi_open_file((char const   *)(pidfile), 1);
    }
#line 766
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 768
      log_halt();
#line 769
      log_init("ipmievd", daemon___0, verbose);
#line 770
      lprintf(3, "Failed to open PID file \'%s\' for writing. Check file permission.",
              pidfile);
#line 773
      exit(1);
      }
    }
    {
#line 775
    tmp___16 = getpid();
#line 775
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d\n",
            tmp___16);
#line 776
    fclose(fp);
    }
  }
  {
#line 780
  act.__sigaction_handler.sa_handler = & ipmievd_cleanup;
#line 781
  act.sa_flags = 0;
#line 782
  sigemptyset(& act.sa_mask);
#line 783
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 784
  sigaction(3, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 785
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 787
  log_halt();
#line 788
  log_init("ipmievd", daemon___0, verbose);
#line 791
  lprintf(5, "Reading sensors...");
#line 792
  ipmi_sdr_list_cache(eintf->intf);
#line 793
  lprintf(7, "Sensors cached");
  }
#line 797
  if ((unsigned long )eintf->setup != (unsigned long )((void *)0)) {
    {
#line 798
    rc = (*(eintf->setup))(eintf);
    }
#line 799
    if (rc < 0) {
      {
#line 800
      lprintf(3, "Error setting up Event Interface %s", eintf->name);
      }
#line 801
      return (-1);
    }
  }
  {
#line 805
  lprintf(5, "Waiting for events...");
  }
#line 808
  if ((unsigned long )eintf->wait != (unsigned long )((void *)0)) {
    {
#line 809
    rc = (*(eintf->wait))(eintf);
    }
#line 810
    if (rc < 0) {
      {
#line 811
      lprintf(3, "Error waiting for events!");
      }
#line 812
      return (-1);
    }
  }
#line 816
  return (0);
}
}
#line 819 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
int ipmievd_sel_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  struct ipmi_event_intf *eintf ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 824
  eintf = ipmi_event_intf_load((char *)"sel");
  }
#line 825
  if ((unsigned long )eintf == (unsigned long )((void *)0)) {
    {
#line 826
    lprintf(3, "Unable to load event interface");
    }
#line 827
    return (-1);
  }
#line 830
  eintf->intf = intf;
#line 832
  if ((unsigned long )intf->session != (unsigned long )((void *)0)) {
    {
#line 833
    tmp = strlen((char const   *)((intf->session)->hostname));
#line 833
    snprintf((char */* __restrict  */)(eintf->prefix), tmp + 3UL, (char const   */* __restrict  */)"%s: ",
             (intf->session)->hostname);
    }
  }
  {
#line 838
  tmp___0 = ipmievd_main(eintf, argc, argv);
  }
#line 838
  return (tmp___0);
}
}
#line 841 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
int ipmievd_open_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  struct ipmi_event_intf *eintf ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 847
  tmp = strncmp((char const   *)(intf->name), "open", (size_t )4);
  }
#line 847
  if (tmp != 0) {
    {
#line 848
    lprintf(3, "Invalid Interface for OpenIPMI Event Handler: %s", intf->name);
    }
#line 849
    return (-1);
  }
  {
#line 852
  eintf = ipmi_event_intf_load((char *)"open");
  }
#line 853
  if ((unsigned long )eintf == (unsigned long )((void *)0)) {
    {
#line 854
    lprintf(3, "Unable to load event interface");
    }
#line 855
    return (-1);
  }
  {
#line 858
  eintf->intf = intf;
#line 860
  tmp___0 = ipmievd_main(eintf, argc, argv);
  }
#line 860
  return (tmp___0);
}
}
#line 863 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/src/ipmievd.c"
struct ipmi_cmd ipmievd_cmd_list[3]  = {      {& ipmievd_open_main, "open", "Use OpenIPMI for asyncronous notification of events"}, 
        {& ipmievd_sel_main,
      "sel", "Poll SEL for notification of events"}, 
        {(int (*)(struct ipmi_intf *intf , int argc , char **argv ))((void *)0), (char const   *)0,
      (char const   *)0}};
#line 64 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_kontronoem.c"
static void ipmi_kontron_help(void) ;
#line 65
static int ipmi_kontron_set_serial_number(struct ipmi_intf *intf ) ;
#line 66
static int ipmi_kontron_set_mfg_date(struct ipmi_intf *intf ) ;
#line 68
static void ipmi_kontron_nextboot_help(void) ;
#line 69
static int ipmi_kontron_nextboot_set(struct ipmi_intf *intf , int argc , char **argv ) ;
#line 72
static int ipmi_kontronoem_send_set_large_buffer(struct ipmi_intf *intf , unsigned char channel ,
                                                 unsigned char size ) ;
#line 76 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_kontronoem.c"
int ipmi_kontronoem_main(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 79
  rc = 0;
#line 81
  if (argc == 0) {
    {
#line 82
    ipmi_kontron_help();
    }
  } else {
    {
#line 83
    tmp___4 = strncmp((char const   *)*(argv + 0), "help", (size_t )4);
    }
#line 83
    if (tmp___4 == 0) {
      {
#line 84
      ipmi_kontron_help();
      }
    } else {
      {
#line 86
      tmp___3 = strncmp((char const   *)*(argv + 0), "setsn", (size_t )5);
      }
#line 86
      if (tmp___3) {
        {
#line 104
        tmp___2 = strncmp((char const   *)*(argv + 0), "setmfgdate", (size_t )5);
        }
#line 104
        if (tmp___2) {
          {
#line 122
          tmp___1 = strncmp((char const   *)*(argv + 0), "nextboot", sizeof("nextboot") - 1UL);
          }
#line 122
          if (tmp___1) {
            {
#line 143
            printf((char const   */* __restrict  */)"Invalid Kontron command: %s",
                   *(argv + 0));
#line 144
            ipmi_kontron_help();
#line 145
            rc = -1;
            }
          } else
#line 124
          if (argc > 1) {
            {
#line 126
            rc = ipmi_kontron_nextboot_set(intf, argc - 1, argv + 1);
            }
#line 126
            if (rc == 0) {
              {
#line 128
              printf((char const   */* __restrict  */)"Nextboot set successfully\n");
              }
            } else {
              {
#line 132
              printf((char const   */* __restrict  */)"Nextboot set failed\n");
              }
            }
          } else {
            {
#line 137
            ipmi_kontron_nextboot_help();
            }
          }
        } else
#line 106
        if (argc >= 1) {
          {
#line 108
          tmp___0 = ipmi_kontron_set_mfg_date(intf);
          }
#line 108
          if (tmp___0 > 0) {
            {
#line 110
            printf((char const   */* __restrict  */)"FRU manufacturing date setted successfully\n");
            }
          } else {
            {
#line 114
            printf((char const   */* __restrict  */)"FRU manufacturing date set failed\n");
            }
          }
        } else {
          {
#line 119
          printf((char const   */* __restrict  */)"fru setmfgdate\n");
          }
        }
      } else
#line 88
      if (argc >= 1) {
        {
#line 90
        tmp = ipmi_kontron_set_serial_number(intf);
        }
#line 90
        if (tmp > 0) {
          {
#line 92
          printf((char const   */* __restrict  */)"FRU serial number setted successfully\n");
          }
        } else {
          {
#line 96
          printf((char const   */* __restrict  */)"FRU serial number set failed\n");
          }
        }
      } else {
        {
#line 101
        printf((char const   */* __restrict  */)"fru setsn\n");
        }
      }
    }
  }
#line 148
  return (rc);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_kontronoem.c"
static void ipmi_kontron_help(void) 
{ 


  {
  {
#line 154
  printf((char const   */* __restrict  */)"Kontron Commands:  setsn setmfgdate nextboot\n");
  }
#line 155
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_kontronoem.c"
int ipmi_kontronoem_set_large_buffer(struct ipmi_intf *intf , unsigned char size ) 
{ 
  uint8_t error_occurs ;
  uint32_t prev_target_addr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 160
  error_occurs = (uint8_t )0;
#line 161
  prev_target_addr = intf->target_addr;
#line 163
  if (intf->target_addr > 0U) {
#line 163
    if (intf->target_addr != intf->my_addr) {
      {
#line 165
      intf->target_addr = intf->my_addr;
#line 167
      printf((char const   */* __restrict  */)"Set local big buffer\n");
#line 168
      tmp = ipmi_kontronoem_send_set_large_buffer(intf, (unsigned char)14, size);
      }
#line 168
      if (tmp == 0) {
        {
#line 170
        printf((char const   */* __restrict  */)"Set local big buffer:success\n");
        }
      } else {
#line 174
        error_occurs = (uint8_t )1;
      }
#line 177
      if ((int )error_occurs == 0) {
        {
#line 179
        tmp___0 = ipmi_kontronoem_send_set_large_buffer(intf, (unsigned char)0, size);
        }
#line 179
        if (tmp___0 == 0) {
          {
#line 181
          printf((char const   */* __restrict  */)"IPMB was set\n");
          }
        } else {
          {
#line 186
          error_occurs = (uint8_t )1;
#line 187
          ipmi_kontronoem_send_set_large_buffer(intf, (unsigned char)14, (unsigned char)0);
          }
        }
      }
#line 192
      intf->target_addr = prev_target_addr;
    }
  }
#line 195
  if ((int )error_occurs == 0) {
    {
#line 197
    tmp___1 = ipmi_kontronoem_send_set_large_buffer(intf, (unsigned char)14, size);
    }
#line 197
    if (! (tmp___1 == 0)) {
#line 203
      if (intf->target_addr > 0U) {
#line 203
        if (intf->target_addr != intf->my_addr) {
          {
#line 206
          intf->target_addr = intf->my_addr;
#line 209
          ipmi_kontronoem_send_set_large_buffer(intf, (unsigned char)14, (unsigned char)0);
#line 211
          intf->target_addr = prev_target_addr;
          }
        }
      }
    }
  }
#line 215
  return ((int )error_occurs);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_kontronoem.c"
static int ipmi_kontronoem_send_set_large_buffer(struct ipmi_intf *intf , unsigned char channel ,
                                                 unsigned char size ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[2] ;
  char const   *tmp ;

  {
  {
#line 226
  memset((void *)(msg_data), 0, sizeof(msg_data));
#line 227
  msg_data[0] = channel;
#line 228
  msg_data[1] = size;
#line 230
  memset((void *)(& req), 0, sizeof(req));
#line 231
  req.msg.netfn = (uint8_t )62;
#line 232
  req.msg.cmd = (uint8_t )130;
#line 233
  req.msg.data = msg_data;
#line 234
  req.msg.data_len = (uint16_t )2;
#line 236
  req.msg.lun = (uint8_t )0;
#line 238
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 239
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 241
    printf((char const   */* __restrict  */)"Cannot send large buffer command\n");
    }
#line 242
    return (-1);
  }
#line 244
  if ((int )rsp->ccode > 0) {
    {
#line 246
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 246
    printf((char const   */* __restrict  */)"Invalid length for the selected interface (%s) %d\n",
           tmp, (int )rsp->ccode);
    }
#line 248
    return (-1);
  }
#line 250
  return (0);
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_kontronoem.c"
static int ipmi_kontron_set_serial_number(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct fru_info fru ;
  struct fru_header header ;
  uint8_t msg_data[4] ;
  char *sn ;
  uint8_t sn_size ;
  uint8_t checksum ;
  uint8_t *fru_data ;
  char *fru_area ;
  uint32_t fru_data_offset ;
  uint32_t fru_data_offset_tmp ;
  uint32_t board_sec_len ;
  uint32_t prod_sec_len ;
  uint32_t i ;
  void *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
  {
#line 276
  sn = (char *)((void *)0);
#line 277
  fru_data = (uint8_t *)((void *)0);
#line 279
  memset((void *)(msg_data), 0, (size_t )4);
#line 280
  msg_data[0] = (uint8_t )180;
#line 281
  msg_data[1] = (uint8_t )144;
#line 282
  msg_data[2] = (uint8_t )145;
#line 283
  msg_data[3] = (uint8_t )139;
#line 285
  memset((void *)(& req), 0, sizeof(req));
#line 286
  req.msg.netfn = (uint8_t )62;
#line 287
  req.msg.cmd = (uint8_t )12;
#line 288
  req.msg.data = msg_data;
#line 289
  req.msg.data_len = (uint16_t )4;
#line 293
  req.msg.lun = (uint8_t )3;
#line 296
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 297
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 299
    printf((char const   */* __restrict  */)" Device not present (No Response)\n");
    }
#line 300
    return (-11);
  }
#line 303
  if ((int )rsp->ccode > 0) {
    {
#line 305
    printf((char const   */* __restrict  */)" This option is not implemented for this board\n");
    }
#line 306
    return (-1);
  }
  {
#line 309
  sn_size = (uint8_t )rsp->data_len;
#line 311
  tmp = malloc((size_t )((int )sn_size + 1));
#line 311
  sn = (char *)tmp;
  }
#line 313
  if ((unsigned long )sn == (unsigned long )((void *)0)) {
    {
#line 315
    printf((char const   */* __restrict  */)"Out of memory!");
    }
#line 316
    return (-1);
  }
  {
#line 319
  memset((void *)sn, 0, (size_t )((int )sn_size + 1));
#line 320
  memcpy((void */* __restrict  */)sn, (void const   */* __restrict  */)(rsp->data),
         (size_t )sn_size);
  }
#line 322
  if (verbose >= 1) {
    {
#line 324
    printf((char const   */* __restrict  */)"Original serial number is : [%s]\n",
           sn);
    }
  }
  {
#line 329
  memset((void *)(msg_data), 0, (size_t )4);
#line 330
  msg_data[0] = (uint8_t )0;
#line 332
  memset((void *)(& req), 0, sizeof(req));
#line 333
  req.msg.netfn = (uint8_t )10;
#line 334
  req.msg.cmd = (uint8_t )16;
#line 335
  req.msg.data = msg_data;
#line 336
  req.msg.data_len = (uint16_t )1;
#line 338
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 339
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 340
    printf((char const   */* __restrict  */)" Device not present (No Response)\n");
#line 341
    free((void *)sn);
#line 342
    sn = (char *)((void *)0);
    }
#line 343
    return (-1);
  }
#line 345
  if ((int )rsp->ccode > 0) {
    {
#line 346
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 346
    printf((char const   */* __restrict  */)" Device not present (%s)\n", tmp___0);
#line 348
    free((void *)sn);
#line 349
    sn = (char *)((void *)0);
    }
#line 350
    return (-1);
  }
#line 353
  fru.size = (uint16_t )(((int )rsp->data[1] << 8) | (int )rsp->data[0]);
#line 354
  fru.access = (uint8_t )((int )rsp->data[2] & 1);
#line 356
  if ((int )fru.size < 1) {
    {
#line 357
    printf((char const   */* __restrict  */)" Invalid FRU size %d", (int )fru.size);
#line 358
    free((void *)sn);
#line 359
    sn = (char *)((void *)0);
    }
#line 360
    return (-1);
  }
  {
#line 366
  msg_data[0] = (uint8_t )0;
#line 367
  msg_data[1] = (uint8_t )0;
#line 368
  msg_data[2] = (uint8_t )0;
#line 369
  msg_data[3] = (uint8_t )8;
#line 371
  memset((void *)(& req), 0, sizeof(req));
#line 372
  req.msg.netfn = (uint8_t )10;
#line 373
  req.msg.cmd = (uint8_t )17;
#line 374
  req.msg.data = msg_data;
#line 375
  req.msg.data_len = (uint16_t )4;
#line 377
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 378
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 380
    printf((char const   */* __restrict  */)" Device not present (No Response)\n");
#line 381
    free((void *)sn);
#line 382
    sn = (char *)((void *)0);
    }
#line 383
    return (-1);
  }
#line 385
  if ((int )rsp->ccode > 0) {
    {
#line 387
    tmp___1 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 387
    printf((char const   */* __restrict  */)" Device not present (%s)\n", tmp___1);
#line 389
    free((void *)sn);
#line 390
    sn = (char *)((void *)0);
    }
#line 391
    return (-1);
  }
#line 394
  if (verbose > 1) {
    {
#line 395
    printbuf((uint8_t const   *)(rsp->data), rsp->data_len, "FRU DATA");
    }
  }
  {
#line 397
  memcpy((void */* __restrict  */)(& header), (void const   */* __restrict  */)(rsp->data + 1),
         (size_t )8);
  }
#line 399
  if ((int )header.version != 1) {
    {
#line 401
    printf((char const   */* __restrict  */)" Unknown FRU header version 0x%02x",
           (int )header.version);
#line 403
    free((void *)sn);
#line 404
    sn = (char *)((void *)0);
    }
#line 405
    return (-1);
  }
  {
#line 409
  board_sec_len = (uint32_t )((int )header.offset.product * 8 - (int )header.offset.board * 8);
#line 412
  tmp___2 = malloc((size_t )fru.size);
#line 412
  fru_data = (uint8_t *)tmp___2;
  }
#line 414
  if ((unsigned long )fru_data == (unsigned long )((void *)0)) {
    {
#line 416
    printf((char const   */* __restrict  */)"Out of memory!");
#line 417
    free((void *)sn);
#line 418
    sn = (char *)((void *)0);
    }
#line 419
    return (-1);
  }
  {
#line 422
  memset((void *)fru_data, 0, (size_t )fru.size);
#line 423
  tmp___3 = read_fru_area(intf, & fru, (uint8_t )0, (uint32_t )((int )header.offset.board * 8),
                          board_sec_len, fru_data);
  }
#line 423
  if (tmp___3 < 0) {
    {
#line 425
    free((void *)sn);
#line 426
    sn = (char *)((void *)0);
#line 427
    free((void *)fru_data);
#line 428
    fru_data = (uint8_t *)((void *)0);
    }
#line 429
    return (-1);
  }
  {
#line 433
  fru_data_offset = (uint32_t )((int )header.offset.board * 8 + 6);
#line 434
  fru_area = get_fru_area_str(fru_data, & fru_data_offset);
#line 437
  fru_area = get_fru_area_str(fru_data, & fru_data_offset);
#line 439
  fru_data_offset_tmp = fru_data_offset;
#line 442
  fru_area = get_fru_area_str(fru_data, & fru_data_offset_tmp);
#line 444
  fru_data_offset ++;
#line 446
  tmp___4 = strlen((char const   *)fru_area);
  }
#line 446
  if (tmp___4 != (size_t )sn_size) {
    {
#line 448
    printf((char const   */* __restrict  */)"The length of the serial number in the FRU Board Area is wrong.\n");
#line 449
    free((void *)sn);
#line 450
    sn = (char *)((void *)0);
#line 451
    free((void *)fru_data);
#line 452
    fru_data = (uint8_t *)((void *)0);
    }
#line 453
    return (-1);
  }
  {
#line 457
  memcpy((void */* __restrict  */)(fru_data + fru_data_offset), (void const   */* __restrict  */)sn,
         (size_t )sn_size);
#line 459
  checksum = (uint8_t )0;
#line 461
  i = (uint32_t )((int )header.offset.board * 8);
  }
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    if (! (i < ((uint32_t )((int )header.offset.board * 8) + board_sec_len) - 2U)) {
#line 461
      goto while_break;
    }
#line 463
    checksum = (uint8_t )((int )checksum + (int )*(fru_data + i));
#line 461
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 465
  checksum = (uint8_t )(~ ((int )checksum) + 1);
#line 468
  *(fru_data + (((uint32_t )((int )header.offset.board * 8) + board_sec_len) - 1U)) = checksum;
#line 471
  tmp___5 = write_fru_area(intf, & fru, (unsigned char)0, (unsigned int )((int )header.offset.board * 8),
                           (unsigned int )((int )header.offset.board * 8), board_sec_len,
                           fru_data);
  }
#line 471
  if (tmp___5 < 0) {
    {
#line 473
    free((void *)sn);
#line 474
    sn = (char *)((void *)0);
#line 475
    free((void *)fru_data);
#line 476
    fru_data = (uint8_t *)((void *)0);
    }
#line 477
    return (-1);
  }
  {
#line 481
  prod_sec_len = (uint32_t )((int )header.offset.multi * 8 - (int )header.offset.product * 8);
#line 483
  tmp___6 = read_fru_area(intf, & fru, (uint8_t )0, (uint32_t )((int )header.offset.product * 8),
                          prod_sec_len, fru_data);
  }
#line 483
  if (tmp___6 < 0) {
    {
#line 485
    free((void *)sn);
#line 486
    sn = (char *)((void *)0);
#line 487
    free((void *)fru_data);
#line 488
    fru_data = (uint8_t *)((void *)0);
    }
#line 489
    return (-1);
  }
  {
#line 493
  fru_data_offset = (uint32_t )((int )header.offset.product * 8 + 3);
#line 494
  fru_area = get_fru_area_str(fru_data, & fru_data_offset);
#line 497
  fru_area = get_fru_area_str(fru_data, & fru_data_offset);
#line 500
  fru_area = get_fru_area_str(fru_data, & fru_data_offset);
#line 503
  fru_area = get_fru_area_str(fru_data, & fru_data_offset);
#line 507
  fru_data_offset_tmp = fru_data_offset;
#line 510
  fru_area = get_fru_area_str(fru_data, & fru_data_offset_tmp);
#line 512
  fru_data_offset ++;
#line 514
  tmp___7 = strlen((char const   *)fru_area);
  }
#line 514
  if (tmp___7 != (size_t )sn_size) {
    {
#line 516
    free((void *)sn);
#line 517
    sn = (char *)((void *)0);
#line 518
    free((void *)fru_data);
#line 519
    fru_data = (uint8_t *)((void *)0);
#line 520
    printf((char const   */* __restrict  */)"The length of the serial number in the FRU Product Area is wrong.\n");
    }
#line 521
    return (-1);
  }
  {
#line 526
  memcpy((void */* __restrict  */)(fru_data + fru_data_offset), (void const   */* __restrict  */)sn,
         (size_t )sn_size);
#line 528
  checksum = (uint8_t )0;
#line 530
  i = (uint32_t )((int )header.offset.product * 8);
  }
  {
#line 530
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 530
    if (! (i < ((uint32_t )((int )header.offset.product * 8) + prod_sec_len) - 2U)) {
#line 530
      goto while_break___0;
    }
#line 532
    checksum = (uint8_t )((int )checksum + (int )*(fru_data + i));
#line 530
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 534
  checksum = (uint8_t )(~ ((int )checksum) + 1);
#line 537
  *(fru_data + (((uint32_t )((int )header.offset.product * 8) + prod_sec_len) - 1U)) = checksum;
#line 540
  tmp___8 = write_fru_area(intf, & fru, (unsigned char)0, (unsigned int )((int )header.offset.product * 8),
                           (unsigned int )((int )header.offset.product * 8), prod_sec_len,
                           fru_data);
  }
#line 540
  if (tmp___8 < 0) {
    {
#line 542
    free((void *)sn);
#line 543
    sn = (char *)((void *)0);
#line 544
    free((void *)fru_data);
#line 545
    fru_data = (uint8_t *)((void *)0);
    }
#line 546
    return (-1);
  }
  {
#line 549
  free((void *)sn);
#line 550
  sn = (char *)((void *)0);
#line 551
  free((void *)fru_data);
#line 552
  fru_data = (uint8_t *)((void *)0);
  }
#line 554
  return (1);
}
}
#line 567 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_kontronoem.c"
static int ipmi_kontron_set_mfg_date(struct ipmi_intf *intf ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  struct fru_info fru ;
  struct fru_header header ;
  uint8_t msg_data[4] ;
  uint8_t mfg_date[3] ;
  uint32_t board_sec_len ;
  uint32_t i ;
  uint8_t *fru_data ;
  uint8_t checksum ;
  char const   *tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 583
  memset((void *)(msg_data), 0, (size_t )4);
#line 584
  msg_data[0] = (uint8_t )180;
#line 585
  msg_data[1] = (uint8_t )144;
#line 586
  msg_data[2] = (uint8_t )145;
#line 587
  msg_data[3] = (uint8_t )139;
#line 589
  memset((void *)(& req), 0, sizeof(req));
#line 590
  req.msg.netfn = (uint8_t )62;
#line 591
  req.msg.cmd = (uint8_t )14;
#line 592
  req.msg.data = msg_data;
#line 593
  req.msg.data_len = (uint16_t )4;
#line 596
  req.msg.lun = (uint8_t )3;
#line 598
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 599
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 601
    printf((char const   */* __restrict  */)"Device not present (No Response)\n");
    }
#line 602
    return (-1);
  }
#line 605
  if ((int )rsp->ccode > 0) {
    {
#line 607
    printf((char const   */* __restrict  */)"This option is not implemented for this board\n");
    }
#line 608
    return (-1);
  }
#line 611
  if (rsp->data_len != 3) {
    {
#line 613
    printf((char const   */* __restrict  */)"Invalid response for the Manufacturing date\n");
    }
#line 614
    return (-1);
  }
  {
#line 617
  memset((void *)(mfg_date), 0, (size_t )3);
#line 618
  memcpy((void */* __restrict  */)(mfg_date), (void const   */* __restrict  */)(rsp->data),
         (size_t )3);
#line 620
  memset((void *)(msg_data), 0, (size_t )4);
#line 621
  msg_data[0] = (uint8_t )0;
#line 623
  memset((void *)(& req), 0, sizeof(req));
#line 624
  req.msg.netfn = (uint8_t )10;
#line 625
  req.msg.cmd = (uint8_t )16;
#line 626
  req.msg.data = msg_data;
#line 627
  req.msg.data_len = (uint16_t )1;
#line 629
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 630
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 631
    printf((char const   */* __restrict  */)" Device not present (No Response)\n");
    }
#line 632
    return (-1);
  }
#line 634
  if ((int )rsp->ccode > 0) {
    {
#line 635
    tmp = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 635
    printf((char const   */* __restrict  */)" Device not present (%s)\n", tmp);
    }
#line 637
    return (-1);
  }
#line 640
  fru.size = (uint16_t )(((int )rsp->data[1] << 8) | (int )rsp->data[0]);
#line 641
  fru.access = (uint8_t )((int )rsp->data[2] & 1);
#line 643
  if ((int )fru.size < 1) {
    {
#line 644
    printf((char const   */* __restrict  */)" Invalid FRU size %d", (int )fru.size);
    }
#line 645
    return (-1);
  }
  {
#line 651
  msg_data[0] = (uint8_t )0;
#line 652
  msg_data[1] = (uint8_t )0;
#line 653
  msg_data[2] = (uint8_t )0;
#line 654
  msg_data[3] = (uint8_t )8;
#line 656
  memset((void *)(& req), 0, sizeof(req));
#line 657
  req.msg.netfn = (uint8_t )10;
#line 658
  req.msg.cmd = (uint8_t )17;
#line 659
  req.msg.data = msg_data;
#line 660
  req.msg.data_len = (uint16_t )4;
#line 662
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 663
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 665
    printf((char const   */* __restrict  */)" Device not present (No Response)\n");
    }
#line 666
    return (-1);
  }
#line 668
  if ((int )rsp->ccode > 0) {
    {
#line 670
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 670
    printf((char const   */* __restrict  */)" Device not present (%s)\n", tmp___0);
    }
#line 672
    return (-1);
  }
#line 675
  if (verbose > 1) {
    {
#line 676
    printbuf((uint8_t const   *)(rsp->data), rsp->data_len, "FRU DATA");
    }
  }
  {
#line 678
  memcpy((void */* __restrict  */)(& header), (void const   */* __restrict  */)(rsp->data + 1),
         (size_t )8);
  }
#line 680
  if ((int )header.version != 1) {
    {
#line 682
    printf((char const   */* __restrict  */)" Unknown FRU header version 0x%02x",
           (int )header.version);
    }
#line 684
    return (-1);
  }
  {
#line 688
  board_sec_len = (uint32_t )((int )header.offset.product * 8 - (int )header.offset.board * 8);
#line 690
  tmp___1 = malloc((size_t )fru.size);
#line 690
  fru_data = (uint8_t *)tmp___1;
  }
#line 692
  if ((unsigned long )fru_data == (unsigned long )((void *)0)) {
    {
#line 694
    printf((char const   */* __restrict  */)"Out of memory!");
    }
#line 695
    return (-1);
  }
  {
#line 698
  memset((void *)fru_data, 0, (size_t )fru.size);
#line 699
  tmp___2 = read_fru_area(intf, & fru, (uint8_t )0, (uint32_t )((int )header.offset.board * 8),
                          board_sec_len, fru_data);
  }
#line 699
  if (tmp___2 < 0) {
    {
#line 701
    free((void *)fru_data);
#line 702
    fru_data = (uint8_t *)((void *)0);
    }
#line 703
    return (-1);
  }
  {
#line 707
  memcpy((void */* __restrict  */)((fru_data + (int )header.offset.board * 8) + 3),
         (void const   */* __restrict  */)(mfg_date), (size_t )3);
#line 709
  checksum = (uint8_t )0;
#line 711
  i = (uint32_t )((int )header.offset.board * 8);
  }
  {
#line 711
  while (1) {
    while_continue: /* CIL Label */ ;
#line 711
    if (! (i < ((uint32_t )((int )header.offset.board * 8) + board_sec_len) - 2U)) {
#line 711
      goto while_break;
    }
#line 713
    checksum = (uint8_t )((int )checksum + (int )*(fru_data + i));
#line 711
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 715
  checksum = (uint8_t )(~ ((int )checksum) + 1);
#line 717
  *(fru_data + (((uint32_t )((int )header.offset.board * 8) + board_sec_len) - 1U)) = checksum;
#line 720
  tmp___3 = write_fru_area(intf, & fru, (unsigned char)0, (unsigned int )((int )header.offset.board * 8),
                           (unsigned int )((int )header.offset.board * 8), board_sec_len,
                           fru_data);
  }
#line 720
  if (tmp___3 < 0) {
    {
#line 722
    free((void *)fru_data);
#line 723
    fru_data = (uint8_t *)((void *)0);
    }
#line 724
    return (-1);
  }
  {
#line 727
  free((void *)fru_data);
#line 728
  fru_data = (uint8_t *)((void *)0);
  }
#line 729
  return (1);
}
}
#line 733 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_kontronoem.c"
static char *bootdev[6]  = {      (char *)"BIOS",      (char *)"FDD",      (char *)"HDD",      (char *)"CDROM", 
        (char *)"network",      (char *)0};
#line 735 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_kontronoem.c"
static void ipmi_kontron_nextboot_help(void) 
{ 
  int i ;

  {
  {
#line 739
  printf((char const   */* __restrict  */)"nextboot <device>\nSupported devices:\n");
#line 741
  i = 0;
  }
  {
#line 741
  while (1) {
    while_continue: /* CIL Label */ ;
#line 741
    if (! ((unsigned long )bootdev[i] != (unsigned long )((char *)0))) {
#line 741
      goto while_break;
    }
    {
#line 742
    printf((char const   */* __restrict  */)"- %s\n", bootdev[i]);
#line 741
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 744
  return;
}
}
#line 754 "/home/june/repo/benchmarks/collector/temp/ipmitool-1.8.13/lib/ipmi_kontronoem.c"
static int ipmi_kontron_nextboot_set(struct ipmi_intf *intf , int argc , char **argv ) 
{ 
  struct ipmi_rs *rsp ;
  struct ipmi_rq req ;
  uint8_t msg_data[8] ;
  int i ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 762
  memset((void *)(msg_data), 0, sizeof(msg_data));
#line 763
  msg_data[0] = (uint8_t )180;
#line 764
  msg_data[1] = (uint8_t )144;
#line 765
  msg_data[2] = (uint8_t )145;
#line 766
  msg_data[3] = (uint8_t )139;
#line 767
  msg_data[4] = (uint8_t )157;
#line 768
  msg_data[5] = (uint8_t )255;
#line 769
  msg_data[6] = (uint8_t )255;
#line 771
  i = 0;
  }
  {
#line 771
  while (1) {
    while_continue: /* CIL Label */ ;
#line 771
    if (! ((unsigned long )bootdev[i] != (unsigned long )((char *)0))) {
#line 771
      goto while_break;
    }
    {
#line 772
    tmp = strcmp((char const   *)*(argv + 0), (char const   *)bootdev[i]);
    }
#line 772
    if (tmp == 0) {
#line 773
      msg_data[5] = (uint8_t )i;
#line 774
      goto while_break;
    }
#line 771
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 779
  if ((int )msg_data[5] == 255) {
    {
#line 780
    printf((char const   */* __restrict  */)"Unknown boot device: %s\n", *(argv + 0));
    }
#line 781
    return (-1);
  }
  {
#line 784
  memset((void *)(& req), 0, sizeof(req));
#line 785
  req.msg.netfn = (uint8_t )62;
#line 786
  req.msg.cmd = (uint8_t )2;
#line 787
  req.msg.data = msg_data;
#line 788
  req.msg.data_len = (uint16_t )7;
#line 791
  req.msg.lun = (uint8_t )3;
#line 793
  rsp = (*(intf->sendrecv))(intf, & req);
  }
#line 794
  if ((unsigned long )rsp == (unsigned long )((void *)0)) {
    {
#line 796
    printf((char const   */* __restrict  */)"Device not present (No Response)\n");
    }
#line 797
    return (-1);
  }
#line 799
  if ((int )rsp->ccode > 0) {
    {
#line 800
    tmp___0 = val2str((uint16_t )rsp->ccode, completion_code_vals);
#line 800
    printf((char const   */* __restrict  */)"Device not present (%s)\n", tmp___0);
    }
#line 802
    return (-1);
  }
#line 804
  return (0);
}
}
