/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 232 "/usr/include/unistd.h"
typedef __gid_t gid_t;
#line 237 "/usr/include/unistd.h"
typedef __uid_t uid_t;
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 40 "/usr/include/linux/capability.h"
struct __user_cap_header_struct {
   __u32 version ;
   int pid ;
};
#line 40 "/usr/include/linux/capability.h"
typedef struct __user_cap_header_struct *cap_user_header_t;
#line 45 "/usr/include/linux/capability.h"
struct __user_cap_data_struct {
   __u32 effective ;
   __u32 permitted ;
   __u32 inheritable ;
};
#line 45 "/usr/include/linux/capability.h"
typedef struct __user_cap_data_struct *cap_user_data_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 42 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rlimit_resource_t;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 353
extern int close(int __fd ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 944
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chroot)(char const   *__path ) ;
#line 111 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgroups)(size_t __n ,
                                                                                __gid_t const   *__groups ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 116
extern struct passwd *getpwnam(char const   *__name ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 717
extern int system(char const   *__command ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 69 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit  const  *__rlimits ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
char *_env[4]  = {      (char *)"HOME=/",      (char *)"COMPARTMENT=YES",      (char *)"PATH=/bin:/usr/bin:/",      (char *)""};
#line 46 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
int cap_set_no[28]  = 
#line 46
  {      0,      1,      2,      3, 
        4,      5,      6,      7, 
        8,      9,      10,      11, 
        12,      13,      14,      15, 
        16,      17,      18,      19, 
        20,      21,      22,      23, 
        24,      25,      26,      0};
#line 53 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
char cap_set_names[28][29]  = 
#line 53
  { {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'C',        (char )'H',        (char )'O',        (char )'W', 
            (char )'N',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'D',        (char )'A',        (char )'C',        (char )'_', 
            (char )'O',        (char )'V',        (char )'E',        (char )'R', 
            (char )'R',        (char )'I',        (char )'D',        (char )'E', 
            (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'D',        (char )'A',        (char )'C',        (char )'_', 
            (char )'R',        (char )'E',        (char )'A',        (char )'D', 
            (char )'_',        (char )'S',        (char )'E',        (char )'A', 
            (char )'R',        (char )'C',        (char )'H',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'F',        (char )'O',        (char )'W',        (char )'N', 
            (char )'E',        (char )'R',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'F',        (char )'S',        (char )'E',        (char )'T', 
            (char )'I',        (char )'D',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'K',        (char )'I',        (char )'L',        (char )'L', 
            (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'S',        (char )'E',        (char )'T',        (char )'G', 
            (char )'I',        (char )'D',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'S',        (char )'E',        (char )'T',        (char )'U', 
            (char )'I',        (char )'D',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'S',        (char )'E',        (char )'T',        (char )'P', 
            (char )'C',        (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'L',        (char )'I',        (char )'N',        (char )'U', 
            (char )'X',        (char )'_',        (char )'I',        (char )'M', 
            (char )'M',        (char )'U',        (char )'T',        (char )'A', 
            (char )'B',        (char )'L',        (char )'E',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'N',        (char )'E',        (char )'T',        (char )'_', 
            (char )'B',        (char )'I',        (char )'N',        (char )'D', 
            (char )'_',        (char )'S',        (char )'E',        (char )'R', 
            (char )'V',        (char )'I',        (char )'C',        (char )'E', 
            (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'N',        (char )'E',        (char )'T',        (char )'_', 
            (char )'B',        (char )'R',        (char )'O',        (char )'A', 
            (char )'D',        (char )'C',        (char )'A',        (char )'S', 
            (char )'T',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'N',        (char )'E',        (char )'T',        (char )'_', 
            (char )'A',        (char )'D',        (char )'M',        (char )'I', 
            (char )'N',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'N',        (char )'E',        (char )'T',        (char )'_', 
            (char )'R',        (char )'A',        (char )'W',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'I',        (char )'P',        (char )'C',        (char )'_', 
            (char )'L',        (char )'O',        (char )'C',        (char )'K', 
            (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'I',        (char )'P',        (char )'C',        (char )'_', 
            (char )'O',        (char )'W',        (char )'N',        (char )'E', 
            (char )'R',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'S',        (char )'Y',        (char )'S',        (char )'_', 
            (char )'M',        (char )'O',        (char )'D',        (char )'U', 
            (char )'L',        (char )'E',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'S',        (char )'Y',        (char )'S',        (char )'_', 
            (char )'R',        (char )'A',        (char )'W',        (char )'I', 
            (char )'O',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'S',        (char )'Y',        (char )'S',        (char )'_', 
            (char )'C',        (char )'H',        (char )'R',        (char )'O', 
            (char )'O',        (char )'T',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'S',        (char )'Y',        (char )'S',        (char )'_', 
            (char )'P',        (char )'T',        (char )'R',        (char )'A', 
            (char )'C',        (char )'E',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'S',        (char )'Y',        (char )'S',        (char )'_', 
            (char )'P',        (char )'A',        (char )'C',        (char )'C', 
            (char )'T',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'S',        (char )'Y',        (char )'S',        (char )'_', 
            (char )'A',        (char )'D',        (char )'M',        (char )'I', 
            (char )'N',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'S',        (char )'Y',        (char )'S',        (char )'_', 
            (char )'B',        (char )'O',        (char )'O',        (char )'T', 
            (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'S',        (char )'Y',        (char )'S',        (char )'_', 
            (char )'N',        (char )'I',        (char )'C',        (char )'E', 
            (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'S',        (char )'Y',        (char )'S',        (char )'_', 
            (char )'R',        (char )'E',        (char )'S',        (char )'O', 
            (char )'U',        (char )'R',        (char )'C',        (char )'E', 
            (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'S',        (char )'Y',        (char )'S',        (char )'_', 
            (char )'T',        (char )'I',        (char )'M',        (char )'E', 
            (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'_', 
            (char )'S',        (char )'Y',        (char )'S',        (char )'_', 
            (char )'T',        (char )'T',        (char )'Y',        (char )'_', 
            (char )'C',        (char )'O',        (char )'N',        (char )'F', 
            (char )'I',        (char )'G',        (char )'\000'}, 
   {        (char )'\000'}};
#line 62
extern int capset(cap_user_header_t header , cap_user_data_t data ) ;
#line 63
extern char **environ ;
#line 64 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
int program_params  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
int fd  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
int do_chroot  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
int do_group  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
int do_user  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
int do_caps  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
int do_init  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
int verbose  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
int quiet  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
char *chroot_path  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
char *init_program  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
char *prg  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
char *user  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
char **_argv  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
long tmp  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
__u32 temp  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
__u32 caps  =    (__u32 )0;
#line 69 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
uid_t set_user  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
gid_t set_group  ;
#line 71 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
struct passwd *pw  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
struct group *gr  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
void help(void) 
{ 
  long tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 75
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s %s %s %s\n\n",
          "Secure compartment", "v1.1", "Marc Heuse <marc@suse.de>", "http://www.suse.de/~marc");
#line 76
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Syntax: %s [options] /full/path/to/program\n",
          prg);
#line 77
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options:\n\t --chroot path\t chroot to path\n\t --user user\t change uid to this user\n\t --group group\t change gid to this group\n\t --init program\t execute this program/script before doing anything\n\t --cap capset\t set capset name. This option can be used several times.\n\t --verbose\t be verbose\n\t --quiet\t do no logging (to syslog)\n\t --fork\t\t fork (if everything is fine)\n\nHints: always try to chroot; use --user&group if possible; chroot and chown all\nfiles to another user than root if you use capabilties. Read the README file!\n\nKnown capset names: none");
#line 78
  tmp = 0L;
  }
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp___1 = strlen((char const   *)(cap_set_names[tmp]));
    }
#line 79
    if (! (tmp___1 > 0UL)) {
#line 79
      goto while_break;
    }
    {
#line 80
    tmp___0 = tmp;
#line 80
    tmp ++;
#line 80
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %s",
            cap_set_names[tmp___0]);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (see linux/capability.h for more information)\n");
#line 82
  exit(-1);
  }
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
void print_msg(char const   *format  , ...) 
{ 
  va_list arg ;
  char *log ;
  void *tmp___0 ;

  {
#line 88
  if (quiet == 0) {
    {
#line 89
    tmp___0 = malloc((size_t )5000);
#line 89
    log = (char *)tmp___0;
#line 90
    __builtin_va_start(arg, format);
#line 91
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
             arg);
#line 92
    vsnprintf((char */* __restrict  */)log, (size_t )5000, (char const   */* __restrict  */)format,
              arg);
#line 93
    syslog(5, (char const   *)log);
#line 94
    __builtin_va_end(arg);
#line 95
    free((void *)log);
    }
  }
#line 97
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
void my_secure(void) 
{ 
  char file[10] ;
  int mode ;

  {
  {
#line 100
  file[0] = (char )'/';
#line 100
  file[1] = (char )'d';
#line 100
  file[2] = (char )'e';
#line 100
  file[3] = (char )'v';
#line 100
  file[4] = (char )'/';
#line 100
  file[5] = (char )'n';
#line 100
  file[6] = (char )'u';
#line 100
  file[7] = (char )'l';
#line 100
  file[8] = (char )'l';
#line 100
  file[9] = (char )'\000';
#line 101
  mode = 2;
#line 103
  alarm(0U);
  }
#line 104
  if (verbose) {
    {
#line 105
    print_msg("Turned possible alarm(2)s off\n");
    }
  }
#line 107
  environ = _env;
#line 108
  if (verbose) {
    {
#line 109
    print_msg("Safe environment set\n");
    }
  }
  {
#line 111
  fd = open((char const   *)(file), mode);
  }
#line 111
  if (fd < 0) {
    {
#line 112
    file[1] = (char )'\000';
#line 113
    mode = 0;
#line 114
    fd = open((char const   *)(file), mode);
    }
#line 114
    if (fd < 0) {
      {
#line 115
      print_msg("Can not open /dev/null nor /, no more fd\'s?\n");
#line 116
      exit(-1);
      }
    }
  }
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! (fd < 2)) {
#line 119
      goto while_break;
    }
    {
#line 120
    fd = open((char const   *)(file), mode);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 121
  close(fd);
  }
#line 122
  if (verbose) {
    {
#line 123
    print_msg("Ensured that fd 0-2 are open\n");
    }
  }
#line 127
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
void my_caps(void) 
{ 
  cap_user_header_t head ;
  void *tmp___0 ;
  cap_user_data_t cap ;
  void *tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  int tmp___4 ;

  {
  {
#line 131
  tmp___0 = calloc((size_t )1, sizeof(cap_user_header_t ));
#line 131
  head = (cap_user_header_t )tmp___0;
#line 132
  tmp___1 = calloc((size_t )1, sizeof(cap_user_data_t ));
#line 132
  cap = (cap_user_data_t )tmp___1;
#line 133
  head->version = (__u32 )429392688;
#line 134
  head->pid = 0;
#line 135
  tmp___3 = caps;
#line 135
  cap->effective = tmp___3;
#line 135
  tmp___2 = tmp___3;
#line 135
  cap->permitted = tmp___2;
#line 135
  cap->inheritable = tmp___2;
#line 140
  tmp___4 = capset(head, cap);
  }
#line 140
  if (tmp___4 != 0) {
    {
#line 141
    print_msg("Could not set capabilities.\n");
#line 142
    exit(-1);
    }
  } else
#line 144
  if (verbose) {
    {
#line 145
    print_msg("Capabilities successfully set to 0x%0x\n", cap->effective);
    }
  }
  {
#line 147
  free((void *)head);
#line 148
  free((void *)cap);
  }
#line 149
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/compartment-1.1.0/compartment.c"
int main(int argc , char **argv ) 
{ 
  struct stat st ;
  int do_fork ;
  struct rlimit limit ;
  unsigned long uidrange ;
  int tmp___0 ;
  int tmp___1 ;
  struct passwd *tmp___2 ;
  struct group *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  __uid_t tmp___18 ;
  __uid_t tmp___19 ;
  __gid_t tmp___20 ;
  __gid_t tmp___21 ;
  struct passwd *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  char *buf ;
  void *tmp___30 ;
  char *buff ;
  void *tmp___31 ;
  int i ;
  size_t tmp___32 ;
  size_t tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;

  {
#line 154
  do_fork = 0;
#line 155
  limit.rlim_cur = (rlim_t )0;
#line 155
  limit.rlim_max = (rlim_t )0;
#line 156
  uidrange = 65535UL;
#line 158
  prg = *(argv + 0);
#line 159
  if (argc < 2) {
    {
#line 160
    help();
    }
  }
  {
#line 161
  tmp___0 = strcmp((char const   *)*(argv + 1), "-h");
  }
#line 161
  if (tmp___0 == 0) {
    {
#line 162
    help();
    }
  } else {
    {
#line 161
    tmp___1 = strcmp((char const   *)*(argv + 1), "--help");
    }
#line 161
    if (tmp___1 == 0) {
      {
#line 162
      help();
      }
    }
  }
  {
#line 164
  my_secure();
#line 165
  openlog("compartment", 1, 3 << 3);
  }
#line 166
  if (sizeof(uid_t ) == 4UL) {
#line 167
    uidrange = 65535UL;
  } else
#line 168
  if (sizeof(uid_t ) == 8UL) {
#line 169
    uidrange = 2147483646UL;
  } else {
    {
#line 171
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: weird uid size: %d\n",
            sizeof(uid_t ));
    }
  }
#line 174
  program_params = 1;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (argc - 1 > program_params) {
      {
#line 175
      tmp___17 = strncmp((char const   *)*(argv + program_params), "--", (size_t )2);
      }
#line 175
      if (! (tmp___17 == 0)) {
#line 175
        goto while_break;
      }
    } else {
#line 175
      goto while_break;
    }
    {
#line 176
    tmp___16 = strcmp((char const   *)*(argv + program_params), "--chroot");
    }
#line 176
    if (tmp___16 == 0) {
#line 177
      program_params ++;
#line 177
      chroot_path = *(argv + program_params);
#line 178
      do_chroot = 1;
    } else {
      {
#line 180
      tmp___15 = strcmp((char const   *)*(argv + program_params), "--user");
      }
#line 180
      if (tmp___15 == 0) {
        {
#line 181
        program_params ++;
#line 181
        tmp___2 = getpwnam((char const   *)*(argv + program_params));
#line 181
        pw = tmp___2;
        }
#line 181
        if ((unsigned long )pw != (unsigned long )((void *)0)) {
#line 182
          user = *(argv + program_params);
#line 183
          set_user = pw->pw_uid;
        } else {
          {
#line 185
          tmp = strtol((char const   */* __restrict  */)*(argv + program_params),
                       (char **/* __restrict  */)((char **)((void *)0)), 10);
          }
#line 186
          if (tmp < 0L) {
            {
#line 187
            print_msg("--user is out of bounds (username or a value between 0 and %lu): %ld\n",
                      uidrange, tmp);
#line 188
            exit(-1);
            }
          } else
#line 186
          if ((unsigned long )tmp > uidrange) {
            {
#line 187
            print_msg("--user is out of bounds (username or a value between 0 and %lu): %ld\n",
                      uidrange, tmp);
#line 188
            exit(-1);
            }
          }
#line 190
          set_user = (uid_t )tmp;
        }
#line 192
        if (verbose) {
          {
#line 193
          print_msg("UID will be set to %d\n", set_user);
          }
        }
#line 194
        do_user = 1;
      } else {
        {
#line 196
        tmp___14 = strcmp((char const   *)*(argv + program_params), "--group");
        }
#line 196
        if (tmp___14 == 0) {
          {
#line 197
          program_params ++;
#line 197
          tmp___3 = getgrnam((char const   *)*(argv + program_params));
#line 197
          gr = tmp___3;
          }
#line 197
          if ((unsigned long )gr != (unsigned long )((void *)0)) {
#line 198
            set_group = gr->gr_gid;
          } else {
            {
#line 200
            tmp = strtol((char const   */* __restrict  */)*(argv + program_params),
                         (char **/* __restrict  */)((char **)((void *)0)), 10);
            }
#line 201
            if (tmp < 0L) {
              {
#line 202
              print_msg("--group is out of bounds (groupname or a value between 0 and %lu): %ld\n",
                        uidrange, tmp);
#line 203
              exit(-1);
              }
            } else
#line 201
            if ((unsigned long )tmp > uidrange) {
              {
#line 202
              print_msg("--group is out of bounds (groupname or a value between 0 and %lu): %ld\n",
                        uidrange, tmp);
#line 203
              exit(-1);
              }
            }
#line 205
            set_group = (gid_t )tmp;
          }
#line 207
          if (verbose) {
            {
#line 208
            print_msg("GID will be set to %d\n", set_group);
            }
          }
#line 209
          do_group = 1;
        } else {
          {
#line 211
          tmp___13 = strcmp((char const   *)*(argv + program_params), "--init");
          }
#line 211
          if (tmp___13 == 0) {
#line 212
            program_params ++;
#line 212
            init_program = *(argv + program_params);
#line 213
            if (verbose) {
              {
#line 214
              print_msg("Initial program will be %s\n", init_program);
              }
            }
#line 215
            do_init = 1;
          } else {
            {
#line 217
            tmp___12 = strcmp((char const   *)*(argv + program_params), "--fork");
            }
#line 217
            if (tmp___12 == 0) {
#line 218
              if (verbose) {
                {
#line 219
                print_msg("Will fork if everything is fine\n");
                }
              }
#line 220
              do_fork = 1;
            } else {
              {
#line 222
              tmp___11 = strcmp((char const   *)*(argv + program_params), "--cap");
              }
#line 222
              if (tmp___11 == 0) {
                {
#line 223
                program_params ++;
#line 224
                tmp = 0L;
#line 225
                temp = caps;
#line 227
                tmp___6 = strcmp((char const   *)*(argv + program_params), "none");
                }
#line 227
                if (tmp___6 == 0) {
#line 227
                  goto _L;
                } else {
                  {
#line 227
                  tmp___7 = strcmp((char const   *)*(argv + program_params), "null");
                  }
#line 227
                  if (tmp___7 == 0) {
                    _L: /* CIL Label */ 
#line 229
                    caps = (__u32 )0;
#line 229
                    temp = caps;
#line 230
                    if (verbose) {
                      {
#line 231
                      print_msg("Capabilities all cleared\n");
                      }
                    }
                  } else {
                    {
#line 233
                    while (1) {
                      while_continue___0: /* CIL Label */ ;
#line 233
                      if (temp == caps) {
                        {
#line 233
                        tmp___5 = strlen((char const   *)(cap_set_names[tmp]));
                        }
#line 233
                        if (! (tmp___5 > 0UL)) {
#line 233
                          goto while_break___0;
                        }
                      } else {
#line 233
                        goto while_break___0;
                      }
                      {
#line 234
                      tmp___4 = strcmp((char const   *)*(argv + program_params), (char const   *)(cap_set_names[tmp]));
                      }
#line 234
                      if (tmp___4 == 0) {
#line 235
                        temp = (__u32 )cap_set_no[tmp];
#line 236
                        caps |= (unsigned int )(1 << (temp & 31U));
#line 237
                        if (verbose) {
                          {
#line 238
                          print_msg("Capabilities will be set to 0x%0x\n", caps);
                          }
                        }
                      }
#line 240
                      tmp ++;
                    }
                    while_break___0: /* CIL Label */ ;
                    }
#line 242
                    if (caps == temp) {
                      {
#line 243
                      print_msg("Unknown capset name: %s\n", *(argv + program_params));
#line 244
                      exit(-1);
                      }
                    }
                  }
                }
#line 247
                do_caps = 1;
              } else {
                {
#line 249
                tmp___10 = strcmp((char const   *)*(argv + program_params), "--verbose");
                }
#line 249
                if (tmp___10 == 0) {
                  {
#line 250
                  print_msg("I am in verbose mode now\n");
#line 251
                  verbose = 1;
                  }
                } else {
                  {
#line 253
                  tmp___9 = strcmp((char const   *)*(argv + program_params), "--quiet");
                  }
#line 253
                  if (tmp___9 == 0) {
#line 254
                    quiet = 1;
                  } else {
                    {
#line 256
                    tmp___8 = strcmp((char const   *)*(argv + program_params), "--help");
                    }
#line 256
                    if (tmp___8 == 0) {
                      {
#line 257
                      help();
                      }
                    } else {
                      {
#line 259
                      print_msg("Unknown parameter: %s\n\n", *(argv + program_params));
#line 260
                      help();
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 263
    program_params ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 266
  tmp___18 = getuid();
#line 266
  tmp___19 = geteuid();
  }
#line 266
  if (tmp___18 != tmp___19) {
    {
#line 267
    print_msg("Warning: euid/egid and uid/gid are different, are we running suid/sgid??\nDo not do that!\n");
    }
  } else {
    {
#line 266
    tmp___20 = getgid();
#line 266
    tmp___21 = getegid();
    }
#line 266
    if (tmp___20 != tmp___21) {
      {
#line 267
      print_msg("Warning: euid/egid and uid/gid are different, are we running suid/sgid??\nDo not do that!\n");
      }
    }
  }
#line 270
  if (program_params == argc) {
    {
#line 271
    print_msg("No program given to execute.\n\n");
#line 272
    help();
    }
  }
#line 274
  _argv = argv;
#line 275
  _argv += program_params;
#line 278
  if (do_user == 0) {
    {
#line 279
    set_user = geteuid();
    }
  }
#line 280
  if (do_group == 0) {
    {
#line 281
    set_group = getegid();
    }
  }
#line 282
  if ((unsigned long )user == (unsigned long )((void *)0)) {
    {
#line 283
    tmp___22 = getpwuid(set_user);
#line 283
    pw = tmp___22;
    }
#line 283
    if ((unsigned long )pw == (unsigned long )((void *)0)) {
      {
#line 284
      print_msg("Warning: username for uid %u is not found in /etc/passwd.\n", set_user);
      }
    } else {
#line 286
      user = pw->pw_name;
    }
  }
#line 290
  if (do_caps) {
#line 290
    if (do_user) {
      {
#line 291
      print_msg("Warning: --user and --caps will not work together!\n");
      }
    }
  }
#line 294
  if (do_init) {
    {
#line 295
    tmp___23 = system((char const   *)init_program);
    }
#line 295
    if (tmp___23) {
      {
#line 296
      print_msg("Error executing init program %s\n", init_program);
#line 297
      exit(1);
      }
    } else
#line 299
    if (verbose) {
      {
#line 300
      print_msg("Init program %s run successfully\n", init_program);
      }
    }
  }
#line 304
  if (do_chroot) {
    {
#line 305
    tmp___24 = chroot((char const   *)chroot_path);
    }
#line 305
    if (tmp___24) {
      {
#line 306
      print_msg("Error chrooting to %s\n", chroot_path);
#line 307
      exit(1);
      }
    }
    {
#line 309
    tmp___25 = chdir("/");
    }
#line 309
    if (tmp___25 != 0) {
      {
#line 310
      print_msg("chdir to / in chroot failed\n");
#line 311
      exit(1);
      }
    }
#line 313
    if (verbose) {
      {
#line 314
      print_msg("Chrooted sucessfully to %s\n", chroot_path);
      }
    }
  }
#line 317
  if (do_user) {
#line 317
    goto _L___0;
  } else
#line 317
  if (do_group) {
#line 317
    goto _L___0;
  } else
#line 317
  if (do_caps) {
    _L___0: /* CIL Label */ 
    {
#line 319
    tmp___26 = setgroups((size_t )0, (__gid_t const   *)((void *)0));
    }
#line 319
    if (tmp___26) {
      {
#line 320
      print_msg("Error removing supplementary groups via setgroups().\n");
#line 321
      exit(1);
      }
    } else
#line 323
    if (verbose) {
      {
#line 324
      print_msg("setgroups() successfully set\n");
      }
    }
  }
#line 331
  if (do_group) {
    {
#line 332
    tmp___27 = setgid(set_group);
    }
#line 332
    if (tmp___27) {
      {
#line 333
      print_msg("Error setting gid to %u\n", set_group);
#line 334
      exit(1);
      }
    } else
#line 336
    if (verbose) {
      {
#line 337
      print_msg("GID successfully set to %d\n", set_group);
      }
    }
  }
#line 341
  if (do_caps) {
    {
#line 342
    my_caps();
    }
  }
#line 344
  if (do_user) {
    {
#line 345
    tmp___28 = setuid(set_user);
    }
#line 345
    if (tmp___28) {
      {
#line 346
      print_msg("Error setting uid to %u\n", set_user);
#line 347
      exit(1);
      }
    } else
#line 349
    if (verbose) {
      {
#line 350
      print_msg("UID successfully set to %d\n", set_user);
      }
    }
  }
#line 354
  fd = 3;
  {
#line 354
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 354
    if (! (fd <= 1023)) {
#line 354
      goto while_break___1;
    }
    {
#line 355
    fcntl(fd, 2, 1);
#line 354
    fd ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 356
  if (verbose) {
    {
#line 357
    print_msg("FD_CLOEXEC successfully set on all filedescriptors > 2\n");
    }
  }
  {
#line 359
  tmp___29 = setrlimit(4, (struct rlimit  const  *)(& limit));
  }
#line 359
  if (tmp___29 < 0) {
    {
#line 360
    print_msg("Could not set core size limit to 0 bytes\n");
    }
  } else
#line 361
  if (verbose) {
    {
#line 362
    print_msg("core size limit successfully set to 0 bytes\n");
    }
  }
#line 364
  if (quiet == 0) {
    {
#line 365
    tmp___30 = malloc((size_t )5000);
#line 365
    buf = (char *)tmp___30;
#line 366
    tmp___31 = malloc((size_t )5000);
#line 366
    buff = (char *)tmp___31;
#line 367
    i = 1;
#line 368
    strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)"Running as: ");
#line 369
    tmp___33 = strlen((char const   *)*(argv + 0));
    }
#line 369
    if (tmp___33 > 4095UL) {
      {
#line 370
      tmp___32 = strlen((char const   *)*(argv + 0));
#line 370
      print_msg("Illegal length of argv[0]: %d\n", tmp___32);
#line 371
      exit(1);
      }
    }
    {
#line 373
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)*(argv + 0));
    }
    {
#line 374
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 374
      if (! (i < argc)) {
#line 374
        goto while_break___2;
      }
      {
#line 375
      tmp___34 = i;
#line 375
      i ++;
#line 375
      snprintf((char */* __restrict  */)buff, (size_t )5000, (char const   */* __restrict  */)"%s %s",
               buf, *(argv + tmp___34));
#line 376
      strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)buff);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 378
    syslog(5, "%s\n", buf);
#line 379
    free((void *)buf);
#line 380
    free((void *)buff);
    }
  }
  {
#line 382
  tmp___35 = stat((char const   */* __restrict  */)*(_argv + 0), (struct stat */* __restrict  */)(& st));
  }
#line 382
  if (tmp___35 < 0) {
#line 383
    if (do_chroot) {
      {
#line 384
      print_msg("Warning: Can not find %s\n", *(_argv + 0));
      }
    } else
#line 383
    if ((int )*(*(_argv + 0) + 0) == 47) {
      {
#line 384
      print_msg("Warning: Can not find %s\n", *(_argv + 0));
      }
    } else
#line 383
    if ((int )*(*(_argv + 0) + 0) == 46) {
      {
#line 384
      print_msg("Warning: Can not find %s\n", *(_argv + 0));
      }
    }
  } else
#line 386
  if (do_fork) {
    {
#line 387
    do_fork = fork();
    }
#line 388
    if (do_fork < 0) {
      {
#line 389
      print_msg("Could not fork\n");
#line 390
      exit(1);
      }
    }
#line 392
    if (do_fork > 0) {
#line 393
      return (0);
    }
#line 394
    if (verbose) {
      {
#line 395
      print_msg("Successfully forked\n");
      }
    }
  }
  {
#line 399
  execvp((char const   *)*(_argv + 0), (char * const  *)_argv);
  }
#line 401
  if (do_chroot == 0) {
    {
#line 402
    print_msg("Could not execute %s\n", *(_argv + 0));
    }
  } else {
    {
#line 404
    tmp___37 = stat((char const   */* __restrict  */)*(_argv + 0), (struct stat */* __restrict  */)(& st));
    }
#line 404
    if (tmp___37 < 0) {
      {
#line 405
      print_msg("Could not find file: %s\n", *(_argv + 0));
      }
    } else {
      {
#line 407
      tmp___36 = access((char const   *)*(_argv + 0), 1);
      }
#line 407
      if (tmp___36 < 0) {
        {
#line 408
        print_msg("Execute bit missing, or no permissions to execute %s\n", *(_argv + 0));
        }
      } else {
        {
#line 410
        print_msg("Could not properly execute %s - the chroot environment might not be\nset up correctly:\nCreate the directories /etc and /lib in chroot_dir and run \"ldd %s\"\nto see which libraries are needed. Copy these to chroot_dir/lib, then chdir to\nchroot_dir and execute \"ldconfig -X -r .\"\n",
                  *(_argv + 0), *(_argv + 0));
        }
      }
    }
  }
#line 413
  return (1);
}
}
