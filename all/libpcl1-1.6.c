/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_13 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_13 __sigset_t;
#line 31 "./../include/pcl.h"
typedef void *coroutine_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/sigstack.h"
struct sigaltstack {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
#line 49 "/usr/include/x86_64-linux-gnu/bits/sigstack.h"
typedef struct sigaltstack stack_t;
#line 31 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef long long greg_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef greg_t gregset_t[23];
#line 92 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short padding[3] ;
};
#line 99 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_xmmreg {
   __uint32_t element[4] ;
};
#line 104 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _libc_fpxreg _st[8] ;
   struct _libc_xmmreg _xmm[16] ;
   __uint32_t padding[24] ;
};
#line 121 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct _libc_fpstate *fpregset_t;
#line 124 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct __anonstruct_mcontext_t_48 {
   gregset_t gregs ;
   fpregset_t fpregs ;
   unsigned long long __reserved1[8] ;
};
#line 124 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct __anonstruct_mcontext_t_48 mcontext_t;
#line 133 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct ucontext {
   unsigned long uc_flags ;
   struct ucontext *uc_link ;
   stack_t uc_stack ;
   mcontext_t uc_mcontext ;
   __sigset_t uc_sigmask ;
   struct _libc_fpstate __fpregs_mem ;
};
#line 133 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct ucontext ucontext_t;
#line 32 "/home/wheatley/newnew/temp/libpcl1-1.6/pcl/pcl.c"
typedef ucontext_t co_core_ctx_t;
#line 52 "/home/wheatley/newnew/temp/libpcl1-1.6/pcl/pcl.c"
struct s_co_ctx {
   co_core_ctx_t cc ;
};
#line 52 "/home/wheatley/newnew/temp/libpcl1-1.6/pcl/pcl.c"
typedef struct s_co_ctx co_ctx_t;
#line 56 "/home/wheatley/newnew/temp/libpcl1-1.6/pcl/pcl.c"
struct s_coroutine {
   co_ctx_t ctx ;
   int alloc ;
   struct s_coroutine *caller ;
   struct s_coroutine *restarget ;
   void (*func)(void * ) ;
   void *data ;
};
#line 56 "/home/wheatley/newnew/temp/libpcl1-1.6/pcl/pcl.c"
typedef struct s_coroutine coroutine;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 34 "./../include/pcl.h"
coroutine_t co_create(void (*func)(void * ) , void *data , void *stack , int size ) ;
#line 35
void co_delete(coroutine_t coro ) ;
#line 36
void co_call(coroutine_t coro ) ;
#line 37
void co_resume(void) ;
#line 38
void co_exit_to(coroutine_t coro ) ;
#line 39
void co_exit(void) ;
#line 40
coroutine_t co_current(void) ;
#line 31 "/usr/include/ucontext.h"
extern  __attribute__((__nothrow__)) int getcontext(ucontext_t *__ucp ) ;
#line 38
extern  __attribute__((__nothrow__)) int swapcontext(ucontext_t * __restrict  __oucp ,
                                                     ucontext_t const   * __restrict  __ucp ) ;
#line 47
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) makecontext)(ucontext_t *__ucp ,
                                                                                   void (*__func)(void) ,
                                                                                   int __argc 
                                                                                   , ...) ;
#line 66 "/home/wheatley/newnew/temp/libpcl1-1.6/pcl/pcl.c"
static coroutine co_main  ;
#line 67 "/home/wheatley/newnew/temp/libpcl1-1.6/pcl/pcl.c"
static coroutine *co_curr  =    & co_main;
#line 68 "/home/wheatley/newnew/temp/libpcl1-1.6/pcl/pcl.c"
static coroutine *co_dhelper  ;
#line 100 "/home/wheatley/newnew/temp/libpcl1-1.6/pcl/pcl.c"
static int co_set_context(co_ctx_t *ctx , void *func , char *stkbase , long stksiz ) 
{ 
  int tmp ;

  {
  {
#line 102
  tmp = getcontext(& ctx->cc);
  }
#line 102
  if (tmp) {
#line 103
    return (-1);
  }
  {
#line 105
  ctx->cc.uc_link = (struct ucontext *)((void *)0);
#line 107
  ctx->cc.uc_stack.ss_sp = (void *)stkbase;
#line 108
  ctx->cc.uc_stack.ss_size = (unsigned long )stksiz - sizeof(long );
#line 109
  ctx->cc.uc_stack.ss_flags = 0;
#line 111
  makecontext(& ctx->cc, (void (*)(void))func, 1);
  }
#line 113
  return (0);
}
}
#line 117 "/home/wheatley/newnew/temp/libpcl1-1.6/pcl/pcl.c"
static void co_switch_context(co_ctx_t *octx , co_ctx_t *nctx ) 
{ 
  int tmp ;

  {
  {
#line 119
  tmp = swapcontext((ucontext_t */* __restrict  */)(& octx->cc), (ucontext_t const   */* __restrict  */)(& nctx->cc));
  }
#line 119
  if (tmp < 0) {
    {
#line 120
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[PCL] Context switch failed: curr=%p\n",
            co_curr);
#line 122
    exit(1);
    }
  }
#line 124
  return;
}
}
#line 374 "/home/wheatley/newnew/temp/libpcl1-1.6/pcl/pcl.c"
static void co_runner(void) 
{ 
  coroutine *co ;

  {
  {
#line 375
  co = co_curr;
#line 377
  co->restarget = co->caller;
#line 378
  (*(co->func))(co->data);
#line 379
  co_exit();
  }
#line 380
  return;
}
}
#line 383 "/home/wheatley/newnew/temp/libpcl1-1.6/pcl/pcl.c"
coroutine_t co_create(void (*func)(void * ) , void *data , void *stack , int size ) 
{ 
  int alloc ;
  int r ;
  coroutine *co ;
  int tmp ;

  {
#line 384
  alloc = 0;
#line 384
  r = (int )(((sizeof(coroutine ) + 256UL) - 1UL) & 0xffffffffffffff00UL);
#line 387
  size = (int )((unsigned long )size & ~ (sizeof(long ) - 1UL));
#line 387
  if (size < 4096) {
#line 388
    return ((void *)0);
  }
#line 389
  if (! stack) {
    {
#line 390
    size = (int )(((((unsigned long )size + sizeof(coroutine )) + 256UL) - 1UL) & 0xffffffffffffff00UL);
#line 391
    stack = malloc((size_t )size);
    }
#line 392
    if (! stack) {
#line 393
      return ((void *)0);
    }
#line 394
    alloc = size;
  }
  {
#line 396
  co = (coroutine *)stack;
#line 397
  stack = (void *)((char *)stack + (((sizeof(coroutine ) + 256UL) - 1UL) & 0xffffffffffffff00UL));
#line 398
  co->alloc = alloc;
#line 399
  co->func = func;
#line 400
  co->data = data;
#line 401
  tmp = co_set_context(& co->ctx, (void *)(& co_runner), (char *)stack, (long )((unsigned long )size - (((sizeof(coroutine ) + 256UL) - 1UL) & 0xffffffffffffff00UL)));
  }
#line 401
  if (tmp < 0) {
#line 402
    if (alloc) {
      {
#line 403
      free((void *)co);
      }
    }
#line 404
    return ((void *)0);
  }
#line 407
  return ((coroutine_t )co);
}
}
#line 411 "/home/wheatley/newnew/temp/libpcl1-1.6/pcl/pcl.c"
void co_delete(coroutine_t coro ) 
{ 
  coroutine *co ;

  {
#line 412
  co = (coroutine *)coro;
#line 414
  if ((unsigned long )co == (unsigned long )co_curr) {
    {
#line 415
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[PCL] Cannot delete itself: curr=%p\n",
            co_curr);
#line 417
    exit(1);
    }
  }
#line 419
  if (co->alloc) {
    {
#line 420
    free((void *)co);
    }
  }
#line 421
  return;
}
}
#line 424 "/home/wheatley/newnew/temp/libpcl1-1.6/pcl/pcl.c"
void co_call(coroutine_t coro ) 
{ 
  coroutine *co ;
  coroutine *oldco ;

  {
  {
#line 425
  co = (coroutine *)coro;
#line 425
  oldco = co_curr;
#line 427
  co->caller = co_curr;
#line 428
  co_curr = co;
#line 430
  co_switch_context(& oldco->ctx, & co->ctx);
  }
#line 431
  return;
}
}
#line 434 "/home/wheatley/newnew/temp/libpcl1-1.6/pcl/pcl.c"
void co_resume(void) 
{ 


  {
  {
#line 436
  co_call((coroutine_t )co_curr->restarget);
#line 437
  co_curr->restarget = co_curr->caller;
  }
#line 438
  return;
}
}
#line 441 "/home/wheatley/newnew/temp/libpcl1-1.6/pcl/pcl.c"
static void co_del_helper(void *data ) 
{ 
  coroutine *cdh ;

  {
  {
#line 444
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 445
    cdh = co_dhelper;
#line 446
    co_dhelper = (coroutine *)((void *)0);
#line 447
    co_delete((coroutine_t )co_curr->caller);
#line 448
    co_call((coroutine_t )cdh);
    }
#line 449
    if (! co_dhelper) {
      {
#line 450
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[PCL] Resume to delete helper coroutine: curr=%p\n",
              co_curr);
#line 452
      exit(1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 460 "/home/wheatley/newnew/temp/libpcl1-1.6/pcl/pcl.c"
static coroutine *dchelper  =    (coroutine *)((void *)0);
#line 461 "/home/wheatley/newnew/temp/libpcl1-1.6/pcl/pcl.c"
static char stk[4096]  ;
#line 458 "/home/wheatley/newnew/temp/libpcl1-1.6/pcl/pcl.c"
void co_exit_to(coroutine_t coro ) 
{ 
  coroutine *co ;
  coroutine_t tmp ;

  {
#line 459
  co = (coroutine *)coro;
#line 463
  if (! dchelper) {
    {
#line 463
    tmp = co_create(& co_del_helper, (void *)0, (void *)(stk), (int )sizeof(stk));
#line 463
    dchelper = (coroutine *)tmp;
    }
#line 463
    if (! dchelper) {
      {
#line 465
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[PCL] Unable to create delete helper coroutine: curr=%p\n",
              co_curr);
#line 467
      exit(1);
      }
    }
  }
  {
#line 470
  co_dhelper = co;
#line 472
  co_call((coroutine_t )dchelper);
#line 474
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[PCL] Stale coroutine called: curr=%p\n",
          co_curr);
#line 476
  exit(1);
  }
}
}
#line 480 "/home/wheatley/newnew/temp/libpcl1-1.6/pcl/pcl.c"
void co_exit(void) 
{ 


  {
  {
#line 482
  co_exit_to((coroutine_t )co_curr->restarget);
  }
#line 483
  return;
}
}
#line 486 "/home/wheatley/newnew/temp/libpcl1-1.6/pcl/pcl.c"
coroutine_t co_current(void) 
{ 


  {
#line 488
  return ((coroutine_t )co_curr);
}
}
#line 29 "/home/wheatley/newnew/temp/libpcl1-1.6/pcl/pcl_version.c"
char const   *pcl_version[1]  = {      "Portable Coroutine Library (PCL) - Version 1.6\nCopyright (C) 2003 Davide Libenzi <davidel@xmailserver.org>\n"};
