/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 224 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 242 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_32 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_32 __in6_u ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 38 "/usr/include/netinet/icmp6.h"
union __anonunion_icmp6_dataun_34 {
   uint32_t icmp6_un_data32[1] ;
   uint16_t icmp6_un_data16[2] ;
   uint8_t icmp6_un_data8[4] ;
};
#line 38 "/usr/include/netinet/icmp6.h"
struct icmp6_hdr {
   uint8_t icmp6_type ;
   uint8_t icmp6_code ;
   uint16_t icmp6_cksum ;
   union __anonunion_icmp6_dataun_34 icmp6_dataun ;
};
#line 111 "/usr/include/netinet/icmp6.h"
struct nd_router_solicit {
   struct icmp6_hdr nd_rs_hdr ;
};
#line 122 "/usr/include/netinet/icmp6.h"
struct nd_router_advert {
   struct icmp6_hdr nd_ra_hdr ;
   uint32_t nd_ra_reachable ;
   uint32_t nd_ra_retransmit ;
};
#line 201 "/usr/include/netinet/icmp6.h"
struct nd_opt_prefix_info {
   uint8_t nd_opt_pi_type ;
   uint8_t nd_opt_pi_len ;
   uint8_t nd_opt_pi_prefix_len ;
   uint8_t nd_opt_pi_flags_reserved ;
   uint32_t nd_opt_pi_valid_time ;
   uint32_t nd_opt_pi_preferred_time ;
   uint32_t nd_opt_pi_reserved2 ;
   struct in6_addr nd_opt_pi_prefix ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/isatap.h"
struct PRLENTRY {
   struct PRLENTRY *next ;
   struct PRLENTRY *sibling ;
   uint32_t ip ;
   struct sockaddr_in6 addr6 ;
   int default_timeout ;
   int next_timeout ;
   int rs_sent ;
   int stale ;
};
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_33 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_34 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_33 ifr_ifrn ;
   union __anonunion_ifr_ifru_34 ifr_ifru ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 44 "/usr/include/netinet/ip.h"
struct iphdr {
   unsigned int ihl : 4 ;
   unsigned int version : 4 ;
   u_int8_t tos ;
   u_int16_t tot_len ;
   u_int16_t id ;
   u_int16_t frag_off ;
   u_int8_t ttl ;
   u_int8_t protocol ;
   u_int16_t check ;
   u_int32_t saddr ;
   u_int32_t daddr ;
};
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 28 "/usr/include/linux/types.h"
typedef __u16 __be16;
#line 30 "/usr/include/linux/types.h"
typedef __u32 __be32;
#line 30 "/usr/include/linux/if_tunnel.h"
struct ip_tunnel_parm {
   char name[16] ;
   int link ;
   __be16 i_flags ;
   __be16 o_flags ;
   __be32 i_key ;
   __be32 o_key ;
   struct iphdr iph ;
};
#line 63 "/usr/include/linux/if_tunnel.h"
struct ip_tunnel_prl {
   __be32 addr ;
   __u16 flags ;
   __u16 __reserved ;
   __u32 datalen ;
   __u32 __reserved2 ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_14 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_14 fd_set;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
struct ROUTER_NAME {
   char *name ;
   struct ROUTER_NAME *next ;
};
#line 608 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
union __anonunion_64 {
   int __in ;
   int __i ;
};
#line 607 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
union __anonunion_65 {
   int __in ;
   int __i ;
};
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 272 "/usr/include/x86_64-linux-gnu/bits/socket.h"
extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__leaf__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                struct cmsghdr *__cmsg ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 202
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 227 "/usr/include/netinet/in.h"
extern struct in6_addr  const  in6addr_any ;
#line 374
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 64 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 190 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.h"
int verbose ;
#line 5 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/rdisc.h"
int create_rs_socket(void) ;
#line 8
int send_rdisc(int fd , int ifindex , struct in6_addr *addr ) ;
#line 11
int recvadv(int fd , int ifindex ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/isatap.h"
struct PRLENTRY *del_internal_pdr(struct PRLENTRY *pr ) ;
#line 45
struct PRLENTRY *find_internal_pdr_by_addr6(struct in6_addr *addr ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/rdisc.c"
int create_rs_socket(void) 
{ 
  int fd ;
  int tmp ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 42
  tmp = socket(10, 3, 58);
#line 42
  fd = tmp;
  }
#line 45
  if (fd < 0) {
#line 46
    return (-1);
  }
  {
#line 48
  i = 1;
#line 49
  tmp___0 = setsockopt(fd, 1, 5, (void const   *)(& i), (socklen_t )sizeof(int ));
  }
#line 49
  if (tmp___0 < 0) {
    {
#line 51
    close(fd);
    }
#line 52
    return (-1);
  }
  {
#line 55
  i = 255;
#line 56
  tmp___1 = setsockopt(fd, 41, 16, (void const   *)(& i), (socklen_t )sizeof(i));
  }
#line 56
  if (tmp___1 < 0) {
    {
#line 58
    close(fd);
    }
#line 59
    return (-1);
  }
  {
#line 62
  i = 255;
#line 63
  tmp___2 = setsockopt(fd, 41, 18, (void const   *)(& i), (socklen_t )sizeof(i));
  }
#line 63
  if (tmp___2 < 0) {
    {
#line 65
    close(fd);
    }
#line 66
    return (-1);
  }
  {
#line 69
  i = 1;
#line 70
  tmp___3 = setsockopt(fd, 41, 51, (void const   *)(& i), (socklen_t )sizeof(int ));
  }
#line 70
  if (tmp___3 < 0) {
    {
#line 72
    close(fd);
    }
#line 73
    return (-1);
  }
#line 75
  return (fd);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/rdisc.c"
int send_rdisc(int fd , int ifindex , struct in6_addr *addr ) 
{ 
  struct sockaddr_in6 target ;
  struct nd_router_solicit rs ;
  ssize_t tmp ;

  {
#line 86
  if (ifindex == 0) {
#line 87
    return (-1);
  }
  {
#line 89
  memset((void *)(& target), 0, sizeof(target));
#line 90
  memset((void *)(& rs), 0, sizeof(rs));
#line 91
  target.sin6_addr = *addr;
#line 92
  target.sin6_family = (sa_family_t )10;
#line 93
  target.sin6_scope_id = (uint32_t )ifindex;
#line 95
  rs.nd_rs_hdr.icmp6_type = (uint8_t )133;
#line 96
  rs.nd_rs_hdr.icmp6_code = (uint8_t )0;
#line 97
  rs.nd_rs_hdr.icmp6_cksum = (uint16_t )0;
#line 98
  rs.nd_rs_hdr.icmp6_dataun.icmp6_un_data32[0] = (uint32_t )0;
#line 100
  tmp = sendto(fd, (void const   *)(& rs), sizeof(rs), 0, (struct sockaddr  const  *)(& target),
               (socklen_t )sizeof(target));
  }
#line 100
  if ((unsigned long )tmp != sizeof(rs)) {
#line 104
    return (-1);
  }
#line 106
  return (0);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/rdisc.c"
static ssize_t recvfromLL(int fd , void *buf , size_t len , int flags , struct sockaddr_in6 *addr ) 
{ 
  char cbuf[(((sizeof(int ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))] ;
  struct iovec iov ;
  struct msghdr hdr ;
  struct cmsghdr *cmsg ;
  ssize_t val ;
  ssize_t tmp ;
  int *data ;

  {
  {
#line 120
  iov.iov_base = buf;
#line 120
  iov.iov_len = len;
#line 125
  hdr.msg_name = (void *)addr;
#line 125
  hdr.msg_namelen = (socklen_t )sizeof(*addr);
#line 125
  hdr.msg_iov = & iov;
#line 125
  hdr.msg_iovlen = (size_t )1;
#line 125
  hdr.msg_control = (void *)(cbuf);
#line 125
  hdr.msg_controllen = sizeof(cbuf);
#line 125
  hdr.msg_flags = 0;
#line 136
  tmp = recvmsg(fd, & hdr, flags);
#line 136
  val = tmp;
  }
#line 137
  if (val == -1L) {
#line 138
    return (val);
  }
#line 141
  if (hdr.msg_controllen >= sizeof(struct cmsghdr )) {
#line 141
    cmsg = (struct cmsghdr *)hdr.msg_control;
  } else {
#line 141
    cmsg = (struct cmsghdr *)0;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! ((unsigned long )cmsg != (unsigned long )((void *)0))) {
#line 141
      goto while_break;
    }
#line 145
    if (cmsg->cmsg_level == 41) {
#line 145
      if (cmsg->cmsg_type == 52) {
#line 148
        data = (int *)(cmsg->__cmsg_data);
#line 149
        if (255 != *data) {
#line 152
          return ((ssize_t )0);
        }
      }
    }
    {
#line 141
    cmsg = __cmsg_nxthdr(& hdr, cmsg);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return (val);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/rdisc.c"
static int parseadv(struct nd_router_advert  const  *ra , int len , struct PRLENTRY *pr ) 
{ 
  double router_lifetime ;
  double v ;
  uint8_t const   *ptr ;
  uint16_t tmp ;
  uint16_t tmp___0 ;
  uint16_t optlen ;
  char str[46] ;
  struct nd_opt_prefix_info *pi ;
  char const   *tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint8_t optlen___0 ;
  uint8_t plen ;
  char str___0[46] ;
  uint32_t lifetime ;
  struct in6_addr dst ;
  char const   *tmp___5 ;

  {
  {
#line 174
  router_lifetime = (double )pr->default_timeout;
#line 176
  tmp = ntohs(ra->nd_ra_hdr.icmp6_dataun.icmp6_un_data16[1]);
#line 176
  v = 0.8 * (double )tmp;
  }
#line 177
  if (v > (double )0) {
#line 177
    if (v < router_lifetime) {
#line 178
      router_lifetime = v;
    }
  }
#line 180
  if (verbose >= 2) {
    {
#line 181
    tmp___0 = ntohs(ra->nd_ra_hdr.icmp6_dataun.icmp6_un_data16[1]);
#line 181
    syslog(6, "  Router lifetime %d sec\n", (int )tmp___0);
    }
  }
#line 184
  ptr = (uint8_t const   *)((uint8_t *)ra + sizeof(struct nd_router_advert ));
#line 185
  len = (int )((unsigned long )len - sizeof(struct nd_router_advert ));
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! (len >= 8)) {
#line 187
      goto while_break;
    }
#line 191
    optlen = (uint16_t )((int )((uint16_t )*(ptr + 1)) << 3);
#line 192
    if ((int )optlen == 0) {
#line 194
      goto while_break;
    } else
#line 192
    if (len < (int )optlen) {
#line 194
      goto while_break;
    }
#line 196
    len -= (int )optlen;
    {
#line 204
    if ((int const   )*(ptr + 0) == 25) {
#line 204
      goto case_25;
    }
#line 204
    if ((int const   )*(ptr + 0) == 5) {
#line 204
      goto case_25;
    }
#line 204
    if ((int const   )*(ptr + 0) == 4) {
#line 204
      goto case_25;
    }
#line 204
    if ((int const   )*(ptr + 0) == 2) {
#line 204
      goto case_25;
    }
#line 204
    if ((int const   )*(ptr + 0) == 1) {
#line 204
      goto case_25;
    }
#line 207
    if ((int const   )*(ptr + 0) == 3) {
#line 207
      goto case_3;
    }
#line 239
    if ((int const   )*(ptr + 0) == 24) {
#line 239
      goto case_24;
    }
#line 198
    goto switch_break;
    case_25: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 205
    goto switch_break;
    case_3: /* CIL Label */ 
#line 210
    pi = (struct nd_opt_prefix_info *)ptr;
#line 212
    if ((unsigned long )optlen < sizeof(struct nd_opt_prefix_info )) {
#line 213
      return (-1);
    }
#line 215
    if (verbose >= 1) {
      {
#line 217
      tmp___1 = inet_ntop(10, (void const   */* __restrict  */)(& pi->nd_opt_pi_prefix),
                          (char */* __restrict  */)(str), (socklen_t )sizeof(str));
      }
#line 217
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 219
        return (-1);
      }
      {
#line 221
      tmp___2 = ntohl(pi->nd_opt_pi_preferred_time);
#line 221
      syslog(6, "  Prefix %s/%u, lifetime %d sec\n", str, (int )pi->nd_opt_pi_prefix_len,
             tmp___2);
      }
    }
    {
#line 227
    tmp___3 = ntohl(pi->nd_opt_pi_preferred_time);
#line 227
    v = 0.8 * (double )tmp___3;
    }
#line 228
    if (v > (double )0) {
#line 228
      if (v < router_lifetime) {
#line 229
        router_lifetime = v;
      }
    }
    {
#line 231
    tmp___4 = ntohl(pi->nd_opt_pi_valid_time);
#line 231
    v = 0.8 * (double )tmp___4;
    }
#line 232
    if (v > (double )0) {
#line 232
      if (v < router_lifetime) {
#line 233
        router_lifetime = v;
      }
    }
#line 235
    goto switch_break;
    case_24: /* CIL Label */ 
#line 240
    optlen___0 = (uint8_t )*(ptr + 1);
#line 240
    plen = (uint8_t )*(ptr + 2);
#line 243
    dst = in6addr_any;
#line 245
    if ((int )optlen___0 > 3) {
#line 246
      return (-1);
    } else
#line 245
    if ((int )plen > 128) {
#line 246
      return (-1);
    } else
#line 245
    if ((int )optlen___0 < ((int )plen + 127) >> 6) {
#line 246
      return (-1);
    }
    {
#line 248
    memcpy((void */* __restrict  */)(dst.__in6_u.__u6_addr8), (void const   */* __restrict  */)(ptr + 8),
           (size_t )(((int )optlen___0 - 1) << 3));
#line 250
    lifetime = ntohl((uint32_t )*((uint32_t const   *)ptr + 1));
    }
#line 252
    if (verbose >= 2) {
      {
#line 253
      tmp___5 = inet_ntop(10, (void const   */* __restrict  */)(& dst), (char */* __restrict  */)(str___0),
                          (socklen_t )sizeof(str___0));
      }
#line 253
      if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
#line 254
        return (-1);
      }
      {
#line 255
      syslog(6, "  Route %s/%u, lifetime %d sec\n", str___0, (int )plen, lifetime);
      }
    }
#line 261
    v = 0.8 * (double )lifetime;
#line 262
    if (v > (double )0) {
#line 262
      if (v < router_lifetime) {
#line 263
        router_lifetime = v;
      }
    }
#line 265
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 269
    ptr += (int )optlen;
  }
  while_break: /* CIL Label */ ;
  }
#line 272
  pr->next_timeout = (int )(router_lifetime * 1000.0);
#line 273
  if (pr->next_timeout < 120) {
#line 274
    pr->next_timeout = 120;
  }
#line 275
  pr->rs_sent = 0;
#line 277
  if (verbose >= 2) {
    {
#line 278
    syslog(6, " Setting next timeout to %d sec\n", pr->next_timeout / 1000);
    }
  }
#line 281
  return (0);
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/rdisc.c"
int recvadv(int fd , int ifindex ) 
{ 
  ssize_t val ;
  char str[46] ;
  struct nd_router_advert *ra ;
  uint8_t buf[1460] ;
  struct sockaddr_in6 addr ;
  struct PRLENTRY *pr ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;

  {
  {
#line 297
  val = (ssize_t )0;
#line 304
  val = recvfromLL(fd, (void *)(buf), sizeof(buf), 256, & addr);
  }
#line 306
  if (val == -1L) {
    {
#line 308
    tmp = __errno_location();
#line 308
    tmp___0 = strerror(*tmp);
#line 308
    syslog(3, "Receiving ICMPv6 packet: %s\n", tmp___0);
    }
#line 309
    return (-1);
  }
#line 313
  if (val == 0L) {
#line 314
    return (0);
  }
#line 317
  ra = (struct nd_router_advert *)(buf);
#line 318
  if ((unsigned long )val < sizeof(struct nd_router_advert )) {
#line 321
    return (0);
  } else
#line 318
  if ((int )ra->nd_ra_hdr.icmp6_type != 134) {
#line 321
    return (0);
  } else
#line 318
  if ((int )ra->nd_ra_hdr.icmp6_code != 0) {
#line 321
    return (0);
  }
#line 324
  if ((uint32_t )ifindex != addr.sin6_scope_id) {
#line 325
    if (verbose >= 2) {
      {
#line 325
      tmp___1 = inet_ntop(10, (void const   */* __restrict  */)(& addr.sin6_addr),
                          (char */* __restrict  */)(str), (socklen_t )sizeof(str));
      }
#line 325
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        {
#line 327
        syslog(6, "Ignoring Advertisement from %s (scope mismatch)", str);
        }
      }
    }
#line 328
    return (0);
  }
  {
#line 332
  pr = find_internal_pdr_by_addr6(& addr.sin6_addr);
  }
#line 333
  if (pr) {
#line 334
    if (verbose >= 1) {
      {
#line 334
      tmp___2 = inet_ntop(10, (void const   */* __restrict  */)(& addr.sin6_addr),
                          (char */* __restrict  */)(str), (socklen_t )sizeof(str));
      }
#line 334
      if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
        {
#line 336
        syslog(6, "Advertisement from %s\n", str);
        }
      }
    }
    {
#line 339
    tmp___4 = parseadv((struct nd_router_advert  const  *)ra, (int )val, pr);
    }
#line 339
    if (tmp___4 < 0) {
#line 340
      if (verbose >= 1) {
        {
#line 340
        tmp___3 = inet_ntop(10, (void const   */* __restrict  */)(& addr.sin6_addr),
                            (char */* __restrict  */)(str), (socklen_t )sizeof(str));
        }
#line 340
        if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
          {
#line 342
          syslog(6, "Ignoring Advertisement from %s (parse error)\n", str);
          }
        }
      }
#line 343
      return (0);
    }
#line 346
    if (pr->sibling) {
#line 348
      if (verbose >= 2) {
        {
#line 348
        tmp___5 = inet_ntop(10, (void const   */* __restrict  */)(& (pr->sibling)->addr6.sin6_addr),
                            (char */* __restrict  */)(str), (socklen_t )sizeof(str));
        }
#line 348
        if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
          {
#line 350
          syslog(6, " (Not soliciting %s anymore)\n", str);
          }
        }
      }
      {
#line 354
      del_internal_pdr(pr->sibling);
#line 355
      pr->sibling = (struct PRLENTRY *)((void *)0);
      }
    }
#line 357
    return (1);
  }
#line 360
  if (verbose >= 1) {
    {
#line 360
    tmp___6 = inet_ntop(10, (void const   */* __restrict  */)(& addr.sin6_addr), (char */* __restrict  */)(str),
                        (socklen_t )sizeof(str));
    }
#line 360
    if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
      {
#line 362
      syslog(4, "Ignoring Advertisement from %s (unsolicited)\n", str);
      }
    }
  }
#line 363
  return (0);
}
}
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 193 "/usr/include/net/if.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) if_nametoindex)(char const   *__ifname ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/tunnel.h"
uint32_t get_if_addr(char const   *dev ) ;
#line 8
int tunnel_add(char const   *dev , char const   *link___0 , uint32_t saddr , uint8_t ttl___0 ,
               int pmtudisc___0 ) ;
#line 14
int tunnel_up(char const   *dev ) ;
#line 16
int tunnel_down(char const   *dev ) ;
#line 18
int tunnel_del(char const   *dev ) ;
#line 20
int tunnel_set_mtu(char const   *dev , int mtu___0 ) ;
#line 22
int tunnel_add_prl(char const   *dev , uint32_t addr , int default_rtr ) ;
#line 26
int tunnel_del_prl(char const   *dev , uint32_t addr ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/tunnel.c"
uint32_t get_if_addr(char const   *dev ) 
{ 
  struct ifreq ifr ;
  int fd ;
  int tmp ;

  {
#line 39
  if ((unsigned long )dev == (unsigned long )((void *)0)) {
#line 40
    return ((uint32_t )0);
  }
  {
#line 42
  memset((void *)(& ifr), 0, sizeof(ifr));
#line 43
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)dev,
          (size_t )16);
#line 45
  fd = socket(2, 2, 0);
  }
#line 46
  if (fd < 0) {
#line 47
    return ((uint32_t )0);
  }
  {
#line 49
  tmp = ioctl(fd, 35093UL, & ifr);
  }
#line 49
  if (tmp) {
    {
#line 50
    close(fd);
    }
#line 51
    return ((uint32_t )0);
  }
  {
#line 53
  close(fd);
  }
#line 54
  return (((struct sockaddr_in *)(& ifr.ifr_ifru.ifru_addr))->sin_addr.s_addr);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/tunnel.c"
int tunnel_add(char const   *dev , char const   *link___0 , uint32_t saddr , uint8_t ttl___0 ,
               int pmtudisc___0 ) 
{ 
  struct ip_tunnel_parm p ;
  struct ifreq ifr ;
  int fd ;
  uint16_t tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 71
  memset((void *)(& p), 0, sizeof(p));
#line 73
  p.iph.version = 4U;
#line 74
  p.iph.ihl = 5U;
#line 75
  p.iph.protocol = (u_int8_t )41;
#line 76
  p.iph.saddr = saddr;
  }
#line 77
  if (pmtudisc___0) {
    {
#line 77
    tmp = htons((uint16_t )16384);
#line 77
    p.iph.frag_off = tmp;
    }
  } else {
#line 77
    p.iph.frag_off = (u_int16_t )0;
  }
  {
#line 78
  p.iph.ttl = ttl___0;
#line 80
  p.i_flags = (__be16 )((int )p.i_flags | 1);
#line 81
  strncpy((char */* __restrict  */)(p.name), (char const   */* __restrict  */)dev,
          (size_t )16);
  }
#line 82
  if (link___0) {
    {
#line 83
    tmp___0 = if_nametoindex(link___0);
#line 83
    p.link = (int )tmp___0;
    }
#line 84
    if (p.link <= 0) {
#line 85
      return (-1);
    }
  }
  {
#line 88
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)"sit0",
          (size_t )16);
#line 89
  ifr.ifr_ifru.ifru_data = (__caddr_t )((void *)(& p));
#line 90
  fd = socket(2, 2, 0);
  }
#line 91
  if (fd < 0) {
#line 92
    return (-1);
  }
  {
#line 94
  tmp___1 = ioctl(fd, 35313UL, & ifr);
  }
#line 94
  if (tmp___1 < 0) {
    {
#line 95
    close(fd);
    }
#line 96
    return (-1);
  }
  {
#line 98
  close(fd);
  }
#line 100
  return (0);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/tunnel.c"
int tunnel_up(char const   *dev ) 
{ 
  struct ifreq ifr ;
  int fd ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 111
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)dev,
          (size_t )16);
#line 112
  fd = socket(2, 2, 0);
  }
#line 113
  if (fd < 0) {
#line 114
    return (-1);
  }
  {
#line 116
  tmp = ioctl(fd, 35091UL, & ifr);
  }
#line 116
  if (tmp) {
    {
#line 117
    close(fd);
    }
#line 118
    return (-1);
  }
  {
#line 120
  ifr.ifr_ifru.ifru_flags = (short )((int )ifr.ifr_ifru.ifru_flags | 1);
#line 122
  tmp___0 = ioctl(fd, 35092UL, & ifr);
  }
#line 122
  if (tmp___0) {
    {
#line 123
    close(fd);
    }
#line 124
    return (-1);
  }
  {
#line 126
  close(fd);
  }
#line 127
  return (0);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/tunnel.c"
int tunnel_down(char const   *dev ) 
{ 
  struct ifreq ifr ;
  int fd ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 138
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)dev,
          (size_t )16);
#line 139
  fd = socket(2, 2, 0);
  }
#line 140
  if (fd < 0) {
#line 141
    return (-1);
  }
  {
#line 143
  tmp = ioctl(fd, 35091UL, & ifr);
  }
#line 143
  if (tmp) {
    {
#line 144
    close(fd);
    }
#line 145
    return (-1);
  }
  {
#line 147
  ifr.ifr_ifru.ifru_flags = (short )((int )ifr.ifr_ifru.ifru_flags & -2);
#line 149
  tmp___0 = ioctl(fd, 35092UL, & ifr);
  }
#line 149
  if (tmp___0) {
    {
#line 150
    close(fd);
    }
#line 151
    return (-1);
  }
  {
#line 153
  close(fd);
  }
#line 154
  return (0);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/tunnel.c"
int tunnel_del(char const   *dev ) 
{ 
  struct ip_tunnel_parm p ;
  struct ifreq ifr ;
  int fd ;
  int tmp ;

  {
  {
#line 166
  memset((void *)(& p), 0, sizeof(p));
#line 168
  p.iph.version = 4U;
#line 169
  p.iph.ihl = 5U;
#line 170
  p.iph.protocol = (u_int8_t )41;
#line 171
  p.i_flags = (__be16 )((int )p.i_flags | 1);
#line 172
  strncpy((char */* __restrict  */)(p.name), (char const   */* __restrict  */)dev,
          (size_t )16);
#line 174
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)dev,
          (size_t )16);
#line 175
  ifr.ifr_ifru.ifru_data = (__caddr_t )((void *)(& p));
#line 176
  fd = socket(2, 2, 0);
  }
#line 177
  if (fd < 0) {
#line 178
    return (-1);
  }
  {
#line 181
  tmp = ioctl(fd, 35314UL, & ifr);
  }
#line 181
  if (tmp) {
    {
#line 182
    close(fd);
    }
#line 183
    return (-1);
  }
  {
#line 185
  close(fd);
  }
#line 187
  return (0);
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/tunnel.c"
int tunnel_set_mtu(char const   *dev , int mtu___0 ) 
{ 
  struct ifreq ifr ;
  int fd ;
  int tmp ;

  {
  {
#line 198
  fd = socket(2, 2, 0);
  }
#line 199
  if (fd < 0) {
#line 200
    return (-1);
  }
  {
#line 202
  memset((void *)(& ifr), 0, sizeof(ifr));
#line 203
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)dev,
          (size_t )16);
#line 204
  ifr.ifr_ifru.ifru_mtu = mtu___0;
#line 205
  tmp = ioctl(fd, 35106UL, & ifr);
  }
#line 205
  if (tmp < 0) {
    {
#line 206
    close(fd);
    }
#line 207
    return (-1);
  }
  {
#line 209
  close(fd);
  }
#line 211
  return (0);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/tunnel.c"
int tunnel_add_prl(char const   *dev , uint32_t addr , int default_rtr ) 
{ 
  struct ip_tunnel_prl p ;
  struct ifreq ifr ;
  int fd ;
  int tmp ;

  {
  {
#line 225
  memset((void *)(& p), 0, sizeof(p));
#line 226
  p.addr = addr;
  }
#line 227
  if (default_rtr) {
#line 228
    p.flags = (__u16 )((int )p.flags | 1);
  }
  {
#line 230
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)dev,
          (size_t )16);
#line 231
  ifr.ifr_ifru.ifru_data = (__caddr_t )((void *)(& p));
#line 232
  fd = socket(2, 2, 0);
  }
#line 233
  if (fd < 0) {
#line 234
    return (-1);
  }
  {
#line 236
  tmp = ioctl(fd, 35317UL, & ifr);
  }
#line 236
  if (tmp) {
    {
#line 237
    close(fd);
    }
#line 238
    return (-1);
  }
  {
#line 240
  close(fd);
  }
#line 241
  return (0);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/tunnel.c"
int tunnel_del_prl(char const   *dev , uint32_t addr ) 
{ 
  struct ip_tunnel_prl p ;
  struct ifreq ifr ;
  int fd ;
  int tmp ;

  {
  {
#line 253
  memset((void *)(& p), 0, sizeof(p));
#line 254
  p.addr = addr;
#line 256
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)dev,
          (size_t )16);
#line 257
  ifr.ifr_ifru.ifru_data = (__caddr_t )((void *)(& p));
#line 258
  fd = socket(2, 2, 0);
  }
#line 259
  if (fd < 0) {
#line 260
    return (-1);
  }
  {
#line 262
  tmp = ioctl(fd, 35318UL, & ifr);
  }
#line 262
  if (tmp) {
    {
#line 263
    close(fd);
    }
#line 264
    return (-1);
  }
  {
#line 266
  close(fd);
  }
#line 267
  return (0);
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 700 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 462 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) bcmp)(void const   *__s1 ,
                                                                                             void const   *__s2 ,
                                                                                             size_t __n )  __attribute__((__pure__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 201 "/usr/include/grp.h"
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/isatap.h"
void flush_internal_prl(void) ;
#line 41
void add_internal_pdr(struct PRLENTRY *pr ) ;
#line 42
struct PRLENTRY *new_internal_pdr(void) ;
#line 44
struct PRLENTRY *find_internal_pdr_by_addr(uint32_t ip ) ;
#line 46
struct PRLENTRY *get_first_internal_pdr(void) ;
#line 48
int add_router_name_to_internal_prl(char const   *host , int default_timeout ) ;
#line 49
int prune_kernel_prl(char const   *dev ) ;
#line 50
int run_solicitation_loop(char *tunnel_name___0 , int check_dns_timeout , char *username ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/isatap.c"
static struct PRLENTRY *prl_head  =    (struct PRLENTRY *)((void *)0);
#line 47 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/isatap.c"
void flush_internal_prl(void) 
{ 


  {
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! prl_head) {
#line 48
      goto while_break;
    }
    {
#line 49
    del_internal_pdr(prl_head);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/isatap.c"
struct PRLENTRY *get_first_internal_pdr(void) 
{ 


  {
#line 54
  return (prl_head);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/isatap.c"
void add_internal_pdr(struct PRLENTRY *pr ) 
{ 


  {
#line 61
  pr->next = prl_head;
#line 62
  prl_head = pr;
#line 63
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/isatap.c"
struct PRLENTRY *new_internal_pdr(void) 
{ 
  struct PRLENTRY *n ;
  void *tmp ;

  {
  {
#line 70
  tmp = malloc(sizeof(struct PRLENTRY ));
#line 70
  n = (struct PRLENTRY *)tmp;
#line 72
  n->ip = (uint32_t )0;
#line 73
  n->next = (struct PRLENTRY *)((void *)0);
#line 74
  n->sibling = (struct PRLENTRY *)((void *)0);
#line 75
  n->default_timeout = 0;
#line 76
  n->next_timeout = 0;
#line 77
  n->rs_sent = 0;
#line 78
  n->stale = 0;
#line 79
  memset((void *)(& n->addr6), 0, sizeof(n->addr6));
  }
#line 81
  return (n);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/isatap.c"
struct PRLENTRY *del_internal_pdr(struct PRLENTRY *pr ) 
{ 
  struct PRLENTRY *prev ;

  {
#line 91
  if ((unsigned long )pr == (unsigned long )prl_head) {
    {
#line 92
    prl_head = pr->next;
#line 93
    free((void *)pr);
    }
#line 94
    return (prl_head);
  }
#line 96
  prev = prl_head;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! prev) {
#line 97
      goto while_break;
    }
#line 98
    if ((unsigned long )prev->next == (unsigned long )pr) {
      {
#line 99
      prev->next = pr->next;
#line 100
      free((void *)pr);
      }
#line 101
      return (prev->next);
    }
#line 103
    prev = prev->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return ((struct PRLENTRY *)((void *)0));
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/isatap.c"
struct PRLENTRY *find_internal_pdr_by_addr(uint32_t ip ) 
{ 
  struct PRLENTRY *cur ;

  {
#line 113
  cur = prl_head;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! cur) {
#line 114
      goto while_break;
    }
#line 115
    if (cur->ip == ip) {
#line 116
      return (cur);
    }
#line 117
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return ((struct PRLENTRY *)((void *)0));
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/isatap.c"
struct PRLENTRY *find_internal_pdr_by_addr6(struct in6_addr *addr ) 
{ 
  struct PRLENTRY *cur ;
  int tmp ;

  {
#line 126
  cur = prl_head;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! cur) {
#line 127
      goto while_break;
    }
    {
#line 128
    tmp = bcmp((void const   *)(& cur->addr6.sin6_addr), (void const   *)addr, sizeof(struct in6_addr ));
    }
#line 128
    if (tmp == 0) {
#line 129
      return (cur);
    }
#line 130
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  return ((struct PRLENTRY *)((void *)0));
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/isatap.c"
static int ipv4_is_private(uint32_t addr ) 
{ 
  uint8_t *b8 ;

  {
#line 145
  b8 = (uint8_t *)(& addr);
  {
#line 153
  if ((int )*(b8 + 0) == 127) {
#line 153
    goto case_127;
  }
#line 153
  if ((int )*(b8 + 0) == 39) {
#line 153
    goto case_127;
  }
#line 153
  if ((int )*(b8 + 0) == 24) {
#line 153
    goto case_127;
  }
#line 153
  if ((int )*(b8 + 0) == 14) {
#line 153
    goto case_127;
  }
#line 153
  if ((int )*(b8 + 0) == 10) {
#line 153
    goto case_127;
  }
#line 153
  if ((int )*(b8 + 0) == 0) {
#line 153
    goto case_127;
  }
#line 156
  if ((int )*(b8 + 0) == 128) {
#line 156
    goto case_128;
  }
#line 160
  if ((int )*(b8 + 0) == 169) {
#line 160
    goto case_169;
  }
#line 164
  if ((int )*(b8 + 0) == 172) {
#line 164
    goto case_172;
  }
#line 168
  if ((int )*(b8 + 0) == 191) {
#line 168
    goto case_191;
  }
#line 172
  if ((int )*(b8 + 0) == 192) {
#line 172
    goto case_192;
  }
#line 188
  if ((int )*(b8 + 0) == 198) {
#line 188
    goto case_198;
  }
#line 192
  if ((int )*(b8 + 0) == 223) {
#line 192
    goto case_223;
  }
#line 147
  goto switch_break;
  case_127: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 154
  return (1);
#line 155
  goto switch_break;
  case_128: /* CIL Label */ 
#line 157
  if ((int )*(b8 + 1) == 0) {
#line 158
    return (1);
  }
#line 159
  goto switch_break;
  case_169: /* CIL Label */ 
#line 161
  if ((int )*(b8 + 1) == 254) {
#line 162
    return (1);
  }
#line 163
  goto switch_break;
  case_172: /* CIL Label */ 
#line 165
  if ((int )*(b8 + 1) >= 16) {
#line 165
    if ((int )*(b8 + 1) <= 31) {
#line 166
      return (1);
    }
  }
#line 167
  goto switch_break;
  case_191: /* CIL Label */ 
#line 169
  if ((int )*(b8 + 1) == 255) {
#line 170
    return (1);
  }
#line 171
  goto switch_break;
  case_192: /* CIL Label */ 
  {
#line 174
  if ((int )*(b8 + 1) == 0) {
#line 174
    goto case_0___0;
  }
#line 178
  if ((int )*(b8 + 1) == 88) {
#line 178
    goto case_88;
  }
#line 182
  if ((int )*(b8 + 1) == 168) {
#line 182
    goto case_168;
  }
#line 184
  goto switch_default;
  case_0___0: /* CIL Label */ 
#line 175
  if ((int )*(b8 + 2) == 0) {
#line 176
    return (1);
  } else
#line 175
  if ((int )*(b8 + 2) == 2) {
#line 176
    return (1);
  }
#line 177
  goto switch_break___0;
  case_88: /* CIL Label */ 
#line 179
  if ((int )*(b8 + 2) == 99) {
#line 180
    return (1);
  }
#line 181
  goto switch_break___0;
  case_168: /* CIL Label */ 
#line 183
  return (1);
  switch_default: /* CIL Label */ 
#line 185
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 187
  goto switch_break;
  case_198: /* CIL Label */ 
#line 189
  if ((int )*(b8 + 1) == 18) {
#line 190
    return (1);
  } else
#line 189
  if ((int )*(b8 + 1) == 19) {
#line 190
    return (1);
  }
#line 191
  goto switch_break;
  case_223: /* CIL Label */ 
#line 193
  if ((int )*(b8 + 1) == 255) {
#line 193
    if ((int )*(b8 + 2) == 255) {
#line 194
      return (1);
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 197
  return (0);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/isatap.c"
int add_router_name_to_internal_prl(char const   *host , int default_timeout ) 
{ 
  struct addrinfo *addr_info ;
  struct addrinfo *p ;
  struct addrinfo hints ;
  int err ;
  char const   *tmp ;
  struct in_addr addr ;
  struct PRLENTRY *pr ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 210
  if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 211
    return (-1);
  }
  {
#line 214
  memset((void *)(& hints), 0, sizeof(hints));
#line 215
  hints.ai_family = 2;
#line 216
  hints.ai_protocol = 41;
#line 217
  err = getaddrinfo((char const   */* __restrict  */)host, (char const   */* __restrict  */)((void *)0),
                    (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& addr_info));
  }
#line 219
  if (err) {
#line 220
    if (verbose >= 0) {
      {
#line 221
      tmp = gai_strerror(err);
#line 221
      syslog(4, "add_router_name_to_internal_prl: %s: %s\n", host, tmp);
      }
    }
#line 223
    return (0);
  }
#line 226
  p = addr_info;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! p) {
#line 227
      goto while_break;
    }
    {
#line 232
    addr = ((struct sockaddr_in *)p->ai_addr)->sin_addr;
#line 233
    pr = find_internal_pdr_by_addr(addr.s_addr);
    }
#line 234
    if (! pr) {
#line 235
      if (verbose >= 1) {
        {
#line 236
        tmp___0 = inet_ntoa(addr);
#line 236
        syslog(6, "Adding internal PDR %s\n", tmp___0);
        }
      }
      {
#line 238
      pr = new_internal_pdr();
#line 239
      pr->ip = addr.s_addr;
#line 240
      pr->default_timeout = default_timeout;
#line 241
      pr->addr6.sin6_addr.__in6_u.__u6_addr32[0] = htonl(4269801472U);
#line 242
      pr->addr6.sin6_addr.__in6_u.__u6_addr32[1] = htonl((uint32_t )0);
#line 243
      pr->addr6.sin6_addr.__in6_u.__u6_addr32[2] = htonl((uint32_t )24318);
#line 244
      pr->addr6.sin6_addr.__in6_u.__u6_addr32[3] = addr.s_addr;
#line 246
      add_internal_pdr(pr);
#line 249
      tmp___1 = ipv4_is_private(addr.s_addr);
      }
#line 249
      if (! tmp___1) {
        {
#line 251
        pr->sibling = new_internal_pdr();
#line 252
        (pr->sibling)->sibling = pr;
#line 253
        pr = pr->sibling;
#line 255
        pr->ip = addr.s_addr;
#line 256
        pr->default_timeout = default_timeout;
#line 257
        pr->addr6.sin6_addr.__in6_u.__u6_addr32[0] = htonl(4269801472U);
#line 258
        pr->addr6.sin6_addr.__in6_u.__u6_addr32[1] = htonl((uint32_t )0);
#line 259
        pr->addr6.sin6_addr.__in6_u.__u6_addr32[2] = htonl((uint32_t )33578750);
#line 260
        pr->addr6.sin6_addr.__in6_u.__u6_addr32[3] = addr.s_addr;
#line 262
        add_internal_pdr(pr);
        }
      }
    } else {
#line 265
      if (verbose >= 2) {
        {
#line 266
        tmp___2 = inet_ntoa(addr);
        }
#line 266
        if (pr->stale) {
#line 266
          tmp___3 = "Refreshing";
        } else {
#line 266
          tmp___3 = "Ignoring duplicate";
        }
        {
#line 266
        syslog(6, "%s internal PDR %s\n", tmp___3, tmp___2);
        }
      }
#line 269
      pr->stale = 0;
#line 270
      if (pr->sibling) {
#line 271
        (pr->sibling)->stale = 0;
      }
    }
#line 274
    p = p->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  freeaddrinfo(addr_info);
  }
#line 278
  return (0);
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/isatap.c"
int prune_kernel_prl(char const   *dev ) 
{ 
  struct PRLENTRY *pr ;
  struct in_addr addr ;
  char *tmp ;

  {
  {
#line 288
  pr = get_first_internal_pdr();
  }
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    if (! pr) {
#line 289
      goto while_break;
    }
#line 290
    if (pr->stale) {
#line 292
      addr.s_addr = pr->ip;
#line 293
      if (verbose >= 1) {
        {
#line 294
        tmp = inet_ntoa(addr);
#line 294
        syslog(6, "Removing old PDR %s from kernel\n", tmp);
        }
      }
      {
#line 296
      tunnel_del_prl(dev, pr->ip);
#line 297
      pr = del_internal_pdr(pr);
      }
    } else {
#line 299
      pr = pr->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  return (0);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/isatap.c"
int drop_to_user(char *username ) 
{ 
  struct passwd *pw ;
  struct passwd *tmp ;
  int *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 308
  tmp = getpwnam((char const   *)username);
#line 308
  pw = tmp;
  }
#line 309
  if ((unsigned long )pw == (unsigned long )((void *)0)) {
    {
#line 311
    tmp___4 = __errno_location();
    }
#line 311
    if (*tmp___4) {
      {
#line 311
      tmp___1 = __errno_location();
#line 311
      tmp___2 = strerror(*tmp___1);
#line 311
      tmp___3 = (char const   *)tmp___2;
      }
    } else {
#line 311
      tmp___3 = "User not found";
    }
    {
#line 311
    syslog(3, "User \"%s\": %s\n", username, tmp___3);
    }
#line 313
    return (-1);
  }
  {
#line 317
  tmp___5 = setgid(pw->pw_gid);
  }
#line 317
  if (tmp___5 < 0) {
#line 318
    return (-1);
  }
  {
#line 319
  tmp___6 = initgroups((char const   *)username, pw->pw_gid);
  }
#line 319
  if (tmp___6 < 0) {
#line 320
    return (-1);
  }
  {
#line 321
  tmp___7 = setuid(pw->pw_uid);
  }
#line 321
  if (tmp___7 < 0) {
#line 322
    return (-1);
  }
#line 324
  return (0);
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/isatap.c"
static void sighup_handler_child(void) 
{ 


  {
  {
#line 331
  exit(101);
  }
}
}
#line 345 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/isatap.c"
int run_solicitation_loop(char *tunnel_name___0 , int check_dns_timeout , char *username ) 
{ 
  struct PRLENTRY *pr ;
  int fd ;
  int ifindex ;
  int check_dns ;
  time_t tmp ;
  unsigned int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  struct in_addr ia ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  fd_set fds ;
  struct timeval timeout ;
  int ret ;
  int next_timeout ;
  int __d0 ;
  int __d1 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char addrstr[46] ;
  char const   *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;

  {
  {
#line 351
  tmp = time((time_t *)((void *)0));
#line 351
  srand((unsigned int )tmp);
#line 353
  tmp___0 = if_nametoindex((char const   *)tunnel_name___0);
#line 353
  ifindex = (int )tmp___0;
  }
#line 354
  if (ifindex < 0) {
    {
#line 355
    tmp___1 = __errno_location();
#line 355
    tmp___2 = strerror(*tmp___1);
#line 355
    syslog(3, "if_nametoindex: %s\n", tmp___2);
    }
#line 356
    return (102);
  }
  {
#line 360
  pr = get_first_internal_pdr();
  }
#line 361
  if ((unsigned long )pr == (unsigned long )((void *)0)) {
#line 362
    if (verbose >= -2) {
      {
#line 363
      syslog(3, "PRL empty!\n");
      }
    }
#line 364
    return (102);
  }
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 366
    if (! pr) {
#line 366
      goto while_break;
    }
    {
#line 367
    tmp___7 = tunnel_add_prl((char const   *)tunnel_name___0, pr->ip, 1);
    }
#line 367
    if (tmp___7 < 0) {
#line 369
      if (verbose >= 2) {
        {
#line 369
        tmp___5 = __errno_location();
        }
#line 369
        if (*tmp___5 != 17) {
          {
#line 370
          tmp___3 = __errno_location();
#line 370
          tmp___4 = strerror(*tmp___3);
#line 370
          syslog(3, "tunnel_add_prl: %s\n", tmp___4);
          }
        }
      }
    } else
#line 371
    if (verbose >= 2) {
      {
#line 373
      ia.s_addr = pr->ip;
#line 374
      tmp___6 = inet_ntoa(ia);
#line 374
      syslog(6, "Adding PDR %s to kernel\n", tmp___6);
      }
    }
    {
#line 377
    tmp___8 = rand();
#line 377
    pr->next_timeout = (int )(((1000.0 * (double )tmp___8) * (double )1) / (double )2147483647);
#line 381
    pr = pr->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 387
  fd = create_rs_socket();
  }
#line 388
  if (fd < 0) {
#line 389
    if (verbose >= -2) {
      {
#line 390
      tmp___9 = __errno_location();
#line 390
      tmp___10 = strerror(*tmp___9);
#line 390
      syslog(3, "create_rs_socket: invalid fd: %s\n", tmp___10);
      }
    }
#line 391
    return (102);
  }
  {
#line 395
  tmp___11 = drop_to_user(username);
  }
#line 395
  if (tmp___11 < 0) {
#line 396
    return (102);
  }
  {
#line 398
  signal(15, (void (*)(int  ))1);
#line 399
  signal(2, (void (*)(int  ))1);
#line 400
  signal(1, (void (*)(int  ))(& sighup_handler_child));
#line 402
  check_dns = check_dns_timeout > 0;
  }
  {
#line 404
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 404
    if (! (! check_dns)) {
#line 404
      if (! (check_dns_timeout > 0)) {
#line 404
        goto while_break___0;
      }
    }
    {
#line 411
    pr = get_first_internal_pdr();
    }
#line 412
    if (check_dns) {
#line 413
      next_timeout = check_dns_timeout;
    } else {
#line 415
      next_timeout = pr->next_timeout;
    }
    {
#line 416
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 416
      if (! pr) {
#line 416
        goto while_break___1;
      }
#line 417
      if (pr->next_timeout < next_timeout) {
#line 418
        next_timeout = pr->next_timeout;
      }
#line 419
      pr = pr->next;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 422
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 422
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.__fds_bits[0]): "memory");
#line 422
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 423
    fds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 424
    timeout.tv_sec = (__time_t )(next_timeout / 1000);
#line 425
    timeout.tv_usec = (__suseconds_t )((next_timeout % 1000) * 1000);
#line 428
    ret = select(fd + 1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
    }
#line 429
    if (ret < 0) {
      {
#line 430
      close(fd);
#line 431
      tmp___12 = __errno_location();
#line 431
      tmp___13 = strerror(*tmp___12);
#line 431
      syslog(3, "select: %s\n", tmp___13);
      }
#line 432
      return (102);
    }
#line 435
    if (ret) {
#line 435
      if ((fds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 439
        next_timeout = (int )((__time_t )next_timeout - (timeout.tv_sec * 1000L + timeout.tv_usec / 1000L));
#line 442
        tmp___16 = recvadv(fd, ifindex);
        }
#line 442
        if (tmp___16 < 0) {
          {
#line 443
          tmp___14 = __errno_location();
#line 443
          tmp___15 = strerror(*tmp___14);
#line 443
          syslog(3, "recvadv: %s\n", tmp___15);
          }
#line 444
          return (100);
        }
      }
    }
#line 447
    if (check_dns) {
#line 448
      check_dns_timeout -= next_timeout;
    }
    {
#line 451
    pr = get_first_internal_pdr();
    }
    {
#line 452
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 452
      if (! pr) {
#line 452
        goto while_break___3;
      }
#line 453
      pr->next_timeout -= next_timeout;
#line 454
      if (pr->next_timeout <= 0) {
#line 455
        if (verbose >= 1) {
          {
#line 457
          tmp___17 = inet_ntop(10, (void const   */* __restrict  */)(& pr->addr6.sin6_addr),
                               (char */* __restrict  */)(addrstr), (socklen_t )sizeof(addrstr));
#line 457
          syslog(6, "Soliciting %s\n", tmp___17);
          }
        }
        {
#line 463
        tmp___20 = send_rdisc(fd, ifindex, & pr->addr6.sin6_addr);
        }
#line 463
        if (tmp___20 < 0) {
#line 464
          if (verbose >= -1) {
            {
#line 465
            tmp___18 = __errno_location();
#line 465
            tmp___19 = strerror(*tmp___18);
#line 465
            syslog(3, "send_rdisc: %s\n", tmp___19);
            }
          }
#line 467
          return (100);
        }
#line 470
        (pr->rs_sent) ++;
#line 471
        if (pr->rs_sent >= 3) {
#line 472
          pr->rs_sent = 0;
#line 473
          pr->next_timeout += 120000;
        } else {
#line 475
          pr->next_timeout += 4000;
        }
      }
#line 477
      pr = pr->next;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 480
  close(fd);
  }
#line 481
  return (101);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 956 "/usr/include/unistd.h"
extern int fsync(int __fd ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 127 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static char *tunnel_name  =    (char *)((void *)0);
#line 45 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static char *interface_name  =    (char *)((void *)0);
#line 51 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static struct ROUTER_NAME *router_name  =    (struct ROUTER_NAME *)((void *)0);
#line 56 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static int rs_interval  =    65536;
#line 57 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static int dns_interval  =    3600;
#line 58 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
int verbose  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static int daemonize  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static char *pid_file  =    (char *)((void *)0);
#line 61 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static int ttl  =    64;
#line 62 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static int mtu  =    0;
#line 63 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static int pmtudisc  =    1;
#line 64 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static int volatile   go_down  =    (int volatile   )0;
#line 65 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static pid_t child  =    0;
#line 66 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static char *unpriv_username  =    (char *)"nobody";
#line 68 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static int syslog_facility  =    3 << 3;
#line 75 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static void show_help(void) 
{ 


  {
  {
#line 77
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: isatapd [OPTIONS] [ROUTER]...\n");
#line 78
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       -n --name       name of the tunnel\n");
#line 79
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       default: is0\n");
#line 80
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       -l --link       tunnel link device\n");
#line 81
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       default: auto\n");
#line 82
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       -m --mtu        set tunnel MTU\n");
#line 83
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       default: auto\n");
#line 84
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       -t --ttl        set tunnel hoplimit.\n");
#line 85
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       default: %d\n",
          64);
#line 86
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       -N --nopmtudisc disable ipv4 pmtu discovery.\n");
#line 87
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       default: pmtudisc enabled\n");
#line 88
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 90
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       -r --router     set potential router.\n");
#line 91
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       default: \'%s\'.\n",
          "isatap");
#line 93
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       -i --interval   interval to perform router solicitation\n");
#line 94
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       default: auto\n");
#line 95
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       -D --check-dns  interval to perform DNS resolution and\n");
#line 96
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       recreate PRL.\n");
#line 97
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       default: %d seconds\n",
          3600);
#line 98
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 100
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       -d --daemon     fork into background\n");
#line 101
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       -p --pid        store pid of daemon in file\n");
#line 102
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"          --user       drop privileges to this user\n");
#line 103
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       default: \'%s\'\n",
          "nobody");
#line 104
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 106
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       -v --verbose    increase verbosity\n");
#line 107
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       -q --quiet      decrease verbosity\n");
#line 108
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 110
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       -h --help       display this message\n");
#line 111
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"          --version    display version\n");
#line 113
  exit(1);
  }
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static void show_version(void) 
{ 


  {
  {
#line 118
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"isatapd-0.9.6\n\n");
#line 119
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Copyright (c) 2009 Sascha Hlusiak <mail@saschahlusiak.de>\n");
#line 120
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nThis is free software; You may redistribute copies of this software\n");
#line 121
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"under the terms of the GNU General Public License.\n");
#line 122
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"For more information about these matters, see the file named COPYING.\n");
#line 124
  exit(0);
  }
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static void add_router_to_name_list(char const   *name ) 
{ 
  struct ROUTER_NAME *n ;
  void *tmp ;

  {
  {
#line 134
  tmp = malloc(sizeof(struct ROUTER_NAME ));
#line 134
  n = (struct ROUTER_NAME *)tmp;
#line 135
  n->next = router_name;
#line 136
  router_name = n;
#line 137
  n->name = strdup(name);
  }
#line 138
  return;
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static void parse_options(int argc , char **argv ) 
{ 
  int c ;
  char const   *short_options ;
  struct option long_options[16] ;
  int long_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 145
  short_options = "hn:i:r:vqd1l:p:m:t:ND:";
#line 146
  long_options[0].name = "help";
#line 146
  long_options[0].has_arg = 0;
#line 146
  long_options[0].flag = (int *)((void *)0);
#line 146
  long_options[0].val = 'h';
#line 146
  long_options[1].name = "name";
#line 146
  long_options[1].has_arg = 1;
#line 146
  long_options[1].flag = (int *)((void *)0);
#line 146
  long_options[1].val = 'n';
#line 146
  long_options[2].name = "link";
#line 146
  long_options[2].has_arg = 1;
#line 146
  long_options[2].flag = (int *)((void *)0);
#line 146
  long_options[2].val = 'l';
#line 146
  long_options[3].name = "router";
#line 146
  long_options[3].has_arg = 1;
#line 146
  long_options[3].flag = (int *)((void *)0);
#line 146
  long_options[3].val = 'r';
#line 146
  long_options[4].name = "interval";
#line 146
  long_options[4].has_arg = 1;
#line 146
  long_options[4].flag = (int *)((void *)0);
#line 146
  long_options[4].val = 'i';
#line 146
  long_options[5].name = "check-dns";
#line 146
  long_options[5].has_arg = 1;
#line 146
  long_options[5].flag = (int *)((void *)0);
#line 146
  long_options[5].val = 'D';
#line 146
  long_options[6].name = "verbose";
#line 146
  long_options[6].has_arg = 0;
#line 146
  long_options[6].flag = (int *)((void *)0);
#line 146
  long_options[6].val = 'v';
#line 146
  long_options[7].name = "quiet";
#line 146
  long_options[7].has_arg = 0;
#line 146
  long_options[7].flag = (int *)((void *)0);
#line 146
  long_options[7].val = 'q';
#line 146
  long_options[8].name = "daemon";
#line 146
  long_options[8].has_arg = 0;
#line 146
  long_options[8].flag = (int *)((void *)0);
#line 146
  long_options[8].val = 'd';
#line 146
  long_options[9].name = "version";
#line 146
  long_options[9].has_arg = 0;
#line 146
  long_options[9].flag = (int *)((void *)0);
#line 146
  long_options[9].val = 'V';
#line 146
  long_options[10].name = "mtu";
#line 146
  long_options[10].has_arg = 1;
#line 146
  long_options[10].flag = (int *)((void *)0);
#line 146
  long_options[10].val = 'm';
#line 146
  long_options[11].name = "pid";
#line 146
  long_options[11].has_arg = 1;
#line 146
  long_options[11].flag = (int *)((void *)0);
#line 146
  long_options[11].val = 'p';
#line 146
  long_options[12].name = "ttl";
#line 146
  long_options[12].has_arg = 1;
#line 146
  long_options[12].flag = (int *)((void *)0);
#line 146
  long_options[12].val = 't';
#line 146
  long_options[13].name = "nopmtudisc";
#line 146
  long_options[13].has_arg = 0;
#line 146
  long_options[13].flag = (int *)((void *)0);
#line 146
  long_options[13].val = 'N';
#line 146
  long_options[14].name = "user";
#line 146
  long_options[14].has_arg = 1;
#line 146
  long_options[14].flag = (int *)((void *)0);
#line 146
  long_options[14].val = 'U';
#line 146
  long_options[15].name = (char const   *)((void *)0);
#line 146
  long_options[15].has_arg = 0;
#line 146
  long_options[15].flag = (int *)((void *)0);
#line 146
  long_options[15].val = 0;
#line 164
  long_index = 0;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 167
    c = getopt_long(argc, (char * const  *)argv, short_options, (struct option  const  *)(long_options),
                    & long_index);
    }
#line 168
    if (c == -1) {
#line 168
      goto while_break;
    }
    {
#line 172
    if (c == 110) {
#line 172
      goto case_110;
    }
#line 177
    if (c == 108) {
#line 177
      goto case_108;
    }
#line 182
    if (c == 114) {
#line 182
      goto case_114;
    }
#line 187
    if (c == 105) {
#line 187
      goto case_105;
    }
#line 201
    if (c == 68) {
#line 201
      goto case_68;
    }
#line 214
    if (c == 109) {
#line 214
      goto case_109;
    }
#line 221
    if (c == 116) {
#line 221
      goto case_116;
    }
#line 232
    if (c == 78) {
#line 232
      goto case_78;
    }
#line 236
    if (c == 100) {
#line 236
      goto case_100;
    }
#line 239
    if (c == 112) {
#line 239
      goto case_112;
    }
#line 242
    if (c == 85) {
#line 242
      goto case_85;
    }
#line 246
    if (c == 118) {
#line 246
      goto case_118;
    }
#line 249
    if (c == 113) {
#line 249
      goto case_113;
    }
#line 253
    if (c == 86) {
#line 253
      goto case_86;
    }
#line 259
    if (c == 63) {
#line 259
      goto case_63;
    }
#line 259
    if (c == 104) {
#line 259
      goto case_63;
    }
#line 256
    goto switch_default;
    case_110: /* CIL Label */ 
#line 172
    if (optarg) {
      {
#line 173
      tunnel_name = strdup((char const   *)optarg);
      }
    }
#line 174
    goto switch_break;
    case_108: /* CIL Label */ 
#line 177
    if (optarg) {
      {
#line 178
      interface_name = strdup((char const   *)optarg);
      }
    }
#line 179
    goto switch_break;
    case_114: /* CIL Label */ 
#line 182
    if (optarg) {
      {
#line 183
      add_router_to_name_list((char const   *)optarg);
      }
    }
#line 184
    goto switch_break;
    case_105: /* CIL Label */ 
#line 187
    if (optarg) {
      {
#line 188
      tmp = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%d",
                   & rs_interval);
      }
#line 188
      if (tmp < 1) {
        {
#line 189
        syslog(3, "invalid cardinal -- %s\n", optarg);
#line 190
        show_help();
        }
      } else
#line 188
      if (rs_interval < 0) {
        {
#line 189
        syslog(3, "invalid cardinal -- %s\n", optarg);
#line 190
        show_help();
        }
      }
#line 192
      if (rs_interval < 120) {
        {
#line 193
        syslog(3, "interval must be greater than %d sec\n", 120);
#line 195
        show_help();
        }
      }
    }
#line 198
    goto switch_break;
    case_68: /* CIL Label */ 
#line 201
    if (optarg) {
      {
#line 202
      tmp___0 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%d",
                       & dns_interval);
      }
#line 202
      if (tmp___0 < 1) {
        {
#line 203
        syslog(3, "invalid cardinal -- %s\n", optarg);
#line 204
        show_help();
        }
      } else
#line 202
      if (dns_interval < 0) {
        {
#line 203
        syslog(3, "invalid cardinal -- %s\n", optarg);
#line 204
        show_help();
        }
      }
#line 206
      if (dns_interval != 0) {
#line 206
        if (dns_interval < 120) {
          {
#line 207
          syslog(3, "dns-check interval must be greater than %d sec\n", 120);
#line 208
          show_help();
          }
        }
      }
    }
#line 211
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 214
    mtu = atoi((char const   *)optarg);
    }
#line 215
    if (mtu <= 0) {
      {
#line 216
      syslog(3, "invalid mtu -- %s\n", optarg);
#line 217
      show_help();
      }
    }
#line 219
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 221
    tmp___1 = strcmp((char const   *)optarg, "auto");
    }
#line 221
    if (tmp___1 == 0) {
#line 222
      ttl = 0;
    } else {
      {
#line 221
      tmp___2 = strcmp((char const   *)optarg, "inherit");
      }
#line 221
      if (tmp___2 == 0) {
#line 222
        ttl = 0;
      } else {
        {
#line 224
        ttl = atoi((char const   *)optarg);
        }
#line 225
        if (ttl <= 0) {
          {
#line 226
          syslog(3, "invalid ttl -- %s\n", optarg);
#line 227
          show_help();
          }
        } else
#line 225
        if (ttl > 255) {
          {
#line 226
          syslog(3, "invalid ttl -- %s\n", optarg);
#line 227
          show_help();
          }
        }
      }
    }
#line 230
    goto switch_break;
    case_78: /* CIL Label */ 
#line 232
    pmtudisc = 0;
#line 233
    goto switch_break;
    case_100: /* CIL Label */ 
#line 236
    daemonize = 1;
#line 237
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 239
    pid_file = strdup((char const   *)optarg);
    }
#line 240
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 242
    unpriv_username = strdup((char const   *)optarg);
    }
#line 243
    goto switch_break;
    case_118: /* CIL Label */ 
#line 246
    verbose ++;
#line 247
    goto switch_break;
    case_113: /* CIL Label */ 
#line 249
    verbose --;
#line 250
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 253
    show_version();
    }
#line 254
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 257
    syslog(3, "not implemented option -- %s\n", *(argv + (optind - 1)));
    }
    case_63: /* CIL Label */ 
    case_104: /* CIL Label */ 
    {
#line 260
    show_help();
    }
#line 261
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 265
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 265
    if (! (optind < argc)) {
#line 265
      goto while_break___0;
    }
    {
#line 266
    add_router_to_name_list((char const   *)*(argv + optind));
#line 265
    optind ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 267
  if ((unsigned long )router_name == (unsigned long )((void *)0)) {
    {
#line 268
    add_router_to_name_list("isatap");
    }
  }
#line 270
  if ((unsigned long )tunnel_name == (unsigned long )((void *)0)) {
    {
#line 271
    tunnel_name = strdup("is0");
    }
  }
  {
#line 272
  tmp___3 = strchr((char const   *)tunnel_name, ':');
  }
#line 272
  if (tmp___3) {
    {
#line 273
    syslog(3, "no \':\' in tunnel name: %s!\n", tunnel_name);
#line 274
    exit(1);
    }
  }
#line 276
  if (pmtudisc == 0) {
#line 276
    if (ttl) {
      {
#line 277
      syslog(3, "--nopmtudisc depends on --ttl inherit!\n");
#line 278
      exit(1);
      }
    }
  }
#line 280
  return;
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static int fill_internal_prl(void) 
{ 
  struct ROUTER_NAME *r ;
  struct PRLENTRY *e ;
  int tmp ;
  struct PRLENTRY *tmp___0 ;

  {
  {
#line 296
  e = get_first_internal_pdr();
  }
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (! e) {
#line 297
      goto while_break;
    }
#line 298
    e->stale = 1;
#line 299
    e = e->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  r = router_name;
  {
#line 303
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 303
    if (! r) {
#line 303
      goto while_break___0;
    }
    {
#line 305
    tmp = add_router_name_to_internal_prl((char const   *)r->name, rs_interval);
    }
#line 305
    if (tmp < 0) {
#line 306
      return (-1);
    }
#line 307
    r = r->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 310
  tmp___0 = get_first_internal_pdr();
  }
#line 310
  if (! tmp___0) {
#line 311
    return (-1);
  }
#line 312
  return (0);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static uint32_t get_tunnel_saddr(char const   *iface ) 
{ 
  uint32_t saddr ;
  struct PRLENTRY *pr ;
  int *tmp ;
  char *tmp___0 ;
  struct sockaddr_in addr ;
  struct sockaddr_in addr2 ;
  socklen_t addrlen ;
  int fd ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 326
  if (iface) {
    {
#line 327
    saddr = get_if_addr(iface);
    }
#line 328
    if (saddr == 0U) {
#line 329
      if (verbose >= -1) {
        {
#line 330
        tmp = __errno_location();
#line 330
        tmp___0 = strerror(*tmp);
#line 330
        syslog(3, "get_if_addr: %s\n", tmp___0);
        }
      }
    }
#line 332
    return (saddr);
  }
  {
#line 335
  pr = get_first_internal_pdr();
#line 336
  saddr = (uint32_t )0;
  }
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (! pr) {
#line 338
      goto while_break;
    }
    {
#line 341
    tmp___1 = socket(2, 2, 0);
#line 341
    fd = tmp___1;
    }
#line 342
    if (fd < 0) {
      {
#line 343
      tmp___2 = __errno_location();
#line 343
      tmp___3 = strerror(*tmp___2);
#line 343
      syslog(3, "socket: %s\n", tmp___3);
      }
#line 344
      goto while_break;
    }
    {
#line 348
    addr.sin_family = (sa_family_t )2;
#line 349
    addr.sin_port = (in_port_t )0;
#line 350
    addr.sin_addr.s_addr = pr->ip;
#line 351
    tmp___7 = connect(fd, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                      (socklen_t )sizeof(struct sockaddr_in ));
    }
#line 351
    if (tmp___7 == 0) {
      {
#line 353
      addrlen = (socklen_t )sizeof(addr2);
#line 354
      getsockname(fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& addr2)),
                  (socklen_t */* __restrict  */)(& addrlen));
      }
#line 355
      if ((unsigned long )addrlen == sizeof(addr2)) {
#line 356
        if (saddr == 0U) {
#line 357
          saddr = addr2.sin_addr.s_addr;
        } else
#line 358
        if (saddr != addr2.sin_addr.s_addr) {
          {
#line 359
          tmp___4 = inet_ntoa(addr2.sin_addr);
#line 359
          tmp___5 = inet_ntoa(addr.sin_addr);
#line 359
          syslog(4, "Outgoing interface for PDR %s differs from %s. Removing from internal PRL.\n",
                 tmp___5, tmp___4);
#line 362
          pr = del_internal_pdr(pr);
#line 363
          close(fd);
          }
#line 364
          goto while_continue;
        }
      }
    } else {
      {
#line 368
      tmp___6 = inet_ntoa(addr.sin_addr);
#line 368
      syslog(4, "PDR %s unreachable. Probing again next time.\n", tmp___6);
      }
    }
    {
#line 371
    close(fd);
#line 373
    pr = pr->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 375
  return (saddr);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static uint32_t wait_for_link(void) 
{ 
  uint32_t saddr ;
  unsigned int tmp ;

  {
  {
#line 384
  saddr = get_tunnel_saddr((char const   *)interface_name);
  }
#line 385
  if (saddr == 0U) {
#line 386
    if (verbose >= 0) {
#line 387
      if (interface_name) {
        {
#line 388
        syslog(6, "waiting for link %s to become ready...\n", interface_name);
        }
      } else {
        {
#line 390
        syslog(6, "waiting for router %s to become reachable...\n", router_name->name);
        }
      }
    }
    {
#line 393
    while (1) {
      while_continue: /* CIL Label */ ;
#line 394
      if (verbose >= 2) {
        {
#line 395
        syslog(7, "still waiting for link...\n");
        }
      }
      {
#line 397
      tmp = sleep(60U);
      }
#line 397
      if (tmp) {
#line 398
        return ((uint32_t )0);
      } else
#line 397
      if (go_down) {
#line 398
        return ((uint32_t )0);
      }
      {
#line 399
      saddr = get_tunnel_saddr((char const   *)interface_name);
      }
#line 393
      if (go_down == (int volatile   )0) {
#line 393
        if (! (saddr == 0U)) {
#line 393
          goto while_break;
        }
      } else {
#line 393
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 402
    if (verbose >= 0) {
#line 403
      if (saddr) {
#line 404
        if (interface_name) {
          {
#line 405
          syslog(6, "link %s became ready...\n", interface_name);
          }
        } else {
          {
#line 407
          syslog(6, "router %s became reachable...\n", router_name->name);
          }
        }
      }
    }
  }
#line 411
  return (saddr);
}
}
#line 419 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static void create_isatap_tunnel(uint32_t saddr ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  struct in_addr addr ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 422
  tmp___1 = tunnel_add((char const   *)tunnel_name, (char const   *)interface_name,
                       saddr, (uint8_t )ttl, pmtudisc);
  }
#line 422
  if (tmp___1 < 0) {
#line 423
    if (verbose >= -1) {
      {
#line 424
      tmp = __errno_location();
#line 424
      tmp___0 = strerror(*tmp);
#line 424
      syslog(3, "tunnel_add: %s\n", tmp___0);
      }
    }
    {
#line 425
    exit(1);
    }
  }
#line 428
  if (verbose >= 1) {
#line 430
    addr.s_addr = saddr;
#line 431
    if (pmtudisc) {
#line 431
      tmp___2 = "pmtudisc";
    } else {
#line 431
      tmp___2 = "nopmtudisc";
    }
    {
#line 431
    tmp___3 = inet_ntoa(addr);
#line 431
    syslog(6, "%s created (local %s, %s)\n", tunnel_name, tmp___3, tmp___2);
    }
  }
#line 435
  if (mtu > 0) {
    {
#line 436
    tmp___6 = tunnel_set_mtu((char const   *)tunnel_name, mtu);
    }
#line 436
    if (tmp___6 < 0) {
#line 437
      if (verbose >= -1) {
        {
#line 438
        tmp___4 = __errno_location();
#line 438
        tmp___5 = strerror(*tmp___4);
#line 438
        syslog(3, "tunnel_set_mtu: %s\n", tmp___5);
        }
      }
      {
#line 439
      tunnel_del((char const   *)tunnel_name);
#line 440
      exit(1);
      }
    }
  }
  {
#line 444
  tmp___9 = tunnel_up((char const   *)tunnel_name);
  }
#line 444
  if (tmp___9 < 0) {
#line 445
    if (verbose >= -1) {
      {
#line 446
      tmp___7 = __errno_location();
#line 446
      tmp___8 = strerror(*tmp___7);
#line 446
      syslog(3, "tunnel_up: %s\n", tmp___8);
      }
    }
    {
#line 447
    tunnel_del((char const   *)tunnel_name);
#line 448
    exit(1);
    }
  }
#line 450
  if (verbose >= 0) {
    {
#line 451
    syslog(5, "interface %s up\n", tunnel_name);
    }
  }
#line 452
  return;
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static void delete_isatap_tunnel(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 459
  tmp___1 = tunnel_down((char const   *)tunnel_name);
  }
#line 459
  if (tmp___1 < 0) {
#line 460
    if (verbose >= -1) {
      {
#line 461
      tmp = __errno_location();
#line 461
      tmp___0 = strerror(*tmp);
#line 461
      syslog(3, "tunnel_down: %s\n", tmp___0);
      }
    }
  } else
#line 462
  if (verbose >= 0) {
    {
#line 463
    syslog(5, "interface %s down\n", tunnel_name);
    }
  }
  {
#line 465
  tmp___4 = tunnel_del((char const   *)tunnel_name);
  }
#line 465
  if (tmp___4 < 0) {
#line 466
    if (verbose >= -1) {
      {
#line 467
      tmp___2 = __errno_location();
#line 467
      tmp___3 = strerror(*tmp___2);
#line 467
      syslog(3, "tunnel_del: %s\n", tmp___3);
      }
    }
  } else
#line 468
  if (verbose >= 1) {
    {
#line 469
    syslog(6, "%s deleted\n", tunnel_name);
    }
  }
#line 470
  return;
}
}
#line 472 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static void write_pid_file(void) 
{ 
  struct flock fl ;
  char s[32] ;
  int pf ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  ssize_t tmp___5 ;
  size_t tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
  {
#line 478
  pf = open((char const   *)pid_file, 577, 420);
  }
#line 479
  if (pf < 0) {
    {
#line 480
    tmp = __errno_location();
#line 480
    tmp___0 = strerror(*tmp);
#line 480
    syslog(3, "Cannot create pid file, terminating: %s\n", tmp___0);
#line 481
    exit(1);
    }
  }
  {
#line 484
  tmp___1 = getpid();
#line 484
  snprintf((char */* __restrict  */)(s), sizeof(s), (char const   */* __restrict  */)"%d\n",
           tmp___1);
#line 485
  tmp___4 = strlen((char const   *)(s));
#line 485
  tmp___5 = write(pf, (void const   *)(s), tmp___4);
#line 485
  tmp___6 = strlen((char const   *)(s));
  }
#line 485
  if ((size_t )tmp___5 < tmp___6) {
    {
#line 486
    tmp___2 = __errno_location();
#line 486
    tmp___3 = strerror(*tmp___2);
#line 486
    syslog(3, "write: %s\n", tmp___3);
    }
  }
  {
#line 487
  tmp___9 = fsync(pf);
  }
#line 487
  if (tmp___9 < 0) {
    {
#line 488
    tmp___7 = __errno_location();
#line 488
    tmp___8 = strerror(*tmp___7);
#line 488
    syslog(3, "fsync: %s\n", tmp___8);
    }
  }
  {
#line 490
  fl.l_type = (short)1;
#line 491
  fl.l_whence = (short)0;
#line 492
  fl.l_start = (__off_t )0;
#line 493
  fl.l_len = (__off_t )0;
#line 495
  tmp___12 = fcntl(pf, 6, & fl);
  }
#line 495
  if (tmp___12 < 0) {
    {
#line 496
    tmp___10 = __errno_location();
#line 496
    tmp___11 = strerror(*tmp___10);
#line 496
    syslog(3, "Cannot lock pid file, terminating: %s\n", tmp___11);
#line 497
    exit(1);
    }
  }
#line 499
  return;
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static void sigint_handler(int sig ) 
{ 


  {
  {
#line 510
  signal(sig, (void (*)(int  ))0);
  }
#line 511
  if (verbose >= 0) {
    {
#line 512
    syslog(5, "signal %d received, going down.\n", sig);
    }
  }
#line 513
  if (child) {
    {
#line 514
    kill(child, 1);
    }
  }
#line 515
  go_down = (int volatile   )1;
#line 516
  return;
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static void sighup_handler(int sig ) 
{ 


  {
#line 526
  if (verbose >= 0) {
    {
#line 527
    syslog(5, "SIGHUP received.\n");
    }
  }
#line 528
  if (child) {
    {
#line 529
    kill(child, 1);
    }
  }
#line 530
  return;
}
}
#line 532 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
static void setup_signals(void) 
{ 


  {
  {
#line 534
  signal(2, & sigint_handler);
#line 535
  signal(15, & sigint_handler);
#line 536
  signal(1, & sighup_handler);
  }
#line 537
  return;
}
}
#line 541 "/home/june/repo/benchmarks/collector/temp/isatapd-0.9.6/src/main.c"
int main(int argc , char **argv ) 
{ 
  uint32_t saddr ;
  pid_t pid ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  uint32_t saddr_n ;
  int status ;
  int *tmp___2 ;
  char *tmp___3 ;
  union __anonunion_64 __constr_expr_0 ;
  union __anonunion_65 __constr_expr_1 ;
  struct PRLENTRY *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 545
  openlog((char const   *)((void *)0), 33, syslog_facility);
#line 546
  parse_options(argc, argv);
  }
#line 548
  if (daemonize == 1) {
    {
#line 551
    pid = fork();
    }
#line 552
    if (pid < 0) {
      {
#line 553
      tmp = __errno_location();
#line 553
      tmp___0 = strerror(*tmp);
#line 553
      syslog(3, "fork: %s\n", tmp___0);
#line 554
      exit(1);
      }
    }
#line 556
    if (pid > 0) {
#line 558
      if (verbose >= 1) {
        {
#line 559
        syslog(6, "Running isatap daemon as pid %d\n", pid);
        }
      }
      {
#line 560
      exit(0);
      }
    }
    {
#line 563
    setsid();
#line 564
    close(0);
#line 565
    close(1);
#line 566
    close(2);
    }
  }
#line 570
  if ((unsigned long )pid_file != (unsigned long )((void *)0)) {
    {
#line 571
    write_pid_file();
    }
  }
  {
#line 573
  setup_signals();
  }
  begin: 
  {
#line 576
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 576
    tmp___1 = fill_internal_prl();
    }
#line 576
    if (! (tmp___1 < 0)) {
#line 576
      goto while_break;
    }
#line 577
    if (verbose >= 0) {
      {
#line 578
      syslog(6, "Internal PRL empty! Rechecking in %d sec.\n", 60);
      }
    }
    {
#line 579
    sleep(60U);
    }
#line 580
    if (go_down) {
#line 581
      goto end;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 585
  saddr = wait_for_link();
  }
#line 586
  if (go_down) {
#line 587
    goto end;
  }
#line 588
  if (saddr == 0U) {
#line 589
    goto begin;
  }
  {
#line 590
  create_isatap_tunnel(saddr);
  }
  {
#line 592
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 592
    if (! (! go_down)) {
#line 592
      goto while_break___0;
    }
    {
#line 597
    child = fork();
    }
#line 598
    if (child < 0) {
      {
#line 599
      tmp___2 = __errno_location();
#line 599
      tmp___3 = strerror(*tmp___2);
#line 599
      syslog(3, "fork: %s\n", tmp___3);
      }
#line 600
      goto while_break___0;
    }
#line 602
    if (child) {
      {
#line 606
      waitpid(child, & status, 0);
#line 607
      __constr_expr_1.__in = status;
      }
#line 607
      if ((__constr_expr_1.__i & 127) == 0) {
#line 608
        __constr_expr_0.__in = status;
#line 608
        status = (__constr_expr_0.__i & 65280) >> 8;
      }
#line 609
      if (verbose >= 2) {
        {
#line 610
        syslog(6, "Solicitation Loop exited with status %d\n", status);
        }
      }
#line 611
      child = 0;
    } else {
      {
#line 615
      status = run_solicitation_loop(tunnel_name, dns_interval * 1000, unpriv_username);
#line 616
      closelog();
#line 617
      exit(status);
      }
    }
#line 621
    if (go_down) {
#line 622
      goto while_break___0;
    }
#line 624
    if (status == 101) {
#line 626
      if (verbose >= 1) {
        {
#line 627
        syslog(6, "Rechecking DNS entries for PRL\n");
        }
      }
      {
#line 629
      fill_internal_prl();
#line 630
      prune_kernel_prl((char const   *)tunnel_name);
#line 632
      tmp___4 = get_first_internal_pdr();
      }
#line 632
      if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
        {
#line 634
        delete_isatap_tunnel();
        }
#line 635
        goto begin;
      }
    }
#line 638
    if (status == 102) {
      {
#line 639
      syslog(3, "Child exited with ERROR_FATAL. Going down.\n");
      }
#line 640
      goto while_break___0;
    }
    {
#line 644
    saddr_n = get_tunnel_saddr((char const   *)interface_name);
    }
#line 646
    if (saddr_n != saddr) {
      {
#line 647
      syslog(4, "Link change detected. Re-creating tunnel.\n");
#line 648
      delete_isatap_tunnel();
      }
#line 649
      goto begin;
    } else
#line 646
    if (saddr_n == 0U) {
      {
#line 647
      syslog(4, "Link change detected. Re-creating tunnel.\n");
#line 648
      delete_isatap_tunnel();
      }
#line 649
      goto begin;
    } else
#line 646
    if (status == 100) {
      {
#line 647
      syslog(4, "Link change detected. Re-creating tunnel.\n");
#line 648
      delete_isatap_tunnel();
      }
#line 649
      goto begin;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 652
  delete_isatap_tunnel();
  }
  end: 
#line 656
  if (pid_file) {
    {
#line 657
    tmp___7 = unlink((char const   *)pid_file);
    }
#line 657
    if (tmp___7 < 0) {
      {
#line 658
      tmp___5 = __errno_location();
#line 658
      tmp___6 = strerror(*tmp___5);
#line 658
      syslog(4, "cannot unlink pid file: %s\n", tmp___6);
      }
    }
  }
  {
#line 660
  closelog();
  }
#line 662
  return (0);
}
}
