/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 128 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 59 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 163 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 92 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag sigjmp_buf[1];
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_17 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_18 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_19 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_20 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_21 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_22 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_23 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_16 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_17 _kill ;
   struct __anonstruct__timer_18 _timer ;
   struct __anonstruct__rt_19 _rt ;
   struct __anonstruct__sigchld_20 _sigchld ;
   struct __anonstruct__sigfault_21 _sigfault ;
   struct __anonstruct__sigpoll_22 _sigpoll ;
   struct __anonstruct__sigsys_23 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_15 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_16 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_15 siginfo_t;
#line 343 "/usr/include/stdlib.h"
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
#line 412 "/usr/include/stdlib.h"
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 34 "/usr/include/x86_64-linux-gnu/sys/times.h"
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/netdb.h"
struct netent {
   char *n_name ;
   char **n_aliases ;
   int n_addrtype ;
   uint32_t n_net ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 326 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 37 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent64 {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 1740 "/usr/lib/perl/5.18/CORE/perl.h"
typedef long IV;
#line 1741 "/usr/lib/perl/5.18/CORE/perl.h"
typedef unsigned long UV;
#line 1947 "/usr/lib/perl/5.18/CORE/perl.h"
typedef double NV;
#line 2424 "/usr/lib/perl/5.18/CORE/perl.h"
typedef size_t STRLEN;
#line 2431
struct op;
#line 2431 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct op OP;
#line 2432
struct cop;
#line 2432 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct cop COP;
#line 2437
struct pmop;
#line 2437 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct pmop PMOP;
#line 2441
struct loop;
#line 2441 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct loop LOOP;
#line 2451
struct interpreter;
#line 2451 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct interpreter PerlInterpreter;
#line 2459
struct sv;
#line 2459 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct sv SV;
#line 2460
struct av;
#line 2460 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct av AV;
#line 2461
struct hv;
#line 2461 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct hv HV;
#line 2462
struct cv;
#line 2462 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct cv CV;
#line 2463
struct p5rx;
#line 2463 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct p5rx REGEXP;
#line 2464
struct gp;
#line 2464 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct gp GP;
#line 2465
struct gv;
#line 2465 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct gv GV;
#line 2466
struct io;
#line 2467
struct context;
#line 2467 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct context PERL_CONTEXT;
#line 2468
struct block;
#line 2470
struct magic;
#line 2470 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct magic MAGIC;
#line 2471
struct xpv;
#line 2471 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct xpv XPV;
#line 2472
struct xpviv;
#line 2472 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct xpviv XPVIV;
#line 2474
struct xpvnv;
#line 2474 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct xpvnv XPVNV;
#line 2477
struct xpvav;
#line 2477 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct xpvav XPVAV;
#line 2478
struct xpvhv;
#line 2478 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct xpvhv XPVHV;
#line 2479
struct xpvgv;
#line 2479 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct xpvgv XPVGV;
#line 2480
struct xpvcv;
#line 2480 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct xpvcv XPVCV;
#line 2483
struct xpvio;
#line 2483 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct xpvio XPVIO;
#line 2484
struct mgvtbl;
#line 2484 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct mgvtbl MGVTBL;
#line 2485
union any;
#line 2485 "/usr/lib/perl/5.18/CORE/perl.h"
typedef union any ANY;
#line 2486
struct ptr_tbl_ent;
#line 2487
struct ptr_tbl;
#line 2487 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct ptr_tbl PTR_TBL_t;
#line 2488
struct clone_params;
#line 2488 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct clone_params CLONE_PARAMS;
#line 2492
struct padlist;
#line 2492 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct padlist PADLIST;
#line 2493 "/usr/lib/perl/5.18/CORE/perl.h"
typedef AV PAD;
#line 2494 "/usr/lib/perl/5.18/CORE/perl.h"
typedef AV PADNAMELIST;
#line 179 "/usr/lib/perl/5.18/CORE/handy.h"
typedef signed char I8;
#line 180 "/usr/lib/perl/5.18/CORE/handy.h"
typedef unsigned char U8;
#line 182 "/usr/lib/perl/5.18/CORE/handy.h"
typedef unsigned short U16;
#line 183 "/usr/lib/perl/5.18/CORE/handy.h"
typedef int I32;
#line 184 "/usr/lib/perl/5.18/CORE/handy.h"
typedef unsigned int U32;
#line 1377 "/usr/lib/perl/5.18/CORE/handy.h"
typedef U32 line_t;
#line 2890 "/usr/lib/perl/5.18/CORE/perl.h"
typedef pthread_key_t perl_key;
#line 3383 "/usr/lib/perl/5.18/CORE/perl.h"
union any {
   void *any_ptr ;
   I32 any_i32 ;
   IV any_iv ;
   UV any_uv ;
   long any_long ;
   _Bool any_bool ;
   void (*any_dptr)(void * ) ;
   void (*any_dxptr)(PerlInterpreter *my_perl  __attribute__((__unused__)) , void * ) ;
};
#line 94 "/usr/lib/perl/5.18/CORE/perlio.h"
struct _PerlIO;
#line 94 "/usr/lib/perl/5.18/CORE/perlio.h"
typedef struct _PerlIO PerlIOl;
#line 96 "/usr/lib/perl/5.18/CORE/perlio.h"
typedef PerlIOl *PerlIO;
#line 378
struct PerlIO_list_s;
#line 378 "/usr/lib/perl/5.18/CORE/perlio.h"
typedef struct PerlIO_list_s PerlIO_list_t;
#line 244 "/usr/lib/perl/5.18/CORE/perly.h"
union YYSTYPE {
   I32 ival ;
   char *pval ;
   OP *opval ;
   GV *gvval ;
   char *p_tkval ;
   I32 i_tkval ;
};
#line 244 "/usr/lib/perl/5.18/CORE/perly.h"
typedef union YYSTYPE YYSTYPE;
#line 169 "/usr/lib/perl/5.18/CORE/sv.h"
struct he;
#line 169 "/usr/lib/perl/5.18/CORE/sv.h"
typedef struct he HE;
#line 170
struct hek;
#line 170 "/usr/lib/perl/5.18/CORE/sv.h"
typedef struct hek HEK;
#line 194
struct regexp;
#line 194 "/usr/lib/perl/5.18/CORE/sv.h"
union __anonunion_sv_u_80 {
   char *svu_pv ;
   IV svu_iv ;
   UV svu_uv ;
   SV *svu_rv ;
   struct regexp *svu_rx ;
   SV **svu_array ;
   HE **svu_hash ;
   GP *svu_gp ;
   PerlIO *svu_fp ;
};
#line 194 "/usr/lib/perl/5.18/CORE/sv.h"
struct sv {
   void *sv_any ;
   U32 sv_refcnt ;
   U32 sv_flags ;
   union __anonunion_sv_u_80 sv_u ;
};
#line 207 "/usr/lib/perl/5.18/CORE/sv.h"
union __anonunion_sv_u_81 {
   char *svu_pv ;
   IV svu_iv ;
   UV svu_uv ;
   SV *svu_rv ;
   struct regexp *svu_rx ;
   SV **svu_array ;
   HE **svu_hash ;
   GP *svu_gp ;
   PerlIO *svu_fp ;
};
#line 207 "/usr/lib/perl/5.18/CORE/sv.h"
struct gv {
   XPVGV *sv_any ;
   U32 sv_refcnt ;
   U32 sv_flags ;
   union __anonunion_sv_u_81 sv_u ;
};
#line 212 "/usr/lib/perl/5.18/CORE/sv.h"
union __anonunion_sv_u_82 {
   char *svu_pv ;
   IV svu_iv ;
   UV svu_uv ;
   SV *svu_rv ;
   struct regexp *svu_rx ;
   SV **svu_array ;
   HE **svu_hash ;
   GP *svu_gp ;
   PerlIO *svu_fp ;
};
#line 212 "/usr/lib/perl/5.18/CORE/sv.h"
struct cv {
   XPVCV *sv_any ;
   U32 sv_refcnt ;
   U32 sv_flags ;
   union __anonunion_sv_u_82 sv_u ;
};
#line 217 "/usr/lib/perl/5.18/CORE/sv.h"
union __anonunion_sv_u_83 {
   char *svu_pv ;
   IV svu_iv ;
   UV svu_uv ;
   SV *svu_rv ;
   struct regexp *svu_rx ;
   SV **svu_array ;
   HE **svu_hash ;
   GP *svu_gp ;
   PerlIO *svu_fp ;
};
#line 217 "/usr/lib/perl/5.18/CORE/sv.h"
struct av {
   XPVAV *sv_any ;
   U32 sv_refcnt ;
   U32 sv_flags ;
   union __anonunion_sv_u_83 sv_u ;
};
#line 222 "/usr/lib/perl/5.18/CORE/sv.h"
union __anonunion_sv_u_84 {
   char *svu_pv ;
   IV svu_iv ;
   UV svu_uv ;
   SV *svu_rv ;
   struct regexp *svu_rx ;
   SV **svu_array ;
   HE **svu_hash ;
   GP *svu_gp ;
   PerlIO *svu_fp ;
};
#line 222 "/usr/lib/perl/5.18/CORE/sv.h"
struct hv {
   XPVHV *sv_any ;
   U32 sv_refcnt ;
   U32 sv_flags ;
   union __anonunion_sv_u_84 sv_u ;
};
#line 227 "/usr/lib/perl/5.18/CORE/sv.h"
union __anonunion_sv_u_85 {
   char *svu_pv ;
   IV svu_iv ;
   UV svu_uv ;
   SV *svu_rv ;
   struct regexp *svu_rx ;
   SV **svu_array ;
   HE **svu_hash ;
   GP *svu_gp ;
   PerlIO *svu_fp ;
};
#line 227 "/usr/lib/perl/5.18/CORE/sv.h"
struct io {
   XPVIO *sv_any ;
   U32 sv_refcnt ;
   U32 sv_flags ;
   union __anonunion_sv_u_85 sv_u ;
};
#line 232 "/usr/lib/perl/5.18/CORE/sv.h"
union __anonunion_sv_u_86 {
   char *svu_pv ;
   IV svu_iv ;
   UV svu_uv ;
   SV *svu_rv ;
   struct regexp *svu_rx ;
   SV **svu_array ;
   HE **svu_hash ;
   GP *svu_gp ;
   PerlIO *svu_fp ;
};
#line 232 "/usr/lib/perl/5.18/CORE/sv.h"
struct p5rx {
   struct regexp *sv_any ;
   U32 sv_refcnt ;
   U32 sv_flags ;
   union __anonunion_sv_u_86 sv_u ;
};
#line 459 "/usr/lib/perl/5.18/CORE/sv.h"
struct __anonstruct_xpad_cop_seq_87 {
   U32 xlow ;
   U32 xhigh ;
};
#line 459 "/usr/lib/perl/5.18/CORE/sv.h"
struct __anonstruct_xbm_s_88 {
   I32 xbm_useful ;
   U8 xbm_rare ;
};
#line 459 "/usr/lib/perl/5.18/CORE/sv.h"
union _xnvu {
   NV xnv_nv ;
   HV *xgv_stash ;
   struct __anonstruct_xpad_cop_seq_87 xpad_cop_seq ;
   struct __anonstruct_xbm_s_88 xbm_s ;
};
#line 472 "/usr/lib/perl/5.18/CORE/sv.h"
union _xivu {
   IV xivu_iv ;
   UV xivu_uv ;
   HEK *xivu_namehek ;
};
#line 478 "/usr/lib/perl/5.18/CORE/sv.h"
union _xmgu {
   MAGIC *xmg_magic ;
   HV *xmg_ourstash ;
   STRLEN xmg_hash_index ;
};
#line 484 "/usr/lib/perl/5.18/CORE/sv.h"
union __anonunion_xpv_len_u_89 {
   STRLEN xpvlenu_len ;
   char *xpvlenu_pv ;
};
#line 484 "/usr/lib/perl/5.18/CORE/sv.h"
struct xpv {
   HV *xmg_stash ;
   union _xmgu xmg_u ;
   STRLEN xpv_cur ;
   union __anonunion_xpv_len_u_89 xpv_len_u ;
};
#line 488 "/usr/lib/perl/5.18/CORE/sv.h"
union __anonunion_xpv_len_u_90 {
   STRLEN xpvlenu_len ;
   char *xpvlenu_pv ;
};
#line 488 "/usr/lib/perl/5.18/CORE/sv.h"
struct xpviv {
   HV *xmg_stash ;
   union _xmgu xmg_u ;
   STRLEN xpv_cur ;
   union __anonunion_xpv_len_u_90 xpv_len_u ;
   union _xivu xiv_u ;
};
#line 502 "/usr/lib/perl/5.18/CORE/sv.h"
union __anonunion_xpv_len_u_92 {
   STRLEN xpvlenu_len ;
   char *xpvlenu_pv ;
};
#line 502 "/usr/lib/perl/5.18/CORE/sv.h"
struct xpvnv {
   HV *xmg_stash ;
   union _xmgu xmg_u ;
   STRLEN xpv_cur ;
   union __anonunion_xpv_len_u_92 xpv_len_u ;
   union _xivu xiv_u ;
   union _xnvu xnv_u ;
};
#line 529 "/usr/lib/perl/5.18/CORE/sv.h"
union __anonunion_xpv_len_u_95 {
   STRLEN xpvlenu_len ;
   char *xpvlenu_pv ;
};
#line 529 "/usr/lib/perl/5.18/CORE/sv.h"
struct xpvgv {
   HV *xmg_stash ;
   union _xmgu xmg_u ;
   STRLEN xpv_cur ;
   union __anonunion_xpv_len_u_95 xpv_len_u ;
   union _xivu xiv_u ;
   union _xnvu xnv_u ;
};
#line 535 "/usr/lib/perl/5.18/CORE/sv.h"
typedef U16 cv_flags_t;
#line 568 "/usr/lib/perl/5.18/CORE/sv.h"
union __anonunion_xpv_len_u_100 {
   STRLEN xpvlenu_len ;
   char *xpvlenu_pv ;
};
#line 568 "/usr/lib/perl/5.18/CORE/sv.h"
union __anonunion_xio_dirpu_101 {
   DIR *xiou_dirp ;
   void *xiou_any ;
};
#line 568 "/usr/lib/perl/5.18/CORE/sv.h"
struct xpvio {
   HV *xmg_stash ;
   union _xmgu xmg_u ;
   STRLEN xpv_cur ;
   union __anonunion_xpv_len_u_100 xpv_len_u ;
   union _xivu xiv_u ;
   PerlIO *xio_ofp ;
   union __anonunion_xio_dirpu_101 xio_dirpu ;
   IV xio_page ;
   IV xio_page_len ;
   IV xio_lines_left ;
   char *xio_top_name ;
   GV *xio_top_gv ;
   char *xio_fmt_name ;
   GV *xio_fmt_gv ;
   char *xio_bottom_name ;
   GV *xio_bottom_gv ;
   char xio_type ;
   U8 xio_flags ;
};
#line 2135 "/usr/lib/perl/5.18/CORE/sv.h"
struct clone_params {
   AV *stashes ;
   UV flags ;
   PerlInterpreter *proto_perl ;
   PerlInterpreter *new_perl ;
   AV *unreferenced ;
};
#line 23 "/usr/lib/perl/5.18/CORE/regexp.h"
struct regnode {
   U8 flags ;
   U8 type ;
   U16 next_off ;
};
#line 29 "/usr/lib/perl/5.18/CORE/regexp.h"
typedef struct regnode regnode;
#line 31
struct reg_substr_data;
#line 35
struct regexp_engine;
#line 38 "/usr/lib/perl/5.18/CORE/regexp.h"
struct reg_substr_datum {
   I32 min_offset ;
   I32 max_offset ;
   SV *substr ;
   SV *utf8_substr ;
   I32 end_shift ;
};
#line 45 "/usr/lib/perl/5.18/CORE/regexp.h"
struct reg_substr_data {
   struct reg_substr_datum data[3] ;
};
#line 57 "/usr/lib/perl/5.18/CORE/regexp.h"
struct regexp_paren_pair {
   I32 start ;
   I32 end ;
   I32 start_tmp ;
};
#line 57 "/usr/lib/perl/5.18/CORE/regexp.h"
typedef struct regexp_paren_pair regexp_paren_pair;
#line 138 "/usr/lib/perl/5.18/CORE/regexp.h"
union __anonunion_xpv_len_u_102 {
   STRLEN xpvlenu_len ;
   char *xpvlenu_pv ;
};
#line 138 "/usr/lib/perl/5.18/CORE/regexp.h"
struct regexp {
   HV *xmg_stash ;
   union _xmgu xmg_u ;
   STRLEN xpv_cur ;
   union __anonunion_xpv_len_u_102 xpv_len_u ;
   struct regexp_engine  const  *engine ;
   REGEXP *mother_re ;
   HV *paren_names ;
   U32 extflags ;
   I32 minlen ;
   I32 minlenret ;
   U32 gofs ;
   struct reg_substr_data *substrs ;
   U32 nparens ;
   U32 intflags ;
   void *pprivate ;
   U32 lastparen ;
   U32 lastcloseparen ;
   regexp_paren_pair *offs ;
   char *subbeg ;
   I32 sublen ;
   I32 suboffset ;
   I32 subcoffset ;
   unsigned int pre_prefix : 4 ;
   unsigned int compflags : 9 ;
   CV *qr_anoncv ;
};
#line 146 "/usr/lib/perl/5.18/CORE/regexp.h"
struct re_scream_pos_data_s {
   char **scream_olds ;
   I32 *scream_pos ;
};
#line 146 "/usr/lib/perl/5.18/CORE/regexp.h"
typedef struct re_scream_pos_data_s re_scream_pos_data;
#line 155 "/usr/lib/perl/5.18/CORE/regexp.h"
struct regexp_engine {
   REGEXP *(*comp)(PerlInterpreter *my_perl  __attribute__((__unused__)) , SV * const  pattern ,
                   U32 flags ) ;
   I32 (*exec)(PerlInterpreter *my_perl  __attribute__((__unused__)) , REGEXP * const  rx ,
               char *stringarg , char *strend , char *strbeg , I32 minend , SV *screamer ,
               void *data , U32 flags ) ;
   char *(*intuit)(PerlInterpreter *my_perl  __attribute__((__unused__)) , REGEXP * const  rx ,
                   SV *sv , char *strpos , char *strend , U32 const   flags , re_scream_pos_data *data ) ;
   SV *(*checkstr)(PerlInterpreter *my_perl  __attribute__((__unused__)) , REGEXP * const  rx ) ;
   void (*free)(PerlInterpreter *my_perl  __attribute__((__unused__)) , REGEXP * const  rx ) ;
   void (*numbered_buff_FETCH)(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                               REGEXP * const  rx , I32 const   paren , SV * const  sv ) ;
   void (*numbered_buff_STORE)(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                               REGEXP * const  rx , I32 const   paren , SV const   * const  value ) ;
   I32 (*numbered_buff_LENGTH)(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                               REGEXP * const  rx , SV const   * const  sv , I32 const   paren ) ;
   SV *(*named_buff)(PerlInterpreter *my_perl  __attribute__((__unused__)) , REGEXP * const  rx ,
                     SV * const  key , SV * const  value , U32 const   flags ) ;
   SV *(*named_buff_iter)(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                          REGEXP * const  rx , SV const   * const  lastkey , U32 const   flags ) ;
   SV *(*qr_package)(PerlInterpreter *my_perl  __attribute__((__unused__)) , REGEXP * const  rx ) ;
   void *(*dupe)(PerlInterpreter *my_perl  __attribute__((__unused__)) , REGEXP * const  rx ,
                 CLONE_PARAMS *param ) ;
   REGEXP *(*op_comp)(PerlInterpreter *my_perl  __attribute__((__unused__)) , SV ** const  patternp ,
                      int pat_count , OP *expr , struct regexp_engine  const  *eng ,
                      REGEXP * volatile  old_re , _Bool *is_bare_re , U32 orig_rx_flags ,
                      U32 pm_flags ) ;
};
#line 595 "/usr/lib/perl/5.18/CORE/regexp.h"
typedef I32 CHECKPOINT;
#line 597 "/usr/lib/perl/5.18/CORE/regexp.h"
struct __anonstruct_yes_106 {
   struct regmatch_state *prev_yes_state ;
};
#line 597 "/usr/lib/perl/5.18/CORE/regexp.h"
struct __anonstruct_branchlike_107 {
   struct regmatch_state *prev_yes_state ;
   U32 lastparen ;
   U32 lastcloseparen ;
   CHECKPOINT cp ;
};
#line 597 "/usr/lib/perl/5.18/CORE/regexp.h"
struct __anonstruct_branch_108 {
   struct regmatch_state *prev_yes_state ;
   U32 lastparen ;
   U32 lastcloseparen ;
   CHECKPOINT cp ;
   regnode *next_branch ;
};
#line 597 "/usr/lib/perl/5.18/CORE/regexp.h"
struct __anonstruct_trie_109 {
   struct regmatch_state *prev_yes_state ;
   U32 lastparen ;
   U32 lastcloseparen ;
   CHECKPOINT cp ;
   U32 accepted ;
   _Bool longfold ;
   U16 *jump ;
   regnode *me ;
   U8 *firstpos ;
   U32 firstchars ;
   U16 nextword ;
   U16 topword ;
};
#line 597 "/usr/lib/perl/5.18/CORE/regexp.h"
struct __anonstruct_eval_110 {
   struct regmatch_state *prev_yes_state ;
   struct regmatch_state *prev_eval ;
   struct regmatch_state *prev_curlyx ;
   REGEXP *prev_rex ;
   _Bool saved_utf8_pat ;
   CHECKPOINT cp ;
   CHECKPOINT lastcp ;
   U32 close_paren ;
   regnode *B ;
};
#line 597 "/usr/lib/perl/5.18/CORE/regexp.h"
struct __anonstruct_ifmatch_111 {
   struct regmatch_state *prev_yes_state ;
   I32 wanted ;
   I32 logical ;
   regnode *me ;
};
#line 597 "/usr/lib/perl/5.18/CORE/regexp.h"
struct __anonstruct_mark_112 {
   struct regmatch_state *prev_yes_state ;
   struct regmatch_state *prev_mark ;
   SV *mark_name ;
   char *mark_loc ;
};
#line 597 "/usr/lib/perl/5.18/CORE/regexp.h"
struct __anonstruct_keeper_113 {
   int val ;
};
#line 597 "/usr/lib/perl/5.18/CORE/regexp.h"
struct __anonstruct_curlyx_114 {
   struct regmatch_state *prev_yes_state ;
   struct regmatch_state *prev_curlyx ;
   regnode *me ;
   regnode *B ;
   CHECKPOINT cp ;
   _Bool minmod ;
   int parenfloor ;
   int count ;
   char *lastloc ;
};
#line 597 "/usr/lib/perl/5.18/CORE/regexp.h"
struct __anonstruct_whilem_115 {
   struct regmatch_state *prev_yes_state ;
   struct regmatch_state *save_curlyx ;
   CHECKPOINT cp ;
   CHECKPOINT lastcp ;
   char *save_lastloc ;
   I32 cache_offset ;
   I32 cache_mask ;
};
#line 597 "/usr/lib/perl/5.18/CORE/regexp.h"
struct __anonstruct_curlym_116 {
   struct regmatch_state *prev_yes_state ;
   int c1 ;
   int c2 ;
   CHECKPOINT cp ;
   U32 lastparen ;
   U32 lastcloseparen ;
   I32 alen ;
   I32 count ;
   _Bool minmod ;
   regnode *A ;
   regnode *B ;
   regnode *me ;
   U8 c1_utf8[14] ;
   U8 c2_utf8[14] ;
};
#line 597 "/usr/lib/perl/5.18/CORE/regexp.h"
struct __anonstruct_curly_117 {
   U32 paren ;
   CHECKPOINT cp ;
   U32 lastparen ;
   U32 lastcloseparen ;
   int c1 ;
   int c2 ;
   char *maxpos ;
   char *oldloc ;
   int count ;
   int min ;
   int max ;
   regnode *A ;
   regnode *B ;
   U8 c1_utf8[14] ;
   U8 c2_utf8[14] ;
};
#line 597 "/usr/lib/perl/5.18/CORE/regexp.h"
union __anonunion_u_105 {
   struct __anonstruct_yes_106 yes ;
   struct __anonstruct_branchlike_107 branchlike ;
   struct __anonstruct_branch_108 branch ;
   struct __anonstruct_trie_109 trie ;
   struct __anonstruct_eval_110 eval ;
   struct __anonstruct_ifmatch_111 ifmatch ;
   struct __anonstruct_mark_112 mark ;
   struct __anonstruct_keeper_113 keeper ;
   struct __anonstruct_curlyx_114 curlyx ;
   struct __anonstruct_whilem_115 whilem ;
   struct __anonstruct_curlym_116 curlym ;
   struct __anonstruct_curly_117 curly ;
};
#line 597 "/usr/lib/perl/5.18/CORE/regexp.h"
struct regmatch_state {
   int resume_state ;
   char *locinput ;
   union __anonunion_u_105 u ;
};
#line 597 "/usr/lib/perl/5.18/CORE/regexp.h"
typedef struct regmatch_state regmatch_state;
#line 753 "/usr/lib/perl/5.18/CORE/regexp.h"
struct regmatch_slab {
   regmatch_state states[(4096UL - 3UL * sizeof(void *)) / sizeof(regmatch_state )] ;
   struct regmatch_slab *prev ;
   struct regmatch_slab *next ;
};
#line 753 "/usr/lib/perl/5.18/CORE/regexp.h"
typedef struct regmatch_slab regmatch_slab;
#line 776 "/usr/lib/perl/5.18/CORE/regexp.h"
struct re_save_state {
   _Bool re_state_eval_setup_done ;
   _Bool re_state_reg_match_utf8 ;
   I32 re_state_reg_oldpos ;
   I32 re_state_reg_maxiter ;
   I32 re_state_reg_leftiter ;
   char *re_state_bostr ;
   char *re_state_regeol ;
   MAGIC *re_state_reg_magic ;
   PMOP *re_state_reg_oldcurpm ;
   PMOP *re_state_reg_curpm ;
   char *re_state_reg_oldsaved ;
   STRLEN re_state_reg_oldsavedlen ;
   STRLEN re_state_reg_oldsavedoffset ;
   STRLEN re_state_reg_oldsavedcoffset ;
   STRLEN re_state_reg_poscache_size ;
   char *re_state_reg_poscache ;
   char *re_state_reg_starttry ;
};
#line 11 "/usr/lib/perl/5.18/CORE/gv.h"
struct gp {
   SV *gp_sv ;
   struct io *gp_io ;
   CV *gp_cv ;
   U32 gp_cvgen ;
   U32 gp_refcnt ;
   HV *gp_hv ;
   AV *gp_av ;
   CV *gp_form ;
   GV *gp_egv ;
   line_t gp_line ;
   HEK *gp_file_hek ;
};
#line 25 "/usr/lib/perl/5.18/CORE/pad.h"
typedef unsigned long PADOFFSET;
#line 31 "/usr/lib/perl/5.18/CORE/pad.h"
struct padlist {
   ssize_t xpadl_max ;
   PAD **xpadl_alloc ;
   PADNAMELIST *xpadl_outid ;
};
#line 13 "/usr/lib/perl/5.18/CORE/cv.h"
union __anonunion_xpv_len_u_119 {
   STRLEN xpvlenu_len ;
   char *xpvlenu_pv ;
};
#line 13 "/usr/lib/perl/5.18/CORE/cv.h"
union __anonunion_xcv_start_u_120 {
   OP *xcv_start ;
   ANY xcv_xsubany ;
};
#line 13 "/usr/lib/perl/5.18/CORE/cv.h"
union __anonunion_xcv_root_u_121 {
   OP *xcv_root ;
   void (*xcv_xsub)(PerlInterpreter *my_perl  __attribute__((__unused__)) , CV * ) ;
};
#line 13 "/usr/lib/perl/5.18/CORE/cv.h"
union __anonunion_xcv_gv_u_122 {
   GV *xcv_gv ;
   HEK *xcv_hek ;
};
#line 13 "/usr/lib/perl/5.18/CORE/cv.h"
struct xpvcv {
   HV *xmg_stash ;
   union _xmgu xmg_u ;
   STRLEN xpv_cur ;
   union __anonunion_xpv_len_u_119 xpv_len_u ;
   HV *xcv_stash ;
   union __anonunion_xcv_start_u_120 xcv_start_u ;
   union __anonunion_xcv_root_u_121 xcv_root_u ;
   union __anonunion_xcv_gv_u_122 xcv_gv_u ;
   char *xcv_file ;
   PADLIST *xcv_padlist ;
   CV *xcv_outside ;
   U32 xcv_outside_seq ;
   cv_flags_t xcv_flags ;
   I32 xcv_depth ;
};
#line 327 "/usr/lib/perl/5.18/CORE/op.h"
struct op {
   OP *op_next ;
   OP *op_sibling ;
   OP *(*op_ppaddr)(PerlInterpreter *my_perl  __attribute__((__unused__)) ) ;
   PADOFFSET op_targ ;
   unsigned int op_type : 9 ;
   unsigned int op_opt : 1 ;
   unsigned int op_slabbed : 1 ;
   unsigned int op_savefree : 1 ;
   unsigned int op_static : 1 ;
   unsigned int op_spare : 3 ;
   U8 op_flags ;
   U8 op_private ;
};
#line 354 "/usr/lib/perl/5.18/CORE/op.h"
union __anonunion_op_pmreplrootu_123 {
   OP *op_pmreplroot ;
   PADOFFSET op_pmtargetoff ;
};
#line 354 "/usr/lib/perl/5.18/CORE/op.h"
union __anonunion_op_pmstashstartu_124 {
   OP *op_pmreplstart ;
   PADOFFSET op_pmstashoff ;
};
#line 354 "/usr/lib/perl/5.18/CORE/op.h"
struct pmop {
   OP *op_next ;
   OP *op_sibling ;
   OP *(*op_ppaddr)(PerlInterpreter *my_perl  __attribute__((__unused__)) ) ;
   PADOFFSET op_targ ;
   unsigned int op_type : 9 ;
   unsigned int op_opt : 1 ;
   unsigned int op_slabbed : 1 ;
   unsigned int op_savefree : 1 ;
   unsigned int op_static : 1 ;
   unsigned int op_spare : 3 ;
   U8 op_flags ;
   U8 op_private ;
   OP *op_first ;
   OP *op_last ;
   IV op_pmoffset ;
   U32 op_pmflags ;
   union __anonunion_op_pmreplrootu_123 op_pmreplrootu ;
   union __anonunion_op_pmstashstartu_124 op_pmstashstartu ;
   OP *op_code_list ;
};
#line 493 "/usr/lib/perl/5.18/CORE/op.h"
struct loop {
   OP *op_next ;
   OP *op_sibling ;
   OP *(*op_ppaddr)(PerlInterpreter *my_perl  __attribute__((__unused__)) ) ;
   PADOFFSET op_targ ;
   unsigned int op_type : 9 ;
   unsigned int op_opt : 1 ;
   unsigned int op_slabbed : 1 ;
   unsigned int op_savefree : 1 ;
   unsigned int op_static : 1 ;
   unsigned int op_spare : 3 ;
   U8 op_flags ;
   U8 op_private ;
   OP *op_first ;
   OP *op_last ;
   OP *op_redoop ;
   OP *op_nextop ;
   OP *op_lastop ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 46 "/usr/include/crypt.h"
struct crypt_data {
   char keysched[128] ;
   char sb0[32768] ;
   char sb1[32768] ;
   char sb2[32768] ;
   char sb3[32768] ;
   char crypt_3_buf[14] ;
   char current_salt[2] ;
   long current_saltbits ;
   int direction ;
   int initialized ;
};
#line 39 "/usr/include/shadow.h"
struct spwd {
   char *sp_namp ;
   char *sp_pwdp ;
   long sp_lstchg ;
   long sp_min ;
   long sp_max ;
   long sp_warn ;
   long sp_inact ;
   long sp_expire ;
   unsigned long sp_flag ;
};
#line 626 "/usr/lib/perl/5.18/CORE/reentr.h"
struct __anonstruct_REENTR_125 {
   char *_asctime_buffer ;
   size_t _asctime_size ;
   struct crypt_data *_crypt_struct_buffer ;
   char *_ctime_buffer ;
   size_t _ctime_size ;
   struct drand48_data _drand48_struct ;
   double _drand48_double ;
   struct group _grent_struct ;
   char *_grent_buffer ;
   size_t _grent_size ;
   struct group *_grent_ptr ;
   struct hostent _hostent_struct ;
   char *_hostent_buffer ;
   size_t _hostent_size ;
   struct hostent *_hostent_ptr ;
   int _hostent_errno ;
   char *_getlogin_buffer ;
   size_t _getlogin_size ;
   struct netent _netent_struct ;
   char *_netent_buffer ;
   size_t _netent_size ;
   struct netent *_netent_ptr ;
   int _netent_errno ;
   struct protoent _protoent_struct ;
   char *_protoent_buffer ;
   size_t _protoent_size ;
   struct protoent *_protoent_ptr ;
   struct passwd _pwent_struct ;
   char *_pwent_buffer ;
   size_t _pwent_size ;
   struct passwd *_pwent_ptr ;
   struct servent _servent_struct ;
   char *_servent_buffer ;
   size_t _servent_size ;
   struct servent *_servent_ptr ;
   struct spwd _spent_struct ;
   char *_spent_buffer ;
   size_t _spent_size ;
   struct spwd *_spent_ptr ;
   struct random_data _random_struct ;
   int32_t _random_retval ;
   struct dirent *_readdir_struct ;
   size_t _readdir_size ;
   struct dirent *_readdir_ptr ;
   struct dirent64 *_readdir64_struct ;
   size_t _readdir64_size ;
   struct dirent64 *_readdir64_ptr ;
   struct random_data _srandom_struct ;
   char *_strerror_buffer ;
   size_t _strerror_size ;
   char *_ttyname_buffer ;
   size_t _ttyname_size ;
   int dummy ;
};
#line 626 "/usr/lib/perl/5.18/CORE/reentr.h"
typedef struct __anonstruct_REENTR_125 REENTR;
#line 32 "/usr/lib/perl/5.18/CORE/hv.h"
union __anonunion_he_valu_126 {
   SV *hent_val ;
   size_t hent_refcount ;
};
#line 32 "/usr/lib/perl/5.18/CORE/hv.h"
struct he {
   HE *hent_next ;
   HEK *hent_hek ;
   union __anonunion_he_valu_126 he_valu ;
};
#line 45 "/usr/lib/perl/5.18/CORE/hv.h"
struct hek {
   U32 hek_hash ;
   I32 hek_len ;
   char hek_key[1] ;
};
#line 125 "/usr/lib/perl/5.18/CORE/hv.h"
struct xpvhv {
   HV *xmg_stash ;
   union _xmgu xmg_u ;
   STRLEN xhv_keys ;
   STRLEN xhv_max ;
};
#line 476
struct refcounted_he;
#line 32 "/usr/lib/perl/5.18/CORE/cop.h"
struct jmpenv {
   struct jmpenv *je_prev ;
   sigjmp_buf je_buf ;
   int je_ret ;
   _Bool je_mustcatch ;
};
#line 39 "/usr/lib/perl/5.18/CORE/cop.h"
typedef struct jmpenv JMPENV;
#line 160 "/usr/lib/perl/5.18/CORE/cop.h"
typedef struct refcounted_he COPHH;
#line 383 "/usr/lib/perl/5.18/CORE/cop.h"
struct cop {
   OP *op_next ;
   OP *op_sibling ;
   OP *(*op_ppaddr)(PerlInterpreter *my_perl  __attribute__((__unused__)) ) ;
   PADOFFSET op_targ ;
   unsigned int op_type : 9 ;
   unsigned int op_opt : 1 ;
   unsigned int op_slabbed : 1 ;
   unsigned int op_savefree : 1 ;
   unsigned int op_static : 1 ;
   unsigned int op_spare : 3 ;
   U8 op_flags ;
   U8 op_private ;
   line_t cop_line ;
   PADOFFSET cop_stashoff ;
   char *cop_file ;
   U32 cop_hints ;
   U32 cop_seq ;
   STRLEN *cop_warnings ;
   COPHH *cop_hints_hash ;
};
#line 557 "/usr/lib/perl/5.18/CORE/cop.h"
struct block_sub {
   OP *retop ;
   CV *cv ;
   AV *savearray ;
   AV *argarray ;
   I32 olddepth ;
   PAD *oldcomppad ;
};
#line 570 "/usr/lib/perl/5.18/CORE/cop.h"
struct block_format {
   OP *retop ;
   CV *cv ;
   GV *gv ;
   GV *dfoutgv ;
};
#line 691 "/usr/lib/perl/5.18/CORE/cop.h"
struct block_eval {
   OP *retop ;
   SV *old_namesv ;
   OP *old_eval_root ;
   SV *cur_text ;
   CV *cv ;
   JMPENV *cur_top_env ;
};
#line 733 "/usr/lib/perl/5.18/CORE/cop.h"
union __anonunion_itervar_u_127 {
   SV **svp ;
   GV *gv ;
   PAD *oldcomppad ;
};
#line 733 "/usr/lib/perl/5.18/CORE/cop.h"
struct __anonstruct_ary_129 {
   AV *ary ;
   IV ix ;
};
#line 733 "/usr/lib/perl/5.18/CORE/cop.h"
struct __anonstruct_lazyiv_130 {
   IV cur ;
   IV end ;
};
#line 733 "/usr/lib/perl/5.18/CORE/cop.h"
struct __anonstruct_lazysv_131 {
   SV *cur ;
   SV *end ;
};
#line 733 "/usr/lib/perl/5.18/CORE/cop.h"
union __anonunion_state_u_128 {
   struct __anonstruct_ary_129 ary ;
   struct __anonstruct_lazyiv_130 lazyiv ;
   struct __anonstruct_lazysv_131 lazysv ;
};
#line 733 "/usr/lib/perl/5.18/CORE/cop.h"
struct block_loop {
   I32 resetsp ;
   LOOP *my_op ;
   union __anonunion_itervar_u_127 itervar_u ;
   union __anonunion_state_u_128 state_u ;
};
#line 800 "/usr/lib/perl/5.18/CORE/cop.h"
struct block_givwhen {
   OP *leave_op ;
};
#line 810 "/usr/lib/perl/5.18/CORE/cop.h"
union __anonunion_blk_u_132 {
   struct block_sub blku_sub ;
   struct block_format blku_format ;
   struct block_eval blku_eval ;
   struct block_loop blku_loop ;
   struct block_givwhen blku_givwhen ;
};
#line 810 "/usr/lib/perl/5.18/CORE/cop.h"
struct block {
   U8 blku_type ;
   U8 blku_gimme ;
   U16 blku_u16 ;
   I32 blku_oldsp ;
   COP *blku_oldcop ;
   I32 blku_oldmarksp ;
   I32 blku_oldscopesp ;
   PMOP *blku_oldpm ;
   union __anonunion_blk_u_132 blk_u ;
};
#line 883 "/usr/lib/perl/5.18/CORE/cop.h"
struct subst {
   U8 sbu_type ;
   U8 sbu_rflags ;
   U16 sbu_rxtainted ;
   I32 sbu_iters ;
   I32 sbu_maxiters ;
   I32 sbu_oldsave ;
   char *sbu_orig ;
   SV *sbu_dstr ;
   SV *sbu_targ ;
   char *sbu_s ;
   char *sbu_m ;
   char *sbu_strend ;
   void *sbu_rxres ;
   REGEXP *sbu_rx ;
};
#line 939 "/usr/lib/perl/5.18/CORE/cop.h"
union __anonunion_cx_u_133 {
   struct block cx_blk ;
   struct subst cx_subst ;
};
#line 939 "/usr/lib/perl/5.18/CORE/cop.h"
struct context {
   union __anonunion_cx_u_133 cx_u ;
};
#line 1086 "/usr/lib/perl/5.18/CORE/cop.h"
struct stackinfo {
   AV *si_stack ;
   PERL_CONTEXT *si_cxstack ;
   struct stackinfo *si_prev ;
   struct stackinfo *si_next ;
   I32 si_cxix ;
   I32 si_cxmax ;
   I32 si_type ;
   I32 si_markoff ;
};
#line 1099 "/usr/lib/perl/5.18/CORE/cop.h"
typedef struct stackinfo PERL_SI;
#line 11 "/usr/lib/perl/5.18/CORE/av.h"
struct xpvav {
   HV *xmg_stash ;
   union _xmgu xmg_u ;
   ssize_t xav_fill ;
   ssize_t xav_max ;
   SV **xav_alloc ;
};
#line 14 "/usr/lib/perl/5.18/CORE/mg.h"
struct mgvtbl {
   int (*svt_get)(PerlInterpreter *my_perl  __attribute__((__unused__)) , SV *sv ,
                  MAGIC *mg ) ;
   int (*svt_set)(PerlInterpreter *my_perl  __attribute__((__unused__)) , SV *sv ,
                  MAGIC *mg ) ;
   U32 (*svt_len)(PerlInterpreter *my_perl  __attribute__((__unused__)) , SV *sv ,
                  MAGIC *mg ) ;
   int (*svt_clear)(PerlInterpreter *my_perl  __attribute__((__unused__)) , SV *sv ,
                    MAGIC *mg ) ;
   int (*svt_free)(PerlInterpreter *my_perl  __attribute__((__unused__)) , SV *sv ,
                   MAGIC *mg ) ;
   int (*svt_copy)(PerlInterpreter *my_perl  __attribute__((__unused__)) , SV *sv ,
                   MAGIC *mg , SV *nsv , char const   *name , I32 namlen ) ;
   int (*svt_dup)(PerlInterpreter *my_perl  __attribute__((__unused__)) , MAGIC *mg ,
                  CLONE_PARAMS *param ) ;
   int (*svt_local)(PerlInterpreter *my_perl  __attribute__((__unused__)) , SV *nsv ,
                    MAGIC *mg ) ;
};
#line 27 "/usr/lib/perl/5.18/CORE/mg.h"
struct magic {
   MAGIC *mg_moremagic ;
   MGVTBL *mg_virtual ;
   U16 mg_private ;
   char mg_type ;
   U8 mg_flags ;
   I32 mg_len ;
   SV *mg_obj ;
   char *mg_ptr ;
};
#line 3497 "/usr/lib/perl/5.18/CORE/perl.h"
struct _sublex_info;
#line 3497 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct _sublex_info SUBLEXINFO;
#line 3498 "/usr/lib/perl/5.18/CORE/perl.h"
struct _sublex_info {
   U8 super_state ;
   U16 sub_inwhat ;
   OP *sub_op ;
   SV *repl ;
};
#line 14 "/usr/lib/perl/5.18/CORE/parser.h"
struct __anonstruct_yy_stack_frame_134 {
   YYSTYPE val ;
   short state ;
   I32 savestack_ix ;
   CV *compcv ;
};
#line 14 "/usr/lib/perl/5.18/CORE/parser.h"
typedef struct __anonstruct_yy_stack_frame_134 yy_stack_frame;
#line 26 "/usr/lib/perl/5.18/CORE/parser.h"
struct yy_lexshared {
   struct yy_lexshared *ls_prev ;
   SV *ls_linestr ;
   char *ls_bufptr ;
   char *re_eval_start ;
   SV *re_eval_str ;
   line_t herelines ;
};
#line 26 "/usr/lib/perl/5.18/CORE/parser.h"
typedef struct yy_lexshared LEXSHARED;
#line 35 "/usr/lib/perl/5.18/CORE/parser.h"
struct yy_parser {
   struct yy_parser *old_parser ;
   YYSTYPE yylval ;
   int yychar ;
   int yyerrstatus ;
   int stack_size ;
   int yylen ;
   yy_stack_frame *stack ;
   yy_stack_frame *ps ;
   I32 lex_brackets ;
   I32 lex_casemods ;
   char *lex_brackstack ;
   char *lex_casestack ;
   U8 lex_defer ;
   _Bool lex_dojoin ;
   U8 lex_expect ;
   U8 expect ;
   I32 lex_formbrack ;
   OP *lex_inpat ;
   OP *lex_op ;
   SV *lex_repl ;
   U16 lex_inwhat ;
   U16 last_lop_op ;
   I32 lex_starts ;
   SV *lex_stuff ;
   I32 multi_start ;
   I32 multi_end ;
   char multi_open ;
   char multi_close ;
   _Bool preambled ;
   _Bool lex_re_reparsing ;
   I32 lex_allbrackets ;
   SUBLEXINFO sublex_info ;
   LEXSHARED *lex_shared ;
   SV *linestr ;
   char *bufptr ;
   char *oldbufptr ;
   char *oldoldbufptr ;
   char *bufend ;
   char *linestart ;
   char *last_uni ;
   char *last_lop ;
   line_t copline ;
   U16 in_my ;
   U8 lex_state ;
   U8 error_count ;
   HV *in_my_stash ;
   PerlIO *rsfp ;
   AV *rsfp_filters ;
   U8 form_lex_state ;
   YYSTYPE nextval[5] ;
   I32 nexttype[5] ;
   I32 nexttoke ;
   COP *saved_curcop ;
   char tokenbuf[256] ;
   U8 lex_fakeeof ;
   U8 lex_flags ;
   unsigned int in_pod : 1 ;
   unsigned int filtered : 1 ;
};
#line 35 "/usr/lib/perl/5.18/CORE/parser.h"
typedef struct yy_parser yy_parser;
#line 3512 "/usr/lib/perl/5.18/CORE/perl.h"
struct ptr_tbl_ent {
   struct ptr_tbl_ent *next ;
   void const   *oldval ;
   void *newval ;
};
#line 3518
struct ptr_tbl_arena;
#line 3518 "/usr/lib/perl/5.18/CORE/perl.h"
struct ptr_tbl {
   struct ptr_tbl_ent **tbl_ary ;
   UV tbl_max ;
   UV tbl_items ;
   struct ptr_tbl_arena *tbl_arena ;
   struct ptr_tbl_ent *tbl_arena_next ;
   struct ptr_tbl_ent *tbl_arena_end ;
};
#line 4798
enum perl_phase {
    PERL_PHASE_CONSTRUCT = 0,
    PERL_PHASE_START = 1,
    PERL_PHASE_CHECK = 2,
    PERL_PHASE_INIT = 3,
    PERL_PHASE_RUN = 4,
    PERL_PHASE_END = 5,
    PERL_PHASE_DESTRUCT = 6
} ;
#line 4936 "/usr/lib/perl/5.18/CORE/perl.h"
struct perl_debug_pad {
   SV pad[3] ;
};
#line 4981 "/usr/lib/perl/5.18/CORE/perl.h"
struct exitlistentry {
   void (*fn)(PerlInterpreter *my_perl  __attribute__((__unused__)) , void * ) ;
   void *ptr ;
};
#line 4981 "/usr/lib/perl/5.18/CORE/perl.h"
typedef struct exitlistentry PerlExitListEntry;
#line 5022 "/usr/lib/perl/5.18/CORE/perl.h"
struct interpreter {
   SV **Istack_sp ;
   OP *Iop ;
   SV **Icurpad ;
   SV **Istack_base ;
   SV **Istack_max ;
   ANY *Isavestack ;
   I32 Isavestack_ix ;
   I32 Isavestack_max ;
   I32 *Iscopestack ;
   I32 Iscopestack_ix ;
   I32 Iscopestack_max ;
   SV **Itmps_stack ;
   I32 Itmps_ix ;
   I32 Itmps_floor ;
   I32 Itmps_max ;
   U32 Isub_generation ;
   I32 *Imarkstack ;
   I32 *Imarkstack_ptr ;
   I32 *Imarkstack_max ;
   U8 Ihash_rand_bits_enabled ;
   UV Ihash_rand_bits ;
   HV *Istrtab ;
   PMOP *Icurpm ;
   _Bool Itainting ;
   _Bool Itainted ;
   U16 Idelaymagic ;
   U8 Ilocalizing ;
   U8 Iin_eval ;
   U8 Idowarn ;
   I8 Iutf8cache ;
   HV *Idefstash ;
   HV *Icurstash ;
   COP *Icurcop ;
   AV *Icurstack ;
   PERL_SI *Icurstackinfo ;
   AV *Imainstack ;
   IV Isv_count ;
   IV Isv_objcount ;
   SV *Isv_root ;
   SV *Isv_arenaroot ;
   struct re_save_state Ireg_state ;
   regmatch_slab *Iregmatch_slab ;
   regmatch_state *Iregmatch_state ;
   PAD *Icomppad ;
   SV Isv_undef ;
   SV Isv_no ;
   SV Isv_yes ;
   SV *ISv ;
   yy_parser *Iparser ;
   HV *Istashcache ;
   STRLEN Ina ;
   struct stat Istatbuf ;
   struct stat Istatcache ;
   GV *Istatgv ;
   SV *Istatname ;
   struct tms Itimesbuf ;
   SV *Irs ;
   GV *Ilast_in_gv ;
   GV *Iofsgv ;
   GV *Idefoutgv ;
   char const   *Ichopset ;
   SV *Iformtarget ;
   SV *Ibodytarget ;
   SV *Itoptarget ;
   OP *Irestartop ;
   JMPENV *Irestartjmpenv ;
   JMPENV *Itop_env ;
   JMPENV Istart_env ;
   SV *Ierrors ;
   HE *Ihv_fetch_ent_mh ;
   OP *Ilastgotoprobe ;
   OP *Isortcop ;
   HV *Isortstash ;
   GV *Ifirstgv ;
   GV *Isecondgv ;
   char *Iefloatbuf ;
   STRLEN Iefloatsize ;
   regnode Iregdummy ;
   U16 Idumpindent ;
   U8 Iexit_flags ;
   _Bool Iutf8locale ;
   char *Icolors[6] ;
   void (*Ipeepp)(PerlInterpreter *my_perl  __attribute__((__unused__)) , OP *o ) ;
   void (*Irpeepp)(PerlInterpreter *my_perl  __attribute__((__unused__)) , OP *o ) ;
   void (*Iopfreehook)(PerlInterpreter *my_perl  __attribute__((__unused__)) , OP * ) ;
   char **Iwatchaddr ;
   char *Iwatchok ;
   U32 Iperldb ;
   U32 Isignals ;
   int Ireentrant_retint ;
   int Iorigargc ;
   char **Iorigargv ;
   GV *Ienvgv ;
   GV *Iincgv ;
   GV *Ihintgv ;
   char *Iorigfilename ;
   SV *Idiehook ;
   SV *Iwarnhook ;
   SV *Ipatchlevel ;
   SV *Iapiversion ;
   char const   * const  *Ilocalpatches ;
   char const   *Isplitstr ;
   _Bool Iminus_c ;
   _Bool Iminus_n ;
   _Bool Iminus_p ;
   _Bool Iminus_l ;
   _Bool Iminus_a ;
   _Bool Iminus_F ;
   _Bool Idoswitches ;
   _Bool Iminus_E ;
   char *Iinplace ;
   SV *Ie_script ;
   time_t Ibasetime ;
   I32 Imaxsysfd ;
   I32 Istatusvalue ;
   I32 Istatusvalue_posix ;
   int Isig_pending ;
   int *Ipsig_pend ;
   GV *Istdingv ;
   GV *Istderrgv ;
   GV *Idefgv ;
   GV *Iargvgv ;
   GV *Iargvoutgv ;
   AV *Iargvout_stack ;
   GV *Ireplgv ;
   GV *Ierrgv ;
   GV *IDBgv ;
   GV *IDBline ;
   GV *IDBsub ;
   SV *IDBsingle ;
   SV *IDBtrace ;
   SV *IDBsignal ;
   AV *Idbargs ;
   HV *Idebstash ;
   HV *Iglobalstash ;
   SV *Icurstname ;
   AV *Ibeginav ;
   AV *Iendav ;
   AV *Iunitcheckav ;
   AV *Icheckav ;
   AV *Iinitav ;
   AV *Ifdpid ;
   char *Iop_mask ;
   CV *Imain_cv ;
   OP *Imain_root ;
   OP *Imain_start ;
   OP *Ieval_root ;
   OP *Ieval_start ;
   COP *Icurcopdb ;
   int Ifilemode ;
   int Ilastfd ;
   char *Ioldname ;
   char const   **IArgv ;
   char *ICmd ;
   AV *Ipreambleav ;
   SV *Imess_sv ;
   SV *Iors_sv ;
   int Iforkprocess ;
   I32 Igensym ;
   _Bool Icv_has_eval ;
   _Bool Itaint_warn ;
   U16 Ilaststype ;
   int Ilaststatval ;
   I32 Imodcount ;
   I32 Iexitlistlen ;
   PerlExitListEntry *Iexitlist ;
   HV *Imodglobal ;
   U32 *Iprofiledata ;
   COP Icompiling ;
   CV *Icompcv ;
   PADNAMELIST *Icomppad_name ;
   I32 Icomppad_name_fill ;
   I32 Icomppad_name_floor ;
   CV *IDBcv ;
   int Igeneration ;
   U32 Iunicode ;
   _Bool Iin_clean_objs ;
   _Bool Iin_clean_all ;
   _Bool Inomemok ;
   _Bool Isavebegin ;
   uid_t Idelaymagic_uid ;
   uid_t Idelaymagic_euid ;
   gid_t Idelaymagic_gid ;
   gid_t Idelaymagic_egid ;
   U32 Ian ;
   U32 Ibreakable_sub_gen ;
   U32 Icop_seqmax ;
   U32 Ievalseq ;
   U32 Iorigalen ;
   char **Iorigenviron ;
   char *Iosname ;
   void (*Isighandlerp)(int  , siginfo_t * , void * ) ;
   void *Ibody_roots[16] ;
   U32 volatile   Idebug ;
   int Imaxo ;
   int (*Irunops)(PerlInterpreter *my_perl  __attribute__((__unused__)) ) ;
   SV *Isubname ;
   I32 Isubline ;
   I32 Imin_intro_pending ;
   I32 Imax_intro_pending ;
   I32 Ipadix ;
   I32 Ipadix_floor ;
   U32 Ihints ;
   char *Icollation_name ;
   size_t Icollxfrm_base ;
   size_t Icollxfrm_mult ;
   U32 Icollation_ix ;
   _Bool Icollation_standard ;
   U8 Isawampersand ;
   _Bool Iunsafe ;
   _Bool Icolorset ;
   enum perl_phase Iphase ;
   _Bool Iin_load_module ;
   signed char Iperl_destruct_level ;
   _Bool Inumeric_standard ;
   _Bool Inumeric_local ;
   char *Inumeric_name ;
   SV *Inumeric_radix_sv ;
   SV *IASCII ;
   SV *ILatin1 ;
   SV *IAboveLatin1 ;
   SV *INonL1NonFinalFold ;
   SV *IHasMultiCharFold ;
   SV *Iutf8_mark ;
   SV *Iutf8_X_regular_begin ;
   SV *Iutf8_X_extend ;
   SV *Iutf8_toupper ;
   SV *Iutf8_totitle ;
   SV *Iutf8_tolower ;
   SV *Iutf8_tofold ;
   SV *Iutf8_charname_begin ;
   SV *Iutf8_charname_continue ;
   SV *Iutf8_swash_ptrs[10] ;
   SV *IPosix_ptrs[17] ;
   SV *IL1Posix_ptrs[17] ;
   SV *IXPosix_ptrs[17] ;
   HV *Ilast_swash_hv ;
   U8 *Ilast_swash_tmps ;
   STRLEN Ilast_swash_slen ;
   U8 Ilast_swash_key[12] ;
   U8 Ilast_swash_klen ;
   _Bool Ipad_reset_pending ;
   _Bool Isrand_called ;
   SV **Ipsig_ptr ;
   SV **Ipsig_name ;
   PTR_TBL_t *Iptr_table ;
   AV *Ibeginav_save ;
   void *Ibody_arenas ;
   SV **Iregex_pad ;
   AV *Iregex_padav ;
   HV **Istashpad ;
   PADOFFSET Istashpadmax ;
   PADOFFSET Istashpadix ;
   REENTR *Ireentrant_buffer ;
   HV *Icustom_op_names ;
   HV *Icustom_op_descs ;
   PerlIOl *Iperlio ;
   PerlIO_list_t *Iknown_layers ;
   PerlIO_list_t *Idef_layerlist ;
   SV *Iencoding ;
   SV *Iutf8_idstart ;
   SV *Iutf8_idcont ;
   SV *Iutf8_xidstart ;
   SV *Iutf8_perl_idstart ;
   SV *Iutf8_perl_idcont ;
   SV *Iutf8_xidcont ;
   I32 (*Isort_RealCmp)(PerlInterpreter *my_perl  __attribute__((__unused__)) , SV * const   ,
                        SV * const   ) ;
   AV *Icheckav_save ;
   AV *Iunitcheckav_save ;
   long Iclocktick ;
   void (*Isharehook)(PerlInterpreter *my_perl  __attribute__((__unused__)) , SV *sv ) ;
   void (*Ilockhook)(PerlInterpreter *my_perl  __attribute__((__unused__)) , SV *sv ) ;
   void (*Iunlockhook)(PerlInterpreter *my_perl  __attribute__((__unused__)) , SV *sv ) ;
   int (*Ithreadhook)(PerlInterpreter *my_perl  __attribute__((__unused__)) ) ;
   _Bool (*Idestroyhook)(PerlInterpreter *my_perl  __attribute__((__unused__)) , SV *sv ) ;
   void (*Isignalhook)(PerlInterpreter *my_perl  __attribute__((__unused__)) ) ;
   HV *Iisarev ;
   HV *Iregistered_mros ;
   AV *Iblockhooks ;
   HV *Iutf8_foldclosures ;
   SV *Iutf8_foldable ;
   HV *Icustom_ops ;
   XPV *IXpv ;
   char const   **Iscopestack_name ;
   struct perl_debug_pad Idebug_pad ;
   void (*Iglobhook)(PerlInterpreter *my_perl  __attribute__((__unused__)) ) ;
   void **Imy_cxt_list ;
   int Imy_cxt_size ;
};
#line 41 "../../src/oping.h"
struct pinghost;
#line 42 "../../src/oping.h"
typedef struct pinghost pinghost_t;
#line 44 "../../src/oping.h"
typedef pinghost_t pingobj_iter_t;
#line 46
struct pingobj;
#line 47 "../../src/oping.h"
typedef struct pingobj pingobj_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 48 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __suseconds_t suseconds_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_10 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_10 fd_set;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 162 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   unsigned long __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(unsigned long )] ;
};
#line 224 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 242 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 107 "/usr/include/netinet/ip.h"
struct ip {
   unsigned int ip_hl : 4 ;
   unsigned int ip_v : 4 ;
   u_int8_t ip_tos ;
   u_short ip_len ;
   u_short ip_id ;
   u_short ip_off ;
   u_int8_t ip_ttl ;
   u_int8_t ip_p ;
   u_short ip_sum ;
   struct in_addr ip_src ;
   struct in_addr ip_dst ;
};
#line 131 "/usr/include/netinet/ip_icmp.h"
struct icmp_ra_addr {
   u_int32_t ira_addr ;
   u_int32_t ira_preference ;
};
#line 137 "/usr/include/netinet/ip_icmp.h"
struct ih_idseq {
   u_int16_t icd_id ;
   u_int16_t icd_seq ;
};
#line 137 "/usr/include/netinet/ip_icmp.h"
struct ih_pmtu {
   u_int16_t ipm_void ;
   u_int16_t ipm_nextmtu ;
};
#line 137 "/usr/include/netinet/ip_icmp.h"
struct ih_rtradv {
   u_int8_t irt_num_addrs ;
   u_int8_t irt_wpa ;
   u_int16_t irt_lifetime ;
};
#line 137 "/usr/include/netinet/ip_icmp.h"
union __anonunion_icmp_hun_39 {
   u_char ih_pptr ;
   struct in_addr ih_gwaddr ;
   struct ih_idseq ih_idseq ;
   u_int32_t ih_void ;
   struct ih_pmtu ih_pmtu ;
   struct ih_rtradv ih_rtradv ;
};
#line 137 "/usr/include/netinet/ip_icmp.h"
struct __anonstruct_id_ts_41 {
   u_int32_t its_otime ;
   u_int32_t its_rtime ;
   u_int32_t its_ttime ;
};
#line 137 "/usr/include/netinet/ip_icmp.h"
struct __anonstruct_id_ip_42 {
   struct ip idi_ip ;
};
#line 137 "/usr/include/netinet/ip_icmp.h"
union __anonunion_icmp_dun_40 {
   struct __anonstruct_id_ts_41 id_ts ;
   struct __anonstruct_id_ip_42 id_ip ;
   struct icmp_ra_addr id_radv ;
   u_int32_t id_mask ;
   u_int8_t id_data[1] ;
};
#line 137 "/usr/include/netinet/ip_icmp.h"
struct icmp {
   u_int8_t icmp_type ;
   u_int8_t icmp_code ;
   u_int16_t icmp_cksum ;
   union __anonunion_icmp_hun_39 icmp_hun ;
   union __anonunion_icmp_dun_40 icmp_dun ;
};
#line 38 "/usr/include/netinet/icmp6.h"
union __anonunion_icmp6_dataun_44 {
   uint32_t icmp6_un_data32[1] ;
   uint16_t icmp6_un_data16[2] ;
   uint8_t icmp6_un_data8[4] ;
};
#line 38 "/usr/include/netinet/icmp6.h"
struct icmp6_hdr {
   uint8_t icmp6_type ;
   uint8_t icmp6_code ;
   uint16_t icmp6_cksum ;
   union __anonunion_icmp6_dataun_44 icmp6_dataun ;
};
#line 108 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
struct pinghost {
   char *username ;
   char *hostname ;
   struct sockaddr_storage *addr ;
   socklen_t addrlen ;
   int addrfamily ;
   int fd ;
   int ident ;
   int sequence ;
   struct timeval *timer ;
   double latency ;
   uint32_t dropped ;
   int recv_ttl ;
   uint8_t recv_qos ;
   char *data ;
   void *context ;
   struct pinghost *next ;
};
#line 132 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
struct pingobj {
   double timeout ;
   int ttl ;
   int addrfamily ;
   uint8_t qos ;
   char *data ;
   struct sockaddr *srcaddr ;
   socklen_t srcaddrlen ;
   char *device ;
   char errmsg[256] ;
   pinghost_t *head ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_58 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_58 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 131 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
struct ping_context {
   char host[1025] ;
   char addr[1025] ;
   int index ;
   int req_sent ;
   int req_rcvd ;
   double latency_min ;
   double latency_max ;
   double latency_total ;
   double latency_total_square ;
};
#line 131 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
typedef struct ping_context ping_context_t;
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 1130 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) pthread_getspecific)(pthread_key_t __key ) ;
#line 302 "/usr/lib/perl/5.18/CORE/proto.h"
extern void ( __attribute__((__nonnull__(3))) Perl_call_list)(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                                              I32 oldscope , AV *paramList ) ;
#line 679
extern  __attribute__((__noreturn__)) void Perl_croak(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                                      char const   *pat  , ...) ;
#line 698
extern  __attribute__((__noreturn__)) void ( __attribute__((__nonnull__(2), __nonnull__(1))) Perl_croak_xs_usage)(CV const   * const  cv ,
                                                                                                                  char const   * const  params ) ;
#line 2506
extern int ( __attribute__((__nonnull__(2))) Perl_mg_set)(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                                          SV *sv ) ;
#line 2881
extern SV *( __attribute__((__warn_unused_result__)) Perl_newSVpvn)(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                                                    char const   * const  s ,
                                                                    STRLEN const   len )  __attribute__((__malloc__)) ;
#line 2921
extern CV *( __attribute__((__nonnull__(4), __nonnull__(3))) Perl_newXS)(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                                                         char const   *name ,
                                                                         void (*subaddr)(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                                                                         CV * ) ,
                                                                         char const   *filename ) ;
#line 3781
extern SV **( __attribute__((__nonnull__(3), __nonnull__(2))) Perl_stack_grow)(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                                                               SV **sp ,
                                                                               SV **p ,
                                                                               int n ) ;
#line 3825
extern IV Perl_sv_2iv_flags(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                            SV * const  sv , I32 const   flags ) ;
#line 3826
extern SV *Perl_sv_2mortal(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                           SV * const  sv ) ;
#line 3832
extern NV Perl_sv_2nv_flags(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                            SV * const  sv , I32 const   flags ) ;
#line 3834
extern char *Perl_sv_2pv_flags(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                               SV * const  sv , STRLEN * const  lp , I32 const   flags ) ;
#line 3988
extern _Bool ( __attribute__((__warn_unused_result__, __nonnull__(3), __nonnull__(2))) Perl_sv_derived_from)(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                                                                                             SV *sv ,
                                                                                                             char const   * const  name ) ;
#line 4130
extern SV *( __attribute__((__warn_unused_result__)) Perl_sv_newmortal)(PerlInterpreter *my_perl  __attribute__((__unused__)) ) ;
#line 4258
extern void ( __attribute__((__nonnull__(2))) Perl_sv_setiv)(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                                             SV * const  sv , IV const   num ) ;
#line 4268
extern void ( __attribute__((__nonnull__(2))) Perl_sv_setnv)(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                                             SV * const  sv , NV const   num ) ;
#line 4278
extern void ( __attribute__((__nonnull__(2))) Perl_sv_setpv)(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                                             SV * const  sv , char const   * const  ptr ) ;
#line 4333
extern SV *( __attribute__((__nonnull__(2))) Perl_sv_setref_pv)(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                                                SV * const  rv , char const   * const  classname ,
                                                                void * const  pv ) ;
#line 4881
extern void ( __attribute__((__nonnull__(3), __nonnull__(2))) Perl_xs_apiversion_bootcheck)(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                                                                            SV *module ,
                                                                                            char const   *api_p ,
                                                                                            STRLEN api_len ) ;
#line 4887
extern void ( __attribute__((__nonnull__(4))) Perl_xs_version_bootcheck)(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                                                         U32 items ,
                                                                         U32 ax ,
                                                                         char const   *xs_p ,
                                                                         STRLEN xs_len ) ;
#line 40 "/usr/lib/perl/5.18/CORE/perlvars.h"
extern perl_key PL_thr_key ;
#line 65 "../../src/oping.h"
pingobj_t *ping_construct(void) ;
#line 66
void ping_destroy(pingobj_t *obj ) ;
#line 68
int ping_setopt(pingobj_t *obj , int option , void *value ) ;
#line 70
int ping_send(pingobj_t *obj ) ;
#line 72
int ping_host_add(pingobj_t *obj , char const   *host ) ;
#line 73
int ping_host_remove(pingobj_t *obj , char const   *host ) ;
#line 75
pingobj_iter_t *ping_iterator_get(pingobj_t *obj ) ;
#line 76
pingobj_iter_t *ping_iterator_next(pingobj_iter_t *iter ) ;
#line 89
int ping_iterator_get_info(pingobj_iter_t *iter , int info , void *buffer , size_t *buffer_len ) ;
#line 92
char const   *ping_get_error(pingobj_t *obj ) ;
#line 191 "Oping.c"
static void XS_Net__Oping__ping_construct(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                          CV *cv  __attribute__((__unused__)) ) ;
#line 192 "Oping.c"
static void XS_Net__Oping__ping_construct(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                          CV *cv  __attribute__((__unused__)) ) 
{ 
  SV **sp ;
  void *tmp ;
  I32 ax ;
  void *tmp___0 ;
  I32 *tmp___1 ;
  SV **mark ;
  void *tmp___2 ;
  I32 tmp___3 ;
  I32 items ;
  pingobj_t *RETVAL ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  IV tmpXSoff ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
  {
#line 194
  tmp = pthread_getspecific(PL_thr_key);
#line 194
  sp = ((PerlInterpreter *)tmp)->Istack_sp;
#line 194
  tmp___0 = pthread_getspecific(PL_thr_key);
#line 194
  tmp___1 = ((PerlInterpreter *)tmp___0)->Imarkstack_ptr;
#line 194
  (((PerlInterpreter *)tmp___0)->Imarkstack_ptr) --;
#line 194
  ax = *tmp___1;
#line 194
  tmp___2 = pthread_getspecific(PL_thr_key);
#line 194
  tmp___3 = ax;
#line 194
  ax ++;
#line 194
  mark = ((PerlInterpreter *)tmp___2)->Istack_base + tmp___3;
#line 194
  items = (I32 )(sp - mark);
  }
#line 195
  if (items != 0) {
    {
#line 196
    Perl_croak_xs_usage((CV const   */* const  */)cv, (char const   */* const  */)"");
    }
  }
  {
#line 45 "Oping.xs"
  RETVAL = ping_construct();
#line 202 "Oping.c"
  tmp___4 = pthread_getspecific(PL_thr_key);
#line 202
  tmp___5 = pthread_getspecific(PL_thr_key);
#line 202
  *(((PerlInterpreter *)tmp___4)->Istack_base + ax) = Perl_sv_newmortal((PerlInterpreter *)tmp___5);
#line 203
  tmp___6 = pthread_getspecific(PL_thr_key);
#line 203
  tmp___7 = pthread_getspecific(PL_thr_key);
#line 203
  Perl_sv_setref_pv((PerlInterpreter *)tmp___7, (SV */* const  */)*(((PerlInterpreter *)tmp___6)->Istack_base + ax),
                    (char const   */* const  */)"pingobj_tPtr", (void */* const  */)((void *)RETVAL));
#line 205
  tmpXSoff = (IV )1;
#line 205
  tmp___8 = pthread_getspecific(PL_thr_key);
#line 205
  tmp___9 = pthread_getspecific(PL_thr_key);
#line 205
  ((PerlInterpreter *)tmp___8)->Istack_sp = (((PerlInterpreter *)tmp___9)->Istack_base + ax) + (tmpXSoff - 1L);
  }
#line 205
  return;
}
}
#line 209
static void XS_Net__Oping__ping_destroy(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                        CV *cv  __attribute__((__unused__)) ) ;
#line 210 "Oping.c"
static void XS_Net__Oping__ping_destroy(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                        CV *cv  __attribute__((__unused__)) ) 
{ 
  SV **sp ;
  void *tmp ;
  I32 ax ;
  void *tmp___0 ;
  I32 *tmp___1 ;
  SV **mark ;
  void *tmp___2 ;
  I32 tmp___3 ;
  I32 items ;
  pingobj_t *obj ;
  IV tmp___4 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  IV tmp___9 ;
  IV tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  _Bool tmp___16 ;
  IV tmpXSoff ;
  void *tmp___17 ;
  void *tmp___18 ;

  {
  {
#line 212
  tmp = pthread_getspecific(PL_thr_key);
#line 212
  sp = ((PerlInterpreter *)tmp)->Istack_sp;
#line 212
  tmp___0 = pthread_getspecific(PL_thr_key);
#line 212
  tmp___1 = ((PerlInterpreter *)tmp___0)->Imarkstack_ptr;
#line 212
  (((PerlInterpreter *)tmp___0)->Imarkstack_ptr) --;
#line 212
  ax = *tmp___1;
#line 212
  tmp___2 = pthread_getspecific(PL_thr_key);
#line 212
  tmp___3 = ax;
#line 212
  ax ++;
#line 212
  mark = ((PerlInterpreter *)tmp___2)->Istack_base + tmp___3;
#line 212
  items = (I32 )(sp - mark);
  }
#line 213
  if (items != 1) {
    {
#line 214
    Perl_croak_xs_usage((CV const   */* const  */)cv, (char const   */* const  */)"obj");
    }
  }
  {
#line 218
  tmp___13 = pthread_getspecific(PL_thr_key);
  }
#line 218
  if ((*(((PerlInterpreter *)tmp___13)->Istack_base + ax))->sv_flags & 2048U) {
    {
#line 218
    tmp___14 = pthread_getspecific(PL_thr_key);
#line 218
    tmp___15 = pthread_getspecific(PL_thr_key);
#line 218
    tmp___16 = Perl_sv_derived_from((PerlInterpreter *)tmp___15, *(((PerlInterpreter *)tmp___14)->Istack_base + ax),
                                    (char const   */* const  */)"pingobj_tPtr");
    }
#line 218
    if (tmp___16) {
      {
#line 219
      tmp___11 = pthread_getspecific(PL_thr_key);
      }
#line 219
      if ((((*(((PerlInterpreter *)tmp___11)->Istack_base + ax))->sv_u.svu_rv)->sv_flags & 2097408U) == 256U) {
        {
#line 219
        tmp___6 = pthread_getspecific(PL_thr_key);
#line 219
        tmp___10 = ((XPVIV *)((*(((PerlInterpreter *)tmp___6)->Istack_base + ax))->sv_u.svu_rv)->sv_any)->xiv_u.xivu_iv;
        }
      } else {
        {
#line 219
        tmp___7 = pthread_getspecific(PL_thr_key);
#line 219
        tmp___8 = pthread_getspecific(PL_thr_key);
#line 219
        tmp___9 = Perl_sv_2iv_flags((PerlInterpreter *)tmp___8, (SV */* const  */)(*(((PerlInterpreter *)tmp___7)->Istack_base + ax))->sv_u.svu_rv,
                                    (I32 const   )2);
#line 219
        tmp___10 = tmp___9;
        }
      }
#line 219
      tmp___4 = tmp___10;
#line 220
      obj = (pingobj_t *)tmp___4;
    } else {
      {
#line 223
      tmp___12 = pthread_getspecific(PL_thr_key);
#line 223
      Perl_croak((PerlInterpreter *)tmp___12, "%s: %s is not of type %s", "Net::Oping::_ping_destroy",
                 "obj", "pingobj_tPtr");
      }
    }
  } else {
    {
#line 223
    tmp___12 = pthread_getspecific(PL_thr_key);
#line 223
    Perl_croak((PerlInterpreter *)tmp___12, "%s: %s is not of type %s", "Net::Oping::_ping_destroy",
               "obj", "pingobj_tPtr");
    }
  }
  {
#line 53 "Oping.xs"
  ping_destroy(obj);
#line 231 "Oping.c"
  tmpXSoff = (IV )0;
#line 231
  tmp___17 = pthread_getspecific(PL_thr_key);
#line 231
  tmp___18 = pthread_getspecific(PL_thr_key);
#line 231
  ((PerlInterpreter *)tmp___17)->Istack_sp = (((PerlInterpreter *)tmp___18)->Istack_base + ax) + (tmpXSoff - 1L);
  }
#line 231
  return;
}
}
#line 235
static void XS_Net__Oping__ping_setopt_timeout(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                               CV *cv  __attribute__((__unused__)) ) ;
#line 236 "Oping.c"
static void XS_Net__Oping__ping_setopt_timeout(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                               CV *cv  __attribute__((__unused__)) ) 
{ 
  SV **sp ;
  void *tmp ;
  I32 ax ;
  void *tmp___0 ;
  I32 *tmp___1 ;
  SV **mark ;
  void *tmp___2 ;
  I32 tmp___3 ;
  I32 items ;
  pingobj_t *obj ;
  double timeout ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  NV tmp___8 ;
  NV tmp___9 ;
  void *tmp___10 ;
  int RETVAL ;
  SV *targ ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  SV *tmp___15 ;
  SV *tmp___16 ;
  void *tmp___17 ;
  IV tmp___18 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  IV tmp___23 ;
  IV tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;
  _Bool tmp___30 ;
  void *tmp___31 ;
  void *tmp___32 ;
  void *tmp___33 ;
  IV tmpXSoff ;
  void *tmp___34 ;
  void *tmp___35 ;

  {
  {
#line 238
  tmp = pthread_getspecific(PL_thr_key);
#line 238
  sp = ((PerlInterpreter *)tmp)->Istack_sp;
#line 238
  tmp___0 = pthread_getspecific(PL_thr_key);
#line 238
  tmp___1 = ((PerlInterpreter *)tmp___0)->Imarkstack_ptr;
#line 238
  (((PerlInterpreter *)tmp___0)->Imarkstack_ptr) --;
#line 238
  ax = *tmp___1;
#line 238
  tmp___2 = pthread_getspecific(PL_thr_key);
#line 238
  tmp___3 = ax;
#line 238
  ax ++;
#line 238
  mark = ((PerlInterpreter *)tmp___2)->Istack_base + tmp___3;
#line 238
  items = (I32 )(sp - mark);
  }
#line 239
  if (items != 2) {
    {
#line 240
    Perl_croak_xs_usage((CV const   */* const  */)cv, (char const   */* const  */)"obj, timeout");
    }
  }
  {
#line 243
  tmp___10 = pthread_getspecific(PL_thr_key);
  }
#line 243
  if (((*(((PerlInterpreter *)tmp___10)->Istack_base + (ax + 1)))->sv_flags & 2097664U) == 512U) {
    {
#line 243
    tmp___5 = pthread_getspecific(PL_thr_key);
#line 243
    tmp___9 = ((XPVNV *)(*(((PerlInterpreter *)tmp___5)->Istack_base + (ax + 1)))->sv_any)->xnv_u.xnv_nv;
    }
  } else {
    {
#line 243
    tmp___6 = pthread_getspecific(PL_thr_key);
#line 243
    tmp___7 = pthread_getspecific(PL_thr_key);
#line 243
    tmp___8 = Perl_sv_2nv_flags((PerlInterpreter *)tmp___7, (SV */* const  */)*(((PerlInterpreter *)tmp___6)->Istack_base + (ax + 1)),
                                (I32 const   )2);
#line 243
    tmp___9 = tmp___8;
    }
  }
  {
#line 243
  timeout = tmp___9;
#line 246
  tmp___17 = pthread_getspecific(PL_thr_key);
  }
#line 246
  if ((int )(((PerlInterpreter *)tmp___17)->Iop)->op_private & 4) {
    {
#line 246
    tmp___12 = pthread_getspecific(PL_thr_key);
#line 246
    tmp___13 = pthread_getspecific(PL_thr_key);
#line 246
    tmp___16 = *(((PerlInterpreter *)tmp___12)->Icurpad + (((PerlInterpreter *)tmp___13)->Iop)->op_targ);
    }
  } else {
    {
#line 246
    tmp___14 = pthread_getspecific(PL_thr_key);
#line 246
    tmp___15 = Perl_sv_newmortal((PerlInterpreter *)tmp___14);
#line 246
    tmp___16 = tmp___15;
    }
  }
  {
#line 246
  targ = tmp___16;
#line 248
  tmp___27 = pthread_getspecific(PL_thr_key);
  }
#line 248
  if ((*(((PerlInterpreter *)tmp___27)->Istack_base + ax))->sv_flags & 2048U) {
    {
#line 248
    tmp___28 = pthread_getspecific(PL_thr_key);
#line 248
    tmp___29 = pthread_getspecific(PL_thr_key);
#line 248
    tmp___30 = Perl_sv_derived_from((PerlInterpreter *)tmp___29, *(((PerlInterpreter *)tmp___28)->Istack_base + ax),
                                    (char const   */* const  */)"pingobj_tPtr");
    }
#line 248
    if (tmp___30) {
      {
#line 249
      tmp___25 = pthread_getspecific(PL_thr_key);
      }
#line 249
      if ((((*(((PerlInterpreter *)tmp___25)->Istack_base + ax))->sv_u.svu_rv)->sv_flags & 2097408U) == 256U) {
        {
#line 249
        tmp___20 = pthread_getspecific(PL_thr_key);
#line 249
        tmp___24 = ((XPVIV *)((*(((PerlInterpreter *)tmp___20)->Istack_base + ax))->sv_u.svu_rv)->sv_any)->xiv_u.xivu_iv;
        }
      } else {
        {
#line 249
        tmp___21 = pthread_getspecific(PL_thr_key);
#line 249
        tmp___22 = pthread_getspecific(PL_thr_key);
#line 249
        tmp___23 = Perl_sv_2iv_flags((PerlInterpreter *)tmp___22, (SV */* const  */)(*(((PerlInterpreter *)tmp___21)->Istack_base + ax))->sv_u.svu_rv,
                                     (I32 const   )2);
#line 249
        tmp___24 = tmp___23;
        }
      }
#line 249
      tmp___18 = tmp___24;
#line 250
      obj = (pingobj_t *)tmp___18;
    } else {
      {
#line 253
      tmp___26 = pthread_getspecific(PL_thr_key);
#line 253
      Perl_croak((PerlInterpreter *)tmp___26, "%s: %s is not of type %s", "Net::Oping::_ping_setopt_timeout",
                 "obj", "pingobj_tPtr");
      }
    }
  } else {
    {
#line 253
    tmp___26 = pthread_getspecific(PL_thr_key);
#line 253
    Perl_croak((PerlInterpreter *)tmp___26, "%s: %s is not of type %s", "Net::Oping::_ping_setopt_timeout",
               "obj", "pingobj_tPtr");
    }
  }
  {
#line 60 "Oping.xs"
  RETVAL = ping_setopt(obj, 1, (void *)(& timeout));
#line 260 "Oping.c"
  tmp___31 = pthread_getspecific(PL_thr_key);
#line 260
  sp = (((PerlInterpreter *)tmp___31)->Istack_base + ax) - 1;
#line 260
  tmp___32 = pthread_getspecific(PL_thr_key);
#line 260
  Perl_sv_setiv((PerlInterpreter *)tmp___32, (SV */* const  */)targ, (IV const   )((IV )RETVAL));
  }
#line 260
  if (targ->sv_flags & 4194304U) {
    {
#line 260
    tmp___33 = pthread_getspecific(PL_thr_key);
#line 260
    Perl_mg_set((PerlInterpreter *)tmp___33, targ);
    }
  }
  {
#line 260
  sp ++;
#line 260
  *sp = targ;
#line 262
  tmpXSoff = (IV )1;
#line 262
  tmp___34 = pthread_getspecific(PL_thr_key);
#line 262
  tmp___35 = pthread_getspecific(PL_thr_key);
#line 262
  ((PerlInterpreter *)tmp___34)->Istack_sp = (((PerlInterpreter *)tmp___35)->Istack_base + ax) + (tmpXSoff - 1L);
  }
#line 262
  return;
}
}
#line 266
static void XS_Net__Oping__ping_setopt_ttl(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                           CV *cv  __attribute__((__unused__)) ) ;
#line 267 "Oping.c"
static void XS_Net__Oping__ping_setopt_ttl(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                           CV *cv  __attribute__((__unused__)) ) 
{ 
  SV **sp ;
  void *tmp ;
  I32 ax ;
  void *tmp___0 ;
  I32 *tmp___1 ;
  SV **mark ;
  void *tmp___2 ;
  I32 tmp___3 ;
  I32 items ;
  pingobj_t *obj ;
  int ttl ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  IV tmp___8 ;
  IV tmp___9 ;
  void *tmp___10 ;
  int RETVAL ;
  SV *targ ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  SV *tmp___15 ;
  SV *tmp___16 ;
  void *tmp___17 ;
  IV tmp___18 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  IV tmp___23 ;
  IV tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;
  _Bool tmp___30 ;
  void *tmp___31 ;
  void *tmp___32 ;
  void *tmp___33 ;
  IV tmpXSoff ;
  void *tmp___34 ;
  void *tmp___35 ;

  {
  {
#line 269
  tmp = pthread_getspecific(PL_thr_key);
#line 269
  sp = ((PerlInterpreter *)tmp)->Istack_sp;
#line 269
  tmp___0 = pthread_getspecific(PL_thr_key);
#line 269
  tmp___1 = ((PerlInterpreter *)tmp___0)->Imarkstack_ptr;
#line 269
  (((PerlInterpreter *)tmp___0)->Imarkstack_ptr) --;
#line 269
  ax = *tmp___1;
#line 269
  tmp___2 = pthread_getspecific(PL_thr_key);
#line 269
  tmp___3 = ax;
#line 269
  ax ++;
#line 269
  mark = ((PerlInterpreter *)tmp___2)->Istack_base + tmp___3;
#line 269
  items = (I32 )(sp - mark);
  }
#line 270
  if (items != 2) {
    {
#line 271
    Perl_croak_xs_usage((CV const   */* const  */)cv, (char const   */* const  */)"obj, ttl");
    }
  }
  {
#line 274
  tmp___10 = pthread_getspecific(PL_thr_key);
  }
#line 274
  if (((*(((PerlInterpreter *)tmp___10)->Istack_base + (ax + 1)))->sv_flags & 2097408U) == 256U) {
    {
#line 274
    tmp___5 = pthread_getspecific(PL_thr_key);
#line 274
    tmp___9 = ((XPVIV *)(*(((PerlInterpreter *)tmp___5)->Istack_base + (ax + 1)))->sv_any)->xiv_u.xivu_iv;
    }
  } else {
    {
#line 274
    tmp___6 = pthread_getspecific(PL_thr_key);
#line 274
    tmp___7 = pthread_getspecific(PL_thr_key);
#line 274
    tmp___8 = Perl_sv_2iv_flags((PerlInterpreter *)tmp___7, (SV */* const  */)*(((PerlInterpreter *)tmp___6)->Istack_base + (ax + 1)),
                                (I32 const   )2);
#line 274
    tmp___9 = tmp___8;
    }
  }
  {
#line 274
  ttl = (int )tmp___9;
#line 277
  tmp___17 = pthread_getspecific(PL_thr_key);
  }
#line 277
  if ((int )(((PerlInterpreter *)tmp___17)->Iop)->op_private & 4) {
    {
#line 277
    tmp___12 = pthread_getspecific(PL_thr_key);
#line 277
    tmp___13 = pthread_getspecific(PL_thr_key);
#line 277
    tmp___16 = *(((PerlInterpreter *)tmp___12)->Icurpad + (((PerlInterpreter *)tmp___13)->Iop)->op_targ);
    }
  } else {
    {
#line 277
    tmp___14 = pthread_getspecific(PL_thr_key);
#line 277
    tmp___15 = Perl_sv_newmortal((PerlInterpreter *)tmp___14);
#line 277
    tmp___16 = tmp___15;
    }
  }
  {
#line 277
  targ = tmp___16;
#line 279
  tmp___27 = pthread_getspecific(PL_thr_key);
  }
#line 279
  if ((*(((PerlInterpreter *)tmp___27)->Istack_base + ax))->sv_flags & 2048U) {
    {
#line 279
    tmp___28 = pthread_getspecific(PL_thr_key);
#line 279
    tmp___29 = pthread_getspecific(PL_thr_key);
#line 279
    tmp___30 = Perl_sv_derived_from((PerlInterpreter *)tmp___29, *(((PerlInterpreter *)tmp___28)->Istack_base + ax),
                                    (char const   */* const  */)"pingobj_tPtr");
    }
#line 279
    if (tmp___30) {
      {
#line 280
      tmp___25 = pthread_getspecific(PL_thr_key);
      }
#line 280
      if ((((*(((PerlInterpreter *)tmp___25)->Istack_base + ax))->sv_u.svu_rv)->sv_flags & 2097408U) == 256U) {
        {
#line 280
        tmp___20 = pthread_getspecific(PL_thr_key);
#line 280
        tmp___24 = ((XPVIV *)((*(((PerlInterpreter *)tmp___20)->Istack_base + ax))->sv_u.svu_rv)->sv_any)->xiv_u.xivu_iv;
        }
      } else {
        {
#line 280
        tmp___21 = pthread_getspecific(PL_thr_key);
#line 280
        tmp___22 = pthread_getspecific(PL_thr_key);
#line 280
        tmp___23 = Perl_sv_2iv_flags((PerlInterpreter *)tmp___22, (SV */* const  */)(*(((PerlInterpreter *)tmp___21)->Istack_base + ax))->sv_u.svu_rv,
                                     (I32 const   )2);
#line 280
        tmp___24 = tmp___23;
        }
      }
#line 280
      tmp___18 = tmp___24;
#line 281
      obj = (pingobj_t *)tmp___18;
    } else {
      {
#line 284
      tmp___26 = pthread_getspecific(PL_thr_key);
#line 284
      Perl_croak((PerlInterpreter *)tmp___26, "%s: %s is not of type %s", "Net::Oping::_ping_setopt_ttl",
                 "obj", "pingobj_tPtr");
      }
    }
  } else {
    {
#line 284
    tmp___26 = pthread_getspecific(PL_thr_key);
#line 284
    Perl_croak((PerlInterpreter *)tmp___26, "%s: %s is not of type %s", "Net::Oping::_ping_setopt_ttl",
               "obj", "pingobj_tPtr");
    }
  }
  {
#line 69 "Oping.xs"
  RETVAL = ping_setopt(obj, 2, (void *)(& ttl));
#line 291 "Oping.c"
  tmp___31 = pthread_getspecific(PL_thr_key);
#line 291
  sp = (((PerlInterpreter *)tmp___31)->Istack_base + ax) - 1;
#line 291
  tmp___32 = pthread_getspecific(PL_thr_key);
#line 291
  Perl_sv_setiv((PerlInterpreter *)tmp___32, (SV */* const  */)targ, (IV const   )((IV )RETVAL));
  }
#line 291
  if (targ->sv_flags & 4194304U) {
    {
#line 291
    tmp___33 = pthread_getspecific(PL_thr_key);
#line 291
    Perl_mg_set((PerlInterpreter *)tmp___33, targ);
    }
  }
  {
#line 291
  sp ++;
#line 291
  *sp = targ;
#line 293
  tmpXSoff = (IV )1;
#line 293
  tmp___34 = pthread_getspecific(PL_thr_key);
#line 293
  tmp___35 = pthread_getspecific(PL_thr_key);
#line 293
  ((PerlInterpreter *)tmp___34)->Istack_sp = (((PerlInterpreter *)tmp___35)->Istack_base + ax) + (tmpXSoff - 1L);
  }
#line 293
  return;
}
}
#line 297
static void XS_Net__Oping__ping_setopt_source(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                              CV *cv  __attribute__((__unused__)) ) ;
#line 298 "Oping.c"
static void XS_Net__Oping__ping_setopt_source(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                              CV *cv  __attribute__((__unused__)) ) 
{ 
  SV **sp ;
  void *tmp ;
  I32 ax ;
  void *tmp___0 ;
  I32 *tmp___1 ;
  SV **mark ;
  void *tmp___2 ;
  I32 tmp___3 ;
  I32 items ;
  pingobj_t *obj ;
  char *addr ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  void *tmp___10 ;
  int RETVAL ;
  SV *targ ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  SV *tmp___15 ;
  SV *tmp___16 ;
  void *tmp___17 ;
  IV tmp___18 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  IV tmp___23 ;
  IV tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;
  _Bool tmp___30 ;
  void *tmp___31 ;
  void *tmp___32 ;
  void *tmp___33 ;
  IV tmpXSoff ;
  void *tmp___34 ;
  void *tmp___35 ;

  {
  {
#line 300
  tmp = pthread_getspecific(PL_thr_key);
#line 300
  sp = ((PerlInterpreter *)tmp)->Istack_sp;
#line 300
  tmp___0 = pthread_getspecific(PL_thr_key);
#line 300
  tmp___1 = ((PerlInterpreter *)tmp___0)->Imarkstack_ptr;
#line 300
  (((PerlInterpreter *)tmp___0)->Imarkstack_ptr) --;
#line 300
  ax = *tmp___1;
#line 300
  tmp___2 = pthread_getspecific(PL_thr_key);
#line 300
  tmp___3 = ax;
#line 300
  ax ++;
#line 300
  mark = ((PerlInterpreter *)tmp___2)->Istack_base + tmp___3;
#line 300
  items = (I32 )(sp - mark);
  }
#line 301
  if (items != 2) {
    {
#line 302
    Perl_croak_xs_usage((CV const   */* const  */)cv, (char const   */* const  */)"obj, addr");
    }
  }
  {
#line 305
  tmp___10 = pthread_getspecific(PL_thr_key);
  }
#line 305
  if (((*(((PerlInterpreter *)tmp___10)->Istack_base + (ax + 1)))->sv_flags & 2098176U) == 1024U) {
    {
#line 305
    tmp___5 = pthread_getspecific(PL_thr_key);
#line 305
    tmp___9 = (*(((PerlInterpreter *)tmp___5)->Istack_base + (ax + 1)))->sv_u.svu_pv;
    }
  } else {
    {
#line 305
    tmp___6 = pthread_getspecific(PL_thr_key);
#line 305
    tmp___7 = pthread_getspecific(PL_thr_key);
#line 305
    tmp___8 = Perl_sv_2pv_flags((PerlInterpreter *)tmp___7, (SV */* const  */)*(((PerlInterpreter *)tmp___6)->Istack_base + (ax + 1)),
                                (STRLEN */* const  */)0, (I32 const   )2);
#line 305
    tmp___9 = tmp___8;
    }
  }
  {
#line 305
  addr = tmp___9;
#line 308
  tmp___17 = pthread_getspecific(PL_thr_key);
  }
#line 308
  if ((int )(((PerlInterpreter *)tmp___17)->Iop)->op_private & 4) {
    {
#line 308
    tmp___12 = pthread_getspecific(PL_thr_key);
#line 308
    tmp___13 = pthread_getspecific(PL_thr_key);
#line 308
    tmp___16 = *(((PerlInterpreter *)tmp___12)->Icurpad + (((PerlInterpreter *)tmp___13)->Iop)->op_targ);
    }
  } else {
    {
#line 308
    tmp___14 = pthread_getspecific(PL_thr_key);
#line 308
    tmp___15 = Perl_sv_newmortal((PerlInterpreter *)tmp___14);
#line 308
    tmp___16 = tmp___15;
    }
  }
  {
#line 308
  targ = tmp___16;
#line 310
  tmp___27 = pthread_getspecific(PL_thr_key);
  }
#line 310
  if ((*(((PerlInterpreter *)tmp___27)->Istack_base + ax))->sv_flags & 2048U) {
    {
#line 310
    tmp___28 = pthread_getspecific(PL_thr_key);
#line 310
    tmp___29 = pthread_getspecific(PL_thr_key);
#line 310
    tmp___30 = Perl_sv_derived_from((PerlInterpreter *)tmp___29, *(((PerlInterpreter *)tmp___28)->Istack_base + ax),
                                    (char const   */* const  */)"pingobj_tPtr");
    }
#line 310
    if (tmp___30) {
      {
#line 311
      tmp___25 = pthread_getspecific(PL_thr_key);
      }
#line 311
      if ((((*(((PerlInterpreter *)tmp___25)->Istack_base + ax))->sv_u.svu_rv)->sv_flags & 2097408U) == 256U) {
        {
#line 311
        tmp___20 = pthread_getspecific(PL_thr_key);
#line 311
        tmp___24 = ((XPVIV *)((*(((PerlInterpreter *)tmp___20)->Istack_base + ax))->sv_u.svu_rv)->sv_any)->xiv_u.xivu_iv;
        }
      } else {
        {
#line 311
        tmp___21 = pthread_getspecific(PL_thr_key);
#line 311
        tmp___22 = pthread_getspecific(PL_thr_key);
#line 311
        tmp___23 = Perl_sv_2iv_flags((PerlInterpreter *)tmp___22, (SV */* const  */)(*(((PerlInterpreter *)tmp___21)->Istack_base + ax))->sv_u.svu_rv,
                                     (I32 const   )2);
#line 311
        tmp___24 = tmp___23;
        }
      }
#line 311
      tmp___18 = tmp___24;
#line 312
      obj = (pingobj_t *)tmp___18;
    } else {
      {
#line 315
      tmp___26 = pthread_getspecific(PL_thr_key);
#line 315
      Perl_croak((PerlInterpreter *)tmp___26, "%s: %s is not of type %s", "Net::Oping::_ping_setopt_source",
                 "obj", "pingobj_tPtr");
      }
    }
  } else {
    {
#line 315
    tmp___26 = pthread_getspecific(PL_thr_key);
#line 315
    Perl_croak((PerlInterpreter *)tmp___26, "%s: %s is not of type %s", "Net::Oping::_ping_setopt_source",
               "obj", "pingobj_tPtr");
    }
  }
  {
#line 78 "Oping.xs"
  RETVAL = ping_setopt(obj, 16, (void *)addr);
#line 322 "Oping.c"
  tmp___31 = pthread_getspecific(PL_thr_key);
#line 322
  sp = (((PerlInterpreter *)tmp___31)->Istack_base + ax) - 1;
#line 322
  tmp___32 = pthread_getspecific(PL_thr_key);
#line 322
  Perl_sv_setiv((PerlInterpreter *)tmp___32, (SV */* const  */)targ, (IV const   )((IV )RETVAL));
  }
#line 322
  if (targ->sv_flags & 4194304U) {
    {
#line 322
    tmp___33 = pthread_getspecific(PL_thr_key);
#line 322
    Perl_mg_set((PerlInterpreter *)tmp___33, targ);
    }
  }
  {
#line 322
  sp ++;
#line 322
  *sp = targ;
#line 324
  tmpXSoff = (IV )1;
#line 324
  tmp___34 = pthread_getspecific(PL_thr_key);
#line 324
  tmp___35 = pthread_getspecific(PL_thr_key);
#line 324
  ((PerlInterpreter *)tmp___34)->Istack_sp = (((PerlInterpreter *)tmp___35)->Istack_base + ax) + (tmpXSoff - 1L);
  }
#line 324
  return;
}
}
#line 328
static void XS_Net__Oping__ping_setopt_device(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                              CV *cv  __attribute__((__unused__)) ) ;
#line 329 "Oping.c"
static void XS_Net__Oping__ping_setopt_device(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                              CV *cv  __attribute__((__unused__)) ) 
{ 
  SV **sp ;
  void *tmp ;
  I32 ax ;
  void *tmp___0 ;
  I32 *tmp___1 ;
  SV **mark ;
  void *tmp___2 ;
  I32 tmp___3 ;
  I32 items ;
  pingobj_t *obj ;
  char *dev ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  void *tmp___10 ;
  int RETVAL ;
  SV *targ ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  SV *tmp___15 ;
  SV *tmp___16 ;
  void *tmp___17 ;
  IV tmp___18 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  IV tmp___23 ;
  IV tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;
  _Bool tmp___30 ;
  void *tmp___31 ;
  void *tmp___32 ;
  void *tmp___33 ;
  IV tmpXSoff ;
  void *tmp___34 ;
  void *tmp___35 ;

  {
  {
#line 331
  tmp = pthread_getspecific(PL_thr_key);
#line 331
  sp = ((PerlInterpreter *)tmp)->Istack_sp;
#line 331
  tmp___0 = pthread_getspecific(PL_thr_key);
#line 331
  tmp___1 = ((PerlInterpreter *)tmp___0)->Imarkstack_ptr;
#line 331
  (((PerlInterpreter *)tmp___0)->Imarkstack_ptr) --;
#line 331
  ax = *tmp___1;
#line 331
  tmp___2 = pthread_getspecific(PL_thr_key);
#line 331
  tmp___3 = ax;
#line 331
  ax ++;
#line 331
  mark = ((PerlInterpreter *)tmp___2)->Istack_base + tmp___3;
#line 331
  items = (I32 )(sp - mark);
  }
#line 332
  if (items != 2) {
    {
#line 333
    Perl_croak_xs_usage((CV const   */* const  */)cv, (char const   */* const  */)"obj, dev");
    }
  }
  {
#line 336
  tmp___10 = pthread_getspecific(PL_thr_key);
  }
#line 336
  if (((*(((PerlInterpreter *)tmp___10)->Istack_base + (ax + 1)))->sv_flags & 2098176U) == 1024U) {
    {
#line 336
    tmp___5 = pthread_getspecific(PL_thr_key);
#line 336
    tmp___9 = (*(((PerlInterpreter *)tmp___5)->Istack_base + (ax + 1)))->sv_u.svu_pv;
    }
  } else {
    {
#line 336
    tmp___6 = pthread_getspecific(PL_thr_key);
#line 336
    tmp___7 = pthread_getspecific(PL_thr_key);
#line 336
    tmp___8 = Perl_sv_2pv_flags((PerlInterpreter *)tmp___7, (SV */* const  */)*(((PerlInterpreter *)tmp___6)->Istack_base + (ax + 1)),
                                (STRLEN */* const  */)0, (I32 const   )2);
#line 336
    tmp___9 = tmp___8;
    }
  }
  {
#line 336
  dev = tmp___9;
#line 339
  tmp___17 = pthread_getspecific(PL_thr_key);
  }
#line 339
  if ((int )(((PerlInterpreter *)tmp___17)->Iop)->op_private & 4) {
    {
#line 339
    tmp___12 = pthread_getspecific(PL_thr_key);
#line 339
    tmp___13 = pthread_getspecific(PL_thr_key);
#line 339
    tmp___16 = *(((PerlInterpreter *)tmp___12)->Icurpad + (((PerlInterpreter *)tmp___13)->Iop)->op_targ);
    }
  } else {
    {
#line 339
    tmp___14 = pthread_getspecific(PL_thr_key);
#line 339
    tmp___15 = Perl_sv_newmortal((PerlInterpreter *)tmp___14);
#line 339
    tmp___16 = tmp___15;
    }
  }
  {
#line 339
  targ = tmp___16;
#line 341
  tmp___27 = pthread_getspecific(PL_thr_key);
  }
#line 341
  if ((*(((PerlInterpreter *)tmp___27)->Istack_base + ax))->sv_flags & 2048U) {
    {
#line 341
    tmp___28 = pthread_getspecific(PL_thr_key);
#line 341
    tmp___29 = pthread_getspecific(PL_thr_key);
#line 341
    tmp___30 = Perl_sv_derived_from((PerlInterpreter *)tmp___29, *(((PerlInterpreter *)tmp___28)->Istack_base + ax),
                                    (char const   */* const  */)"pingobj_tPtr");
    }
#line 341
    if (tmp___30) {
      {
#line 342
      tmp___25 = pthread_getspecific(PL_thr_key);
      }
#line 342
      if ((((*(((PerlInterpreter *)tmp___25)->Istack_base + ax))->sv_u.svu_rv)->sv_flags & 2097408U) == 256U) {
        {
#line 342
        tmp___20 = pthread_getspecific(PL_thr_key);
#line 342
        tmp___24 = ((XPVIV *)((*(((PerlInterpreter *)tmp___20)->Istack_base + ax))->sv_u.svu_rv)->sv_any)->xiv_u.xivu_iv;
        }
      } else {
        {
#line 342
        tmp___21 = pthread_getspecific(PL_thr_key);
#line 342
        tmp___22 = pthread_getspecific(PL_thr_key);
#line 342
        tmp___23 = Perl_sv_2iv_flags((PerlInterpreter *)tmp___22, (SV */* const  */)(*(((PerlInterpreter *)tmp___21)->Istack_base + ax))->sv_u.svu_rv,
                                     (I32 const   )2);
#line 342
        tmp___24 = tmp___23;
        }
      }
#line 342
      tmp___18 = tmp___24;
#line 343
      obj = (pingobj_t *)tmp___18;
    } else {
      {
#line 346
      tmp___26 = pthread_getspecific(PL_thr_key);
#line 346
      Perl_croak((PerlInterpreter *)tmp___26, "%s: %s is not of type %s", "Net::Oping::_ping_setopt_device",
                 "obj", "pingobj_tPtr");
      }
    }
  } else {
    {
#line 346
    tmp___26 = pthread_getspecific(PL_thr_key);
#line 346
    Perl_croak((PerlInterpreter *)tmp___26, "%s: %s is not of type %s", "Net::Oping::_ping_setopt_device",
               "obj", "pingobj_tPtr");
    }
  }
  {
#line 88 "Oping.xs"
  RETVAL = ping_setopt(obj, 32, (void *)dev);
#line 357 "Oping.c"
  tmp___31 = pthread_getspecific(PL_thr_key);
#line 357
  sp = (((PerlInterpreter *)tmp___31)->Istack_base + ax) - 1;
#line 357
  tmp___32 = pthread_getspecific(PL_thr_key);
#line 357
  Perl_sv_setiv((PerlInterpreter *)tmp___32, (SV */* const  */)targ, (IV const   )((IV )RETVAL));
  }
#line 357
  if (targ->sv_flags & 4194304U) {
    {
#line 357
    tmp___33 = pthread_getspecific(PL_thr_key);
#line 357
    Perl_mg_set((PerlInterpreter *)tmp___33, targ);
    }
  }
  {
#line 357
  sp ++;
#line 357
  *sp = targ;
#line 359
  tmpXSoff = (IV )1;
#line 359
  tmp___34 = pthread_getspecific(PL_thr_key);
#line 359
  tmp___35 = pthread_getspecific(PL_thr_key);
#line 359
  ((PerlInterpreter *)tmp___34)->Istack_sp = (((PerlInterpreter *)tmp___35)->Istack_base + ax) + (tmpXSoff - 1L);
  }
#line 359
  return;
}
}
#line 363
static void XS_Net__Oping__ping_host_add(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                         CV *cv  __attribute__((__unused__)) ) ;
#line 364 "Oping.c"
static void XS_Net__Oping__ping_host_add(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                         CV *cv  __attribute__((__unused__)) ) 
{ 
  SV **sp ;
  void *tmp ;
  I32 ax ;
  void *tmp___0 ;
  I32 *tmp___1 ;
  SV **mark ;
  void *tmp___2 ;
  I32 tmp___3 ;
  I32 items ;
  pingobj_t *obj ;
  char const   *host ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  void *tmp___10 ;
  int RETVAL ;
  SV *targ ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  SV *tmp___15 ;
  SV *tmp___16 ;
  void *tmp___17 ;
  IV tmp___18 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  IV tmp___23 ;
  IV tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;
  _Bool tmp___30 ;
  void *tmp___31 ;
  void *tmp___32 ;
  void *tmp___33 ;
  IV tmpXSoff ;
  void *tmp___34 ;
  void *tmp___35 ;

  {
  {
#line 366
  tmp = pthread_getspecific(PL_thr_key);
#line 366
  sp = ((PerlInterpreter *)tmp)->Istack_sp;
#line 366
  tmp___0 = pthread_getspecific(PL_thr_key);
#line 366
  tmp___1 = ((PerlInterpreter *)tmp___0)->Imarkstack_ptr;
#line 366
  (((PerlInterpreter *)tmp___0)->Imarkstack_ptr) --;
#line 366
  ax = *tmp___1;
#line 366
  tmp___2 = pthread_getspecific(PL_thr_key);
#line 366
  tmp___3 = ax;
#line 366
  ax ++;
#line 366
  mark = ((PerlInterpreter *)tmp___2)->Istack_base + tmp___3;
#line 366
  items = (I32 )(sp - mark);
  }
#line 367
  if (items != 2) {
    {
#line 368
    Perl_croak_xs_usage((CV const   */* const  */)cv, (char const   */* const  */)"obj, host");
    }
  }
  {
#line 371
  tmp___10 = pthread_getspecific(PL_thr_key);
  }
#line 371
  if (((*(((PerlInterpreter *)tmp___10)->Istack_base + (ax + 1)))->sv_flags & 2098176U) == 1024U) {
    {
#line 371
    tmp___5 = pthread_getspecific(PL_thr_key);
#line 371
    tmp___9 = (*(((PerlInterpreter *)tmp___5)->Istack_base + (ax + 1)))->sv_u.svu_pv;
    }
  } else {
    {
#line 371
    tmp___6 = pthread_getspecific(PL_thr_key);
#line 371
    tmp___7 = pthread_getspecific(PL_thr_key);
#line 371
    tmp___8 = Perl_sv_2pv_flags((PerlInterpreter *)tmp___7, (SV */* const  */)*(((PerlInterpreter *)tmp___6)->Istack_base + (ax + 1)),
                                (STRLEN */* const  */)0, (I32 const   )2);
#line 371
    tmp___9 = tmp___8;
    }
  }
  {
#line 371
  host = (char const   *)tmp___9;
#line 374
  tmp___17 = pthread_getspecific(PL_thr_key);
  }
#line 374
  if ((int )(((PerlInterpreter *)tmp___17)->Iop)->op_private & 4) {
    {
#line 374
    tmp___12 = pthread_getspecific(PL_thr_key);
#line 374
    tmp___13 = pthread_getspecific(PL_thr_key);
#line 374
    tmp___16 = *(((PerlInterpreter *)tmp___12)->Icurpad + (((PerlInterpreter *)tmp___13)->Iop)->op_targ);
    }
  } else {
    {
#line 374
    tmp___14 = pthread_getspecific(PL_thr_key);
#line 374
    tmp___15 = Perl_sv_newmortal((PerlInterpreter *)tmp___14);
#line 374
    tmp___16 = tmp___15;
    }
  }
  {
#line 374
  targ = tmp___16;
#line 376
  tmp___27 = pthread_getspecific(PL_thr_key);
  }
#line 376
  if ((*(((PerlInterpreter *)tmp___27)->Istack_base + ax))->sv_flags & 2048U) {
    {
#line 376
    tmp___28 = pthread_getspecific(PL_thr_key);
#line 376
    tmp___29 = pthread_getspecific(PL_thr_key);
#line 376
    tmp___30 = Perl_sv_derived_from((PerlInterpreter *)tmp___29, *(((PerlInterpreter *)tmp___28)->Istack_base + ax),
                                    (char const   */* const  */)"pingobj_tPtr");
    }
#line 376
    if (tmp___30) {
      {
#line 377
      tmp___25 = pthread_getspecific(PL_thr_key);
      }
#line 377
      if ((((*(((PerlInterpreter *)tmp___25)->Istack_base + ax))->sv_u.svu_rv)->sv_flags & 2097408U) == 256U) {
        {
#line 377
        tmp___20 = pthread_getspecific(PL_thr_key);
#line 377
        tmp___24 = ((XPVIV *)((*(((PerlInterpreter *)tmp___20)->Istack_base + ax))->sv_u.svu_rv)->sv_any)->xiv_u.xivu_iv;
        }
      } else {
        {
#line 377
        tmp___21 = pthread_getspecific(PL_thr_key);
#line 377
        tmp___22 = pthread_getspecific(PL_thr_key);
#line 377
        tmp___23 = Perl_sv_2iv_flags((PerlInterpreter *)tmp___22, (SV */* const  */)(*(((PerlInterpreter *)tmp___21)->Istack_base + ax))->sv_u.svu_rv,
                                     (I32 const   )2);
#line 377
        tmp___24 = tmp___23;
        }
      }
#line 377
      tmp___18 = tmp___24;
#line 378
      obj = (pingobj_t *)tmp___18;
    } else {
      {
#line 381
      tmp___26 = pthread_getspecific(PL_thr_key);
#line 381
      Perl_croak((PerlInterpreter *)tmp___26, "%s: %s is not of type %s", "Net::Oping::_ping_host_add",
                 "obj", "pingobj_tPtr");
      }
    }
  } else {
    {
#line 381
    tmp___26 = pthread_getspecific(PL_thr_key);
#line 381
    Perl_croak((PerlInterpreter *)tmp___26, "%s: %s is not of type %s", "Net::Oping::_ping_host_add",
               "obj", "pingobj_tPtr");
    }
  }
  {
#line 100 "Oping.xs"
  RETVAL = ping_host_add(obj, host);
#line 388 "Oping.c"
  tmp___31 = pthread_getspecific(PL_thr_key);
#line 388
  sp = (((PerlInterpreter *)tmp___31)->Istack_base + ax) - 1;
#line 388
  tmp___32 = pthread_getspecific(PL_thr_key);
#line 388
  Perl_sv_setiv((PerlInterpreter *)tmp___32, (SV */* const  */)targ, (IV const   )((IV )RETVAL));
  }
#line 388
  if (targ->sv_flags & 4194304U) {
    {
#line 388
    tmp___33 = pthread_getspecific(PL_thr_key);
#line 388
    Perl_mg_set((PerlInterpreter *)tmp___33, targ);
    }
  }
  {
#line 388
  sp ++;
#line 388
  *sp = targ;
#line 390
  tmpXSoff = (IV )1;
#line 390
  tmp___34 = pthread_getspecific(PL_thr_key);
#line 390
  tmp___35 = pthread_getspecific(PL_thr_key);
#line 390
  ((PerlInterpreter *)tmp___34)->Istack_sp = (((PerlInterpreter *)tmp___35)->Istack_base + ax) + (tmpXSoff - 1L);
  }
#line 390
  return;
}
}
#line 394
static void XS_Net__Oping__ping_host_remove(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                            CV *cv  __attribute__((__unused__)) ) ;
#line 395 "Oping.c"
static void XS_Net__Oping__ping_host_remove(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                            CV *cv  __attribute__((__unused__)) ) 
{ 
  SV **sp ;
  void *tmp ;
  I32 ax ;
  void *tmp___0 ;
  I32 *tmp___1 ;
  SV **mark ;
  void *tmp___2 ;
  I32 tmp___3 ;
  I32 items ;
  pingobj_t *obj ;
  char const   *host ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  void *tmp___10 ;
  int RETVAL ;
  SV *targ ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  SV *tmp___15 ;
  SV *tmp___16 ;
  void *tmp___17 ;
  IV tmp___18 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  IV tmp___23 ;
  IV tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;
  _Bool tmp___30 ;
  void *tmp___31 ;
  void *tmp___32 ;
  void *tmp___33 ;
  IV tmpXSoff ;
  void *tmp___34 ;
  void *tmp___35 ;

  {
  {
#line 397
  tmp = pthread_getspecific(PL_thr_key);
#line 397
  sp = ((PerlInterpreter *)tmp)->Istack_sp;
#line 397
  tmp___0 = pthread_getspecific(PL_thr_key);
#line 397
  tmp___1 = ((PerlInterpreter *)tmp___0)->Imarkstack_ptr;
#line 397
  (((PerlInterpreter *)tmp___0)->Imarkstack_ptr) --;
#line 397
  ax = *tmp___1;
#line 397
  tmp___2 = pthread_getspecific(PL_thr_key);
#line 397
  tmp___3 = ax;
#line 397
  ax ++;
#line 397
  mark = ((PerlInterpreter *)tmp___2)->Istack_base + tmp___3;
#line 397
  items = (I32 )(sp - mark);
  }
#line 398
  if (items != 2) {
    {
#line 399
    Perl_croak_xs_usage((CV const   */* const  */)cv, (char const   */* const  */)"obj, host");
    }
  }
  {
#line 402
  tmp___10 = pthread_getspecific(PL_thr_key);
  }
#line 402
  if (((*(((PerlInterpreter *)tmp___10)->Istack_base + (ax + 1)))->sv_flags & 2098176U) == 1024U) {
    {
#line 402
    tmp___5 = pthread_getspecific(PL_thr_key);
#line 402
    tmp___9 = (*(((PerlInterpreter *)tmp___5)->Istack_base + (ax + 1)))->sv_u.svu_pv;
    }
  } else {
    {
#line 402
    tmp___6 = pthread_getspecific(PL_thr_key);
#line 402
    tmp___7 = pthread_getspecific(PL_thr_key);
#line 402
    tmp___8 = Perl_sv_2pv_flags((PerlInterpreter *)tmp___7, (SV */* const  */)*(((PerlInterpreter *)tmp___6)->Istack_base + (ax + 1)),
                                (STRLEN */* const  */)0, (I32 const   )2);
#line 402
    tmp___9 = tmp___8;
    }
  }
  {
#line 402
  host = (char const   *)tmp___9;
#line 405
  tmp___17 = pthread_getspecific(PL_thr_key);
  }
#line 405
  if ((int )(((PerlInterpreter *)tmp___17)->Iop)->op_private & 4) {
    {
#line 405
    tmp___12 = pthread_getspecific(PL_thr_key);
#line 405
    tmp___13 = pthread_getspecific(PL_thr_key);
#line 405
    tmp___16 = *(((PerlInterpreter *)tmp___12)->Icurpad + (((PerlInterpreter *)tmp___13)->Iop)->op_targ);
    }
  } else {
    {
#line 405
    tmp___14 = pthread_getspecific(PL_thr_key);
#line 405
    tmp___15 = Perl_sv_newmortal((PerlInterpreter *)tmp___14);
#line 405
    tmp___16 = tmp___15;
    }
  }
  {
#line 405
  targ = tmp___16;
#line 407
  tmp___27 = pthread_getspecific(PL_thr_key);
  }
#line 407
  if ((*(((PerlInterpreter *)tmp___27)->Istack_base + ax))->sv_flags & 2048U) {
    {
#line 407
    tmp___28 = pthread_getspecific(PL_thr_key);
#line 407
    tmp___29 = pthread_getspecific(PL_thr_key);
#line 407
    tmp___30 = Perl_sv_derived_from((PerlInterpreter *)tmp___29, *(((PerlInterpreter *)tmp___28)->Istack_base + ax),
                                    (char const   */* const  */)"pingobj_tPtr");
    }
#line 407
    if (tmp___30) {
      {
#line 408
      tmp___25 = pthread_getspecific(PL_thr_key);
      }
#line 408
      if ((((*(((PerlInterpreter *)tmp___25)->Istack_base + ax))->sv_u.svu_rv)->sv_flags & 2097408U) == 256U) {
        {
#line 408
        tmp___20 = pthread_getspecific(PL_thr_key);
#line 408
        tmp___24 = ((XPVIV *)((*(((PerlInterpreter *)tmp___20)->Istack_base + ax))->sv_u.svu_rv)->sv_any)->xiv_u.xivu_iv;
        }
      } else {
        {
#line 408
        tmp___21 = pthread_getspecific(PL_thr_key);
#line 408
        tmp___22 = pthread_getspecific(PL_thr_key);
#line 408
        tmp___23 = Perl_sv_2iv_flags((PerlInterpreter *)tmp___22, (SV */* const  */)(*(((PerlInterpreter *)tmp___21)->Istack_base + ax))->sv_u.svu_rv,
                                     (I32 const   )2);
#line 408
        tmp___24 = tmp___23;
        }
      }
#line 408
      tmp___18 = tmp___24;
#line 409
      obj = (pingobj_t *)tmp___18;
    } else {
      {
#line 412
      tmp___26 = pthread_getspecific(PL_thr_key);
#line 412
      Perl_croak((PerlInterpreter *)tmp___26, "%s: %s is not of type %s", "Net::Oping::_ping_host_remove",
                 "obj", "pingobj_tPtr");
      }
    }
  } else {
    {
#line 412
    tmp___26 = pthread_getspecific(PL_thr_key);
#line 412
    Perl_croak((PerlInterpreter *)tmp___26, "%s: %s is not of type %s", "Net::Oping::_ping_host_remove",
               "obj", "pingobj_tPtr");
    }
  }
  {
#line 109 "Oping.xs"
  RETVAL = ping_host_remove(obj, host);
#line 419 "Oping.c"
  tmp___31 = pthread_getspecific(PL_thr_key);
#line 419
  sp = (((PerlInterpreter *)tmp___31)->Istack_base + ax) - 1;
#line 419
  tmp___32 = pthread_getspecific(PL_thr_key);
#line 419
  Perl_sv_setiv((PerlInterpreter *)tmp___32, (SV */* const  */)targ, (IV const   )((IV )RETVAL));
  }
#line 419
  if (targ->sv_flags & 4194304U) {
    {
#line 419
    tmp___33 = pthread_getspecific(PL_thr_key);
#line 419
    Perl_mg_set((PerlInterpreter *)tmp___33, targ);
    }
  }
  {
#line 419
  sp ++;
#line 419
  *sp = targ;
#line 421
  tmpXSoff = (IV )1;
#line 421
  tmp___34 = pthread_getspecific(PL_thr_key);
#line 421
  tmp___35 = pthread_getspecific(PL_thr_key);
#line 421
  ((PerlInterpreter *)tmp___34)->Istack_sp = (((PerlInterpreter *)tmp___35)->Istack_base + ax) + (tmpXSoff - 1L);
  }
#line 421
  return;
}
}
#line 425
static void XS_Net__Oping__ping_send(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                     CV *cv  __attribute__((__unused__)) ) ;
#line 426 "Oping.c"
static void XS_Net__Oping__ping_send(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                     CV *cv  __attribute__((__unused__)) ) 
{ 
  SV **sp ;
  void *tmp ;
  I32 ax ;
  void *tmp___0 ;
  I32 *tmp___1 ;
  SV **mark ;
  void *tmp___2 ;
  I32 tmp___3 ;
  I32 items ;
  pingobj_t *obj ;
  int RETVAL ;
  SV *targ ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  SV *tmp___8 ;
  SV *tmp___9 ;
  void *tmp___10 ;
  IV tmp___11 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  IV tmp___16 ;
  IV tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  _Bool tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  IV tmpXSoff ;
  void *tmp___27 ;
  void *tmp___28 ;

  {
  {
#line 428
  tmp = pthread_getspecific(PL_thr_key);
#line 428
  sp = ((PerlInterpreter *)tmp)->Istack_sp;
#line 428
  tmp___0 = pthread_getspecific(PL_thr_key);
#line 428
  tmp___1 = ((PerlInterpreter *)tmp___0)->Imarkstack_ptr;
#line 428
  (((PerlInterpreter *)tmp___0)->Imarkstack_ptr) --;
#line 428
  ax = *tmp___1;
#line 428
  tmp___2 = pthread_getspecific(PL_thr_key);
#line 428
  tmp___3 = ax;
#line 428
  ax ++;
#line 428
  mark = ((PerlInterpreter *)tmp___2)->Istack_base + tmp___3;
#line 428
  items = (I32 )(sp - mark);
  }
#line 429
  if (items != 1) {
    {
#line 430
    Perl_croak_xs_usage((CV const   */* const  */)cv, (char const   */* const  */)"obj");
    }
  }
  {
#line 434
  tmp___10 = pthread_getspecific(PL_thr_key);
  }
#line 434
  if ((int )(((PerlInterpreter *)tmp___10)->Iop)->op_private & 4) {
    {
#line 434
    tmp___5 = pthread_getspecific(PL_thr_key);
#line 434
    tmp___6 = pthread_getspecific(PL_thr_key);
#line 434
    tmp___9 = *(((PerlInterpreter *)tmp___5)->Icurpad + (((PerlInterpreter *)tmp___6)->Iop)->op_targ);
    }
  } else {
    {
#line 434
    tmp___7 = pthread_getspecific(PL_thr_key);
#line 434
    tmp___8 = Perl_sv_newmortal((PerlInterpreter *)tmp___7);
#line 434
    tmp___9 = tmp___8;
    }
  }
  {
#line 434
  targ = tmp___9;
#line 436
  tmp___20 = pthread_getspecific(PL_thr_key);
  }
#line 436
  if ((*(((PerlInterpreter *)tmp___20)->Istack_base + ax))->sv_flags & 2048U) {
    {
#line 436
    tmp___21 = pthread_getspecific(PL_thr_key);
#line 436
    tmp___22 = pthread_getspecific(PL_thr_key);
#line 436
    tmp___23 = Perl_sv_derived_from((PerlInterpreter *)tmp___22, *(((PerlInterpreter *)tmp___21)->Istack_base + ax),
                                    (char const   */* const  */)"pingobj_tPtr");
    }
#line 436
    if (tmp___23) {
      {
#line 437
      tmp___18 = pthread_getspecific(PL_thr_key);
      }
#line 437
      if ((((*(((PerlInterpreter *)tmp___18)->Istack_base + ax))->sv_u.svu_rv)->sv_flags & 2097408U) == 256U) {
        {
#line 437
        tmp___13 = pthread_getspecific(PL_thr_key);
#line 437
        tmp___17 = ((XPVIV *)((*(((PerlInterpreter *)tmp___13)->Istack_base + ax))->sv_u.svu_rv)->sv_any)->xiv_u.xivu_iv;
        }
      } else {
        {
#line 437
        tmp___14 = pthread_getspecific(PL_thr_key);
#line 437
        tmp___15 = pthread_getspecific(PL_thr_key);
#line 437
        tmp___16 = Perl_sv_2iv_flags((PerlInterpreter *)tmp___15, (SV */* const  */)(*(((PerlInterpreter *)tmp___14)->Istack_base + ax))->sv_u.svu_rv,
                                     (I32 const   )2);
#line 437
        tmp___17 = tmp___16;
        }
      }
#line 437
      tmp___11 = tmp___17;
#line 438
      obj = (pingobj_t *)tmp___11;
    } else {
      {
#line 441
      tmp___19 = pthread_getspecific(PL_thr_key);
#line 441
      Perl_croak((PerlInterpreter *)tmp___19, "%s: %s is not of type %s", "Net::Oping::_ping_send",
                 "obj", "pingobj_tPtr");
      }
    }
  } else {
    {
#line 441
    tmp___19 = pthread_getspecific(PL_thr_key);
#line 441
    Perl_croak((PerlInterpreter *)tmp___19, "%s: %s is not of type %s", "Net::Oping::_ping_send",
               "obj", "pingobj_tPtr");
    }
  }
  {
#line 117 "Oping.xs"
  RETVAL = ping_send(obj);
#line 448 "Oping.c"
  tmp___24 = pthread_getspecific(PL_thr_key);
#line 448
  sp = (((PerlInterpreter *)tmp___24)->Istack_base + ax) - 1;
#line 448
  tmp___25 = pthread_getspecific(PL_thr_key);
#line 448
  Perl_sv_setiv((PerlInterpreter *)tmp___25, (SV */* const  */)targ, (IV const   )((IV )RETVAL));
  }
#line 448
  if (targ->sv_flags & 4194304U) {
    {
#line 448
    tmp___26 = pthread_getspecific(PL_thr_key);
#line 448
    Perl_mg_set((PerlInterpreter *)tmp___26, targ);
    }
  }
  {
#line 448
  sp ++;
#line 448
  *sp = targ;
#line 450
  tmpXSoff = (IV )1;
#line 450
  tmp___27 = pthread_getspecific(PL_thr_key);
#line 450
  tmp___28 = pthread_getspecific(PL_thr_key);
#line 450
  ((PerlInterpreter *)tmp___27)->Istack_sp = (((PerlInterpreter *)tmp___28)->Istack_base + ax) + (tmpXSoff - 1L);
  }
#line 450
  return;
}
}
#line 454
static void XS_Net__Oping__ping_iterator_get(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                             CV *cv  __attribute__((__unused__)) ) ;
#line 455 "Oping.c"
static void XS_Net__Oping__ping_iterator_get(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                             CV *cv  __attribute__((__unused__)) ) 
{ 
  SV **sp ;
  void *tmp ;
  I32 ax ;
  void *tmp___0 ;
  I32 *tmp___1 ;
  SV **mark ;
  void *tmp___2 ;
  I32 tmp___3 ;
  I32 items ;
  pingobj_t *obj ;
  pingobj_iter_t *RETVAL ;
  IV tmp___4 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  IV tmp___9 ;
  IV tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  _Bool tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  IV tmpXSoff ;
  void *tmp___21 ;
  void *tmp___22 ;

  {
  {
#line 457
  tmp = pthread_getspecific(PL_thr_key);
#line 457
  sp = ((PerlInterpreter *)tmp)->Istack_sp;
#line 457
  tmp___0 = pthread_getspecific(PL_thr_key);
#line 457
  tmp___1 = ((PerlInterpreter *)tmp___0)->Imarkstack_ptr;
#line 457
  (((PerlInterpreter *)tmp___0)->Imarkstack_ptr) --;
#line 457
  ax = *tmp___1;
#line 457
  tmp___2 = pthread_getspecific(PL_thr_key);
#line 457
  tmp___3 = ax;
#line 457
  ax ++;
#line 457
  mark = ((PerlInterpreter *)tmp___2)->Istack_base + tmp___3;
#line 457
  items = (I32 )(sp - mark);
  }
#line 458
  if (items != 1) {
    {
#line 459
    Perl_croak_xs_usage((CV const   */* const  */)cv, (char const   */* const  */)"obj");
    }
  }
  {
#line 464
  tmp___13 = pthread_getspecific(PL_thr_key);
  }
#line 464
  if ((*(((PerlInterpreter *)tmp___13)->Istack_base + ax))->sv_flags & 2048U) {
    {
#line 464
    tmp___14 = pthread_getspecific(PL_thr_key);
#line 464
    tmp___15 = pthread_getspecific(PL_thr_key);
#line 464
    tmp___16 = Perl_sv_derived_from((PerlInterpreter *)tmp___15, *(((PerlInterpreter *)tmp___14)->Istack_base + ax),
                                    (char const   */* const  */)"pingobj_tPtr");
    }
#line 464
    if (tmp___16) {
      {
#line 465
      tmp___11 = pthread_getspecific(PL_thr_key);
      }
#line 465
      if ((((*(((PerlInterpreter *)tmp___11)->Istack_base + ax))->sv_u.svu_rv)->sv_flags & 2097408U) == 256U) {
        {
#line 465
        tmp___6 = pthread_getspecific(PL_thr_key);
#line 465
        tmp___10 = ((XPVIV *)((*(((PerlInterpreter *)tmp___6)->Istack_base + ax))->sv_u.svu_rv)->sv_any)->xiv_u.xivu_iv;
        }
      } else {
        {
#line 465
        tmp___7 = pthread_getspecific(PL_thr_key);
#line 465
        tmp___8 = pthread_getspecific(PL_thr_key);
#line 465
        tmp___9 = Perl_sv_2iv_flags((PerlInterpreter *)tmp___8, (SV */* const  */)(*(((PerlInterpreter *)tmp___7)->Istack_base + ax))->sv_u.svu_rv,
                                    (I32 const   )2);
#line 465
        tmp___10 = tmp___9;
        }
      }
#line 465
      tmp___4 = tmp___10;
#line 466
      obj = (pingobj_t *)tmp___4;
    } else {
      {
#line 469
      tmp___12 = pthread_getspecific(PL_thr_key);
#line 469
      Perl_croak((PerlInterpreter *)tmp___12, "%s: %s is not of type %s", "Net::Oping::_ping_iterator_get",
                 "obj", "pingobj_tPtr");
      }
    }
  } else {
    {
#line 469
    tmp___12 = pthread_getspecific(PL_thr_key);
#line 469
    Perl_croak((PerlInterpreter *)tmp___12, "%s: %s is not of type %s", "Net::Oping::_ping_iterator_get",
               "obj", "pingobj_tPtr");
    }
  }
  {
#line 125 "Oping.xs"
  RETVAL = ping_iterator_get(obj);
#line 476 "Oping.c"
  tmp___17 = pthread_getspecific(PL_thr_key);
#line 476
  tmp___18 = pthread_getspecific(PL_thr_key);
#line 476
  *(((PerlInterpreter *)tmp___17)->Istack_base + ax) = Perl_sv_newmortal((PerlInterpreter *)tmp___18);
#line 477
  tmp___19 = pthread_getspecific(PL_thr_key);
#line 477
  tmp___20 = pthread_getspecific(PL_thr_key);
#line 477
  Perl_sv_setref_pv((PerlInterpreter *)tmp___20, (SV */* const  */)*(((PerlInterpreter *)tmp___19)->Istack_base + ax),
                    (char const   */* const  */)"pingobj_iter_tPtr", (void */* const  */)((void *)RETVAL));
#line 479
  tmpXSoff = (IV )1;
#line 479
  tmp___21 = pthread_getspecific(PL_thr_key);
#line 479
  tmp___22 = pthread_getspecific(PL_thr_key);
#line 479
  ((PerlInterpreter *)tmp___21)->Istack_sp = (((PerlInterpreter *)tmp___22)->Istack_base + ax) + (tmpXSoff - 1L);
  }
#line 479
  return;
}
}
#line 483
static void XS_Net__Oping__ping_iterator_next(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                              CV *cv  __attribute__((__unused__)) ) ;
#line 484 "Oping.c"
static void XS_Net__Oping__ping_iterator_next(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                              CV *cv  __attribute__((__unused__)) ) 
{ 
  SV **sp ;
  void *tmp ;
  I32 ax ;
  void *tmp___0 ;
  I32 *tmp___1 ;
  SV **mark ;
  void *tmp___2 ;
  I32 tmp___3 ;
  I32 items ;
  pingobj_iter_t *iter ;
  pingobj_iter_t *RETVAL ;
  IV tmp___4 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  IV tmp___9 ;
  IV tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  _Bool tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  IV tmpXSoff ;
  void *tmp___21 ;
  void *tmp___22 ;

  {
  {
#line 486
  tmp = pthread_getspecific(PL_thr_key);
#line 486
  sp = ((PerlInterpreter *)tmp)->Istack_sp;
#line 486
  tmp___0 = pthread_getspecific(PL_thr_key);
#line 486
  tmp___1 = ((PerlInterpreter *)tmp___0)->Imarkstack_ptr;
#line 486
  (((PerlInterpreter *)tmp___0)->Imarkstack_ptr) --;
#line 486
  ax = *tmp___1;
#line 486
  tmp___2 = pthread_getspecific(PL_thr_key);
#line 486
  tmp___3 = ax;
#line 486
  ax ++;
#line 486
  mark = ((PerlInterpreter *)tmp___2)->Istack_base + tmp___3;
#line 486
  items = (I32 )(sp - mark);
  }
#line 487
  if (items != 1) {
    {
#line 488
    Perl_croak_xs_usage((CV const   */* const  */)cv, (char const   */* const  */)"iter");
    }
  }
  {
#line 493
  tmp___13 = pthread_getspecific(PL_thr_key);
  }
#line 493
  if ((*(((PerlInterpreter *)tmp___13)->Istack_base + ax))->sv_flags & 2048U) {
    {
#line 493
    tmp___14 = pthread_getspecific(PL_thr_key);
#line 493
    tmp___15 = pthread_getspecific(PL_thr_key);
#line 493
    tmp___16 = Perl_sv_derived_from((PerlInterpreter *)tmp___15, *(((PerlInterpreter *)tmp___14)->Istack_base + ax),
                                    (char const   */* const  */)"pingobj_iter_tPtr");
    }
#line 493
    if (tmp___16) {
      {
#line 494
      tmp___11 = pthread_getspecific(PL_thr_key);
      }
#line 494
      if ((((*(((PerlInterpreter *)tmp___11)->Istack_base + ax))->sv_u.svu_rv)->sv_flags & 2097408U) == 256U) {
        {
#line 494
        tmp___6 = pthread_getspecific(PL_thr_key);
#line 494
        tmp___10 = ((XPVIV *)((*(((PerlInterpreter *)tmp___6)->Istack_base + ax))->sv_u.svu_rv)->sv_any)->xiv_u.xivu_iv;
        }
      } else {
        {
#line 494
        tmp___7 = pthread_getspecific(PL_thr_key);
#line 494
        tmp___8 = pthread_getspecific(PL_thr_key);
#line 494
        tmp___9 = Perl_sv_2iv_flags((PerlInterpreter *)tmp___8, (SV */* const  */)(*(((PerlInterpreter *)tmp___7)->Istack_base + ax))->sv_u.svu_rv,
                                    (I32 const   )2);
#line 494
        tmp___10 = tmp___9;
        }
      }
#line 494
      tmp___4 = tmp___10;
#line 495
      iter = (pingobj_iter_t *)tmp___4;
    } else {
      {
#line 498
      tmp___12 = pthread_getspecific(PL_thr_key);
#line 498
      Perl_croak((PerlInterpreter *)tmp___12, "%s: %s is not of type %s", "Net::Oping::_ping_iterator_next",
                 "iter", "pingobj_iter_tPtr");
      }
    }
  } else {
    {
#line 498
    tmp___12 = pthread_getspecific(PL_thr_key);
#line 498
    Perl_croak((PerlInterpreter *)tmp___12, "%s: %s is not of type %s", "Net::Oping::_ping_iterator_next",
               "iter", "pingobj_iter_tPtr");
    }
  }
  {
#line 133 "Oping.xs"
  RETVAL = ping_iterator_next(iter);
#line 505 "Oping.c"
  tmp___17 = pthread_getspecific(PL_thr_key);
#line 505
  tmp___18 = pthread_getspecific(PL_thr_key);
#line 505
  *(((PerlInterpreter *)tmp___17)->Istack_base + ax) = Perl_sv_newmortal((PerlInterpreter *)tmp___18);
#line 506
  tmp___19 = pthread_getspecific(PL_thr_key);
#line 506
  tmp___20 = pthread_getspecific(PL_thr_key);
#line 506
  Perl_sv_setref_pv((PerlInterpreter *)tmp___20, (SV */* const  */)*(((PerlInterpreter *)tmp___19)->Istack_base + ax),
                    (char const   */* const  */)"pingobj_iter_tPtr", (void */* const  */)((void *)RETVAL));
#line 508
  tmpXSoff = (IV )1;
#line 508
  tmp___21 = pthread_getspecific(PL_thr_key);
#line 508
  tmp___22 = pthread_getspecific(PL_thr_key);
#line 508
  ((PerlInterpreter *)tmp___21)->Istack_sp = (((PerlInterpreter *)tmp___22)->Istack_base + ax) + (tmpXSoff - 1L);
  }
#line 508
  return;
}
}
#line 512
static void XS_Net__Oping__ping_iterator_get_latency(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                                     CV *cv  __attribute__((__unused__)) ) ;
#line 513 "Oping.c"
static void XS_Net__Oping__ping_iterator_get_latency(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                                     CV *cv  __attribute__((__unused__)) ) 
{ 
  SV **sp ;
  void *tmp ;
  I32 ax ;
  void *tmp___0 ;
  I32 *tmp___1 ;
  SV **mark ;
  void *tmp___2 ;
  I32 tmp___3 ;
  I32 items ;
  pingobj_iter_t *iter ;
  double RETVAL ;
  SV *targ ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  SV *tmp___8 ;
  SV *tmp___9 ;
  void *tmp___10 ;
  IV tmp___11 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  IV tmp___16 ;
  IV tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  _Bool tmp___23 ;
  double tmp___24 ;
  size_t tmp_size ;
  int status ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  IV tmpXSoff ;
  void *tmp___28 ;
  void *tmp___29 ;

  {
  {
#line 515
  tmp = pthread_getspecific(PL_thr_key);
#line 515
  sp = ((PerlInterpreter *)tmp)->Istack_sp;
#line 515
  tmp___0 = pthread_getspecific(PL_thr_key);
#line 515
  tmp___1 = ((PerlInterpreter *)tmp___0)->Imarkstack_ptr;
#line 515
  (((PerlInterpreter *)tmp___0)->Imarkstack_ptr) --;
#line 515
  ax = *tmp___1;
#line 515
  tmp___2 = pthread_getspecific(PL_thr_key);
#line 515
  tmp___3 = ax;
#line 515
  ax ++;
#line 515
  mark = ((PerlInterpreter *)tmp___2)->Istack_base + tmp___3;
#line 515
  items = (I32 )(sp - mark);
  }
#line 516
  if (items != 1) {
    {
#line 517
    Perl_croak_xs_usage((CV const   */* const  */)cv, (char const   */* const  */)"iter");
    }
  }
  {
#line 521
  tmp___10 = pthread_getspecific(PL_thr_key);
  }
#line 521
  if ((int )(((PerlInterpreter *)tmp___10)->Iop)->op_private & 4) {
    {
#line 521
    tmp___5 = pthread_getspecific(PL_thr_key);
#line 521
    tmp___6 = pthread_getspecific(PL_thr_key);
#line 521
    tmp___9 = *(((PerlInterpreter *)tmp___5)->Icurpad + (((PerlInterpreter *)tmp___6)->Iop)->op_targ);
    }
  } else {
    {
#line 521
    tmp___7 = pthread_getspecific(PL_thr_key);
#line 521
    tmp___8 = Perl_sv_newmortal((PerlInterpreter *)tmp___7);
#line 521
    tmp___9 = tmp___8;
    }
  }
  {
#line 521
  targ = tmp___9;
#line 523
  tmp___20 = pthread_getspecific(PL_thr_key);
  }
#line 523
  if ((*(((PerlInterpreter *)tmp___20)->Istack_base + ax))->sv_flags & 2048U) {
    {
#line 523
    tmp___21 = pthread_getspecific(PL_thr_key);
#line 523
    tmp___22 = pthread_getspecific(PL_thr_key);
#line 523
    tmp___23 = Perl_sv_derived_from((PerlInterpreter *)tmp___22, *(((PerlInterpreter *)tmp___21)->Istack_base + ax),
                                    (char const   */* const  */)"pingobj_iter_tPtr");
    }
#line 523
    if (tmp___23) {
      {
#line 524
      tmp___18 = pthread_getspecific(PL_thr_key);
      }
#line 524
      if ((((*(((PerlInterpreter *)tmp___18)->Istack_base + ax))->sv_u.svu_rv)->sv_flags & 2097408U) == 256U) {
        {
#line 524
        tmp___13 = pthread_getspecific(PL_thr_key);
#line 524
        tmp___17 = ((XPVIV *)((*(((PerlInterpreter *)tmp___13)->Istack_base + ax))->sv_u.svu_rv)->sv_any)->xiv_u.xivu_iv;
        }
      } else {
        {
#line 524
        tmp___14 = pthread_getspecific(PL_thr_key);
#line 524
        tmp___15 = pthread_getspecific(PL_thr_key);
#line 524
        tmp___16 = Perl_sv_2iv_flags((PerlInterpreter *)tmp___15, (SV */* const  */)(*(((PerlInterpreter *)tmp___14)->Istack_base + ax))->sv_u.svu_rv,
                                     (I32 const   )2);
#line 524
        tmp___17 = tmp___16;
        }
      }
#line 524
      tmp___11 = tmp___17;
#line 525
      iter = (pingobj_iter_t *)tmp___11;
    } else {
      {
#line 528
      tmp___19 = pthread_getspecific(PL_thr_key);
#line 528
      Perl_croak((PerlInterpreter *)tmp___19, "%s: %s is not of type %s", "Net::Oping::_ping_iterator_get_latency",
                 "iter", "pingobj_iter_tPtr");
      }
    }
  } else {
    {
#line 528
    tmp___19 = pthread_getspecific(PL_thr_key);
#line 528
    Perl_croak((PerlInterpreter *)tmp___19, "%s: %s is not of type %s", "Net::Oping::_ping_iterator_get_latency",
               "iter", "pingobj_iter_tPtr");
    }
  }
  {
#line 145 "Oping.xs"
  RETVAL = - 1.0;
#line 147
  tmp_size = sizeof(tmp___24);
#line 148
  status = ping_iterator_get_info(iter, 4, (void *)(& tmp___24), & tmp_size);
  }
#line 150
  if (status == 0) {
#line 151
    RETVAL = tmp___24;
  }
  {
#line 545 "Oping.c"
  tmp___25 = pthread_getspecific(PL_thr_key);
#line 545
  sp = (((PerlInterpreter *)tmp___25)->Istack_base + ax) - 1;
#line 545
  tmp___26 = pthread_getspecific(PL_thr_key);
#line 545
  Perl_sv_setnv((PerlInterpreter *)tmp___26, (SV */* const  */)targ, (NV const   )RETVAL);
  }
#line 545
  if (targ->sv_flags & 4194304U) {
    {
#line 545
    tmp___27 = pthread_getspecific(PL_thr_key);
#line 545
    Perl_mg_set((PerlInterpreter *)tmp___27, targ);
    }
  }
  {
#line 545
  sp ++;
#line 545
  *sp = targ;
#line 547
  tmpXSoff = (IV )1;
#line 547
  tmp___28 = pthread_getspecific(PL_thr_key);
#line 547
  tmp___29 = pthread_getspecific(PL_thr_key);
#line 547
  ((PerlInterpreter *)tmp___28)->Istack_sp = (((PerlInterpreter *)tmp___29)->Istack_base + ax) + (tmpXSoff - 1L);
  }
#line 547
  return;
}
}
#line 551
static void XS_Net__Oping__ping_iterator_get_hostname(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                                      CV *cv  __attribute__((__unused__)) ) ;
#line 552 "Oping.c"
static void XS_Net__Oping__ping_iterator_get_hostname(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                                      CV *cv  __attribute__((__unused__)) ) 
{ 
  SV **sp ;
  void *tmp ;
  I32 ax ;
  void *tmp___0 ;
  I32 *tmp___1 ;
  SV **mark ;
  void *tmp___2 ;
  I32 tmp___3 ;
  I32 items ;
  pingobj_iter_t *iter ;
  IV tmp___4 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  IV tmp___9 ;
  IV tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  _Bool tmp___16 ;
  char *buffer ;
  size_t buffer_size ;
  int status ;
  void *tmp___17 ;
  void *tmp___18 ;
  long tmp___19 ;
  void *tmp___20 ;
  int tmp___21 ;
  size_t tmp___22 ;
  void *tmp___23 ;
  SV *tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;

  {
  {
#line 554
  tmp = pthread_getspecific(PL_thr_key);
#line 554
  sp = ((PerlInterpreter *)tmp)->Istack_sp;
#line 554
  tmp___0 = pthread_getspecific(PL_thr_key);
#line 554
  tmp___1 = ((PerlInterpreter *)tmp___0)->Imarkstack_ptr;
#line 554
  (((PerlInterpreter *)tmp___0)->Imarkstack_ptr) --;
#line 554
  ax = *tmp___1;
#line 554
  tmp___2 = pthread_getspecific(PL_thr_key);
#line 554
  tmp___3 = ax;
#line 554
  ax ++;
#line 554
  mark = ((PerlInterpreter *)tmp___2)->Istack_base + tmp___3;
#line 554
  items = (I32 )(sp - mark);
  }
#line 555
  if (items != 1) {
    {
#line 556
    Perl_croak_xs_usage((CV const   */* const  */)cv, (char const   */* const  */)"iter");
    }
  }
  {
#line 558
  sp -= items;
#line 562
  tmp___13 = pthread_getspecific(PL_thr_key);
  }
#line 562
  if ((*(((PerlInterpreter *)tmp___13)->Istack_base + ax))->sv_flags & 2048U) {
    {
#line 562
    tmp___14 = pthread_getspecific(PL_thr_key);
#line 562
    tmp___15 = pthread_getspecific(PL_thr_key);
#line 562
    tmp___16 = Perl_sv_derived_from((PerlInterpreter *)tmp___15, *(((PerlInterpreter *)tmp___14)->Istack_base + ax),
                                    (char const   */* const  */)"pingobj_iter_tPtr");
    }
#line 562
    if (tmp___16) {
      {
#line 563
      tmp___11 = pthread_getspecific(PL_thr_key);
      }
#line 563
      if ((((*(((PerlInterpreter *)tmp___11)->Istack_base + ax))->sv_u.svu_rv)->sv_flags & 2097408U) == 256U) {
        {
#line 563
        tmp___6 = pthread_getspecific(PL_thr_key);
#line 563
        tmp___10 = ((XPVIV *)((*(((PerlInterpreter *)tmp___6)->Istack_base + ax))->sv_u.svu_rv)->sv_any)->xiv_u.xivu_iv;
        }
      } else {
        {
#line 563
        tmp___7 = pthread_getspecific(PL_thr_key);
#line 563
        tmp___8 = pthread_getspecific(PL_thr_key);
#line 563
        tmp___9 = Perl_sv_2iv_flags((PerlInterpreter *)tmp___8, (SV */* const  */)(*(((PerlInterpreter *)tmp___7)->Istack_base + ax))->sv_u.svu_rv,
                                    (I32 const   )2);
#line 563
        tmp___10 = tmp___9;
        }
      }
#line 563
      tmp___4 = tmp___10;
#line 564
      iter = (pingobj_iter_t *)tmp___4;
    } else {
      {
#line 567
      tmp___12 = pthread_getspecific(PL_thr_key);
#line 567
      Perl_croak((PerlInterpreter *)tmp___12, "%s: %s is not of type %s", "Net::Oping::_ping_iterator_get_hostname",
                 "iter", "pingobj_iter_tPtr");
      }
    }
  } else {
    {
#line 567
    tmp___12 = pthread_getspecific(PL_thr_key);
#line 567
    Perl_croak((PerlInterpreter *)tmp___12, "%s: %s is not of type %s", "Net::Oping::_ping_iterator_get_hostname",
               "iter", "pingobj_iter_tPtr");
    }
  }
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 164 "Oping.xs"
    buffer = (char *)((void *)0);
#line 165
    buffer_size = (size_t )0;
#line 166
    status = ping_iterator_get_info(iter, 1, (void *)buffer, & buffer_size);
    }
#line 168
    if (status != 12) {
#line 169
      goto while_break;
    }
    {
#line 175
    tmp___17 = malloc(buffer_size);
#line 175
    buffer = (char *)tmp___17;
    }
#line 176
    if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 177
      goto while_break;
    }
    {
#line 179
    status = ping_iterator_get_info(iter, 1, (void *)buffer, & buffer_size);
    }
#line 181
    if (status != 0) {
      {
#line 183
      free((void *)buffer);
      }
#line 184
      goto while_break;
    }
    {
#line 186
    *(buffer + (buffer_size - 1UL)) = (char)0;
#line 188
    tmp___18 = pthread_getspecific(PL_thr_key);
#line 188
    tmp___19 = __builtin_expect((long )(((PerlInterpreter *)tmp___18)->Istack_max - sp < 1L),
                                0L);
    }
#line 188
    if (tmp___19) {
      {
#line 188
      tmp___20 = pthread_getspecific(PL_thr_key);
#line 188
      sp = Perl_stack_grow((PerlInterpreter *)tmp___20, sp, sp, 1);
      }
#line 188
      if (sp) {
#line 188
        tmp___21 = 1;
      } else {
#line 188
        tmp___21 = 0;
      }
    } else {
#line 188
      tmp___21 = 0;
    }
    {
#line 188
    sp ++;
#line 188
    tmp___22 = strlen((char const   *)buffer);
#line 188
    tmp___23 = pthread_getspecific(PL_thr_key);
#line 188
    tmp___24 = Perl_newSVpvn((PerlInterpreter *)tmp___23, (char const   */* const  */)buffer,
                             (STRLEN const   )tmp___22);
#line 188
    tmp___25 = pthread_getspecific(PL_thr_key);
#line 188
    *sp = Perl_sv_2mortal((PerlInterpreter *)tmp___25, (SV */* const  */)tmp___24);
#line 189
    free((void *)buffer);
    }
#line 163
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 605 "Oping.c"
  tmp___26 = pthread_getspecific(PL_thr_key);
#line 605
  ((PerlInterpreter *)tmp___26)->Istack_sp = sp;
  }
#line 606
  return;
}
}
#line 611
static void XS_Net__Oping__ping_iterator_get_dropped(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                                     CV *cv  __attribute__((__unused__)) ) ;
#line 612 "Oping.c"
static void XS_Net__Oping__ping_iterator_get_dropped(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                                     CV *cv  __attribute__((__unused__)) ) 
{ 
  SV **sp ;
  void *tmp ;
  I32 ax ;
  void *tmp___0 ;
  I32 *tmp___1 ;
  SV **mark ;
  void *tmp___2 ;
  I32 tmp___3 ;
  I32 items ;
  pingobj_iter_t *iter ;
  int RETVAL ;
  SV *targ ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  SV *tmp___8 ;
  SV *tmp___9 ;
  void *tmp___10 ;
  IV tmp___11 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  IV tmp___16 ;
  IV tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  _Bool tmp___23 ;
  uint32_t tmp___24 ;
  size_t tmp_size ;
  int status ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  IV tmpXSoff ;
  void *tmp___28 ;
  void *tmp___29 ;

  {
  {
#line 614
  tmp = pthread_getspecific(PL_thr_key);
#line 614
  sp = ((PerlInterpreter *)tmp)->Istack_sp;
#line 614
  tmp___0 = pthread_getspecific(PL_thr_key);
#line 614
  tmp___1 = ((PerlInterpreter *)tmp___0)->Imarkstack_ptr;
#line 614
  (((PerlInterpreter *)tmp___0)->Imarkstack_ptr) --;
#line 614
  ax = *tmp___1;
#line 614
  tmp___2 = pthread_getspecific(PL_thr_key);
#line 614
  tmp___3 = ax;
#line 614
  ax ++;
#line 614
  mark = ((PerlInterpreter *)tmp___2)->Istack_base + tmp___3;
#line 614
  items = (I32 )(sp - mark);
  }
#line 615
  if (items != 1) {
    {
#line 616
    Perl_croak_xs_usage((CV const   */* const  */)cv, (char const   */* const  */)"iter");
    }
  }
  {
#line 620
  tmp___10 = pthread_getspecific(PL_thr_key);
  }
#line 620
  if ((int )(((PerlInterpreter *)tmp___10)->Iop)->op_private & 4) {
    {
#line 620
    tmp___5 = pthread_getspecific(PL_thr_key);
#line 620
    tmp___6 = pthread_getspecific(PL_thr_key);
#line 620
    tmp___9 = *(((PerlInterpreter *)tmp___5)->Icurpad + (((PerlInterpreter *)tmp___6)->Iop)->op_targ);
    }
  } else {
    {
#line 620
    tmp___7 = pthread_getspecific(PL_thr_key);
#line 620
    tmp___8 = Perl_sv_newmortal((PerlInterpreter *)tmp___7);
#line 620
    tmp___9 = tmp___8;
    }
  }
  {
#line 620
  targ = tmp___9;
#line 622
  tmp___20 = pthread_getspecific(PL_thr_key);
  }
#line 622
  if ((*(((PerlInterpreter *)tmp___20)->Istack_base + ax))->sv_flags & 2048U) {
    {
#line 622
    tmp___21 = pthread_getspecific(PL_thr_key);
#line 622
    tmp___22 = pthread_getspecific(PL_thr_key);
#line 622
    tmp___23 = Perl_sv_derived_from((PerlInterpreter *)tmp___22, *(((PerlInterpreter *)tmp___21)->Istack_base + ax),
                                    (char const   */* const  */)"pingobj_iter_tPtr");
    }
#line 622
    if (tmp___23) {
      {
#line 623
      tmp___18 = pthread_getspecific(PL_thr_key);
      }
#line 623
      if ((((*(((PerlInterpreter *)tmp___18)->Istack_base + ax))->sv_u.svu_rv)->sv_flags & 2097408U) == 256U) {
        {
#line 623
        tmp___13 = pthread_getspecific(PL_thr_key);
#line 623
        tmp___17 = ((XPVIV *)((*(((PerlInterpreter *)tmp___13)->Istack_base + ax))->sv_u.svu_rv)->sv_any)->xiv_u.xivu_iv;
        }
      } else {
        {
#line 623
        tmp___14 = pthread_getspecific(PL_thr_key);
#line 623
        tmp___15 = pthread_getspecific(PL_thr_key);
#line 623
        tmp___16 = Perl_sv_2iv_flags((PerlInterpreter *)tmp___15, (SV */* const  */)(*(((PerlInterpreter *)tmp___14)->Istack_base + ax))->sv_u.svu_rv,
                                     (I32 const   )2);
#line 623
        tmp___17 = tmp___16;
        }
      }
#line 623
      tmp___11 = tmp___17;
#line 624
      iter = (pingobj_iter_t *)tmp___11;
    } else {
      {
#line 627
      tmp___19 = pthread_getspecific(PL_thr_key);
#line 627
      Perl_croak((PerlInterpreter *)tmp___19, "%s: %s is not of type %s", "Net::Oping::_ping_iterator_get_dropped",
                 "iter", "pingobj_iter_tPtr");
      }
    }
  } else {
    {
#line 627
    tmp___19 = pthread_getspecific(PL_thr_key);
#line 627
    Perl_croak((PerlInterpreter *)tmp___19, "%s: %s is not of type %s", "Net::Oping::_ping_iterator_get_dropped",
               "iter", "pingobj_iter_tPtr");
    }
  }
  {
#line 201 "Oping.xs"
  RETVAL = -1;
#line 203
  tmp_size = sizeof(tmp___24);
#line 204
  status = ping_iterator_get_info(iter, 9, (void *)(& tmp___24), & tmp_size);
  }
#line 206
  if (status == 0) {
#line 207
    RETVAL = (int )tmp___24;
  }
  {
#line 648 "Oping.c"
  tmp___25 = pthread_getspecific(PL_thr_key);
#line 648
  sp = (((PerlInterpreter *)tmp___25)->Istack_base + ax) - 1;
#line 648
  tmp___26 = pthread_getspecific(PL_thr_key);
#line 648
  Perl_sv_setiv((PerlInterpreter *)tmp___26, (SV */* const  */)targ, (IV const   )((IV )RETVAL));
  }
#line 648
  if (targ->sv_flags & 4194304U) {
    {
#line 648
    tmp___27 = pthread_getspecific(PL_thr_key);
#line 648
    Perl_mg_set((PerlInterpreter *)tmp___27, targ);
    }
  }
  {
#line 648
  sp ++;
#line 648
  *sp = targ;
#line 650
  tmpXSoff = (IV )1;
#line 650
  tmp___28 = pthread_getspecific(PL_thr_key);
#line 650
  tmp___29 = pthread_getspecific(PL_thr_key);
#line 650
  ((PerlInterpreter *)tmp___28)->Istack_sp = (((PerlInterpreter *)tmp___29)->Istack_base + ax) + (tmpXSoff - 1L);
  }
#line 650
  return;
}
}
#line 654
static void XS_Net__Oping__ping_iterator_get_recv_ttl(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                                      CV *cv  __attribute__((__unused__)) ) ;
#line 655 "Oping.c"
static void XS_Net__Oping__ping_iterator_get_recv_ttl(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                                      CV *cv  __attribute__((__unused__)) ) 
{ 
  SV **sp ;
  void *tmp ;
  I32 ax ;
  void *tmp___0 ;
  I32 *tmp___1 ;
  SV **mark ;
  void *tmp___2 ;
  I32 tmp___3 ;
  I32 items ;
  pingobj_iter_t *iter ;
  int RETVAL ;
  SV *targ ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  SV *tmp___8 ;
  SV *tmp___9 ;
  void *tmp___10 ;
  IV tmp___11 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  IV tmp___16 ;
  IV tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  _Bool tmp___23 ;
  int tmp___24 ;
  size_t tmp_size ;
  int status ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  IV tmpXSoff ;
  void *tmp___28 ;
  void *tmp___29 ;

  {
  {
#line 657
  tmp = pthread_getspecific(PL_thr_key);
#line 657
  sp = ((PerlInterpreter *)tmp)->Istack_sp;
#line 657
  tmp___0 = pthread_getspecific(PL_thr_key);
#line 657
  tmp___1 = ((PerlInterpreter *)tmp___0)->Imarkstack_ptr;
#line 657
  (((PerlInterpreter *)tmp___0)->Imarkstack_ptr) --;
#line 657
  ax = *tmp___1;
#line 657
  tmp___2 = pthread_getspecific(PL_thr_key);
#line 657
  tmp___3 = ax;
#line 657
  ax ++;
#line 657
  mark = ((PerlInterpreter *)tmp___2)->Istack_base + tmp___3;
#line 657
  items = (I32 )(sp - mark);
  }
#line 658
  if (items != 1) {
    {
#line 659
    Perl_croak_xs_usage((CV const   */* const  */)cv, (char const   */* const  */)"iter");
    }
  }
  {
#line 663
  tmp___10 = pthread_getspecific(PL_thr_key);
  }
#line 663
  if ((int )(((PerlInterpreter *)tmp___10)->Iop)->op_private & 4) {
    {
#line 663
    tmp___5 = pthread_getspecific(PL_thr_key);
#line 663
    tmp___6 = pthread_getspecific(PL_thr_key);
#line 663
    tmp___9 = *(((PerlInterpreter *)tmp___5)->Icurpad + (((PerlInterpreter *)tmp___6)->Iop)->op_targ);
    }
  } else {
    {
#line 663
    tmp___7 = pthread_getspecific(PL_thr_key);
#line 663
    tmp___8 = Perl_sv_newmortal((PerlInterpreter *)tmp___7);
#line 663
    tmp___9 = tmp___8;
    }
  }
  {
#line 663
  targ = tmp___9;
#line 665
  tmp___20 = pthread_getspecific(PL_thr_key);
  }
#line 665
  if ((*(((PerlInterpreter *)tmp___20)->Istack_base + ax))->sv_flags & 2048U) {
    {
#line 665
    tmp___21 = pthread_getspecific(PL_thr_key);
#line 665
    tmp___22 = pthread_getspecific(PL_thr_key);
#line 665
    tmp___23 = Perl_sv_derived_from((PerlInterpreter *)tmp___22, *(((PerlInterpreter *)tmp___21)->Istack_base + ax),
                                    (char const   */* const  */)"pingobj_iter_tPtr");
    }
#line 665
    if (tmp___23) {
      {
#line 666
      tmp___18 = pthread_getspecific(PL_thr_key);
      }
#line 666
      if ((((*(((PerlInterpreter *)tmp___18)->Istack_base + ax))->sv_u.svu_rv)->sv_flags & 2097408U) == 256U) {
        {
#line 666
        tmp___13 = pthread_getspecific(PL_thr_key);
#line 666
        tmp___17 = ((XPVIV *)((*(((PerlInterpreter *)tmp___13)->Istack_base + ax))->sv_u.svu_rv)->sv_any)->xiv_u.xivu_iv;
        }
      } else {
        {
#line 666
        tmp___14 = pthread_getspecific(PL_thr_key);
#line 666
        tmp___15 = pthread_getspecific(PL_thr_key);
#line 666
        tmp___16 = Perl_sv_2iv_flags((PerlInterpreter *)tmp___15, (SV */* const  */)(*(((PerlInterpreter *)tmp___14)->Istack_base + ax))->sv_u.svu_rv,
                                     (I32 const   )2);
#line 666
        tmp___17 = tmp___16;
        }
      }
#line 666
      tmp___11 = tmp___17;
#line 667
      iter = (pingobj_iter_t *)tmp___11;
    } else {
      {
#line 670
      tmp___19 = pthread_getspecific(PL_thr_key);
#line 670
      Perl_croak((PerlInterpreter *)tmp___19, "%s: %s is not of type %s", "Net::Oping::_ping_iterator_get_recv_ttl",
                 "iter", "pingobj_iter_tPtr");
      }
    }
  } else {
    {
#line 670
    tmp___19 = pthread_getspecific(PL_thr_key);
#line 670
    Perl_croak((PerlInterpreter *)tmp___19, "%s: %s is not of type %s", "Net::Oping::_ping_iterator_get_recv_ttl",
               "iter", "pingobj_iter_tPtr");
    }
  }
  {
#line 223 "Oping.xs"
  RETVAL = -1;
#line 225
  tmp_size = sizeof(tmp___24);
#line 226
  status = ping_iterator_get_info(iter, 10, (void *)(& tmp___24), & tmp_size);
  }
#line 228
  if (status == 0) {
#line 229
    RETVAL = tmp___24;
  }
  {
#line 691 "Oping.c"
  tmp___25 = pthread_getspecific(PL_thr_key);
#line 691
  sp = (((PerlInterpreter *)tmp___25)->Istack_base + ax) - 1;
#line 691
  tmp___26 = pthread_getspecific(PL_thr_key);
#line 691
  Perl_sv_setiv((PerlInterpreter *)tmp___26, (SV */* const  */)targ, (IV const   )((IV )RETVAL));
  }
#line 691
  if (targ->sv_flags & 4194304U) {
    {
#line 691
    tmp___27 = pthread_getspecific(PL_thr_key);
#line 691
    Perl_mg_set((PerlInterpreter *)tmp___27, targ);
    }
  }
  {
#line 691
  sp ++;
#line 691
  *sp = targ;
#line 693
  tmpXSoff = (IV )1;
#line 693
  tmp___28 = pthread_getspecific(PL_thr_key);
#line 693
  tmp___29 = pthread_getspecific(PL_thr_key);
#line 693
  ((PerlInterpreter *)tmp___28)->Istack_sp = (((PerlInterpreter *)tmp___29)->Istack_base + ax) + (tmpXSoff - 1L);
  }
#line 693
  return;
}
}
#line 697
static void XS_Net__Oping__ping_get_error(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                          CV *cv  __attribute__((__unused__)) ) ;
#line 698 "Oping.c"
static void XS_Net__Oping__ping_get_error(PerlInterpreter *my_perl  __attribute__((__unused__)) ,
                                          CV *cv  __attribute__((__unused__)) ) 
{ 
  SV **sp ;
  void *tmp ;
  I32 ax ;
  void *tmp___0 ;
  I32 *tmp___1 ;
  SV **mark ;
  void *tmp___2 ;
  I32 tmp___3 ;
  I32 items ;
  pingobj_t *obj ;
  char const   *RETVAL ;
  SV *targ ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  SV *tmp___8 ;
  SV *tmp___9 ;
  void *tmp___10 ;
  IV tmp___11 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  IV tmp___16 ;
  IV tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  _Bool tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  IV tmpXSoff ;
  void *tmp___27 ;
  void *tmp___28 ;

  {
  {
#line 700
  tmp = pthread_getspecific(PL_thr_key);
#line 700
  sp = ((PerlInterpreter *)tmp)->Istack_sp;
#line 700
  tmp___0 = pthread_getspecific(PL_thr_key);
#line 700
  tmp___1 = ((PerlInterpreter *)tmp___0)->Imarkstack_ptr;
#line 700
  (((PerlInterpreter *)tmp___0)->Imarkstack_ptr) --;
#line 700
  ax = *tmp___1;
#line 700
  tmp___2 = pthread_getspecific(PL_thr_key);
#line 700
  tmp___3 = ax;
#line 700
  ax ++;
#line 700
  mark = ((PerlInterpreter *)tmp___2)->Istack_base + tmp___3;
#line 700
  items = (I32 )(sp - mark);
  }
#line 701
  if (items != 1) {
    {
#line 702
    Perl_croak_xs_usage((CV const   */* const  */)cv, (char const   */* const  */)"obj");
    }
  }
  {
#line 706
  tmp___10 = pthread_getspecific(PL_thr_key);
  }
#line 706
  if ((int )(((PerlInterpreter *)tmp___10)->Iop)->op_private & 4) {
    {
#line 706
    tmp___5 = pthread_getspecific(PL_thr_key);
#line 706
    tmp___6 = pthread_getspecific(PL_thr_key);
#line 706
    tmp___9 = *(((PerlInterpreter *)tmp___5)->Icurpad + (((PerlInterpreter *)tmp___6)->Iop)->op_targ);
    }
  } else {
    {
#line 706
    tmp___7 = pthread_getspecific(PL_thr_key);
#line 706
    tmp___8 = Perl_sv_newmortal((PerlInterpreter *)tmp___7);
#line 706
    tmp___9 = tmp___8;
    }
  }
  {
#line 706
  targ = tmp___9;
#line 708
  tmp___20 = pthread_getspecific(PL_thr_key);
  }
#line 708
  if ((*(((PerlInterpreter *)tmp___20)->Istack_base + ax))->sv_flags & 2048U) {
    {
#line 708
    tmp___21 = pthread_getspecific(PL_thr_key);
#line 708
    tmp___22 = pthread_getspecific(PL_thr_key);
#line 708
    tmp___23 = Perl_sv_derived_from((PerlInterpreter *)tmp___22, *(((PerlInterpreter *)tmp___21)->Istack_base + ax),
                                    (char const   */* const  */)"pingobj_tPtr");
    }
#line 708
    if (tmp___23) {
      {
#line 709
      tmp___18 = pthread_getspecific(PL_thr_key);
      }
#line 709
      if ((((*(((PerlInterpreter *)tmp___18)->Istack_base + ax))->sv_u.svu_rv)->sv_flags & 2097408U) == 256U) {
        {
#line 709
        tmp___13 = pthread_getspecific(PL_thr_key);
#line 709
        tmp___17 = ((XPVIV *)((*(((PerlInterpreter *)tmp___13)->Istack_base + ax))->sv_u.svu_rv)->sv_any)->xiv_u.xivu_iv;
        }
      } else {
        {
#line 709
        tmp___14 = pthread_getspecific(PL_thr_key);
#line 709
        tmp___15 = pthread_getspecific(PL_thr_key);
#line 709
        tmp___16 = Perl_sv_2iv_flags((PerlInterpreter *)tmp___15, (SV */* const  */)(*(((PerlInterpreter *)tmp___14)->Istack_base + ax))->sv_u.svu_rv,
                                     (I32 const   )2);
#line 709
        tmp___17 = tmp___16;
        }
      }
#line 709
      tmp___11 = tmp___17;
#line 710
      obj = (pingobj_t *)tmp___11;
    } else {
      {
#line 713
      tmp___19 = pthread_getspecific(PL_thr_key);
#line 713
      Perl_croak((PerlInterpreter *)tmp___19, "%s: %s is not of type %s", "Net::Oping::_ping_get_error",
                 "obj", "pingobj_tPtr");
      }
    }
  } else {
    {
#line 713
    tmp___19 = pthread_getspecific(PL_thr_key);
#line 713
    Perl_croak((PerlInterpreter *)tmp___19, "%s: %s is not of type %s", "Net::Oping::_ping_get_error",
               "obj", "pingobj_tPtr");
    }
  }
  {
#line 240 "Oping.xs"
  RETVAL = ping_get_error(obj);
#line 720 "Oping.c"
  tmp___24 = pthread_getspecific(PL_thr_key);
#line 720
  Perl_sv_setpv((PerlInterpreter *)tmp___24, (SV */* const  */)targ, (char const   */* const  */)RETVAL);
#line 720
  tmp___25 = pthread_getspecific(PL_thr_key);
#line 720
  sp = (((PerlInterpreter *)tmp___25)->Istack_base + ax) - 1;
  }
#line 720
  if (targ->sv_flags & 4194304U) {
    {
#line 720
    tmp___26 = pthread_getspecific(PL_thr_key);
#line 720
    Perl_mg_set((PerlInterpreter *)tmp___26, targ);
    }
  }
  {
#line 720
  sp ++;
#line 720
  *sp = targ;
#line 722
  tmpXSoff = (IV )1;
#line 722
  tmp___27 = pthread_getspecific(PL_thr_key);
#line 722
  tmp___28 = pthread_getspecific(PL_thr_key);
#line 722
  ((PerlInterpreter *)tmp___27)->Istack_sp = (((PerlInterpreter *)tmp___28)->Istack_base + ax) + (tmpXSoff - 1L);
  }
#line 722
  return;
}
}
#line 728
void boot_Net__Oping(PerlInterpreter *my_perl  __attribute__((__unused__)) , CV *cv  __attribute__((__unused__)) ) ;
#line 729 "Oping.c"
void boot_Net__Oping(PerlInterpreter *my_perl  __attribute__((__unused__)) , CV *cv  __attribute__((__unused__)) ) 
{ 
  SV **sp ;
  void *tmp ;
  I32 ax ;
  void *tmp___0 ;
  I32 *tmp___1 ;
  SV **mark ;
  void *tmp___2 ;
  I32 tmp___3 ;
  I32 items ;
  char const   *file ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  IV tmpXSoff ;
  void *tmp___29 ;
  void *tmp___30 ;

  {
  {
#line 731
  tmp = pthread_getspecific(PL_thr_key);
#line 731
  sp = ((PerlInterpreter *)tmp)->Istack_sp;
#line 731
  tmp___0 = pthread_getspecific(PL_thr_key);
#line 731
  tmp___1 = ((PerlInterpreter *)tmp___0)->Imarkstack_ptr;
#line 731
  (((PerlInterpreter *)tmp___0)->Imarkstack_ptr) --;
#line 731
  ax = *tmp___1;
#line 731
  tmp___2 = pthread_getspecific(PL_thr_key);
#line 731
  tmp___3 = ax;
#line 731
  ax ++;
#line 731
  mark = ((PerlInterpreter *)tmp___2)->Istack_base + tmp___3;
#line 731
  items = (I32 )(sp - mark);
#line 735
  file = "Oping.c";
#line 741
  tmp___4 = pthread_getspecific(PL_thr_key);
#line 741
  tmp___5 = pthread_getspecific(PL_thr_key);
#line 741
  Perl_xs_apiversion_bootcheck((PerlInterpreter *)tmp___5, *(((PerlInterpreter *)tmp___4)->Istack_base + ax),
                               "v5.18.0", sizeof("v5.18.0") - 1UL);
#line 743
  tmp___6 = pthread_getspecific(PL_thr_key);
#line 743
  Perl_xs_version_bootcheck((PerlInterpreter *)tmp___6, (U32 )items, (U32 )ax, "1.21",
                            sizeof("1.21") - 1UL);
#line 745
  tmp___7 = pthread_getspecific(PL_thr_key);
#line 745
  Perl_newXS((PerlInterpreter *)tmp___7, "Net::Oping::_ping_construct", & XS_Net__Oping__ping_construct,
             file);
#line 746
  tmp___8 = pthread_getspecific(PL_thr_key);
#line 746
  Perl_newXS((PerlInterpreter *)tmp___8, "Net::Oping::_ping_destroy", & XS_Net__Oping__ping_destroy,
             file);
#line 747
  tmp___9 = pthread_getspecific(PL_thr_key);
#line 747
  Perl_newXS((PerlInterpreter *)tmp___9, "Net::Oping::_ping_setopt_timeout", & XS_Net__Oping__ping_setopt_timeout,
             file);
#line 748
  tmp___10 = pthread_getspecific(PL_thr_key);
#line 748
  Perl_newXS((PerlInterpreter *)tmp___10, "Net::Oping::_ping_setopt_ttl", & XS_Net__Oping__ping_setopt_ttl,
             file);
#line 749
  tmp___11 = pthread_getspecific(PL_thr_key);
#line 749
  Perl_newXS((PerlInterpreter *)tmp___11, "Net::Oping::_ping_setopt_source", & XS_Net__Oping__ping_setopt_source,
             file);
#line 750
  tmp___12 = pthread_getspecific(PL_thr_key);
#line 750
  Perl_newXS((PerlInterpreter *)tmp___12, "Net::Oping::_ping_setopt_device", & XS_Net__Oping__ping_setopt_device,
             file);
#line 751
  tmp___13 = pthread_getspecific(PL_thr_key);
#line 751
  Perl_newXS((PerlInterpreter *)tmp___13, "Net::Oping::_ping_host_add", & XS_Net__Oping__ping_host_add,
             file);
#line 752
  tmp___14 = pthread_getspecific(PL_thr_key);
#line 752
  Perl_newXS((PerlInterpreter *)tmp___14, "Net::Oping::_ping_host_remove", & XS_Net__Oping__ping_host_remove,
             file);
#line 753
  tmp___15 = pthread_getspecific(PL_thr_key);
#line 753
  Perl_newXS((PerlInterpreter *)tmp___15, "Net::Oping::_ping_send", & XS_Net__Oping__ping_send,
             file);
#line 754
  tmp___16 = pthread_getspecific(PL_thr_key);
#line 754
  Perl_newXS((PerlInterpreter *)tmp___16, "Net::Oping::_ping_iterator_get", & XS_Net__Oping__ping_iterator_get,
             file);
#line 755
  tmp___17 = pthread_getspecific(PL_thr_key);
#line 755
  Perl_newXS((PerlInterpreter *)tmp___17, "Net::Oping::_ping_iterator_next", & XS_Net__Oping__ping_iterator_next,
             file);
#line 756
  tmp___18 = pthread_getspecific(PL_thr_key);
#line 756
  Perl_newXS((PerlInterpreter *)tmp___18, "Net::Oping::_ping_iterator_get_latency",
             & XS_Net__Oping__ping_iterator_get_latency, file);
#line 757
  tmp___19 = pthread_getspecific(PL_thr_key);
#line 757
  Perl_newXS((PerlInterpreter *)tmp___19, "Net::Oping::_ping_iterator_get_hostname",
             & XS_Net__Oping__ping_iterator_get_hostname, file);
#line 758
  tmp___20 = pthread_getspecific(PL_thr_key);
#line 758
  Perl_newXS((PerlInterpreter *)tmp___20, "Net::Oping::_ping_iterator_get_dropped",
             & XS_Net__Oping__ping_iterator_get_dropped, file);
#line 759
  tmp___21 = pthread_getspecific(PL_thr_key);
#line 759
  Perl_newXS((PerlInterpreter *)tmp___21, "Net::Oping::_ping_iterator_get_recv_ttl",
             & XS_Net__Oping__ping_iterator_get_recv_ttl, file);
#line 760
  tmp___22 = pthread_getspecific(PL_thr_key);
#line 760
  Perl_newXS((PerlInterpreter *)tmp___22, "Net::Oping::_ping_get_error", & XS_Net__Oping__ping_get_error,
             file);
#line 762
  tmp___26 = pthread_getspecific(PL_thr_key);
  }
#line 762
  if (((PerlInterpreter *)tmp___26)->Iunitcheckav) {
    {
#line 763
    tmp___23 = pthread_getspecific(PL_thr_key);
#line 763
    tmp___24 = pthread_getspecific(PL_thr_key);
#line 763
    tmp___25 = pthread_getspecific(PL_thr_key);
#line 763
    Perl_call_list((PerlInterpreter *)tmp___25, ((PerlInterpreter *)tmp___24)->Iscopestack_ix,
                   ((PerlInterpreter *)tmp___23)->Iunitcheckav);
    }
  }
  {
#line 765
  tmp___27 = pthread_getspecific(PL_thr_key);
#line 765
  tmp___28 = pthread_getspecific(PL_thr_key);
#line 765
  *(((PerlInterpreter *)tmp___27)->Istack_base + ax) = & ((PerlInterpreter *)tmp___28)->Isv_yes;
#line 765
  tmpXSoff = (IV )1;
#line 765
  tmp___29 = pthread_getspecific(PL_thr_key);
#line 765
  tmp___30 = pthread_getspecific(PL_thr_key);
#line 765
  ((PerlInterpreter *)tmp___29)->Istack_sp = (((PerlInterpreter *)tmp___30)->Istack_base + ax) + (tmpXSoff - 1L);
  }
#line 765
  return;
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 321 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 324
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 427
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) strerror_r)(int __errnum ,
                                                                                                 char *__buf ,
                                                                                                 size_t __buflen )  __asm__("__xpg_strerror_r")  ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 272 "/usr/include/x86_64-linux-gnu/bits/socket.h"
extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__leaf__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                struct cmsghdr *__cmsg ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 202
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 677
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , int __flags ) ;
#line 94 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.h"
void *ping_iterator_get_context(pingobj_iter_t *iter ) ;
#line 95
void ping_iterator_set_context(pingobj_iter_t *iter , void *context ) ;
#line 156 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static char *sstrerror(int errnum , char *buf , size_t buflen ) 
{ 
  int tmp ;

  {
  {
#line 158
  *(buf + 0) = (char)0;
#line 182
  tmp = strerror_r(errnum, buf, buflen);
  }
#line 182
  if (tmp != 0) {
    {
#line 184
    snprintf((char */* __restrict  */)buf, buflen, (char const   */* __restrict  */)"Error %i (%#x); Additionally, strerror_r failed.",
             errnum, errnum);
    }
  }
#line 190
  *(buf + (buflen - 1UL)) = (char)0;
#line 192
  return (buf);
}
}
#line 195 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static void ping_set_error(pingobj_t *obj , char const   *function , char const   *message ) 
{ 


  {
  {
#line 198
  snprintf((char */* __restrict  */)(obj->errmsg), sizeof(obj->errmsg), (char const   */* __restrict  */)"%s: %s",
           function, message);
#line 200
  obj->errmsg[sizeof(obj->errmsg) - 1UL] = (char)0;
  }
#line 201
  return;
}
}
#line 203 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static void ping_set_errno(pingobj_t *obj , int error_number ) 
{ 


  {
  {
#line 205
  sstrerror(error_number, obj->errmsg, sizeof(obj->errmsg));
  }
#line 206
  return;
}
}
#line 208 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_timeval_add(struct timeval *tv1 , struct timeval *tv2 , struct timeval *res ) 
{ 


  {
#line 211
  res->tv_sec = tv1->tv_sec + tv2->tv_sec;
#line 212
  res->tv_usec = tv1->tv_usec + tv2->tv_usec;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! (res->tv_usec > 1000000L)) {
#line 214
      goto while_break;
    }
#line 216
    res->tv_usec -= 1000000L;
#line 217
    (res->tv_sec) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return (0);
}
}
#line 223 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_timeval_sub(struct timeval *tv1 , struct timeval *tv2 , struct timeval *res ) 
{ 


  {
#line 226
  if (tv1->tv_sec < tv2->tv_sec) {
#line 229
    return (-1);
  } else
#line 226
  if (tv1->tv_sec == tv2->tv_sec) {
#line 226
    if (tv1->tv_usec < tv2->tv_usec) {
#line 229
      return (-1);
    }
  }
#line 231
  res->tv_sec = tv1->tv_sec - tv2->tv_sec;
#line 232
  res->tv_usec = tv1->tv_usec - tv2->tv_usec;
#line 234
  if (! (res->tv_sec > 0L)) {
#line 234
    if (res->tv_sec == 0L) {
#line 234
      if (! (res->tv_usec >= 0L)) {
        {
#line 234
        __assert_fail("(res->tv_sec > 0) || ((res->tv_sec == 0) && (res->tv_usec >= 0))",
                      "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c",
                      234U, "ping_timeval_sub");
        }
      }
    } else {
      {
#line 234
      __assert_fail("(res->tv_sec > 0) || ((res->tv_sec == 0) && (res->tv_usec >= 0))",
                    "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c", 234U,
                    "ping_timeval_sub");
      }
    }
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! (res->tv_usec < 0L)) {
#line 236
      goto while_break;
    }
#line 238
    res->tv_usec += 1000000L;
#line 239
    (res->tv_sec) --;
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  return (0);
}
}
#line 245 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static uint16_t ping_icmp4_checksum(char *buf , size_t len ) 
{ 
  uint32_t sum ;
  uint16_t ret ;
  uint16_t *ptr ;

  {
#line 247
  sum = (uint32_t )0;
#line 248
  ret = (uint16_t )0;
#line 252
  ptr = (uint16_t *)buf;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! (len > 1UL)) {
#line 252
      goto while_break;
    }
#line 253
    sum += (uint32_t )*ptr;
#line 252
    ptr ++;
#line 252
    len -= 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  if (len == 1UL) {
#line 257
    *((char *)(& ret)) = *((char *)ptr);
#line 258
    sum += (uint32_t )ret;
  }
#line 262
  sum = (sum >> 16) + (sum & 65535U);
#line 263
  sum = (sum >> 16) + (sum & 65535U);
#line 265
  ret = (uint16_t )(~ sum);
#line 267
  return (ret);
}
}
#line 270 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static pinghost_t *ping_receive_ipv4(pingobj_t *obj , char *buffer , size_t buffer_len ) 
{ 
  struct ip *ip_hdr ;
  struct icmp *icmp_hdr ;
  size_t ip_hdr_len ;
  uint16_t recv_checksum ;
  uint16_t calc_checksum ;
  uint16_t ident ;
  uint16_t seq ;
  pinghost_t *ptr ;

  {
#line 286
  if (buffer_len < sizeof(struct ip )) {
#line 287
    return ((pinghost_t *)((void *)0));
  }
#line 289
  ip_hdr = (struct ip *)buffer;
#line 290
  ip_hdr_len = (size_t )(ip_hdr->ip_hl << 2);
#line 292
  if (buffer_len < ip_hdr_len) {
#line 293
    return ((pinghost_t *)((void *)0));
  }
#line 295
  buffer += ip_hdr_len;
#line 296
  buffer_len -= ip_hdr_len;
#line 298
  if (buffer_len < sizeof(struct icmp )) {
#line 299
    return ((pinghost_t *)((void *)0));
  }
#line 301
  icmp_hdr = (struct icmp *)buffer;
#line 302
  buffer += sizeof(struct icmp );
#line 303
  buffer_len -= sizeof(struct icmp );
#line 305
  if ((int )icmp_hdr->icmp_type != 0) {
#line 308
    return ((pinghost_t *)((void *)0));
  }
  {
#line 311
  recv_checksum = icmp_hdr->icmp_cksum;
#line 312
  icmp_hdr->icmp_cksum = (u_int16_t )0;
#line 313
  calc_checksum = ping_icmp4_checksum((char *)icmp_hdr, sizeof(struct icmp ) + buffer_len);
  }
#line 316
  if ((int )recv_checksum != (int )calc_checksum) {
#line 321
    return ((pinghost_t *)((void *)0));
  }
  {
#line 324
  ident = ntohs(icmp_hdr->icmp_hun.ih_idseq.icd_id);
#line 325
  seq = ntohs(icmp_hdr->icmp_hun.ih_idseq.icd_seq);
#line 329
  ptr = obj->head;
  }
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 329
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 329
      goto while_break;
    }
#line 334
    if (ptr->addrfamily != 2) {
#line 335
      goto __Cont;
    }
#line 337
    if (! (ptr->timer)->tv_sec) {
#line 337
      if (! (ptr->timer)->tv_usec) {
#line 338
        goto __Cont;
      }
    }
#line 340
    if (ptr->ident != (int )ident) {
#line 341
      goto __Cont;
    }
#line 343
    if (((ptr->sequence - 1) & 65535) != (int )seq) {
#line 344
      goto __Cont;
    }
#line 350
    goto while_break;
    __Cont: /* CIL Label */ 
#line 329
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 359
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 360
    ptr->recv_ttl = (int )ip_hdr->ip_ttl;
#line 361
    ptr->recv_qos = ip_hdr->ip_tos;
  }
#line 363
  return (ptr);
}
}
#line 382 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static pinghost_t *ping_receive_ipv6(pingobj_t *obj , char *buffer , size_t buffer_len ) 
{ 
  struct icmp6_hdr *icmp_hdr ;
  uint16_t ident ;
  uint16_t seq ;
  pinghost_t *ptr ;

  {
#line 392
  if (buffer_len < sizeof(struct icmp6_hdr )) {
#line 393
    return ((pinghost_t *)((void *)0));
  }
#line 395
  icmp_hdr = (struct icmp6_hdr *)buffer;
#line 396
  buffer += sizeof(struct icmp );
#line 397
  buffer_len -= sizeof(struct icmp );
#line 399
  if ((int )icmp_hdr->icmp6_type != 129) {
#line 402
    return ((pinghost_t *)((void *)0));
  }
#line 405
  if ((int )icmp_hdr->icmp6_code != 0) {
#line 408
    return ((pinghost_t *)((void *)0));
  }
  {
#line 411
  ident = ntohs(icmp_hdr->icmp6_dataun.icmp6_un_data16[0]);
#line 412
  seq = ntohs(icmp_hdr->icmp6_dataun.icmp6_un_data16[1]);
#line 416
  ptr = obj->head;
  }
  {
#line 416
  while (1) {
    while_continue: /* CIL Label */ ;
#line 416
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 416
      goto while_break;
    }
#line 421
    if (ptr->addrfamily != 10) {
#line 422
      goto __Cont;
    }
#line 424
    if (! (ptr->timer)->tv_sec) {
#line 424
      if (! (ptr->timer)->tv_usec) {
#line 425
        goto __Cont;
      }
    }
#line 427
    if (ptr->ident != (int )ident) {
#line 428
      goto __Cont;
    }
#line 430
    if (((ptr->sequence - 1) & 65535) != (int )seq) {
#line 431
      goto __Cont;
    }
#line 437
    goto while_break;
    __Cont: /* CIL Label */ 
#line 416
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 447
  return (ptr);
}
}
#line 450 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_receive_one(pingobj_t *obj , pinghost_t const   *ph , struct timeval *now ) 
{ 
  struct timeval diff ;
  struct timeval pkt_now ;
  pinghost_t *host ;
  int recv_ttl ;
  uint8_t recv_qos ;
  struct msghdr msghdr ;
  struct cmsghdr *cmsg ;
  char payload_buffer[4096] ;
  ssize_t payload_buffer_len ;
  char control_buffer[4096] ;
  struct iovec payload_iovec ;
  __suseconds_t tmp ;
  int tmp___0 ;
  __suseconds_t tmp___1 ;

  {
  {
#line 457
  pkt_now = *now;
#line 458
  host = (pinghost_t *)((void *)0);
#line 472
  memset((void *)(& payload_iovec), 0, sizeof(payload_iovec));
#line 473
  payload_iovec.iov_base = (void *)(payload_buffer);
#line 474
  payload_iovec.iov_len = sizeof(payload_buffer);
#line 476
  memset((void *)(& msghdr), 0, sizeof(msghdr));
#line 478
  msghdr.msg_name = (void *)0;
#line 479
  msghdr.msg_namelen = (socklen_t )0;
#line 481
  msghdr.msg_iov = & payload_iovec;
#line 482
  msghdr.msg_iovlen = (size_t )1;
#line 484
  msghdr.msg_control = (void *)(control_buffer);
#line 485
  msghdr.msg_controllen = sizeof(control_buffer);
#line 487
  msghdr.msg_flags = 0;
#line 492
  payload_buffer_len = recvmsg((int )ph->fd, & msghdr, 0);
  }
#line 493
  if (payload_buffer_len < 0L) {
#line 500
    return (-1);
  }
#line 505
  recv_ttl = -1;
#line 506
  recv_qos = (uint8_t )0;
#line 507
  if (msghdr.msg_controllen >= sizeof(struct cmsghdr )) {
#line 507
    cmsg = (struct cmsghdr *)msghdr.msg_control;
  } else {
#line 507
    cmsg = (struct cmsghdr *)0;
  }
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;
#line 507
    if (! ((unsigned long )cmsg != (unsigned long )((void *)0))) {
#line 507
      goto while_break;
    }
#line 511
    if (cmsg->cmsg_level == 1) {
#line 514
      if (cmsg->cmsg_type == 29) {
        {
#line 515
        memcpy((void */* __restrict  */)(& pkt_now), (void const   */* __restrict  */)(cmsg->__cmsg_data),
               sizeof(pkt_now));
        }
      }
    } else
#line 518
    if (ph->addrfamily == 2) {
#line 520
      if (cmsg->cmsg_level != 0) {
#line 521
        goto __Cont;
      }
#line 523
      if (cmsg->cmsg_type == 1) {
        {
#line 525
        memcpy((void */* __restrict  */)(& recv_qos), (void const   */* __restrict  */)(cmsg->__cmsg_data),
               sizeof(recv_qos));
        }
      } else
#line 529
      if (cmsg->cmsg_type == 2) {
        {
#line 531
        memcpy((void */* __restrict  */)(& recv_ttl), (void const   */* __restrict  */)(cmsg->__cmsg_data),
               sizeof(recv_ttl));
        }
      }
    } else
#line 541
    if (ph->addrfamily == 10) {
#line 543
      if (cmsg->cmsg_level != 41) {
#line 544
        goto __Cont;
      }
#line 546
      if (cmsg->cmsg_type == 67) {
        {
#line 548
        memcpy((void */* __restrict  */)(& recv_qos), (void const   */* __restrict  */)(cmsg->__cmsg_data),
               sizeof(recv_qos));
        }
      } else
#line 553
      if (cmsg->cmsg_type == 52) {
        {
#line 555
        memcpy((void */* __restrict  */)(& recv_ttl), (void const   */* __restrict  */)(cmsg->__cmsg_data),
               sizeof(recv_ttl));
        }
      } else
#line 562
      if (cmsg->cmsg_type == 16) {
        {
#line 564
        memcpy((void */* __restrict  */)(& recv_ttl), (void const   */* __restrict  */)(cmsg->__cmsg_data),
               sizeof(recv_ttl));
        }
      } else
#line 571
      if (cmsg->cmsg_type == 18) {
        {
#line 573
        memcpy((void */* __restrict  */)(& recv_ttl), (void const   */* __restrict  */)(cmsg->__cmsg_data),
               sizeof(recv_ttl));
        }
      }
    }
    __Cont: /* CIL Label */ 
    {
#line 507
    cmsg = __cmsg_nxthdr(& msghdr, cmsg);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 592
  if (ph->addrfamily == 2) {
    {
#line 594
    host = ping_receive_ipv4(obj, payload_buffer, (size_t )payload_buffer_len);
    }
#line 595
    if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 596
      return (-1);
    }
  } else
#line 598
  if (ph->addrfamily == 10) {
    {
#line 600
    host = ping_receive_ipv6(obj, payload_buffer, (size_t )payload_buffer_len);
    }
#line 601
    if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 602
      return (-1);
    }
  } else {
#line 608
    return (-1);
  }
  {
#line 618
  tmp___0 = ping_timeval_sub(& pkt_now, host->timer, & diff);
  }
#line 618
  if (tmp___0 < 0) {
#line 620
    tmp = (__suseconds_t )0;
#line 620
    (host->timer)->tv_usec = tmp;
#line 620
    (host->timer)->tv_sec = tmp;
#line 621
    return (-1);
  }
#line 628
  if (recv_ttl >= 0) {
#line 629
    host->recv_ttl = recv_ttl;
  }
#line 630
  host->recv_qos = recv_qos;
#line 632
  host->latency = (double )diff.tv_usec / 1000.0;
#line 633
  host->latency += (double )diff.tv_sec * 1000.0;
#line 635
  tmp___1 = (__suseconds_t )0;
#line 635
  (host->timer)->tv_usec = tmp___1;
#line 635
  (host->timer)->tv_sec = tmp___1;
#line 637
  return (0);
}
}
#line 640 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_receive_all(pingobj_t *obj ) 
{ 
  fd_set read_fds ;
  fd_set err_fds ;
  int num_fds ;
  int max_fd ;
  pinghost_t *ph ;
  pinghost_t *ptr ;
  struct timeval endtime ;
  struct timeval nowtime ;
  struct timeval timeout ;
  int status ;
  int ret ;
  int *tmp ;
  int tmp___0 ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  __suseconds_t tmp___8 ;

  {
#line 657
  ph = obj->head;
#line 658
  ret = 0;
#line 660
  ptr = ph;
  {
#line 660
  while (1) {
    while_continue: /* CIL Label */ ;
#line 660
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 660
      goto while_break;
    }
#line 662
    ptr->latency = - 1.0;
#line 663
    ptr->recv_ttl = -1;
#line 660
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 666
  tmp___0 = gettimeofday((struct timeval */* __restrict  */)(& nowtime), (__timezone_ptr_t )((void *)0));
  }
#line 666
  if (tmp___0 == -1) {
    {
#line 668
    tmp = __errno_location();
#line 668
    ping_set_errno(obj, *tmp);
    }
#line 669
    return (-1);
  }
  {
#line 673
  timeout.tv_sec = (time_t )obj->timeout;
#line 674
  timeout.tv_usec = (suseconds_t )((double )1000000 * (obj->timeout - (double )timeout.tv_sec));
#line 680
  ping_timeval_add(& nowtime, & timeout, & endtime);
  }
  {
#line 682
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 684
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 684
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& read_fds.__fds_bits[0]): "memory");
#line 684
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 685
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 685
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& err_fds.__fds_bits[0]): "memory");
#line 685
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 686
    num_fds = 0;
#line 687
    max_fd = -1;
#line 689
    ptr = ph;
    {
#line 689
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 689
      if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 689
        goto while_break___3;
      }
#line 691
      if (! (ptr->timer)->tv_sec) {
#line 691
        if (! (ptr->timer)->tv_usec) {
#line 692
          goto __Cont;
        }
      }
#line 694
      read_fds.__fds_bits[ptr->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ptr->fd % (8 * (int )sizeof(__fd_mask ));
#line 695
      err_fds.__fds_bits[ptr->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ptr->fd % (8 * (int )sizeof(__fd_mask ));
#line 696
      num_fds ++;
#line 698
      if (max_fd < ptr->fd) {
#line 699
        max_fd = ptr->fd;
      }
      __Cont: /* CIL Label */ 
#line 689
      ptr = ptr->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 702
    if (num_fds == 0) {
#line 703
      goto while_break___0;
    }
    {
#line 705
    tmp___2 = gettimeofday((struct timeval */* __restrict  */)(& nowtime), (__timezone_ptr_t )((void *)0));
    }
#line 705
    if (tmp___2 == -1) {
      {
#line 707
      tmp___1 = __errno_location();
#line 707
      ping_set_errno(obj, *tmp___1);
      }
#line 708
      return (-1);
    }
    {
#line 711
    tmp___3 = ping_timeval_sub(& endtime, & nowtime, & timeout);
    }
#line 711
    if (tmp___3 == -1) {
#line 712
      goto while_break___0;
    }
    {
#line 718
    status = select(max_fd + 1, (fd_set */* __restrict  */)(& read_fds), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)(& err_fds), (struct timeval */* __restrict  */)(& timeout));
#line 720
    tmp___5 = gettimeofday((struct timeval */* __restrict  */)(& nowtime), (__timezone_ptr_t )((void *)0));
    }
#line 720
    if (tmp___5 == -1) {
      {
#line 722
      tmp___4 = __errno_location();
#line 722
      ping_set_errno(obj, *tmp___4);
      }
#line 723
      return (-1);
    }
#line 726
    if (status == -1) {
      {
#line 726
      tmp___6 = __errno_location();
      }
#line 726
      if (*tmp___6 == 4) {
#line 729
        goto while_continue___0;
      } else {
#line 726
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 731
    if (status < 0) {
#line 738
      goto while_break___0;
    } else
#line 740
    if (status == 0) {
#line 743
      ptr = ph;
      {
#line 743
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 743
        if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 743
          goto while_break___4;
        }
#line 744
        if (ptr->latency < 0.0) {
#line 745
          (ptr->dropped) ++;
        }
#line 743
        ptr = ptr->next;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 746
      goto while_break___0;
    }
#line 749
    ptr = ph;
    {
#line 749
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 749
      if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 749
        goto while_break___5;
      }
#line 751
      if ((read_fds.__fds_bits[ptr->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << ptr->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 753
        tmp___7 = ping_receive_one(obj, (pinghost_t const   *)ptr, & nowtime);
        }
#line 753
        if (tmp___7 == 0) {
#line 754
          ret ++;
        }
      } else
#line 756
      if ((err_fds.__fds_bits[ptr->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << ptr->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 761
        tmp___8 = (__suseconds_t )0;
#line 761
        (ptr->timer)->tv_usec = tmp___8;
#line 761
        (ptr->timer)->tv_sec = tmp___8;
      }
#line 749
      ptr = ptr->next;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 766
  return (ret);
}
}
#line 776 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static ssize_t ping_sendto(pingobj_t *obj , pinghost_t *ph , void const   *buf , size_t buflen ) 
{ 
  ssize_t ret ;
  __suseconds_t tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 781
  tmp___0 = gettimeofday((struct timeval */* __restrict  */)ph->timer, (__timezone_ptr_t )((void *)0));
  }
#line 781
  if (tmp___0 == -1) {
#line 783
    tmp = (__suseconds_t )0;
#line 783
    (ph->timer)->tv_usec = tmp;
#line 783
    (ph->timer)->tv_sec = tmp;
#line 784
    return ((ssize_t )-1);
  }
  {
#line 787
  ret = sendto(ph->fd, buf, buflen, 0, (struct sockaddr  const  *)((struct sockaddr *)ph->addr),
               ph->addrlen);
  }
#line 790
  if (ret < 0L) {
    {
#line 793
    tmp___1 = __errno_location();
    }
#line 793
    if (*tmp___1 == 113) {
#line 794
      return ((ssize_t )0);
    }
    {
#line 797
    tmp___2 = __errno_location();
    }
#line 797
    if (*tmp___2 == 101) {
#line 798
      return ((ssize_t )0);
    }
    {
#line 800
    tmp___3 = __errno_location();
#line 800
    ping_set_errno(obj, *tmp___3);
    }
  }
#line 803
  return (ret);
}
}
#line 806 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_send_one_ipv4(pingobj_t *obj , pinghost_t *ph ) 
{ 
  struct icmp *icmp4 ;
  int status ;
  char buf[4096] ;
  int buflen ;
  char *data ;
  int datalen ;
  size_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 819
  memset((void *)(buf), '\000', sizeof(buf));
#line 820
  icmp4 = (struct icmp *)(buf);
#line 821
  data = (char *)(icmp4 + 1);
#line 823
  icmp4->icmp_type = (u_int8_t )8;
#line 824
  icmp4->icmp_code = (u_int8_t )0;
#line 825
  icmp4->icmp_cksum = (u_int16_t )0;
#line 826
  icmp4->icmp_hun.ih_idseq.icd_id = htons((uint16_t )ph->ident);
#line 827
  icmp4->icmp_hun.ih_idseq.icd_seq = htons((uint16_t )ph->sequence);
#line 829
  buflen = (int )(4096UL - sizeof(struct icmp ));
#line 830
  strncpy((char */* __restrict  */)data, (char const   */* __restrict  */)ph->data,
          (size_t )buflen);
#line 831
  tmp = strlen((char const   *)data);
#line 831
  datalen = (int )tmp;
#line 833
  buflen = (int )((unsigned long )datalen + sizeof(struct icmp ));
#line 835
  icmp4->icmp_cksum = ping_icmp4_checksum(buf, (size_t )buflen);
#line 839
  tmp___0 = ping_sendto(obj, ph, (void const   *)(buf), (size_t )buflen);
#line 839
  status = (int )tmp___0;
  }
#line 840
  if (status < 0) {
    {
#line 842
    perror("ping_sendto");
    }
#line 843
    return (-1);
  }
#line 848
  return (0);
}
}
#line 851 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_send_one_ipv6(pingobj_t *obj , pinghost_t *ph ) 
{ 
  struct icmp6_hdr *icmp6 ;
  int status ;
  char buf[4096] ;
  int buflen ;
  char *data ;
  int datalen ;
  size_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 864
  memset((void *)(buf), '\000', sizeof(buf));
#line 865
  icmp6 = (struct icmp6_hdr *)(buf);
#line 866
  data = (char *)(icmp6 + 1);
#line 868
  icmp6->icmp6_type = (uint8_t )128;
#line 869
  icmp6->icmp6_code = (uint8_t )0;
#line 872
  icmp6->icmp6_cksum = (uint16_t )0;
#line 873
  icmp6->icmp6_dataun.icmp6_un_data16[0] = htons((uint16_t )ph->ident);
#line 874
  icmp6->icmp6_dataun.icmp6_un_data16[1] = htons((uint16_t )ph->sequence);
#line 876
  buflen = (int )(4096UL - sizeof(struct icmp6_hdr ));
#line 877
  strncpy((char */* __restrict  */)data, (char const   */* __restrict  */)ph->data,
          (size_t )buflen);
#line 878
  tmp = strlen((char const   *)data);
#line 878
  datalen = (int )tmp;
#line 880
  buflen = (int )((unsigned long )datalen + sizeof(struct icmp6_hdr ));
#line 884
  tmp___0 = ping_sendto(obj, ph, (void const   *)(buf), (size_t )buflen);
#line 884
  status = (int )tmp___0;
  }
#line 885
  if (status < 0) {
    {
#line 887
    perror("ping_sendto");
    }
#line 888
    return (-1);
  }
#line 893
  return (0);
}
}
#line 896 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_send_all(pingobj_t *obj ) 
{ 
  pinghost_t *ph ;
  pinghost_t *ptr ;
  int ret ;
  __suseconds_t tmp ;
  int tmp___0 ;
  __suseconds_t tmp___1 ;
  int tmp___2 ;
  __suseconds_t tmp___3 ;
  int tmp___4 ;
  __suseconds_t tmp___5 ;

  {
#line 903
  ret = 0;
#line 904
  ph = obj->head;
#line 906
  ptr = ph;
  {
#line 906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 906
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 906
      goto while_break;
    }
    {
#line 910
    tmp___0 = gettimeofday((struct timeval */* __restrict  */)ptr->timer, (__timezone_ptr_t )((void *)0));
    }
#line 910
    if (tmp___0 == -1) {
#line 917
      tmp = (__suseconds_t )0;
#line 917
      (ptr->timer)->tv_usec = tmp;
#line 917
      (ptr->timer)->tv_sec = tmp;
#line 918
      ret --;
#line 919
      goto __Cont;
    }
#line 926
    if (ptr->addrfamily == 10) {
      {
#line 929
      tmp___2 = ping_send_one_ipv6(obj, ptr);
      }
#line 929
      if (tmp___2 != 0) {
#line 931
        tmp___1 = (__suseconds_t )0;
#line 931
        (ptr->timer)->tv_usec = tmp___1;
#line 931
        (ptr->timer)->tv_sec = tmp___1;
#line 932
        ret --;
#line 933
        goto __Cont;
      }
    } else
#line 936
    if (ptr->addrfamily == 2) {
      {
#line 939
      tmp___4 = ping_send_one_ipv4(obj, ptr);
      }
#line 939
      if (tmp___4 != 0) {
#line 941
        tmp___3 = (__suseconds_t )0;
#line 941
        (ptr->timer)->tv_usec = tmp___3;
#line 941
        (ptr->timer)->tv_sec = tmp___3;
#line 942
        ret --;
#line 943
        goto __Cont;
      }
    } else {
#line 949
      tmp___5 = (__suseconds_t )0;
#line 949
      (ptr->timer)->tv_usec = tmp___5;
#line 949
      (ptr->timer)->tv_sec = tmp___5;
#line 950
      ret --;
#line 951
      goto __Cont;
    }
#line 954
    (ptr->sequence) ++;
    __Cont: /* CIL Label */ 
#line 906
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  return (ret);
}
}
#line 963 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_set_ttl(pinghost_t *ph , int ttl ) 
{ 
  int ret ;

  {
#line 965
  ret = -2;
#line 967
  if (ph->addrfamily == 2) {
    {
#line 970
    ret = setsockopt(ph->fd, 0, 2, (void const   *)(& ttl), (socklen_t )sizeof(ttl));
    }
  } else
#line 973
  if (ph->addrfamily == 10) {
    {
#line 976
    ret = setsockopt(ph->fd, 41, 16, (void const   *)(& ttl), (socklen_t )sizeof(ttl));
    }
  }
#line 980
  return (ret);
}
}
#line 989 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_set_qos(pingobj_t *obj , pinghost_t *ph , uint8_t qos ) 
{ 
  int ret ;
  char errbuf[256] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 991
  ret = 22;
#line 994
  if (ph->addrfamily == 2) {
    {
#line 997
    ret = setsockopt(ph->fd, 0, 1, (void const   *)(& qos), (socklen_t )sizeof(qos));
    }
#line 999
    if (ret != 0) {
      {
#line 1001
      tmp = __errno_location();
#line 1001
      ret = *tmp;
#line 1002
      tmp___0 = sstrerror(ret, errbuf, sizeof(errbuf));
#line 1002
      ping_set_error(obj, "ping_set_qos", (char const   *)tmp___0);
      }
    }
  } else
#line 1007
  if (ph->addrfamily == 10) {
    {
#line 1010
    tmp___1 = (int )qos;
#line 1013
    ret = setsockopt(ph->fd, 41, 67, (void const   *)(& tmp___1), (socklen_t )sizeof(tmp___1));
    }
#line 1015
    if (ret != 0) {
      {
#line 1017
      tmp___2 = __errno_location();
#line 1017
      ret = *tmp___2;
#line 1018
      tmp___3 = sstrerror(ret, errbuf, sizeof(errbuf));
#line 1018
      ping_set_error(obj, "ping_set_qos", (char const   *)tmp___3);
      }
    }
  }
#line 1024
  return (ret);
}
}
#line 1030
static int ping_get_ident(void) ;
#line 1030 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int did_seed  =    0;
#line 1027 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_get_ident(void) 
{ 
  int fd ;
  int retval ;
  unsigned int seed ;
  ssize_t tmp ;
  long tmp___0 ;

  {
#line 1034
  if (did_seed == 0) {
    {
#line 1036
    fd = open("/dev/urandom", 0);
    }
#line 1036
    if (fd != -1) {
      {
#line 1040
      tmp = read(fd, (void *)(& seed), sizeof(seed));
      }
#line 1040
      if (tmp != -1L) {
        {
#line 1042
        did_seed = 1;
#line 1044
        srandom(seed);
        }
      }
      {
#line 1047
      close(fd);
      }
    }
  }
  {
#line 1059
  tmp___0 = random();
#line 1059
  retval = (int )tmp___0;
  }
#line 1063
  return (retval);
}
}
#line 1066 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static pinghost_t *ping_alloc(void) 
{ 
  pinghost_t *ph ;
  size_t ph_size ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 1071
  ph_size = (sizeof(pinghost_t ) + sizeof(struct sockaddr_storage )) + sizeof(struct timeval );
#line 1075
  tmp = malloc(ph_size);
#line 1075
  ph = (pinghost_t *)tmp;
  }
#line 1076
  if ((unsigned long )ph == (unsigned long )((void *)0)) {
#line 1077
    return ((pinghost_t *)((void *)0));
  }
  {
#line 1079
  memset((void *)ph, '\000', ph_size);
#line 1081
  ph->timer = (struct timeval *)(ph + 1);
#line 1082
  ph->addr = (struct sockaddr_storage *)(ph->timer + 1);
#line 1084
  ph->addrlen = (socklen_t )sizeof(struct sockaddr_storage );
#line 1085
  ph->fd = -1;
#line 1086
  ph->latency = - 1.0;
#line 1087
  ph->dropped = (uint32_t )0;
#line 1088
  tmp___0 = ping_get_ident();
#line 1088
  ph->ident = tmp___0 & 65535;
  }
#line 1090
  return (ph);
}
}
#line 1093 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static void ping_free(pinghost_t *ph ) 
{ 


  {
#line 1095
  if (ph->fd >= 0) {
    {
#line 1096
    close(ph->fd);
    }
  }
#line 1098
  if ((unsigned long )ph->username != (unsigned long )((void *)0)) {
    {
#line 1099
    free((void *)ph->username);
    }
  }
#line 1101
  if ((unsigned long )ph->hostname != (unsigned long )((void *)0)) {
    {
#line 1102
    free((void *)ph->hostname);
    }
  }
#line 1104
  if ((unsigned long )ph->data != (unsigned long )((void *)0)) {
    {
#line 1105
    free((void *)ph->data);
    }
  }
  {
#line 1107
  free((void *)ph);
  }
#line 1108
  return;
}
}
#line 1113 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
char const   *ping_get_error(pingobj_t *obj ) 
{ 


  {
#line 1115
  if ((unsigned long )obj == (unsigned long )((void *)0)) {
#line 1116
    return ((char const   *)((void *)0));
  }
#line 1117
  return ((char const   *)(obj->errmsg));
}
}
#line 1120 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
pingobj_t *ping_construct(void) 
{ 
  pingobj_t *obj ;
  void *tmp ;

  {
  {
#line 1124
  tmp = malloc(sizeof(pingobj_t ));
#line 1124
  obj = (pingobj_t *)tmp;
  }
#line 1124
  if ((unsigned long )obj == (unsigned long )((void *)0)) {
#line 1125
    return ((pingobj_t *)((void *)0));
  }
  {
#line 1126
  memset((void *)obj, 0, sizeof(pingobj_t ));
#line 1128
  obj->timeout = 1.0;
#line 1129
  obj->ttl = 255;
#line 1130
  obj->addrfamily = 0;
#line 1131
  obj->data = strdup("liboping -- ICMP ping library <http://octo.it/liboping/>");
#line 1132
  obj->qos = (uint8_t )0;
  }
#line 1134
  return (obj);
}
}
#line 1137 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
void ping_destroy(pingobj_t *obj ) 
{ 
  pinghost_t *current ;
  pinghost_t *next ;

  {
#line 1142
  if ((unsigned long )obj == (unsigned long )((void *)0)) {
#line 1143
    return;
  }
#line 1145
  current = obj->head;
#line 1146
  next = (pinghost_t *)((void *)0);
  {
#line 1148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1148
    if (! ((unsigned long )current != (unsigned long )((void *)0))) {
#line 1148
      goto while_break;
    }
    {
#line 1150
    next = current->next;
#line 1151
    ping_free(current);
#line 1152
    current = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1155
  if ((unsigned long )obj->data != (unsigned long )((void *)0)) {
    {
#line 1156
    free((void *)obj->data);
    }
  }
#line 1158
  if ((unsigned long )obj->srcaddr != (unsigned long )((void *)0)) {
    {
#line 1159
    free((void *)obj->srcaddr);
    }
  }
#line 1161
  if ((unsigned long )obj->device != (unsigned long )((void *)0)) {
    {
#line 1162
    free((void *)obj->device);
    }
  }
  {
#line 1164
  free((void *)obj);
  }
#line 1166
  return;
}
}
#line 1169 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
int ping_setopt(pingobj_t *obj , int option , void *value ) 
{ 
  int ret ;
  pinghost_t *ph ;
  pinghost_t *ph___0 ;
  char *hostname ;
  struct addrinfo ai_hints ;
  struct addrinfo *ai_list ;
  int status ;
  int tmp ;
  char errbuf[256] ;
  int *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char *device ;
  char *tmp___6 ;
  int *tmp___7 ;

  {
#line 1171
  ret = 0;
#line 1173
  if ((unsigned long )obj == (unsigned long )((void *)0)) {
#line 1174
    return (-1);
  } else
#line 1173
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 1174
    return (-1);
  }
  {
#line 1178
  if (option == 64) {
#line 1178
    goto case_64;
  }
#line 1188
  if (option == 1) {
#line 1188
    goto case_1;
  }
#line 1197
  if (option == 2) {
#line 1197
    goto case_2;
  }
#line 1213
  if (option == 4) {
#line 1213
    goto case_4;
  }
#line 1229
  if (option == 8) {
#line 1229
    goto case_8;
  }
#line 1238
  if (option == 16) {
#line 1238
    goto case_16;
  }
#line 1299
  if (option == 32) {
#line 1299
    goto case_32;
  }
#line 1321
  goto switch_default;
  case_64: /* CIL Label */ 
#line 1182
  obj->qos = *((uint8_t *)value);
#line 1183
  ph = obj->head;
  {
#line 1183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1183
    if (! ((unsigned long )ph != (unsigned long )((void *)0))) {
#line 1183
      goto while_break;
    }
    {
#line 1184
    ping_set_qos(obj, ph, obj->qos);
#line 1183
    ph = ph->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1185
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1189
  obj->timeout = *((double *)value);
#line 1190
  if (obj->timeout < 0.0) {
#line 1192
    obj->timeout = 1.0;
#line 1193
    ret = -1;
  }
#line 1195
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1198
  obj->ttl = *((int *)value);
#line 1199
  if (obj->ttl < 1) {
#line 1201
    obj->ttl = 255;
#line 1202
    ret = -1;
  } else
#line 1199
  if (obj->ttl > 255) {
#line 1201
    obj->ttl = 255;
#line 1202
    ret = -1;
  } else {
#line 1208
    ph___0 = obj->head;
    {
#line 1208
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1208
      if (! ((unsigned long )ph___0 != (unsigned long )((void *)0))) {
#line 1208
        goto while_break___0;
      }
      {
#line 1209
      ping_set_ttl(ph___0, obj->ttl);
#line 1208
      ph___0 = ph___0->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1211
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1214
  obj->addrfamily = *((int *)value);
#line 1215
  if (obj->addrfamily != 0) {
#line 1215
    if (obj->addrfamily != 2) {
#line 1215
      if (obj->addrfamily != 10) {
#line 1219
        obj->addrfamily = 0;
#line 1220
        ret = -1;
      }
    }
  }
#line 1222
  if ((unsigned long )obj->srcaddr != (unsigned long )((void *)0)) {
    {
#line 1224
    free((void *)obj->srcaddr);
#line 1225
    obj->srcaddr = (struct sockaddr *)((void *)0);
    }
  }
#line 1227
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1230
  if ((unsigned long )obj->data != (unsigned long )((void *)0)) {
    {
#line 1232
    free((void *)obj->data);
#line 1233
    obj->data = (char *)((void *)0);
    }
  }
  {
#line 1235
  obj->data = strdup((char const   *)value);
  }
#line 1236
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 1240
  hostname = (char *)value;
#line 1250
  memset((void *)(& ai_hints), '\000', sizeof(ai_hints));
#line 1251
  tmp = 0;
#line 1251
  obj->addrfamily = tmp;
#line 1251
  ai_hints.ai_family = tmp;
#line 1253
  ai_hints.ai_flags = 32;
#line 1255
  status = getaddrinfo((char const   */* __restrict  */)hostname, (char const   */* __restrict  */)((void *)0),
                       (struct addrinfo  const  */* __restrict  */)(& ai_hints), (struct addrinfo **/* __restrict  */)(& ai_list));
  }
#line 1256
  if (status != 0) {
#line 1261
    if (status == -11) {
      {
#line 1261
      tmp___0 = __errno_location();
#line 1261
      tmp___1 = sstrerror(*tmp___0, errbuf, sizeof(errbuf));
#line 1261
      tmp___3 = (char const   *)tmp___1;
      }
    } else {
      {
#line 1261
      tmp___2 = gai_strerror(status);
#line 1261
      tmp___3 = tmp___2;
      }
    }
    {
#line 1261
    ping_set_error(obj, "getaddrinfo", tmp___3);
#line 1267
    ret = -1;
    }
#line 1268
    goto switch_break;
  }
#line 1276
  if ((unsigned long )obj->srcaddr == (unsigned long )((void *)0)) {
    {
#line 1278
    obj->srcaddrlen = (socklen_t )0;
#line 1279
    tmp___4 = malloc(sizeof(struct sockaddr_storage ));
#line 1279
    obj->srcaddr = (struct sockaddr *)tmp___4;
    }
#line 1280
    if ((unsigned long )obj->srcaddr == (unsigned long )((void *)0)) {
      {
#line 1282
      tmp___5 = __errno_location();
#line 1282
      ping_set_errno(obj, *tmp___5);
#line 1283
      ret = -1;
#line 1284
      freeaddrinfo(ai_list);
      }
#line 1285
      goto switch_break;
    }
  }
  {
#line 1288
  memset((void *)obj->srcaddr, 0, sizeof(struct sockaddr_storage ));
  }
#line 1289
  if (! ((unsigned long )ai_list->ai_addrlen <= sizeof(struct sockaddr_storage ))) {
    {
#line 1289
    __assert_fail("ai_list->ai_addrlen <= sizeof (struct sockaddr_storage)", "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c",
                  1289U, "ping_setopt");
    }
  }
  {
#line 1290
  memcpy((void */* __restrict  */)((void *)obj->srcaddr), (void const   */* __restrict  */)((void const   *)ai_list->ai_addr),
         (size_t )ai_list->ai_addrlen);
#line 1292
  obj->srcaddrlen = ai_list->ai_addrlen;
#line 1293
  obj->addrfamily = ai_list->ai_family;
#line 1295
  freeaddrinfo(ai_list);
  }
#line 1297
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 1302
  tmp___6 = strdup((char const   *)((char *)value));
#line 1302
  device = tmp___6;
  }
#line 1304
  if ((unsigned long )device == (unsigned long )((void *)0)) {
    {
#line 1306
    tmp___7 = __errno_location();
#line 1306
    ping_set_errno(obj, *tmp___7);
#line 1307
    ret = -1;
    }
#line 1308
    goto switch_break;
  }
#line 1311
  if ((unsigned long )obj->device != (unsigned long )((void *)0)) {
    {
#line 1312
    free((void *)obj->device);
    }
  }
#line 1313
  obj->device = device;
#line 1319
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1322
  ret = -2;
  switch_break: /* CIL Label */ ;
  }
#line 1325
  return (ret);
}
}
#line 1329 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
int ping_send(pingobj_t *obj ) 
{ 
  int ret ;
  int tmp ;

  {
#line 1333
  if ((unsigned long )obj == (unsigned long )((void *)0)) {
#line 1334
    return (-1);
  }
  {
#line 1336
  tmp = ping_send_all(obj);
  }
#line 1336
  if (tmp < 0) {
#line 1337
    return (-1);
  }
  {
#line 1339
  ret = ping_receive_all(obj);
  }
#line 1339
  if (ret < 0) {
#line 1340
    return (-2);
  }
#line 1342
  return (ret);
}
}
#line 1345 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static pinghost_t *ping_host_search(pinghost_t *ph , char const   *host ) 
{ 
  int tmp ;

  {
  {
#line 1347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1347
    if (! ((unsigned long )ph != (unsigned long )((void *)0))) {
#line 1347
      goto while_break;
    }
    {
#line 1349
    tmp = strcasecmp((char const   *)ph->username, host);
    }
#line 1349
    if (tmp == 0) {
#line 1350
      goto while_break;
    }
#line 1352
    ph = ph->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1355
  return (ph);
}
}
#line 1358 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
int ping_host_add(pingobj_t *obj , char const   *host ) 
{ 
  pinghost_t *ph ;
  struct addrinfo ai_hints ;
  struct addrinfo *ai_list ;
  struct addrinfo *ai_ptr ;
  int ai_return ;
  pinghost_t *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char errbuf[256] ;
  int *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char errmsg[256] ;
  int *tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  int status ;
  int opt ;
  int *tmp___17 ;
  char *old_hostname ;
  char *tmp___18 ;
  int tmp___19 ;
  int opt___0 ;
  int opt___1 ;
  pinghost_t *hptr ;

  {
#line 1366
  if ((unsigned long )obj == (unsigned long )((void *)0)) {
#line 1367
    return (-1);
  } else
#line 1366
  if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 1367
    return (-1);
  }
  {
#line 1371
  tmp = ping_host_search(obj->head, host);
  }
#line 1371
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 1372
    return (0);
  }
  {
#line 1374
  memset((void *)(& ai_hints), '\000', sizeof(ai_hints));
#line 1375
  ai_hints.ai_flags = 0;
#line 1377
  ai_hints.ai_flags |= 32;
#line 1380
  ai_hints.ai_flags |= 2;
#line 1382
  ai_hints.ai_family = obj->addrfamily;
#line 1383
  ai_hints.ai_socktype = 3;
#line 1385
  ph = ping_alloc();
  }
#line 1385
  if ((unsigned long )ph == (unsigned long )((void *)0)) {
#line 1388
    return (-1);
  }
  {
#line 1391
  tmp___1 = strdup(host);
#line 1391
  ph->username = tmp___1;
  }
#line 1391
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 1394
    tmp___0 = __errno_location();
#line 1394
    ping_set_errno(obj, *tmp___0);
#line 1395
    ping_free(ph);
    }
#line 1396
    return (-1);
  }
  {
#line 1399
  tmp___3 = strdup(host);
#line 1399
  ph->hostname = tmp___3;
  }
#line 1399
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
    {
#line 1402
    tmp___2 = __errno_location();
#line 1402
    ping_set_errno(obj, *tmp___2);
#line 1403
    ping_free(ph);
    }
#line 1404
    return (-1);
  }
#line 1408
  if ((unsigned long )obj->data == (unsigned long )((void *)0)) {
#line 1408
    tmp___6 = "liboping -- ICMP ping library <http://octo.it/liboping/>";
  } else {
#line 1408
    tmp___6 = (char const   *)obj->data;
  }
  {
#line 1408
  tmp___5 = strdup(tmp___6);
#line 1408
  ph->data = tmp___5;
  }
#line 1408
  if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
    {
#line 1411
    tmp___4 = __errno_location();
#line 1411
    ping_set_errno(obj, *tmp___4);
#line 1412
    ping_free(ph);
    }
#line 1413
    return (-1);
  }
  {
#line 1416
  ai_return = getaddrinfo((char const   */* __restrict  */)host, (char const   */* __restrict  */)((void *)0),
                          (struct addrinfo  const  */* __restrict  */)(& ai_hints),
                          (struct addrinfo **/* __restrict  */)(& ai_list));
  }
#line 1416
  if (ai_return != 0) {
#line 1422
    if (ai_return == -11) {
      {
#line 1422
      tmp___7 = __errno_location();
#line 1422
      tmp___8 = sstrerror(*tmp___7, errbuf, sizeof(errbuf));
#line 1422
      tmp___10 = (char const   *)tmp___8;
      }
    } else {
      {
#line 1422
      tmp___9 = gai_strerror(ai_return);
#line 1422
      tmp___10 = tmp___9;
      }
    }
    {
#line 1422
    ping_set_error(obj, "getaddrinfo", tmp___10);
#line 1428
    ping_free(ph);
    }
#line 1429
    return (-1);
  }
#line 1432
  if ((unsigned long )ai_list == (unsigned long )((void *)0)) {
    {
#line 1433
    ping_set_error(obj, "getaddrinfo", "No hosts returned");
    }
  }
#line 1435
  ai_ptr = ai_list;
  {
#line 1435
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1435
    if (! ((unsigned long )ai_ptr != (unsigned long )((void *)0))) {
#line 1435
      goto while_break;
    }
#line 1437
    ph->fd = -1;
#line 1439
    if (ai_ptr->ai_family == 2) {
#line 1441
      ai_ptr->ai_socktype = 3;
#line 1442
      ai_ptr->ai_protocol = 1;
    } else
#line 1444
    if (ai_ptr->ai_family == 10) {
#line 1446
      ai_ptr->ai_socktype = 3;
#line 1447
      ai_ptr->ai_protocol = 58;
    } else {
      {
#line 1453
      snprintf((char */* __restrict  */)(errmsg), (size_t )256, (char const   */* __restrict  */)"Unknown `ai_family\': %i",
               ai_ptr->ai_family);
#line 1454
      errmsg[255] = (char )'\000';
#line 1457
      ping_set_error(obj, "getaddrinfo", (char const   *)(errmsg));
      }
#line 1458
      goto __Cont;
    }
    {
#line 1463
    ph->fd = socket(ai_ptr->ai_family, ai_ptr->ai_socktype, ai_ptr->ai_protocol);
    }
#line 1464
    if (ph->fd == -1) {
      {
#line 1471
      tmp___11 = __errno_location();
#line 1471
      ping_set_errno(obj, *tmp___11);
      }
#line 1472
      goto __Cont;
    }
#line 1475
    if ((unsigned long )obj->srcaddr != (unsigned long )((void *)0)) {
#line 1477
      if (! (obj->srcaddrlen > 0U)) {
        {
#line 1477
        __assert_fail("obj->srcaddrlen > 0", "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c",
                      1477U, "ping_host_add");
        }
      }
#line 1478
      if (! ((unsigned long )obj->srcaddrlen <= sizeof(struct sockaddr_storage ))) {
        {
#line 1478
        __assert_fail("obj->srcaddrlen <= sizeof (struct sockaddr_storage)", "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c",
                      1478U, "ping_host_add");
        }
      }
      {
#line 1480
      tmp___13 = bind(ph->fd, (struct sockaddr  const  *)obj->srcaddr, obj->srcaddrlen);
      }
#line 1480
      if (tmp___13 == -1) {
        {
#line 1487
        tmp___12 = __errno_location();
#line 1487
        ping_set_errno(obj, *tmp___12);
#line 1488
        close(ph->fd);
#line 1489
        ph->fd = -1;
        }
#line 1490
        goto __Cont;
      }
    }
#line 1495
    if ((unsigned long )obj->device != (unsigned long )((void *)0)) {
      {
#line 1497
      tmp___15 = strlen((char const   *)obj->device);
#line 1497
      tmp___16 = setsockopt(ph->fd, 1, 25, (void const   *)obj->device, (socklen_t )(tmp___15 + 1UL));
      }
#line 1497
      if (tmp___16 != 0) {
        {
#line 1505
        tmp___14 = __errno_location();
#line 1505
        ping_set_errno(obj, *tmp___14);
#line 1506
        close(ph->fd);
#line 1507
        ph->fd = -1;
        }
#line 1508
        goto __Cont;
      }
    }
    {
#line 1516
    opt = 1;
#line 1518
    status = setsockopt(ph->fd, 1, 29, (void const   *)(& opt), (socklen_t )sizeof(opt));
    }
#line 1521
    if (status != 0) {
      {
#line 1528
      tmp___17 = __errno_location();
#line 1528
      ping_set_errno(obj, *tmp___17);
#line 1529
      close(ph->fd);
#line 1530
      ph->fd = -1;
      }
#line 1531
      goto __Cont;
    }
#line 1535
    if (! (sizeof(struct sockaddr_storage ) >= (unsigned long )ai_ptr->ai_addrlen)) {
      {
#line 1535
      __assert_fail("sizeof (struct sockaddr_storage) >= ai_ptr->ai_addrlen", "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c",
                    1535U, "ping_host_add");
      }
    }
    {
#line 1536
    memset((void *)ph->addr, '\000', sizeof(struct sockaddr_storage ));
#line 1537
    memcpy((void */* __restrict  */)ph->addr, (void const   */* __restrict  */)ai_ptr->ai_addr,
           (size_t )ai_ptr->ai_addrlen);
#line 1538
    ph->addrlen = ai_ptr->ai_addrlen;
#line 1539
    ph->addrfamily = ai_ptr->ai_family;
    }
#line 1542
    if ((unsigned long )ai_ptr->ai_canonname != (unsigned long )((void *)0)) {
      {
#line 1542
      tmp___19 = strcmp((char const   *)ph->hostname, (char const   *)ai_ptr->ai_canonname);
      }
#line 1542
      if (tmp___19 != 0) {
        {
#line 1550
        old_hostname = ph->hostname;
#line 1551
        tmp___18 = strdup((char const   *)ai_ptr->ai_canonname);
#line 1551
        ph->hostname = tmp___18;
        }
#line 1551
        if ((unsigned long )tmp___18 == (unsigned long )((void *)0)) {
#line 1554
          ph->hostname = old_hostname;
        } else
#line 1556
        if ((unsigned long )old_hostname != (unsigned long )((void *)0)) {
          {
#line 1558
          free((void *)old_hostname);
          }
        }
      }
    }
#line 1563
    if (ph->addrfamily == 2) {
      {
#line 1569
      opt___0 = 1;
#line 1570
      setsockopt(ph->fd, 0, 13, (void const   *)(& opt___0), (socklen_t )sizeof(opt___0));
#line 1575
      opt___0 = 1;
#line 1576
      setsockopt(ph->fd, 0, 12, (void const   *)(& opt___0), (socklen_t )sizeof(opt___0));
      }
    } else
#line 1580
    if (ph->addrfamily == 10) {
      {
#line 1586
      opt___1 = 1;
#line 1587
      setsockopt(ph->fd, 41, 51, (void const   *)(& opt___1), (socklen_t )sizeof(opt___1));
#line 1593
      opt___1 = 1;
#line 1594
      setsockopt(ph->fd, 41, 66, (void const   *)(& opt___1), (socklen_t )sizeof(opt___1));
      }
    }
#line 1600
    goto while_break;
    __Cont: /* CIL Label */ 
#line 1435
    ai_ptr = ai_ptr->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1603
  freeaddrinfo(ai_list);
  }
#line 1605
  if (ph->fd < 0) {
    {
#line 1607
    ping_free(ph);
    }
#line 1608
    return (-1);
  }
#line 1616
  if ((unsigned long )obj->head == (unsigned long )((void *)0)) {
#line 1618
    obj->head = ph;
  } else {
#line 1624
    hptr = obj->head;
    {
#line 1625
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1625
      if (! ((unsigned long )hptr->next != (unsigned long )((void *)0))) {
#line 1625
        goto while_break___0;
      }
#line 1626
      hptr = hptr->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1628
    if ((unsigned long )hptr != (unsigned long )((void *)0)) {
#line 1628
      if (! ((unsigned long )hptr->next == (unsigned long )((void *)0))) {
        {
#line 1628
        __assert_fail("(hptr != ((void *)0)) && (hptr->next == ((void *)0))", "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c",
                      1628U, "ping_host_add");
        }
      }
    } else {
      {
#line 1628
      __assert_fail("(hptr != ((void *)0)) && (hptr->next == ((void *)0))", "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c",
                    1628U, "ping_host_add");
      }
    }
#line 1629
    hptr->next = ph;
  }
  {
#line 1632
  ping_set_ttl(ph, obj->ttl);
#line 1633
  ping_set_qos(obj, ph, obj->qos);
  }
#line 1635
  return (0);
}
}
#line 1638 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
int ping_host_remove(pingobj_t *obj , char const   *host ) 
{ 
  pinghost_t *pre ;
  pinghost_t *cur ;
  int tmp ;

  {
#line 1642
  if ((unsigned long )obj == (unsigned long )((void *)0)) {
#line 1643
    return (-1);
  } else
#line 1642
  if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 1643
    return (-1);
  }
#line 1645
  pre = (pinghost_t *)((void *)0);
#line 1646
  cur = obj->head;
  {
#line 1648
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1648
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 1648
      goto while_break;
    }
    {
#line 1650
    tmp = strcasecmp(host, (char const   *)cur->username);
    }
#line 1650
    if (tmp == 0) {
#line 1651
      goto while_break;
    }
#line 1653
    pre = cur;
#line 1654
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1657
  if ((unsigned long )cur == (unsigned long )((void *)0)) {
    {
#line 1659
    ping_set_error(obj, "ping_host_remove", "Host not found");
    }
#line 1660
    return (-1);
  }
#line 1663
  if ((unsigned long )pre == (unsigned long )((void *)0)) {
#line 1664
    obj->head = cur->next;
  } else {
#line 1666
    pre->next = cur->next;
  }
  {
#line 1668
  ping_free(cur);
  }
#line 1670
  return (0);
}
}
#line 1673 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
pingobj_iter_t *ping_iterator_get(pingobj_t *obj ) 
{ 


  {
#line 1675
  if ((unsigned long )obj == (unsigned long )((void *)0)) {
#line 1676
    return ((pingobj_iter_t *)((void *)0));
  }
#line 1677
  return (obj->head);
}
}
#line 1680 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
pingobj_iter_t *ping_iterator_next(pingobj_iter_t *iter ) 
{ 


  {
#line 1682
  if ((unsigned long )iter == (unsigned long )((void *)0)) {
#line 1683
    return ((pingobj_iter_t *)((void *)0));
  }
#line 1684
  return (iter->next);
}
}
#line 1687 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
int ping_iterator_get_info(pingobj_iter_t *iter , int info , void *buffer , size_t *buffer_len ) 
{ 
  int ret ;
  size_t orig_buffer_len ;
  size_t tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;

  {
#line 1690
  ret = 22;
#line 1692
  orig_buffer_len = *buffer_len;
#line 1694
  if ((unsigned long )iter == (unsigned long )((void *)0)) {
#line 1695
    return (-1);
  } else
#line 1694
  if ((unsigned long )buffer_len == (unsigned long )((void *)0)) {
#line 1695
    return (-1);
  }
#line 1697
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 1697
    if (*buffer_len != 0UL) {
#line 1698
      return (-1);
    }
  }
  {
#line 1702
  if (info == 8) {
#line 1702
    goto case_8;
  }
#line 1714
  if (info == 1) {
#line 1714
    goto case_1;
  }
#line 1726
  if (info == 2) {
#line 1726
    goto case_2;
  }
#line 1750
  if (info == 3) {
#line 1750
    goto case_3;
  }
#line 1759
  if (info == 4) {
#line 1759
    goto case_4;
  }
#line 1768
  if (info == 9) {
#line 1768
    goto case_9;
  }
#line 1777
  if (info == 5) {
#line 1777
    goto case_5;
  }
#line 1786
  if (info == 6) {
#line 1786
    goto case_6;
  }
#line 1795
  if (info == 7) {
#line 1795
    goto case_7;
  }
#line 1804
  if (info == 10) {
#line 1804
    goto case_10;
  }
#line 1813
  if (info == 11) {
#line 1813
    goto case_11;
  }
#line 1700
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1703
  ret = 12;
#line 1704
  tmp = strlen((char const   *)iter->username);
#line 1704
  *buffer_len = tmp + 1UL;
  }
#line 1705
  if (orig_buffer_len <= *buffer_len) {
#line 1706
    goto switch_break;
  }
  {
#line 1710
  strncpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)iter->username,
          orig_buffer_len);
#line 1711
  ret = 0;
  }
#line 1712
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1715
  ret = 12;
#line 1716
  tmp___0 = strlen((char const   *)iter->hostname);
#line 1716
  *buffer_len = tmp___0 + 1UL;
  }
#line 1717
  if (orig_buffer_len < *buffer_len) {
#line 1718
    goto switch_break;
  }
  {
#line 1722
  strncpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)iter->hostname,
          orig_buffer_len);
#line 1723
  ret = 0;
  }
#line 1724
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1727
  ret = getnameinfo((struct sockaddr  const  */* __restrict  */)((struct sockaddr *)iter->addr),
                    iter->addrlen, (char */* __restrict  */)((char *)buffer), (socklen_t )*buffer_len,
                    (char */* __restrict  */)((void *)0), (socklen_t )0, 1);
  }
#line 1733
  if (ret != 0) {
#line 1735
    if (ret == -10) {
#line 1740
      ret = 12;
    } else
#line 1735
    if (ret == -12) {
#line 1740
      ret = 12;
    } else
#line 1742
    if (ret == -11) {
      {
#line 1743
      tmp___1 = __errno_location();
#line 1743
      ret = *tmp___1;
      }
    } else {
#line 1746
      ret = 22;
    }
  }
#line 1748
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1751
  ret = 12;
#line 1752
  *buffer_len = sizeof(int );
#line 1753
  if (orig_buffer_len < sizeof(int )) {
#line 1754
    goto switch_break;
  }
#line 1755
  *((int *)buffer) = iter->addrfamily;
#line 1756
  ret = 0;
#line 1757
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1760
  ret = 12;
#line 1761
  *buffer_len = sizeof(double );
#line 1762
  if (orig_buffer_len < sizeof(double )) {
#line 1763
    goto switch_break;
  }
#line 1764
  *((double *)buffer) = iter->latency;
#line 1765
  ret = 0;
#line 1766
  goto switch_break;
  case_9: /* CIL Label */ 
#line 1769
  ret = 12;
#line 1770
  *buffer_len = sizeof(uint32_t );
#line 1771
  if (orig_buffer_len < sizeof(uint32_t )) {
#line 1772
    goto switch_break;
  }
#line 1773
  *((uint32_t *)buffer) = iter->dropped;
#line 1774
  ret = 0;
#line 1775
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1778
  ret = 12;
#line 1779
  *buffer_len = sizeof(unsigned int );
#line 1780
  if (orig_buffer_len < sizeof(unsigned int )) {
#line 1781
    goto switch_break;
  }
#line 1782
  *((unsigned int *)buffer) = (unsigned int )iter->sequence;
#line 1783
  ret = 0;
#line 1784
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1787
  ret = 12;
#line 1788
  *buffer_len = sizeof(uint16_t );
#line 1789
  if (orig_buffer_len < sizeof(uint16_t )) {
#line 1790
    goto switch_break;
  }
#line 1791
  *((uint16_t *)buffer) = (uint16_t )iter->ident;
#line 1792
  ret = 0;
#line 1793
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1796
  ret = 12;
#line 1797
  *buffer_len = strlen((char const   *)iter->data);
  }
#line 1798
  if (orig_buffer_len < *buffer_len) {
#line 1799
    goto switch_break;
  }
  {
#line 1800
  strncpy((char */* __restrict  */)((char *)buffer), (char const   */* __restrict  */)iter->data,
          orig_buffer_len);
#line 1801
  ret = 0;
  }
#line 1802
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1805
  ret = 12;
#line 1806
  *buffer_len = sizeof(int );
#line 1807
  if (orig_buffer_len < sizeof(int )) {
#line 1808
    goto switch_break;
  }
#line 1809
  *((int *)buffer) = iter->recv_ttl;
#line 1810
  ret = 0;
#line 1811
  goto switch_break;
  case_11: /* CIL Label */ 
#line 1814
  ret = 12;
#line 1815
  if (*buffer_len > sizeof(unsigned int )) {
#line 1815
    *buffer_len = sizeof(unsigned int );
  }
#line 1816
  if (! *buffer_len) {
#line 1816
    *buffer_len = (size_t )1;
  }
#line 1817
  if (orig_buffer_len < *buffer_len) {
#line 1818
    goto switch_break;
  }
  {
#line 1819
  memcpy((void */* __restrict  */)buffer, (void const   */* __restrict  */)(& iter->recv_qos),
         *buffer_len);
#line 1820
  ret = 0;
  }
#line 1821
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1824
  return (ret);
}
}
#line 1827 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
void *ping_iterator_get_context(pingobj_iter_t *iter ) 
{ 


  {
#line 1829
  if ((unsigned long )iter == (unsigned long )((void *)0)) {
#line 1830
    return ((void *)0);
  }
#line 1831
  return (iter->context);
}
}
#line 1834 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
void ping_iterator_set_context(pingobj_iter_t *iter , void *context ) 
{ 


  {
#line 1836
  if ((unsigned long )iter == (unsigned long )((void *)0)) {
#line 1837
    return;
  }
#line 1838
  iter->context = context;
#line 1839
  return;
}
}
#line 156 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static char *sstrerror___0(int errnum , char *buf , size_t buflen ) 
{ 
  int tmp ;

  {
  {
#line 158
  *(buf + 0) = (char)0;
#line 182
  tmp = strerror_r(errnum, buf, buflen);
  }
#line 182
  if (tmp != 0) {
    {
#line 184
    snprintf((char */* __restrict  */)buf, buflen, (char const   */* __restrict  */)"Error %i (%#x); Additionally, strerror_r failed.",
             errnum, errnum);
    }
  }
#line 190
  *(buf + (buflen - 1UL)) = (char)0;
#line 192
  return (buf);
}
}
#line 195 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static void ping_set_error___0(pingobj_t *obj , char const   *function , char const   *message ) 
{ 


  {
  {
#line 198
  snprintf((char */* __restrict  */)(obj->errmsg), sizeof(obj->errmsg), (char const   */* __restrict  */)"%s: %s",
           function, message);
#line 200
  obj->errmsg[sizeof(obj->errmsg) - 1UL] = (char)0;
  }
#line 201
  return;
}
}
#line 203 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static void ping_set_errno___0(pingobj_t *obj , int error_number ) 
{ 


  {
  {
#line 205
  sstrerror___0(error_number, obj->errmsg, sizeof(obj->errmsg));
  }
#line 206
  return;
}
}
#line 208 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_timeval_add___0(struct timeval *tv1 , struct timeval *tv2 , struct timeval *res ) 
{ 


  {
#line 211
  res->tv_sec = tv1->tv_sec + tv2->tv_sec;
#line 212
  res->tv_usec = tv1->tv_usec + tv2->tv_usec;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! (res->tv_usec > 1000000L)) {
#line 214
      goto while_break;
    }
#line 216
    res->tv_usec -= 1000000L;
#line 217
    (res->tv_sec) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return (0);
}
}
#line 223 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_timeval_sub___0(struct timeval *tv1 , struct timeval *tv2 , struct timeval *res ) 
{ 


  {
#line 226
  if (tv1->tv_sec < tv2->tv_sec) {
#line 229
    return (-1);
  } else
#line 226
  if (tv1->tv_sec == tv2->tv_sec) {
#line 226
    if (tv1->tv_usec < tv2->tv_usec) {
#line 229
      return (-1);
    }
  }
#line 231
  res->tv_sec = tv1->tv_sec - tv2->tv_sec;
#line 232
  res->tv_usec = tv1->tv_usec - tv2->tv_usec;
#line 234
  if (! (res->tv_sec > 0L)) {
#line 234
    if (res->tv_sec == 0L) {
#line 234
      if (! (res->tv_usec >= 0L)) {
        {
#line 234
        __assert_fail("(res->tv_sec > 0) || ((res->tv_sec == 0) && (res->tv_usec >= 0))",
                      "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c",
                      234U, "ping_timeval_sub");
        }
      }
    } else {
      {
#line 234
      __assert_fail("(res->tv_sec > 0) || ((res->tv_sec == 0) && (res->tv_usec >= 0))",
                    "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c", 234U,
                    "ping_timeval_sub");
      }
    }
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! (res->tv_usec < 0L)) {
#line 236
      goto while_break;
    }
#line 238
    res->tv_usec += 1000000L;
#line 239
    (res->tv_sec) --;
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  return (0);
}
}
#line 245 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static uint16_t ping_icmp4_checksum___0(char *buf , size_t len ) 
{ 
  uint32_t sum ;
  uint16_t ret ;
  uint16_t *ptr ;

  {
#line 247
  sum = (uint32_t )0;
#line 248
  ret = (uint16_t )0;
#line 252
  ptr = (uint16_t *)buf;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! (len > 1UL)) {
#line 252
      goto while_break;
    }
#line 253
    sum += (uint32_t )*ptr;
#line 252
    ptr ++;
#line 252
    len -= 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  if (len == 1UL) {
#line 257
    *((char *)(& ret)) = *((char *)ptr);
#line 258
    sum += (uint32_t )ret;
  }
#line 262
  sum = (sum >> 16) + (sum & 65535U);
#line 263
  sum = (sum >> 16) + (sum & 65535U);
#line 265
  ret = (uint16_t )(~ sum);
#line 267
  return (ret);
}
}
#line 270 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static pinghost_t *ping_receive_ipv4___0(pingobj_t *obj , char *buffer , size_t buffer_len ) 
{ 
  struct ip *ip_hdr ;
  struct icmp *icmp_hdr ;
  size_t ip_hdr_len ;
  uint16_t recv_checksum ;
  uint16_t calc_checksum ;
  uint16_t ident ;
  uint16_t seq ;
  pinghost_t *ptr ;

  {
#line 286
  if (buffer_len < sizeof(struct ip )) {
#line 287
    return ((pinghost_t *)((void *)0));
  }
#line 289
  ip_hdr = (struct ip *)buffer;
#line 290
  ip_hdr_len = (size_t )(ip_hdr->ip_hl << 2);
#line 292
  if (buffer_len < ip_hdr_len) {
#line 293
    return ((pinghost_t *)((void *)0));
  }
#line 295
  buffer += ip_hdr_len;
#line 296
  buffer_len -= ip_hdr_len;
#line 298
  if (buffer_len < sizeof(struct icmp )) {
#line 299
    return ((pinghost_t *)((void *)0));
  }
#line 301
  icmp_hdr = (struct icmp *)buffer;
#line 302
  buffer += sizeof(struct icmp );
#line 303
  buffer_len -= sizeof(struct icmp );
#line 305
  if ((int )icmp_hdr->icmp_type != 0) {
#line 308
    return ((pinghost_t *)((void *)0));
  }
  {
#line 311
  recv_checksum = icmp_hdr->icmp_cksum;
#line 312
  icmp_hdr->icmp_cksum = (u_int16_t )0;
#line 313
  calc_checksum = ping_icmp4_checksum___0((char *)icmp_hdr, sizeof(struct icmp ) + buffer_len);
  }
#line 316
  if ((int )recv_checksum != (int )calc_checksum) {
#line 321
    return ((pinghost_t *)((void *)0));
  }
  {
#line 324
  ident = ntohs(icmp_hdr->icmp_hun.ih_idseq.icd_id);
#line 325
  seq = ntohs(icmp_hdr->icmp_hun.ih_idseq.icd_seq);
#line 329
  ptr = obj->head;
  }
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 329
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 329
      goto while_break;
    }
#line 334
    if (ptr->addrfamily != 2) {
#line 335
      goto __Cont;
    }
#line 337
    if (! (ptr->timer)->tv_sec) {
#line 337
      if (! (ptr->timer)->tv_usec) {
#line 338
        goto __Cont;
      }
    }
#line 340
    if (ptr->ident != (int )ident) {
#line 341
      goto __Cont;
    }
#line 343
    if (((ptr->sequence - 1) & 65535) != (int )seq) {
#line 344
      goto __Cont;
    }
#line 350
    goto while_break;
    __Cont: /* CIL Label */ 
#line 329
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 359
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 360
    ptr->recv_ttl = (int )ip_hdr->ip_ttl;
#line 361
    ptr->recv_qos = ip_hdr->ip_tos;
  }
#line 363
  return (ptr);
}
}
#line 382 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static pinghost_t *ping_receive_ipv6___0(pingobj_t *obj , char *buffer , size_t buffer_len ) 
{ 
  struct icmp6_hdr *icmp_hdr ;
  uint16_t ident ;
  uint16_t seq ;
  pinghost_t *ptr ;

  {
#line 392
  if (buffer_len < sizeof(struct icmp6_hdr )) {
#line 393
    return ((pinghost_t *)((void *)0));
  }
#line 395
  icmp_hdr = (struct icmp6_hdr *)buffer;
#line 396
  buffer += sizeof(struct icmp );
#line 397
  buffer_len -= sizeof(struct icmp );
#line 399
  if ((int )icmp_hdr->icmp6_type != 129) {
#line 402
    return ((pinghost_t *)((void *)0));
  }
#line 405
  if ((int )icmp_hdr->icmp6_code != 0) {
#line 408
    return ((pinghost_t *)((void *)0));
  }
  {
#line 411
  ident = ntohs(icmp_hdr->icmp6_dataun.icmp6_un_data16[0]);
#line 412
  seq = ntohs(icmp_hdr->icmp6_dataun.icmp6_un_data16[1]);
#line 416
  ptr = obj->head;
  }
  {
#line 416
  while (1) {
    while_continue: /* CIL Label */ ;
#line 416
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 416
      goto while_break;
    }
#line 421
    if (ptr->addrfamily != 10) {
#line 422
      goto __Cont;
    }
#line 424
    if (! (ptr->timer)->tv_sec) {
#line 424
      if (! (ptr->timer)->tv_usec) {
#line 425
        goto __Cont;
      }
    }
#line 427
    if (ptr->ident != (int )ident) {
#line 428
      goto __Cont;
    }
#line 430
    if (((ptr->sequence - 1) & 65535) != (int )seq) {
#line 431
      goto __Cont;
    }
#line 437
    goto while_break;
    __Cont: /* CIL Label */ 
#line 416
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 447
  return (ptr);
}
}
#line 450 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_receive_one___0(pingobj_t *obj , pinghost_t const   *ph , struct timeval *now ) 
{ 
  struct timeval diff ;
  struct timeval pkt_now ;
  pinghost_t *host ;
  int recv_ttl ;
  uint8_t recv_qos ;
  struct msghdr msghdr ;
  struct cmsghdr *cmsg ;
  char payload_buffer[4096] ;
  ssize_t payload_buffer_len ;
  char control_buffer[4096] ;
  struct iovec payload_iovec ;
  __suseconds_t tmp ;
  int tmp___0 ;
  __suseconds_t tmp___1 ;

  {
  {
#line 457
  pkt_now = *now;
#line 458
  host = (pinghost_t *)((void *)0);
#line 472
  memset((void *)(& payload_iovec), 0, sizeof(payload_iovec));
#line 473
  payload_iovec.iov_base = (void *)(payload_buffer);
#line 474
  payload_iovec.iov_len = sizeof(payload_buffer);
#line 476
  memset((void *)(& msghdr), 0, sizeof(msghdr));
#line 478
  msghdr.msg_name = (void *)0;
#line 479
  msghdr.msg_namelen = (socklen_t )0;
#line 481
  msghdr.msg_iov = & payload_iovec;
#line 482
  msghdr.msg_iovlen = (size_t )1;
#line 484
  msghdr.msg_control = (void *)(control_buffer);
#line 485
  msghdr.msg_controllen = sizeof(control_buffer);
#line 487
  msghdr.msg_flags = 0;
#line 492
  payload_buffer_len = recvmsg((int )ph->fd, & msghdr, 0);
  }
#line 493
  if (payload_buffer_len < 0L) {
#line 500
    return (-1);
  }
#line 505
  recv_ttl = -1;
#line 506
  recv_qos = (uint8_t )0;
#line 507
  if (msghdr.msg_controllen >= sizeof(struct cmsghdr )) {
#line 507
    cmsg = (struct cmsghdr *)msghdr.msg_control;
  } else {
#line 507
    cmsg = (struct cmsghdr *)0;
  }
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;
#line 507
    if (! ((unsigned long )cmsg != (unsigned long )((void *)0))) {
#line 507
      goto while_break;
    }
#line 511
    if (cmsg->cmsg_level == 1) {
#line 514
      if (cmsg->cmsg_type == 29) {
        {
#line 515
        memcpy((void */* __restrict  */)(& pkt_now), (void const   */* __restrict  */)(cmsg->__cmsg_data),
               sizeof(pkt_now));
        }
      }
    } else
#line 518
    if (ph->addrfamily == 2) {
#line 520
      if (cmsg->cmsg_level != 0) {
#line 521
        goto __Cont;
      }
#line 523
      if (cmsg->cmsg_type == 1) {
        {
#line 525
        memcpy((void */* __restrict  */)(& recv_qos), (void const   */* __restrict  */)(cmsg->__cmsg_data),
               sizeof(recv_qos));
        }
      } else
#line 529
      if (cmsg->cmsg_type == 2) {
        {
#line 531
        memcpy((void */* __restrict  */)(& recv_ttl), (void const   */* __restrict  */)(cmsg->__cmsg_data),
               sizeof(recv_ttl));
        }
      }
    } else
#line 541
    if (ph->addrfamily == 10) {
#line 543
      if (cmsg->cmsg_level != 41) {
#line 544
        goto __Cont;
      }
#line 546
      if (cmsg->cmsg_type == 67) {
        {
#line 548
        memcpy((void */* __restrict  */)(& recv_qos), (void const   */* __restrict  */)(cmsg->__cmsg_data),
               sizeof(recv_qos));
        }
      } else
#line 553
      if (cmsg->cmsg_type == 52) {
        {
#line 555
        memcpy((void */* __restrict  */)(& recv_ttl), (void const   */* __restrict  */)(cmsg->__cmsg_data),
               sizeof(recv_ttl));
        }
      } else
#line 562
      if (cmsg->cmsg_type == 16) {
        {
#line 564
        memcpy((void */* __restrict  */)(& recv_ttl), (void const   */* __restrict  */)(cmsg->__cmsg_data),
               sizeof(recv_ttl));
        }
      } else
#line 571
      if (cmsg->cmsg_type == 18) {
        {
#line 573
        memcpy((void */* __restrict  */)(& recv_ttl), (void const   */* __restrict  */)(cmsg->__cmsg_data),
               sizeof(recv_ttl));
        }
      }
    }
    __Cont: /* CIL Label */ 
    {
#line 507
    cmsg = __cmsg_nxthdr(& msghdr, cmsg);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 592
  if (ph->addrfamily == 2) {
    {
#line 594
    host = ping_receive_ipv4___0(obj, payload_buffer, (size_t )payload_buffer_len);
    }
#line 595
    if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 596
      return (-1);
    }
  } else
#line 598
  if (ph->addrfamily == 10) {
    {
#line 600
    host = ping_receive_ipv6___0(obj, payload_buffer, (size_t )payload_buffer_len);
    }
#line 601
    if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 602
      return (-1);
    }
  } else {
#line 608
    return (-1);
  }
  {
#line 618
  tmp___0 = ping_timeval_sub___0(& pkt_now, host->timer, & diff);
  }
#line 618
  if (tmp___0 < 0) {
#line 620
    tmp = (__suseconds_t )0;
#line 620
    (host->timer)->tv_usec = tmp;
#line 620
    (host->timer)->tv_sec = tmp;
#line 621
    return (-1);
  }
#line 628
  if (recv_ttl >= 0) {
#line 629
    host->recv_ttl = recv_ttl;
  }
#line 630
  host->recv_qos = recv_qos;
#line 632
  host->latency = (double )diff.tv_usec / 1000.0;
#line 633
  host->latency += (double )diff.tv_sec * 1000.0;
#line 635
  tmp___1 = (__suseconds_t )0;
#line 635
  (host->timer)->tv_usec = tmp___1;
#line 635
  (host->timer)->tv_sec = tmp___1;
#line 637
  return (0);
}
}
#line 640 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_receive_all___0(pingobj_t *obj ) 
{ 
  fd_set read_fds ;
  fd_set err_fds ;
  int num_fds ;
  int max_fd ;
  pinghost_t *ph ;
  pinghost_t *ptr ;
  struct timeval endtime ;
  struct timeval nowtime ;
  struct timeval timeout ;
  int status ;
  int ret ;
  int *tmp ;
  int tmp___0 ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  __suseconds_t tmp___8 ;

  {
#line 657
  ph = obj->head;
#line 658
  ret = 0;
#line 660
  ptr = ph;
  {
#line 660
  while (1) {
    while_continue: /* CIL Label */ ;
#line 660
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 660
      goto while_break;
    }
#line 662
    ptr->latency = - 1.0;
#line 663
    ptr->recv_ttl = -1;
#line 660
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 666
  tmp___0 = gettimeofday((struct timeval */* __restrict  */)(& nowtime), (__timezone_ptr_t )((void *)0));
  }
#line 666
  if (tmp___0 == -1) {
    {
#line 668
    tmp = __errno_location();
#line 668
    ping_set_errno___0(obj, *tmp);
    }
#line 669
    return (-1);
  }
  {
#line 673
  timeout.tv_sec = (time_t )obj->timeout;
#line 674
  timeout.tv_usec = (suseconds_t )((double )1000000 * (obj->timeout - (double )timeout.tv_sec));
#line 680
  ping_timeval_add___0(& nowtime, & timeout, & endtime);
  }
  {
#line 682
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 684
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 684
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& read_fds.__fds_bits[0]): "memory");
#line 684
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 685
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 685
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& err_fds.__fds_bits[0]): "memory");
#line 685
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 686
    num_fds = 0;
#line 687
    max_fd = -1;
#line 689
    ptr = ph;
    {
#line 689
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 689
      if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 689
        goto while_break___3;
      }
#line 691
      if (! (ptr->timer)->tv_sec) {
#line 691
        if (! (ptr->timer)->tv_usec) {
#line 692
          goto __Cont;
        }
      }
#line 694
      read_fds.__fds_bits[ptr->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ptr->fd % (8 * (int )sizeof(__fd_mask ));
#line 695
      err_fds.__fds_bits[ptr->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ptr->fd % (8 * (int )sizeof(__fd_mask ));
#line 696
      num_fds ++;
#line 698
      if (max_fd < ptr->fd) {
#line 699
        max_fd = ptr->fd;
      }
      __Cont: /* CIL Label */ 
#line 689
      ptr = ptr->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 702
    if (num_fds == 0) {
#line 703
      goto while_break___0;
    }
    {
#line 705
    tmp___2 = gettimeofday((struct timeval */* __restrict  */)(& nowtime), (__timezone_ptr_t )((void *)0));
    }
#line 705
    if (tmp___2 == -1) {
      {
#line 707
      tmp___1 = __errno_location();
#line 707
      ping_set_errno___0(obj, *tmp___1);
      }
#line 708
      return (-1);
    }
    {
#line 711
    tmp___3 = ping_timeval_sub___0(& endtime, & nowtime, & timeout);
    }
#line 711
    if (tmp___3 == -1) {
#line 712
      goto while_break___0;
    }
    {
#line 718
    status = select(max_fd + 1, (fd_set */* __restrict  */)(& read_fds), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)(& err_fds), (struct timeval */* __restrict  */)(& timeout));
#line 720
    tmp___5 = gettimeofday((struct timeval */* __restrict  */)(& nowtime), (__timezone_ptr_t )((void *)0));
    }
#line 720
    if (tmp___5 == -1) {
      {
#line 722
      tmp___4 = __errno_location();
#line 722
      ping_set_errno___0(obj, *tmp___4);
      }
#line 723
      return (-1);
    }
#line 726
    if (status == -1) {
      {
#line 726
      tmp___6 = __errno_location();
      }
#line 726
      if (*tmp___6 == 4) {
#line 729
        goto while_continue___0;
      } else {
#line 726
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 731
    if (status < 0) {
#line 738
      goto while_break___0;
    } else
#line 740
    if (status == 0) {
#line 743
      ptr = ph;
      {
#line 743
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 743
        if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 743
          goto while_break___4;
        }
#line 744
        if (ptr->latency < 0.0) {
#line 745
          (ptr->dropped) ++;
        }
#line 743
        ptr = ptr->next;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 746
      goto while_break___0;
    }
#line 749
    ptr = ph;
    {
#line 749
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 749
      if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 749
        goto while_break___5;
      }
#line 751
      if ((read_fds.__fds_bits[ptr->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << ptr->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 753
        tmp___7 = ping_receive_one___0(obj, (pinghost_t const   *)ptr, & nowtime);
        }
#line 753
        if (tmp___7 == 0) {
#line 754
          ret ++;
        }
      } else
#line 756
      if ((err_fds.__fds_bits[ptr->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << ptr->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 761
        tmp___8 = (__suseconds_t )0;
#line 761
        (ptr->timer)->tv_usec = tmp___8;
#line 761
        (ptr->timer)->tv_sec = tmp___8;
      }
#line 749
      ptr = ptr->next;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 766
  return (ret);
}
}
#line 776 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static ssize_t ping_sendto___0(pingobj_t *obj , pinghost_t *ph , void const   *buf ,
                               size_t buflen ) 
{ 
  ssize_t ret ;
  __suseconds_t tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 781
  tmp___0 = gettimeofday((struct timeval */* __restrict  */)ph->timer, (__timezone_ptr_t )((void *)0));
  }
#line 781
  if (tmp___0 == -1) {
#line 783
    tmp = (__suseconds_t )0;
#line 783
    (ph->timer)->tv_usec = tmp;
#line 783
    (ph->timer)->tv_sec = tmp;
#line 784
    return ((ssize_t )-1);
  }
  {
#line 787
  ret = sendto(ph->fd, buf, buflen, 0, (struct sockaddr  const  *)((struct sockaddr *)ph->addr),
               ph->addrlen);
  }
#line 790
  if (ret < 0L) {
    {
#line 793
    tmp___1 = __errno_location();
    }
#line 793
    if (*tmp___1 == 113) {
#line 794
      return ((ssize_t )0);
    }
    {
#line 797
    tmp___2 = __errno_location();
    }
#line 797
    if (*tmp___2 == 101) {
#line 798
      return ((ssize_t )0);
    }
    {
#line 800
    tmp___3 = __errno_location();
#line 800
    ping_set_errno___0(obj, *tmp___3);
    }
  }
#line 803
  return (ret);
}
}
#line 806 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_send_one_ipv4___0(pingobj_t *obj , pinghost_t *ph ) 
{ 
  struct icmp *icmp4 ;
  int status ;
  char buf[4096] ;
  int buflen ;
  char *data ;
  int datalen ;
  size_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 819
  memset((void *)(buf), '\000', sizeof(buf));
#line 820
  icmp4 = (struct icmp *)(buf);
#line 821
  data = (char *)(icmp4 + 1);
#line 823
  icmp4->icmp_type = (u_int8_t )8;
#line 824
  icmp4->icmp_code = (u_int8_t )0;
#line 825
  icmp4->icmp_cksum = (u_int16_t )0;
#line 826
  icmp4->icmp_hun.ih_idseq.icd_id = htons((uint16_t )ph->ident);
#line 827
  icmp4->icmp_hun.ih_idseq.icd_seq = htons((uint16_t )ph->sequence);
#line 829
  buflen = (int )(4096UL - sizeof(struct icmp ));
#line 830
  strncpy((char */* __restrict  */)data, (char const   */* __restrict  */)ph->data,
          (size_t )buflen);
#line 831
  tmp = strlen((char const   *)data);
#line 831
  datalen = (int )tmp;
#line 833
  buflen = (int )((unsigned long )datalen + sizeof(struct icmp ));
#line 835
  icmp4->icmp_cksum = ping_icmp4_checksum___0(buf, (size_t )buflen);
#line 839
  tmp___0 = ping_sendto___0(obj, ph, (void const   *)(buf), (size_t )buflen);
#line 839
  status = (int )tmp___0;
  }
#line 840
  if (status < 0) {
    {
#line 842
    perror("ping_sendto");
    }
#line 843
    return (-1);
  }
#line 848
  return (0);
}
}
#line 851 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_send_one_ipv6___0(pingobj_t *obj , pinghost_t *ph ) 
{ 
  struct icmp6_hdr *icmp6 ;
  int status ;
  char buf[4096] ;
  int buflen ;
  char *data ;
  int datalen ;
  size_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 864
  memset((void *)(buf), '\000', sizeof(buf));
#line 865
  icmp6 = (struct icmp6_hdr *)(buf);
#line 866
  data = (char *)(icmp6 + 1);
#line 868
  icmp6->icmp6_type = (uint8_t )128;
#line 869
  icmp6->icmp6_code = (uint8_t )0;
#line 872
  icmp6->icmp6_cksum = (uint16_t )0;
#line 873
  icmp6->icmp6_dataun.icmp6_un_data16[0] = htons((uint16_t )ph->ident);
#line 874
  icmp6->icmp6_dataun.icmp6_un_data16[1] = htons((uint16_t )ph->sequence);
#line 876
  buflen = (int )(4096UL - sizeof(struct icmp6_hdr ));
#line 877
  strncpy((char */* __restrict  */)data, (char const   */* __restrict  */)ph->data,
          (size_t )buflen);
#line 878
  tmp = strlen((char const   *)data);
#line 878
  datalen = (int )tmp;
#line 880
  buflen = (int )((unsigned long )datalen + sizeof(struct icmp6_hdr ));
#line 884
  tmp___0 = ping_sendto___0(obj, ph, (void const   *)(buf), (size_t )buflen);
#line 884
  status = (int )tmp___0;
  }
#line 885
  if (status < 0) {
    {
#line 887
    perror("ping_sendto");
    }
#line 888
    return (-1);
  }
#line 893
  return (0);
}
}
#line 896 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_send_all___0(pingobj_t *obj ) 
{ 
  pinghost_t *ph ;
  pinghost_t *ptr ;
  int ret ;
  __suseconds_t tmp ;
  int tmp___0 ;
  __suseconds_t tmp___1 ;
  int tmp___2 ;
  __suseconds_t tmp___3 ;
  int tmp___4 ;
  __suseconds_t tmp___5 ;

  {
#line 903
  ret = 0;
#line 904
  ph = obj->head;
#line 906
  ptr = ph;
  {
#line 906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 906
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 906
      goto while_break;
    }
    {
#line 910
    tmp___0 = gettimeofday((struct timeval */* __restrict  */)ptr->timer, (__timezone_ptr_t )((void *)0));
    }
#line 910
    if (tmp___0 == -1) {
#line 917
      tmp = (__suseconds_t )0;
#line 917
      (ptr->timer)->tv_usec = tmp;
#line 917
      (ptr->timer)->tv_sec = tmp;
#line 918
      ret --;
#line 919
      goto __Cont;
    }
#line 926
    if (ptr->addrfamily == 10) {
      {
#line 929
      tmp___2 = ping_send_one_ipv6___0(obj, ptr);
      }
#line 929
      if (tmp___2 != 0) {
#line 931
        tmp___1 = (__suseconds_t )0;
#line 931
        (ptr->timer)->tv_usec = tmp___1;
#line 931
        (ptr->timer)->tv_sec = tmp___1;
#line 932
        ret --;
#line 933
        goto __Cont;
      }
    } else
#line 936
    if (ptr->addrfamily == 2) {
      {
#line 939
      tmp___4 = ping_send_one_ipv4___0(obj, ptr);
      }
#line 939
      if (tmp___4 != 0) {
#line 941
        tmp___3 = (__suseconds_t )0;
#line 941
        (ptr->timer)->tv_usec = tmp___3;
#line 941
        (ptr->timer)->tv_sec = tmp___3;
#line 942
        ret --;
#line 943
        goto __Cont;
      }
    } else {
#line 949
      tmp___5 = (__suseconds_t )0;
#line 949
      (ptr->timer)->tv_usec = tmp___5;
#line 949
      (ptr->timer)->tv_sec = tmp___5;
#line 950
      ret --;
#line 951
      goto __Cont;
    }
#line 954
    (ptr->sequence) ++;
    __Cont: /* CIL Label */ 
#line 906
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  return (ret);
}
}
#line 963 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_set_ttl___0(pinghost_t *ph , int ttl ) 
{ 
  int ret ;

  {
#line 965
  ret = -2;
#line 967
  if (ph->addrfamily == 2) {
    {
#line 970
    ret = setsockopt(ph->fd, 0, 2, (void const   *)(& ttl), (socklen_t )sizeof(ttl));
    }
  } else
#line 973
  if (ph->addrfamily == 10) {
    {
#line 976
    ret = setsockopt(ph->fd, 41, 16, (void const   *)(& ttl), (socklen_t )sizeof(ttl));
    }
  }
#line 980
  return (ret);
}
}
#line 989 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_set_qos___0(pingobj_t *obj , pinghost_t *ph , uint8_t qos ) 
{ 
  int ret ;
  char errbuf[256] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 991
  ret = 22;
#line 994
  if (ph->addrfamily == 2) {
    {
#line 997
    ret = setsockopt(ph->fd, 0, 1, (void const   *)(& qos), (socklen_t )sizeof(qos));
    }
#line 999
    if (ret != 0) {
      {
#line 1001
      tmp = __errno_location();
#line 1001
      ret = *tmp;
#line 1002
      tmp___0 = sstrerror___0(ret, errbuf, sizeof(errbuf));
#line 1002
      ping_set_error___0(obj, "ping_set_qos", (char const   *)tmp___0);
      }
    }
  } else
#line 1007
  if (ph->addrfamily == 10) {
    {
#line 1010
    tmp___1 = (int )qos;
#line 1013
    ret = setsockopt(ph->fd, 41, 67, (void const   *)(& tmp___1), (socklen_t )sizeof(tmp___1));
    }
#line 1015
    if (ret != 0) {
      {
#line 1017
      tmp___2 = __errno_location();
#line 1017
      ret = *tmp___2;
#line 1018
      tmp___3 = sstrerror___0(ret, errbuf, sizeof(errbuf));
#line 1018
      ping_set_error___0(obj, "ping_set_qos", (char const   *)tmp___3);
      }
    }
  }
#line 1024
  return (ret);
}
}
#line 1030
static int ping_get_ident___0(void) ;
#line 1030 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int did_seed___0  =    0;
#line 1027 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_get_ident___0(void) 
{ 
  int fd ;
  int retval ;
  unsigned int seed ;
  ssize_t tmp ;
  long tmp___0 ;

  {
#line 1034
  if (did_seed___0 == 0) {
    {
#line 1036
    fd = open("/dev/urandom", 0);
    }
#line 1036
    if (fd != -1) {
      {
#line 1040
      tmp = read(fd, (void *)(& seed), sizeof(seed));
      }
#line 1040
      if (tmp != -1L) {
        {
#line 1042
        did_seed___0 = 1;
#line 1044
        srandom(seed);
        }
      }
      {
#line 1047
      close(fd);
      }
    }
  }
  {
#line 1059
  tmp___0 = random();
#line 1059
  retval = (int )tmp___0;
  }
#line 1063
  return (retval);
}
}
#line 1066 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static pinghost_t *ping_alloc___0(void) 
{ 
  pinghost_t *ph ;
  size_t ph_size ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 1071
  ph_size = (sizeof(pinghost_t ) + sizeof(struct sockaddr_storage )) + sizeof(struct timeval );
#line 1075
  tmp = malloc(ph_size);
#line 1075
  ph = (pinghost_t *)tmp;
  }
#line 1076
  if ((unsigned long )ph == (unsigned long )((void *)0)) {
#line 1077
    return ((pinghost_t *)((void *)0));
  }
  {
#line 1079
  memset((void *)ph, '\000', ph_size);
#line 1081
  ph->timer = (struct timeval *)(ph + 1);
#line 1082
  ph->addr = (struct sockaddr_storage *)(ph->timer + 1);
#line 1084
  ph->addrlen = (socklen_t )sizeof(struct sockaddr_storage );
#line 1085
  ph->fd = -1;
#line 1086
  ph->latency = - 1.0;
#line 1087
  ph->dropped = (uint32_t )0;
#line 1088
  tmp___0 = ping_get_ident___0();
#line 1088
  ph->ident = tmp___0 & 65535;
  }
#line 1090
  return (ph);
}
}
#line 1093 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static void ping_free___0(pinghost_t *ph ) 
{ 


  {
#line 1095
  if (ph->fd >= 0) {
    {
#line 1096
    close(ph->fd);
    }
  }
#line 1098
  if ((unsigned long )ph->username != (unsigned long )((void *)0)) {
    {
#line 1099
    free((void *)ph->username);
    }
  }
#line 1101
  if ((unsigned long )ph->hostname != (unsigned long )((void *)0)) {
    {
#line 1102
    free((void *)ph->hostname);
    }
  }
#line 1104
  if ((unsigned long )ph->data != (unsigned long )((void *)0)) {
    {
#line 1105
    free((void *)ph->data);
    }
  }
  {
#line 1107
  free((void *)ph);
  }
#line 1108
  return;
}
}
#line 1345 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static pinghost_t *ping_host_search___0(pinghost_t *ph , char const   *host ) 
{ 
  int tmp ;

  {
  {
#line 1347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1347
    if (! ((unsigned long )ph != (unsigned long )((void *)0))) {
#line 1347
      goto while_break;
    }
    {
#line 1349
    tmp = strcasecmp((char const   *)ph->username, host);
    }
#line 1349
    if (tmp == 0) {
#line 1350
      goto while_break;
    }
#line 1352
    ph = ph->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1355
  return (ph);
}
}
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 164
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 187
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 675 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 710
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) seteuid)(__uid_t __uid ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 115 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) modf)(double __x ,
                                                                              double *__iptr ) ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 334 "/usr/include/time.h"
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 259 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 150 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static double opt_interval  =    1.0;
#line 151 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static int opt_addrfamily  =    0;
#line 152 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static char *opt_srcaddr  =    (char *)((void *)0);
#line 153 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static char *opt_device  =    (char *)((void *)0);
#line 154 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static char *opt_filename  =    (char *)((void *)0);
#line 155 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static int opt_count  =    -1;
#line 156 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static int opt_send_ttl  =    64;
#line 157 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static uint8_t opt_send_qos  =    (uint8_t )0;
#line 158 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static double opt_exit_status_threshold  =    1.0;
#line 163 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static int host_num  =    0;
#line 169 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static void sigint_handler(int signal___0 ) 
{ 


  {
#line 172
  signal___0 = 0;
#line 174
  opt_count = 0;
#line 175
  return;
}
}
#line 177 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static ping_context_t *context_create(void) 
{ 
  ping_context_t *ret ;
  void *tmp ;

  {
  {
#line 181
  tmp = malloc(sizeof(ping_context_t ));
#line 181
  ret = (ping_context_t *)tmp;
  }
#line 181
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 182
    return ((ping_context_t *)((void *)0));
  }
  {
#line 184
  memset((void *)ret, '\000', sizeof(ping_context_t ));
#line 186
  ret->latency_min = - 1.0;
#line 187
  ret->latency_max = - 1.0;
#line 188
  ret->latency_total = 0.0;
#line 189
  ret->latency_total_square = 0.0;
  }
#line 195
  return (ret);
}
}
#line 198 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static void context_destroy(ping_context_t *context ) 
{ 


  {
#line 200
  if ((unsigned long )context == (unsigned long )((void *)0)) {
#line 201
    return;
  }
  {
#line 211
  free((void *)context);
  }
#line 212
  return;
}
}
#line 214 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static double context_get_average(ping_context_t *ctx ) 
{ 
  double num_total ;

  {
#line 218
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 219
    return (- 1.0);
  }
#line 221
  if (ctx->req_rcvd < 1) {
#line 222
    return (- 0.0);
  }
#line 224
  num_total = (double )ctx->req_rcvd;
#line 225
  return (ctx->latency_total / num_total);
}
}
#line 228 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static double context_get_stddev(ping_context_t *ctx ) 
{ 
  double num_total ;
  double tmp ;

  {
#line 232
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 233
    return (- 1.0);
  }
#line 235
  if (ctx->req_rcvd < 1) {
#line 236
    return (- 0.0);
  } else
#line 237
  if (ctx->req_rcvd < 2) {
#line 238
    return (0.0);
  }
  {
#line 240
  num_total = (double )ctx->req_rcvd;
#line 241
  tmp = sqrt((num_total * ctx->latency_total_square - ctx->latency_total * ctx->latency_total) / (num_total * (num_total - 1.0)));
  }
#line 241
  return (tmp);
}
}
#line 246 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static double context_get_packet_loss(ping_context_t const   *ctx ) 
{ 


  {
#line 248
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 249
    return (- 1.0);
  }
#line 251
  if (ctx->req_sent < 1) {
#line 252
    return (0.0);
  }
#line 254
  return ((100.0 * (double )(ctx->req_sent - ctx->req_rcvd)) / (double )ctx->req_sent);
}
}
#line 258 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static int ping_initialize_contexts(pingobj_t *ping ) 
{ 
  pingobj_iter_t *iter ;
  int index___0 ;
  ping_context_t *context ;
  size_t buffer_size ;

  {
#line 263
  if ((unsigned long )ping == (unsigned long )((void *)0)) {
#line 264
    return (22);
  }
  {
#line 266
  index___0 = 0;
#line 267
  iter = ping_iterator_get(ping);
  }
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! ((unsigned long )iter != (unsigned long )((void *)0))) {
#line 267
      goto while_break;
    }
    {
#line 274
    context = context_create();
#line 275
    context->index = index___0;
#line 277
    buffer_size = sizeof(context->host);
#line 278
    ping_iterator_get_info(iter, 1, (void *)(context->host), & buffer_size);
#line 280
    buffer_size = sizeof(context->addr);
#line 281
    ping_iterator_get_info(iter, 2, (void *)(context->addr), & buffer_size);
#line 283
    ping_iterator_set_context(iter, (void *)context);
#line 285
    index___0 ++;
#line 267
    iter = ping_iterator_next(iter);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return (0);
}
}
#line 291 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static void usage_exit(char const   *name , int status ) 
{ 


  {
  {
#line 293
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [OPTIONS] -f filename | host [host [host ...]]\n\nAvailable options:\n  -4|-6        force the use of IPv4 or IPv6\n  -c count     number of ICMP packets to send\n  -i interval  interval with which to send ICMP packets\n  -t ttl       time to live for each ICMP packet\n  -Q qos       Quality of Service (QoS) of outgoing packets\n               Use \"-Q help\" for a list of valid options.\n  -I srcaddr   source address\n  -D device    outgoing interface name\n  -f filename  filename to read hosts from\n  -Z percent   Exit with non-zero exit status if more than this percentage of\n               probes timed out. (default: never)\n\noping 1.6.2, http://verplant.org/liboping/\nby Florian octo Forster <octo@verplant.org>\nfor contributions see `AUTHORS\'\n",
          name);
#line 316
  exit(status);
  }
}
}
#line 319
static  __attribute__((__noreturn__)) void usage_qos_exit(char const   *arg , int status ) ;
#line 319 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static void usage_qos_exit(char const   *arg , int status ) 
{ 


  {
#line 322
  if ((unsigned long )arg != (unsigned long )((char const   *)0)) {
    {
#line 323
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid QoS argument: \"%s\"\n\n",
            arg);
    }
  }
  {
#line 325
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Valid QoS arguments (option \"-Q\") are:\n\n  Differentiated Services (IPv4 and IPv6, RFC 2474)\n\n    be                     Best Effort (BE, default PHB).\n    ef                     Expedited Forwarding (EF) PHB group (RFC 3246).\n                           (low delay, low loss, low jitter)\n    va                     Voice Admit (VA) DSCP (RFC 5865).\n                           (capacity-admitted traffic)\n    af[1-4][1-3]           Assured Forwarding (AF) PHB group (RFC 2597).\n                           For example: \"af12\" (class 1, precedence 2)\n    cs[0-7]                Class Selector (CS) PHB group (RFC 2474).\n                           For example: \"cs1\" (priority traffic)\n\n  Type of Service (IPv4, RFC 1349, obsolete)\n\n    lowdelay     (%#04x)    minimize delay\n    throughput   (%#04x)    maximize throughput\n    reliability  (%#04x)    maximize reliability\n    mincost      (%#04x)    minimize monetary cost\n\n  Specify manually\n\n    0x00 - 0xff            Hexadecimal numeric specification.\n       0 -  255            Decimal numeric specification.\n\n",
          16U, 8U, 4U, 2U);
#line 356
  exit(status);
  }
}
}
#line 359 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static int set_opt_send_qos(char const   *opt ) 
{ 
  uint8_t dscp ;
  uint8_t class ;
  uint8_t prec ;
  uint8_t class___0 ;
  unsigned long value ;
  char *endptr ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 361
  if ((unsigned long )opt == (unsigned long )((void *)0)) {
#line 362
    return (22);
  }
  {
#line 364
  tmp___14 = strcasecmp("help", opt);
  }
#line 364
  if (tmp___14 == 0) {
    {
#line 365
    usage_qos_exit((char const   *)((void *)0), 0);
    }
  } else {
    {
#line 368
    tmp___13 = strcasecmp("be", opt);
    }
#line 368
    if (tmp___13 == 0) {
#line 369
      opt_send_qos = (uint8_t )0;
    } else {
      {
#line 371
      tmp___12 = strcasecmp("ef", opt);
      }
#line 371
      if (tmp___12 == 0) {
#line 372
        opt_send_qos = (uint8_t )184;
      } else {
        {
#line 374
        tmp___11 = strcasecmp("va", opt);
        }
#line 374
        if (tmp___11 == 0) {
#line 375
          opt_send_qos = (uint8_t )176;
        } else {
          {
#line 377
          tmp___8 = strlen("af");
#line 377
          tmp___9 = strncasecmp("af", opt, tmp___8);
          }
#line 377
          if (tmp___9 == 0) {
            {
#line 377
            tmp___10 = strlen(opt);
            }
#line 377
            if (tmp___10 == 4UL) {
#line 381
              class = (uint8_t )0;
#line 382
              prec = (uint8_t )0;
#line 385
              if ((int const   )*(opt + 2) == 49) {
#line 386
                class = (uint8_t )1;
              } else
#line 387
              if ((int const   )*(opt + 2) == 50) {
#line 388
                class = (uint8_t )2;
              } else
#line 389
              if ((int const   )*(opt + 2) == 51) {
#line 390
                class = (uint8_t )3;
              } else
#line 391
              if ((int const   )*(opt + 2) == 52) {
#line 392
                class = (uint8_t )4;
              } else {
                {
#line 394
                usage_qos_exit(opt, 0);
                }
              }
#line 397
              if ((int const   )*(opt + 3) == 49) {
#line 398
                prec = (uint8_t )1;
              } else
#line 399
              if ((int const   )*(opt + 3) == 50) {
#line 400
                prec = (uint8_t )2;
              } else
#line 401
              if ((int const   )*(opt + 3) == 51) {
#line 402
                prec = (uint8_t )3;
              } else {
                {
#line 404
                usage_qos_exit(opt, 0);
                }
              }
#line 406
              dscp = (uint8_t )(8 * (int )class + 2 * (int )prec);
#line 408
              opt_send_qos = (uint8_t )((int )dscp << 2);
            } else {
#line 377
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
            {
#line 411
            tmp___5 = strlen("cs");
#line 411
            tmp___6 = strncasecmp("cs", opt, tmp___5);
            }
#line 411
            if (tmp___6 == 0) {
              {
#line 411
              tmp___7 = strlen(opt);
              }
#line 411
              if (tmp___7 == 3UL) {
#line 416
                if ((int const   )*(opt + 2) < 48) {
                  {
#line 417
                  usage_qos_exit(opt, 1);
                  }
                } else
#line 416
                if ((int const   )*(opt + 2) > 55) {
                  {
#line 417
                  usage_qos_exit(opt, 1);
                  }
                }
#line 421
                class___0 = (uint8_t )((int )((uint8_t )*(opt + 2)) - 48);
#line 422
                opt_send_qos = (uint8_t )((int )class___0 << 5);
              } else {
#line 411
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              {
#line 425
              tmp___4 = strcasecmp("lowdelay", opt);
              }
#line 425
              if (tmp___4 == 0) {
#line 426
                opt_send_qos = (uint8_t )16;
              } else {
                {
#line 427
                tmp___3 = strcasecmp("throughput", opt);
                }
#line 427
                if (tmp___3 == 0) {
#line 428
                  opt_send_qos = (uint8_t )8;
                } else {
                  {
#line 429
                  tmp___2 = strcasecmp("reliability", opt);
                  }
#line 429
                  if (tmp___2 == 0) {
#line 430
                    opt_send_qos = (uint8_t )4;
                  } else {
                    {
#line 431
                    tmp___1 = strcasecmp("mincost", opt);
                    }
#line 431
                    if (tmp___1 == 0) {
#line 432
                      opt_send_qos = (uint8_t )2;
                    } else {
                      {
#line 439
                      tmp = __errno_location();
#line 439
                      *tmp = 0;
#line 440
                      endptr = (char *)((void *)0);
#line 441
                      value = strtoul((char const   */* __restrict  */)opt, (char **/* __restrict  */)(& endptr),
                                      0);
#line 442
                      tmp___0 = __errno_location();
                      }
#line 442
                      if (*tmp___0 != 0) {
                        {
#line 445
                        usage_qos_exit(opt, 1);
                        }
                      } else
#line 442
                      if ((unsigned long )endptr == (unsigned long )opt) {
                        {
#line 445
                        usage_qos_exit(opt, 1);
                        }
                      } else
#line 442
                      if ((unsigned long )endptr == (unsigned long )((void *)0)) {
                        {
#line 445
                        usage_qos_exit(opt, 1);
                        }
                      } else
#line 442
                      if ((int )*endptr != 0) {
                        {
#line 445
                        usage_qos_exit(opt, 1);
                        }
                      } else
#line 442
                      if (value > 255UL) {
                        {
#line 445
                        usage_qos_exit(opt, 1);
                        }
                      }
#line 447
                      opt_send_qos = (uint8_t )value;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 450
  return (0);
}
}
#line 453 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static char *format_qos(uint8_t qos , char *buffer , size_t buffer_size ) 
{ 
  uint8_t dscp ;
  uint8_t ecn ;
  char *dscp_str ;
  char *ecn_str ;

  {
#line 460
  dscp = (uint8_t )((int )qos >> 2);
#line 461
  ecn = (uint8_t )((int )qos & 3);
  {
#line 465
  if ((int )dscp == 0) {
#line 465
    goto case_0;
  }
#line 466
  if ((int )dscp == 46) {
#line 466
    goto case_46;
  }
#line 467
  if ((int )dscp == 45) {
#line 467
    goto case_45;
  }
#line 468
  if ((int )dscp == 10) {
#line 468
    goto case_10;
  }
#line 469
  if ((int )dscp == 12) {
#line 469
    goto case_12;
  }
#line 470
  if ((int )dscp == 14) {
#line 470
    goto case_14;
  }
#line 471
  if ((int )dscp == 18) {
#line 471
    goto case_18;
  }
#line 472
  if ((int )dscp == 20) {
#line 472
    goto case_20;
  }
#line 473
  if ((int )dscp == 22) {
#line 473
    goto case_22;
  }
#line 474
  if ((int )dscp == 26) {
#line 474
    goto case_26;
  }
#line 475
  if ((int )dscp == 28) {
#line 475
    goto case_28;
  }
#line 476
  if ((int )dscp == 30) {
#line 476
    goto case_30;
  }
#line 477
  if ((int )dscp == 34) {
#line 477
    goto case_34;
  }
#line 478
  if ((int )dscp == 36) {
#line 478
    goto case_36;
  }
#line 479
  if ((int )dscp == 38) {
#line 479
    goto case_38;
  }
#line 480
  if ((int )dscp == 8) {
#line 480
    goto case_8;
  }
#line 481
  if ((int )dscp == 16) {
#line 481
    goto case_16;
  }
#line 482
  if ((int )dscp == 24) {
#line 482
    goto case_24;
  }
#line 483
  if ((int )dscp == 32) {
#line 483
    goto case_32;
  }
#line 484
  if ((int )dscp == 40) {
#line 484
    goto case_40;
  }
#line 485
  if ((int )dscp == 48) {
#line 485
    goto case_48;
  }
#line 486
  if ((int )dscp == 56) {
#line 486
    goto case_56;
  }
#line 487
  goto switch_default;
  case_0: /* CIL Label */ 
#line 465
  dscp_str = (char *)"be";
#line 465
  goto switch_break;
  case_46: /* CIL Label */ 
#line 466
  dscp_str = (char *)"ef";
#line 466
  goto switch_break;
  case_45: /* CIL Label */ 
#line 467
  dscp_str = (char *)"va";
#line 467
  goto switch_break;
  case_10: /* CIL Label */ 
#line 468
  dscp_str = (char *)"af11";
#line 468
  goto switch_break;
  case_12: /* CIL Label */ 
#line 469
  dscp_str = (char *)"af12";
#line 469
  goto switch_break;
  case_14: /* CIL Label */ 
#line 470
  dscp_str = (char *)"af13";
#line 470
  goto switch_break;
  case_18: /* CIL Label */ 
#line 471
  dscp_str = (char *)"af21";
#line 471
  goto switch_break;
  case_20: /* CIL Label */ 
#line 472
  dscp_str = (char *)"af22";
#line 472
  goto switch_break;
  case_22: /* CIL Label */ 
#line 473
  dscp_str = (char *)"af23";
#line 473
  goto switch_break;
  case_26: /* CIL Label */ 
#line 474
  dscp_str = (char *)"af31";
#line 474
  goto switch_break;
  case_28: /* CIL Label */ 
#line 475
  dscp_str = (char *)"af32";
#line 475
  goto switch_break;
  case_30: /* CIL Label */ 
#line 476
  dscp_str = (char *)"af33";
#line 476
  goto switch_break;
  case_34: /* CIL Label */ 
#line 477
  dscp_str = (char *)"af41";
#line 477
  goto switch_break;
  case_36: /* CIL Label */ 
#line 478
  dscp_str = (char *)"af42";
#line 478
  goto switch_break;
  case_38: /* CIL Label */ 
#line 479
  dscp_str = (char *)"af43";
#line 479
  goto switch_break;
  case_8: /* CIL Label */ 
#line 480
  dscp_str = (char *)"cs1";
#line 480
  goto switch_break;
  case_16: /* CIL Label */ 
#line 481
  dscp_str = (char *)"cs2";
#line 481
  goto switch_break;
  case_24: /* CIL Label */ 
#line 482
  dscp_str = (char *)"cs3";
#line 482
  goto switch_break;
  case_32: /* CIL Label */ 
#line 483
  dscp_str = (char *)"cs4";
#line 483
  goto switch_break;
  case_40: /* CIL Label */ 
#line 484
  dscp_str = (char *)"cs5";
#line 484
  goto switch_break;
  case_48: /* CIL Label */ 
#line 485
  dscp_str = (char *)"cs6";
#line 485
  goto switch_break;
  case_56: /* CIL Label */ 
#line 486
  dscp_str = (char *)"cs7";
#line 486
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 487
  dscp_str = (char *)((void *)0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 492
  if ((int )ecn == 1) {
#line 492
    goto case_1;
  }
#line 493
  if ((int )ecn == 2) {
#line 493
    goto case_2;
  }
#line 494
  if ((int )ecn == 3) {
#line 494
    goto case_3;
  }
#line 495
  goto switch_default___0;
  case_1: /* CIL Label */ 
#line 492
  ecn_str = (char *)",ecn(1)";
#line 492
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 493
  ecn_str = (char *)",ecn(0)";
#line 493
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 494
  ecn_str = (char *)",ce";
#line 494
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 495
  ecn_str = (char *)"";
  switch_break___0: /* CIL Label */ ;
  }
#line 498
  if ((unsigned long )dscp_str == (unsigned long )((void *)0)) {
    {
#line 499
    snprintf((char */* __restrict  */)buffer, buffer_size, (char const   */* __restrict  */)"0x%02x%s",
             (int )dscp, ecn_str);
    }
  } else {
    {
#line 501
    snprintf((char */* __restrict  */)buffer, buffer_size, (char const   */* __restrict  */)"%s%s",
             dscp_str, ecn_str);
    }
  }
#line 502
  *(buffer + (buffer_size - 1UL)) = (char)0;
#line 504
  return (buffer);
}
}
#line 507 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static int read_options(int argc , char **argv ) 
{ 
  int optchar ;
  int new_count ;
  double new_interval ;
  int new_send_ttl ;
  char *endptr ;
  double tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 511
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 513
    optchar = getopt(argc, (char * const  *)argv, "46c:hi:I:t:Q:f:D:Z:");
    }
#line 519
    if (optchar == -1) {
#line 520
      goto while_break;
    }
    {
#line 525
    if (optchar == 54) {
#line 525
      goto case_54;
    }
#line 525
    if (optchar == 52) {
#line 525
      goto case_54;
    }
#line 529
    if (optchar == 99) {
#line 529
      goto case_99;
    }
#line 541
    if (optchar == 102) {
#line 541
      goto case_102;
    }
#line 549
    if (optchar == 105) {
#line 549
      goto case_105;
    }
#line 560
    if (optchar == 73) {
#line 560
      goto case_73;
    }
#line 568
    if (optchar == 68) {
#line 568
      goto case_68;
    }
#line 572
    if (optchar == 116) {
#line 572
      goto case_116;
    }
#line 584
    if (optchar == 81) {
#line 584
      goto case_81;
    }
#line 588
    if (optchar == 90) {
#line 588
      goto case_90;
    }
#line 615
    if (optchar == 104) {
#line 615
      goto case_104;
    }
#line 618
    goto switch_default;
    case_54: /* CIL Label */ 
    case_52: /* CIL Label */ 
#line 526
    if (optchar == 52) {
#line 526
      opt_addrfamily = 2;
    } else {
#line 526
      opt_addrfamily = 10;
    }
#line 527
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 532
    new_count = atoi((char const   *)optarg);
    }
#line 533
    if (new_count > 0) {
#line 534
      opt_count = new_count;
    } else {
      {
#line 536
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ignoring invalid count: %s\n",
              optarg);
      }
    }
#line 539
    goto switch_break;
    case_102: /* CIL Label */ 
#line 543
    if ((unsigned long )opt_filename != (unsigned long )((void *)0)) {
      {
#line 544
      free((void *)opt_filename);
      }
    }
    {
#line 545
    opt_filename = strdup((char const   *)optarg);
    }
#line 547
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 552
    new_interval = atof((char const   *)optarg);
    }
#line 553
    if (new_interval < 0.001) {
      {
#line 554
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ignoring invalid interval: %s\n",
              optarg);
      }
    } else {
#line 557
      opt_interval = new_interval;
    }
#line 559
    goto switch_break;
    case_73: /* CIL Label */ 
#line 562
    if ((unsigned long )opt_srcaddr != (unsigned long )((void *)0)) {
      {
#line 563
      free((void *)opt_srcaddr);
      }
    }
    {
#line 564
    opt_srcaddr = strdup((char const   *)optarg);
    }
#line 566
    goto switch_break;
    case_68: /* CIL Label */ 
#line 569
    opt_device = optarg;
#line 570
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 575
    new_send_ttl = atoi((char const   *)optarg);
    }
#line 576
    if (new_send_ttl > 0) {
#line 576
      if (new_send_ttl < 256) {
#line 577
        opt_send_ttl = new_send_ttl;
      } else {
        {
#line 579
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ignoring invalid TTL argument: %s\n",
                optarg);
        }
      }
    } else {
      {
#line 579
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ignoring invalid TTL argument: %s\n",
              optarg);
      }
    }
#line 581
    goto switch_break;
    case_81: /* CIL Label */ 
    {
#line 585
    set_opt_send_qos((char const   *)optarg);
    }
#line 586
    goto switch_break;
    case_90: /* CIL Label */ 
    {
#line 590
    endptr = (char *)((void *)0);
#line 593
    tmp___0 = __errno_location();
#line 593
    *tmp___0 = 0;
#line 594
    tmp = strtod((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& endptr));
#line 595
    tmp___1 = __errno_location();
    }
#line 595
    if (*tmp___1 != 0) {
      {
#line 597
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ignoring invalid -Z argument: %s\n",
              optarg);
#line 598
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The \"-Z\" option requires a numeric argument between 0 and 100.\n");
      }
    } else
#line 595
    if ((unsigned long )endptr == (unsigned long )((void *)0)) {
      {
#line 597
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ignoring invalid -Z argument: %s\n",
              optarg);
#line 598
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The \"-Z\" option requires a numeric argument between 0 and 100.\n");
      }
    } else
#line 595
    if ((int )*endptr != 0) {
      {
#line 597
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ignoring invalid -Z argument: %s\n",
              optarg);
#line 598
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The \"-Z\" option requires a numeric argument between 0 and 100.\n");
      }
    } else
#line 595
    if (tmp < 0.0) {
      {
#line 597
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ignoring invalid -Z argument: %s\n",
              optarg);
#line 598
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The \"-Z\" option requires a numeric argument between 0 and 100.\n");
      }
    } else
#line 595
    if (tmp > 100.0) {
      {
#line 597
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ignoring invalid -Z argument: %s\n",
              optarg);
#line 598
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The \"-Z\" option requires a numeric argument between 0 and 100.\n");
      }
    } else {
#line 601
      opt_exit_status_threshold = tmp / 100.0;
    }
#line 603
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 616
    usage_exit((char const   *)*(argv + 0), 0);
    }
#line 617
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 619
    usage_exit((char const   *)*(argv + 0), 1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 623
  return (optind);
}
}
#line 626 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static void time_normalize(struct timespec *ts ) 
{ 


  {
  {
#line 628
  while (1) {
    while_continue: /* CIL Label */ ;
#line 628
    if (! (ts->tv_nsec < 0L)) {
#line 628
      goto while_break;
    }
#line 630
    if (ts->tv_sec == 0L) {
#line 632
      ts->tv_nsec = (__syscall_slong_t )0;
#line 633
      return;
    }
#line 636
    (ts->tv_sec) --;
#line 637
    ts->tv_nsec += 1000000000L;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 640
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 640
    if (! (ts->tv_nsec >= 1000000000L)) {
#line 640
      goto while_break___0;
    }
#line 642
    (ts->tv_sec) ++;
#line 643
    ts->tv_nsec -= 1000000000L;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 645
  return;
}
}
#line 647 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static void time_calc(struct timespec *ts_dest , struct timespec  const  *ts_int ,
                      struct timeval  const  *tv_begin , struct timeval  const  *tv_end ) 
{ 


  {
  {
#line 652
  ts_dest->tv_sec = (__time_t )(tv_begin->tv_sec + ts_int->tv_sec);
#line 653
  ts_dest->tv_nsec = (__syscall_slong_t )(tv_begin->tv_usec * 1000L + ts_int->tv_nsec);
#line 654
  time_normalize(ts_dest);
  }
#line 659
  if (tv_end->tv_sec > (__time_t const   )ts_dest->tv_sec) {
#line 663
    ts_dest->tv_sec = (__time_t )0;
#line 664
    ts_dest->tv_nsec = (__syscall_slong_t )0;
#line 665
    return;
  } else
#line 659
  if (tv_end->tv_sec == (__time_t const   )ts_dest->tv_sec) {
#line 659
    if (tv_end->tv_usec * 1000L > (__suseconds_t const   )ts_dest->tv_nsec) {
#line 663
      ts_dest->tv_sec = (__time_t )0;
#line 664
      ts_dest->tv_nsec = (__syscall_slong_t )0;
#line 665
      return;
    }
  }
  {
#line 668
  ts_dest->tv_sec -= (__time_t )tv_end->tv_sec;
#line 669
  ts_dest->tv_nsec -= (__syscall_slong_t )(tv_end->tv_usec * 1000L);
#line 670
  time_normalize(ts_dest);
  }
#line 671
  return;
}
}
#line 968 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static int pre_loop_hook(pingobj_t *ping ) 
{ 
  pingobj_iter_t *iter ;
  ping_context_t *ctx ;
  size_t buffer_size ;
  void *tmp ;

  {
  {
#line 972
  iter = ping_iterator_get(ping);
  }
  {
#line 972
  while (1) {
    while_continue: /* CIL Label */ ;
#line 972
    if (! ((unsigned long )iter != (unsigned long )((void *)0))) {
#line 972
      goto while_break;
    }
    {
#line 979
    tmp = ping_iterator_get_context(iter);
#line 979
    ctx = (ping_context_t *)tmp;
    }
#line 980
    if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 981
      goto __Cont;
    }
    {
#line 983
    buffer_size = (size_t )0;
#line 984
    ping_iterator_get_info(iter, 7, (void *)0, & buffer_size);
#line 986
    printf((char const   */* __restrict  */)"PING %s (%s) %zu bytes of data.\n", ctx->host,
           ctx->addr, buffer_size);
    }
    __Cont: /* CIL Label */ 
    {
#line 972
    iter = ping_iterator_next(iter);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 990
  return (0);
}
}
#line 993 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static int pre_sleep_hook(pingobj_t *ping  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 995
  fflush(stdout);
  }
#line 997
  return (0);
}
}
#line 1000 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static int post_sleep_hook(pingobj_t *ping  __attribute__((__unused__)) ) 
{ 


  {
#line 1002
  return (0);
}
}
#line 1006 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static void update_host_hook(pingobj_iter_t *iter , int index___0  __attribute__((__unused__)) ) 
{ 
  double latency ;
  unsigned int sequence ;
  int recv_ttl ;
  uint8_t recv_qos ;
  char recv_qos_str[16] ;
  size_t buffer_len ;
  size_t data_len ;
  ping_context_t *context ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 1018
  latency = - 1.0;
#line 1019
  buffer_len = sizeof(latency);
#line 1020
  ping_iterator_get_info(iter, 4, (void *)(& latency), & buffer_len);
#line 1023
  sequence = 0U;
#line 1024
  buffer_len = sizeof(sequence);
#line 1025
  ping_iterator_get_info(iter, 5, (void *)(& sequence), & buffer_len);
#line 1028
  recv_ttl = -1;
#line 1029
  buffer_len = sizeof(recv_ttl);
#line 1030
  ping_iterator_get_info(iter, 10, (void *)(& recv_ttl), & buffer_len);
#line 1033
  recv_qos = (uint8_t )0;
#line 1034
  buffer_len = sizeof(recv_qos);
#line 1035
  ping_iterator_get_info(iter, 11, (void *)(& recv_qos), & buffer_len);
#line 1038
  data_len = (size_t )0;
#line 1039
  ping_iterator_get_info(iter, 7, (void *)0, & data_len);
#line 1042
  tmp = ping_iterator_get_context(iter);
#line 1042
  context = (ping_context_t *)tmp;
#line 1050
  (context->req_sent) ++;
  }
#line 1051
  if (latency > 0.0) {
#line 1053
    (context->req_rcvd) ++;
#line 1054
    context->latency_total += latency;
#line 1055
    context->latency_total_square += latency * latency;
#line 1057
    if (context->latency_max < 0.0) {
#line 1058
      context->latency_max = latency;
    } else
#line 1057
    if (context->latency_max < latency) {
#line 1058
      context->latency_max = latency;
    }
#line 1059
    if (context->latency_min < 0.0) {
#line 1060
      context->latency_min = latency;
    } else
#line 1059
    if (context->latency_min > latency) {
#line 1060
      context->latency_min = latency;
    }
    {
#line 1094
    printf((char const   */* __restrict  */)"%zu bytes from %s (%s): icmp_seq=%u ttl=%i ",
           data_len, context->host, context->addr, sequence, recv_ttl);
    }
#line 1098
    if ((int )recv_qos != 0) {
      {
#line 1100
      tmp___0 = format_qos(recv_qos, recv_qos_str, sizeof(recv_qos_str));
#line 1100
      printf((char const   */* __restrict  */)"qos=%s ", tmp___0);
      }
    } else
#line 1098
    if ((int )opt_send_qos != 0) {
      {
#line 1100
      tmp___0 = format_qos(recv_qos, recv_qos_str, sizeof(recv_qos_str));
#line 1100
      printf((char const   */* __restrict  */)"qos=%s ", tmp___0);
      }
    }
    {
#line 1103
    printf((char const   */* __restrict  */)"time=%.2f ms\n", latency);
    }
  } else {
    {
#line 1124
    printf((char const   */* __restrict  */)"echo reply from %s (%s): icmp_seq=%u timeout\n",
           context->host, context->addr, sequence);
    }
  }
#line 1136
  return;
}
}
#line 1141 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
static int post_loop_hook(pingobj_t *ping ) 
{ 
  pingobj_iter_t *iter ;
  int failure_count ;
  ping_context_t *context ;
  void *tmp ;
  double tmp___0 ;
  double pct_failed ;
  double average ;
  double deviation ;

  {
  {
#line 1144
  failure_count = 0;
#line 1150
  iter = ping_iterator_get(ping);
  }
  {
#line 1150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1150
    if (! ((unsigned long )iter != (unsigned long )((void *)0))) {
#line 1150
      goto while_break;
    }
    {
#line 1156
    tmp = ping_iterator_get_context(iter);
#line 1156
    context = (ping_context_t *)tmp;
#line 1158
    tmp___0 = context_get_packet_loss((ping_context_t const   *)context);
#line 1158
    printf((char const   */* __restrict  */)"\n--- %s ping statistics ---\n%i packets transmitted, %i received, %.2f%% packet loss, time %.1fms\n",
           context->host, context->req_sent, context->req_rcvd, tmp___0, context->latency_total);
#line 1165
    pct_failed = 1.0 - (double )context->req_rcvd / (double )context->req_sent;
    }
#line 1167
    if (pct_failed > opt_exit_status_threshold) {
#line 1168
      failure_count ++;
    }
#line 1171
    if (context->req_rcvd != 0) {
      {
#line 1176
      average = context_get_average(context);
#line 1177
      deviation = context_get_stddev(context);
#line 1179
      printf((char const   */* __restrict  */)"rtt min/avg/max/sdev = %.3f/%.3f/%.3f/%.3f ms\n",
             context->latency_min, average, context->latency_max, deviation);
      }
    }
    {
#line 1186
    ping_iterator_set_context(iter, (void *)0);
#line 1187
    context_destroy(context);
#line 1150
    iter = ping_iterator_next(iter);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1190
  return (failure_count);
}
}
#line 1193 "/home/wheatley/newnew/temp/liboping-1.6.2/src/oping.c"
int main(int argc , char **argv ) 
{ 
  pingobj_t *ping ;
  pingobj_iter_t *iter ;
  struct sigaction sigint_action ;
  struct timeval tv_begin ;
  struct timeval tv_end ;
  struct timespec ts_wait ;
  struct timespec ts_int ;
  int optind___0 ;
  int i ;
  int status ;
  uid_t saved_set_uid ;
  __uid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  double temp_sec ;
  double temp_nsec ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  FILE *infile ;
  char line[256] ;
  char host[256] ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char const   *errmsg ;
  char const   *tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  __uid_t tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  char const   *errmsg___0 ;
  char const   *tmp___27 ;
  int tmp___28 ;
  __uid_t tmp___29 ;
  int *tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  int index___0 ;
  int status___0 ;
  int tmp___33 ;
  char const   *tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int *tmp___37 ;

  {
  {
#line 1212
  saved_set_uid = geteuid();
#line 1215
  tmp = getuid();
#line 1215
  status = seteuid(tmp);
  }
#line 1216
  if (status != 0) {
    {
#line 1218
    tmp___0 = __errno_location();
#line 1218
    tmp___1 = strerror(*tmp___0);
#line 1218
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Temporarily dropping privileges failed: %s\n",
            tmp___1);
#line 1220
    exit(1);
    }
  }
  {
#line 1224
  setlocale(6, "");
#line 1225
  optind___0 = read_options(argc, argv);
  }
#line 1242
  if (optind___0 >= argc) {
#line 1242
    if ((unsigned long )opt_filename == (unsigned long )((void *)0)) {
      {
#line 1243
      usage_exit((char const   *)*(argv + 0), 1);
      }
    }
  }
  {
#line 1246
  ping = ping_construct();
  }
#line 1246
  if ((unsigned long )ping == (unsigned long )((void *)0)) {
    {
#line 1248
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ping_construct failed\n");
    }
#line 1249
    return (1);
  }
  {
#line 1252
  tmp___3 = ping_setopt(ping, 2, (void *)(& opt_send_ttl));
  }
#line 1252
  if (tmp___3 != 0) {
    {
#line 1254
    tmp___2 = ping_get_error(ping);
#line 1254
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Setting TTL to %i failed: %s\n",
            opt_send_ttl, tmp___2);
    }
  }
  {
#line 1258
  tmp___5 = ping_setopt(ping, 64, (void *)(& opt_send_qos));
  }
#line 1258
  if (tmp___5 != 0) {
    {
#line 1260
    tmp___4 = ping_get_error(ping);
#line 1260
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Setting TOS to %i failed: %s\n",
            (int )opt_send_qos, tmp___4);
    }
  }
  {
#line 1268
  temp_nsec = modf(opt_interval, & temp_sec);
#line 1269
  ts_int.tv_sec = (time_t )temp_sec;
#line 1270
  ts_int.tv_nsec = (long )(temp_nsec * (double )1000000000L);
  }
#line 1275
  if (opt_addrfamily != 0) {
    {
#line 1276
    ping_setopt(ping, 4, (void *)(& opt_addrfamily));
    }
  }
#line 1278
  if ((unsigned long )opt_srcaddr != (unsigned long )((void *)0)) {
    {
#line 1280
    tmp___7 = ping_setopt(ping, 16, (void *)opt_srcaddr);
    }
#line 1280
    if (tmp___7 != 0) {
      {
#line 1282
      tmp___6 = ping_get_error(ping);
#line 1282
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Setting source address failed: %s\n",
              tmp___6);
      }
    }
  }
#line 1287
  if ((unsigned long )opt_device != (unsigned long )((void *)0)) {
    {
#line 1289
    tmp___9 = ping_setopt(ping, 32, (void *)opt_device);
    }
#line 1289
    if (tmp___9 != 0) {
      {
#line 1291
      tmp___8 = ping_get_error(ping);
#line 1291
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Setting device failed: %s\n",
              tmp___8);
      }
    }
  }
#line 1296
  if ((unsigned long )opt_filename != (unsigned long )((void *)0)) {
    {
#line 1302
    tmp___10 = strcmp((char const   *)opt_filename, "-");
    }
#line 1302
    if (tmp___10 == 0) {
      {
#line 1304
      infile = fdopen(0, "r");
      }
    } else {
      {
#line 1306
      infile = fopen((char const   */* __restrict  */)opt_filename, (char const   */* __restrict  */)"r");
      }
    }
#line 1308
    if ((unsigned long )infile == (unsigned long )((void *)0)) {
      {
#line 1310
      tmp___11 = __errno_location();
#line 1310
      tmp___12 = strerror(*tmp___11);
#line 1310
      tmp___15 = strcmp((char const   *)opt_filename, "-");
      }
#line 1310
      if (tmp___15 == 0) {
#line 1310
        tmp___14 = "STDIN";
      } else {
#line 1310
        tmp___14 = (char const   *)opt_filename;
      }
      {
#line 1310
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Opening %s failed: %s\n",
              tmp___14, tmp___12);
      }
#line 1314
      return (1);
    }
    {
#line 1319
    status = seteuid(saved_set_uid);
    }
#line 1320
    if (status != 0) {
      {
#line 1322
      tmp___16 = __errno_location();
#line 1322
      tmp___17 = strerror(*tmp___16);
#line 1322
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Temporarily re-gaining privileges failed: %s\n",
              tmp___17);
#line 1324
      exit(1);
      }
    }
    {
#line 1328
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1328
      tmp___21 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)infile);
      }
#line 1328
      if (! tmp___21) {
#line 1328
        goto while_break;
      }
      {
#line 1331
      tmp___18 = sscanf((char const   */* __restrict  */)(line), (char const   */* __restrict  */)"%s",
                        host);
      }
#line 1331
      if (tmp___18 != 1) {
#line 1332
        goto while_continue;
      }
#line 1334
      if ((int )host[0] == 0) {
#line 1335
        goto while_continue;
      } else
#line 1334
      if ((int )host[0] == 35) {
#line 1335
        goto while_continue;
      }
      {
#line 1337
      tmp___20 = ping_host_add(ping, (char const   *)(host));
      }
#line 1337
      if (tmp___20 < 0) {
        {
#line 1339
        tmp___19 = ping_get_error(ping);
#line 1339
        errmsg = tmp___19;
#line 1341
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Adding host `%s\' failed: %s\n",
                host, errmsg);
        }
#line 1342
        goto while_continue;
      } else {
#line 1346
        host_num ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1352
    tmp___22 = getuid();
#line 1352
    status = seteuid(tmp___22);
    }
#line 1353
    if (status != 0) {
      {
#line 1355
      tmp___23 = __errno_location();
#line 1355
      tmp___24 = strerror(*tmp___23);
#line 1355
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Temporarily dropping privileges failed: %s\n",
              tmp___24);
#line 1357
      exit(1);
      }
    }
    {
#line 1361
    fclose(infile);
    }
  }
  {
#line 1366
  status = seteuid(saved_set_uid);
  }
#line 1367
  if (status != 0) {
    {
#line 1369
    tmp___25 = __errno_location();
#line 1369
    tmp___26 = strerror(*tmp___25);
#line 1369
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Temporarily re-gaining privileges failed: %s\n",
            tmp___26);
#line 1371
    exit(1);
    }
  }
#line 1375
  i = optind___0;
  {
#line 1375
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1375
    if (! (i < argc)) {
#line 1375
      goto while_break___0;
    }
    {
#line 1377
    tmp___28 = ping_host_add(ping, (char const   *)*(argv + i));
    }
#line 1377
    if (tmp___28 < 0) {
      {
#line 1379
      tmp___27 = ping_get_error(ping);
#line 1379
      errmsg___0 = tmp___27;
#line 1381
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Adding host `%s\' failed: %s\n",
              *(argv + i), errmsg___0);
      }
#line 1382
      goto __Cont;
    } else {
#line 1386
      host_num ++;
    }
    __Cont: /* CIL Label */ 
#line 1375
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1391
  tmp___29 = getuid();
#line 1391
  status = setuid(tmp___29);
  }
#line 1392
  if (status != 0) {
    {
#line 1394
    tmp___30 = __errno_location();
#line 1394
    tmp___31 = strerror(*tmp___30);
#line 1394
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dropping privileges failed: %s\n",
            tmp___31);
#line 1396
    exit(1);
    }
  }
  {
#line 1400
  saved_set_uid = (uid_t )-1;
#line 1403
  ping_initialize_contexts(ping);
  }
#line 1405
  if (i == 0) {
#line 1406
    return (1);
  }
  {
#line 1408
  memset((void *)(& sigint_action), '\000', sizeof(sigint_action));
#line 1409
  sigint_action.__sigaction_handler.sa_handler = & sigint_handler;
#line 1410
  tmp___32 = sigaction(2, (struct sigaction  const  */* __restrict  */)(& sigint_action),
                       (struct sigaction */* __restrict  */)((void *)0));
  }
#line 1410
  if (tmp___32 < 0) {
    {
#line 1412
    perror("sigaction");
    }
#line 1413
    return (1);
  }
  {
#line 1416
  pre_loop_hook(ping);
  }
  {
#line 1418
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1418
    if (! (opt_count != 0)) {
#line 1418
      goto while_break___1;
    }
    {
#line 1423
    tmp___33 = gettimeofday((struct timeval */* __restrict  */)(& tv_begin), (__timezone_ptr_t )((void *)0));
    }
#line 1423
    if (tmp___33 < 0) {
      {
#line 1425
      perror("gettimeofday");
      }
#line 1426
      return (1);
    }
    {
#line 1429
    tmp___35 = ping_send(ping);
    }
#line 1429
    if (tmp___35 < 0) {
      {
#line 1431
      tmp___34 = ping_get_error(ping);
#line 1431
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ping_send failed: %s\n",
              tmp___34);
      }
#line 1433
      return (1);
    }
    {
#line 1436
    index___0 = 0;
#line 1437
    iter = ping_iterator_get(ping);
    }
    {
#line 1437
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1437
      if (! ((unsigned long )iter != (unsigned long )((void *)0))) {
#line 1437
        goto while_break___2;
      }
      {
#line 1441
      update_host_hook(iter, index___0);
#line 1442
      index___0 ++;
#line 1437
      iter = ping_iterator_next(iter);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1445
    pre_sleep_hook(ping);
    }
#line 1448
    if (opt_count == 1) {
#line 1449
      goto while_break___1;
    }
    {
#line 1451
    tmp___36 = gettimeofday((struct timeval */* __restrict  */)(& tv_end), (__timezone_ptr_t )((void *)0));
    }
#line 1451
    if (tmp___36 < 0) {
      {
#line 1453
      perror("gettimeofday");
      }
#line 1454
      return (1);
    }
    {
#line 1457
    time_calc(& ts_wait, (struct timespec  const  *)(& ts_int), (struct timeval  const  *)(& tv_begin),
              (struct timeval  const  *)(& tv_end));
    }
    {
#line 1460
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1460
      status___0 = nanosleep((struct timespec  const  *)(& ts_wait), & ts_wait);
      }
#line 1460
      if (! (status___0 != 0)) {
#line 1460
        goto while_break___3;
      }
      {
#line 1462
      tmp___37 = __errno_location();
      }
#line 1462
      if (*tmp___37 != 4) {
        {
#line 1464
        perror("nanosleep");
        }
#line 1465
        goto while_break___3;
      } else
#line 1467
      if (opt_count == 0) {
#line 1470
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 1474
    post_sleep_hook(ping);
    }
#line 1476
    if (opt_count > 0) {
#line 1477
      opt_count --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1481
  status = post_loop_hook(ping);
#line 1483
  ping_destroy(ping);
  }
#line 1485
  if (status == 0) {
    {
#line 1486
    exit(0);
    }
  } else {
#line 1489
    if (status > 255) {
#line 1490
      status = 255;
    }
    {
#line 1491
    exit(status);
    }
  }
}
}
#line 156 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static char *sstrerror___1(int errnum , char *buf , size_t buflen ) 
{ 
  int tmp ;

  {
  {
#line 158
  *(buf + 0) = (char)0;
#line 182
  tmp = strerror_r(errnum, buf, buflen);
  }
#line 182
  if (tmp != 0) {
    {
#line 184
    snprintf((char */* __restrict  */)buf, buflen, (char const   */* __restrict  */)"Error %i (%#x); Additionally, strerror_r failed.",
             errnum, errnum);
    }
  }
#line 190
  *(buf + (buflen - 1UL)) = (char)0;
#line 192
  return (buf);
}
}
#line 195 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static void ping_set_error___1(pingobj_t *obj , char const   *function , char const   *message ) 
{ 


  {
  {
#line 198
  snprintf((char */* __restrict  */)(obj->errmsg), sizeof(obj->errmsg), (char const   */* __restrict  */)"%s: %s",
           function, message);
#line 200
  obj->errmsg[sizeof(obj->errmsg) - 1UL] = (char)0;
  }
#line 201
  return;
}
}
#line 203 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static void ping_set_errno___1(pingobj_t *obj , int error_number ) 
{ 


  {
  {
#line 205
  sstrerror___1(error_number, obj->errmsg, sizeof(obj->errmsg));
  }
#line 206
  return;
}
}
#line 208 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_timeval_add___1(struct timeval *tv1 , struct timeval *tv2 , struct timeval *res ) 
{ 


  {
#line 211
  res->tv_sec = tv1->tv_sec + tv2->tv_sec;
#line 212
  res->tv_usec = tv1->tv_usec + tv2->tv_usec;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! (res->tv_usec > 1000000L)) {
#line 214
      goto while_break;
    }
#line 216
    res->tv_usec -= 1000000L;
#line 217
    (res->tv_sec) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return (0);
}
}
#line 223 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_timeval_sub___1(struct timeval *tv1 , struct timeval *tv2 , struct timeval *res ) 
{ 


  {
#line 226
  if (tv1->tv_sec < tv2->tv_sec) {
#line 229
    return (-1);
  } else
#line 226
  if (tv1->tv_sec == tv2->tv_sec) {
#line 226
    if (tv1->tv_usec < tv2->tv_usec) {
#line 229
      return (-1);
    }
  }
#line 231
  res->tv_sec = tv1->tv_sec - tv2->tv_sec;
#line 232
  res->tv_usec = tv1->tv_usec - tv2->tv_usec;
#line 234
  if (! (res->tv_sec > 0L)) {
#line 234
    if (res->tv_sec == 0L) {
#line 234
      if (! (res->tv_usec >= 0L)) {
        {
#line 234
        __assert_fail("(res->tv_sec > 0) || ((res->tv_sec == 0) && (res->tv_usec >= 0))",
                      "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c",
                      234U, "ping_timeval_sub");
        }
      }
    } else {
      {
#line 234
      __assert_fail("(res->tv_sec > 0) || ((res->tv_sec == 0) && (res->tv_usec >= 0))",
                    "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c", 234U,
                    "ping_timeval_sub");
      }
    }
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! (res->tv_usec < 0L)) {
#line 236
      goto while_break;
    }
#line 238
    res->tv_usec += 1000000L;
#line 239
    (res->tv_sec) --;
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  return (0);
}
}
#line 245 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static uint16_t ping_icmp4_checksum___1(char *buf , size_t len ) 
{ 
  uint32_t sum ;
  uint16_t ret ;
  uint16_t *ptr ;

  {
#line 247
  sum = (uint32_t )0;
#line 248
  ret = (uint16_t )0;
#line 252
  ptr = (uint16_t *)buf;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! (len > 1UL)) {
#line 252
      goto while_break;
    }
#line 253
    sum += (uint32_t )*ptr;
#line 252
    ptr ++;
#line 252
    len -= 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  if (len == 1UL) {
#line 257
    *((char *)(& ret)) = *((char *)ptr);
#line 258
    sum += (uint32_t )ret;
  }
#line 262
  sum = (sum >> 16) + (sum & 65535U);
#line 263
  sum = (sum >> 16) + (sum & 65535U);
#line 265
  ret = (uint16_t )(~ sum);
#line 267
  return (ret);
}
}
#line 270 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static pinghost_t *ping_receive_ipv4___1(pingobj_t *obj , char *buffer , size_t buffer_len ) 
{ 
  struct ip *ip_hdr ;
  struct icmp *icmp_hdr ;
  size_t ip_hdr_len ;
  uint16_t recv_checksum ;
  uint16_t calc_checksum ;
  uint16_t ident ;
  uint16_t seq ;
  pinghost_t *ptr ;

  {
#line 286
  if (buffer_len < sizeof(struct ip )) {
#line 287
    return ((pinghost_t *)((void *)0));
  }
#line 289
  ip_hdr = (struct ip *)buffer;
#line 290
  ip_hdr_len = (size_t )(ip_hdr->ip_hl << 2);
#line 292
  if (buffer_len < ip_hdr_len) {
#line 293
    return ((pinghost_t *)((void *)0));
  }
#line 295
  buffer += ip_hdr_len;
#line 296
  buffer_len -= ip_hdr_len;
#line 298
  if (buffer_len < sizeof(struct icmp )) {
#line 299
    return ((pinghost_t *)((void *)0));
  }
#line 301
  icmp_hdr = (struct icmp *)buffer;
#line 302
  buffer += sizeof(struct icmp );
#line 303
  buffer_len -= sizeof(struct icmp );
#line 305
  if ((int )icmp_hdr->icmp_type != 0) {
#line 308
    return ((pinghost_t *)((void *)0));
  }
  {
#line 311
  recv_checksum = icmp_hdr->icmp_cksum;
#line 312
  icmp_hdr->icmp_cksum = (u_int16_t )0;
#line 313
  calc_checksum = ping_icmp4_checksum___1((char *)icmp_hdr, sizeof(struct icmp ) + buffer_len);
  }
#line 316
  if ((int )recv_checksum != (int )calc_checksum) {
#line 321
    return ((pinghost_t *)((void *)0));
  }
  {
#line 324
  ident = ntohs(icmp_hdr->icmp_hun.ih_idseq.icd_id);
#line 325
  seq = ntohs(icmp_hdr->icmp_hun.ih_idseq.icd_seq);
#line 329
  ptr = obj->head;
  }
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 329
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 329
      goto while_break;
    }
#line 334
    if (ptr->addrfamily != 2) {
#line 335
      goto __Cont;
    }
#line 337
    if (! (ptr->timer)->tv_sec) {
#line 337
      if (! (ptr->timer)->tv_usec) {
#line 338
        goto __Cont;
      }
    }
#line 340
    if (ptr->ident != (int )ident) {
#line 341
      goto __Cont;
    }
#line 343
    if (((ptr->sequence - 1) & 65535) != (int )seq) {
#line 344
      goto __Cont;
    }
#line 350
    goto while_break;
    __Cont: /* CIL Label */ 
#line 329
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 359
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 360
    ptr->recv_ttl = (int )ip_hdr->ip_ttl;
#line 361
    ptr->recv_qos = ip_hdr->ip_tos;
  }
#line 363
  return (ptr);
}
}
#line 382 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static pinghost_t *ping_receive_ipv6___1(pingobj_t *obj , char *buffer , size_t buffer_len ) 
{ 
  struct icmp6_hdr *icmp_hdr ;
  uint16_t ident ;
  uint16_t seq ;
  pinghost_t *ptr ;

  {
#line 392
  if (buffer_len < sizeof(struct icmp6_hdr )) {
#line 393
    return ((pinghost_t *)((void *)0));
  }
#line 395
  icmp_hdr = (struct icmp6_hdr *)buffer;
#line 396
  buffer += sizeof(struct icmp );
#line 397
  buffer_len -= sizeof(struct icmp );
#line 399
  if ((int )icmp_hdr->icmp6_type != 129) {
#line 402
    return ((pinghost_t *)((void *)0));
  }
#line 405
  if ((int )icmp_hdr->icmp6_code != 0) {
#line 408
    return ((pinghost_t *)((void *)0));
  }
  {
#line 411
  ident = ntohs(icmp_hdr->icmp6_dataun.icmp6_un_data16[0]);
#line 412
  seq = ntohs(icmp_hdr->icmp6_dataun.icmp6_un_data16[1]);
#line 416
  ptr = obj->head;
  }
  {
#line 416
  while (1) {
    while_continue: /* CIL Label */ ;
#line 416
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 416
      goto while_break;
    }
#line 421
    if (ptr->addrfamily != 10) {
#line 422
      goto __Cont;
    }
#line 424
    if (! (ptr->timer)->tv_sec) {
#line 424
      if (! (ptr->timer)->tv_usec) {
#line 425
        goto __Cont;
      }
    }
#line 427
    if (ptr->ident != (int )ident) {
#line 428
      goto __Cont;
    }
#line 430
    if (((ptr->sequence - 1) & 65535) != (int )seq) {
#line 431
      goto __Cont;
    }
#line 437
    goto while_break;
    __Cont: /* CIL Label */ 
#line 416
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 447
  return (ptr);
}
}
#line 450 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_receive_one___1(pingobj_t *obj , pinghost_t const   *ph , struct timeval *now ) 
{ 
  struct timeval diff ;
  struct timeval pkt_now ;
  pinghost_t *host ;
  int recv_ttl ;
  uint8_t recv_qos ;
  struct msghdr msghdr ;
  struct cmsghdr *cmsg ;
  char payload_buffer[4096] ;
  ssize_t payload_buffer_len ;
  char control_buffer[4096] ;
  struct iovec payload_iovec ;
  __suseconds_t tmp ;
  int tmp___0 ;
  __suseconds_t tmp___1 ;

  {
  {
#line 457
  pkt_now = *now;
#line 458
  host = (pinghost_t *)((void *)0);
#line 472
  memset((void *)(& payload_iovec), 0, sizeof(payload_iovec));
#line 473
  payload_iovec.iov_base = (void *)(payload_buffer);
#line 474
  payload_iovec.iov_len = sizeof(payload_buffer);
#line 476
  memset((void *)(& msghdr), 0, sizeof(msghdr));
#line 478
  msghdr.msg_name = (void *)0;
#line 479
  msghdr.msg_namelen = (socklen_t )0;
#line 481
  msghdr.msg_iov = & payload_iovec;
#line 482
  msghdr.msg_iovlen = (size_t )1;
#line 484
  msghdr.msg_control = (void *)(control_buffer);
#line 485
  msghdr.msg_controllen = sizeof(control_buffer);
#line 487
  msghdr.msg_flags = 0;
#line 492
  payload_buffer_len = recvmsg((int )ph->fd, & msghdr, 0);
  }
#line 493
  if (payload_buffer_len < 0L) {
#line 500
    return (-1);
  }
#line 505
  recv_ttl = -1;
#line 506
  recv_qos = (uint8_t )0;
#line 507
  if (msghdr.msg_controllen >= sizeof(struct cmsghdr )) {
#line 507
    cmsg = (struct cmsghdr *)msghdr.msg_control;
  } else {
#line 507
    cmsg = (struct cmsghdr *)0;
  }
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;
#line 507
    if (! ((unsigned long )cmsg != (unsigned long )((void *)0))) {
#line 507
      goto while_break;
    }
#line 511
    if (cmsg->cmsg_level == 1) {
#line 514
      if (cmsg->cmsg_type == 29) {
        {
#line 515
        memcpy((void */* __restrict  */)(& pkt_now), (void const   */* __restrict  */)(cmsg->__cmsg_data),
               sizeof(pkt_now));
        }
      }
    } else
#line 518
    if (ph->addrfamily == 2) {
#line 520
      if (cmsg->cmsg_level != 0) {
#line 521
        goto __Cont;
      }
#line 523
      if (cmsg->cmsg_type == 1) {
        {
#line 525
        memcpy((void */* __restrict  */)(& recv_qos), (void const   */* __restrict  */)(cmsg->__cmsg_data),
               sizeof(recv_qos));
        }
      } else
#line 529
      if (cmsg->cmsg_type == 2) {
        {
#line 531
        memcpy((void */* __restrict  */)(& recv_ttl), (void const   */* __restrict  */)(cmsg->__cmsg_data),
               sizeof(recv_ttl));
        }
      }
    } else
#line 541
    if (ph->addrfamily == 10) {
#line 543
      if (cmsg->cmsg_level != 41) {
#line 544
        goto __Cont;
      }
#line 546
      if (cmsg->cmsg_type == 67) {
        {
#line 548
        memcpy((void */* __restrict  */)(& recv_qos), (void const   */* __restrict  */)(cmsg->__cmsg_data),
               sizeof(recv_qos));
        }
      } else
#line 553
      if (cmsg->cmsg_type == 52) {
        {
#line 555
        memcpy((void */* __restrict  */)(& recv_ttl), (void const   */* __restrict  */)(cmsg->__cmsg_data),
               sizeof(recv_ttl));
        }
      } else
#line 562
      if (cmsg->cmsg_type == 16) {
        {
#line 564
        memcpy((void */* __restrict  */)(& recv_ttl), (void const   */* __restrict  */)(cmsg->__cmsg_data),
               sizeof(recv_ttl));
        }
      } else
#line 571
      if (cmsg->cmsg_type == 18) {
        {
#line 573
        memcpy((void */* __restrict  */)(& recv_ttl), (void const   */* __restrict  */)(cmsg->__cmsg_data),
               sizeof(recv_ttl));
        }
      }
    }
    __Cont: /* CIL Label */ 
    {
#line 507
    cmsg = __cmsg_nxthdr(& msghdr, cmsg);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 592
  if (ph->addrfamily == 2) {
    {
#line 594
    host = ping_receive_ipv4___1(obj, payload_buffer, (size_t )payload_buffer_len);
    }
#line 595
    if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 596
      return (-1);
    }
  } else
#line 598
  if (ph->addrfamily == 10) {
    {
#line 600
    host = ping_receive_ipv6___1(obj, payload_buffer, (size_t )payload_buffer_len);
    }
#line 601
    if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 602
      return (-1);
    }
  } else {
#line 608
    return (-1);
  }
  {
#line 618
  tmp___0 = ping_timeval_sub___1(& pkt_now, host->timer, & diff);
  }
#line 618
  if (tmp___0 < 0) {
#line 620
    tmp = (__suseconds_t )0;
#line 620
    (host->timer)->tv_usec = tmp;
#line 620
    (host->timer)->tv_sec = tmp;
#line 621
    return (-1);
  }
#line 628
  if (recv_ttl >= 0) {
#line 629
    host->recv_ttl = recv_ttl;
  }
#line 630
  host->recv_qos = recv_qos;
#line 632
  host->latency = (double )diff.tv_usec / 1000.0;
#line 633
  host->latency += (double )diff.tv_sec * 1000.0;
#line 635
  tmp___1 = (__suseconds_t )0;
#line 635
  (host->timer)->tv_usec = tmp___1;
#line 635
  (host->timer)->tv_sec = tmp___1;
#line 637
  return (0);
}
}
#line 640 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_receive_all___1(pingobj_t *obj ) 
{ 
  fd_set read_fds ;
  fd_set err_fds ;
  int num_fds ;
  int max_fd ;
  pinghost_t *ph ;
  pinghost_t *ptr ;
  struct timeval endtime ;
  struct timeval nowtime ;
  struct timeval timeout ;
  int status ;
  int ret ;
  int *tmp ;
  int tmp___0 ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  __suseconds_t tmp___8 ;

  {
#line 657
  ph = obj->head;
#line 658
  ret = 0;
#line 660
  ptr = ph;
  {
#line 660
  while (1) {
    while_continue: /* CIL Label */ ;
#line 660
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 660
      goto while_break;
    }
#line 662
    ptr->latency = - 1.0;
#line 663
    ptr->recv_ttl = -1;
#line 660
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 666
  tmp___0 = gettimeofday((struct timeval */* __restrict  */)(& nowtime), (__timezone_ptr_t )((void *)0));
  }
#line 666
  if (tmp___0 == -1) {
    {
#line 668
    tmp = __errno_location();
#line 668
    ping_set_errno___1(obj, *tmp);
    }
#line 669
    return (-1);
  }
  {
#line 673
  timeout.tv_sec = (time_t )obj->timeout;
#line 674
  timeout.tv_usec = (suseconds_t )((double )1000000 * (obj->timeout - (double )timeout.tv_sec));
#line 680
  ping_timeval_add___1(& nowtime, & timeout, & endtime);
  }
  {
#line 682
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 684
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 684
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& read_fds.__fds_bits[0]): "memory");
#line 684
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 685
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 685
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& err_fds.__fds_bits[0]): "memory");
#line 685
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 686
    num_fds = 0;
#line 687
    max_fd = -1;
#line 689
    ptr = ph;
    {
#line 689
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 689
      if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 689
        goto while_break___3;
      }
#line 691
      if (! (ptr->timer)->tv_sec) {
#line 691
        if (! (ptr->timer)->tv_usec) {
#line 692
          goto __Cont;
        }
      }
#line 694
      read_fds.__fds_bits[ptr->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ptr->fd % (8 * (int )sizeof(__fd_mask ));
#line 695
      err_fds.__fds_bits[ptr->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ptr->fd % (8 * (int )sizeof(__fd_mask ));
#line 696
      num_fds ++;
#line 698
      if (max_fd < ptr->fd) {
#line 699
        max_fd = ptr->fd;
      }
      __Cont: /* CIL Label */ 
#line 689
      ptr = ptr->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 702
    if (num_fds == 0) {
#line 703
      goto while_break___0;
    }
    {
#line 705
    tmp___2 = gettimeofday((struct timeval */* __restrict  */)(& nowtime), (__timezone_ptr_t )((void *)0));
    }
#line 705
    if (tmp___2 == -1) {
      {
#line 707
      tmp___1 = __errno_location();
#line 707
      ping_set_errno___1(obj, *tmp___1);
      }
#line 708
      return (-1);
    }
    {
#line 711
    tmp___3 = ping_timeval_sub___1(& endtime, & nowtime, & timeout);
    }
#line 711
    if (tmp___3 == -1) {
#line 712
      goto while_break___0;
    }
    {
#line 718
    status = select(max_fd + 1, (fd_set */* __restrict  */)(& read_fds), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)(& err_fds), (struct timeval */* __restrict  */)(& timeout));
#line 720
    tmp___5 = gettimeofday((struct timeval */* __restrict  */)(& nowtime), (__timezone_ptr_t )((void *)0));
    }
#line 720
    if (tmp___5 == -1) {
      {
#line 722
      tmp___4 = __errno_location();
#line 722
      ping_set_errno___1(obj, *tmp___4);
      }
#line 723
      return (-1);
    }
#line 726
    if (status == -1) {
      {
#line 726
      tmp___6 = __errno_location();
      }
#line 726
      if (*tmp___6 == 4) {
#line 729
        goto while_continue___0;
      } else {
#line 726
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 731
    if (status < 0) {
#line 738
      goto while_break___0;
    } else
#line 740
    if (status == 0) {
#line 743
      ptr = ph;
      {
#line 743
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 743
        if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 743
          goto while_break___4;
        }
#line 744
        if (ptr->latency < 0.0) {
#line 745
          (ptr->dropped) ++;
        }
#line 743
        ptr = ptr->next;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 746
      goto while_break___0;
    }
#line 749
    ptr = ph;
    {
#line 749
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 749
      if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 749
        goto while_break___5;
      }
#line 751
      if ((read_fds.__fds_bits[ptr->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << ptr->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 753
        tmp___7 = ping_receive_one___1(obj, (pinghost_t const   *)ptr, & nowtime);
        }
#line 753
        if (tmp___7 == 0) {
#line 754
          ret ++;
        }
      } else
#line 756
      if ((err_fds.__fds_bits[ptr->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << ptr->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 761
        tmp___8 = (__suseconds_t )0;
#line 761
        (ptr->timer)->tv_usec = tmp___8;
#line 761
        (ptr->timer)->tv_sec = tmp___8;
      }
#line 749
      ptr = ptr->next;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 766
  return (ret);
}
}
#line 776 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static ssize_t ping_sendto___1(pingobj_t *obj , pinghost_t *ph , void const   *buf ,
                               size_t buflen ) 
{ 
  ssize_t ret ;
  __suseconds_t tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 781
  tmp___0 = gettimeofday((struct timeval */* __restrict  */)ph->timer, (__timezone_ptr_t )((void *)0));
  }
#line 781
  if (tmp___0 == -1) {
#line 783
    tmp = (__suseconds_t )0;
#line 783
    (ph->timer)->tv_usec = tmp;
#line 783
    (ph->timer)->tv_sec = tmp;
#line 784
    return ((ssize_t )-1);
  }
  {
#line 787
  ret = sendto(ph->fd, buf, buflen, 0, (struct sockaddr  const  *)((struct sockaddr *)ph->addr),
               ph->addrlen);
  }
#line 790
  if (ret < 0L) {
    {
#line 793
    tmp___1 = __errno_location();
    }
#line 793
    if (*tmp___1 == 113) {
#line 794
      return ((ssize_t )0);
    }
    {
#line 797
    tmp___2 = __errno_location();
    }
#line 797
    if (*tmp___2 == 101) {
#line 798
      return ((ssize_t )0);
    }
    {
#line 800
    tmp___3 = __errno_location();
#line 800
    ping_set_errno___1(obj, *tmp___3);
    }
  }
#line 803
  return (ret);
}
}
#line 806 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_send_one_ipv4___1(pingobj_t *obj , pinghost_t *ph ) 
{ 
  struct icmp *icmp4 ;
  int status ;
  char buf[4096] ;
  int buflen ;
  char *data ;
  int datalen ;
  size_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 819
  memset((void *)(buf), '\000', sizeof(buf));
#line 820
  icmp4 = (struct icmp *)(buf);
#line 821
  data = (char *)(icmp4 + 1);
#line 823
  icmp4->icmp_type = (u_int8_t )8;
#line 824
  icmp4->icmp_code = (u_int8_t )0;
#line 825
  icmp4->icmp_cksum = (u_int16_t )0;
#line 826
  icmp4->icmp_hun.ih_idseq.icd_id = htons((uint16_t )ph->ident);
#line 827
  icmp4->icmp_hun.ih_idseq.icd_seq = htons((uint16_t )ph->sequence);
#line 829
  buflen = (int )(4096UL - sizeof(struct icmp ));
#line 830
  strncpy((char */* __restrict  */)data, (char const   */* __restrict  */)ph->data,
          (size_t )buflen);
#line 831
  tmp = strlen((char const   *)data);
#line 831
  datalen = (int )tmp;
#line 833
  buflen = (int )((unsigned long )datalen + sizeof(struct icmp ));
#line 835
  icmp4->icmp_cksum = ping_icmp4_checksum___1(buf, (size_t )buflen);
#line 839
  tmp___0 = ping_sendto___1(obj, ph, (void const   *)(buf), (size_t )buflen);
#line 839
  status = (int )tmp___0;
  }
#line 840
  if (status < 0) {
    {
#line 842
    perror("ping_sendto");
    }
#line 843
    return (-1);
  }
#line 848
  return (0);
}
}
#line 851 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_send_one_ipv6___1(pingobj_t *obj , pinghost_t *ph ) 
{ 
  struct icmp6_hdr *icmp6 ;
  int status ;
  char buf[4096] ;
  int buflen ;
  char *data ;
  int datalen ;
  size_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 864
  memset((void *)(buf), '\000', sizeof(buf));
#line 865
  icmp6 = (struct icmp6_hdr *)(buf);
#line 866
  data = (char *)(icmp6 + 1);
#line 868
  icmp6->icmp6_type = (uint8_t )128;
#line 869
  icmp6->icmp6_code = (uint8_t )0;
#line 872
  icmp6->icmp6_cksum = (uint16_t )0;
#line 873
  icmp6->icmp6_dataun.icmp6_un_data16[0] = htons((uint16_t )ph->ident);
#line 874
  icmp6->icmp6_dataun.icmp6_un_data16[1] = htons((uint16_t )ph->sequence);
#line 876
  buflen = (int )(4096UL - sizeof(struct icmp6_hdr ));
#line 877
  strncpy((char */* __restrict  */)data, (char const   */* __restrict  */)ph->data,
          (size_t )buflen);
#line 878
  tmp = strlen((char const   *)data);
#line 878
  datalen = (int )tmp;
#line 880
  buflen = (int )((unsigned long )datalen + sizeof(struct icmp6_hdr ));
#line 884
  tmp___0 = ping_sendto___1(obj, ph, (void const   *)(buf), (size_t )buflen);
#line 884
  status = (int )tmp___0;
  }
#line 885
  if (status < 0) {
    {
#line 887
    perror("ping_sendto");
    }
#line 888
    return (-1);
  }
#line 893
  return (0);
}
}
#line 896 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_send_all___1(pingobj_t *obj ) 
{ 
  pinghost_t *ph ;
  pinghost_t *ptr ;
  int ret ;
  __suseconds_t tmp ;
  int tmp___0 ;
  __suseconds_t tmp___1 ;
  int tmp___2 ;
  __suseconds_t tmp___3 ;
  int tmp___4 ;
  __suseconds_t tmp___5 ;

  {
#line 903
  ret = 0;
#line 904
  ph = obj->head;
#line 906
  ptr = ph;
  {
#line 906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 906
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 906
      goto while_break;
    }
    {
#line 910
    tmp___0 = gettimeofday((struct timeval */* __restrict  */)ptr->timer, (__timezone_ptr_t )((void *)0));
    }
#line 910
    if (tmp___0 == -1) {
#line 917
      tmp = (__suseconds_t )0;
#line 917
      (ptr->timer)->tv_usec = tmp;
#line 917
      (ptr->timer)->tv_sec = tmp;
#line 918
      ret --;
#line 919
      goto __Cont;
    }
#line 926
    if (ptr->addrfamily == 10) {
      {
#line 929
      tmp___2 = ping_send_one_ipv6___1(obj, ptr);
      }
#line 929
      if (tmp___2 != 0) {
#line 931
        tmp___1 = (__suseconds_t )0;
#line 931
        (ptr->timer)->tv_usec = tmp___1;
#line 931
        (ptr->timer)->tv_sec = tmp___1;
#line 932
        ret --;
#line 933
        goto __Cont;
      }
    } else
#line 936
    if (ptr->addrfamily == 2) {
      {
#line 939
      tmp___4 = ping_send_one_ipv4___1(obj, ptr);
      }
#line 939
      if (tmp___4 != 0) {
#line 941
        tmp___3 = (__suseconds_t )0;
#line 941
        (ptr->timer)->tv_usec = tmp___3;
#line 941
        (ptr->timer)->tv_sec = tmp___3;
#line 942
        ret --;
#line 943
        goto __Cont;
      }
    } else {
#line 949
      tmp___5 = (__suseconds_t )0;
#line 949
      (ptr->timer)->tv_usec = tmp___5;
#line 949
      (ptr->timer)->tv_sec = tmp___5;
#line 950
      ret --;
#line 951
      goto __Cont;
    }
#line 954
    (ptr->sequence) ++;
    __Cont: /* CIL Label */ 
#line 906
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  return (ret);
}
}
#line 963 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_set_ttl___1(pinghost_t *ph , int ttl ) 
{ 
  int ret ;

  {
#line 965
  ret = -2;
#line 967
  if (ph->addrfamily == 2) {
    {
#line 970
    ret = setsockopt(ph->fd, 0, 2, (void const   *)(& ttl), (socklen_t )sizeof(ttl));
    }
  } else
#line 973
  if (ph->addrfamily == 10) {
    {
#line 976
    ret = setsockopt(ph->fd, 41, 16, (void const   *)(& ttl), (socklen_t )sizeof(ttl));
    }
  }
#line 980
  return (ret);
}
}
#line 989 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_set_qos___1(pingobj_t *obj , pinghost_t *ph , uint8_t qos ) 
{ 
  int ret ;
  char errbuf[256] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 991
  ret = 22;
#line 994
  if (ph->addrfamily == 2) {
    {
#line 997
    ret = setsockopt(ph->fd, 0, 1, (void const   *)(& qos), (socklen_t )sizeof(qos));
    }
#line 999
    if (ret != 0) {
      {
#line 1001
      tmp = __errno_location();
#line 1001
      ret = *tmp;
#line 1002
      tmp___0 = sstrerror___1(ret, errbuf, sizeof(errbuf));
#line 1002
      ping_set_error___1(obj, "ping_set_qos", (char const   *)tmp___0);
      }
    }
  } else
#line 1007
  if (ph->addrfamily == 10) {
    {
#line 1010
    tmp___1 = (int )qos;
#line 1013
    ret = setsockopt(ph->fd, 41, 67, (void const   *)(& tmp___1), (socklen_t )sizeof(tmp___1));
    }
#line 1015
    if (ret != 0) {
      {
#line 1017
      tmp___2 = __errno_location();
#line 1017
      ret = *tmp___2;
#line 1018
      tmp___3 = sstrerror___1(ret, errbuf, sizeof(errbuf));
#line 1018
      ping_set_error___1(obj, "ping_set_qos", (char const   *)tmp___3);
      }
    }
  }
#line 1024
  return (ret);
}
}
#line 1030
static int ping_get_ident___1(void) ;
#line 1030 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int did_seed___1  =    0;
#line 1027 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static int ping_get_ident___1(void) 
{ 
  int fd ;
  int retval ;
  unsigned int seed ;
  ssize_t tmp ;
  long tmp___0 ;

  {
#line 1034
  if (did_seed___1 == 0) {
    {
#line 1036
    fd = open("/dev/urandom", 0);
    }
#line 1036
    if (fd != -1) {
      {
#line 1040
      tmp = read(fd, (void *)(& seed), sizeof(seed));
      }
#line 1040
      if (tmp != -1L) {
        {
#line 1042
        did_seed___1 = 1;
#line 1044
        srandom(seed);
        }
      }
      {
#line 1047
      close(fd);
      }
    }
  }
  {
#line 1059
  tmp___0 = random();
#line 1059
  retval = (int )tmp___0;
  }
#line 1063
  return (retval);
}
}
#line 1066 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static pinghost_t *ping_alloc___1(void) 
{ 
  pinghost_t *ph ;
  size_t ph_size ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 1071
  ph_size = (sizeof(pinghost_t ) + sizeof(struct sockaddr_storage )) + sizeof(struct timeval );
#line 1075
  tmp = malloc(ph_size);
#line 1075
  ph = (pinghost_t *)tmp;
  }
#line 1076
  if ((unsigned long )ph == (unsigned long )((void *)0)) {
#line 1077
    return ((pinghost_t *)((void *)0));
  }
  {
#line 1079
  memset((void *)ph, '\000', ph_size);
#line 1081
  ph->timer = (struct timeval *)(ph + 1);
#line 1082
  ph->addr = (struct sockaddr_storage *)(ph->timer + 1);
#line 1084
  ph->addrlen = (socklen_t )sizeof(struct sockaddr_storage );
#line 1085
  ph->fd = -1;
#line 1086
  ph->latency = - 1.0;
#line 1087
  ph->dropped = (uint32_t )0;
#line 1088
  tmp___0 = ping_get_ident___1();
#line 1088
  ph->ident = tmp___0 & 65535;
  }
#line 1090
  return (ph);
}
}
#line 1093 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static void ping_free___1(pinghost_t *ph ) 
{ 


  {
#line 1095
  if (ph->fd >= 0) {
    {
#line 1096
    close(ph->fd);
    }
  }
#line 1098
  if ((unsigned long )ph->username != (unsigned long )((void *)0)) {
    {
#line 1099
    free((void *)ph->username);
    }
  }
#line 1101
  if ((unsigned long )ph->hostname != (unsigned long )((void *)0)) {
    {
#line 1102
    free((void *)ph->hostname);
    }
  }
#line 1104
  if ((unsigned long )ph->data != (unsigned long )((void *)0)) {
    {
#line 1105
    free((void *)ph->data);
    }
  }
  {
#line 1107
  free((void *)ph);
  }
#line 1108
  return;
}
}
#line 1345 "/home/wheatley/newnew/temp/liboping-1.6.2/src/liboping.c"
static pinghost_t *ping_host_search___1(pinghost_t *ph , char const   *host ) 
{ 
  int tmp ;

  {
  {
#line 1347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1347
    if (! ((unsigned long )ph != (unsigned long )((void *)0))) {
#line 1347
      goto while_break;
    }
    {
#line 1349
    tmp = strcasecmp((char const   *)ph->username, host);
    }
#line 1349
    if (tmp == 0) {
#line 1350
      goto while_break;
    }
#line 1352
    ph = ph->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1355
  return (ph);
}
}
