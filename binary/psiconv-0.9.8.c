/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 37 "../psiconv/general.h"
typedef unsigned int psiconv_u32;
#line 31 "../psiconv/general.h"
typedef unsigned char psiconv_u8;
#line 34 "../psiconv/general.h"
typedef unsigned short psiconv_u16;
#line 39 "../psiconv/general.h"
typedef psiconv_u16 psiconv_ucs2;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 90 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 76 "../psiconv/data.h"
enum psiconv_bool {
    psiconv_bool_false = 0,
    psiconv_bool_true = 1
} ;
#line 76 "../psiconv/data.h"
typedef enum psiconv_bool psiconv_bool_t;
#line 30 "../psiconv/configuration.h"
typedef void psiconv_error_handler_t(int kind , psiconv_u32 off , char const   *message );
#line 33 "../psiconv/configuration.h"
struct psiconv_config_s {
   int verbosity ;
   int colordepth ;
   int redbits ;
   int greenbits ;
   int bluebits ;
   psiconv_bool_t color ;
   psiconv_error_handler_t *error_handler ;
   psiconv_u8 unknown_epoc_char ;
   psiconv_ucs2 unknown_unicode_char ;
   psiconv_ucs2 unicode_table[256] ;
   psiconv_bool_t unicode ;
};
#line 33 "../psiconv/configuration.h"
typedef struct psiconv_config_s *psiconv_config;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 37 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.h"
struct psiconv_list_s;
#line 37 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.h"
typedef struct psiconv_list_s *psiconv_list;
#line 38 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
struct psiconv_list_s {
   psiconv_u32 cur_len ;
   psiconv_u32 max_len ;
   size_t el_size ;
   void *els ;
};
#line 33 "../psiconv/general.h"
typedef short psiconv_s16;
#line 41 "../psiconv/data.h"
struct psiconv_file_s;
#line 41 "../psiconv/data.h"
typedef struct psiconv_file_s *psiconv_file;
#line 51
enum psiconv_file_type {
    psiconv_unknown_file = 0,
    psiconv_word_file = 1,
    psiconv_texted_file = 2,
    psiconv_mbm_file = 3,
    psiconv_sketch_file = 4,
    psiconv_clipart_file = 5,
    psiconv_sheet_file = 6
} ;
#line 51 "../psiconv/data.h"
typedef enum psiconv_file_type psiconv_file_type_t;
#line 65 "../psiconv/data.h"
typedef psiconv_ucs2 *psiconv_string_t;
#line 70 "../psiconv/data.h"
typedef float psiconv_length_t;
#line 71 "../psiconv/data.h"
typedef float psiconv_size_t;
#line 93
enum psiconv_super_sub {
    psiconv_normalscript = 0,
    psiconv_superscript = 1,
    psiconv_subscript = 2
} ;
#line 93 "../psiconv/data.h"
typedef enum psiconv_super_sub psiconv_super_sub_t;
#line 100
enum psiconv_justify_hor {
    psiconv_justify_left = 0,
    psiconv_justify_centre = 1,
    psiconv_justify_right = 2,
    psiconv_justify_full = 3
} ;
#line 100 "../psiconv/data.h"
typedef enum psiconv_justify_hor psiconv_justify_hor_t;
#line 108
enum psiconv_justify_ver {
    psiconv_justify_top = 0,
    psiconv_justify_middle = 1,
    psiconv_justify_bottom = 2
} ;
#line 108 "../psiconv/data.h"
typedef enum psiconv_justify_ver psiconv_justify_ver_t;
#line 115
enum psiconv_border_kind {
    psiconv_border_none = 0,
    psiconv_border_solid = 1,
    psiconv_border_double = 2,
    psiconv_border_dotted = 3,
    psiconv_border_dashed = 4,
    psiconv_border_dotdashed = 5,
    psiconv_border_dotdotdashed = 6
} ;
#line 115 "../psiconv/data.h"
typedef enum psiconv_border_kind psiconv_border_kind_t;
#line 127
enum psiconv_screenfont {
    psiconv_font_misc = 0,
    psiconv_font_sansserif = 1,
    psiconv_font_nonprop = 2,
    psiconv_font_serif = 3
} ;
#line 127 "../psiconv/data.h"
typedef enum psiconv_screenfont psiconv_screenfont_t;
#line 161 "../psiconv/data.h"
struct psiconv_color_s {
   psiconv_u8 red ;
   psiconv_u8 green ;
   psiconv_u8 blue ;
};
#line 161 "../psiconv/data.h"
typedef struct psiconv_color_s *psiconv_color;
#line 171 "../psiconv/data.h"
struct psiconv_font_s {
   psiconv_string_t name ;
   psiconv_screenfont_t screenfont ;
};
#line 171 "../psiconv/data.h"
typedef struct psiconv_font_s *psiconv_font;
#line 178 "../psiconv/data.h"
struct psiconv_border_s {
   psiconv_border_kind_t kind ;
   psiconv_size_t thickness ;
   psiconv_color color ;
};
#line 178 "../psiconv/data.h"
typedef struct psiconv_border_s *psiconv_border;
#line 203 "../psiconv/data.h"
struct psiconv_bullet_s {
   psiconv_bool_t on ;
   psiconv_size_t font_size ;
   psiconv_ucs2 character ;
   psiconv_bool_t indent ;
   psiconv_color color ;
   psiconv_font font ;
};
#line 203 "../psiconv/data.h"
typedef struct psiconv_bullet_s *psiconv_bullet;
#line 221 "../psiconv/data.h"
typedef psiconv_list psiconv_tab_list;
#line 225 "../psiconv/data.h"
struct psiconv_all_tabs_s {
   psiconv_length_t normal ;
   psiconv_tab_list extras ;
};
#line 225 "../psiconv/data.h"
typedef struct psiconv_all_tabs_s *psiconv_all_tabs;
#line 239 "../psiconv/data.h"
struct psiconv_character_layout_s {
   psiconv_color color ;
   psiconv_color back_color ;
   psiconv_size_t font_size ;
   psiconv_bool_t italic ;
   psiconv_bool_t bold ;
   psiconv_super_sub_t super_sub ;
   psiconv_bool_t underline ;
   psiconv_bool_t strikethrough ;
   psiconv_font font ;
};
#line 239 "../psiconv/data.h"
typedef struct psiconv_character_layout_s *psiconv_character_layout;
#line 269 "../psiconv/data.h"
struct psiconv_paragraph_layout_s {
   psiconv_color back_color ;
   psiconv_length_t indent_left ;
   psiconv_length_t indent_right ;
   psiconv_length_t indent_first ;
   psiconv_justify_hor_t justify_hor ;
   psiconv_justify_ver_t justify_ver ;
   psiconv_size_t linespacing ;
   psiconv_bool_t linespacing_exact ;
   psiconv_size_t space_above ;
   psiconv_size_t space_below ;
   psiconv_bool_t keep_together ;
   psiconv_bool_t keep_with_next ;
   psiconv_bool_t on_next_page ;
   psiconv_bool_t no_widow_protection ;
   psiconv_bool_t wrap_to_fit_cell ;
   psiconv_length_t border_distance ;
   psiconv_bullet bullet ;
   psiconv_border left_border ;
   psiconv_border right_border ;
   psiconv_border top_border ;
   psiconv_border bottom_border ;
   psiconv_all_tabs tabs ;
};
#line 269 "../psiconv/data.h"
typedef struct psiconv_paragraph_layout_s *psiconv_paragraph_layout;
#line 313 "../psiconv/data.h"
struct psiconv_section_table_entry_s {
   psiconv_u32 id ;
   psiconv_u32 offset ;
};
#line 313 "../psiconv/data.h"
typedef struct psiconv_section_table_entry_s *psiconv_section_table_entry;
#line 324 "../psiconv/data.h"
typedef psiconv_list psiconv_section_table_section;
#line 341 "../psiconv/data.h"
struct psiconv_object_icon_section_s {
   psiconv_length_t icon_width ;
   psiconv_length_t icon_height ;
   psiconv_string_t icon_name ;
};
#line 341 "../psiconv/data.h"
typedef struct psiconv_object_icon_section_s *psiconv_object_icon_section;
#line 352 "../psiconv/data.h"
struct psiconv_object_display_section_s {
   psiconv_bool_t show_icon ;
   psiconv_length_t width ;
   psiconv_length_t height ;
};
#line 352 "../psiconv/data.h"
typedef struct psiconv_object_display_section_s *psiconv_object_display_section;
#line 363 "../psiconv/data.h"
struct psiconv_embedded_object_section_s {
   psiconv_object_icon_section icon ;
   psiconv_object_display_section display ;
   psiconv_file object ;
};
#line 363 "../psiconv/data.h"
typedef struct psiconv_embedded_object_section_s *psiconv_embedded_object_section;
#line 378 "../psiconv/data.h"
struct psiconv_in_line_layout_s {
   psiconv_character_layout layout ;
   int length ;
   psiconv_embedded_object_section object ;
   psiconv_length_t object_width ;
   psiconv_length_t object_height ;
};
#line 378 "../psiconv/data.h"
typedef struct psiconv_in_line_layout_s *psiconv_in_line_layout;
#line 389 "../psiconv/data.h"
typedef psiconv_list psiconv_in_line_layouts;
#line 402 "../psiconv/data.h"
typedef psiconv_list psiconv_replacements;
#line 412 "../psiconv/data.h"
struct psiconv_paragraph_s {
   psiconv_string_t text ;
   psiconv_character_layout base_character ;
   psiconv_paragraph_layout base_paragraph ;
   psiconv_s16 base_style ;
   psiconv_in_line_layouts in_lines ;
   psiconv_replacements replacements ;
};
#line 412 "../psiconv/data.h"
typedef struct psiconv_paragraph_s *psiconv_paragraph;
#line 423 "../psiconv/data.h"
typedef psiconv_list psiconv_text_and_layout;
#line 428 "../psiconv/data.h"
struct psiconv_texted_section_s {
   psiconv_text_and_layout paragraphs ;
};
#line 428 "../psiconv/data.h"
typedef struct psiconv_texted_section_s *psiconv_texted_section;
#line 437 "../psiconv/data.h"
struct psiconv_page_header_s {
   psiconv_bool_t on_first_page ;
   psiconv_paragraph_layout base_paragraph_layout ;
   psiconv_character_layout base_character_layout ;
   psiconv_texted_section text ;
};
#line 437 "../psiconv/data.h"
typedef struct psiconv_page_header_s *psiconv_page_header;
#line 448 "../psiconv/data.h"
struct psiconv_page_layout_section_s {
   psiconv_u32 first_page_nr ;
   psiconv_length_t header_dist ;
   psiconv_length_t footer_dist ;
   psiconv_length_t left_margin ;
   psiconv_length_t right_margin ;
   psiconv_length_t top_margin ;
   psiconv_length_t bottom_margin ;
   psiconv_length_t page_width ;
   psiconv_length_t page_height ;
   psiconv_page_header header ;
   psiconv_page_header footer ;
   psiconv_bool_t landscape ;
};
#line 448 "../psiconv/data.h"
typedef struct psiconv_page_layout_section_s *psiconv_page_layout_section;
#line 472 "../psiconv/data.h"
struct psiconv_word_status_section_s {
   psiconv_bool_t show_tabs ;
   psiconv_bool_t show_spaces ;
   psiconv_bool_t show_paragraph_ends ;
   psiconv_bool_t show_line_breaks ;
   psiconv_bool_t show_hard_minus ;
   psiconv_bool_t show_hard_space ;
   psiconv_bool_t show_full_pictures ;
   psiconv_bool_t show_full_graphs ;
   psiconv_bool_t show_top_toolbar ;
   psiconv_bool_t show_side_toolbar ;
   psiconv_bool_t fit_lines_to_screen ;
   psiconv_u32 cursor_position ;
   psiconv_u32 display_size ;
};
#line 472 "../psiconv/data.h"
typedef struct psiconv_word_status_section_s *psiconv_word_status_section;
#line 494 "../psiconv/data.h"
struct psiconv_word_style_s {
   psiconv_character_layout character ;
   psiconv_paragraph_layout paragraph ;
   psiconv_ucs2 hotkey ;
   psiconv_string_t name ;
   psiconv_bool_t built_in ;
   psiconv_u32 outline_level ;
};
#line 494 "../psiconv/data.h"
typedef struct psiconv_word_style_s *psiconv_word_style;
#line 505 "../psiconv/data.h"
typedef psiconv_list psiconv_word_style_list;
#line 511 "../psiconv/data.h"
struct psiconv_word_styles_section_s {
   psiconv_word_style normal ;
   psiconv_word_style_list styles ;
};
#line 511 "../psiconv/data.h"
typedef struct psiconv_word_styles_section_s *psiconv_word_styles_section;
#line 520 "../psiconv/data.h"
struct psiconv_word_f_s {
   psiconv_page_layout_section page_sec ;
   psiconv_text_and_layout paragraphs ;
   psiconv_word_status_section status_sec ;
   psiconv_word_styles_section styles_sec ;
};
#line 520 "../psiconv/data.h"
typedef struct psiconv_word_f_s *psiconv_word_f;
#line 547 "../psiconv/data.h"
struct psiconv_paint_data_section_s {
   psiconv_u32 xsize ;
   psiconv_u32 ysize ;
   psiconv_length_t pic_xsize ;
   psiconv_length_t pic_ysize ;
   float *red ;
   float *green ;
   float *blue ;
};
#line 547 "../psiconv/data.h"
typedef struct psiconv_paint_data_section_s *psiconv_paint_data_section;
#line 576 "../psiconv/data.h"
struct psiconv_sketch_section_s {
   psiconv_u16 displayed_xsize ;
   psiconv_u16 displayed_ysize ;
   psiconv_u16 picture_data_x_offset ;
   psiconv_u16 picture_data_y_offset ;
   psiconv_u16 form_xsize ;
   psiconv_u16 form_ysize ;
   psiconv_u16 displayed_size_x_offset ;
   psiconv_u16 displayed_size_y_offset ;
   float magnification_x ;
   float magnification_y ;
   float cut_left ;
   float cut_right ;
   float cut_top ;
   float cut_bottom ;
   psiconv_paint_data_section picture ;
};
#line 576 "../psiconv/data.h"
typedef struct psiconv_sketch_section_s *psiconv_sketch_section;
#line 595 "../psiconv/data.h"
struct psiconv_sketch_f_s {
   psiconv_sketch_section sketch_sec ;
};
#line 595 "../psiconv/data.h"
typedef struct psiconv_sketch_f_s *psiconv_sketch_f;
#line 1001 "../psiconv/data.h"
struct psiconv_file_s {
   psiconv_file_type_t type ;
   void *file ;
};
#line 36 "../psiconv/buffer.h"
struct psiconv_buffer_s;
#line 36 "../psiconv/buffer.h"
typedef struct psiconv_buffer_s *psiconv_buffer;
#line 172 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_common.c"
struct psiconv_paragraph_type_list_s {
   psiconv_character_layout character ;
   psiconv_paragraph_layout paragraph ;
   psiconv_u8 style ;
   psiconv_u8 nr ;
};
#line 172 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_common.c"
typedef struct psiconv_paragraph_type_list_s *psiconv_paragraph_type_list;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 83 "../psiconv/data.h"
enum psiconv_triple {
    psiconv_triple_on = 0,
    psiconv_triple_off = 1,
    psiconv_triple_auto = 2
} ;
#line 83 "../psiconv/data.h"
typedef enum psiconv_triple psiconv_triple_t;
#line 300 "../psiconv/data.h"
struct psiconv_header_section_s {
   psiconv_u32 uid1 ;
   psiconv_u32 uid2 ;
   psiconv_u32 uid3 ;
   psiconv_u32 checksum ;
   psiconv_file_type_t file ;
};
#line 300 "../psiconv/data.h"
typedef struct psiconv_header_section_s *psiconv_header_section;
#line 333 "../psiconv/data.h"
struct psiconv_application_id_section_s {
   psiconv_u32 id ;
   psiconv_string_t name ;
};
#line 333 "../psiconv/data.h"
typedef struct psiconv_application_id_section_s *psiconv_application_id_section;
#line 531 "../psiconv/data.h"
struct psiconv_texted_f_s {
   psiconv_page_layout_section page_sec ;
   psiconv_texted_section texted_sec ;
};
#line 531 "../psiconv/data.h"
typedef struct psiconv_texted_f_s *psiconv_texted_f;
#line 541 "../psiconv/data.h"
typedef psiconv_list psiconv_jumptable_section;
#line 559 "../psiconv/data.h"
typedef psiconv_list psiconv_pictures;
#line 565 "../psiconv/data.h"
struct psiconv_mbm_f_s {
   psiconv_pictures sections ;
};
#line 565 "../psiconv/data.h"
typedef struct psiconv_mbm_f_s *psiconv_mbm_f;
#line 600 "../psiconv/data.h"
struct psiconv_clipart_section_s {
   psiconv_paint_data_section picture ;
};
#line 600 "../psiconv/data.h"
typedef struct psiconv_clipart_section_s *psiconv_clipart_section;
#line 606 "../psiconv/data.h"
typedef psiconv_list psiconv_cliparts;
#line 608 "../psiconv/data.h"
struct psiconv_clipart_f_s {
   psiconv_cliparts sections ;
};
#line 608 "../psiconv/data.h"
typedef struct psiconv_clipart_f_s *psiconv_clipart_f;
#line 721 "../psiconv/data.h"
struct psiconv_sheet_status_section_s {
   psiconv_bool_t show_graph ;
   psiconv_u32 cursor_row ;
   psiconv_u32 cursor_column ;
   psiconv_bool_t show_top_sheet_toolbar ;
   psiconv_bool_t show_side_sheet_toolbar ;
   psiconv_bool_t show_top_graph_toolbar ;
   psiconv_bool_t show_side_graph_toolbar ;
   psiconv_u32 sheet_display_size ;
   psiconv_u32 graph_display_size ;
   psiconv_triple_t show_horizontal_scrollbar ;
   psiconv_triple_t show_vertical_scrollbar ;
};
#line 721 "../psiconv/data.h"
typedef struct psiconv_sheet_status_section_s *psiconv_sheet_status_section;
#line 874 "../psiconv/data.h"
typedef psiconv_list psiconv_formula_list;
#line 945 "../psiconv/data.h"
typedef psiconv_list psiconv_sheet_worksheet_list;
#line 971 "../psiconv/data.h"
typedef psiconv_list psiconv_sheet_variable_list;
#line 974 "../psiconv/data.h"
struct psiconv_sheet_name_section_s {
   psiconv_string_t name ;
};
#line 974 "../psiconv/data.h"
typedef struct psiconv_sheet_name_section_s *psiconv_sheet_name_section;
#line 979 "../psiconv/data.h"
struct psiconv_sheet_info_section_s {
   psiconv_bool_t auto_recalc ;
};
#line 979 "../psiconv/data.h"
typedef struct psiconv_sheet_info_section_s *psiconv_sheet_info_section;
#line 984 "../psiconv/data.h"
struct psiconv_sheet_workbook_section_s {
   psiconv_formula_list formulas ;
   psiconv_sheet_worksheet_list worksheets ;
   psiconv_sheet_variable_list variables ;
   psiconv_sheet_info_section info ;
   psiconv_sheet_name_section name ;
};
#line 984 "../psiconv/data.h"
typedef struct psiconv_sheet_workbook_section_s *psiconv_sheet_workbook_section;
#line 993 "../psiconv/data.h"
struct psiconv_sheet_f_s {
   psiconv_page_layout_section page_sec ;
   psiconv_sheet_status_section status_sec ;
   psiconv_sheet_workbook_section workbook_sec ;
};
#line 993 "../psiconv/data.h"
typedef struct psiconv_sheet_f_s *psiconv_sheet_f;
#line 48 "../psiconv/data.h"
typedef double psiconv_float_t;
#line 613 "../psiconv/data.h"
struct psiconv_sheet_ref_s {
   psiconv_s16 offset ;
   psiconv_bool_t absolute ;
};
#line 613 "../psiconv/data.h"
typedef struct psiconv_sheet_ref_s psiconv_sheet_ref_t;
#line 619 "../psiconv/data.h"
struct psiconv_sheet_cell_reference_s {
   psiconv_sheet_ref_t row ;
   psiconv_sheet_ref_t column ;
};
#line 619 "../psiconv/data.h"
typedef struct psiconv_sheet_cell_reference_s psiconv_sheet_cell_reference_t;
#line 625 "../psiconv/data.h"
struct psiconv_sheet_cell_block_s {
   psiconv_sheet_cell_reference_t first ;
   psiconv_sheet_cell_reference_t last ;
};
#line 625 "../psiconv/data.h"
typedef struct psiconv_sheet_cell_block_s psiconv_sheet_cell_block_t;
#line 736
enum psiconv_formula_type {
    psiconv_formula_unknown = 0,
    psiconv_formula_op_lt = 1,
    psiconv_formula_op_le = 2,
    psiconv_formula_op_gt = 3,
    psiconv_formula_op_ge = 4,
    psiconv_formula_op_ne = 5,
    psiconv_formula_op_eq = 6,
    psiconv_formula_op_add = 7,
    psiconv_formula_op_sub = 8,
    psiconv_formula_op_mul = 9,
    psiconv_formula_op_div = 10,
    psiconv_formula_op_pow = 11,
    psiconv_formula_op_pos = 12,
    psiconv_formula_op_neg = 13,
    psiconv_formula_op_not = 14,
    psiconv_formula_op_and = 15,
    psiconv_formula_op_or = 16,
    psiconv_formula_op_con = 17,
    psiconv_formula_op_bra = 18,
    psiconv_formula_mark_eof = 19,
    psiconv_formula_dat_float = 20,
    psiconv_formula_dat_int = 21,
    psiconv_formula_dat_var = 22,
    psiconv_formula_dat_string = 23,
    psiconv_formula_dat_cellref = 24,
    psiconv_formula_dat_cellblock = 25,
    psiconv_formula_dat_vcellblock = 26,
    psiconv_formula_mark_opsep = 27,
    psiconv_formula_mark_opend = 28,
    psiconv_formula_fun_false = 29,
    psiconv_formula_fun_if = 30,
    psiconv_formula_fun_true = 31,
    psiconv_formula_fun_cell = 32,
    psiconv_formula_fun_errortype = 33,
    psiconv_formula_fun_isblank = 34,
    psiconv_formula_fun_iserr = 35,
    psiconv_formula_fun_iserror = 36,
    psiconv_formula_fun_islogical = 37,
    psiconv_formula_fun_isna = 38,
    psiconv_formula_fun_isnontext = 39,
    psiconv_formula_fun_isnumber = 40,
    psiconv_formula_fun_istext = 41,
    psiconv_formula_fun_n = 42,
    psiconv_formula_fun_type = 43,
    psiconv_formula_fun_address = 44,
    psiconv_formula_fun_column = 45,
    psiconv_formula_fun_columns = 46,
    psiconv_formula_fun_hlookup = 47,
    psiconv_formula_fun_index = 48,
    psiconv_formula_fun_indirect = 49,
    psiconv_formula_fun_lookup = 50,
    psiconv_formula_fun_offset = 51,
    psiconv_formula_fun_row = 52,
    psiconv_formula_fun_rows = 53,
    psiconv_formula_fun_vlookup = 54,
    psiconv_formula_fun_char = 55,
    psiconv_formula_fun_code = 56,
    psiconv_formula_fun_exact = 57,
    psiconv_formula_fun_find = 58,
    psiconv_formula_fun_left = 59,
    psiconv_formula_fun_len = 60,
    psiconv_formula_fun_lower = 61,
    psiconv_formula_fun_mid = 62,
    psiconv_formula_fun_proper = 63,
    psiconv_formula_fun_replace = 64,
    psiconv_formula_fun_rept = 65,
    psiconv_formula_fun_right = 66,
    psiconv_formula_fun_string = 67,
    psiconv_formula_fun_t = 68,
    psiconv_formula_fun_trim = 69,
    psiconv_formula_fun_upper = 70,
    psiconv_formula_fun_value = 71,
    psiconv_formula_fun_date = 72,
    psiconv_formula_fun_datevalue = 73,
    psiconv_formula_fun_day = 74,
    psiconv_formula_fun_hour = 75,
    psiconv_formula_fun_minute = 76,
    psiconv_formula_fun_month = 77,
    psiconv_formula_fun_now = 78,
    psiconv_formula_fun_second = 79,
    psiconv_formula_fun_today = 80,
    psiconv_formula_fun_time = 81,
    psiconv_formula_fun_timevalue = 82,
    psiconv_formula_fun_year = 83,
    psiconv_formula_fun_abs = 84,
    psiconv_formula_fun_acos = 85,
    psiconv_formula_fun_asin = 86,
    psiconv_formula_fun_atan = 87,
    psiconv_formula_fun_atan2 = 88,
    psiconv_formula_fun_cos = 89,
    psiconv_formula_fun_degrees = 90,
    psiconv_formula_fun_exp = 91,
    psiconv_formula_fun_fact = 92,
    psiconv_formula_fun_int = 93,
    psiconv_formula_fun_ln = 94,
    psiconv_formula_fun_log10 = 95,
    psiconv_formula_fun_mod = 96,
    psiconv_formula_fun_pi = 97,
    psiconv_formula_fun_radians = 98,
    psiconv_formula_fun_rand = 99,
    psiconv_formula_fun_round = 100,
    psiconv_formula_fun_sign = 101,
    psiconv_formula_fun_sin = 102,
    psiconv_formula_fun_sqrt = 103,
    psiconv_formula_fun_sumproduct = 104,
    psiconv_formula_fun_tan = 105,
    psiconv_formula_fun_trunc = 106,
    psiconv_formula_fun_cterm = 107,
    psiconv_formula_fun_ddb = 108,
    psiconv_formula_fun_fv = 109,
    psiconv_formula_fun_irr = 110,
    psiconv_formula_fun_npv = 111,
    psiconv_formula_fun_pmt = 112,
    psiconv_formula_fun_pv = 113,
    psiconv_formula_fun_rate = 114,
    psiconv_formula_fun_sln = 115,
    psiconv_formula_fun_syd = 116,
    psiconv_formula_fun_term = 117,
    psiconv_formula_fun_combin = 118,
    psiconv_formula_fun_permut = 119,
    psiconv_formula_vfn_average = 120,
    psiconv_formula_vfn_choose = 121,
    psiconv_formula_vfn_count = 122,
    psiconv_formula_vfn_counta = 123,
    psiconv_formula_vfn_countblank = 124,
    psiconv_formula_vfn_max = 125,
    psiconv_formula_vfn_min = 126,
    psiconv_formula_vfn_product = 127,
    psiconv_formula_vfn_stdevp = 128,
    psiconv_formula_vfn_stdev = 129,
    psiconv_formula_vfn_sum = 130,
    psiconv_formula_vfn_sumsq = 131,
    psiconv_formula_vfn_varp = 132,
    psiconv_formula_vfn_var = 133
} ;
#line 736 "../psiconv/data.h"
typedef enum psiconv_formula_type psiconv_formula_type_t;
#line 876 "../psiconv/data.h"
union __anonunion_data_26 {
   psiconv_u32 dat_int ;
   double dat_float ;
   psiconv_string_t dat_string ;
   psiconv_sheet_cell_reference_t dat_cellref ;
   psiconv_sheet_cell_block_t dat_cellblock ;
   psiconv_formula_list fun_operands ;
   psiconv_u32 dat_variable ;
};
#line 876 "../psiconv/data.h"
struct psiconv_formula_s {
   psiconv_formula_type_t type ;
   union __anonunion_data_26 data ;
};
#line 876 "../psiconv/data.h"
typedef struct psiconv_formula_s *psiconv_formula;
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
struct formula_element {
   psiconv_formula_type_t formula_type ;
   int number_of_args ;
   char const   *name ;
};
#line 146 "../psiconv/data.h"
enum psiconv_replacement_type {
    psiconv_replace_time = 0,
    psiconv_replace_date = 1,
    psiconv_replace_pagenr = 2,
    psiconv_replace_nr_of_pages = 3,
    psiconv_replace_filename = 4
} ;
#line 146 "../psiconv/data.h"
typedef enum psiconv_replacement_type psiconv_replacement_type_t;
#line 394 "../psiconv/data.h"
struct psiconv_replacement_s {
   int offset ;
   int cur_len ;
   psiconv_replacement_type_t type ;
};
#line 404 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
struct anon_style_s {
   int nr ;
   psiconv_s16 base_style ;
   psiconv_character_layout character ;
   psiconv_paragraph_layout paragraph ;
};
#line 404 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
typedef struct anon_style_s *anon_style;
#line 412 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
typedef psiconv_list anon_style_list;
#line 137 "../psiconv/data.h"
enum psiconv_tab_kind {
    psiconv_tab_left = 0,
    psiconv_tab_centre = 1,
    psiconv_tab_right = 2
} ;
#line 137 "../psiconv/data.h"
typedef enum psiconv_tab_kind psiconv_tab_kind_t;
#line 214 "../psiconv/data.h"
struct psiconv_tab_s {
   psiconv_length_t location ;
   psiconv_tab_kind_t kind ;
};
#line 214 "../psiconv/data.h"
typedef struct psiconv_tab_s *psiconv_tab;
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.h"
typedef psiconv_list psiconv_pixel_bytes;
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.h"
typedef psiconv_list psiconv_pixel_ints;
#line 35 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.h"
struct psiconv_pixel_float_s {
   psiconv_u32 length ;
   float *red ;
   float *green ;
   float *blue ;
};
#line 35 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.h"
typedef struct psiconv_pixel_float_s psiconv_pixel_floats_t;
#line 476 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
typedef psiconv_list psiconv_word_data;
#line 36 "../psiconv/general.h"
typedef int psiconv_s32;
#line 394 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
typedef struct psiconv_replacement_s *psiconv_replacement;
#line 631
enum psiconv_cell_type {
    psiconv_cell_blank = 0,
    psiconv_cell_int = 1,
    psiconv_cell_bool = 2,
    psiconv_cell_error = 3,
    psiconv_cell_float = 4,
    psiconv_cell_string = 5
} ;
#line 631 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
typedef enum psiconv_cell_type psiconv_cell_type_t;
#line 641
enum psiconv_sheet_errorcode {
    psiconv_sheet_error_none = 0,
    psiconv_sheet_error_null = 1,
    psiconv_sheet_error_divzero = 2,
    psiconv_sheet_error_value = 3,
    psiconv_sheet_error_reference = 4,
    psiconv_sheet_error_name = 5,
    psiconv_sheet_error_number = 6,
    psiconv_sheet_error_notavail = 7
} ;
#line 641 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
typedef enum psiconv_sheet_errorcode psiconv_sheet_errorcode_t;
#line 653
enum psiconv_sheet_numberformat_code {
    psiconv_numberformat_general = 0,
    psiconv_numberformat_fixeddecimal = 1,
    psiconv_numberformat_scientific = 2,
    psiconv_numberformat_currency = 3,
    psiconv_numberformat_percent = 4,
    psiconv_numberformat_triads = 5,
    psiconv_numberformat_boolean = 6,
    psiconv_numberformat_text = 7,
    psiconv_numberformat_date_dmm = 8,
    psiconv_numberformat_date_mmd = 9,
    psiconv_numberformat_date_ddmmyy = 10,
    psiconv_numberformat_date_mmddyy = 11,
    psiconv_numberformat_date_yymmdd = 12,
    psiconv_numberformat_date_dmmm = 13,
    psiconv_numberformat_date_dmmmyy = 14,
    psiconv_numberformat_date_ddmmmyy = 15,
    psiconv_numberformat_date_mmm = 16,
    psiconv_numberformat_date_monthname = 17,
    psiconv_numberformat_date_mmmyy = 18,
    psiconv_numberformat_date_monthnameyy = 19,
    psiconv_numberformat_date_monthnamedyyyy = 20,
    psiconv_numberformat_datetime_ddmmyyyyhhii = 21,
    psiconv_numberformat_datetime_ddmmyyyyHHii = 22,
    psiconv_numberformat_datetime_mmddyyyyhhii = 23,
    psiconv_numberformat_datetime_mmddyyyyHHii = 24,
    psiconv_numberformat_datetime_yyyymmddhhii = 25,
    psiconv_numberformat_datetime_yyyymmddHHii = 26,
    psiconv_numberformat_time_hhii = 27,
    psiconv_numberformat_time_hhiiss = 28,
    psiconv_numberformat_time_HHii = 29,
    psiconv_numberformat_time_HHiiss = 30
} ;
#line 653 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
typedef enum psiconv_sheet_numberformat_code psiconv_sheet_numberformat_code_t;
#line 688 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
struct psiconv_sheet_numberformat_s {
   psiconv_sheet_numberformat_code_t code ;
   psiconv_u8 decimal ;
};
#line 688 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
typedef struct psiconv_sheet_numberformat_s *psiconv_sheet_numberformat;
#line 694 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
struct psiconv_sheet_cell_layout_s {
   psiconv_character_layout character ;
   psiconv_paragraph_layout paragraph ;
   psiconv_sheet_numberformat numberformat ;
};
#line 694 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
typedef struct psiconv_sheet_cell_layout_s *psiconv_sheet_cell_layout;
#line 701 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
union __anonunion_data_25 {
   psiconv_u32 dat_int ;
   double dat_float ;
   psiconv_string_t dat_string ;
   psiconv_bool_t dat_bool ;
   psiconv_sheet_errorcode_t dat_error ;
};
#line 701 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
struct psiconv_sheet_cell_s {
   psiconv_u16 column ;
   psiconv_u16 row ;
   psiconv_cell_type_t type ;
   union __anonunion_data_25 data ;
   psiconv_sheet_cell_layout layout ;
   psiconv_bool_t calculated ;
   psiconv_u32 ref_formula ;
};
#line 701 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
typedef struct psiconv_sheet_cell_s *psiconv_sheet_cell;
#line 718 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
typedef psiconv_list psiconv_sheet_cell_list;
#line 890 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
struct psiconv_sheet_line_s {
   psiconv_u32 position ;
   psiconv_sheet_cell_layout layout ;
};
#line 890 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
typedef struct psiconv_sheet_line_s *psiconv_sheet_line;
#line 896 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
typedef psiconv_list psiconv_sheet_line_list;
#line 899 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
struct psiconv_sheet_grid_size_s {
   psiconv_u32 line_number ;
   psiconv_length_t size ;
};
#line 899 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
typedef struct psiconv_sheet_grid_size_s *psiconv_sheet_grid_size;
#line 905 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
typedef psiconv_list psiconv_sheet_grid_size_list;
#line 908 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
typedef psiconv_list psiconv_sheet_grid_break_list;
#line 910 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
struct psiconv_sheet_grid_section_s {
   psiconv_bool_t show_column_titles ;
   psiconv_bool_t show_row_titles ;
   psiconv_bool_t show_vertical_grid ;
   psiconv_bool_t show_horizontal_grid ;
   psiconv_bool_t freeze_rows ;
   psiconv_bool_t freeze_columns ;
   psiconv_u32 frozen_rows ;
   psiconv_u32 frozen_columns ;
   psiconv_u32 first_unfrozen_row_displayed ;
   psiconv_u32 first_unfrozen_column_displayed ;
   psiconv_bool_t show_page_breaks ;
   psiconv_u32 first_row ;
   psiconv_u32 first_column ;
   psiconv_u32 last_row ;
   psiconv_u32 last_column ;
   psiconv_length_t default_row_height ;
   psiconv_length_t default_column_width ;
   psiconv_sheet_grid_size_list row_heights ;
   psiconv_sheet_grid_size_list column_heights ;
   psiconv_sheet_grid_break_list row_page_breaks ;
   psiconv_sheet_grid_break_list column_page_breaks ;
};
#line 910 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
typedef struct psiconv_sheet_grid_section_s *psiconv_sheet_grid_section;
#line 935 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
struct psiconv_sheet_worksheet_s {
   psiconv_sheet_cell_layout default_layout ;
   psiconv_sheet_cell_list cells ;
   psiconv_bool_t show_zeros ;
   psiconv_sheet_line_list row_default_layouts ;
   psiconv_sheet_line_list col_default_layouts ;
   psiconv_sheet_grid_section grid ;
};
#line 935 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
typedef struct psiconv_sheet_worksheet_s *psiconv_sheet_worksheet;
#line 948
enum psiconv_variable_type {
    psiconv_var_int = 0,
    psiconv_var_float = 1,
    psiconv_var_string = 2,
    psiconv_var_cellref = 3,
    psiconv_var_cellblock = 4
} ;
#line 948 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
typedef enum psiconv_variable_type psiconv_variable_type_t;
#line 957 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
union __anonunion_data_27 {
   psiconv_s32 dat_int ;
   double dat_float ;
   psiconv_string_t dat_string ;
   psiconv_sheet_cell_reference_t dat_cellref ;
   psiconv_sheet_cell_block_t dat_cellblock ;
};
#line 957 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
struct psiconv_sheet_variable_s {
   psiconv_u32 number ;
   psiconv_string_t name ;
   psiconv_variable_type_t type ;
   union __anonunion_data_27 data ;
};
#line 957 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
typedef struct psiconv_sheet_variable_s *psiconv_sheet_variable;
#line 34 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/buffer.c"
struct psiconv_relocation_s {
   psiconv_u32 offset ;
   int id ;
};
#line 34 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/buffer.c"
typedef struct psiconv_relocation_s *psiconv_relocation;
#line 39 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/buffer.c"
struct psiconv_buffer_s {
   psiconv_list reloc_target ;
   psiconv_list reloc_ref ;
   psiconv_list data ;
};
#line 34 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/psiconv.h"
enum __anonenum_encoding_9 {
    ENCODING_UTF8 = 0,
    ENCODING_UCS2 = 1,
    ENCODING_PSION = 2,
    ENCODING_ASCII = 3,
    ENCODING_ASCII_HTML = 4
} ;
#line 34 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/psiconv.h"
typedef enum __anonenum_encoding_9 encoding;
#line 43 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/psiconv.h"
typedef int output_function(psiconv_config const   config , psiconv_list list , psiconv_file const   file ,
                            char const   *type , encoding const   encoding_type );
#line 48 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/psiconv.h"
struct fileformat_s {
   char const   *name ;
   char const   *description ;
   int supported_format ;
   output_function *output ;
};
#line 83 "../../compat/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 48 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/psiconv.h"
typedef struct fileformat_s *fileformat;
#line 50 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/common.h"
psiconv_u32 psiconv_checkuid(psiconv_u32 id1 , psiconv_u32 id2 , psiconv_u32 id3 ) ;
#line 28 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/checkuid.c"
static psiconv_u32 uid1___0[32]  = 
#line 28 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/checkuid.c"
  {      (psiconv_u32 )17824,      (psiconv_u32 )35648,      (psiconv_u32 )1697,      (psiconv_u32 )3394, 
        (psiconv_u32 )6788,      (psiconv_u32 )13576,      (psiconv_u32 )27152,      (psiconv_u32 )54304, 
        (psiconv_u32 )1168113664,      2336227328U,      (psiconv_u32 )111214592,      (psiconv_u32 )222429184, 
        (psiconv_u32 )444858368,      (psiconv_u32 )889716736,      (psiconv_u32 )1779433472,      3558866944U, 
        (psiconv_u32 )43601,      (psiconv_u32 )17539,      (psiconv_u32 )35078,      (psiconv_u32 )557, 
        (psiconv_u32 )1114,      (psiconv_u32 )2228,      (psiconv_u32 )4456,      (psiconv_u32 )8912, 
        2857435136U,      (psiconv_u32 )1149435904,      2298871808U,      (psiconv_u32 )36503552, 
        (psiconv_u32 )73007104,      (psiconv_u32 )146014208,      (psiconv_u32 )292028416,      (psiconv_u32 )584056832};
#line 62 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/checkuid.c"
static psiconv_u32 uid2___0[32]  = 
#line 62
  {      (psiconv_u32 )30388,      (psiconv_u32 )60776,      (psiconv_u32 )51953,      (psiconv_u32 )34243, 
        (psiconv_u32 )7079,      (psiconv_u32 )14158,      (psiconv_u32 )28316,      (psiconv_u32 )56632, 
        (psiconv_u32 )1991507968,      3983015936U,      3404791808U,      2244149248U, 
        (psiconv_u32 )463929344,      (psiconv_u32 )927858688,      (psiconv_u32 )1855717376,      3711434752U, 
        (psiconv_u32 )14128,      (psiconv_u32 )28256,      (psiconv_u32 )56512,      (psiconv_u32 )43425, 
        (psiconv_u32 )17251,      (psiconv_u32 )34502,      (psiconv_u32 )7597,      (psiconv_u32 )15194, 
        (psiconv_u32 )925892608,      (psiconv_u32 )1851785216,      3703570432U,      2845900800U, 
        (psiconv_u32 )1130561536,      2261123072U,      (psiconv_u32 )497876992,      (psiconv_u32 )995753984};
#line 96 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/checkuid.c"
static psiconv_u32 uid3___0[32]  = 
#line 96
  {      (psiconv_u32 )13105,      (psiconv_u32 )26210,      (psiconv_u32 )52420,      (psiconv_u32 )35241, 
        (psiconv_u32 )883,      (psiconv_u32 )1766,      (psiconv_u32 )3532,      (psiconv_u32 )7064, 
        (psiconv_u32 )858849280,      (psiconv_u32 )1717698560,      3435397120U,      2309554176U, 
        (psiconv_u32 )57868288,      (psiconv_u32 )115736576,      (psiconv_u32 )231473152,      (psiconv_u32 )462946304, 
        (psiconv_u32 )4129,      (psiconv_u32 )8258,      (psiconv_u32 )16516,      (psiconv_u32 )33032, 
        (psiconv_u32 )4657,      (psiconv_u32 )9314,      (psiconv_u32 )18628,      (psiconv_u32 )37256, 
        (psiconv_u32 )270598144,      (psiconv_u32 )541196288,      (psiconv_u32 )1082392576,      2164785152U, 
        (psiconv_u32 )305201152,      (psiconv_u32 )610402304,      (psiconv_u32 )1220804608,      2441609216U};
#line 131 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/checkuid.c"
psiconv_u32 psiconv_checkuid(psiconv_u32 id1 , psiconv_u32 id2 , psiconv_u32 id3 ) 
{ 
  psiconv_u32 i ;
  psiconv_u32 res ;

  {
#line 134
  res = (psiconv_u32 )0;
#line 135
  i = (psiconv_u32 )0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (i < 32U)) {
#line 135
      goto while_break;
    }
#line 136
    if (id1 & (unsigned int )(1 << i)) {
#line 137
      res ^= uid1___0[i];
    }
#line 138
    if (id2 & (unsigned int )(1 << i)) {
#line 139
      res ^= uid2___0[i];
    }
#line 140
    if (id3 & (unsigned int )(1 << i)) {
#line 141
      res ^= uid3___0[i];
    }
#line 135
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return (res);
}
}
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 48 "../psiconv/configuration.h"
psiconv_config psiconv_config_default(void) ;
#line 50
void psiconv_config_read(char const   *extra_config_files , psiconv_config *config ) ;
#line 53
void psiconv_config_free(psiconv_config config ) ;
#line 34 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/error.h"
void psiconv_error(psiconv_config config , int level , psiconv_u32 off , char const   *format 
                   , ...) ;
#line 38
void psiconv_progress(psiconv_config config , int level , psiconv_u32 off , char const   *format 
                      , ...) ;
#line 40
void psiconv_debug(psiconv_config config , int level , psiconv_u32 off , char const   *format 
                   , ...) ;
#line 37 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/unicode.h"
extern int psiconv_unicode_select_characterset(psiconv_config const   config , int charset ) ;
#line 150 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 489
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) index)(char const   *__s ,
                                                                                              int __c )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 43 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
static struct psiconv_config_s default_config  = 
#line 43 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
     {3, 2, 0, 0, 0, (psiconv_bool_t )0, (psiconv_error_handler_t *)((void *)0), (psiconv_u8 )'?',
    (psiconv_ucs2 )'?', {(psiconv_ucs2 )0}, (psiconv_bool_t )0};
#line 46
static void psiconv_config_parse_statement(char const   *filename , int linenr , char const   *var ,
                                           int value , psiconv_config *config ) ;
#line 51
static void psiconv_config_parse_line(char const   *filename , int linenr , char const   *line ,
                                      psiconv_config *config ) ;
#line 54
static void psiconv_config_parse_file(char const   *filename , psiconv_config *config ) ;
#line 57 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
psiconv_config psiconv_config_default(void) 
{ 
  psiconv_config result ;
  void *tmp ;

  {
  {
#line 60
  tmp = malloc(sizeof(*result));
#line 60
  result = (psiconv_config )tmp;
#line 61
  *result = default_config;
#line 62
  psiconv_unicode_select_characterset((psiconv_config const   )result, 1);
  }
#line 63
  return (result);
}
}
#line 66 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
void psiconv_config_free(psiconv_config config ) 
{ 


  {
  {
#line 68
  free((void *)config);
  }
#line 69
  return;
}
}
#line 71 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
static void psiconv_config_parse_statement(char const   *filename , int linenr , char const   *var ,
                                           int value , psiconv_config *config ) 
{ 
  int charnr ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 78
  tmp___9 = strcasecmp(var, "verbosity");
  }
#line 78
  if (tmp___9) {
    {
#line 84
    tmp___8 = strcasecmp(var, "color");
    }
#line 84
    if (tmp___8) {
      {
#line 90
      tmp___7 = strcasecmp(var, "colordepth");
      }
#line 90
      if (tmp___7) {
        {
#line 96
        tmp___6 = strcasecmp(var, "redbits");
        }
#line 96
        if (tmp___6) {
          {
#line 102
          tmp___5 = strcasecmp(var, "greenbits");
          }
#line 102
          if (tmp___5) {
            {
#line 108
            tmp___4 = strcasecmp(var, "bluebits");
            }
#line 108
            if (tmp___4) {
              {
#line 114
              tmp___3 = strcasecmp(var, "characterset");
              }
#line 114
              if (tmp___3) {
                {
#line 121
                tmp___2 = strcasecmp(var, "unknownunicodechar");
                }
#line 121
                if (tmp___2) {
                  {
#line 128
                  tmp___1 = strcasecmp(var, "unknownepocchar");
                  }
#line 128
                  if (tmp___1) {
                    {
#line 135
                    tmp = sscanf((char const   */* __restrict  */)var, (char const   */* __restrict  */)"char%d",
                                 & charnr);
#line 135
                    tmp___0 = strlen(var);
                    }
#line 135
                    if ((size_t )tmp == tmp___0) {
#line 136
                      if (charnr < 0) {
                        {
#line 137
                        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharXXX should have XXX between 0 and 255",
                                      filename, linenr);
                        }
                      } else
#line 136
                      if (charnr > 255) {
                        {
#line 137
                        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharXXX should have XXX between 0 and 255",
                                      filename, linenr);
                        }
                      }
#line 140
                      if (value >= 1) {
#line 140
                        if (value <= 65536) {
#line 141
                          (*config)->unicode_table[charnr] = (psiconv_ucs2 )value;
                        } else {
                          {
#line 143
                          psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharXXX should be between 1 and 65535",
                                        filename, linenr);
                          }
                        }
                      } else {
                        {
#line 143
                        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharXXX should be between 1 and 65535",
                                      filename, linenr);
                        }
                      }
                    } else {
                      {
#line 147
                      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Unknown variable %s",
                                    filename, linenr, var);
                      }
                    }
                  } else
#line 129
                  if (value >= 1) {
#line 129
                    if (value < 256) {
#line 130
                      (*config)->unknown_epoc_char = (psiconv_u8 )value;
                    } else {
                      {
#line 132
                      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: UnknownEPOCChar should be between 1 and 255",
                                    filename, linenr);
                      }
                    }
                  } else {
                    {
#line 132
                    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: UnknownEPOCChar should be between 1 and 255",
                                  filename, linenr);
                    }
                  }
                } else
#line 122
                if (value >= 1) {
#line 122
                  if (value < 65536) {
#line 123
                    (*config)->unknown_unicode_char = (psiconv_ucs2 )value;
                  } else {
                    {
#line 125
                    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: UnknownUnicodeChar should be between 1 and 65535",
                                  filename, linenr);
                    }
                  }
                } else {
                  {
#line 125
                  psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: UnknownUnicodeChar should be between 1 and 65535",
                                filename, linenr);
                  }
                }
              } else
#line 115
              if (value >= 0) {
#line 115
                if (value <= 1) {
                  {
#line 116
                  psiconv_unicode_select_characterset((psiconv_config const   )*config,
                                                      value);
                  }
                } else {
                  {
#line 118
                  psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharacterSet should be between 0 and 1",
                                filename, linenr);
                  }
                }
              } else {
                {
#line 118
                psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharacterSet should be between 0 and 1",
                              filename, linenr);
                }
              }
            } else
#line 109
            if (value >= 0) {
#line 109
              if (value <= 32) {
#line 110
                (*config)->bluebits = value;
              } else {
                {
#line 112
                psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: BlueBits should be between 1 and 32 or 0",
                              filename, linenr);
                }
              }
            } else {
              {
#line 112
              psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: BlueBits should be between 1 and 32 or 0",
                            filename, linenr);
              }
            }
          } else
#line 103
          if (value >= 0) {
#line 103
            if (value <= 32) {
#line 104
              (*config)->greenbits = value;
            } else {
              {
#line 106
              psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: GreenBits should be between 1 and 32 or 0",
                            filename, linenr);
              }
            }
          } else {
            {
#line 106
            psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: GreenBits should be between 1 and 32 or 0",
                          filename, linenr);
            }
          }
        } else
#line 97
        if (value >= 0) {
#line 97
          if (value <= 32) {
#line 98
            (*config)->redbits = value;
          } else {
            {
#line 100
            psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: RedBits should be between 1 and 32 or 0",
                          filename, linenr);
            }
          }
        } else {
          {
#line 100
          psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: RedBits should be between 1 and 32 or 0",
                        filename, linenr);
          }
        }
      } else
#line 91
      if (value > 0) {
#line 91
        if (value <= 32) {
#line 92
          (*config)->colordepth = value;
        } else {
          {
#line 94
          psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: ColorDepth should be between 1 and 32",
                        filename, linenr);
          }
        }
      } else {
        {
#line 94
        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: ColorDepth should be between 1 and 32",
                      filename, linenr);
        }
      }
    } else
#line 85
    if (value == 0) {
#line 86
      (*config)->color = (psiconv_bool_t )value;
    } else
#line 85
    if (value == 1) {
#line 86
      (*config)->color = (psiconv_bool_t )value;
    } else {
      {
#line 88
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Color should be 0 or 1",
                    filename, linenr);
      }
    }
  } else
#line 79
  if (value >= 1) {
#line 79
    if (value <= 5) {
#line 80
      (*config)->verbosity = value;
    } else {
      {
#line 82
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Verbosity should be between 1 and 5",
                    filename, linenr);
      }
    }
  } else {
    {
#line 82
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Verbosity should be between 1 and 5",
                  filename, linenr);
    }
  }
  {
#line 150
  psiconv_debug(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Set variable %s to %d",
                filename, linenr, var, value);
  }
#line 152
  return;
}
}
#line 155 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
static void psiconv_config_parse_line(char const   *filename , int linenr , char const   *line ,
                                      psiconv_config *config ) 
{ 
  int sovar ;
  int eovar ;
  int soval ;
  int eoval ;
  int eol ;
  char *var ;
  long val ;
  void *tmp ;

  {
  {
#line 163
  psiconv_debug(*config, 0, (psiconv_u32 )0, "Going to parse line %d: %s", linenr,
                line);
#line 164
  sovar = 0;
  }
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (*(line + sovar)) {
#line 165
      if (! ((int const   )*(line + sovar) < 32)) {
#line 165
        goto while_break;
      }
    } else {
#line 165
      goto while_break;
    }
#line 166
    sovar ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  if (! *(line + sovar)) {
#line 168
    return;
  } else
#line 167
  if ((int const   )*(line + sovar) == 35) {
#line 168
    return;
  }
#line 169
  eovar = sovar;
  {
#line 170
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 170
    if (*(line + eovar)) {
#line 170
      if ((int const   )*(line + eovar) >= 65) {
#line 170
        if (! ((int const   )*(line + eovar) <= 90)) {
#line 170
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 170
      if ((int const   )*(line + eovar) >= 97) {
#line 170
        if (! ((int const   )*(line + eovar) <= 122)) {
#line 170
          goto while_break___0;
        }
      } else {
#line 170
        goto while_break___0;
      }
    } else {
#line 170
      goto while_break___0;
    }
#line 172
    eovar ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 173
  if (sovar == eovar) {
    {
#line 174
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (no variable found)",
                  filename, linenr);
    }
#line 176
    return;
  }
#line 178
  soval = eovar;
  {
#line 179
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 179
    if (*(line + soval)) {
#line 179
      if (! ((int const   )*(line + soval) <= 32)) {
#line 179
        goto while_break___1;
      }
    } else {
#line 179
      goto while_break___1;
    }
#line 180
    soval ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 181
  if ((int const   )*(line + soval) != 61) {
    {
#line 182
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (no = token found)",
                  filename, linenr);
    }
#line 184
    return;
  }
#line 186
  soval ++;
  {
#line 187
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 187
    if (*(line + soval)) {
#line 187
      if (! ((int const   )*(line + soval) <= 32)) {
#line 187
        goto while_break___2;
      }
    } else {
#line 187
      goto while_break___2;
    }
#line 188
    soval ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 189
  eoval = soval;
  {
#line 190
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 190
    if (*(line + eoval)) {
#line 190
      if ((int const   )*(line + eoval) >= 48) {
#line 190
        if (! ((int const   )*(line + eoval) <= 57)) {
#line 190
          goto while_break___3;
        }
      } else {
#line 190
        goto while_break___3;
      }
    } else {
#line 190
      goto while_break___3;
    }
#line 191
    eoval ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 192
  if (eoval == soval) {
    {
#line 193
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (no value found)",
                  filename, linenr);
    }
#line 195
    return;
  }
#line 197
  if (soval - eoval > 7) {
    {
#line 198
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (value too large)",
                  filename, linenr);
    }
#line 200
    return;
  }
#line 202
  eol = eoval;
  {
#line 203
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 203
    if (*(line + eol)) {
#line 203
      if (! ((int const   )*(line + eol) < 32)) {
#line 203
        goto while_break___4;
      }
    } else {
#line 203
      goto while_break___4;
    }
#line 204
    eol ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 205
  if (*(line + eol)) {
    {
#line 206
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (trailing garbage)",
                  filename, linenr);
    }
#line 208
    return;
  }
  {
#line 211
  tmp = malloc((size_t )((eovar - sovar) + 1));
#line 211
  var = (char *)tmp;
#line 212
  memcpy((void */* __restrict  */)var, (void const   */* __restrict  */)(line + sovar),
         (size_t )(eovar - sovar));
#line 213
  *(var + (eovar - sovar)) = (char)0;
#line 215
  val = atol(line + soval);
#line 217
  psiconv_config_parse_statement(filename, linenr, (char const   *)var, (int )val,
                                 config);
#line 218
  free((void *)var);
  }
#line 219
  return;
}
}
#line 222 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
static void psiconv_config_parse_file(char const   *filename , psiconv_config *config ) 
{ 
  int file ;
  int linenr ;
  struct stat stat_buf ;
  off_t filesize ;
  off_t bytes_left ;
  off_t bytes_read ;
  off_t sol ;
  off_t eol ;
  char *filebuffer ;
  char *filebuffer_ptr ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 229
  psiconv_progress(*config, 0, (psiconv_u32 )0, "Going to access configuration file %s",
                   filename);
#line 233
  file = open(filename, 0);
  }
#line 233
  if (file == -1) {
#line 234
    goto ERROR0;
  }
  {
#line 237
  tmp___0 = fstat(file, & stat_buf);
  }
#line 237
  if (tmp___0) {
    {
#line 238
    tmp = close(file);
    }
#line 238
    if (tmp) {
      {
#line 239
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Couldn\'t close file",
                    filename);
      }
    }
#line 241
    return;
  }
  {
#line 244
  filesize = stat_buf.st_size;
#line 245
  tmp___1 = malloc((size_t )(filesize + 1L));
#line 245
  filebuffer = (char *)tmp___1;
  }
#line 245
  if (! filebuffer) {
    {
#line 246
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Out of memory error",
                  filename);
    }
#line 248
    goto ERROR1;
  }
#line 251
  filebuffer_ptr = filebuffer;
#line 252
  bytes_left = filesize;
#line 253
  bytes_read = (off_t )1;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (bytes_read > 0L) {
#line 254
      if (! bytes_left) {
#line 254
        goto while_break;
      }
    } else {
#line 254
      goto while_break;
    }
    {
#line 255
    bytes_read = read(file, (void *)filebuffer_ptr, (size_t )bytes_left);
    }
#line 256
    if (bytes_read > 0L) {
#line 257
      filebuffer_ptr += bytes_read;
#line 258
      bytes_left -= bytes_read;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  if (bytes_left) {
#line 263
    if (bytes_left != filesize) {
      {
#line 264
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Couldn\'t read file into memory",
                    filename);
      }
#line 266
      goto ERROR2;
    }
  }
  {
#line 269
  tmp___2 = close(file);
  }
#line 269
  if (tmp___2) {
    {
#line 270
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Couldn\'t close file",
                  filename);
#line 272
    file = -1;
    }
#line 273
    goto ERROR2;
  }
  {
#line 275
  file = -1;
#line 277
  psiconv_progress(*config, 0, (psiconv_u32 )0, "Going to parse configuration file %s: ",
                   filename);
#line 280
  linenr = 0;
#line 281
  sol = (off_t )0;
  }
  {
#line 283
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 283
    if (! (sol < filesize)) {
#line 283
      goto while_break___0;
    }
#line 284
    linenr ++;
#line 285
    eol = sol;
    {
#line 286
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 286
      if (eol < filesize) {
#line 286
        if ((int )*(filebuffer + eol) != 13) {
#line 286
          if ((int )*(filebuffer + eol) != 10) {
#line 286
            if (! ((int )*(filebuffer + eol) != 0)) {
#line 286
              goto while_break___1;
            }
          } else {
#line 286
            goto while_break___1;
          }
        } else {
#line 286
          goto while_break___1;
        }
      } else {
#line 286
        goto while_break___1;
      }
#line 288
      eol ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 290
    if (eol < filesize) {
#line 290
      if ((int )*(filebuffer + eol) == 0) {
        {
#line 291
        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Unexpected character \000 found",
                      filename, linenr);
        }
#line 293
        goto ERROR2;
      }
    }
#line 295
    if (eol < filesize + 1L) {
#line 295
      if ((int )*(filebuffer + eol) == 13) {
#line 295
        if ((int )*(filebuffer + (eol + 1L)) == 10) {
#line 298
          *(filebuffer + eol) = (char)0;
#line 299
          eol ++;
        } else {
#line 295
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 295
      if ((int )*(filebuffer + eol) == 10) {
#line 295
        if ((int )*(filebuffer + (eol + 1L)) == 13) {
#line 298
          *(filebuffer + eol) = (char)0;
#line 299
          eol ++;
        }
      }
    }
    {
#line 301
    *(filebuffer + eol) = (char)0;
#line 302
    psiconv_config_parse_line(filename, linenr, (char const   *)(filebuffer + sol),
                              config);
#line 303
    sol = eol + 1L;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 305
  free((void *)filebuffer);
  }
#line 306
  return;
  ERROR2: 
  {
#line 309
  free((void *)filebuffer);
  }
  ERROR1: 
#line 311
  if (file != -1) {
    {
#line 311
    tmp___3 = close(file);
    }
#line 311
    if (tmp___3) {
      {
#line 312
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Couldn\'t close file",
                    filename);
      }
    }
  }
  ERROR0: 
#line 315
  return;
}
}
#line 318 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
void psiconv_config_read(char const   *extra_config_files , psiconv_config *config ) 
{ 
  char *path ;
  char *pathptr ;
  char *filename ;
  char *filename_old ;
  char const   *home ;
  int filename_len ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;

  {
#line 326
  if (extra_config_files) {
    {
#line 326
    tmp___2 = strlen(extra_config_files);
    }
#line 326
    if (tmp___2) {
      {
#line 327
      tmp = strlen("/usr/local/etc/psiconv/psiconv.conf:~/.psiconv.conf");
#line 327
      tmp___0 = strlen(extra_config_files);
#line 327
      tmp___1 = malloc((tmp + tmp___0) + 2UL);
#line 327
      path = (char *)tmp___1;
#line 329
      strcpy((char */* __restrict  */)path, (char const   */* __restrict  */)"/usr/local/etc/psiconv/psiconv.conf:~/.psiconv.conf");
#line 330
      strcat((char */* __restrict  */)path, (char const   */* __restrict  */)":");
#line 331
      strcat((char */* __restrict  */)path, (char const   */* __restrict  */)extra_config_files);
      }
    } else {
      {
#line 333
      path = strdup("/usr/local/etc/psiconv/psiconv.conf:~/.psiconv.conf");
      }
    }
  } else {
    {
#line 333
    path = strdup("/usr/local/etc/psiconv/psiconv.conf:~/.psiconv.conf");
    }
  }
#line 336
  pathptr = path;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 337
    tmp___14 = strlen((char const   *)pathptr);
    }
#line 337
    if (! tmp___14) {
#line 337
      goto while_break;
    }
    {
#line 339
    tmp___6 = index((char const   *)pathptr, ':');
    }
#line 339
    if (tmp___6) {
      {
#line 339
      tmp___4 = index((char const   *)pathptr, ':');
#line 339
      filename_len = (int )(tmp___4 - pathptr);
      }
    } else {
      {
#line 339
      tmp___5 = strlen((char const   *)pathptr);
#line 339
      filename_len = (int )tmp___5;
      }
    }
    {
#line 341
    tmp___7 = malloc((size_t )(filename_len + 1));
#line 341
    filename = (char *)tmp___7;
#line 342
    filename = strncpy((char */* __restrict  */)filename, (char const   */* __restrict  */)pathptr,
                       (size_t )filename_len);
#line 343
    *(filename + filename_len) = (char)0;
#line 344
    pathptr += filename_len;
#line 345
    tmp___8 = strlen((char const   *)pathptr);
    }
#line 345
    if (tmp___8) {
#line 346
      pathptr ++;
    }
#line 349
    if ((int )*(filename + 0) == 126) {
#line 349
      if ((int )*(filename + 1) == 47) {
#line 349
        goto _L;
      } else
#line 349
      if ((int )*(filename + 1) == 0) {
        _L: /* CIL Label */ 
        {
#line 350
        tmp___9 = getenv("HOME");
#line 350
        home = (char const   *)tmp___9;
        }
#line 351
        if (home) {
          {
#line 352
          filename_old = filename;
#line 353
          tmp___10 = strlen((char const   *)filename_old);
#line 353
          tmp___11 = strlen(home);
#line 353
          tmp___12 = malloc(tmp___10 + tmp___11);
#line 353
          filename = (char *)tmp___12;
#line 354
          strcpy((char */* __restrict  */)filename, (char const   */* __restrict  */)home);
#line 355
          tmp___13 = strlen((char const   *)filename);
#line 355
          strcpy((char */* __restrict  */)(filename + tmp___13), (char const   */* __restrict  */)(filename_old + 1));
#line 356
          free((void *)filename_old);
          }
        }
      }
    }
    {
#line 360
    psiconv_config_parse_file((char const   *)filename, config);
#line 361
    free((void *)filename);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 363
  free((void *)path);
  }
#line 364
  return;
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 45 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.h"
psiconv_list psiconv_list_new(size_t element_size ) ;
#line 49
void psiconv_list_free(psiconv_list l ) ;
#line 54
void psiconv_list_free_el(psiconv_list l , void (*free_el)(void *el ) ) ;
#line 57
psiconv_u32 psiconv_list_length(psiconv_list const   l ) ;
#line 60
int psiconv_list_is_empty(psiconv_list const   l ) ;
#line 63
void psiconv_list_empty(psiconv_list l ) ;
#line 69
void *psiconv_list_get(psiconv_list const   l , psiconv_u32 indx ) ;
#line 77
int psiconv_list_add(psiconv_list l , void const   *el ) ;
#line 84
int psiconv_list_pop(psiconv_list l , void *el ) ;
#line 89
int psiconv_list_replace(psiconv_list l , psiconv_u32 indx , void const   *el ) ;
#line 95
void psiconv_list_foreach_el(psiconv_list l , void (*action)(void *el ) ) ;
#line 100
psiconv_list psiconv_list_clone(psiconv_list const   l ) ;
#line 106
size_t psiconv_list_fread(psiconv_list l , size_t size , FILE *f ) ;
#line 110
int psiconv_list_fread_all(psiconv_list l , FILE *f ) ;
#line 114
int psiconv_list_fwrite_all(psiconv_list const   l , FILE *f ) ;
#line 118
int psiconv_list_concat(psiconv_list l , psiconv_list const   extra ) ;
#line 36 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
static int psiconv_list_resize(psiconv_list l , psiconv_u32 nr ) ;
#line 45 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
psiconv_list psiconv_list_new(size_t element_size ) 
{ 
  psiconv_list l ;
  void *tmp ;

  {
  {
#line 48
  tmp = malloc(sizeof(*l));
#line 48
  l = (psiconv_list )tmp;
  }
#line 49
  if (! l) {
#line 50
    return ((psiconv_list )((void *)0));
  }
#line 51
  l->cur_len = (psiconv_u32 )0;
#line 52
  l->max_len = (psiconv_u32 )0;
#line 53
  l->el_size = element_size;
#line 54
  l->els = (void *)0;
#line 55
  return (l);
}
}
#line 58 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
void psiconv_list_free(psiconv_list l ) 
{ 


  {
#line 60
  if (l->max_len) {
    {
#line 61
    free(l->els);
    }
  }
  {
#line 62
  free((void *)l);
#line 63
  l = (psiconv_list )((void *)0);
  }
#line 64
  return;
}
}
#line 66 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
void psiconv_list_free_el(psiconv_list l , void (*free_el)(void *el ) ) 
{ 


  {
  {
#line 68
  psiconv_list_foreach_el(l, free_el);
#line 69
  psiconv_list_free(l);
  }
#line 70
  return;
}
}
#line 72 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
psiconv_u32 psiconv_list_length(psiconv_list const   l ) 
{ 


  {
#line 74
  return (l->cur_len);
}
}
#line 77 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
int psiconv_list_is_empty(psiconv_list const   l ) 
{ 


  {
#line 79
  return (l->cur_len == 0U);
}
}
#line 82 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
void psiconv_list_empty(psiconv_list l ) 
{ 


  {
#line 84
  l->cur_len = (psiconv_u32 )0;
#line 85
  return;
}
}
#line 87 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
void *psiconv_list_get(psiconv_list const   l , psiconv_u32 indx ) 
{ 


  {
#line 89
  if (indx >= l->cur_len) {
#line 90
    return ((void *)0);
  } else {
#line 92
    return ((void *)((char *)l->els + (size_t )indx * l->el_size));
  }
}
}
#line 95 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
int psiconv_list_add(psiconv_list l , void const   *el ) 
{ 
  int res ;

  {
  {
#line 98
  res = psiconv_list_resize(l, l->cur_len + 1U);
  }
#line 98
  if (res) {
#line 99
    return (res);
  }
  {
#line 100
  memcpy((void */* __restrict  */)((char *)l->els + (size_t )l->cur_len * l->el_size),
         (void const   */* __restrict  */)el, l->el_size);
#line 101
  (l->cur_len) ++;
  }
#line 102
  return (0);
}
}
#line 105 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
int psiconv_list_pop(psiconv_list l , void *el ) 
{ 


  {
#line 107
  if (! l->cur_len) {
#line 108
    return (-1);
  }
  {
#line 109
  (l->cur_len) --;
#line 110
  memcpy((void */* __restrict  */)el, (void const   */* __restrict  */)((char *)l->els + (size_t )l->cur_len * l->el_size),
         l->el_size);
  }
#line 111
  return (0);
}
}
#line 114 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
int psiconv_list_replace(psiconv_list l , psiconv_u32 indx , void const   *el ) 
{ 


  {
#line 116
  if (indx >= l->cur_len) {
#line 117
    return (-1);
  }
  {
#line 118
  memcpy((void */* __restrict  */)((char *)l->els + (size_t )indx * l->el_size), (void const   */* __restrict  */)el,
         l->el_size);
  }
#line 119
  return (0);
}
}
#line 122 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
void psiconv_list_foreach_el(psiconv_list l , void (*action)(void *el ) ) 
{ 
  psiconv_u32 i ;
  void *tmp ;

  {
#line 125
  i = (psiconv_u32 )0;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! (i < l->cur_len)) {
#line 125
      goto while_break;
    }
    {
#line 126
    tmp = psiconv_list_get((psiconv_list const   )l, i);
#line 126
    (*action)(tmp);
#line 125
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  return;
}
}
#line 129 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
psiconv_list psiconv_list_clone(psiconv_list const   l ) 
{ 
  psiconv_list l2 ;
  psiconv_u32 i ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 133
  l2 = psiconv_list_new(l->el_size);
  }
#line 134
  if (! l2) {
#line 135
    return ((psiconv_list )((void *)0));
  }
#line 136
  i = (psiconv_u32 )0;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! (i < l->cur_len)) {
#line 136
      goto while_break;
    }
    {
#line 137
    tmp = psiconv_list_get(l, i);
#line 137
    tmp___0 = psiconv_list_add(l2, (void const   *)tmp);
    }
#line 137
    if (tmp___0) {
      {
#line 138
      psiconv_list_free(l2);
      }
#line 139
      return ((psiconv_list )((void *)0));
    }
#line 136
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  return (l2);
}
}
#line 145 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
size_t psiconv_list_fread(psiconv_list l , size_t size , FILE *f ) 
{ 
  size_t res ;
  int tmp ;

  {
  {
#line 148
  tmp = psiconv_list_resize(l, (psiconv_u32 )((size_t )l->cur_len + size));
  }
#line 148
  if (tmp) {
#line 149
    return ((size_t )0);
  }
  {
#line 150
  res = fread((void */* __restrict  */)((char *)l->els + (size_t )l->cur_len * l->el_size),
              l->el_size, size, (FILE */* __restrict  */)f);
#line 151
  l->cur_len = (psiconv_u32 )((size_t )l->cur_len + res);
  }
#line 152
  return (res);
}
}
#line 155 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
int psiconv_list_fread_all(psiconv_list l , FILE *f ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 157
    tmp___1 = feof(f);
    }
#line 157
    if (tmp___1) {
#line 157
      goto while_break;
    }
    {
#line 158
    tmp = psiconv_list_fread(l, (size_t )1024, f);
    }
#line 158
    if (! tmp) {
      {
#line 158
      tmp___0 = feof(f);
      }
#line 158
      if (! tmp___0) {
#line 159
        return (-2);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return (0);
}
}
#line 164 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
int psiconv_list_fwrite_all(psiconv_list const   l , FILE *f ) 
{ 
  psiconv_u32 pos ;
  psiconv_u32 written ;
  psiconv_u32 len ;
  psiconv_u32 tmp ;
  size_t tmp___0 ;

  {
  {
#line 166
  pos = (psiconv_u32 )0;
#line 168
  tmp = psiconv_list_length(l);
#line 168
  len = tmp;
  }
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (pos < len)) {
#line 169
      goto while_break;
    }
    {
#line 170
    tmp___0 = fwrite((void const   */* __restrict  */)((char *)l->els + (size_t )pos * l->el_size),
                     l->el_size, (size_t )(len - pos), (FILE */* __restrict  */)f);
#line 170
    written = (psiconv_u32 )tmp___0;
    }
#line 170
    if (! written) {
#line 172
      return (-1);
    }
#line 173
    pos += written;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  return (0);
}
}
#line 178 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
static int psiconv_list_resize(psiconv_list l , psiconv_u32 nr ) 
{ 
  void *temp ;

  {
#line 181
  if (nr > l->max_len) {
    {
#line 182
    l->max_len = (psiconv_u32 )(1.1 * (double )nr);
#line 183
    l->max_len += 16U - l->max_len % 16U;
#line 184
    temp = realloc(l->els, (size_t )l->max_len * l->el_size);
    }
#line 185
    if (temp) {
#line 186
      l->els = temp;
#line 187
      return (0);
    } else {
#line 189
      return (-2);
    }
  }
#line 191
  return (0);
}
}
#line 194 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
int psiconv_list_concat(psiconv_list l , psiconv_list const   extra ) 
{ 
  int res ;

  {
#line 197
  if (l->el_size != extra->el_size) {
#line 198
    return (-1);
  }
  {
#line 199
  res = psiconv_list_resize(l, l->cur_len + extra->cur_len);
  }
#line 199
  if (res) {
#line 201
    return (res);
  }
  {
#line 203
  memcpy((void */* __restrict  */)((char *)l->els + (size_t )l->cur_len * l->el_size),
         (void const   */* __restrict  */)extra->els, (size_t )extra->cur_len * extra->el_size);
#line 205
  l->cur_len += extra->cur_len;
  }
#line 206
  return (0);
}
}
#line 1060 "../psiconv/data.h"
psiconv_paragraph_layout psiconv_clone_paragraph_layout(psiconv_paragraph_layout ls ) ;
#line 1063
psiconv_character_layout psiconv_clone_character_layout(psiconv_character_layout ls ) ;
#line 1067
psiconv_word_style psiconv_get_style(psiconv_word_styles_section ss , int nr ) ;
#line 1090
void psiconv_free_paragraph_layout(psiconv_paragraph_layout layout ) ;
#line 1091
void psiconv_free_character_layout(psiconv_character_layout layout ) ;
#line 1094
void psiconv_free_word_styles_section(psiconv_word_styles_section styles___1 ) ;
#line 1175
int psiconv_compare_paragraph_layout(psiconv_paragraph_layout const   value1 , psiconv_paragraph_layout const   value2 ) ;
#line 1179
int psiconv_compare_character_layout(psiconv_character_layout const   value1 , psiconv_character_layout const   value2 ) ;
#line 40 "../psiconv/buffer.h"
psiconv_buffer psiconv_buffer_new(void) ;
#line 44
void psiconv_buffer_free(psiconv_buffer buf ) ;
#line 47
psiconv_u32 psiconv_buffer_length(psiconv_buffer const   buf ) ;
#line 75
int psiconv_buffer_concat(psiconv_buffer buf , psiconv_buffer const   extra ) ;
#line 81
int psiconv_buffer_add_target(psiconv_buffer buf , int id ) ;
#line 88
int psiconv_buffer_add_reference(psiconv_buffer buf , int id ) ;
#line 91
int psiconv_buffer_resolve(psiconv_buffer buf ) ;
#line 94
psiconv_u32 psiconv_buffer_unique_id(void) ;
#line 48 "../psiconv/unicode.h"
int psiconv_unicode_write_char(psiconv_config const   config , psiconv_buffer buf ,
                               int lev , psiconv_ucs2 value ) ;
#line 55
int psiconv_unicode_strlen(psiconv_ucs2 const   *input ) ;
#line 64
psiconv_ucs2 *psiconv_unicode_empty_string(void) ;
#line 40 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_routines.h"
int psiconv_write_u8(psiconv_config const   config , psiconv_buffer buf , int lev ,
                     psiconv_u8 const   value ) ;
#line 42
int psiconv_write_u16(psiconv_config const   config , psiconv_buffer buf , int lev ,
                      psiconv_u16 const   value ) ;
#line 44
int psiconv_write_u32(psiconv_config const   config , psiconv_buffer buf , int lev ,
                      psiconv_u32 const   value ) ;
#line 48
int psiconv_write_X(psiconv_config const   config , psiconv_buffer buf , int lev ,
                    psiconv_u32 const   value ) ;
#line 50
int psiconv_write_length(psiconv_config const   config , psiconv_buffer buf , int lev ,
                         psiconv_length_t const   value ) ;
#line 61
int psiconv_write_string(psiconv_config const   config , psiconv_buffer buf , int lev ,
                         psiconv_string_t const   value ) ;
#line 66
int psiconv_write_offset(psiconv_config const   config , psiconv_buffer buf , int lev ,
                         psiconv_u32 const   id ) ;
#line 83
int psiconv_write_paragraph_layout_list(psiconv_config const   config , psiconv_buffer buf ,
                                        int lev , psiconv_paragraph_layout const   value ,
                                        psiconv_paragraph_layout const   base ) ;
#line 87
int psiconv_write_character_layout_list(psiconv_config const   config , psiconv_buffer buf ,
                                        int lev , psiconv_character_layout const   value ,
                                        psiconv_character_layout const   base ) ;
#line 108
int psiconv_write_header_section(psiconv_config const   config , psiconv_buffer buf ,
                                 int lev , psiconv_u32 uid1___5 , psiconv_u32 uid2___5 ,
                                 psiconv_u32 uid3___5 ) ;
#line 111
int psiconv_write_section_table_section(psiconv_config const   config , psiconv_buffer buf ,
                                        int lev , psiconv_section_table_section const   value ) ;
#line 114
int psiconv_write_application_id_section(psiconv_config const   config , psiconv_buffer buf ,
                                         int lev , psiconv_u32 id , psiconv_string_t const   text___3 ) ;
#line 117
int psiconv_write_text_section(psiconv_config const   config , psiconv_buffer buf ,
                               int lev , psiconv_text_and_layout const   value ) ;
#line 120
int psiconv_write_styled_layout_section(psiconv_config const   config , psiconv_buffer buf ,
                                        int lev , psiconv_text_and_layout const   result ,
                                        psiconv_word_styles_section const   styles___1 ) ;
#line 124
int psiconv_write_styleless_layout_section(psiconv_config const   config , psiconv_buffer buf ,
                                           int lev , psiconv_text_and_layout const   value ,
                                           psiconv_character_layout const   base_char ,
                                           psiconv_paragraph_layout const   base_para ) ;
#line 129
int psiconv_write_embedded_object_section(psiconv_config const   config , psiconv_buffer buf ,
                                          int lev , psiconv_embedded_object_section const   value ) ;
#line 132
int psiconv_write_object_display_section(psiconv_config const   config , psiconv_buffer buf ,
                                         int lev , psiconv_object_display_section const   value ) ;
#line 135
int psiconv_write_object_icon_section(psiconv_config const   config , psiconv_buffer buf ,
                                      int lev , psiconv_object_icon_section const   value ) ;
#line 191
int psiconv_write_word_file(psiconv_config const   config , psiconv_buffer buf , int lev ,
                            psiconv_word_f const   value ) ;
#line 198
int psiconv_write_sketch_file(psiconv_config const   config , psiconv_buffer buf ,
                              int lev , psiconv_sketch_f const   value ) ;
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_common.c"
static int psiconv_write_layout_section(psiconv_config const   config , psiconv_buffer buf ,
                                        int lev , psiconv_text_and_layout const   value ,
                                        psiconv_word_styles_section const   styles___1 ,
                                        int with_styles ) ;
#line 39 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_common.c"
int psiconv_write_header_section(psiconv_config const   config , psiconv_buffer buf ,
                                 int lev , psiconv_u32 uid1___5 , psiconv_u32 uid2___5 ,
                                 psiconv_u32 uid3___5 ) 
{ 
  int res ;
  psiconv_u32 tmp ;

  {
  {
#line 44
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing header section");
#line 45
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )uid1___5);
  }
#line 45
  if (res) {
#line 46
    goto ERROR;
  }
  {
#line 47
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )uid2___5);
  }
#line 47
  if (res) {
#line 48
    goto ERROR;
  }
  {
#line 49
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )uid3___5);
  }
#line 49
  if (res) {
#line 50
    goto ERROR;
  }
  {
#line 51
  tmp = psiconv_checkuid(uid1___5, uid2___5, uid3___5);
#line 51
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )tmp);
  }
#line 51
  if (res) {
#line 53
    goto ERROR;
  }
  {
#line 54
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of header section");
  }
#line 55
  return (0);
  ERROR: 
  {
#line 58
  psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of header section failed");
  }
#line 59
  return (res);
}
}
#line 62 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_common.c"
int psiconv_write_section_table_section(psiconv_config const   config , psiconv_buffer buf ,
                                        int lev , psiconv_section_table_section const   value ) 
{ 
  int res ;
  int i ;
  psiconv_section_table_entry entry ;
  psiconv_u32 tmp ;
  void *tmp___0 ;
  psiconv_u32 tmp___1 ;

  {
  {
#line 69
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing section table section");
  }
#line 70
  if (! value) {
    {
#line 71
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null section table section");
#line 72
    res = -4;
    }
#line 73
    goto ERROR;
  }
  {
#line 76
  tmp = psiconv_list_length(value);
#line 76
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )(2U * tmp));
  }
#line 76
  if (res) {
#line 77
    goto ERROR;
  }
#line 78
  i = 0;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 78
    tmp___1 = psiconv_list_length(value);
    }
#line 78
    if (! ((psiconv_u32 )i < tmp___1)) {
#line 78
      goto while_break;
    }
    {
#line 79
    tmp___0 = psiconv_list_get(value, (psiconv_u32 )i);
#line 79
    entry = (psiconv_section_table_entry )tmp___0;
    }
#line 79
    if (! entry) {
      {
#line 80
      psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Data structure corruption");
#line 81
      res = -2;
      }
#line 82
      goto ERROR;
    }
    {
#line 84
    res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )entry->id);
    }
#line 84
    if (res) {
#line 85
      goto ERROR;
    }
    {
#line 86
    res = psiconv_write_offset(config, buf, lev + 1, (psiconv_u32 const   )entry->offset);
    }
#line 86
    if (res) {
#line 87
      goto ERROR;
    }
#line 78
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of section table section");
  }
#line 90
  return (0);
  ERROR: 
  {
#line 93
  psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of section table section failed");
  }
#line 94
  return (res);
}
}
#line 97 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_common.c"
int psiconv_write_application_id_section(psiconv_config const   config , psiconv_buffer buf ,
                                         int lev , psiconv_u32 id , psiconv_string_t const   text___3 ) 
{ 
  int res ;

  {
  {
#line 102
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing application id section");
#line 103
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )id);
  }
#line 103
  if (res) {
#line 104
    goto ERROR;
  }
  {
#line 105
  res = psiconv_write_string(config, buf, lev + 1, text___3);
  }
#line 105
  if (res) {
#line 106
    goto ERROR;
  }
  {
#line 107
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of application id section");
  }
#line 108
  return (0);
  ERROR: 
  {
#line 110
  psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of application id section failed");
  }
#line 111
  return (res);
}
}
#line 114 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_common.c"
int psiconv_write_text_section(psiconv_config const   config , psiconv_buffer buf ,
                               int lev , psiconv_text_and_layout const   value ) 
{ 
  int res ;
  psiconv_buffer extra_buf ;
  int i ;
  int j ;
  psiconv_paragraph paragraph___3 ;
  void *tmp ;
  int tmp___0 ;
  psiconv_u32 tmp___1 ;
  psiconv_u32 tmp___2 ;
  psiconv_u32 tmp___3 ;

  {
  {
#line 119
  extra_buf = (psiconv_buffer )((void *)0);
#line 123
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing text section");
  }
#line 124
  if (! value) {
    {
#line 125
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Null text section");
#line 126
    res = -4;
    }
#line 127
    goto ERROR;
  }
  {
#line 130
  tmp___3 = psiconv_list_length(value);
  }
#line 130
  if (tmp___3) {
    {
#line 131
    extra_buf = psiconv_buffer_new();
    }
#line 131
    if (! extra_buf) {
      {
#line 132
      psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 133
      res = -2;
      }
#line 134
      goto ERROR;
    }
#line 136
    i = 0;
    {
#line 136
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 136
      tmp___1 = psiconv_list_length(value);
      }
#line 136
      if (! ((psiconv_u32 )i < tmp___1)) {
#line 136
        goto while_break;
      }
      {
#line 137
      tmp = psiconv_list_get(value, (psiconv_u32 )i);
#line 137
      paragraph___3 = (psiconv_paragraph )tmp;
      }
#line 137
      if (! paragraph___3) {
        {
#line 138
        psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Data structure corruption");
#line 139
        res = -2;
        }
#line 140
        goto ERROR;
      }
#line 142
      j = 0;
      {
#line 142
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 142
        tmp___0 = psiconv_unicode_strlen((psiconv_ucs2 const   *)paragraph___3->text);
        }
#line 142
        if (! (j < tmp___0)) {
#line 142
          goto while_break___0;
        }
        {
#line 143
        res = psiconv_unicode_write_char(config, extra_buf, lev + 1, *(paragraph___3->text + j));
        }
#line 143
        if (res) {
#line 145
          goto ERROR;
        }
#line 142
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 146
      psiconv_unicode_write_char(config, extra_buf, lev + 1, (psiconv_ucs2 )6);
#line 136
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 148
    tmp___2 = psiconv_buffer_length((psiconv_buffer const   )extra_buf);
#line 148
    res = psiconv_write_X(config, buf, lev + 1, (psiconv_u32 const   )tmp___2);
    }
#line 148
    if (res) {
#line 149
      goto ERROR;
    }
    {
#line 150
    res = psiconv_buffer_concat(buf, (psiconv_buffer const   )extra_buf);
    }
  } else {
    {
#line 153
    res = psiconv_write_u16(config, buf, lev + 1, (psiconv_u16 const   )1538);
    }
#line 153
    if (res) {
#line 154
      goto ERROR;
    }
  }
  {
#line 156
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of text section");
  }
#line 157
  return (0);
  ERROR: 
#line 160
  if (extra_buf) {
    {
#line 161
    psiconv_buffer_free(extra_buf);
    }
  }
  {
#line 162
  psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of text section failed");
  }
#line 163
  return (res);
}
}
#line 166 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_common.c"
static int psiconv_write_layout_section(psiconv_config const   config , psiconv_buffer buf ,
                                        int lev , psiconv_text_and_layout const   value ,
                                        psiconv_word_styles_section const   styles___1 ,
                                        int with_styles ) 
{ 
  psiconv_u32 obj_id ;
  psiconv_list paragraph_type_list ;
  psiconv_paragraph_type_list paragraph_type ;
  struct psiconv_paragraph_type_list_s new_type ;
  psiconv_buffer buf_types ;
  psiconv_buffer buf_elements ;
  psiconv_buffer buf_inlines ;
  psiconv_buffer buf_objects ;
  psiconv_paragraph paragraph___3 ;
  psiconv_in_line_layout in_line ;
  psiconv_word_style style___1 ;
  psiconv_character_layout para_charlayout ;
  int i ;
  int j ;
  int para_type ;
  int nr_of_inlines ;
  int res ;
  int ptl_length ;
  int pel_length ;
  int thislen ;
  int paralen ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  psiconv_u32 tmp___2 ;
  psiconv_u32 tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  psiconv_u32 tmp___8 ;
  psiconv_u32 tmp___9 ;
  void *tmp___10 ;
  psiconv_u32 tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  psiconv_u32 tmp___15 ;
  psiconv_u32 tmp___16 ;
  psiconv_u32 tmp___17 ;
  psiconv_u32 tmp___18 ;
  psiconv_u32 tmp___19 ;
  psiconv_u32 tmp___20 ;
  psiconv_u32 tmp___21 ;
  int tmp___22 ;

  {
  {
#line 185
  in_line = (psiconv_in_line_layout )((void *)0);
#line 188
  nr_of_inlines = 0;
#line 190
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing layout section");
  }
#line 191
  if (! value) {
    {
#line 192
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null text section");
#line 193
    res = -4;
    }
#line 194
    goto ERROR1;
  }
  {
#line 197
  paragraph_type_list = psiconv_list_new(sizeof(new_type));
  }
#line 197
  if (! paragraph_type_list) {
    {
#line 198
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 199
    res = -2;
    }
#line 200
    goto ERROR1;
  }
  {
#line 203
  buf_types = psiconv_buffer_new();
  }
#line 203
  if (! buf_types) {
    {
#line 204
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 205
    res = -2;
    }
#line 206
    goto ERROR2;
  }
  {
#line 209
  buf_elements = psiconv_buffer_new();
  }
#line 209
  if (! buf_elements) {
    {
#line 210
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 211
    res = -2;
    }
#line 212
    goto ERROR3;
  }
  {
#line 215
  buf_inlines = psiconv_buffer_new();
  }
#line 215
  if (! buf_inlines) {
    {
#line 216
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 217
    res = -2;
    }
#line 218
    goto ERROR4;
  }
  {
#line 221
  buf_objects = psiconv_buffer_new();
  }
#line 221
  if (! buf_objects) {
    {
#line 222
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 223
    res = -2;
    }
#line 224
    goto ERROR5;
  }
#line 227
  i = 0;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 227
    tmp___18 = psiconv_list_length(value);
    }
#line 227
    if (! ((psiconv_u32 )i < tmp___18)) {
#line 227
      goto while_break;
    }
    {
#line 228
    tmp = psiconv_list_get(value, (psiconv_u32 )i);
#line 228
    paragraph___3 = (psiconv_paragraph )tmp;
    }
#line 228
    if (! paragraph___3) {
      {
#line 229
      psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Data structure corruption");
#line 230
      res = -2;
      }
#line 231
      goto ERROR6;
    }
    {
#line 233
    tmp___0 = psiconv_unicode_strlen((psiconv_ucs2 const   *)paragraph___3->text);
#line 233
    res = psiconv_write_u32(config, buf_elements, lev + 1, (psiconv_u32 const   )(tmp___0 + 1));
    }
#line 233
    if (res) {
#line 235
      goto ERROR6;
    }
    {
#line 238
    tmp___2 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
    }
#line 238
    if (tmp___2 == 1U) {
      {
#line 239
      tmp___1 = psiconv_list_get((psiconv_list const   )paragraph___3->in_lines, (psiconv_u32 )0);
#line 239
      in_line = (psiconv_in_line_layout )tmp___1;
      }
#line 239
      if (! in_line) {
        {
#line 240
        psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Data structure corruption");
#line 241
        res = -2;
        }
#line 242
        goto ERROR6;
      }
    }
    {
#line 245
    tmp___16 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
    }
#line 245
    if (tmp___16 > 1U) {
#line 245
      goto _L;
    } else {
      {
#line 245
      tmp___17 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
      }
#line 245
      if (tmp___17 == 1U) {
#line 245
        if ((unsigned long )in_line->object != (unsigned long )((void *)0)) {
          _L: /* CIL Label */ 
          {
#line 250
          res = psiconv_write_u8(config, buf_elements, lev + 1, (psiconv_u8 const   )0);
          }
#line 250
          if (res) {
#line 251
            goto ERROR6;
          }
          {
#line 252
          style___1 = psiconv_get_style((psiconv_word_styles_section )styles___1,
                                        (int )paragraph___3->base_style);
          }
#line 252
          if (! style___1) {
            {
#line 253
            psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Unknown style");
#line 254
            res = -4;
            }
#line 255
            goto ERROR6;
          }
          {
#line 257
          res = psiconv_write_paragraph_layout_list(config, buf_elements, lev + 1,
                                                    (psiconv_paragraph_layout const   )paragraph___3->base_paragraph,
                                                    (psiconv_paragraph_layout const   )style___1->paragraph);
          }
#line 257
          if (res) {
#line 260
            goto ERROR6;
          }
#line 261
          if (with_styles) {
            {
#line 262
            res = psiconv_write_u8(config, buf_elements, lev + 1, (psiconv_u8 const   )paragraph___3->base_style);
            }
#line 262
            if (res) {
#line 263
              goto ERROR6;
            }
          }
          {
#line 264
          tmp___3 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
#line 264
          res = psiconv_write_u32(config, buf_elements, lev + 1, (psiconv_u32 const   )tmp___3);
          }
#line 264
          if (res) {
#line 266
            goto ERROR6;
          }
#line 269
          paralen = 0;
#line 270
          j = 0;
          {
#line 270
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 270
            tmp___9 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
            }
#line 270
            if (! ((psiconv_u32 )j < tmp___9)) {
#line 270
              goto while_break___0;
            }
            {
#line 271
            nr_of_inlines ++;
#line 272
            tmp___4 = psiconv_list_get((psiconv_list const   )paragraph___3->in_lines,
                                       (psiconv_u32 )j);
#line 272
            in_line = (psiconv_in_line_layout )tmp___4;
            }
#line 272
            if (! in_line) {
              {
#line 273
              psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Data structure corruption");
#line 274
              res = -2;
              }
#line 275
              goto ERROR6;
            }
#line 277
            if (in_line->object) {
#line 277
              tmp___5 = 1;
            } else {
#line 277
              tmp___5 = 0;
            }
            {
#line 277
            res = psiconv_write_u8(config, buf_inlines, lev + 1, (psiconv_u8 const   )tmp___5);
            }
#line 277
            if (res) {
#line 278
              goto ERROR6;
            }
            {
#line 279
            thislen = in_line->length;
#line 280
            paralen += thislen;
#line 283
            tmp___8 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
            }
#line 283
            if ((psiconv_u32 )j == tmp___8 - 1U) {
              {
#line 284
              tmp___6 = psiconv_unicode_strlen((psiconv_ucs2 const   *)paragraph___3->text);
              }
#line 284
              if (paralen > tmp___6 + 1) {
                {
#line 285
                psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Inline formatting data length and line length are inconsistent");
#line 286
                res = -4;
                }
#line 287
                goto ERROR6;
              }
              {
#line 289
              tmp___7 = psiconv_unicode_strlen((psiconv_ucs2 const   *)paragraph___3->text);
#line 289
              thislen += (tmp___7 + 1) - paralen;
              }
            }
            {
#line 291
            res = psiconv_write_u32(config, buf_inlines, lev + 1, (psiconv_u32 const   )thislen);
            }
#line 291
            if (res) {
#line 292
              goto ERROR6;
            }
            {
#line 293
            res = psiconv_write_character_layout_list(config, buf_inlines, lev + 1,
                                                      (psiconv_character_layout const   )in_line->layout,
                                                      (psiconv_character_layout const   )style___1->character);
            }
#line 293
            if (res) {
#line 296
              goto ERROR6;
            }
#line 297
            if (in_line->object) {
              {
#line 298
              res = psiconv_write_u32(config, buf_inlines, lev + 1, (psiconv_u32 const   )268435537);
              }
#line 298
              if (res) {
#line 299
                goto ERROR6;
              }
              {
#line 300
              obj_id = psiconv_buffer_unique_id();
#line 301
              res = psiconv_buffer_add_reference(buf_inlines, (int )obj_id);
              }
#line 301
              if (res) {
                {
#line 302
                psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
                }
#line 303
                goto ERROR6;
              }
              {
#line 305
              res = psiconv_buffer_add_target(buf_objects, (int )obj_id);
              }
#line 305
              if (res) {
                {
#line 306
                psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
                }
#line 307
                goto ERROR6;
              }
              {
#line 309
              res = psiconv_write_embedded_object_section(config, buf_objects, lev + 1,
                                                          (psiconv_embedded_object_section const   )in_line->object);
              }
#line 309
              if (res) {
#line 311
                goto ERROR6;
              }
              {
#line 312
              res = psiconv_write_length(config, buf_inlines, lev + 1, (psiconv_length_t const   )in_line->object_width);
              }
#line 312
              if (res) {
#line 313
                goto ERROR6;
              }
              {
#line 314
              res = psiconv_write_length(config, buf_inlines, lev + 1, (psiconv_length_t const   )in_line->object_height);
              }
#line 314
              if (res) {
#line 315
                goto ERROR6;
              }
            }
#line 270
            j ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
#line 245
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 320
        para_type = 0;
#line 322
        tmp___11 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
        }
#line 322
        if (tmp___11 == 0U) {
#line 323
          para_charlayout = paragraph___3->base_character;
        } else {
          {
#line 325
          tmp___10 = psiconv_list_get((psiconv_list const   )paragraph___3->in_lines,
                                      (psiconv_u32 )0);
#line 325
          in_line = (psiconv_in_line_layout )tmp___10;
          }
#line 325
          if (! in_line) {
            {
#line 326
            psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Data structure corruption");
#line 327
            res = -2;
            }
#line 328
            goto ERROR6;
          }
#line 330
          para_charlayout = in_line->layout;
        }
#line 332
        j = 0;
        {
#line 332
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 332
          tmp___15 = psiconv_list_length((psiconv_list const   )paragraph_type_list);
          }
#line 332
          if (! ((psiconv_u32 )j < tmp___15)) {
#line 332
            goto while_break___1;
          }
          {
#line 333
          tmp___12 = psiconv_list_get((psiconv_list const   )paragraph_type_list,
                                      (psiconv_u32 )j);
#line 333
          paragraph_type = (psiconv_paragraph_type_list )tmp___12;
          }
#line 333
          if (! paragraph_type) {
            {
#line 334
            psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Data structure corruption");
#line 335
            res = -2;
            }
#line 336
            goto ERROR6;
          }
#line 338
          if ((int )paragraph___3->base_style == (int )paragraph_type->style) {
            {
#line 338
            tmp___13 = psiconv_compare_character_layout((psiconv_character_layout const   )para_charlayout,
                                                        (psiconv_character_layout const   )paragraph_type->character);
            }
#line 338
            if (! tmp___13) {
              {
#line 338
              tmp___14 = psiconv_compare_paragraph_layout((psiconv_paragraph_layout const   )paragraph___3->base_paragraph,
                                                          (psiconv_paragraph_layout const   )paragraph_type->paragraph);
              }
#line 338
              if (! tmp___14) {
#line 343
                para_type = (int )paragraph_type->nr;
#line 344
                goto while_break___1;
              }
            }
          }
#line 332
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 347
        if (! para_type) {
          {
#line 349
          new_type.nr = (psiconv_u8 )(j + 1);
#line 349
          para_type = (int )new_type.nr;
#line 351
          new_type.paragraph = paragraph___3->base_paragraph;
#line 352
          new_type.character = para_charlayout;
#line 353
          new_type.style = (psiconv_u8 )paragraph___3->base_style;
#line 354
          paragraph_type = & new_type;
#line 355
          res = psiconv_list_add(paragraph_type_list, (void const   *)paragraph_type);
          }
#line 355
          if (res) {
            {
#line 356
            psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
            }
#line 357
            goto ERROR6;
          }
          {
#line 359
          res = psiconv_write_u32(config, buf_types, lev + 1, (psiconv_u32 const   )paragraph_type->nr);
          }
#line 359
          if (res) {
#line 360
            goto ERROR6;
          }
          {
#line 361
          style___1 = psiconv_get_style((psiconv_word_styles_section )styles___1,
                                        (int )paragraph_type->style);
          }
#line 361
          if (! style___1) {
            {
#line 362
            psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Unknown style");
#line 363
            res = -4;
            }
#line 364
            goto ERROR6;
          }
          {
#line 366
          res = psiconv_write_paragraph_layout_list(config, buf_types, lev + 1, (psiconv_paragraph_layout const   )paragraph_type->paragraph,
                                                    (psiconv_paragraph_layout const   )style___1->paragraph);
          }
#line 366
          if (res) {
#line 368
            goto ERROR6;
          }
#line 369
          if (with_styles) {
            {
#line 370
            res = psiconv_write_u8(config, buf_types, lev + 1, (psiconv_u8 const   )paragraph_type->style);
            }
#line 370
            if (res) {
#line 371
              goto ERROR6;
            }
          }
          {
#line 372
          res = psiconv_write_character_layout_list(config, buf_types, lev + 1, (psiconv_character_layout const   )paragraph_type->character,
                                                    (psiconv_character_layout const   )style___1->character);
          }
#line 372
          if (res) {
#line 374
            goto ERROR6;
          }
        }
        {
#line 376
        res = psiconv_write_u8(config, buf_elements, lev + 1, (psiconv_u8 const   )para_type);
        }
#line 376
        if (res) {
#line 377
          goto ERROR6;
        }
      }
    }
#line 227
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 382
  tmp___21 = psiconv_list_length(value);
  }
#line 382
  if (tmp___21) {
    {
#line 400
    tmp___19 = psiconv_list_length(value);
#line 400
    pel_length = (int )tmp___19;
#line 401
    tmp___20 = psiconv_list_length((psiconv_list const   )paragraph_type_list);
#line 401
    ptl_length = (int )tmp___20;
    }
  } else {
    {
#line 383
    res = psiconv_write_u32(config, buf_types, lev + 1, (psiconv_u32 const   )1);
    }
#line 383
    if (res) {
#line 384
      goto ERROR6;
    }
    {
#line 385
    res = psiconv_write_u32(config, buf_types, lev + 1, (psiconv_u32 const   )0);
    }
#line 385
    if (res) {
#line 386
      goto ERROR6;
    }
#line 387
    if (with_styles) {
      {
#line 388
      res = psiconv_write_u8(config, buf_types, lev + 1, (psiconv_u8 const   )0);
      }
#line 388
      if (res) {
#line 389
        goto ERROR6;
      }
    }
    {
#line 390
    res = psiconv_write_u32(config, buf_types, lev + 1, (psiconv_u32 const   )0);
    }
#line 390
    if (res) {
#line 391
      goto ERROR6;
    }
    {
#line 393
    res = psiconv_write_u32(config, buf_elements, lev + 1, (psiconv_u32 const   )1);
    }
#line 393
    if (res) {
#line 394
      goto ERROR6;
    }
    {
#line 395
    res = psiconv_write_u8(config, buf_elements, lev + 1, (psiconv_u8 const   )1);
    }
#line 395
    if (res) {
#line 396
      goto ERROR6;
    }
#line 397
    pel_length = 1;
#line 398
    ptl_length = 1;
  }
#line 405
  if (with_styles) {
#line 405
    tmp___22 = 1;
  } else {
#line 405
    tmp___22 = 0;
  }
  {
#line 405
  res = psiconv_write_u16(config, buf, lev + 1, (psiconv_u16 const   )tmp___22);
  }
#line 405
  if (res) {
#line 406
    goto ERROR6;
  }
  {
#line 407
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )ptl_length);
  }
#line 407
  if (res) {
#line 408
    goto ERROR6;
  }
  {
#line 409
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )buf_types);
  }
#line 409
  if (res) {
    {
#line 410
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 411
    goto ERROR6;
  }
  {
#line 413
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )pel_length);
  }
#line 413
  if (res) {
#line 414
    goto ERROR6;
  }
  {
#line 415
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )buf_elements);
  }
#line 415
  if (res) {
    {
#line 416
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 417
    goto ERROR6;
  }
  {
#line 419
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )nr_of_inlines);
  }
#line 419
  if (res) {
#line 420
    goto ERROR6;
  }
  {
#line 421
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )buf_inlines);
  }
#line 421
  if (res) {
    {
#line 422
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 423
    goto ERROR6;
  }
  {
#line 425
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )buf_objects);
  }
#line 425
  if (res) {
    {
#line 426
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 427
    goto ERROR6;
  }
  ERROR6: 
  {
#line 431
  psiconv_buffer_free(buf_objects);
  }
  ERROR5: 
  {
#line 433
  psiconv_buffer_free(buf_inlines);
  }
  ERROR4: 
  {
#line 435
  psiconv_buffer_free(buf_elements);
  }
  ERROR3: 
  {
#line 437
  psiconv_buffer_free(buf_types);
  }
  ERROR2: 
  {
#line 439
  psiconv_list_free(paragraph_type_list);
  }
  ERROR1: 
#line 441
  if (res) {
    {
#line 442
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of layout section failed");
    }
  } else {
    {
#line 444
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of layout section");
    }
  }
#line 445
  return (res);
}
}
#line 448 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_common.c"
int psiconv_write_styled_layout_section(psiconv_config const   config , psiconv_buffer buf ,
                                        int lev , psiconv_text_and_layout const   result ,
                                        psiconv_word_styles_section const   styles___1 ) 
{ 
  int res ;

  {
  {
#line 455
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing styled layout section");
#line 456
  res = psiconv_write_layout_section(config, buf, lev + 1, result, styles___1, 1);
  }
#line 457
  if (res) {
    {
#line 458
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of styles layout section failed");
    }
  } else {
    {
#line 460
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of styled layout section");
    }
  }
#line 461
  return (res);
}
}
#line 464 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_common.c"
int psiconv_write_styleless_layout_section(psiconv_config const   config , psiconv_buffer buf ,
                                           int lev , psiconv_text_and_layout const   value ,
                                           psiconv_character_layout const   base_char ,
                                           psiconv_paragraph_layout const   base_para ) 
{ 
  int res ;
  psiconv_word_styles_section styles_section ;
  void *tmp ;
  psiconv_word_style tmp___0 ;
  void *tmp___1 ;
  psiconv_character_layout tmp___2 ;
  psiconv_paragraph_layout tmp___3 ;
  psiconv_string_t tmp___4 ;
  psiconv_word_style_list tmp___5 ;

  {
  {
#line 470
  res = 0;
#line 473
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing styleless layout section");
#line 474
  tmp = malloc(sizeof(*styles_section));
#line 474
  styles_section = (psiconv_word_styles_section )tmp;
  }
#line 474
  if (! styles_section) {
    {
#line 475
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 476
    goto ERROR1;
  }
  {
#line 478
  tmp___1 = malloc(sizeof(*(styles_section->normal)));
#line 478
  tmp___0 = (psiconv_word_style )tmp___1;
#line 478
  styles_section->normal = tmp___0;
  }
#line 478
  if (! tmp___0) {
    {
#line 479
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 480
    goto ERROR2;
  }
  {
#line 482
  tmp___2 = psiconv_clone_character_layout((psiconv_character_layout )base_char);
#line 482
  (styles_section->normal)->character = tmp___2;
  }
#line 482
  if (! tmp___2) {
    {
#line 484
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 485
    goto ERROR3;
  }
  {
#line 487
  tmp___3 = psiconv_clone_paragraph_layout((psiconv_paragraph_layout )base_para);
#line 487
  (styles_section->normal)->paragraph = tmp___3;
  }
#line 487
  if (! tmp___3) {
    {
#line 489
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 490
    goto ERROR4;
  }
  {
#line 492
  (styles_section->normal)->hotkey = (psiconv_ucs2 )0;
#line 493
  tmp___4 = psiconv_unicode_empty_string();
#line 493
  (styles_section->normal)->name = tmp___4;
  }
#line 493
  if (! tmp___4) {
    {
#line 494
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 495
    goto ERROR5;
  }
  {
#line 497
  tmp___5 = psiconv_list_new(sizeof(struct psiconv_word_style_s ));
#line 497
  styles_section->styles = tmp___5;
  }
#line 497
  if (! tmp___5) {
    {
#line 499
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 500
    goto ERROR6;
  }
  {
#line 503
  res = psiconv_write_layout_section(config, buf, lev + 1, value, (psiconv_word_styles_section const   )styles_section,
                                     0);
#line 504
  psiconv_free_word_styles_section(styles_section);
#line 505
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of styleless layout section");
  }
#line 506
  return (res);
  ERROR6: 
  {
#line 509
  free((void *)(styles_section->normal)->name);
  }
  ERROR5: 
  {
#line 511
  psiconv_free_paragraph_layout((styles_section->normal)->paragraph);
  }
  ERROR4: 
  {
#line 513
  psiconv_free_character_layout((styles_section->normal)->character);
  }
  ERROR3: 
  {
#line 515
  free((void *)styles_section->normal);
  }
  ERROR2: 
  {
#line 517
  free((void *)styles_section);
  }
  ERROR1: 
  {
#line 519
  psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of styleless layout section failed");
  }
#line 520
  if (! res) {
#line 521
    return (-2);
  } else {
#line 523
    return (res);
  }
}
}
#line 527 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_common.c"
int psiconv_write_embedded_object_section(psiconv_config const   config , psiconv_buffer buf ,
                                          int lev , psiconv_embedded_object_section const   value ) 
{ 
  int res ;
  psiconv_u32 display_id ;
  psiconv_u32 icon_id ;
  psiconv_u32 table_id ;
  psiconv_buffer extra_buf ;

  {
  {
#line 535
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing embedded object section");
  }
#line 536
  if (! value) {
    {
#line 537
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null Object");
#line 538
    res = -4;
    }
#line 539
    goto ERROR1;
  }
  {
#line 542
  extra_buf = psiconv_buffer_new();
  }
#line 542
  if (! extra_buf) {
    {
#line 543
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 544
    res = -2;
    }
#line 545
    goto ERROR1;
  }
  {
#line 548
  display_id = psiconv_buffer_unique_id();
#line 549
  icon_id = psiconv_buffer_unique_id();
#line 550
  table_id = psiconv_buffer_unique_id();
#line 551
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )6);
  }
#line 551
  if (res) {
#line 552
    goto ERROR2;
  }
  {
#line 553
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )268435782);
  }
#line 553
  if (res) {
#line 554
    goto ERROR2;
  }
  {
#line 555
  res = psiconv_buffer_add_reference(buf, (int )display_id);
  }
#line 555
  if (res) {
    {
#line 556
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 557
    goto ERROR2;
  }
  {
#line 559
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )268435754);
  }
#line 559
  if (res) {
#line 560
    goto ERROR2;
  }
  {
#line 561
  res = psiconv_buffer_add_reference(buf, (int )icon_id);
  }
#line 561
  if (res) {
    {
#line 562
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 563
    goto ERROR2;
  }
  {
#line 565
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )268435780);
  }
#line 565
  if (res) {
#line 566
    goto ERROR2;
  }
  {
#line 567
  res = psiconv_buffer_add_reference(buf, (int )table_id);
  }
#line 567
  if (res) {
    {
#line 568
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 569
    goto ERROR2;
  }
  {
#line 572
  res = psiconv_buffer_add_target(buf, (int )display_id);
  }
#line 572
  if (res) {
    {
#line 573
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 574
    goto ERROR2;
  }
  {
#line 576
  res = psiconv_write_object_display_section(config, buf, lev + 1, (psiconv_object_display_section const   )value->display);
  }
#line 576
  if (res) {
#line 577
    goto ERROR2;
  }
  {
#line 578
  res = psiconv_buffer_add_target(buf, (int )icon_id);
  }
#line 578
  if (res) {
    {
#line 579
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 580
    goto ERROR2;
  }
  {
#line 582
  res = psiconv_write_object_icon_section(config, buf, lev + 1, (psiconv_object_icon_section const   )value->icon);
  }
#line 582
  if (res) {
#line 583
    goto ERROR2;
  }
  {
#line 584
  res = psiconv_buffer_add_target(buf, (int )table_id);
  }
#line 584
  if (res) {
    {
#line 585
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 586
    goto ERROR2;
  }
  {
#line 589
  if ((unsigned int )(value->object)->type == 1U) {
#line 589
    goto case_1;
  }
#line 594
  if ((unsigned int )(value->object)->type == 4U) {
#line 594
    goto case_4;
  }
#line 606
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 590
  res = psiconv_write_word_file(config, extra_buf, lev + 1, (psiconv_word_f const   )((psiconv_word_f )(value->object)->file));
  }
#line 590
  if (res) {
#line 592
    goto ERROR2;
  }
#line 593
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 595
  res = psiconv_write_sketch_file(config, extra_buf, lev + 1, (psiconv_sketch_f const   )((psiconv_sketch_f )(value->object)->file));
  }
#line 595
  if (res) {
#line 597
    goto ERROR2;
  }
#line 598
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 607
  psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Unknown or unsupported object type");
#line 608
  res = -4;
  }
#line 609
  goto ERROR2;
  switch_break: /* CIL Label */ ;
  }
  {
#line 612
  res = psiconv_buffer_resolve(extra_buf);
  }
#line 612
  if (res) {
    {
#line 613
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Internal error resolving buffer references");
    }
#line 614
    goto ERROR2;
  }
  {
#line 616
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )extra_buf);
  }
#line 616
  if (res) {
    {
#line 617
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 618
    goto ERROR2;
  }
  {
#line 620
  psiconv_buffer_free(extra_buf);
#line 622
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of embedded object section");
  }
#line 623
  return (0);
  ERROR2: 
  {
#line 626
  psiconv_buffer_free(extra_buf);
  }
  ERROR1: 
  {
#line 628
  psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of embedded object section failed");
  }
#line 629
  return (res);
}
}
#line 633 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_common.c"
int psiconv_write_object_display_section(psiconv_config const   config , psiconv_buffer buf ,
                                         int lev , psiconv_object_display_section const   value ) 
{ 
  int res ;
  int tmp ;

  {
  {
#line 639
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing object display section");
  }
#line 641
  if (! value) {
    {
#line 642
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null Object Display Section");
#line 643
    res = -4;
    }
#line 644
    goto ERROR1;
  }
#line 647
  if (value->show_icon) {
#line 647
    tmp = 0;
  } else {
#line 647
    tmp = 1;
  }
  {
#line 647
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )tmp);
  }
#line 647
  if (res) {
#line 648
    goto ERROR1;
  }
  {
#line 649
  res = psiconv_write_length(config, buf, lev + 1, (psiconv_length_t const   )value->width);
  }
#line 649
  if (res) {
#line 650
    goto ERROR1;
  }
  {
#line 651
  res = psiconv_write_length(config, buf, lev + 1, (psiconv_length_t const   )value->height);
  }
#line 651
  if (res) {
#line 652
    goto ERROR1;
  }
  {
#line 653
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )0);
  }
#line 653
  if (res) {
#line 654
    goto ERROR1;
  }
  {
#line 656
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of object display section");
  }
#line 658
  return (0);
  ERROR1: 
  {
#line 661
  psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of object display section failed");
  }
#line 662
  return (res);
}
}
#line 665 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_common.c"
int psiconv_write_object_icon_section(psiconv_config const   config , psiconv_buffer buf ,
                                      int lev , psiconv_object_icon_section const   value ) 
{ 
  int res ;

  {
  {
#line 671
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing object icon section");
  }
#line 673
  if (! value) {
    {
#line 674
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null Object Icon Section");
#line 675
    res = -4;
    }
#line 676
    goto ERROR1;
  }
  {
#line 679
  res = psiconv_write_string(config, buf, lev + 1, (psiconv_string_t const   )value->icon_name);
  }
#line 679
  if (res) {
#line 680
    goto ERROR1;
  }
  {
#line 681
  res = psiconv_write_length(config, buf, lev + 1, (psiconv_length_t const   )value->icon_width);
  }
#line 681
  if (res) {
#line 682
    goto ERROR1;
  }
  {
#line 683
  res = psiconv_write_length(config, buf, lev + 1, (psiconv_length_t const   )value->icon_height);
  }
#line 683
  if (res) {
#line 684
    goto ERROR1;
  }
  {
#line 686
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of object icon section");
  }
#line 687
  return (0);
  ERROR1: 
  {
#line 690
  psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of object icon section failed");
  }
#line 691
  return (res);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/error.h"
void psiconv_fatal(psiconv_config config , int level , psiconv_u32 off , char const   *format 
                   , ...) ;
#line 36
void psiconv_warn(psiconv_config config , int level , psiconv_u32 off , char const   *format 
                  , ...) ;
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/error.c"
static void psiconv_default_error_handler(int kind , psiconv_u32 off , char const   *message ) 
{ 


  {
  {
#line 36
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          message);
  }
#line 37
  return;
}
}
#line 41 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/error.c"
void psiconv_fatal(psiconv_config config , int level , psiconv_u32 off , char const   *format 
                   , ...) 
{ 
  char buffer[1024] ;
  va_list ap ;
  size_t curlen ;

  {
  {
#line 48
  __builtin_va_start(ap, format);
#line 49
  snprintf((char */* __restrict  */)(buffer), (size_t )1024, (char const   */* __restrict  */)"Fatal error (offset %08x): ",
           off);
#line 50
  curlen = strlen((char const   *)(buffer));
#line 52
  vsnprintf((char */* __restrict  */)(buffer + curlen), 1024UL - curlen, (char const   */* __restrict  */)format,
            ap);
  }
#line 53
  if (config->error_handler) {
    {
#line 54
    (*(config->error_handler))(1, off, (char const   *)(buffer));
    }
  } else {
    {
#line 56
    psiconv_default_error_handler(1, off, (char const   *)(buffer));
    }
  }
  {
#line 57
  __builtin_va_end(ap);
#line 59
  exit(1);
  }
}
}
#line 62 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/error.c"
void psiconv_error(psiconv_config config , int level , psiconv_u32 off , char const   *format 
                   , ...) 
{ 
  char buffer[1024] ;
  va_list ap ;
  size_t curlen ;

  {
  {
#line 69
  __builtin_va_start(ap, format);
  }
#line 71
  if (config->verbosity >= 2) {
    {
#line 72
    snprintf((char */* __restrict  */)(buffer), (size_t )1024, (char const   */* __restrict  */)"ERROR (offset %08x): ",
             off);
#line 73
    curlen = strlen((char const   *)(buffer));
#line 75
    vsnprintf((char */* __restrict  */)(buffer + curlen), 1024UL - curlen, (char const   */* __restrict  */)format,
              ap);
    }
#line 76
    if (config->error_handler) {
      {
#line 77
      (*(config->error_handler))(2, off, (char const   *)(buffer));
      }
    } else {
      {
#line 79
      psiconv_default_error_handler(2, off, (char const   *)(buffer));
      }
    }
  }
  {
#line 81
  __builtin_va_end(ap);
  }
#line 82
  return;
}
}
#line 84 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/error.c"
void psiconv_warn(psiconv_config config , int level , psiconv_u32 off , char const   *format 
                  , ...) 
{ 
  char buffer[1024] ;
  va_list ap ;
  size_t curlen ;

  {
  {
#line 91
  __builtin_va_start(ap, format);
  }
#line 93
  if (config->verbosity >= 3) {
    {
#line 94
    snprintf((char */* __restrict  */)(buffer), (size_t )1024, (char const   */* __restrict  */)"WARNING (offset %08x): ",
             off);
#line 95
    curlen = strlen((char const   *)(buffer));
#line 97
    vsnprintf((char */* __restrict  */)(buffer + curlen), 1024UL - curlen, (char const   */* __restrict  */)format,
              ap);
    }
#line 98
    if (config->error_handler) {
      {
#line 99
      (*(config->error_handler))(3, off, (char const   *)(buffer));
      }
    } else {
      {
#line 101
      psiconv_default_error_handler(3, off, (char const   *)(buffer));
      }
    }
  }
  {
#line 103
  __builtin_va_end(ap);
  }
#line 104
  return;
}
}
#line 106 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/error.c"
void psiconv_progress(psiconv_config config , int level , psiconv_u32 off , char const   *format 
                      , ...) 
{ 
  char buffer[1024] ;
  va_list ap ;
  size_t curlen ;
  int i ;

  {
  {
#line 114
  __builtin_va_start(ap, format);
  }
#line 115
  if (config->verbosity >= 4) {
    {
#line 116
    snprintf((char */* __restrict  */)(buffer), (size_t )1024, (char const   */* __restrict  */)"%08x ",
             off);
#line 117
    curlen = strlen((char const   *)(buffer));
#line 119
    i = 0;
    }
    {
#line 119
    while (1) {
      while_continue: /* CIL Label */ ;
#line 119
      if (i < level) {
#line 119
        if (! (((size_t )i + curlen) + 3UL < 1024UL)) {
#line 119
          goto while_break;
        }
      } else {
#line 119
        goto while_break;
      }
#line 120
      buffer[(size_t )i + curlen] = (char )'=';
#line 119
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 121
    curlen += (size_t )i;
#line 123
    buffer[curlen] = (char )'>';
#line 124
    buffer[curlen + 1UL] = (char )' ';
#line 125
    buffer[curlen + 2UL] = (char )'\000';
#line 126
    curlen += 2UL;
#line 128
    vsnprintf((char */* __restrict  */)(buffer + curlen), 1024UL - curlen, (char const   */* __restrict  */)format,
              ap);
    }
#line 130
    if (config->error_handler) {
      {
#line 131
      (*(config->error_handler))(4, off, (char const   *)(buffer));
      }
    } else {
      {
#line 133
      psiconv_default_error_handler(4, off, (char const   *)(buffer));
      }
    }
  }
  {
#line 136
  __builtin_va_end(ap);
  }
#line 137
  return;
}
}
#line 140 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/error.c"
void psiconv_debug(psiconv_config config , int level , psiconv_u32 off , char const   *format 
                   , ...) 
{ 
  char buffer[1024] ;
  va_list ap ;
  size_t curlen ;
  int i ;

  {
  {
#line 148
  __builtin_va_start(ap, format);
  }
#line 149
  if (config->verbosity >= 5) {
    {
#line 150
    snprintf((char */* __restrict  */)(buffer), (size_t )1024, (char const   */* __restrict  */)"%08x ",
             off);
#line 151
    curlen = strlen((char const   *)(buffer));
#line 153
    i = 0;
    }
    {
#line 153
    while (1) {
      while_continue: /* CIL Label */ ;
#line 153
      if (i < level) {
#line 153
        if (! (((size_t )i + curlen) + 3UL < 1024UL)) {
#line 153
          goto while_break;
        }
      } else {
#line 153
        goto while_break;
      }
#line 154
      buffer[(size_t )i + curlen] = (char )'-';
#line 153
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 155
    curlen += (size_t )i;
#line 157
    buffer[curlen] = (char )'>';
#line 158
    buffer[curlen + 1UL] = (char )' ';
#line 159
    buffer[curlen + 2UL] = (char )'\000';
#line 160
    curlen += 2UL;
#line 162
    vsnprintf((char */* __restrict  */)(buffer + curlen), 1024UL - curlen, (char const   */* __restrict  */)format,
              ap);
    }
#line 164
    if (config->error_handler) {
      {
#line 165
      (*(config->error_handler))(5, off, (char const   *)(buffer));
      }
    } else {
      {
#line 167
      psiconv_default_error_handler(5, off, (char const   *)(buffer));
      }
    }
  }
  {
#line 169
  __builtin_va_end(ap);
  }
#line 170
  return;
}
}
#line 1052 "../psiconv/data.h"
psiconv_character_layout psiconv_basic_character_layout(void) ;
#line 1056
psiconv_paragraph_layout psiconv_basic_paragraph_layout(void) ;
#line 1098
void psiconv_free_sheet_status_section(psiconv_sheet_status_section section ) ;
#line 1124
void psiconv_free_header_section(psiconv_header_section header___3 ) ;
#line 1126
void psiconv_free_section_table_section(psiconv_section_table_section section ) ;
#line 1128
void psiconv_free_application_id_section(psiconv_application_id_section section ) ;
#line 1141
void psiconv_free_text_and_layout(psiconv_text_and_layout text___3 ) ;
#line 1144
void psiconv_free_page_layout_section(psiconv_page_layout_section section ) ;
#line 1146
void psiconv_free_word_status_section(psiconv_word_status_section section ) ;
#line 1150
void psiconv_free_paint_data_section(psiconv_paint_data_section section ) ;
#line 1152
void psiconv_free_jumptable_section(psiconv_jumptable_section section ) ;
#line 1157
void psiconv_free_clipart_section(psiconv_clipart_section section ) ;
#line 42 "../psiconv/common.h"
char *psiconv_make_printable(psiconv_config const   config , psiconv_string_t const   input ) ;
#line 38 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse.h"
psiconv_file_type_t psiconv_file_type(psiconv_config const   config , psiconv_buffer buf ,
                                      int *length , psiconv_header_section *result ) ;
#line 50
int psiconv_parse(psiconv_config const   config , psiconv_buffer const   buf , psiconv_file *result ) ;
#line 45 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_routines.h"
psiconv_u32 psiconv_read_u32(psiconv_config const   config , psiconv_buffer const   buf ,
                             int lev , psiconv_u32 off , int *status ) ;
#line 145
int psiconv_parse_page_layout_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                      int lev , psiconv_u32 off , int *length , psiconv_page_layout_section *result ) ;
#line 154
int psiconv_parse_header_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                 int lev , psiconv_u32 off , int *length , psiconv_header_section *result ) ;
#line 159
int psiconv_parse_section_table_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                        int lev , psiconv_u32 off , int *length ,
                                        psiconv_section_table_section *result ) ;
#line 165
int psiconv_parse_application_id_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                         int lev , psiconv_u32 off , int *length ,
                                         psiconv_application_id_section *result ) ;
#line 170
int psiconv_parse_text_section(psiconv_config const   config , psiconv_buffer const   buf ,
                               int lev , psiconv_u32 off , int *length , psiconv_text_and_layout *result ) ;
#line 175
int psiconv_parse_styled_layout_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                        int lev , psiconv_u32 off , int *length ,
                                        psiconv_text_and_layout result , psiconv_word_styles_section const   styles___1 ) ;
#line 215
int psiconv_parse_texted_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                 int lev , psiconv_u32 off , int *length , psiconv_texted_section *result ,
                                 psiconv_character_layout base_char , psiconv_paragraph_layout base_para ) ;
#line 227
int psiconv_parse_word_status_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                      int lev , psiconv_u32 off , int *length , psiconv_word_status_section *result ) ;
#line 232
int psiconv_parse_word_styles_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                      int lev , psiconv_u32 off , int *length , psiconv_word_styles_section *result ) ;
#line 242
int psiconv_parse_sheet_status_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                       int lev , psiconv_u32 off , int *length , psiconv_sheet_status_section *result ) ;
#line 257
int psiconv_parse_sheet_workbook_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                         int lev , psiconv_u32 off , int *length ,
                                         psiconv_sheet_workbook_section *result ) ;
#line 358
int psiconv_parse_paint_data_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                     int lev , psiconv_u32 off , int *length , int isclipart ,
                                     psiconv_paint_data_section *result ) ;
#line 364
int psiconv_parse_jumptable_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                    int lev , psiconv_u32 off , int *length , psiconv_jumptable_section *result ) ;
#line 369
int psiconv_parse_sketch_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                 int lev , psiconv_u32 off , int *length , psiconv_sketch_section *result ) ;
#line 374
int psiconv_parse_clipart_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                  int lev , psiconv_u32 off , int *length , psiconv_clipart_section *result ) ;
#line 387
int psiconv_parse_texted_file(psiconv_config const   config , psiconv_buffer const   buf ,
                              int lev , psiconv_u32 off , psiconv_texted_f *result ) ;
#line 391
int psiconv_parse_word_file(psiconv_config const   config , psiconv_buffer const   buf ,
                            int lev , psiconv_u32 off , psiconv_word_f *result ) ;
#line 395
int psiconv_parse_mbm_file(psiconv_config const   config , psiconv_buffer const   buf ,
                           int lev , psiconv_u32 off , psiconv_mbm_f *result ) ;
#line 399
int psiconv_parse_sketch_file(psiconv_config const   config , psiconv_buffer const   buf ,
                              int lev , psiconv_u32 off , psiconv_sketch_f *result ) ;
#line 403
int psiconv_parse_clipart_file(psiconv_config const   config , psiconv_buffer const   buf ,
                               int lev , psiconv_u32 off , psiconv_clipart_f *result ) ;
#line 406
int psiconv_parse_sheet_file(psiconv_config const   config , psiconv_buffer const   buf ,
                             int lev , psiconv_u32 off , psiconv_sheet_f *result ) ;
#line 36 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_driver.c"
static psiconv_bool_t applid_matches(psiconv_string_t found , char const   *sought ) 
{ 
  int i ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 40
  tmp = psiconv_unicode_strlen((psiconv_ucs2 const   *)found);
#line 40
  tmp___0 = strlen(sought);
  }
#line 40
  if ((size_t )tmp != tmp___0) {
#line 41
    return ((psiconv_bool_t )0);
  }
#line 42
  i = 0;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 42
    tmp___1 = strlen(sought);
    }
#line 42
    if (! ((size_t )i < tmp___1)) {
#line 42
      goto while_break;
    }
#line 43
    if ((int )*(found + i) != (int )*(sought + i)) {
#line 43
      if ((int const   )*(sought + i) < 97) {
#line 46
        return ((psiconv_bool_t )0);
      } else
#line 43
      if ((int const   )*(sought + i) > 122) {
#line 46
        return ((psiconv_bool_t )0);
      } else
#line 43
      if ((int )*(found + i) != (int )(((int const   )*(sought + i) + 65) - 97)) {
#line 46
        return ((psiconv_bool_t )0);
      }
    }
#line 42
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return ((psiconv_bool_t )1);
}
}
#line 50 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_driver.c"
psiconv_file_type_t psiconv_file_type(psiconv_config const   config , psiconv_buffer buf ,
                                      int *length , psiconv_header_section *result ) 
{ 
  psiconv_header_section header___3 ;
  psiconv_file_type_t res ;
  int leng ;
  int tmp ;

  {
  {
#line 58
  tmp = psiconv_parse_header_section(config, (psiconv_buffer const   )buf, 0, (psiconv_u32 )0,
                                     & leng, & header___3);
  }
#line 58
  if (tmp) {
#line 59
    return ((psiconv_file_type_t )0);
  }
#line 60
  res = header___3->file;
#line 61
  if (result) {
#line 62
    *result = header___3;
  } else {
    {
#line 64
    psiconv_free_header_section(header___3);
    }
  }
#line 65
  if (length) {
#line 66
    *length = leng;
  }
#line 67
  return (res);
}
}
#line 70 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_driver.c"
int psiconv_parse(psiconv_config const   config , psiconv_buffer const   buf , psiconv_file *result ) 
{ 
  int res ;
  int lev ;
  int off ;
  int leng ;
  psiconv_file tmp ;
  void *tmp___0 ;

  {
  {
#line 73
  res = 0;
#line 74
  lev = 0;
#line 75
  off = 0;
#line 78
  tmp___0 = malloc(sizeof(*(*result)));
#line 78
  tmp = (psiconv_file )tmp___0;
#line 78
  *result = tmp;
  }
#line 78
  if (! tmp) {
#line 79
    goto ERROR1;
  }
  {
#line 81
  (*result)->type = psiconv_file_type(config, (psiconv_buffer )buf, & leng, (psiconv_header_section *)((void *)0));
  }
#line 82
  if ((unsigned int )(*result)->type == 0U) {
    {
#line 83
    psiconv_warn((psiconv_config )config, lev + 1, (psiconv_u32 )off, "Unknown file type: can\'t parse!");
#line 84
    (*result)->file = (void *)0;
    }
  } else
#line 85
  if ((unsigned int )(*result)->type == 1U) {
    {
#line 86
    res = psiconv_parse_word_file(config, buf, lev + 2, (psiconv_u32 )leng, (psiconv_word_f *)(& (*result)->file));
    }
  } else
#line 88
  if ((unsigned int )(*result)->type == 2U) {
    {
#line 89
    res = psiconv_parse_texted_file(config, buf, lev + 2, (psiconv_u32 )leng, (psiconv_texted_f *)(& (*result)->file));
    }
  } else
#line 91
  if ((unsigned int )(*result)->type == 3U) {
    {
#line 92
    res = psiconv_parse_mbm_file(config, buf, lev + 2, (psiconv_u32 )leng, (psiconv_mbm_f *)(& (*result)->file));
    }
  } else
#line 94
  if ((unsigned int )(*result)->type == 4U) {
    {
#line 95
    res = psiconv_parse_sketch_file(config, buf, lev + 2, (psiconv_u32 )leng, (psiconv_sketch_f *)(& (*result)->file));
    }
  } else
#line 97
  if ((unsigned int )(*result)->type == 5U) {
    {
#line 98
    res = psiconv_parse_clipart_file(config, buf, lev + 2, (psiconv_u32 )leng, (psiconv_clipart_f *)(& (*result)->file));
    }
  } else
#line 100
  if ((unsigned int )(*result)->type == 6U) {
    {
#line 101
    res = psiconv_parse_sheet_file(config, buf, lev + 2, (psiconv_u32 )leng, (psiconv_sheet_f *)(& (*result)->file));
    }
  } else {
    {
#line 104
    psiconv_warn((psiconv_config )config, lev + 1, (psiconv_u32 )off, "Can\'t parse this file yet!");
#line 105
    (*result)->file = (void *)0;
    }
  }
#line 107
  if (res) {
#line 108
    goto ERROR2;
  }
#line 109
  return (0);
  ERROR2: 
  {
#line 112
  free((void *)*result);
  }
  ERROR1: 
  {
#line 114
  psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )off, "Reading of Psion File failed");
  }
#line 115
  if (res == 0) {
#line 116
    return (-2);
  } else {
#line 118
    return (res);
  }
}
}
#line 121 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_driver.c"
int psiconv_parse_clipart_file(psiconv_config const   config , psiconv_buffer const   buf ,
                               int lev , psiconv_u32 off , psiconv_clipart_f *result ) 
{ 
  int res ;
  int i ;
  psiconv_jumptable_section table ;
  psiconv_clipart_section clipart ;
  psiconv_u32 *entry ;
  psiconv_clipart_f tmp ;
  void *tmp___0 ;
  psiconv_cliparts tmp___1 ;
  void *tmp___2 ;
  psiconv_u32 tmp___3 ;
  void *tmp___4 ;
  psiconv_u32 tmp___5 ;

  {
  {
#line 125
  res = 0;
#line 131
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a clipart file");
#line 132
  tmp___0 = malloc(sizeof(*(*result)));
#line 132
  tmp = (psiconv_clipart_f )tmp___0;
#line 132
  *result = tmp;
  }
#line 132
  if (! tmp) {
#line 133
    goto ERROR1;
  }
  {
#line 135
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the MBM jumptable");
#line 136
  res = psiconv_parse_jumptable_section(config, buf, lev + 2, off, (int *)((void *)0),
                                        & table);
  }
#line 136
  if (res) {
#line 137
    goto ERROR2;
  }
  {
#line 139
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the clipart sections");
#line 140
  tmp___1 = psiconv_list_new(sizeof(*clipart));
#line 140
  (*result)->sections = tmp___1;
  }
#line 140
  if (! tmp___1) {
#line 141
    goto ERROR3;
  }
#line 142
  i = 0;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 142
    tmp___3 = psiconv_list_length((psiconv_list const   )table);
    }
#line 142
    if (! ((psiconv_u32 )i < tmp___3)) {
#line 142
      goto while_break;
    }
    {
#line 143
    tmp___2 = psiconv_list_get((psiconv_list const   )table, (psiconv_u32 )i);
#line 143
    entry = (psiconv_u32 *)tmp___2;
    }
#line 143
    if (! entry) {
#line 144
      goto ERROR4;
    }
    {
#line 145
    psiconv_progress((psiconv_config )config, lev + 3, off, "Going to read clipart section %i",
                     i);
#line 146
    res = psiconv_parse_clipart_section(config, buf, lev + 3, *entry, (int *)((void *)0),
                                        & clipart);
    }
#line 146
    if (res) {
#line 147
      goto ERROR4;
    }
    {
#line 148
    res = psiconv_list_add((*result)->sections, (void const   *)clipart);
    }
#line 148
    if (res) {
#line 149
      goto ERROR5;
    }
    {
#line 150
    free((void *)clipart);
#line 142
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 153
  psiconv_free_jumptable_section(table);
#line 154
  psiconv_progress((psiconv_config )config, lev + 1, off, "End of clipart file");
  }
#line 155
  return (res);
  ERROR5: 
  {
#line 157
  psiconv_free_clipart_section(clipart);
  }
  ERROR4: 
#line 159
  i = 0;
  {
#line 159
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 159
    tmp___5 = psiconv_list_length((psiconv_list const   )(*result)->sections);
    }
#line 159
    if (! ((psiconv_u32 )i < tmp___5)) {
#line 159
      goto while_break___0;
    }
    {
#line 160
    tmp___4 = psiconv_list_get((psiconv_list const   )(*result)->sections, (psiconv_u32 )i);
#line 160
    clipart = (psiconv_clipart_section )tmp___4;
    }
#line 160
    if (! clipart) {
      {
#line 161
      psiconv_error((psiconv_config )config, lev + 1, off, "Data structure corruption");
      }
#line 162
      goto ERROR3;
    }
    {
#line 164
    psiconv_free_clipart_section(clipart);
#line 159
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 166
  psiconv_list_free((*result)->sections);
  }
  ERROR3: 
  {
#line 168
  psiconv_free_jumptable_section(table);
  }
  ERROR2: 
  {
#line 170
  free((void *)*result);
  }
  ERROR1: 
  {
#line 172
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Clipart File failed");
  }
#line 173
  if (res == 0) {
#line 174
    return (-2);
  } else {
#line 176
    return (res);
  }
}
}
#line 179 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_driver.c"
int psiconv_parse_mbm_file(psiconv_config const   config , psiconv_buffer const   buf ,
                           int lev , psiconv_u32 off , psiconv_mbm_f *result ) 
{ 
  int res ;
  int i ;
  psiconv_jumptable_section table ;
  psiconv_paint_data_section paint ;
  psiconv_u32 *entry ;
  psiconv_u32 sto ;
  psiconv_mbm_f tmp ;
  void *tmp___0 ;
  psiconv_pictures tmp___1 ;
  void *tmp___2 ;
  psiconv_u32 tmp___3 ;
  void *tmp___4 ;
  psiconv_u32 tmp___5 ;

  {
  {
#line 183
  res = 0;
#line 190
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a mbm file");
#line 191
  tmp___0 = malloc(sizeof(*(*result)));
#line 191
  tmp = (psiconv_mbm_f )tmp___0;
#line 191
  *result = tmp;
  }
#line 191
  if (! tmp) {
#line 192
    goto ERROR1;
  }
  {
#line 194
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the offset of the MBM jumptable");
#line 195
  sto = psiconv_read_u32(config, buf, lev + 2, off, & res);
  }
#line 196
  if (res) {
#line 197
    goto ERROR2;
  }
  {
#line 198
  psiconv_debug((psiconv_config )config, lev + 2, off, "Offset: %08x", sto);
#line 200
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the MBM jumptable");
#line 201
  res = psiconv_parse_jumptable_section(config, buf, lev + 2, sto, (int *)((void *)0),
                                        & table);
  }
#line 201
  if (res) {
#line 202
    goto ERROR2;
  }
  {
#line 204
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the picture sections");
#line 205
  tmp___1 = psiconv_list_new(sizeof(*paint));
#line 205
  (*result)->sections = tmp___1;
  }
#line 205
  if (! tmp___1) {
#line 206
    goto ERROR3;
  }
#line 207
  i = 0;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 207
    tmp___3 = psiconv_list_length((psiconv_list const   )table);
    }
#line 207
    if (! ((psiconv_u32 )i < tmp___3)) {
#line 207
      goto while_break;
    }
    {
#line 208
    tmp___2 = psiconv_list_get((psiconv_list const   )table, (psiconv_u32 )i);
#line 208
    entry = (psiconv_u32 *)tmp___2;
    }
#line 208
    if (! entry) {
#line 209
      goto ERROR4;
    }
    {
#line 210
    psiconv_progress((psiconv_config )config, lev + 3, off, "Going to read picture section %i",
                     i);
#line 211
    res = psiconv_parse_paint_data_section(config, buf, lev + 3, *entry, (int *)((void *)0),
                                           0, & paint);
    }
#line 211
    if (res) {
#line 213
      goto ERROR4;
    }
    {
#line 214
    res = psiconv_list_add((*result)->sections, (void const   *)paint);
    }
#line 214
    if (res) {
#line 215
      goto ERROR5;
    }
    {
#line 216
    free((void *)paint);
#line 207
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 219
  psiconv_free_jumptable_section(table);
#line 220
  psiconv_progress((psiconv_config )config, lev + 1, off, "End of mbm file");
  }
#line 221
  return (0);
  ERROR5: 
  {
#line 223
  psiconv_free_paint_data_section(paint);
  }
  ERROR4: 
#line 225
  i = 0;
  {
#line 225
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 225
    tmp___5 = psiconv_list_length((psiconv_list const   )(*result)->sections);
    }
#line 225
    if (! ((psiconv_u32 )i < tmp___5)) {
#line 225
      goto while_break___0;
    }
    {
#line 226
    tmp___4 = psiconv_list_get((psiconv_list const   )(*result)->sections, (psiconv_u32 )i);
#line 226
    paint = (psiconv_paint_data_section )tmp___4;
    }
#line 226
    if (! paint) {
      {
#line 227
      psiconv_error((psiconv_config )config, lev + 1, off, "Data structure corruption");
      }
#line 228
      goto ERROR3;
    }
    {
#line 230
    psiconv_free_paint_data_section(paint);
#line 225
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 232
  psiconv_list_free((*result)->sections);
  }
  ERROR3: 
  {
#line 234
  psiconv_free_jumptable_section(table);
  }
  ERROR2: 
  {
#line 236
  free((void *)*result);
  }
  ERROR1: 
  {
#line 238
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of MBM File failed");
  }
#line 239
  if (res == 0) {
#line 240
    return (-2);
  } else {
#line 242
    return (res);
  }
}
}
#line 245 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_driver.c"
int psiconv_parse_sketch_file(psiconv_config const   config , psiconv_buffer const   buf ,
                              int lev , psiconv_u32 off , psiconv_sketch_f *result ) 
{ 
  psiconv_section_table_section table ;
  psiconv_application_id_section appl_id ;
  psiconv_u32 applid_sec ;
  psiconv_u32 sketch_sec ;
  psiconv_u32 sto ;
  psiconv_section_table_entry entry ;
  int i ;
  int res ;
  char *temp_str ;
  psiconv_sketch_f tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  psiconv_u32 tmp___2 ;
  psiconv_bool_t tmp___3 ;

  {
  {
#line 252
  applid_sec = (psiconv_u32 )0;
#line 253
  sketch_sec = (psiconv_u32 )0;
#line 257
  res = 0;
#line 260
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a sketch file");
#line 261
  tmp___0 = malloc(sizeof(*(*result)));
#line 261
  tmp = (psiconv_sketch_f )tmp___0;
#line 261
  *result = tmp;
  }
#line 261
  if (! tmp) {
#line 262
    goto ERROR1;
  }
  {
#line 264
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the offset of the section table section");
#line 266
  sto = psiconv_read_u32(config, buf, lev + 2, off, & res);
  }
#line 267
  if (res) {
#line 268
    goto ERROR2;
  }
  {
#line 269
  psiconv_debug((psiconv_config )config, lev + 2, off, "Offset: %08x", sto);
#line 271
  psiconv_progress((psiconv_config )config, lev + 2, sto, "Going to read the section table section");
#line 272
  res = psiconv_parse_section_table_section(config, buf, lev + 2, sto, (int *)((void *)0),
                                            & table);
  }
#line 272
  if (res) {
#line 273
    goto ERROR2;
  }
#line 275
  i = 0;
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 275
    tmp___2 = psiconv_list_length((psiconv_list const   )table);
    }
#line 275
    if (! ((psiconv_u32 )i < tmp___2)) {
#line 275
      goto while_break;
    }
    {
#line 276
    psiconv_progress((psiconv_config )config, lev + 2, sto, "Going to read entry %d",
                     i);
#line 277
    tmp___1 = psiconv_list_get((psiconv_list const   )table, (psiconv_u32 )i);
#line 277
    entry = (psiconv_section_table_entry )tmp___1;
    }
#line 277
    if (! entry) {
#line 278
      goto ERROR3;
    }
#line 279
    if (entry->id == 268435593U) {
      {
#line 280
      applid_sec = entry->offset;
#line 281
      psiconv_debug((psiconv_config )config, lev + 3, sto, "Found the Application ID section at %08x",
                    applid_sec);
      }
    } else
#line 283
    if (entry->id == 268435581U) {
      {
#line 284
      sketch_sec = entry->offset;
#line 285
      psiconv_debug((psiconv_config )config, lev + 3, sto, "Found the Sketch section at %08x",
                    sketch_sec);
      }
    } else {
      {
#line 288
      psiconv_warn((psiconv_config )config, lev + 3, sto, "Found unknown section in the Section Table (ignoring)");
#line 290
      psiconv_debug((psiconv_config )config, lev + 3, sto, "Section ID %08x, offset %08x",
                    entry->id, entry->offset);
      }
    }
#line 275
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 295
  psiconv_progress((psiconv_config )config, lev + 2, sto, "Looking for the Application ID section");
  }
#line 296
  if (! applid_sec) {
    {
#line 297
    psiconv_error((psiconv_config )config, lev + 2, sto, "Application ID section not found in the section table");
#line 299
    res = -3;
    }
#line 300
    goto ERROR3;
  } else {
    {
#line 302
    psiconv_debug((psiconv_config )config, lev + 2, sto, "Application ID section at offset %08x",
                  applid_sec);
#line 304
    res = psiconv_parse_application_id_section(config, buf, lev + 2, applid_sec, (int *)((void *)0),
                                               & appl_id);
    }
#line 304
    if (res) {
#line 306
      goto ERROR3;
    }
  }
#line 308
  if (appl_id->id != 268435581U) {
#line 308
    goto _L;
  } else {
    {
#line 308
    tmp___3 = applid_matches(appl_id->name, "paint.app");
    }
#line 308
    if (! tmp___3) {
      _L: /* CIL Label */ 
      {
#line 310
      psiconv_warn((psiconv_config )config, lev + 2, applid_sec, "Application ID section contains unexpected data");
#line 312
      psiconv_debug((psiconv_config )config, lev + 2, applid_sec, "ID: %08x expected, %08x found",
                    268435581, appl_id->id);
#line 314
      temp_str = psiconv_make_printable(config, (psiconv_string_t const   )appl_id->name);
      }
#line 314
      if (! temp_str) {
#line 315
        goto ERROR4;
      }
      {
#line 316
      psiconv_debug((psiconv_config )config, lev + 2, applid_sec, "Name: `%s\' expected, `%s\' found",
                    "Paint.app", temp_str);
#line 318
      free((void *)temp_str);
#line 319
      res = -3;
      }
#line 320
      goto ERROR4;
    }
  }
  {
#line 323
  psiconv_progress((psiconv_config )config, lev + 2, sto, "Looking for the Sketch section");
  }
#line 324
  if (! sketch_sec) {
    {
#line 325
    psiconv_warn((psiconv_config )config, lev + 2, sto, "Sketch section not found in the section table");
    }
  } else {
    {
#line 328
    psiconv_debug((psiconv_config )config, lev + 2, sto, "Sketch section at offset %08x",
                  applid_sec);
#line 330
    res = psiconv_parse_sketch_section(config, buf, lev + 2, sketch_sec, (int *)((void *)0),
                                       & (*result)->sketch_sec);
    }
#line 330
    if (res) {
#line 332
      goto ERROR4;
    }
  }
  {
#line 335
  psiconv_free_application_id_section(appl_id);
#line 336
  psiconv_free_section_table_section(table);
#line 338
  psiconv_progress((psiconv_config )config, lev + 1, off, "End of sketch file");
  }
#line 339
  return (res);
  ERROR4: 
  {
#line 342
  psiconv_free_application_id_section(appl_id);
  }
  ERROR3: 
  {
#line 344
  free((void *)table);
  }
  ERROR2: 
  {
#line 346
  free((void *)*result);
  }
  ERROR1: 
  {
#line 348
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sketch File failed");
  }
#line 349
  if (res == 0) {
#line 350
    return (-2);
  } else {
#line 352
    return (res);
  }
}
}
#line 356 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_driver.c"
int psiconv_parse_texted_file(psiconv_config const   config , psiconv_buffer const   buf ,
                              int lev , psiconv_u32 off , psiconv_texted_f *result ) 
{ 
  int res ;
  psiconv_section_table_section table ;
  psiconv_application_id_section appl_id ;
  char *temp_str ;
  psiconv_character_layout base_char ;
  psiconv_paragraph_layout base_para ;
  psiconv_u32 page_sec ;
  psiconv_u32 texted_sec ;
  psiconv_u32 applid_sec ;
  psiconv_u32 sto ;
  psiconv_section_table_entry entry ;
  int i ;
  psiconv_texted_f tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  psiconv_u32 tmp___2 ;
  psiconv_bool_t tmp___3 ;

  {
  {
#line 361
  res = 0;
#line 367
  page_sec = (psiconv_u32 )0;
#line 368
  texted_sec = (psiconv_u32 )0;
#line 369
  applid_sec = (psiconv_u32 )0;
#line 374
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a texted file");
#line 375
  tmp___0 = malloc(sizeof(*(*result)));
#line 375
  tmp = (psiconv_texted_f )tmp___0;
#line 375
  *result = tmp;
  }
#line 375
  if (! tmp) {
#line 376
    goto ERROR1;
  }
  {
#line 378
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the offset of the section table section");
#line 380
  sto = psiconv_read_u32(config, buf, lev + 2, off, & res);
  }
#line 381
  if (res) {
#line 382
    goto ERROR2;
  }
  {
#line 383
  psiconv_debug((psiconv_config )config, lev + 2, off, "Offset: %08x", sto);
#line 385
  psiconv_progress((psiconv_config )config, lev + 2, sto, "Going to read the section table section");
#line 386
  res = psiconv_parse_section_table_section(config, buf, lev + 2, sto, (int *)((void *)0),
                                            & table);
  }
#line 386
  if (res) {
#line 387
    goto ERROR2;
  }
#line 389
  i = 0;
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 389
    tmp___2 = psiconv_list_length((psiconv_list const   )table);
    }
#line 389
    if (! ((psiconv_u32 )i < tmp___2)) {
#line 389
      goto while_break;
    }
    {
#line 390
    psiconv_progress((psiconv_config )config, lev + 2, sto, "Going to read entry %d",
                     i);
#line 391
    tmp___1 = psiconv_list_get((psiconv_list const   )table, (psiconv_u32 )i);
#line 391
    entry = (psiconv_section_table_entry )tmp___1;
    }
#line 391
    if (! entry) {
#line 392
      goto ERROR3;
    }
#line 393
    if (entry->id == 268435593U) {
      {
#line 394
      applid_sec = entry->offset;
#line 395
      psiconv_debug((psiconv_config )config, lev + 3, sto, "Found the Application ID section at %08x",
                    applid_sec);
      }
    } else
#line 397
    if (entry->id == 268435717U) {
      {
#line 398
      page_sec = entry->offset;
#line 399
      psiconv_debug((psiconv_config )config, lev + 3, sto, "Found the Page Layout section at %08x",
                    page_sec);
      }
    } else
#line 401
    if (entry->id == 268435589U) {
      {
#line 402
      texted_sec = entry->offset;
#line 403
      psiconv_debug((psiconv_config )config, lev + 3, sto, "Found the TextEd section at %08x",
                    texted_sec);
      }
    } else {
      {
#line 406
      psiconv_warn((psiconv_config )config, lev + 3, sto, "Found unknown section in the Section Table (ignoring)");
#line 408
      psiconv_debug((psiconv_config )config, lev + 3, sto, "Section ID %08x, offset %08x",
                    entry->id, entry->offset);
      }
    }
#line 389
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 413
  psiconv_progress((psiconv_config )config, lev + 2, sto, "Looking for the Application ID section");
  }
#line 414
  if (! applid_sec) {
    {
#line 415
    psiconv_error((psiconv_config )config, lev + 2, sto, "Application ID section not found in the section table");
#line 417
    res = -3;
    }
#line 418
    goto ERROR3;
  } else {
    {
#line 420
    psiconv_debug((psiconv_config )config, lev + 2, sto, "Application ID section at offset %08x",
                  applid_sec);
#line 422
    res = psiconv_parse_application_id_section(config, buf, lev + 2, applid_sec, (int *)((void *)0),
                                               & appl_id);
    }
#line 422
    if (res) {
#line 424
      goto ERROR3;
    }
  }
#line 427
  if (appl_id->id != 268435589U) {
#line 427
    goto _L;
  } else {
    {
#line 427
    tmp___3 = applid_matches(appl_id->name, "texted.app");
    }
#line 427
    if (! tmp___3) {
      _L: /* CIL Label */ 
      {
#line 429
      psiconv_warn((psiconv_config )config, lev + 2, applid_sec, "Application ID section contains unexpected data");
#line 431
      psiconv_debug((psiconv_config )config, lev + 2, applid_sec, "ID: %08x expected, %08x found",
                    268435589, appl_id->id);
#line 433
      temp_str = psiconv_make_printable(config, (psiconv_string_t const   )appl_id->name);
      }
#line 433
      if (! temp_str) {
#line 434
        goto ERROR4;
      }
      {
#line 435
      psiconv_debug((psiconv_config )config, lev + 2, applid_sec, "Name: `%s\' expected, `%s\' found",
                    "TextEd.app", temp_str);
#line 437
      free((void *)temp_str);
#line 438
      res = -3;
      }
#line 439
      goto ERROR4;
    }
  }
  {
#line 442
  psiconv_progress((psiconv_config )config, lev + 2, sto, "Looking for the Page layout section");
  }
#line 444
  if (! page_sec) {
    {
#line 445
    psiconv_error((psiconv_config )config, lev + 2, sto, "Page layout section not found in the section table");
#line 447
    res = -3;
    }
#line 448
    goto ERROR4;
  } else {
    {
#line 450
    psiconv_debug((psiconv_config )config, lev + 2, sto, "Page layout section at offset %08x",
                  page_sec);
#line 452
    res = psiconv_parse_page_layout_section(config, buf, lev + 2, page_sec, (int *)((void *)0),
                                            & (*result)->page_sec);
    }
#line 452
    if (res) {
#line 454
      goto ERROR4;
    }
  }
  {
#line 457
  base_char = psiconv_basic_character_layout();
  }
#line 457
  if (! base_char) {
#line 458
    goto ERROR5;
  }
  {
#line 459
  base_para = psiconv_basic_paragraph_layout();
  }
#line 459
  if (! base_para) {
#line 460
    goto ERROR6;
  }
  {
#line 462
  psiconv_progress((psiconv_config )config, lev + 2, sto, "Looking for the TextEd section");
  }
#line 464
  if (! texted_sec) {
    {
#line 465
    psiconv_error((psiconv_config )config, lev + 2, sto, "TextEd section not found in the section table");
#line 467
    res = -3;
    }
#line 468
    goto ERROR7;
  } else {
    {
#line 470
    psiconv_debug((psiconv_config )config, lev + 2, sto, "TextEd section at offset %08x",
                  texted_sec);
#line 471
    res = psiconv_parse_texted_section(config, buf, lev + 2, texted_sec, (int *)((void *)0),
                                       & (*result)->texted_sec, base_char, base_para);
    }
#line 471
    if (res) {
#line 474
      goto ERROR7;
    }
  }
  {
#line 476
  psiconv_free_character_layout(base_char);
#line 477
  psiconv_free_paragraph_layout(base_para);
#line 479
  psiconv_free_application_id_section(appl_id);
#line 480
  psiconv_free_section_table_section(table);
#line 482
  psiconv_progress((psiconv_config )config, lev + 1, off, "End of TextEd file");
  }
#line 483
  return (0);
  ERROR7: 
  {
#line 486
  psiconv_free_paragraph_layout(base_para);
  }
  ERROR6: 
  {
#line 488
  psiconv_free_character_layout(base_char);
  }
  ERROR5: 
  {
#line 490
  psiconv_free_page_layout_section((*result)->page_sec);
  }
  ERROR4: 
  {
#line 492
  psiconv_free_application_id_section(appl_id);
  }
  ERROR3: 
  {
#line 494
  psiconv_free_section_table_section(table);
  }
  ERROR2: 
  {
#line 496
  free((void *)*result);
  }
  ERROR1: 
  {
#line 498
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of TextEd File failed");
  }
#line 499
  if (res == 0) {
#line 500
    return (-2);
  } else {
#line 502
    return (res);
  }
}
}
#line 505 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_driver.c"
int psiconv_parse_word_file(psiconv_config const   config , psiconv_buffer const   buf ,
                            int lev , psiconv_u32 off , psiconv_word_f *result ) 
{ 
  int res ;
  psiconv_section_table_section table ;
  psiconv_application_id_section appl_id ;
  char *temp_str ;
  psiconv_u32 pwd_sec ;
  psiconv_u32 status_sec ;
  psiconv_u32 styles_sec ;
  psiconv_u32 page_sec ;
  psiconv_u32 text_sec ;
  psiconv_u32 layout_sec ;
  psiconv_u32 applid_sec ;
  psiconv_section_table_entry entry ;
  psiconv_u32 sto ;
  int i ;
  psiconv_word_f tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  psiconv_u32 tmp___2 ;
  psiconv_bool_t tmp___3 ;

  {
  {
#line 509
  res = 0;
#line 513
  pwd_sec = (psiconv_u32 )0;
#line 514
  status_sec = (psiconv_u32 )0;
#line 515
  styles_sec = (psiconv_u32 )0;
#line 516
  page_sec = (psiconv_u32 )0;
#line 517
  text_sec = (psiconv_u32 )0;
#line 518
  layout_sec = (psiconv_u32 )0;
#line 519
  applid_sec = (psiconv_u32 )0;
#line 524
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a word file");
#line 525
  tmp___0 = malloc(sizeof(*(*result)));
#line 525
  tmp = (psiconv_word_f )tmp___0;
#line 525
  *result = tmp;
  }
#line 525
  if (! tmp) {
#line 526
    goto ERROR1;
  }
  {
#line 528
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the offset of the section table section");
#line 530
  sto = psiconv_read_u32(config, buf, lev + 2, off, & res);
  }
#line 531
  if (res) {
#line 532
    goto ERROR2;
  }
  {
#line 533
  psiconv_debug((psiconv_config )config, lev + 2, off, "Offset: %08x", sto);
#line 535
  psiconv_progress((psiconv_config )config, lev + 2, sto, "Going to read the section table section");
#line 537
  res = psiconv_parse_section_table_section(config, buf, lev + 2, sto, (int *)((void *)0),
                                            & table);
  }
#line 537
  if (res) {
#line 538
    goto ERROR2;
  }
#line 540
  i = 0;
  {
#line 540
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 540
    tmp___2 = psiconv_list_length((psiconv_list const   )table);
    }
#line 540
    if (! ((psiconv_u32 )i < tmp___2)) {
#line 540
      goto while_break;
    }
    {
#line 541
    psiconv_progress((psiconv_config )config, lev + 2, sto, "Going to read entry %d",
                     i);
#line 542
    tmp___1 = psiconv_list_get((psiconv_list const   )table, (psiconv_u32 )i);
#line 542
    entry = (psiconv_section_table_entry )tmp___1;
    }
#line 542
    if (! entry) {
#line 543
      goto ERROR3;
    }
#line 544
    if (entry->id == 268435593U) {
      {
#line 545
      applid_sec = entry->offset;
#line 546
      psiconv_debug((psiconv_config )config, lev + 3, sto, "Found the Application ID section at %08x",
                    applid_sec);
      }
    } else
#line 548
    if (entry->id == 268435717U) {
      {
#line 549
      page_sec = entry->offset;
#line 550
      psiconv_debug((psiconv_config )config, lev + 3, sto, "Found the Page Layout section at %08x",
                    page_sec);
      }
    } else
#line 552
    if (entry->id == 268435718U) {
      {
#line 553
      text_sec = entry->offset;
#line 554
      psiconv_debug((psiconv_config )config, lev + 3, sto, "Found the Text section at %08x",
                    text_sec);
      }
    } else
#line 555
    if (entry->id == 268435661U) {
      {
#line 556
      pwd_sec = entry->offset;
#line 557
      psiconv_debug((psiconv_config )config, lev + 3, sto, "Found the Password section at %08x",
                    pwd_sec);
#line 559
      psiconv_error((psiconv_config )config, lev + 3, sto, "Password section found - can\'t read encrypted data");
#line 561
      res = -3;
      }
#line 562
      goto ERROR3;
    } else
#line 563
    if (entry->id == 268436035U) {
      {
#line 564
      status_sec = entry->offset;
#line 565
      psiconv_debug((psiconv_config )config, lev + 3, sto, "Found the Word Status section at %08x",
                    status_sec);
      }
    } else
#line 567
    if (entry->id == 268435716U) {
      {
#line 568
      styles_sec = entry->offset;
#line 569
      psiconv_debug((psiconv_config )config, lev + 3, sto, "Found the Word Styles section at %08x",
                    styles_sec);
      }
    } else
#line 571
    if (entry->id == 268435779U) {
      {
#line 572
      layout_sec = entry->offset;
#line 573
      psiconv_debug((psiconv_config )config, lev + 3, sto, "Found the Layout section at %08x",
                    layout_sec);
      }
    } else {
      {
#line 576
      psiconv_warn((psiconv_config )config, lev + 3, sto, "Found unknown section in the Section Table (ignoring)");
#line 578
      psiconv_debug((psiconv_config )config, lev + 3, sto, "Section ID %08x, offset %08x",
                    entry->id, entry->offset);
      }
    }
#line 540
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 584
  psiconv_progress((psiconv_config )config, lev + 2, sto, "Looking for the Status section");
  }
#line 586
  if (! status_sec) {
    {
#line 587
    psiconv_error((psiconv_config )config, lev + 2, sto, "Status section not found in the section table");
#line 588
    res = -3;
    }
#line 589
    goto ERROR3;
  } else {
    {
#line 591
    psiconv_debug((psiconv_config )config, lev + 2, sto, "Status section at offset %08x",
                  status_sec);
#line 592
    res = psiconv_parse_word_status_section(config, buf, lev + 2, status_sec, (int *)((void *)0),
                                            & (*result)->status_sec);
    }
#line 592
    if (res) {
#line 594
      goto ERROR3;
    }
  }
  {
#line 597
  psiconv_progress((psiconv_config )config, lev + 2, sto, "Looking for the Application ID section");
  }
#line 598
  if (! applid_sec) {
    {
#line 599
    psiconv_error((psiconv_config )config, lev + 2, sto, "Application ID section not found in the section table");
#line 601
    res = -3;
    }
#line 602
    goto ERROR4;
  } else {
    {
#line 604
    psiconv_debug((psiconv_config )config, lev + 2, sto, "Application ID section at offset %08x",
                  applid_sec);
#line 606
    res = psiconv_parse_application_id_section(config, buf, lev + 2, applid_sec, (int *)((void *)0),
                                               & appl_id);
    }
#line 606
    if (res) {
#line 608
      goto ERROR4;
    }
  }
#line 610
  if (appl_id->id != 268435583U) {
#line 610
    goto _L;
  } else {
    {
#line 610
    tmp___3 = applid_matches(appl_id->name, "word.app");
    }
#line 610
    if (! tmp___3) {
      _L: /* CIL Label */ 
      {
#line 612
      psiconv_warn((psiconv_config )config, lev + 2, applid_sec, "Application ID section contains unexpected data");
#line 614
      psiconv_debug((psiconv_config )config, lev + 2, applid_sec, "ID: %08x expected, %08x found",
                    268435583, appl_id->id);
#line 616
      temp_str = psiconv_make_printable(config, (psiconv_string_t const   )appl_id->name);
      }
#line 616
      if (! temp_str) {
#line 617
        goto ERROR5;
      }
      {
#line 618
      psiconv_debug((psiconv_config )config, lev + 2, applid_sec, "Name: `%s\' expected, `%s\' found",
                    "Word.app", temp_str);
#line 620
      free((void *)temp_str);
#line 621
      res = -3;
      }
#line 622
      goto ERROR5;
    }
  }
  {
#line 625
  psiconv_progress((psiconv_config )config, lev + 2, sto, "Looking for the Page layout section");
  }
#line 627
  if (! page_sec) {
    {
#line 628
    psiconv_error((psiconv_config )config, lev + 2, sto, "Page layout section not found in the section table");
#line 630
    res = -3;
    }
#line 631
    goto ERROR5;
  } else {
    {
#line 633
    psiconv_debug((psiconv_config )config, lev + 2, sto, "Page layout section at offset %08x",
                  page_sec);
#line 635
    res = psiconv_parse_page_layout_section(config, buf, lev + 2, page_sec, (int *)((void *)0),
                                            & (*result)->page_sec);
    }
#line 635
    if (res) {
#line 637
      goto ERROR5;
    }
  }
  {
#line 640
  psiconv_progress((psiconv_config )config, lev + 2, sto, "Looking for the Word Style section");
  }
#line 642
  if (! styles_sec) {
    {
#line 643
    psiconv_error((psiconv_config )config, lev + 2, sto, "Word styles section not found in the section table");
#line 645
    res = -3;
    }
#line 646
    goto ERROR6;
  } else {
    {
#line 648
    psiconv_debug((psiconv_config )config, lev + 2, sto, "Word styles section at offset %08x",
                  styles_sec);
#line 650
    res = psiconv_parse_word_styles_section(config, buf, lev + 2, styles_sec, (int *)((void *)0),
                                            & (*result)->styles_sec);
    }
#line 650
    if (res) {
#line 652
      goto ERROR6;
    }
  }
  {
#line 655
  psiconv_progress((psiconv_config )config, lev + 2, sto, "Looking for the Text section");
  }
#line 657
  if (! text_sec) {
    {
#line 658
    psiconv_error((psiconv_config )config, lev + 2, sto, "Text section not found in the section table");
#line 659
    res = -3;
    }
#line 660
    goto ERROR7;
  } else {
    {
#line 662
    psiconv_debug((psiconv_config )config, lev + 2, sto, "Text section at offset %08x",
                  text_sec);
#line 664
    res = psiconv_parse_text_section(config, buf, lev + 2, text_sec, (int *)((void *)0),
                                     & (*result)->paragraphs);
    }
#line 664
    if (res) {
#line 666
      goto ERROR7;
    }
  }
  {
#line 669
  psiconv_progress((psiconv_config )config, lev + 2, sto, "Looking for the Layout section");
  }
#line 670
  if (! layout_sec) {
    {
#line 671
    psiconv_debug((psiconv_config )config, lev + 2, sto, "No layout section today");
    }
  } else {
    {
#line 673
    psiconv_debug((psiconv_config )config, lev + 2, sto, "Layout section at offset %08x",
                  layout_sec);
#line 675
    res = psiconv_parse_styled_layout_section(config, buf, lev + 2, layout_sec, (int *)((void *)0),
                                              (*result)->paragraphs, (psiconv_word_styles_section const   )(*result)->styles_sec);
    }
#line 675
    if (res) {
#line 678
      goto ERROR8;
    }
  }
  {
#line 681
  psiconv_free_application_id_section(appl_id);
#line 682
  psiconv_free_section_table_section(table);
#line 684
  psiconv_progress((psiconv_config )config, lev + 1, off, "End of word file");
  }
#line 685
  return (0);
  ERROR8: 
  {
#line 689
  psiconv_free_text_and_layout((*result)->paragraphs);
  }
  ERROR7: 
  {
#line 691
  psiconv_free_word_styles_section((*result)->styles_sec);
  }
  ERROR6: 
  {
#line 693
  psiconv_free_page_layout_section((*result)->page_sec);
  }
  ERROR5: 
  {
#line 695
  psiconv_free_application_id_section(appl_id);
  }
  ERROR4: 
  {
#line 697
  psiconv_free_word_status_section((*result)->status_sec);
  }
  ERROR3: 
  {
#line 699
  psiconv_free_section_table_section(table);
  }
  ERROR2: 
  {
#line 701
  free((void *)*result);
  }
  ERROR1: 
  {
#line 703
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Word File failed");
  }
#line 704
  if (res == 0) {
#line 705
    return (-2);
  } else {
#line 707
    return (res);
  }
}
}
#line 710 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_driver.c"
int psiconv_parse_sheet_file(psiconv_config const   config , psiconv_buffer const   buf ,
                             int lev , psiconv_u32 off , psiconv_sheet_f *result ) 
{ 
  int res ;
  psiconv_section_table_section table ;
  psiconv_application_id_section appl_id ;
  char *temp_str ;
  psiconv_u32 pwd_sec ;
  psiconv_u32 status_sec ;
  psiconv_u32 page_sec ;
  psiconv_u32 applid_sec ;
  psiconv_u32 workbook_sec ;
  psiconv_section_table_entry entry ;
  psiconv_u32 sto ;
  int i ;
  psiconv_sheet_f tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  psiconv_u32 tmp___2 ;
  psiconv_bool_t tmp___3 ;

  {
  {
#line 714
  res = 0;
#line 718
  pwd_sec = (psiconv_u32 )0;
#line 719
  status_sec = (psiconv_u32 )0;
#line 720
  page_sec = (psiconv_u32 )0;
#line 721
  applid_sec = (psiconv_u32 )0;
#line 722
  workbook_sec = (psiconv_u32 )0;
#line 727
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a sheet file");
#line 728
  tmp___0 = malloc(sizeof(*(*result)));
#line 728
  tmp = (psiconv_sheet_f )tmp___0;
#line 728
  *result = tmp;
  }
#line 728
  if (! tmp) {
#line 729
    goto ERROR1;
  }
  {
#line 731
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the offset of the section table section");
#line 733
  sto = psiconv_read_u32(config, buf, lev + 2, off, & res);
  }
#line 734
  if (res) {
#line 735
    goto ERROR2;
  }
  {
#line 736
  psiconv_debug((psiconv_config )config, lev + 2, off, "Offset: %08x", sto);
#line 738
  psiconv_progress((psiconv_config )config, lev + 2, sto, "Going to read the section table section");
#line 740
  res = psiconv_parse_section_table_section(config, buf, lev + 2, sto, (int *)((void *)0),
                                            & table);
  }
#line 740
  if (res) {
#line 741
    goto ERROR2;
  }
#line 743
  i = 0;
  {
#line 743
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 743
    tmp___2 = psiconv_list_length((psiconv_list const   )table);
    }
#line 743
    if (! ((psiconv_u32 )i < tmp___2)) {
#line 743
      goto while_break;
    }
    {
#line 744
    psiconv_progress((psiconv_config )config, lev + 2, sto, "Going to read entry %d",
                     i);
#line 745
    tmp___1 = psiconv_list_get((psiconv_list const   )table, (psiconv_u32 )i);
#line 745
    entry = (psiconv_section_table_entry )tmp___1;
    }
#line 745
    if (! entry) {
#line 746
      goto ERROR3;
    }
#line 747
    if (entry->id == 268435593U) {
      {
#line 748
      applid_sec = entry->offset;
#line 749
      psiconv_debug((psiconv_config )config, lev + 3, sto, "Found the Application ID section at %08x",
                    applid_sec);
      }
    } else
#line 751
    if (entry->id == 268435717U) {
      {
#line 752
      page_sec = entry->offset;
#line 753
      psiconv_debug((psiconv_config )config, lev + 3, sto, "Found the Page Layout section at %08x",
                    page_sec);
      }
    } else
#line 755
    if (entry->id == 268435661U) {
      {
#line 756
      pwd_sec = entry->offset;
#line 757
      psiconv_debug((psiconv_config )config, lev + 3, sto, "Found the Password section at %08x",
                    pwd_sec);
#line 759
      psiconv_error((psiconv_config )config, lev + 3, sto, "Password section found - can\'t read encrypted data");
#line 761
      res = -3;
      }
#line 762
      goto ERROR3;
    } else
#line 763
    if (entry->id == 268435741U) {
      {
#line 764
      workbook_sec = entry->offset;
#line 765
      psiconv_debug((psiconv_config )config, lev + 3, sto, "Found the Sheet Workbook section at %08x",
                    workbook_sec);
      }
    } else
#line 767
    if (entry->id == 268435743U) {
      {
#line 768
      status_sec = entry->offset;
#line 769
      psiconv_debug((psiconv_config )config, lev + 3, sto, "Found the Sheet Status section at %08x",
                    status_sec);
      }
    } else {
      {
#line 772
      psiconv_warn((psiconv_config )config, lev + 3, sto, "Found unknown section in the Section Table (ignoring)");
#line 774
      psiconv_debug((psiconv_config )config, lev + 3, sto, "Section ID %08x, offset %08x",
                    entry->id, entry->offset);
      }
    }
#line 743
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 780
  psiconv_progress((psiconv_config )config, lev + 2, sto, "Looking for the Status section");
  }
#line 782
  if (! status_sec) {
    {
#line 783
    psiconv_error((psiconv_config )config, lev + 2, sto, "Status section not found in the section table");
#line 784
    res = -3;
    }
#line 785
    goto ERROR3;
  } else {
    {
#line 787
    psiconv_debug((psiconv_config )config, lev + 2, sto, "Status section at offset %08x",
                  status_sec);
#line 788
    res = psiconv_parse_sheet_status_section(config, buf, lev + 2, status_sec, (int *)((void *)0),
                                             & (*result)->status_sec);
    }
#line 788
    if (res) {
#line 790
      goto ERROR3;
    }
  }
  {
#line 793
  psiconv_progress((psiconv_config )config, lev + 2, sto, "Looking for the Application ID section");
  }
#line 794
  if (! applid_sec) {
    {
#line 795
    psiconv_error((psiconv_config )config, lev + 2, sto, "Application ID section not found in the section table");
#line 797
    res = -3;
    }
#line 798
    goto ERROR4;
  } else {
    {
#line 800
    psiconv_debug((psiconv_config )config, lev + 2, sto, "Application ID section at offset %08x",
                  applid_sec);
#line 802
    res = psiconv_parse_application_id_section(config, buf, lev + 2, applid_sec, (int *)((void *)0),
                                               & appl_id);
    }
#line 802
    if (res) {
#line 804
      goto ERROR4;
    }
  }
#line 806
  if (appl_id->id != 268435592U) {
#line 806
    goto _L;
  } else {
    {
#line 806
    tmp___3 = applid_matches(appl_id->name, "sheet.app");
    }
#line 806
    if (! tmp___3) {
      _L: /* CIL Label */ 
      {
#line 808
      psiconv_warn((psiconv_config )config, lev + 2, applid_sec, "Application ID section contains unexpected data");
#line 810
      psiconv_debug((psiconv_config )config, lev + 2, applid_sec, "ID: %08x expected, %08x found",
                    268435592, appl_id->id);
#line 812
      temp_str = psiconv_make_printable(config, (psiconv_string_t const   )appl_id->name);
      }
#line 812
      if (! temp_str) {
#line 813
        goto ERROR5;
      }
      {
#line 814
      psiconv_debug((psiconv_config )config, lev + 2, applid_sec, "Name: `%s\' expected, `%s\' found",
                    "Sheet.app", temp_str);
#line 816
      free((void *)temp_str);
#line 817
      res = -3;
      }
#line 818
      goto ERROR5;
    }
  }
  {
#line 821
  psiconv_progress((psiconv_config )config, lev + 2, sto, "Looking for the Page layout section");
  }
#line 823
  if (! page_sec) {
    {
#line 824
    psiconv_error((psiconv_config )config, lev + 2, sto, "Page layout section not found in the section table");
#line 826
    res = -3;
    }
#line 827
    goto ERROR5;
  } else {
    {
#line 829
    psiconv_debug((psiconv_config )config, lev + 2, sto, "Page layout section at offset %08x",
                  page_sec);
#line 831
    res = psiconv_parse_page_layout_section(config, buf, lev + 2, page_sec, (int *)((void *)0),
                                            & (*result)->page_sec);
    }
#line 831
    if (res) {
#line 833
      goto ERROR5;
    }
  }
  {
#line 836
  psiconv_progress((psiconv_config )config, lev + 2, sto, "Looking for the Sheet Workbook section");
  }
#line 838
  if (! workbook_sec) {
    {
#line 839
    psiconv_error((psiconv_config )config, lev + 2, sto, "Sheet workbook section not found in the section table");
#line 841
    res = -3;
    }
#line 842
    goto ERROR6;
  } else {
    {
#line 844
    psiconv_debug((psiconv_config )config, lev + 2, sto, "Sheet workbook section at offset %08x",
                  page_sec);
#line 846
    res = psiconv_parse_sheet_workbook_section(config, buf, lev + 2, workbook_sec,
                                               (int *)((void *)0), & (*result)->workbook_sec);
    }
#line 846
    if (res) {
#line 848
      goto ERROR6;
    }
  }
  {
#line 851
  psiconv_free_application_id_section(appl_id);
#line 852
  psiconv_free_section_table_section(table);
#line 854
  psiconv_progress((psiconv_config )config, lev + 1, off, "End of Sheet file");
  }
#line 855
  return (0);
  ERROR6: 
  {
#line 858
  psiconv_free_page_layout_section((*result)->page_sec);
  }
  ERROR5: 
  {
#line 860
  psiconv_free_application_id_section(appl_id);
  }
  ERROR4: 
  {
#line 862
  psiconv_free_sheet_status_section((*result)->status_sec);
  }
  ERROR3: 
  {
#line 864
  psiconv_free_section_table_section(table);
  }
  ERROR2: 
  {
#line 866
  free((void *)*result);
  }
  ERROR1: 
  {
#line 868
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet File failed");
  }
#line 869
  if (res == 0) {
#line 870
    return (-2);
  } else {
#line 872
    return (res);
  }
}
}
#line 1096 "../psiconv/data.h"
void psiconv_free_formula(psiconv_formula formula ) ;
#line 1097
void psiconv_free_formula_list(psiconv_formula_list list ) ;
#line 39 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_routines.h"
psiconv_u8 psiconv_read_u8(psiconv_config const   config , psiconv_buffer const   buf ,
                           int lev , psiconv_u32 off , int *status ) ;
#line 42
psiconv_u16 psiconv_read_u16(psiconv_config const   config , psiconv_buffer const   buf ,
                             int lev , psiconv_u32 off , int *status ) ;
#line 52
psiconv_u32 psiconv_read_S(psiconv_config const   config , psiconv_buffer const   buf ,
                           int lev , psiconv_u32 off , int *length , int *status ) ;
#line 70
psiconv_string_t psiconv_read_short_string(psiconv_config const   config , psiconv_buffer const   buf ,
                                           int lev , psiconv_u32 off , int *length ,
                                           int *status ) ;
#line 84
psiconv_float_t psiconv_read_float(psiconv_config const   config , psiconv_buffer const   buf ,
                                   int lev , psiconv_u32 off , int *length , int *status ) ;
#line 252
int psiconv_parse_formula(psiconv_config const   config , psiconv_buffer const   buf ,
                          int lev , psiconv_u32 off , int *length , psiconv_formula *result ) ;
#line 40 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static struct formula_element formula_elements[256]  = 
#line 40 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
  {      {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )1, 2, "<"}, 
        {(psiconv_formula_type_t )2, 2, "<="}, 
        {(psiconv_formula_type_t )3, 2, ">"}, 
        {(psiconv_formula_type_t )4, 2, ">="}, 
        {(psiconv_formula_type_t )5, 2, "<>"}, 
        {(psiconv_formula_type_t )6, 2, "="}, 
        {(psiconv_formula_type_t )7, 2, "+"}, 
        {(psiconv_formula_type_t )8, 2, "-"}, 
        {(psiconv_formula_type_t )9, 2, "*"}, 
        {(psiconv_formula_type_t )10, 2, "/"}, 
        {(psiconv_formula_type_t )11, 2, "^"}, 
        {(psiconv_formula_type_t )12, 1, "+"}, 
        {(psiconv_formula_type_t )13, 1, "-"}, 
        {(psiconv_formula_type_t )14, 1, "NOT"}, 
        {(psiconv_formula_type_t )15, 2, "AND"}, 
        {(psiconv_formula_type_t )16, 2, "OR"}, 
        {(psiconv_formula_type_t )17, 2, "&"}, 
        {(psiconv_formula_type_t )18, 1, "()"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )19, 0, "End of formula"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )20, 0, "Floating point number"}, 
        {(psiconv_formula_type_t )21, 0, "Signed integer number"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )22, 0, "Named variable"}, 
        {(psiconv_formula_type_t )23, 0, "String"}, 
        {(psiconv_formula_type_t )24, 0, "Cell reference"}, 
        {(psiconv_formula_type_t )25, 0, "Cell block"}, 
        {(psiconv_formula_type_t )26, 0, "Cell block {varargs}"}, 
        {(psiconv_formula_type_t )27, 0, "Operand separator"}, 
        {(psiconv_formula_type_t )28, 0, "Operand list end"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )29, 0, "FALSE"}, 
        {(psiconv_formula_type_t )30, 3, "IF"}, 
        {(psiconv_formula_type_t )31, 0, "TRUE"}, 
        {(psiconv_formula_type_t )32, 2, "CELL"}, 
        {(psiconv_formula_type_t )33, 0, "ERRORTYPE"}, 
        {(psiconv_formula_type_t )34, 1, "ISBLANK"}, 
        {(psiconv_formula_type_t )35, 1, "ISERR"}, 
        {(psiconv_formula_type_t )36, 1, "ISERROR"}, 
        {(psiconv_formula_type_t )37, 1, "ISLOGICAL"}, 
        {(psiconv_formula_type_t )38, 1, "ISNA"}, 
        {(psiconv_formula_type_t )39, 1, "ISNONTEXT"}, 
        {(psiconv_formula_type_t )40, 1, "ISNUMBER"}, 
        {(psiconv_formula_type_t )41, 1, "ISTEXT"}, 
        {(psiconv_formula_type_t )42, 1, "N"}, 
        {(psiconv_formula_type_t )43, 1, "TYPE"}, 
        {(psiconv_formula_type_t )44, 2, "ADDRESS"}, 
        {(psiconv_formula_type_t )45, 1, "COLUMN"}, 
        {(psiconv_formula_type_t )46, 1, "COLUMNS"}, 
        {(psiconv_formula_type_t )47, 3, "HLOOKUP"}, 
        {(psiconv_formula_type_t )48, 3, "INDEX"}, 
        {(psiconv_formula_type_t )49, 1, "INDIRECT"}, 
        {(psiconv_formula_type_t )50, 3, "LOOKUP"}, 
        {(psiconv_formula_type_t )51, 3, "OFFSET"}, 
        {(psiconv_formula_type_t )52, 1, "ROW"}, 
        {(psiconv_formula_type_t )53, 1, "ROWS"}, 
        {(psiconv_formula_type_t )54, 3, "VLOOKUP"}, 
        {(psiconv_formula_type_t )55, 1, "CHAR"}, 
        {(psiconv_formula_type_t )56, 1, "CODE"}, 
        {(psiconv_formula_type_t )57, 2, "EXACT"}, 
        {(psiconv_formula_type_t )58, 3, "FIND"}, 
        {(psiconv_formula_type_t )59, 2, "LEFT"}, 
        {(psiconv_formula_type_t )60, 1, "LEN"}, 
        {(psiconv_formula_type_t )61, 1, "LOWER"}, 
        {(psiconv_formula_type_t )62, 3, "MID"}, 
        {(psiconv_formula_type_t )63, 1, "PROPER"}, 
        {(psiconv_formula_type_t )64, 4, "REPLACE"}, 
        {(psiconv_formula_type_t )65, 2, "REPT"}, 
        {(psiconv_formula_type_t )66, 2, "RIGHT"}, 
        {(psiconv_formula_type_t )67, 2, "STRING"}, 
        {(psiconv_formula_type_t )68, 1, "T"}, 
        {(psiconv_formula_type_t )69, 1, "TRIM"}, 
        {(psiconv_formula_type_t )70, 1, "UPPER"}, 
        {(psiconv_formula_type_t )71, 1, "VALUE"}, 
        {(psiconv_formula_type_t )72, 3, "DATE"}, 
        {(psiconv_formula_type_t )73, 1, "DATEVALUE"}, 
        {(psiconv_formula_type_t )74, 1, "DAY"}, 
        {(psiconv_formula_type_t )75, 1, "HOUR"}, 
        {(psiconv_formula_type_t )76, 1, "MINUTE"}, 
        {(psiconv_formula_type_t )77, 1, "MONTH"}, 
        {(psiconv_formula_type_t )78, 0, "NOW"}, 
        {(psiconv_formula_type_t )79, 1, "SECOND"}, 
        {(psiconv_formula_type_t )80, 0, "TODAY"}, 
        {(psiconv_formula_type_t )81, 3, "TIME"}, 
        {(psiconv_formula_type_t )82, 1, "TIMEVALUE"}, 
        {(psiconv_formula_type_t )83, 1, "YEAR"}, 
        {(psiconv_formula_type_t )84, 1, "ABS"}, 
        {(psiconv_formula_type_t )85, 1, "ACOS"}, 
        {(psiconv_formula_type_t )86, 1, "ASIN"}, 
        {(psiconv_formula_type_t )87, 1, "ATAN"}, 
        {(psiconv_formula_type_t )88, 2, "ATAN2"}, 
        {(psiconv_formula_type_t )89, 1, "COS"}, 
        {(psiconv_formula_type_t )90, 0, "DEGREES"}, 
        {(psiconv_formula_type_t )91, 1, "EXP"}, 
        {(psiconv_formula_type_t )92, 1, "FACT"}, 
        {(psiconv_formula_type_t )93, 1, "INT"}, 
        {(psiconv_formula_type_t )94, 1, "LN"}, 
        {(psiconv_formula_type_t )95, 1, "LOG10"}, 
        {(psiconv_formula_type_t )96, 2, "MOD"}, 
        {(psiconv_formula_type_t )97, 0, "PI"}, 
        {(psiconv_formula_type_t )98, 1, "RADIANS"}, 
        {(psiconv_formula_type_t )99, 0, "RAND"}, 
        {(psiconv_formula_type_t )100, 2, "ROUND"}, 
        {(psiconv_formula_type_t )101, 1, "SIGN"}, 
        {(psiconv_formula_type_t )102, 1, "SIN"}, 
        {(psiconv_formula_type_t )103, 1, "SQRT"}, 
        {(psiconv_formula_type_t )104, 2, "SUMPRODUCT"}, 
        {(psiconv_formula_type_t )105, 1, "TAN"}, 
        {(psiconv_formula_type_t )106, 1, "TRUNC"}, 
        {(psiconv_formula_type_t )107, 3, "CTERM"}, 
        {(psiconv_formula_type_t )108, 4, "DDB"}, 
        {(psiconv_formula_type_t )109, 3, "FV"}, 
        {(psiconv_formula_type_t )110, 2, "IRR"}, 
        {(psiconv_formula_type_t )111, 2, "NPV"}, 
        {(psiconv_formula_type_t )112, 3, "PMT"}, 
        {(psiconv_formula_type_t )113, 3, "PV"}, 
        {(psiconv_formula_type_t )114, 3, "RATE"}, 
        {(psiconv_formula_type_t )115, 3, "SLN"}, 
        {(psiconv_formula_type_t )116, 4, "SYD"}, 
        {(psiconv_formula_type_t )117, 3, "TERM"}, 
        {(psiconv_formula_type_t )118, 2, "COMBIN"}, 
        {(psiconv_formula_type_t )119, 2, "PERMUT"}, 
        {(psiconv_formula_type_t )120, -1, "AVERAGE"}, 
        {(psiconv_formula_type_t )121, -1, "CHOOSE"}, 
        {(psiconv_formula_type_t )122, -1, "COUNT"}, 
        {(psiconv_formula_type_t )123, -1, "COUNTA"}, 
        {(psiconv_formula_type_t )124, -1, "COUNTBLANK"}, 
        {(psiconv_formula_type_t )125, -1, "MAX"}, 
        {(psiconv_formula_type_t )126, -1, "MIN"}, 
        {(psiconv_formula_type_t )127, -1, "PRODUCT"}, 
        {(psiconv_formula_type_t )128, -1, "STDEVP"}, 
        {(psiconv_formula_type_t )129, -1, "STDEV"}, 
        {(psiconv_formula_type_t )130, -1, "SUM"}, 
        {(psiconv_formula_type_t )131, -1, "SUMSQ"}, 
        {(psiconv_formula_type_t )132, -1, "VARP"}, 
        {(psiconv_formula_type_t )133, -1, "VAR"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}};
#line 296 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static int psiconv_parse_sheet_ref(psiconv_config const   config , psiconv_buffer const   buf ,
                                   int lev , psiconv_u32 off , int *length , psiconv_sheet_ref_t *result ) 
{ 
  int res ;
  psiconv_u16 temp ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 304
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a sheet ref");
#line 305
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the offset encoding");
#line 306
  temp = psiconv_read_u16(config, buf, lev + 2, off, & res);
  }
#line 307
  if (res) {
#line 308
    if (length) {
#line 309
      *length = 0;
    }
#line 310
    return (res);
  }
  {
#line 312
  psiconv_debug((psiconv_config )config, lev + 2, off, "Encoded word: %04x", (int )temp);
  }
#line 313
  if ((int )temp & 16384) {
#line 313
    result->absolute = (psiconv_bool_t )1;
  } else {
#line 313
    result->absolute = (psiconv_bool_t )0;
  }
#line 314
  if ((int )temp & 32768) {
#line 314
    tmp = -1;
  } else {
#line 314
    tmp = 1;
  }
#line 314
  result->offset = (psiconv_s16 )(((int )temp & 16383) * tmp);
#line 315
  if (result->absolute) {
#line 315
    tmp___0 = "absolute";
  } else {
#line 315
    tmp___0 = "relative";
  }
  {
#line 315
  psiconv_debug((psiconv_config )config, lev + 2, off, "Reference: %s offset %d",
                tmp___0, (int )result->offset);
  }
#line 317
  if (length) {
#line 318
    *length = 2;
  }
#line 319
  return (0);
}
}
#line 322 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static int psiconv_parse_sheet_cell_reference(psiconv_config const   config , psiconv_buffer const   buf ,
                                              int lev , psiconv_u32 off , int *length ,
                                              psiconv_sheet_cell_reference_t *result ) 
{ 
  int len ;
  int leng ;
  int res ;
  psiconv_u8 temp ;

  {
  {
#line 327
  len = 0;
#line 331
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read a sheet cell reference");
#line 332
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the row reference");
#line 333
  res = psiconv_parse_sheet_ref(config, buf, lev + 2, off + (psiconv_u32 )len, & leng,
                                & result->row);
  }
#line 333
  if (res) {
#line 334
    goto ERROR;
  }
  {
#line 335
  len += leng;
#line 336
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the column reference");
#line 337
  res = psiconv_parse_sheet_ref(config, buf, lev + 2, off + (psiconv_u32 )len, & leng,
                                & result->column);
  }
#line 337
  if (res) {
#line 338
    goto ERROR;
  }
  {
#line 339
  len += leng;
#line 341
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the trailing byte (%02x expected)",
                   0);
#line 343
  temp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 344
  if (res) {
#line 345
    goto ERROR;
  }
#line 346
  if ((int )temp != 0) {
    {
#line 347
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unknown byte in cell reference (ignored");
#line 348
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Trailing byte: %02x",
                  (int )temp);
    }
  }
  {
#line 350
  len ++;
#line 351
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of cell reference (total length: %08x)",
                   len);
  }
#line 353
  if (length) {
#line 354
    *length = len;
  }
#line 355
  return (0);
  ERROR: 
#line 357
  if (length) {
#line 358
    *length = 0;
  }
#line 359
  return (res);
}
}
#line 362 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static int psiconv_parse_sheet_cell_block(psiconv_config const   config , psiconv_buffer const   buf ,
                                          int lev , psiconv_u32 off , int *length ,
                                          psiconv_sheet_cell_block_t *result ) 
{ 
  int len ;
  int leng ;
  int res ;

  {
  {
#line 367
  len = 0;
#line 370
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read a sheet cell block");
#line 371
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the first cell");
#line 372
  res = psiconv_parse_sheet_cell_reference(config, buf, lev + 2, off + (psiconv_u32 )len,
                                           & leng, & result->first);
  }
#line 372
  if (res) {
#line 374
    goto ERROR;
  }
  {
#line 375
  len += leng;
#line 376
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the last cell");
#line 377
  res = psiconv_parse_sheet_cell_reference(config, buf, lev + 2, off + (psiconv_u32 )len,
                                           & leng, & result->last);
  }
#line 377
  if (res) {
#line 379
    goto ERROR;
  }
  {
#line 380
  len += leng;
#line 381
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of cell block (total length: %08x)",
                   len);
  }
#line 383
  if (length) {
#line 384
    *length = len;
  }
#line 385
  return (0);
  ERROR: 
#line 387
  if (length) {
#line 388
    *length = 0;
  }
#line 389
  return (res);
}
}
#line 392 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static int psiconv_parse_formula_element_list(psiconv_config const   config , psiconv_buffer const   buf ,
                                              int lev , psiconv_u32 off , int *length ,
                                              psiconv_formula *result , psiconv_u32 maxlen ) 
{ 
  int res ;
  int len ;
  int leng ;
  int eof ;
  psiconv_u8 marker ;
  psiconv_u8 submarker ;
  psiconv_u8 submarker2 ;
  psiconv_formula_list formula_stack ;
  psiconv_formula formula ;
  psiconv_formula subformula ;
  psiconv_formula subformula1 ;
  psiconv_formula subformula2 ;
  psiconv_formula subformula3 ;
  psiconv_formula subformula4 ;
  psiconv_u16 temp ;
  psiconv_u16 nr_of_subs ;
  psiconv_formula tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  psiconv_formula_list tmp___6 ;
  psiconv_formula_list tmp___7 ;
  psiconv_formula_type_t tmp___8 ;
  psiconv_formula_type_t tmp___9 ;
  psiconv_formula_type_t tmp___10 ;
  psiconv_formula_type_t tmp___11 ;
  psiconv_u32 tmp___12 ;
  psiconv_u32 tmp___13 ;

  {
  {
#line 398
  res = 0;
#line 399
  len = 0;
#line 401
  eof = 0;
#line 408
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a formula element list");
#line 409
  tmp___0 = malloc(sizeof(*(*result)));
#line 409
  tmp = (psiconv_formula )tmp___0;
#line 409
  *result = tmp;
  }
#line 409
  if (! tmp) {
#line 410
    goto ERROR1;
  }
  {
#line 411
  formula_stack = psiconv_list_new(sizeof(struct psiconv_formula_s ));
  }
#line 411
  if (! formula_stack) {
#line 412
    goto ERROR2;
  }
  {
#line 413
  tmp___1 = malloc(sizeof(*formula));
#line 413
  formula = (psiconv_formula )tmp___1;
  }
#line 413
  if (! formula) {
#line 414
    goto ERROR3;
  }
  {
#line 416
  formula->type = (psiconv_formula_type_t )0;
#line 417
  tmp___2 = malloc(sizeof(*subformula1));
#line 417
  subformula1 = (psiconv_formula )tmp___2;
  }
#line 417
  if (! subformula1) {
#line 418
    goto ERROR4;
  }
  {
#line 419
  subformula1->type = (psiconv_formula_type_t )0;
#line 420
  tmp___3 = malloc(sizeof(*subformula2));
#line 420
  subformula2 = (psiconv_formula )tmp___3;
  }
#line 420
  if (! subformula2) {
#line 421
    goto ERROR5;
  }
  {
#line 422
  subformula2->type = (psiconv_formula_type_t )0;
#line 423
  tmp___4 = malloc(sizeof(*subformula3));
#line 423
  subformula3 = (psiconv_formula )tmp___4;
  }
#line 423
  if (! subformula3) {
#line 424
    goto ERROR6;
  }
  {
#line 425
  subformula3->type = (psiconv_formula_type_t )0;
#line 426
  tmp___5 = malloc(sizeof(*subformula4));
#line 426
  subformula4 = (psiconv_formula )tmp___5;
  }
#line 426
  if (! subformula4) {
#line 427
    goto ERROR7;
  }
#line 428
  subformula4->type = (psiconv_formula_type_t )0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! eof) {
#line 430
      if (! ((psiconv_u32 )len + off < maxlen)) {
#line 430
        goto while_break;
      }
    } else {
#line 430
      goto while_break;
    }
    {
#line 431
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read a formula item marker");
#line 432
    marker = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
    }
#line 433
    if (res) {
#line 434
      goto ERROR8;
    }
    {
#line 435
    psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Marker: %02x (%s)",
                  (int )marker, formula_elements[marker].name);
#line 437
    len ++;
    }
#line 439
    if ((unsigned int )formula_elements[marker].formula_type == 0U) {
      {
#line 440
      psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Unknown formula marker found!");
      }
#line 441
      goto ERROR8;
    } else
#line 442
    if ((unsigned int )formula_elements[marker].formula_type == 19U) {
      {
#line 448
      len --;
#line 449
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "End of this formula list");
#line 450
      eof = 1;
      }
    } else
#line 442
    if ((unsigned int )formula_elements[marker].formula_type == 28U) {
      {
#line 448
      len --;
#line 449
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "End of this formula list");
#line 450
      eof = 1;
      }
    } else
#line 442
    if ((unsigned int )formula_elements[marker].formula_type == 27U) {
      {
#line 448
      len --;
#line 449
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "End of this formula list");
#line 450
      eof = 1;
      }
    } else
#line 451
    if ((unsigned int )formula_elements[marker].formula_type == 21U) {
      {
#line 453
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: an integer");
#line 454
      formula->data.dat_int = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & res);
      }
#line 455
      if (res) {
#line 456
        goto ERROR8;
      }
      {
#line 457
      formula->type = formula_elements[marker].formula_type;
#line 458
      psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Value: %08x",
                    formula->data.dat_int);
#line 459
      len += 4;
#line 460
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 460
      if (res) {
#line 461
        goto ERROR8;
      }
#line 462
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 463
    if ((unsigned int )formula_elements[marker].formula_type == 20U) {
      {
#line 465
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a float");
#line 466
      formula->data.dat_float = psiconv_read_float(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                   & leng, & res);
      }
#line 468
      if (res) {
#line 469
        goto ERROR8;
      }
      {
#line 470
      formula->type = formula_elements[marker].formula_type;
#line 471
      psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Value: %f",
                    formula->data.dat_float);
#line 472
      len += leng;
#line 473
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 473
      if (res) {
#line 474
        goto ERROR8;
      }
#line 475
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 476
    if ((unsigned int )formula_elements[marker].formula_type == 24U) {
      {
#line 478
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a cell reference");
#line 479
      res = psiconv_parse_sheet_cell_reference(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & leng, & formula->data.dat_cellref);
      }
#line 479
      if (res) {
#line 481
        goto ERROR8;
      }
      {
#line 482
      formula->type = formula_elements[marker].formula_type;
#line 483
      len += leng;
#line 484
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 484
      if (res) {
#line 485
        goto ERROR8;
      }
#line 486
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 487
    if ((unsigned int )formula_elements[marker].formula_type == 25U) {
#line 487
      goto _L;
    } else
#line 487
    if ((unsigned int )formula_elements[marker].formula_type == 26U) {
      _L: /* CIL Label */ 
      {
#line 491
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a cell block");
#line 492
      res = psiconv_parse_sheet_cell_block(config, buf, lev + 2, off + (psiconv_u32 )len,
                                           & leng, & formula->data.dat_cellblock);
      }
#line 492
      if (res) {
#line 494
        goto ERROR8;
      }
      {
#line 495
      formula->type = formula_elements[marker].formula_type;
#line 496
      len += leng;
#line 497
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 497
      if (res) {
#line 498
        goto ERROR8;
      }
#line 499
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 500
    if ((unsigned int )formula_elements[marker].formula_type == 23U) {
      {
#line 502
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a string");
#line 503
      formula->data.dat_string = psiconv_read_short_string(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                           & leng, & res);
      }
#line 505
      if (res) {
#line 506
        goto ERROR8;
      }
      {
#line 507
      formula->type = formula_elements[marker].formula_type;
#line 508
      len += leng;
#line 509
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 509
      if (res) {
#line 510
        goto ERROR8;
      }
#line 511
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 512
    if ((unsigned int )formula_elements[marker].formula_type == 22U) {
      {
#line 514
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a variable reference");
#line 515
      formula->data.dat_variable = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                    & res);
      }
#line 516
      if (res) {
#line 517
        goto ERROR8;
      }
      {
#line 518
      formula->type = formula_elements[marker].formula_type;
#line 519
      len += 4;
#line 520
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 520
      if (res) {
#line 521
        goto ERROR8;
      }
#line 522
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 523
    if (formula_elements[marker].number_of_args == -1) {
      {
#line 524
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Going to parse a vararg function");
#line 525
      tmp___6 = psiconv_list_new(sizeof(*formula));
#line 525
      formula->data.fun_operands = tmp___6;
      }
#line 525
      if (! tmp___6) {
#line 527
        goto ERROR8;
      }
#line 528
      formula->type = formula_elements[marker].formula_type;
#line 529
      nr_of_subs = (psiconv_u16 )0;
      {
#line 530
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 531
        nr_of_subs = (psiconv_u16 )((int )nr_of_subs + 1);
#line 532
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read vararg argument %d", (int )nr_of_subs);
#line 534
        res = psiconv_parse_formula_element_list(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                 & leng, & subformula, maxlen);
        }
#line 534
        if (res) {
#line 536
          goto ERROR8;
        }
        {
#line 537
        len += leng;
#line 538
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula);
        }
#line 538
        if (res) {
          {
#line 539
          psiconv_free_formula(subformula);
          }
#line 540
          goto ERROR8;
        }
        {
#line 542
        free((void *)subformula);
#line 543
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read the next marker");
#line 544
        submarker = psiconv_read_u8(config, buf, lev + 4, off + (psiconv_u32 )len,
                                    & res);
#line 545
        len ++;
        }
#line 546
        if (res) {
#line 547
          goto ERROR8;
        }
        {
#line 548
        submarker2 = psiconv_read_u8(config, buf, lev + 4, off + (psiconv_u32 )len,
                                     & res);
        }
#line 549
        if (res) {
#line 550
          goto ERROR8;
        }
#line 530
        if ((unsigned int )formula_elements[submarker].formula_type == 27U) {
#line 530
          if (! ((unsigned int )formula_elements[submarker2].formula_type != 28U)) {
#line 530
            goto while_break___0;
          }
        } else {
#line 530
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 555
      if ((unsigned int )formula_elements[submarker].formula_type == 27U) {
#line 555
        if ((unsigned int )formula_elements[submarker2].formula_type == 28U) {
#line 559
          submarker = submarker2;
#line 560
          len ++;
        }
      }
#line 562
      if ((unsigned int )formula_elements[submarker].formula_type != 28U) {
        {
#line 564
        psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Formula corrupted!");
#line 565
        psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Found unexpected marker %02x",
                      (int )submarker);
        }
#line 566
        goto ERROR8;
      }
      {
#line 568
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Going to read the repeated marker %02x", (int )marker);
#line 570
      submarker = psiconv_read_u8(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
      }
#line 571
      if (res) {
#line 572
        goto ERROR8;
      }
#line 573
      if ((int )submarker != (int )marker) {
        {
#line 574
        psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Formula corrupted!");
#line 575
        psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Expected marker %02x, found %02x",
                      (int )marker, (int )submarker);
        }
#line 577
        goto ERROR8;
      }
      {
#line 579
      len ++;
#line 580
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Going to read the number of arguments (%d expected)", (int )nr_of_subs);
#line 583
      temp = psiconv_read_u16(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
      }
#line 584
      if (res) {
#line 585
        goto ERROR8;
      }
#line 586
      if ((int )temp != (int )nr_of_subs) {
        {
#line 587
        psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Formula corrupted!");
#line 588
        psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Read %d arguments, but formula says there are %d",
                      (int )nr_of_subs, (int )temp);
        }
#line 591
        goto ERROR8;
      }
      {
#line 593
      len += 2;
#line 594
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 594
      if (res) {
#line 595
        goto ERROR8;
      }
#line 596
      formula->type = (psiconv_formula_type_t )0;
    } else {
#line 598
      if (formula_elements[marker].number_of_args > 0) {
        {
#line 599
        res = psiconv_list_pop(formula_stack, (void *)subformula1);
        }
#line 599
        if (res) {
#line 600
          goto ERROR8;
        }
      }
#line 601
      if (formula_elements[marker].number_of_args > 1) {
        {
#line 602
        res = psiconv_list_pop(formula_stack, (void *)subformula2);
        }
#line 602
        if (res) {
#line 603
          goto ERROR8;
        }
      }
#line 604
      if (formula_elements[marker].number_of_args > 2) {
        {
#line 605
        res = psiconv_list_pop(formula_stack, (void *)subformula3);
        }
#line 605
        if (res) {
#line 606
          goto ERROR8;
        }
      }
#line 607
      if (formula_elements[marker].number_of_args > 3) {
        {
#line 608
        res = psiconv_list_pop(formula_stack, (void *)subformula4);
        }
#line 608
        if (res) {
#line 609
          goto ERROR8;
        }
      }
      {
#line 610
      tmp___7 = psiconv_list_new(sizeof(*formula));
#line 610
      formula->data.fun_operands = tmp___7;
      }
#line 610
      if (! tmp___7) {
#line 612
        goto ERROR8;
      }
#line 613
      formula->type = formula_elements[marker].formula_type;
#line 614
      if (formula_elements[marker].number_of_args > 3) {
        {
#line 615
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula4);
        }
#line 615
        if (res) {
#line 616
          goto ERROR8;
        }
      }
#line 617
      if (formula_elements[marker].number_of_args > 2) {
        {
#line 618
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula3);
        }
#line 618
        if (res) {
#line 619
          goto ERROR8;
        }
      }
#line 620
      if (formula_elements[marker].number_of_args > 1) {
        {
#line 621
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula2);
        }
#line 621
        if (res) {
#line 622
          goto ERROR8;
        }
      }
#line 623
      if (formula_elements[marker].number_of_args > 0) {
        {
#line 624
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula1);
        }
#line 624
        if (res) {
#line 625
          goto ERROR8;
        }
      }
      {
#line 626
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 626
      if (res) {
#line 627
        goto ERROR8;
      }
#line 628
      tmp___11 = (psiconv_formula_type_t )0;
#line 628
      formula->type = tmp___11;
#line 628
      tmp___10 = tmp___11;
#line 628
      subformula1->type = tmp___10;
#line 628
      tmp___9 = tmp___10;
#line 628
      subformula2->type = tmp___9;
#line 628
      tmp___8 = tmp___9;
#line 628
      subformula3->type = tmp___8;
#line 628
      subformula4->type = tmp___8;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  if ((psiconv_u32 )len + off > maxlen) {
    {
#line 633
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Formula corrupted!");
#line 634
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Expected end: %04x, found end: %04x",
                  maxlen, (psiconv_u32 )len + off);
    }
#line 636
    goto ERROR8;
  } else
#line 632
  if (! eof) {
    {
#line 633
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Formula corrupted!");
#line 634
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Expected end: %04x, found end: %04x",
                  maxlen, (psiconv_u32 )len + off);
    }
#line 636
    goto ERROR8;
  }
  {
#line 638
  tmp___13 = psiconv_list_length((psiconv_list const   )formula_stack);
  }
#line 638
  if (tmp___13 != 1U) {
    {
#line 639
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Formula corrupted!");
#line 640
    tmp___12 = psiconv_list_length((psiconv_list const   )formula_stack);
#line 640
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "More than one item left on the stack (%d)",
                  tmp___12);
    }
#line 642
    goto ERROR8;
  }
  {
#line 644
  res = psiconv_list_pop(formula_stack, (void *)*result);
  }
#line 644
  if (res) {
#line 645
    goto ERROR8;
  }
  {
#line 646
  psiconv_list_free(formula_stack);
#line 647
  free((void *)formula);
  }
#line 649
  if (length) {
#line 650
    *length = len;
  }
  {
#line 652
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of formula element list (total length: %08x)",
                   len);
  }
#line 654
  return (0);
  ERROR8: 
  {
#line 657
  psiconv_free_formula(subformula4);
  }
  ERROR7: 
  {
#line 659
  psiconv_free_formula(subformula3);
  }
  ERROR6: 
  {
#line 661
  psiconv_free_formula(subformula2);
  }
  ERROR5: 
  {
#line 663
  psiconv_free_formula(subformula1);
  }
  ERROR4: 
  {
#line 665
  psiconv_free_formula(formula);
  }
  ERROR3: 
  {
#line 667
  psiconv_free_formula_list(formula_stack);
  }
  ERROR2: 
  {
#line 669
  free((void *)*result);
  }
  ERROR1: 
  {
#line 671
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of formula element list failed");
  }
#line 672
  if (length) {
#line 673
    *length = 0;
  }
#line 674
  if (! res) {
#line 675
    return (-2);
  } else {
#line 677
    return (res);
  }
}
}
#line 683 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
int psiconv_parse_formula(psiconv_config const   config , psiconv_buffer const   buf ,
                          int lev , psiconv_u32 off , int *length , psiconv_formula *result ) 
{ 
  int res ;
  int len ;
  int leng ;
  psiconv_u32 bytelen ;
  psiconv_u32 formula_end ;
  psiconv_u8 temp ;

  {
  {
#line 688
  res = 0;
#line 689
  len = 0;
#line 694
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a formula");
#line 696
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the formula byte length");
#line 698
  bytelen = psiconv_read_S(config, buf, lev + 2, off + (psiconv_u32 )len, & leng,
                           & res);
  }
#line 699
  if (res) {
#line 700
    goto ERROR1;
  }
  {
#line 701
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Formula byte length: %d",
                bytelen);
#line 702
  len += leng;
#line 703
  bytelen += (psiconv_u32 )len;
#line 704
  formula_end = off + bytelen;
#line 706
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the formula elements list");
#line 707
  res = psiconv_parse_formula_element_list(config, buf, lev + 2, off + (psiconv_u32 )len,
                                           & leng, result, formula_end);
  }
#line 707
  if (res) {
#line 709
    goto ERROR1;
  }
  {
#line 710
  len += leng;
#line 712
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the eof marker");
#line 713
  temp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 714
  if (res) {
#line 715
    goto ERROR2;
  }
#line 716
  if ((unsigned int )formula_elements[temp].formula_type != 19U) {
    {
#line 717
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Formula corrupted!");
#line 718
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Expected marker: %02x, found byte: %02x",
                  21, (int )temp);
    }
#line 720
    goto ERROR2;
  }
#line 722
  len ++;
#line 724
  if (off + (psiconv_u32 )len != formula_end) {
    {
#line 725
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Formula corrupted!");
#line 726
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Expected end: %04x, found end: %04x",
                  formula_end, (psiconv_u32 )len + off);
    }
#line 728
    goto ERROR2;
  }
#line 731
  if (length) {
#line 732
    *length = len;
  }
  {
#line 734
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of formula (total length: %08x)",
                   len);
  }
#line 736
  return (0);
  ERROR2: 
  {
#line 739
  psiconv_free_formula(*result);
  }
  ERROR1: 
  {
#line 741
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of formula failed");
  }
#line 742
  if (length) {
#line 743
    *length = 0;
  }
#line 744
  if (! res) {
#line 745
    return (-2);
  } else {
#line 747
    return (res);
  }
}
}
#line 1130 "../psiconv/data.h"
void psiconv_free_object_display_section(psiconv_object_display_section section ) ;
#line 1132
void psiconv_free_object_icon_section(psiconv_object_icon_section section ) ;
#line 1134
void psiconv_free_embedded_object_section(psiconv_embedded_object_section object ) ;
#line 100 "../psiconv/buffer.h"
int psiconv_buffer_subbuffer(psiconv_buffer *buf , psiconv_buffer const   org , psiconv_u32 offset ,
                             psiconv_u32 length ) ;
#line 42 "../psiconv/unicode.h"
psiconv_ucs2 psiconv_unicode_read_char(psiconv_config const   config , psiconv_buffer buf ,
                                       int lev , psiconv_u32 off , int *length , int *status ) ;
#line 67
psiconv_ucs2 *psiconv_unicode_from_list(psiconv_list input ) ;
#line 55 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_routines.h"
psiconv_u32 psiconv_read_X(psiconv_config const   config , psiconv_buffer const   buf ,
                           int lev , psiconv_u32 off , int *length , int *status ) ;
#line 58
psiconv_length_t psiconv_read_length(psiconv_config const   config , psiconv_buffer const   buf ,
                                     int lev , psiconv_u32 off , int *length , int *status ) ;
#line 66
psiconv_string_t psiconv_read_string(psiconv_config const   config , psiconv_buffer const   buf ,
                                     int lev , psiconv_u32 off , int *length , int *status ) ;
#line 125
int psiconv_parse_paragraph_layout_list(psiconv_config const   config , psiconv_buffer const   buf ,
                                        int lev , psiconv_u32 off , int *length ,
                                        psiconv_paragraph_layout result ) ;
#line 130
int psiconv_parse_character_layout_list(psiconv_config const   config , psiconv_buffer const   buf ,
                                        int lev , psiconv_u32 off , int *length ,
                                        psiconv_character_layout result ) ;
#line 182
int psiconv_parse_styleless_layout_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                           int lev , psiconv_u32 off , int *length ,
                                           psiconv_text_and_layout result , psiconv_character_layout const   base_char ,
                                           psiconv_paragraph_layout const   base_para ) ;
#line 190
int psiconv_parse_embedded_object_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                          int lev , psiconv_u32 off , int *length ,
                                          psiconv_embedded_object_section *result ) ;
#line 196
int psiconv_parse_object_display_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                         int lev , psiconv_u32 off , int *length ,
                                         psiconv_object_display_section *result ) ;
#line 202
int psiconv_parse_object_icon_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                      int lev , psiconv_u32 off , int *length , psiconv_object_icon_section *result ) ;
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
static int psiconv_parse_layout_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                        int lev , psiconv_u32 off , int *length ,
                                        psiconv_text_and_layout result , psiconv_word_styles_section styles___1 ,
                                        int with_styles ) ;
#line 40
static psiconv_file_type_t psiconv_determine_embedded_object_type(psiconv_config const   config ,
                                                                  psiconv_buffer const   buf ,
                                                                  int lev , int *status ) ;
#line 45 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
int psiconv_parse_header_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                 int lev , psiconv_u32 off , int *length , psiconv_header_section *result ) 
{ 
  int res ;
  int len ;
  psiconv_u32 temp ;
  psiconv_header_section tmp ;
  void *tmp___0 ;
  psiconv_u32 tmp___1 ;
  psiconv_u32 tmp___2 ;

  {
  {
#line 50
  res = 0;
#line 51
  len = 0;
#line 54
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read the header section");
#line 55
  tmp___0 = malloc(sizeof(*(*result)));
#line 55
  tmp = (psiconv_header_section )tmp___0;
#line 55
  *result = tmp;
  }
#line 55
  if (! tmp) {
#line 56
    goto ERROR1;
  }
  {
#line 58
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read UID1 to UID3");
#line 59
  (*result)->uid1 = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                     & res);
  }
#line 60
  if (res) {
#line 61
    goto ERROR2;
  }
  {
#line 62
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "UID1: %08x",
                (*result)->uid1);
  }
#line 63
  if ((*result)->uid1 == 268435521U) {
    {
#line 65
    (*result)->file = (psiconv_file_type_t )5;
#line 66
    (*result)->uid2 = (psiconv_u32 )0;
#line 67
    (*result)->uid3 = (psiconv_u32 )0;
#line 68
    (*result)->checksum = (psiconv_u32 )0;
#line 69
    len += 4;
#line 70
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "File is a Clipart file");
    }
#line 71
    goto DONE;
  }
#line 73
  if ((*result)->uid1 != 268435511U) {
    {
#line 74
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "UID1 has unknown value. This is probably not a (parsable) Psion 5 file");
#line 77
    res = -3;
    }
#line 78
    goto ERROR2;
  }
  {
#line 80
  len += 4;
#line 81
  (*result)->uid2 = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                     & res);
  }
#line 82
  if (res) {
#line 83
    goto ERROR2;
  }
  {
#line 84
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "UID2: %08x",
                (*result)->uid2);
#line 85
  len += 4;
#line 86
  (*result)->uid3 = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                     & res);
  }
#line 87
  if (res) {
#line 88
    goto ERROR2;
  }
  {
#line 89
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "UID3: %08x",
                (*result)->uid3);
#line 90
  len += 4;
#line 92
  (*result)->file = (psiconv_file_type_t )0;
  }
#line 93
  if ((*result)->uid1 == 268435511U) {
#line 94
    if ((*result)->uid2 == 268435565U) {
#line 95
      if ((*result)->uid3 == 268435583U) {
        {
#line 96
        (*result)->file = (psiconv_file_type_t )1;
#line 97
        psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "File is a Word file");
        }
      } else
#line 98
      if ((*result)->uid3 == 268435589U) {
        {
#line 99
        (*result)->file = (psiconv_file_type_t )2;
#line 100
        psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "File is a TextEd file");
        }
      } else
#line 101
      if ((*result)->uid3 == 268435581U) {
        {
#line 102
        (*result)->file = (psiconv_file_type_t )4;
#line 103
        psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "File is a Sketch file");
        }
      } else
#line 104
      if ((*result)->uid3 == 268435592U) {
        {
#line 105
        (*result)->file = (psiconv_file_type_t )6;
#line 106
        psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "File is a Sheet file");
        }
      }
    } else
#line 108
    if ((*result)->uid2 == 268435522U) {
#line 109
      (*result)->file = (psiconv_file_type_t )3;
#line 110
      if ((*result)->uid3 != 0U) {
        {
#line 111
        psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "UID3 set in MBM file?!?");
        }
      }
      {
#line 112
      psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "File is a MBM file");
      }
    }
  }
#line 115
  if ((unsigned int )(*result)->file == 0U) {
    {
#line 116
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unknown file type");
#line 117
    (*result)->file = (psiconv_file_type_t )0;
    }
  }
  {
#line 120
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Checking UID4");
#line 121
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 122
  if (res) {
#line 123
    goto ERROR2;
  }
  {
#line 124
  tmp___2 = psiconv_checkuid((*result)->uid1, (*result)->uid2, (*result)->uid3);
  }
#line 124
  if (temp == tmp___2) {
    {
#line 126
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Checksum %08x is correct",
                  temp);
    }
  } else {
    {
#line 128
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Checksum failed, file corrupted!");
#line 129
    tmp___1 = psiconv_checkuid((*result)->uid1, (*result)->uid2, (*result)->uid3);
#line 129
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Expected checksum %08x, found %08x",
                  tmp___1, temp);
#line 132
    res = -3;
    }
#line 133
    goto ERROR2;
  }
#line 135
  len += 4;
  DONE: 
#line 138
  if (length) {
#line 139
    *length = len;
  }
  {
#line 141
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of Header Section (total length: %08x)", len);
  }
#line 144
  return (res);
  ERROR2: 
  {
#line 147
  free((void *)*result);
  }
  ERROR1: 
  {
#line 149
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Header Section failed");
  }
#line 150
  if (length) {
#line 151
    *length = 0;
  }
#line 152
  if (res == 0) {
#line 153
    return (-2);
  } else {
#line 155
    return (res);
  }
}
}
#line 158 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
int psiconv_parse_section_table_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                        int lev , psiconv_u32 off , int *length ,
                                        psiconv_section_table_section *result ) 
{ 
  int res ;
  int len ;
  psiconv_section_table_entry entry ;
  int i ;
  psiconv_u8 nr ;
  psiconv_section_table_section tmp ;
  void *tmp___0 ;

  {
  {
#line 163
  res = 0;
#line 164
  len = 0;
#line 170
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read the section table section");
#line 171
  tmp = psiconv_list_new(sizeof(*entry));
#line 171
  *result = tmp;
  }
#line 171
  if (! tmp) {
#line 172
    goto ERROR1;
  }
  {
#line 174
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the section table length");
#line 175
  nr = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 176
  if (res) {
#line 177
    goto ERROR2;
  }
  {
#line 178
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Length: %08x",
                (int )nr);
  }
#line 179
  if ((int )nr & 1) {
    {
#line 180
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Section table length odd - ignoring last entry");
    }
  }
  {
#line 183
  len ++;
#line 185
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the section table entries");
#line 186
  tmp___0 = malloc(sizeof(*entry));
#line 186
  entry = (psiconv_section_table_entry )tmp___0;
#line 187
  i = 0;
  }
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! (i < (int )nr / 2)) {
#line 187
      goto while_break;
    }
    {
#line 188
    entry->id = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
    }
#line 189
    if (res) {
#line 190
      goto ERROR3;
    }
    {
#line 191
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Entry %d: ID = %08x",
                  i, entry->id);
#line 192
    len += 4;
#line 193
    entry->offset = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                     & res);
    }
#line 194
    if (res) {
#line 195
      goto ERROR3;
    }
    {
#line 196
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Entry %d: Offset = %08x",
                  i, entry->offset);
#line 197
    len += 4;
#line 198
    res = psiconv_list_add(*result, (void const   *)entry);
    }
#line 198
    if (res) {
#line 199
      goto ERROR3;
    }
#line 187
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 202
  free((void *)entry);
  }
#line 204
  if (length) {
#line 205
    *length = len;
  }
  {
#line 207
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of section table section (total length: %08x)", len);
  }
#line 210
  return (0);
  ERROR3: 
  {
#line 212
  free((void *)entry);
  }
  ERROR2: 
  {
#line 214
  psiconv_list_free(*result);
  }
  ERROR1: 
  {
#line 216
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Section Table Section failed");
  }
#line 217
  if (length) {
#line 218
    *length = 0;
  }
#line 219
  if (res == 0) {
#line 220
    return (-2);
  } else {
#line 222
    return (res);
  }
}
}
#line 225 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
int psiconv_parse_application_id_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                         int lev , psiconv_u32 off , int *length ,
                                         psiconv_application_id_section *result ) 
{ 
  int res ;
  int len ;
  int leng ;
  psiconv_application_id_section tmp ;
  void *tmp___0 ;

  {
  {
#line 230
  res = 0;
#line 231
  len = 0;
#line 234
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read the application id section");
#line 235
  tmp___0 = malloc(sizeof(*(*result)));
#line 235
  tmp = (psiconv_application_id_section )tmp___0;
#line 235
  *result = tmp;
  }
#line 235
  if (! tmp) {
#line 236
    goto ERROR1;
  }
  {
#line 238
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the type identifier");
#line 239
  (*result)->id = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                   & res);
  }
#line 240
  if (res) {
#line 241
    goto ERROR2;
  }
  {
#line 242
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Identifier: %08x",
                (*result)->id);
#line 243
  len += 4;
#line 245
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the application id string");
#line 246
  (*result)->name = psiconv_read_string(config, buf, lev + 2, off + (psiconv_u32 )len,
                                        & leng, & res);
  }
#line 247
  if (res) {
#line 248
    goto ERROR2;
  }
#line 249
  len += leng;
#line 251
  if (length) {
#line 252
    *length = len;
  }
  {
#line 254
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of application id section (total length: %08x", len);
  }
#line 257
  return (res);
  ERROR2: 
  {
#line 259
  free((void *)*result);
  }
  ERROR1: 
  {
#line 261
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Application ID Section failed");
  }
#line 262
  if (length) {
#line 263
    *length = 0;
  }
#line 264
  if (res == 0) {
#line 265
    return (-2);
  } else {
#line 267
    return (res);
  }
}
}
#line 270 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
int psiconv_parse_text_section(psiconv_config const   config , psiconv_buffer const   buf ,
                               int lev , psiconv_u32 off , int *length , psiconv_text_and_layout *result ) 
{ 
  int res ;
  int len ;
  psiconv_u32 text_len ;
  psiconv_paragraph para ;
  psiconv_ucs2 temp ;
  psiconv_list line ;
  int nr ;
  int i ;
  int leng ;
  char *str_copy ;
  psiconv_text_and_layout tmp ;
  void *tmp___0 ;
  psiconv_string_t tmp___1 ;
  size_t tmp___2 ;
  psiconv_in_line_layouts tmp___3 ;
  psiconv_replacements tmp___4 ;
  psiconv_character_layout tmp___5 ;
  psiconv_paragraph_layout tmp___6 ;

  {
  {
#line 275
  res = 0;
#line 276
  len = 0;
#line 287
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to parse the text section");
#line 289
  tmp = psiconv_list_new(sizeof(*para));
#line 289
  *result = tmp;
  }
#line 289
  if (! tmp) {
#line 290
    goto ERROR1;
  }
  {
#line 291
  tmp___0 = malloc(sizeof(*para));
#line 291
  para = (psiconv_paragraph )tmp___0;
  }
#line 291
  if (! para) {
#line 292
    goto ERROR2;
  }
  {
#line 294
  psiconv_progress((psiconv_config )config, lev + 2, off, "Reading the text length");
#line 295
  text_len = psiconv_read_X(config, buf, lev + 2, off, & leng, & res);
  }
#line 296
  if (res) {
#line 297
    goto ERROR3;
  }
  {
#line 298
  psiconv_debug((psiconv_config )config, lev + 2, off, "Length: %08x", text_len);
#line 299
  len += leng;
#line 301
  line = psiconv_list_new(sizeof(psiconv_ucs2 ));
  }
#line 301
  if (! line) {
#line 302
    goto ERROR3;
  }
#line 304
  i = 0;
#line 305
  nr = 0;
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if (! ((psiconv_u32 )i < text_len)) {
#line 306
      goto while_break;
    }
    {
#line 307
    temp = psiconv_unicode_read_char(config, (psiconv_buffer )buf, lev + 2, (off + (psiconv_u32 )len) + (psiconv_u32 )i,
                                     & leng, & res);
    }
#line 308
    if (res) {
#line 309
      goto ERROR4;
    }
#line 310
    if ((psiconv_u32 )(i + leng) > text_len) {
      {
#line 311
      psiconv_error((psiconv_config )config, lev + 2, (off + (psiconv_u32 )len) + (psiconv_u32 )i,
                    "Malformed text section");
#line 312
      res = 3;
      }
#line 313
      goto ERROR4;
    }
#line 315
    if ((int )temp == 6) {
#line 315
      goto _L;
    } else
#line 315
    if ((psiconv_u32 )(i + leng) == text_len) {
      _L: /* CIL Label */ 
      {
#line 316
      tmp___1 = psiconv_unicode_from_list(line);
#line 316
      para->text = tmp___1;
      }
#line 316
      if (! tmp___1) {
#line 317
        goto ERROR4;
      }
      {
#line 319
      str_copy = psiconv_make_printable(config, (psiconv_string_t const   )para->text);
      }
#line 319
      if (! str_copy) {
#line 320
        goto ERROR5;
      }
      {
#line 321
      tmp___2 = strlen((char const   *)str_copy);
#line 321
      psiconv_debug((psiconv_config )config, lev + 2, (off + (psiconv_u32 )i) + (psiconv_u32 )len,
                    "Line %d: %d characters", nr, tmp___2 + 1UL);
#line 323
      psiconv_debug((psiconv_config )config, lev + 2, (off + (psiconv_u32 )i) + (psiconv_u32 )len,
                    "Line %d: `%s\'", nr, str_copy);
#line 324
      free((void *)str_copy);
#line 325
      i += leng;
#line 327
      tmp___3 = psiconv_list_new(sizeof(struct psiconv_in_line_layout_s ));
#line 327
      para->in_lines = tmp___3;
      }
#line 327
      if (! tmp___3) {
#line 329
        goto ERROR5;
      }
      {
#line 330
      tmp___4 = psiconv_list_new(sizeof(struct psiconv_replacement_s ));
#line 330
      para->replacements = tmp___4;
      }
#line 330
      if (! tmp___4) {
#line 332
        goto ERROR6;
      }
      {
#line 333
      tmp___5 = psiconv_basic_character_layout();
#line 333
      para->base_character = tmp___5;
      }
#line 333
      if (! tmp___5) {
#line 334
        goto ERROR7;
      }
      {
#line 335
      tmp___6 = psiconv_basic_paragraph_layout();
#line 335
      para->base_paragraph = tmp___6;
      }
#line 335
      if (! tmp___6) {
#line 336
        goto ERROR8;
      }
      {
#line 337
      para->base_style = (psiconv_s16 )0;
#line 339
      res = psiconv_list_add(*result, (void const   *)para);
      }
#line 339
      if (res) {
#line 340
        goto ERROR9;
      }
      {
#line 341
      psiconv_progress((psiconv_config )config, lev + 2, (off + (psiconv_u32 )len) + (psiconv_u32 )i,
                       "Starting a new line");
#line 342
      psiconv_list_empty(line);
#line 343
      nr ++;
      }
    } else {
      {
#line 345
      res = psiconv_list_add(line, (void const   *)(& temp));
      }
#line 345
      if (res) {
#line 346
        goto ERROR4;
      }
#line 347
      i += leng;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 351
  psiconv_list_free(line);
#line 352
  free((void *)para);
#line 354
  len = (int )((psiconv_u32 )len + text_len);
  }
#line 356
  if (length) {
#line 357
    *length = len;
  }
  {
#line 359
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of text section (total length: %08x", len);
  }
#line 362
  return (res);
  ERROR9: 
  {
#line 365
  psiconv_free_paragraph_layout(para->base_paragraph);
  }
  ERROR8: 
  {
#line 367
  psiconv_free_character_layout(para->base_character);
  }
  ERROR7: 
  {
#line 369
  psiconv_list_free(para->replacements);
  }
  ERROR6: 
  {
#line 371
  psiconv_list_free(para->in_lines);
  }
  ERROR5: 
  {
#line 373
  free((void *)para->text);
  }
  ERROR4: 
  {
#line 375
  psiconv_list_free(line);
  }
  ERROR3: 
  {
#line 377
  free((void *)para);
  }
  ERROR2: 
  {
#line 379
  psiconv_free_text_and_layout(*result);
  }
  ERROR1: 
  {
#line 381
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Text Section failed");
  }
#line 382
  if (length) {
#line 383
    *length = 0;
  }
#line 384
  if (! res) {
#line 385
    return (-2);
  } else {
#line 387
    return (res);
  }
}
}
#line 391 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
static int psiconv_parse_layout_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                        int lev , psiconv_u32 off , int *length ,
                                        psiconv_text_and_layout result , psiconv_word_styles_section styles___1 ,
                                        int with_styles ) 
{ 
  int res ;
  int len ;
  psiconv_u32 temp ;
  int parse_styles ;
  int nr ;
  int i ;
  int j ;
  int total ;
  int leng ;
  int line_length ;
  anon_style_list anon_styles ;
  struct anon_style_s anon ;
  anon_style anon_ptr ;
  psiconv_character_layout temp_char ;
  psiconv_paragraph_layout temp_para ;
  psiconv_word_style temp_style ;
  psiconv_paragraph para ;
  struct psiconv_in_line_layout_s in_line ;
  int *inline_count ;
  psiconv_u16 tmp ;
  psiconv_u8 tmp___0 ;
  psiconv_u32 tmp___1 ;
  psiconv_u8 tmp___2 ;
  psiconv_u32 tmp___3 ;
  psiconv_u32 tmp___4 ;
  psiconv_u32 tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  psiconv_in_line_layouts tmp___8 ;
  psiconv_character_layout tmp___9 ;
  psiconv_paragraph_layout tmp___10 ;
  psiconv_u32 tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  psiconv_u8 tmp___15 ;
  void *tmp___16 ;
  psiconv_u32 tmp___17 ;
  psiconv_u32 tmp___18 ;
  psiconv_u8 tmp___19 ;
  psiconv_u32 tmp___20 ;
  psiconv_u32 tmp___21 ;
  void *tmp___22 ;
  psiconv_u8 tmp___23 ;
  psiconv_u32 tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  psiconv_u32 tmp___27 ;
  void *tmp___28 ;
  psiconv_u32 tmp___29 ;
  void *tmp___30 ;
  psiconv_u32 tmp___31 ;

  {
  {
#line 399
  res = 0;
#line 400
  len = 0;
#line 416
  anon_ptr = (anon_style )((void *)0);
#line 427
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read the layout section");
#line 429
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the section type");
#line 430
  tmp = psiconv_read_u16(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 430
  temp = (psiconv_u32 )tmp;
  }
#line 431
  if (res) {
#line 432
    goto ERROR1;
  }
  {
#line 433
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Type: %02x",
                temp);
#line 434
  parse_styles = with_styles;
  }
#line 435
  if (temp == 1U) {
#line 435
    if (! with_styles) {
      {
#line 436
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Styleless layout section expected, but styled section found!");
#line 438
      parse_styles = 1;
      }
    } else {
#line 435
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 439
  if (temp == 0U) {
#line 439
    if (with_styles) {
      {
#line 440
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Styled layout section expected, but styleless section found!");
#line 442
      parse_styles = 0;
      }
    } else {
#line 439
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 443
  if (temp != 0U) {
#line 443
    if (temp != 1U) {
      {
#line 444
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Layout section type indicator has unknown value!");
      }
    }
  }
  {
#line 447
  len += 2;
#line 449
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read paragraph type list");
#line 450
  anon_styles = psiconv_list_new(sizeof(anon));
  }
#line 450
  if (! anon_styles) {
#line 451
    goto ERROR1;
  }
  {
#line 452
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read paragraph type list length");
#line 453
  tmp___0 = psiconv_read_u8(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
#line 453
  nr = (int )tmp___0;
  }
#line 454
  if (res) {
#line 455
    goto ERROR2;
  }
  {
#line 456
  psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Length: %02x",
                nr);
#line 457
  len ++;
#line 459
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the paragraph type list elements");
#line 461
  i = 0;
  }
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    if (! (i < nr)) {
#line 461
      goto while_break;
    }
    {
#line 462
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Element %d",
                     i);
#line 463
    tmp___1 = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
#line 463
    anon.nr = (int )tmp___1;
    }
#line 464
    if (res) {
#line 465
      goto ERROR3;
    }
    {
#line 466
    psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Number: %08x",
                  anon.nr);
#line 467
    len += 4;
#line 469
    psiconv_progress((psiconv_config )config, lev + 4, off, "Going to determine the base style");
    }
#line 470
    if (parse_styles) {
      {
#line 471
      temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
      }
#line 472
      if (res) {
#line 473
        goto ERROR3;
      }
      {
#line 474
      tmp___2 = psiconv_read_u8(config, buf, lev + 3, ((off + (psiconv_u32 )len) + 4U) + temp,
                                & res);
#line 474
      anon.base_style = (psiconv_s16 )tmp___2;
      }
#line 475
      if (res) {
#line 476
        goto ERROR3;
      }
      {
#line 477
      psiconv_debug((psiconv_config )config, lev + 4, (off + (psiconv_u32 )len) + temp,
                    "Style indicator: %02x", (int )anon.base_style);
      }
    } else {
#line 480
      anon.base_style = (psiconv_s16 )0;
    }
    {
#line 481
    temp_style = psiconv_get_style(styles___1, (int )anon.base_style);
    }
#line 481
    if (! temp_style) {
      {
#line 482
      psiconv_warn((psiconv_config )config, lev + 4, off, "Unknown Style referenced");
#line 483
      temp_style = psiconv_get_style(styles___1, (int )anon.base_style);
      }
#line 483
      if (! temp_style) {
        {
#line 484
        psiconv_warn((psiconv_config )config, lev + 4, off, "Base style unknown");
        }
#line 485
        goto ERROR3;
      }
    }
    {
#line 488
    anon.paragraph = psiconv_clone_paragraph_layout(temp_style->paragraph);
    }
#line 488
    if (! anon.paragraph) {
#line 490
      goto ERROR3;
    }
    {
#line 491
    anon.character = psiconv_clone_character_layout(temp_style->character);
    }
#line 491
    if (! anon.character) {
#line 493
      goto ERROR3_1;
    }
    {
#line 495
    psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to read the paragraph layout");
#line 496
    res = psiconv_parse_paragraph_layout_list(config, buf, lev + 4, off + (psiconv_u32 )len,
                                              & leng, anon.paragraph);
    }
#line 496
    if (res) {
#line 498
      goto ERROR3_2;
    }
#line 499
    len += leng;
#line 500
    if (parse_styles) {
#line 501
      len ++;
    }
    {
#line 503
    psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to read the character layout");
#line 504
    res = psiconv_parse_character_layout_list(config, buf, lev + 4, off + (psiconv_u32 )len,
                                              & leng, anon.character);
    }
#line 504
    if (res) {
#line 506
      goto ERROR3_2;
    }
    {
#line 507
    len += leng;
#line 508
    res = psiconv_list_add(anon_styles, (void const   *)(& anon));
    }
#line 508
    if (res) {
#line 509
      goto ERROR3_2;
    }
#line 461
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 512
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to parse the paragraph element list");
#line 513
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the number of paragraphs");
#line 514
  tmp___3 = psiconv_read_u32(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
#line 514
  nr = (int )tmp___3;
  }
#line 515
  if (res) {
#line 516
    goto ERROR3;
  }
  {
#line 517
  tmp___5 = psiconv_list_length((psiconv_list const   )result);
  }
#line 517
  if ((psiconv_u32 )nr != tmp___5) {
    {
#line 518
    psiconv_warn((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Number of text paragraphs and paragraph elements does not match");
#line 520
    tmp___4 = psiconv_list_length((psiconv_list const   )result);
#line 520
    psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "%d text paragraphs, %d paragraph elements",
                  tmp___4, nr);
    }
  }
  {
#line 524
  psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Number of paragraphs: %d",
                nr);
#line 525
  len += 4;
#line 526
  tmp___6 = malloc((unsigned long )nr * sizeof(*inline_count));
#line 526
  inline_count = (int *)tmp___6;
  }
#line 526
  if (! inline_count) {
#line 527
    goto ERROR3;
  }
  {
#line 529
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the paragraph elements");
#line 530
  i = 0;
  }
  {
#line 530
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 530
    if (! (i < nr)) {
#line 530
      goto while_break___0;
    }
    {
#line 531
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Element %d",
                     i);
#line 532
    tmp___11 = psiconv_list_length((psiconv_list const   )result);
    }
#line 532
    if ((psiconv_u32 )i >= tmp___11) {
      {
#line 533
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to allocate a new element");
#line 534
      tmp___7 = malloc(sizeof(*para));
#line 534
      para = (psiconv_paragraph )tmp___7;
      }
#line 534
      if (! para) {
#line 535
        goto ERROR4;
      }
      {
#line 536
      tmp___8 = psiconv_list_new(sizeof(struct psiconv_in_line_layout_s ));
#line 536
      para->in_lines = tmp___8;
      }
#line 536
      if (! tmp___8) {
#line 538
        goto ERROR4_1;
      }
      {
#line 539
      para->base_style = (psiconv_s16 )0;
#line 540
      tmp___9 = psiconv_basic_character_layout();
#line 540
      para->base_character = tmp___9;
      }
#line 540
      if (! tmp___9) {
#line 541
        goto ERROR4_2;
      }
      {
#line 542
      tmp___10 = psiconv_basic_paragraph_layout();
#line 542
      para->base_paragraph = tmp___10;
      }
#line 542
      if (! tmp___10) {
#line 543
        goto ERROR4_3;
      }
      {
#line 544
      res = psiconv_list_add(result, (void const   *)para);
      }
#line 544
      if (res) {
#line 545
        goto ERROR4_4;
      }
      {
#line 546
      free((void *)para);
      }
    }
    {
#line 548
    tmp___12 = psiconv_list_get((psiconv_list const   )result, (psiconv_u32 )i);
#line 548
    para = (psiconv_paragraph )tmp___12;
    }
#line 548
    if (! para) {
#line 549
      goto ERROR4;
    }
    {
#line 551
    psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to read the paragraph length");
#line 552
    temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
    }
#line 553
    if (res) {
#line 554
      goto ERROR4;
    }
    {
#line 555
    tmp___14 = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
    }
#line 555
    if (temp != (psiconv_u32 )(tmp___14 + 1)) {
      {
#line 556
      psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Disagreement of the length of paragraph in layout section");
#line 558
      tmp___13 = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
#line 558
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Paragraph length: layout section says %d, counted %d",
                    temp, tmp___13 + 1);
      }
    } else {
      {
#line 562
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Paragraph length: %d",
                    temp);
      }
    }
    {
#line 563
    len += 4;
#line 565
    psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to read the paragraph type");
#line 566
    tmp___15 = psiconv_read_u8(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
#line 566
    temp = (psiconv_u32 )tmp___15;
    }
#line 567
    if (res) {
#line 568
      goto ERROR4;
    }
#line 569
    if (temp != 0U) {
      {
#line 570
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Type: %02x",
                    temp);
#line 571
      j = 0;
      }
      {
#line 571
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 571
        tmp___17 = psiconv_list_length((psiconv_list const   )anon_styles);
        }
#line 571
        if (! ((psiconv_u32 )j < tmp___17)) {
#line 571
          goto while_break___1;
        }
        {
#line 572
        tmp___16 = psiconv_list_get((psiconv_list const   )anon_styles, (psiconv_u32 )j);
#line 572
        anon_ptr = (anon_style )tmp___16;
        }
#line 572
        if (! anon_ptr) {
          {
#line 573
          psiconv_error((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Data structure corruption");
          }
#line 574
          goto ERROR4;
        }
#line 576
        if (temp == (psiconv_u32 )anon_ptr->nr) {
#line 577
          goto while_break___1;
        }
#line 571
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 579
      tmp___18 = psiconv_list_length((psiconv_list const   )anon_styles);
      }
#line 579
      if ((psiconv_u32 )j == tmp___18) {
        {
#line 580
        psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Layout section paragraph type unknown");
#line 581
        psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Unknown type - using base styles instead");
#line 582
        para->base_style = (psiconv_s16 )0;
#line 583
        temp_style = psiconv_get_style(styles___1, 0);
        }
#line 583
        if (! temp_style) {
          {
#line 584
          psiconv_error((psiconv_config )config, lev + 4, off, "Base style unknown");
          }
#line 585
          goto ERROR4;
        }
        {
#line 587
        temp_para = psiconv_clone_paragraph_layout(temp_style->paragraph);
        }
#line 587
        if (! temp_para) {
#line 589
          goto ERROR4;
        }
        {
#line 590
        psiconv_free_paragraph_layout(para->base_paragraph);
#line 591
        para->base_paragraph = temp_para;
#line 593
        temp_char = psiconv_clone_character_layout(temp_style->character);
        }
#line 593
        if (! temp_char) {
#line 595
          goto ERROR4;
        }
        {
#line 596
        psiconv_free_character_layout(para->base_character);
#line 597
        para->base_character = temp_char;
        }
      } else {
        {
#line 599
        para->base_style = anon_ptr->base_style;
#line 600
        temp_para = psiconv_clone_paragraph_layout(anon_ptr->paragraph);
        }
#line 600
        if (! temp_para) {
#line 601
          goto ERROR4;
        }
        {
#line 602
        psiconv_free_paragraph_layout(para->base_paragraph);
#line 603
        para->base_paragraph = temp_para;
#line 605
        temp_char = psiconv_clone_character_layout(anon_ptr->character);
        }
#line 605
        if (! temp_char) {
#line 606
          goto ERROR4;
        }
        {
#line 607
        psiconv_free_character_layout(para->base_character);
#line 608
        para->base_character = temp_char;
        }
      }
#line 610
      *(inline_count + i) = 0;
#line 611
      len ++;
    } else {
      {
#line 613
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Type: %02x (not based on a paragraph type)",
                    temp);
#line 615
      len ++;
      }
#line 616
      if (parse_styles) {
        {
#line 617
        temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
        }
#line 618
        if (res) {
#line 619
          goto ERROR4;
        }
        {
#line 620
        psiconv_progress((psiconv_config )config, lev + 4, ((off + (psiconv_u32 )len) + temp) + 4U,
                         "Going to read the paragraph element base style");
#line 622
        tmp___19 = psiconv_read_u8(config, buf, lev + 4, ((off + (psiconv_u32 )len) + temp) + 4U,
                                   & res);
#line 622
        temp = (psiconv_u32 )tmp___19;
        }
#line 623
        if (res) {
#line 624
          goto ERROR4;
        }
        {
#line 625
        psiconv_debug((psiconv_config )config, lev + 4, ((off + (psiconv_u32 )len) + temp) + 4U,
                      "Style: %02x", temp);
        }
      } else {
#line 627
        temp = (psiconv_u32 )0;
      }
      {
#line 629
      temp_style = psiconv_get_style(styles___1, (int )temp);
      }
#line 629
      if (! temp_style) {
        {
#line 630
        psiconv_warn((psiconv_config )config, lev + 4, off, "Unknown Style referenced");
#line 631
        temp_style = psiconv_get_style(styles___1, 0);
        }
#line 631
        if (! temp_style) {
          {
#line 632
          psiconv_error((psiconv_config )config, lev + 4, off, "Base style unknown");
          }
#line 633
          goto ERROR4;
        }
      }
      {
#line 637
      temp_para = psiconv_clone_paragraph_layout(temp_style->paragraph);
      }
#line 637
      if (! temp_para) {
#line 638
        goto ERROR4;
      }
      {
#line 639
      psiconv_free_paragraph_layout(para->base_paragraph);
#line 640
      para->base_paragraph = temp_para;
#line 642
      temp_char = psiconv_clone_character_layout(temp_style->character);
      }
#line 642
      if (! temp_char) {
#line 643
        goto ERROR4;
      }
      {
#line 644
      psiconv_free_character_layout(para->base_character);
#line 645
      para->base_character = temp_char;
#line 647
      para->base_style = (psiconv_s16 )temp;
#line 648
      psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                       "Going to read paragraph layout");
#line 649
      res = psiconv_parse_paragraph_layout_list(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                & leng, para->base_paragraph);
      }
#line 649
      if (res) {
#line 651
        goto ERROR4;
      }
#line 652
      len += leng;
#line 653
      if (parse_styles) {
#line 654
        len ++;
      }
      {
#line 655
      psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                       "Going to read number of in-line layout elements");
#line 657
      tmp___20 = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
#line 657
      *(inline_count + i) = (int )tmp___20;
      }
#line 658
      if (res) {
#line 659
        goto ERROR4;
      }
      {
#line 660
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Nr: %08x",
                    *(inline_count + i));
#line 661
      len += 4;
      }
    }
#line 530
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 665
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the text layout inline list");
#line 667
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the number of elements");
#line 668
  tmp___21 = psiconv_read_u32(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
#line 668
  nr = (int )tmp___21;
  }
#line 669
  if (res) {
#line 670
    goto ERROR4;
  }
  {
#line 671
  psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Elements: %08x",
                nr);
#line 672
  len += 4;
#line 674
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the text layout inline elements");
#line 676
  total = 0;
#line 677
  i = 0;
  }
  {
#line 677
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 677
    tmp___27 = psiconv_list_length((psiconv_list const   )result);
    }
#line 677
    if (! ((psiconv_u32 )i < tmp___27)) {
#line 677
      goto while_break___2;
    }
    {
#line 678
    tmp___22 = psiconv_list_get((psiconv_list const   )result, (psiconv_u32 )i);
#line 678
    para = (psiconv_paragraph )tmp___22;
    }
#line 678
    if (! para) {
      {
#line 679
      psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Data structure corruption");
      }
#line 680
      goto ERROR4;
    }
#line 682
    line_length = -1;
#line 683
    j = 0;
    {
#line 683
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 683
      if (! (j < *(inline_count + i))) {
#line 683
        goto while_break___3;
      }
      {
#line 684
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Element %d: Paragraph %d, element %d", total, i, j);
      }
#line 686
      if (total >= nr) {
        {
#line 687
        psiconv_warn((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Layout section inlines: not enough element");
#line 689
        psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Can\'t read element!");
        }
      } else {
        {
#line 691
        total ++;
#line 692
        in_line.object = (psiconv_embedded_object_section )((void *)0);
#line 693
        in_line.layout = (psiconv_character_layout )((void *)0);
#line 694
        in_line.layout = psiconv_clone_character_layout(para->base_character);
        }
#line 694
        if (! in_line.layout) {
#line 696
          goto ERROR4;
        }
        {
#line 697
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read the element type");
#line 698
        tmp___23 = psiconv_read_u8(config, buf, lev + 4, (psiconv_u32 )len + off,
                                   & res);
#line 698
        temp = (psiconv_u32 )tmp___23;
        }
#line 699
        if (res) {
#line 700
          goto ERROR5;
        }
        {
#line 701
        len ++;
#line 702
        psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Type: %02x",
                      temp);
#line 703
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read the number of characters it applies to");
#line 705
        tmp___24 = psiconv_read_u32(config, buf, lev + 4, (psiconv_u32 )len + off,
                                    & res);
#line 705
        in_line.length = (int )tmp___24;
        }
#line 706
        if (res) {
#line 707
          goto ERROR5;
        }
        {
#line 708
        psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Length: %02x",
                      in_line.length);
#line 709
        len += 4;
#line 710
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read the character layout");
#line 711
        res = psiconv_parse_character_layout_list(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                  & leng, in_line.layout);
        }
#line 711
        if (res) {
#line 713
          goto ERROR5;
        }
#line 714
        len += leng;
#line 716
        if (temp == 1U) {
          {
#line 717
          psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Found an embedded object");
#line 718
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to read the object marker (0x%08x expected)", 268435537);
#line 720
          temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
          }
#line 721
          if (res) {
#line 722
            goto ERROR5;
          }
#line 723
          if (temp != 268435537U) {
            {
#line 724
            psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Unknown id marks embedded object");
#line 725
            psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                          "Marker: read %08x, expected %08x", temp, 268435537);
            }
          }
          {
#line 728
          len += 4;
#line 729
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to read the Embedded Object Section offset");
#line 731
          temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
          }
#line 732
          if (res) {
#line 733
            goto ERROR5;
          }
          {
#line 734
          psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Offset: %08x", temp);
#line 735
          len += 4;
#line 736
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to parse the Embedded Object Section");
#line 738
          res = psiconv_parse_embedded_object_section(config, buf, lev + 4, temp,
                                                      (int *)((void *)0), & in_line.object);
          }
#line 738
          if (res) {
#line 740
            goto ERROR5;
          }
          {
#line 741
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to read the object width");
#line 743
          in_line.object_width = psiconv_read_length(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                     & leng, & res);
          }
#line 745
          if (res) {
#line 746
            goto ERROR5;
          }
          {
#line 747
          psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Object width: %f cm", (double )in_line.object_width);
#line 749
          len += leng;
#line 750
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to read the object height");
#line 752
          in_line.object_height = psiconv_read_length(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                      & leng, & res);
          }
#line 754
          if (res) {
#line 755
            goto ERROR5;
          }
          {
#line 756
          psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Object height: %f cm", (double )in_line.object_height);
#line 758
          len += leng;
          }
        } else
#line 759
        if (temp != 0U) {
          {
#line 760
          psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                       "Layout section unknown inline type");
          }
        }
        {
#line 762
        tmp___26 = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
        }
#line 762
        if (line_length + in_line.length > tmp___26) {
          {
#line 763
          psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                       "Layout section inlines: line length mismatch");
#line 765
          res = -1;
#line 766
          tmp___25 = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
#line 766
          in_line.length = tmp___25 - line_length;
          }
        }
        {
#line 768
        line_length += in_line.length;
#line 769
        res = psiconv_list_add(para->in_lines, (void const   *)(& in_line));
        }
#line 769
        if (res) {
#line 770
          goto ERROR5;
        }
      }
#line 683
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 677
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 775
  if (total != nr) {
    {
#line 776
    psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Layout section too many inlines, skipping remaining");
    }
  }
  {
#line 780
  free((void *)inline_count);
#line 782
  i = 0;
  }
  {
#line 782
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 782
    tmp___29 = psiconv_list_length((psiconv_list const   )anon_styles);
    }
#line 782
    if (! ((psiconv_u32 )i < tmp___29)) {
#line 782
      goto while_break___4;
    }
    {
#line 783
    tmp___28 = psiconv_list_get((psiconv_list const   )anon_styles, (psiconv_u32 )i);
#line 783
    anon_ptr = (anon_style )tmp___28;
    }
#line 783
    if (! anon_ptr) {
      {
#line 784
      psiconv_error((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Data structure corruption");
      }
#line 785
      goto ERROR2;
    }
    {
#line 787
    psiconv_free_character_layout(anon_ptr->character);
#line 788
    psiconv_free_paragraph_layout(anon_ptr->paragraph);
#line 782
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 790
  psiconv_list_free(anon_styles);
  }
#line 792
  if (length) {
#line 793
    *length = len;
  }
  {
#line 795
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of layout section (total length: %08x)", len);
  }
#line 798
  return (0);
  ERROR4_4: 
  {
#line 801
  psiconv_free_paragraph_layout(para->base_paragraph);
  }
  ERROR4_3: 
  {
#line 803
  psiconv_free_character_layout(para->base_character);
  }
  ERROR4_2: 
  {
#line 805
  psiconv_list_free(para->in_lines);
  }
  ERROR4_1: 
  {
#line 807
  free((void *)para);
  }
#line 808
  goto ERROR4;
  ERROR3_2: 
  {
#line 811
  psiconv_free_character_layout(anon.character);
  }
  ERROR3_1: 
  {
#line 813
  psiconv_free_paragraph_layout(anon.paragraph);
  }
#line 814
  goto ERROR3;
  ERROR5: 
#line 817
  if (in_line.layout) {
    {
#line 818
    psiconv_free_character_layout(in_line.layout);
    }
  }
#line 819
  if (in_line.object) {
    {
#line 820
    psiconv_free_embedded_object_section(in_line.object);
    }
  }
  ERROR4: 
  {
#line 822
  free((void *)inline_count);
  }
  ERROR3: 
#line 824
  i = 0;
  {
#line 824
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 824
    tmp___31 = psiconv_list_length((psiconv_list const   )anon_styles);
    }
#line 824
    if (! ((psiconv_u32 )i < tmp___31)) {
#line 824
      goto while_break___5;
    }
    {
#line 825
    tmp___30 = psiconv_list_get((psiconv_list const   )anon_styles, (psiconv_u32 )i);
#line 825
    anon_ptr = (anon_style )tmp___30;
    }
#line 825
    if (! anon_ptr) {
      {
#line 826
      psiconv_error((psiconv_config )config, lev + 1, off, "Data structure corruption");
      }
#line 827
      goto while_break___5;
    }
    {
#line 829
    psiconv_free_paragraph_layout(anon_ptr->paragraph);
#line 830
    psiconv_free_character_layout(anon_ptr->character);
#line 824
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  ERROR2: 
  {
#line 834
  psiconv_list_free(anon_styles);
  }
  ERROR1: 
  {
#line 836
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Layout Section failed");
  }
#line 837
  if (length) {
#line 838
    *length = 0;
  }
#line 839
  if (! res) {
#line 840
    return (-2);
  } else {
#line 842
    return (res);
  }
}
}
#line 845 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
int psiconv_parse_styled_layout_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                        int lev , psiconv_u32 off , int *length ,
                                        psiconv_text_and_layout result , psiconv_word_styles_section const   styles___1 ) 
{ 
  int tmp ;

  {
  {
#line 852
  tmp = psiconv_parse_layout_section(config, buf, lev, off, length, result, (psiconv_word_styles_section )styles___1,
                                     1);
  }
#line 852
  return (tmp);
}
}
#line 855 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
int psiconv_parse_styleless_layout_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                           int lev , psiconv_u32 off , int *length ,
                                           psiconv_text_and_layout result , psiconv_character_layout const   base_char ,
                                           psiconv_paragraph_layout const   base_para ) 
{ 
  int res ;
  psiconv_word_styles_section styles_section ;
  void *tmp ;
  psiconv_word_style tmp___0 ;
  void *tmp___1 ;
  psiconv_character_layout tmp___2 ;
  psiconv_paragraph_layout tmp___3 ;
  psiconv_string_t tmp___4 ;
  psiconv_word_style_list tmp___5 ;

  {
  {
#line 863
  res = 0;
#line 866
  tmp = malloc(sizeof(*styles_section));
#line 866
  styles_section = (psiconv_word_styles_section )tmp;
  }
#line 866
  if (! styles_section) {
#line 867
    goto ERROR1;
  }
  {
#line 868
  tmp___1 = malloc(sizeof(*(styles_section->normal)));
#line 868
  tmp___0 = (psiconv_word_style )tmp___1;
#line 868
  styles_section->normal = tmp___0;
  }
#line 868
  if (! tmp___0) {
#line 869
    goto ERROR2;
  }
  {
#line 870
  tmp___2 = psiconv_clone_character_layout((psiconv_character_layout )base_char);
#line 870
  (styles_section->normal)->character = tmp___2;
  }
#line 870
  if (! tmp___2) {
#line 872
    goto ERROR3;
  }
  {
#line 873
  tmp___3 = psiconv_clone_paragraph_layout((psiconv_paragraph_layout )base_para);
#line 873
  (styles_section->normal)->paragraph = tmp___3;
  }
#line 873
  if (! tmp___3) {
#line 875
    goto ERROR4;
  }
  {
#line 876
  (styles_section->normal)->hotkey = (psiconv_ucs2 )0;
#line 878
  tmp___4 = psiconv_unicode_empty_string();
#line 878
  (styles_section->normal)->name = tmp___4;
  }
#line 878
  if (! tmp___4) {
#line 879
    goto ERROR5;
  }
  {
#line 880
  tmp___5 = psiconv_list_new(sizeof(struct psiconv_word_style_s ));
#line 880
  styles_section->styles = tmp___5;
  }
#line 880
  if (! tmp___5) {
#line 882
    goto ERROR6;
  }
  {
#line 884
  res = psiconv_parse_layout_section(config, buf, lev, off, length, result, styles_section,
                                     0);
#line 887
  psiconv_free_word_styles_section(styles_section);
  }
#line 888
  return (res);
  ERROR6: 
  {
#line 891
  free((void *)(styles_section->normal)->name);
  }
  ERROR5: 
  {
#line 893
  psiconv_free_paragraph_layout((styles_section->normal)->paragraph);
  }
  ERROR4: 
  {
#line 895
  psiconv_free_character_layout((styles_section->normal)->character);
  }
  ERROR3: 
  {
#line 897
  free((void *)styles_section->normal);
  }
  ERROR2: 
  {
#line 899
  free((void *)styles_section);
  }
  ERROR1: 
  {
#line 901
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Styleless Layout Section failed");
  }
#line 902
  if (length) {
#line 903
    *length = 0;
  }
#line 904
  if (! res) {
#line 905
    return (-2);
  } else {
#line 907
    return (res);
  }
}
}
#line 910 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
int psiconv_parse_embedded_object_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                          int lev , psiconv_u32 off , int *length ,
                                          psiconv_embedded_object_section *result ) 
{ 
  int res ;
  int len ;
  int leng ;
  int i ;
  psiconv_section_table_section table ;
  psiconv_section_table_entry entry ;
  psiconv_u32 icon_sec ;
  psiconv_u32 display_sec ;
  psiconv_u32 table_sec ;
  psiconv_buffer subbuf ;
  psiconv_embedded_object_section tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  psiconv_u32 tmp___2 ;
  psiconv_u32 tmp___3 ;
  psiconv_file tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 915
  res = 0;
#line 916
  len = 0;
#line 920
  icon_sec = (psiconv_u32 )0;
#line 920
  display_sec = (psiconv_u32 )0;
#line 920
  table_sec = (psiconv_u32 )0;
#line 923
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read an Embedded Object");
#line 924
  tmp___0 = malloc(sizeof(*(*result)));
#line 924
  tmp = (psiconv_embedded_object_section )tmp___0;
#line 924
  *result = tmp;
  }
#line 924
  if (! tmp) {
#line 925
    goto ERROR1;
  }
  {
#line 927
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the Embedded Object Section");
#line 928
  psiconv_parse_section_table_section(config, buf, lev + 2, off + (psiconv_u32 )len,
                                      & leng, & table);
#line 929
  len += leng;
#line 931
  i = 0;
  }
  {
#line 931
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 931
    tmp___2 = psiconv_list_length((psiconv_list const   )table);
    }
#line 931
    if (! ((psiconv_u32 )i < tmp___2)) {
#line 931
      goto while_break;
    }
    {
#line 932
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read entry %d",
                     i);
#line 933
    tmp___1 = psiconv_list_get((psiconv_list const   )table, (psiconv_u32 )i);
#line 933
    entry = (psiconv_section_table_entry )tmp___1;
    }
#line 933
    if (! entry) {
#line 934
      goto ERROR2;
    }
#line 935
    if (entry->id == 268435782U) {
      {
#line 936
      display_sec = entry->offset;
#line 937
      psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Found the Object Display Section at %08x",
                    display_sec);
      }
    } else
#line 939
    if (entry->id == 268435754U) {
      {
#line 940
      icon_sec = entry->offset;
#line 941
      psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Found the Object Icon Section at %08x",
                    icon_sec);
      }
    } else
#line 943
    if (entry->id == 268435780U) {
      {
#line 944
      table_sec = entry->offset;
#line 945
      psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Found the Object Section Table Section at %08x",
                    table_sec);
      }
    } else {
      {
#line 948
      psiconv_warn((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Found unknown section in the Object Display Section (ignoring)");
#line 951
      psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Section ID %08x, offset %08x",
                    entry->id, entry->offset);
      }
    }
#line 931
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 956
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Looking for the Object Display Section");
  }
#line 957
  if (! icon_sec) {
    {
#line 958
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Object Display Section not found");
#line 959
    (*result)->display = (psiconv_object_display_section )((void *)0);
    }
  } else {
    {
#line 961
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Object Display Section at offset %08x",
                  display_sec);
#line 963
    res = psiconv_parse_object_display_section(config, buf, lev + 2, display_sec,
                                               (int *)((void *)0), & (*result)->display);
    }
#line 963
    if (res) {
#line 965
      goto ERROR2;
    }
  }
  {
#line 968
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Looking for the Object Icon Section");
  }
#line 969
  if (! icon_sec) {
    {
#line 970
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Object Icon Section not found");
#line 971
    (*result)->icon = (psiconv_object_icon_section )((void *)0);
    }
  } else {
    {
#line 973
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Object Icon Section at offset %08x",
                  icon_sec);
#line 974
    res = psiconv_parse_object_icon_section(config, buf, lev + 2, icon_sec, (int *)((void *)0),
                                            & (*result)->icon);
    }
#line 974
    if (res) {
#line 976
      goto ERROR3;
    }
  }
  {
#line 979
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Looking for the Section Table Offset Section");
  }
#line 981
  if (! table_sec) {
    {
#line 982
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Embedded Section Table Offset Section not found");
#line 984
    (*result)->object = (psiconv_file )((void *)0);
    }
  } else {
    {
#line 986
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Extracting object: add %08x to all following offsets",
                     table_sec);
#line 990
    tmp___3 = psiconv_buffer_length(buf);
#line 990
    res = psiconv_buffer_subbuffer(& subbuf, buf, table_sec, tmp___3 - table_sec);
    }
#line 990
    if (res) {
#line 992
      goto ERROR4;
    }
    {
#line 994
    tmp___5 = malloc(sizeof(*((*result)->object)));
#line 994
    tmp___4 = (psiconv_file )tmp___5;
#line 994
    (*result)->object = tmp___4;
    }
#line 994
    if (! tmp___4) {
#line 995
      goto ERROR5;
    }
    {
#line 999
    psiconv_progress((psiconv_config )config, lev + 3, (psiconv_u32 )0, "Trying to determine the file type");
#line 1000
    ((*result)->object)->type = psiconv_determine_embedded_object_type(config, (psiconv_buffer const   )subbuf,
                                                                       lev + 3, & res);
    }
    {
#line 1003
    if ((unsigned int )((*result)->object)->type == 1U) {
#line 1003
      goto case_1;
    }
#line 1008
    if ((unsigned int )((*result)->object)->type == 2U) {
#line 1008
      goto case_2;
    }
#line 1013
    if ((unsigned int )((*result)->object)->type == 6U) {
#line 1013
      goto case_6;
    }
#line 1018
    if ((unsigned int )((*result)->object)->type == 4U) {
#line 1018
      goto case_4;
    }
#line 1023
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 1004
    res = psiconv_parse_word_file(config, (psiconv_buffer const   )subbuf, lev + 3,
                                  (psiconv_u32 )0, (psiconv_word_f *)(& ((*result)->object)->file));
    }
#line 1004
    if (res) {
#line 1006
      goto ERROR6;
    }
#line 1007
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1009
    res = psiconv_parse_texted_file(config, (psiconv_buffer const   )subbuf, lev + 3,
                                    (psiconv_u32 )0, (psiconv_texted_f *)(& ((*result)->object)->file));
    }
#line 1009
    if (res) {
#line 1011
      goto ERROR6;
    }
#line 1012
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 1014
    res = psiconv_parse_sheet_file(config, (psiconv_buffer const   )subbuf, lev + 3,
                                   (psiconv_u32 )0, (psiconv_sheet_f *)(& ((*result)->object)->file));
    }
#line 1014
    if (res) {
#line 1016
      goto ERROR6;
    }
#line 1017
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1019
    res = psiconv_parse_sketch_file(config, (psiconv_buffer const   )subbuf, lev + 3,
                                    (psiconv_u32 )0, (psiconv_sketch_f *)(& ((*result)->object)->file));
    }
#line 1019
    if (res) {
#line 1021
      goto ERROR6;
    }
#line 1022
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1024
    psiconv_warn((psiconv_config )config, lev + 3, (psiconv_u32 )0, "Can\'t parse embedded object (still continuing)");
#line 1025
    ((*result)->object)->file = (void *)0;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 1029
  psiconv_buffer_free(subbuf);
#line 1030
  psiconv_free_section_table_section(table);
  }
#line 1032
  if (length) {
#line 1033
    *length = len;
  }
  {
#line 1035
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of Embedded Object Section (total length: %08x)", len);
  }
#line 1038
  return (res);
  ERROR6: 
  {
#line 1042
  free((void *)(*result)->object);
  }
  ERROR5: 
  {
#line 1044
  psiconv_buffer_free(subbuf);
  }
  ERROR4: 
  {
#line 1046
  psiconv_free_object_icon_section((*result)->icon);
  }
  ERROR3: 
  {
#line 1048
  psiconv_free_object_display_section((*result)->display);
  }
  ERROR2: 
  {
#line 1050
  psiconv_free_section_table_section(table);
  }
  ERROR1: 
  {
#line 1052
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading Embedded Object failed");
  }
#line 1054
  if (length) {
#line 1055
    *length = 0;
  }
#line 1057
  if (res == 0) {
#line 1058
    return (-2);
  } else {
#line 1060
    return (res);
  }
}
}
#line 1063 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
static psiconv_file_type_t psiconv_determine_embedded_object_type(psiconv_config const   config ,
                                                                  psiconv_buffer const   buf ,
                                                                  int lev , int *status ) 
{ 
  psiconv_u32 off ;
  psiconv_section_table_section table ;
  int res ;
  int i ;
  psiconv_file_type_t file_type ;
  psiconv_section_table_entry entry ;
  psiconv_application_id_section applid ;
  void *tmp ;
  psiconv_u32 tmp___0 ;
  psiconv_u32 tmp___1 ;

  {
  {
#line 1071
  file_type = (psiconv_file_type_t )0;
#line 1075
  psiconv_progress((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Going to determine embedded object file type");
#line 1076
  psiconv_progress((psiconv_config )config, lev + 2, (psiconv_u32 )0, "Going to read the Section Table Offset Section");
#line 1077
  off = psiconv_read_u32(config, buf, lev, (psiconv_u32 )0, & res);
  }
#line 1078
  if (res) {
#line 1079
    goto ERROR1;
  }
  {
#line 1080
  psiconv_debug((psiconv_config )config, lev + 2, (psiconv_u32 )0, "Offset: %08x",
                off);
#line 1082
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the Section Table Section");
#line 1083
  res = psiconv_parse_section_table_section(config, buf, lev + 2, off, (int *)((void *)0),
                                            & table);
  }
#line 1083
  if (res) {
#line 1084
    goto ERROR1;
  }
  {
#line 1086
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to search the Section Table Section for the Application ID Section");
#line 1088
  i = 0;
  }
  {
#line 1088
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1088
    tmp___0 = psiconv_list_length((psiconv_list const   )table);
    }
#line 1088
    if (! ((psiconv_u32 )i < tmp___0)) {
#line 1088
      goto while_break;
    }
    {
#line 1089
    psiconv_progress((psiconv_config )config, lev + 3, off, "Going to read entry %d",
                     i);
#line 1090
    tmp = psiconv_list_get((psiconv_list const   )table, (psiconv_u32 )i);
#line 1090
    entry = (psiconv_section_table_entry )tmp;
    }
#line 1090
    if (! entry) {
#line 1091
      goto ERROR2;
    }
#line 1092
    if (entry->id == 268435593U) {
      {
#line 1093
      psiconv_progress((psiconv_config )config, lev + 3, off, "Found the Application ID Section at offset %08x",
                       entry->offset);
#line 1096
      off = entry->offset;
      }
#line 1097
      goto while_break;
    }
#line 1088
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1100
  tmp___1 = psiconv_list_length((psiconv_list const   )table);
  }
#line 1100
  if ((psiconv_u32 )i == tmp___1) {
    {
#line 1101
    psiconv_error((psiconv_config )config, lev + 2, off, "No Application ID Section found");
#line 1102
    res = 3;
    }
#line 1103
    goto ERROR2;
  }
  {
#line 1106
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the Application ID Section");
#line 1107
  res = psiconv_parse_application_id_section(config, buf, lev + 2, off, (int *)((void *)0),
                                             & applid);
  }
#line 1107
  if (res) {
#line 1108
    goto ERROR2;
  }
  {
#line 1111
  if (applid->id == 268435583U) {
#line 1111
    goto case_268435583;
  }
#line 1114
  if (applid->id == 268435589U) {
#line 1114
    goto case_268435589;
  }
#line 1117
  if (applid->id == 268435581U) {
#line 1117
    goto case_268435581;
  }
#line 1120
  if (applid->id == 268435592U) {
#line 1120
    goto case_268435592;
  }
#line 1123
  goto switch_default;
  case_268435583: /* CIL Label */ 
  {
#line 1111
  file_type = (psiconv_file_type_t )1;
#line 1112
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found a Word file");
  }
#line 1113
  goto switch_break;
  case_268435589: /* CIL Label */ 
  {
#line 1114
  file_type = (psiconv_file_type_t )2;
#line 1115
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found a TextEd file");
  }
#line 1116
  goto switch_break;
  case_268435581: /* CIL Label */ 
  {
#line 1117
  file_type = (psiconv_file_type_t )4;
#line 1118
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found a Sketch file");
  }
#line 1119
  goto switch_break;
  case_268435592: /* CIL Label */ 
  {
#line 1120
  file_type = (psiconv_file_type_t )6;
#line 1121
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found a Sheet file");
  }
#line 1122
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1123
  psiconv_warn((psiconv_config )config, lev + 2, off, "Found an unknown file type");
#line 1124
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found ID %08x", applid->id);
  }
  switch_break: /* CIL Label */ ;
  }
  ERROR2: 
  {
#line 1128
  psiconv_free_application_id_section(applid);
  }
  ERROR1: 
  {
#line 1130
  psiconv_free_section_table_section(table);
  }
#line 1131
  if (status) {
#line 1132
    *status = res;
  }
#line 1133
  return (file_type);
}
}
#line 1137 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
int psiconv_parse_object_display_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                         int lev , psiconv_u32 off , int *length ,
                                         psiconv_object_display_section *result ) 
{ 
  int res ;
  int len ;
  int leng ;
  psiconv_u32 temp ;
  psiconv_object_display_section tmp ;
  void *tmp___0 ;
  psiconv_u8 tmp___1 ;

  {
  {
#line 1142
  res = 0;
#line 1143
  len = 0;
#line 1147
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read the Object Display Section");
#line 1148
  tmp___0 = malloc(sizeof(*(*result)));
#line 1148
  tmp = (psiconv_object_display_section )tmp___0;
#line 1148
  *result = tmp;
  }
#line 1148
  if (! tmp) {
#line 1149
    goto ERROR1;
  }
  {
#line 1151
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the display as icon flag (expecting 0x00 or 0x01)");
#line 1153
  tmp___1 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 1153
  temp = (psiconv_u32 )tmp___1;
  }
#line 1154
  if (res) {
#line 1155
    goto ERROR2;
  }
#line 1156
  if (temp == 0U) {
    {
#line 1157
    (*result)->show_icon = (psiconv_bool_t )1;
#line 1158
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Displayed as icon");
    }
  } else
#line 1159
  if (temp == 1U) {
    {
#line 1160
    (*result)->show_icon = (psiconv_bool_t )0;
#line 1161
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Displayed as full document");
    }
  } else {
    {
#line 1163
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unknown Object Display Section Icon Flag");
#line 1164
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Icon flag found: %02x",
                  temp);
    }
#line 1166
    if (temp & 1U) {
#line 1166
      (*result)->show_icon = (psiconv_bool_t )0;
    } else {
#line 1166
      (*result)->show_icon = (psiconv_bool_t )1;
    }
  }
  {
#line 1168
  len ++;
#line 1170
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the display width");
#line 1171
  (*result)->width = psiconv_read_length(config, buf, lev + 2, off + (psiconv_u32 )len,
                                         & leng, & res);
  }
#line 1172
  if (res) {
#line 1173
    goto ERROR2;
  }
  {
#line 1174
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Display width: %f cm",
                (double )(*result)->width);
#line 1175
  len += leng;
#line 1177
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the display height");
#line 1178
  (*result)->height = psiconv_read_length(config, buf, lev + 2, off + (psiconv_u32 )len,
                                          & leng, & res);
  }
#line 1179
  if (res) {
#line 1180
    goto ERROR2;
  }
  {
#line 1181
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Display length: %f cm",
                (double )(*result)->height);
#line 1182
  len += leng;
#line 1184
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read unknown long (%08x expected)",
                   0);
#line 1186
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 1187
  if (temp != 0U) {
    {
#line 1188
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unknown Object Display Section final long");
#line 1189
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Long read: %08x",
                  temp);
    }
  }
#line 1191
  len += 4;
#line 1193
  if (length) {
#line 1194
    *length = len;
  }
  {
#line 1196
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of Object Display Section (total length: %08x", len);
  }
#line 1198
  return (res);
  ERROR2: 
  {
#line 1201
  free((void *)*result);
  }
  ERROR1: 
  {
#line 1203
  psiconv_error((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Reading of Object Display Section failed");
  }
#line 1204
  if (length) {
#line 1205
    *length = 0;
  }
#line 1206
  if (! res) {
#line 1207
    return (-2);
  } else {
#line 1209
    return (res);
  }
}
}
#line 1212 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
int psiconv_parse_object_icon_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                      int lev , psiconv_u32 off , int *length , psiconv_object_icon_section *result ) 
{ 
  int res ;
  int len ;
  int leng ;
  psiconv_object_icon_section tmp ;
  void *tmp___0 ;

  {
  {
#line 1217
  res = 0;
#line 1218
  len = 0;
#line 1221
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read the Object Icon Section");
#line 1222
  tmp___0 = malloc(sizeof(*(*result)));
#line 1222
  tmp = (psiconv_object_icon_section )tmp___0;
#line 1222
  *result = tmp;
  }
#line 1222
  if (! tmp) {
#line 1223
    goto ERROR1;
  }
  {
#line 1225
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the icon name");
#line 1226
  (*result)->icon_name = psiconv_read_string(config, buf, lev + 2, off + (psiconv_u32 )len,
                                             & leng, & res);
  }
#line 1227
  if (res) {
#line 1228
    goto ERROR2;
  }
  {
#line 1229
  len += leng;
#line 1231
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the icon width");
#line 1232
  (*result)->icon_width = psiconv_read_length(config, buf, lev + 2, off + (psiconv_u32 )len,
                                              & leng, & res);
  }
#line 1233
  if (res) {
#line 1234
    goto ERROR3;
  }
  {
#line 1235
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Icon width: %f cm",
                (double )(*result)->icon_width);
#line 1236
  len += leng;
#line 1238
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the icon height");
#line 1239
  (*result)->icon_height = psiconv_read_length(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & leng, & res);
  }
#line 1240
  if (res) {
#line 1241
    goto ERROR3;
  }
  {
#line 1242
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Icon length: %f cm",
                (double )(*result)->icon_height);
#line 1243
  len += leng;
  }
#line 1245
  if (length) {
#line 1246
    *length = len;
  }
  {
#line 1248
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of Object Icon Section(total length: %08x", len);
  }
#line 1250
  return (res);
  ERROR3: 
  {
#line 1253
  free((void *)(*result)->icon_name);
  }
  ERROR2: 
  {
#line 1255
  free((void *)*result);
  }
  ERROR1: 
  {
#line 1257
  psiconv_error((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Reading of Object Icon Section failed");
  }
#line 1258
  if (length) {
#line 1259
    *length = 0;
  }
#line 1260
  if (! res) {
#line 1261
    return (-2);
  } else {
#line 1263
    return (res);
  }
}
}
#line 1163 "../psiconv/data.h"
int psiconv_compare_color(psiconv_color const   value1 , psiconv_color const   value2 ) ;
#line 1165
int psiconv_compare_font(psiconv_font const   value1 , psiconv_font const   value2 ) ;
#line 1167
int psiconv_compare_border(psiconv_border const   value1 , psiconv_border const   value2 ) ;
#line 1169
int psiconv_compare_bullet(psiconv_bullet const   value1 , psiconv_bullet const   value2 ) ;
#line 1173
int psiconv_compare_all_tabs(psiconv_all_tabs const   value1 , psiconv_all_tabs const   value2 ) ;
#line 53 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_routines.h"
int psiconv_write_size(psiconv_config const   config , psiconv_buffer buf , int lev ,
                       psiconv_size_t const   value ) ;
#line 55
int psiconv_write_bool(psiconv_config const   config , psiconv_buffer buf , int lev ,
                       psiconv_bool_t const   value ) ;
#line 64
int psiconv_write_charlist(psiconv_config const   config , psiconv_buffer buf , int lev ,
                           psiconv_string_t const   value ) ;
#line 73
int psiconv_write_color(psiconv_config const   config , psiconv_buffer buf , int lev ,
                        psiconv_color const   value ) ;
#line 75
int psiconv_write_font(psiconv_config const   config , psiconv_buffer buf , int lev ,
                       psiconv_font const   value ) ;
#line 77
int psiconv_write_border(psiconv_config const   config , psiconv_buffer buf , int lev ,
                         psiconv_border const   value ) ;
#line 79
int psiconv_write_bullet(psiconv_config const   config , psiconv_buffer buf , int lev ,
                         psiconv_bullet const   value ) ;
#line 81
int psiconv_write_tab(psiconv_config const   config , psiconv_buffer buf , int lev ,
                      psiconv_tab const   value ) ;
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_layout.c"
int psiconv_write_color(psiconv_config const   config , psiconv_buffer buf , int lev ,
                        psiconv_color const   value ) 
{ 
  int res ;

  {
  {
#line 38
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing color");
  }
#line 40
  if (! value) {
    {
#line 41
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null color");
#line 42
    res = -4;
    }
#line 43
    goto ERROR;
  }
  {
#line 45
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )value->red);
  }
#line 45
  if (res) {
#line 46
    goto ERROR;
  }
  {
#line 47
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )value->green);
  }
#line 47
  if (res) {
#line 48
    goto ERROR;
  }
  {
#line 49
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )value->blue);
  }
#line 49
  if (res) {
#line 50
    goto ERROR;
  }
  {
#line 51
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of color");
  }
#line 52
  return (0);
  ERROR: 
  {
#line 55
  psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of color failed");
  }
#line 56
  return (res);
}
}
#line 59 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_layout.c"
int psiconv_write_font(psiconv_config const   config , psiconv_buffer buf , int lev ,
                       psiconv_font const   value ) 
{ 
  int res ;
  int len ;
  psiconv_u32 tmp ;

  {
  {
#line 64
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing font");
  }
#line 65
  if (! value) {
    {
#line 66
    tmp = psiconv_buffer_length((psiconv_buffer const   )buf);
#line 66
    psiconv_error((psiconv_config )config, 0, tmp, "Null font");
#line 67
    res = -4;
    }
#line 68
    goto ERROR;
  }
  {
#line 70
  len = psiconv_unicode_strlen((psiconv_ucs2 const   *)value->name);
#line 71
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )(len + 1));
  }
#line 71
  if (res) {
#line 72
    goto ERROR;
  }
  {
#line 73
  res = psiconv_write_charlist(config, buf, lev + 1, (psiconv_string_t const   )value->name);
  }
#line 73
  if (res) {
#line 74
    goto ERROR;
  }
  {
#line 75
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )value->screenfont);
  }
#line 75
  if (res) {
#line 76
    goto ERROR;
  }
  {
#line 77
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of font");
  }
#line 78
  return (0);
  ERROR: 
  {
#line 81
  psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of font failed");
  }
#line 82
  return (res);
}
}
#line 85 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_layout.c"
int psiconv_write_border(psiconv_config const   config , psiconv_buffer buf , int lev ,
                         psiconv_border const   value ) 
{ 
  int res ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;

  {
  {
#line 89
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing border");
  }
#line 91
  if (! value) {
    {
#line 92
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null border");
#line 93
    res = -4;
    }
#line 94
    goto ERROR;
  }
#line 96
  if ((unsigned int )value->kind > 6U) {
    {
#line 97
    psiconv_warn((psiconv_config )config, lev, (psiconv_u32 )0, "Unknown border kind (%d); assuming none",
                 (unsigned int )value->kind);
    }
  }
#line 99
  if ((unsigned int )value->kind == 0U) {
#line 99
    tmp___5 = 0;
  } else {
#line 99
    if ((unsigned int )value->kind == 1U) {
#line 99
      tmp___4 = 1;
    } else {
#line 99
      if ((unsigned int )value->kind == 2U) {
#line 99
        tmp___3 = 2;
      } else {
#line 99
        if ((unsigned int )value->kind == 3U) {
#line 99
          tmp___2 = 3;
        } else {
#line 99
          if ((unsigned int )value->kind == 4U) {
#line 99
            tmp___1 = 4;
          } else {
#line 99
            if ((unsigned int )value->kind == 5U) {
#line 99
              tmp___0 = 5;
            } else {
#line 99
              if ((unsigned int )value->kind == 6U) {
#line 99
                tmp = 6;
              } else {
#line 99
                tmp = 0;
              }
#line 99
              tmp___0 = tmp;
            }
#line 99
            tmp___1 = tmp___0;
          }
#line 99
          tmp___2 = tmp___1;
        }
#line 99
        tmp___3 = tmp___2;
      }
#line 99
      tmp___4 = tmp___3;
    }
#line 99
    tmp___5 = tmp___4;
  }
  {
#line 99
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )tmp___5);
  }
#line 99
  if (res) {
#line 108
    goto ERROR;
  }
#line 109
  if ((unsigned int )value->kind == 1U) {
#line 109
    tmp___6 = (double )value->thickness;
  } else
#line 109
  if ((unsigned int )value->kind == 2U) {
#line 109
    tmp___6 = (double )value->thickness;
  } else {
#line 109
    tmp___6 = 1.0 / 20.0;
  }
  {
#line 109
  res = psiconv_write_size(config, buf, lev + 1, (psiconv_size_t const   )tmp___6);
  }
#line 109
  if (res) {
#line 113
    goto ERROR;
  }
  {
#line 114
  res = psiconv_write_color(config, buf, lev + 1, (psiconv_color const   )value->color);
  }
#line 114
  if (res) {
#line 115
    goto ERROR;
  }
  {
#line 117
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )1);
  }
#line 117
  if (res) {
#line 118
    goto ERROR;
  }
  {
#line 119
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of border");
  }
#line 120
  return (0);
  ERROR: 
  {
#line 123
  psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of border failed");
  }
#line 124
  return (res);
}
}
#line 127 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_layout.c"
int psiconv_write_bullet(psiconv_config const   config , psiconv_buffer buf , int lev ,
                         psiconv_bullet const   value ) 
{ 
  int res ;
  psiconv_buffer extra_buf ;
  psiconv_u32 tmp ;
  psiconv_u32 tmp___0 ;

  {
  {
#line 132
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing bullet");
  }
#line 134
  if (! value) {
    {
#line 135
    tmp = psiconv_buffer_length((psiconv_buffer const   )buf);
#line 135
    psiconv_error((psiconv_config )config, 0, tmp, "Null bullet");
#line 136
    res = -4;
    }
#line 137
    goto ERROR1;
  }
  {
#line 140
  extra_buf = psiconv_buffer_new();
  }
#line 140
  if (! extra_buf) {
    {
#line 141
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 142
    res = -2;
    }
#line 143
    goto ERROR1;
  }
  {
#line 145
  res = psiconv_write_size(config, extra_buf, lev + 1, (psiconv_size_t const   )value->font_size);
  }
#line 145
  if (res) {
#line 146
    goto ERROR2;
  }
  {
#line 147
  res = psiconv_unicode_write_char(config, extra_buf, lev + 1, value->character);
  }
#line 147
  if (res) {
#line 149
    goto ERROR2;
  }
  {
#line 150
  res = psiconv_write_bool(config, extra_buf, lev + 1, (psiconv_bool_t const   )value->indent);
  }
#line 150
  if (res) {
#line 151
    goto ERROR2;
  }
  {
#line 152
  res = psiconv_write_color(config, extra_buf, lev + 1, (psiconv_color const   )value->color);
  }
#line 152
  if (res) {
#line 153
    goto ERROR2;
  }
  {
#line 154
  res = psiconv_write_font(config, extra_buf, lev + 1, (psiconv_font const   )value->font);
  }
#line 154
  if (res) {
#line 155
    goto ERROR2;
  }
  {
#line 157
  tmp___0 = psiconv_buffer_length((psiconv_buffer const   )extra_buf);
#line 157
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )tmp___0);
  }
#line 157
  if (res) {
#line 158
    goto ERROR2;
  }
  {
#line 159
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )extra_buf);
  }
#line 159
  if (res) {
    {
#line 160
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 161
    goto ERROR2;
  }
  ERROR2: 
  {
#line 165
  psiconv_buffer_free(extra_buf);
  }
  ERROR1: 
#line 167
  if (res) {
    {
#line 168
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of bullet failed");
    }
  } else {
    {
#line 170
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of bullet");
    }
  }
#line 171
  return (res);
}
}
#line 174 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_layout.c"
int psiconv_write_tab(psiconv_config const   config , psiconv_buffer buf , int lev ,
                      psiconv_tab const   value ) 
{ 
  int res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 178
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing tab");
  }
#line 180
  if (! value) {
    {
#line 181
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null tab");
#line 182
    res = -4;
    }
#line 183
    goto ERROR;
  }
  {
#line 185
  res = psiconv_write_length(config, buf, lev + 1, (psiconv_length_t const   )value->location);
  }
#line 185
  if (res) {
#line 186
    goto ERROR;
  }
#line 187
  if ((unsigned int )value->kind != 0U) {
#line 187
    if ((unsigned int )value->kind != 2U) {
#line 187
      if ((unsigned int )value->kind != 1U) {
        {
#line 190
        psiconv_warn((psiconv_config )config, lev, (psiconv_u32 )0, "Unknown tab kind (%d); assuming left",
                     (unsigned int )value->kind);
        }
      }
    }
  }
#line 192
  if ((unsigned int )value->kind == 2U) {
#line 192
    tmp___0 = 2;
  } else {
#line 192
    if ((unsigned int )value->kind == 1U) {
#line 192
      tmp = 3;
    } else {
#line 192
      tmp = 1;
    }
#line 192
    tmp___0 = tmp;
  }
  {
#line 192
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )tmp___0);
  }
#line 192
  if (res) {
#line 195
    goto ERROR;
  }
  {
#line 196
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of tab");
  }
#line 197
  return (0);
  ERROR: 
  {
#line 199
  psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of tab failed");
  }
#line 200
  return (res);
}
}
#line 203 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_layout.c"
int psiconv_write_paragraph_layout_list(psiconv_config const   config , psiconv_buffer buf ,
                                        int lev , psiconv_paragraph_layout const   value ,
                                        psiconv_paragraph_layout const   base ) 
{ 
  int res ;
  int i ;
  psiconv_buffer extra_buf ;
  psiconv_tab tab ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  psiconv_u32 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  psiconv_u32 tmp___11 ;
  void *tmp___12 ;
  psiconv_u32 tmp___13 ;
  int tmp___14 ;
  psiconv_u32 tmp___15 ;

  {
  {
#line 212
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing paragraph layout list");
  }
#line 214
  if (! value) {
    {
#line 215
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null paragraph layout list");
#line 216
    res = -4;
    }
#line 217
    goto ERROR1;
  }
  {
#line 219
  extra_buf = psiconv_buffer_new();
  }
#line 219
  if (! extra_buf) {
#line 220
    res = -2;
#line 221
    goto ERROR1;
  }
#line 224
  if (! base) {
#line 224
    goto _L;
  } else {
    {
#line 224
    tmp = psiconv_compare_color((psiconv_color const   )base->back_color, (psiconv_color const   )value->back_color);
    }
#line 224
    if (tmp) {
      _L: /* CIL Label */ 
      {
#line 225
      res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )1);
      }
#line 225
      if (res) {
#line 226
        goto ERROR2;
      }
      {
#line 227
      res = psiconv_write_color(config, extra_buf, lev + 1, (psiconv_color const   )value->back_color);
      }
#line 227
      if (res) {
#line 228
        goto ERROR2;
      }
    }
  }
#line 231
  if (! base) {
#line 231
    goto _L___0;
  } else
#line 231
  if (value->indent_left != base->indent_left) {
    _L___0: /* CIL Label */ 
    {
#line 232
    res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )2);
    }
#line 232
    if (res) {
#line 233
      goto ERROR2;
    }
    {
#line 234
    res = psiconv_write_length(config, extra_buf, lev + 1, (psiconv_length_t const   )value->indent_left);
    }
#line 234
    if (res) {
#line 235
      goto ERROR2;
    }
  }
#line 238
  if (! base) {
#line 238
    goto _L___1;
  } else
#line 238
  if (value->indent_right != base->indent_right) {
    _L___1: /* CIL Label */ 
    {
#line 239
    res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )3);
    }
#line 239
    if (res) {
#line 240
      goto ERROR2;
    }
    {
#line 241
    res = psiconv_write_length(config, extra_buf, lev + 1, (psiconv_length_t const   )value->indent_right);
    }
#line 241
    if (res) {
#line 242
      goto ERROR2;
    }
  }
#line 245
  if (! base) {
#line 245
    goto _L___2;
  } else
#line 245
  if (value->indent_first != base->indent_first) {
    _L___2: /* CIL Label */ 
    {
#line 246
    res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )4);
    }
#line 246
    if (res) {
#line 247
      goto ERROR2;
    }
    {
#line 248
    res = psiconv_write_length(config, extra_buf, lev + 1, (psiconv_length_t const   )value->indent_first);
    }
#line 248
    if (res) {
#line 249
      goto ERROR2;
    }
  }
#line 252
  if (! base) {
#line 252
    goto _L___3;
  } else
#line 252
  if ((unsigned int )value->justify_hor != (unsigned int )base->justify_hor) {
    _L___3: /* CIL Label */ 
    {
#line 253
    res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )5);
    }
#line 253
    if (res) {
#line 254
      goto ERROR2;
    }
#line 255
    if ((unsigned int )value->justify_hor < 0U) {
      {
#line 257
      psiconv_warn((psiconv_config )config, lev, (psiconv_u32 )0, "Unknown horizontal justify (%d); assuming left",
                   (unsigned int )value->justify_hor);
      }
    } else
#line 255
    if ((unsigned int )value->justify_hor > 3U) {
      {
#line 257
      psiconv_warn((psiconv_config )config, lev, (psiconv_u32 )0, "Unknown horizontal justify (%d); assuming left",
                   (unsigned int )value->justify_hor);
      }
    }
#line 260
    if ((unsigned int )value->justify_hor == 1U) {
#line 260
      tmp___2 = 1;
    } else {
#line 260
      if ((unsigned int )value->justify_hor == 2U) {
#line 260
        tmp___1 = 2;
      } else {
#line 260
        if ((unsigned int )value->justify_hor == 3U) {
#line 260
          tmp___0 = 3;
        } else {
#line 260
          tmp___0 = 0;
        }
#line 260
        tmp___1 = tmp___0;
      }
#line 260
      tmp___2 = tmp___1;
    }
    {
#line 260
    res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )tmp___2);
    }
#line 260
    if (res) {
#line 264
      goto ERROR2;
    }
  }
#line 267
  if (! base) {
#line 267
    goto _L___4;
  } else
#line 267
  if ((unsigned int )value->justify_ver != (unsigned int )base->justify_ver) {
    _L___4: /* CIL Label */ 
    {
#line 268
    res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )6);
    }
#line 268
    if (res) {
#line 269
      goto ERROR2;
    }
#line 270
    if ((unsigned int )value->justify_ver < 0U) {
      {
#line 272
      tmp___3 = psiconv_buffer_length((psiconv_buffer const   )buf);
#line 272
      psiconv_warn((psiconv_config )config, 0, tmp___3, "Unknown vertical justify (%d); assuming middle",
                   (unsigned int )value->justify_ver);
      }
    } else
#line 270
    if ((unsigned int )value->justify_ver > 2U) {
      {
#line 272
      tmp___3 = psiconv_buffer_length((psiconv_buffer const   )buf);
#line 272
      psiconv_warn((psiconv_config )config, 0, tmp___3, "Unknown vertical justify (%d); assuming middle",
                   (unsigned int )value->justify_ver);
      }
    }
#line 275
    if ((unsigned int )value->justify_ver == 1U) {
#line 275
      tmp___5 = 1;
    } else {
#line 275
      if ((unsigned int )value->justify_ver == 2U) {
#line 275
        tmp___4 = 2;
      } else {
#line 275
        tmp___4 = 0;
      }
#line 275
      tmp___5 = tmp___4;
    }
    {
#line 275
    res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )tmp___5);
    }
#line 275
    if (res) {
#line 278
      goto ERROR2;
    }
  }
#line 281
  if (! base) {
#line 281
    goto _L___5;
  } else
#line 281
  if (value->linespacing != base->linespacing) {
    _L___5: /* CIL Label */ 
    {
#line 282
    res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )7);
    }
#line 282
    if (res) {
#line 283
      goto ERROR2;
    }
    {
#line 284
    res = psiconv_write_size(config, extra_buf, lev + 1, (psiconv_size_t const   )value->linespacing);
    }
#line 284
    if (res) {
#line 285
      goto ERROR2;
    }
  }
#line 288
  if (! base) {
#line 288
    goto _L___6;
  } else
#line 288
  if ((unsigned int )value->linespacing_exact != (unsigned int )base->linespacing_exact) {
    _L___6: /* CIL Label */ 
    {
#line 289
    res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )8);
    }
#line 289
    if (res) {
#line 290
      goto ERROR2;
    }
    {
#line 291
    res = psiconv_write_bool(config, extra_buf, lev + 1, (psiconv_bool_t const   )value->linespacing_exact);
    }
#line 291
    if (res) {
#line 292
      goto ERROR2;
    }
  }
#line 295
  if (! base) {
#line 295
    goto _L___7;
  } else
#line 295
  if (value->space_above != base->space_above) {
    _L___7: /* CIL Label */ 
    {
#line 296
    res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )9);
    }
#line 296
    if (res) {
#line 297
      goto ERROR2;
    }
    {
#line 298
    res = psiconv_write_size(config, extra_buf, lev + 1, (psiconv_size_t const   )value->space_above);
    }
#line 298
    if (res) {
#line 299
      goto ERROR2;
    }
  }
#line 302
  if (! base) {
#line 302
    goto _L___8;
  } else
#line 302
  if (value->space_below != base->space_below) {
    _L___8: /* CIL Label */ 
    {
#line 303
    res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )10);
    }
#line 303
    if (res) {
#line 304
      goto ERROR2;
    }
    {
#line 305
    res = psiconv_write_size(config, extra_buf, lev + 1, (psiconv_size_t const   )value->space_below);
    }
#line 305
    if (res) {
#line 306
      goto ERROR2;
    }
  }
#line 309
  if (! base) {
#line 309
    goto _L___9;
  } else
#line 309
  if ((unsigned int )value->keep_together != (unsigned int )base->keep_together) {
    _L___9: /* CIL Label */ 
    {
#line 310
    res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )11);
    }
#line 310
    if (res) {
#line 311
      goto ERROR2;
    }
    {
#line 312
    res = psiconv_write_bool(config, extra_buf, lev + 1, (psiconv_bool_t const   )value->keep_together);
    }
#line 312
    if (res) {
#line 313
      goto ERROR2;
    }
  }
#line 316
  if (! base) {
#line 316
    goto _L___10;
  } else
#line 316
  if ((unsigned int )value->keep_with_next != (unsigned int )base->keep_with_next) {
    _L___10: /* CIL Label */ 
    {
#line 317
    res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )12);
    }
#line 317
    if (res) {
#line 318
      goto ERROR2;
    }
    {
#line 319
    res = psiconv_write_bool(config, extra_buf, lev + 1, (psiconv_bool_t const   )value->keep_with_next);
    }
#line 319
    if (res) {
#line 320
      goto ERROR2;
    }
  }
#line 323
  if (! base) {
#line 323
    goto _L___11;
  } else
#line 323
  if ((unsigned int )value->on_next_page != (unsigned int )base->on_next_page) {
    _L___11: /* CIL Label */ 
    {
#line 324
    res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )13);
    }
#line 324
    if (res) {
#line 325
      goto ERROR2;
    }
    {
#line 326
    res = psiconv_write_bool(config, extra_buf, lev + 1, (psiconv_bool_t const   )value->on_next_page);
    }
#line 326
    if (res) {
#line 327
      goto ERROR2;
    }
  }
#line 330
  if (! base) {
#line 330
    goto _L___12;
  } else
#line 330
  if ((unsigned int )value->no_widow_protection != (unsigned int )base->no_widow_protection) {
    _L___12: /* CIL Label */ 
    {
#line 331
    res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )14);
    }
#line 331
    if (res) {
#line 332
      goto ERROR2;
    }
    {
#line 333
    res = psiconv_write_bool(config, extra_buf, lev + 1, (psiconv_bool_t const   )value->no_widow_protection);
    }
#line 333
    if (res) {
#line 334
      goto ERROR2;
    }
  }
#line 337
  if (! base) {
#line 337
    goto _L___13;
  } else
#line 337
  if ((unsigned int )value->wrap_to_fit_cell != (unsigned int )base->wrap_to_fit_cell) {
    _L___13: /* CIL Label */ 
    {
#line 338
    res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )15);
    }
#line 338
    if (res) {
#line 339
      goto ERROR2;
    }
    {
#line 340
    res = psiconv_write_bool(config, extra_buf, lev + 1, (psiconv_bool_t const   )value->wrap_to_fit_cell);
    }
#line 340
    if (res) {
#line 341
      goto ERROR2;
    }
  }
#line 344
  if (! base) {
#line 344
    goto _L___14;
  } else
#line 344
  if (value->border_distance != base->border_distance) {
    _L___14: /* CIL Label */ 
    {
#line 345
    res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )16);
    }
#line 345
    if (res) {
#line 346
      goto ERROR2;
    }
    {
#line 347
    res = psiconv_write_length(config, extra_buf, lev + 1, (psiconv_length_t const   )value->border_distance);
    }
#line 347
    if (res) {
#line 348
      goto ERROR2;
    }
  }
#line 351
  if (! base) {
#line 351
    goto _L___15;
  } else {
    {
#line 351
    tmp___6 = psiconv_compare_border((psiconv_border const   )value->top_border, (psiconv_border const   )base->top_border);
    }
#line 351
    if (tmp___6) {
      _L___15: /* CIL Label */ 
      {
#line 352
      res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )17);
      }
#line 352
      if (res) {
#line 353
        goto ERROR2;
      }
      {
#line 354
      res = psiconv_write_border(config, extra_buf, lev + 1, (psiconv_border const   )value->top_border);
      }
#line 354
      if (res) {
#line 355
        goto ERROR2;
      }
    }
  }
#line 358
  if (! base) {
#line 358
    goto _L___16;
  } else {
    {
#line 358
    tmp___7 = psiconv_compare_border((psiconv_border const   )value->bottom_border,
                                     (psiconv_border const   )base->bottom_border);
    }
#line 358
    if (tmp___7) {
      _L___16: /* CIL Label */ 
      {
#line 360
      res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )18);
      }
#line 360
      if (res) {
#line 361
        goto ERROR2;
      }
      {
#line 362
      res = psiconv_write_border(config, extra_buf, lev + 1, (psiconv_border const   )value->bottom_border);
      }
#line 362
      if (res) {
#line 363
        goto ERROR2;
      }
    }
  }
#line 366
  if (! base) {
#line 366
    goto _L___17;
  } else {
    {
#line 366
    tmp___8 = psiconv_compare_border((psiconv_border const   )value->left_border,
                                     (psiconv_border const   )base->left_border);
    }
#line 366
    if (tmp___8) {
      _L___17: /* CIL Label */ 
      {
#line 368
      res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )19);
      }
#line 368
      if (res) {
#line 369
        goto ERROR2;
      }
      {
#line 370
      res = psiconv_write_border(config, extra_buf, lev + 1, (psiconv_border const   )value->left_border);
      }
#line 370
      if (res) {
#line 371
        goto ERROR2;
      }
    }
  }
#line 374
  if (! base) {
#line 374
    goto _L___18;
  } else {
    {
#line 374
    tmp___9 = psiconv_compare_border((psiconv_border const   )value->right_border,
                                     (psiconv_border const   )base->right_border);
    }
#line 374
    if (tmp___9) {
      _L___18: /* CIL Label */ 
      {
#line 376
      res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )20);
      }
#line 376
      if (res) {
#line 377
        goto ERROR2;
      }
      {
#line 378
      res = psiconv_write_border(config, extra_buf, lev + 1, (psiconv_border const   )value->right_border);
      }
#line 378
      if (res) {
#line 379
        goto ERROR2;
      }
    }
  }
#line 382
  if (! base) {
#line 382
    goto _L___19;
  } else {
    {
#line 382
    tmp___10 = psiconv_compare_bullet((psiconv_bullet const   )value->bullet, (psiconv_bullet const   )base->bullet);
    }
#line 382
    if (tmp___10) {
      _L___19: /* CIL Label */ 
      {
#line 384
      res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )21);
      }
#line 384
      if (res) {
#line 385
        goto ERROR2;
      }
      {
#line 386
      res = psiconv_write_bullet(config, extra_buf, lev + 1, (psiconv_bullet const   )value->bullet);
      }
#line 386
      if (res) {
#line 387
        goto ERROR2;
      }
    }
  }
#line 390
  if (! value->tabs) {
    {
#line 391
    tmp___11 = psiconv_buffer_length((psiconv_buffer const   )buf);
#line 391
    psiconv_error((psiconv_config )config, 0, tmp___11, "Null tabs");
#line 392
    res = -4;
    }
#line 393
    goto ERROR2;
  } else
#line 390
  if (! (value->tabs)->extras) {
    {
#line 391
    tmp___11 = psiconv_buffer_length((psiconv_buffer const   )buf);
#line 391
    psiconv_error((psiconv_config )config, 0, tmp___11, "Null tabs");
#line 392
    res = -4;
    }
#line 393
    goto ERROR2;
  }
#line 399
  if (! base) {
#line 399
    goto _L___20;
  } else {
    {
#line 399
    tmp___14 = psiconv_compare_all_tabs((psiconv_all_tabs const   )value->tabs, (psiconv_all_tabs const   )base->tabs);
    }
#line 399
    if (tmp___14) {
      _L___20: /* CIL Label */ 
      {
#line 400
      res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )22);
      }
#line 400
      if (res) {
#line 401
        goto ERROR2;
      }
      {
#line 402
      res = psiconv_write_length(config, extra_buf, lev + 1, (psiconv_length_t const   )(value->tabs)->normal);
      }
#line 402
      if (res) {
#line 403
        goto ERROR2;
      }
#line 404
      i = 0;
      {
#line 404
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 404
        tmp___13 = psiconv_list_length((psiconv_list const   )(value->tabs)->extras);
        }
#line 404
        if (! ((psiconv_u32 )i < tmp___13)) {
#line 404
          goto while_break;
        }
        {
#line 405
        tmp___12 = psiconv_list_get((psiconv_list const   )(value->tabs)->extras,
                                    (psiconv_u32 )i);
#line 405
        tab = (psiconv_tab )tmp___12;
        }
#line 405
        if (! tab) {
          {
#line 406
          psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Data structure corruption");
#line 407
          res = -2;
          }
#line 408
          goto ERROR2;
        }
        {
#line 410
        res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )23);
        }
#line 410
        if (res) {
#line 411
          goto ERROR2;
        }
        {
#line 412
        res = psiconv_write_tab(config, extra_buf, lev + 1, (psiconv_tab const   )tab);
        }
#line 412
        if (res) {
#line 413
          goto ERROR2;
        }
#line 404
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 417
  tmp___15 = psiconv_buffer_length((psiconv_buffer const   )extra_buf);
#line 417
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )tmp___15);
  }
#line 417
  if (res) {
#line 418
    goto ERROR2;
  }
  {
#line 420
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )extra_buf);
  }
#line 420
  if (res) {
    {
#line 421
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 422
    goto ERROR2;
  }
  ERROR2: 
  {
#line 426
  psiconv_buffer_free(extra_buf);
  }
  ERROR1: 
#line 428
  if (res) {
    {
#line 429
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of paragraph layout list failed");
    }
  } else {
    {
#line 431
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of paragraph layout list");
    }
  }
#line 432
  return (res);
}
}
#line 435 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_layout.c"
int psiconv_write_character_layout_list(psiconv_config const   config , psiconv_buffer buf ,
                                        int lev , psiconv_character_layout const   value ,
                                        psiconv_character_layout const   base ) 
{ 
  int res ;
  psiconv_buffer extra_buf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  psiconv_u32 tmp___4 ;

  {
  {
#line 443
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing character layout list");
  }
#line 445
  if (! value) {
    {
#line 446
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null character layout list");
#line 447
    res = -4;
    }
#line 448
    goto ERROR1;
  }
  {
#line 450
  extra_buf = psiconv_buffer_new();
  }
#line 450
  if (! extra_buf) {
#line 451
    res = -2;
#line 452
    goto ERROR1;
  }
#line 455
  if (! base) {
#line 455
    goto _L;
  } else {
    {
#line 455
    tmp = psiconv_compare_color((psiconv_color const   )base->color, (psiconv_color const   )value->color);
    }
#line 455
    if (tmp) {
      _L: /* CIL Label */ 
      {
#line 456
      res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )25);
      }
#line 456
      if (res) {
#line 457
        goto ERROR2;
      }
      {
#line 458
      res = psiconv_write_color(config, extra_buf, lev + 1, (psiconv_color const   )value->color);
      }
#line 458
      if (res) {
#line 459
        goto ERROR2;
      }
    }
  }
#line 462
  if (! base) {
#line 462
    goto _L___0;
  } else {
    {
#line 462
    tmp___0 = psiconv_compare_color((psiconv_color const   )base->back_color, (psiconv_color const   )value->back_color);
    }
#line 462
    if (tmp___0) {
      _L___0: /* CIL Label */ 
      {
#line 463
      res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )26);
      }
#line 463
      if (res) {
#line 464
        goto ERROR2;
      }
      {
#line 465
      res = psiconv_write_color(config, extra_buf, lev + 1, (psiconv_color const   )value->back_color);
      }
#line 465
      if (res) {
#line 466
        goto ERROR2;
      }
    }
  }
#line 469
  if (! base) {
#line 469
    goto _L___1;
  } else
#line 469
  if (value->font_size != base->font_size) {
    _L___1: /* CIL Label */ 
    {
#line 470
    res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )28);
    }
#line 470
    if (res) {
#line 471
      goto ERROR2;
    }
    {
#line 472
    res = psiconv_write_size(config, extra_buf, lev + 1, (psiconv_size_t const   )value->font_size);
    }
#line 472
    if (res) {
#line 473
      goto ERROR2;
    }
  }
#line 476
  if (! base) {
#line 476
    goto _L___2;
  } else
#line 476
  if ((unsigned int )value->italic != (unsigned int )base->italic) {
    _L___2: /* CIL Label */ 
    {
#line 477
    res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )29);
    }
#line 477
    if (res) {
#line 478
      goto ERROR2;
    }
    {
#line 479
    res = psiconv_write_bool(config, extra_buf, lev + 1, (psiconv_bool_t const   )value->italic);
    }
#line 479
    if (res) {
#line 480
      goto ERROR2;
    }
  }
#line 483
  if (! base) {
#line 483
    goto _L___3;
  } else
#line 483
  if ((unsigned int )value->bold != (unsigned int )base->bold) {
    _L___3: /* CIL Label */ 
    {
#line 484
    res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )30);
    }
#line 484
    if (res) {
#line 485
      goto ERROR2;
    }
    {
#line 486
    res = psiconv_write_bool(config, extra_buf, lev + 1, (psiconv_bool_t const   )value->bold);
    }
#line 486
    if (res) {
#line 487
      goto ERROR2;
    }
  }
#line 490
  if (! base) {
#line 490
    goto _L___4;
  } else
#line 490
  if ((unsigned int )value->super_sub != (unsigned int )base->super_sub) {
    _L___4: /* CIL Label */ 
#line 491
    if ((unsigned int )value->super_sub != 1U) {
#line 491
      if ((unsigned int )value->super_sub != 2U) {
#line 491
        if ((unsigned int )value->super_sub != 0U) {
          {
#line 494
          psiconv_warn((psiconv_config )config, lev, (psiconv_u32 )0, "Unknown supersubscript (%d); assuming normal",
                       (unsigned int )value->super_sub);
          }
        }
      }
    }
    {
#line 496
    res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )31);
    }
#line 496
    if (res) {
#line 497
      goto ERROR2;
    }
#line 498
    if ((unsigned int )value->super_sub == 1U) {
#line 498
      tmp___2 = 1;
    } else {
#line 498
      if ((unsigned int )value->super_sub == 2U) {
#line 498
        tmp___1 = 2;
      } else {
#line 498
        tmp___1 = 0;
      }
#line 498
      tmp___2 = tmp___1;
    }
    {
#line 498
    res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )tmp___2);
    }
#line 498
    if (res) {
#line 501
      goto ERROR2;
    }
  }
#line 504
  if (! base) {
#line 504
    goto _L___5;
  } else
#line 504
  if ((unsigned int )value->underline != (unsigned int )base->underline) {
    _L___5: /* CIL Label */ 
    {
#line 505
    res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )32);
    }
#line 505
    if (res) {
#line 506
      goto ERROR2;
    }
    {
#line 507
    res = psiconv_write_bool(config, extra_buf, lev + 1, (psiconv_bool_t const   )value->underline);
    }
#line 507
    if (res) {
#line 508
      goto ERROR2;
    }
  }
#line 511
  if (! base) {
#line 511
    goto _L___6;
  } else
#line 511
  if ((unsigned int )value->strikethrough != (unsigned int )base->strikethrough) {
    _L___6: /* CIL Label */ 
    {
#line 512
    res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )33);
    }
#line 512
    if (res) {
#line 513
      goto ERROR2;
    }
    {
#line 514
    res = psiconv_write_bool(config, extra_buf, lev + 1, (psiconv_bool_t const   )value->strikethrough);
    }
#line 514
    if (res) {
#line 515
      goto ERROR2;
    }
  }
#line 518
  if (! base) {
#line 518
    goto _L___7;
  } else {
    {
#line 518
    tmp___3 = psiconv_compare_font((psiconv_font const   )base->font, (psiconv_font const   )value->font);
    }
#line 518
    if (tmp___3) {
      _L___7: /* CIL Label */ 
      {
#line 519
      res = psiconv_write_u8(config, extra_buf, lev + 1, (psiconv_u8 const   )34);
      }
#line 519
      if (res) {
#line 520
        goto ERROR2;
      }
      {
#line 521
      res = psiconv_write_font(config, extra_buf, lev + 1, (psiconv_font const   )value->font);
      }
#line 521
      if (res) {
#line 522
        goto ERROR2;
      }
    }
  }
  {
#line 525
  tmp___4 = psiconv_buffer_length((psiconv_buffer const   )extra_buf);
#line 525
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )tmp___4);
  }
#line 525
  if (res) {
#line 526
    goto ERROR2;
  }
  {
#line 528
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )extra_buf);
  }
  ERROR2: 
  {
#line 531
  psiconv_buffer_free(extra_buf);
  }
  ERROR1: 
#line 533
  if (res) {
    {
#line 534
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of character layout list failed");
    }
  } else {
    {
#line 536
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of character layout list");
    }
  }
#line 537
  return (res);
}
}
#line 146 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_routines.h"
int psiconv_write_sketch_section(psiconv_config const   config , psiconv_buffer buf ,
                                 int lev , psiconv_sketch_section const   value ) ;
#line 150
int psiconv_write_paint_data_section(psiconv_config const   config , psiconv_buffer buf ,
                                     int lev , psiconv_paint_data_section const   value ,
                                     int is_clipart ) ;
#line 155
int psiconv_write_jumptable_section(psiconv_config const   config , psiconv_buffer buf ,
                                    int lev , psiconv_jumptable_section const   value ) ;
#line 159
int psiconv_write_clipart_section(psiconv_config const   config , psiconv_buffer buf ,
                                  int lev , psiconv_clipart_section const   value ) ;
#line 43 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.h"
psiconv_pixel_floats_t psiconv_palet_none ;
#line 43
psiconv_pixel_floats_t psiconv_palet_color_4 ;
#line 43
psiconv_pixel_floats_t psiconv_palet_color_8 ;
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_collect_pixel_data(psiconv_pixel_ints *pixels , int xsize , int ysize ,
                                      psiconv_pixel_floats_t const   data , int colordepth ,
                                      int color___1 , int redbits , int bluebits ,
                                      int greenbits , psiconv_pixel_floats_t const   palet ) ;
#line 39
static int psiconv_pixel_data_to_bytes(psiconv_config const   config , int lev , psiconv_pixel_bytes *bytes ,
                                       int xsize , int ysize , psiconv_pixel_ints const   pixels ,
                                       int colordepth ) ;
#line 43
static int psiconv_encode_rle8(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                               psiconv_pixel_bytes *encoded_bytes ) ;
#line 46
static int psiconv_encode_rle12(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                psiconv_pixel_bytes *encoded_bytes ) ;
#line 49
static int psiconv_encode_rle16(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                psiconv_pixel_bytes *encoded_bytes ) ;
#line 52
static int psiconv_encode_rle24(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                psiconv_pixel_bytes *encoded_bytes ) ;
#line 56 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
int psiconv_write_paint_data_section(psiconv_config const   config , psiconv_buffer buf ,
                                     int lev , psiconv_paint_data_section const   value ,
                                     int is_clipart ) 
{ 
  int res ;
  int colordepth ;
  int i ;
  psiconv_pixel_ints ints ;
  psiconv_pixel_floats_t floats ;
  psiconv_pixel_floats_t palet ;
  psiconv_list bytes ;
  psiconv_list bytes_rle ;
  psiconv_u8 *byteptr ;
  psiconv_u8 encoding ;
  psiconv_u32 tmp ;
  psiconv_u32 tmp___0 ;
  psiconv_u32 tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  psiconv_u32 tmp___4 ;

  {
  {
#line 67
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing paint data section");
  }
#line 71
  if (config->colordepth != 2) {
#line 71
    if (config->colordepth != 4) {
#line 71
      if (config->colordepth != 8) {
#line 71
        if (config->colordepth != 12) {
#line 71
          if (config->colordepth != 16) {
#line 71
            if (config->colordepth != 24) {
              {
#line 74
              psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Unsupported color depth (%d); try 2, 4, 8, 16 or 24",
                            config->colordepth);
#line 77
              res = -4;
              }
#line 78
              goto ERROR1;
            }
          }
        }
      }
    }
  }
#line 81
  if (config->color) {
#line 81
    if (config->bluebits) {
#line 81
      goto _L;
    } else
#line 81
    if (config->redbits) {
#line 81
      goto _L;
    } else
#line 81
    if (config->greenbits) {
      _L: /* CIL Label */ 
#line 81
      if ((config->bluebits + config->redbits) + config->greenbits != config->colordepth) {
        {
#line 84
        psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Sum of red (%d), green  (%d) and blue (%d) bits should be equal to the color depth (%d)",
                      config->redbits, config->greenbits, config->bluebits, config->colordepth);
#line 89
        res = -4;
        }
#line 90
        goto ERROR1;
      }
    }
  }
#line 93
  if (config->color) {
#line 93
    if (! config->redbits) {
#line 93
      if (! config->greenbits) {
#line 93
        if (! config->bluebits) {
#line 93
          if (config->colordepth != 4) {
#line 93
            if (config->colordepth != 8) {
              {
#line 96
              psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Current color depth (%d) has no palet associated with it",
                            config->colordepth);
#line 99
              res = -4;
              }
#line 100
              goto ERROR1;
            }
          }
        }
      }
    }
  }
#line 103
  if (config->color) {
    {
#line 104
    psiconv_warn((psiconv_config )config, lev, (psiconv_u32 )0, "All image types except 2-bit greyscale are experimental!");
    }
  } else
#line 103
  if (config->colordepth != 2) {
    {
#line 104
    psiconv_warn((psiconv_config )config, lev, (psiconv_u32 )0, "All image types except 2-bit greyscale are experimental!");
    }
  }
#line 108
  if (! value) {
    {
#line 109
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null paint data section");
#line 110
    res = -4;
    }
#line 111
    goto ERROR1;
  }
#line 114
  floats.red = value->red;
#line 115
  floats.green = value->green;
#line 116
  floats.blue = value->blue;
#line 117
  floats.length = value->xsize * value->ysize;
#line 119
  palet = psiconv_palet_none;
#line 120
  if (config->color) {
#line 120
    if (config->redbits == 0) {
#line 120
      if (config->greenbits == 0) {
#line 120
        if (config->bluebits == 0) {
          {
#line 123
          if (config->colordepth == 4) {
#line 123
            goto case_4;
          }
#line 124
          if (config->colordepth == 8) {
#line 124
            goto case_8;
          }
#line 125
          goto switch_default;
          case_4: /* CIL Label */ 
#line 123
          palet = psiconv_palet_color_4;
#line 123
          goto switch_break;
          case_8: /* CIL Label */ 
#line 124
          palet = psiconv_palet_color_8;
#line 124
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 125
          palet = psiconv_palet_none;
#line 125
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
#line 128
  res = psiconv_collect_pixel_data(& ints, (int )value->xsize, (int )value->ysize,
                                   (psiconv_pixel_floats_t const   )floats, config->colordepth,
                                   (int )config->color, config->redbits, config->greenbits,
                                   config->bluebits, (psiconv_pixel_floats_t const   )palet);
  }
#line 128
  if (res) {
    {
#line 133
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Error collecting pixel data");
    }
#line 134
    goto ERROR1;
  }
  {
#line 137
  res = psiconv_pixel_data_to_bytes(config, lev + 1, & bytes, (int )value->xsize,
                                    (int )value->ysize, (psiconv_pixel_ints const   )ints,
                                    config->colordepth);
  }
#line 137
  if (res) {
    {
#line 140
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Error translating pixel data to bytes");
    }
#line 141
    goto ERROR2;
  }
  {
#line 148
  if (config->colordepth == 8) {
#line 148
    goto case_8___0;
  }
#line 148
  if (config->colordepth == 4) {
#line 148
    goto case_8___0;
  }
#line 148
  if (config->colordepth == 2) {
#line 148
    goto case_8___0;
  }
#line 155
  if (config->colordepth == 12) {
#line 155
    goto case_12;
  }
#line 162
  if (config->colordepth == 16) {
#line 162
    goto case_16;
  }
#line 169
  if (config->colordepth == 24) {
#line 169
    goto case_24;
  }
#line 176
  goto switch_default___0;
  case_8___0: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 149
  encoding = (psiconv_u8 )1;
#line 150
  res = psiconv_encode_rle8(config, (psiconv_pixel_bytes const   )bytes, & bytes_rle);
  }
#line 150
  if (res) {
    {
#line 151
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Error encoding RLE8");
    }
#line 152
    goto ERROR3;
  }
#line 154
  goto switch_break___0;
  case_12: /* CIL Label */ 
  {
#line 156
  encoding = (psiconv_u8 )2;
#line 157
  res = psiconv_encode_rle12(config, (psiconv_pixel_bytes const   )bytes, & bytes_rle);
  }
#line 157
  if (res) {
    {
#line 158
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Error encoding RLE12");
    }
#line 159
    goto ERROR3;
  }
#line 161
  goto switch_break___0;
  case_16: /* CIL Label */ 
  {
#line 163
  encoding = (psiconv_u8 )3;
#line 164
  res = psiconv_encode_rle16(config, (psiconv_pixel_bytes const   )bytes, & bytes_rle);
  }
#line 164
  if (res) {
    {
#line 165
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Error encoding RLE16");
    }
#line 166
    goto ERROR3;
  }
#line 168
  goto switch_break___0;
  case_24: /* CIL Label */ 
  {
#line 170
  encoding = (psiconv_u8 )4;
#line 171
  res = psiconv_encode_rle24(config, (psiconv_pixel_bytes const   )bytes, & bytes_rle);
  }
#line 171
  if (res) {
    {
#line 172
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Error encoding RLE24");
    }
#line 173
    goto ERROR3;
  }
#line 175
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 177
  encoding = (psiconv_u8 )0;
  switch_break___0: /* CIL Label */ ;
  }
#line 179
  if (encoding) {
    {
#line 180
    tmp = psiconv_list_length((psiconv_list const   )bytes_rle);
#line 180
    tmp___0 = psiconv_list_length((psiconv_list const   )bytes);
    }
#line 180
    if (tmp < tmp___0) {
      {
#line 181
      psiconv_list_free(bytes);
#line 182
      bytes = bytes_rle;
      }
    } else {
      {
#line 184
      psiconv_list_free(bytes_rle);
#line 185
      encoding = (psiconv_u8 )0;
      }
    }
  }
  {
#line 189
  tmp___1 = psiconv_list_length((psiconv_list const   )bytes);
#line 189
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )(40U + tmp___1));
  }
#line 189
  if (res) {
#line 191
    goto ERROR3;
  }
  {
#line 192
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )40);
  }
#line 192
  if (res) {
#line 193
    goto ERROR3;
  }
  {
#line 194
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )value->xsize);
  }
#line 194
  if (res) {
#line 195
    goto ERROR3;
  }
  {
#line 196
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )value->ysize);
  }
#line 196
  if (res) {
#line 197
    goto ERROR3;
  }
  {
#line 198
  res = psiconv_write_length(config, buf, lev + 1, (psiconv_length_t const   )value->pic_xsize);
  }
#line 198
  if (res) {
#line 199
    goto ERROR3;
  }
  {
#line 200
  res = psiconv_write_length(config, buf, lev + 1, (psiconv_length_t const   )value->pic_ysize);
  }
#line 200
  if (res) {
#line 201
    goto ERROR3;
  }
  {
#line 202
  colordepth = config->colordepth;
#line 203
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )colordepth);
  }
#line 203
  if (res) {
#line 204
    goto ERROR3;
  }
#line 205
  if (config->color) {
#line 205
    tmp___2 = 1;
  } else {
#line 205
    tmp___2 = 0;
  }
  {
#line 205
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )tmp___2);
  }
#line 205
  if (res) {
#line 206
    goto ERROR3;
  }
  {
#line 207
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )0);
  }
#line 207
  if (res) {
#line 208
    goto ERROR3;
  }
  {
#line 209
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )encoding);
  }
#line 209
  if (res) {
#line 210
    goto ERROR3;
  }
#line 211
  if (is_clipart) {
    {
#line 212
    res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )4294967295U);
    }
#line 212
    if (res) {
#line 213
      goto ERROR3;
    }
    {
#line 214
    res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )68);
    }
#line 214
    if (res) {
#line 215
      goto ERROR3;
    }
  }
#line 217
  i = 0;
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 217
    tmp___4 = psiconv_list_length((psiconv_list const   )bytes);
    }
#line 217
    if (! ((psiconv_u32 )i < tmp___4)) {
#line 217
      goto while_break;
    }
    {
#line 218
    tmp___3 = psiconv_list_get((psiconv_list const   )bytes, (psiconv_u32 )i);
#line 218
    byteptr = (psiconv_u8 *)tmp___3;
    }
#line 218
    if (! byteptr) {
#line 219
      goto ERROR3;
    }
    {
#line 220
    res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )*byteptr);
    }
#line 220
    if (res) {
#line 221
      goto ERROR3;
    }
#line 217
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  ERROR3: 
  {
#line 225
  psiconv_list_free(bytes);
  }
  ERROR2: 
  {
#line 227
  psiconv_list_free(ints);
  }
  ERROR1: 
#line 229
  if (res) {
    {
#line 230
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of paint data section failed");
    }
  } else {
    {
#line 232
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of paint data section");
    }
  }
#line 233
  return (res);
}
}
#line 240 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_collect_pixel_data(psiconv_pixel_ints *pixels , int xsize , int ysize ,
                                      psiconv_pixel_floats_t const   data , int colordepth ,
                                      int color___1 , int redbits , int bluebits ,
                                      int greenbits , psiconv_pixel_floats_t const   palet ) 
{ 
  int res ;
  int x ;
  int y ;
  int i ;
  psiconv_u32 index___0 ;
  psiconv_u32 pixel ;
  float p_red ;
  float p_green ;
  float p_blue ;
  float dist ;
  float new_dist ;
  psiconv_pixel_ints tmp ;

  {
  {
#line 250
  tmp = psiconv_list_new(sizeof(psiconv_u32 ));
#line 250
  *pixels = tmp;
  }
#line 250
  if (! tmp) {
#line 251
    res = -2;
#line 252
    goto ERROR1;
  }
#line 255
  y = 0;
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! (y < ysize)) {
#line 255
      goto while_break;
    }
#line 256
    x = 0;
    {
#line 256
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 256
      if (! (x < xsize)) {
#line 256
        goto while_break___0;
      }
#line 257
      index___0 = (psiconv_u32 )(y * xsize + x);
#line 258
      p_red = *(data.red + index___0);
#line 259
      p_green = *(data.green + index___0);
#line 260
      p_blue = *(data.blue + index___0);
#line 261
      if (! palet.length) {
#line 262
        if (color___1) {
#line 263
          pixel = (((psiconv_u32 )((double )(p_red * (float )(1 << redbits)) + 0.5) << (greenbits + bluebits)) + ((psiconv_u32 )((double )(p_green * (float )(1 << greenbits)) + 0.5) << bluebits)) + (psiconv_u32 )((double )(p_blue * (float )(1 << bluebits)) + 0.5);
        } else {
#line 269
          pixel = (psiconv_u32 )(((0.212671 * (double )p_red + 0.715160 * (double )p_green) + 0.072169 * (double )p_blue) * ((double )(1 << colordepth) * 0.999));
        }
      } else {
#line 271
        dist = (float )4;
#line 272
        pixel = (psiconv_u32 )-1;
#line 273
        i = 0;
        {
#line 273
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 273
          if (! ((psiconv_u32 const   )i < palet.length)) {
#line 273
            goto while_break___1;
          }
#line 274
          new_dist = ((p_red - *(palet.red + i)) * (p_red - *(palet.red + i)) + (p_green - *(palet.green + i)) * (p_green - *(palet.green + i))) + (p_blue - *(palet.blue + i)) * (p_blue - *(palet.blue + i));
#line 277
          if (new_dist < dist) {
#line 278
            pixel = (psiconv_u32 )i;
#line 279
            dist = new_dist;
          }
#line 273
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 283
      res = psiconv_list_add(*pixels, (void const   *)(& pixel));
      }
#line 283
      if (res) {
#line 284
        goto ERROR2;
      }
#line 256
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 255
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  return (0);
  ERROR2: 
  {
#line 290
  psiconv_list_free(*pixels);
  }
  ERROR1: 
#line 292
  return (res);
}
}
#line 295 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_pixel_data_to_bytes(psiconv_config const   config , int lev , psiconv_pixel_bytes *bytes ,
                                       int xsize , int ysize , psiconv_pixel_ints const   pixels ,
                                       int colordepth ) 
{ 
  int res ;
  int x ;
  int y ;
  psiconv_u32 inputdata ;
  psiconv_u8 outputbyte ;
  psiconv_u32 *pixelptr ;
  int inputbitsleft ;
  int outputbitnr ;
  int bitsfit ;
  int outputbytenr ;
  psiconv_u32 tmp ;
  psiconv_pixel_bytes tmp___0 ;
  void *tmp___1 ;

  {
#line 309
  if (! bytes) {
    {
#line 310
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "NULL pixel data");
#line 311
    res = -4;
    }
#line 312
    goto ERROR1;
  }
#line 314
  if (! pixels) {
    {
#line 315
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "NULL pixel data");
#line 316
    res = -4;
    }
#line 317
    goto ERROR1;
  }
  {
#line 319
  tmp = psiconv_list_length(pixels);
  }
#line 319
  if (tmp != (psiconv_u32 )(xsize * ysize)) {
    {
#line 320
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Pixel number is not correct");
#line 321
    res = -4;
    }
#line 322
    goto ERROR1;
  }
  {
#line 325
  tmp___0 = psiconv_list_new(sizeof(psiconv_u8 ));
#line 325
  *bytes = tmp___0;
  }
#line 325
  if (! tmp___0) {
#line 326
    res = -2;
#line 327
    goto ERROR1;
  }
#line 331
  outputbitnr = 0;
#line 332
  outputbyte = (psiconv_u8 )0;
#line 333
  y = 0;
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 333
    if (! (y < ysize)) {
#line 333
      goto while_break;
    }
#line 334
    outputbytenr = 0;
#line 335
    x = 0;
    {
#line 335
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 335
      if (! (x < xsize)) {
#line 335
        goto while_break___0;
      }
      {
#line 336
      tmp___1 = psiconv_list_get(pixels, (psiconv_u32 )(y * xsize + x));
#line 336
      pixelptr = (psiconv_u32 *)tmp___1;
      }
#line 336
      if (! pixelptr) {
        {
#line 337
        psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Data structure corruption");
#line 338
        res = -2;
        }
#line 339
        goto ERROR2;
      }
#line 341
      inputbitsleft = colordepth;
#line 342
      inputdata = *pixelptr;
      {
#line 343
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 343
        if (! inputbitsleft) {
#line 343
          goto while_break___1;
        }
#line 344
        if (inputbitsleft + outputbitnr <= 8) {
#line 344
          bitsfit = inputbitsleft;
        } else {
#line 344
          bitsfit = 8 - outputbitnr;
        }
#line 345
        outputbyte = (psiconv_u8 )((unsigned int )outputbyte | ((inputdata & (unsigned int )((1 << bitsfit) - 1)) << outputbitnr));
#line 346
        inputdata >>= bitsfit;
#line 347
        inputbitsleft -= bitsfit;
#line 348
        outputbitnr += bitsfit;
#line 349
        if (outputbitnr == 8) {
          {
#line 350
          res = psiconv_list_add(*bytes, (void const   *)(& outputbyte));
          }
#line 350
          if (res) {
#line 351
            goto ERROR2;
          }
#line 352
          outputbitnr = 0;
#line 353
          outputbyte = (psiconv_u8 )0;
#line 354
          outputbytenr ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 335
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 359
    if (outputbitnr != 0) {
      {
#line 360
      res = psiconv_list_add(*bytes, (void const   *)(& outputbyte));
      }
#line 360
      if (res) {
#line 361
        goto ERROR2;
      }
#line 362
      outputbitnr = 0;
#line 363
      outputbyte = (psiconv_u8 )0;
#line 364
      outputbytenr ++;
    }
    {
#line 367
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 367
      if (! (outputbytenr % 4)) {
#line 367
        goto while_break___2;
      }
      {
#line 368
      res = psiconv_list_add(*bytes, (void const   *)(& outputbyte));
      }
#line 368
      if (res) {
#line 369
        goto ERROR2;
      }
#line 370
      outputbytenr ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 333
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return (0);
  ERROR2: 
  {
#line 377
  psiconv_list_free(*bytes);
  }
  ERROR1: 
#line 379
  return (res);
}
}
#line 386 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_encode_rle8(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                               psiconv_pixel_bytes *encoded_bytes ) 
{ 
  int res ;
  int i ;
  int j ;
  int len ;
  psiconv_u8 *entry ;
  psiconv_u8 *next ;
  psiconv_u8 temp ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  psiconv_u32 tmp___3 ;
  void *tmp___4 ;
  psiconv_u32 tmp___5 ;
  void *tmp___6 ;
  psiconv_u32 tmp___7 ;
  psiconv_u32 tmp___8 ;

  {
  {
#line 394
  tmp = psiconv_list_new(sizeof(*entry));
#line 394
  *encoded_bytes = tmp;
  }
#line 394
  if (! tmp) {
#line 395
    res = -2;
#line 396
    goto ERROR1;
  }
#line 399
  i = 0;
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 399
    tmp___8 = psiconv_list_length(plain_bytes);
    }
#line 399
    if (! ((psiconv_u32 )i < tmp___8)) {
#line 399
      goto while_break;
    }
    {
#line 400
    tmp___0 = psiconv_list_get(plain_bytes, (psiconv_u32 )i);
#line 400
    entry = (psiconv_u8 *)tmp___0;
    }
#line 400
    if (! entry) {
#line 401
      res = -2;
#line 402
      goto ERROR2;
    }
    {
#line 404
    tmp___1 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 1));
#line 404
    next = (psiconv_u8 *)tmp___1;
    }
#line 404
    if (! next) {
#line 405
      res = -2;
#line 406
      goto ERROR2;
    }
    {
#line 408
    tmp___7 = psiconv_list_length(plain_bytes);
    }
#line 408
    if ((psiconv_u32 )i == tmp___7 - 2U) {
      {
#line 409
      temp = (psiconv_u8 )254;
#line 410
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 410
      if (res) {
#line 411
        goto ERROR2;
      }
      {
#line 412
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry);
      }
#line 412
      if (res) {
#line 413
        goto ERROR2;
      }
      {
#line 414
      res = psiconv_list_add(*encoded_bytes, (void const   *)next);
      }
#line 414
      if (res) {
#line 415
        goto ERROR2;
      }
#line 416
      i += 2;
    } else
#line 417
    if ((int )*next == (int )*entry) {
#line 418
      len = 1;
      {
#line 419
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 419
        if ((int )*next == (int )*entry) {
          {
#line 419
          tmp___3 = psiconv_list_length(plain_bytes);
          }
#line 419
          if ((psiconv_u32 )((i + len) + 2) < tmp___3) {
#line 419
            if (! (len < 128)) {
#line 419
              goto while_break___0;
            }
          } else {
#line 419
            goto while_break___0;
          }
        } else {
#line 419
          goto while_break___0;
        }
        {
#line 422
        len ++;
#line 423
        tmp___2 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len));
#line 423
        next = (psiconv_u8 *)tmp___2;
        }
#line 423
        if (! next) {
#line 424
          res = -2;
#line 425
          goto ERROR2;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 428
      temp = (psiconv_u8 )(len - 1);
#line 429
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 429
      if (res) {
#line 430
        goto ERROR2;
      }
      {
#line 431
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry);
      }
#line 431
      if (res) {
#line 432
        goto ERROR2;
      }
#line 433
      i += len;
    } else {
#line 435
      len = 1;
      {
#line 436
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 436
        if ((int )*next != (int )*entry) {
          {
#line 436
          tmp___5 = psiconv_list_length(plain_bytes);
          }
#line 436
          if ((psiconv_u32 )((i + len) + 1) < tmp___5) {
#line 436
            if (! (len < 128)) {
#line 436
              goto while_break___1;
            }
          } else {
#line 436
            goto while_break___1;
          }
        } else {
#line 436
          goto while_break___1;
        }
        {
#line 439
        len ++;
#line 440
        entry = next;
#line 441
        tmp___4 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len));
#line 441
        next = (psiconv_u8 *)tmp___4;
        }
#line 441
        if (! next) {
#line 442
          res = -2;
#line 443
          goto ERROR2;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 446
      len --;
#line 447
      temp = (psiconv_u8 )(256 - len);
#line 448
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 448
      if (res) {
#line 449
        goto ERROR2;
      }
#line 450
      j = 0;
      {
#line 450
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 450
        if (! (j < len)) {
#line 450
          goto while_break___2;
        }
        {
#line 451
        tmp___6 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + j));
#line 451
        next = (psiconv_u8 *)tmp___6;
        }
#line 451
        if (! next) {
#line 452
          res = -2;
#line 453
          goto ERROR2;
        }
        {
#line 455
        res = psiconv_list_add(*encoded_bytes, (void const   *)next);
        }
#line 455
        if (res) {
#line 456
          goto ERROR2;
        }
#line 450
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 458
      i += len;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 461
  return (0);
  ERROR2: 
  {
#line 464
  psiconv_list_free(*encoded_bytes);
  }
  ERROR1: 
#line 466
  return (res);
}
}
#line 472 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_encode_rle12(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                psiconv_pixel_bytes *encoded_bytes ) 
{ 
  psiconv_word_data data ;
  int res ;
  int i ;
  int len ;
  int location ;
  psiconv_u16 *word_entry ;
  psiconv_u16 *word_next ;
  psiconv_u16 word_data ;
  psiconv_u8 byte_temp ;
  psiconv_u8 *byte_entry ;
  void *tmp ;
  psiconv_u32 tmp___0 ;
  psiconv_pixel_bytes tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  psiconv_u32 tmp___6 ;
  void *tmp___7 ;
  psiconv_u32 tmp___8 ;
  int tmp___9 ;
  psiconv_u32 tmp___10 ;

  {
  {
#line 486
  data = psiconv_list_new(sizeof(psiconv_u16 ));
  }
#line 486
  if (! data) {
#line 487
    res = -2;
#line 488
    goto ERROR1;
  }
#line 491
  i = 0;
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 491
    tmp___0 = psiconv_list_length(plain_bytes);
    }
#line 491
    if (! ((psiconv_u32 )i < tmp___0)) {
#line 491
      goto while_break;
    }
    {
#line 492
    tmp = psiconv_list_get(plain_bytes, (psiconv_u32 )i);
#line 492
    byte_entry = (psiconv_u8 *)tmp;
    }
#line 492
    if (! byte_entry) {
#line 493
      res = -2;
#line 494
      goto ERROR2;
    }
#line 496
    location = 0;
#line 497
    if (location == 0) {
#line 498
      word_data = (psiconv_u16 )*byte_entry;
#line 499
      location ++;
    } else
#line 500
    if (location == 1) {
      {
#line 501
      word_data = (psiconv_u16 )(((int )word_data << 4) + ((int )*byte_entry & 15));
#line 502
      res = psiconv_list_add(data, (void const   *)(& word_data));
      }
#line 502
      if (res) {
#line 503
        goto ERROR2;
      }
#line 504
      word_data = (psiconv_u16 )((int )*byte_entry >> 4);
#line 505
      location ++;
    } else {
      {
#line 507
      word_data = (psiconv_u16 )(((int )word_data << 8) + (int )*byte_entry);
#line 508
      res = psiconv_list_add(data, (void const   *)(& word_data));
      }
#line 508
      if (res) {
#line 509
        goto ERROR2;
      }
#line 510
      location = 0;
    }
#line 491
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 514
  tmp___1 = psiconv_list_new(sizeof(psiconv_u8 ));
#line 514
  *encoded_bytes = tmp___1;
  }
#line 514
  if (! tmp___1) {
#line 515
    res = -2;
#line 516
    goto ERROR2;
  }
#line 519
  i = 0;
  {
#line 519
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 519
    tmp___10 = psiconv_list_length((psiconv_list const   )data);
    }
#line 519
    if (! ((psiconv_u32 )i < tmp___10)) {
#line 519
      goto while_break___0;
    }
    {
#line 520
    tmp___2 = psiconv_list_get((psiconv_list const   )data, (psiconv_u32 )i);
#line 520
    word_entry = (psiconv_u16 *)tmp___2;
    }
#line 520
    if (! word_entry) {
#line 521
      res = -2;
#line 522
      goto ERROR3;
    }
    {
#line 525
    tmp___3 = psiconv_list_get((psiconv_list const   )data, (psiconv_u32 )(i + 1));
#line 525
    word_next = (psiconv_u16 *)tmp___3;
    }
#line 525
    if (! word_next) {
#line 526
      res = -2;
#line 527
      goto ERROR3;
    }
    {
#line 530
    tmp___6 = psiconv_list_length((psiconv_list const   )data);
    }
#line 530
    if ((psiconv_u32 )i == tmp___6 - 2U) {
#line 531
      if (*word_entry) {
#line 531
        tmp___4 = 1;
      } else {
#line 531
        tmp___4 = 0;
      }
      {
#line 531
      byte_temp = (psiconv_u8 )tmp___4;
#line 532
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
      }
#line 532
      if (res) {
#line 533
        goto ERROR3;
      }
      {
#line 534
      byte_temp = (psiconv_u8 )((int )*word_entry >> 8);
#line 535
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
      }
#line 535
      if (res) {
#line 536
        goto ERROR3;
      }
#line 537
      if (*word_next) {
#line 537
        tmp___5 = 1;
      } else {
#line 537
        tmp___5 = 0;
      }
      {
#line 537
      byte_temp = (psiconv_u8 )tmp___5;
#line 538
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
      }
#line 538
      if (res) {
#line 539
        goto ERROR3;
      }
      {
#line 540
      byte_temp = (psiconv_u8 )((int )*word_next >> 8);
#line 541
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
      }
#line 541
      if (res) {
#line 542
        goto ERROR3;
      }
#line 543
      i += 2;
    }
#line 546
    len = 0;
    {
#line 547
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 547
      if ((int )*word_entry == (int )*word_next) {
#line 547
        if (len < 16) {
          {
#line 547
          tmp___8 = psiconv_list_length((psiconv_list const   )data);
          }
#line 547
          if (! ((psiconv_u32 )((i + len) + 1) < tmp___8)) {
#line 547
            goto while_break___1;
          }
        } else {
#line 547
          goto while_break___1;
        }
      } else {
#line 547
        goto while_break___1;
      }
      {
#line 549
      len ++;
#line 550
      tmp___7 = psiconv_list_get((psiconv_list const   )data, (psiconv_u32 )(i + len));
#line 550
      word_next = (psiconv_u16 *)tmp___7;
      }
#line 550
      if (! word_next) {
#line 551
        res = -2;
#line 552
        goto ERROR3;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 556
    if (*word_entry) {
#line 556
      tmp___9 = 1;
    } else {
#line 556
      tmp___9 = 0;
    }
    {
#line 556
    byte_temp = (psiconv_u8 )tmp___9;
#line 557
    res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
    }
#line 557
    if (res) {
#line 558
      goto ERROR3;
    }
    {
#line 559
    byte_temp = (psiconv_u8 )(((int )*word_entry >> 8) + ((len - 1) << 4));
#line 560
    res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
    }
#line 560
    if (res) {
#line 561
      goto ERROR3;
    }
#line 562
    i += len;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 564
  return (0);
  ERROR3: 
  {
#line 567
  psiconv_list_free(*encoded_bytes);
  }
  ERROR2: 
  {
#line 569
  psiconv_list_free(data);
  }
  ERROR1: 
#line 571
  return (res);
}
}
#line 578 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_encode_rle16(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                psiconv_pixel_bytes *encoded_bytes ) 
{ 
  int res ;
  int i ;
  int j ;
  int len ;
  psiconv_u8 *entry1 ;
  psiconv_u8 *entry2 ;
  psiconv_u8 *next1 ;
  psiconv_u8 *next2 ;
  psiconv_u8 temp ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  psiconv_u32 tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  psiconv_u32 tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  psiconv_u32 tmp___12 ;
  psiconv_u32 tmp___13 ;

  {
  {
#line 586
  tmp = psiconv_list_new(sizeof(*entry1));
#line 586
  *encoded_bytes = tmp;
  }
#line 586
  if (! tmp) {
#line 587
    res = -2;
#line 588
    goto ERROR1;
  }
#line 591
  i = 0;
  {
#line 591
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 591
    tmp___13 = psiconv_list_length(plain_bytes);
    }
#line 591
    if (! ((psiconv_u32 )i < tmp___13)) {
#line 591
      goto while_break;
    }
    {
#line 592
    tmp___0 = psiconv_list_get(plain_bytes, (psiconv_u32 )i);
#line 592
    entry1 = (psiconv_u8 *)tmp___0;
    }
#line 592
    if (! entry1) {
#line 593
      res = -2;
#line 594
      goto ERROR2;
    }
    {
#line 596
    tmp___1 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 1));
#line 596
    entry2 = (psiconv_u8 *)tmp___1;
    }
#line 596
    if (! entry2) {
#line 597
      res = -2;
#line 598
      goto ERROR2;
    }
    {
#line 600
    tmp___2 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 2));
#line 600
    next1 = (psiconv_u8 *)tmp___2;
    }
#line 600
    if (! next1) {
#line 601
      res = -2;
#line 602
      goto ERROR2;
    }
    {
#line 604
    tmp___3 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 3));
#line 604
    next2 = (psiconv_u8 *)tmp___3;
    }
#line 604
    if (! next2) {
#line 605
      res = -2;
#line 606
      goto ERROR2;
    }
    {
#line 608
    tmp___12 = psiconv_list_length(plain_bytes);
    }
#line 608
    if ((psiconv_u32 )i == tmp___12 - 4U) {
      {
#line 609
      temp = (psiconv_u8 )254;
#line 610
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 610
      if (res) {
#line 611
        goto ERROR2;
      }
      {
#line 612
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry1);
      }
#line 612
      if (res) {
#line 613
        goto ERROR2;
      }
      {
#line 614
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry2);
      }
#line 614
      if (res) {
#line 615
        goto ERROR2;
      }
      {
#line 616
      res = psiconv_list_add(*encoded_bytes, (void const   *)next1);
      }
#line 616
      if (res) {
#line 617
        goto ERROR2;
      }
      {
#line 618
      res = psiconv_list_add(*encoded_bytes, (void const   *)next2);
      }
#line 618
      if (res) {
#line 619
        goto ERROR2;
      }
#line 620
      i += 4;
    } else
#line 621
    if ((int )*next1 == (int )*entry1) {
#line 621
      if ((int )*next2 == (int )*entry2) {
#line 622
        len = 0;
        {
#line 623
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 623
          if ((int )*next1 == (int )*entry1) {
#line 623
            if ((int )*next2 == (int )*entry2) {
              {
#line 623
              tmp___6 = psiconv_list_length(plain_bytes);
              }
#line 623
              if ((psiconv_u32 )((i + 2 * len) + 4) < tmp___6) {
#line 623
                if (! (len < 128)) {
#line 623
                  goto while_break___0;
                }
              } else {
#line 623
                goto while_break___0;
              }
            } else {
#line 623
              goto while_break___0;
            }
          } else {
#line 623
            goto while_break___0;
          }
          {
#line 626
          len ++;
#line 627
          tmp___4 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len * 2));
#line 627
          next1 = (psiconv_u8 *)tmp___4;
          }
#line 627
          if (! next1) {
#line 628
            res = -2;
#line 629
            goto ERROR2;
          }
          {
#line 631
          tmp___5 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 2) + 1));
#line 631
          next2 = (psiconv_u8 *)tmp___5;
          }
#line 631
          if (! next2) {
#line 632
            res = -2;
#line 633
            goto ERROR2;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 636
        temp = (psiconv_u8 )(len - 1);
#line 637
        res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
        }
#line 637
        if (res) {
#line 638
          goto ERROR2;
        }
        {
#line 639
        res = psiconv_list_add(*encoded_bytes, (void const   *)entry1);
        }
#line 639
        if (res) {
#line 640
          goto ERROR2;
        }
        {
#line 641
        res = psiconv_list_add(*encoded_bytes, (void const   *)entry2);
        }
#line 641
        if (res) {
#line 642
          goto ERROR2;
        }
#line 643
        i += len * 2;
      } else {
#line 621
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 645
      len = 1;
      {
#line 646
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 646
        if ((int )*next1 != (int )*entry1) {
#line 646
          goto _L;
        } else
#line 646
        if ((int )*next2 != (int )*entry2) {
          _L: /* CIL Label */ 
          {
#line 646
          tmp___9 = psiconv_list_length(plain_bytes);
          }
#line 646
          if ((psiconv_u32 )((i + len * 2) + 4) < tmp___9) {
#line 646
            if (! (len < 128)) {
#line 646
              goto while_break___1;
            }
          } else {
#line 646
            goto while_break___1;
          }
        } else {
#line 646
          goto while_break___1;
        }
        {
#line 649
        len ++;
#line 650
        entry1 = next1;
#line 651
        entry2 = next2;
#line 652
        tmp___7 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len * 2));
#line 652
        next1 = (psiconv_u8 *)tmp___7;
        }
#line 652
        if (! next1) {
#line 653
          res = -2;
#line 654
          goto ERROR2;
        }
        {
#line 656
        tmp___8 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 2) + 1));
#line 656
        next2 = (psiconv_u8 *)tmp___8;
        }
#line 656
        if (! next2) {
#line 657
          res = -2;
#line 658
          goto ERROR2;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 661
      len --;
#line 662
      temp = (psiconv_u8 )(256 - len);
#line 663
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 663
      if (res) {
#line 664
        goto ERROR2;
      }
#line 665
      j = 0;
      {
#line 665
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 665
        if (! (j < len)) {
#line 665
          goto while_break___2;
        }
        {
#line 666
        tmp___10 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + j * 2));
#line 666
        next1 = (psiconv_u8 *)tmp___10;
        }
#line 666
        if (! next1) {
#line 667
          res = -2;
#line 668
          goto ERROR2;
        }
        {
#line 670
        tmp___11 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + j * 2) + 1));
#line 670
        next2 = (psiconv_u8 *)tmp___11;
        }
#line 670
        if (! next2) {
#line 671
          res = -2;
#line 672
          goto ERROR2;
        }
        {
#line 674
        res = psiconv_list_add(*encoded_bytes, (void const   *)next1);
        }
#line 674
        if (res) {
#line 675
          goto ERROR2;
        }
        {
#line 676
        res = psiconv_list_add(*encoded_bytes, (void const   *)next2);
        }
#line 676
        if (res) {
#line 677
          goto ERROR2;
        }
#line 665
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 679
      i += len * 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 682
  return (0);
  ERROR2: 
  {
#line 685
  psiconv_list_free(*encoded_bytes);
  }
  ERROR1: 
#line 687
  return (res);
}
}
#line 694 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_encode_rle24(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                psiconv_pixel_bytes *encoded_bytes ) 
{ 
  int res ;
  int i ;
  int j ;
  int len ;
  psiconv_u8 *entry1 ;
  psiconv_u8 *entry2 ;
  psiconv_u8 *entry3 ;
  psiconv_u8 *next1 ;
  psiconv_u8 *next2 ;
  psiconv_u8 *next3 ;
  psiconv_u8 temp ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  psiconv_u32 tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  psiconv_u32 tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  psiconv_u32 tmp___17 ;
  psiconv_u32 tmp___18 ;

  {
  {
#line 702
  tmp = psiconv_list_new(sizeof(*entry1));
#line 702
  *encoded_bytes = tmp;
  }
#line 702
  if (! tmp) {
#line 703
    res = -2;
#line 704
    goto ERROR1;
  }
#line 707
  i = 0;
  {
#line 707
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 707
    tmp___18 = psiconv_list_length(plain_bytes);
    }
#line 707
    if (! ((psiconv_u32 )i < tmp___18)) {
#line 707
      goto while_break;
    }
    {
#line 708
    tmp___0 = psiconv_list_get(plain_bytes, (psiconv_u32 )i);
#line 708
    entry1 = (psiconv_u8 *)tmp___0;
    }
#line 708
    if (! entry1) {
#line 709
      res = -2;
#line 710
      goto ERROR2;
    }
    {
#line 712
    tmp___1 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 1));
#line 712
    entry2 = (psiconv_u8 *)tmp___1;
    }
#line 712
    if (! entry2) {
#line 713
      res = -2;
#line 714
      goto ERROR2;
    }
    {
#line 716
    tmp___2 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 2));
#line 716
    entry3 = (psiconv_u8 *)tmp___2;
    }
#line 716
    if (! entry3) {
#line 717
      res = -2;
#line 718
      goto ERROR2;
    }
    {
#line 720
    tmp___3 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 3));
#line 720
    next1 = (psiconv_u8 *)tmp___3;
    }
#line 720
    if (! next1) {
#line 721
      res = -2;
#line 722
      goto ERROR2;
    }
    {
#line 724
    tmp___4 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 4));
#line 724
    next2 = (psiconv_u8 *)tmp___4;
    }
#line 724
    if (! next2) {
#line 725
      res = -2;
#line 726
      goto ERROR2;
    }
    {
#line 728
    tmp___5 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 5));
#line 728
    next3 = (psiconv_u8 *)tmp___5;
    }
#line 728
    if (! next3) {
#line 729
      res = -2;
#line 730
      goto ERROR2;
    }
    {
#line 732
    tmp___17 = psiconv_list_length(plain_bytes);
    }
#line 732
    if ((psiconv_u32 )i == tmp___17 - 6U) {
      {
#line 733
      temp = (psiconv_u8 )254;
#line 734
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 734
      if (res) {
#line 735
        goto ERROR2;
      }
      {
#line 736
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry1);
      }
#line 736
      if (res) {
#line 737
        goto ERROR2;
      }
      {
#line 738
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry2);
      }
#line 738
      if (res) {
#line 739
        goto ERROR2;
      }
      {
#line 740
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry3);
      }
#line 740
      if (res) {
#line 741
        goto ERROR2;
      }
      {
#line 742
      res = psiconv_list_add(*encoded_bytes, (void const   *)next1);
      }
#line 742
      if (res) {
#line 743
        goto ERROR2;
      }
      {
#line 744
      res = psiconv_list_add(*encoded_bytes, (void const   *)next2);
      }
#line 744
      if (res) {
#line 745
        goto ERROR2;
      }
      {
#line 746
      res = psiconv_list_add(*encoded_bytes, (void const   *)next3);
      }
#line 746
      if (res) {
#line 747
        goto ERROR2;
      }
#line 748
      i += 4;
    } else
#line 749
    if ((int )*next1 == (int )*entry1) {
#line 749
      if ((int )*next2 == (int )*entry2) {
#line 749
        if ((int )*next3 == (int )*entry3) {
#line 751
          len = 0;
          {
#line 752
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 752
            if ((int )*next1 == (int )*entry1) {
#line 752
              if ((int )*next2 == (int )*entry2) {
#line 752
                if ((int )*next3 == (int )*entry3) {
                  {
#line 752
                  tmp___9 = psiconv_list_length(plain_bytes);
                  }
#line 752
                  if ((psiconv_u32 )((i + 3 * len) + 6) < tmp___9) {
#line 752
                    if (! (len < 128)) {
#line 752
                      goto while_break___0;
                    }
                  } else {
#line 752
                    goto while_break___0;
                  }
                } else {
#line 752
                  goto while_break___0;
                }
              } else {
#line 752
                goto while_break___0;
              }
            } else {
#line 752
              goto while_break___0;
            }
            {
#line 756
            len ++;
#line 757
            tmp___6 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len * 3));
#line 757
            next1 = (psiconv_u8 *)tmp___6;
            }
#line 757
            if (! next1) {
#line 758
              res = -2;
#line 759
              goto ERROR2;
            }
            {
#line 761
            tmp___7 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 3) + 1));
#line 761
            next2 = (psiconv_u8 *)tmp___7;
            }
#line 761
            if (! next2) {
#line 762
              res = -2;
#line 763
              goto ERROR2;
            }
            {
#line 765
            tmp___8 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 3) + 2));
#line 765
            next3 = (psiconv_u8 *)tmp___8;
            }
#line 765
            if (! next3) {
#line 766
              res = -2;
#line 767
              goto ERROR2;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 770
          temp = (psiconv_u8 )(len - 1);
#line 771
          res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
          }
#line 771
          if (res) {
#line 772
            goto ERROR2;
          }
          {
#line 773
          res = psiconv_list_add(*encoded_bytes, (void const   *)entry1);
          }
#line 773
          if (res) {
#line 774
            goto ERROR2;
          }
          {
#line 775
          res = psiconv_list_add(*encoded_bytes, (void const   *)entry2);
          }
#line 775
          if (res) {
#line 776
            goto ERROR2;
          }
          {
#line 777
          res = psiconv_list_add(*encoded_bytes, (void const   *)entry3);
          }
#line 777
          if (res) {
#line 778
            goto ERROR2;
          }
#line 779
          i += len * 3;
        } else {
#line 749
          goto _L___1;
        }
      } else {
#line 749
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 781
      len = 1;
      {
#line 782
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 782
        if ((int )*next1 != (int )*entry1) {
#line 782
          goto _L;
        } else
#line 782
        if ((int )*next2 != (int )*entry2) {
#line 782
          goto _L;
        } else
#line 782
        if ((int )*next3 != (int )*entry3) {
          _L: /* CIL Label */ 
          {
#line 782
          tmp___13 = psiconv_list_length(plain_bytes);
          }
#line 782
          if ((psiconv_u32 )((i + len * 3) + 6) < tmp___13) {
#line 782
            if (! (len < 128)) {
#line 782
              goto while_break___1;
            }
          } else {
#line 782
            goto while_break___1;
          }
        } else {
#line 782
          goto while_break___1;
        }
        {
#line 786
        len ++;
#line 787
        entry1 = next1;
#line 788
        entry2 = next2;
#line 789
        entry3 = next3;
#line 790
        tmp___10 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len * 3));
#line 790
        next1 = (psiconv_u8 *)tmp___10;
        }
#line 790
        if (! next1) {
#line 791
          res = -2;
#line 792
          goto ERROR2;
        }
        {
#line 794
        tmp___11 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 3) + 1));
#line 794
        next2 = (psiconv_u8 *)tmp___11;
        }
#line 794
        if (! next2) {
#line 795
          res = -2;
#line 796
          goto ERROR2;
        }
        {
#line 798
        tmp___12 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 3) + 2));
#line 798
        next3 = (psiconv_u8 *)tmp___12;
        }
#line 798
        if (! next3) {
#line 799
          res = -2;
#line 800
          goto ERROR2;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 803
      len --;
#line 804
      temp = (psiconv_u8 )(256 - len);
#line 805
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 805
      if (res) {
#line 806
        goto ERROR2;
      }
#line 807
      j = 0;
      {
#line 807
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 807
        if (! (j < len)) {
#line 807
          goto while_break___2;
        }
        {
#line 808
        tmp___14 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + j * 3));
#line 808
        next1 = (psiconv_u8 *)tmp___14;
        }
#line 808
        if (! next1) {
#line 809
          res = -2;
#line 810
          goto ERROR2;
        }
        {
#line 812
        tmp___15 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + j * 3) + 1));
#line 812
        next2 = (psiconv_u8 *)tmp___15;
        }
#line 812
        if (! next2) {
#line 813
          res = -2;
#line 814
          goto ERROR2;
        }
        {
#line 816
        tmp___16 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + j * 3) + 2));
#line 816
        next2 = (psiconv_u8 *)tmp___16;
        }
#line 816
        if (! next2) {
#line 817
          res = -2;
#line 818
          goto ERROR2;
        }
        {
#line 820
        res = psiconv_list_add(*encoded_bytes, (void const   *)next1);
        }
#line 820
        if (res) {
#line 821
          goto ERROR2;
        }
        {
#line 822
        res = psiconv_list_add(*encoded_bytes, (void const   *)next2);
        }
#line 822
        if (res) {
#line 823
          goto ERROR2;
        }
        {
#line 824
        res = psiconv_list_add(*encoded_bytes, (void const   *)next3);
        }
#line 824
        if (res) {
#line 825
          goto ERROR2;
        }
#line 807
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 827
      i += len * 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 830
  return (0);
  ERROR2: 
  {
#line 833
  psiconv_list_free(*encoded_bytes);
  }
  ERROR1: 
#line 835
  return (res);
}
}
#line 839 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
int psiconv_write_sketch_section(psiconv_config const   config , psiconv_buffer buf ,
                                 int lev , psiconv_sketch_section const   value ) 
{ 
  int res ;

  {
  {
#line 845
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing sketch section");
  }
#line 846
  if (! value) {
    {
#line 847
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "NULL sketch section");
#line 848
    res = -4;
    }
#line 849
    goto ERROR1;
  }
  {
#line 852
  res = psiconv_write_u16(config, buf, lev + 1, (psiconv_u16 const   )value->displayed_xsize);
  }
#line 852
  if (res) {
#line 853
    goto ERROR1;
  }
  {
#line 854
  res = psiconv_write_u16(config, buf, lev + 1, (psiconv_u16 const   )value->displayed_ysize);
  }
#line 854
  if (res) {
#line 855
    goto ERROR1;
  }
  {
#line 856
  res = psiconv_write_u16(config, buf, lev + 1, (psiconv_u16 const   )value->picture_data_x_offset);
  }
#line 856
  if (res) {
#line 857
    goto ERROR1;
  }
  {
#line 858
  res = psiconv_write_u16(config, buf, lev + 1, (psiconv_u16 const   )value->picture_data_y_offset);
  }
#line 858
  if (res) {
#line 859
    goto ERROR1;
  }
  {
#line 860
  res = psiconv_write_u16(config, buf, lev + 1, (psiconv_u16 const   )value->displayed_size_x_offset);
  }
#line 860
  if (res) {
#line 861
    goto ERROR1;
  }
  {
#line 862
  res = psiconv_write_u16(config, buf, lev + 1, (psiconv_u16 const   )value->displayed_size_y_offset);
  }
#line 862
  if (res) {
#line 863
    goto ERROR1;
  }
  {
#line 864
  res = psiconv_write_u16(config, buf, lev + 1, (psiconv_u16 const   )value->form_xsize);
  }
#line 864
  if (res) {
#line 865
    goto ERROR1;
  }
  {
#line 866
  res = psiconv_write_u16(config, buf, lev + 1, (psiconv_u16 const   )value->form_ysize);
  }
#line 866
  if (res) {
#line 867
    goto ERROR1;
  }
  {
#line 868
  res = psiconv_write_u16(config, buf, lev + 1, (psiconv_u16 const   )0);
  }
#line 868
  if (res) {
#line 869
    goto ERROR1;
  }
  {
#line 870
  res = psiconv_write_paint_data_section(config, buf, lev + 1, (psiconv_paint_data_section const   )value->picture,
                                         0);
  }
#line 870
  if (res) {
#line 871
    goto ERROR1;
  }
  {
#line 872
  res = psiconv_write_u16(config, buf, lev + 1, (psiconv_u16 const   )(value->magnification_x * (float )1000));
  }
#line 872
  if (res) {
#line 873
    goto ERROR1;
  }
  {
#line 874
  res = psiconv_write_u16(config, buf, lev + 1, (psiconv_u16 const   )(value->magnification_y * (float )1000));
  }
#line 874
  if (res) {
#line 875
    goto ERROR1;
  }
  {
#line 876
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )((value->cut_left * (float )12) * (float )value->displayed_xsize));
  }
#line 876
  if (res) {
#line 878
    goto ERROR1;
  }
  {
#line 879
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )((value->cut_right * (float )12) * (float )value->displayed_xsize));
  }
#line 879
  if (res) {
#line 881
    goto ERROR1;
  }
  {
#line 882
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )((value->cut_top * (float )12) * (float )value->displayed_ysize));
  }
#line 882
  if (res) {
#line 884
    goto ERROR1;
  }
  {
#line 885
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )((value->cut_bottom * (float )12) * (float )value->displayed_ysize));
  }
#line 885
  if (res) {

  }
  ERROR1: 
#line 890
  if (res) {
    {
#line 891
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of sketch section failed");
    }
  } else {
    {
#line 893
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of sketch section");
    }
  }
#line 894
  return (res);
}
}
#line 897 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
int psiconv_write_clipart_section(psiconv_config const   config , psiconv_buffer buf ,
                                  int lev , psiconv_clipart_section const   value ) 
{ 
  int res ;

  {
  {
#line 903
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing clipart section");
  }
#line 904
  if (! value) {
    {
#line 905
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "NULL Clipart Section");
#line 906
    res = -4;
    }
#line 907
    goto ERROR;
  }
  {
#line 909
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )268435520);
  }
#line 909
  if (res) {
#line 910
    goto ERROR;
  }
  {
#line 911
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )2);
  }
#line 911
  if (res) {
#line 912
    goto ERROR;
  }
  {
#line 913
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )0);
  }
#line 913
  if (res) {
#line 914
    goto ERROR;
  }
  {
#line 915
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )0);
  }
#line 915
  if (res) {
#line 916
    goto ERROR;
  }
  {
#line 917
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )12);
  }
#line 917
  if (res) {
#line 918
    goto ERROR;
  }
  {
#line 919
  res = psiconv_write_paint_data_section(config, buf, lev + 1, (psiconv_paint_data_section const   )value->picture,
                                         1);
  }
#line 919
  if (res) {

  }
  ERROR: 
#line 923
  if (res) {
    {
#line 924
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of clipart section failed");
    }
  } else {
    {
#line 926
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of clipart section");
    }
  }
#line 927
  return (res);
}
}
#line 930 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
int psiconv_write_jumptable_section(psiconv_config const   config , psiconv_buffer buf ,
                                    int lev , psiconv_jumptable_section const   value ) 
{ 
  int res ;
  int i ;
  psiconv_u32 *offset_ptr ;
  psiconv_u32 tmp ;
  void *tmp___0 ;
  psiconv_u32 tmp___1 ;

  {
  {
#line 937
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing jumptable section");
  }
#line 939
  if (! value) {
    {
#line 940
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "NULL Jumptable Section");
#line 941
    res = -4;
    }
#line 942
    goto ERROR;
  }
  {
#line 944
  tmp = psiconv_list_length(value);
#line 944
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )tmp);
  }
#line 944
  if (res) {
#line 945
    goto ERROR;
  }
#line 946
  i = 0;
  {
#line 946
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 946
    tmp___1 = psiconv_list_length(value);
    }
#line 946
    if (! ((psiconv_u32 )i < tmp___1)) {
#line 946
      goto while_break;
    }
    {
#line 947
    tmp___0 = psiconv_list_get(value, (psiconv_u32 )i);
#line 947
    offset_ptr = (psiconv_u32 *)tmp___0;
    }
#line 947
    if (! offset_ptr) {
      {
#line 948
      psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Massive memory corruption");
#line 949
      res = -2;
      }
#line 950
      goto ERROR;
    }
    {
#line 952
    res = psiconv_write_offset(config, buf, lev + 1, (psiconv_u32 const   )*offset_ptr);
    }
#line 952
    if (res) {
#line 953
      goto ERROR;
    }
#line 946
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  ERROR: 
#line 957
  if (res) {
    {
#line 958
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of jumptable section failed");
    }
  } else {
    {
#line 960
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of jumptable section");
    }
  }
#line 961
  return (res);
}
}
#line 43 "../psiconv/generate.h"
int psiconv_write(psiconv_config const   config , psiconv_buffer *buf , psiconv_file const   value ) ;
#line 100 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_routines.h"
int psiconv_write_page_layout_section(psiconv_config const   config , psiconv_buffer buf ,
                                      int lev , psiconv_page_layout_section const   value ) ;
#line 168
int psiconv_write_texted_section(psiconv_config const   config , psiconv_buffer buf ,
                                 int lev , psiconv_texted_section const   value ,
                                 psiconv_character_layout const   base_char , psiconv_paragraph_layout const   base_para ,
                                 psiconv_buffer *extra_buf ) ;
#line 179
int psiconv_write_word_status_section(psiconv_config const   config , psiconv_buffer buf ,
                                      int lev , psiconv_word_status_section const   value ) ;
#line 182
int psiconv_write_word_styles_section(psiconv_config const   config , psiconv_buffer buf ,
                                      int lev , psiconv_word_styles_section const   value ) ;
#line 194
int psiconv_write_texted_file(psiconv_config const   config , psiconv_buffer buf ,
                              int lev , psiconv_texted_f value ) ;
#line 201
int psiconv_write_mbm_file(psiconv_config const   config , psiconv_buffer buf , int lev ,
                           psiconv_mbm_f value ) ;
#line 204
int psiconv_write_clipart_file(psiconv_config const   config , psiconv_buffer buf ,
                               int lev , psiconv_clipart_f value ) ;
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
static psiconv_ucs2 unicode_paint[10]  = 
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
  {      (psiconv_ucs2 )'P',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'i',      (psiconv_ucs2 )'n', 
        (psiconv_ucs2 )'t',      (psiconv_ucs2 )'.',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'p', 
        (psiconv_ucs2 )'p',      (psiconv_ucs2 )0};
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
static psiconv_ucs2 unicode_texted[11]  = 
#line 33
  {      (psiconv_ucs2 )'T',      (psiconv_ucs2 )'e',      (psiconv_ucs2 )'x',      (psiconv_ucs2 )'t', 
        (psiconv_ucs2 )'E',      (psiconv_ucs2 )'d',      (psiconv_ucs2 )'.',      (psiconv_ucs2 )'a', 
        (psiconv_ucs2 )'p',      (psiconv_ucs2 )'p',      (psiconv_ucs2 )0};
#line 34 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
static psiconv_ucs2 unicode_word[9]  = 
#line 34
  {      (psiconv_ucs2 )'W',      (psiconv_ucs2 )'o',      (psiconv_ucs2 )'r',      (psiconv_ucs2 )'d', 
        (psiconv_ucs2 )'.',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'p',      (psiconv_ucs2 )'p', 
        (psiconv_ucs2 )0};
#line 37 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
int psiconv_write(psiconv_config const   config , psiconv_buffer *buf , psiconv_file const   value ) 
{ 
  int res ;
  int lev ;
  psiconv_buffer tmp ;

  {
#line 41
  lev = 0;
#line 43
  if (! value) {
    {
#line 44
    psiconv_error((psiconv_config )config, 0, (psiconv_u32 )0, "Can\'t parse to an empty buffer!");
    }
#line 45
    return (-1);
  }
  {
#line 47
  tmp = psiconv_buffer_new();
#line 47
  *buf = tmp;
  }
#line 47
  if (! tmp) {
    {
#line 48
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 49
    return (-2);
  }
#line 52
  if ((unsigned int )value->type == 1U) {
    {
#line 53
    res = psiconv_write_header_section(config, *buf, lev + 1, (psiconv_u32 )268435511,
                                       (psiconv_u32 )268435565, (psiconv_u32 )268435583);
    }
#line 53
    if (res) {
#line 56
      goto ERROR;
    }
    {
#line 57
    res = psiconv_write_word_file(config, *buf, lev + 1, (psiconv_word_f const   )((psiconv_word_f )value->file));
    }
#line 57
    if (res) {
#line 58
      goto ERROR;
    }
  } else
#line 59
  if ((unsigned int )value->type == 2U) {
    {
#line 60
    res = psiconv_write_header_section(config, *buf, lev + 1, (psiconv_u32 )268435511,
                                       (psiconv_u32 )268435565, (psiconv_u32 )268435589);
    }
#line 60
    if (res) {
#line 63
      goto ERROR;
    }
    {
#line 64
    res = psiconv_write_texted_file(config, *buf, lev + 1, (psiconv_texted_f )value->file);
    }
#line 64
    if (res) {
#line 66
      goto ERROR;
    }
  } else
#line 67
  if ((unsigned int )value->type == 4U) {
    {
#line 68
    res = psiconv_write_header_section(config, *buf, lev + 1, (psiconv_u32 )268435511,
                                       (psiconv_u32 )268435565, (psiconv_u32 )268435581);
    }
#line 68
    if (res) {
#line 71
      goto ERROR;
    }
    {
#line 72
    res = psiconv_write_sketch_file(config, *buf, lev + 1, (psiconv_sketch_f const   )((psiconv_sketch_f )value->file));
    }
#line 72
    if (res) {
#line 74
      goto ERROR;
    }
  } else
#line 75
  if ((unsigned int )value->type == 3U) {
    {
#line 76
    res = psiconv_write_header_section(config, *buf, lev + 1, (psiconv_u32 )268435511,
                                       (psiconv_u32 )268435522, (psiconv_u32 )0);
    }
#line 76
    if (res) {
#line 79
      goto ERROR;
    }
    {
#line 80
    res = psiconv_write_mbm_file(config, *buf, lev + 1, (psiconv_mbm_f )value->file);
    }
#line 80
    if (res) {
#line 82
      goto ERROR;
    }
  } else
#line 83
  if ((unsigned int )value->type == 5U) {
    {
#line 85
    res = psiconv_write_clipart_file(config, *buf, lev + 1, (psiconv_clipart_f )value->file);
    }
#line 85
    if (res) {
#line 87
      goto ERROR;
    }
  } else {
    {
#line 89
    psiconv_error((psiconv_config )config, 0, (psiconv_u32 )0, "Unknown or unsupported file type");
#line 90
    res = -4;
    }
#line 91
    goto ERROR;
  }
  {
#line 93
  res = psiconv_buffer_resolve(*buf);
  }
#line 93
  if (res) {
    {
#line 94
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Internal error resolving buffer references");
    }
#line 95
    goto ERROR;
  }
#line 97
  return (0);
  ERROR: 
  {
#line 100
  psiconv_buffer_free(*buf);
  }
#line 101
  return (res);
}
}
#line 104 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
int psiconv_write_texted_file(psiconv_config const   config , psiconv_buffer buf ,
                              int lev , psiconv_texted_f value ) 
{ 
  psiconv_character_layout base_char ;
  psiconv_paragraph_layout base_para ;
  int res ;
  psiconv_section_table_section section_table ;
  psiconv_section_table_entry entry ;
  psiconv_u32 section_table_id ;
  psiconv_buffer buf_texted ;
  void *tmp ;

  {
  {
#line 115
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing texted file");
  }
#line 116
  if (! value) {
    {
#line 117
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null TextEd file");
#line 118
    res = -4;
    }
#line 119
    goto ERROR1;
  }
  {
#line 122
  section_table = psiconv_list_new(sizeof(*entry));
  }
#line 122
  if (! section_table) {
    {
#line 123
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 124
    res = -2;
    }
#line 125
    goto ERROR1;
  }
  {
#line 128
  tmp = malloc(sizeof(*entry));
#line 128
  entry = (psiconv_section_table_entry )tmp;
  }
#line 128
  if (! entry) {
    {
#line 129
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 130
    res = -2;
    }
#line 131
    goto ERROR2;
  }
  {
#line 134
  base_char = psiconv_basic_character_layout();
  }
#line 134
  if (! base_char) {
    {
#line 135
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 136
    res = -2;
    }
#line 137
    goto ERROR3;
  }
  {
#line 139
  base_para = psiconv_basic_paragraph_layout();
  }
#line 139
  if (! base_para) {
    {
#line 140
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 141
    res = -2;
    }
#line 142
    goto ERROR4;
  }
  {
#line 145
  section_table_id = psiconv_buffer_unique_id();
#line 146
  res = psiconv_write_offset(config, buf, lev + 1, (psiconv_u32 const   )section_table_id);
  }
#line 146
  if (res) {
    {
#line 147
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 148
    goto ERROR5;
  }
  {
#line 151
  entry->id = (psiconv_u32 )268435593;
#line 152
  entry->offset = psiconv_buffer_unique_id();
#line 153
  res = psiconv_list_add(section_table, (void const   *)entry);
  }
#line 153
  if (res) {
    {
#line 154
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 155
    goto ERROR5;
  }
  {
#line 157
  res = psiconv_buffer_add_target(buf, (int )entry->offset);
  }
#line 157
  if (res) {
    {
#line 158
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 159
    goto ERROR5;
  }
  {
#line 161
  res = psiconv_write_application_id_section(config, buf, lev + 1, (psiconv_u32 )268435589,
                                             (psiconv_string_t const   )(unicode_texted));
  }
#line 161
  if (res) {
#line 163
    goto ERROR5;
  }
  {
#line 165
  entry->id = (psiconv_u32 )268435717;
#line 166
  entry->offset = psiconv_buffer_unique_id();
#line 167
  res = psiconv_list_add(section_table, (void const   *)entry);
  }
#line 167
  if (res) {
    {
#line 168
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 169
    goto ERROR5;
  }
  {
#line 171
  res = psiconv_buffer_add_target(buf, (int )entry->offset);
  }
#line 171
  if (res) {
    {
#line 172
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 173
    goto ERROR5;
  }
  {
#line 175
  res = psiconv_write_page_layout_section(config, buf, lev + 1, (psiconv_page_layout_section const   )value->page_sec);
  }
#line 175
  if (res) {
#line 176
    goto ERROR5;
  }
  {
#line 178
  entry->id = (psiconv_u32 )268435589;
#line 179
  entry->offset = psiconv_buffer_unique_id();
#line 180
  res = psiconv_list_add(section_table, (void const   *)entry);
  }
#line 180
  if (res) {
    {
#line 181
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 182
    goto ERROR5;
  }
  {
#line 184
  res = psiconv_buffer_add_target(buf, (int )entry->offset);
  }
#line 184
  if (res) {
    {
#line 185
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 186
    goto ERROR5;
  }
  {
#line 188
  res = psiconv_write_texted_section(config, buf, lev + 1, (psiconv_texted_section const   )value->texted_sec,
                                     (psiconv_character_layout const   )base_char,
                                     (psiconv_paragraph_layout const   )base_para,
                                     & buf_texted);
  }
#line 188
  if (res) {
#line 190
    goto ERROR5;
  }
  {
#line 192
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )buf_texted);
  }
#line 192
  if (res) {
    {
#line 193
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 194
    goto ERROR6;
  }
  {
#line 197
  res = psiconv_buffer_add_target(buf, (int )section_table_id);
  }
#line 197
  if (res) {
    {
#line 198
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 199
    goto ERROR6;
  }
  {
#line 202
  res = psiconv_write_section_table_section(config, buf, lev + 1, (psiconv_section_table_section const   )section_table);
  }
  ERROR6: 
  {
#line 205
  psiconv_buffer_free(buf_texted);
  }
  ERROR5: 
  {
#line 207
  psiconv_free_paragraph_layout(base_para);
  }
  ERROR4: 
  {
#line 209
  psiconv_free_character_layout(base_char);
  }
  ERROR3: 
  {
#line 211
  free((void *)entry);
  }
  ERROR2: 
  {
#line 213
  psiconv_list_free(section_table);
  }
  ERROR1: 
#line 215
  if (res) {
    {
#line 216
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of texted file failed");
    }
  } else {
    {
#line 218
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of texted file");
    }
  }
#line 219
  return (res);
}
}
#line 222 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
int psiconv_write_word_file(psiconv_config const   config , psiconv_buffer buf , int lev ,
                            psiconv_word_f const   value ) 
{ 
  int res ;
  psiconv_section_table_section section_table ;
  psiconv_section_table_entry entry ;
  psiconv_u32 section_table_id ;
  void *tmp ;

  {
  {
#line 230
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing word file");
  }
#line 231
  if (! value) {
    {
#line 232
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null Word file");
#line 233
    res = -4;
    }
#line 234
    goto ERROR1;
  }
  {
#line 237
  section_table = psiconv_list_new(sizeof(*entry));
  }
#line 237
  if (! section_table) {
    {
#line 238
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 239
    res = -2;
    }
#line 240
    goto ERROR1;
  }
  {
#line 243
  tmp = malloc(sizeof(*entry));
#line 243
  entry = (psiconv_section_table_entry )tmp;
  }
#line 243
  if (! entry) {
    {
#line 244
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 245
    res = -2;
    }
#line 246
    goto ERROR2;
  }
  {
#line 249
  section_table_id = psiconv_buffer_unique_id();
#line 250
  res = psiconv_write_offset(config, buf, lev + 1, (psiconv_u32 const   )section_table_id);
  }
#line 250
  if (res) {
#line 251
    goto ERROR3;
  }
  {
#line 253
  entry->id = (psiconv_u32 )268435593;
#line 254
  entry->offset = psiconv_buffer_unique_id();
#line 255
  res = psiconv_list_add(section_table, (void const   *)entry);
  }
#line 255
  if (res) {
    {
#line 256
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 257
    goto ERROR3;
  }
  {
#line 259
  res = psiconv_buffer_add_target(buf, (int )entry->offset);
  }
#line 259
  if (res) {
    {
#line 260
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 261
    goto ERROR3;
  }
  {
#line 263
  res = psiconv_write_application_id_section(config, buf, lev + 1, (psiconv_u32 )268435583,
                                             (psiconv_string_t const   )(unicode_word));
  }
#line 263
  if (res) {
#line 265
    goto ERROR3;
  }
  {
#line 267
  entry->id = (psiconv_u32 )268436035;
#line 268
  entry->offset = psiconv_buffer_unique_id();
#line 269
  res = psiconv_list_add(section_table, (void const   *)entry);
  }
#line 269
  if (res) {
    {
#line 270
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 271
    goto ERROR3;
  }
  {
#line 273
  res = psiconv_buffer_add_target(buf, (int )entry->offset);
  }
#line 273
  if (res) {
    {
#line 274
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 275
    goto ERROR3;
  }
  {
#line 277
  res = psiconv_write_word_status_section(config, buf, lev + 1, (psiconv_word_status_section const   )value->status_sec);
  }
#line 277
  if (res) {
#line 278
    goto ERROR3;
  }
  {
#line 280
  entry->id = (psiconv_u32 )268435717;
#line 281
  entry->offset = psiconv_buffer_unique_id();
#line 282
  res = psiconv_list_add(section_table, (void const   *)entry);
  }
#line 282
  if (res) {
    {
#line 283
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 284
    goto ERROR3;
  }
  {
#line 286
  res = psiconv_buffer_add_target(buf, (int )entry->offset);
  }
#line 286
  if (res) {
    {
#line 287
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 288
    goto ERROR3;
  }
  {
#line 290
  res = psiconv_write_page_layout_section(config, buf, lev + 1, (psiconv_page_layout_section const   )value->page_sec);
  }
#line 290
  if (res) {
#line 291
    goto ERROR3;
  }
  {
#line 293
  entry->id = (psiconv_u32 )268435716;
#line 294
  entry->offset = psiconv_buffer_unique_id();
#line 295
  res = psiconv_list_add(section_table, (void const   *)entry);
  }
#line 295
  if (res) {
    {
#line 296
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 297
    goto ERROR3;
  }
  {
#line 299
  res = psiconv_buffer_add_target(buf, (int )entry->offset);
  }
#line 299
  if (res) {
    {
#line 300
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 301
    goto ERROR3;
  }
  {
#line 303
  res = psiconv_write_word_styles_section(config, buf, lev + 1, (psiconv_word_styles_section const   )value->styles_sec);
  }
#line 303
  if (res) {
#line 304
    goto ERROR3;
  }
  {
#line 306
  entry->id = (psiconv_u32 )268435718;
#line 307
  entry->offset = psiconv_buffer_unique_id();
#line 308
  res = psiconv_list_add(section_table, (void const   *)entry);
  }
#line 308
  if (res) {
    {
#line 309
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 310
    goto ERROR3;
  }
  {
#line 312
  res = psiconv_buffer_add_target(buf, (int )entry->offset);
  }
#line 312
  if (res) {
    {
#line 313
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 314
    goto ERROR3;
  }
  {
#line 316
  res = psiconv_write_text_section(config, buf, lev + 1, (psiconv_text_and_layout const   )value->paragraphs);
  }
#line 316
  if (res) {
#line 317
    goto ERROR3;
  }
  {
#line 319
  entry->id = (psiconv_u32 )268435779;
#line 320
  entry->offset = psiconv_buffer_unique_id();
#line 321
  res = psiconv_list_add(section_table, (void const   *)entry);
  }
#line 321
  if (res) {
    {
#line 322
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 323
    goto ERROR3;
  }
  {
#line 325
  res = psiconv_buffer_add_target(buf, (int )entry->offset);
  }
#line 325
  if (res) {
    {
#line 326
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 327
    goto ERROR3;
  }
  {
#line 329
  res = psiconv_write_styled_layout_section(config, buf, lev + 1, (psiconv_text_and_layout const   )value->paragraphs,
                                            (psiconv_word_styles_section const   )value->styles_sec);
  }
#line 329
  if (res) {
#line 331
    goto ERROR3;
  }
  {
#line 333
  res = psiconv_buffer_add_target(buf, (int )section_table_id);
  }
#line 333
  if (res) {
    {
#line 334
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 335
    goto ERROR3;
  }
  {
#line 338
  res = psiconv_write_section_table_section(config, buf, lev + 1, (psiconv_section_table_section const   )section_table);
  }
  ERROR3: 
  {
#line 341
  free((void *)entry);
  }
  ERROR2: 
  {
#line 343
  psiconv_list_free(section_table);
  }
  ERROR1: 
#line 345
  if (res) {
    {
#line 346
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of word file failed");
    }
  } else {
    {
#line 348
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of word file");
    }
  }
#line 349
  return (res);
}
}
#line 352 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
int psiconv_write_sketch_file(psiconv_config const   config , psiconv_buffer buf ,
                              int lev , psiconv_sketch_f const   value ) 
{ 
  int res ;
  psiconv_section_table_section section_table ;
  psiconv_section_table_entry entry ;
  psiconv_u32 section_table_id ;
  void *tmp ;

  {
  {
#line 360
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing sketch file");
  }
#line 361
  if (! value) {
    {
#line 362
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null Sketch file");
#line 363
    res = -4;
    }
#line 364
    goto ERROR1;
  }
  {
#line 367
  section_table = psiconv_list_new(sizeof(*entry));
  }
#line 367
  if (! section_table) {
    {
#line 368
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 369
    res = -2;
    }
#line 370
    goto ERROR1;
  }
  {
#line 373
  tmp = malloc(sizeof(*entry));
#line 373
  entry = (psiconv_section_table_entry )tmp;
  }
#line 373
  if (! entry) {
    {
#line 374
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 375
    res = -2;
    }
#line 376
    goto ERROR2;
  }
  {
#line 379
  section_table_id = psiconv_buffer_unique_id();
#line 380
  res = psiconv_write_offset(config, buf, lev + 1, (psiconv_u32 const   )section_table_id);
  }
#line 380
  if (res) {
#line 381
    goto ERROR3;
  }
  {
#line 383
  entry->id = (psiconv_u32 )268435593;
#line 384
  entry->offset = psiconv_buffer_unique_id();
#line 385
  res = psiconv_list_add(section_table, (void const   *)entry);
  }
#line 385
  if (res) {
    {
#line 386
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 387
    goto ERROR3;
  }
  {
#line 389
  res = psiconv_buffer_add_target(buf, (int )entry->offset);
  }
#line 389
  if (res) {
    {
#line 390
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 391
    goto ERROR3;
  }
  {
#line 393
  res = psiconv_write_application_id_section(config, buf, lev + 1, (psiconv_u32 )268435581,
                                             (psiconv_string_t const   )(unicode_paint));
  }
#line 393
  if (res) {
#line 395
    goto ERROR3;
  }
  {
#line 397
  entry->id = (psiconv_u32 )268435581;
#line 398
  entry->offset = psiconv_buffer_unique_id();
#line 399
  res = psiconv_list_add(section_table, (void const   *)entry);
  }
#line 399
  if (res) {
    {
#line 400
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 401
    goto ERROR3;
  }
  {
#line 403
  res = psiconv_buffer_add_target(buf, (int )entry->offset);
  }
#line 403
  if (res) {
    {
#line 404
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 405
    goto ERROR3;
  }
  {
#line 407
  res = psiconv_write_sketch_section(config, buf, lev + 1, (psiconv_sketch_section const   )value->sketch_sec);
  }
#line 407
  if (res) {
#line 408
    goto ERROR3;
  }
  {
#line 410
  res = psiconv_buffer_add_target(buf, (int )section_table_id);
  }
#line 410
  if (res) {
    {
#line 411
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 412
    goto ERROR3;
  }
  {
#line 414
  res = psiconv_write_section_table_section(config, buf, lev + 1, (psiconv_section_table_section const   )section_table);
  }
  ERROR3: 
  {
#line 417
  free((void *)entry);
  }
  ERROR2: 
  {
#line 419
  psiconv_list_free(section_table);
  }
  ERROR1: 
#line 421
  if (res) {
    {
#line 422
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of sketch file failed");
    }
  } else {
    {
#line 424
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of sketch file");
    }
  }
#line 425
  return (res);
}
}
#line 428 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
int psiconv_write_mbm_file(psiconv_config const   config , psiconv_buffer buf , int lev ,
                           psiconv_mbm_f value ) 
{ 
  int res ;
  int i ;
  psiconv_jumptable_section jumptable ;
  psiconv_u32 *entry ;
  psiconv_u32 id ;
  psiconv_u32 table_id ;
  psiconv_paint_data_section section ;
  void *tmp ;
  psiconv_u32 tmp___0 ;

  {
  {
#line 436
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing mbm file");
  }
#line 437
  if (! value) {
    {
#line 438
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null MBM file");
#line 439
    res = -4;
    }
#line 440
    goto ERROR1;
  }
  {
#line 443
  jumptable = psiconv_list_new(sizeof(*entry));
  }
#line 443
  if (! jumptable) {
    {
#line 444
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 445
    res = -2;
    }
#line 446
    goto ERROR1;
  }
  {
#line 449
  table_id = psiconv_buffer_unique_id();
#line 450
  res = psiconv_buffer_add_reference(buf, (int )table_id);
  }
#line 450
  if (res) {
    {
#line 451
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 452
    goto ERROR2;
  }
#line 455
  i = 0;
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 455
    tmp___0 = psiconv_list_length((psiconv_list const   )value->sections);
    }
#line 455
    if (! ((psiconv_u32 )i < tmp___0)) {
#line 455
      goto while_break;
    }
    {
#line 456
    tmp = psiconv_list_get((psiconv_list const   )value->sections, (psiconv_u32 )i);
#line 456
    section = (psiconv_paint_data_section )tmp;
    }
#line 456
    if (! section) {
      {
#line 457
      psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Data structure corruption");
#line 458
      res = -2;
      }
#line 459
      goto ERROR2;
    }
    {
#line 461
    id = psiconv_buffer_unique_id();
#line 462
    res = psiconv_list_add(jumptable, (void const   *)(& id));
    }
#line 462
    if (res) {
      {
#line 463
      psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
      }
#line 464
      goto ERROR2;
    }
    {
#line 466
    res = psiconv_buffer_add_target(buf, (int )id);
    }
#line 466
    if (res) {
      {
#line 467
      psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
      }
#line 468
      goto ERROR2;
    }
    {
#line 470
    res = psiconv_write_paint_data_section(config, buf, lev + 1, (psiconv_paint_data_section const   )section,
                                           0);
    }
#line 470
    if (res) {
#line 471
      goto ERROR2;
    }
#line 455
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 474
  res = psiconv_buffer_add_target(buf, (int )table_id);
  }
#line 474
  if (res) {
    {
#line 475
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 476
    goto ERROR2;
  }
  {
#line 478
  res = psiconv_write_jumptable_section(config, buf, lev + 1, (psiconv_jumptable_section const   )jumptable);
  }
#line 478
  if (res) {

  }
  ERROR2: 
  {
#line 483
  psiconv_list_free(jumptable);
  }
  ERROR1: 
#line 485
  if (res) {
    {
#line 486
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of mbm file failed");
    }
  } else {
    {
#line 488
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of mbm file");
    }
  }
#line 489
  return (res);
}
}
#line 493 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
int psiconv_write_clipart_file(psiconv_config const   config , psiconv_buffer buf ,
                               int lev , psiconv_clipart_f value ) 
{ 
  int res ;
  int i ;
  psiconv_jumptable_section jumptable ;
  psiconv_u32 *entry ;
  psiconv_u32 id ;
  psiconv_clipart_section section ;
  psiconv_buffer sec_buf ;
  void *tmp ;
  psiconv_u32 tmp___0 ;

  {
  {
#line 502
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing clipart file");
  }
#line 503
  if (! value) {
    {
#line 504
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null Clipart file");
#line 505
    res = -4;
    }
#line 506
    goto ERROR1;
  }
  {
#line 509
  jumptable = psiconv_list_new(sizeof(*entry));
  }
#line 509
  if (! jumptable) {
    {
#line 510
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 511
    res = -2;
    }
#line 512
    goto ERROR1;
  }
  {
#line 515
  sec_buf = psiconv_buffer_new();
  }
#line 515
  if (! sec_buf) {
    {
#line 516
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 517
    res = -2;
    }
#line 518
    goto ERROR2;
  }
  {
#line 521
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )268435521);
  }
#line 521
  if (res) {
#line 522
    goto ERROR3;
  }
#line 524
  i = 0;
  {
#line 524
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 524
    tmp___0 = psiconv_list_length((psiconv_list const   )value->sections);
    }
#line 524
    if (! ((psiconv_u32 )i < tmp___0)) {
#line 524
      goto while_break;
    }
    {
#line 525
    tmp = psiconv_list_get((psiconv_list const   )value->sections, (psiconv_u32 )i);
#line 525
    section = (psiconv_clipart_section )tmp;
    }
#line 525
    if (! section) {
      {
#line 526
      psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Data structure corruption");
#line 527
      res = -2;
      }
#line 528
      goto ERROR3;
    }
    {
#line 530
    id = psiconv_buffer_unique_id();
#line 531
    res = psiconv_list_add(jumptable, (void const   *)(& id));
    }
#line 531
    if (res) {
      {
#line 532
      psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
      }
#line 533
      goto ERROR3;
    }
    {
#line 535
    res = psiconv_buffer_add_target(sec_buf, (int )id);
    }
#line 535
    if (res) {
      {
#line 536
      psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
      }
#line 537
      goto ERROR3;
    }
    {
#line 539
    res = psiconv_write_clipart_section(config, sec_buf, lev + 1, (psiconv_clipart_section const   )section);
    }
#line 539
    if (res) {
#line 540
      goto ERROR3;
    }
#line 524
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 543
  res = psiconv_write_jumptable_section(config, buf, lev + 1, (psiconv_jumptable_section const   )jumptable);
  }
#line 543
  if (res) {
#line 544
    goto ERROR3;
  }
  {
#line 546
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )sec_buf);
  }
#line 546
  if (res) {
    {
#line 547
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 548
    goto ERROR3;
  }
  ERROR3: 
  {
#line 553
  psiconv_buffer_free(sec_buf);
  }
  ERROR2: 
  {
#line 555
  psiconv_list_free(jumptable);
  }
  ERROR1: 
#line 557
  if (res) {
    {
#line 558
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of clipart file failed");
    }
  } else {
    {
#line 560
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of clipart file");
    }
  }
#line 561
  return (res);
}
}
#line 58 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/unicode.h"
psiconv_ucs2 *psiconv_unicode_strdup(psiconv_ucs2 const   *input ) ;
#line 61
int psiconv_unicode_strcmp(psiconv_ucs2 const   *str1 , psiconv_ucs2 const   *str2 ) ;
#line 70
psiconv_ucs2 *psiconv_unicode_strstr(psiconv_ucs2 const   *haystack , psiconv_ucs2 const   *needle ) ;
#line 37 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/unicode.c"
psiconv_ucs2 table_cp1252[256]  = 
#line 37 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/unicode.c"
  {      (psiconv_ucs2 )0,      (psiconv_ucs2 )0,      (psiconv_ucs2 )0,      (psiconv_ucs2 )0, 
        (psiconv_ucs2 )0,      (psiconv_ucs2 )0,      (psiconv_ucs2 )6,      (psiconv_ucs2 )7, 
        (psiconv_ucs2 )8,      (psiconv_ucs2 )9,      (psiconv_ucs2 )10,      (psiconv_ucs2 )11, 
        (psiconv_ucs2 )12,      (psiconv_ucs2 )13,      (psiconv_ucs2 )14,      (psiconv_ucs2 )15, 
        (psiconv_ucs2 )160,      (psiconv_ucs2 )0,      (psiconv_ucs2 )0,      (psiconv_ucs2 )0, 
        (psiconv_ucs2 )0,      (psiconv_ucs2 )0,      (psiconv_ucs2 )0,      (psiconv_ucs2 )0, 
        (psiconv_ucs2 )0,      (psiconv_ucs2 )0,      (psiconv_ucs2 )0,      (psiconv_ucs2 )0, 
        (psiconv_ucs2 )0,      (psiconv_ucs2 )0,      (psiconv_ucs2 )0,      (psiconv_ucs2 )0, 
        (psiconv_ucs2 )32,      (psiconv_ucs2 )33,      (psiconv_ucs2 )34,      (psiconv_ucs2 )35, 
        (psiconv_ucs2 )36,      (psiconv_ucs2 )37,      (psiconv_ucs2 )38,      (psiconv_ucs2 )39, 
        (psiconv_ucs2 )40,      (psiconv_ucs2 )41,      (psiconv_ucs2 )42,      (psiconv_ucs2 )43, 
        (psiconv_ucs2 )44,      (psiconv_ucs2 )45,      (psiconv_ucs2 )46,      (psiconv_ucs2 )47, 
        (psiconv_ucs2 )48,      (psiconv_ucs2 )49,      (psiconv_ucs2 )50,      (psiconv_ucs2 )51, 
        (psiconv_ucs2 )52,      (psiconv_ucs2 )53,      (psiconv_ucs2 )54,      (psiconv_ucs2 )55, 
        (psiconv_ucs2 )56,      (psiconv_ucs2 )57,      (psiconv_ucs2 )58,      (psiconv_ucs2 )59, 
        (psiconv_ucs2 )60,      (psiconv_ucs2 )61,      (psiconv_ucs2 )62,      (psiconv_ucs2 )63, 
        (psiconv_ucs2 )64,      (psiconv_ucs2 )65,      (psiconv_ucs2 )66,      (psiconv_ucs2 )67, 
        (psiconv_ucs2 )68,      (psiconv_ucs2 )69,      (psiconv_ucs2 )70,      (psiconv_ucs2 )71, 
        (psiconv_ucs2 )72,      (psiconv_ucs2 )73,      (psiconv_ucs2 )74,      (psiconv_ucs2 )75, 
        (psiconv_ucs2 )76,      (psiconv_ucs2 )77,      (psiconv_ucs2 )78,      (psiconv_ucs2 )79, 
        (psiconv_ucs2 )80,      (psiconv_ucs2 )81,      (psiconv_ucs2 )82,      (psiconv_ucs2 )83, 
        (psiconv_ucs2 )84,      (psiconv_ucs2 )85,      (psiconv_ucs2 )86,      (psiconv_ucs2 )87, 
        (psiconv_ucs2 )88,      (psiconv_ucs2 )89,      (psiconv_ucs2 )90,      (psiconv_ucs2 )91, 
        (psiconv_ucs2 )92,      (psiconv_ucs2 )93,      (psiconv_ucs2 )94,      (psiconv_ucs2 )95, 
        (psiconv_ucs2 )96,      (psiconv_ucs2 )97,      (psiconv_ucs2 )98,      (psiconv_ucs2 )99, 
        (psiconv_ucs2 )100,      (psiconv_ucs2 )101,      (psiconv_ucs2 )102,      (psiconv_ucs2 )103, 
        (psiconv_ucs2 )104,      (psiconv_ucs2 )105,      (psiconv_ucs2 )106,      (psiconv_ucs2 )107, 
        (psiconv_ucs2 )108,      (psiconv_ucs2 )109,      (psiconv_ucs2 )110,      (psiconv_ucs2 )111, 
        (psiconv_ucs2 )112,      (psiconv_ucs2 )113,      (psiconv_ucs2 )114,      (psiconv_ucs2 )115, 
        (psiconv_ucs2 )116,      (psiconv_ucs2 )117,      (psiconv_ucs2 )118,      (psiconv_ucs2 )119, 
        (psiconv_ucs2 )120,      (psiconv_ucs2 )121,      (psiconv_ucs2 )122,      (psiconv_ucs2 )123, 
        (psiconv_ucs2 )124,      (psiconv_ucs2 )125,      (psiconv_ucs2 )126,      (psiconv_ucs2 )0, 
        (psiconv_ucs2 )8364,      (psiconv_ucs2 )0,      (psiconv_ucs2 )8218,      (psiconv_ucs2 )402, 
        (psiconv_ucs2 )8222,      (psiconv_ucs2 )8230,      (psiconv_ucs2 )8224,      (psiconv_ucs2 )8225, 
        (psiconv_ucs2 )710,      (psiconv_ucs2 )8240,      (psiconv_ucs2 )352,      (psiconv_ucs2 )8249, 
        (psiconv_ucs2 )338,      (psiconv_ucs2 )0,      (psiconv_ucs2 )381,      (psiconv_ucs2 )0, 
        (psiconv_ucs2 )0,      (psiconv_ucs2 )8216,      (psiconv_ucs2 )8217,      (psiconv_ucs2 )8220, 
        (psiconv_ucs2 )8221,      (psiconv_ucs2 )8226,      (psiconv_ucs2 )8211,      (psiconv_ucs2 )8212, 
        (psiconv_ucs2 )732,      (psiconv_ucs2 )8482,      (psiconv_ucs2 )353,      (psiconv_ucs2 )8250, 
        (psiconv_ucs2 )339,      (psiconv_ucs2 )0,      (psiconv_ucs2 )382,      (psiconv_ucs2 )376, 
        (psiconv_ucs2 )0,      (psiconv_ucs2 )161,      (psiconv_ucs2 )162,      (psiconv_ucs2 )163, 
        (psiconv_ucs2 )164,      (psiconv_ucs2 )165,      (psiconv_ucs2 )166,      (psiconv_ucs2 )167, 
        (psiconv_ucs2 )168,      (psiconv_ucs2 )169,      (psiconv_ucs2 )170,      (psiconv_ucs2 )171, 
        (psiconv_ucs2 )172,      (psiconv_ucs2 )173,      (psiconv_ucs2 )174,      (psiconv_ucs2 )175, 
        (psiconv_ucs2 )176,      (psiconv_ucs2 )177,      (psiconv_ucs2 )178,      (psiconv_ucs2 )179, 
        (psiconv_ucs2 )180,      (psiconv_ucs2 )181,      (psiconv_ucs2 )182,      (psiconv_ucs2 )183, 
        (psiconv_ucs2 )184,      (psiconv_ucs2 )185,      (psiconv_ucs2 )186,      (psiconv_ucs2 )187, 
        (psiconv_ucs2 )188,      (psiconv_ucs2 )189,      (psiconv_ucs2 )190,      (psiconv_ucs2 )191, 
        (psiconv_ucs2 )192,      (psiconv_ucs2 )193,      (psiconv_ucs2 )194,      (psiconv_ucs2 )195, 
        (psiconv_ucs2 )196,      (psiconv_ucs2 )197,      (psiconv_ucs2 )198,      (psiconv_ucs2 )199, 
        (psiconv_ucs2 )200,      (psiconv_ucs2 )201,      (psiconv_ucs2 )202,      (psiconv_ucs2 )203, 
        (psiconv_ucs2 )204,      (psiconv_ucs2 )205,      (psiconv_ucs2 )206,      (psiconv_ucs2 )207, 
        (psiconv_ucs2 )208,      (psiconv_ucs2 )209,      (psiconv_ucs2 )210,      (psiconv_ucs2 )211, 
        (psiconv_ucs2 )212,      (psiconv_ucs2 )213,      (psiconv_ucs2 )214,      (psiconv_ucs2 )215, 
        (psiconv_ucs2 )216,      (psiconv_ucs2 )217,      (psiconv_ucs2 )218,      (psiconv_ucs2 )219, 
        (psiconv_ucs2 )220,      (psiconv_ucs2 )221,      (psiconv_ucs2 )222,      (psiconv_ucs2 )223, 
        (psiconv_ucs2 )224,      (psiconv_ucs2 )225,      (psiconv_ucs2 )226,      (psiconv_ucs2 )227, 
        (psiconv_ucs2 )228,      (psiconv_ucs2 )229,      (psiconv_ucs2 )230,      (psiconv_ucs2 )231, 
        (psiconv_ucs2 )232,      (psiconv_ucs2 )233,      (psiconv_ucs2 )234,      (psiconv_ucs2 )235, 
        (psiconv_ucs2 )236,      (psiconv_ucs2 )237,      (psiconv_ucs2 )238,      (psiconv_ucs2 )239, 
        (psiconv_ucs2 )240,      (psiconv_ucs2 )241,      (psiconv_ucs2 )242,      (psiconv_ucs2 )243, 
        (psiconv_ucs2 )244,      (psiconv_ucs2 )245,      (psiconv_ucs2 )246,      (psiconv_ucs2 )247, 
        (psiconv_ucs2 )248,      (psiconv_ucs2 )249,      (psiconv_ucs2 )250,      (psiconv_ucs2 )251, 
        (psiconv_ucs2 )252,      (psiconv_ucs2 )253,      (psiconv_ucs2 )254,      (psiconv_ucs2 )255};
#line 76 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/unicode.c"
extern int psiconv_unicode_select_characterset(psiconv_config const   config , int charset ) 
{ 


  {
  {
#line 80
  if (charset == 0) {
#line 80
    goto case_0;
  }
#line 82
  if (charset == 1) {
#line 82
    goto case_1;
  }
#line 86
  goto switch_default;
  case_0: /* CIL Label */ 
#line 80
  config->unicode = (psiconv_bool_t )1;
#line 81
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 82
  config->unicode = (psiconv_bool_t )0;
#line 83
  memcpy((void */* __restrict  */)(config->unicode_table), (void const   */* __restrict  */)(table_cp1252),
         sizeof(psiconv_ucs2 ) * 256UL);
  }
#line 85
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 86
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 88
  return (0);
}
}
#line 92 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/unicode.c"
psiconv_ucs2 psiconv_unicode_read_char(psiconv_config const   config , psiconv_buffer buf ,
                                       int lev , psiconv_u32 off , int *length , int *status ) 
{ 
  psiconv_u8 char1 ;
  psiconv_u8 char2 ;
  psiconv_u8 char3 ;
  psiconv_ucs2 result ;
  int res ;
  int len ;

  {
  {
#line 98
  result = (psiconv_ucs2 )0;
#line 100
  len = 0;
#line 102
  char1 = psiconv_read_u8(config, (psiconv_buffer const   )buf, lev, off + (psiconv_u32 )len,
                          & res);
  }
#line 103
  if (res) {
#line 104
    goto ERROR;
  }
#line 105
  len ++;
#line 107
  if (config->unicode) {
#line 108
    if ((int )char1 >= 240) {
#line 109
      res = 3;
#line 110
      goto ERROR;
    } else
#line 111
    if ((int )char1 < 128) {
#line 112
      result = (psiconv_ucs2 )char1;
    } else {
      {
#line 114
      char2 = psiconv_read_u8(config, (psiconv_buffer const   )buf, lev, off + (psiconv_u32 )len,
                              & res);
#line 115
      len ++;
      }
#line 116
      if (((int )char2 & 192) != 128) {
#line 117
        res = 3;
#line 118
        goto ERROR;
      }
#line 120
      if ((int )char1 < 224) {
#line 121
        result = (psiconv_ucs2 )((((int )char1 & 31) << 6) | ((int )char2 & 63));
      } else {
        {
#line 123
        char3 = psiconv_read_u8(config, (psiconv_buffer const   )buf, lev, off + (psiconv_u32 )len,
                                & res);
#line 124
        len ++;
        }
#line 125
        if (((int )char3 & 192) != 128) {
#line 126
          res = 3;
#line 127
          goto ERROR;
        }
#line 129
        result = (psiconv_ucs2 )(((((int )char1 & 15) << 12) | (((int )char2 & 63) << 6)) | ((int )char3 & 63));
      }
    }
  } else
#line 134
  if (config->unicode_table[char1]) {
#line 134
    result = config->unicode_table[char1];
  } else {
#line 134
    result = config->unknown_unicode_char;
  }
  ERROR: 
#line 137
  if (length) {
#line 138
    *length = len;
  }
#line 139
  if (status) {
#line 140
    *status = res;
  }
#line 141
  return (result);
}
}
#line 144 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/unicode.c"
int psiconv_unicode_write_char(psiconv_config const   config , psiconv_buffer buf ,
                               int lev , psiconv_ucs2 value ) 
{ 
  int i ;
  int res ;
  int tmp ;

  {
#line 149
  res = 0;
#line 151
  if (config->unicode) {
#line 152
    if ((int )value < 128) {
      {
#line 153
      res = psiconv_write_u8(config, buf, lev, (psiconv_u8 const   )value);
      }
#line 153
      if (res) {
#line 154
        goto ERROR;
      }
    } else
#line 155
    if ((int )value < 2048) {
      {
#line 156
      res = psiconv_write_u8(config, buf, lev, (psiconv_u8 const   )(192 | ((int )value >> 6)));
      }
#line 156
      if (res) {
#line 157
        goto ERROR;
      }
      {
#line 158
      res = psiconv_write_u8(config, buf, lev, (psiconv_u8 const   )(128 | ((int )value & 63)));
      }
#line 158
      if (res) {
#line 159
        goto ERROR;
      }
    } else {
      {
#line 161
      res = psiconv_write_u8(config, buf, lev, (psiconv_u8 const   )(224 | ((int )value >> 12)));
      }
#line 161
      if (res) {
#line 162
        goto ERROR;
      }
      {
#line 163
      res = psiconv_write_u8(config, buf, lev, (psiconv_u8 const   )(128 | (((int )value >> 6) & 63)));
      }
#line 163
      if (res) {
#line 164
        goto ERROR;
      }
      {
#line 165
      res = psiconv_write_u8(config, buf, lev, (psiconv_u8 const   )(128 | ((int )value & 63)));
      }
#line 165
      if (res) {
#line 166
        goto ERROR;
      }
    }
  } else {
#line 169
    i = 0;
    {
#line 169
    while (1) {
      while_continue: /* CIL Label */ ;
#line 169
      if (! (i < 256)) {
#line 169
        goto while_break;
      }
#line 170
      if ((int )config->unicode_table[i] == (int )value) {
#line 171
        goto while_break;
      }
#line 169
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 172
    if (i == 256) {
#line 172
      tmp = (int )config->unknown_epoc_char;
    } else {
#line 172
      tmp = i;
    }
    {
#line 172
    res = psiconv_write_u8(config, buf, lev, (psiconv_u8 const   )tmp);
    }
#line 172
    if (res) {
#line 174
      goto ERROR;
    }
  }
  ERROR: 
#line 177
  return (res);
}
}
#line 180 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/unicode.c"
int psiconv_unicode_strlen(psiconv_ucs2 const   *input ) 
{ 
  int i ;

  {
#line 182
  i = 0;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! *(input + i)) {
#line 183
      goto while_break;
    }
#line 184
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  return (i);
}
}
#line 188 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/unicode.c"
psiconv_ucs2 *psiconv_unicode_strdup(psiconv_ucs2 const   *input ) 
{ 
  psiconv_ucs2 *output ;
  int i ;
  int tmp ;
  void *tmp___0 ;
  psiconv_ucs2 tmp___1 ;

  {
  {
#line 191
  i = 0;
#line 193
  tmp = psiconv_unicode_strlen(input);
#line 193
  tmp___0 = malloc(sizeof(*output) * (unsigned long )(1 + tmp));
#line 193
  output = (psiconv_ucs2 *)tmp___0;
  }
#line 193
  if (! output) {
#line 195
    return ((psiconv_ucs2 *)((void *)0));
  }
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    tmp___1 = (psiconv_ucs2 )*(input + i);
#line 196
    *(output + i) = tmp___1;
#line 196
    if (! tmp___1) {
#line 196
      goto while_break;
    }
#line 197
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  return (output);
}
}
#line 201 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/unicode.c"
int psiconv_unicode_strcmp(psiconv_ucs2 const   *str1 , psiconv_ucs2 const   *str2 ) 
{ 
  int i ;

  {
#line 203
  i = 0;
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    if (*(str1 + i)) {
#line 204
      if (! *(str2 + i)) {
#line 204
        goto while_break;
      }
    } else {
#line 204
      goto while_break;
    }
#line 205
    if ((int const   )*(str1 + i) < (int const   )*(str2 + i)) {
#line 206
      return (-1);
    }
#line 207
    if ((int const   )*(str1 + i) > (int const   )*(str2 + i)) {
#line 208
      return (1);
    }
#line 209
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  if ((int const   )*(str1 + i) < (int const   )*(str2 + i)) {
#line 212
    return (-1);
  } else
#line 213
  if ((int const   )*(str1 + i) > (int const   )*(str2 + i)) {
#line 214
    return (1);
  } else {
#line 216
    return (0);
  }
}
}
#line 220 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/unicode.c"
psiconv_ucs2 *psiconv_unicode_empty_string(void) 
{ 
  psiconv_ucs2 *result ;
  void *tmp ;

  {
  {
#line 223
  tmp = malloc(sizeof(psiconv_ucs2 ));
#line 223
  result = (psiconv_ucs2 *)tmp;
  }
#line 224
  if (result) {
#line 225
    *(result + 0) = (psiconv_ucs2 )0;
  }
#line 226
  return (result);
}
}
#line 230 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/unicode.c"
psiconv_ucs2 *psiconv_unicode_from_list(psiconv_list input ) 
{ 
  psiconv_ucs2 *result ;
  int i ;
  psiconv_ucs2 *character ;
  psiconv_u32 tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  psiconv_u32 tmp___2 ;

  {
  {
#line 236
  tmp = psiconv_list_length((psiconv_list const   )input);
#line 236
  tmp___0 = malloc(sizeof(psiconv_ucs2 ) * (unsigned long )(tmp + 1U));
#line 236
  result = (psiconv_ucs2 *)tmp___0;
  }
#line 236
  if (! result) {
#line 237
    goto ERROR1;
  }
#line 238
  i = 0;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 238
    tmp___2 = psiconv_list_length((psiconv_list const   )input);
    }
#line 238
    if (! ((psiconv_u32 )i < tmp___2)) {
#line 238
      goto while_break;
    }
    {
#line 239
    tmp___1 = psiconv_list_get((psiconv_list const   )input, (psiconv_u32 )i);
#line 239
    character = (psiconv_ucs2 *)tmp___1;
    }
#line 239
    if (! character) {
#line 240
      goto ERROR2;
    }
#line 241
    *(result + i) = *character;
#line 238
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 243
  *(result + i) = (psiconv_ucs2 )0;
#line 244
  return (result);
  ERROR2: 
  {
#line 247
  free((void *)result);
  }
  ERROR1: 
#line 249
  return ((psiconv_ucs2 *)((void *)0));
}
}
#line 253 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/unicode.c"
psiconv_ucs2 *psiconv_unicode_strstr(psiconv_ucs2 const   *haystack , psiconv_ucs2 const   *needle ) 
{ 
  int i ;
  int j ;
  int haystack_len ;
  int needle_len ;

  {
  {
#line 257
  haystack_len = psiconv_unicode_strlen(haystack);
#line 258
  needle_len = psiconv_unicode_strlen(needle);
#line 262
  i = 0;
  }
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    if (! (i < (haystack_len - needle_len) + 1)) {
#line 262
      goto while_break;
    }
#line 263
    j = 0;
    {
#line 263
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 263
      if (! (j < needle_len)) {
#line 263
        goto while_break___0;
      }
#line 264
      if ((int const   )*(haystack + (i + j)) != (int const   )*(needle + j)) {
#line 265
        goto while_break___0;
      }
#line 263
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 266
    if (j == needle_len) {
#line 267
      return ((psiconv_ucs2 *)haystack + i);
    }
#line 262
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  return ((psiconv_ucs2 *)((void *)0));
}
}
#line 1071 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.h"
int psiconv_find_style(psiconv_word_styles_section const   ss , psiconv_ucs2 const   *name ,
                       int *nr ) ;
#line 1075
psiconv_formula psiconv_get_formula(psiconv_formula_list ss , int nr ) ;
#line 1078
psiconv_sheet_cell_layout psiconv_get_default_layout(psiconv_sheet_line_list row_defaults ,
                                                     psiconv_sheet_line_list col_defaults ,
                                                     psiconv_sheet_cell_layout cell_default ,
                                                     int row , int col ) ;
#line 1084
void psiconv_free_color(psiconv_color color___1 ) ;
#line 1085
void psiconv_free_border(psiconv_border border___1 ) ;
#line 1086
void psiconv_free_bullet(psiconv_bullet bullet___4 ) ;
#line 1087
void psiconv_free_font(psiconv_font font___9 ) ;
#line 1088
void psiconv_free_tab(psiconv_tab tab ) ;
#line 1089
void psiconv_free_tabs(psiconv_all_tabs tabs___4 ) ;
#line 1092
void psiconv_free_word_style(psiconv_word_style style___1 ) ;
#line 1093
void psiconv_free_word_style_list(psiconv_word_style_list style_list ) ;
#line 1100
void psiconv_free_sheet_cell_layout(psiconv_sheet_cell_layout layout ) ;
#line 1101
void psiconv_free_sheet_grid_break_list(psiconv_sheet_grid_break_list list ) ;
#line 1103
void psiconv_free_sheet_grid_size(psiconv_sheet_grid_size s ) ;
#line 1104
void psiconv_free_sheet_grid_size_list(psiconv_sheet_grid_size_list list ) ;
#line 1106
void psiconv_free_sheet_grid_section(psiconv_sheet_grid_section sec ) ;
#line 1107
void psiconv_free_sheet_worksheet(psiconv_sheet_worksheet sheet ) ;
#line 1108
void psiconv_free_sheet_worksheet_list(psiconv_sheet_worksheet_list list ) ;
#line 1111
void psiconv_free_sheet_f(psiconv_sheet_f file ) ;
#line 1112
void psiconv_free_sheet_cell(psiconv_sheet_cell cell ) ;
#line 1113
void psiconv_free_sheet_cell_list(psiconv_sheet_cell_list list ) ;
#line 1114
void psiconv_free_sheet_numberformat(psiconv_sheet_numberformat numberformat ) ;
#line 1116
void psiconv_free_sheet_line_list(psiconv_sheet_line_list list ) ;
#line 1117
void psiconv_free_sheet_line(psiconv_sheet_line line ) ;
#line 1118
void psiconv_free_sheet_name_section(psiconv_sheet_name_section section ) ;
#line 1119
void psiconv_free_sheet_variable(psiconv_sheet_variable var ) ;
#line 1120
void psiconv_free_sheet_variable_list(psiconv_sheet_variable_list list ) ;
#line 1121
void psiconv_free_sheet_info_section(psiconv_sheet_info_section section ) ;
#line 1122
void psiconv_free_sheet_workbook_section(psiconv_sheet_workbook_section section ) ;
#line 1125
void psiconv_free_section_table_entry(psiconv_section_table_entry entry ) ;
#line 1136
void psiconv_free_in_line_layout(psiconv_in_line_layout layout ) ;
#line 1137
void psiconv_free_in_line_layouts(psiconv_in_line_layouts layouts ) ;
#line 1138
void psiconv_free_replacement(psiconv_replacement replacement ) ;
#line 1139
void psiconv_free_replacements(psiconv_replacements replacements ) ;
#line 1140
void psiconv_free_paragraph(psiconv_paragraph paragraph___3 ) ;
#line 1142
void psiconv_free_texted_section(psiconv_texted_section section ) ;
#line 1143
void psiconv_free_page_header(psiconv_page_header header___3 ) ;
#line 1148
void psiconv_free_word_f(psiconv_word_f file ) ;
#line 1149
void psiconv_free_texted_f(psiconv_texted_f file ) ;
#line 1151
void psiconv_free_pictures(psiconv_pictures section ) ;
#line 1154
void psiconv_free_mbm_f(psiconv_mbm_f file ) ;
#line 1155
void psiconv_free_sketch_section(psiconv_sketch_section sec ) ;
#line 1156
void psiconv_free_sketch_f(psiconv_sketch_f file ) ;
#line 1158
void psiconv_free_cliparts(psiconv_cliparts section ) ;
#line 1159
void psiconv_free_clipart_f(psiconv_clipart_f file ) ;
#line 1161
void psiconv_free_file(psiconv_file file ) ;
#line 1171
int psiconv_compare_tab(psiconv_tab const   value1 , psiconv_tab const   value2 ) ;
#line 1184
psiconv_file psiconv_empty_file(psiconv_file_type_t type ) ;
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_color clone_color(psiconv_color color___1 ) ;
#line 34
static psiconv_font clone_font(psiconv_font font___9 ) ;
#line 35
static psiconv_border clone_border(psiconv_border border___1 ) ;
#line 36
static psiconv_bullet clone_bullet(psiconv_bullet bullet___4 ) ;
#line 37
static psiconv_all_tabs clone_all_tabs(psiconv_all_tabs all_tabs ) ;
#line 38
static void psiconv_free_style_aux(void *style___1 ) ;
#line 39
static void psiconv_free_in_line_layout_aux(void *layout ) ;
#line 40
static void psiconv_free_paragraph_aux(void *paragraph___3 ) ;
#line 41
static void psiconv_free_paint_data_section_aux(void *section ) ;
#line 42
static void psiconv_free_clipart_section_aux(void *section ) ;
#line 43
static void psiconv_free_formula_aux(void *data ) ;
#line 44
static void psiconv_free_sheet_worksheet_aux(void *data ) ;
#line 45
static void psiconv_free_sheet_variable_aux(void *variable ) ;
#line 46
static void psiconv_free_sheet_cell_aux(void *cell ) ;
#line 47
static void psiconv_free_sheet_line_aux(void *line ) ;
#line 50
static psiconv_word_styles_section psiconv_empty_word_styles_section(void) ;
#line 51
static psiconv_text_and_layout psiconv_empty_text_and_layout(void) ;
#line 52
static psiconv_texted_section psiconv_empty_texted_section(void) ;
#line 53
static psiconv_page_header psiconv_empty_page_header(void) ;
#line 54
static psiconv_page_layout_section psiconv_empty_page_layout_section(void) ;
#line 55
static psiconv_word_status_section psiconv_empty_word_status_section(void) ;
#line 56
static psiconv_word_f psiconv_empty_word_f(void) ;
#line 57
static psiconv_sheet_status_section psiconv_empty_sheet_status_section(void) ;
#line 58
static psiconv_formula_list psiconv_empty_formula_list(void) ;
#line 59
static psiconv_sheet_workbook_section psiconv_empty_sheet_workbook_section(void) ;
#line 61
static psiconv_sheet_f psiconv_empty_sheet_f(void) ;
#line 62
static psiconv_texted_f psiconv_empty_texted_f(void) ;
#line 63
static psiconv_paint_data_section psiconv_empty_paint_data_section(void) ;
#line 64
static psiconv_pictures psiconv_empty_pictures(void) ;
#line 65
static psiconv_mbm_f psiconv_empty_mbm_f(void) ;
#line 66
static psiconv_sketch_section psiconv_empty_sketch_section(void) ;
#line 67
static psiconv_sketch_f psiconv_empty_sketch_f(void) ;
#line 68
static psiconv_clipart_f psiconv_empty_clipart_f(void) ;
#line 69
static psiconv_cliparts psiconv_empty_cliparts(void) ;
#line 77 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_color_s black  =    {(psiconv_u8 )0, (psiconv_u8 )0, (psiconv_u8 )0};
#line 83 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_color_s white  =    {(psiconv_u8 )255, (psiconv_u8 )255, (psiconv_u8 )255};
#line 89 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_ucs2 font_times[16]  = 
#line 89
  {      (psiconv_ucs2 )'T',      (psiconv_ucs2 )'i',      (psiconv_ucs2 )'m',      (psiconv_ucs2 )'e', 
        (psiconv_ucs2 )'s',      (psiconv_ucs2 )' ',      (psiconv_ucs2 )'N',      (psiconv_ucs2 )'e', 
        (psiconv_ucs2 )'w',      (psiconv_ucs2 )' ',      (psiconv_ucs2 )'R',      (psiconv_ucs2 )'o', 
        (psiconv_ucs2 )'m',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'n',      (psiconv_ucs2 )0};
#line 92 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_font_s font  =    {font_times, (psiconv_screenfont_t )3};
#line 74 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
psiconv_character_layout psiconv_basic_character_layout(void) 
{ 
  struct psiconv_character_layout_s cl ;
  psiconv_character_layout tmp ;

  {
  {
#line 97
  cl.color = & black;
#line 97
  cl.back_color = & white;
#line 97
  cl.font_size = (psiconv_size_t )10.0;
#line 97
  cl.italic = (psiconv_bool_t )0;
#line 97
  cl.bold = (psiconv_bool_t )0;
#line 97
  cl.super_sub = (psiconv_super_sub_t )0;
#line 97
  cl.underline = (psiconv_bool_t )0;
#line 97
  cl.strikethrough = (psiconv_bool_t )0;
#line 97
  cl.font = & font;
#line 110
  tmp = psiconv_clone_character_layout(& cl);
  }
#line 110
  return (tmp);
}
}
#line 117 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_ucs2 font_times___0[16]  = 
#line 117
  {      (psiconv_ucs2 )'T',      (psiconv_ucs2 )'i',      (psiconv_ucs2 )'m',      (psiconv_ucs2 )'e', 
        (psiconv_ucs2 )'s',      (psiconv_ucs2 )' ',      (psiconv_ucs2 )'N',      (psiconv_ucs2 )'e', 
        (psiconv_ucs2 )'w',      (psiconv_ucs2 )' ',      (psiconv_ucs2 )'R',      (psiconv_ucs2 )'o', 
        (psiconv_ucs2 )'m',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'n',      (psiconv_ucs2 )0};
#line 121 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_font_s font___0  =    {font_times___0, (psiconv_screenfont_t )2};
#line 126 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_color_s black___0  =    {(psiconv_u8 )0, (psiconv_u8 )0, (psiconv_u8 )0};
#line 132 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_color_s white___0  =    {(psiconv_u8 )255, (psiconv_u8 )255, (psiconv_u8 )255};
#line 138 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_border_s no_border  =    {(psiconv_border_kind_t )0, (psiconv_size_t )1, & black___0};
#line 144 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_bullet_s bullet  =    {(psiconv_bool_t )0, (psiconv_size_t )10.0, (psiconv_ucs2 )8221, (psiconv_bool_t )1,
    & black___0, & font___0};
#line 153 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_all_tabs_s tabs  =    {(psiconv_length_t )0.64, (psiconv_tab_list )((void *)0)};
#line 115 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
psiconv_paragraph_layout psiconv_basic_paragraph_layout(void) 
{ 
  struct psiconv_paragraph_layout_s pl ;
  psiconv_paragraph_layout res ;
  psiconv_tab_list tmp ;

  {
  {
#line 158
  pl.back_color = & white___0;
#line 158
  pl.indent_left = (psiconv_length_t )0.0;
#line 158
  pl.indent_right = (psiconv_length_t )0.0;
#line 158
  pl.indent_first = (psiconv_length_t )0.0;
#line 158
  pl.justify_hor = (psiconv_justify_hor_t )0;
#line 158
  pl.justify_ver = (psiconv_justify_ver_t )1;
#line 158
  pl.linespacing = (psiconv_size_t )10.0;
#line 158
  pl.linespacing_exact = (psiconv_bool_t )0;
#line 158
  pl.space_above = (psiconv_size_t )0.0;
#line 158
  pl.space_below = (psiconv_size_t )0.0;
#line 158
  pl.keep_together = (psiconv_bool_t )0;
#line 158
  pl.keep_with_next = (psiconv_bool_t )0;
#line 158
  pl.on_next_page = (psiconv_bool_t )0;
#line 158
  pl.no_widow_protection = (psiconv_bool_t )0;
#line 158
  pl.wrap_to_fit_cell = (psiconv_bool_t )0;
#line 158
  pl.border_distance = (psiconv_length_t )0.0;
#line 158
  pl.bullet = & bullet;
#line 158
  pl.left_border = & no_border;
#line 158
  pl.right_border = & no_border;
#line 158
  pl.top_border = & no_border;
#line 158
  pl.bottom_border = & no_border;
#line 158
  pl.tabs = & tabs;
#line 185
  tmp = psiconv_list_new(sizeof(struct psiconv_tab_s ));
#line 185
  (pl.tabs)->extras = tmp;
  }
#line 185
  if (! tmp) {
#line 186
    return ((psiconv_paragraph_layout )((void *)0));
  }
  {
#line 187
  res = psiconv_clone_paragraph_layout(& pl);
#line 188
  psiconv_list_free((pl.tabs)->extras);
  }
#line 189
  return (res);
}
}
#line 192 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_color clone_color(psiconv_color color___1 ) 
{ 
  psiconv_color result ;
  void *tmp ;

  {
  {
#line 195
  tmp = malloc(sizeof(*result));
#line 195
  result = (psiconv_color )tmp;
  }
#line 195
  if (! result) {
#line 196
    return ((psiconv_color )((void *)0));
  }
#line 197
  *result = *color___1;
#line 198
  return (result);
}
}
#line 201 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_font clone_font(psiconv_font font___9 ) 
{ 
  psiconv_font result ;
  void *tmp ;
  psiconv_string_t tmp___0 ;

  {
  {
#line 204
  tmp = malloc(sizeof(*result));
#line 204
  result = (psiconv_font )tmp;
  }
#line 204
  if (! result) {
#line 205
    goto ERROR1;
  }
  {
#line 206
  *result = *font___9;
#line 207
  tmp___0 = psiconv_unicode_strdup((psiconv_ucs2 const   *)result->name);
#line 207
  result->name = tmp___0;
  }
#line 207
  if (! tmp___0) {
#line 208
    goto ERROR2;
  }
#line 209
  return (result);
  ERROR2: 
  {
#line 211
  free((void *)result);
  }
  ERROR1: 
#line 213
  return ((psiconv_font )((void *)0));
}
}
#line 216 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_border clone_border(psiconv_border border___1 ) 
{ 
  psiconv_border result ;
  void *tmp ;
  psiconv_color tmp___0 ;

  {
  {
#line 219
  tmp = malloc(sizeof(*result));
#line 219
  result = (psiconv_border )tmp;
  }
#line 219
  if (! result) {
#line 220
    goto ERROR1;
  }
  {
#line 221
  *result = *border___1;
#line 222
  tmp___0 = clone_color(result->color);
#line 222
  result->color = tmp___0;
  }
#line 222
  if (! tmp___0) {
#line 223
    goto ERROR2;
  }
#line 224
  return (result);
  ERROR2: 
  {
#line 226
  free((void *)result);
  }
  ERROR1: 
#line 228
  return ((psiconv_border )((void *)0));
}
}
#line 231 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_bullet clone_bullet(psiconv_bullet bullet___4 ) 
{ 
  psiconv_bullet result ;
  void *tmp ;
  psiconv_font tmp___0 ;
  psiconv_color tmp___1 ;

  {
  {
#line 234
  tmp = malloc(sizeof(*result));
#line 234
  result = (psiconv_bullet )tmp;
  }
#line 234
  if (! result) {
#line 235
    goto ERROR1;
  }
  {
#line 236
  *result = *bullet___4;
#line 237
  tmp___0 = clone_font(result->font);
#line 237
  result->font = tmp___0;
  }
#line 237
  if (! tmp___0) {
#line 238
    goto ERROR2;
  }
  {
#line 239
  tmp___1 = clone_color(result->color);
#line 239
  result->color = tmp___1;
  }
#line 239
  if (! tmp___1) {
#line 240
    goto ERROR3;
  }
#line 241
  return (result);
  ERROR3: 
  {
#line 243
  psiconv_free_font(result->font);
  }
  ERROR2: 
  {
#line 245
  free((void *)result);
  }
  ERROR1: 
#line 247
  return ((psiconv_bullet )((void *)0));
}
}
#line 250 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_all_tabs clone_all_tabs(psiconv_all_tabs all_tabs ) 
{ 
  psiconv_all_tabs result ;
  void *tmp ;
  psiconv_tab_list tmp___0 ;

  {
  {
#line 253
  tmp = malloc(sizeof(*result));
#line 253
  result = (psiconv_all_tabs )tmp;
  }
#line 253
  if (! result) {
#line 254
    goto ERROR1;
  }
  {
#line 255
  *result = *all_tabs;
#line 256
  tmp___0 = psiconv_list_clone((psiconv_list const   )result->extras);
#line 256
  result->extras = tmp___0;
  }
#line 256
  if (! tmp___0) {
#line 257
    goto ERROR2;
  }
#line 258
  return (result);
  ERROR2: 
  {
#line 260
  free((void *)result);
  }
  ERROR1: 
#line 262
  return ((psiconv_all_tabs )((void *)0));
}
}
#line 265 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
psiconv_character_layout psiconv_clone_character_layout(psiconv_character_layout ls ) 
{ 
  psiconv_character_layout result ;
  void *tmp ;
  psiconv_color tmp___0 ;
  psiconv_color tmp___1 ;
  psiconv_font tmp___2 ;

  {
  {
#line 270
  tmp = malloc(sizeof(*result));
#line 270
  result = (psiconv_character_layout )tmp;
  }
#line 270
  if (! result) {
#line 271
    goto ERROR1;
  }
  {
#line 272
  *result = *ls;
#line 273
  tmp___0 = clone_color(result->color);
#line 273
  result->color = tmp___0;
  }
#line 273
  if (! tmp___0) {
#line 274
    goto ERROR2;
  }
  {
#line 275
  tmp___1 = clone_color(result->back_color);
#line 275
  result->back_color = tmp___1;
  }
#line 275
  if (! tmp___1) {
#line 276
    goto ERROR3;
  }
  {
#line 277
  tmp___2 = clone_font(result->font);
#line 277
  result->font = tmp___2;
  }
#line 277
  if (! tmp___2) {
#line 278
    goto ERROR4;
  }
#line 279
  return (result);
  ERROR4: 
  {
#line 281
  psiconv_free_color(result->back_color);
  }
  ERROR3: 
  {
#line 283
  psiconv_free_color(result->color);
  }
  ERROR2: 
  {
#line 285
  free((void *)result);
  }
  ERROR1: 
#line 287
  return ((psiconv_character_layout )((void *)0));
}
}
#line 290 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
psiconv_paragraph_layout psiconv_clone_paragraph_layout(psiconv_paragraph_layout ls ) 
{ 
  psiconv_paragraph_layout result ;
  void *tmp ;
  psiconv_color tmp___0 ;
  psiconv_bullet tmp___1 ;
  psiconv_border tmp___2 ;
  psiconv_border tmp___3 ;
  psiconv_border tmp___4 ;
  psiconv_border tmp___5 ;
  psiconv_all_tabs tmp___6 ;

  {
  {
#line 295
  tmp = malloc(sizeof(*result));
#line 295
  result = (psiconv_paragraph_layout )tmp;
  }
#line 295
  if (! result) {
#line 296
    goto ERROR1;
  }
  {
#line 297
  *result = *ls;
#line 298
  tmp___0 = clone_color(result->back_color);
#line 298
  result->back_color = tmp___0;
  }
#line 298
  if (! tmp___0) {
#line 299
    goto ERROR2;
  }
  {
#line 300
  tmp___1 = clone_bullet(result->bullet);
#line 300
  result->bullet = tmp___1;
  }
#line 300
  if (! tmp___1) {
#line 301
    goto ERROR3;
  }
  {
#line 302
  tmp___2 = clone_border(result->left_border);
#line 302
  result->left_border = tmp___2;
  }
#line 302
  if (! tmp___2) {
#line 303
    goto ERROR4;
  }
  {
#line 304
  tmp___3 = clone_border(result->right_border);
#line 304
  result->right_border = tmp___3;
  }
#line 304
  if (! tmp___3) {
#line 305
    goto ERROR5;
  }
  {
#line 306
  tmp___4 = clone_border(result->top_border);
#line 306
  result->top_border = tmp___4;
  }
#line 306
  if (! tmp___4) {
#line 307
    goto ERROR6;
  }
  {
#line 308
  tmp___5 = clone_border(result->bottom_border);
#line 308
  result->bottom_border = tmp___5;
  }
#line 308
  if (! tmp___5) {
#line 309
    goto ERROR7;
  }
  {
#line 310
  tmp___6 = clone_all_tabs(result->tabs);
#line 310
  result->tabs = tmp___6;
  }
#line 310
  if (! tmp___6) {
#line 311
    goto ERROR8;
  }
#line 312
  return (result);
  ERROR8: 
  {
#line 314
  psiconv_free_border(result->bottom_border);
  }
  ERROR7: 
  {
#line 316
  psiconv_free_border(result->top_border);
  }
  ERROR6: 
  {
#line 318
  psiconv_free_border(result->right_border);
  }
  ERROR5: 
  {
#line 320
  psiconv_free_border(result->left_border);
  }
  ERROR4: 
  {
#line 322
  psiconv_free_bullet(result->bullet);
  }
  ERROR3: 
  {
#line 324
  psiconv_free_color(result->back_color);
  }
  ERROR2: 
  {
#line 326
  free((void *)result);
  }
  ERROR1: 
#line 328
  return ((psiconv_paragraph_layout )((void *)0));
}
}
#line 331 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
psiconv_word_style psiconv_get_style(psiconv_word_styles_section ss , int nr ) 
{ 
  void *tmp ;

  {
#line 333
  if (nr == 0) {
#line 334
    return (ss->normal);
  } else {
    {
#line 336
    tmp = psiconv_list_get((psiconv_list const   )ss->styles, (psiconv_u32 )(255 - nr));
    }
#line 336
    return ((psiconv_word_style )tmp);
  }
}
}
#line 339 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
int psiconv_find_style(psiconv_word_styles_section const   ss , psiconv_ucs2 const   *name ,
                       int *nr ) 
{ 
  psiconv_ucs2 value_normal[7] ;
  psiconv_word_style style___1 ;
  int i ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  psiconv_u32 tmp___2 ;

  {
#line 343
  value_normal[0] = (psiconv_ucs2 )'N';
#line 343
  value_normal[1] = (psiconv_ucs2 )'o';
#line 343
  value_normal[2] = (psiconv_ucs2 )'r';
#line 343
  value_normal[3] = (psiconv_ucs2 )'m';
#line 343
  value_normal[4] = (psiconv_ucs2 )'a';
#line 343
  value_normal[5] = (psiconv_ucs2 )'l';
#line 343
  value_normal[6] = (psiconv_ucs2 )0;
#line 347
  if (! nr) {
#line 348
    return (1);
  }
  {
#line 349
  tmp = psiconv_unicode_strcmp((psiconv_ucs2 const   *)(value_normal), name);
  }
#line 349
  if (! tmp) {
#line 350
    *nr = 0;
#line 351
    return (0);
  }
#line 353
  i = 0;
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 353
    tmp___2 = psiconv_list_length((psiconv_list const   )ss->styles);
    }
#line 353
    if (! ((psiconv_u32 )i < tmp___2)) {
#line 353
      goto while_break;
    }
    {
#line 354
    tmp___0 = psiconv_list_get((psiconv_list const   )ss->styles, (psiconv_u32 )i);
#line 354
    style___1 = (psiconv_word_style )tmp___0;
    }
#line 354
    if (! style___1) {
#line 355
      return (2);
    }
    {
#line 356
    tmp___1 = psiconv_unicode_strcmp((psiconv_ucs2 const   *)style___1->name, name);
    }
#line 356
    if (! tmp___1) {
#line 357
      *nr = 255 - i;
#line 358
      return (0);
    }
#line 353
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  *nr = 0;
#line 362
  return (1);
}
}
#line 366 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
psiconv_formula psiconv_get_formula(psiconv_formula_list ss , int nr ) 
{ 
  psiconv_u32 tmp ;
  void *tmp___0 ;

  {
  {
#line 368
  tmp = psiconv_list_length((psiconv_list const   )ss);
#line 368
  tmp___0 = psiconv_list_get((psiconv_list const   )ss, (tmp - (psiconv_u32 )nr) - 1U);
  }
#line 368
  return ((psiconv_formula )tmp___0);
}
}
#line 372 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
psiconv_sheet_cell_layout psiconv_get_default_layout(psiconv_sheet_line_list row_defaults ,
                                                     psiconv_sheet_line_list col_defaults ,
                                                     psiconv_sheet_cell_layout cell_default ,
                                                     int row , int col ) 
{ 
  int i ;
  psiconv_sheet_line line ;
  void *tmp ;
  psiconv_u32 tmp___0 ;
  void *tmp___1 ;
  psiconv_u32 tmp___2 ;

  {
#line 380
  i = 0;
  {
#line 380
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 380
    tmp___0 = psiconv_list_length((psiconv_list const   )row_defaults);
    }
#line 380
    if (! ((psiconv_u32 )i < tmp___0)) {
#line 380
      goto while_break;
    }
    {
#line 381
    tmp = psiconv_list_get((psiconv_list const   )row_defaults, (psiconv_u32 )i);
#line 381
    line = (psiconv_sheet_line )tmp;
    }
#line 382
    if (line->position == (psiconv_u32 )row) {
#line 383
      return (line->layout);
    }
#line 380
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 385
  i = 0;
  {
#line 385
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 385
    tmp___2 = psiconv_list_length((psiconv_list const   )col_defaults);
    }
#line 385
    if (! ((psiconv_u32 )i < tmp___2)) {
#line 385
      goto while_break___0;
    }
    {
#line 386
    tmp___1 = psiconv_list_get((psiconv_list const   )col_defaults, (psiconv_u32 )i);
#line 386
    line = (psiconv_sheet_line )tmp___1;
    }
#line 387
    if (line->position == (psiconv_u32 )col) {
#line 388
      return (line->layout);
    }
#line 385
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 390
  return (cell_default);
}
}
#line 394 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_color(psiconv_color color___1 ) 
{ 


  {
#line 396
  if (color___1) {
    {
#line 397
    free((void *)color___1);
    }
  }
#line 398
  return;
}
}
#line 400 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_border(psiconv_border border___1 ) 
{ 


  {
#line 402
  if (border___1) {
    {
#line 403
    psiconv_free_color(border___1->color);
#line 404
    free((void *)border___1);
    }
  }
#line 406
  return;
}
}
#line 408 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_font(psiconv_font font___9 ) 
{ 


  {
#line 410
  if (font___9) {
#line 411
    if (font___9->name) {
      {
#line 412
      free((void *)font___9->name);
      }
    }
    {
#line 413
    free((void *)font___9);
    }
  }
#line 415
  return;
}
}
#line 417 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_bullet(psiconv_bullet bullet___4 ) 
{ 


  {
#line 419
  if (bullet___4) {
    {
#line 420
    psiconv_free_color(bullet___4->color);
#line 421
    psiconv_free_font(bullet___4->font);
#line 422
    free((void *)bullet___4);
    }
  }
#line 424
  return;
}
}
#line 426 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_character_layout(psiconv_character_layout layout ) 
{ 


  {
#line 428
  if (layout) {
    {
#line 429
    psiconv_free_color(layout->color);
#line 430
    psiconv_free_color(layout->back_color);
#line 431
    psiconv_free_font(layout->font);
#line 432
    free((void *)layout);
    }
  }
#line 434
  return;
}
}
#line 436 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_tab(psiconv_tab tab ) 
{ 


  {
#line 438
  if (tab) {
    {
#line 439
    free((void *)tab);
    }
  }
#line 440
  return;
}
}
#line 442 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_tabs(psiconv_all_tabs tabs___4 ) 
{ 


  {
#line 444
  if (tabs___4) {
    {
#line 445
    psiconv_list_free(tabs___4->extras);
#line 446
    free((void *)tabs___4);
    }
  }
#line 448
  return;
}
}
#line 450 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_paragraph_layout(psiconv_paragraph_layout layout ) 
{ 


  {
#line 452
  if (layout) {
    {
#line 453
    psiconv_free_color(layout->back_color);
#line 454
    psiconv_free_bullet(layout->bullet);
#line 455
    psiconv_free_border(layout->left_border);
#line 456
    psiconv_free_border(layout->right_border);
#line 457
    psiconv_free_border(layout->top_border);
#line 458
    psiconv_free_border(layout->bottom_border);
#line 459
    psiconv_free_tabs(layout->tabs);
#line 460
    free((void *)layout);
    }
  }
#line 462
  return;
}
}
#line 464 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_style_aux(void *style___1 ) 
{ 


  {
#line 466
  if (((psiconv_word_style )style___1)->name) {
    {
#line 467
    free((void *)((psiconv_word_style )style___1)->name);
    }
  }
  {
#line 468
  psiconv_free_character_layout(((psiconv_word_style )style___1)->character);
#line 469
  psiconv_free_paragraph_layout(((psiconv_word_style )style___1)->paragraph);
  }
#line 470
  return;
}
}
#line 472 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_word_style(psiconv_word_style style___1 ) 
{ 


  {
#line 474
  if (style___1) {
    {
#line 475
    psiconv_free_style_aux((void *)style___1);
#line 476
    free((void *)style___1);
    }
  }
#line 478
  return;
}
}
#line 480 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_word_style_list(psiconv_word_style_list style_list ) 
{ 


  {
#line 482
  if (style_list) {
    {
#line 483
    psiconv_list_free_el(style_list, & psiconv_free_style_aux);
    }
  }
#line 484
  return;
}
}
#line 486 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_word_styles_section(psiconv_word_styles_section styles___1 ) 
{ 


  {
#line 488
  if (styles___1) {
    {
#line 489
    psiconv_free_word_style(styles___1->normal);
#line 490
    psiconv_free_word_style_list(styles___1->styles);
#line 491
    free((void *)styles___1);
    }
  }
#line 493
  return;
}
}
#line 495 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_header_section(psiconv_header_section header___3 ) 
{ 


  {
#line 497
  if (header___3) {
    {
#line 498
    free((void *)header___3);
    }
  }
#line 499
  return;
}
}
#line 501 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_section_table_entry(psiconv_section_table_entry entry ) 
{ 


  {
#line 503
  if (entry) {
    {
#line 504
    free((void *)entry);
    }
  }
#line 505
  return;
}
}
#line 507 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_section_table_section(psiconv_section_table_section section ) 
{ 


  {
#line 509
  if (section) {
    {
#line 510
    psiconv_list_free(section);
    }
  }
#line 511
  return;
}
}
#line 513 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_application_id_section(psiconv_application_id_section section ) 
{ 


  {
#line 515
  if (section) {
#line 516
    if (section->name) {
      {
#line 517
      free((void *)section->name);
      }
    }
    {
#line 518
    free((void *)section);
    }
  }
#line 520
  return;
}
}
#line 522 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_object_icon_section(psiconv_object_icon_section section ) 
{ 


  {
#line 524
  if (section) {
#line 525
    if (section->icon_name) {
      {
#line 526
      free((void *)section->icon_name);
      }
    }
    {
#line 527
    free((void *)section);
    }
  }
#line 529
  return;
}
}
#line 531 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_object_display_section(psiconv_object_display_section section ) 
{ 


  {
#line 533
  if (section) {
    {
#line 534
    free((void *)section);
    }
  }
#line 535
  return;
}
}
#line 537 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_embedded_object_section(psiconv_embedded_object_section object ) 
{ 


  {
#line 540
  if (object) {
    {
#line 541
    psiconv_free_object_icon_section(object->icon);
#line 542
    psiconv_free_object_display_section(object->display);
#line 543
    psiconv_free_file(object->object);
#line 544
    free((void *)object);
    }
  }
#line 546
  return;
}
}
#line 548 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_in_line_layout_aux(void *layout ) 
{ 


  {
  {
#line 550
  psiconv_free_character_layout(((psiconv_in_line_layout )layout)->layout);
#line 551
  psiconv_free_embedded_object_section(((psiconv_in_line_layout )layout)->object);
  }
#line 553
  return;
}
}
#line 555 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_in_line_layout(psiconv_in_line_layout layout ) 
{ 


  {
#line 557
  if (layout) {
    {
#line 558
    psiconv_free_in_line_layout_aux((void *)layout);
#line 559
    free((void *)layout);
    }
  }
#line 561
  return;
}
}
#line 563 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_in_line_layouts(psiconv_in_line_layouts layouts ) 
{ 


  {
#line 565
  if (layouts) {
    {
#line 566
    psiconv_list_free_el(layouts, & psiconv_free_in_line_layout_aux);
    }
  }
#line 567
  return;
}
}
#line 569 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_replacement(psiconv_replacement replacement ) 
{ 


  {
#line 571
  if (replacement) {
    {
#line 572
    free((void *)replacement);
    }
  }
#line 573
  return;
}
}
#line 575 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_replacements(psiconv_replacements replacements ) 
{ 


  {
#line 577
  if (replacements) {
    {
#line 578
    psiconv_list_free(replacements);
    }
  }
#line 579
  return;
}
}
#line 581 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_paragraph_aux(void *paragraph___3 ) 
{ 


  {
#line 583
  if (((psiconv_paragraph )paragraph___3)->text) {
    {
#line 584
    free((void *)((psiconv_paragraph )paragraph___3)->text);
    }
  }
  {
#line 585
  psiconv_free_character_layout(((psiconv_paragraph )paragraph___3)->base_character);
#line 587
  psiconv_free_paragraph_layout(((psiconv_paragraph )paragraph___3)->base_paragraph);
#line 589
  psiconv_free_in_line_layouts(((psiconv_paragraph )paragraph___3)->in_lines);
#line 591
  psiconv_free_replacements(((psiconv_paragraph )paragraph___3)->replacements);
  }
#line 593
  return;
}
}
#line 595 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_paragraph(psiconv_paragraph paragraph___3 ) 
{ 


  {
#line 597
  if (paragraph___3) {
    {
#line 598
    psiconv_free_paragraph_aux((void *)paragraph___3);
#line 599
    free((void *)paragraph___3);
    }
  }
#line 601
  return;
}
}
#line 603 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_text_and_layout(psiconv_text_and_layout text___3 ) 
{ 


  {
#line 605
  if (text___3) {
    {
#line 606
    psiconv_list_free_el(text___3, & psiconv_free_paragraph_aux);
    }
  }
#line 607
  return;
}
}
#line 609 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_texted_section(psiconv_texted_section section ) 
{ 


  {
#line 611
  if (section) {
    {
#line 612
    psiconv_free_text_and_layout(section->paragraphs);
#line 613
    free((void *)section);
    }
  }
#line 615
  return;
}
}
#line 617 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_page_header(psiconv_page_header header___3 ) 
{ 


  {
#line 619
  if (header___3) {
    {
#line 620
    psiconv_free_character_layout(header___3->base_character_layout);
#line 621
    psiconv_free_paragraph_layout(header___3->base_paragraph_layout);
#line 622
    psiconv_free_texted_section(header___3->text);
#line 623
    free((void *)header___3);
    }
  }
#line 625
  return;
}
}
#line 627 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_page_layout_section(psiconv_page_layout_section section ) 
{ 


  {
#line 629
  if (section) {
    {
#line 630
    psiconv_free_page_header(section->header);
#line 631
    psiconv_free_page_header(section->footer);
#line 632
    free((void *)section);
    }
  }
#line 634
  return;
}
}
#line 636 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_word_status_section(psiconv_word_status_section section ) 
{ 


  {
#line 638
  if (section) {
    {
#line 639
    free((void *)section);
    }
  }
#line 640
  return;
}
}
#line 642 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_word_f(psiconv_word_f file ) 
{ 


  {
#line 644
  if (file) {
    {
#line 645
    psiconv_free_page_layout_section(file->page_sec);
#line 646
    psiconv_free_text_and_layout(file->paragraphs);
#line 647
    psiconv_free_word_status_section(file->status_sec);
#line 648
    psiconv_free_word_styles_section(file->styles_sec);
#line 649
    free((void *)file);
    }
  }
#line 651
  return;
}
}
#line 653 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_sheet_status_section(psiconv_sheet_status_section section ) 
{ 


  {
#line 655
  if (section) {
    {
#line 656
    free((void *)section);
    }
  }
#line 657
  return;
}
}
#line 659 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_sheet_numberformat(psiconv_sheet_numberformat numberformat ) 
{ 


  {
#line 661
  if (numberformat) {
    {
#line 662
    free((void *)numberformat);
    }
  }
#line 663
  return;
}
}
#line 665 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_sheet_cell_layout(psiconv_sheet_cell_layout layout ) 
{ 


  {
  {
#line 667
  psiconv_free_paragraph_layout(layout->paragraph);
#line 668
  psiconv_free_character_layout(layout->character);
#line 669
  psiconv_free_sheet_numberformat(layout->numberformat);
  }
#line 670
  return;
}
}
#line 672 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_sheet_cell_aux(void *cell ) 
{ 
  psiconv_sheet_cell data ;

  {
  {
#line 674
  data = (psiconv_sheet_cell )cell;
#line 676
  psiconv_free_sheet_cell_layout(data->layout);
  }
#line 678
  if ((unsigned int )data->type == 5U) {
#line 678
    if (data->data.dat_string) {
      {
#line 679
      free((void *)data->data.dat_string);
      }
    }
  }
#line 680
  return;
}
}
#line 682 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_sheet_cell(psiconv_sheet_cell cell ) 
{ 


  {
#line 684
  if (cell) {
    {
#line 685
    psiconv_free_sheet_cell_aux((void *)cell);
#line 686
    free((void *)cell);
    }
  }
#line 688
  return;
}
}
#line 690 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_sheet_cell_list(psiconv_sheet_cell_list list ) 
{ 


  {
#line 692
  if (list) {
    {
#line 693
    psiconv_list_free_el(list, & psiconv_free_sheet_cell_aux);
    }
  }
#line 694
  return;
}
}
#line 696 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_sheet_line_aux(void *line ) 
{ 
  psiconv_sheet_line data ;

  {
  {
#line 698
  data = (psiconv_sheet_line )line;
#line 700
  psiconv_free_sheet_cell_layout(data->layout);
  }
#line 701
  return;
}
}
#line 703 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_sheet_line(psiconv_sheet_line line ) 
{ 


  {
#line 705
  if (line) {
    {
#line 706
    psiconv_free_sheet_line_aux((void *)line);
#line 707
    free((void *)line);
    }
  }
#line 709
  return;
}
}
#line 712 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_sheet_line_list(psiconv_sheet_line_list list ) 
{ 


  {
#line 714
  if (list) {
    {
#line 715
    psiconv_list_free_el(list, & psiconv_free_sheet_line_aux);
    }
  }
#line 716
  return;
}
}
#line 718 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_sheet_grid_break_list(psiconv_sheet_grid_break_list list ) 
{ 


  {
#line 720
  if (list) {
    {
#line 721
    psiconv_list_free(list);
    }
  }
#line 722
  return;
}
}
#line 724 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_sheet_grid_size(psiconv_sheet_grid_size s ) 
{ 


  {
#line 726
  if (s) {
    {
#line 727
    free((void *)s);
    }
  }
#line 728
  return;
}
}
#line 730 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_sheet_grid_size_list(psiconv_sheet_grid_size_list list ) 
{ 


  {
#line 732
  if (list) {
    {
#line 733
    psiconv_list_free(list);
    }
  }
#line 734
  return;
}
}
#line 736 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_sheet_grid_section(psiconv_sheet_grid_section sec ) 
{ 


  {
#line 738
  if (sec) {
    {
#line 739
    psiconv_free_sheet_grid_size_list(sec->row_heights);
#line 740
    psiconv_free_sheet_grid_size_list(sec->column_heights);
#line 741
    psiconv_free_sheet_grid_break_list(sec->row_page_breaks);
#line 742
    psiconv_free_sheet_grid_break_list(sec->column_page_breaks);
#line 743
    free((void *)sec);
    }
  }
#line 745
  return;
}
}
#line 747 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_sheet_worksheet_aux(void *data ) 
{ 
  psiconv_sheet_worksheet section ;

  {
  {
#line 749
  section = (psiconv_sheet_worksheet )data;
#line 750
  psiconv_free_sheet_cell_layout(section->default_layout);
#line 751
  psiconv_free_sheet_cell_list(section->cells);
#line 752
  psiconv_free_sheet_line_list(section->row_default_layouts);
#line 753
  psiconv_free_sheet_line_list(section->col_default_layouts);
#line 754
  psiconv_free_sheet_grid_section(section->grid);
  }
#line 755
  return;
}
}
#line 757 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_sheet_worksheet(psiconv_sheet_worksheet sheet ) 
{ 


  {
#line 759
  if (sheet) {
    {
#line 760
    psiconv_free_sheet_worksheet_aux((void *)sheet);
#line 761
    free((void *)sheet);
    }
  }
#line 763
  return;
}
}
#line 765 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_sheet_worksheet_list(psiconv_sheet_worksheet_list list ) 
{ 


  {
#line 767
  if (list) {
    {
#line 768
    psiconv_list_free_el(list, & psiconv_free_sheet_worksheet_aux);
    }
  }
#line 769
  return;
}
}
#line 771 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_formula_aux(void *data ) 
{ 
  psiconv_formula formula ;

  {
#line 774
  formula = (psiconv_formula )data;
#line 775
  if ((unsigned int )formula->type == 23U) {
    {
#line 776
    free((void *)formula->data.dat_string);
    }
  } else
#line 777
  if ((unsigned int )formula->type != 21U) {
#line 777
    if ((unsigned int )formula->type != 22U) {
#line 777
      if ((unsigned int )formula->type != 20U) {
#line 777
        if ((unsigned int )formula->type != 24U) {
#line 777
          if ((unsigned int )formula->type != 25U) {
#line 777
            if ((unsigned int )formula->type != 26U) {
#line 777
              if ((unsigned int )formula->type != 27U) {
#line 777
                if ((unsigned int )formula->type != 28U) {
#line 777
                  if ((unsigned int )formula->type != 19U) {
#line 777
                    if ((unsigned int )formula->type != 0U) {
                      {
#line 787
                      psiconv_free_formula_list(formula->data.fun_operands);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 788
  return;
}
}
#line 790 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_formula(psiconv_formula formula ) 
{ 


  {
#line 792
  if (formula) {
    {
#line 793
    psiconv_free_formula_aux((void *)formula);
#line 794
    free((void *)formula);
    }
  }
#line 796
  return;
}
}
#line 798 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_formula_list(psiconv_formula_list list ) 
{ 


  {
#line 800
  if (list) {
    {
#line 801
    psiconv_list_free_el(list, & psiconv_free_formula_aux);
    }
  }
#line 802
  return;
}
}
#line 804 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_sheet_name_section(psiconv_sheet_name_section section ) 
{ 


  {
#line 806
  if (section) {
#line 807
    if (section->name) {
      {
#line 808
      free((void *)section->name);
      }
    }
    {
#line 809
    free((void *)section);
    }
  }
#line 811
  return;
}
}
#line 813 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_sheet_info_section(psiconv_sheet_info_section section ) 
{ 


  {
#line 815
  if (section) {
    {
#line 816
    free((void *)section);
    }
  }
#line 818
  return;
}
}
#line 820 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_sheet_variable_aux(void *variable ) 
{ 
  psiconv_sheet_variable var ;

  {
#line 822
  var = (psiconv_sheet_variable )variable;
#line 823
  if (var->name) {
    {
#line 824
    free((void *)var->name);
    }
  }
#line 825
  if ((unsigned int )var->type == 2U) {
    {
#line 826
    free((void *)var->data.dat_string);
    }
  }
#line 827
  return;
}
}
#line 829 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_sheet_variable(psiconv_sheet_variable var ) 
{ 


  {
#line 831
  if (var) {
    {
#line 832
    psiconv_free_sheet_variable_aux((void *)var);
#line 833
    free((void *)var);
    }
  }
#line 835
  return;
}
}
#line 837 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_sheet_variable_list(psiconv_sheet_variable_list list ) 
{ 


  {
#line 839
  if (list) {
    {
#line 840
    psiconv_list_free_el(list, & psiconv_free_sheet_variable_aux);
    }
  }
#line 841
  return;
}
}
#line 843 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_sheet_workbook_section(psiconv_sheet_workbook_section section ) 
{ 


  {
#line 845
  if (section) {
    {
#line 846
    psiconv_free_formula_list(section->formulas);
#line 847
    psiconv_free_sheet_worksheet_list(section->worksheets);
#line 848
    psiconv_free_sheet_name_section(section->name);
#line 849
    psiconv_free_sheet_info_section(section->info);
#line 850
    psiconv_free_sheet_variable_list(section->variables);
#line 851
    free((void *)section);
    }
  }
#line 853
  return;
}
}
#line 855 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_sheet_f(psiconv_sheet_f file ) 
{ 


  {
#line 857
  if (file) {
    {
#line 858
    psiconv_free_page_layout_section(file->page_sec);
#line 859
    psiconv_free_sheet_status_section(file->status_sec);
#line 860
    psiconv_free_sheet_workbook_section(file->workbook_sec);
#line 861
    free((void *)file);
    }
  }
#line 863
  return;
}
}
#line 865 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_texted_f(psiconv_texted_f file ) 
{ 


  {
#line 867
  if (file) {
    {
#line 868
    psiconv_free_page_layout_section(file->page_sec);
#line 869
    psiconv_free_texted_section(file->texted_sec);
#line 870
    free((void *)file);
    }
  }
#line 872
  return;
}
}
#line 874 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_paint_data_section_aux(void *section ) 
{ 


  {
#line 876
  if (((psiconv_paint_data_section )section)->red) {
    {
#line 877
    free((void *)((psiconv_paint_data_section )section)->red);
    }
  }
#line 878
  if (((psiconv_paint_data_section )section)->green) {
    {
#line 879
    free((void *)((psiconv_paint_data_section )section)->green);
    }
  }
#line 880
  if (((psiconv_paint_data_section )section)->blue) {
    {
#line 881
    free((void *)((psiconv_paint_data_section )section)->blue);
    }
  }
#line 882
  return;
}
}
#line 884 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_paint_data_section(psiconv_paint_data_section section ) 
{ 


  {
#line 886
  if (section) {
    {
#line 887
    psiconv_free_paint_data_section_aux((void *)section);
#line 888
    free((void *)section);
    }
  }
#line 890
  return;
}
}
#line 892 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_pictures(psiconv_pictures section ) 
{ 


  {
#line 894
  if (section) {
    {
#line 895
    psiconv_list_free_el(section, & psiconv_free_paint_data_section_aux);
    }
  }
#line 896
  return;
}
}
#line 898 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_jumptable_section(psiconv_jumptable_section section ) 
{ 


  {
#line 900
  if (section) {
    {
#line 901
    psiconv_list_free(section);
    }
  }
#line 902
  return;
}
}
#line 904 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_mbm_f(psiconv_mbm_f file ) 
{ 


  {
#line 906
  if (file) {
    {
#line 907
    psiconv_free_pictures(file->sections);
#line 908
    free((void *)file);
    }
  }
#line 910
  return;
}
}
#line 912 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_sketch_section(psiconv_sketch_section sec ) 
{ 


  {
#line 914
  if (sec) {
    {
#line 915
    psiconv_free_paint_data_section(sec->picture);
#line 916
    free((void *)sec);
    }
  }
#line 918
  return;
}
}
#line 920 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_sketch_f(psiconv_sketch_f file ) 
{ 


  {
#line 922
  if (file) {
    {
#line 923
    psiconv_free_sketch_section(file->sketch_sec);
#line 924
    free((void *)file);
    }
  }
#line 926
  return;
}
}
#line 928 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_clipart_section_aux(void *section ) 
{ 


  {
#line 930
  if (section) {
    {
#line 931
    psiconv_free_paint_data_section(((psiconv_clipart_section )section)->picture);
    }
  }
#line 932
  return;
}
}
#line 934 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_clipart_section(psiconv_clipart_section section ) 
{ 


  {
#line 936
  if (section) {
    {
#line 937
    psiconv_free_clipart_section_aux((void *)section);
#line 938
    free((void *)section);
    }
  }
#line 940
  return;
}
}
#line 942 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_cliparts(psiconv_cliparts section ) 
{ 


  {
#line 944
  if (section) {
    {
#line 945
    psiconv_list_free_el(section, & psiconv_free_clipart_section_aux);
    }
  }
#line 946
  return;
}
}
#line 948 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_clipart_f(psiconv_clipart_f file ) 
{ 


  {
#line 950
  if (file) {
    {
#line 951
    psiconv_free_cliparts(file->sections);
#line 952
    free((void *)file);
    }
  }
#line 954
  return;
}
}
#line 956 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
void psiconv_free_file(psiconv_file file ) 
{ 


  {
#line 958
  if (file) {
#line 959
    if ((unsigned int )file->type == 1U) {
      {
#line 960
      psiconv_free_word_f((psiconv_word_f )file->file);
      }
    } else
#line 961
    if ((unsigned int )file->type == 2U) {
      {
#line 962
      psiconv_free_texted_f((psiconv_texted_f )file->file);
      }
    } else
#line 963
    if ((unsigned int )file->type == 3U) {
      {
#line 964
      psiconv_free_mbm_f((psiconv_mbm_f )file->file);
      }
    } else
#line 965
    if ((unsigned int )file->type == 4U) {
      {
#line 966
      psiconv_free_sketch_f((psiconv_sketch_f )file->file);
      }
    } else
#line 967
    if ((unsigned int )file->type == 5U) {
      {
#line 968
      psiconv_free_clipart_f((psiconv_clipart_f )file->file);
      }
    } else
#line 969
    if ((unsigned int )file->type == 6U) {
      {
#line 970
      psiconv_free_sheet_f((psiconv_sheet_f )file->file);
      }
    }
    {
#line 971
    free((void *)file);
    }
  }
#line 973
  return;
}
}
#line 975 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
int psiconv_compare_color(psiconv_color const   value1 , psiconv_color const   value2 ) 
{ 


  {
#line 978
  if (! value1) {
#line 979
    return (1);
  } else
#line 978
  if (! value2) {
#line 979
    return (1);
  }
#line 980
  if ((int )value1->red == (int )value2->red) {
#line 980
    if ((int )value1->green == (int )value2->green) {
#line 980
      if ((int )value1->blue == (int )value2->blue) {
#line 983
        return (0);
      } else {
#line 985
        return (1);
      }
    } else {
#line 985
      return (1);
    }
  } else {
#line 985
    return (1);
  }
}
}
#line 988 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
int psiconv_compare_font(psiconv_font const   value1 , psiconv_font const   value2 ) 
{ 
  int tmp ;

  {
#line 991
  if (! value1) {
#line 992
    return (1);
  } else
#line 991
  if (! value2) {
#line 992
    return (1);
  } else
#line 991
  if (! value1->name) {
#line 992
    return (1);
  } else
#line 991
  if (! value2->name) {
#line 992
    return (1);
  }
#line 993
  if ((unsigned int )value1->screenfont == (unsigned int )value2->screenfont) {
    {
#line 993
    tmp = psiconv_unicode_strcmp((psiconv_ucs2 const   *)value1->name, (psiconv_ucs2 const   *)value2->name);
    }
#line 993
    if (tmp) {
#line 997
      return (1);
    } else {
#line 995
      return (0);
    }
  } else {
#line 997
    return (1);
  }
}
}
#line 1000 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
int psiconv_compare_border(psiconv_border const   value1 , psiconv_border const   value2 ) 
{ 
  int tmp ;

  {
#line 1003
  if (! value1) {
#line 1004
    return (1);
  } else
#line 1003
  if (! value2) {
#line 1004
    return (1);
  }
#line 1005
  if ((unsigned int )value1->kind == (unsigned int )value2->kind) {
#line 1005
    if (value1->thickness == value2->thickness) {
      {
#line 1005
      tmp = psiconv_compare_color((psiconv_color const   )value1->color, (psiconv_color const   )value2->color);
      }
#line 1005
      if (tmp) {
#line 1010
        return (1);
      } else {
#line 1008
        return (0);
      }
    } else {
#line 1010
      return (1);
    }
  } else {
#line 1010
    return (1);
  }
}
}
#line 1013 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
int psiconv_compare_bullet(psiconv_bullet const   value1 , psiconv_bullet const   value2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1016
  if (! value1) {
#line 1017
    return (1);
  } else
#line 1016
  if (! value2) {
#line 1017
    return (1);
  }
#line 1018
  if ((unsigned int )value1->on == (unsigned int )value2->on) {
#line 1018
    if (value1->font_size == value2->font_size) {
#line 1018
      if ((int )value1->character == (int )value2->character) {
#line 1018
        if ((unsigned int )value1->indent == (unsigned int )value2->indent) {
          {
#line 1018
          tmp = psiconv_compare_color((psiconv_color const   )value1->color, (psiconv_color const   )value2->color);
          }
#line 1018
          if (tmp) {
#line 1026
            return (1);
          } else {
            {
#line 1018
            tmp___0 = psiconv_compare_font((psiconv_font const   )value1->font, (psiconv_font const   )value2->font);
            }
#line 1018
            if (tmp___0) {
#line 1026
              return (1);
            } else {
#line 1024
              return (0);
            }
          }
        } else {
#line 1026
          return (1);
        }
      } else {
#line 1026
        return (1);
      }
    } else {
#line 1026
      return (1);
    }
  } else {
#line 1026
    return (1);
  }
}
}
#line 1029 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
int psiconv_compare_tab(psiconv_tab const   value1 , psiconv_tab const   value2 ) 
{ 


  {
#line 1031
  if (! value1) {
#line 1032
    return (1);
  } else
#line 1031
  if (! value2) {
#line 1032
    return (1);
  }
#line 1033
  if (value1->location == value2->location) {
#line 1033
    if ((unsigned int )value1->kind == (unsigned int )value2->kind) {
#line 1035
      return (0);
    } else {
#line 1037
      return (1);
    }
  } else {
#line 1037
    return (1);
  }
}
}
#line 1040 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
int psiconv_compare_all_tabs(psiconv_all_tabs const   value1 , psiconv_all_tabs const   value2 ) 
{ 
  int i ;
  psiconv_u32 tmp ;
  psiconv_u32 tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  psiconv_u32 tmp___4 ;

  {
#line 1045
  if (! value1) {
#line 1046
    return (1);
  } else
#line 1045
  if (! value2) {
#line 1046
    return (1);
  } else
#line 1045
  if (! value1->extras) {
#line 1046
    return (1);
  } else
#line 1045
  if (! value2->extras) {
#line 1046
    return (1);
  }
#line 1048
  if (value1->normal != value2->normal) {
#line 1051
    return (1);
  } else {
    {
#line 1048
    tmp = psiconv_list_length((psiconv_list const   )value1->extras);
#line 1048
    tmp___0 = psiconv_list_length((psiconv_list const   )value2->extras);
    }
#line 1048
    if (tmp != tmp___0) {
#line 1051
      return (1);
    }
  }
#line 1052
  i = 0;
  {
#line 1052
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1052
    tmp___4 = psiconv_list_length((psiconv_list const   )value1->extras);
    }
#line 1052
    if (! ((psiconv_u32 )i < tmp___4)) {
#line 1052
      goto while_break;
    }
    {
#line 1053
    tmp___1 = psiconv_list_get((psiconv_list const   )value2->extras, (psiconv_u32 )i);
#line 1053
    tmp___2 = psiconv_list_get((psiconv_list const   )value1->extras, (psiconv_u32 )i);
#line 1053
    tmp___3 = psiconv_compare_tab((psiconv_tab const   )tmp___2, (psiconv_tab const   )tmp___1);
    }
#line 1053
    if (tmp___3) {
#line 1056
      return (1);
    }
#line 1052
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1057
  return (0);
}
}
#line 1060 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
int psiconv_compare_paragraph_layout(psiconv_paragraph_layout const   value1 , psiconv_paragraph_layout const   value2 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1063
  if (! value1) {
#line 1064
    return (1);
  } else
#line 1063
  if (! value2) {
#line 1064
    return (1);
  }
#line 1065
  if (value1->indent_left == value2->indent_left) {
#line 1065
    if (value1->indent_right == value2->indent_right) {
#line 1065
      if (value1->indent_first == value2->indent_first) {
#line 1065
        if ((unsigned int )value1->justify_hor == (unsigned int )value2->justify_hor) {
#line 1065
          if ((unsigned int )value1->justify_ver == (unsigned int )value2->justify_ver) {
#line 1065
            if (value1->linespacing == value2->linespacing) {
#line 1065
              if (value1->space_above == value2->space_above) {
#line 1065
                if (value1->space_below == value2->space_below) {
#line 1065
                  if ((unsigned int )value1->keep_together == (unsigned int )value2->keep_together) {
#line 1065
                    if ((unsigned int )value1->keep_with_next == (unsigned int )value2->keep_with_next) {
#line 1065
                      if ((unsigned int )value1->on_next_page == (unsigned int )value2->on_next_page) {
#line 1065
                        if ((unsigned int )value1->no_widow_protection == (unsigned int )value2->no_widow_protection) {
#line 1065
                          if (value1->border_distance == value2->border_distance) {
                            {
#line 1065
                            tmp = psiconv_compare_color((psiconv_color const   )value1->back_color,
                                                        (psiconv_color const   )value2->back_color);
                            }
#line 1065
                            if (tmp) {
#line 1087
                              return (1);
                            } else {
                              {
#line 1065
                              tmp___0 = psiconv_compare_bullet((psiconv_bullet const   )value1->bullet,
                                                               (psiconv_bullet const   )value2->bullet);
                              }
#line 1065
                              if (tmp___0) {
#line 1087
                                return (1);
                              } else {
                                {
#line 1065
                                tmp___1 = psiconv_compare_border((psiconv_border const   )value1->left_border,
                                                                 (psiconv_border const   )value2->left_border);
                                }
#line 1065
                                if (tmp___1) {
#line 1087
                                  return (1);
                                } else {
                                  {
#line 1065
                                  tmp___2 = psiconv_compare_border((psiconv_border const   )value1->right_border,
                                                                   (psiconv_border const   )value2->right_border);
                                  }
#line 1065
                                  if (tmp___2) {
#line 1087
                                    return (1);
                                  } else {
                                    {
#line 1065
                                    tmp___3 = psiconv_compare_border((psiconv_border const   )value1->top_border,
                                                                     (psiconv_border const   )value2->top_border);
                                    }
#line 1065
                                    if (tmp___3) {
#line 1087
                                      return (1);
                                    } else {
                                      {
#line 1065
                                      tmp___4 = psiconv_compare_border((psiconv_border const   )value1->bottom_border,
                                                                       (psiconv_border const   )value2->bottom_border);
                                      }
#line 1065
                                      if (tmp___4) {
#line 1087
                                        return (1);
                                      } else {
                                        {
#line 1065
                                        tmp___5 = psiconv_compare_all_tabs((psiconv_all_tabs const   )value1->tabs,
                                                                           (psiconv_all_tabs const   )value2->tabs);
                                        }
#line 1065
                                        if (tmp___5) {
#line 1087
                                          return (1);
                                        } else {
#line 1085
                                          return (0);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          } else {
#line 1087
                            return (1);
                          }
                        } else {
#line 1087
                          return (1);
                        }
                      } else {
#line 1087
                        return (1);
                      }
                    } else {
#line 1087
                      return (1);
                    }
                  } else {
#line 1087
                    return (1);
                  }
                } else {
#line 1087
                  return (1);
                }
              } else {
#line 1087
                return (1);
              }
            } else {
#line 1087
              return (1);
            }
          } else {
#line 1087
            return (1);
          }
        } else {
#line 1087
          return (1);
        }
      } else {
#line 1087
        return (1);
      }
    } else {
#line 1087
      return (1);
    }
  } else {
#line 1087
    return (1);
  }
}
}
#line 1091 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
int psiconv_compare_character_layout(psiconv_character_layout const   value1 , psiconv_character_layout const   value2 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1094
  if (! value1) {
#line 1095
    return (1);
  } else
#line 1094
  if (! value2) {
#line 1095
    return (1);
  }
#line 1096
  if (value1->font_size == value2->font_size) {
#line 1096
    if ((unsigned int )value1->italic == (unsigned int )value2->italic) {
#line 1096
      if ((unsigned int )value1->bold == (unsigned int )value2->bold) {
#line 1096
        if ((unsigned int )value1->super_sub == (unsigned int )value2->super_sub) {
#line 1096
          if ((unsigned int )value1->underline == (unsigned int )value2->underline) {
#line 1096
            if ((unsigned int )value1->strikethrough == (unsigned int )value2->strikethrough) {
              {
#line 1096
              tmp = psiconv_compare_color((psiconv_color const   )value1->color, (psiconv_color const   )value2->color);
              }
#line 1096
              if (tmp) {
#line 1107
                return (1);
              } else {
                {
#line 1096
                tmp___0 = psiconv_compare_color((psiconv_color const   )value1->back_color,
                                                (psiconv_color const   )value2->back_color);
                }
#line 1096
                if (tmp___0) {
#line 1107
                  return (1);
                } else {
                  {
#line 1096
                  tmp___1 = psiconv_compare_font((psiconv_font const   )value1->font,
                                                 (psiconv_font const   )value2->font);
                  }
#line 1096
                  if (tmp___1) {
#line 1107
                    return (1);
                  } else {
#line 1105
                    return (0);
                  }
                }
              }
            } else {
#line 1107
              return (1);
            }
          } else {
#line 1107
            return (1);
          }
        } else {
#line 1107
          return (1);
        }
      } else {
#line 1107
        return (1);
      }
    } else {
#line 1107
      return (1);
    }
  } else {
#line 1107
    return (1);
  }
}
}
#line 1112 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_word_styles_section psiconv_empty_word_styles_section(void) 
{ 
  psiconv_word_styles_section result ;
  void *tmp ;
  psiconv_word_style_list tmp___0 ;
  psiconv_word_style tmp___1 ;
  void *tmp___2 ;
  psiconv_character_layout tmp___3 ;
  psiconv_paragraph_layout tmp___4 ;

  {
  {
#line 1115
  tmp = malloc(sizeof(*result));
#line 1115
  result = (psiconv_word_styles_section )tmp;
  }
#line 1115
  if (! result) {
#line 1116
    goto ERROR1;
  }
  {
#line 1117
  tmp___0 = psiconv_list_new(sizeof(struct psiconv_word_style_s ));
#line 1117
  result->styles = tmp___0;
  }
#line 1117
  if (! tmp___0) {
#line 1118
    goto ERROR2;
  }
  {
#line 1119
  tmp___2 = malloc(sizeof(struct psiconv_word_style_s ));
#line 1119
  tmp___1 = (psiconv_word_style )tmp___2;
#line 1119
  result->normal = tmp___1;
  }
#line 1119
  if (! tmp___1) {
#line 1120
    goto ERROR3;
  }
  {
#line 1121
  tmp___3 = psiconv_basic_character_layout();
#line 1121
  (result->normal)->character = tmp___3;
  }
#line 1121
  if (! tmp___3) {
#line 1122
    goto ERROR4;
  }
  {
#line 1123
  tmp___4 = psiconv_basic_paragraph_layout();
#line 1123
  (result->normal)->paragraph = tmp___4;
  }
#line 1123
  if (! tmp___4) {
#line 1124
    goto ERROR5;
  }
#line 1125
  (result->normal)->hotkey = (psiconv_ucs2 )'N';
#line 1126
  (result->normal)->name = (psiconv_string_t )((void *)0);
#line 1127
  (result->normal)->built_in = (psiconv_bool_t )1;
#line 1128
  (result->normal)->outline_level = (psiconv_u32 )0;
#line 1129
  return (result);
  ERROR5: 
  {
#line 1131
  psiconv_free_character_layout((result->normal)->character);
  }
  ERROR4: 
  {
#line 1133
  free((void *)result->normal);
  }
  ERROR3: 
  {
#line 1135
  psiconv_list_free(result->styles);
  }
  ERROR2: 
  {
#line 1137
  free((void *)result);
  }
  ERROR1: 
#line 1139
  return ((psiconv_word_styles_section )((void *)0));
}
}
#line 1142 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_text_and_layout psiconv_empty_text_and_layout(void) 
{ 
  psiconv_list tmp ;

  {
  {
#line 1144
  tmp = psiconv_list_new(sizeof(struct psiconv_paragraph_s ));
  }
#line 1144
  return (tmp);
}
}
#line 1147 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_texted_section psiconv_empty_texted_section(void) 
{ 
  psiconv_texted_section result ;
  void *tmp ;
  psiconv_text_and_layout tmp___0 ;

  {
  {
#line 1150
  tmp = malloc(sizeof(*result));
#line 1150
  result = (psiconv_texted_section )tmp;
  }
#line 1150
  if (! result) {
#line 1151
    goto ERROR1;
  }
  {
#line 1152
  tmp___0 = psiconv_empty_text_and_layout();
#line 1152
  result->paragraphs = tmp___0;
  }
#line 1152
  if (! tmp___0) {
#line 1153
    goto ERROR2;
  }
#line 1154
  return (result);
  ERROR2: 
  {
#line 1156
  free((void *)result);
  }
  ERROR1: 
#line 1158
  return ((psiconv_texted_section )((void *)0));
}
}
#line 1161 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_page_header psiconv_empty_page_header(void) 
{ 
  psiconv_page_header result ;
  void *tmp ;
  psiconv_paragraph_layout tmp___0 ;
  psiconv_character_layout tmp___1 ;
  psiconv_texted_section tmp___2 ;

  {
  {
#line 1164
  tmp = malloc(sizeof(*result));
#line 1164
  result = (psiconv_page_header )tmp;
  }
#line 1164
  if (! result) {
#line 1165
    goto ERROR1;
  }
  {
#line 1166
  result->on_first_page = (psiconv_bool_t )1;
#line 1167
  tmp___0 = psiconv_basic_paragraph_layout();
#line 1167
  result->base_paragraph_layout = tmp___0;
  }
#line 1167
  if (! tmp___0) {
#line 1168
    goto ERROR2;
  }
  {
#line 1169
  tmp___1 = psiconv_basic_character_layout();
#line 1169
  result->base_character_layout = tmp___1;
  }
#line 1169
  if (! tmp___1) {
#line 1170
    goto ERROR3;
  }
  {
#line 1171
  tmp___2 = psiconv_empty_texted_section();
#line 1171
  result->text = tmp___2;
  }
#line 1171
  if (! tmp___2) {
#line 1172
    goto ERROR4;
  }
#line 1173
  return (result);
  ERROR4: 
  {
#line 1175
  psiconv_free_character_layout(result->base_character_layout);
  }
  ERROR3: 
  {
#line 1177
  psiconv_free_paragraph_layout(result->base_paragraph_layout);
  }
  ERROR2: 
  {
#line 1179
  free((void *)result);
  }
  ERROR1: 
#line 1181
  return ((psiconv_page_header )((void *)0));
}
}
#line 1184 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_page_layout_section psiconv_empty_page_layout_section(void) 
{ 
  psiconv_page_layout_section result ;
  void *tmp ;
  psiconv_length_t tmp___0 ;
  psiconv_length_t tmp___1 ;
  psiconv_length_t tmp___2 ;
  psiconv_page_header tmp___3 ;
  psiconv_page_header tmp___4 ;

  {
  {
#line 1187
  tmp = malloc(sizeof(*result));
#line 1187
  result = (psiconv_page_layout_section )tmp;
  }
#line 1187
  if (! result) {
#line 1188
    goto ERROR1;
  }
  {
#line 1189
  result->first_page_nr = (psiconv_u32 )1;
#line 1190
  tmp___0 = (psiconv_length_t )1.27;
#line 1190
  result->footer_dist = tmp___0;
#line 1190
  result->header_dist = tmp___0;
#line 1191
  tmp___1 = (psiconv_length_t )3.175;
#line 1191
  result->right_margin = tmp___1;
#line 1191
  result->left_margin = tmp___1;
#line 1192
  tmp___2 = (psiconv_length_t )2.54;
#line 1192
  result->bottom_margin = tmp___2;
#line 1192
  result->top_margin = tmp___2;
#line 1193
  result->page_width = (psiconv_length_t )21.0;
#line 1194
  result->page_height = (psiconv_length_t )29.7;
#line 1195
  result->landscape = (psiconv_bool_t )0;
#line 1196
  tmp___3 = psiconv_empty_page_header();
#line 1196
  result->header = tmp___3;
  }
#line 1196
  if (! tmp___3) {
#line 1197
    goto ERROR2;
  }
  {
#line 1198
  tmp___4 = psiconv_empty_page_header();
#line 1198
  result->footer = tmp___4;
  }
#line 1198
  if (! tmp___4) {
#line 1199
    goto ERROR3;
  }
#line 1200
  return (result);
  ERROR3: 
  {
#line 1202
  psiconv_free_page_header(result->header);
  }
  ERROR2: 
  {
#line 1204
  free((void *)result);
  }
  ERROR1: 
#line 1206
  return ((psiconv_page_layout_section )((void *)0));
}
}
#line 1209 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_word_status_section psiconv_empty_word_status_section(void) 
{ 
  psiconv_word_status_section result ;
  void *tmp ;
  psiconv_bool_t tmp___0 ;
  psiconv_bool_t tmp___1 ;
  psiconv_bool_t tmp___2 ;
  psiconv_bool_t tmp___3 ;
  psiconv_bool_t tmp___4 ;
  psiconv_bool_t tmp___5 ;
  psiconv_bool_t tmp___6 ;
  psiconv_bool_t tmp___7 ;

  {
  {
#line 1212
  tmp = malloc(sizeof(*result));
#line 1212
  result = (psiconv_word_status_section )tmp;
  }
#line 1212
  if (! result) {
#line 1213
    return ((psiconv_word_status_section )((void *)0));
  }
#line 1214
  tmp___4 = (psiconv_bool_t )0;
#line 1214
  result->fit_lines_to_screen = tmp___4;
#line 1214
  tmp___3 = tmp___4;
#line 1214
  result->show_hard_space = tmp___3;
#line 1214
  tmp___2 = tmp___3;
#line 1214
  result->show_hard_minus = tmp___2;
#line 1214
  tmp___1 = tmp___2;
#line 1214
  result->show_paragraph_ends = tmp___1;
#line 1214
  tmp___0 = tmp___1;
#line 1214
  result->show_spaces = tmp___0;
#line 1214
  result->show_tabs = tmp___0;
#line 1217
  tmp___7 = (psiconv_bool_t )1;
#line 1217
  result->show_side_toolbar = tmp___7;
#line 1217
  tmp___6 = tmp___7;
#line 1217
  result->show_top_toolbar = tmp___6;
#line 1217
  tmp___5 = tmp___6;
#line 1217
  result->show_full_graphs = tmp___5;
#line 1217
  result->show_full_pictures = tmp___5;
#line 1220
  result->cursor_position = (psiconv_u32 )0;
#line 1221
  result->display_size = (psiconv_u32 )1000;
#line 1222
  return (result);
}
}
#line 1225 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_word_f psiconv_empty_word_f(void) 
{ 
  psiconv_word_f result ;
  void *tmp ;
  psiconv_page_layout_section tmp___0 ;
  psiconv_text_and_layout tmp___1 ;
  psiconv_word_status_section tmp___2 ;
  psiconv_word_styles_section tmp___3 ;

  {
  {
#line 1228
  tmp = malloc(sizeof(*result));
#line 1228
  result = (psiconv_word_f )tmp;
  }
#line 1228
  if (! result) {
#line 1229
    goto ERROR1;
  }
  {
#line 1230
  tmp___0 = psiconv_empty_page_layout_section();
#line 1230
  result->page_sec = tmp___0;
  }
#line 1230
  if (! tmp___0) {
#line 1231
    goto ERROR2;
  }
  {
#line 1232
  tmp___1 = psiconv_empty_text_and_layout();
#line 1232
  result->paragraphs = tmp___1;
  }
#line 1232
  if (! tmp___1) {
#line 1233
    goto ERROR3;
  }
  {
#line 1234
  tmp___2 = psiconv_empty_word_status_section();
#line 1234
  result->status_sec = tmp___2;
  }
#line 1234
  if (! tmp___2) {
#line 1235
    goto ERROR4;
  }
  {
#line 1236
  tmp___3 = psiconv_empty_word_styles_section();
#line 1236
  result->styles_sec = tmp___3;
  }
#line 1236
  if (! tmp___3) {
#line 1237
    goto ERROR5;
  }
#line 1238
  return (result);
  ERROR5: 
  {
#line 1240
  psiconv_free_word_status_section(result->status_sec);
  }
  ERROR4: 
  {
#line 1242
  psiconv_free_text_and_layout(result->paragraphs);
  }
  ERROR3: 
  {
#line 1244
  psiconv_free_page_layout_section(result->page_sec);
  }
  ERROR2: 
  {
#line 1246
  free((void *)result);
  }
  ERROR1: 
#line 1248
  return ((psiconv_word_f )((void *)0));
}
}
#line 1251 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sheet_status_section psiconv_empty_sheet_status_section(void) 
{ 
  psiconv_sheet_status_section result ;
  void *tmp ;
  psiconv_triple_t tmp___0 ;
  psiconv_bool_t tmp___1 ;
  psiconv_bool_t tmp___2 ;
  psiconv_bool_t tmp___3 ;
  psiconv_u32 tmp___4 ;
  psiconv_u32 tmp___5 ;

  {
  {
#line 1254
  tmp = malloc(sizeof(*result));
#line 1254
  result = (psiconv_sheet_status_section )tmp;
  }
#line 1254
  if (! result) {
#line 1255
    return ((psiconv_sheet_status_section )((void *)0));
  }
#line 1256
  tmp___0 = (psiconv_triple_t )2;
#line 1256
  result->show_vertical_scrollbar = tmp___0;
#line 1256
  result->show_horizontal_scrollbar = tmp___0;
#line 1258
  result->show_graph = (psiconv_bool_t )0;
#line 1259
  tmp___3 = (psiconv_bool_t )1;
#line 1259
  result->show_side_graph_toolbar = tmp___3;
#line 1259
  tmp___2 = tmp___3;
#line 1259
  result->show_top_graph_toolbar = tmp___2;
#line 1259
  tmp___1 = tmp___2;
#line 1259
  result->show_side_sheet_toolbar = tmp___1;
#line 1259
  result->show_top_sheet_toolbar = tmp___1;
#line 1262
  tmp___4 = (psiconv_u32 )0;
#line 1262
  result->cursor_column = tmp___4;
#line 1262
  result->cursor_row = tmp___4;
#line 1263
  tmp___5 = (psiconv_u32 )1000;
#line 1263
  result->graph_display_size = tmp___5;
#line 1263
  result->sheet_display_size = tmp___5;
#line 1264
  return (result);
}
}
#line 1267 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_formula_list psiconv_empty_formula_list(void) 
{ 
  psiconv_list tmp ;

  {
  {
#line 1269
  tmp = psiconv_list_new(sizeof(struct psiconv_formula_s ));
  }
#line 1269
  return (tmp);
}
}
#line 1272 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sheet_workbook_section psiconv_empty_sheet_workbook_section(void) 
{ 
  psiconv_sheet_workbook_section result ;
  void *tmp ;
  psiconv_formula_list tmp___0 ;

  {
  {
#line 1275
  tmp = malloc(sizeof(*result));
#line 1275
  result = (psiconv_sheet_workbook_section )tmp;
  }
#line 1275
  if (! result) {
#line 1276
    goto ERROR1;
  }
  {
#line 1277
  tmp___0 = psiconv_empty_formula_list();
#line 1277
  result->formulas = tmp___0;
  }
#line 1277
  if (! tmp___0) {
#line 1278
    goto ERROR2;
  }
#line 1279
  return (result);
  ERROR2: 
  {
#line 1281
  free((void *)result);
  }
  ERROR1: 
#line 1283
  return ((psiconv_sheet_workbook_section )((void *)0));
}
}
#line 1287 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sheet_f psiconv_empty_sheet_f(void) 
{ 
  psiconv_sheet_f result ;
  void *tmp ;
  psiconv_page_layout_section tmp___0 ;
  psiconv_sheet_status_section tmp___1 ;
  psiconv_sheet_workbook_section tmp___2 ;

  {
  {
#line 1290
  tmp = malloc(sizeof(*result));
#line 1290
  result = (psiconv_sheet_f )tmp;
  }
#line 1290
  if (! result) {
#line 1291
    goto ERROR1;
  }
  {
#line 1292
  tmp___0 = psiconv_empty_page_layout_section();
#line 1292
  result->page_sec = tmp___0;
  }
#line 1292
  if (! tmp___0) {
#line 1293
    goto ERROR2;
  }
  {
#line 1294
  tmp___1 = psiconv_empty_sheet_status_section();
#line 1294
  result->status_sec = tmp___1;
  }
#line 1294
  if (! tmp___1) {
#line 1295
    goto ERROR3;
  }
  {
#line 1296
  tmp___2 = psiconv_empty_sheet_workbook_section();
#line 1296
  result->workbook_sec = tmp___2;
  }
#line 1296
  if (! tmp___2) {
#line 1297
    goto ERROR4;
  }
#line 1298
  return (result);
  ERROR4: 
  {
#line 1300
  psiconv_free_sheet_status_section(result->status_sec);
  }
  ERROR3: 
  {
#line 1302
  psiconv_free_page_layout_section(result->page_sec);
  }
  ERROR2: 
  {
#line 1304
  free((void *)result);
  }
  ERROR1: 
#line 1306
  return ((psiconv_sheet_f )((void *)0));
}
}
#line 1309 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_texted_f psiconv_empty_texted_f(void) 
{ 
  psiconv_texted_f result ;
  void *tmp ;
  psiconv_page_layout_section tmp___0 ;
  psiconv_texted_section tmp___1 ;

  {
  {
#line 1312
  tmp = malloc(sizeof(*result));
#line 1312
  result = (psiconv_texted_f )tmp;
  }
#line 1312
  if (! result) {
#line 1313
    goto ERROR1;
  }
  {
#line 1314
  tmp___0 = psiconv_empty_page_layout_section();
#line 1314
  result->page_sec = tmp___0;
  }
#line 1314
  if (! tmp___0) {
#line 1315
    goto ERROR2;
  }
  {
#line 1316
  tmp___1 = psiconv_empty_texted_section();
#line 1316
  result->texted_sec = tmp___1;
  }
#line 1316
  if (! tmp___1) {
#line 1317
    goto ERROR3;
  }
#line 1318
  return (result);
  ERROR3: 
  {
#line 1320
  psiconv_free_page_layout_section(result->page_sec);
  }
  ERROR2: 
  {
#line 1322
  free((void *)result);
  }
  ERROR1: 
#line 1324
  return ((psiconv_texted_f )((void *)0));
}
}
#line 1327 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_paint_data_section psiconv_empty_paint_data_section(void) 
{ 
  psiconv_paint_data_section result ;
  void *tmp ;
  psiconv_u32 tmp___0 ;
  psiconv_length_t tmp___1 ;
  psiconv_length_t tmp___2 ;
  float *tmp___3 ;
  void *tmp___4 ;
  float *tmp___5 ;
  void *tmp___6 ;
  float *tmp___7 ;
  void *tmp___8 ;

  {
  {
#line 1330
  tmp = malloc(sizeof(*result));
#line 1330
  result = (psiconv_paint_data_section )tmp;
  }
#line 1330
  if (! result) {
#line 1331
    goto ERROR1;
  }
  {
#line 1333
  tmp___2 = (psiconv_length_t )0;
#line 1333
  result->pic_ysize = tmp___2;
#line 1333
  tmp___1 = tmp___2;
#line 1333
  result->pic_xsize = tmp___1;
#line 1333
  tmp___0 = (psiconv_u32 )tmp___1;
#line 1333
  result->ysize = tmp___0;
#line 1333
  result->xsize = tmp___0;
#line 1335
  tmp___4 = malloc((size_t )0);
#line 1335
  tmp___3 = (float *)tmp___4;
#line 1335
  result->red = tmp___3;
  }
#line 1335
  if (! tmp___3) {
#line 1336
    goto ERROR2;
  }
  {
#line 1337
  tmp___6 = malloc((size_t )0);
#line 1337
  tmp___5 = (float *)tmp___6;
#line 1337
  result->green = tmp___5;
  }
#line 1337
  if (! tmp___5) {
#line 1338
    goto ERROR3;
  }
  {
#line 1339
  tmp___8 = malloc((size_t )0);
#line 1339
  tmp___7 = (float *)tmp___8;
#line 1339
  result->blue = tmp___7;
  }
#line 1339
  if (! tmp___7) {
#line 1340
    goto ERROR4;
  }
#line 1341
  return (result);
  ERROR4: 
  {
#line 1343
  free((void *)result->green);
  }
  ERROR3: 
  {
#line 1345
  free((void *)result->red);
  }
  ERROR2: 
  {
#line 1347
  free((void *)result);
  }
  ERROR1: 
#line 1349
  return ((psiconv_paint_data_section )((void *)0));
}
}
#line 1353 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_pictures psiconv_empty_pictures(void) 
{ 
  psiconv_pictures result ;
  psiconv_paint_data_section pds ;
  int tmp ;

  {
  {
#line 1357
  result = psiconv_list_new(sizeof(struct psiconv_paint_data_section_s ));
  }
#line 1357
  if (! result) {
#line 1358
    goto ERROR1;
  }
  {
#line 1359
  pds = psiconv_empty_paint_data_section();
  }
#line 1359
  if (! pds) {
#line 1360
    goto ERROR2;
  }
  {
#line 1361
  tmp = psiconv_list_add(result, (void const   *)pds);
  }
#line 1361
  if (tmp) {
#line 1362
    goto ERROR3;
  }
  {
#line 1363
  free((void *)pds);
  }
#line 1364
  return (result);
  ERROR3: 
  {
#line 1366
  psiconv_free_paint_data_section(pds);
  }
  ERROR2: 
  {
#line 1368
  psiconv_list_free(result);
  }
  ERROR1: 
#line 1370
  return ((psiconv_pictures )((void *)0));
}
}
#line 1373 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_mbm_f psiconv_empty_mbm_f(void) 
{ 
  psiconv_mbm_f result ;
  void *tmp ;
  psiconv_pictures tmp___0 ;

  {
  {
#line 1376
  tmp = malloc(sizeof(*result));
#line 1376
  result = (psiconv_mbm_f )tmp;
  }
#line 1376
  if (! result) {
#line 1377
    goto ERROR1;
  }
  {
#line 1378
  tmp___0 = psiconv_empty_pictures();
#line 1378
  result->sections = tmp___0;
  }
#line 1378
  if (! tmp___0) {
#line 1379
    goto ERROR2;
  }
#line 1380
  return (result);
  ERROR2: 
  {
#line 1382
  free((void *)result);
  }
  ERROR1: 
#line 1384
  return ((psiconv_mbm_f )((void *)0));
}
}
#line 1387 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sketch_section psiconv_empty_sketch_section(void) 
{ 
  psiconv_sketch_section result ;
  void *tmp ;
  psiconv_u16 tmp___0 ;
  psiconv_u16 tmp___1 ;
  psiconv_u16 tmp___2 ;
  psiconv_u16 tmp___3 ;
  psiconv_u16 tmp___4 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;
  float tmp___8 ;
  psiconv_paint_data_section tmp___9 ;

  {
  {
#line 1390
  tmp = malloc(sizeof(*result));
#line 1390
  result = (psiconv_sketch_section )tmp;
  }
#line 1390
  if (! result) {
#line 1391
    goto ERROR1;
  }
  {
#line 1392
  result->displayed_xsize = (psiconv_u16 )320;
#line 1393
  result->displayed_ysize = (psiconv_u16 )200;
#line 1394
  tmp___4 = (psiconv_u16 )0;
#line 1394
  result->displayed_size_y_offset = tmp___4;
#line 1394
  tmp___3 = tmp___4;
#line 1394
  result->displayed_size_x_offset = tmp___3;
#line 1394
  tmp___2 = tmp___3;
#line 1394
  result->form_ysize = tmp___2;
#line 1394
  tmp___1 = tmp___2;
#line 1394
  result->form_xsize = tmp___1;
#line 1394
  tmp___0 = tmp___1;
#line 1394
  result->picture_data_y_offset = tmp___0;
#line 1394
  result->picture_data_x_offset = tmp___0;
#line 1397
  tmp___5 = (float )1.0;
#line 1397
  result->magnification_y = tmp___5;
#line 1397
  result->magnification_x = tmp___5;
#line 1398
  tmp___8 = (float )0.0;
#line 1398
  result->cut_bottom = tmp___8;
#line 1398
  tmp___7 = tmp___8;
#line 1398
  result->cut_top = tmp___7;
#line 1398
  tmp___6 = tmp___7;
#line 1398
  result->cut_right = tmp___6;
#line 1398
  result->cut_left = tmp___6;
#line 1400
  tmp___9 = psiconv_empty_paint_data_section();
#line 1400
  result->picture = tmp___9;
  }
#line 1400
  if (! tmp___9) {
#line 1401
    goto ERROR2;
  }
#line 1402
  return (result);
  ERROR2: 
  {
#line 1404
  free((void *)result);
  }
  ERROR1: 
#line 1406
  return ((psiconv_sketch_section )((void *)0));
}
}
#line 1409 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sketch_f psiconv_empty_sketch_f(void) 
{ 
  psiconv_sketch_f result ;
  void *tmp ;
  psiconv_sketch_section tmp___0 ;

  {
  {
#line 1412
  tmp = malloc(sizeof(*result));
#line 1412
  result = (psiconv_sketch_f )tmp;
  }
#line 1412
  if (! result) {
#line 1413
    goto ERROR1;
  }
  {
#line 1414
  tmp___0 = psiconv_empty_sketch_section();
#line 1414
  result->sketch_sec = tmp___0;
  }
#line 1414
  if (! tmp___0) {
#line 1415
    goto ERROR2;
  }
#line 1416
  return (result);
  ERROR2: 
  {
#line 1418
  free((void *)result);
  }
  ERROR1: 
#line 1420
  return ((psiconv_sketch_f )((void *)0));
}
}
#line 1423 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_cliparts psiconv_empty_cliparts(void) 
{ 
  psiconv_list tmp ;

  {
  {
#line 1426
  tmp = psiconv_list_new(sizeof(struct psiconv_clipart_section_s ));
  }
#line 1426
  return (tmp);
}
}
#line 1429 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_clipart_f psiconv_empty_clipart_f(void) 
{ 
  psiconv_clipart_f result ;
  void *tmp ;
  psiconv_cliparts tmp___0 ;

  {
  {
#line 1432
  tmp = malloc(sizeof(*result));
#line 1432
  result = (psiconv_clipart_f )tmp;
  }
#line 1432
  if (! result) {
#line 1433
    goto ERROR1;
  }
  {
#line 1434
  tmp___0 = psiconv_empty_cliparts();
#line 1434
  result->sections = tmp___0;
  }
#line 1434
  if (! tmp___0) {
#line 1435
    goto ERROR2;
  }
#line 1436
  return (result);
  ERROR2: 
  {
#line 1438
  free((void *)result);
  }
  ERROR1: 
#line 1440
  return ((psiconv_clipart_f )((void *)0));
}
}
#line 1443 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
psiconv_file psiconv_empty_file(psiconv_file_type_t type ) 
{ 
  psiconv_file result ;
  void *tmp ;
  void *tmp___0 ;
  psiconv_word_f tmp___1 ;
  void *tmp___2 ;
  psiconv_sheet_f tmp___3 ;
  void *tmp___4 ;
  psiconv_texted_f tmp___5 ;
  void *tmp___6 ;
  psiconv_mbm_f tmp___7 ;
  void *tmp___8 ;
  psiconv_sketch_f tmp___9 ;
  void *tmp___10 ;
  psiconv_clipart_f tmp___11 ;

  {
  {
#line 1446
  tmp = malloc(sizeof(*result));
#line 1446
  result = (psiconv_file )tmp;
  }
#line 1446
  if (! result) {
#line 1447
    return ((psiconv_file )((void *)0));
  }
#line 1448
  result->type = type;
#line 1449
  if ((unsigned int )type == 1U) {
    {
#line 1450
    tmp___1 = psiconv_empty_word_f();
#line 1450
    tmp___0 = (void *)tmp___1;
#line 1450
    result->file = tmp___0;
    }
#line 1450
    if (! tmp___0) {
#line 1451
      goto ERROR;
    }
  } else
#line 1452
  if ((unsigned int )type == 6U) {
    {
#line 1453
    tmp___3 = psiconv_empty_sheet_f();
#line 1453
    tmp___2 = (void *)tmp___3;
#line 1453
    result->file = tmp___2;
    }
#line 1453
    if (! tmp___2) {
#line 1454
      goto ERROR;
    }
  } else
#line 1455
  if ((unsigned int )type == 2U) {
    {
#line 1456
    tmp___5 = psiconv_empty_texted_f();
#line 1456
    tmp___4 = (void *)tmp___5;
#line 1456
    result->file = tmp___4;
    }
#line 1456
    if (! tmp___4) {
#line 1457
      goto ERROR;
    }
  } else
#line 1458
  if ((unsigned int )type == 3U) {
    {
#line 1459
    tmp___7 = psiconv_empty_mbm_f();
#line 1459
    tmp___6 = (void *)tmp___7;
#line 1459
    result->file = tmp___6;
    }
#line 1459
    if (! tmp___6) {
#line 1460
      goto ERROR;
    }
  } else
#line 1461
  if ((unsigned int )type == 4U) {
    {
#line 1462
    tmp___9 = psiconv_empty_sketch_f();
#line 1462
    tmp___8 = (void *)tmp___9;
#line 1462
    result->file = tmp___8;
    }
#line 1462
    if (! tmp___8) {
#line 1463
      goto ERROR;
    }
  } else
#line 1464
  if ((unsigned int )type == 5U) {
    {
#line 1465
    tmp___11 = psiconv_empty_clipart_f();
#line 1465
    tmp___10 = (void *)tmp___11;
#line 1465
    result->file = tmp___10;
    }
#line 1465
    if (! tmp___10) {
#line 1466
      goto ERROR;
    }
  } else {
#line 1468
    goto ERROR;
  }
#line 1469
  return (result);
  ERROR: 
  {
#line 1471
  free((void *)result);
  }
#line 1472
  return ((psiconv_file )((void *)0));
}
}
#line 48 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_routines.h"
psiconv_s32 psiconv_read_sint(psiconv_config const   config , psiconv_buffer const   buf ,
                              int lev , psiconv_u32 off , int *length , int *status ) ;
#line 79
int psiconv_parse_bool(psiconv_config const   config , psiconv_buffer const   buf ,
                       int lev , psiconv_u32 off , int *length , psiconv_bool_t *result ) ;
#line 247
int psiconv_parse_sheet_formula_list(psiconv_config const   config , psiconv_buffer const   buf ,
                                     int lev , psiconv_u32 off , int *length , psiconv_formula_list *result ) ;
#line 262
int psiconv_parse_sheet_cell(psiconv_config const   config , psiconv_buffer const   buf ,
                             int lev , psiconv_u32 off , int *length , psiconv_sheet_cell *result ,
                             psiconv_sheet_cell_layout const   default_layout , psiconv_sheet_line_list const   row_default_layouts ,
                             psiconv_sheet_line_list const   col_default_layouts ) ;
#line 270
int psiconv_parse_sheet_cell_list(psiconv_config const   config , psiconv_buffer const   buf ,
                                  int lev , psiconv_u32 off , int *length , psiconv_sheet_cell_list *result ,
                                  psiconv_sheet_cell_layout const   default_layout ,
                                  psiconv_sheet_line_list const   row_default_layouts ,
                                  psiconv_sheet_line_list const   col_default_layouts ) ;
#line 278
int psiconv_parse_sheet_worksheet_list(psiconv_config const   config , psiconv_buffer const   buf ,
                                       int lev , psiconv_u32 off , int *length , psiconv_sheet_worksheet_list *result ) ;
#line 284
int psiconv_parse_sheet_worksheet(psiconv_config const   config , psiconv_buffer const   buf ,
                                  int lev , psiconv_u32 off , int *length , psiconv_sheet_worksheet *result ) ;
#line 289
int psiconv_parse_sheet_numberformat(psiconv_config const   config , psiconv_buffer const   buf ,
                                     int lev , psiconv_u32 off , int *length , psiconv_sheet_numberformat result ) ;
#line 294
int psiconv_parse_sheet_cell_layout(psiconv_config const   config , psiconv_buffer const   buf ,
                                    int lev , psiconv_u32 off , int *length , psiconv_sheet_cell_layout result ) ;
#line 299
int psiconv_parse_sheet_line(psiconv_config const   config , psiconv_buffer const   buf ,
                             int lev , psiconv_u32 off , int *length , psiconv_sheet_line *result ,
                             psiconv_sheet_cell_layout const   default_layout ) ;
#line 305
int psiconv_parse_sheet_line_list(psiconv_config const   config , psiconv_buffer const   buf ,
                                  int lev , psiconv_u32 off , int *length , psiconv_sheet_line_list *result ,
                                  psiconv_sheet_cell_layout const   default_layout ) ;
#line 311
int psiconv_parse_sheet_name_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                     int lev , psiconv_u32 off , int *length , psiconv_sheet_name_section *result ) ;
#line 316
int psiconv_parse_sheet_info_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                     int lev , psiconv_u32 off , int *length , psiconv_sheet_info_section *result ) ;
#line 321
int psiconv_parse_sheet_variable(psiconv_config const   config , psiconv_buffer const   buf ,
                                 int lev , psiconv_u32 off , int *length , psiconv_sheet_variable *result ) ;
#line 326
int psiconv_parse_sheet_variable_list(psiconv_config const   config , psiconv_buffer const   buf ,
                                      int lev , psiconv_u32 off , int *length , psiconv_sheet_variable_list *result ) ;
#line 331
int psiconv_parse_sheet_grid_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                     int lev , psiconv_u32 off , int *length , psiconv_sheet_grid_section *result ) ;
#line 336
int psiconv_parse_sheet_grid_size_list(psiconv_config const   config , psiconv_buffer const   buf ,
                                       int lev , psiconv_u32 off , int *length , psiconv_sheet_grid_size_list *result ) ;
#line 341
int psiconv_parse_sheet_grid_size(psiconv_config const   config , psiconv_buffer const   buf ,
                                  int lev , psiconv_u32 off , int *length , psiconv_sheet_grid_size *result ) ;
#line 346
int psiconv_parse_sheet_grid_break_list(psiconv_config const   config , psiconv_buffer const   buf ,
                                        int lev , psiconv_u32 off , int *length ,
                                        psiconv_sheet_grid_break_list *result ) ;
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
static psiconv_sheet_cell_layout psiconv_basic_cell_layout(void) 
{ 
  psiconv_sheet_cell_layout result ;
  void *tmp ;
  psiconv_character_layout tmp___0 ;
  psiconv_paragraph_layout tmp___1 ;
  psiconv_sheet_numberformat tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 35
  tmp = malloc(sizeof(*result));
#line 35
  result = (psiconv_sheet_cell_layout )tmp;
  }
#line 35
  if (! result) {
#line 36
    goto ERROR1;
  }
  {
#line 37
  tmp___0 = psiconv_basic_character_layout();
#line 37
  result->character = tmp___0;
  }
#line 37
  if (! tmp___0) {
#line 38
    goto ERROR2;
  }
  {
#line 39
  tmp___1 = psiconv_basic_paragraph_layout();
#line 39
  result->paragraph = tmp___1;
  }
#line 39
  if (! tmp___1) {
#line 40
    goto ERROR3;
  }
  {
#line 41
  tmp___3 = malloc(sizeof(*(result->numberformat)));
#line 41
  tmp___2 = (psiconv_sheet_numberformat )tmp___3;
#line 41
  result->numberformat = tmp___2;
  }
#line 41
  if (! tmp___2) {
#line 42
    goto ERROR4;
  }
#line 43
  (result->numberformat)->code = (psiconv_sheet_numberformat_code_t )0;
#line 44
  (result->numberformat)->decimal = (psiconv_u8 )2;
#line 45
  return (result);
  ERROR4: 
  {
#line 47
  psiconv_free_paragraph_layout(result->paragraph);
  }
  ERROR3: 
  {
#line 49
  psiconv_free_character_layout(result->character);
  }
  ERROR2: 
  {
#line 51
  free((void *)result);
  }
  ERROR1: 
#line 53
  return ((psiconv_sheet_cell_layout )((void *)0));
}
}
#line 56 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
static psiconv_sheet_cell_layout psiconv_clone_cell_layout(psiconv_sheet_cell_layout original ) 
{ 
  psiconv_sheet_cell_layout result ;
  void *tmp ;
  psiconv_character_layout tmp___0 ;
  psiconv_paragraph_layout tmp___1 ;
  psiconv_sheet_numberformat tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 60
  tmp = malloc(sizeof(*result));
#line 60
  result = (psiconv_sheet_cell_layout )tmp;
  }
#line 60
  if (! result) {
#line 61
    goto ERROR1;
  }
  {
#line 62
  tmp___0 = psiconv_clone_character_layout(original->character);
#line 62
  result->character = tmp___0;
  }
#line 62
  if (! tmp___0) {
#line 64
    goto ERROR2;
  }
  {
#line 65
  tmp___1 = psiconv_clone_paragraph_layout(original->paragraph);
#line 65
  result->paragraph = tmp___1;
  }
#line 65
  if (! tmp___1) {
#line 67
    goto ERROR3;
  }
  {
#line 68
  tmp___3 = malloc(sizeof(*(result->numberformat)));
#line 68
  tmp___2 = (psiconv_sheet_numberformat )tmp___3;
#line 68
  result->numberformat = tmp___2;
  }
#line 68
  if (! tmp___2) {
#line 69
    goto ERROR4;
  }
#line 70
  (result->numberformat)->code = (original->numberformat)->code;
#line 71
  (result->numberformat)->decimal = (original->numberformat)->decimal;
#line 72
  return (result);
  ERROR4: 
  {
#line 74
  psiconv_free_paragraph_layout(result->paragraph);
  }
  ERROR3: 
  {
#line 76
  psiconv_free_character_layout(result->character);
  }
  ERROR2: 
  {
#line 78
  free((void *)result);
  }
  ERROR1: 
#line 80
  return ((psiconv_sheet_cell_layout )((void *)0));
}
}
#line 83 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
static psiconv_sheet_cell_reference_t psiconv_read_var_cellref(psiconv_config const   config ,
                                                               psiconv_buffer const   buf ,
                                                               int lev , psiconv_u32 off ,
                                                               int *length , int *status ) 
{ 
  int len ;
  int res ;
  psiconv_sheet_cell_reference_t result ;
  psiconv_u32 temp ;
  psiconv_u8 tmp ;

  {
  {
#line 89
  len = 0;
#line 94
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read a sheet cell reference");
#line 95
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the initial byte (%02x expected)",
                   0);
#line 97
  tmp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 97
  temp = (psiconv_u32 )tmp;
  }
#line 98
  if (res) {
#line 99
    goto ERROR1;
  }
#line 100
  if (temp != 0U) {
    {
#line 101
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet cell reference initial byte unknown value (ignored)");
#line 103
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Initial byte: %02x",
                  temp);
    }
  }
  {
#line 105
  len ++;
#line 107
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 108
  if (res) {
#line 109
    goto ERROR1;
  }
#line 110
  if (temp & 4294901760U) {
    {
#line 111
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet cell row reference to unknown row (reset)");
    }
  }
  {
#line 114
  result.row.offset = (psiconv_s16 )temp;
#line 115
  result.row.absolute = (psiconv_bool_t )1;
#line 116
  len += 4;
#line 118
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 119
  if (res) {
#line 120
    goto ERROR1;
  }
#line 121
  if (temp & 4294901760U) {
    {
#line 122
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet cell column reference to unknown row (reset)");
    }
  }
#line 125
  result.column.offset = (psiconv_s16 )temp;
#line 126
  result.column.absolute = (psiconv_bool_t )1;
#line 127
  len += 4;
#line 129
  if (length) {
#line 130
    *length = len;
  }
  {
#line 132
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet column reference (total length: %08x)",
                   len);
  }
#line 134
  return (result);
  ERROR1: 
  {
#line 136
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Column Reference failed");
  }
#line 137
  if (length) {
#line 138
    *length = 0;
  }
#line 139
  if (status) {
#line 140
    if (res) {
#line 140
      *status = res;
    } else {
#line 140
      *status = -2;
    }
  }
#line 141
  return (result);
}
}
#line 144 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
static psiconv_sheet_cell_block_t psiconv_read_var_cellblock(psiconv_config const   config ,
                                                             psiconv_buffer const   buf ,
                                                             int lev , psiconv_u32 off ,
                                                             int *length , int *status ) 
{ 
  int len ;
  int res ;
  psiconv_sheet_cell_block_t result ;
  psiconv_u32 temp ;
  psiconv_u8 tmp ;

  {
  {
#line 150
  len = 0;
#line 155
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read a sheet cell block reference");
#line 156
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the initial byte (%02x expected)",
                   0);
#line 158
  tmp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 158
  temp = (psiconv_u32 )tmp;
  }
#line 159
  if (res) {
#line 160
    goto ERROR1;
  }
#line 161
  if (temp != 0U) {
    {
#line 162
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet cell reference initial byte unknown value (ignored)");
#line 164
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Initial byte: %02x",
                  temp);
    }
  }
  {
#line 166
  len ++;
#line 168
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 169
  if (res) {
#line 170
    goto ERROR1;
  }
#line 171
  if (temp & 4294901760U) {
    {
#line 172
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet block initial row reference to unknown row (reset)");
    }
  }
  {
#line 175
  result.first.row.offset = (psiconv_s16 )temp;
#line 176
  result.first.row.absolute = (psiconv_bool_t )1;
#line 177
  len += 4;
#line 179
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 180
  if (res) {
#line 181
    goto ERROR1;
  }
#line 182
  if (temp & 4294901760U) {
    {
#line 183
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet block initial column reference to unknown row (reset)");
    }
  }
  {
#line 186
  result.first.column.offset = (psiconv_s16 )temp;
#line 187
  result.first.column.absolute = (psiconv_bool_t )1;
#line 188
  len += 4;
#line 190
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 191
  if (res) {
#line 192
    goto ERROR1;
  }
#line 193
  if (temp & 4294901760U) {
    {
#line 194
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet block final row reference to unknown row (reset)");
    }
  }
  {
#line 197
  result.last.row.offset = (psiconv_s16 )temp;
#line 198
  result.last.row.absolute = (psiconv_bool_t )1;
#line 199
  len += 4;
#line 201
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 202
  if (res) {
#line 203
    goto ERROR1;
  }
#line 204
  if (temp & 4294901760U) {
    {
#line 205
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet block final column reference to unknown row (reset)");
    }
  }
#line 208
  result.last.column.offset = (psiconv_s16 )temp;
#line 209
  result.last.column.absolute = (psiconv_bool_t )1;
#line 210
  len += 4;
#line 212
  if (length) {
#line 213
    *length = len;
  }
  {
#line 215
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet cell block reference (total length: %08x)",
                   len);
  }
#line 218
  return (result);
  ERROR1: 
  {
#line 220
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Cell Block Reference failed");
  }
#line 221
  if (length) {
#line 222
    *length = 0;
  }
#line 223
  if (status) {
#line 224
    if (res) {
#line 224
      *status = res;
    } else {
#line 224
      *status = -2;
    }
  }
#line 225
  return (result);
}
}
#line 228 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
int psiconv_parse_sheet_numberformat(psiconv_config const   config , psiconv_buffer const   buf ,
                                     int lev , psiconv_u32 off , int *length , psiconv_sheet_numberformat result ) 
{ 
  int res ;
  int len ;
  psiconv_u8 temp ;
  psiconv_u8 tmp ;

  {
  {
#line 233
  res = 0;
#line 234
  len = 0;
#line 237
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a sheet numberformat");
#line 239
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the initial byte (%02x expected)",
                   2);
#line 241
  temp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 242
  if (res) {
#line 243
    goto ERROR1;
  }
#line 244
  if ((int )temp != 2) {
    {
#line 245
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet numberformat initial byte unknown value (ignored)");
#line 247
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Initial byte: %02x",
                  (int )temp);
    }
  }
  {
#line 249
  len ++;
#line 251
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the code byte");
#line 252
  temp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 253
  if (res) {
#line 254
    goto ERROR1;
  }
  {
#line 255
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Code: %02x",
                (int )temp);
  }
#line 256
  if ((int )temp == 0) {
#line 257
    result->code = (psiconv_sheet_numberformat_code_t )0;
  } else
#line 258
  if ((int )temp == 2) {
#line 259
    result->code = (psiconv_sheet_numberformat_code_t )1;
  } else
#line 260
  if ((int )temp == 4) {
#line 261
    result->code = (psiconv_sheet_numberformat_code_t )2;
  } else
#line 262
  if ((int )temp == 6) {
#line 263
    result->code = (psiconv_sheet_numberformat_code_t )3;
  } else
#line 264
  if ((int )temp == 8) {
#line 265
    result->code = (psiconv_sheet_numberformat_code_t )4;
  } else
#line 266
  if ((int )temp == 10) {
#line 267
    result->code = (psiconv_sheet_numberformat_code_t )5;
  } else
#line 268
  if ((int )temp == 12) {
#line 269
    result->code = (psiconv_sheet_numberformat_code_t )6;
  } else
#line 270
  if ((int )temp == 14) {
#line 271
    result->code = (psiconv_sheet_numberformat_code_t )7;
  } else
#line 272
  if ((int )temp == 16) {
#line 273
    result->code = (psiconv_sheet_numberformat_code_t )8;
  } else
#line 274
  if ((int )temp == 18) {
#line 275
    result->code = (psiconv_sheet_numberformat_code_t )9;
  } else
#line 276
  if ((int )temp == 20) {
#line 277
    result->code = (psiconv_sheet_numberformat_code_t )10;
  } else
#line 278
  if ((int )temp == 22) {
#line 279
    result->code = (psiconv_sheet_numberformat_code_t )11;
  } else
#line 280
  if ((int )temp == 24) {
#line 281
    result->code = (psiconv_sheet_numberformat_code_t )12;
  } else
#line 282
  if ((int )temp == 26) {
#line 283
    result->code = (psiconv_sheet_numberformat_code_t )13;
  } else
#line 284
  if ((int )temp == 28) {
#line 285
    result->code = (psiconv_sheet_numberformat_code_t )14;
  } else
#line 286
  if ((int )temp == 30) {
#line 287
    result->code = (psiconv_sheet_numberformat_code_t )15;
  } else
#line 288
  if ((int )temp == 32) {
#line 289
    result->code = (psiconv_sheet_numberformat_code_t )16;
  } else
#line 290
  if ((int )temp == 34) {
#line 291
    result->code = (psiconv_sheet_numberformat_code_t )17;
  } else
#line 292
  if ((int )temp == 36) {
#line 293
    result->code = (psiconv_sheet_numberformat_code_t )18;
  } else
#line 294
  if ((int )temp == 38) {
#line 295
    result->code = (psiconv_sheet_numberformat_code_t )19;
  } else
#line 296
  if ((int )temp == 40) {
#line 297
    result->code = (psiconv_sheet_numberformat_code_t )20;
  } else
#line 298
  if ((int )temp == 42) {
#line 299
    result->code = (psiconv_sheet_numberformat_code_t )21;
  } else
#line 300
  if ((int )temp == 44) {
#line 301
    result->code = (psiconv_sheet_numberformat_code_t )22;
  } else
#line 302
  if ((int )temp == 46) {
#line 303
    result->code = (psiconv_sheet_numberformat_code_t )23;
  } else
#line 304
  if ((int )temp == 48) {
#line 305
    result->code = (psiconv_sheet_numberformat_code_t )24;
  } else
#line 306
  if ((int )temp == 50) {
#line 307
    result->code = (psiconv_sheet_numberformat_code_t )25;
  } else
#line 308
  if ((int )temp == 52) {
#line 309
    result->code = (psiconv_sheet_numberformat_code_t )26;
  } else
#line 310
  if ((int )temp == 54) {
#line 311
    result->code = (psiconv_sheet_numberformat_code_t )27;
  } else
#line 312
  if ((int )temp == 56) {
#line 313
    result->code = (psiconv_sheet_numberformat_code_t )28;
  } else
#line 314
  if ((int )temp == 58) {
#line 315
    result->code = (psiconv_sheet_numberformat_code_t )29;
  } else
#line 316
  if ((int )temp == 60) {
#line 317
    result->code = (psiconv_sheet_numberformat_code_t )30;
  } else {
    {
#line 319
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unknown number format (assumed general)");
#line 320
    result->code = (psiconv_sheet_numberformat_code_t )0;
    }
  }
  {
#line 322
  len ++;
#line 324
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the number of decimals");
#line 325
  tmp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 325
  result->decimal = (psiconv_u8 )((int )tmp >> 1);
  }
#line 326
  if (res) {
#line 327
    goto ERROR1;
  }
  {
#line 328
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Decimals: %d",
                (int )result->decimal);
#line 329
  len ++;
  }
#line 331
  if (length) {
#line 332
    *length = len;
  }
  {
#line 334
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet number format (total length: %08x)",
                   len);
  }
#line 336
  return (0);
  ERROR1: 
  {
#line 339
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Number Format failed");
  }
#line 340
  if (length) {
#line 341
    *length = 0;
  }
#line 342
  if (! res) {
#line 343
    return (-2);
  } else {
#line 345
    return (res);
  }
}
}
#line 348 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
int psiconv_parse_sheet_status_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                       int lev , psiconv_u32 off , int *length , psiconv_sheet_status_section *result ) 
{ 
  int res ;
  int len ;
  psiconv_u32 temp ;
  int leng ;
  psiconv_sheet_status_section tmp ;
  void *tmp___0 ;
  psiconv_u8 tmp___1 ;
  psiconv_u8 tmp___2 ;
  psiconv_u8 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  psiconv_u8 tmp___6 ;

  {
  {
#line 353
  res = 0;
#line 354
  len = 0;
#line 358
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read the sheet status section");
#line 359
  tmp___0 = malloc(sizeof(*(*result)));
#line 359
  tmp = (psiconv_sheet_status_section )tmp___0;
#line 359
  *result = tmp;
  }
#line 359
  if (! tmp) {
#line 360
    goto ERROR1;
  }
  {
#line 362
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the initial byte (%02x expected)",
                   2);
#line 364
  tmp___1 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 364
  temp = (psiconv_u32 )tmp___1;
  }
#line 365
  if (res) {
#line 366
    goto ERROR2;
  }
#line 367
  if (temp != 2U) {
    {
#line 368
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet status section initial byte unknown value (ignored)");
#line 370
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Initial byte: %02x",
                  temp);
    }
  }
  {
#line 372
  len ++;
#line 374
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the cursor row");
#line 376
  (*result)->cursor_row = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                           & res);
  }
#line 377
  if (res) {
#line 378
    goto ERROR2;
  }
  {
#line 379
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Cursor row: %08x",
                (*result)->cursor_row);
#line 381
  len += 4;
#line 383
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the cursor column");
#line 385
  (*result)->cursor_column = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                              & res);
  }
#line 386
  if (res) {
#line 387
    goto ERROR2;
  }
  {
#line 388
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Cursor column: %08x",
                (*result)->cursor_column);
#line 390
  len += 4;
#line 392
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read initially display graph");
#line 393
  res = psiconv_parse_bool(config, buf, lev + 2, off + (psiconv_u32 )len, & leng,
                           & (*result)->show_graph);
  }
#line 393
  if (res) {
#line 395
    goto ERROR2;
  }
  {
#line 396
  len += leng;
#line 398
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the toolbar status byte");
#line 400
  tmp___2 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 400
  temp = (psiconv_u32 )tmp___2;
  }
#line 401
  if (res) {
#line 402
    goto ERROR2;
  }
#line 404
  if (temp & 1U) {
#line 404
    (*result)->show_side_sheet_toolbar = (psiconv_bool_t )1;
  } else {
#line 404
    (*result)->show_side_sheet_toolbar = (psiconv_bool_t )0;
  }
  {
#line 406
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Show side sheet toolbar: %02x",
                (unsigned int )(*result)->show_side_sheet_toolbar);
  }
#line 408
  if (temp & 2U) {
#line 408
    (*result)->show_top_sheet_toolbar = (psiconv_bool_t )1;
  } else {
#line 408
    (*result)->show_top_sheet_toolbar = (psiconv_bool_t )0;
  }
  {
#line 410
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Show top sheet toolbar: %02x",
                (unsigned int )(*result)->show_top_sheet_toolbar);
  }
#line 412
  if (temp & 4U) {
#line 412
    (*result)->show_side_graph_toolbar = (psiconv_bool_t )1;
  } else {
#line 412
    (*result)->show_side_graph_toolbar = (psiconv_bool_t )0;
  }
  {
#line 414
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Show side graph toolbar: %02x",
                (unsigned int )(*result)->show_side_graph_toolbar);
  }
#line 416
  if (temp & 8U) {
#line 416
    (*result)->show_top_graph_toolbar = (psiconv_bool_t )1;
  } else {
#line 416
    (*result)->show_top_graph_toolbar = (psiconv_bool_t )0;
  }
  {
#line 418
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Show top graph toolbar: %02x",
                (unsigned int )(*result)->show_top_graph_toolbar);
  }
#line 420
  if (temp & 240U) {
    {
#line 421
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet status section toolbar byte flags contains unknown flags (ignored)");
#line 423
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unknown flags: %02x",
                  temp & 240U);
    }
  }
  {
#line 425
  len ++;
#line 427
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the scrollbar status byte");
#line 429
  tmp___3 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 429
  temp = (psiconv_u32 )tmp___3;
  }
#line 430
  if (res) {
#line 431
    goto ERROR2;
  }
#line 432
  if ((temp & 3U) == 3U) {
    {
#line 433
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet status section scrollbar byte flags contains unknown flags (ignored)");
#line 435
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unknown flag: %02x",
                  temp & 3U);
    }
  }
#line 437
  if ((temp & 3U) == 1U) {
#line 437
    (*result)->show_horizontal_scrollbar = (psiconv_triple_t )1;
  } else {
#line 437
    if ((temp & 3U) == 2U) {
#line 437
      tmp___4 = 2;
    } else {
#line 437
      tmp___4 = 0;
    }
#line 437
    (*result)->show_horizontal_scrollbar = (psiconv_triple_t )tmp___4;
  }
  {
#line 440
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Show horizontal scrollbar: %02x",
                (unsigned int )(*result)->show_horizontal_scrollbar);
  }
#line 442
  if ((temp & 12U) == 12U) {
    {
#line 443
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet status section scrollbar byte flags contains unknown flags (ignored)");
#line 445
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unknown flag: %02x",
                  temp & 12U);
    }
  }
#line 447
  if ((temp & 12U) == 4U) {
#line 447
    (*result)->show_vertical_scrollbar = (psiconv_triple_t )1;
  } else {
#line 447
    if ((temp & 12U) == 8U) {
#line 447
      tmp___5 = 2;
    } else {
#line 447
      tmp___5 = 0;
    }
#line 447
    (*result)->show_vertical_scrollbar = (psiconv_triple_t )tmp___5;
  }
  {
#line 450
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Show vertical scrollbar: %02x",
                (unsigned int )(*result)->show_vertical_scrollbar);
  }
#line 452
  if (temp & 240U) {
    {
#line 453
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet status section scrollbar byte flags contains unknown flags (ignored)");
#line 455
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unknown flags: %02x",
                  temp & 240U);
    }
  }
  {
#line 457
  len ++;
#line 459
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read an unknown byte (%02x expected)",
                   0);
#line 461
  tmp___6 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 461
  temp = (psiconv_u32 )tmp___6;
  }
#line 462
  if (res) {
#line 463
    goto ERROR2;
  }
#line 464
  if (temp != 0U) {
    {
#line 465
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet status section unknown byte unknown value (ignored)");
#line 467
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unknown byte: %02x",
                  temp);
    }
  }
  {
#line 469
  len ++;
#line 471
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read sheet display size");
#line 472
  (*result)->sheet_display_size = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                   & res);
  }
#line 473
  if (res) {
#line 474
    goto ERROR2;
  }
  {
#line 475
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet display size: %08x",
                (*result)->sheet_display_size);
#line 477
  len += 4;
#line 479
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read graph display size");
#line 480
  (*result)->graph_display_size = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                   & res);
  }
#line 481
  if (res) {
#line 482
    goto ERROR2;
  }
  {
#line 483
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Graph display size: %08x",
                (*result)->graph_display_size);
#line 485
  len += 4;
  }
#line 487
  if (length) {
#line 488
    *length = len;
  }
  {
#line 490
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet status section (total length: %08x)",
                   len);
  }
#line 492
  return (0);
  ERROR2: 
  {
#line 495
  free((void *)*result);
  }
  ERROR1: 
  {
#line 497
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Status Section failed");
  }
#line 498
  if (length) {
#line 499
    *length = 0;
  }
#line 500
  if (! res) {
#line 501
    return (-2);
  } else {
#line 503
    return (res);
  }
}
}
#line 506 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
int psiconv_parse_sheet_workbook_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                         int lev , psiconv_u32 off , int *length ,
                                         psiconv_sheet_workbook_section *result ) 
{ 
  int res ;
  int with_name ;
  psiconv_u32 temp ;
  psiconv_u32 formulas_off ;
  psiconv_u32 worksheets_off ;
  psiconv_u32 info_off ;
  psiconv_u32 var_off ;
  psiconv_u32 name_off ;
  int len ;
  psiconv_sheet_workbook_section tmp ;
  void *tmp___0 ;
  psiconv_u8 tmp___1 ;

  {
  {
#line 511
  res = 0;
#line 512
  name_off = (psiconv_u32 )0;
#line 513
  len = 0;
#line 515
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read the sheet workbook section");
#line 516
  tmp___0 = malloc(sizeof(*(*result)));
#line 516
  tmp = (psiconv_sheet_workbook_section )tmp___0;
#line 516
  *result = tmp;
  }
#line 516
  if (! tmp) {
#line 517
    goto ERROR1;
  }
  {
#line 519
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the initial byte (%02x or %02x expected)",
                   2, 4);
#line 522
  tmp___1 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 522
  temp = (psiconv_u32 )tmp___1;
  }
#line 523
  if (res) {
#line 524
    goto ERROR2;
  }
#line 525
  if (temp != 4U) {
#line 525
    if (temp != 2U) {
      {
#line 526
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet workbook section initial byte unknown value (ignored)");
#line 528
      psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Initial byte: %02x",
                    temp);
      }
    }
  }
  {
#line 530
  with_name = temp == 4U;
#line 531
  len ++;
#line 533
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the offset of the sheet info Section");
#line 535
  info_off = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 536
  if (res) {
#line 537
    goto ERROR2;
  }
  {
#line 538
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Offset: %04x",
                info_off);
#line 539
  len += 4;
#line 541
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the offset of the Formulas List");
#line 543
  formulas_off = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 544
  if (res) {
#line 545
    goto ERROR2;
  }
  {
#line 546
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Offset: %04x",
                formulas_off);
#line 547
  len += 4;
#line 549
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the offset of the Worksheet List");
#line 551
  worksheets_off = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                    & res);
  }
#line 552
  if (res) {
#line 553
    goto ERROR2;
  }
  {
#line 554
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Offset: %04x",
                worksheets_off);
#line 555
  len += 4;
#line 557
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the offset of the Variable List");
#line 559
  var_off = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 560
  if (res) {
#line 561
    goto ERROR2;
  }
  {
#line 562
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Offset: %04x",
                var_off);
#line 563
  len += 4;
  }
#line 565
  if (with_name) {
    {
#line 566
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the offset of the Name Section");
#line 568
    name_off = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
    }
#line 569
    if (res) {
#line 570
      goto ERROR2;
    }
    {
#line 571
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Offset: %04x",
                  name_off);
#line 572
    len += 4;
    }
  }
  {
#line 576
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the info section");
#line 577
  res = psiconv_parse_sheet_info_section(config, buf, lev + 2, info_off, (int *)((void *)0),
                                         & (*result)->info);
  }
#line 577
  if (res) {
#line 579
    goto ERROR2;
  }
  {
#line 581
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the variables list");
#line 582
  res = psiconv_parse_sheet_variable_list(config, buf, lev + 2, var_off, (int *)((void *)0),
                                          & (*result)->variables);
  }
#line 582
  if (res) {
#line 584
    goto ERROR3;
  }
  {
#line 586
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the formulas list");
#line 587
  res = psiconv_parse_sheet_formula_list(config, buf, lev + 2, formulas_off, (int *)((void *)0),
                                         & (*result)->formulas);
  }
#line 587
  if (res) {
#line 589
    goto ERROR4;
  }
  {
#line 591
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the worksheet list");
#line 592
  res = psiconv_parse_sheet_worksheet_list(config, buf, lev + 2, worksheets_off, (int *)((void *)0),
                                           & (*result)->worksheets);
  }
#line 592
  if (res) {
#line 594
    goto ERROR5;
  }
#line 596
  if (with_name) {
    {
#line 597
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the name section");
#line 598
    res = psiconv_parse_sheet_name_section(config, buf, lev + 2, name_off, (int *)((void *)0),
                                           & (*result)->name);
    }
#line 598
    if (res) {
#line 600
      goto ERROR6;
    }
  } else {
#line 602
    (*result)->name = (psiconv_sheet_name_section )((void *)0);
  }
#line 604
  if (length) {
#line 605
    *length = len;
  }
  {
#line 607
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet workbook section (total length: %08x)",
                   len);
  }
#line 609
  return (0);
  ERROR6: 
  {
#line 612
  psiconv_free_sheet_worksheet_list((*result)->worksheets);
  }
  ERROR5: 
  {
#line 614
  psiconv_free_formula_list((*result)->formulas);
  }
  ERROR4: 
  {
#line 616
  psiconv_free_sheet_variable_list((*result)->variables);
  }
  ERROR3: 
  {
#line 618
  psiconv_free_sheet_info_section((*result)->info);
  }
  ERROR2: 
  {
#line 620
  free((void *)*result);
  }
  ERROR1: 
  {
#line 622
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Workbook Section failed");
  }
#line 623
  if (length) {
#line 624
    *length = 0;
  }
#line 625
  if (! res) {
#line 626
    return (-2);
  } else {
#line 628
    return (res);
  }
}
}
#line 631 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
int psiconv_parse_sheet_name_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                     int lev , psiconv_u32 off , int *length , psiconv_sheet_name_section *result ) 
{ 
  int res ;
  psiconv_u32 temp ;
  int len ;
  int leng ;
  psiconv_sheet_name_section tmp ;
  void *tmp___0 ;
  psiconv_u8 tmp___1 ;

  {
  {
#line 636
  res = 0;
#line 638
  len = 0;
#line 640
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read the sheet name section");
#line 641
  tmp___0 = malloc(sizeof(*(*result)));
#line 641
  tmp = (psiconv_sheet_name_section )tmp___0;
#line 641
  *result = tmp;
  }
#line 641
  if (! tmp) {
#line 642
    goto ERROR1;
  }
  {
#line 644
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the initial byte (%02x expected)",
                   2);
#line 646
  tmp___1 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 646
  temp = (psiconv_u32 )tmp___1;
  }
#line 647
  if (res) {
#line 648
    goto ERROR2;
  }
#line 649
  if (temp != 2U) {
    {
#line 650
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet name section initial byte unknown value (ignored)");
#line 652
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Initial byte: %02x",
                  temp);
    }
  }
  {
#line 654
  len ++;
#line 656
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the sheet name");
#line 657
  (*result)->name = psiconv_read_string(config, buf, lev + 2, off + (psiconv_u32 )len,
                                        & leng, & res);
  }
#line 658
  if (res) {
#line 659
    goto ERROR2;
  }
#line 660
  len += leng;
#line 662
  if (length) {
#line 663
    *length = len;
  }
  {
#line 665
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet name section (total length: %08x)",
                   len);
  }
#line 667
  return (0);
  ERROR2: 
  {
#line 670
  free((void *)*result);
  }
  ERROR1: 
  {
#line 672
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Name Section failed");
  }
#line 673
  if (length) {
#line 674
    *length = 0;
  }
#line 675
  if (! res) {
#line 676
    return (-2);
  } else {
#line 678
    return (res);
  }
}
}
#line 681 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
int psiconv_parse_sheet_info_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                     int lev , psiconv_u32 off , int *length , psiconv_sheet_info_section *result ) 
{ 
  int res ;
  psiconv_u32 temp ;
  int len ;
  int leng ;
  psiconv_sheet_info_section tmp ;
  void *tmp___0 ;
  psiconv_u8 tmp___1 ;
  psiconv_u8 tmp___2 ;

  {
  {
#line 686
  res = 0;
#line 688
  len = 0;
#line 690
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read the sheet info section");
#line 691
  tmp___0 = malloc(sizeof(*(*result)));
#line 691
  tmp = (psiconv_sheet_info_section )tmp___0;
#line 691
  *result = tmp;
  }
#line 691
  if (! tmp) {
#line 692
    goto ERROR1;
  }
  {
#line 694
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the initial byte (%02x expected)",
                   2);
#line 696
  tmp___1 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 696
  temp = (psiconv_u32 )tmp___1;
  }
#line 697
  if (res) {
#line 698
    goto ERROR2;
  }
#line 699
  if (temp != 2U) {
    {
#line 700
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet info section initial byte unknown value (ignored)");
#line 702
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Initial byte: %02x",
                  temp);
    }
  }
  {
#line 704
  len ++;
#line 706
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read an unknown Xint");
#line 707
  temp = psiconv_read_X(config, buf, lev + 2, off + (psiconv_u32 )len, & leng, & res);
  }
#line 708
  if (res) {
#line 709
    goto ERROR2;
  }
  {
#line 710
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Value: %d\n",
                temp);
#line 711
  len += leng;
#line 713
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the flags byte");
#line 714
  tmp___2 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 714
  temp = (psiconv_u32 )tmp___2;
  }
#line 715
  if (res) {
#line 716
    goto ERROR2;
  }
#line 717
  if (temp & 1U) {
#line 717
    (*result)->auto_recalc = (psiconv_bool_t )1;
  } else {
#line 717
    (*result)->auto_recalc = (psiconv_bool_t )0;
  }
  {
#line 718
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Auto recalculation: %02x",
                (unsigned int )(*result)->auto_recalc);
  }
#line 720
  if ((temp & 254U) != 2U) {
    {
#line 721
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet Info Section flags byte contains unknown flags (ignored)");
#line 723
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unknown flags: %02x",
                  temp & 254U);
    }
  }
#line 726
  len ++;
#line 729
  if (length) {
#line 730
    *length = len;
  }
  {
#line 732
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet info section (total length: %08x)",
                   len);
  }
#line 734
  return (0);
  ERROR2: 
  {
#line 737
  free((void *)*result);
  }
  ERROR1: 
  {
#line 739
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Name Section failed");
  }
#line 740
  if (length) {
#line 741
    *length = 0;
  }
#line 742
  if (! res) {
#line 743
    return (-2);
  } else {
#line 745
    return (res);
  }
}
}
#line 748 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
int psiconv_parse_sheet_formula_list(psiconv_config const   config , psiconv_buffer const   buf ,
                                     int lev , psiconv_u32 off , int *length , psiconv_formula_list *result ) 
{ 
  int res ;
  int len ;
  psiconv_u32 temp ;
  psiconv_formula formula ;
  psiconv_u32 listlen ;
  psiconv_u32 i ;
  int leng ;
  psiconv_formula_list tmp ;
  psiconv_u8 tmp___0 ;

  {
  {
#line 753
  res = 0;
#line 754
  len = 0;
#line 760
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read the sheet formula list");
#line 761
  tmp = psiconv_list_new(sizeof(struct psiconv_formula_s ));
#line 761
  *result = tmp;
  }
#line 761
  if (! tmp) {
#line 762
    goto ERROR1;
  }
  {
#line 764
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the initial byte (%02x expected)",
                   2);
#line 766
  tmp___0 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 766
  temp = (psiconv_u32 )tmp___0;
  }
#line 767
  if (res) {
#line 768
    goto ERROR2;
  }
#line 769
  if (temp != 2U) {
    {
#line 770
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet formula list initial byte unknown value (ignored)");
#line 772
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Initial byte: %02x",
                  temp);
    }
  }
  {
#line 774
  len ++;
#line 776
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the number of formulas");
#line 778
  listlen = psiconv_read_X(config, buf, lev + 2, off + (psiconv_u32 )len, & leng,
                           & res);
  }
#line 779
  if (res) {
#line 780
    goto ERROR2;
  }
  {
#line 781
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Number of formulas: %d",
                listlen);
#line 782
  len += leng;
#line 784
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read all formulas");
#line 785
  i = (psiconv_u32 )0;
  }
  {
#line 785
  while (1) {
    while_continue: /* CIL Label */ ;
#line 785
    if (! (i < listlen)) {
#line 785
      goto while_break;
    }
    {
#line 786
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read formula %d",
                     i);
#line 787
    res = psiconv_parse_formula(config, buf, lev + 3, off + (psiconv_u32 )len, & leng,
                                & formula);
    }
#line 787
    if (res) {
#line 788
      goto ERROR2;
    }
    {
#line 789
    res = psiconv_list_add(*result, (void const   *)formula);
    }
#line 789
    if (res) {
#line 790
      goto ERROR3;
    }
    {
#line 791
    free((void *)formula);
#line 792
    len += leng;
#line 785
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 795
  if (length) {
#line 796
    *length = len;
  }
  {
#line 798
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet formula list (total length: %08x)",
                   len);
  }
#line 800
  return (0);
  ERROR3: 
  {
#line 803
  psiconv_free_formula(formula);
  }
  ERROR2: 
  {
#line 805
  psiconv_list_free(*result);
  }
  ERROR1: 
  {
#line 807
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Formula list failed");
  }
#line 808
  if (length) {
#line 809
    *length = 0;
  }
#line 810
  if (! res) {
#line 811
    return (-2);
  } else {
#line 813
    return (res);
  }
}
}
#line 816 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
int psiconv_parse_sheet_cell(psiconv_config const   config , psiconv_buffer const   buf ,
                             int lev , psiconv_u32 off , int *length , psiconv_sheet_cell *result ,
                             psiconv_sheet_cell_layout const   default_layout , psiconv_sheet_line_list const   row_default_layouts ,
                             psiconv_sheet_line_list const   col_default_layouts ) 
{ 
  int res ;
  int len ;
  psiconv_u32 temp ;
  psiconv_bool_t has_layout ;
  int leng ;
  char *auxstr ;
  psiconv_sheet_cell tmp ;
  void *tmp___0 ;
  psiconv_u8 tmp___1 ;
  psiconv_u8 tmp___2 ;
  psiconv_u8 tmp___3 ;
  psiconv_u8 tmp___4 ;
  psiconv_u16 tmp___5 ;
  psiconv_sheet_cell_layout tmp___6 ;
  psiconv_sheet_cell_layout tmp___7 ;

  {
  {
#line 824
  res = 0;
#line 825
  len = 0;
#line 831
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a sheet cell structure");
#line 832
  tmp___0 = malloc(sizeof(*(*result)));
#line 832
  tmp = (psiconv_sheet_cell )tmp___0;
#line 832
  *result = tmp;
  }
#line 832
  if (! tmp) {
#line 833
    goto ERROR1;
  }
  {
#line 835
  (*result)->layout = (psiconv_sheet_cell_layout )((void *)0);
#line 836
  (*result)->type = (psiconv_cell_type_t )0;
#line 838
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the cell position");
#line 839
  tmp___1 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 839
  temp = (psiconv_u32 )tmp___1;
  }
#line 840
  if (res) {
#line 841
    goto ERROR2;
  }
  {
#line 842
  len ++;
#line 843
  tmp___2 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 843
  temp += (psiconv_u32 )((int )tmp___2 << 8);
  }
#line 844
  if (res) {
#line 845
    goto ERROR2;
  }
  {
#line 846
  len ++;
#line 847
  tmp___3 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 847
  temp += (psiconv_u32 )((int )tmp___3 << 16);
  }
#line 848
  if (res) {
#line 849
    goto ERROR2;
  }
  {
#line 850
  len ++;
#line 851
  (*result)->column = (psiconv_u16 )((temp >> 2) & 255U);
#line 852
  (*result)->row = (psiconv_u16 )((temp >> 10) & 16383U);
#line 853
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Cell position is col:%02x row:%04x",
                (int )(*result)->column, (int )(*result)->row);
  }
#line 855
  if (temp & 3U) {
    {
#line 856
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unknown flags in cell position (ignored)");
#line 857
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Flags: %02x",
                  temp & 3U);
    }
  }
  {
#line 860
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the cell type");
#line 861
  tmp___4 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 861
  temp = (psiconv_u32 )tmp___4;
  }
#line 862
  if (res) {
#line 863
    goto ERROR2;
  }
#line 864
  len ++;
#line 865
  (*result)->type = (psiconv_cell_type_t )((temp >> 5) & 7U);
#line 866
  if (temp & 8U) {
#line 866
    (*result)->calculated = (psiconv_bool_t )1;
  } else {
#line 866
    (*result)->calculated = (psiconv_bool_t )0;
  }
#line 867
  if (temp & 16U) {
#line 867
    has_layout = (psiconv_bool_t )1;
  } else {
#line 867
    has_layout = (psiconv_bool_t )0;
  }
  {
#line 869
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the cell value");
  }
#line 870
  if ((unsigned int )(*result)->type == 0U) {
    {
#line 871
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Cell type is blank: no value given.");
    }
  } else
#line 872
  if ((unsigned int )(*result)->type == 1U) {
    {
#line 873
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read an integer");
#line 874
    (*result)->data.dat_int = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & res);
    }
#line 875
    if (res) {
#line 876
      goto ERROR2;
    }
    {
#line 877
    len += 4;
#line 878
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Cell contents: %ld",
                  (*result)->data.dat_int);
    }
  } else
#line 880
  if ((unsigned int )(*result)->type == 2U) {
    {
#line 881
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read a boolean");
#line 882
    res = psiconv_parse_bool(config, buf, lev + 2, off + (psiconv_u32 )len, & leng,
                             & (*result)->data.dat_bool);
    }
#line 882
    if (res) {
#line 884
      goto ERROR2;
    }
    {
#line 885
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Cell contents: %01x",
                  temp);
    }
#line 886
    if (temp) {
#line 886
      (*result)->data.dat_bool = (psiconv_bool_t )1;
    } else {
#line 886
      (*result)->data.dat_bool = (psiconv_bool_t )0;
    }
#line 887
    len += leng;
  } else
#line 888
  if ((unsigned int )(*result)->type == 3U) {
    {
#line 889
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the error code");
#line 890
    tmp___5 = psiconv_read_u16(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 890
    temp = (psiconv_u32 )tmp___5;
    }
#line 891
    if (res) {
#line 892
      goto ERROR2;
    }
#line 893
    if (temp == 0U) {
#line 894
      (*result)->data.dat_error = (psiconv_sheet_errorcode_t )0;
    } else
#line 895
    if (temp == 1U) {
#line 896
      (*result)->data.dat_error = (psiconv_sheet_errorcode_t )1;
    } else
#line 897
    if (temp == 2U) {
#line 898
      (*result)->data.dat_error = (psiconv_sheet_errorcode_t )2;
    } else
#line 899
    if (temp == 3U) {
#line 900
      (*result)->data.dat_error = (psiconv_sheet_errorcode_t )3;
    } else
#line 901
    if (temp == 4U) {
#line 902
      (*result)->data.dat_error = (psiconv_sheet_errorcode_t )4;
    } else
#line 903
    if (temp == 5U) {
#line 904
      (*result)->data.dat_error = (psiconv_sheet_errorcode_t )5;
    } else
#line 905
    if (temp == 6U) {
#line 906
      (*result)->data.dat_error = (psiconv_sheet_errorcode_t )6;
    } else
#line 907
    if (temp == 7U) {
#line 908
      (*result)->data.dat_error = (psiconv_sheet_errorcode_t )7;
    } else {
      {
#line 910
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unknown error code (default assumed)");
#line 911
      psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Error code: %04x",
                    temp);
#line 912
      (*result)->data.dat_error = (psiconv_sheet_errorcode_t )0;
      }
    }
    {
#line 914
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Cell contents: %04x",
                  (unsigned int )(*result)->data.dat_error);
#line 916
    len += 2;
    }
  } else
#line 917
  if ((unsigned int )(*result)->type == 4U) {
    {
#line 918
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read a float");
#line 919
    (*result)->data.dat_float = psiconv_read_float(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                   & leng, & res);
    }
#line 921
    if (res) {
#line 922
      goto ERROR2;
    }
    {
#line 923
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Cell contents: %f",
                  (*result)->data.dat_float);
#line 924
    len += leng;
    }
  } else
#line 925
  if ((unsigned int )(*result)->type == 5U) {
    {
#line 926
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read a string");
#line 927
    (*result)->data.dat_string = psiconv_read_string(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                     & leng, & res);
    }
#line 929
    if (res) {
#line 930
      goto ERROR2;
    }
    {
#line 931
    auxstr = psiconv_make_printable(config, (psiconv_string_t const   )(*result)->data.dat_string);
    }
#line 931
    if (! auxstr) {
#line 932
      goto ERROR2;
    }
    {
#line 933
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Cell contents: `%s\'",
                  auxstr);
#line 934
    free((void *)auxstr);
#line 935
    len += leng;
    }
  } else {
    {
#line 937
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unknown Sheet Cell type: %02x",
                  (unsigned int )(*result)->type);
#line 938
    res = 3;
    }
#line 939
    goto ERROR2;
  }
  {
#line 942
  tmp___7 = psiconv_get_default_layout((psiconv_sheet_line_list )row_default_layouts,
                                       (psiconv_sheet_line_list )col_default_layouts,
                                       (psiconv_sheet_cell_layout )default_layout,
                                       (int )(*result)->row, (int )(*result)->column);
#line 942
  tmp___6 = psiconv_clone_cell_layout(tmp___7);
#line 942
  (*result)->layout = tmp___6;
  }
#line 942
  if (! tmp___6) {
#line 948
    goto ERROR2;
  }
#line 949
  if (has_layout) {
    {
#line 950
    res = psiconv_parse_sheet_cell_layout(config, buf, lev + 2, off + (psiconv_u32 )len,
                                          & leng, (*result)->layout);
    }
#line 950
    if (res) {
#line 952
      goto ERROR2;
    }
#line 953
    len += leng;
  }
#line 956
  if ((*result)->calculated) {
    {
#line 957
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the cell formula reference");
#line 958
    temp = psiconv_read_X(config, buf, lev + 2, off + (psiconv_u32 )len, & leng, & res);
    }
#line 959
    if (res) {
#line 960
      goto ERROR2;
    }
    {
#line 961
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Cell formula reference: %d",
                  temp);
#line 962
    len += leng;
#line 963
    (*result)->ref_formula = temp;
    }
  }
#line 966
  if (length) {
#line 967
    *length = len;
  }
  {
#line 969
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet cell structure (total length: %08x)",
                   len);
  }
#line 971
  return (0);
  ERROR2: 
  {
#line 974
  psiconv_free_sheet_cell(*result);
  }
  ERROR1: 
  {
#line 976
  psiconv_warn((psiconv_config )config, lev + 1, off, "Reading of Sheet Cell Structure failed");
  }
#line 977
  if (length) {
#line 978
    *length = 0;
  }
#line 979
  if (! res) {
#line 980
    return (-2);
  } else {
#line 982
    return (res);
  }
}
}
#line 985 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
int psiconv_parse_sheet_cell_list(psiconv_config const   config , psiconv_buffer const   buf ,
                                  int lev , psiconv_u32 off , int *length , psiconv_sheet_cell_list *result ,
                                  psiconv_sheet_cell_layout const   default_layout ,
                                  psiconv_sheet_line_list const   row_default_layouts ,
                                  psiconv_sheet_line_list const   col_default_layouts ) 
{ 
  int res ;
  int len ;
  psiconv_u32 temp ;
  psiconv_sheet_cell cell ;
  psiconv_u32 listlen ;
  psiconv_u32 i ;
  int leng ;
  psiconv_sheet_cell_list tmp ;
  psiconv_u8 tmp___0 ;
  psiconv_u8 tmp___1 ;

  {
  {
#line 993
  res = 0;
#line 994
  len = 0;
#line 1000
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read the sheet cell list");
#line 1001
  tmp = psiconv_list_new(sizeof(struct psiconv_sheet_cell_s ));
#line 1001
  *result = tmp;
  }
#line 1001
  if (! tmp) {
#line 1002
    goto ERROR1;
  }
  {
#line 1004
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the initial byte (%02x expected)",
                   2);
#line 1006
  tmp___0 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 1006
  temp = (psiconv_u32 )tmp___0;
  }
#line 1007
  if (res) {
#line 1008
    goto ERROR2;
  }
#line 1009
  if (temp != 2U) {
    {
#line 1010
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet cell list initial byte unknown value (ignored)");
#line 1012
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Initial byte: %02x",
                  temp);
    }
  }
  {
#line 1014
  len ++;
#line 1016
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the initial byte (%02x expected)",
                   0);
#line 1018
  tmp___1 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 1018
  temp = (psiconv_u32 )tmp___1;
  }
#line 1019
  if (res) {
#line 1020
    goto ERROR2;
  }
#line 1021
  if (temp != 0U) {
    {
#line 1022
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet cell list initial byte unknown value (ignored)");
#line 1024
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Initial byte: %02x",
                  temp);
    }
  }
  {
#line 1026
  len ++;
#line 1028
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the number of defined cells");
#line 1030
  listlen = psiconv_read_X(config, buf, lev + 2, off + (psiconv_u32 )len, & leng,
                           & res);
  }
#line 1031
  if (res) {
#line 1032
    goto ERROR2;
  }
  {
#line 1033
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Number of defined cells: %d",
                listlen);
#line 1034
  len += leng;
#line 1036
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read all cells");
#line 1037
  i = (psiconv_u32 )0;
  }
  {
#line 1037
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1037
    if (! (i < listlen)) {
#line 1037
      goto while_break;
    }
    {
#line 1038
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read cell %d",
                     i);
#line 1039
    res = psiconv_parse_sheet_cell(config, buf, lev + 3, off + (psiconv_u32 )len,
                                   & leng, & cell, default_layout, row_default_layouts,
                                   col_default_layouts);
    }
#line 1039
    if (res) {
#line 1042
      goto ERROR2;
    }
    {
#line 1043
    res = psiconv_list_add(*result, (void const   *)cell);
    }
#line 1043
    if (res) {
#line 1044
      goto ERROR3;
    }
    {
#line 1045
    free((void *)cell);
#line 1046
    len += leng;
#line 1037
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1049
  if (length) {
#line 1050
    *length = len;
  }
  {
#line 1052
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet cell list (total length: %08x)",
                   len);
  }
#line 1054
  return (0);
  ERROR3: 
  {
#line 1057
  psiconv_free_sheet_cell(cell);
  }
  ERROR2: 
  {
#line 1059
  psiconv_free_sheet_cell_list(*result);
  }
  ERROR1: 
  {
#line 1061
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Cells List failed");
  }
#line 1062
  if (length) {
#line 1063
    *length = 0;
  }
#line 1064
  if (! res) {
#line 1065
    return (-2);
  } else {
#line 1067
    return (res);
  }
}
}
#line 1071 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
int psiconv_parse_sheet_worksheet_list(psiconv_config const   config , psiconv_buffer const   buf ,
                                       int lev , psiconv_u32 off , int *length , psiconv_sheet_worksheet_list *result ) 
{ 
  psiconv_sheet_worksheet worksheet ;
  int res ;
  int len ;
  psiconv_u8 temp ;
  psiconv_u32 offset ;
  int leng ;
  int i ;
  int nr ;
  psiconv_sheet_worksheet_list tmp ;
  psiconv_u32 tmp___0 ;

  {
  {
#line 1077
  res = 0;
#line 1078
  len = 0;
#line 1083
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read the worksheet list");
#line 1084
  tmp = psiconv_list_new(sizeof(*worksheet));
#line 1084
  *result = tmp;
  }
#line 1084
  if (! tmp) {
#line 1085
    goto ERROR1;
  }
  {
#line 1087
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the initial bytes (%02x expected)",
                   2);
#line 1089
  temp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 1090
  if (res) {
#line 1091
    goto ERROR2;
  }
#line 1092
  if ((int )temp != 2) {
    {
#line 1093
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet worksheet list initial byte unknown value (ignored)");
#line 1095
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Initial byte: %02x",
                  (int )temp);
    }
  }
  {
#line 1097
  len ++;
#line 1099
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the list length");
#line 1100
  tmp___0 = psiconv_read_X(config, buf, lev + 2, off + (psiconv_u32 )len, & leng,
                           & res);
#line 1100
  nr = (int )tmp___0;
  }
#line 1101
  if (res) {
#line 1102
    goto ERROR2;
  }
  {
#line 1103
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Length: %02x",
                nr);
#line 1104
  len += leng;
#line 1106
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the list");
#line 1107
  i = 0;
  }
  {
#line 1107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1107
    if (! (i < nr)) {
#line 1107
      goto while_break;
    }
    {
#line 1108
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read element %d",
                     i);
#line 1109
    psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to read the initial byte (%02x expected)",
                     0);
#line 1111
    temp = psiconv_read_u8(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
    }
#line 1112
    if (res) {
#line 1113
      goto ERROR2;
    }
#line 1114
    if ((int )temp != 0) {
      {
#line 1115
      psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Sheet worksheet element initial byte unknown value (ignored)");
#line 1117
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Initial byte: %02x",
                    (int )temp);
      }
    }
    {
#line 1119
    len ++;
#line 1121
    psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to read the worksheet offset");
#line 1122
    offset = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
    }
#line 1123
    if (res) {
#line 1124
      goto ERROR2;
    }
    {
#line 1125
    psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Offset: %08x",
                  offset);
#line 1126
    len += 4;
#line 1128
    res = psiconv_parse_sheet_worksheet(config, buf, lev + 4, offset, (int *)((void *)0),
                                        & worksheet);
    }
#line 1128
    if (res) {
#line 1130
      goto ERROR2;
    }
    {
#line 1131
    res = psiconv_list_add(*result, (void const   *)worksheet);
    }
#line 1131
    if (res) {
#line 1132
      goto ERROR3;
    }
    {
#line 1133
    free((void *)worksheet);
#line 1107
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1136
  if (length) {
#line 1137
    *length = len;
  }
  {
#line 1139
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of worksheet list (total length: %08x)",
                   len);
  }
#line 1142
  return (0);
  ERROR3: 
  {
#line 1145
  psiconv_free_sheet_worksheet(worksheet);
  }
  ERROR2: 
  {
#line 1147
  psiconv_free_sheet_worksheet_list(*result);
  }
  ERROR1: 
  {
#line 1149
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of worksheet list failed");
  }
#line 1150
  if (length) {
#line 1151
    *length = 0;
  }
#line 1152
  if (! res) {
#line 1153
    return (-2);
  } else {
#line 1155
    return (res);
  }
}
}
#line 1158 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
int psiconv_parse_sheet_cell_layout(psiconv_config const   config , psiconv_buffer const   buf ,
                                    int lev , psiconv_u32 off , int *length , psiconv_sheet_cell_layout result ) 
{ 
  int res ;
  int len ;
  int leng ;
  psiconv_u8 temp ;

  {
  {
#line 1164
  res = 0;
#line 1165
  len = 0;
#line 1169
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a sheet cell layout");
#line 1171
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the first byte (%02x expected)",
                   2);
#line 1173
  temp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 1174
  if (res) {
#line 1175
    goto ERROR1;
  }
#line 1176
  if ((int )temp != 2) {
    {
#line 1177
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Worksheet section initial byte unknown value (ignored)");
#line 1179
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Initial byte: %02x",
                  (int )temp);
    }
  }
  {
#line 1181
  len ++;
#line 1183
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the default formats flag");
#line 1184
  temp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 1185
  if (res) {
#line 1186
    goto ERROR1;
  }
#line 1187
  len ++;
#line 1189
  if ((int )temp & 1) {
    {
#line 1190
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the default paragraph codes");
#line 1191
    res = psiconv_parse_paragraph_layout_list(config, buf, lev + 3, off + (psiconv_u32 )len,
                                              & leng, result->paragraph);
    }
#line 1191
    if (res) {
#line 1193
      goto ERROR1;
    }
#line 1194
    len += leng;
  }
#line 1197
  if ((int )temp & 2) {
    {
#line 1198
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the default character codes");
#line 1199
    res = psiconv_parse_character_layout_list(config, buf, lev + 3, off + (psiconv_u32 )len,
                                              & leng, result->character);
    }
#line 1199
    if (res) {
#line 1201
      goto ERROR1;
    }
#line 1202
    len += leng;
  }
#line 1205
  if ((int )temp & 4) {
    {
#line 1206
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the default number format");
#line 1207
    psiconv_parse_sheet_numberformat(config, buf, lev + 3, off + (psiconv_u32 )len,
                                     & leng, result->numberformat);
#line 1209
    len += leng;
    }
  }
#line 1212
  if (length) {
#line 1213
    *length = len;
  }
  {
#line 1215
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet cell layout (total length: %08x)",
                   len);
  }
#line 1218
  return (0);
  ERROR1: 
  {
#line 1221
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of sheet cell layout failed");
  }
#line 1222
  if (length) {
#line 1223
    *length = 0;
  }
#line 1224
  if (! res) {
#line 1225
    return (-2);
  } else {
#line 1227
    return (res);
  }
}
}
#line 1231 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
int psiconv_parse_sheet_worksheet(psiconv_config const   config , psiconv_buffer const   buf ,
                                  int lev , psiconv_u32 off , int *length , psiconv_sheet_worksheet *result ) 
{ 
  int res ;
  psiconv_u32 temp ;
  psiconv_u32 cells_off ;
  psiconv_u32 grid_off ;
  psiconv_u32 rows_off ;
  psiconv_u32 cols_off ;
  psiconv_u32 unknown_off ;
  int len ;
  int leng ;
  psiconv_sheet_worksheet tmp ;
  void *tmp___0 ;
  psiconv_u8 tmp___1 ;
  psiconv_u8 tmp___2 ;
  psiconv_sheet_cell_layout tmp___3 ;

  {
  {
#line 1236
  res = 0;
#line 1238
  len = 0;
#line 1241
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read the sheet worksheet section");
#line 1242
  tmp___0 = malloc(sizeof(*(*result)));
#line 1242
  tmp = (psiconv_sheet_worksheet )tmp___0;
#line 1242
  *result = tmp;
  }
#line 1242
  if (! tmp) {
#line 1243
    goto ERROR1;
  }
  {
#line 1245
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the initial bytes (%02x expected)",
                   4);
#line 1247
  tmp___1 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 1247
  temp = (psiconv_u32 )tmp___1;
  }
#line 1248
  if (res) {
#line 1249
    goto ERROR2;
  }
#line 1250
  if (temp != 4U) {
    {
#line 1251
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Worksheet section initial byte unknown value (ignored)");
#line 1253
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Initial byte: %02x",
                  temp);
    }
  }
  {
#line 1255
  len ++;
#line 1257
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the flags byte");
#line 1258
  tmp___2 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 1258
  temp = (psiconv_u32 )tmp___2;
  }
#line 1259
  if (res) {
#line 1260
    goto ERROR2;
  }
  {
#line 1261
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Flags byte: %02x",
                temp);
  }
#line 1262
  if (temp & 1U) {
#line 1262
    (*result)->show_zeros = (psiconv_bool_t )1;
  } else {
#line 1262
    (*result)->show_zeros = (psiconv_bool_t )0;
  }
#line 1263
  if (temp & 254U) {
    {
#line 1264
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Worksheet section flags byte unknown bits (ignored)");
    }
  }
  {
#line 1267
  len ++;
#line 1269
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the default cell layout");
#line 1270
  tmp___3 = psiconv_basic_cell_layout();
#line 1270
  (*result)->default_layout = tmp___3;
  }
#line 1270
  if (! tmp___3) {
#line 1271
    goto ERROR2;
  }
  {
#line 1272
  res = psiconv_parse_sheet_cell_layout(config, buf, lev + 2, off + (psiconv_u32 )len,
                                        & leng, (*result)->default_layout);
  }
#line 1272
  if (res) {
#line 1274
    goto ERROR3;
  }
  {
#line 1275
  len += leng;
#line 1277
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the offset of the row defaults Section");
#line 1279
  rows_off = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 1280
  if (res) {
#line 1281
    goto ERROR3;
  }
  {
#line 1282
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Offset: %04x",
                rows_off);
#line 1283
  len += 4;
#line 1285
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the offset of the column defaults Section");
#line 1287
  cols_off = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 1288
  if (res) {
#line 1289
    goto ERROR3;
  }
  {
#line 1290
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Offset: %04x",
                cols_off);
#line 1291
  len += 4;
#line 1293
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the offset of the Cells List");
#line 1295
  cells_off = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 1296
  if (res) {
#line 1297
    goto ERROR3;
  }
  {
#line 1298
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Offset: %04x",
                cells_off);
#line 1299
  len += 4;
#line 1301
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the offset of the Grid Section");
#line 1303
  grid_off = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 1304
  if (res) {
#line 1305
    goto ERROR3;
  }
  {
#line 1306
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Offset: %04x",
                grid_off);
#line 1307
  len += 4;
#line 1309
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the offset of the 3rd ??? Section");
#line 1311
  unknown_off = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 1312
  if (res) {
#line 1313
    goto ERROR3;
  }
  {
#line 1314
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Offset: %04x",
                unknown_off);
#line 1315
  len += 4;
#line 1317
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read a long of the 3rd ??? Section (%08x expected)",
                   0);
#line 1320
  temp = psiconv_read_u32(config, buf, lev + 2, unknown_off, & res);
  }
#line 1321
  if (res) {
#line 1322
    goto ERROR3;
  }
#line 1323
  if (temp != 0U) {
    {
#line 1324
    psiconv_warn((psiconv_config )config, lev + 2, unknown_off, "Unknown worksheet subsection has unknown contents (ignored)");
#line 1326
    psiconv_debug((psiconv_config )config, lev + 2, unknown_off, "Offset: %04x", temp);
    }
  }
  {
#line 1328
  len += 4;
#line 1330
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the row defaults");
#line 1331
  res = psiconv_parse_sheet_line_list(config, buf, lev + 2, rows_off, (int *)((void *)0),
                                      & (*result)->row_default_layouts, (psiconv_sheet_cell_layout const   )(*result)->default_layout);
  }
#line 1331
  if (res) {
#line 1334
    goto ERROR3;
  }
  {
#line 1336
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the column defaults");
#line 1337
  res = psiconv_parse_sheet_line_list(config, buf, lev + 2, cols_off, (int *)((void *)0),
                                      & (*result)->col_default_layouts, (psiconv_sheet_cell_layout const   )(*result)->default_layout);
  }
#line 1337
  if (res) {
#line 1340
    goto ERROR4;
  }
  {
#line 1342
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the cells list");
#line 1343
  res = psiconv_parse_sheet_cell_list(config, buf, lev + 2, cells_off, (int *)((void *)0),
                                      & (*result)->cells, (psiconv_sheet_cell_layout const   )(*result)->default_layout,
                                      (psiconv_sheet_line_list const   )(*result)->row_default_layouts,
                                      (psiconv_sheet_line_list const   )(*result)->col_default_layouts);
  }
#line 1343
  if (res) {
#line 1348
    goto ERROR5;
  }
  {
#line 1351
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the grid section");
#line 1352
  res = psiconv_parse_sheet_grid_section(config, buf, lev + 2, grid_off, (int *)((void *)0),
                                         & (*result)->grid);
  }
#line 1352
  if (res) {
#line 1354
    goto ERROR6;
  }
#line 1358
  if (length) {
#line 1359
    *length = len;
  }
  {
#line 1361
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet worksheet section (total length: %08x)",
                   len);
  }
#line 1363
  return (0);
  ERROR6: 
  {
#line 1366
  psiconv_free_sheet_cell_list((*result)->cells);
  }
  ERROR5: 
  {
#line 1368
  psiconv_free_sheet_line_list((*result)->col_default_layouts);
  }
  ERROR4: 
  {
#line 1370
  psiconv_free_sheet_line_list((*result)->row_default_layouts);
  }
  ERROR3: 
  {
#line 1372
  psiconv_free_sheet_cell_layout((*result)->default_layout);
  }
  ERROR2: 
  {
#line 1374
  free((void *)*result);
  }
  ERROR1: 
  {
#line 1376
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Worksheet Section failed");
  }
#line 1377
  if (length) {
#line 1378
    *length = 0;
  }
#line 1379
  if (! res) {
#line 1380
    return (-2);
  } else {
#line 1382
    return (res);
  }
}
}
#line 1385 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
int psiconv_parse_sheet_line(psiconv_config const   config , psiconv_buffer const   buf ,
                             int lev , psiconv_u32 off , int *length , psiconv_sheet_line *result ,
                             psiconv_sheet_cell_layout const   default_layout ) 
{ 
  int res ;
  int len ;
  int leng ;
  psiconv_sheet_line tmp ;
  void *tmp___0 ;
  psiconv_sheet_cell_layout tmp___1 ;

  {
  {
#line 1391
  res = 0;
#line 1392
  len = 0;
#line 1396
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a sheet line");
#line 1397
  tmp___0 = malloc(sizeof(*(*result)));
#line 1397
  tmp = (psiconv_sheet_line )tmp___0;
#line 1397
  *result = tmp;
  }
#line 1397
  if (! tmp) {
#line 1398
    goto ERROR1;
  }
  {
#line 1400
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the line number");
#line 1401
  (*result)->position = psiconv_read_X(config, buf, lev + 2, off + (psiconv_u32 )len,
                                       & leng, & res);
  }
#line 1402
  if (res) {
#line 1403
    goto ERROR2;
  }
  {
#line 1404
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Line number: %d\n",
                (*result)->position);
#line 1405
  len += leng;
#line 1407
  tmp___1 = psiconv_clone_cell_layout((psiconv_sheet_cell_layout )default_layout);
#line 1407
  (*result)->layout = tmp___1;
  }
#line 1407
  if (! tmp___1) {
#line 1408
    goto ERROR2;
  }
  {
#line 1409
  res = psiconv_parse_sheet_cell_layout(config, buf, lev + 2, off + (psiconv_u32 )len,
                                        & leng, (*result)->layout);
  }
#line 1409
  if (res) {
#line 1411
    goto ERROR3;
  }
#line 1412
  len += leng;
#line 1414
  if (length) {
#line 1415
    *length = len;
  }
  {
#line 1417
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of the sheet line (total length: %08x)",
                   len);
  }
#line 1419
  return (0);
  ERROR3: 
  {
#line 1422
  psiconv_free_sheet_cell_layout((*result)->layout);
  }
  ERROR2: 
  {
#line 1424
  free((void *)*result);
  }
  ERROR1: 
  {
#line 1426
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of the sheet line failed");
  }
#line 1427
  if (length) {
#line 1428
    *length = 0;
  }
#line 1429
  if (! res) {
#line 1430
    return (-2);
  } else {
#line 1432
    return (res);
  }
}
}
#line 1436 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
int psiconv_parse_sheet_line_list(psiconv_config const   config , psiconv_buffer const   buf ,
                                  int lev , psiconv_u32 off , int *length , psiconv_sheet_line_list *result ,
                                  psiconv_sheet_cell_layout const   default_layout ) 
{ 
  int res ;
  int len ;
  psiconv_u32 temp ;
  psiconv_sheet_line line ;
  psiconv_u32 listlen ;
  psiconv_u32 i ;
  int leng ;
  psiconv_sheet_line_list tmp ;
  psiconv_u8 tmp___0 ;

  {
  {
#line 1442
  res = 0;
#line 1443
  len = 0;
#line 1449
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read the sheet line list");
#line 1450
  tmp = psiconv_list_new(sizeof(struct psiconv_sheet_line_s ));
#line 1450
  *result = tmp;
  }
#line 1450
  if (! tmp) {
#line 1451
    goto ERROR1;
  }
  {
#line 1453
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the initial byte (%02x expected)",
                   2);
#line 1455
  tmp___0 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 1455
  temp = (psiconv_u32 )tmp___0;
  }
#line 1456
  if (res) {
#line 1457
    goto ERROR2;
  }
#line 1458
  if (temp != 2U) {
    {
#line 1459
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet line list initial byte unknown value (ignored)");
#line 1461
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Initial byte: %02x",
                  temp);
    }
  }
  {
#line 1463
  len ++;
#line 1465
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the number of defined lines");
#line 1467
  listlen = psiconv_read_X(config, buf, lev + 2, off + (psiconv_u32 )len, & leng,
                           & res);
  }
#line 1468
  if (res) {
#line 1469
    goto ERROR2;
  }
  {
#line 1470
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Number of defined lines: %d",
                listlen);
#line 1471
  len += leng;
#line 1473
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read all lines");
#line 1474
  i = (psiconv_u32 )0;
  }
  {
#line 1474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1474
    if (! (i < listlen)) {
#line 1474
      goto while_break;
    }
    {
#line 1475
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read line %d",
                     i);
#line 1476
    res = psiconv_parse_sheet_line(config, buf, lev + 3, off + (psiconv_u32 )len,
                                   & leng, & line, default_layout);
    }
#line 1476
    if (res) {
#line 1478
      goto ERROR2;
    }
    {
#line 1479
    res = psiconv_list_add(*result, (void const   *)line);
    }
#line 1479
    if (res) {
#line 1480
      goto ERROR3;
    }
    {
#line 1481
    free((void *)line);
#line 1482
    len += leng;
#line 1474
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1485
  if (length) {
#line 1486
    *length = len;
  }
  {
#line 1488
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet line list (total length: %08x)",
                   len);
  }
#line 1490
  return (0);
  ERROR3: 
  {
#line 1493
  psiconv_free_sheet_line(line);
  }
  ERROR2: 
  {
#line 1495
  psiconv_free_sheet_line_list(*result);
  }
  ERROR1: 
  {
#line 1497
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Line List failed");
  }
#line 1498
  if (length) {
#line 1499
    *length = 0;
  }
#line 1500
  if (! res) {
#line 1501
    return (-2);
  } else {
#line 1503
    return (res);
  }
}
}
#line 1506 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
int psiconv_parse_sheet_variable(psiconv_config const   config , psiconv_buffer const   buf ,
                                 int lev , psiconv_u32 off , int *length , psiconv_sheet_variable *result ) 
{ 
  int res ;
  int len ;
  psiconv_u32 marker ;
  int leng ;
  psiconv_sheet_variable tmp ;
  void *tmp___0 ;
  psiconv_u8 tmp___1 ;

  {
  {
#line 1511
  res = 0;
#line 1512
  len = 0;
#line 1516
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a sheet variable");
#line 1517
  tmp___0 = malloc(sizeof(*(*result)));
#line 1517
  tmp = (psiconv_sheet_variable )tmp___0;
#line 1517
  *result = tmp;
  }
#line 1517
  if (! tmp) {
#line 1518
    goto ERROR1;
  }
  {
#line 1520
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the variable name");
#line 1521
  (*result)->name = psiconv_read_string(config, buf, lev + 2, off + (psiconv_u32 )len,
                                        & leng, & res);
  }
#line 1522
  if (res) {
#line 1523
    goto ERROR2;
  }
  {
#line 1524
  len += leng;
#line 1526
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the type marker");
#line 1527
  tmp___1 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 1527
  marker = (psiconv_u32 )tmp___1;
  }
#line 1528
  if (res) {
#line 1529
    goto ERROR3;
  }
  {
#line 1530
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Marker: %02x",
                marker);
#line 1531
  len ++;
  }
#line 1533
  if (marker == 0U) {
    {
#line 1534
    (*result)->type = (psiconv_variable_type_t )0;
#line 1535
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read a signed integer");
#line 1536
    (*result)->data.dat_int = psiconv_read_sint(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                & leng, & res);
    }
#line 1537
    if (res) {
#line 1538
      goto ERROR3;
    }
    {
#line 1539
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Value: %d",
                  (*result)->data.dat_int);
#line 1540
    len += leng;
    }
  } else
#line 1541
  if (marker == 1U) {
    {
#line 1542
    (*result)->type = (psiconv_variable_type_t )1;
#line 1543
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read a floating point number");
#line 1544
    (*result)->data.dat_float = psiconv_read_float(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                   & leng, & res);
    }
#line 1546
    if (res) {
#line 1547
      goto ERROR3;
    }
    {
#line 1548
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Value: %f",
                  (*result)->data.dat_float);
#line 1549
    len += leng;
    }
  } else
#line 1550
  if (marker == 2U) {
    {
#line 1551
    (*result)->type = (psiconv_variable_type_t )2;
#line 1552
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read a string");
#line 1553
    (*result)->data.dat_string = psiconv_read_string(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                     & leng, & res);
    }
#line 1555
    if (res) {
#line 1556
      goto ERROR3;
    }
#line 1557
    len += leng;
  } else
#line 1558
  if (marker == 3U) {
    {
#line 1559
    (*result)->type = (psiconv_variable_type_t )3;
#line 1560
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read a cell reference");
#line 1561
    (*result)->data.dat_cellref = psiconv_read_var_cellref(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                           & leng, & res);
    }
#line 1563
    if (res) {
#line 1564
      goto ERROR3;
    }
#line 1565
    len += leng;
  } else
#line 1566
  if (marker == 4U) {
    {
#line 1567
    (*result)->type = (psiconv_variable_type_t )4;
#line 1568
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read a cell block reference");
#line 1569
    (*result)->data.dat_cellblock = psiconv_read_var_cellblock(config, buf, lev + 2,
                                                               off + (psiconv_u32 )len,
                                                               & leng, & res);
    }
#line 1572
    if (res) {
#line 1573
      goto ERROR3;
    }
#line 1574
    len += leng;
  } else {
    {
#line 1576
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet variable unknown type marker");
#line 1577
    res = -3;
    }
#line 1578
    goto ERROR3;
  }
  {
#line 1581
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the variable number");
#line 1582
  (*result)->number = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                       & res);
  }
#line 1583
  if (res) {
#line 1584
    goto ERROR4;
  }
  {
#line 1585
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Number: %08x",
                (*result)->number);
#line 1586
  len += 4;
  }
#line 1588
  if (length) {
#line 1589
    *length = len;
  }
  {
#line 1591
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet variable (total length: %08x)",
                   len);
  }
#line 1593
  return (0);
  ERROR4: 
#line 1596
  if ((unsigned int )(*result)->type == 2U) {
    {
#line 1597
    free((void *)(*result)->data.dat_string);
    }
  }
  ERROR3: 
  {
#line 1599
  free((void *)(*result)->name);
  }
  ERROR2: 
  {
#line 1601
  free((void *)*result);
  }
  ERROR1: 
  {
#line 1603
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Variable failed");
  }
#line 1604
  if (length) {
#line 1605
    *length = 0;
  }
#line 1606
  if (! res) {
#line 1607
    return (-2);
  } else {
#line 1609
    return (res);
  }
}
}
#line 1613 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
int psiconv_parse_sheet_variable_list(psiconv_config const   config , psiconv_buffer const   buf ,
                                      int lev , psiconv_u32 off , int *length , psiconv_sheet_variable_list *result ) 
{ 
  int res ;
  int len ;
  psiconv_u32 temp ;
  psiconv_sheet_variable variable ;
  psiconv_u32 listlen ;
  psiconv_u32 i ;
  int leng ;
  psiconv_sheet_variable_list tmp ;
  psiconv_u8 tmp___0 ;

  {
  {
#line 1618
  res = 0;
#line 1619
  len = 0;
#line 1625
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read the sheet variable list");
#line 1626
  tmp = psiconv_list_new(sizeof(struct psiconv_sheet_variable_s ));
#line 1626
  *result = tmp;
  }
#line 1626
  if (! tmp) {
#line 1627
    goto ERROR1;
  }
  {
#line 1629
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the initial byte (%02x expected)",
                   2);
#line 1631
  tmp___0 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 1631
  temp = (psiconv_u32 )tmp___0;
  }
#line 1632
  if (res) {
#line 1633
    goto ERROR2;
  }
#line 1634
  if (temp != 2U) {
    {
#line 1635
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet variable list initial byte unknown value (ignored)");
#line 1637
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Initial byte: %02x",
                  temp);
    }
  }
  {
#line 1639
  len ++;
#line 1641
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the number of variables");
#line 1643
  listlen = psiconv_read_X(config, buf, lev + 2, off + (psiconv_u32 )len, & leng,
                           & res);
  }
#line 1644
  if (res) {
#line 1645
    goto ERROR2;
  }
  {
#line 1646
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Number of variables: %d",
                listlen);
#line 1647
  len += leng;
#line 1649
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read all variables");
#line 1650
  i = (psiconv_u32 )0;
  }
  {
#line 1650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1650
    if (! (i < listlen)) {
#line 1650
      goto while_break;
    }
    {
#line 1651
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read variable %d",
                     i);
#line 1652
    res = psiconv_parse_sheet_variable(config, buf, lev + 3, off + (psiconv_u32 )len,
                                       & leng, & variable);
    }
#line 1652
    if (res) {
#line 1653
      goto ERROR2;
    }
    {
#line 1654
    res = psiconv_list_add(*result, (void const   *)variable);
    }
#line 1654
    if (res) {
#line 1655
      goto ERROR3;
    }
#line 1656
    len += leng;
#line 1650
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1659
  if (length) {
#line 1660
    *length = len;
  }
  {
#line 1662
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet variabels list (total length: %08x)",
                   len);
  }
#line 1664
  return (0);
  ERROR3: 
  {
#line 1667
  psiconv_free_sheet_variable(variable);
  }
  ERROR2: 
  {
#line 1669
  psiconv_list_free(*result);
  }
  ERROR1: 
  {
#line 1671
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Variable list failed");
  }
#line 1672
  if (length) {
#line 1673
    *length = 0;
  }
#line 1674
  if (! res) {
#line 1675
    return (-2);
  } else {
#line 1677
    return (res);
  }
}
}
#line 1680 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
int psiconv_parse_sheet_grid_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                     int lev , psiconv_u32 off , int *length , psiconv_sheet_grid_section *result ) 
{ 
  int res ;
  int i ;
  int len ;
  int leng ;
  psiconv_u32 temp ;
  psiconv_sheet_grid_section tmp ;
  void *tmp___0 ;
  psiconv_u8 tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  psiconv_u8 tmp___7 ;
  char const   *tmp___8 ;
  psiconv_u8 tmp___9 ;
  psiconv_u8 tmp___10 ;
  char const   *tmp___11 ;
  psiconv_u16 tmp___12 ;
  psiconv_u8 tmp___13 ;
  psiconv_u32 tmp___14 ;
  psiconv_u32 tmp___15 ;
  psiconv_u32 tmp___16 ;
  psiconv_u8 tmp___17 ;

  {
  {
#line 1685
  res = 0;
#line 1686
  len = 0;
#line 1689
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read the sheet grid section");
#line 1690
  tmp___0 = malloc(sizeof(*(*result)));
#line 1690
  tmp = (psiconv_sheet_grid_section )tmp___0;
#line 1690
  *result = tmp;
  }
#line 1690
  if (! tmp) {
#line 1691
    goto ERROR1;
  }
  {
#line 1693
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the first flags byte");
#line 1694
  tmp___1 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 1694
  temp = (psiconv_u32 )tmp___1;
  }
#line 1695
  if (res) {
#line 1696
    goto ERROR2;
  }
#line 1697
  if (temp & 1U) {
#line 1697
    (*result)->show_column_titles = (psiconv_bool_t )1;
  } else {
#line 1697
    (*result)->show_column_titles = (psiconv_bool_t )0;
  }
#line 1699
  if ((*result)->show_column_titles) {
#line 1699
    tmp___2 = "true";
  } else {
#line 1699
    tmp___2 = "false";
  }
  {
#line 1699
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Show column titles: %s",
                tmp___2);
  }
#line 1702
  if (temp & 2U) {
#line 1702
    (*result)->show_row_titles = (psiconv_bool_t )1;
  } else {
#line 1702
    (*result)->show_row_titles = (psiconv_bool_t )0;
  }
#line 1703
  if ((*result)->show_row_titles) {
#line 1703
    tmp___3 = "true";
  } else {
#line 1703
    tmp___3 = "false";
  }
  {
#line 1703
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Show row titles: %s",
                tmp___3);
  }
#line 1706
  if (temp & 4U) {
#line 1706
    (*result)->show_vertical_grid = (psiconv_bool_t )1;
  } else {
#line 1706
    (*result)->show_vertical_grid = (psiconv_bool_t )0;
  }
#line 1708
  if ((*result)->show_vertical_grid) {
#line 1708
    tmp___4 = "true";
  } else {
#line 1708
    tmp___4 = "false";
  }
  {
#line 1708
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Show vertical grid: %s",
                tmp___4);
  }
#line 1711
  if (temp & 7U) {
#line 1711
    (*result)->show_horizontal_grid = (psiconv_bool_t )1;
  } else {
#line 1711
    (*result)->show_horizontal_grid = (psiconv_bool_t )0;
  }
#line 1713
  if ((*result)->show_horizontal_grid) {
#line 1713
    tmp___5 = "true";
  } else {
#line 1713
    tmp___5 = "false";
  }
  {
#line 1713
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Show horizontal grid: %s",
                tmp___5);
  }
#line 1716
  if (temp & 128U) {
#line 1716
    (*result)->freeze_rows = (psiconv_bool_t )1;
  } else {
#line 1716
    (*result)->freeze_rows = (psiconv_bool_t )0;
  }
#line 1717
  if ((*result)->freeze_rows) {
#line 1717
    tmp___6 = "true";
  } else {
#line 1717
    tmp___6 = "false";
  }
  {
#line 1717
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Freeze rows: %s",
                tmp___6);
  }
#line 1720
  if ((temp & 112U) != 48U) {
    {
#line 1721
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Grid section first flag byte has unknown bits (ignored)");
#line 1723
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Bits: %02x (%02x expected)",
                  temp & 112U, 48);
    }
  }
  {
#line 1725
  len ++;
#line 1727
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the second flags byte");
#line 1728
  tmp___7 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 1728
  temp = (psiconv_u32 )tmp___7;
  }
#line 1729
  if (res) {
#line 1730
    goto ERROR2;
  }
#line 1731
  if (temp & 1U) {
#line 1731
    (*result)->freeze_columns = (psiconv_bool_t )1;
  } else {
#line 1731
    (*result)->freeze_columns = (psiconv_bool_t )0;
  }
#line 1732
  if ((*result)->freeze_columns) {
#line 1732
    tmp___8 = "true";
  } else {
#line 1732
    tmp___8 = "false";
  }
  {
#line 1732
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Freeze columns: %s",
                tmp___8);
  }
#line 1734
  if ((temp & 254U) != 128U) {
    {
#line 1735
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Grid section second flag byte has unknown bits (ignored)");
#line 1737
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Bits: %02x (%02x expected)",
                  temp & 254U, 128);
    }
  }
  {
#line 1739
  len ++;
#line 1741
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to an unknown byte (%02x expected)",
                   144);
#line 1743
  tmp___9 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 1743
  temp = (psiconv_u32 )tmp___9;
  }
#line 1744
  if (res) {
#line 1745
    goto ERROR2;
  }
#line 1746
  if (temp != 144U) {
    {
#line 1747
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Grid section third byte unknown value (ignored)");
#line 1749
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Value: %02x",
                  temp);
    }
  }
  {
#line 1751
  len ++;
#line 1753
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the fourth flags byte");
#line 1754
  tmp___10 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 1754
  temp = (psiconv_u32 )tmp___10;
  }
#line 1755
  if (res) {
#line 1756
    goto ERROR2;
  }
#line 1757
  if (temp & 4U) {
#line 1757
    (*result)->show_page_breaks = (psiconv_bool_t )1;
  } else {
#line 1757
    (*result)->show_page_breaks = (psiconv_bool_t )0;
  }
#line 1758
  if ((*result)->show_page_breaks) {
#line 1758
    tmp___11 = "true";
  } else {
#line 1758
    tmp___11 = "false";
  }
  {
#line 1758
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Show page breaks: %s",
                tmp___11);
  }
#line 1761
  if ((temp & 252U) != 0U) {
    {
#line 1762
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Grid section fourth flag byte has unknown bits (ignored)");
#line 1764
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Bits: %02x (%02x expected)",
                  temp & 252U, 0);
    }
  }
  {
#line 1766
  len ++;
#line 1768
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the first visible row");
#line 1769
  (*result)->first_row = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                          & res);
  }
#line 1770
  if (res) {
#line 1771
    goto ERROR2;
  }
  {
#line 1772
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "First row: %d",
                (*result)->first_row);
#line 1773
  len += 4;
#line 1775
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the first visible column");
#line 1776
  (*result)->first_column = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                             & res);
  }
#line 1777
  if (res) {
#line 1778
    goto ERROR2;
  }
  {
#line 1779
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "First column: %d",
                (*result)->first_column);
#line 1780
  len += 4;
#line 1782
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the last visible row");
#line 1783
  (*result)->last_row = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                         & res);
  }
#line 1784
  if (res) {
#line 1785
    goto ERROR2;
  }
  {
#line 1786
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Last row: %d",
                (*result)->last_row);
#line 1787
  len += 4;
#line 1789
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the last visible column");
#line 1790
  (*result)->last_column = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                            & res);
  }
#line 1791
  if (res) {
#line 1792
    goto ERROR2;
  }
  {
#line 1793
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Last column: %d",
                (*result)->last_column);
#line 1794
  len += 4;
#line 1796
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the default row height");
#line 1797
  (*result)->default_row_height = psiconv_read_length(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                      & leng, & res);
  }
#line 1799
  if (res) {
#line 1800
    goto ERROR2;
  }
  {
#line 1801
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Default row height: %f",
                (double )(*result)->default_row_height);
#line 1803
  len += leng;
#line 1805
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the row heights list");
#line 1806
  res = psiconv_parse_sheet_grid_size_list(config, buf, lev + 2, off + (psiconv_u32 )len,
                                           & leng, & (*result)->row_heights);
  }
#line 1806
  if (res) {
#line 1808
    goto ERROR2;
  }
  {
#line 1809
  len += leng;
#line 1811
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the default column height");
#line 1812
  (*result)->default_column_width = psiconv_read_length(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                        & leng, & res);
  }
#line 1814
  if (res) {
#line 1815
    goto ERROR3;
  }
  {
#line 1816
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Default column width: %f",
                (double )(*result)->default_column_width);
#line 1818
  len += leng;
#line 1820
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the column heights list");
#line 1821
  res = psiconv_parse_sheet_grid_size_list(config, buf, lev + 2, off + (psiconv_u32 )len,
                                           & leng, & (*result)->column_heights);
  }
#line 1821
  if (res) {
#line 1823
    goto ERROR3;
  }
  {
#line 1824
  len += leng;
#line 1826
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read an unknown word (%04x expected)",
                   0);
#line 1828
  tmp___12 = psiconv_read_u16(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 1828
  temp = (psiconv_u32 )tmp___12;
  }
#line 1829
  if (res) {
#line 1830
    goto ERROR4;
  }
#line 1831
  if (temp != 0U) {
    {
#line 1832
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Grid section unknown word has unknown value (ignored)");
#line 1834
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Value: %04x",
                  temp);
    }
  }
  {
#line 1836
  len += 2;
#line 1838
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the row breaks list");
#line 1839
  res = psiconv_parse_sheet_grid_break_list(config, buf, lev + 2, off + (psiconv_u32 )len,
                                            & leng, & (*result)->row_page_breaks);
  }
#line 1839
  if (res) {
#line 1841
    goto ERROR4;
  }
  {
#line 1842
  len += leng;
#line 1844
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the column breaks list");
#line 1845
  res = psiconv_parse_sheet_grid_break_list(config, buf, lev + 2, off + (psiconv_u32 )len,
                                            & leng, & (*result)->column_page_breaks);
  }
#line 1845
  if (res) {
#line 1847
    goto ERROR5;
  }
  {
#line 1848
  len += leng;
#line 1851
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read 22 unknown bytes (%02x expected)",
                   0);
#line 1853
  i = 0;
  }
  {
#line 1853
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1853
    if (! (i < 22)) {
#line 1853
      goto while_break;
    }
    {
#line 1854
    tmp___13 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 1854
    temp = (psiconv_u32 )tmp___13;
    }
#line 1855
    if (res) {
#line 1856
      goto ERROR6;
    }
#line 1857
    if (temp != 0U) {
      {
#line 1858
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Grid section unknown byte %d has unknown value (ignored)",
                   i);
#line 1861
      psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Value: %02x",
                    temp);
      }
    }
#line 1863
    len ++;
#line 1853
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1866
  if ((*result)->freeze_rows) {
#line 1866
    goto _L;
  } else
#line 1866
  if ((*result)->freeze_columns) {
    _L: /* CIL Label */ 
    {
#line 1868
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read number of frozen rows");
#line 1869
    (*result)->frozen_rows = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                              & res);
    }
#line 1870
    if (res) {
#line 1871
      goto ERROR6;
    }
    {
#line 1872
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Number of frozen rows: %d",
                  (*result)->frozen_rows);
#line 1874
    len += leng;
#line 1876
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read number of frozen columns");
#line 1877
    (*result)->frozen_columns = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                 & res);
    }
#line 1878
    if (res) {
#line 1879
      goto ERROR6;
    }
    {
#line 1880
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Number of frozen columns: %d",
                  (*result)->frozen_columns);
#line 1882
    len += leng;
#line 1884
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read first unfrozen row");
#line 1885
    (*result)->first_unfrozen_row_displayed = psiconv_read_u32(config, buf, lev + 2,
                                                               off + (psiconv_u32 )len,
                                                               & res);
    }
#line 1887
    if (res) {
#line 1888
      goto ERROR6;
    }
    {
#line 1889
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "First row: %d",
                  (*result)->first_unfrozen_row_displayed);
#line 1891
    len += leng;
#line 1893
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read first unfrozen column");
#line 1894
    (*result)->first_unfrozen_column_displayed = psiconv_read_u32(config, buf, lev + 2,
                                                                  off + (psiconv_u32 )len,
                                                                  & res);
    }
#line 1896
    if (res) {
#line 1897
      goto ERROR6;
    }
    {
#line 1898
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "First column: %d",
                  (*result)->first_unfrozen_column_displayed);
#line 1900
    len += leng;
    }
  } else {
#line 1902
    tmp___16 = (psiconv_u32 )0;
#line 1902
    (*result)->first_unfrozen_column_displayed = tmp___16;
#line 1902
    tmp___15 = tmp___16;
#line 1902
    (*result)->first_unfrozen_row_displayed = tmp___15;
#line 1902
    tmp___14 = tmp___15;
#line 1902
    (*result)->frozen_columns = tmp___14;
#line 1902
    (*result)->frozen_rows = tmp___14;
  }
  {
#line 1906
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read 3 unknown bytes (%02x expected)",
                   255);
#line 1908
  i = 0;
  }
  {
#line 1908
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1908
    if (! (i < 3)) {
#line 1908
      goto while_break___0;
    }
    {
#line 1909
    tmp___17 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 1909
    temp = (psiconv_u32 )tmp___17;
    }
#line 1910
    if (res) {
#line 1911
      goto ERROR6;
    }
#line 1912
    if (temp != 255U) {
      {
#line 1913
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Grid section unknown byte %d has unknown value (ignored)",
                   i);
#line 1916
      psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Value: %02x",
                    temp);
      }
    }
#line 1918
    len ++;
#line 1908
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1921
  if (length) {
#line 1922
    *length = len;
  }
  {
#line 1924
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet grid section (total length: %08x)",
                   len);
  }
#line 1926
  return (0);
  ERROR6: 
  {
#line 1929
  psiconv_free_sheet_grid_break_list((*result)->column_page_breaks);
  }
  ERROR5: 
  {
#line 1931
  psiconv_free_sheet_grid_break_list((*result)->row_page_breaks);
  }
  ERROR4: 
  {
#line 1933
  psiconv_free_sheet_grid_size_list((*result)->column_heights);
  }
  ERROR3: 
  {
#line 1935
  psiconv_free_sheet_grid_size_list((*result)->row_heights);
  }
  ERROR2: 
  {
#line 1937
  free((void *)*result);
  }
  ERROR1: 
  {
#line 1939
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Grid Section failed");
  }
#line 1940
  if (length) {
#line 1941
    *length = 0;
  }
#line 1942
  if (! res) {
#line 1943
    return (-2);
  } else {
#line 1945
    return (res);
  }
}
}
#line 1949 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
int psiconv_parse_sheet_grid_size_list(psiconv_config const   config , psiconv_buffer const   buf ,
                                       int lev , psiconv_u32 off , int *length , psiconv_sheet_grid_size_list *result ) 
{ 
  int res ;
  int len ;
  int i ;
  int leng ;
  int listlen ;
  psiconv_sheet_grid_size size ;
  psiconv_sheet_grid_size_list tmp ;
  psiconv_u32 tmp___0 ;

  {
  {
#line 1954
  res = 0;
#line 1955
  len = 0;
#line 1959
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a sheet grid size list");
#line 1960
  tmp = psiconv_list_new(sizeof(struct psiconv_sheet_grid_size_s ));
#line 1960
  *result = tmp;
  }
#line 1960
  if (! tmp) {
#line 1961
    goto ERROR1;
  }
  {
#line 1963
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the number of elements");
#line 1965
  tmp___0 = psiconv_read_X(config, buf, lev + 2, off + (psiconv_u32 )len, & leng,
                           & res);
#line 1965
  listlen = (int )tmp___0;
  }
#line 1966
  if (res) {
#line 1967
    goto ERROR2;
  }
  {
#line 1968
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Number of elements: %d",
                listlen);
#line 1969
  len += leng;
#line 1971
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read all elements");
#line 1972
  i = 0;
  }
  {
#line 1972
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1972
    if (! (i < listlen)) {
#line 1972
      goto while_break;
    }
    {
#line 1973
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read element %d",
                     i);
#line 1974
    res = psiconv_parse_sheet_grid_size(config, buf, lev + 3, off + (psiconv_u32 )len,
                                        & leng, & size);
    }
#line 1974
    if (res) {
#line 1975
      goto ERROR2;
    }
    {
#line 1976
    res = psiconv_list_add(*result, (void const   *)size);
    }
#line 1976
    if (res) {
#line 1977
      goto ERROR3;
    }
    {
#line 1978
    free((void *)size);
#line 1979
    len += leng;
#line 1972
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1982
  if (length) {
#line 1983
    *length = len;
  }
  {
#line 1985
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet grid size list (total length: %08x)",
                   len);
  }
#line 1987
  return (0);
  ERROR3: 
  {
#line 1990
  psiconv_free_sheet_grid_size(size);
  }
  ERROR2: 
  {
#line 1992
  psiconv_list_free(*result);
  }
  ERROR1: 
  {
#line 1994
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Grid Size List failed");
  }
#line 1995
  if (length) {
#line 1996
    *length = 0;
  }
#line 1997
  if (! res) {
#line 1998
    return (-2);
  } else {
#line 2000
    return (res);
  }
}
}
#line 2003 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
int psiconv_parse_sheet_grid_size(psiconv_config const   config , psiconv_buffer const   buf ,
                                  int lev , psiconv_u32 off , int *length , psiconv_sheet_grid_size *result ) 
{ 
  int res ;
  int len ;
  int leng ;
  psiconv_sheet_grid_size tmp ;
  void *tmp___0 ;

  {
  {
#line 2008
  res = 0;
#line 2009
  len = 0;
#line 2012
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a sheet grid size");
#line 2014
  tmp___0 = malloc(sizeof(*(*result)));
#line 2014
  tmp = (psiconv_sheet_grid_size )tmp___0;
#line 2014
  *result = tmp;
  }
#line 2014
  if (! tmp) {
#line 2015
    goto ERROR1;
  }
  {
#line 2017
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the row or column number");
#line 2018
  (*result)->line_number = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                            & res);
  }
#line 2019
  if (res) {
#line 2020
    goto ERROR2;
  }
  {
#line 2021
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Line number: %d\n",
                (*result)->line_number);
#line 2022
  len += 4;
#line 2024
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the row or column height");
#line 2025
  (*result)->size = psiconv_read_length(config, buf, lev + 2, off + (psiconv_u32 )len,
                                        & leng, & res);
  }
#line 2026
  if (res) {
#line 2027
    goto ERROR2;
  }
  {
#line 2028
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Size: %f\n",
                (double )(*result)->size);
#line 2029
  len += leng;
  }
#line 2031
  if (length) {
#line 2032
    *length = len;
  }
  {
#line 2034
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet grid size(total length: %08x)",
                   len);
  }
#line 2036
  return (0);
  ERROR2: 
  {
#line 2039
  free((void *)*result);
  }
  ERROR1: 
  {
#line 2041
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Grid Size failed");
  }
#line 2042
  if (length) {
#line 2043
    *length = 0;
  }
#line 2044
  if (! res) {
#line 2045
    return (-2);
  } else {
#line 2047
    return (res);
  }
}
}
#line 2051 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
int psiconv_parse_sheet_grid_break_list(psiconv_config const   config , psiconv_buffer const   buf ,
                                        int lev , psiconv_u32 off , int *length ,
                                        psiconv_sheet_grid_break_list *result ) 
{ 
  int res ;
  int len ;
  int i ;
  int leng ;
  int listlen ;
  psiconv_u32 nr ;
  psiconv_sheet_grid_break_list tmp ;
  psiconv_u32 tmp___0 ;

  {
  {
#line 2056
  res = 0;
#line 2057
  len = 0;
#line 2061
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a sheet grid break list");
#line 2062
  tmp = psiconv_list_new(sizeof(psiconv_u32 ));
#line 2062
  *result = tmp;
  }
#line 2062
  if (! tmp) {
#line 2063
    goto ERROR1;
  }
  {
#line 2065
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the number of elements");
#line 2067
  tmp___0 = psiconv_read_X(config, buf, lev + 2, off + (psiconv_u32 )len, & leng,
                           & res);
#line 2067
  listlen = (int )tmp___0;
  }
#line 2068
  if (res) {
#line 2069
    goto ERROR2;
  }
  {
#line 2070
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Number of elements: %d",
                listlen);
#line 2071
  len += leng;
#line 2073
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read all elements");
#line 2074
  i = 0;
  }
  {
#line 2074
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2074
    if (! (i < listlen)) {
#line 2074
      goto while_break;
    }
    {
#line 2075
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read element %d",
                     i);
#line 2076
    nr = psiconv_read_u32(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
    }
#line 2077
    if (res) {
#line 2078
      goto ERROR2;
    }
    {
#line 2079
    res = psiconv_list_add(*result, (void const   *)(& nr));
    }
#line 2079
    if (res) {
#line 2080
      goto ERROR2;
    }
#line 2081
    len += leng;
#line 2074
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2084
  if (length) {
#line 2085
    *length = len;
  }
  {
#line 2087
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet grid break list (total length: %08x)",
                   len);
  }
#line 2089
  return (0);
  ERROR2: 
  {
#line 2092
  psiconv_list_free(*result);
  }
  ERROR1: 
  {
#line 2094
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Grid break List failed");
  }
#line 2095
  if (length) {
#line 2096
    *length = 0;
  }
#line 2097
  if (! res) {
#line 2098
    return (-2);
  } else {
#line 2100
    return (res);
  }
}
}
#line 96 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_routines.h"
int psiconv_write_page_header(psiconv_config const   config , psiconv_buffer buf ,
                              int lev , psiconv_page_header const   value , psiconv_buffer *extra_buf ) ;
#line 35 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_page.c"
int psiconv_write_page_header(psiconv_config const   config , psiconv_buffer buf ,
                              int lev , psiconv_page_header const   value , psiconv_buffer *extra_buf ) 
{ 
  int res ;
  psiconv_paragraph_layout basepara ;
  psiconv_character_layout basechar ;

  {
  {
#line 44
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing page header");
  }
#line 46
  if (! value) {
    {
#line 47
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null page header");
#line 48
    res = -4;
    }
#line 49
    goto ERROR1;
  }
  {
#line 52
  basepara = psiconv_basic_paragraph_layout();
  }
#line 52
  if (! basepara) {
    {
#line 53
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 54
    res = -2;
    }
#line 55
    goto ERROR1;
  }
  {
#line 57
  basechar = psiconv_basic_character_layout();
  }
#line 57
  if (! basechar) {
    {
#line 58
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 59
    res = -2;
    }
#line 60
    goto ERROR2;
  }
  {
#line 64
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )1);
  }
#line 64
  if (res) {
#line 65
    goto ERROR3;
  }
  {
#line 66
  res = psiconv_write_bool(config, buf, lev + 1, (psiconv_bool_t const   )value->on_first_page);
  }
#line 66
  if (res) {
#line 67
    goto ERROR3;
  }
  {
#line 69
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )0);
  }
#line 69
  if (res) {
#line 70
    goto ERROR3;
  }
  {
#line 71
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )0);
  }
#line 71
  if (res) {
#line 72
    goto ERROR3;
  }
  {
#line 73
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )0);
  }
#line 73
  if (res) {
#line 74
    goto ERROR3;
  }
  {
#line 75
  res = psiconv_write_paragraph_layout_list(config, buf, lev + 1, (psiconv_paragraph_layout const   )value->base_paragraph_layout,
                                            (psiconv_paragraph_layout const   )basepara);
  }
#line 75
  if (res) {
#line 77
    goto ERROR3;
  }
  {
#line 78
  res = psiconv_write_character_layout_list(config, buf, lev + 1, (psiconv_character_layout const   )value->base_character_layout,
                                            (psiconv_character_layout const   )basechar);
  }
#line 78
  if (res) {
#line 80
    goto ERROR3;
  }
  {
#line 81
  res = psiconv_write_texted_section(config, buf, lev + 1, (psiconv_texted_section const   )value->text,
                                     (psiconv_character_layout const   )value->base_character_layout,
                                     (psiconv_paragraph_layout const   )value->base_paragraph_layout,
                                     extra_buf);
  }
  ERROR3: 
  {
#line 85
  psiconv_free_character_layout(basechar);
  }
  ERROR2: 
  {
#line 87
  psiconv_free_paragraph_layout(basepara);
  }
  ERROR1: 
#line 89
  if (res) {
    {
#line 90
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of page header failed");
    }
  } else {
    {
#line 92
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of page header");
    }
  }
#line 93
  return (res);
}
}
#line 96 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_page.c"
int psiconv_write_page_layout_section(psiconv_config const   config , psiconv_buffer buf ,
                                      int lev , psiconv_page_layout_section const   value ) 
{ 
  int res ;
  psiconv_buffer header_buf ;
  psiconv_buffer footer_buf ;

  {
  {
#line 103
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing page layout section");
  }
#line 105
  if (! value) {
    {
#line 106
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null page section");
#line 107
    res = -4;
    }
#line 108
    goto ERROR1;
  }
  {
#line 111
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )value->first_page_nr);
  }
#line 111
  if (res) {
#line 112
    goto ERROR1;
  }
  {
#line 113
  res = psiconv_write_length(config, buf, lev + 1, (psiconv_length_t const   )value->header_dist);
  }
#line 113
  if (res) {
#line 114
    goto ERROR1;
  }
  {
#line 115
  res = psiconv_write_length(config, buf, lev + 1, (psiconv_length_t const   )value->footer_dist);
  }
#line 115
  if (res) {
#line 116
    goto ERROR1;
  }
  {
#line 117
  res = psiconv_write_length(config, buf, lev + 1, (psiconv_length_t const   )value->left_margin);
  }
#line 117
  if (res) {
#line 118
    goto ERROR1;
  }
  {
#line 119
  res = psiconv_write_length(config, buf, lev + 1, (psiconv_length_t const   )value->right_margin);
  }
#line 119
  if (res) {
#line 120
    goto ERROR1;
  }
  {
#line 121
  res = psiconv_write_length(config, buf, lev + 1, (psiconv_length_t const   )value->top_margin);
  }
#line 121
  if (res) {
#line 122
    goto ERROR1;
  }
  {
#line 123
  res = psiconv_write_length(config, buf, lev + 1, (psiconv_length_t const   )value->bottom_margin);
  }
#line 123
  if (res) {
#line 124
    goto ERROR1;
  }
  {
#line 125
  res = psiconv_write_page_header(config, buf, lev + 1, (psiconv_page_header const   )value->header,
                                  & header_buf);
  }
#line 125
  if (res) {
#line 126
    goto ERROR1;
  }
  {
#line 127
  res = psiconv_write_page_header(config, buf, lev + 1, (psiconv_page_header const   )value->footer,
                                  & footer_buf);
  }
#line 127
  if (res) {
#line 128
    goto ERROR2;
  }
  {
#line 129
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )268435726);
  }
#line 129
  if (res) {
#line 130
    goto ERROR3;
  }
  {
#line 131
  res = psiconv_write_length(config, buf, lev + 1, (psiconv_length_t const   )value->page_width);
  }
#line 131
  if (res) {
#line 132
    goto ERROR3;
  }
  {
#line 133
  res = psiconv_write_length(config, buf, lev + 1, (psiconv_length_t const   )value->page_height);
  }
#line 133
  if (res) {
#line 134
    goto ERROR3;
  }
  {
#line 135
  res = psiconv_write_bool(config, buf, lev + 1, (psiconv_bool_t const   )value->landscape);
  }
#line 135
  if (res) {
#line 136
    goto ERROR3;
  }
  {
#line 137
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )header_buf);
  }
#line 137
  if (res) {
    {
#line 138
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 139
    goto ERROR3;
  }
  {
#line 141
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )footer_buf);
  }
#line 141
  if (res) {
    {
#line 142
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 143
    goto ERROR3;
  }
  ERROR3: 
  {
#line 148
  psiconv_buffer_free(footer_buf);
  }
  ERROR2: 
  {
#line 150
  psiconv_buffer_free(header_buf);
  }
  ERROR1: 
#line 152
  if (res) {
    {
#line 153
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of page layout section failed");
    }
  } else {
    {
#line 155
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of page layout section");
    }
  }
#line 156
  return (res);
}
}
#line 36 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle8(psiconv_config const   config , int lev , psiconv_u32 off ,
                               psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) ;
#line 41
static int psiconv_decode_rle12(psiconv_config const   config , int lev , psiconv_u32 off ,
                                psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) ;
#line 46
static int psiconv_decode_rle16(psiconv_config const   config , int lev , psiconv_u32 off ,
                                psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) ;
#line 51
static int psiconv_decode_rle24(psiconv_config const   config , int lev , psiconv_u32 off ,
                                psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) ;
#line 56
static int psiconv_bytes_to_pixel_data(psiconv_config const   config , int lev , psiconv_u32 off ,
                                       psiconv_pixel_bytes const   bytes , psiconv_pixel_ints *pixels ,
                                       int colordepth , int xsize , int ysize ) ;
#line 62
static int psiconv_pixel_data_to_floats(psiconv_config const   config , int lev ,
                                        psiconv_u32 off , psiconv_pixel_ints const   pixels ,
                                        psiconv_pixel_floats_t *floats , int colordepth ,
                                        int color___1 , int redbits , int bluebits ,
                                        int greenbits , psiconv_pixel_floats_t const   palet ) ;
#line 72 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
int psiconv_parse_jumptable_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                    int lev , psiconv_u32 off , int *length , psiconv_jumptable_section *result ) 
{ 
  int res ;
  int len ;
  psiconv_u32 listlen ;
  psiconv_u32 temp ;
  int i ;
  psiconv_jumptable_section tmp ;

  {
  {
#line 77
  res = 0;
#line 78
  len = 0;
#line 82
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read the jumptable section");
#line 83
  tmp = psiconv_list_new(sizeof(psiconv_u32 ));
#line 83
  *result = tmp;
  }
#line 83
  if (! tmp) {
#line 84
    goto ERROR1;
  }
  {
#line 86
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the list length");
#line 87
  listlen = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 88
  if (res) {
#line 89
    goto ERROR2;
  }
  {
#line 90
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "List length: %08x",
                listlen);
#line 91
  len += 4;
#line 93
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the list");
#line 94
  i = 0;
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! ((psiconv_u32 )i < listlen)) {
#line 94
      goto while_break;
    }
    {
#line 95
    temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
    }
#line 96
    if (res) {
#line 97
      goto ERROR2;
    }
    {
#line 98
    res = psiconv_list_add(*result, (void const   *)(& temp));
    }
#line 98
    if (res) {
#line 99
      goto ERROR2;
    }
    {
#line 100
    psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Offset: %08x",
                  temp);
#line 101
    len += 4;
#line 94
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if (length) {
#line 105
    *length = len;
  }
  {
#line 107
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of jumptable section (total length: %08x)", len);
  }
#line 110
  return (0);
  ERROR2: 
  {
#line 113
  psiconv_list_free(*result);
  }
  ERROR1: 
  {
#line 115
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Jumptable Section failed");
  }
#line 116
  if (length) {
#line 117
    *length = 0;
  }
#line 118
  if (! res) {
#line 119
    return (-2);
  } else {
#line 121
    return (res);
  }
}
}
#line 124 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
int psiconv_parse_paint_data_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                     int lev , psiconv_u32 off , int *length , int isclipart ,
                                     psiconv_paint_data_section *result ) 
{ 
  int res ;
  int len ;
  psiconv_u32 size ;
  psiconv_u32 offset ;
  psiconv_u32 picsize ;
  psiconv_u32 temp ;
  psiconv_u32 datasize ;
  psiconv_u32 color___1 ;
  psiconv_u32 redbits ;
  psiconv_u32 bluebits ;
  psiconv_u32 greenbits ;
  psiconv_u8 byte ;
  int leng ;
  int i ;
  psiconv_u32 bits_per_pixel ;
  psiconv_u32 compression ;
  psiconv_pixel_bytes bytes ;
  psiconv_pixel_bytes decoded ;
  psiconv_pixel_ints pixels ;
  psiconv_pixel_floats_t floats ;
  psiconv_pixel_floats_t palet ;
  psiconv_paint_data_section tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 129
  res = 0;
#line 130
  len = 0;
#line 140
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a paint data section");
#line 141
  tmp___0 = malloc(sizeof(*(*result)));
#line 141
  tmp = (psiconv_paint_data_section )tmp___0;
#line 141
  *result = tmp;
  }
#line 141
  if (! tmp) {
#line 142
    goto ERROR1;
  }
  {
#line 144
  bytes = psiconv_list_new(sizeof(psiconv_u8 ));
  }
#line 144
  if (! bytes) {
#line 145
    goto ERROR2;
  }
  {
#line 147
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read section size");
#line 148
  size = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 149
  if (res) {
#line 150
    goto ERROR3;
  }
  {
#line 151
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Section size: %08x",
                size);
#line 152
  len += 4;
#line 154
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read pixel data offset");
#line 155
  offset = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 156
  if (res) {
#line 157
    goto ERROR3;
  }
#line 158
  if (offset != 40U) {
    {
#line 159
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Paint data section data offset has unexpected value");
#line 161
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Data offset: read %08x, expected %08x",
                  offset, 40);
#line 163
    res = -1;
    }
  }
  {
#line 165
  len += 4;
#line 167
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read picture X size");
#line 168
  (*result)->xsize = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                      & res);
  }
#line 169
  if (res) {
#line 170
    goto ERROR3;
  }
  {
#line 171
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Picture X size: %08x:",
                (*result)->xsize);
#line 172
  len += 4;
#line 174
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read picture Y size");
#line 175
  (*result)->ysize = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                      & res);
  }
#line 176
  if (res) {
#line 177
    goto ERROR3;
  }
  {
#line 178
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Picture Y size: %08x:",
                (*result)->ysize);
#line 179
  len += 4;
#line 181
  picsize = (*result)->ysize * (*result)->xsize;
#line 183
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the real picture x size");
#line 184
  (*result)->pic_xsize = psiconv_read_length(config, buf, lev + 2, off + (psiconv_u32 )len,
                                             & leng, & res);
  }
#line 185
  if (res) {
#line 186
    goto ERROR3;
  }
  {
#line 187
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Picture x size: %f",
                (double )(*result)->pic_xsize);
#line 188
  len += leng;
#line 190
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the real picture y size");
#line 191
  (*result)->pic_ysize = psiconv_read_length(config, buf, lev + 2, off + (psiconv_u32 )len,
                                             & leng, & res);
  }
#line 192
  if (res) {
#line 193
    goto ERROR3;
  }
  {
#line 194
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Picture y size: %f",
                (double )(*result)->pic_ysize);
#line 195
  len += leng;
#line 197
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the number of bits per pixel");
#line 198
  bits_per_pixel = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                    & res);
  }
#line 199
  if (res) {
#line 200
    goto ERROR3;
  }
  {
#line 201
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Bits per pixel: %d",
                bits_per_pixel);
#line 202
  len += 4;
#line 204
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read whether this is a colour or greyscale picture");
#line 206
  color___1 = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 207
  if (res) {
#line 208
    goto ERROR3;
  }
#line 209
  if (color___1 != 0U) {
#line 209
    if (color___1 != 1U) {
      {
#line 210
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Paint data section unknown color type (ignored)");
#line 212
      psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Color: read %08x, expected %08x or %08x",
                    color___1, 0, 1);
#line 214
      color___1 = (psiconv_u32 )1;
      }
    } else {
#line 209
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 216
    if (color___1) {
#line 216
      tmp___1 = "color";
    } else {
#line 216
      tmp___1 = "greyscale";
    }
    {
#line 216
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Color: %08x (%s picture)",
                  color___1, tmp___1);
    }
  }
  {
#line 219
  len += 4;
#line 221
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 222
  if (res) {
#line 223
    goto ERROR3;
  }
#line 224
  if (temp != 0U) {
    {
#line 225
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Paint data section prologue has unknown values (ignored)");
#line 227
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "read %08x, expected %08x",
                  temp, 0);
    }
  }
  {
#line 230
  len += 4;
#line 232
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read whether RLE compression is used");
#line 234
  compression = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 235
  if (res) {
#line 236
    goto ERROR3;
  }
#line 237
  if (compression > 4U) {
    {
#line 238
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Paint data section has unknown compression type, assuming RLE");
#line 240
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Read compression type %d",
                  compression);
#line 241
    compression = (psiconv_u32 )0;
    }
  }
#line 243
  if (compression == 4U) {
#line 243
    tmp___5 = "RLE24";
  } else {
#line 243
    if (compression == 3U) {
#line 243
      tmp___4 = "RLE16";
    } else {
#line 243
      if (compression == 2U) {
#line 243
        tmp___3 = "RLE12";
      } else {
#line 243
        if (compression == 1U) {
#line 243
          tmp___2 = "RLE8";
        } else {
#line 243
          tmp___2 = "none";
        }
#line 243
        tmp___3 = tmp___2;
      }
#line 243
      tmp___4 = tmp___3;
    }
#line 243
    tmp___5 = tmp___4;
  }
  {
#line 243
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Compression: %s",
                tmp___5);
#line 246
  len += 4;
  }
#line 248
  if (isclipart) {
    {
#line 249
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read an unknown long");
#line 250
    temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
    }
#line 251
    if (res) {
#line 252
      goto ERROR3;
    }
#line 253
    if (temp != 4294967295U) {
      {
#line 254
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Paint data section prologue has unknown values (ignoring)");
#line 256
      psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Read %08x, expected %08x",
                    temp, 4294967295U);
      }
    }
    {
#line 259
    len += 4;
#line 260
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read a second unknown long");
#line 261
    temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
    }
#line 262
    if (res) {
#line 263
      goto ERROR3;
    }
#line 264
    if (temp != 68U) {
      {
#line 265
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Paint data section prologue has unknown values (ignoring)");
#line 267
      psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "read %08x, expected %08x",
                    temp, 68);
      }
    }
#line 270
    len += 4;
  }
#line 273
  len = (int )offset;
#line 274
  datasize = size - (psiconv_u32 )len;
#line 275
  if (isclipart) {
#line 276
    len += 8;
  }
#line 278
  if (color___1) {
    {
#line 279
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "All image types except 2-bit greyscale are experimental!");
    }
  } else
#line 278
  if (bits_per_pixel != 2U) {
    {
#line 279
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "All image types except 2-bit greyscale are experimental!");
    }
  }
  {
#line 282
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the pixel data");
#line 283
  i = 0;
  }
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (! ((psiconv_u32 )i < datasize)) {
#line 283
      goto while_break;
    }
    {
#line 284
    byte = psiconv_read_u8(config, buf, lev + 2, (off + (psiconv_u32 )len) + (psiconv_u32 )i,
                           & res);
    }
#line 290
    if (res) {
#line 291
      goto ERROR3;
    }
    {
#line 292
    psiconv_list_add(bytes, (void const   *)(& byte));
#line 283
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 294
  len = (int )((psiconv_u32 )len + datasize);
  {
#line 297
  if (compression == 1U) {
#line 297
    goto case_1;
  }
#line 303
  if (compression == 2U) {
#line 303
    goto case_2;
  }
#line 309
  if (compression == 3U) {
#line 309
    goto case_3;
  }
#line 315
  if (compression == 4U) {
#line 315
    goto case_4;
  }
#line 296
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 298
  res = psiconv_decode_rle8(config, lev + 2, off + (psiconv_u32 )len, (psiconv_pixel_bytes const   )bytes,
                            & decoded);
  }
#line 298
  if (res) {
#line 299
    goto ERROR3;
  }
  {
#line 300
  psiconv_list_free(bytes);
#line 301
  bytes = decoded;
  }
#line 302
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 304
  tmp___6 = psiconv_decode_rle12(config, lev + 2, off + (psiconv_u32 )len, (psiconv_pixel_bytes const   )bytes,
                                 & decoded);
  }
#line 304
  if (tmp___6) {
#line 305
    goto ERROR3;
  }
  {
#line 306
  psiconv_list_free(bytes);
#line 307
  bytes = decoded;
  }
#line 308
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 310
  tmp___7 = psiconv_decode_rle16(config, lev + 2, off + (psiconv_u32 )len, (psiconv_pixel_bytes const   )bytes,
                                 & decoded);
  }
#line 310
  if (tmp___7) {
#line 311
    goto ERROR3;
  }
  {
#line 312
  psiconv_list_free(bytes);
#line 313
  bytes = decoded;
  }
#line 314
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 316
  tmp___8 = psiconv_decode_rle24(config, lev + 2, off + (psiconv_u32 )len, (psiconv_pixel_bytes const   )bytes,
                                 & decoded);
  }
#line 316
  if (tmp___8) {
#line 317
    goto ERROR3;
  }
  {
#line 318
  psiconv_list_free(bytes);
#line 319
  bytes = decoded;
  }
#line 320
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 323
  res = psiconv_bytes_to_pixel_data(config, lev + 2, off + (psiconv_u32 )len, (psiconv_pixel_bytes const   )bytes,
                                    & pixels, (int )bits_per_pixel, (int )(*result)->xsize,
                                    (int )(*result)->ysize);
  }
#line 323
  if (res) {
#line 326
    goto ERROR3;
  }
#line 329
  greenbits = (psiconv_u32 )0;
#line 329
  redbits = greenbits;
#line 329
  bluebits = redbits;
#line 330
  palet = psiconv_palet_none;
#line 331
  if (color___1) {
#line 332
    if (bits_per_pixel == 4U) {
#line 333
      palet = psiconv_palet_color_4;
    } else
#line 334
    if (bits_per_pixel == 8U) {
#line 335
      palet = psiconv_palet_color_8;
    } else {
#line 337
      redbits = (bits_per_pixel + 2U) / 3U;
#line 338
      greenbits = (bits_per_pixel + 2U) / 3U;
#line 339
      bluebits = (bits_per_pixel - redbits) - greenbits;
    }
  }
  {
#line 342
  res = psiconv_pixel_data_to_floats(config, lev + 2, off + (psiconv_u32 )len, (psiconv_pixel_ints const   )pixels,
                                     & floats, (int )bits_per_pixel, (int )color___1,
                                     (int )redbits, (int )greenbits, (int )bluebits,
                                     (psiconv_pixel_floats_t const   )palet);
  }
#line 342
  if (res) {
#line 345
    goto ERROR4;
  }
  {
#line 347
  (*result)->red = floats.red;
#line 348
  (*result)->green = floats.green;
#line 349
  (*result)->blue = floats.blue;
#line 351
  psiconv_list_free(bytes);
#line 352
  psiconv_list_free(pixels);
  }
#line 355
  if (length) {
#line 356
    *length = len;
  }
  {
#line 358
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of Paint Data Section (total length: %08x)",
                   len);
  }
#line 361
  return (0);
  ERROR4: 
  {
#line 364
  psiconv_list_free(pixels);
  }
  ERROR3: 
  {
#line 366
  psiconv_list_free(bytes);
  }
  ERROR2: 
  {
#line 368
  free((void *)*result);
  }
  ERROR1: 
  {
#line 370
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Paint Data Section failed");
  }
#line 371
  if (length) {
#line 372
    *length = 0;
  }
#line 373
  if (! res) {
#line 374
    return (-2);
  } else {
#line 376
    return (res);
  }
}
}
#line 379 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
int psiconv_parse_sketch_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                 int lev , psiconv_u32 off , int *length , psiconv_sketch_section *result ) 
{ 
  int res ;
  int len ;
  psiconv_u32 temp ;
  int leng ;
  psiconv_sketch_section tmp ;
  void *tmp___0 ;
  psiconv_u16 tmp___1 ;
  psiconv_u16 tmp___2 ;
  psiconv_u16 tmp___3 ;

  {
  {
#line 384
  res = 0;
#line 385
  len = 0;
#line 389
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read the sketch section");
#line 390
  tmp___0 = malloc(sizeof(*(*result)));
#line 390
  tmp = (psiconv_sketch_section )tmp___0;
#line 390
  *result = tmp;
  }
#line 390
  if (! tmp) {
#line 391
    goto ERROR1;
  }
  {
#line 393
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the displayed hor. size");
#line 394
  (*result)->displayed_xsize = psiconv_read_u16(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                & res);
  }
#line 395
  if (res) {
#line 396
    goto ERROR2;
  }
  {
#line 397
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Displayed hor. size: %04x",
                (int )(*result)->displayed_xsize);
#line 399
  len += 2;
#line 400
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read displayed ver. size");
#line 401
  (*result)->displayed_ysize = psiconv_read_u16(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                & res);
  }
#line 402
  if (res) {
#line 403
    goto ERROR2;
  }
  {
#line 404
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Displayed ver. size: %04x",
                (int )(*result)->displayed_ysize);
#line 406
  len += 2;
#line 408
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the data hor. offset");
#line 409
  (*result)->picture_data_x_offset = psiconv_read_u16(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                      & res);
  }
#line 411
  if (res) {
#line 412
    goto ERROR2;
  }
  {
#line 413
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Data hor. offset: %04x",
                (int )(*result)->picture_data_x_offset);
#line 415
  len += 2;
#line 416
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the data ver. offset");
#line 417
  (*result)->picture_data_y_offset = psiconv_read_u16(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                      & res);
  }
#line 419
  if (res) {
#line 420
    goto ERROR2;
  }
  {
#line 421
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Data ver. offset: %04x",
                (int )(*result)->picture_data_y_offset);
#line 423
  len += 2;
#line 425
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the displayed hor. offset");
#line 426
  (*result)->displayed_size_x_offset = psiconv_read_u16(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                        & res);
  }
#line 428
  if (res) {
#line 429
    goto ERROR2;
  }
  {
#line 430
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Displayed hor. offset: %04x",
                (int )(*result)->displayed_size_x_offset);
#line 432
  len += 2;
#line 433
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the displayed ver. offset");
#line 434
  (*result)->displayed_size_y_offset = psiconv_read_u16(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                        & res);
  }
#line 436
  if (res) {
#line 437
    goto ERROR2;
  }
  {
#line 438
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Displayed ver. offset: %04x",
                (int )(*result)->displayed_size_y_offset);
#line 440
  len += 2;
#line 442
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the form hor. size");
#line 443
  (*result)->form_xsize = psiconv_read_u16(config, buf, lev + 2, off + (psiconv_u32 )len,
                                           & res);
  }
#line 444
  if (res) {
#line 445
    goto ERROR2;
  }
  {
#line 446
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Form hor. size: %04x",
                (int )(*result)->form_xsize);
#line 448
  len += 2;
#line 449
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read form ver. size");
#line 450
  (*result)->form_ysize = psiconv_read_u16(config, buf, lev + 2, off + (psiconv_u32 )len,
                                           & res);
  }
#line 451
  if (res) {
#line 452
    goto ERROR2;
  }
  {
#line 453
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Form ver. size: %04x",
                (int )(*result)->form_ysize);
#line 455
  len += 2;
#line 457
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to skip 1 word of zeros");
#line 458
  tmp___1 = psiconv_read_u16(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 458
  temp = (psiconv_u32 )tmp___1;
  }
#line 459
  if (res) {
#line 460
    goto ERROR2;
  }
#line 461
  if (temp != 0U) {
    {
#line 462
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unexpected value in sketch section preamble (ignored)");
#line 464
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Read %04x, expected %04x",
                  temp, 0);
    }
  }
  {
#line 467
  off += 2U;
#line 469
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the picture data");
#line 470
  res = psiconv_parse_paint_data_section(config, buf, lev + 2, off + (psiconv_u32 )len,
                                         & leng, 0, & (*result)->picture);
  }
#line 470
  if (res) {
#line 472
    goto ERROR2;
  }
  {
#line 473
  off += (psiconv_u32 )leng;
#line 475
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the hor. magnification");
#line 476
  tmp___2 = psiconv_read_u16(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 476
  (*result)->magnification_x = (float )((double )tmp___2 / 1000.0);
  }
#line 477
  if (res) {
#line 478
    goto ERROR3;
  }
  {
#line 479
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Form hor. magnification: %f",
                (double )(*result)->magnification_x);
#line 481
  len += 2;
#line 482
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the ver. magnification");
#line 483
  tmp___3 = psiconv_read_u16(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 483
  (*result)->magnification_y = (float )((double )tmp___3 / 1000.0);
  }
#line 484
  if (res) {
#line 485
    goto ERROR3;
  }
  {
#line 486
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Form ver. magnification: %f",
                (double )(*result)->magnification_y);
#line 488
  len += 2;
#line 490
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the left cut");
#line 491
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 492
  if (res) {
#line 493
    goto ERROR3;
  }
  {
#line 494
  (*result)->cut_left = (float )(((double )temp * 6.0) / (double )(*result)->displayed_xsize);
#line 495
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Left cut: raw %08x, real: %f",
                temp, (double )(*result)->cut_left);
#line 497
  len += 4;
#line 498
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the right cut");
#line 499
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 500
  if (res) {
#line 501
    goto ERROR3;
  }
  {
#line 502
  (*result)->cut_right = (float )(((double )temp * 6.0) / (double )(*result)->displayed_xsize);
#line 503
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Right cut: raw %08x, real: %f",
                temp, (double )(*result)->cut_right);
#line 505
  len += 4;
#line 506
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the top cut");
#line 507
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 508
  if (res) {
#line 509
    goto ERROR3;
  }
  {
#line 510
  (*result)->cut_top = (float )(((double )temp * 6.0) / (double )(*result)->displayed_ysize);
#line 511
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Top cut: raw %08x, real: %f",
                temp, (double )(*result)->cut_top);
#line 513
  len += 4;
#line 514
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the bottom cut");
#line 515
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 516
  if (res) {
#line 517
    goto ERROR3;
  }
  {
#line 518
  (*result)->cut_bottom = (float )(((double )temp * 6.0) / (double )(*result)->displayed_ysize);
#line 519
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Bottom cut: raw %08x, real: %f",
                temp, (double )(*result)->cut_bottom);
#line 521
  len += 4;
  }
#line 523
  if (length) {
#line 524
    *length = len;
  }
  {
#line 526
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sketch section (total length: %08x)",
                   len);
  }
#line 529
  return (res);
  ERROR3: 
  {
#line 531
  psiconv_free_paint_data_section((*result)->picture);
  }
  ERROR2: 
  {
#line 533
  free((void *)*result);
  }
  ERROR1: 
  {
#line 535
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sketch Section failed");
  }
#line 536
  if (length) {
#line 537
    *length = 0;
  }
#line 538
  if (! res) {
#line 539
    return (-2);
  } else {
#line 541
    return (res);
  }
}
}
#line 545 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
int psiconv_parse_clipart_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                  int lev , psiconv_u32 off , int *length , psiconv_clipart_section *result ) 
{ 
  int res ;
  int len ;
  int leng ;
  psiconv_u32 temp ;
  psiconv_clipart_section tmp ;
  void *tmp___0 ;

  {
  {
#line 550
  res = 0;
#line 551
  len = 0;
#line 555
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read the clipart section");
#line 556
  tmp___0 = malloc(sizeof(*(*result)));
#line 556
  tmp = (psiconv_clipart_section )tmp___0;
#line 556
  *result = tmp;
  }
#line 556
  if (! tmp) {
#line 557
    goto ERROR1;
  }
  {
#line 559
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the section ID");
#line 560
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 561
  if (res) {
#line 562
    goto ERROR2;
  }
#line 563
  if (temp != 268435520U) {
    {
#line 564
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unexpected value in clipart section preamble (ignored)");
#line 566
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Read %08x, expected %08x",
                  temp, 268435520);
    }
  } else {
    {
#line 569
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Clipart ID: %08x",
                  temp);
    }
  }
  {
#line 570
  off += 4U;
#line 572
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read an unknown long");
#line 573
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 574
  if (res) {
#line 575
    goto ERROR2;
  }
#line 576
  if (temp != 2U) {
    {
#line 577
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unexpected value in clipart section preamble (ignored)");
#line 579
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Read %08x, expected %08x",
                  temp, 2);
    }
  } else {
    {
#line 582
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "First unknown long: %08x",
                  temp);
    }
  }
  {
#line 583
  off += 4U;
#line 585
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read a second unknown long");
#line 586
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 587
  if (res) {
#line 588
    goto ERROR2;
  }
#line 589
  if (temp != 0U) {
    {
#line 590
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unexpected value in clipart section preamble (ignored)");
#line 592
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Read %08x, expected %08x",
                  temp, 0);
    }
  } else {
    {
#line 594
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Second unknown long: %08x",
                  temp);
    }
  }
  {
#line 595
  off += 4U;
#line 597
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read a third unknown long");
#line 598
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 599
  if (res) {
#line 600
    goto ERROR2;
  }
#line 601
  if (temp != 0U) {
    {
#line 602
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unexpected value in clipart section preamble (ignored)");
#line 604
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Read %08x, expected %08x",
                  temp, 0);
    }
  } else {
    {
#line 606
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Third unknown long: %08x",
                  temp);
    }
  }
  {
#line 607
  off += 4U;
#line 609
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read a fourth unknown long");
#line 610
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 611
  if (res) {
#line 612
    goto ERROR2;
  }
#line 613
  if (temp != 12U) {
#line 613
    if (temp != 8U) {
      {
#line 614
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unexpected value in clipart section preamble (ignored)");
#line 616
      psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Read %08x, expected %08x or %08x",
                    temp, 12, 8);
      }
    } else {
      {
#line 619
      psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Fourth unknown long: %08x",
                    temp);
      }
    }
  } else {
    {
#line 619
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Fourth unknown long: %08x",
                  temp);
    }
  }
  {
#line 620
  off += 4U;
#line 622
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the Paint Data Section");
#line 623
  res = psiconv_parse_paint_data_section(config, buf, lev + 2, off + (psiconv_u32 )len,
                                         & leng, 1, & (*result)->picture);
  }
#line 623
  if (res) {
#line 625
    goto ERROR2;
  }
#line 626
  len += leng;
#line 628
  if (length) {
#line 629
    *length = len;
  }
  {
#line 631
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of clipart section (total length: %08x)",
                   len);
  }
#line 633
  return (0);
  ERROR2: 
  {
#line 636
  free((void *)*result);
  }
  ERROR1: 
  {
#line 638
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Font failed");
  }
#line 639
  if (length) {
#line 640
    *length = 0;
  }
#line 641
  if (! res) {
#line 642
    return (-2);
  } else {
#line 644
    return (res);
  }
}
}
#line 647 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle8(psiconv_config const   config , int lev , psiconv_u32 off ,
                               psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) 
{ 
  int res ;
  psiconv_u8 *marker ;
  psiconv_u8 *value ;
  int i ;
  int j ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  psiconv_u32 tmp___3 ;

  {
  {
#line 651
  res = 0;
#line 655
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to decode the RLE8 encoding");
#line 656
  tmp = psiconv_list_new(sizeof(psiconv_u8 ));
#line 656
  *decoded = tmp;
  }
#line 656
  if (! tmp) {
#line 657
    goto ERROR1;
  }
#line 659
  i = 0;
  {
#line 659
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 659
    tmp___3 = psiconv_list_length(encoded);
    }
#line 659
    if (! ((psiconv_u32 )i < tmp___3)) {
#line 659
      goto while_break;
    }
    {
#line 663
    tmp___0 = psiconv_list_get(encoded, (psiconv_u32 )i);
#line 663
    marker = (psiconv_u8 *)tmp___0;
    }
#line 663
    if (! marker) {
#line 664
      goto ERROR2;
    }
#line 668
    if ((int )*marker < 128) {
      {
#line 674
      tmp___1 = psiconv_list_get(encoded, (psiconv_u32 )(i + 1));
#line 674
      value = (psiconv_u8 *)tmp___1;
      }
#line 674
      if (! value) {
#line 675
        goto ERROR2;
      }
#line 681
      j = 0;
      {
#line 681
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 681
        if (! (j < (int )*marker + 1)) {
#line 681
          goto while_break___0;
        }
        {
#line 682
        res = psiconv_list_add(*decoded, (void const   *)value);
        }
#line 682
        if (res) {
#line 683
          goto ERROR2;
        }
#line 681
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 684
      i += 2;
    } else {
#line 690
      j = 0;
      {
#line 690
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 690
        if (! (j < 256 - (int )*marker)) {
#line 690
          goto while_break___1;
        }
        {
#line 695
        tmp___2 = psiconv_list_get(encoded, (psiconv_u32 )((i + j) + 1));
#line 695
        value = (psiconv_u8 *)tmp___2;
        }
#line 695
        if (! value) {
#line 696
          goto ERROR2;
        }
        {
#line 700
        res = psiconv_list_add(*decoded, (void const   *)value);
        }
#line 700
        if (res) {
#line 701
          goto ERROR2;
        }
#line 690
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 703
      i += (256 - (int )*marker) + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 706
  psiconv_progress((psiconv_config )config, lev, off, "End of RLE8 decoding process");
  }
#line 708
  return (0);
  ERROR2: 
  {
#line 711
  psiconv_list_free(*decoded);
  }
  ERROR1: 
  {
#line 713
  psiconv_error((psiconv_config )config, lev + 1, off, "Decoding of RLE8 failed");
  }
#line 714
  if (! res) {
#line 715
    return (-2);
  } else {
#line 717
    return (res);
  }
}
}
#line 720 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle12(psiconv_config const   config , int lev , psiconv_u32 off ,
                                psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) 
{ 
  int res ;
  psiconv_u8 *value0 ;
  psiconv_u8 *value1 ;
  psiconv_u32 value ;
  psiconv_u32 repeat ;
  int i ;
  int j ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  psiconv_u32 tmp___2 ;

  {
  {
#line 724
  res = 0;
#line 729
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to decode the RLE12 encoding");
#line 730
  tmp = psiconv_list_new(sizeof(psiconv_u8 ));
#line 730
  *decoded = tmp;
  }
#line 730
  if (! tmp) {
#line 731
    goto ERROR1;
  }
#line 733
  i = 0;
  {
#line 733
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 733
    tmp___2 = psiconv_list_length(encoded);
    }
#line 733
    if (! ((psiconv_u32 )i < tmp___2)) {
#line 733
      goto while_break;
    }
    {
#line 734
    psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read data word at %04x",
                     i);
#line 735
    tmp___0 = psiconv_list_get(encoded, (psiconv_u32 )i);
#line 735
    value0 = (psiconv_u8 *)tmp___0;
    }
#line 735
    if (! value0) {
#line 736
      goto ERROR2;
    }
    {
#line 737
    tmp___1 = psiconv_list_get(encoded, (psiconv_u32 )(i + 1));
#line 737
    value1 = (psiconv_u8 *)tmp___1;
    }
#line 737
    if (! value1) {
#line 738
      goto ERROR2;
    }
    {
#line 739
    psiconv_debug((psiconv_config )config, lev + 2, off, "Data Word: %04x", (int )*value0 + ((int )*value1 << 8));
#line 740
    value = (psiconv_u32 )((int )*value0 + (((int )*value1 & 15) << 8));
#line 741
    repeat = (psiconv_u32 )(((int )*value1 >> 4) + 1);
#line 742
    psiconv_progress((psiconv_config )config, lev + 2, off, "Adding %02x pixels %03x",
                     repeat, value);
#line 744
    j = 0;
    }
    {
#line 744
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 744
      if (! ((psiconv_u32 )j < repeat)) {
#line 744
        goto while_break___0;
      }
      {
#line 745
      res = psiconv_list_add(*decoded, (void const   *)(& value));
      }
#line 745
      if (res) {
#line 746
        goto ERROR2;
      }
#line 744
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 747
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 749
  psiconv_progress((psiconv_config )config, lev, off, "End of RLE12 decoding process");
  }
#line 751
  return (0);
  ERROR2: 
  {
#line 754
  psiconv_list_free(*decoded);
  }
  ERROR1: 
  {
#line 756
  psiconv_error((psiconv_config )config, lev + 1, off, "Decoding of RLE12 failed");
  }
#line 757
  if (! res) {
#line 758
    return (-2);
  } else {
#line 760
    return (res);
  }
}
}
#line 763 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle16(psiconv_config const   config , int lev , psiconv_u32 off ,
                                psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) 
{ 
  int res ;
  psiconv_u8 *marker ;
  psiconv_u8 *value0 ;
  psiconv_u8 *value1 ;
  psiconv_u32 value ;
  int i ;
  int j ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  psiconv_u32 tmp___5 ;

  {
  {
#line 767
  res = 0;
#line 772
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to decode the RLE16 encoding");
#line 773
  tmp = psiconv_list_new(sizeof(psiconv_u8 ));
#line 773
  *decoded = tmp;
  }
#line 773
  if (! tmp) {
#line 774
    goto ERROR1;
  }
#line 776
  i = 0;
  {
#line 776
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 776
    tmp___5 = psiconv_list_length(encoded);
    }
#line 776
    if (! ((psiconv_u32 )i < tmp___5)) {
#line 776
      goto while_break;
    }
    {
#line 777
    psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read marker byte at %04x",
                     i);
#line 778
    tmp___0 = psiconv_list_get(encoded, (psiconv_u32 )i);
#line 778
    marker = (psiconv_u8 *)tmp___0;
    }
#line 778
    if (! marker) {
#line 779
      goto ERROR2;
    }
    {
#line 780
    psiconv_debug((psiconv_config )config, lev + 2, off, "Marker byte: %02x", (int )*marker);
    }
#line 781
    if ((int )*marker < 128) {
      {
#line 782
      psiconv_debug((psiconv_config )config, lev + 2, off, "Marker: repeat value word %02x times",
                    (int )*marker + 1);
#line 784
      psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read value word at %04x",
                       i + 1);
#line 785
      tmp___1 = psiconv_list_get(encoded, (psiconv_u32 )(i + 1));
#line 785
      value0 = (psiconv_u8 *)tmp___1;
      }
#line 785
      if (! value0) {
#line 786
        goto ERROR2;
      }
      {
#line 787
      tmp___2 = psiconv_list_get(encoded, (psiconv_u32 )(i + 2));
#line 787
      value1 = (psiconv_u8 *)tmp___2;
      }
#line 787
      if (! value1) {
#line 788
        goto ERROR2;
      }
      {
#line 789
      value = (psiconv_u32 )((int )*value0 + ((int )*value1 << 8));
#line 790
      psiconv_debug((psiconv_config )config, lev + 2, off, "Value word: %02x", value);
#line 791
      psiconv_progress((psiconv_config )config, lev + 2, off, "Adding %02x pixels %04x",
                       (int )*marker + 1, value);
#line 793
      j = 0;
      }
      {
#line 793
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 793
        if (! (j < (int )*marker + 1)) {
#line 793
          goto while_break___0;
        }
        {
#line 794
        res = psiconv_list_add(*decoded, (void const   *)(& value));
        }
#line 794
        if (res) {
#line 795
          goto ERROR2;
        }
#line 793
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 796
      i += 3;
    } else {
      {
#line 798
      psiconv_debug((psiconv_config )config, lev + 2, off, "Marker: %02x value words follow",
                    256 - (int )*marker);
#line 800
      j = 0;
      }
      {
#line 800
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 800
        if (! (j < 256 - (int )*marker)) {
#line 800
          goto while_break___1;
        }
        {
#line 801
        psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read value word at %04x",
                         (i + j * 2) + 1);
#line 803
        tmp___3 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 2) + 1));
#line 803
        value0 = (psiconv_u8 *)tmp___3;
        }
#line 803
        if (! value0) {
#line 804
          goto ERROR2;
        }
        {
#line 805
        tmp___4 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 2) + 2));
#line 805
        value1 = (psiconv_u8 *)tmp___4;
        }
#line 805
        if (! value1) {
#line 806
          goto ERROR2;
        }
        {
#line 807
        value = (psiconv_u32 )((int )*value0 + ((int )*value1 << 8));
#line 808
        psiconv_debug((psiconv_config )config, lev + 2, off, "Value: %04x", value);
#line 809
        res = psiconv_list_add(*decoded, (void const   *)(& value));
        }
#line 809
        if (res) {
#line 810
          goto ERROR2;
        }
#line 800
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 812
      i += (256 - (int )*marker) * 2 + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 815
  psiconv_progress((psiconv_config )config, lev, off, "End of RLE16 decoding process");
  }
#line 817
  return (0);
  ERROR2: 
  {
#line 820
  psiconv_list_free(*decoded);
  }
  ERROR1: 
  {
#line 822
  psiconv_error((psiconv_config )config, lev + 1, off, "Decoding of RLE16 failed");
  }
#line 823
  if (! res) {
#line 824
    return (-2);
  } else {
#line 826
    return (res);
  }
}
}
#line 829 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle24(psiconv_config const   config , int lev , psiconv_u32 off ,
                                psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) 
{ 
  int res ;
  psiconv_u8 *marker ;
  psiconv_u8 *value0 ;
  psiconv_u8 *value1 ;
  psiconv_u8 *value2 ;
  psiconv_u32 value ;
  int i ;
  int j ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  psiconv_u32 tmp___7 ;

  {
  {
#line 833
  res = 0;
#line 838
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to decode the RLE24 encoding");
#line 839
  tmp = psiconv_list_new(sizeof(psiconv_u8 ));
#line 839
  *decoded = tmp;
  }
#line 839
  if (! tmp) {
#line 840
    goto ERROR1;
  }
#line 842
  i = 0;
  {
#line 842
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 842
    tmp___7 = psiconv_list_length(encoded);
    }
#line 842
    if (! ((psiconv_u32 )i < tmp___7)) {
#line 842
      goto while_break;
    }
    {
#line 843
    psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read marker byte at %04x",
                     i);
#line 844
    tmp___0 = psiconv_list_get(encoded, (psiconv_u32 )i);
#line 844
    marker = (psiconv_u8 *)tmp___0;
    }
#line 844
    if (! marker) {
#line 845
      goto ERROR2;
    }
    {
#line 846
    psiconv_debug((psiconv_config )config, lev + 2, off, "Marker byte: %02x", (int )*marker);
    }
#line 847
    if ((int )*marker < 128) {
      {
#line 848
      psiconv_debug((psiconv_config )config, lev + 2, off, "Marker: repeat value byte triplet %02x times",
                    (int )*marker + 1);
#line 850
      psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read value byte triplet at %04x",
                       i + 1);
#line 851
      tmp___1 = psiconv_list_get(encoded, (psiconv_u32 )(i + 1));
#line 851
      value0 = (psiconv_u8 *)tmp___1;
      }
#line 851
      if (! value0) {
#line 852
        goto ERROR2;
      }
      {
#line 853
      tmp___2 = psiconv_list_get(encoded, (psiconv_u32 )(i + 2));
#line 853
      value1 = (psiconv_u8 *)tmp___2;
      }
#line 853
      if (! value1) {
#line 854
        goto ERROR2;
      }
      {
#line 855
      tmp___3 = psiconv_list_get(encoded, (psiconv_u32 )(i + 3));
#line 855
      value2 = (psiconv_u8 *)tmp___3;
      }
#line 855
      if (! value2) {
#line 856
        goto ERROR2;
      }
      {
#line 857
      value = (psiconv_u32 )(((int )*value0 + ((int )*value1 << 8)) + ((int )*value2 << 16));
#line 858
      psiconv_debug((psiconv_config )config, lev + 2, off, "Value byte triplet: %06x",
                    value);
#line 859
      psiconv_progress((psiconv_config )config, lev + 2, off, "Adding %02x pixels %06x",
                       (int )*marker + 1, value);
#line 861
      j = 0;
      }
      {
#line 861
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 861
        if (! (j < (int )*marker + 1)) {
#line 861
          goto while_break___0;
        }
        {
#line 862
        res = psiconv_list_add(*decoded, (void const   *)(& value));
        }
#line 862
        if (res) {
#line 863
          goto ERROR2;
        }
#line 861
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 864
      i += 4;
    } else {
      {
#line 866
      psiconv_debug((psiconv_config )config, lev + 2, off, "Marker: %02x value byte triplets follow",
                    256 - (int )*marker);
#line 868
      j = 0;
      }
      {
#line 868
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 868
        if (! (j < 256 - (int )*marker)) {
#line 868
          goto while_break___1;
        }
        {
#line 869
        psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read value byte triplets at %04x",
                         (i + j * 3) + 1);
#line 871
        tmp___4 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 3) + 1));
#line 871
        value0 = (psiconv_u8 *)tmp___4;
        }
#line 871
        if (! value0) {
#line 872
          goto ERROR2;
        }
        {
#line 873
        tmp___5 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 3) + 2));
#line 873
        value1 = (psiconv_u8 *)tmp___5;
        }
#line 873
        if (! value1) {
#line 874
          goto ERROR2;
        }
        {
#line 875
        tmp___6 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 3) + 3));
#line 875
        value2 = (psiconv_u8 *)tmp___6;
        }
#line 875
        if (! value2) {
#line 876
          goto ERROR2;
        }
        {
#line 877
        value = (psiconv_u32 )(((int )*value0 + ((int )*value1 << 8)) + ((int )*value2 << 16));
#line 878
        psiconv_debug((psiconv_config )config, lev + 2, off, "Value: %06x", value);
#line 879
        res = psiconv_list_add(*decoded, (void const   *)(& value));
        }
#line 879
        if (res) {
#line 880
          goto ERROR2;
        }
#line 868
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 882
      i += (256 - (int )*marker) * 3 + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 885
  psiconv_progress((psiconv_config )config, lev, off, "End of RLE24 decoding process");
  }
#line 887
  return (0);
  ERROR2: 
  {
#line 890
  psiconv_list_free(*decoded);
  }
  ERROR1: 
  {
#line 892
  psiconv_error((psiconv_config )config, lev + 1, off, "Decoding of RLE24 failed");
  }
#line 893
  if (! res) {
#line 894
    return (-2);
  } else {
#line 896
    return (res);
  }
}
}
#line 899 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_bytes_to_pixel_data(psiconv_config const   config , int lev , psiconv_u32 off ,
                                       psiconv_pixel_bytes const   bytes , psiconv_pixel_ints *pixels ,
                                       int colordepth , int xsize , int ysize ) 
{ 
  int res ;
  int ibits ;
  int obits ;
  int x ;
  int y ;
  int bits ;
  psiconv_u8 input ;
  psiconv_u32 nr ;
  psiconv_u32 output ;
  psiconv_u8 *ientry ;
  psiconv_pixel_ints tmp ;
  void *tmp___0 ;

  {
  {
#line 905
  res = 0;
#line 911
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to convert the bytes to pixels");
#line 912
  tmp = psiconv_list_new(sizeof(psiconv_u32 ));
#line 912
  *pixels = tmp;
  }
#line 912
  if (! tmp) {
#line 913
    goto ERROR1;
  }
#line 915
  nr = (psiconv_u32 )0;
#line 916
  y = 0;
  {
#line 916
  while (1) {
    while_continue: /* CIL Label */ ;
#line 916
    if (! (y < ysize)) {
#line 916
      goto while_break;
    }
    {
#line 918
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 918
      if (! (nr % 4U)) {
#line 918
        goto while_break___0;
      }
#line 919
      nr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 920
    input = (psiconv_u8 )0;
#line 921
    ibits = 0;
#line 922
    x = 0;
    {
#line 922
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 922
      if (! (x < xsize)) {
#line 922
        goto while_break___1;
      }
#line 927
      output = (psiconv_u32 )0;
#line 928
      obits = 0;
      {
#line 929
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 929
        if (! (obits < colordepth)) {
#line 929
          goto while_break___2;
        }
#line 930
        if (ibits == 0) {
          {
#line 935
          tmp___0 = psiconv_list_get(bytes, nr);
#line 935
          ientry = (psiconv_u8 *)tmp___0;
          }
#line 935
          if (! ientry) {
#line 936
            goto ERROR2;
          }
#line 940
          input = *ientry;
#line 941
          ibits = 8;
#line 942
          nr ++;
        }
#line 944
        if (ibits + obits > colordepth) {
#line 944
          bits = colordepth - obits;
        } else {
#line 944
          bits = ibits;
        }
#line 945
        output <<= bits;
#line 946
        output |= (unsigned int )((int )input & ((1 << bits) - 1));
#line 947
        input = (psiconv_u8 )((int )input >> bits);
#line 948
        ibits -= bits;
#line 949
        obits += bits;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 954
      res = psiconv_list_add(*pixels, (void const   *)(& output));
      }
#line 954
      if (res) {
#line 955
        goto ERROR2;
      }
#line 922
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 916
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 959
  psiconv_progress((psiconv_config )config, lev, off, "Converting bytes to pixels completed");
  }
#line 961
  return (0);
  ERROR2: 
  {
#line 965
  psiconv_list_free(*pixels);
  }
  ERROR1: 
  {
#line 967
  psiconv_error((psiconv_config )config, lev + 1, off, "Converting bytes to pixels failed");
  }
#line 968
  if (! res) {
#line 969
    return (-2);
  } else {
#line 971
    return (res);
  }
}
}
#line 974 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_pixel_data_to_floats(psiconv_config const   config , int lev ,
                                        psiconv_u32 off , psiconv_pixel_ints const   pixels ,
                                        psiconv_pixel_floats_t *floats , int colordepth ,
                                        int color___1 , int redbits , int bluebits ,
                                        int greenbits , psiconv_pixel_floats_t const   palet ) 
{ 
  int res ;
  psiconv_u32 i ;
  psiconv_u32 *pixel ;
  float *tmp ;
  psiconv_u32 tmp___0 ;
  void *tmp___1 ;
  float *tmp___2 ;
  psiconv_u32 tmp___3 ;
  void *tmp___4 ;
  float *tmp___5 ;
  psiconv_u32 tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  float tmp___9 ;
  float tmp___10 ;
  psiconv_u32 tmp___11 ;

  {
  {
#line 982
  res = 0;
#line 986
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to convert pixels to floats");
#line 987
  tmp___0 = psiconv_list_length(pixels);
#line 987
  tmp___1 = malloc((unsigned long )tmp___0 * sizeof(*(floats->red)));
#line 987
  tmp = (float *)tmp___1;
#line 987
  floats->red = tmp;
  }
#line 987
  if (! tmp) {
#line 989
    goto ERROR1;
  }
  {
#line 990
  tmp___3 = psiconv_list_length(pixels);
#line 990
  tmp___4 = malloc((unsigned long )tmp___3 * sizeof(*(floats->green)));
#line 990
  tmp___2 = (float *)tmp___4;
#line 990
  floats->green = tmp___2;
  }
#line 990
  if (! tmp___2) {
#line 992
    goto ERROR2;
  }
  {
#line 993
  tmp___6 = psiconv_list_length(pixels);
#line 993
  tmp___7 = malloc((unsigned long )tmp___6 * sizeof(*(floats->blue)));
#line 993
  tmp___5 = (float *)tmp___7;
#line 993
  floats->blue = tmp___5;
  }
#line 993
  if (! tmp___5) {
#line 995
    goto ERROR3;
  }
  {
#line 996
  floats->length = psiconv_list_length(pixels);
#line 998
  i = (psiconv_u32 )0;
  }
  {
#line 998
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 998
    tmp___11 = psiconv_list_length(pixels);
    }
#line 998
    if (! (i < tmp___11)) {
#line 998
      goto while_break;
    }
    {
#line 999
    tmp___8 = psiconv_list_get(pixels, i);
#line 999
    pixel = (psiconv_u32 *)tmp___8;
    }
#line 999
    if (! pixel) {
#line 1000
      goto ERROR4;
    }
#line 1004
    if (! palet.length) {
#line 1005
      if (color___1) {
#line 1006
        *(floats->blue + i) = (float )(*pixel & (unsigned int )((1 << bluebits) - 1)) / (float )((1 << bluebits) - 1);
#line 1008
        *(floats->green + i) = (float )((*pixel >> bluebits) & (unsigned int )((1 << greenbits) - 1)) / (float )((1 << greenbits) - 1);
#line 1010
        *(floats->red + i) = (float )((*pixel >> (bluebits + greenbits)) & (unsigned int )((1 << redbits) - 1)) / (float )((1 << redbits) - 1);
      } else {
#line 1013
        tmp___10 = (float )*pixel / (float )((1 << colordepth) - 1);
#line 1013
        *(floats->blue + i) = tmp___10;
#line 1013
        tmp___9 = tmp___10;
#line 1013
        *(floats->green + i) = tmp___9;
#line 1013
        *(floats->red + i) = tmp___9;
      }
    } else
#line 1018
    if (*pixel >= (psiconv_u32 )palet.length) {
      {
#line 1019
      psiconv_warn((psiconv_config )config, lev + 2, off, "Invalid palet color found (using color 0x00)");
#line 1021
      *(floats->red + i) = *(palet.red + 0);
#line 1022
      *(floats->green + i) = *(palet.green + 0);
#line 1023
      *(floats->blue + i) = *(palet.blue + 0);
      }
    } else {
#line 1025
      *(floats->red + i) = *(palet.red + *pixel);
#line 1026
      *(floats->green + i) = *(palet.green + *pixel);
#line 1027
      *(floats->blue + i) = *(palet.blue + *pixel);
    }
#line 998
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1035
  psiconv_progress((psiconv_config )config, lev + 1, off, "Finished converting pixels to floats");
  }
#line 1036
  return (0);
  ERROR4: 
  {
#line 1039
  free((void *)floats->blue);
  }
  ERROR3: 
  {
#line 1041
  free((void *)floats->green);
  }
  ERROR2: 
  {
#line 1043
  free((void *)floats->red);
  }
  ERROR1: 
  {
#line 1045
  psiconv_error((psiconv_config )config, lev + 1, off, "Converting pixels to floats failed");
  }
#line 1046
  if (! res) {
#line 1047
    return (-2);
  } else {
#line 1049
    return (res);
  }
}
}
#line 58 "../psiconv/buffer.h"
int psiconv_buffer_add(psiconv_buffer buf , psiconv_u8 data ) ;
#line 46 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_routines.h"
int psiconv_write_S(psiconv_config const   config , psiconv_buffer buf , int lev ,
                    psiconv_u32 const   value ) ;
#line 58
int psiconv_write_short_string(psiconv_config const   config , psiconv_buffer buf ,
                               int lev , psiconv_string_t const   value ) ;
#line 34 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_simple.c"
static int psiconv_write_string_aux(psiconv_config const   config , psiconv_buffer buf ,
                                    int lev , psiconv_string_t const   value , int kind ) ;
#line 38 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_simple.c"
int psiconv_write_u8(psiconv_config const   config , psiconv_buffer buf , int lev ,
                     psiconv_u8 const   value ) 
{ 
  int res ;

  {
  {
#line 42
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing u8");
#line 43
  psiconv_debug((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Value: %02x",
                (int const   )value);
#line 44
  res = psiconv_buffer_add(buf, (psiconv_u8 )value);
  }
#line 45
  if (res) {
    {
#line 46
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Out of memory error");
    }
  }
#line 47
  return (res);
}
}
#line 50 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_simple.c"
int psiconv_write_u16(psiconv_config const   config , psiconv_buffer buf , int lev ,
                      psiconv_u16 const   value ) 
{ 
  int res ;

  {
  {
#line 54
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing u16");
#line 55
  psiconv_debug((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Value: %04x",
                (int const   )value);
#line 56
  res = psiconv_buffer_add(buf, (psiconv_u8 )((int const   )value & 255));
  }
#line 56
  if (res) {
#line 57
    goto ERROR;
  }
  {
#line 58
  res = psiconv_buffer_add(buf, (psiconv_u8 )(((int const   )value & 65280) >> 8));
  }
#line 58
  if (res) {

  }
  ERROR: 
#line 61
  if (res) {
    {
#line 62
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Out of memory error");
    }
  }
#line 63
  return (res);
}
}
#line 66 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_simple.c"
int psiconv_write_u32(psiconv_config const   config , psiconv_buffer buf , int lev ,
                      psiconv_u32 const   value ) 
{ 
  int res ;

  {
  {
#line 70
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing u32");
#line 71
  psiconv_debug((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Value: %08x",
                value);
#line 73
  res = psiconv_buffer_add(buf, (psiconv_u8 )(value & 255U));
  }
#line 73
  if (res) {
#line 74
    goto ERROR;
  }
  {
#line 75
  res = psiconv_buffer_add(buf, (psiconv_u8 )((value & 65280U) >> 8));
  }
#line 75
  if (res) {
#line 76
    goto ERROR;
  }
  {
#line 77
  res = psiconv_buffer_add(buf, (psiconv_u8 )((value & 16711680U) >> 16));
  }
#line 77
  if (res) {
#line 78
    goto ERROR;
  }
  {
#line 79
  res = psiconv_buffer_add(buf, (psiconv_u8 )((value & 4278190080U) >> 24));
  }
#line 79
  if (res) {

  }
  ERROR: 
#line 82
  if (res) {
    {
#line 83
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Out of memory error");
    }
  }
#line 84
  return (res);
}
}
#line 87 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_simple.c"
int psiconv_write_S(psiconv_config const   config , psiconv_buffer buf , int lev ,
                    psiconv_u32 const   value ) 
{ 
  int res ;
  psiconv_u32 tmp ;

  {
  {
#line 92
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing S");
#line 93
  psiconv_debug((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Value: %08x",
                value);
  }
#line 94
  if (value < 64U) {
    {
#line 95
    res = psiconv_write_u8(config, buf, lev + 2, (psiconv_u8 const   )(value * 4U + 2U));
    }
  } else
#line 96
  if (value < 8192U) {
    {
#line 97
    res = psiconv_write_u16(config, buf, lev + 2, (psiconv_u16 const   )(value * 8U + 3U));
    }
  } else {
    {
#line 99
    tmp = psiconv_buffer_length((psiconv_buffer const   )buf);
#line 99
    psiconv_error((psiconv_config )config, 0, tmp, "Don\'t know how to write S value larger than 0x2000 (trying %x)",
                  value);
#line 102
    res = -4;
    }
  }
#line 104
  if (res) {
    {
#line 105
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of S failed");
    }
  } else {
    {
#line 107
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of S");
    }
  }
#line 108
  return (res);
}
}
#line 111 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_simple.c"
int psiconv_write_X(psiconv_config const   config , psiconv_buffer buf , int lev ,
                    psiconv_u32 const   value ) 
{ 
  int res ;

  {
  {
#line 115
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing X");
#line 116
  psiconv_debug((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Value: %08x",
                value);
  }
#line 117
  if (value < 128U) {
    {
#line 118
    res = psiconv_write_u8(config, buf, lev + 2, (psiconv_u8 const   )(value * 2U));
    }
  } else
#line 119
  if (value < 16384U) {
    {
#line 120
    res = psiconv_write_u16(config, buf, lev + 2, (psiconv_u16 const   )(value * 4U + 1U));
    }
  } else
#line 121
  if (value < 536870912U) {
    {
#line 122
    res = psiconv_write_u16(config, buf, lev + 2, (psiconv_u16 const   )(value * 8U + 3U));
    }
  } else {
    {
#line 124
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Don\'t know how to write X value larger than 0x20000000 (trying %x)",
                  value);
#line 127
    res = -4;
    }
  }
#line 129
  if (res) {
    {
#line 130
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of X failed");
    }
  } else {
    {
#line 132
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of X");
    }
  }
#line 133
  return (res);
}
}
#line 136 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_simple.c"
int psiconv_write_length(psiconv_config const   config , psiconv_buffer buf , int lev ,
                         psiconv_length_t const   value ) 
{ 
  int res ;

  {
  {
#line 140
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing length");
#line 141
  psiconv_debug((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Value: %f", (double const   )value);
#line 142
  res = psiconv_write_u32(config, buf, lev + 2, (psiconv_u32 const   )((double )value * (1440.0 / 2.54) + 0.5));
  }
#line 143
  if (res) {
    {
#line 144
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of length failed");
    }
  } else {
    {
#line 146
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of length");
    }
  }
#line 147
  return (res);
}
}
#line 150 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_simple.c"
int psiconv_write_size(psiconv_config const   config , psiconv_buffer buf , int lev ,
                       psiconv_size_t const   value ) 
{ 
  int res ;

  {
  {
#line 154
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing size");
#line 155
  psiconv_debug((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Value: %f", (double const   )value);
#line 156
  res = psiconv_write_u32(config, buf, lev + 2, (psiconv_u32 const   )((double )value * 20.0 + 0.5));
  }
#line 157
  if (res) {
    {
#line 158
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of size failed");
    }
  } else {
    {
#line 160
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of size");
    }
  }
#line 161
  return (res);
}
}
#line 164 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_simple.c"
int psiconv_write_bool(psiconv_config const   config , psiconv_buffer buf , int lev ,
                       psiconv_bool_t const   value ) 
{ 
  int res ;
  char const   *tmp ;
  psiconv_u32 tmp___0 ;
  int tmp___1 ;

  {
  {
#line 168
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing bool");
  }
#line 169
  if ((unsigned int const   )value == 0U) {
#line 169
    tmp = "False";
  } else {
#line 169
    tmp = "True";
  }
  {
#line 169
  psiconv_debug((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Value: %s", tmp);
  }
#line 171
  if ((unsigned int const   )value != 1U) {
#line 171
    if ((unsigned int const   )value != 0U) {
      {
#line 172
      tmp___0 = psiconv_buffer_length((psiconv_buffer const   )buf);
#line 172
      psiconv_warn((psiconv_config )config, 0, tmp___0, "Boolean has non-enum value (found %d, used true)",
                   (unsigned int const   )value);
      }
    }
  }
#line 174
  if ((unsigned int const   )value == 0U) {
#line 174
    tmp___1 = 0;
  } else {
#line 174
    tmp___1 = 1;
  }
  {
#line 174
  res = psiconv_write_u8(config, buf, lev + 2, (psiconv_u8 const   )tmp___1);
  }
#line 175
  if (res) {
    {
#line 176
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of bool failed");
    }
  } else {
    {
#line 178
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of bool");
    }
  }
#line 179
  return (res);
}
}
#line 182 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_simple.c"
int psiconv_write_string(psiconv_config const   config , psiconv_buffer buf , int lev ,
                         psiconv_string_t const   value ) 
{ 
  int res ;

  {
  {
#line 186
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing string");
#line 187
  res = psiconv_write_string_aux(config, buf, lev + 1, value, -1);
  }
#line 188
  if (res) {
    {
#line 189
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of string failed");
    }
  } else {
    {
#line 191
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of string");
    }
  }
#line 192
  return (res);
}
}
#line 195 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_simple.c"
int psiconv_write_short_string(psiconv_config const   config , psiconv_buffer buf ,
                               int lev , psiconv_string_t const   value ) 
{ 
  int res ;

  {
  {
#line 199
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing short string");
#line 200
  res = psiconv_write_string_aux(config, buf, lev + 1, value, -2);
  }
#line 201
  if (res) {
    {
#line 202
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of short string failed");
    }
  } else {
    {
#line 204
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of short string");
    }
  }
#line 205
  return (res);
}
}
#line 208 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_simple.c"
int psiconv_write_charlist(psiconv_config const   config , psiconv_buffer buf , int lev ,
                           psiconv_string_t const   value ) 
{ 
  int res ;

  {
  {
#line 212
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing charlist");
#line 213
  res = psiconv_write_string_aux(config, buf, lev + 1, value, 0);
  }
#line 214
  if (res) {
    {
#line 215
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of charlist failed");
    }
  } else {
    {
#line 217
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of charlist");
    }
  }
#line 218
  return (res);
}
}
#line 222 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_simple.c"
static int psiconv_write_string_aux(psiconv_config const   config , psiconv_buffer buf ,
                                    int lev , psiconv_string_t const   value , int kind ) 
{ 
  int res ;
  int i ;
  int len ;
  char *printable ;

  {
  {
#line 228
  len = psiconv_unicode_strlen((psiconv_ucs2 const   *)value);
  }
#line 229
  if (! value) {
    {
#line 230
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "NULL string");
    }
#line 231
    return (-4);
  }
  {
#line 234
  printable = psiconv_make_printable(config, value);
  }
#line 234
  if (! printable) {
    {
#line 235
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Out of memory error");
    }
#line 236
    return (-2);
  }
  {
#line 238
  psiconv_debug((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Value: %s", printable);
#line 239
  free((void *)printable);
  }
#line 241
  if (kind == -1) {
    {
#line 242
    res = psiconv_write_S(config, buf, lev + 2, (psiconv_u32 const   )len);
    }
  } else
#line 243
  if (kind == -2) {
    {
#line 244
    res = psiconv_write_u8(config, buf, lev + 2, (psiconv_u8 const   )len);
    }
  } else {
#line 246
    res = 0;
  }
#line 247
  if (res) {
#line 248
    return (res);
  }
#line 250
  i = 0;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (i < len)) {
#line 250
      goto while_break;
    }
    {
#line 251
    res = psiconv_unicode_write_char(config, buf, lev + 2, *(value + i));
    }
#line 251
    if (res) {
#line 252
      return (res);
    }
#line 250
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  return (0);
}
}
#line 256 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_simple.c"
int psiconv_write_offset(psiconv_config const   config , psiconv_buffer buf , int lev ,
                         psiconv_u32 const   id ) 
{ 
  int res ;

  {
  {
#line 260
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing offset");
#line 261
  psiconv_debug((psiconv_config )config, lev + 1, (psiconv_u32 )0, "ID: %08x", id);
#line 262
  res = psiconv_buffer_add_reference(buf, (int )id);
  }
#line 263
  if (res) {
    {
#line 264
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Out of memory error");
    }
  }
#line 265
  return (res);
}
}
#line 30 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
psiconv_pixel_floats_t psiconv_palet_none  =    {(psiconv_u32 )0, (float *)((void *)0), (float *)((void *)0), (float *)((void *)0)};
#line 39 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_4_red[16]  = 
#line 39
  {      (float )((double )0 / 255.0),      (float )((double )85 / 255.0),      (float )((double )128 / 255.0),      (float )((double )128 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )128 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )170 / 255.0),      (float )((double )255 / 255.0)};
#line 46 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_4_green[16]  = 
#line 46
  {      (float )((double )0 / 255.0),      (float )((double )85 / 255.0),      (float )((double )0 / 255.0),      (float )((double )128 / 255.0), 
        (float )((double )128 / 255.0),      (float )((double )0 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )128 / 255.0),      (float )((double )170 / 255.0),      (float )((double )255 / 255.0)};
#line 53 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_4_blue[16]  = 
#line 53
  {      (float )((double )0 / 255.0),      (float )((double )85 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )255 / 255.0),      (float )((double )128 / 255.0), 
        (float )((double )128 / 255.0),      (float )((double )128 / 255.0),      (float )((double )170 / 255.0),      (float )((double )255 / 255.0)};
#line 60 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
psiconv_pixel_floats_t psiconv_palet_color_4  =    {(psiconv_u32 )16, palet_color_4_red, palet_color_4_green, palet_color_4_blue};
#line 69 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_8_red[256]  = 
#line 69
  {      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )17 / 255.0),      (float )((double )34 / 255.0),      (float )((double )68 / 255.0),      (float )((double )85 / 255.0), 
        (float )((double )119 / 255.0),      (float )((double )17 / 255.0),      (float )((double )34 / 255.0),      (float )((double )68 / 255.0), 
        (float )((double )85 / 255.0),      (float )((double )119 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )136 / 255.0),      (float )((double )170 / 255.0), 
        (float )((double )187 / 255.0),      (float )((double )221 / 255.0),      (float )((double )238 / 255.0),      (float )((double )136 / 255.0), 
        (float )((double )170 / 255.0),      (float )((double )187 / 255.0),      (float )((double )221 / 255.0),      (float )((double )238 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0)};
#line 136 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_8_green[256]  = 
#line 136
  {      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )17 / 255.0),      (float )((double )34 / 255.0),      (float )((double )68 / 255.0),      (float )((double )85 / 255.0), 
        (float )((double )119 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )17 / 255.0),      (float )((double )34 / 255.0), 
        (float )((double )68 / 255.0),      (float )((double )85 / 255.0),      (float )((double )119 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )136 / 255.0),      (float )((double )170 / 255.0),      (float )((double )187 / 255.0), 
        (float )((double )221 / 255.0),      (float )((double )238 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )136 / 255.0), 
        (float )((double )170 / 255.0),      (float )((double )187 / 255.0),      (float )((double )221 / 255.0),      (float )((double )238 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0)};
#line 203 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_8_blue[256]  = 
#line 203
  {      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )17 / 255.0),      (float )((double )34 / 255.0),      (float )((double )68 / 255.0),      (float )((double )85 / 255.0), 
        (float )((double )119 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )17 / 255.0), 
        (float )((double )34 / 255.0),      (float )((double )68 / 255.0),      (float )((double )85 / 255.0),      (float )((double )119 / 255.0), 
        (float )((double )136 / 255.0),      (float )((double )170 / 255.0),      (float )((double )187 / 255.0),      (float )((double )221 / 255.0), 
        (float )((double )238 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )136 / 255.0), 
        (float )((double )170 / 255.0),      (float )((double )187 / 255.0),      (float )((double )221 / 255.0),      (float )((double )238 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0)};
#line 270 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
psiconv_pixel_floats_t psiconv_palet_color_8  =    {(psiconv_u32 )256, palet_color_8_red, palet_color_8_green, palet_color_8_blue};
#line 52 "../psiconv/buffer.h"
psiconv_u8 *psiconv_buffer_get(psiconv_buffer const   buf , psiconv_u32 off ) ;
#line 62 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_routines.h"
psiconv_size_t psiconv_read_size(psiconv_config const   config , psiconv_buffer const   buf ,
                                 int lev , psiconv_u32 off , int *length , int *status ) ;
#line 74
psiconv_string_t psiconv_read_charlist(psiconv_config const   config , psiconv_buffer const   buf ,
                                       int lev , psiconv_u32 off , int nrofchars ,
                                       int *status ) ;
#line 34 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
static psiconv_float_t pow2(int n ) ;
#line 35
static psiconv_string_t psiconv_read_string_aux(psiconv_config const   config , psiconv_buffer const   buf ,
                                                int lev , psiconv_u32 off , int *length ,
                                                int *status , int kind ) ;
#line 42 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
static psiconv_float_t pow2(int n ) 
{ 
  psiconv_float_t res ;
  int i ;
  int tmp ;
  psiconv_float_t tmp___0 ;

  {
#line 44
  res = 1.0;
#line 47
  i = 0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (n < 0) {
#line 47
      tmp = - n;
    } else {
#line 47
      tmp = n;
    }
#line 47
    if (! (i < tmp)) {
#line 47
      goto while_break;
    }
#line 48
    res *= 2.0;
#line 47
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  if (n < 0) {
#line 50
    tmp___0 = (psiconv_float_t )1 / res;
  } else {
#line 50
    tmp___0 = res;
  }
#line 50
  return (tmp___0);
}
}
#line 52 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
psiconv_u8 psiconv_read_u8(psiconv_config const   config , psiconv_buffer const   buf ,
                           int lev , psiconv_u32 off , int *status ) 
{ 
  psiconv_u8 *ptr ;

  {
  {
#line 56
  ptr = psiconv_buffer_get(buf, off);
  }
#line 57
  if (! ptr) {
    {
#line 58
    psiconv_error((psiconv_config )config, lev, off, "Trying byte read past the end of the file");
    }
#line 59
    if (status) {
#line 60
      *status = -3;
    }
#line 61
    return ((psiconv_u8 )0);
  }
#line 63
  if (status) {
#line 64
    *status = 0;
  }
#line 65
  return (*ptr);
}
}
#line 68 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
psiconv_u16 psiconv_read_u16(psiconv_config const   config , psiconv_buffer const   buf ,
                             int lev , psiconv_u32 off , int *status ) 
{ 
  psiconv_u8 *ptr0 ;
  psiconv_u8 *ptr1 ;

  {
  {
#line 72
  ptr0 = psiconv_buffer_get(buf, off);
#line 73
  ptr1 = psiconv_buffer_get(buf, off + 1U);
  }
#line 74
  if (! ptr0) {
#line 74
    goto _L;
  } else
#line 74
  if (! ptr1) {
    _L: /* CIL Label */ 
    {
#line 75
    psiconv_error((psiconv_config )config, lev, off, "Trying word read past the end of the file");
    }
#line 76
    if (status) {
#line 77
      *status = -3;
    }
#line 78
    return ((psiconv_u16 )0);
  }
#line 80
  if (status) {
#line 81
    *status = 0;
  }
#line 82
  return ((psiconv_u16 )((int )*ptr0 + ((int )*ptr1 << 8)));
}
}
#line 85 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
psiconv_u32 psiconv_read_u32(psiconv_config const   config , psiconv_buffer const   buf ,
                             int lev , psiconv_u32 off , int *status ) 
{ 
  psiconv_u8 *ptr0 ;
  psiconv_u8 *ptr1 ;
  psiconv_u8 *ptr2 ;
  psiconv_u8 *ptr3 ;

  {
  {
#line 89
  ptr0 = psiconv_buffer_get(buf, off);
#line 90
  ptr1 = psiconv_buffer_get(buf, off + 1U);
#line 91
  ptr2 = psiconv_buffer_get(buf, off + 2U);
#line 92
  ptr3 = psiconv_buffer_get(buf, off + 3U);
  }
#line 93
  if (! ptr0) {
#line 93
    goto _L;
  } else
#line 93
  if (! ptr1) {
#line 93
    goto _L;
  } else
#line 93
  if (! ptr2) {
#line 93
    goto _L;
  } else
#line 93
  if (! ptr3) {
    _L: /* CIL Label */ 
    {
#line 94
    psiconv_error((psiconv_config )config, lev, off, "Trying long read past the end of the file");
    }
#line 95
    if (status) {
#line 96
      *status = -3;
    }
#line 97
    return ((psiconv_u32 )0);
  }
#line 99
  if (status) {
#line 100
    *status = 0;
  }
#line 101
  return ((psiconv_u32 )((((int )*ptr0 + ((int )*ptr1 << 8)) + ((int )*ptr2 << 16)) + ((int )*ptr3 << 24)));
}
}
#line 104 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
psiconv_s32 psiconv_read_sint(psiconv_config const   config , psiconv_buffer const   buf ,
                              int lev , psiconv_u32 off , int *length , int *status ) 
{ 
  int localstatus ;
  psiconv_u32 temp ;
  int tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 110
  temp = psiconv_read_u32(config, buf, lev, off, & localstatus);
  }
#line 111
  if (status) {
#line 112
    *status = localstatus;
  }
#line 113
  if (length) {
#line 114
    if (localstatus) {
#line 114
      *length = 0;
    } else {
#line 114
      *length = 4;
    }
  }
#line 116
  if (localstatus) {
#line 116
    tmp___0 = 0U;
  } else {
#line 116
    if (temp & 2147483648U) {
#line 116
      tmp = -1;
    } else {
#line 116
      tmp = 1;
    }
#line 116
    tmp___0 = (temp & 2147483647U) * (unsigned int )tmp;
  }
#line 116
  return ((psiconv_s32 )tmp___0);
}
}
#line 119 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
psiconv_u32 psiconv_read_S(psiconv_config const   config , psiconv_buffer const   buf ,
                           int lev , psiconv_u32 off , int *length , int *status ) 
{ 
  psiconv_u8 temp ;
  psiconv_u32 res ;
  int len ;
  int localstatus ;
  psiconv_u8 tmp ;
  psiconv_u16 tmp___0 ;

  {
  {
#line 126
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a S length indicator");
#line 127
  temp = psiconv_read_u8(config, buf, lev + 2, off, & localstatus);
  }
#line 128
  if (localstatus) {
#line 129
    goto ERROR;
  }
#line 130
  if (((int )temp & 3) == 2) {
    {
#line 131
    tmp = psiconv_read_u8(config, buf, lev + 2, off, & localstatus);
#line 131
    res = (psiconv_u32 )((int )tmp >> 2);
    }
#line 132
    if (localstatus) {
#line 133
      goto ERROR;
    }
    {
#line 134
    len = 1;
#line 135
    psiconv_debug((psiconv_config )config, lev + 2, off, "Indicator (1 byte): %02x",
                  res);
    }
  } else
#line 136
  if (((int )temp & 7) == 5) {
    {
#line 137
    tmp___0 = psiconv_read_u16(config, buf, lev + 2, off, & localstatus);
#line 137
    res = (psiconv_u32 )((int )tmp___0 >> 3);
    }
#line 138
    if (localstatus) {
#line 139
      goto ERROR;
    }
    {
#line 140
    len = 2;
#line 141
    psiconv_debug((psiconv_config )config, lev + 2, off, "Indicator (2 bytes): %04x",
                  res);
    }
  } else {
    {
#line 143
    psiconv_error((psiconv_config )config, lev + 2, off, "S indicator: unknown encoding!");
#line 144
    psiconv_debug((psiconv_config )config, lev + 2, off, "Raw data first byte: %02x",
                  (int )temp);
    }
#line 145
    goto ERROR;
  }
#line 148
  if (length) {
#line 149
    *length = len;
  }
#line 150
  if (status) {
#line 151
    *status = 0;
  }
  {
#line 153
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of S length indicator (total length: %08x)", len);
  }
#line 156
  return (res);
  ERROR: 
  {
#line 159
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of S indicator failed");
  }
#line 160
  if (status) {
#line 161
    *status = localstatus;
  }
#line 162
  if (length) {
#line 163
    *length = 0;
  }
#line 164
  return ((psiconv_u32 )0);
}
}
#line 167 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
psiconv_u32 psiconv_read_X(psiconv_config const   config , psiconv_buffer const   buf ,
                           int lev , psiconv_u32 off , int *length , int *status ) 
{ 
  psiconv_u8 temp ;
  psiconv_u32 res ;
  int len ;
  int localstatus ;
  psiconv_u8 tmp ;
  psiconv_u16 tmp___0 ;
  psiconv_u32 tmp___1 ;

  {
  {
#line 174
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a X length indicator");
#line 175
  temp = psiconv_read_u8(config, buf, lev + 2, off, & localstatus);
  }
#line 176
  if (localstatus) {
#line 177
    goto ERROR;
  }
#line 178
  if (((int )temp & 1) == 0) {
    {
#line 179
    tmp = psiconv_read_u8(config, buf, lev + 2, off, & localstatus);
#line 179
    res = (psiconv_u32 )((int )tmp >> 1);
    }
#line 180
    if (localstatus) {
#line 181
      goto ERROR;
    }
    {
#line 182
    len = 1;
#line 183
    psiconv_debug((psiconv_config )config, lev + 2, off, "Indicator (1 byte): %02x",
                  res);
    }
  } else
#line 184
  if (((int )temp & 3) == 1) {
    {
#line 185
    tmp___0 = psiconv_read_u16(config, buf, lev + 2, off, & localstatus);
#line 185
    res = (psiconv_u32 )((int )tmp___0 >> 2);
    }
#line 186
    if (localstatus) {
#line 187
      goto ERROR;
    }
    {
#line 188
    len = 2;
#line 189
    psiconv_debug((psiconv_config )config, lev + 2, off, "Indicator (2 bytes): %04x",
                  res);
    }
  } else
#line 190
  if (((int )temp & 7) == 3) {
    {
#line 191
    tmp___1 = psiconv_read_u32(config, buf, lev + 2, off, & localstatus);
#line 191
    res = tmp___1 >> 3;
    }
#line 192
    if (localstatus) {
#line 193
      goto ERROR;
    }
    {
#line 194
    len = 4;
#line 195
    psiconv_debug((psiconv_config )config, lev + 2, off, "Indicator (4 bytes): %08x",
                  res);
    }
  } else {
    {
#line 197
    psiconv_error((psiconv_config )config, lev + 2, off, "X indicator: unknown encoding!");
#line 198
    psiconv_debug((psiconv_config )config, lev + 2, off, "Raw data first byte: %02x",
                  (int )temp);
    }
#line 199
    goto ERROR;
  }
#line 202
  if (length) {
#line 203
    *length = len;
  }
#line 204
  if (status) {
#line 205
    *status = 0;
  }
  {
#line 207
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of X length indicator (total length: %08x)", len);
  }
#line 210
  return (res);
  ERROR: 
  {
#line 213
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of X indicator failed");
  }
#line 214
  if (status) {
#line 215
    *status = localstatus;
  }
#line 216
  if (length) {
#line 217
    *length = 0;
  }
#line 218
  return ((psiconv_u32 )0);
}
}
#line 221 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
psiconv_length_t psiconv_read_length(psiconv_config const   config , psiconv_buffer const   buf ,
                                     int lev , psiconv_u32 off , int *length , int *status ) 
{ 
  psiconv_length_t res ;
  int localstatus ;
  psiconv_u32 tmp ;

  {
  {
#line 227
  tmp = psiconv_read_u32(config, buf, lev, off, & localstatus);
#line 227
  res = (psiconv_length_t )((2.54 / 1440.0) * (double )((psiconv_s32 )tmp));
  }
#line 229
  if (localstatus) {
    {
#line 230
    psiconv_error((psiconv_config )config, lev + 1, off, "Reading of length failed");
    }
#line 231
    if (length) {
#line 232
      *length = 0;
    }
#line 233
    if (status) {
#line 234
      *status = localstatus;
    }
#line 235
    return ((psiconv_length_t )0);
  }
  {
#line 237
  psiconv_debug((psiconv_config )config, lev + 1, off, "Length: %f", (double )res);
  }
#line 238
  if (length) {
#line 239
    *length = 4;
  }
#line 240
  if (status) {
#line 241
    *status = 0;
  }
#line 242
  return (res);
}
}
#line 245 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
psiconv_size_t psiconv_read_size(psiconv_config const   config , psiconv_buffer const   buf ,
                                 int lev , psiconv_u32 off , int *length , int *status ) 
{ 
  psiconv_size_t res ;
  int localstatus ;
  psiconv_u32 tmp ;

  {
  {
#line 250
  tmp = psiconv_read_u32(config, buf, lev, off, & localstatus);
#line 250
  res = (psiconv_size_t )((double )((psiconv_s32 )tmp) / 20.0);
  }
#line 251
  if (localstatus) {
    {
#line 252
    psiconv_error((psiconv_config )config, lev + 1, off, "Reading of size failed");
    }
#line 253
    if (length) {
#line 254
      *length = 0;
    }
#line 255
    if (status) {
#line 256
      *status = localstatus;
    }
#line 257
    return ((psiconv_size_t )0);
  }
  {
#line 259
  psiconv_debug((psiconv_config )config, lev + 1, off, "Size: %f", (double )res);
  }
#line 260
  if (status) {
#line 261
    *status = 0;
  }
#line 262
  if (length) {
#line 263
    *length = 4;
  }
#line 264
  return (res);
}
}
#line 267 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
int psiconv_parse_bool(psiconv_config const   config , psiconv_buffer const   buf ,
                       int lev , psiconv_u32 off , int *length , psiconv_bool_t *result ) 
{ 
  psiconv_u8 temp ;
  int localstatus ;

  {
  {
#line 272
  temp = psiconv_read_u8(config, buf, lev, off, & localstatus);
  }
#line 273
  if (localstatus) {
    {
#line 274
    psiconv_error((psiconv_config )config, lev + 1, off, "Reading of bool failed");
    }
#line 275
    if (length) {
#line 276
      *length = 0;
    }
#line 277
    return (localstatus);
  }
#line 279
  if (length) {
#line 280
    *length = 1;
  }
#line 281
  if ((int )temp == 0) {
#line 282
    *result = (psiconv_bool_t )0;
#line 283
    return (0);
  } else
#line 284
  if ((int )temp == 1) {
#line 285
    *result = (psiconv_bool_t )1;
#line 286
    return (0);
  }
  {
#line 288
  psiconv_warn((psiconv_config )config, lev + 1, off, "Unknown value for boolean");
#line 289
  psiconv_debug((psiconv_config )config, lev + 1, off, "Boolean value: %02x", (int )temp);
#line 290
  *result = (psiconv_bool_t )1;
  }
#line 291
  return (0);
}
}
#line 294 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
psiconv_string_t psiconv_read_string(psiconv_config const   config , psiconv_buffer const   buf ,
                                     int lev , psiconv_u32 off , int *length , int *status ) 
{ 
  psiconv_string_t tmp ;

  {
  {
#line 298
  tmp = psiconv_read_string_aux(config, buf, lev, off, length, status, -1);
  }
#line 298
  return (tmp);
}
}
#line 301 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
psiconv_string_t psiconv_read_short_string(psiconv_config const   config , psiconv_buffer const   buf ,
                                           int lev , psiconv_u32 off , int *length ,
                                           int *status ) 
{ 
  psiconv_string_t tmp ;

  {
  {
#line 305
  tmp = psiconv_read_string_aux(config, buf, lev, off, length, status, -2);
  }
#line 305
  return (tmp);
}
}
#line 308 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
psiconv_string_t psiconv_read_charlist(psiconv_config const   config , psiconv_buffer const   buf ,
                                       int lev , psiconv_u32 off , int nrofchars ,
                                       int *status ) 
{ 
  int length ;
  psiconv_string_t tmp ;

  {
#line 314
  if (nrofchars <= 0) {
    {
#line 315
    psiconv_error((psiconv_config )config, lev, off, "psiconv_read_charlist called with non-positive nrofchars");
    }
#line 317
    if (status) {
#line 318
      *status = -1;
    }
#line 319
    return ((psiconv_string_t )((void *)0));
  }
  {
#line 321
  tmp = psiconv_read_string_aux(config, buf, lev, off, & length, status, nrofchars);
  }
#line 321
  return (tmp);
}
}
#line 325 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
static psiconv_string_t psiconv_read_string_aux(psiconv_config const   config , psiconv_buffer const   buf ,
                                                int lev , psiconv_u32 off , int *length ,
                                                int *status , int kind ) 
{ 
  int bytecount ;
  int i ;
  int leng ;
  int len ;
  int localstatus ;
  psiconv_string_t result ;
  char *res_copy ;
  psiconv_list string ;
  psiconv_ucs2 nextchar ;
  psiconv_ucs2 *nextcharptr ;
  psiconv_u32 tmp ;
  psiconv_u8 tmp___0 ;
  psiconv_u32 tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  psiconv_u32 tmp___4 ;

  {
  {
#line 337
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a string");
  }
#line 339
  if (kind == -1) {
    {
#line 340
    tmp = psiconv_read_S(config, buf, lev + 2, off, & leng, & localstatus);
#line 340
    bytecount = (int )tmp;
    }
  } else
#line 341
  if (kind == -2) {
    {
#line 342
    tmp___0 = psiconv_read_u8(config, buf, lev + 2, off, & localstatus);
#line 342
    bytecount = (int )tmp___0;
#line 343
    leng = 1;
    }
  } else {
#line 345
    bytecount = kind;
#line 346
    leng = 0;
#line 347
    localstatus = 0;
  }
#line 349
  if (localstatus) {
#line 350
    goto ERROR1;
  }
  {
#line 351
  psiconv_debug((psiconv_config )config, lev + 2, off, "Length: %i", bytecount);
#line 352
  len = leng;
#line 354
  string = psiconv_list_new(sizeof(*result));
  }
#line 354
  if (! string) {
#line 355
    goto ERROR1;
  }
#line 358
  i = 0;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! (i < bytecount)) {
#line 359
      goto while_break;
    }
    {
#line 360
    nextchar = psiconv_unicode_read_char(config, (psiconv_buffer )buf, lev, (off + (psiconv_u32 )i) + (psiconv_u32 )len,
                                         & leng, & localstatus);
    }
#line 362
    if (localstatus) {
#line 363
      goto ERROR2;
    }
    {
#line 364
    localstatus = psiconv_list_add(string, (void const   *)(& nextchar));
    }
#line 364
    if (localstatus) {
#line 365
      goto ERROR2;
    }
#line 366
    i += leng;
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  if (i > bytecount) {
    {
#line 369
    psiconv_error((psiconv_config )config, lev, (off + (psiconv_u32 )i) + (psiconv_u32 )len,
                  "Malformed string");
#line 370
    localstatus = 3;
    }
#line 371
    goto ERROR2;
  }
  {
#line 373
  len += bytecount;
#line 376
  tmp___1 = psiconv_list_length((psiconv_list const   )string);
#line 376
  tmp___2 = malloc(sizeof(*result) * (unsigned long )(tmp___1 + 1U));
#line 376
  result = (psiconv_string_t )tmp___2;
  }
#line 376
  if (! result) {
#line 377
    goto ERROR2;
  }
#line 378
  i = 0;
  {
#line 378
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 378
    tmp___4 = psiconv_list_length((psiconv_list const   )string);
    }
#line 378
    if (! ((psiconv_u32 )i < tmp___4)) {
#line 378
      goto while_break___0;
    }
    {
#line 379
    tmp___3 = psiconv_list_get((psiconv_list const   )string, (psiconv_u32 )i);
#line 379
    nextcharptr = (psiconv_ucs2 *)tmp___3;
    }
#line 379
    if (! nextcharptr) {
      {
#line 380
      psiconv_error((psiconv_config )config, lev, (off + (psiconv_u32 )i) + (psiconv_u32 )len,
                    "Data structure corruption");
      }
#line 381
      goto ERROR3;
    }
#line 383
    *(result + i) = *nextcharptr;
#line 378
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 385
  *(result + i) = (psiconv_ucs2 )0;
#line 387
  res_copy = psiconv_make_printable(config, (psiconv_string_t const   )result);
  }
#line 388
  if (! res_copy) {
#line 389
    goto ERROR3;
  }
  {
#line 390
  psiconv_debug((psiconv_config )config, lev + 2, off, "Contents: `%s\'", res_copy);
#line 391
  free((void *)res_copy);
#line 393
  psiconv_list_free(string);
  }
#line 395
  if (length) {
#line 396
    *length = len;
  }
#line 398
  if (status) {
#line 399
    *status = 0;
  }
  {
#line 401
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of string (total length: %08x)", len);
  }
#line 403
  return (result);
  ERROR3: 
  {
#line 406
  free((void *)result);
  }
  ERROR2: 
  {
#line 408
  psiconv_list_free(string);
  }
  ERROR1: 
  {
#line 410
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of string failed");
  }
#line 411
  if (status) {
#line 412
    *status = localstatus;
  }
#line 413
  if (length) {
#line 414
    *length = 0;
  }
#line 415
  return ((psiconv_string_t )((void *)0));
}
}
#line 418 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
psiconv_float_t psiconv_read_float(psiconv_config const   config , psiconv_buffer const   buf ,
                                   int lev , psiconv_u32 off , int *length , int *status ) 
{ 
  psiconv_float_t result ;
  psiconv_float_t bitvalue ;
  int res ;
  int bit ;
  psiconv_u32 temp ;
  psiconv_u8 tmp ;
  psiconv_u16 tmp___0 ;
  psiconv_float_t tmp___1 ;

  {
  {
#line 423
  temp = (psiconv_u32 )0;
#line 425
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a float");
#line 427
  bitvalue = 0.5;
#line 428
  result = 1.0;
#line 429
  bit = 51;
  }
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 429
    if (! (bit > 0)) {
#line 429
      goto while_break;
    }
#line 430
    if (bit == 51) {
      {
#line 431
      tmp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )(bit >> 3),
                            & res);
#line 431
      temp = (psiconv_u32 )tmp;
      }
    } else
#line 430
    if ((bit & 7) == 7) {
      {
#line 431
      tmp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )(bit >> 3),
                            & res);
#line 431
      temp = (psiconv_u32 )tmp;
      }
    }
#line 432
    if (res) {
#line 433
      goto ERROR;
    }
#line 434
    if (temp & (unsigned int )(1 << (bit & 7))) {
#line 435
      result += bitvalue;
    }
#line 436
    bitvalue /= 2.0;
#line 429
    bit --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 438
  tmp___0 = psiconv_read_u16(config, buf, lev + 2, off + 6U, & res);
#line 438
  temp = (psiconv_u32 )tmp___0;
  }
#line 439
  if (res) {
#line 440
    goto ERROR;
  }
#line 441
  if (temp & 32768U) {
#line 442
    result = - result;
  }
  {
#line 443
  temp = (temp & 32752U) >> 4;
#line 444
  tmp___1 = pow2((int )temp - 1023);
#line 444
  result *= tmp___1;
#line 445
  psiconv_debug((psiconv_config )config, lev + 1, off, "Float value: %f", result);
  }
#line 446
  if (length) {
#line 447
    *length = 8;
  }
#line 448
  if (*status) {
#line 449
    *status = res;
  }
#line 450
  return (result);
  ERROR: 
  {
#line 452
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of float failed");
  }
#line 453
  if (length) {
#line 454
    *length = 0;
  }
#line 455
  if (*status) {
#line 456
    *status = res;
  }
#line 457
  return (0.0);
}
}
#line 34 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_texted.c"
int psiconv_write_texted_section(psiconv_config const   config , psiconv_buffer buf ,
                                 int lev , psiconv_texted_section const   value ,
                                 psiconv_character_layout const   base_char , psiconv_paragraph_layout const   base_para ,
                                 psiconv_buffer *extra_buf ) 
{ 
  int res ;
  int with_layout_section ;
  psiconv_u32 layout_id ;
  psiconv_buffer tmp ;
  psiconv_u32 tmp___0 ;

  {
  {
#line 41
  with_layout_section = 0;
#line 44
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing texted section");
  }
#line 46
  if (! value) {
    {
#line 47
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null TextEd section");
#line 48
    res = -4;
    }
#line 49
    goto ERROR1;
  }
  {
#line 52
  tmp = psiconv_buffer_new();
#line 52
  *extra_buf = tmp;
  }
#line 52
  if (! tmp) {
    {
#line 53
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 54
    res = -2;
    }
#line 55
    goto ERROR1;
  }
  {
#line 58
  layout_id = psiconv_buffer_unique_id();
#line 59
  res = psiconv_buffer_add_target(*extra_buf, (int )layout_id);
  }
#line 59
  if (res) {
    {
#line 60
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 61
    goto ERROR2;
  }
  {
#line 64
  tmp___0 = psiconv_list_length((psiconv_list const   )value->paragraphs);
  }
#line 64
  if (tmp___0) {
    {
#line 65
    with_layout_section = 1;
#line 66
    res = psiconv_write_styleless_layout_section(config, *extra_buf, lev + 1, (psiconv_text_and_layout const   )value->paragraphs,
                                                 base_char, base_para);
    }
#line 66
    if (res) {
#line 69
      goto ERROR2;
    }
  }
  {
#line 72
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )268435548);
  }
#line 72
  if (res) {
#line 73
    goto ERROR2;
  }
  {
#line 76
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )268435555);
  }
#line 76
  if (res) {
#line 77
    goto ERROR2;
  }
  {
#line 78
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )0);
  }
#line 78
  if (res) {
#line 79
    goto ERROR2;
  }
  {
#line 80
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )268435557);
  }
#line 80
  if (res) {
#line 81
    goto ERROR2;
  }
  {
#line 82
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )0);
  }
#line 82
  if (res) {
#line 83
    goto ERROR2;
  }
  {
#line 84
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )268435558);
  }
#line 84
  if (res) {
#line 85
    goto ERROR2;
  }
#line 86
  if (with_layout_section) {
    {
#line 87
    res = psiconv_write_offset(config, buf, lev + 1, (psiconv_u32 const   )layout_id);
    }
#line 87
    if (res) {
#line 88
      goto ERROR2;
    }
  } else {
    {
#line 90
    res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )0);
    }
#line 90
    if (res) {
#line 91
      goto ERROR2;
    }
  }
  {
#line 94
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )268435556);
  }
#line 94
  if (res) {
#line 95
    goto ERROR2;
  }
  {
#line 97
  res = psiconv_write_text_section(config, buf, lev + 1, (psiconv_text_and_layout const   )value->paragraphs);
  }
#line 97
  if (res) {
#line 98
    goto ERROR2;
  }
  {
#line 99
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of texted section");
  }
#line 100
  return (0);
  ERROR2: 
  {
#line 103
  psiconv_buffer_free(*extra_buf);
  }
  ERROR1: 
  {
#line 105
  psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of texted section failed");
  }
#line 106
  return (res);
}
}
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_texted.c"
int psiconv_parse_texted_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                 int lev , psiconv_u32 off , int *length , psiconv_texted_section *result ,
                                 psiconv_character_layout base_char , psiconv_paragraph_layout base_para ) 
{ 
  int res ;
  int len ;
  psiconv_u32 layout_sec ;
  psiconv_u32 unknown_sec ;
  psiconv_u32 replacement_sec ;
  psiconv_u32 temp ;
  int leng ;
  psiconv_texted_section tmp ;
  void *tmp___0 ;
  psiconv_u32 tmp___1 ;
  int tmp___2 ;

  {
  {
#line 39
  res = 0;
#line 40
  len = 0;
#line 41
  layout_sec = (psiconv_u32 )0;
#line 42
  unknown_sec = (psiconv_u32 )0;
#line 43
  replacement_sec = (psiconv_u32 )0;
#line 47
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a texted section");
#line 48
  tmp___0 = malloc(sizeof(*(*result)));
#line 48
  tmp = (psiconv_texted_section )tmp___0;
#line 48
  *result = tmp;
  }
#line 48
  if (! tmp) {
#line 49
    goto ERROR1;
  }
  {
#line 51
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read section id");
#line 52
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 53
  if (res) {
#line 54
    goto ERROR2;
  }
#line 55
  if (temp != 268435548U) {
    {
#line 56
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Page header section body id not found");
#line 58
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Page body id: read %08x, expected %08x",
                  temp, 268435589);
#line 61
    res = -3;
    }
#line 62
    goto ERROR2;
  }
  {
#line 64
  len += 4;
#line 66
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the section jumptable");
  }
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 67
    temp = psiconv_read_u32(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
    }
#line 67
    if (! res) {
#line 67
      if (temp != 268435556U) {
#line 67
        tmp___2 = 1;
      } else {
#line 67
        tmp___2 = 0;
      }
    } else {
#line 67
      tmp___2 = 0;
    }
#line 67
    if (! tmp___2) {
#line 67
      goto while_break;
    }
#line 69
    len += 4;
#line 70
    if (temp == 268435558U) {
      {
#line 71
      layout_sec = psiconv_read_u32(config, buf, lev + 3, off + (psiconv_u32 )len,
                                    & res);
      }
#line 72
      if (res) {
#line 73
        goto ERROR2;
      }
      {
#line 74
      psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Found Layout section at %08x",
                    layout_sec);
      }
    } else
#line 75
    if (temp == 268435555U) {
      {
#line 76
      replacement_sec = psiconv_read_u32(config, buf, lev + 3, off + (psiconv_u32 )len,
                                         & res);
      }
#line 77
      if (res) {
#line 78
        goto ERROR2;
      }
      {
#line 79
      psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Found Replacement section at %08x",
                    replacement_sec);
      }
    } else
#line 81
    if (temp == 268435557U) {
      {
#line 82
      unknown_sec = psiconv_read_u32(config, buf, lev + 3, off + (psiconv_u32 )len,
                                     & res);
      }
#line 83
      if (res) {
#line 84
        goto ERROR2;
      }
#line 85
      if (unknown_sec) {
        {
#line 86
        psiconv_warn((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Unknown section in TextEd jumptable has real offset (ignoring)");
        }
      }
      {
#line 89
      psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Found Unknown section at %08x",
                    unknown_sec);
      }
    } else {
      {
#line 92
      psiconv_warn((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Unknown section in TextEd jumptable (ignoring)");
#line 94
      tmp___1 = psiconv_read_u32(config, buf, lev + 3, off + (psiconv_u32 )len, (int *)((void *)0));
#line 94
      psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Section ID %08x at offset %08x",
                    temp, tmp___1);
      }
    }
#line 97
    len += 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  if (res) {
#line 100
    goto ERROR2;
  }
  {
#line 102
  len += 4;
#line 103
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the text");
#line 104
  res = psiconv_parse_text_section(config, buf, lev + 2, off + (psiconv_u32 )len,
                                   & leng, & (*result)->paragraphs);
  }
#line 104
  if (res) {
#line 106
    goto ERROR2;
  }
#line 107
  len += leng;
#line 109
  if (layout_sec) {
    {
#line 110
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the layout");
#line 111
    res = psiconv_parse_styleless_layout_section(config, buf, lev + 2, layout_sec,
                                                 (int *)((void *)0), (*result)->paragraphs,
                                                 (psiconv_character_layout const   )base_char,
                                                 (psiconv_paragraph_layout const   )base_para);
    }
#line 111
    if (res) {
#line 114
      goto ERROR3;
    }
  }
#line 124
  if (length) {
#line 125
    *length = len;
  }
  {
#line 127
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of TextEd section (total length: %08x", len);
  }
#line 130
  return (0);
  ERROR3: 
  {
#line 133
  psiconv_free_text_and_layout((*result)->paragraphs);
  }
  ERROR2: 
  {
#line 135
  free((void *)*result);
  }
  ERROR1: 
  {
#line 137
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of TextEd Section failed");
  }
#line 138
  if (length) {
#line 139
    *length = 0;
  }
#line 140
  if (! res) {
#line 141
    return (-2);
  } else {
#line 143
    return (res);
  }
}
}
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_word.c"
int psiconv_parse_word_status_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                      int lev , psiconv_u32 off , int *length , psiconv_word_status_section *result ) 
{ 
  int res ;
  int len ;
  psiconv_u32 temp ;
  int leng ;
  psiconv_word_status_section tmp ;
  void *tmp___0 ;
  psiconv_u8 tmp___1 ;
  psiconv_u8 tmp___2 ;
  psiconv_u8 tmp___3 ;
  psiconv_u8 tmp___4 ;

  {
  {
#line 37
  res = 0;
#line 38
  len = 0;
#line 42
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read the word status section");
#line 43
  tmp___0 = malloc(sizeof(*(*result)));
#line 43
  tmp = (psiconv_word_status_section )tmp___0;
#line 43
  *result = tmp;
  }
#line 43
  if (! tmp) {
#line 44
    goto ERROR1;
  }
  {
#line 46
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the initial byte (%02x expected)",
                   2);
#line 48
  tmp___1 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 48
  temp = (psiconv_u32 )tmp___1;
  }
#line 49
  if (res) {
#line 50
    goto ERROR2;
  }
#line 51
  if (temp != 2U) {
    {
#line 52
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Word status section initial byte unknown value (ignored)");
#line 54
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Initial byte: %02x",
                  temp);
    }
  }
  {
#line 56
  len ++;
#line 58
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the first byte of display flags");
#line 60
  tmp___2 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 60
  temp = (psiconv_u32 )tmp___2;
  }
#line 61
  if (res) {
#line 62
    goto ERROR2;
  }
#line 64
  if (temp & 1U) {
#line 64
    (*result)->show_tabs = (psiconv_bool_t )1;
  } else {
#line 64
    (*result)->show_tabs = (psiconv_bool_t )0;
  }
  {
#line 65
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Show tabs: %02x",
                (unsigned int )(*result)->show_tabs);
  }
#line 66
  if (temp & 2U) {
#line 66
    (*result)->show_spaces = (psiconv_bool_t )1;
  } else {
#line 66
    (*result)->show_spaces = (psiconv_bool_t )0;
  }
  {
#line 67
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Show spaces: %02x",
                (unsigned int )(*result)->show_spaces);
  }
#line 68
  if (temp & 4U) {
#line 68
    (*result)->show_paragraph_ends = (psiconv_bool_t )1;
  } else {
#line 68
    (*result)->show_paragraph_ends = (psiconv_bool_t )0;
  }
  {
#line 70
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Show paragraph ends: %02x",
                (unsigned int )(*result)->show_paragraph_ends);
  }
#line 72
  if (temp & 8U) {
#line 72
    (*result)->show_line_breaks = (psiconv_bool_t )1;
  } else {
#line 72
    (*result)->show_line_breaks = (psiconv_bool_t )0;
  }
  {
#line 74
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Show line breaks: %02x",
                (unsigned int )(*result)->show_line_breaks);
  }
#line 76
  if (temp & 32U) {
#line 76
    (*result)->show_hard_minus = (psiconv_bool_t )1;
  } else {
#line 76
    (*result)->show_hard_minus = (psiconv_bool_t )0;
  }
  {
#line 78
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Show hard minus: %02x",
                (unsigned int )(*result)->show_hard_minus);
  }
#line 80
  if (temp & 64U) {
#line 80
    (*result)->show_hard_space = (psiconv_bool_t )1;
  } else {
#line 80
    (*result)->show_hard_space = (psiconv_bool_t )0;
  }
  {
#line 82
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Show hard space: %02x",
                (unsigned int )(*result)->show_hard_space);
  }
#line 84
  if (temp & 144U) {
    {
#line 85
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Word status section first byte of display flags contains unknown flags (ignored)");
#line 87
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unknown flags: %02x",
                  temp & 144U);
    }
  }
  {
#line 89
  len ++;
#line 91
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read second byte of display flags");
#line 92
  tmp___3 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 92
  temp = (psiconv_u32 )tmp___3;
  }
#line 93
  if (res) {
#line 94
    goto ERROR2;
  }
#line 96
  if (temp & 1U) {
#line 96
    (*result)->show_full_pictures = (psiconv_bool_t )1;
  } else {
#line 96
    (*result)->show_full_pictures = (psiconv_bool_t )0;
  }
  {
#line 98
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Show full pictures: %02x",
                (unsigned int )(*result)->show_full_pictures);
  }
#line 100
  if (temp & 2U) {
#line 100
    (*result)->show_full_graphs = (psiconv_bool_t )1;
  } else {
#line 100
    (*result)->show_full_graphs = (psiconv_bool_t )0;
  }
  {
#line 102
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Show full graphs: %02x",
                (unsigned int )(*result)->show_full_graphs);
  }
#line 104
  if (temp & 252U) {
    {
#line 105
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Word status section second byte of display flags contains unknown flags (ignored)");
#line 107
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unknown flags: %02x",
                  temp & 252U);
    }
  }
  {
#line 109
  len ++;
#line 111
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read top toolbar setting");
#line 112
  res = psiconv_parse_bool(config, buf, lev + 2, off + (psiconv_u32 )len, & leng,
                           & (*result)->show_top_toolbar);
  }
#line 112
  if (res) {
#line 114
    goto ERROR2;
  }
  {
#line 115
  len += leng;
#line 117
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read side toolbar setting");
#line 118
  res = psiconv_parse_bool(config, buf, lev + 2, off + (psiconv_u32 )len, & leng,
                           & (*result)->show_side_toolbar);
  }
#line 118
  if (res) {
#line 120
    goto ERROR2;
  }
  {
#line 121
  len += leng;
#line 123
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read operational flags");
#line 124
  tmp___4 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 124
  temp = (psiconv_u32 )tmp___4;
  }
#line 125
  if (res) {
#line 126
    goto ERROR2;
  }
#line 127
  if (temp & 8U) {
#line 127
    (*result)->fit_lines_to_screen = (psiconv_bool_t )1;
  } else {
#line 127
    (*result)->fit_lines_to_screen = (psiconv_bool_t )0;
  }
  {
#line 129
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Fit lines to screen: %02x",
                (unsigned int )(*result)->fit_lines_to_screen);
  }
#line 131
  if (temp & 247U) {
    {
#line 132
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Word status section operational flags contains unknown flags (ignored)");
#line 134
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unknown flags: %02x",
                  temp & 252U);
    }
  }
  {
#line 136
  len ++;
#line 138
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read cursor position");
#line 139
  (*result)->cursor_position = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                & res);
  }
#line 140
  if (res) {
#line 141
    goto ERROR2;
  }
  {
#line 142
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Cursor position: %08x",
                (*result)->cursor_position);
#line 144
  len += 4;
#line 146
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read display size");
#line 147
  (*result)->display_size = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                             & res);
  }
#line 148
  if (res) {
#line 149
    goto ERROR2;
  }
  {
#line 150
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Display size: %08x",
                (*result)->display_size);
#line 152
  len += 4;
  }
#line 154
  if (length) {
#line 155
    *length = len;
  }
  {
#line 157
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of word status section (total length: %08x)",
                   len);
  }
#line 159
  return (0);
  ERROR2: 
  {
#line 162
  free((void *)*result);
  }
  ERROR1: 
  {
#line 164
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Word Status Section failed");
  }
#line 165
  if (length) {
#line 166
    *length = 0;
  }
#line 167
  if (! res) {
#line 168
    return (-2);
  } else {
#line 170
    return (res);
  }
}
}
#line 173 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_word.c"
int psiconv_parse_word_styles_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                      int lev , psiconv_u32 off , int *length , psiconv_word_styles_section *result ) 
{ 
  int res ;
  int len ;
  int leng ;
  int i ;
  int nr ;
  int j ;
  psiconv_word_style style___1 ;
  psiconv_u32 temp ;
  psiconv_word_styles_section tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  psiconv_paragraph_layout tmp___2 ;
  psiconv_character_layout tmp___3 ;
  psiconv_word_style_list tmp___4 ;
  void *tmp___5 ;
  psiconv_u8 tmp___6 ;
  psiconv_u8 tmp___7 ;
  psiconv_u32 tmp___8 ;
  psiconv_u32 tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  psiconv_u32 tmp___12 ;
  void *tmp___13 ;
  psiconv_character_layout tmp___14 ;
  psiconv_paragraph_layout tmp___15 ;
  psiconv_u8 tmp___16 ;
  psiconv_u32 tmp___17 ;
  void *tmp___18 ;

  {
  {
#line 178
  res = 0;
#line 179
  len = 0;
#line 184
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read the word styles section");
#line 185
  tmp___0 = malloc(sizeof(*(*result)));
#line 185
  tmp = (psiconv_word_styles_section )tmp___0;
#line 185
  *result = tmp;
  }
#line 185
  if (! tmp) {
#line 186
    goto ERROR1;
  }
  {
#line 188
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read style normal");
#line 189
  tmp___1 = malloc(sizeof(*style___1));
#line 189
  style___1 = (psiconv_word_style )tmp___1;
  }
#line 189
  if (! style___1) {
#line 190
    goto ERROR2;
  }
  {
#line 191
  style___1->name = (psiconv_string_t )((void *)0);
#line 192
  tmp___2 = psiconv_basic_paragraph_layout();
#line 192
  style___1->paragraph = tmp___2;
  }
#line 192
  if (! tmp___2) {
#line 193
    goto ERROR2_1;
  }
  {
#line 194
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the paragraph codes");
#line 195
  res = psiconv_parse_paragraph_layout_list(config, buf, lev + 3, off + (psiconv_u32 )len,
                                            & leng, style___1->paragraph);
  }
#line 195
  if (res) {
#line 197
    goto ERROR2_2;
  }
  {
#line 198
  len += leng;
#line 199
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the character codes");
#line 200
  tmp___3 = psiconv_basic_character_layout();
#line 200
  style___1->character = tmp___3;
  }
#line 200
  if (! tmp___3) {
#line 201
    goto ERROR2_2;
  }
  {
#line 202
  res = psiconv_parse_character_layout_list(config, buf, lev + 3, off + (psiconv_u32 )len,
                                            & leng, style___1->character);
  }
#line 202
  if (res) {
#line 204
    goto ERROR2_3;
  }
  {
#line 205
  len += leng;
#line 207
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the hotkey");
#line 208
  style___1->hotkey = psiconv_unicode_read_char(config, (psiconv_buffer )buf, lev + 3,
                                                off + (psiconv_u32 )len, (int *)((void *)0),
                                                & res);
#line 209
  psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Normal Hotkey value %08x",
                (int )style___1->hotkey);
  }
#line 210
  if (res) {
#line 211
    goto ERROR2_3;
  }
  {
#line 212
  len += 4;
#line 213
  (*result)->normal = style___1;
#line 215
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read hotkeys list");
#line 216
  tmp___4 = psiconv_list_new(sizeof(*style___1));
#line 216
  (*result)->styles = tmp___4;
  }
#line 216
  if (! tmp___4) {
#line 217
    goto ERROR3;
  }
  {
#line 218
  tmp___5 = malloc(sizeof(*style___1));
#line 218
  style___1 = (psiconv_word_style )tmp___5;
  }
#line 218
  if (! style___1) {
#line 219
    goto ERROR3_1;
  }
  {
#line 222
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the number of entries");
#line 223
  tmp___6 = psiconv_read_u8(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
#line 223
  nr = (int )tmp___6;
  }
#line 224
  if (res) {
#line 225
    goto ERROR3_2;
  }
  {
#line 226
  len ++;
#line 227
  psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Nummer of hotkeys: %02x",
                nr);
#line 228
  i = 0;
  }
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! (i < nr)) {
#line 228
      goto while_break;
    }
    {
#line 230
    style___1->hotkey = psiconv_unicode_read_char(config, (psiconv_buffer )buf, lev + 3,
                                                  off + (psiconv_u32 )len, (int *)((void *)0),
                                                  & res);
#line 232
    psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Hotkey %d value %08x",
                  i, (int )style___1->hotkey);
#line 233
    len += 4;
#line 234
    res = psiconv_list_add((*result)->styles, (void const   *)style___1);
    }
#line 234
    if (res) {
#line 235
      goto ERROR3_2;
    }
#line 228
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  free((void *)style___1);
#line 239
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read all other styles");
#line 240
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the number of styles");
#line 241
  tmp___7 = psiconv_read_u8(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
#line 241
  nr = (int )tmp___7;
  }
#line 242
  if (res) {
#line 243
    goto ERROR4;
  }
  {
#line 244
  tmp___9 = psiconv_list_length((psiconv_list const   )(*result)->styles);
  }
#line 244
  if ((psiconv_u32 )nr != tmp___9) {
    {
#line 245
    psiconv_warn((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Number of styles and hotkeys do not match");
#line 246
    tmp___8 = psiconv_list_length((psiconv_list const   )(*result)->styles);
#line 246
    psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "%d hotkeys, %d styles",
                  tmp___8, nr);
    }
  }
#line 249
  len ++;
#line 251
  i = 0;
  {
#line 251
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 251
    if (! (i < nr)) {
#line 251
      goto while_break___0;
    }
    {
#line 252
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Next style: %d",
                     i);
#line 253
    tmp___12 = psiconv_list_length((psiconv_list const   )(*result)->styles);
    }
#line 253
    if ((psiconv_u32 )i >= tmp___12) {
      {
#line 254
      tmp___10 = malloc(sizeof(*style___1));
#line 254
      style___1 = (psiconv_word_style )tmp___10;
      }
#line 254
      if (! style___1) {
#line 255
        goto ERROR5;
      }
      {
#line 256
      style___1->hotkey = (psiconv_ucs2 )0;
#line 257
      tmp___11 = psiconv_list_add((*result)->styles, (void const   *)style___1);
      }
#line 257
      if (tmp___11) {
        {
#line 258
        free((void *)style___1);
        }
#line 259
        goto ERROR5;
      }
      {
#line 261
      psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "New entry added in list");
#line 262
      free((void *)style___1);
      }
    }
    {
#line 264
    tmp___13 = psiconv_list_get((psiconv_list const   )(*result)->styles, (psiconv_u32 )i);
#line 264
    style___1 = (psiconv_word_style )tmp___13;
    }
#line 264
    if (! style___1) {
#line 265
      goto ERROR5;
    }
    {
#line 266
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the style name");
#line 267
    style___1->name = psiconv_read_string(config, buf, lev + 3, off + (psiconv_u32 )len,
                                          & leng, & res);
    }
#line 268
    if (res) {
#line 269
      goto ERROR5;
    }
    {
#line 270
    len += leng;
#line 271
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read whether this style is built-in");
#line 273
    temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
    }
#line 274
    if (res) {
#line 275
      goto ERROR6;
    }
#line 277
    if (temp == 268435532U) {
      {
#line 278
      style___1->built_in = (psiconv_bool_t )1;
#line 279
      psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Built-in style");
      }
    } else
#line 280
    if (temp == 268435535U) {
      {
#line 281
      style___1->built_in = (psiconv_bool_t )0;
#line 282
      psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Removable style");
      }
    } else {
      {
#line 284
      psiconv_warn((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Word styles section unknown style id (treated as built-in)");
#line 286
      psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Unknown id: %08x",
                    temp);
#line 287
      style___1->built_in = (psiconv_bool_t )0;
      }
    }
    {
#line 289
    len += 4;
#line 290
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read outline level");
#line 291
    style___1->outline_level = psiconv_read_u32(config, buf, lev + 3, off + (psiconv_u32 )len,
                                                & res);
    }
#line 292
    if (res) {
#line 293
      goto ERROR6;
    }
    {
#line 294
    psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Outline Level: %08x",
                  style___1->outline_level);
#line 295
    len += 4;
#line 296
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the character codes");
#line 297
    tmp___14 = psiconv_clone_character_layout(((*result)->normal)->character);
#line 297
    style___1->character = tmp___14;
    }
#line 297
    if (! tmp___14) {
#line 298
      goto ERROR6;
    }
    {
#line 299
    res = psiconv_parse_character_layout_list(config, buf, lev + 3, off + (psiconv_u32 )len,
                                              & leng, style___1->character);
    }
#line 299
    if (res) {
#line 301
      goto ERROR7;
    }
    {
#line 302
    len += leng;
#line 303
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the paragraph codes");
#line 304
    tmp___15 = psiconv_clone_paragraph_layout(((*result)->normal)->paragraph);
#line 304
    style___1->paragraph = tmp___15;
    }
#line 304
    if (! tmp___15) {
#line 305
      goto ERROR7;
    }
    {
#line 306
    res = psiconv_parse_paragraph_layout_list(config, buf, lev + 3, off + (psiconv_u32 )len,
                                              & leng, style___1->paragraph);
    }
#line 306
    if (res) {
#line 308
      goto ERROR8;
    }
#line 309
    len += leng;
#line 251
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 312
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Reading trailing bytes");
#line 313
  i = 0;
  }
  {
#line 313
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 313
    tmp___17 = psiconv_list_length((psiconv_list const   )(*result)->styles);
    }
#line 313
    if (! ((psiconv_u32 )i < tmp___17)) {
#line 313
      goto while_break___1;
    }
    {
#line 314
    tmp___16 = psiconv_read_u8(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
#line 314
    temp = (psiconv_u32 )tmp___16;
    }
#line 315
    if (res) {
#line 316
      goto ERROR4;
    }
#line 317
    if (temp != 255U) {
      {
#line 318
      psiconv_warn((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Unknown trailing style byte");
#line 319
      psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Trailing byte: %02x expected, read %02x",
                    255, temp);
      }
    } else {
      {
#line 322
      psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Read trailing byte 0xff");
      }
    }
#line 323
    len ++;
#line 313
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 326
  if (length) {
#line 327
    *length = len;
  }
  {
#line 329
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of word styles section (total length: %08x)",
                   len);
  }
#line 332
  return (res);
  ERROR3_2: 
  {
#line 336
  free((void *)style___1);
  }
  ERROR3_1: 
  {
#line 338
  psiconv_list_free((*result)->styles);
  }
#line 339
  goto ERROR3;
  ERROR2_3: 
  {
#line 342
  psiconv_free_character_layout(style___1->character);
  }
  ERROR2_2: 
  {
#line 344
  psiconv_free_paragraph_layout(style___1->paragraph);
  }
  ERROR2_1: 
  {
#line 346
  free((void *)style___1);
  }
#line 347
  goto ERROR2;
  ERROR8: 
  {
#line 350
  psiconv_free_paragraph_layout(style___1->paragraph);
  }
  ERROR7: 
  {
#line 352
  psiconv_free_character_layout(style___1->character);
  }
  ERROR6: 
  {
#line 354
  free((void *)style___1->name);
  }
  ERROR5: 
#line 356
  j = 0;
  {
#line 356
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 356
    if (! (j < i)) {
#line 356
      goto while_break___2;
    }
    {
#line 357
    tmp___18 = psiconv_list_get((psiconv_list const   )(*result)->styles, (psiconv_u32 )j);
#line 357
    style___1 = (psiconv_word_style )tmp___18;
    }
#line 357
    if (! style___1) {
      {
#line 358
      psiconv_error((psiconv_config )config, lev + 1, off, "Data structure corruption");
      }
#line 359
      goto ERROR4;
    }
    {
#line 361
    psiconv_free_character_layout(style___1->character);
#line 362
    psiconv_free_paragraph_layout(style___1->paragraph);
#line 363
    free((void *)style___1->name);
#line 356
    j ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  ERROR4: 
  {
#line 366
  psiconv_list_free((*result)->styles);
  }
  ERROR3: 
  {
#line 368
  psiconv_free_word_style((*result)->normal);
  }
  ERROR2: 
  {
#line 370
  free((void *)*result);
  }
  ERROR1: 
  {
#line 372
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Word Status Section failed");
  }
#line 373
  if (length) {
#line 374
    *length = 0;
  }
#line 375
  if (! res) {
#line 376
    return (-2);
  } else {
#line 378
    return (res);
  }
}
}
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/misc.c"
char *psiconv_make_printable(psiconv_config const   config , psiconv_string_t const   input ) 
{ 
  int i ;
  char *output ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 39
  tmp = psiconv_unicode_strlen((psiconv_ucs2 const   *)input);
#line 39
  tmp___0 = malloc(sizeof(*output) * (unsigned long )(tmp + 1));
#line 39
  output = (char *)tmp___0;
  }
#line 39
  if (! output) {
#line 41
    return ((char *)((void *)0));
  }
#line 44
  i = 0;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 44
    tmp___1 = psiconv_unicode_strlen((psiconv_ucs2 const   *)input);
    }
#line 44
    if (! (i < tmp___1)) {
#line 44
      goto while_break;
    }
#line 45
    if ((int )*(input + i) < 32) {
#line 46
      *(output + i) = (char )'.';
    } else
#line 45
    if ((int )*(input + i) >= 127) {
#line 46
      *(output + i) = (char )'.';
    } else {
#line 48
      *(output + i) = (char )*(input + i);
    }
#line 44
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 49
  *(output + i) = (char)0;
#line 50
  return (output);
}
}
#line 94 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_routines.h"
int psiconv_parse_color(psiconv_config const   config , psiconv_buffer const   buf ,
                        int lev , psiconv_u32 off , int *length , psiconv_color *result ) ;
#line 99
int psiconv_parse_font(psiconv_config const   config , psiconv_buffer const   buf ,
                       int lev , psiconv_u32 off , int *length , psiconv_font *result ) ;
#line 104
int psiconv_parse_border(psiconv_config const   config , psiconv_buffer const   buf ,
                         int lev , psiconv_u32 off , int *length , psiconv_border *result ) ;
#line 109
int psiconv_parse_bullet(psiconv_config const   config , psiconv_buffer const   buf ,
                         int lev , psiconv_u32 off , int *length , psiconv_bullet *result ) ;
#line 114
int psiconv_parse_tab(psiconv_config const   config , psiconv_buffer const   buf ,
                      int lev , psiconv_u32 off , int *length , psiconv_tab *result ) ;
#line 34 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_layout.c"
int psiconv_parse_color(psiconv_config const   config , psiconv_buffer const   buf ,
                        int lev , psiconv_u32 off , int *length , psiconv_color *result ) 
{ 
  int res ;
  int len ;
  psiconv_color tmp ;
  void *tmp___0 ;

  {
  {
#line 38
  res = 0;
#line 39
  len = 0;
#line 41
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to parse color");
#line 42
  tmp___0 = malloc(sizeof(*(*result)));
#line 42
  tmp = (psiconv_color )tmp___0;
#line 42
  *result = tmp;
  }
#line 42
  if (! tmp) {
#line 43
    goto ERROR1;
  }
  {
#line 45
  (*result)->red = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len,
                                   & res);
  }
#line 46
  if (res) {
#line 47
    goto ERROR2;
  }
  {
#line 48
  (*result)->green = psiconv_read_u8(config, buf, lev + 2, (off + (psiconv_u32 )len) + 1U,
                                     & res);
  }
#line 49
  if (res) {
#line 50
    goto ERROR2;
  }
  {
#line 51
  (*result)->blue = psiconv_read_u8(config, buf, lev + 2, (off + (psiconv_u32 )len) + 2U,
                                    & res);
  }
#line 52
  if (res) {
#line 53
    goto ERROR2;
  }
  {
#line 54
  len += 3;
#line 56
  psiconv_debug((psiconv_config )config, lev + 2, off, "Color: red %02x, green %02x, blue %02x",
                (int )(*result)->red, (int )(*result)->green, (int )(*result)->blue);
  }
#line 58
  if (length) {
#line 59
    *length = len;
  }
  {
#line 61
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of color (total length: %08x)", len);
  }
#line 62
  return (0);
  ERROR2: 
  {
#line 65
  free((void *)*result);
  }
  ERROR1: 
  {
#line 67
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Color failed");
  }
#line 68
  if (length) {
#line 69
    *length = 0;
  }
#line 70
  if (res == 0) {
#line 71
    return (-2);
  } else {
#line 73
    return (res);
  }
}
}
#line 78 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_layout.c"
int psiconv_parse_font(psiconv_config const   config , psiconv_buffer const   buf ,
                       int lev , psiconv_u32 off , int *length , psiconv_font *result ) 
{ 
  int res ;
  char *str_copy ;
  int len ;
  int fontlen ;
  psiconv_font tmp ;
  void *tmp___0 ;
  psiconv_u8 tmp___1 ;
  psiconv_u8 tmp___2 ;

  {
  {
#line 82
  res = 0;
#line 84
  len = 0;
#line 87
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to parse font");
#line 88
  tmp___0 = malloc(sizeof(*(*result)));
#line 88
  tmp = (psiconv_font )tmp___0;
#line 88
  *result = tmp;
  }
#line 88
  if (! tmp) {
#line 89
    goto ERROR1;
  }
  {
#line 91
  tmp___1 = psiconv_read_u8(config, buf, lev + 2, off, & res);
#line 91
  fontlen = (int )tmp___1;
  }
#line 92
  if (res) {
#line 93
    goto ERROR2;
  }
  {
#line 94
  len = 1;
#line 96
  (*result)->name = psiconv_read_charlist(config, buf, lev + 2, off + (psiconv_u32 )len,
                                          fontlen - 1, & res);
  }
#line 97
  if (res) {
#line 98
    goto ERROR2;
  }
  {
#line 99
  len += fontlen - 1;
#line 101
  tmp___2 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 101
  (*result)->screenfont = (psiconv_screenfont_t )tmp___2;
  }
#line 102
  if (res) {
#line 103
    goto ERROR3;
  }
  {
#line 105
  str_copy = psiconv_make_printable(config, (psiconv_string_t const   )(*result)->name);
  }
#line 105
  if (! str_copy) {
#line 106
    goto ERROR3;
  }
  {
#line 108
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Found font `%s\', displayed with screen font %02x",
                str_copy, (unsigned int )(*result)->screenfont);
#line 111
  free((void *)str_copy);
#line 112
  len ++;
  }
#line 114
  if (length) {
#line 115
    *length = len;
  }
  {
#line 117
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of font (total length: %08x)", len);
  }
#line 119
  return (0);
  ERROR3: 
  {
#line 122
  free((void *)(*result)->name);
  }
  ERROR2: 
  {
#line 124
  free((void *)*result);
  }
  ERROR1: 
  {
#line 126
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Font failed");
  }
#line 127
  if (length) {
#line 128
    *length = 0;
  }
#line 129
  if (! res) {
#line 130
    return (-2);
  } else {
#line 132
    return (res);
  }
}
}
#line 135 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_layout.c"
int psiconv_parse_border(psiconv_config const   config , psiconv_buffer const   buf ,
                         int lev , psiconv_u32 off , int *length , psiconv_border *result ) 
{ 
  int res ;
  int len ;
  psiconv_u32 temp ;
  int leng ;
  psiconv_border tmp ;
  void *tmp___0 ;
  psiconv_u8 tmp___1 ;
  int tmp___2 ;
  psiconv_u8 tmp___3 ;

  {
  {
#line 139
  res = 0;
#line 140
  len = 0;
#line 144
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to parse border data");
#line 145
  tmp___0 = malloc(sizeof(*(*result)));
#line 145
  tmp = (psiconv_border )tmp___0;
#line 145
  *result = tmp;
  }
#line 145
  if (! tmp) {
#line 146
    goto ERROR1;
  }
  {
#line 149
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read border kind");
#line 150
  tmp___1 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 150
  temp = (psiconv_u32 )tmp___1;
  }
#line 151
  if (res) {
#line 152
    goto ERROR2;
  }
#line 153
  if (temp == 0U) {
#line 154
    (*result)->kind = (psiconv_border_kind_t )0;
  } else
#line 155
  if (temp == 1U) {
#line 156
    (*result)->kind = (psiconv_border_kind_t )1;
  } else
#line 157
  if (temp == 2U) {
#line 158
    (*result)->kind = (psiconv_border_kind_t )2;
  } else
#line 159
  if (temp == 3U) {
#line 160
    (*result)->kind = (psiconv_border_kind_t )3;
  } else
#line 161
  if (temp == 4U) {
#line 162
    (*result)->kind = (psiconv_border_kind_t )4;
  } else
#line 163
  if (temp == 5U) {
#line 164
    (*result)->kind = (psiconv_border_kind_t )5;
  } else
#line 165
  if (temp == 6U) {
#line 166
    (*result)->kind = (psiconv_border_kind_t )6;
  } else {
    {
#line 168
    psiconv_warn((psiconv_config )config, lev + 2, off, "Unknown border kind (defaults to `none\')");
#line 169
    (*result)->kind = (psiconv_border_kind_t )0;
    }
  }
  {
#line 171
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Kind: %02x",
                temp);
#line 172
  len ++;
#line 174
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read border thickness");
#line 175
  (*result)->thickness = psiconv_read_size(config, buf, lev + 2, off + (psiconv_u32 )len,
                                           & leng, & res);
  }
#line 176
  if (res) {
#line 177
    goto ERROR2;
  }
  {
#line 188
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Thickness: %f",
                (double )(*result)->thickness);
#line 189
  len += leng;
#line 191
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the border color");
#line 192
  tmp___2 = psiconv_parse_color(config, buf, lev + 2, off + (psiconv_u32 )len, & leng,
                                & (*result)->color);
  }
#line 192
  if (tmp___2) {
#line 193
    goto ERROR2;
  }
  {
#line 194
  len += leng;
#line 196
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the final unknown byte (0x00 or 0x01 expected)");
#line 198
  tmp___3 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 198
  temp = (psiconv_u32 )tmp___3;
  }
#line 199
  if (res) {
#line 200
    goto ERROR3;
  }
#line 201
  if (temp != 1U) {
#line 201
    if (temp != 0U) {
      {
#line 202
      psiconv_warn((psiconv_config )config, lev + 2, off, "Unknown last byte in border specification");
#line 203
      psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Last byte: read %02x, expected %02x or %02x",
                    temp, 0, 1);
      }
    }
  }
#line 206
  len ++;
#line 208
  if (length) {
#line 209
    *length = len;
  }
  {
#line 211
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of border (total length: %08x)", len);
  }
#line 214
  return (0);
  ERROR3: 
  {
#line 217
  psiconv_free_color((*result)->color);
  }
  ERROR2: 
  {
#line 219
  free((void *)result);
  }
  ERROR1: 
  {
#line 221
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Border failed");
  }
#line 222
  if (length) {
#line 223
    *length = 0;
  }
#line 224
  if (! res) {
#line 225
    return (-2);
  } else {
#line 227
    return (res);
  }
}
}
#line 230 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_layout.c"
int psiconv_parse_bullet(psiconv_config const   config , psiconv_buffer const   buf ,
                         int lev , psiconv_u32 off , int *length , psiconv_bullet *result ) 
{ 
  int res ;
  int len ;
  int leng ;
  int bullet_length ;
  psiconv_bullet tmp ;
  void *tmp___0 ;
  psiconv_u8 tmp___1 ;

  {
  {
#line 234
  res = 0;
#line 235
  len = 0;
#line 239
  tmp___0 = malloc(sizeof(*(*result)));
#line 239
  tmp = (psiconv_bullet )tmp___0;
#line 239
  *result = tmp;
  }
#line 239
  if (! tmp) {
#line 240
    goto ERROR1;
  }
  {
#line 241
  (*result)->on = (psiconv_bool_t )1;
#line 243
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to parse bullet data");
#line 244
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read bullet length");
#line 245
  tmp___1 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 245
  bullet_length = (int )tmp___1;
  }
#line 246
  if (res) {
#line 247
    goto ERROR2;
  }
  {
#line 248
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Length: %02x",
                bullet_length);
#line 249
  len ++;
#line 251
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read bullet font size");
#line 252
  (*result)->font_size = psiconv_read_size(config, buf, lev + 2, off + (psiconv_u32 )len,
                                           & leng, & res);
  }
#line 253
  if (res) {
#line 254
    goto ERROR2;
  }
  {
#line 255
  len += leng;
#line 257
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read bullet character");
#line 258
  (*result)->character = psiconv_unicode_read_char(config, (psiconv_buffer )buf, lev + 2,
                                                   off + (psiconv_u32 )len, & leng,
                                                   & res);
  }
#line 260
  if (res) {
#line 261
    goto ERROR2;
  }
  {
#line 262
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Character: %02x",
                (int )(*result)->character);
#line 263
  len += leng;
#line 265
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read indent on/off");
#line 266
  res = psiconv_parse_bool(config, buf, lev + 2, off + (psiconv_u32 )len, & leng,
                           & (*result)->indent);
  }
#line 266
  if (res) {
#line 267
    goto ERROR2;
  }
  {
#line 268
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Indent on: %02x",
                (unsigned int )(*result)->indent);
#line 269
  len += leng;
#line 271
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read bullet color");
#line 272
  res = psiconv_parse_color(config, buf, lev + 2, off + (psiconv_u32 )len, & leng,
                            & (*result)->color);
  }
#line 272
  if (res) {
#line 273
    goto ERROR2;
  }
  {
#line 274
  len += leng;
#line 276
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read bullet font");
#line 277
  res = psiconv_parse_font(config, buf, lev + 2, off + (psiconv_u32 )len, & leng,
                           & (*result)->font);
  }
#line 277
  if (res) {
#line 278
    goto ERROR3;
  }
#line 279
  len += leng;
#line 281
  if (len != bullet_length + 1) {
    {
#line 282
    psiconv_warn((psiconv_config )config, lev + 2, off, "Bullet data structure length mismatch");
#line 283
    psiconv_debug((psiconv_config )config, lev + 2, off, "Length: specified %02x, found %02x",
                  bullet_length, len - 1);
    }
  }
  {
#line 287
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of bullet data (total length: %08x)", len);
  }
#line 290
  if (length) {
#line 291
    *length = len;
  }
#line 292
  return (0);
  ERROR3: 
  {
#line 295
  psiconv_free_color((*result)->color);
  }
  ERROR2: 
  {
#line 297
  free((void *)result);
  }
  ERROR1: 
  {
#line 299
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Bullet failed");
  }
#line 300
  if (length) {
#line 301
    *length = 0;
  }
#line 302
  if (! res) {
#line 303
    return (-2);
  } else {
#line 305
    return (res);
  }
}
}
#line 308 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_layout.c"
int psiconv_parse_tab(psiconv_config const   config , psiconv_buffer const   buf ,
                      int lev , psiconv_u32 off , int *length , psiconv_tab *result ) 
{ 
  int res ;
  int len ;
  int leng ;
  psiconv_u8 temp ;
  psiconv_tab tmp ;
  void *tmp___0 ;

  {
  {
#line 312
  res = 0;
#line 313
  len = 0;
#line 317
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to parse tab");
#line 318
  tmp___0 = malloc(sizeof(*(*result)));
#line 318
  tmp = (psiconv_tab )tmp___0;
#line 318
  *result = tmp;
  }
#line 318
  if (! tmp) {
#line 319
    goto ERROR1;
  }
  {
#line 321
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read tab location");
#line 322
  (*result)->location = psiconv_read_length(config, buf, lev + 2, off + (psiconv_u32 )len,
                                            & leng, & res);
  }
#line 323
  if (res) {
#line 324
    goto ERROR2;
  }
  {
#line 325
  len += leng;
#line 327
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the tab kind");
#line 328
  temp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 329
  if (res) {
#line 330
    goto ERROR2;
  }
#line 331
  if ((int )temp == 1) {
#line 332
    (*result)->kind = (psiconv_tab_kind_t )0;
  } else
#line 333
  if ((int )temp == 2) {
#line 334
    (*result)->kind = (psiconv_tab_kind_t )1;
  } else
#line 335
  if ((int )temp == 3) {
#line 336
    (*result)->kind = (psiconv_tab_kind_t )2;
  } else {
    {
#line 338
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unknown tab kind argument");
#line 339
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Kind found: %02x (defaulted to left tab)",
                  (int )temp);
#line 341
    (*result)->kind = (psiconv_tab_kind_t )0;
    }
  }
  {
#line 343
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Kind: %02x",
                (int )temp);
#line 344
  len ++;
  }
#line 346
  if (length) {
#line 347
    *length = len;
  }
  {
#line 349
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of tab (total length: %08x)", len);
  }
#line 350
  return (0);
  ERROR2: 
  {
#line 353
  free((void *)result);
  }
  ERROR1: 
  {
#line 355
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Tab failed");
  }
#line 356
  if (length) {
#line 357
    *length = 0;
  }
#line 358
  if (! res) {
#line 359
    return (-2);
  } else {
#line 361
    return (res);
  }
}
}
#line 364 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_layout.c"
int psiconv_parse_paragraph_layout_list(psiconv_config const   config , psiconv_buffer const   buf ,
                                        int lev , psiconv_u32 off , int *length ,
                                        psiconv_paragraph_layout result ) 
{ 
  int res ;
  int len ;
  int list_length ;
  int leng ;
  int nr ;
  psiconv_u8 id ;
  psiconv_u32 temp ;
  psiconv_tab temp_tab ;
  psiconv_color temp_color ;
  psiconv_border temp_border ;
  psiconv_bullet temp_bullet ;
  psiconv_u32 tmp ;
  psiconv_u8 tmp___0 ;
  psiconv_u8 tmp___1 ;

  {
  {
#line 369
  res = 0;
#line 370
  len = 0;
#line 379
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read paragraph layout list");
#line 381
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the list length");
#line 382
  tmp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 382
  list_length = (int )tmp;
  }
#line 383
  if (res) {
#line 384
    goto ERROR1;
  }
  {
#line 385
  psiconv_debug((psiconv_config )config, lev + 2, off, "Length in bytes: %08x", list_length);
#line 386
  len += 4;
#line 388
  nr = 0;
  }
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if (! (len - 4 < list_length)) {
#line 389
      goto while_break;
    }
    {
#line 390
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read element %d",
                     nr);
#line 391
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the element id");
#line 392
    id = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
    }
#line 393
    if (res) {
#line 394
      goto ERROR1;
    }
    {
#line 395
    psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Id: %02x",
                  (int )id);
#line 396
    len ++;
    }
    {
#line 398
    if ((int )id == 1) {
#line 398
      goto case_1;
    }
#line 406
    if ((int )id == 2) {
#line 406
      goto case_2;
    }
#line 413
    if ((int )id == 3) {
#line 413
      goto case_3;
    }
#line 421
    if ((int )id == 4) {
#line 421
      goto case_4;
    }
#line 429
    if ((int )id == 5) {
#line 429
      goto case_5;
    }
#line 450
    if ((int )id == 6) {
#line 450
      goto case_6;
    }
#line 469
    if ((int )id == 7) {
#line 469
      goto case_7;
    }
#line 476
    if ((int )id == 8) {
#line 476
      goto case_8;
    }
#line 483
    if ((int )id == 9) {
#line 483
      goto case_9;
    }
#line 490
    if ((int )id == 10) {
#line 490
      goto case_10;
    }
#line 497
    if ((int )id == 11) {
#line 497
      goto case_11;
    }
#line 504
    if ((int )id == 12) {
#line 504
      goto case_12;
    }
#line 511
    if ((int )id == 13) {
#line 511
      goto case_13;
    }
#line 518
    if ((int )id == 14) {
#line 518
      goto case_14;
    }
#line 525
    if ((int )id == 15) {
#line 525
      goto case_15;
    }
#line 532
    if ((int )id == 16) {
#line 532
      goto case_16;
    }
#line 540
    if ((int )id == 17) {
#line 540
      goto case_17;
    }
#line 548
    if ((int )id == 18) {
#line 548
      goto case_18;
    }
#line 556
    if ((int )id == 19) {
#line 556
      goto case_19;
    }
#line 564
    if ((int )id == 20) {
#line 564
      goto case_20;
    }
#line 572
    if ((int )id == 21) {
#line 572
      goto case_21;
    }
#line 580
    if ((int )id == 22) {
#line 580
      goto case_22;
    }
#line 588
    if ((int )id == 23) {
#line 588
      goto case_23;
    }
#line 599
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 399
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read background color");
#line 400
    res = psiconv_parse_color(config, buf, lev + 3, off + (psiconv_u32 )len, & leng,
                              & temp_color);
    }
#line 400
    if (res) {
#line 401
      goto ERROR1;
    }
    {
#line 402
    psiconv_free_color(result->back_color);
#line 403
    result->back_color = temp_color;
#line 404
    len += leng;
    }
#line 405
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 407
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read indent left");
#line 408
    result->indent_left = psiconv_read_length(config, buf, lev + 3, off + (psiconv_u32 )len,
                                              & leng, & res);
    }
#line 409
    if (res) {
#line 410
      goto ERROR1;
    }
#line 411
    len += leng;
#line 412
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 414
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read indent right");
#line 415
    result->indent_right = psiconv_read_length(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & leng, & res);
    }
#line 417
    if (res) {
#line 418
      goto ERROR1;
    }
#line 419
    len += leng;
#line 420
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 422
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read indent left first line");
#line 423
    result->indent_first = psiconv_read_length(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & leng, & res);
    }
#line 425
    if (res) {
#line 426
      goto ERROR1;
    }
#line 427
    len += leng;
#line 428
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 430
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read horizontal justify");
#line 431
    tmp___0 = psiconv_read_u8(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
#line 431
    temp = (psiconv_u32 )tmp___0;
    }
#line 432
    if (res) {
#line 433
      goto ERROR1;
    }
#line 434
    if (temp == 0U) {
#line 435
      result->justify_hor = (psiconv_justify_hor_t )0;
    } else
#line 436
    if (temp == 1U) {
#line 437
      result->justify_hor = (psiconv_justify_hor_t )1;
    } else
#line 438
    if (temp == 2U) {
#line 439
      result->justify_hor = (psiconv_justify_hor_t )2;
    } else
#line 440
    if (temp == 3U) {
#line 441
      result->justify_hor = (psiconv_justify_hor_t )3;
    } else {
      {
#line 443
      psiconv_warn((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Unknown horizontal justify argument in paragraph layout codes list");
#line 445
      result->justify_hor = (psiconv_justify_hor_t )0;
      }
    }
    {
#line 447
    psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Justify: %02x",
                  temp);
#line 448
    len ++;
    }
#line 449
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 451
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read vertical justify");
#line 452
    tmp___1 = psiconv_read_u8(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
#line 452
    temp = (psiconv_u32 )tmp___1;
    }
#line 453
    if (res) {
#line 454
      goto ERROR1;
    }
#line 455
    if (temp == 0U) {
#line 456
      result->justify_ver = (psiconv_justify_ver_t )0;
    } else
#line 457
    if (temp == 1U) {
#line 458
      result->justify_ver = (psiconv_justify_ver_t )1;
    } else
#line 459
    if (temp == 2U) {
#line 460
      result->justify_ver = (psiconv_justify_ver_t )2;
    } else {
      {
#line 462
      psiconv_warn((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Unknown vertical justify argument in paragraph layout codes list");
#line 464
      result->justify_ver = (psiconv_justify_ver_t )2;
      }
    }
    {
#line 466
    psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Justify: %02x",
                  temp);
#line 467
    len ++;
    }
#line 468
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 470
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read linespacing distance");
#line 471
    result->linespacing = psiconv_read_size(config, buf, lev + 3, off + (psiconv_u32 )len,
                                            & leng, & res);
    }
#line 472
    if (res) {
#line 473
      goto ERROR1;
    }
#line 474
    len += leng;
#line 475
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 477
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read linespacing exact");
#line 478
    res = psiconv_parse_bool(config, buf, lev + 3, off + (psiconv_u32 )len, & leng,
                             & result->linespacing_exact);
    }
#line 478
    if (res) {
#line 480
      goto ERROR1;
    }
#line 481
    len += leng;
#line 482
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 484
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read top space");
#line 485
    result->space_above = psiconv_read_size(config, buf, lev + 3, off + (psiconv_u32 )len,
                                            & leng, & res);
    }
#line 486
    if (res) {
#line 487
      goto ERROR1;
    }
#line 488
    len += leng;
#line 489
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 491
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read bottom space");
#line 492
    result->space_below = psiconv_read_size(config, buf, lev + 3, off + (psiconv_u32 )len,
                                            & leng, & res);
    }
#line 493
    if (res) {
#line 494
      goto ERROR1;
    }
#line 495
    len += leng;
#line 496
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 498
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read on one page");
#line 499
    res = psiconv_parse_bool(config, buf, lev + 3, off + (psiconv_u32 )len, & leng,
                             & result->keep_together);
    }
#line 499
    if (res) {
#line 501
      goto ERROR1;
    }
#line 502
    len += leng;
#line 503
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 505
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read together with");
#line 506
    res = psiconv_parse_bool(config, buf, lev + 3, off + (psiconv_u32 )len, & leng,
                             & result->keep_with_next);
    }
#line 506
    if (res) {
#line 508
      goto ERROR1;
    }
#line 509
    len += leng;
#line 510
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 512
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read on next page");
#line 513
    res = psiconv_parse_bool(config, buf, lev + 3, off + (psiconv_u32 )len, & leng,
                             & result->on_next_page);
    }
#line 513
    if (res) {
#line 515
      goto ERROR1;
    }
#line 516
    len += leng;
#line 517
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 519
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read no widow protection");
#line 520
    res = psiconv_parse_bool(config, buf, lev + 3, off + (psiconv_u32 )len, & leng,
                             & result->no_widow_protection);
    }
#line 520
    if (res) {
#line 522
      goto ERROR1;
    }
#line 523
    len += leng;
#line 524
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 526
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read wrap to fit cell limits");
#line 527
    res = psiconv_parse_bool(config, buf, lev + 3, off + (psiconv_u32 )len, & leng,
                             & result->wrap_to_fit_cell);
    }
#line 527
    if (res) {
#line 529
      goto ERROR1;
    }
#line 530
    len += leng;
#line 531
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 533
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read border distance to text");
#line 534
    result->border_distance = psiconv_read_length(config, buf, lev + 3, off + (psiconv_u32 )len,
                                                  & leng, & res);
    }
#line 536
    if (res) {
#line 537
      goto ERROR1;
    }
#line 538
    len += leng;
#line 539
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 541
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read top border");
#line 542
    res = psiconv_parse_border(config, buf, lev + 3, off + (psiconv_u32 )len, & leng,
                               & temp_border);
    }
#line 542
    if (res) {
#line 543
      goto ERROR1;
    }
    {
#line 544
    psiconv_free_border(result->top_border);
#line 545
    result->top_border = temp_border;
#line 546
    len += leng;
    }
#line 547
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 549
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read bottom border");
#line 550
    res = psiconv_parse_border(config, buf, lev + 3, off + (psiconv_u32 )len, & leng,
                               & temp_border);
    }
#line 550
    if (res) {
#line 551
      goto ERROR1;
    }
    {
#line 552
    psiconv_free_border(result->bottom_border);
#line 553
    result->bottom_border = temp_border;
#line 554
    len += leng;
    }
#line 555
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 557
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read left border");
#line 558
    res = psiconv_parse_border(config, buf, lev + 3, off + (psiconv_u32 )len, & leng,
                               & temp_border);
    }
#line 558
    if (res) {
#line 559
      goto ERROR1;
    }
    {
#line 560
    psiconv_free_border(result->left_border);
#line 561
    result->left_border = temp_border;
#line 562
    len += leng;
    }
#line 563
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 565
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read right border");
#line 566
    res = psiconv_parse_border(config, buf, lev + 3, off + (psiconv_u32 )len, & leng,
                               & temp_border);
    }
#line 566
    if (res) {
#line 567
      goto ERROR1;
    }
    {
#line 568
    psiconv_free_border(result->right_border);
#line 569
    result->right_border = temp_border;
#line 570
    len += leng;
    }
#line 571
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 573
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read bullet");
#line 574
    res = psiconv_parse_bullet(config, buf, lev + 3, off + (psiconv_u32 )len, & leng,
                               & temp_bullet);
    }
#line 574
    if (res) {
#line 575
      goto ERROR1;
    }
    {
#line 576
    psiconv_free_bullet(result->bullet);
#line 577
    result->bullet = temp_bullet;
#line 578
    len += leng;
    }
#line 579
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 581
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read standard tabs");
#line 582
    (result->tabs)->normal = psiconv_read_length(config, buf, lev + 3, off + (psiconv_u32 )len,
                                                 & leng, & res);
    }
#line 584
    if (res) {
#line 585
      goto ERROR1;
    }
#line 586
    len += leng;
#line 587
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 589
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read extra tab");
#line 590
    res = psiconv_parse_tab(config, buf, lev + 3, off + (psiconv_u32 )len, & leng,
                            & temp_tab);
    }
#line 590
    if (res) {
#line 591
      goto ERROR1;
    }
    {
#line 592
    res = psiconv_list_add((result->tabs)->extras, (void const   *)temp_tab);
    }
#line 592
    if (res) {
      {
#line 593
      psiconv_free_tab(temp_tab);
      }
#line 594
      goto ERROR1;
    }
    {
#line 596
    psiconv_free_tab(temp_tab);
#line 597
    len += leng;
    }
#line 598
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 600
    psiconv_warn((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Unknown code in paragraph layout codes list");
#line 602
    psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Code: %02x",
                  (int )id);
#line 603
    len ++;
    }
#line 604
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 606
    nr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 609
  if (len - 4 != list_length) {
    {
#line 610
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Read past end of paragraph layout codes list. I probably lost track somewhere!");
#line 613
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Read %d characters instead of %d",
                  len - 4, list_length);
#line 615
    res = 3;
    }
#line 616
    goto ERROR1;
  }
  {
#line 619
  len = list_length + 4;
#line 621
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "End of paragraph layout list (total length: %08x)",
                   len);
  }
#line 624
  if (length) {
#line 625
    *length = len;
  }
#line 626
  return (0);
  ERROR1: 
  {
#line 629
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of paragraph_layout_list failed");
  }
#line 630
  if (length) {
#line 631
    *length = 0;
  }
#line 632
  if (! res) {
#line 633
    return (-2);
  } else {
#line 635
    return (res);
  }
}
}
#line 638 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_layout.c"
int psiconv_parse_character_layout_list(psiconv_config const   config , psiconv_buffer const   buf ,
                                        int lev , psiconv_u32 off , int *length ,
                                        psiconv_character_layout result ) 
{ 
  int res ;
  int len ;
  int list_length ;
  int leng ;
  int nr ;
  psiconv_u8 id ;
  psiconv_u32 temp ;
  psiconv_color temp_color ;
  psiconv_font temp_font ;
  psiconv_u32 tmp ;
  psiconv_u8 tmp___0 ;
  psiconv_u8 tmp___1 ;

  {
  {
#line 643
  res = 0;
#line 644
  len = 0;
#line 651
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read character layout codes");
#line 653
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the list length");
#line 654
  tmp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 654
  list_length = (int )tmp;
  }
#line 655
  if (res) {
#line 656
    goto ERROR1;
  }
  {
#line 657
  psiconv_debug((psiconv_config )config, lev + 2, off, "Length in bytes: %08x", list_length);
#line 658
  len += 4;
#line 660
  nr = 0;
  }
  {
#line 661
  while (1) {
    while_continue: /* CIL Label */ ;
#line 661
    if (! (len - 4 < list_length)) {
#line 661
      goto while_break;
    }
    {
#line 662
    psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read element %d",
                     nr);
#line 663
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the element id");
#line 664
    id = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
    }
#line 665
    if (res) {
#line 666
      goto ERROR1;
    }
    {
#line 667
    psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Id: %02x",
                  (int )id);
#line 668
    len ++;
    }
    {
#line 670
    if ((int )id == 24) {
#line 670
      goto case_24;
    }
#line 674
    if ((int )id == 25) {
#line 674
      goto case_25;
    }
#line 682
    if ((int )id == 26) {
#line 682
      goto case_26;
    }
#line 690
    if ((int )id == 27) {
#line 690
      goto case_27;
    }
#line 694
    if ((int )id == 28) {
#line 694
      goto case_28;
    }
#line 701
    if ((int )id == 29) {
#line 701
      goto case_29;
    }
#line 707
    if ((int )id == 30) {
#line 707
      goto case_30;
    }
#line 713
    if ((int )id == 31) {
#line 713
      goto case_31;
    }
#line 731
    if ((int )id == 32) {
#line 731
      goto case_32;
    }
#line 738
    if ((int )id == 33) {
#line 738
      goto case_33;
    }
#line 745
    if ((int )id == 34) {
#line 745
      goto case_34;
    }
#line 753
    if ((int )id == 35) {
#line 753
      goto case_35;
    }
#line 757
    if ((int )id == 36) {
#line 757
      goto case_36;
    }
#line 769
    goto switch_default;
    case_24: /* CIL Label */ 
    {
#line 671
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to skip an unknown setting");
#line 672
    len ++;
    }
#line 673
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 675
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read text color");
#line 676
    res = psiconv_parse_color(config, buf, lev + 3, off + (psiconv_u32 )len, & leng,
                              & temp_color);
    }
#line 676
    if (res) {
#line 677
      goto ERROR1;
    }
    {
#line 678
    psiconv_free_color(result->color);
#line 679
    result->color = temp_color;
#line 680
    len += leng;
    }
#line 681
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 683
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read background color (?)");
#line 684
    res = psiconv_parse_color(config, buf, lev + 2, off + (psiconv_u32 )len, & leng,
                              & temp_color);
    }
#line 684
    if (res) {
#line 685
      goto ERROR1;
    }
    {
#line 686
    psiconv_free_color(result->back_color);
#line 687
    result->back_color = temp_color;
#line 688
    len += leng;
    }
#line 689
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 691
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to skip an unknown setting");
#line 692
    len ++;
    }
#line 693
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 695
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read font size");
#line 696
    result->font_size = psiconv_read_size(config, buf, lev + 3, off + (psiconv_u32 )len,
                                          & leng, & res);
    }
#line 697
    if (res) {
#line 698
      goto ERROR1;
    }
#line 699
    len += leng;
#line 700
    goto switch_break;
    case_29: /* CIL Label */ 
    {
#line 702
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read italic");
#line 703
    res = psiconv_parse_bool(config, buf, lev + 3, off + (psiconv_u32 )len, & leng,
                             & result->italic);
    }
#line 703
    if (res) {
#line 704
      goto ERROR1;
    }
#line 705
    len += leng;
#line 706
    goto switch_break;
    case_30: /* CIL Label */ 
    {
#line 708
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read bold");
#line 709
    res = psiconv_parse_bool(config, buf, lev + 3, off + (psiconv_u32 )len, & leng,
                             & result->bold);
    }
#line 709
    if (res) {
#line 710
      goto ERROR1;
    }
#line 711
    len += leng;
#line 712
    goto switch_break;
    case_31: /* CIL Label */ 
    {
#line 714
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read super_sub");
#line 715
    tmp___0 = psiconv_read_u8(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
#line 715
    temp = (psiconv_u32 )tmp___0;
    }
#line 716
    if (res) {
#line 717
      goto ERROR1;
    }
#line 718
    if (temp == 0U) {
#line 719
      result->super_sub = (psiconv_super_sub_t )0;
    } else
#line 720
    if (temp == 1U) {
#line 721
      result->super_sub = (psiconv_super_sub_t )1;
    } else
#line 722
    if (temp == 2U) {
#line 723
      result->super_sub = (psiconv_super_sub_t )2;
    } else {
      {
#line 725
      psiconv_warn((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Unknown super_sub argument in character layout codes list");
      }
    }
    {
#line 728
    psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Super_sub: %02x",
                  temp);
#line 729
    len ++;
    }
#line 730
    goto switch_break;
    case_32: /* CIL Label */ 
    {
#line 732
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read underline");
#line 733
    res = psiconv_parse_bool(config, buf, lev + 3, off + (psiconv_u32 )len, & leng,
                             & result->underline);
    }
#line 733
    if (res) {
#line 735
      goto ERROR1;
    }
#line 736
    len += leng;
#line 737
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 739
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read strikethrough");
#line 740
    res = psiconv_parse_bool(config, buf, lev + 3, off + (psiconv_u32 )len, & leng,
                             & result->strikethrough);
    }
#line 740
    if (res) {
#line 742
      goto ERROR1;
    }
#line 743
    len += leng;
#line 744
    goto switch_break;
    case_34: /* CIL Label */ 
    {
#line 746
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read font");
#line 747
    res = psiconv_parse_font(config, buf, lev + 3, off + (psiconv_u32 )len, & leng,
                             & temp_font);
    }
#line 747
    if (res) {
#line 748
      goto ERROR1;
    }
    {
#line 749
    psiconv_free_font(result->font);
#line 750
    result->font = temp_font;
#line 751
    len += leng;
    }
#line 752
    goto switch_break;
    case_35: /* CIL Label */ 
    {
#line 754
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to skip an unknown setting");
#line 755
    len ++;
    }
#line 756
    goto switch_break;
    case_36: /* CIL Label */ 
    {
#line 758
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read unknown code 0x24 (%02x expected)",
                     0);
#line 760
    tmp___1 = psiconv_read_u8(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
#line 760
    temp = (psiconv_u32 )tmp___1;
    }
#line 761
    if (res) {
#line 762
      goto ERROR1;
    }
#line 763
    if (temp != 0U) {
      {
#line 764
      psiconv_warn((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Unknown code 0x24 value != 0x0 (0x%02x)",
                   temp);
      }
    }
#line 767
    len ++;
#line 768
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 770
    psiconv_warn((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Unknown code in character layout list");
#line 771
    psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Code: %02x",
                  (int )id);
#line 772
    len ++;
    }
#line 773
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 775
    nr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 778
  if (len - 4 != list_length) {
    {
#line 779
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Read past end of character layout codes list. I probably lost track somewhere!");
#line 782
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Read %d characters instead of %d",
                  len - 4, list_length);
#line 784
    res = 3;
    }
#line 785
    goto ERROR1;
  }
  {
#line 788
  len = list_length + 4;
#line 790
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "End of character layout list (total length: %08x)",
                   len);
  }
#line 793
  if (length) {
#line 794
    *length = len;
  }
#line 795
  return (res);
  ERROR1: 
  {
#line 798
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of character_layout_list failed");
  }
#line 799
  if (length) {
#line 800
    *length = 0;
  }
#line 801
  if (! res) {
#line 802
    return (-2);
  } else {
#line 804
    return (res);
  }
}
}
#line 62 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/buffer.h"
size_t psiconv_buffer_fread(psiconv_buffer buf , size_t size , FILE *f ) ;
#line 66
int psiconv_buffer_fread_all(psiconv_buffer buf , FILE *f ) ;
#line 70
int psiconv_buffer_fwrite_all(psiconv_buffer const   buf , FILE *f ) ;
#line 45 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/buffer.c"
static psiconv_u32 unique_id  =    (psiconv_u32 )1;
#line 47 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/buffer.c"
psiconv_u32 psiconv_buffer_unique_id(void) 
{ 
  psiconv_u32 tmp ;

  {
#line 49
  tmp = unique_id;
#line 49
  unique_id ++;
#line 49
  return (tmp);
}
}
#line 52 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/buffer.c"
psiconv_buffer psiconv_buffer_new(void) 
{ 
  psiconv_buffer buf ;
  void *tmp ;
  psiconv_list tmp___0 ;
  psiconv_list tmp___1 ;
  psiconv_list tmp___2 ;

  {
  {
#line 55
  tmp = malloc(sizeof(*buf));
#line 55
  buf = (psiconv_buffer )tmp;
  }
#line 55
  if (! buf) {
#line 56
    goto ERROR1;
  }
  {
#line 57
  tmp___0 = psiconv_list_new(sizeof(psiconv_u8 ));
#line 57
  buf->data = tmp___0;
  }
#line 57
  if (! tmp___0) {
#line 58
    goto ERROR2;
  }
  {
#line 59
  tmp___1 = psiconv_list_new(sizeof(struct psiconv_relocation_s ));
#line 59
  buf->reloc_target = tmp___1;
  }
#line 59
  if (! tmp___1) {
#line 61
    goto ERROR3;
  }
  {
#line 62
  tmp___2 = psiconv_list_new(sizeof(struct psiconv_relocation_s ));
#line 62
  buf->reloc_ref = tmp___2;
  }
#line 62
  if (! tmp___2) {
#line 64
    goto ERROR4;
  }
#line 65
  return (buf);
  ERROR4: 
  {
#line 67
  psiconv_list_free(buf->reloc_target);
  }
  ERROR3: 
  {
#line 69
  psiconv_list_free(buf->data);
  }
  ERROR2: 
  {
#line 71
  free((void *)buf);
  }
  ERROR1: 
#line 73
  return ((psiconv_buffer )((void *)0));
}
}
#line 76 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/buffer.c"
void psiconv_buffer_free(psiconv_buffer buf ) 
{ 


  {
  {
#line 78
  psiconv_list_free(buf->reloc_ref);
#line 79
  psiconv_list_free(buf->reloc_target);
#line 80
  psiconv_list_free(buf->data);
#line 81
  free((void *)buf);
  }
#line 82
  return;
}
}
#line 84 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/buffer.c"
psiconv_u32 psiconv_buffer_length(psiconv_buffer const   buf ) 
{ 
  psiconv_u32 tmp ;

  {
  {
#line 86
  tmp = psiconv_list_length((psiconv_list const   )buf->data);
  }
#line 86
  return (tmp);
}
}
#line 89 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/buffer.c"
psiconv_u8 *psiconv_buffer_get(psiconv_buffer const   buf , psiconv_u32 off ) 
{ 
  void *tmp ;

  {
  {
#line 91
  tmp = psiconv_list_get((psiconv_list const   )buf->data, off);
  }
#line 91
  return ((psiconv_u8 *)tmp);
}
}
#line 94 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/buffer.c"
int psiconv_buffer_add(psiconv_buffer buf , psiconv_u8 data ) 
{ 
  int tmp ;

  {
  {
#line 96
  tmp = psiconv_list_add(buf->data, (void const   *)(& data));
  }
#line 96
  return (tmp);
}
}
#line 99 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/buffer.c"
size_t psiconv_buffer_fread(psiconv_buffer buf , size_t size , FILE *f ) 
{ 
  size_t tmp ;

  {
  {
#line 101
  tmp = psiconv_list_fread(buf->data, size, f);
  }
#line 101
  return (tmp);
}
}
#line 104 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/buffer.c"
int psiconv_buffer_fread_all(psiconv_buffer buf , FILE *f ) 
{ 
  int tmp ;

  {
  {
#line 106
  tmp = psiconv_list_fread_all(buf->data, f);
  }
#line 106
  return (tmp);
}
}
#line 109 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/buffer.c"
int psiconv_buffer_fwrite_all(psiconv_buffer const   buf , FILE *f ) 
{ 
  int tmp ;

  {
  {
#line 111
  tmp = psiconv_list_fwrite_all((psiconv_list const   )buf->data, f);
  }
#line 111
  return (tmp);
}
}
#line 114 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/buffer.c"
int psiconv_buffer_subbuffer(psiconv_buffer *buf , psiconv_buffer const   org , psiconv_u32 offset ,
                             psiconv_u32 length ) 
{ 
  int i ;
  int res ;
  psiconv_u8 *data ;
  psiconv_buffer tmp ;

  {
  {
#line 120
  tmp = psiconv_buffer_new();
#line 120
  *buf = tmp;
  }
#line 120
  if (! tmp) {
#line 121
    res = 2;
#line 122
    goto ERROR1;
  }
#line 124
  i = 0;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! ((psiconv_u32 )i < length)) {
#line 124
      goto while_break;
    }
    {
#line 125
    data = psiconv_buffer_get(org, offset + (psiconv_u32 )i);
    }
#line 125
    if (! data) {
#line 126
      res = 1;
#line 127
      goto ERROR2;
    }
    {
#line 129
    res = psiconv_buffer_add(*buf, *data);
    }
#line 129
    if (res) {
#line 130
      goto ERROR2;
    }
#line 124
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  return (0);
  ERROR2: 
  {
#line 136
  psiconv_buffer_free(*buf);
  }
  ERROR1: 
#line 138
  return (res);
}
}
#line 141 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/buffer.c"
int psiconv_buffer_concat(psiconv_buffer buf , psiconv_buffer const   extra ) 
{ 
  int res ;
  psiconv_u32 i ;
  psiconv_relocation reloc ;
  void *tmp ;
  psiconv_u32 tmp___0 ;
  psiconv_u32 tmp___1 ;
  void *tmp___2 ;
  psiconv_u32 tmp___3 ;
  psiconv_u32 tmp___4 ;
  int tmp___5 ;

  {
#line 148
  i = (psiconv_u32 )0;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 148
    tmp___1 = psiconv_list_length((psiconv_list const   )extra->reloc_target);
    }
#line 148
    if (! (i < tmp___1)) {
#line 148
      goto while_break;
    }
    {
#line 149
    tmp = psiconv_list_get((psiconv_list const   )extra->reloc_target, i);
#line 149
    reloc = (psiconv_relocation )tmp;
    }
#line 149
    if (! reloc) {
#line 150
      return (-1);
    }
    {
#line 151
    tmp___0 = psiconv_list_length((psiconv_list const   )buf->data);
#line 151
    reloc->offset += tmp___0;
#line 152
    res = psiconv_list_add(buf->reloc_target, (void const   *)reloc);
    }
#line 152
    if (res) {
#line 153
      return (res);
    }
#line 148
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  i = (psiconv_u32 )0;
  {
#line 155
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 155
    tmp___4 = psiconv_list_length((psiconv_list const   )extra->reloc_ref);
    }
#line 155
    if (! (i < tmp___4)) {
#line 155
      goto while_break___0;
    }
    {
#line 156
    tmp___2 = psiconv_list_get((psiconv_list const   )extra->reloc_ref, i);
#line 156
    reloc = (psiconv_relocation )tmp___2;
    }
#line 156
    if (! reloc) {
#line 157
      return (-1);
    }
    {
#line 158
    tmp___3 = psiconv_list_length((psiconv_list const   )buf->data);
#line 158
    reloc->offset += tmp___3;
#line 159
    res = psiconv_list_add(buf->reloc_ref, (void const   *)reloc);
    }
#line 159
    if (res) {
#line 160
      return (res);
    }
#line 155
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 162
  tmp___5 = psiconv_list_concat(buf->data, (psiconv_list const   )extra->data);
  }
#line 162
  return (tmp___5);
}
}
#line 165 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/buffer.c"
int psiconv_buffer_resolve(psiconv_buffer buf ) 
{ 
  int res ;
  psiconv_u32 i ;
  psiconv_u32 j ;
  psiconv_u32 temp ;
  psiconv_relocation target ;
  psiconv_relocation ref ;
  void *tmp ;
  void *tmp___0 ;
  psiconv_u32 tmp___1 ;
  psiconv_u32 tmp___2 ;
  psiconv_u32 tmp___3 ;

  {
#line 171
  i = (psiconv_u32 )0;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 171
    tmp___3 = psiconv_list_length((psiconv_list const   )buf->reloc_ref);
    }
#line 171
    if (! (i < tmp___3)) {
#line 171
      goto while_break;
    }
    {
#line 172
    tmp = psiconv_list_get((psiconv_list const   )buf->reloc_ref, i);
#line 172
    ref = (psiconv_relocation )tmp;
    }
#line 172
    if (! ref) {
#line 173
      return (-1);
    }
#line 174
    j = (psiconv_u32 )0;
    {
#line 174
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 174
      tmp___1 = psiconv_list_length((psiconv_list const   )buf->reloc_target);
      }
#line 174
      if (! (j < tmp___1)) {
#line 174
        goto while_break___0;
      }
      {
#line 175
      tmp___0 = psiconv_list_get((psiconv_list const   )buf->reloc_target, j);
#line 175
      target = (psiconv_relocation )tmp___0;
      }
#line 175
      if (! target) {
#line 176
        return (-1);
      }
#line 177
      if (ref->id == target->id) {
        {
#line 178
        temp = target->offset & 255U;
#line 179
        res = psiconv_list_replace(buf->data, ref->offset, (void const   *)(& temp));
        }
#line 179
        if (res) {
#line 180
          return (-1);
        }
        {
#line 181
        temp = (target->offset >> 8) & 255U;
#line 182
        res = psiconv_list_replace(buf->data, ref->offset + 1U, (void const   *)(& temp));
        }
#line 182
        if (res) {
#line 183
          return (-1);
        }
        {
#line 184
        temp = (target->offset >> 16) & 255U;
#line 185
        res = psiconv_list_replace(buf->data, ref->offset + 2U, (void const   *)(& temp));
        }
#line 185
        if (res) {
#line 186
          return (-1);
        }
        {
#line 187
        temp = (target->offset >> 24) & 255U;
#line 188
        res = psiconv_list_replace(buf->data, ref->offset + 3U, (void const   *)(& temp));
        }
#line 188
        if (res) {
#line 189
          return (-1);
        }
#line 190
        goto while_break___0;
      }
#line 174
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 193
    tmp___2 = psiconv_list_length((psiconv_list const   )buf->reloc_target);
    }
#line 193
    if (j == tmp___2) {
#line 194
      return (-1);
    }
#line 171
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  psiconv_list_empty(buf->reloc_target);
#line 197
  psiconv_list_empty(buf->reloc_ref);
  }
#line 198
  return (0);
}
}
#line 201 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/buffer.c"
int psiconv_buffer_add_reference(psiconv_buffer buf , int id ) 
{ 
  struct psiconv_relocation_s reloc ;
  int res ;
  int i ;
  psiconv_u8 data ;

  {
  {
#line 207
  reloc.offset = psiconv_list_length((psiconv_list const   )buf->data);
#line 208
  reloc.id = id;
#line 209
  res = psiconv_list_add(buf->reloc_ref, (void const   *)(& reloc));
  }
#line 209
  if (res) {
#line 210
    return (res);
  }
#line 211
  data = (psiconv_u8 )0;
#line 212
  i = 0;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! (i < 4)) {
#line 212
      goto while_break;
    }
    {
#line 213
    res = psiconv_list_add(buf->data, (void const   *)(& data));
    }
#line 213
    if (res) {
#line 214
      return (res);
    }
#line 212
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  return (0);
}
}
#line 218 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/buffer.c"
int psiconv_buffer_add_target(psiconv_buffer buf , int id ) 
{ 
  struct psiconv_relocation_s reloc ;
  int tmp ;

  {
  {
#line 222
  reloc.offset = psiconv_list_length((psiconv_list const   )buf->data);
#line 223
  reloc.id = id;
#line 224
  tmp = psiconv_list_add(buf->reloc_target, (void const   *)(& reloc));
  }
#line 224
  return (tmp);
}
}
#line 140 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_routines.h"
int psiconv_parse_page_header(psiconv_config const   config , psiconv_buffer const   buf ,
                              int lev , psiconv_u32 off , int *length , psiconv_page_header *result ) ;
#line 34 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_page.c"
int psiconv_parse_page_header(psiconv_config const   config , psiconv_buffer const   buf ,
                              int lev , psiconv_u32 off , int *length , psiconv_page_header *result ) 
{ 
  int res ;
  int len ;
  int i ;
  int leng ;
  int has_content ;
  psiconv_u32 temp ;
  psiconv_page_header tmp ;
  void *tmp___0 ;
  psiconv_u8 tmp___1 ;
  psiconv_u8 tmp___2 ;
  psiconv_paragraph_layout tmp___3 ;
  psiconv_character_layout tmp___4 ;

  {
  {
#line 38
  res = 0;
#line 39
  len = 0;
#line 43
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a page header (or footer)");
#line 44
  tmp___0 = malloc(sizeof(*(*result)));
#line 44
  tmp = (psiconv_page_header )tmp___0;
#line 44
  *result = tmp;
  }
#line 44
  if (! tmp) {
#line 45
    goto ERROR1;
  }
  {
#line 47
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the has_content flag");
#line 49
  tmp___1 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 49
  temp = (psiconv_u32 )tmp___1;
  }
#line 50
  if (res) {
#line 51
    goto ERROR2;
  }
#line 52
  if (temp == 0U) {
#line 53
    has_content = 0;
  } else
#line 54
  if (temp == 1U) {
#line 55
    has_content = 1;
  } else {
    {
#line 57
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Page header has_content flag unknown value (assumed default)");
#line 59
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Flag: %02x",
                  temp);
#line 60
    has_content = 1;
    }
  }
  {
#line 62
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Has_content flag: %02x",
                has_content);
#line 63
  len ++;
#line 65
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read displayed-on-first-page flag");
#line 66
  res = psiconv_parse_bool(config, buf, lev + 2, off + (psiconv_u32 )len, & leng,
                           & (*result)->on_first_page);
  }
#line 66
  if (res) {
#line 68
    goto ERROR2;
  }
  {
#line 69
  len += leng;
#line 71
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read three zero bytes");
#line 72
  i = 0;
  }
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (! (i < 3)) {
#line 72
      goto while_break;
    }
    {
#line 73
    tmp___2 = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 73
    temp = (psiconv_u32 )tmp___2;
    }
#line 74
    if (res) {
#line 75
      goto ERROR2;
    }
#line 76
    if (temp != 0U) {
      {
#line 77
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Page Header unknown value in zero bytes section");
#line 79
      psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Byte %d: read %02x, expected %02x",
                    i, temp, 0);
      }
    }
#line 72
    i ++;
#line 72
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 84
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read base paragraph layout");
#line 85
  tmp___3 = psiconv_basic_paragraph_layout();
#line 85
  (*result)->base_paragraph_layout = tmp___3;
  }
#line 85
  if (! tmp___3) {
#line 86
    goto ERROR2;
  }
#line 88
  if (has_content) {
    {
#line 89
    res = psiconv_parse_paragraph_layout_list(config, buf, lev + 2, off + (psiconv_u32 )len,
                                              & leng, (*result)->base_paragraph_layout);
    }
#line 89
    if (res) {
#line 91
      goto ERROR3;
    }
#line 92
    len += leng;
  }
  {
#line 95
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read base character layout");
#line 96
  tmp___4 = psiconv_basic_character_layout();
#line 96
  (*result)->base_character_layout = tmp___4;
  }
#line 96
  if (! tmp___4) {
#line 97
    goto ERROR3;
  }
#line 98
  if (has_content) {
    {
#line 99
    res = psiconv_parse_character_layout_list(config, buf, lev + 2, off + (psiconv_u32 )len,
                                              & leng, (*result)->base_character_layout);
    }
#line 99
    if (res) {
#line 101
      goto ERROR4;
    }
  }
  {
#line 103
  len += leng;
#line 106
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the TextEd section");
  }
#line 107
  if (has_content) {
    {
#line 108
    res = psiconv_parse_texted_section(config, buf, lev + 2, off + (psiconv_u32 )len,
                                       & leng, & (*result)->text, (*result)->base_character_layout,
                                       (*result)->base_paragraph_layout);
    }
#line 108
    if (res) {
#line 112
      goto ERROR4;
    }
#line 113
    len += leng;
  } else {
#line 115
    (*result)->text = (psiconv_texted_section )((void *)0);
  }
#line 118
  if (length) {
#line 119
    *length = len;
  }
  {
#line 121
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of page header(total length: %08x", len);
  }
#line 124
  return (res);
  ERROR4: 
  {
#line 127
  psiconv_free_character_layout((*result)->base_character_layout);
  }
  ERROR3: 
  {
#line 129
  psiconv_free_paragraph_layout((*result)->base_paragraph_layout);
  }
  ERROR2: 
  {
#line 131
  free((void *)*result);
  }
  ERROR1: 
  {
#line 133
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Page Header failed");
  }
#line 134
  if (length) {
#line 135
    *length = 0;
  }
#line 136
  if (! res) {
#line 137
    return (-2);
  } else {
#line 139
    return (res);
  }
}
}
#line 142 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_page.c"
int psiconv_parse_page_layout_section(psiconv_config const   config , psiconv_buffer const   buf ,
                                      int lev , psiconv_u32 off , int *length , psiconv_page_layout_section *result ) 
{ 
  int res ;
  int len ;
  int leng ;
  psiconv_u32 temp ;
  psiconv_page_layout_section tmp ;
  void *tmp___0 ;

  {
  {
#line 147
  res = 0;
#line 148
  len = 0;
#line 152
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read the page layout section");
#line 153
  tmp___0 = malloc(sizeof(*(*result)));
#line 153
  tmp = (psiconv_page_layout_section )tmp___0;
#line 153
  *result = tmp;
  }
#line 153
  if (! tmp) {
#line 154
    goto ERROR1;
  }
  {
#line 156
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read first page number");
#line 157
  (*result)->first_page_nr = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                              & res);
  }
#line 158
  if (res) {
#line 159
    goto ERROR2;
  }
  {
#line 160
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "First page: %d",
                (*result)->first_page_nr);
#line 161
  len += 4;
#line 163
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read header distance");
#line 164
  (*result)->header_dist = psiconv_read_length(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & leng, & res);
  }
#line 165
  if (res) {
#line 166
    goto ERROR2;
  }
  {
#line 167
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Header distance: %6.3f",
                (double )(*result)->header_dist);
#line 168
  len += leng;
#line 170
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read footer distance");
#line 171
  (*result)->footer_dist = psiconv_read_length(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & leng, & res);
  }
#line 172
  if (res) {
#line 173
    goto ERROR2;
  }
  {
#line 174
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Footer distance: %6.3f",
                (double )(*result)->footer_dist);
#line 175
  len += leng;
#line 177
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the left margin");
#line 178
  (*result)->left_margin = psiconv_read_length(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & leng, & res);
  }
#line 179
  if (res) {
#line 180
    goto ERROR2;
  }
  {
#line 181
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Left margin: %6.3f",
                (double )(*result)->left_margin);
#line 182
  len += leng;
#line 184
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going read the to right margin");
#line 185
  (*result)->right_margin = psiconv_read_length(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                & leng, & res);
  }
#line 186
  if (res) {
#line 187
    goto ERROR2;
  }
  {
#line 188
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Right margin: %6.3f",
                (double )(*result)->right_margin);
#line 189
  len += leng;
#line 191
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the top margin");
#line 192
  (*result)->top_margin = psiconv_read_length(config, buf, lev + 2, off + (psiconv_u32 )len,
                                              & leng, & res);
  }
#line 193
  if (res) {
#line 194
    goto ERROR2;
  }
  {
#line 195
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Top margin: %6.3f",
                (double )(*result)->top_margin);
#line 196
  len += leng;
#line 198
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the bottom margin");
#line 199
  (*result)->bottom_margin = psiconv_read_length(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                 & leng, & res);
  }
#line 200
  if (res) {
#line 201
    goto ERROR2;
  }
  {
#line 202
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Bottom margin: %6.3f",
                (double )(*result)->bottom_margin);
#line 203
  len += leng;
#line 205
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the header");
#line 206
  res = psiconv_parse_page_header(config, buf, lev + 2, off + (psiconv_u32 )len, & leng,
                                  & (*result)->header);
  }
#line 206
  if (res) {
#line 208
    goto ERROR2;
  }
  {
#line 209
  len += leng;
#line 211
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the footer");
#line 212
  res = psiconv_parse_page_header(config, buf, lev + 2, off + (psiconv_u32 )len, & leng,
                                  & (*result)->footer);
  }
#line 212
  if (res) {
#line 214
    goto ERROR3;
  }
  {
#line 215
  len += leng;
#line 217
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read page dimensions id");
#line 218
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 219
  if (res) {
#line 220
    goto ERROR4;
  }
#line 221
  if (temp != 268435709U) {
#line 221
    if (temp != 268435726U) {
      {
#line 223
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Page layout section page dimensions marker not found");
#line 225
      psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Page dimensions marker: read %08x, expected %08x or %08x",
                    temp, 268435709, 268435726);
      }
    }
  }
  {
#line 230
  len += 4;
#line 232
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the page width");
#line 233
  (*result)->page_width = psiconv_read_length(config, buf, lev + 2, off + (psiconv_u32 )len,
                                              & leng, & res);
  }
#line 234
  if (res) {
#line 235
    goto ERROR4;
  }
  {
#line 236
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Page width: %6.3f",
                (double )(*result)->page_width);
#line 237
  len += leng;
#line 239
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the page height");
#line 240
  (*result)->page_height = psiconv_read_length(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & leng, & res);
  }
#line 241
  if (res) {
#line 242
    goto ERROR4;
  }
  {
#line 243
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Page height: %6.3f",
                (double )(*result)->page_height);
#line 244
  len += leng;
#line 246
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read page portrait/landscape");
#line 247
  res = psiconv_parse_bool(config, buf, lev + 2, off + (psiconv_u32 )len, & leng,
                           & (*result)->landscape);
  }
#line 247
  if (res) {
#line 248
    goto ERROR4;
  }
  {
#line 249
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Landscape: %d",
                (unsigned int )(*result)->landscape);
#line 250
  len += leng;
  }
#line 253
  if (length) {
#line 254
    *length = len;
  }
  {
#line 256
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of page section (total length: %08x)",
                   len);
  }
#line 259
  return (res);
  ERROR4: 
  {
#line 262
  psiconv_free_page_header((*result)->footer);
  }
  ERROR3: 
  {
#line 264
  psiconv_free_page_header((*result)->header);
  }
  ERROR2: 
  {
#line 266
  free((void *)*result);
  }
  ERROR1: 
  {
#line 268
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Page Section failed");
  }
#line 269
  if (length) {
#line 270
    *length = 0;
  }
#line 271
  if (! res) {
#line 272
    return (-2);
  } else {
#line 274
    return (res);
  }
}
}
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_word.c"
int psiconv_write_word_status_section(psiconv_config const   config , psiconv_buffer buf ,
                                      int lev , psiconv_word_status_section const   value ) 
{ 
  int res ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 39
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing word status section");
  }
#line 41
  if (! value) {
    {
#line 42
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null word status section");
#line 43
    res = -4;
    }
#line 44
    goto ERROR;
  }
  {
#line 47
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )2);
  }
#line 47
  if (res) {
#line 48
    goto ERROR;
  }
#line 49
  if (value->show_tabs) {
#line 49
    tmp = 1;
  } else {
#line 49
    tmp = 0;
  }
#line 49
  if (value->show_spaces) {
#line 49
    tmp___0 = 2;
  } else {
#line 49
    tmp___0 = 0;
  }
#line 49
  if (value->show_paragraph_ends) {
#line 49
    tmp___1 = 4;
  } else {
#line 49
    tmp___1 = 0;
  }
#line 49
  if (value->show_line_breaks) {
#line 49
    tmp___2 = 8;
  } else {
#line 49
    tmp___2 = 0;
  }
#line 49
  if (value->show_hard_minus) {
#line 49
    tmp___3 = 32;
  } else {
#line 49
    tmp___3 = 0;
  }
#line 49
  if (value->show_hard_space) {
#line 49
    tmp___4 = 64;
  } else {
#line 49
    tmp___4 = 0;
  }
  {
#line 49
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )(((((tmp | tmp___0) | tmp___1) | tmp___2) | tmp___3) | tmp___4));
  }
#line 49
  if (res) {
#line 55
    goto ERROR;
  }
#line 56
  if (value->show_full_pictures) {
#line 56
    tmp___5 = 1;
  } else {
#line 56
    tmp___5 = 0;
  }
#line 56
  if (value->show_full_graphs) {
#line 56
    tmp___6 = 2;
  } else {
#line 56
    tmp___6 = 0;
  }
  {
#line 56
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )(tmp___5 | tmp___6));
  }
#line 56
  if (res) {
#line 58
    goto ERROR;
  }
  {
#line 59
  res = psiconv_write_bool(config, buf, lev + 1, (psiconv_bool_t const   )value->show_top_toolbar);
  }
#line 59
  if (res) {
#line 60
    goto ERROR;
  }
  {
#line 61
  res = psiconv_write_bool(config, buf, lev + 1, (psiconv_bool_t const   )value->show_side_toolbar);
  }
#line 61
  if (res) {
#line 62
    goto ERROR;
  }
#line 63
  if (value->fit_lines_to_screen) {
#line 63
    tmp___7 = 8;
  } else {
#line 63
    tmp___7 = 0;
  }
  {
#line 63
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )tmp___7);
  }
#line 63
  if (res) {
#line 64
    goto ERROR;
  }
  {
#line 65
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )value->cursor_position);
  }
#line 65
  if (res) {
#line 66
    goto ERROR;
  }
  {
#line 67
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )value->display_size);
  }
#line 67
  if (res) {
#line 68
    goto ERROR;
  }
  {
#line 69
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of word status section");
  }
#line 70
  return (0);
  ERROR: 
  {
#line 73
  psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of word status section failed");
  }
#line 74
  return (res);
}
}
#line 77 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_word.c"
int psiconv_write_word_styles_section(psiconv_config const   config , psiconv_buffer buf ,
                                      int lev , psiconv_word_styles_section const   value ) 
{ 
  int res ;
  int i ;
  int j ;
  psiconv_word_style style___1 ;
  psiconv_paragraph_layout basepara ;
  psiconv_character_layout basechar ;
  psiconv_font font___9 ;
  psiconv_u32 buflen ;
  psiconv_u32 tmp ;
  psiconv_u32 tmp___0 ;
  void *tmp___1 ;
  psiconv_u32 tmp___2 ;
  psiconv_u32 tmp___3 ;
  psiconv_u32 tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  psiconv_u32 tmp___7 ;
  psiconv_u32 tmp___8 ;

  {
  {
#line 88
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing word styles section");
  }
#line 90
  if (! value) {
    {
#line 91
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null word styles section");
#line 92
    res = -4;
    }
#line 93
    goto ERROR1;
  } else
#line 90
  if (! value->normal) {
    {
#line 91
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null word styles section");
#line 92
    res = -4;
    }
#line 93
    goto ERROR1;
  } else
#line 90
  if (! value->styles) {
    {
#line 91
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null word styles section");
#line 92
    res = -4;
    }
#line 93
    goto ERROR1;
  }
  {
#line 96
  basepara = psiconv_basic_paragraph_layout();
  }
#line 96
  if (! basepara) {
    {
#line 97
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 98
    res = -2;
    }
#line 99
    goto ERROR1;
  }
  {
#line 102
  basechar = psiconv_basic_character_layout();
  }
#line 102
  if (! basechar) {
    {
#line 103
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 104
    res = -2;
    }
#line 105
    goto ERROR2;
  }
  {
#line 109
  res = psiconv_write_paragraph_layout_list(config, buf, lev + 1, (psiconv_paragraph_layout const   )(value->normal)->paragraph,
                                            (psiconv_paragraph_layout const   )basepara);
  }
#line 109
  if (res) {
#line 112
    goto ERROR3;
  }
  {
#line 114
  font___9 = basechar->font;
#line 115
  basechar->font = (psiconv_font )((void *)0);
#line 116
  res = psiconv_write_character_layout_list(config, buf, lev + 1, (psiconv_character_layout const   )(value->normal)->character,
                                            (psiconv_character_layout const   )basechar);
#line 119
  basechar->font = font___9;
  }
#line 120
  if (res) {
#line 121
    goto ERROR3;
  }
  {
#line 122
  buflen = psiconv_buffer_length((psiconv_buffer const   )buf);
#line 123
  res = psiconv_unicode_write_char(config, buf, lev + 1, (value->normal)->hotkey);
  }
#line 123
  if (res) {
#line 125
    goto ERROR3;
  }
  {
#line 126
  tmp = psiconv_buffer_length((psiconv_buffer const   )buf);
#line 126
  j = (int )(tmp - buflen);
  }
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! (j < 4)) {
#line 126
      goto while_break;
    }
    {
#line 127
    res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )0);
    }
#line 127
    if (res) {
#line 128
      goto ERROR3;
    }
#line 126
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 130
  tmp___0 = psiconv_list_length((psiconv_list const   )value->styles);
#line 130
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )tmp___0);
  }
#line 130
  if (res) {
#line 132
    goto ERROR3;
  }
#line 136
  i = 0;
  {
#line 136
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 136
    tmp___3 = psiconv_list_length((psiconv_list const   )value->styles);
    }
#line 136
    if (! ((psiconv_u32 )i < tmp___3)) {
#line 136
      goto while_break___0;
    }
    {
#line 137
    tmp___1 = psiconv_list_get((psiconv_list const   )value->styles, (psiconv_u32 )i);
#line 137
    style___1 = (psiconv_word_style )tmp___1;
    }
#line 137
    if (! style___1) {
      {
#line 138
      psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Data structure corruption");
#line 139
      res = -2;
      }
#line 140
      goto ERROR3;
    }
    {
#line 142
    buflen = psiconv_buffer_length((psiconv_buffer const   )buf);
#line 143
    res = psiconv_unicode_write_char(config, buf, lev + 1, style___1->hotkey);
    }
#line 143
    if (res) {
#line 144
      goto ERROR3;
    }
    {
#line 145
    tmp___2 = psiconv_buffer_length((psiconv_buffer const   )buf);
#line 145
    j = (int )(tmp___2 - buflen);
    }
    {
#line 145
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 145
      if (! (j < 4)) {
#line 145
        goto while_break___1;
      }
      {
#line 146
      res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )0);
      }
#line 146
      if (res) {
#line 147
        goto ERROR3;
      }
#line 145
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 136
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 149
  tmp___4 = psiconv_list_length((psiconv_list const   )value->styles);
#line 149
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )tmp___4);
  }
#line 149
  if (res) {
#line 150
    goto ERROR3;
  }
#line 151
  i = 0;
  {
#line 151
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 151
    tmp___7 = psiconv_list_length((psiconv_list const   )value->styles);
    }
#line 151
    if (! ((psiconv_u32 )i < tmp___7)) {
#line 151
      goto while_break___2;
    }
    {
#line 152
    tmp___5 = psiconv_list_get((psiconv_list const   )value->styles, (psiconv_u32 )i);
#line 152
    style___1 = (psiconv_word_style )tmp___5;
    }
#line 152
    if (! style___1) {
      {
#line 153
      psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Data structure corruption");
#line 154
      res = -2;
      }
#line 155
      goto ERROR3;
    }
#line 157
    if (! style___1->name) {
      {
#line 158
      psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null style name");
#line 159
      res = -4;
      }
#line 160
      goto ERROR3;
    }
    {
#line 162
    res = psiconv_write_string(config, buf, lev + 1, (psiconv_string_t const   )style___1->name);
    }
#line 162
    if (res) {
#line 163
      goto ERROR3;
    }
#line 164
    if (style___1->built_in) {
#line 164
      tmp___6 = 268435532;
    } else {
#line 164
      tmp___6 = 268435535;
    }
    {
#line 164
    res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )tmp___6);
    }
#line 164
    if (res) {
#line 166
      goto ERROR3;
    }
    {
#line 167
    res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )style___1->outline_level);
    }
#line 167
    if (res) {
#line 168
      goto ERROR3;
    }
    {
#line 169
    res = psiconv_write_character_layout_list(config, buf, lev + 1, (psiconv_character_layout const   )style___1->character,
                                              (psiconv_character_layout const   )(value->normal)->character);
    }
#line 169
    if (res) {
#line 171
      goto ERROR3;
    }
    {
#line 172
    res = psiconv_write_paragraph_layout_list(config, buf, lev + 1, (psiconv_paragraph_layout const   )style___1->paragraph,
                                              (psiconv_paragraph_layout const   )(value->normal)->paragraph);
    }
#line 172
    if (res) {
#line 174
      goto ERROR3;
    }
#line 151
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 177
  i = 0;
  {
#line 177
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 177
    tmp___8 = psiconv_list_length((psiconv_list const   )value->styles);
    }
#line 177
    if (! ((psiconv_u32 )i < tmp___8)) {
#line 177
      goto while_break___3;
    }
    {
#line 178
    res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )255);
    }
#line 178
    if (res) {
#line 179
      goto ERROR3;
    }
#line 177
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 180
  res = 0;
  ERROR3: 
  {
#line 183
  psiconv_free_character_layout(basechar);
  }
  ERROR2: 
  {
#line 185
  psiconv_free_paragraph_layout(basepara);
  }
  ERROR1: 
#line 187
  if (res) {
    {
#line 188
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of word styles section failed");
    }
  } else {
    {
#line 190
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of word styles section");
    }
  }
#line 191
  return (res);
}
}
#line 43 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
static struct psiconv_config_s default_config___0  = 
#line 43 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
     {3, 2, 0, 0, 0, (psiconv_bool_t )0, (psiconv_error_handler_t *)((void *)0), (psiconv_u8 )'?',
    (psiconv_ucs2 )'?', {(psiconv_ucs2 )0}, (psiconv_bool_t )0};
#line 46
static void psiconv_config_parse_statement___0(char const   *filename , int linenr ,
                                               char const   *var , int value , psiconv_config *config ) ;
#line 51
static void psiconv_config_parse_line___0(char const   *filename , int linenr , char const   *line ,
                                          psiconv_config *config ) ;
#line 54
static void psiconv_config_parse_file___0(char const   *filename , psiconv_config *config ) ;
#line 71 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
static void psiconv_config_parse_statement___0(char const   *filename , int linenr ,
                                               char const   *var , int value , psiconv_config *config ) 
{ 
  int charnr ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 78
  tmp___9 = strcasecmp(var, "verbosity");
  }
#line 78
  if (tmp___9) {
    {
#line 84
    tmp___8 = strcasecmp(var, "color");
    }
#line 84
    if (tmp___8) {
      {
#line 90
      tmp___7 = strcasecmp(var, "colordepth");
      }
#line 90
      if (tmp___7) {
        {
#line 96
        tmp___6 = strcasecmp(var, "redbits");
        }
#line 96
        if (tmp___6) {
          {
#line 102
          tmp___5 = strcasecmp(var, "greenbits");
          }
#line 102
          if (tmp___5) {
            {
#line 108
            tmp___4 = strcasecmp(var, "bluebits");
            }
#line 108
            if (tmp___4) {
              {
#line 114
              tmp___3 = strcasecmp(var, "characterset");
              }
#line 114
              if (tmp___3) {
                {
#line 121
                tmp___2 = strcasecmp(var, "unknownunicodechar");
                }
#line 121
                if (tmp___2) {
                  {
#line 128
                  tmp___1 = strcasecmp(var, "unknownepocchar");
                  }
#line 128
                  if (tmp___1) {
                    {
#line 135
                    tmp = sscanf((char const   */* __restrict  */)var, (char const   */* __restrict  */)"char%d",
                                 & charnr);
#line 135
                    tmp___0 = strlen(var);
                    }
#line 135
                    if ((size_t )tmp == tmp___0) {
#line 136
                      if (charnr < 0) {
                        {
#line 137
                        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharXXX should have XXX between 0 and 255",
                                      filename, linenr);
                        }
                      } else
#line 136
                      if (charnr > 255) {
                        {
#line 137
                        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharXXX should have XXX between 0 and 255",
                                      filename, linenr);
                        }
                      }
#line 140
                      if (value >= 1) {
#line 140
                        if (value <= 65536) {
#line 141
                          (*config)->unicode_table[charnr] = (psiconv_ucs2 )value;
                        } else {
                          {
#line 143
                          psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharXXX should be between 1 and 65535",
                                        filename, linenr);
                          }
                        }
                      } else {
                        {
#line 143
                        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharXXX should be between 1 and 65535",
                                      filename, linenr);
                        }
                      }
                    } else {
                      {
#line 147
                      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Unknown variable %s",
                                    filename, linenr, var);
                      }
                    }
                  } else
#line 129
                  if (value >= 1) {
#line 129
                    if (value < 256) {
#line 130
                      (*config)->unknown_epoc_char = (psiconv_u8 )value;
                    } else {
                      {
#line 132
                      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: UnknownEPOCChar should be between 1 and 255",
                                    filename, linenr);
                      }
                    }
                  } else {
                    {
#line 132
                    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: UnknownEPOCChar should be between 1 and 255",
                                  filename, linenr);
                    }
                  }
                } else
#line 122
                if (value >= 1) {
#line 122
                  if (value < 65536) {
#line 123
                    (*config)->unknown_unicode_char = (psiconv_ucs2 )value;
                  } else {
                    {
#line 125
                    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: UnknownUnicodeChar should be between 1 and 65535",
                                  filename, linenr);
                    }
                  }
                } else {
                  {
#line 125
                  psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: UnknownUnicodeChar should be between 1 and 65535",
                                filename, linenr);
                  }
                }
              } else
#line 115
              if (value >= 0) {
#line 115
                if (value <= 1) {
                  {
#line 116
                  psiconv_unicode_select_characterset((psiconv_config const   )*config,
                                                      value);
                  }
                } else {
                  {
#line 118
                  psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharacterSet should be between 0 and 1",
                                filename, linenr);
                  }
                }
              } else {
                {
#line 118
                psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharacterSet should be between 0 and 1",
                              filename, linenr);
                }
              }
            } else
#line 109
            if (value >= 0) {
#line 109
              if (value <= 32) {
#line 110
                (*config)->bluebits = value;
              } else {
                {
#line 112
                psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: BlueBits should be between 1 and 32 or 0",
                              filename, linenr);
                }
              }
            } else {
              {
#line 112
              psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: BlueBits should be between 1 and 32 or 0",
                            filename, linenr);
              }
            }
          } else
#line 103
          if (value >= 0) {
#line 103
            if (value <= 32) {
#line 104
              (*config)->greenbits = value;
            } else {
              {
#line 106
              psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: GreenBits should be between 1 and 32 or 0",
                            filename, linenr);
              }
            }
          } else {
            {
#line 106
            psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: GreenBits should be between 1 and 32 or 0",
                          filename, linenr);
            }
          }
        } else
#line 97
        if (value >= 0) {
#line 97
          if (value <= 32) {
#line 98
            (*config)->redbits = value;
          } else {
            {
#line 100
            psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: RedBits should be between 1 and 32 or 0",
                          filename, linenr);
            }
          }
        } else {
          {
#line 100
          psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: RedBits should be between 1 and 32 or 0",
                        filename, linenr);
          }
        }
      } else
#line 91
      if (value > 0) {
#line 91
        if (value <= 32) {
#line 92
          (*config)->colordepth = value;
        } else {
          {
#line 94
          psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: ColorDepth should be between 1 and 32",
                        filename, linenr);
          }
        }
      } else {
        {
#line 94
        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: ColorDepth should be between 1 and 32",
                      filename, linenr);
        }
      }
    } else
#line 85
    if (value == 0) {
#line 86
      (*config)->color = (psiconv_bool_t )value;
    } else
#line 85
    if (value == 1) {
#line 86
      (*config)->color = (psiconv_bool_t )value;
    } else {
      {
#line 88
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Color should be 0 or 1",
                    filename, linenr);
      }
    }
  } else
#line 79
  if (value >= 1) {
#line 79
    if (value <= 5) {
#line 80
      (*config)->verbosity = value;
    } else {
      {
#line 82
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Verbosity should be between 1 and 5",
                    filename, linenr);
      }
    }
  } else {
    {
#line 82
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Verbosity should be between 1 and 5",
                  filename, linenr);
    }
  }
  {
#line 150
  psiconv_debug(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Set variable %s to %d",
                filename, linenr, var, value);
  }
#line 152
  return;
}
}
#line 155 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
static void psiconv_config_parse_line___0(char const   *filename , int linenr , char const   *line ,
                                          psiconv_config *config ) 
{ 
  int sovar ;
  int eovar ;
  int soval ;
  int eoval ;
  int eol ;
  char *var ;
  long val ;
  void *tmp ;

  {
  {
#line 163
  psiconv_debug(*config, 0, (psiconv_u32 )0, "Going to parse line %d: %s", linenr,
                line);
#line 164
  sovar = 0;
  }
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (*(line + sovar)) {
#line 165
      if (! ((int const   )*(line + sovar) < 32)) {
#line 165
        goto while_break;
      }
    } else {
#line 165
      goto while_break;
    }
#line 166
    sovar ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  if (! *(line + sovar)) {
#line 168
    return;
  } else
#line 167
  if ((int const   )*(line + sovar) == 35) {
#line 168
    return;
  }
#line 169
  eovar = sovar;
  {
#line 170
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 170
    if (*(line + eovar)) {
#line 170
      if ((int const   )*(line + eovar) >= 65) {
#line 170
        if (! ((int const   )*(line + eovar) <= 90)) {
#line 170
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 170
      if ((int const   )*(line + eovar) >= 97) {
#line 170
        if (! ((int const   )*(line + eovar) <= 122)) {
#line 170
          goto while_break___0;
        }
      } else {
#line 170
        goto while_break___0;
      }
    } else {
#line 170
      goto while_break___0;
    }
#line 172
    eovar ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 173
  if (sovar == eovar) {
    {
#line 174
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (no variable found)",
                  filename, linenr);
    }
#line 176
    return;
  }
#line 178
  soval = eovar;
  {
#line 179
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 179
    if (*(line + soval)) {
#line 179
      if (! ((int const   )*(line + soval) <= 32)) {
#line 179
        goto while_break___1;
      }
    } else {
#line 179
      goto while_break___1;
    }
#line 180
    soval ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 181
  if ((int const   )*(line + soval) != 61) {
    {
#line 182
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (no = token found)",
                  filename, linenr);
    }
#line 184
    return;
  }
#line 186
  soval ++;
  {
#line 187
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 187
    if (*(line + soval)) {
#line 187
      if (! ((int const   )*(line + soval) <= 32)) {
#line 187
        goto while_break___2;
      }
    } else {
#line 187
      goto while_break___2;
    }
#line 188
    soval ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 189
  eoval = soval;
  {
#line 190
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 190
    if (*(line + eoval)) {
#line 190
      if ((int const   )*(line + eoval) >= 48) {
#line 190
        if (! ((int const   )*(line + eoval) <= 57)) {
#line 190
          goto while_break___3;
        }
      } else {
#line 190
        goto while_break___3;
      }
    } else {
#line 190
      goto while_break___3;
    }
#line 191
    eoval ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 192
  if (eoval == soval) {
    {
#line 193
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (no value found)",
                  filename, linenr);
    }
#line 195
    return;
  }
#line 197
  if (soval - eoval > 7) {
    {
#line 198
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (value too large)",
                  filename, linenr);
    }
#line 200
    return;
  }
#line 202
  eol = eoval;
  {
#line 203
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 203
    if (*(line + eol)) {
#line 203
      if (! ((int const   )*(line + eol) < 32)) {
#line 203
        goto while_break___4;
      }
    } else {
#line 203
      goto while_break___4;
    }
#line 204
    eol ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 205
  if (*(line + eol)) {
    {
#line 206
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (trailing garbage)",
                  filename, linenr);
    }
#line 208
    return;
  }
  {
#line 211
  tmp = malloc((size_t )((eovar - sovar) + 1));
#line 211
  var = (char *)tmp;
#line 212
  memcpy((void */* __restrict  */)var, (void const   */* __restrict  */)(line + sovar),
         (size_t )(eovar - sovar));
#line 213
  *(var + (eovar - sovar)) = (char)0;
#line 215
  val = atol(line + soval);
#line 217
  psiconv_config_parse_statement___0(filename, linenr, (char const   *)var, (int )val,
                                     config);
#line 218
  free((void *)var);
  }
#line 219
  return;
}
}
#line 222 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
static void psiconv_config_parse_file___0(char const   *filename , psiconv_config *config ) 
{ 
  int file ;
  int linenr ;
  struct stat stat_buf ;
  off_t filesize ;
  off_t bytes_left ;
  off_t bytes_read ;
  off_t sol ;
  off_t eol ;
  char *filebuffer ;
  char *filebuffer_ptr ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 229
  psiconv_progress(*config, 0, (psiconv_u32 )0, "Going to access configuration file %s",
                   filename);
#line 233
  file = open(filename, 0);
  }
#line 233
  if (file == -1) {
#line 234
    goto ERROR0;
  }
  {
#line 237
  tmp___0 = fstat(file, & stat_buf);
  }
#line 237
  if (tmp___0) {
    {
#line 238
    tmp = close(file);
    }
#line 238
    if (tmp) {
      {
#line 239
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Couldn\'t close file",
                    filename);
      }
    }
#line 241
    return;
  }
  {
#line 244
  filesize = stat_buf.st_size;
#line 245
  tmp___1 = malloc((size_t )(filesize + 1L));
#line 245
  filebuffer = (char *)tmp___1;
  }
#line 245
  if (! filebuffer) {
    {
#line 246
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Out of memory error",
                  filename);
    }
#line 248
    goto ERROR1;
  }
#line 251
  filebuffer_ptr = filebuffer;
#line 252
  bytes_left = filesize;
#line 253
  bytes_read = (off_t )1;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (bytes_read > 0L) {
#line 254
      if (! bytes_left) {
#line 254
        goto while_break;
      }
    } else {
#line 254
      goto while_break;
    }
    {
#line 255
    bytes_read = read(file, (void *)filebuffer_ptr, (size_t )bytes_left);
    }
#line 256
    if (bytes_read > 0L) {
#line 257
      filebuffer_ptr += bytes_read;
#line 258
      bytes_left -= bytes_read;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  if (bytes_left) {
#line 263
    if (bytes_left != filesize) {
      {
#line 264
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Couldn\'t read file into memory",
                    filename);
      }
#line 266
      goto ERROR2;
    }
  }
  {
#line 269
  tmp___2 = close(file);
  }
#line 269
  if (tmp___2) {
    {
#line 270
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Couldn\'t close file",
                  filename);
#line 272
    file = -1;
    }
#line 273
    goto ERROR2;
  }
  {
#line 275
  file = -1;
#line 277
  psiconv_progress(*config, 0, (psiconv_u32 )0, "Going to parse configuration file %s: ",
                   filename);
#line 280
  linenr = 0;
#line 281
  sol = (off_t )0;
  }
  {
#line 283
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 283
    if (! (sol < filesize)) {
#line 283
      goto while_break___0;
    }
#line 284
    linenr ++;
#line 285
    eol = sol;
    {
#line 286
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 286
      if (eol < filesize) {
#line 286
        if ((int )*(filebuffer + eol) != 13) {
#line 286
          if ((int )*(filebuffer + eol) != 10) {
#line 286
            if (! ((int )*(filebuffer + eol) != 0)) {
#line 286
              goto while_break___1;
            }
          } else {
#line 286
            goto while_break___1;
          }
        } else {
#line 286
          goto while_break___1;
        }
      } else {
#line 286
        goto while_break___1;
      }
#line 288
      eol ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 290
    if (eol < filesize) {
#line 290
      if ((int )*(filebuffer + eol) == 0) {
        {
#line 291
        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Unexpected character \000 found",
                      filename, linenr);
        }
#line 293
        goto ERROR2;
      }
    }
#line 295
    if (eol < filesize + 1L) {
#line 295
      if ((int )*(filebuffer + eol) == 13) {
#line 295
        if ((int )*(filebuffer + (eol + 1L)) == 10) {
#line 298
          *(filebuffer + eol) = (char)0;
#line 299
          eol ++;
        } else {
#line 295
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 295
      if ((int )*(filebuffer + eol) == 10) {
#line 295
        if ((int )*(filebuffer + (eol + 1L)) == 13) {
#line 298
          *(filebuffer + eol) = (char)0;
#line 299
          eol ++;
        }
      }
    }
    {
#line 301
    *(filebuffer + eol) = (char)0;
#line 302
    psiconv_config_parse_line___0(filename, linenr, (char const   *)(filebuffer + sol),
                                  config);
#line 303
    sol = eol + 1L;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 305
  free((void *)filebuffer);
  }
#line 306
  return;
  ERROR2: 
  {
#line 309
  free((void *)filebuffer);
  }
  ERROR1: 
#line 311
  if (file != -1) {
    {
#line 311
    tmp___3 = close(file);
    }
#line 311
    if (tmp___3) {
      {
#line 312
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Couldn\'t close file",
                    filename);
      }
    }
  }
  ERROR0: 
#line 315
  return;
}
}
#line 34 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
static psiconv_float_t pow2___0(int n ) ;
#line 35
static psiconv_string_t psiconv_read_string_aux___0(psiconv_config const   config ,
                                                    psiconv_buffer const   buf , int lev ,
                                                    psiconv_u32 off , int *length ,
                                                    int *status , int kind ) ;
#line 42 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
static psiconv_float_t pow2___0(int n ) 
{ 
  psiconv_float_t res ;
  int i ;
  int tmp ;
  psiconv_float_t tmp___0 ;

  {
#line 44
  res = 1.0;
#line 47
  i = 0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (n < 0) {
#line 47
      tmp = - n;
    } else {
#line 47
      tmp = n;
    }
#line 47
    if (! (i < tmp)) {
#line 47
      goto while_break;
    }
#line 48
    res *= 2.0;
#line 47
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  if (n < 0) {
#line 50
    tmp___0 = (psiconv_float_t )1 / res;
  } else {
#line 50
    tmp___0 = res;
  }
#line 50
  return (tmp___0);
}
}
#line 325 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
static psiconv_string_t psiconv_read_string_aux___0(psiconv_config const   config ,
                                                    psiconv_buffer const   buf , int lev ,
                                                    psiconv_u32 off , int *length ,
                                                    int *status , int kind ) 
{ 
  int bytecount ;
  int i ;
  int leng ;
  int len ;
  int localstatus ;
  psiconv_string_t result ;
  char *res_copy ;
  psiconv_list string ;
  psiconv_ucs2 nextchar ;
  psiconv_ucs2 *nextcharptr ;
  psiconv_u32 tmp ;
  psiconv_u8 tmp___0 ;
  psiconv_u32 tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  psiconv_u32 tmp___4 ;

  {
  {
#line 337
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a string");
  }
#line 339
  if (kind == -1) {
    {
#line 340
    tmp = psiconv_read_S(config, buf, lev + 2, off, & leng, & localstatus);
#line 340
    bytecount = (int )tmp;
    }
  } else
#line 341
  if (kind == -2) {
    {
#line 342
    tmp___0 = psiconv_read_u8(config, buf, lev + 2, off, & localstatus);
#line 342
    bytecount = (int )tmp___0;
#line 343
    leng = 1;
    }
  } else {
#line 345
    bytecount = kind;
#line 346
    leng = 0;
#line 347
    localstatus = 0;
  }
#line 349
  if (localstatus) {
#line 350
    goto ERROR1;
  }
  {
#line 351
  psiconv_debug((psiconv_config )config, lev + 2, off, "Length: %i", bytecount);
#line 352
  len = leng;
#line 354
  string = psiconv_list_new(sizeof(*result));
  }
#line 354
  if (! string) {
#line 355
    goto ERROR1;
  }
#line 358
  i = 0;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! (i < bytecount)) {
#line 359
      goto while_break;
    }
    {
#line 360
    nextchar = psiconv_unicode_read_char(config, (psiconv_buffer )buf, lev, (off + (psiconv_u32 )i) + (psiconv_u32 )len,
                                         & leng, & localstatus);
    }
#line 362
    if (localstatus) {
#line 363
      goto ERROR2;
    }
    {
#line 364
    localstatus = psiconv_list_add(string, (void const   *)(& nextchar));
    }
#line 364
    if (localstatus) {
#line 365
      goto ERROR2;
    }
#line 366
    i += leng;
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  if (i > bytecount) {
    {
#line 369
    psiconv_error((psiconv_config )config, lev, (off + (psiconv_u32 )i) + (psiconv_u32 )len,
                  "Malformed string");
#line 370
    localstatus = 3;
    }
#line 371
    goto ERROR2;
  }
  {
#line 373
  len += bytecount;
#line 376
  tmp___1 = psiconv_list_length((psiconv_list const   )string);
#line 376
  tmp___2 = malloc(sizeof(*result) * (unsigned long )(tmp___1 + 1U));
#line 376
  result = (psiconv_string_t )tmp___2;
  }
#line 376
  if (! result) {
#line 377
    goto ERROR2;
  }
#line 378
  i = 0;
  {
#line 378
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 378
    tmp___4 = psiconv_list_length((psiconv_list const   )string);
    }
#line 378
    if (! ((psiconv_u32 )i < tmp___4)) {
#line 378
      goto while_break___0;
    }
    {
#line 379
    tmp___3 = psiconv_list_get((psiconv_list const   )string, (psiconv_u32 )i);
#line 379
    nextcharptr = (psiconv_ucs2 *)tmp___3;
    }
#line 379
    if (! nextcharptr) {
      {
#line 380
      psiconv_error((psiconv_config )config, lev, (off + (psiconv_u32 )i) + (psiconv_u32 )len,
                    "Data structure corruption");
      }
#line 381
      goto ERROR3;
    }
#line 383
    *(result + i) = *nextcharptr;
#line 378
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 385
  *(result + i) = (psiconv_ucs2 )0;
#line 387
  res_copy = psiconv_make_printable(config, (psiconv_string_t const   )result);
  }
#line 388
  if (! res_copy) {
#line 389
    goto ERROR3;
  }
  {
#line 390
  psiconv_debug((psiconv_config )config, lev + 2, off, "Contents: `%s\'", res_copy);
#line 391
  free((void *)res_copy);
#line 393
  psiconv_list_free(string);
  }
#line 395
  if (length) {
#line 396
    *length = len;
  }
#line 398
  if (status) {
#line 399
    *status = 0;
  }
  {
#line 401
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of string (total length: %08x)", len);
  }
#line 403
  return (result);
  ERROR3: 
  {
#line 406
  free((void *)result);
  }
  ERROR2: 
  {
#line 408
  psiconv_list_free(string);
  }
  ERROR1: 
  {
#line 410
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of string failed");
  }
#line 411
  if (status) {
#line 412
    *status = localstatus;
  }
#line 413
  if (length) {
#line 414
    *length = 0;
  }
#line 415
  return ((psiconv_string_t )((void *)0));
}
}
#line 36 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle8___0(psiconv_config const   config , int lev , psiconv_u32 off ,
                                   psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) ;
#line 41
static int psiconv_decode_rle12___0(psiconv_config const   config , int lev , psiconv_u32 off ,
                                    psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) ;
#line 46
static int psiconv_decode_rle16___0(psiconv_config const   config , int lev , psiconv_u32 off ,
                                    psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) ;
#line 51
static int psiconv_decode_rle24___0(psiconv_config const   config , int lev , psiconv_u32 off ,
                                    psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) ;
#line 56
static int psiconv_bytes_to_pixel_data___0(psiconv_config const   config , int lev ,
                                           psiconv_u32 off , psiconv_pixel_bytes const   bytes ,
                                           psiconv_pixel_ints *pixels , int colordepth ,
                                           int xsize , int ysize ) ;
#line 62
static int psiconv_pixel_data_to_floats___0(psiconv_config const   config , int lev ,
                                            psiconv_u32 off , psiconv_pixel_ints const   pixels ,
                                            psiconv_pixel_floats_t *floats , int colordepth ,
                                            int color___1 , int redbits , int bluebits ,
                                            int greenbits , psiconv_pixel_floats_t const   palet ) ;
#line 647 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle8___0(psiconv_config const   config , int lev , psiconv_u32 off ,
                                   psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) 
{ 
  int res ;
  psiconv_u8 *marker ;
  psiconv_u8 *value ;
  int i ;
  int j ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  psiconv_u32 tmp___3 ;

  {
  {
#line 651
  res = 0;
#line 655
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to decode the RLE8 encoding");
#line 656
  tmp = psiconv_list_new(sizeof(psiconv_u8 ));
#line 656
  *decoded = tmp;
  }
#line 656
  if (! tmp) {
#line 657
    goto ERROR1;
  }
#line 659
  i = 0;
  {
#line 659
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 659
    tmp___3 = psiconv_list_length(encoded);
    }
#line 659
    if (! ((psiconv_u32 )i < tmp___3)) {
#line 659
      goto while_break;
    }
    {
#line 663
    tmp___0 = psiconv_list_get(encoded, (psiconv_u32 )i);
#line 663
    marker = (psiconv_u8 *)tmp___0;
    }
#line 663
    if (! marker) {
#line 664
      goto ERROR2;
    }
#line 668
    if ((int )*marker < 128) {
      {
#line 674
      tmp___1 = psiconv_list_get(encoded, (psiconv_u32 )(i + 1));
#line 674
      value = (psiconv_u8 *)tmp___1;
      }
#line 674
      if (! value) {
#line 675
        goto ERROR2;
      }
#line 681
      j = 0;
      {
#line 681
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 681
        if (! (j < (int )*marker + 1)) {
#line 681
          goto while_break___0;
        }
        {
#line 682
        res = psiconv_list_add(*decoded, (void const   *)value);
        }
#line 682
        if (res) {
#line 683
          goto ERROR2;
        }
#line 681
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 684
      i += 2;
    } else {
#line 690
      j = 0;
      {
#line 690
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 690
        if (! (j < 256 - (int )*marker)) {
#line 690
          goto while_break___1;
        }
        {
#line 695
        tmp___2 = psiconv_list_get(encoded, (psiconv_u32 )((i + j) + 1));
#line 695
        value = (psiconv_u8 *)tmp___2;
        }
#line 695
        if (! value) {
#line 696
          goto ERROR2;
        }
        {
#line 700
        res = psiconv_list_add(*decoded, (void const   *)value);
        }
#line 700
        if (res) {
#line 701
          goto ERROR2;
        }
#line 690
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 703
      i += (256 - (int )*marker) + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 706
  psiconv_progress((psiconv_config )config, lev, off, "End of RLE8 decoding process");
  }
#line 708
  return (0);
  ERROR2: 
  {
#line 711
  psiconv_list_free(*decoded);
  }
  ERROR1: 
  {
#line 713
  psiconv_error((psiconv_config )config, lev + 1, off, "Decoding of RLE8 failed");
  }
#line 714
  if (! res) {
#line 715
    return (-2);
  } else {
#line 717
    return (res);
  }
}
}
#line 720 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle12___0(psiconv_config const   config , int lev , psiconv_u32 off ,
                                    psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) 
{ 
  int res ;
  psiconv_u8 *value0 ;
  psiconv_u8 *value1 ;
  psiconv_u32 value ;
  psiconv_u32 repeat ;
  int i ;
  int j ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  psiconv_u32 tmp___2 ;

  {
  {
#line 724
  res = 0;
#line 729
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to decode the RLE12 encoding");
#line 730
  tmp = psiconv_list_new(sizeof(psiconv_u8 ));
#line 730
  *decoded = tmp;
  }
#line 730
  if (! tmp) {
#line 731
    goto ERROR1;
  }
#line 733
  i = 0;
  {
#line 733
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 733
    tmp___2 = psiconv_list_length(encoded);
    }
#line 733
    if (! ((psiconv_u32 )i < tmp___2)) {
#line 733
      goto while_break;
    }
    {
#line 734
    psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read data word at %04x",
                     i);
#line 735
    tmp___0 = psiconv_list_get(encoded, (psiconv_u32 )i);
#line 735
    value0 = (psiconv_u8 *)tmp___0;
    }
#line 735
    if (! value0) {
#line 736
      goto ERROR2;
    }
    {
#line 737
    tmp___1 = psiconv_list_get(encoded, (psiconv_u32 )(i + 1));
#line 737
    value1 = (psiconv_u8 *)tmp___1;
    }
#line 737
    if (! value1) {
#line 738
      goto ERROR2;
    }
    {
#line 739
    psiconv_debug((psiconv_config )config, lev + 2, off, "Data Word: %04x", (int )*value0 + ((int )*value1 << 8));
#line 740
    value = (psiconv_u32 )((int )*value0 + (((int )*value1 & 15) << 8));
#line 741
    repeat = (psiconv_u32 )(((int )*value1 >> 4) + 1);
#line 742
    psiconv_progress((psiconv_config )config, lev + 2, off, "Adding %02x pixels %03x",
                     repeat, value);
#line 744
    j = 0;
    }
    {
#line 744
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 744
      if (! ((psiconv_u32 )j < repeat)) {
#line 744
        goto while_break___0;
      }
      {
#line 745
      res = psiconv_list_add(*decoded, (void const   *)(& value));
      }
#line 745
      if (res) {
#line 746
        goto ERROR2;
      }
#line 744
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 747
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 749
  psiconv_progress((psiconv_config )config, lev, off, "End of RLE12 decoding process");
  }
#line 751
  return (0);
  ERROR2: 
  {
#line 754
  psiconv_list_free(*decoded);
  }
  ERROR1: 
  {
#line 756
  psiconv_error((psiconv_config )config, lev + 1, off, "Decoding of RLE12 failed");
  }
#line 757
  if (! res) {
#line 758
    return (-2);
  } else {
#line 760
    return (res);
  }
}
}
#line 763 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle16___0(psiconv_config const   config , int lev , psiconv_u32 off ,
                                    psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) 
{ 
  int res ;
  psiconv_u8 *marker ;
  psiconv_u8 *value0 ;
  psiconv_u8 *value1 ;
  psiconv_u32 value ;
  int i ;
  int j ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  psiconv_u32 tmp___5 ;

  {
  {
#line 767
  res = 0;
#line 772
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to decode the RLE16 encoding");
#line 773
  tmp = psiconv_list_new(sizeof(psiconv_u8 ));
#line 773
  *decoded = tmp;
  }
#line 773
  if (! tmp) {
#line 774
    goto ERROR1;
  }
#line 776
  i = 0;
  {
#line 776
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 776
    tmp___5 = psiconv_list_length(encoded);
    }
#line 776
    if (! ((psiconv_u32 )i < tmp___5)) {
#line 776
      goto while_break;
    }
    {
#line 777
    psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read marker byte at %04x",
                     i);
#line 778
    tmp___0 = psiconv_list_get(encoded, (psiconv_u32 )i);
#line 778
    marker = (psiconv_u8 *)tmp___0;
    }
#line 778
    if (! marker) {
#line 779
      goto ERROR2;
    }
    {
#line 780
    psiconv_debug((psiconv_config )config, lev + 2, off, "Marker byte: %02x", (int )*marker);
    }
#line 781
    if ((int )*marker < 128) {
      {
#line 782
      psiconv_debug((psiconv_config )config, lev + 2, off, "Marker: repeat value word %02x times",
                    (int )*marker + 1);
#line 784
      psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read value word at %04x",
                       i + 1);
#line 785
      tmp___1 = psiconv_list_get(encoded, (psiconv_u32 )(i + 1));
#line 785
      value0 = (psiconv_u8 *)tmp___1;
      }
#line 785
      if (! value0) {
#line 786
        goto ERROR2;
      }
      {
#line 787
      tmp___2 = psiconv_list_get(encoded, (psiconv_u32 )(i + 2));
#line 787
      value1 = (psiconv_u8 *)tmp___2;
      }
#line 787
      if (! value1) {
#line 788
        goto ERROR2;
      }
      {
#line 789
      value = (psiconv_u32 )((int )*value0 + ((int )*value1 << 8));
#line 790
      psiconv_debug((psiconv_config )config, lev + 2, off, "Value word: %02x", value);
#line 791
      psiconv_progress((psiconv_config )config, lev + 2, off, "Adding %02x pixels %04x",
                       (int )*marker + 1, value);
#line 793
      j = 0;
      }
      {
#line 793
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 793
        if (! (j < (int )*marker + 1)) {
#line 793
          goto while_break___0;
        }
        {
#line 794
        res = psiconv_list_add(*decoded, (void const   *)(& value));
        }
#line 794
        if (res) {
#line 795
          goto ERROR2;
        }
#line 793
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 796
      i += 3;
    } else {
      {
#line 798
      psiconv_debug((psiconv_config )config, lev + 2, off, "Marker: %02x value words follow",
                    256 - (int )*marker);
#line 800
      j = 0;
      }
      {
#line 800
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 800
        if (! (j < 256 - (int )*marker)) {
#line 800
          goto while_break___1;
        }
        {
#line 801
        psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read value word at %04x",
                         (i + j * 2) + 1);
#line 803
        tmp___3 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 2) + 1));
#line 803
        value0 = (psiconv_u8 *)tmp___3;
        }
#line 803
        if (! value0) {
#line 804
          goto ERROR2;
        }
        {
#line 805
        tmp___4 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 2) + 2));
#line 805
        value1 = (psiconv_u8 *)tmp___4;
        }
#line 805
        if (! value1) {
#line 806
          goto ERROR2;
        }
        {
#line 807
        value = (psiconv_u32 )((int )*value0 + ((int )*value1 << 8));
#line 808
        psiconv_debug((psiconv_config )config, lev + 2, off, "Value: %04x", value);
#line 809
        res = psiconv_list_add(*decoded, (void const   *)(& value));
        }
#line 809
        if (res) {
#line 810
          goto ERROR2;
        }
#line 800
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 812
      i += (256 - (int )*marker) * 2 + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 815
  psiconv_progress((psiconv_config )config, lev, off, "End of RLE16 decoding process");
  }
#line 817
  return (0);
  ERROR2: 
  {
#line 820
  psiconv_list_free(*decoded);
  }
  ERROR1: 
  {
#line 822
  psiconv_error((psiconv_config )config, lev + 1, off, "Decoding of RLE16 failed");
  }
#line 823
  if (! res) {
#line 824
    return (-2);
  } else {
#line 826
    return (res);
  }
}
}
#line 829 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle24___0(psiconv_config const   config , int lev , psiconv_u32 off ,
                                    psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) 
{ 
  int res ;
  psiconv_u8 *marker ;
  psiconv_u8 *value0 ;
  psiconv_u8 *value1 ;
  psiconv_u8 *value2 ;
  psiconv_u32 value ;
  int i ;
  int j ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  psiconv_u32 tmp___7 ;

  {
  {
#line 833
  res = 0;
#line 838
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to decode the RLE24 encoding");
#line 839
  tmp = psiconv_list_new(sizeof(psiconv_u8 ));
#line 839
  *decoded = tmp;
  }
#line 839
  if (! tmp) {
#line 840
    goto ERROR1;
  }
#line 842
  i = 0;
  {
#line 842
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 842
    tmp___7 = psiconv_list_length(encoded);
    }
#line 842
    if (! ((psiconv_u32 )i < tmp___7)) {
#line 842
      goto while_break;
    }
    {
#line 843
    psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read marker byte at %04x",
                     i);
#line 844
    tmp___0 = psiconv_list_get(encoded, (psiconv_u32 )i);
#line 844
    marker = (psiconv_u8 *)tmp___0;
    }
#line 844
    if (! marker) {
#line 845
      goto ERROR2;
    }
    {
#line 846
    psiconv_debug((psiconv_config )config, lev + 2, off, "Marker byte: %02x", (int )*marker);
    }
#line 847
    if ((int )*marker < 128) {
      {
#line 848
      psiconv_debug((psiconv_config )config, lev + 2, off, "Marker: repeat value byte triplet %02x times",
                    (int )*marker + 1);
#line 850
      psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read value byte triplet at %04x",
                       i + 1);
#line 851
      tmp___1 = psiconv_list_get(encoded, (psiconv_u32 )(i + 1));
#line 851
      value0 = (psiconv_u8 *)tmp___1;
      }
#line 851
      if (! value0) {
#line 852
        goto ERROR2;
      }
      {
#line 853
      tmp___2 = psiconv_list_get(encoded, (psiconv_u32 )(i + 2));
#line 853
      value1 = (psiconv_u8 *)tmp___2;
      }
#line 853
      if (! value1) {
#line 854
        goto ERROR2;
      }
      {
#line 855
      tmp___3 = psiconv_list_get(encoded, (psiconv_u32 )(i + 3));
#line 855
      value2 = (psiconv_u8 *)tmp___3;
      }
#line 855
      if (! value2) {
#line 856
        goto ERROR2;
      }
      {
#line 857
      value = (psiconv_u32 )(((int )*value0 + ((int )*value1 << 8)) + ((int )*value2 << 16));
#line 858
      psiconv_debug((psiconv_config )config, lev + 2, off, "Value byte triplet: %06x",
                    value);
#line 859
      psiconv_progress((psiconv_config )config, lev + 2, off, "Adding %02x pixels %06x",
                       (int )*marker + 1, value);
#line 861
      j = 0;
      }
      {
#line 861
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 861
        if (! (j < (int )*marker + 1)) {
#line 861
          goto while_break___0;
        }
        {
#line 862
        res = psiconv_list_add(*decoded, (void const   *)(& value));
        }
#line 862
        if (res) {
#line 863
          goto ERROR2;
        }
#line 861
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 864
      i += 4;
    } else {
      {
#line 866
      psiconv_debug((psiconv_config )config, lev + 2, off, "Marker: %02x value byte triplets follow",
                    256 - (int )*marker);
#line 868
      j = 0;
      }
      {
#line 868
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 868
        if (! (j < 256 - (int )*marker)) {
#line 868
          goto while_break___1;
        }
        {
#line 869
        psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read value byte triplets at %04x",
                         (i + j * 3) + 1);
#line 871
        tmp___4 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 3) + 1));
#line 871
        value0 = (psiconv_u8 *)tmp___4;
        }
#line 871
        if (! value0) {
#line 872
          goto ERROR2;
        }
        {
#line 873
        tmp___5 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 3) + 2));
#line 873
        value1 = (psiconv_u8 *)tmp___5;
        }
#line 873
        if (! value1) {
#line 874
          goto ERROR2;
        }
        {
#line 875
        tmp___6 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 3) + 3));
#line 875
        value2 = (psiconv_u8 *)tmp___6;
        }
#line 875
        if (! value2) {
#line 876
          goto ERROR2;
        }
        {
#line 877
        value = (psiconv_u32 )(((int )*value0 + ((int )*value1 << 8)) + ((int )*value2 << 16));
#line 878
        psiconv_debug((psiconv_config )config, lev + 2, off, "Value: %06x", value);
#line 879
        res = psiconv_list_add(*decoded, (void const   *)(& value));
        }
#line 879
        if (res) {
#line 880
          goto ERROR2;
        }
#line 868
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 882
      i += (256 - (int )*marker) * 3 + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 885
  psiconv_progress((psiconv_config )config, lev, off, "End of RLE24 decoding process");
  }
#line 887
  return (0);
  ERROR2: 
  {
#line 890
  psiconv_list_free(*decoded);
  }
  ERROR1: 
  {
#line 892
  psiconv_error((psiconv_config )config, lev + 1, off, "Decoding of RLE24 failed");
  }
#line 893
  if (! res) {
#line 894
    return (-2);
  } else {
#line 896
    return (res);
  }
}
}
#line 899 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_bytes_to_pixel_data___0(psiconv_config const   config , int lev ,
                                           psiconv_u32 off , psiconv_pixel_bytes const   bytes ,
                                           psiconv_pixel_ints *pixels , int colordepth ,
                                           int xsize , int ysize ) 
{ 
  int res ;
  int ibits ;
  int obits ;
  int x ;
  int y ;
  int bits ;
  psiconv_u8 input ;
  psiconv_u32 nr ;
  psiconv_u32 output ;
  psiconv_u8 *ientry ;
  psiconv_pixel_ints tmp ;
  void *tmp___0 ;

  {
  {
#line 905
  res = 0;
#line 911
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to convert the bytes to pixels");
#line 912
  tmp = psiconv_list_new(sizeof(psiconv_u32 ));
#line 912
  *pixels = tmp;
  }
#line 912
  if (! tmp) {
#line 913
    goto ERROR1;
  }
#line 915
  nr = (psiconv_u32 )0;
#line 916
  y = 0;
  {
#line 916
  while (1) {
    while_continue: /* CIL Label */ ;
#line 916
    if (! (y < ysize)) {
#line 916
      goto while_break;
    }
    {
#line 918
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 918
      if (! (nr % 4U)) {
#line 918
        goto while_break___0;
      }
#line 919
      nr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 920
    input = (psiconv_u8 )0;
#line 921
    ibits = 0;
#line 922
    x = 0;
    {
#line 922
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 922
      if (! (x < xsize)) {
#line 922
        goto while_break___1;
      }
#line 927
      output = (psiconv_u32 )0;
#line 928
      obits = 0;
      {
#line 929
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 929
        if (! (obits < colordepth)) {
#line 929
          goto while_break___2;
        }
#line 930
        if (ibits == 0) {
          {
#line 935
          tmp___0 = psiconv_list_get(bytes, nr);
#line 935
          ientry = (psiconv_u8 *)tmp___0;
          }
#line 935
          if (! ientry) {
#line 936
            goto ERROR2;
          }
#line 940
          input = *ientry;
#line 941
          ibits = 8;
#line 942
          nr ++;
        }
#line 944
        if (ibits + obits > colordepth) {
#line 944
          bits = colordepth - obits;
        } else {
#line 944
          bits = ibits;
        }
#line 945
        output <<= bits;
#line 946
        output |= (unsigned int )((int )input & ((1 << bits) - 1));
#line 947
        input = (psiconv_u8 )((int )input >> bits);
#line 948
        ibits -= bits;
#line 949
        obits += bits;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 954
      res = psiconv_list_add(*pixels, (void const   *)(& output));
      }
#line 954
      if (res) {
#line 955
        goto ERROR2;
      }
#line 922
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 916
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 959
  psiconv_progress((psiconv_config )config, lev, off, "Converting bytes to pixels completed");
  }
#line 961
  return (0);
  ERROR2: 
  {
#line 965
  psiconv_list_free(*pixels);
  }
  ERROR1: 
  {
#line 967
  psiconv_error((psiconv_config )config, lev + 1, off, "Converting bytes to pixels failed");
  }
#line 968
  if (! res) {
#line 969
    return (-2);
  } else {
#line 971
    return (res);
  }
}
}
#line 974 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_pixel_data_to_floats___0(psiconv_config const   config , int lev ,
                                            psiconv_u32 off , psiconv_pixel_ints const   pixels ,
                                            psiconv_pixel_floats_t *floats , int colordepth ,
                                            int color___1 , int redbits , int bluebits ,
                                            int greenbits , psiconv_pixel_floats_t const   palet ) 
{ 
  int res ;
  psiconv_u32 i ;
  psiconv_u32 *pixel ;
  float *tmp ;
  psiconv_u32 tmp___0 ;
  void *tmp___1 ;
  float *tmp___2 ;
  psiconv_u32 tmp___3 ;
  void *tmp___4 ;
  float *tmp___5 ;
  psiconv_u32 tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  float tmp___9 ;
  float tmp___10 ;
  psiconv_u32 tmp___11 ;

  {
  {
#line 982
  res = 0;
#line 986
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to convert pixels to floats");
#line 987
  tmp___0 = psiconv_list_length(pixels);
#line 987
  tmp___1 = malloc((unsigned long )tmp___0 * sizeof(*(floats->red)));
#line 987
  tmp = (float *)tmp___1;
#line 987
  floats->red = tmp;
  }
#line 987
  if (! tmp) {
#line 989
    goto ERROR1;
  }
  {
#line 990
  tmp___3 = psiconv_list_length(pixels);
#line 990
  tmp___4 = malloc((unsigned long )tmp___3 * sizeof(*(floats->green)));
#line 990
  tmp___2 = (float *)tmp___4;
#line 990
  floats->green = tmp___2;
  }
#line 990
  if (! tmp___2) {
#line 992
    goto ERROR2;
  }
  {
#line 993
  tmp___6 = psiconv_list_length(pixels);
#line 993
  tmp___7 = malloc((unsigned long )tmp___6 * sizeof(*(floats->blue)));
#line 993
  tmp___5 = (float *)tmp___7;
#line 993
  floats->blue = tmp___5;
  }
#line 993
  if (! tmp___5) {
#line 995
    goto ERROR3;
  }
  {
#line 996
  floats->length = psiconv_list_length(pixels);
#line 998
  i = (psiconv_u32 )0;
  }
  {
#line 998
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 998
    tmp___11 = psiconv_list_length(pixels);
    }
#line 998
    if (! (i < tmp___11)) {
#line 998
      goto while_break;
    }
    {
#line 999
    tmp___8 = psiconv_list_get(pixels, i);
#line 999
    pixel = (psiconv_u32 *)tmp___8;
    }
#line 999
    if (! pixel) {
#line 1000
      goto ERROR4;
    }
#line 1004
    if (! palet.length) {
#line 1005
      if (color___1) {
#line 1006
        *(floats->blue + i) = (float )(*pixel & (unsigned int )((1 << bluebits) - 1)) / (float )((1 << bluebits) - 1);
#line 1008
        *(floats->green + i) = (float )((*pixel >> bluebits) & (unsigned int )((1 << greenbits) - 1)) / (float )((1 << greenbits) - 1);
#line 1010
        *(floats->red + i) = (float )((*pixel >> (bluebits + greenbits)) & (unsigned int )((1 << redbits) - 1)) / (float )((1 << redbits) - 1);
      } else {
#line 1013
        tmp___10 = (float )*pixel / (float )((1 << colordepth) - 1);
#line 1013
        *(floats->blue + i) = tmp___10;
#line 1013
        tmp___9 = tmp___10;
#line 1013
        *(floats->green + i) = tmp___9;
#line 1013
        *(floats->red + i) = tmp___9;
      }
    } else
#line 1018
    if (*pixel >= (psiconv_u32 )palet.length) {
      {
#line 1019
      psiconv_warn((psiconv_config )config, lev + 2, off, "Invalid palet color found (using color 0x00)");
#line 1021
      *(floats->red + i) = *(palet.red + 0);
#line 1022
      *(floats->green + i) = *(palet.green + 0);
#line 1023
      *(floats->blue + i) = *(palet.blue + 0);
      }
    } else {
#line 1025
      *(floats->red + i) = *(palet.red + *pixel);
#line 1026
      *(floats->green + i) = *(palet.green + *pixel);
#line 1027
      *(floats->blue + i) = *(palet.blue + *pixel);
    }
#line 998
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1035
  psiconv_progress((psiconv_config )config, lev + 1, off, "Finished converting pixels to floats");
  }
#line 1036
  return (0);
  ERROR4: 
  {
#line 1039
  free((void *)floats->blue);
  }
  ERROR3: 
  {
#line 1041
  free((void *)floats->green);
  }
  ERROR2: 
  {
#line 1043
  free((void *)floats->red);
  }
  ERROR1: 
  {
#line 1045
  psiconv_error((psiconv_config )config, lev + 1, off, "Converting pixels to floats failed");
  }
#line 1046
  if (! res) {
#line 1047
    return (-2);
  } else {
#line 1049
    return (res);
  }
}
}
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_common.c"
static int psiconv_write_layout_section___0(psiconv_config const   config , psiconv_buffer buf ,
                                            int lev , psiconv_text_and_layout const   value ,
                                            psiconv_word_styles_section const   styles___1 ,
                                            int with_styles ) ;
#line 166 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_common.c"
static int psiconv_write_layout_section___0(psiconv_config const   config , psiconv_buffer buf ,
                                            int lev , psiconv_text_and_layout const   value ,
                                            psiconv_word_styles_section const   styles___1 ,
                                            int with_styles ) 
{ 
  psiconv_u32 obj_id ;
  psiconv_list paragraph_type_list ;
  psiconv_paragraph_type_list paragraph_type ;
  struct psiconv_paragraph_type_list_s new_type ;
  psiconv_buffer buf_types ;
  psiconv_buffer buf_elements ;
  psiconv_buffer buf_inlines ;
  psiconv_buffer buf_objects ;
  psiconv_paragraph paragraph___3 ;
  psiconv_in_line_layout in_line ;
  psiconv_word_style style___1 ;
  psiconv_character_layout para_charlayout ;
  int i ;
  int j ;
  int para_type ;
  int nr_of_inlines ;
  int res ;
  int ptl_length ;
  int pel_length ;
  int thislen ;
  int paralen ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  psiconv_u32 tmp___2 ;
  psiconv_u32 tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  psiconv_u32 tmp___8 ;
  psiconv_u32 tmp___9 ;
  void *tmp___10 ;
  psiconv_u32 tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  psiconv_u32 tmp___15 ;
  psiconv_u32 tmp___16 ;
  psiconv_u32 tmp___17 ;
  psiconv_u32 tmp___18 ;
  psiconv_u32 tmp___19 ;
  psiconv_u32 tmp___20 ;
  psiconv_u32 tmp___21 ;
  int tmp___22 ;

  {
  {
#line 185
  in_line = (psiconv_in_line_layout )((void *)0);
#line 188
  nr_of_inlines = 0;
#line 190
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing layout section");
  }
#line 191
  if (! value) {
    {
#line 192
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null text section");
#line 193
    res = -4;
    }
#line 194
    goto ERROR1;
  }
  {
#line 197
  paragraph_type_list = psiconv_list_new(sizeof(new_type));
  }
#line 197
  if (! paragraph_type_list) {
    {
#line 198
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 199
    res = -2;
    }
#line 200
    goto ERROR1;
  }
  {
#line 203
  buf_types = psiconv_buffer_new();
  }
#line 203
  if (! buf_types) {
    {
#line 204
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 205
    res = -2;
    }
#line 206
    goto ERROR2;
  }
  {
#line 209
  buf_elements = psiconv_buffer_new();
  }
#line 209
  if (! buf_elements) {
    {
#line 210
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 211
    res = -2;
    }
#line 212
    goto ERROR3;
  }
  {
#line 215
  buf_inlines = psiconv_buffer_new();
  }
#line 215
  if (! buf_inlines) {
    {
#line 216
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 217
    res = -2;
    }
#line 218
    goto ERROR4;
  }
  {
#line 221
  buf_objects = psiconv_buffer_new();
  }
#line 221
  if (! buf_objects) {
    {
#line 222
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 223
    res = -2;
    }
#line 224
    goto ERROR5;
  }
#line 227
  i = 0;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 227
    tmp___18 = psiconv_list_length(value);
    }
#line 227
    if (! ((psiconv_u32 )i < tmp___18)) {
#line 227
      goto while_break;
    }
    {
#line 228
    tmp = psiconv_list_get(value, (psiconv_u32 )i);
#line 228
    paragraph___3 = (psiconv_paragraph )tmp;
    }
#line 228
    if (! paragraph___3) {
      {
#line 229
      psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Data structure corruption");
#line 230
      res = -2;
      }
#line 231
      goto ERROR6;
    }
    {
#line 233
    tmp___0 = psiconv_unicode_strlen((psiconv_ucs2 const   *)paragraph___3->text);
#line 233
    res = psiconv_write_u32(config, buf_elements, lev + 1, (psiconv_u32 const   )(tmp___0 + 1));
    }
#line 233
    if (res) {
#line 235
      goto ERROR6;
    }
    {
#line 238
    tmp___2 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
    }
#line 238
    if (tmp___2 == 1U) {
      {
#line 239
      tmp___1 = psiconv_list_get((psiconv_list const   )paragraph___3->in_lines, (psiconv_u32 )0);
#line 239
      in_line = (psiconv_in_line_layout )tmp___1;
      }
#line 239
      if (! in_line) {
        {
#line 240
        psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Data structure corruption");
#line 241
        res = -2;
        }
#line 242
        goto ERROR6;
      }
    }
    {
#line 245
    tmp___16 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
    }
#line 245
    if (tmp___16 > 1U) {
#line 245
      goto _L;
    } else {
      {
#line 245
      tmp___17 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
      }
#line 245
      if (tmp___17 == 1U) {
#line 245
        if ((unsigned long )in_line->object != (unsigned long )((void *)0)) {
          _L: /* CIL Label */ 
          {
#line 250
          res = psiconv_write_u8(config, buf_elements, lev + 1, (psiconv_u8 const   )0);
          }
#line 250
          if (res) {
#line 251
            goto ERROR6;
          }
          {
#line 252
          style___1 = psiconv_get_style((psiconv_word_styles_section )styles___1,
                                        (int )paragraph___3->base_style);
          }
#line 252
          if (! style___1) {
            {
#line 253
            psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Unknown style");
#line 254
            res = -4;
            }
#line 255
            goto ERROR6;
          }
          {
#line 257
          res = psiconv_write_paragraph_layout_list(config, buf_elements, lev + 1,
                                                    (psiconv_paragraph_layout const   )paragraph___3->base_paragraph,
                                                    (psiconv_paragraph_layout const   )style___1->paragraph);
          }
#line 257
          if (res) {
#line 260
            goto ERROR6;
          }
#line 261
          if (with_styles) {
            {
#line 262
            res = psiconv_write_u8(config, buf_elements, lev + 1, (psiconv_u8 const   )paragraph___3->base_style);
            }
#line 262
            if (res) {
#line 263
              goto ERROR6;
            }
          }
          {
#line 264
          tmp___3 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
#line 264
          res = psiconv_write_u32(config, buf_elements, lev + 1, (psiconv_u32 const   )tmp___3);
          }
#line 264
          if (res) {
#line 266
            goto ERROR6;
          }
#line 269
          paralen = 0;
#line 270
          j = 0;
          {
#line 270
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 270
            tmp___9 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
            }
#line 270
            if (! ((psiconv_u32 )j < tmp___9)) {
#line 270
              goto while_break___0;
            }
            {
#line 271
            nr_of_inlines ++;
#line 272
            tmp___4 = psiconv_list_get((psiconv_list const   )paragraph___3->in_lines,
                                       (psiconv_u32 )j);
#line 272
            in_line = (psiconv_in_line_layout )tmp___4;
            }
#line 272
            if (! in_line) {
              {
#line 273
              psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Data structure corruption");
#line 274
              res = -2;
              }
#line 275
              goto ERROR6;
            }
#line 277
            if (in_line->object) {
#line 277
              tmp___5 = 1;
            } else {
#line 277
              tmp___5 = 0;
            }
            {
#line 277
            res = psiconv_write_u8(config, buf_inlines, lev + 1, (psiconv_u8 const   )tmp___5);
            }
#line 277
            if (res) {
#line 278
              goto ERROR6;
            }
            {
#line 279
            thislen = in_line->length;
#line 280
            paralen += thislen;
#line 283
            tmp___8 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
            }
#line 283
            if ((psiconv_u32 )j == tmp___8 - 1U) {
              {
#line 284
              tmp___6 = psiconv_unicode_strlen((psiconv_ucs2 const   *)paragraph___3->text);
              }
#line 284
              if (paralen > tmp___6 + 1) {
                {
#line 285
                psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Inline formatting data length and line length are inconsistent");
#line 286
                res = -4;
                }
#line 287
                goto ERROR6;
              }
              {
#line 289
              tmp___7 = psiconv_unicode_strlen((psiconv_ucs2 const   *)paragraph___3->text);
#line 289
              thislen += (tmp___7 + 1) - paralen;
              }
            }
            {
#line 291
            res = psiconv_write_u32(config, buf_inlines, lev + 1, (psiconv_u32 const   )thislen);
            }
#line 291
            if (res) {
#line 292
              goto ERROR6;
            }
            {
#line 293
            res = psiconv_write_character_layout_list(config, buf_inlines, lev + 1,
                                                      (psiconv_character_layout const   )in_line->layout,
                                                      (psiconv_character_layout const   )style___1->character);
            }
#line 293
            if (res) {
#line 296
              goto ERROR6;
            }
#line 297
            if (in_line->object) {
              {
#line 298
              res = psiconv_write_u32(config, buf_inlines, lev + 1, (psiconv_u32 const   )268435537);
              }
#line 298
              if (res) {
#line 299
                goto ERROR6;
              }
              {
#line 300
              obj_id = psiconv_buffer_unique_id();
#line 301
              res = psiconv_buffer_add_reference(buf_inlines, (int )obj_id);
              }
#line 301
              if (res) {
                {
#line 302
                psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
                }
#line 303
                goto ERROR6;
              }
              {
#line 305
              res = psiconv_buffer_add_target(buf_objects, (int )obj_id);
              }
#line 305
              if (res) {
                {
#line 306
                psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
                }
#line 307
                goto ERROR6;
              }
              {
#line 309
              res = psiconv_write_embedded_object_section(config, buf_objects, lev + 1,
                                                          (psiconv_embedded_object_section const   )in_line->object);
              }
#line 309
              if (res) {
#line 311
                goto ERROR6;
              }
              {
#line 312
              res = psiconv_write_length(config, buf_inlines, lev + 1, (psiconv_length_t const   )in_line->object_width);
              }
#line 312
              if (res) {
#line 313
                goto ERROR6;
              }
              {
#line 314
              res = psiconv_write_length(config, buf_inlines, lev + 1, (psiconv_length_t const   )in_line->object_height);
              }
#line 314
              if (res) {
#line 315
                goto ERROR6;
              }
            }
#line 270
            j ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
#line 245
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 320
        para_type = 0;
#line 322
        tmp___11 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
        }
#line 322
        if (tmp___11 == 0U) {
#line 323
          para_charlayout = paragraph___3->base_character;
        } else {
          {
#line 325
          tmp___10 = psiconv_list_get((psiconv_list const   )paragraph___3->in_lines,
                                      (psiconv_u32 )0);
#line 325
          in_line = (psiconv_in_line_layout )tmp___10;
          }
#line 325
          if (! in_line) {
            {
#line 326
            psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Data structure corruption");
#line 327
            res = -2;
            }
#line 328
            goto ERROR6;
          }
#line 330
          para_charlayout = in_line->layout;
        }
#line 332
        j = 0;
        {
#line 332
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 332
          tmp___15 = psiconv_list_length((psiconv_list const   )paragraph_type_list);
          }
#line 332
          if (! ((psiconv_u32 )j < tmp___15)) {
#line 332
            goto while_break___1;
          }
          {
#line 333
          tmp___12 = psiconv_list_get((psiconv_list const   )paragraph_type_list,
                                      (psiconv_u32 )j);
#line 333
          paragraph_type = (psiconv_paragraph_type_list )tmp___12;
          }
#line 333
          if (! paragraph_type) {
            {
#line 334
            psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Data structure corruption");
#line 335
            res = -2;
            }
#line 336
            goto ERROR6;
          }
#line 338
          if ((int )paragraph___3->base_style == (int )paragraph_type->style) {
            {
#line 338
            tmp___13 = psiconv_compare_character_layout((psiconv_character_layout const   )para_charlayout,
                                                        (psiconv_character_layout const   )paragraph_type->character);
            }
#line 338
            if (! tmp___13) {
              {
#line 338
              tmp___14 = psiconv_compare_paragraph_layout((psiconv_paragraph_layout const   )paragraph___3->base_paragraph,
                                                          (psiconv_paragraph_layout const   )paragraph_type->paragraph);
              }
#line 338
              if (! tmp___14) {
#line 343
                para_type = (int )paragraph_type->nr;
#line 344
                goto while_break___1;
              }
            }
          }
#line 332
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 347
        if (! para_type) {
          {
#line 349
          new_type.nr = (psiconv_u8 )(j + 1);
#line 349
          para_type = (int )new_type.nr;
#line 351
          new_type.paragraph = paragraph___3->base_paragraph;
#line 352
          new_type.character = para_charlayout;
#line 353
          new_type.style = (psiconv_u8 )paragraph___3->base_style;
#line 354
          paragraph_type = & new_type;
#line 355
          res = psiconv_list_add(paragraph_type_list, (void const   *)paragraph_type);
          }
#line 355
          if (res) {
            {
#line 356
            psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
            }
#line 357
            goto ERROR6;
          }
          {
#line 359
          res = psiconv_write_u32(config, buf_types, lev + 1, (psiconv_u32 const   )paragraph_type->nr);
          }
#line 359
          if (res) {
#line 360
            goto ERROR6;
          }
          {
#line 361
          style___1 = psiconv_get_style((psiconv_word_styles_section )styles___1,
                                        (int )paragraph_type->style);
          }
#line 361
          if (! style___1) {
            {
#line 362
            psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Unknown style");
#line 363
            res = -4;
            }
#line 364
            goto ERROR6;
          }
          {
#line 366
          res = psiconv_write_paragraph_layout_list(config, buf_types, lev + 1, (psiconv_paragraph_layout const   )paragraph_type->paragraph,
                                                    (psiconv_paragraph_layout const   )style___1->paragraph);
          }
#line 366
          if (res) {
#line 368
            goto ERROR6;
          }
#line 369
          if (with_styles) {
            {
#line 370
            res = psiconv_write_u8(config, buf_types, lev + 1, (psiconv_u8 const   )paragraph_type->style);
            }
#line 370
            if (res) {
#line 371
              goto ERROR6;
            }
          }
          {
#line 372
          res = psiconv_write_character_layout_list(config, buf_types, lev + 1, (psiconv_character_layout const   )paragraph_type->character,
                                                    (psiconv_character_layout const   )style___1->character);
          }
#line 372
          if (res) {
#line 374
            goto ERROR6;
          }
        }
        {
#line 376
        res = psiconv_write_u8(config, buf_elements, lev + 1, (psiconv_u8 const   )para_type);
        }
#line 376
        if (res) {
#line 377
          goto ERROR6;
        }
      }
    }
#line 227
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 382
  tmp___21 = psiconv_list_length(value);
  }
#line 382
  if (tmp___21) {
    {
#line 400
    tmp___19 = psiconv_list_length(value);
#line 400
    pel_length = (int )tmp___19;
#line 401
    tmp___20 = psiconv_list_length((psiconv_list const   )paragraph_type_list);
#line 401
    ptl_length = (int )tmp___20;
    }
  } else {
    {
#line 383
    res = psiconv_write_u32(config, buf_types, lev + 1, (psiconv_u32 const   )1);
    }
#line 383
    if (res) {
#line 384
      goto ERROR6;
    }
    {
#line 385
    res = psiconv_write_u32(config, buf_types, lev + 1, (psiconv_u32 const   )0);
    }
#line 385
    if (res) {
#line 386
      goto ERROR6;
    }
#line 387
    if (with_styles) {
      {
#line 388
      res = psiconv_write_u8(config, buf_types, lev + 1, (psiconv_u8 const   )0);
      }
#line 388
      if (res) {
#line 389
        goto ERROR6;
      }
    }
    {
#line 390
    res = psiconv_write_u32(config, buf_types, lev + 1, (psiconv_u32 const   )0);
    }
#line 390
    if (res) {
#line 391
      goto ERROR6;
    }
    {
#line 393
    res = psiconv_write_u32(config, buf_elements, lev + 1, (psiconv_u32 const   )1);
    }
#line 393
    if (res) {
#line 394
      goto ERROR6;
    }
    {
#line 395
    res = psiconv_write_u8(config, buf_elements, lev + 1, (psiconv_u8 const   )1);
    }
#line 395
    if (res) {
#line 396
      goto ERROR6;
    }
#line 397
    pel_length = 1;
#line 398
    ptl_length = 1;
  }
#line 405
  if (with_styles) {
#line 405
    tmp___22 = 1;
  } else {
#line 405
    tmp___22 = 0;
  }
  {
#line 405
  res = psiconv_write_u16(config, buf, lev + 1, (psiconv_u16 const   )tmp___22);
  }
#line 405
  if (res) {
#line 406
    goto ERROR6;
  }
  {
#line 407
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )ptl_length);
  }
#line 407
  if (res) {
#line 408
    goto ERROR6;
  }
  {
#line 409
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )buf_types);
  }
#line 409
  if (res) {
    {
#line 410
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 411
    goto ERROR6;
  }
  {
#line 413
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )pel_length);
  }
#line 413
  if (res) {
#line 414
    goto ERROR6;
  }
  {
#line 415
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )buf_elements);
  }
#line 415
  if (res) {
    {
#line 416
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 417
    goto ERROR6;
  }
  {
#line 419
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )nr_of_inlines);
  }
#line 419
  if (res) {
#line 420
    goto ERROR6;
  }
  {
#line 421
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )buf_inlines);
  }
#line 421
  if (res) {
    {
#line 422
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 423
    goto ERROR6;
  }
  {
#line 425
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )buf_objects);
  }
#line 425
  if (res) {
    {
#line 426
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 427
    goto ERROR6;
  }
  ERROR6: 
  {
#line 431
  psiconv_buffer_free(buf_objects);
  }
  ERROR5: 
  {
#line 433
  psiconv_buffer_free(buf_inlines);
  }
  ERROR4: 
  {
#line 435
  psiconv_buffer_free(buf_elements);
  }
  ERROR3: 
  {
#line 437
  psiconv_buffer_free(buf_types);
  }
  ERROR2: 
  {
#line 439
  psiconv_list_free(paragraph_type_list);
  }
  ERROR1: 
#line 441
  if (res) {
    {
#line 442
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of layout section failed");
    }
  } else {
    {
#line 444
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of layout section");
    }
  }
#line 445
  return (res);
}
}
#line 36 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_driver.c"
static psiconv_bool_t applid_matches___0(psiconv_string_t found , char const   *sought ) 
{ 
  int i ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 40
  tmp = psiconv_unicode_strlen((psiconv_ucs2 const   *)found);
#line 40
  tmp___0 = strlen(sought);
  }
#line 40
  if ((size_t )tmp != tmp___0) {
#line 41
    return ((psiconv_bool_t )0);
  }
#line 42
  i = 0;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 42
    tmp___1 = strlen(sought);
    }
#line 42
    if (! ((size_t )i < tmp___1)) {
#line 42
      goto while_break;
    }
#line 43
    if ((int )*(found + i) != (int )*(sought + i)) {
#line 43
      if ((int const   )*(sought + i) < 97) {
#line 46
        return ((psiconv_bool_t )0);
      } else
#line 43
      if ((int const   )*(sought + i) > 122) {
#line 46
        return ((psiconv_bool_t )0);
      } else
#line 43
      if ((int )*(found + i) != (int )(((int const   )*(sought + i) + 65) - 97)) {
#line 46
        return ((psiconv_bool_t )0);
      }
    }
#line 42
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return ((psiconv_bool_t )1);
}
}
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_collect_pixel_data___0(psiconv_pixel_ints *pixels , int xsize ,
                                          int ysize , psiconv_pixel_floats_t const   data ,
                                          int colordepth , int color___1 , int redbits ,
                                          int bluebits , int greenbits , psiconv_pixel_floats_t const   palet ) ;
#line 39
static int psiconv_pixel_data_to_bytes___0(psiconv_config const   config , int lev ,
                                           psiconv_pixel_bytes *bytes , int xsize ,
                                           int ysize , psiconv_pixel_ints const   pixels ,
                                           int colordepth ) ;
#line 43
static int psiconv_encode_rle8___0(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                   psiconv_pixel_bytes *encoded_bytes ) ;
#line 46
static int psiconv_encode_rle12___0(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                    psiconv_pixel_bytes *encoded_bytes ) ;
#line 49
static int psiconv_encode_rle16___0(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                    psiconv_pixel_bytes *encoded_bytes ) ;
#line 52
static int psiconv_encode_rle24___0(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                    psiconv_pixel_bytes *encoded_bytes ) ;
#line 240 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_collect_pixel_data___0(psiconv_pixel_ints *pixels , int xsize ,
                                          int ysize , psiconv_pixel_floats_t const   data ,
                                          int colordepth , int color___1 , int redbits ,
                                          int bluebits , int greenbits , psiconv_pixel_floats_t const   palet ) 
{ 
  int res ;
  int x ;
  int y ;
  int i ;
  psiconv_u32 index___0 ;
  psiconv_u32 pixel ;
  float p_red ;
  float p_green ;
  float p_blue ;
  float dist ;
  float new_dist ;
  psiconv_pixel_ints tmp ;

  {
  {
#line 250
  tmp = psiconv_list_new(sizeof(psiconv_u32 ));
#line 250
  *pixels = tmp;
  }
#line 250
  if (! tmp) {
#line 251
    res = -2;
#line 252
    goto ERROR1;
  }
#line 255
  y = 0;
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! (y < ysize)) {
#line 255
      goto while_break;
    }
#line 256
    x = 0;
    {
#line 256
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 256
      if (! (x < xsize)) {
#line 256
        goto while_break___0;
      }
#line 257
      index___0 = (psiconv_u32 )(y * xsize + x);
#line 258
      p_red = *(data.red + index___0);
#line 259
      p_green = *(data.green + index___0);
#line 260
      p_blue = *(data.blue + index___0);
#line 261
      if (! palet.length) {
#line 262
        if (color___1) {
#line 263
          pixel = (((psiconv_u32 )((double )(p_red * (float )(1 << redbits)) + 0.5) << (greenbits + bluebits)) + ((psiconv_u32 )((double )(p_green * (float )(1 << greenbits)) + 0.5) << bluebits)) + (psiconv_u32 )((double )(p_blue * (float )(1 << bluebits)) + 0.5);
        } else {
#line 269
          pixel = (psiconv_u32 )(((0.212671 * (double )p_red + 0.715160 * (double )p_green) + 0.072169 * (double )p_blue) * ((double )(1 << colordepth) * 0.999));
        }
      } else {
#line 271
        dist = (float )4;
#line 272
        pixel = (psiconv_u32 )-1;
#line 273
        i = 0;
        {
#line 273
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 273
          if (! ((psiconv_u32 const   )i < palet.length)) {
#line 273
            goto while_break___1;
          }
#line 274
          new_dist = ((p_red - *(palet.red + i)) * (p_red - *(palet.red + i)) + (p_green - *(palet.green + i)) * (p_green - *(palet.green + i))) + (p_blue - *(palet.blue + i)) * (p_blue - *(palet.blue + i));
#line 277
          if (new_dist < dist) {
#line 278
            pixel = (psiconv_u32 )i;
#line 279
            dist = new_dist;
          }
#line 273
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 283
      res = psiconv_list_add(*pixels, (void const   *)(& pixel));
      }
#line 283
      if (res) {
#line 284
        goto ERROR2;
      }
#line 256
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 255
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  return (0);
  ERROR2: 
  {
#line 290
  psiconv_list_free(*pixels);
  }
  ERROR1: 
#line 292
  return (res);
}
}
#line 295 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_pixel_data_to_bytes___0(psiconv_config const   config , int lev ,
                                           psiconv_pixel_bytes *bytes , int xsize ,
                                           int ysize , psiconv_pixel_ints const   pixels ,
                                           int colordepth ) 
{ 
  int res ;
  int x ;
  int y ;
  psiconv_u32 inputdata ;
  psiconv_u8 outputbyte ;
  psiconv_u32 *pixelptr ;
  int inputbitsleft ;
  int outputbitnr ;
  int bitsfit ;
  int outputbytenr ;
  psiconv_u32 tmp ;
  psiconv_pixel_bytes tmp___0 ;
  void *tmp___1 ;

  {
#line 309
  if (! bytes) {
    {
#line 310
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "NULL pixel data");
#line 311
    res = -4;
    }
#line 312
    goto ERROR1;
  }
#line 314
  if (! pixels) {
    {
#line 315
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "NULL pixel data");
#line 316
    res = -4;
    }
#line 317
    goto ERROR1;
  }
  {
#line 319
  tmp = psiconv_list_length(pixels);
  }
#line 319
  if (tmp != (psiconv_u32 )(xsize * ysize)) {
    {
#line 320
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Pixel number is not correct");
#line 321
    res = -4;
    }
#line 322
    goto ERROR1;
  }
  {
#line 325
  tmp___0 = psiconv_list_new(sizeof(psiconv_u8 ));
#line 325
  *bytes = tmp___0;
  }
#line 325
  if (! tmp___0) {
#line 326
    res = -2;
#line 327
    goto ERROR1;
  }
#line 331
  outputbitnr = 0;
#line 332
  outputbyte = (psiconv_u8 )0;
#line 333
  y = 0;
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 333
    if (! (y < ysize)) {
#line 333
      goto while_break;
    }
#line 334
    outputbytenr = 0;
#line 335
    x = 0;
    {
#line 335
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 335
      if (! (x < xsize)) {
#line 335
        goto while_break___0;
      }
      {
#line 336
      tmp___1 = psiconv_list_get(pixels, (psiconv_u32 )(y * xsize + x));
#line 336
      pixelptr = (psiconv_u32 *)tmp___1;
      }
#line 336
      if (! pixelptr) {
        {
#line 337
        psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Data structure corruption");
#line 338
        res = -2;
        }
#line 339
        goto ERROR2;
      }
#line 341
      inputbitsleft = colordepth;
#line 342
      inputdata = *pixelptr;
      {
#line 343
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 343
        if (! inputbitsleft) {
#line 343
          goto while_break___1;
        }
#line 344
        if (inputbitsleft + outputbitnr <= 8) {
#line 344
          bitsfit = inputbitsleft;
        } else {
#line 344
          bitsfit = 8 - outputbitnr;
        }
#line 345
        outputbyte = (psiconv_u8 )((unsigned int )outputbyte | ((inputdata & (unsigned int )((1 << bitsfit) - 1)) << outputbitnr));
#line 346
        inputdata >>= bitsfit;
#line 347
        inputbitsleft -= bitsfit;
#line 348
        outputbitnr += bitsfit;
#line 349
        if (outputbitnr == 8) {
          {
#line 350
          res = psiconv_list_add(*bytes, (void const   *)(& outputbyte));
          }
#line 350
          if (res) {
#line 351
            goto ERROR2;
          }
#line 352
          outputbitnr = 0;
#line 353
          outputbyte = (psiconv_u8 )0;
#line 354
          outputbytenr ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 335
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 359
    if (outputbitnr != 0) {
      {
#line 360
      res = psiconv_list_add(*bytes, (void const   *)(& outputbyte));
      }
#line 360
      if (res) {
#line 361
        goto ERROR2;
      }
#line 362
      outputbitnr = 0;
#line 363
      outputbyte = (psiconv_u8 )0;
#line 364
      outputbytenr ++;
    }
    {
#line 367
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 367
      if (! (outputbytenr % 4)) {
#line 367
        goto while_break___2;
      }
      {
#line 368
      res = psiconv_list_add(*bytes, (void const   *)(& outputbyte));
      }
#line 368
      if (res) {
#line 369
        goto ERROR2;
      }
#line 370
      outputbytenr ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 333
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return (0);
  ERROR2: 
  {
#line 377
  psiconv_list_free(*bytes);
  }
  ERROR1: 
#line 379
  return (res);
}
}
#line 386 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_encode_rle8___0(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                   psiconv_pixel_bytes *encoded_bytes ) 
{ 
  int res ;
  int i ;
  int j ;
  int len ;
  psiconv_u8 *entry ;
  psiconv_u8 *next ;
  psiconv_u8 temp ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  psiconv_u32 tmp___3 ;
  void *tmp___4 ;
  psiconv_u32 tmp___5 ;
  void *tmp___6 ;
  psiconv_u32 tmp___7 ;
  psiconv_u32 tmp___8 ;

  {
  {
#line 394
  tmp = psiconv_list_new(sizeof(*entry));
#line 394
  *encoded_bytes = tmp;
  }
#line 394
  if (! tmp) {
#line 395
    res = -2;
#line 396
    goto ERROR1;
  }
#line 399
  i = 0;
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 399
    tmp___8 = psiconv_list_length(plain_bytes);
    }
#line 399
    if (! ((psiconv_u32 )i < tmp___8)) {
#line 399
      goto while_break;
    }
    {
#line 400
    tmp___0 = psiconv_list_get(plain_bytes, (psiconv_u32 )i);
#line 400
    entry = (psiconv_u8 *)tmp___0;
    }
#line 400
    if (! entry) {
#line 401
      res = -2;
#line 402
      goto ERROR2;
    }
    {
#line 404
    tmp___1 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 1));
#line 404
    next = (psiconv_u8 *)tmp___1;
    }
#line 404
    if (! next) {
#line 405
      res = -2;
#line 406
      goto ERROR2;
    }
    {
#line 408
    tmp___7 = psiconv_list_length(plain_bytes);
    }
#line 408
    if ((psiconv_u32 )i == tmp___7 - 2U) {
      {
#line 409
      temp = (psiconv_u8 )254;
#line 410
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 410
      if (res) {
#line 411
        goto ERROR2;
      }
      {
#line 412
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry);
      }
#line 412
      if (res) {
#line 413
        goto ERROR2;
      }
      {
#line 414
      res = psiconv_list_add(*encoded_bytes, (void const   *)next);
      }
#line 414
      if (res) {
#line 415
        goto ERROR2;
      }
#line 416
      i += 2;
    } else
#line 417
    if ((int )*next == (int )*entry) {
#line 418
      len = 1;
      {
#line 419
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 419
        if ((int )*next == (int )*entry) {
          {
#line 419
          tmp___3 = psiconv_list_length(plain_bytes);
          }
#line 419
          if ((psiconv_u32 )((i + len) + 2) < tmp___3) {
#line 419
            if (! (len < 128)) {
#line 419
              goto while_break___0;
            }
          } else {
#line 419
            goto while_break___0;
          }
        } else {
#line 419
          goto while_break___0;
        }
        {
#line 422
        len ++;
#line 423
        tmp___2 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len));
#line 423
        next = (psiconv_u8 *)tmp___2;
        }
#line 423
        if (! next) {
#line 424
          res = -2;
#line 425
          goto ERROR2;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 428
      temp = (psiconv_u8 )(len - 1);
#line 429
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 429
      if (res) {
#line 430
        goto ERROR2;
      }
      {
#line 431
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry);
      }
#line 431
      if (res) {
#line 432
        goto ERROR2;
      }
#line 433
      i += len;
    } else {
#line 435
      len = 1;
      {
#line 436
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 436
        if ((int )*next != (int )*entry) {
          {
#line 436
          tmp___5 = psiconv_list_length(plain_bytes);
          }
#line 436
          if ((psiconv_u32 )((i + len) + 1) < tmp___5) {
#line 436
            if (! (len < 128)) {
#line 436
              goto while_break___1;
            }
          } else {
#line 436
            goto while_break___1;
          }
        } else {
#line 436
          goto while_break___1;
        }
        {
#line 439
        len ++;
#line 440
        entry = next;
#line 441
        tmp___4 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len));
#line 441
        next = (psiconv_u8 *)tmp___4;
        }
#line 441
        if (! next) {
#line 442
          res = -2;
#line 443
          goto ERROR2;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 446
      len --;
#line 447
      temp = (psiconv_u8 )(256 - len);
#line 448
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 448
      if (res) {
#line 449
        goto ERROR2;
      }
#line 450
      j = 0;
      {
#line 450
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 450
        if (! (j < len)) {
#line 450
          goto while_break___2;
        }
        {
#line 451
        tmp___6 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + j));
#line 451
        next = (psiconv_u8 *)tmp___6;
        }
#line 451
        if (! next) {
#line 452
          res = -2;
#line 453
          goto ERROR2;
        }
        {
#line 455
        res = psiconv_list_add(*encoded_bytes, (void const   *)next);
        }
#line 455
        if (res) {
#line 456
          goto ERROR2;
        }
#line 450
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 458
      i += len;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 461
  return (0);
  ERROR2: 
  {
#line 464
  psiconv_list_free(*encoded_bytes);
  }
  ERROR1: 
#line 466
  return (res);
}
}
#line 472 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_encode_rle12___0(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                    psiconv_pixel_bytes *encoded_bytes ) 
{ 
  psiconv_word_data data ;
  int res ;
  int i ;
  int len ;
  int location ;
  psiconv_u16 *word_entry ;
  psiconv_u16 *word_next ;
  psiconv_u16 word_data ;
  psiconv_u8 byte_temp ;
  psiconv_u8 *byte_entry ;
  void *tmp ;
  psiconv_u32 tmp___0 ;
  psiconv_pixel_bytes tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  psiconv_u32 tmp___6 ;
  void *tmp___7 ;
  psiconv_u32 tmp___8 ;
  int tmp___9 ;
  psiconv_u32 tmp___10 ;

  {
  {
#line 486
  data = psiconv_list_new(sizeof(psiconv_u16 ));
  }
#line 486
  if (! data) {
#line 487
    res = -2;
#line 488
    goto ERROR1;
  }
#line 491
  i = 0;
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 491
    tmp___0 = psiconv_list_length(plain_bytes);
    }
#line 491
    if (! ((psiconv_u32 )i < tmp___0)) {
#line 491
      goto while_break;
    }
    {
#line 492
    tmp = psiconv_list_get(plain_bytes, (psiconv_u32 )i);
#line 492
    byte_entry = (psiconv_u8 *)tmp;
    }
#line 492
    if (! byte_entry) {
#line 493
      res = -2;
#line 494
      goto ERROR2;
    }
#line 496
    location = 0;
#line 497
    if (location == 0) {
#line 498
      word_data = (psiconv_u16 )*byte_entry;
#line 499
      location ++;
    } else
#line 500
    if (location == 1) {
      {
#line 501
      word_data = (psiconv_u16 )(((int )word_data << 4) + ((int )*byte_entry & 15));
#line 502
      res = psiconv_list_add(data, (void const   *)(& word_data));
      }
#line 502
      if (res) {
#line 503
        goto ERROR2;
      }
#line 504
      word_data = (psiconv_u16 )((int )*byte_entry >> 4);
#line 505
      location ++;
    } else {
      {
#line 507
      word_data = (psiconv_u16 )(((int )word_data << 8) + (int )*byte_entry);
#line 508
      res = psiconv_list_add(data, (void const   *)(& word_data));
      }
#line 508
      if (res) {
#line 509
        goto ERROR2;
      }
#line 510
      location = 0;
    }
#line 491
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 514
  tmp___1 = psiconv_list_new(sizeof(psiconv_u8 ));
#line 514
  *encoded_bytes = tmp___1;
  }
#line 514
  if (! tmp___1) {
#line 515
    res = -2;
#line 516
    goto ERROR2;
  }
#line 519
  i = 0;
  {
#line 519
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 519
    tmp___10 = psiconv_list_length((psiconv_list const   )data);
    }
#line 519
    if (! ((psiconv_u32 )i < tmp___10)) {
#line 519
      goto while_break___0;
    }
    {
#line 520
    tmp___2 = psiconv_list_get((psiconv_list const   )data, (psiconv_u32 )i);
#line 520
    word_entry = (psiconv_u16 *)tmp___2;
    }
#line 520
    if (! word_entry) {
#line 521
      res = -2;
#line 522
      goto ERROR3;
    }
    {
#line 525
    tmp___3 = psiconv_list_get((psiconv_list const   )data, (psiconv_u32 )(i + 1));
#line 525
    word_next = (psiconv_u16 *)tmp___3;
    }
#line 525
    if (! word_next) {
#line 526
      res = -2;
#line 527
      goto ERROR3;
    }
    {
#line 530
    tmp___6 = psiconv_list_length((psiconv_list const   )data);
    }
#line 530
    if ((psiconv_u32 )i == tmp___6 - 2U) {
#line 531
      if (*word_entry) {
#line 531
        tmp___4 = 1;
      } else {
#line 531
        tmp___4 = 0;
      }
      {
#line 531
      byte_temp = (psiconv_u8 )tmp___4;
#line 532
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
      }
#line 532
      if (res) {
#line 533
        goto ERROR3;
      }
      {
#line 534
      byte_temp = (psiconv_u8 )((int )*word_entry >> 8);
#line 535
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
      }
#line 535
      if (res) {
#line 536
        goto ERROR3;
      }
#line 537
      if (*word_next) {
#line 537
        tmp___5 = 1;
      } else {
#line 537
        tmp___5 = 0;
      }
      {
#line 537
      byte_temp = (psiconv_u8 )tmp___5;
#line 538
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
      }
#line 538
      if (res) {
#line 539
        goto ERROR3;
      }
      {
#line 540
      byte_temp = (psiconv_u8 )((int )*word_next >> 8);
#line 541
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
      }
#line 541
      if (res) {
#line 542
        goto ERROR3;
      }
#line 543
      i += 2;
    }
#line 546
    len = 0;
    {
#line 547
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 547
      if ((int )*word_entry == (int )*word_next) {
#line 547
        if (len < 16) {
          {
#line 547
          tmp___8 = psiconv_list_length((psiconv_list const   )data);
          }
#line 547
          if (! ((psiconv_u32 )((i + len) + 1) < tmp___8)) {
#line 547
            goto while_break___1;
          }
        } else {
#line 547
          goto while_break___1;
        }
      } else {
#line 547
        goto while_break___1;
      }
      {
#line 549
      len ++;
#line 550
      tmp___7 = psiconv_list_get((psiconv_list const   )data, (psiconv_u32 )(i + len));
#line 550
      word_next = (psiconv_u16 *)tmp___7;
      }
#line 550
      if (! word_next) {
#line 551
        res = -2;
#line 552
        goto ERROR3;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 556
    if (*word_entry) {
#line 556
      tmp___9 = 1;
    } else {
#line 556
      tmp___9 = 0;
    }
    {
#line 556
    byte_temp = (psiconv_u8 )tmp___9;
#line 557
    res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
    }
#line 557
    if (res) {
#line 558
      goto ERROR3;
    }
    {
#line 559
    byte_temp = (psiconv_u8 )(((int )*word_entry >> 8) + ((len - 1) << 4));
#line 560
    res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
    }
#line 560
    if (res) {
#line 561
      goto ERROR3;
    }
#line 562
    i += len;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 564
  return (0);
  ERROR3: 
  {
#line 567
  psiconv_list_free(*encoded_bytes);
  }
  ERROR2: 
  {
#line 569
  psiconv_list_free(data);
  }
  ERROR1: 
#line 571
  return (res);
}
}
#line 578 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_encode_rle16___0(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                    psiconv_pixel_bytes *encoded_bytes ) 
{ 
  int res ;
  int i ;
  int j ;
  int len ;
  psiconv_u8 *entry1 ;
  psiconv_u8 *entry2 ;
  psiconv_u8 *next1 ;
  psiconv_u8 *next2 ;
  psiconv_u8 temp ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  psiconv_u32 tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  psiconv_u32 tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  psiconv_u32 tmp___12 ;
  psiconv_u32 tmp___13 ;

  {
  {
#line 586
  tmp = psiconv_list_new(sizeof(*entry1));
#line 586
  *encoded_bytes = tmp;
  }
#line 586
  if (! tmp) {
#line 587
    res = -2;
#line 588
    goto ERROR1;
  }
#line 591
  i = 0;
  {
#line 591
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 591
    tmp___13 = psiconv_list_length(plain_bytes);
    }
#line 591
    if (! ((psiconv_u32 )i < tmp___13)) {
#line 591
      goto while_break;
    }
    {
#line 592
    tmp___0 = psiconv_list_get(plain_bytes, (psiconv_u32 )i);
#line 592
    entry1 = (psiconv_u8 *)tmp___0;
    }
#line 592
    if (! entry1) {
#line 593
      res = -2;
#line 594
      goto ERROR2;
    }
    {
#line 596
    tmp___1 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 1));
#line 596
    entry2 = (psiconv_u8 *)tmp___1;
    }
#line 596
    if (! entry2) {
#line 597
      res = -2;
#line 598
      goto ERROR2;
    }
    {
#line 600
    tmp___2 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 2));
#line 600
    next1 = (psiconv_u8 *)tmp___2;
    }
#line 600
    if (! next1) {
#line 601
      res = -2;
#line 602
      goto ERROR2;
    }
    {
#line 604
    tmp___3 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 3));
#line 604
    next2 = (psiconv_u8 *)tmp___3;
    }
#line 604
    if (! next2) {
#line 605
      res = -2;
#line 606
      goto ERROR2;
    }
    {
#line 608
    tmp___12 = psiconv_list_length(plain_bytes);
    }
#line 608
    if ((psiconv_u32 )i == tmp___12 - 4U) {
      {
#line 609
      temp = (psiconv_u8 )254;
#line 610
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 610
      if (res) {
#line 611
        goto ERROR2;
      }
      {
#line 612
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry1);
      }
#line 612
      if (res) {
#line 613
        goto ERROR2;
      }
      {
#line 614
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry2);
      }
#line 614
      if (res) {
#line 615
        goto ERROR2;
      }
      {
#line 616
      res = psiconv_list_add(*encoded_bytes, (void const   *)next1);
      }
#line 616
      if (res) {
#line 617
        goto ERROR2;
      }
      {
#line 618
      res = psiconv_list_add(*encoded_bytes, (void const   *)next2);
      }
#line 618
      if (res) {
#line 619
        goto ERROR2;
      }
#line 620
      i += 4;
    } else
#line 621
    if ((int )*next1 == (int )*entry1) {
#line 621
      if ((int )*next2 == (int )*entry2) {
#line 622
        len = 0;
        {
#line 623
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 623
          if ((int )*next1 == (int )*entry1) {
#line 623
            if ((int )*next2 == (int )*entry2) {
              {
#line 623
              tmp___6 = psiconv_list_length(plain_bytes);
              }
#line 623
              if ((psiconv_u32 )((i + 2 * len) + 4) < tmp___6) {
#line 623
                if (! (len < 128)) {
#line 623
                  goto while_break___0;
                }
              } else {
#line 623
                goto while_break___0;
              }
            } else {
#line 623
              goto while_break___0;
            }
          } else {
#line 623
            goto while_break___0;
          }
          {
#line 626
          len ++;
#line 627
          tmp___4 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len * 2));
#line 627
          next1 = (psiconv_u8 *)tmp___4;
          }
#line 627
          if (! next1) {
#line 628
            res = -2;
#line 629
            goto ERROR2;
          }
          {
#line 631
          tmp___5 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 2) + 1));
#line 631
          next2 = (psiconv_u8 *)tmp___5;
          }
#line 631
          if (! next2) {
#line 632
            res = -2;
#line 633
            goto ERROR2;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 636
        temp = (psiconv_u8 )(len - 1);
#line 637
        res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
        }
#line 637
        if (res) {
#line 638
          goto ERROR2;
        }
        {
#line 639
        res = psiconv_list_add(*encoded_bytes, (void const   *)entry1);
        }
#line 639
        if (res) {
#line 640
          goto ERROR2;
        }
        {
#line 641
        res = psiconv_list_add(*encoded_bytes, (void const   *)entry2);
        }
#line 641
        if (res) {
#line 642
          goto ERROR2;
        }
#line 643
        i += len * 2;
      } else {
#line 621
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 645
      len = 1;
      {
#line 646
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 646
        if ((int )*next1 != (int )*entry1) {
#line 646
          goto _L;
        } else
#line 646
        if ((int )*next2 != (int )*entry2) {
          _L: /* CIL Label */ 
          {
#line 646
          tmp___9 = psiconv_list_length(plain_bytes);
          }
#line 646
          if ((psiconv_u32 )((i + len * 2) + 4) < tmp___9) {
#line 646
            if (! (len < 128)) {
#line 646
              goto while_break___1;
            }
          } else {
#line 646
            goto while_break___1;
          }
        } else {
#line 646
          goto while_break___1;
        }
        {
#line 649
        len ++;
#line 650
        entry1 = next1;
#line 651
        entry2 = next2;
#line 652
        tmp___7 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len * 2));
#line 652
        next1 = (psiconv_u8 *)tmp___7;
        }
#line 652
        if (! next1) {
#line 653
          res = -2;
#line 654
          goto ERROR2;
        }
        {
#line 656
        tmp___8 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 2) + 1));
#line 656
        next2 = (psiconv_u8 *)tmp___8;
        }
#line 656
        if (! next2) {
#line 657
          res = -2;
#line 658
          goto ERROR2;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 661
      len --;
#line 662
      temp = (psiconv_u8 )(256 - len);
#line 663
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 663
      if (res) {
#line 664
        goto ERROR2;
      }
#line 665
      j = 0;
      {
#line 665
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 665
        if (! (j < len)) {
#line 665
          goto while_break___2;
        }
        {
#line 666
        tmp___10 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + j * 2));
#line 666
        next1 = (psiconv_u8 *)tmp___10;
        }
#line 666
        if (! next1) {
#line 667
          res = -2;
#line 668
          goto ERROR2;
        }
        {
#line 670
        tmp___11 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + j * 2) + 1));
#line 670
        next2 = (psiconv_u8 *)tmp___11;
        }
#line 670
        if (! next2) {
#line 671
          res = -2;
#line 672
          goto ERROR2;
        }
        {
#line 674
        res = psiconv_list_add(*encoded_bytes, (void const   *)next1);
        }
#line 674
        if (res) {
#line 675
          goto ERROR2;
        }
        {
#line 676
        res = psiconv_list_add(*encoded_bytes, (void const   *)next2);
        }
#line 676
        if (res) {
#line 677
          goto ERROR2;
        }
#line 665
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 679
      i += len * 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 682
  return (0);
  ERROR2: 
  {
#line 685
  psiconv_list_free(*encoded_bytes);
  }
  ERROR1: 
#line 687
  return (res);
}
}
#line 694 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_encode_rle24___0(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                    psiconv_pixel_bytes *encoded_bytes ) 
{ 
  int res ;
  int i ;
  int j ;
  int len ;
  psiconv_u8 *entry1 ;
  psiconv_u8 *entry2 ;
  psiconv_u8 *entry3 ;
  psiconv_u8 *next1 ;
  psiconv_u8 *next2 ;
  psiconv_u8 *next3 ;
  psiconv_u8 temp ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  psiconv_u32 tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  psiconv_u32 tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  psiconv_u32 tmp___17 ;
  psiconv_u32 tmp___18 ;

  {
  {
#line 702
  tmp = psiconv_list_new(sizeof(*entry1));
#line 702
  *encoded_bytes = tmp;
  }
#line 702
  if (! tmp) {
#line 703
    res = -2;
#line 704
    goto ERROR1;
  }
#line 707
  i = 0;
  {
#line 707
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 707
    tmp___18 = psiconv_list_length(plain_bytes);
    }
#line 707
    if (! ((psiconv_u32 )i < tmp___18)) {
#line 707
      goto while_break;
    }
    {
#line 708
    tmp___0 = psiconv_list_get(plain_bytes, (psiconv_u32 )i);
#line 708
    entry1 = (psiconv_u8 *)tmp___0;
    }
#line 708
    if (! entry1) {
#line 709
      res = -2;
#line 710
      goto ERROR2;
    }
    {
#line 712
    tmp___1 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 1));
#line 712
    entry2 = (psiconv_u8 *)tmp___1;
    }
#line 712
    if (! entry2) {
#line 713
      res = -2;
#line 714
      goto ERROR2;
    }
    {
#line 716
    tmp___2 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 2));
#line 716
    entry3 = (psiconv_u8 *)tmp___2;
    }
#line 716
    if (! entry3) {
#line 717
      res = -2;
#line 718
      goto ERROR2;
    }
    {
#line 720
    tmp___3 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 3));
#line 720
    next1 = (psiconv_u8 *)tmp___3;
    }
#line 720
    if (! next1) {
#line 721
      res = -2;
#line 722
      goto ERROR2;
    }
    {
#line 724
    tmp___4 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 4));
#line 724
    next2 = (psiconv_u8 *)tmp___4;
    }
#line 724
    if (! next2) {
#line 725
      res = -2;
#line 726
      goto ERROR2;
    }
    {
#line 728
    tmp___5 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 5));
#line 728
    next3 = (psiconv_u8 *)tmp___5;
    }
#line 728
    if (! next3) {
#line 729
      res = -2;
#line 730
      goto ERROR2;
    }
    {
#line 732
    tmp___17 = psiconv_list_length(plain_bytes);
    }
#line 732
    if ((psiconv_u32 )i == tmp___17 - 6U) {
      {
#line 733
      temp = (psiconv_u8 )254;
#line 734
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 734
      if (res) {
#line 735
        goto ERROR2;
      }
      {
#line 736
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry1);
      }
#line 736
      if (res) {
#line 737
        goto ERROR2;
      }
      {
#line 738
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry2);
      }
#line 738
      if (res) {
#line 739
        goto ERROR2;
      }
      {
#line 740
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry3);
      }
#line 740
      if (res) {
#line 741
        goto ERROR2;
      }
      {
#line 742
      res = psiconv_list_add(*encoded_bytes, (void const   *)next1);
      }
#line 742
      if (res) {
#line 743
        goto ERROR2;
      }
      {
#line 744
      res = psiconv_list_add(*encoded_bytes, (void const   *)next2);
      }
#line 744
      if (res) {
#line 745
        goto ERROR2;
      }
      {
#line 746
      res = psiconv_list_add(*encoded_bytes, (void const   *)next3);
      }
#line 746
      if (res) {
#line 747
        goto ERROR2;
      }
#line 748
      i += 4;
    } else
#line 749
    if ((int )*next1 == (int )*entry1) {
#line 749
      if ((int )*next2 == (int )*entry2) {
#line 749
        if ((int )*next3 == (int )*entry3) {
#line 751
          len = 0;
          {
#line 752
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 752
            if ((int )*next1 == (int )*entry1) {
#line 752
              if ((int )*next2 == (int )*entry2) {
#line 752
                if ((int )*next3 == (int )*entry3) {
                  {
#line 752
                  tmp___9 = psiconv_list_length(plain_bytes);
                  }
#line 752
                  if ((psiconv_u32 )((i + 3 * len) + 6) < tmp___9) {
#line 752
                    if (! (len < 128)) {
#line 752
                      goto while_break___0;
                    }
                  } else {
#line 752
                    goto while_break___0;
                  }
                } else {
#line 752
                  goto while_break___0;
                }
              } else {
#line 752
                goto while_break___0;
              }
            } else {
#line 752
              goto while_break___0;
            }
            {
#line 756
            len ++;
#line 757
            tmp___6 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len * 3));
#line 757
            next1 = (psiconv_u8 *)tmp___6;
            }
#line 757
            if (! next1) {
#line 758
              res = -2;
#line 759
              goto ERROR2;
            }
            {
#line 761
            tmp___7 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 3) + 1));
#line 761
            next2 = (psiconv_u8 *)tmp___7;
            }
#line 761
            if (! next2) {
#line 762
              res = -2;
#line 763
              goto ERROR2;
            }
            {
#line 765
            tmp___8 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 3) + 2));
#line 765
            next3 = (psiconv_u8 *)tmp___8;
            }
#line 765
            if (! next3) {
#line 766
              res = -2;
#line 767
              goto ERROR2;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 770
          temp = (psiconv_u8 )(len - 1);
#line 771
          res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
          }
#line 771
          if (res) {
#line 772
            goto ERROR2;
          }
          {
#line 773
          res = psiconv_list_add(*encoded_bytes, (void const   *)entry1);
          }
#line 773
          if (res) {
#line 774
            goto ERROR2;
          }
          {
#line 775
          res = psiconv_list_add(*encoded_bytes, (void const   *)entry2);
          }
#line 775
          if (res) {
#line 776
            goto ERROR2;
          }
          {
#line 777
          res = psiconv_list_add(*encoded_bytes, (void const   *)entry3);
          }
#line 777
          if (res) {
#line 778
            goto ERROR2;
          }
#line 779
          i += len * 3;
        } else {
#line 749
          goto _L___1;
        }
      } else {
#line 749
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 781
      len = 1;
      {
#line 782
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 782
        if ((int )*next1 != (int )*entry1) {
#line 782
          goto _L;
        } else
#line 782
        if ((int )*next2 != (int )*entry2) {
#line 782
          goto _L;
        } else
#line 782
        if ((int )*next3 != (int )*entry3) {
          _L: /* CIL Label */ 
          {
#line 782
          tmp___13 = psiconv_list_length(plain_bytes);
          }
#line 782
          if ((psiconv_u32 )((i + len * 3) + 6) < tmp___13) {
#line 782
            if (! (len < 128)) {
#line 782
              goto while_break___1;
            }
          } else {
#line 782
            goto while_break___1;
          }
        } else {
#line 782
          goto while_break___1;
        }
        {
#line 786
        len ++;
#line 787
        entry1 = next1;
#line 788
        entry2 = next2;
#line 789
        entry3 = next3;
#line 790
        tmp___10 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len * 3));
#line 790
        next1 = (psiconv_u8 *)tmp___10;
        }
#line 790
        if (! next1) {
#line 791
          res = -2;
#line 792
          goto ERROR2;
        }
        {
#line 794
        tmp___11 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 3) + 1));
#line 794
        next2 = (psiconv_u8 *)tmp___11;
        }
#line 794
        if (! next2) {
#line 795
          res = -2;
#line 796
          goto ERROR2;
        }
        {
#line 798
        tmp___12 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 3) + 2));
#line 798
        next3 = (psiconv_u8 *)tmp___12;
        }
#line 798
        if (! next3) {
#line 799
          res = -2;
#line 800
          goto ERROR2;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 803
      len --;
#line 804
      temp = (psiconv_u8 )(256 - len);
#line 805
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 805
      if (res) {
#line 806
        goto ERROR2;
      }
#line 807
      j = 0;
      {
#line 807
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 807
        if (! (j < len)) {
#line 807
          goto while_break___2;
        }
        {
#line 808
        tmp___14 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + j * 3));
#line 808
        next1 = (psiconv_u8 *)tmp___14;
        }
#line 808
        if (! next1) {
#line 809
          res = -2;
#line 810
          goto ERROR2;
        }
        {
#line 812
        tmp___15 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + j * 3) + 1));
#line 812
        next2 = (psiconv_u8 *)tmp___15;
        }
#line 812
        if (! next2) {
#line 813
          res = -2;
#line 814
          goto ERROR2;
        }
        {
#line 816
        tmp___16 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + j * 3) + 2));
#line 816
        next2 = (psiconv_u8 *)tmp___16;
        }
#line 816
        if (! next2) {
#line 817
          res = -2;
#line 818
          goto ERROR2;
        }
        {
#line 820
        res = psiconv_list_add(*encoded_bytes, (void const   *)next1);
        }
#line 820
        if (res) {
#line 821
          goto ERROR2;
        }
        {
#line 822
        res = psiconv_list_add(*encoded_bytes, (void const   *)next2);
        }
#line 822
        if (res) {
#line 823
          goto ERROR2;
        }
        {
#line 824
        res = psiconv_list_add(*encoded_bytes, (void const   *)next3);
        }
#line 824
        if (res) {
#line 825
          goto ERROR2;
        }
#line 807
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 827
      i += len * 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 830
  return (0);
  ERROR2: 
  {
#line 833
  psiconv_list_free(*encoded_bytes);
  }
  ERROR1: 
#line 835
  return (res);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 27 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/extra/rewrite.c"
int main(int argc , char **argv ) 
{ 
  FILE *fp ;
  psiconv_buffer buf ;
  psiconv_file psionfile ;
  psiconv_config config ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 36
  if (argc < 3) {
    {
#line 37
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough arguments\n");
#line 38
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Syntax: INFILE OUTFILE\n");
#line 39
    exit(1);
    }
  }
  {
#line 42
  config = psiconv_config_default();
#line 43
  psiconv_config_read((char const   *)((void *)0), & config);
#line 45
  fp = fopen((char const   */* __restrict  */)*(argv + 1), (char const   */* __restrict  */)"r");
  }
#line 45
  if (! fp) {
    {
#line 46
    perror("Can\'t open file");
#line 47
    exit(1);
    }
  }
  {
#line 49
  buf = psiconv_buffer_new();
  }
#line 49
  if (! buf) {
    {
#line 50
    perror("Can\'t allocate buf");
#line 51
    exit(1);
    }
  }
  {
#line 53
  tmp = psiconv_buffer_fread_all(buf, fp);
  }
#line 53
  if (tmp) {
    {
#line 54
    perror("Can\'t fread file");
#line 55
    exit(1);
    }
  }
  {
#line 57
  fclose(fp);
#line 58
  tmp___0 = psiconv_parse(config, (psiconv_buffer const   )buf, & psionfile);
  }
#line 58
  if (tmp___0) {
    {
#line 59
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Parse error\n");
#line 60
    exit(1);
    }
  }
  {
#line 63
  psiconv_buffer_free(buf);
#line 64
  buf = (psiconv_buffer )((void *)0);
#line 65
  tmp___1 = psiconv_write(config, & buf, (psiconv_file const   )psionfile);
  }
#line 65
  if (tmp___1) {
    {
#line 66
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Generate error\n");
#line 67
    exit(1);
    }
  }
  {
#line 69
  psiconv_free_file(psionfile);
#line 70
  fp = fopen((char const   */* __restrict  */)*(argv + 2), (char const   */* __restrict  */)"w");
  }
#line 70
  if (! fp) {
    {
#line 71
    perror("Can\'t open file");
#line 72
    exit(1);
    }
  }
  {
#line 74
  tmp___2 = psiconv_buffer_fwrite_all((psiconv_buffer const   )buf, fp);
  }
#line 74
  if (tmp___2) {
    {
#line 75
    perror("Can\'t fwrite file");
#line 76
    exit(1);
    }
  }
  {
#line 78
  fclose(fp);
#line 79
  psiconv_buffer_free(buf);
#line 80
  psiconv_config_free(config);
#line 81
  exit(0);
  }
}
}
#line 39 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_4_red___0[16]  = 
#line 39 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
  {      (float )((double )0 / 255.0),      (float )((double )85 / 255.0),      (float )((double )128 / 255.0),      (float )((double )128 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )128 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )170 / 255.0),      (float )((double )255 / 255.0)};
#line 46 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_4_green___0[16]  = 
#line 46
  {      (float )((double )0 / 255.0),      (float )((double )85 / 255.0),      (float )((double )0 / 255.0),      (float )((double )128 / 255.0), 
        (float )((double )128 / 255.0),      (float )((double )0 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )128 / 255.0),      (float )((double )170 / 255.0),      (float )((double )255 / 255.0)};
#line 53 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_4_blue___0[16]  = 
#line 53
  {      (float )((double )0 / 255.0),      (float )((double )85 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )255 / 255.0),      (float )((double )128 / 255.0), 
        (float )((double )128 / 255.0),      (float )((double )128 / 255.0),      (float )((double )170 / 255.0),      (float )((double )255 / 255.0)};
#line 69 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_8_red___0[256]  = 
#line 69
  {      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )17 / 255.0),      (float )((double )34 / 255.0),      (float )((double )68 / 255.0),      (float )((double )85 / 255.0), 
        (float )((double )119 / 255.0),      (float )((double )17 / 255.0),      (float )((double )34 / 255.0),      (float )((double )68 / 255.0), 
        (float )((double )85 / 255.0),      (float )((double )119 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )136 / 255.0),      (float )((double )170 / 255.0), 
        (float )((double )187 / 255.0),      (float )((double )221 / 255.0),      (float )((double )238 / 255.0),      (float )((double )136 / 255.0), 
        (float )((double )170 / 255.0),      (float )((double )187 / 255.0),      (float )((double )221 / 255.0),      (float )((double )238 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0)};
#line 136 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_8_green___0[256]  = 
#line 136
  {      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )17 / 255.0),      (float )((double )34 / 255.0),      (float )((double )68 / 255.0),      (float )((double )85 / 255.0), 
        (float )((double )119 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )17 / 255.0),      (float )((double )34 / 255.0), 
        (float )((double )68 / 255.0),      (float )((double )85 / 255.0),      (float )((double )119 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )136 / 255.0),      (float )((double )170 / 255.0),      (float )((double )187 / 255.0), 
        (float )((double )221 / 255.0),      (float )((double )238 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )136 / 255.0), 
        (float )((double )170 / 255.0),      (float )((double )187 / 255.0),      (float )((double )221 / 255.0),      (float )((double )238 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0)};
#line 203 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_8_blue___0[256]  = 
#line 203
  {      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )17 / 255.0),      (float )((double )34 / 255.0),      (float )((double )68 / 255.0),      (float )((double )85 / 255.0), 
        (float )((double )119 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )17 / 255.0), 
        (float )((double )34 / 255.0),      (float )((double )68 / 255.0),      (float )((double )85 / 255.0),      (float )((double )119 / 255.0), 
        (float )((double )136 / 255.0),      (float )((double )170 / 255.0),      (float )((double )187 / 255.0),      (float )((double )221 / 255.0), 
        (float )((double )238 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )136 / 255.0), 
        (float )((double )170 / 255.0),      (float )((double )187 / 255.0),      (float )((double )221 / 255.0),      (float )((double )238 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0)};
#line 36 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
static int psiconv_list_resize___0(psiconv_list l , psiconv_u32 nr ) ;
#line 178 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
static int psiconv_list_resize___0(psiconv_list l , psiconv_u32 nr ) 
{ 
  void *temp ;

  {
#line 181
  if (nr > l->max_len) {
    {
#line 182
    l->max_len = (psiconv_u32 )(1.1 * (double )nr);
#line 183
    l->max_len += 16U - l->max_len % 16U;
#line 184
    temp = realloc(l->els, (size_t )l->max_len * l->el_size);
    }
#line 185
    if (temp) {
#line 186
      l->els = temp;
#line 187
      return (0);
    } else {
#line 189
      return (-2);
    }
  }
#line 191
  return (0);
}
}
#line 45 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/buffer.c"
static psiconv_u32 unique_id___0  =    (psiconv_u32 )1;
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_color clone_color___0(psiconv_color color___1 ) ;
#line 34
static psiconv_font clone_font___0(psiconv_font font___9 ) ;
#line 35
static psiconv_border clone_border___0(psiconv_border border___1 ) ;
#line 36
static psiconv_bullet clone_bullet___0(psiconv_bullet bullet___4 ) ;
#line 37
static psiconv_all_tabs clone_all_tabs___0(psiconv_all_tabs all_tabs ) ;
#line 38
static void psiconv_free_style_aux___0(void *style___1 ) ;
#line 39
static void psiconv_free_in_line_layout_aux___0(void *layout ) ;
#line 40
static void psiconv_free_paragraph_aux___0(void *paragraph___3 ) ;
#line 41
static void psiconv_free_paint_data_section_aux___0(void *section ) ;
#line 42
static void psiconv_free_clipart_section_aux___0(void *section ) ;
#line 43
static void psiconv_free_formula_aux___0(void *data ) ;
#line 44
static void psiconv_free_sheet_worksheet_aux___0(void *data ) ;
#line 45
static void psiconv_free_sheet_variable_aux___0(void *variable ) ;
#line 46
static void psiconv_free_sheet_cell_aux___0(void *cell ) ;
#line 47
static void psiconv_free_sheet_line_aux___0(void *line ) ;
#line 50
static psiconv_word_styles_section psiconv_empty_word_styles_section___0(void) ;
#line 51
static psiconv_text_and_layout psiconv_empty_text_and_layout___0(void) ;
#line 52
static psiconv_texted_section psiconv_empty_texted_section___0(void) ;
#line 53
static psiconv_page_header psiconv_empty_page_header___0(void) ;
#line 54
static psiconv_page_layout_section psiconv_empty_page_layout_section___0(void) ;
#line 55
static psiconv_word_status_section psiconv_empty_word_status_section___0(void) ;
#line 56
static psiconv_word_f psiconv_empty_word_f___0(void) ;
#line 57
static psiconv_sheet_status_section psiconv_empty_sheet_status_section___0(void) ;
#line 58
static psiconv_formula_list psiconv_empty_formula_list___0(void) ;
#line 59
static psiconv_sheet_workbook_section psiconv_empty_sheet_workbook_section___0(void) ;
#line 61
static psiconv_sheet_f psiconv_empty_sheet_f___0(void) ;
#line 62
static psiconv_texted_f psiconv_empty_texted_f___0(void) ;
#line 63
static psiconv_paint_data_section psiconv_empty_paint_data_section___0(void) ;
#line 64
static psiconv_pictures psiconv_empty_pictures___0(void) ;
#line 65
static psiconv_mbm_f psiconv_empty_mbm_f___0(void) ;
#line 66
static psiconv_sketch_section psiconv_empty_sketch_section___0(void) ;
#line 67
static psiconv_sketch_f psiconv_empty_sketch_f___0(void) ;
#line 68
static psiconv_clipart_f psiconv_empty_clipart_f___0(void) ;
#line 69
static psiconv_cliparts psiconv_empty_cliparts___0(void) ;
#line 77 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_color_s black___1  =    {(psiconv_u8 )0, (psiconv_u8 )0, (psiconv_u8 )0};
#line 83 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_color_s white___1  =    {(psiconv_u8 )255, (psiconv_u8 )255, (psiconv_u8 )255};
#line 89 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_ucs2 font_times___1[16]  = 
#line 89
  {      (psiconv_ucs2 )'T',      (psiconv_ucs2 )'i',      (psiconv_ucs2 )'m',      (psiconv_ucs2 )'e', 
        (psiconv_ucs2 )'s',      (psiconv_ucs2 )' ',      (psiconv_ucs2 )'N',      (psiconv_ucs2 )'e', 
        (psiconv_ucs2 )'w',      (psiconv_ucs2 )' ',      (psiconv_ucs2 )'R',      (psiconv_ucs2 )'o', 
        (psiconv_ucs2 )'m',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'n',      (psiconv_ucs2 )0};
#line 92 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_font_s font___1  =    {font_times___1, (psiconv_screenfont_t )3};
#line 117 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_ucs2 font_times___2[16]  = 
#line 117
  {      (psiconv_ucs2 )'T',      (psiconv_ucs2 )'i',      (psiconv_ucs2 )'m',      (psiconv_ucs2 )'e', 
        (psiconv_ucs2 )'s',      (psiconv_ucs2 )' ',      (psiconv_ucs2 )'N',      (psiconv_ucs2 )'e', 
        (psiconv_ucs2 )'w',      (psiconv_ucs2 )' ',      (psiconv_ucs2 )'R',      (psiconv_ucs2 )'o', 
        (psiconv_ucs2 )'m',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'n',      (psiconv_ucs2 )0};
#line 121 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_font_s font___2  =    {font_times___2, (psiconv_screenfont_t )2};
#line 126 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_color_s black___2  =    {(psiconv_u8 )0, (psiconv_u8 )0, (psiconv_u8 )0};
#line 132 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_color_s white___2  =    {(psiconv_u8 )255, (psiconv_u8 )255, (psiconv_u8 )255};
#line 138 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_border_s no_border___0  =    {(psiconv_border_kind_t )0, (psiconv_size_t )1, & black___2};
#line 144 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_bullet_s bullet___0  =    {(psiconv_bool_t )0, (psiconv_size_t )10.0, (psiconv_ucs2 )8221, (psiconv_bool_t )1,
    & black___2, & font___2};
#line 153 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_all_tabs_s tabs___0  =    {(psiconv_length_t )0.64, (psiconv_tab_list )((void *)0)};
#line 192 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_color clone_color___0(psiconv_color color___1 ) 
{ 
  psiconv_color result ;
  void *tmp ;

  {
  {
#line 195
  tmp = malloc(sizeof(*result));
#line 195
  result = (psiconv_color )tmp;
  }
#line 195
  if (! result) {
#line 196
    return ((psiconv_color )((void *)0));
  }
#line 197
  *result = *color___1;
#line 198
  return (result);
}
}
#line 201 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_font clone_font___0(psiconv_font font___9 ) 
{ 
  psiconv_font result ;
  void *tmp ;
  psiconv_string_t tmp___0 ;

  {
  {
#line 204
  tmp = malloc(sizeof(*result));
#line 204
  result = (psiconv_font )tmp;
  }
#line 204
  if (! result) {
#line 205
    goto ERROR1;
  }
  {
#line 206
  *result = *font___9;
#line 207
  tmp___0 = psiconv_unicode_strdup((psiconv_ucs2 const   *)result->name);
#line 207
  result->name = tmp___0;
  }
#line 207
  if (! tmp___0) {
#line 208
    goto ERROR2;
  }
#line 209
  return (result);
  ERROR2: 
  {
#line 211
  free((void *)result);
  }
  ERROR1: 
#line 213
  return ((psiconv_font )((void *)0));
}
}
#line 216 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_border clone_border___0(psiconv_border border___1 ) 
{ 
  psiconv_border result ;
  void *tmp ;
  psiconv_color tmp___0 ;

  {
  {
#line 219
  tmp = malloc(sizeof(*result));
#line 219
  result = (psiconv_border )tmp;
  }
#line 219
  if (! result) {
#line 220
    goto ERROR1;
  }
  {
#line 221
  *result = *border___1;
#line 222
  tmp___0 = clone_color___0(result->color);
#line 222
  result->color = tmp___0;
  }
#line 222
  if (! tmp___0) {
#line 223
    goto ERROR2;
  }
#line 224
  return (result);
  ERROR2: 
  {
#line 226
  free((void *)result);
  }
  ERROR1: 
#line 228
  return ((psiconv_border )((void *)0));
}
}
#line 231 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_bullet clone_bullet___0(psiconv_bullet bullet___4 ) 
{ 
  psiconv_bullet result ;
  void *tmp ;
  psiconv_font tmp___0 ;
  psiconv_color tmp___1 ;

  {
  {
#line 234
  tmp = malloc(sizeof(*result));
#line 234
  result = (psiconv_bullet )tmp;
  }
#line 234
  if (! result) {
#line 235
    goto ERROR1;
  }
  {
#line 236
  *result = *bullet___4;
#line 237
  tmp___0 = clone_font___0(result->font);
#line 237
  result->font = tmp___0;
  }
#line 237
  if (! tmp___0) {
#line 238
    goto ERROR2;
  }
  {
#line 239
  tmp___1 = clone_color___0(result->color);
#line 239
  result->color = tmp___1;
  }
#line 239
  if (! tmp___1) {
#line 240
    goto ERROR3;
  }
#line 241
  return (result);
  ERROR3: 
  {
#line 243
  psiconv_free_font(result->font);
  }
  ERROR2: 
  {
#line 245
  free((void *)result);
  }
  ERROR1: 
#line 247
  return ((psiconv_bullet )((void *)0));
}
}
#line 250 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_all_tabs clone_all_tabs___0(psiconv_all_tabs all_tabs ) 
{ 
  psiconv_all_tabs result ;
  void *tmp ;
  psiconv_tab_list tmp___0 ;

  {
  {
#line 253
  tmp = malloc(sizeof(*result));
#line 253
  result = (psiconv_all_tabs )tmp;
  }
#line 253
  if (! result) {
#line 254
    goto ERROR1;
  }
  {
#line 255
  *result = *all_tabs;
#line 256
  tmp___0 = psiconv_list_clone((psiconv_list const   )result->extras);
#line 256
  result->extras = tmp___0;
  }
#line 256
  if (! tmp___0) {
#line 257
    goto ERROR2;
  }
#line 258
  return (result);
  ERROR2: 
  {
#line 260
  free((void *)result);
  }
  ERROR1: 
#line 262
  return ((psiconv_all_tabs )((void *)0));
}
}
#line 464 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_style_aux___0(void *style___1 ) 
{ 


  {
#line 466
  if (((psiconv_word_style )style___1)->name) {
    {
#line 467
    free((void *)((psiconv_word_style )style___1)->name);
    }
  }
  {
#line 468
  psiconv_free_character_layout(((psiconv_word_style )style___1)->character);
#line 469
  psiconv_free_paragraph_layout(((psiconv_word_style )style___1)->paragraph);
  }
#line 470
  return;
}
}
#line 548 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_in_line_layout_aux___0(void *layout ) 
{ 


  {
  {
#line 550
  psiconv_free_character_layout(((psiconv_in_line_layout )layout)->layout);
#line 551
  psiconv_free_embedded_object_section(((psiconv_in_line_layout )layout)->object);
  }
#line 553
  return;
}
}
#line 581 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_paragraph_aux___0(void *paragraph___3 ) 
{ 


  {
#line 583
  if (((psiconv_paragraph )paragraph___3)->text) {
    {
#line 584
    free((void *)((psiconv_paragraph )paragraph___3)->text);
    }
  }
  {
#line 585
  psiconv_free_character_layout(((psiconv_paragraph )paragraph___3)->base_character);
#line 587
  psiconv_free_paragraph_layout(((psiconv_paragraph )paragraph___3)->base_paragraph);
#line 589
  psiconv_free_in_line_layouts(((psiconv_paragraph )paragraph___3)->in_lines);
#line 591
  psiconv_free_replacements(((psiconv_paragraph )paragraph___3)->replacements);
  }
#line 593
  return;
}
}
#line 672 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_sheet_cell_aux___0(void *cell ) 
{ 
  psiconv_sheet_cell data ;

  {
  {
#line 674
  data = (psiconv_sheet_cell )cell;
#line 676
  psiconv_free_sheet_cell_layout(data->layout);
  }
#line 678
  if ((unsigned int )data->type == 5U) {
#line 678
    if (data->data.dat_string) {
      {
#line 679
      free((void *)data->data.dat_string);
      }
    }
  }
#line 680
  return;
}
}
#line 696 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_sheet_line_aux___0(void *line ) 
{ 
  psiconv_sheet_line data ;

  {
  {
#line 698
  data = (psiconv_sheet_line )line;
#line 700
  psiconv_free_sheet_cell_layout(data->layout);
  }
#line 701
  return;
}
}
#line 747 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_sheet_worksheet_aux___0(void *data ) 
{ 
  psiconv_sheet_worksheet section ;

  {
  {
#line 749
  section = (psiconv_sheet_worksheet )data;
#line 750
  psiconv_free_sheet_cell_layout(section->default_layout);
#line 751
  psiconv_free_sheet_cell_list(section->cells);
#line 752
  psiconv_free_sheet_line_list(section->row_default_layouts);
#line 753
  psiconv_free_sheet_line_list(section->col_default_layouts);
#line 754
  psiconv_free_sheet_grid_section(section->grid);
  }
#line 755
  return;
}
}
#line 771 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_formula_aux___0(void *data ) 
{ 
  psiconv_formula formula ;

  {
#line 774
  formula = (psiconv_formula )data;
#line 775
  if ((unsigned int )formula->type == 23U) {
    {
#line 776
    free((void *)formula->data.dat_string);
    }
  } else
#line 777
  if ((unsigned int )formula->type != 21U) {
#line 777
    if ((unsigned int )formula->type != 22U) {
#line 777
      if ((unsigned int )formula->type != 20U) {
#line 777
        if ((unsigned int )formula->type != 24U) {
#line 777
          if ((unsigned int )formula->type != 25U) {
#line 777
            if ((unsigned int )formula->type != 26U) {
#line 777
              if ((unsigned int )formula->type != 27U) {
#line 777
                if ((unsigned int )formula->type != 28U) {
#line 777
                  if ((unsigned int )formula->type != 19U) {
#line 777
                    if ((unsigned int )formula->type != 0U) {
                      {
#line 787
                      psiconv_free_formula_list(formula->data.fun_operands);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 788
  return;
}
}
#line 820 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_sheet_variable_aux___0(void *variable ) 
{ 
  psiconv_sheet_variable var ;

  {
#line 822
  var = (psiconv_sheet_variable )variable;
#line 823
  if (var->name) {
    {
#line 824
    free((void *)var->name);
    }
  }
#line 825
  if ((unsigned int )var->type == 2U) {
    {
#line 826
    free((void *)var->data.dat_string);
    }
  }
#line 827
  return;
}
}
#line 874 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_paint_data_section_aux___0(void *section ) 
{ 


  {
#line 876
  if (((psiconv_paint_data_section )section)->red) {
    {
#line 877
    free((void *)((psiconv_paint_data_section )section)->red);
    }
  }
#line 878
  if (((psiconv_paint_data_section )section)->green) {
    {
#line 879
    free((void *)((psiconv_paint_data_section )section)->green);
    }
  }
#line 880
  if (((psiconv_paint_data_section )section)->blue) {
    {
#line 881
    free((void *)((psiconv_paint_data_section )section)->blue);
    }
  }
#line 882
  return;
}
}
#line 928 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_clipart_section_aux___0(void *section ) 
{ 


  {
#line 930
  if (section) {
    {
#line 931
    psiconv_free_paint_data_section(((psiconv_clipart_section )section)->picture);
    }
  }
#line 932
  return;
}
}
#line 1112 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_word_styles_section psiconv_empty_word_styles_section___0(void) 
{ 
  psiconv_word_styles_section result ;
  void *tmp ;
  psiconv_word_style_list tmp___0 ;
  psiconv_word_style tmp___1 ;
  void *tmp___2 ;
  psiconv_character_layout tmp___3 ;
  psiconv_paragraph_layout tmp___4 ;

  {
  {
#line 1115
  tmp = malloc(sizeof(*result));
#line 1115
  result = (psiconv_word_styles_section )tmp;
  }
#line 1115
  if (! result) {
#line 1116
    goto ERROR1;
  }
  {
#line 1117
  tmp___0 = psiconv_list_new(sizeof(struct psiconv_word_style_s ));
#line 1117
  result->styles = tmp___0;
  }
#line 1117
  if (! tmp___0) {
#line 1118
    goto ERROR2;
  }
  {
#line 1119
  tmp___2 = malloc(sizeof(struct psiconv_word_style_s ));
#line 1119
  tmp___1 = (psiconv_word_style )tmp___2;
#line 1119
  result->normal = tmp___1;
  }
#line 1119
  if (! tmp___1) {
#line 1120
    goto ERROR3;
  }
  {
#line 1121
  tmp___3 = psiconv_basic_character_layout();
#line 1121
  (result->normal)->character = tmp___3;
  }
#line 1121
  if (! tmp___3) {
#line 1122
    goto ERROR4;
  }
  {
#line 1123
  tmp___4 = psiconv_basic_paragraph_layout();
#line 1123
  (result->normal)->paragraph = tmp___4;
  }
#line 1123
  if (! tmp___4) {
#line 1124
    goto ERROR5;
  }
#line 1125
  (result->normal)->hotkey = (psiconv_ucs2 )'N';
#line 1126
  (result->normal)->name = (psiconv_string_t )((void *)0);
#line 1127
  (result->normal)->built_in = (psiconv_bool_t )1;
#line 1128
  (result->normal)->outline_level = (psiconv_u32 )0;
#line 1129
  return (result);
  ERROR5: 
  {
#line 1131
  psiconv_free_character_layout((result->normal)->character);
  }
  ERROR4: 
  {
#line 1133
  free((void *)result->normal);
  }
  ERROR3: 
  {
#line 1135
  psiconv_list_free(result->styles);
  }
  ERROR2: 
  {
#line 1137
  free((void *)result);
  }
  ERROR1: 
#line 1139
  return ((psiconv_word_styles_section )((void *)0));
}
}
#line 1142 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_text_and_layout psiconv_empty_text_and_layout___0(void) 
{ 
  psiconv_list tmp ;

  {
  {
#line 1144
  tmp = psiconv_list_new(sizeof(struct psiconv_paragraph_s ));
  }
#line 1144
  return (tmp);
}
}
#line 1147 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_texted_section psiconv_empty_texted_section___0(void) 
{ 
  psiconv_texted_section result ;
  void *tmp ;
  psiconv_text_and_layout tmp___0 ;

  {
  {
#line 1150
  tmp = malloc(sizeof(*result));
#line 1150
  result = (psiconv_texted_section )tmp;
  }
#line 1150
  if (! result) {
#line 1151
    goto ERROR1;
  }
  {
#line 1152
  tmp___0 = psiconv_empty_text_and_layout___0();
#line 1152
  result->paragraphs = tmp___0;
  }
#line 1152
  if (! tmp___0) {
#line 1153
    goto ERROR2;
  }
#line 1154
  return (result);
  ERROR2: 
  {
#line 1156
  free((void *)result);
  }
  ERROR1: 
#line 1158
  return ((psiconv_texted_section )((void *)0));
}
}
#line 1161 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_page_header psiconv_empty_page_header___0(void) 
{ 
  psiconv_page_header result ;
  void *tmp ;
  psiconv_paragraph_layout tmp___0 ;
  psiconv_character_layout tmp___1 ;
  psiconv_texted_section tmp___2 ;

  {
  {
#line 1164
  tmp = malloc(sizeof(*result));
#line 1164
  result = (psiconv_page_header )tmp;
  }
#line 1164
  if (! result) {
#line 1165
    goto ERROR1;
  }
  {
#line 1166
  result->on_first_page = (psiconv_bool_t )1;
#line 1167
  tmp___0 = psiconv_basic_paragraph_layout();
#line 1167
  result->base_paragraph_layout = tmp___0;
  }
#line 1167
  if (! tmp___0) {
#line 1168
    goto ERROR2;
  }
  {
#line 1169
  tmp___1 = psiconv_basic_character_layout();
#line 1169
  result->base_character_layout = tmp___1;
  }
#line 1169
  if (! tmp___1) {
#line 1170
    goto ERROR3;
  }
  {
#line 1171
  tmp___2 = psiconv_empty_texted_section___0();
#line 1171
  result->text = tmp___2;
  }
#line 1171
  if (! tmp___2) {
#line 1172
    goto ERROR4;
  }
#line 1173
  return (result);
  ERROR4: 
  {
#line 1175
  psiconv_free_character_layout(result->base_character_layout);
  }
  ERROR3: 
  {
#line 1177
  psiconv_free_paragraph_layout(result->base_paragraph_layout);
  }
  ERROR2: 
  {
#line 1179
  free((void *)result);
  }
  ERROR1: 
#line 1181
  return ((psiconv_page_header )((void *)0));
}
}
#line 1184 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_page_layout_section psiconv_empty_page_layout_section___0(void) 
{ 
  psiconv_page_layout_section result ;
  void *tmp ;
  psiconv_length_t tmp___0 ;
  psiconv_length_t tmp___1 ;
  psiconv_length_t tmp___2 ;
  psiconv_page_header tmp___3 ;
  psiconv_page_header tmp___4 ;

  {
  {
#line 1187
  tmp = malloc(sizeof(*result));
#line 1187
  result = (psiconv_page_layout_section )tmp;
  }
#line 1187
  if (! result) {
#line 1188
    goto ERROR1;
  }
  {
#line 1189
  result->first_page_nr = (psiconv_u32 )1;
#line 1190
  tmp___0 = (psiconv_length_t )1.27;
#line 1190
  result->footer_dist = tmp___0;
#line 1190
  result->header_dist = tmp___0;
#line 1191
  tmp___1 = (psiconv_length_t )3.175;
#line 1191
  result->right_margin = tmp___1;
#line 1191
  result->left_margin = tmp___1;
#line 1192
  tmp___2 = (psiconv_length_t )2.54;
#line 1192
  result->bottom_margin = tmp___2;
#line 1192
  result->top_margin = tmp___2;
#line 1193
  result->page_width = (psiconv_length_t )21.0;
#line 1194
  result->page_height = (psiconv_length_t )29.7;
#line 1195
  result->landscape = (psiconv_bool_t )0;
#line 1196
  tmp___3 = psiconv_empty_page_header___0();
#line 1196
  result->header = tmp___3;
  }
#line 1196
  if (! tmp___3) {
#line 1197
    goto ERROR2;
  }
  {
#line 1198
  tmp___4 = psiconv_empty_page_header___0();
#line 1198
  result->footer = tmp___4;
  }
#line 1198
  if (! tmp___4) {
#line 1199
    goto ERROR3;
  }
#line 1200
  return (result);
  ERROR3: 
  {
#line 1202
  psiconv_free_page_header(result->header);
  }
  ERROR2: 
  {
#line 1204
  free((void *)result);
  }
  ERROR1: 
#line 1206
  return ((psiconv_page_layout_section )((void *)0));
}
}
#line 1209 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_word_status_section psiconv_empty_word_status_section___0(void) 
{ 
  psiconv_word_status_section result ;
  void *tmp ;
  psiconv_bool_t tmp___0 ;
  psiconv_bool_t tmp___1 ;
  psiconv_bool_t tmp___2 ;
  psiconv_bool_t tmp___3 ;
  psiconv_bool_t tmp___4 ;
  psiconv_bool_t tmp___5 ;
  psiconv_bool_t tmp___6 ;
  psiconv_bool_t tmp___7 ;

  {
  {
#line 1212
  tmp = malloc(sizeof(*result));
#line 1212
  result = (psiconv_word_status_section )tmp;
  }
#line 1212
  if (! result) {
#line 1213
    return ((psiconv_word_status_section )((void *)0));
  }
#line 1214
  tmp___4 = (psiconv_bool_t )0;
#line 1214
  result->fit_lines_to_screen = tmp___4;
#line 1214
  tmp___3 = tmp___4;
#line 1214
  result->show_hard_space = tmp___3;
#line 1214
  tmp___2 = tmp___3;
#line 1214
  result->show_hard_minus = tmp___2;
#line 1214
  tmp___1 = tmp___2;
#line 1214
  result->show_paragraph_ends = tmp___1;
#line 1214
  tmp___0 = tmp___1;
#line 1214
  result->show_spaces = tmp___0;
#line 1214
  result->show_tabs = tmp___0;
#line 1217
  tmp___7 = (psiconv_bool_t )1;
#line 1217
  result->show_side_toolbar = tmp___7;
#line 1217
  tmp___6 = tmp___7;
#line 1217
  result->show_top_toolbar = tmp___6;
#line 1217
  tmp___5 = tmp___6;
#line 1217
  result->show_full_graphs = tmp___5;
#line 1217
  result->show_full_pictures = tmp___5;
#line 1220
  result->cursor_position = (psiconv_u32 )0;
#line 1221
  result->display_size = (psiconv_u32 )1000;
#line 1222
  return (result);
}
}
#line 1225 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_word_f psiconv_empty_word_f___0(void) 
{ 
  psiconv_word_f result ;
  void *tmp ;
  psiconv_page_layout_section tmp___0 ;
  psiconv_text_and_layout tmp___1 ;
  psiconv_word_status_section tmp___2 ;
  psiconv_word_styles_section tmp___3 ;

  {
  {
#line 1228
  tmp = malloc(sizeof(*result));
#line 1228
  result = (psiconv_word_f )tmp;
  }
#line 1228
  if (! result) {
#line 1229
    goto ERROR1;
  }
  {
#line 1230
  tmp___0 = psiconv_empty_page_layout_section___0();
#line 1230
  result->page_sec = tmp___0;
  }
#line 1230
  if (! tmp___0) {
#line 1231
    goto ERROR2;
  }
  {
#line 1232
  tmp___1 = psiconv_empty_text_and_layout___0();
#line 1232
  result->paragraphs = tmp___1;
  }
#line 1232
  if (! tmp___1) {
#line 1233
    goto ERROR3;
  }
  {
#line 1234
  tmp___2 = psiconv_empty_word_status_section___0();
#line 1234
  result->status_sec = tmp___2;
  }
#line 1234
  if (! tmp___2) {
#line 1235
    goto ERROR4;
  }
  {
#line 1236
  tmp___3 = psiconv_empty_word_styles_section___0();
#line 1236
  result->styles_sec = tmp___3;
  }
#line 1236
  if (! tmp___3) {
#line 1237
    goto ERROR5;
  }
#line 1238
  return (result);
  ERROR5: 
  {
#line 1240
  psiconv_free_word_status_section(result->status_sec);
  }
  ERROR4: 
  {
#line 1242
  psiconv_free_text_and_layout(result->paragraphs);
  }
  ERROR3: 
  {
#line 1244
  psiconv_free_page_layout_section(result->page_sec);
  }
  ERROR2: 
  {
#line 1246
  free((void *)result);
  }
  ERROR1: 
#line 1248
  return ((psiconv_word_f )((void *)0));
}
}
#line 1251 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sheet_status_section psiconv_empty_sheet_status_section___0(void) 
{ 
  psiconv_sheet_status_section result ;
  void *tmp ;
  psiconv_triple_t tmp___0 ;
  psiconv_bool_t tmp___1 ;
  psiconv_bool_t tmp___2 ;
  psiconv_bool_t tmp___3 ;
  psiconv_u32 tmp___4 ;
  psiconv_u32 tmp___5 ;

  {
  {
#line 1254
  tmp = malloc(sizeof(*result));
#line 1254
  result = (psiconv_sheet_status_section )tmp;
  }
#line 1254
  if (! result) {
#line 1255
    return ((psiconv_sheet_status_section )((void *)0));
  }
#line 1256
  tmp___0 = (psiconv_triple_t )2;
#line 1256
  result->show_vertical_scrollbar = tmp___0;
#line 1256
  result->show_horizontal_scrollbar = tmp___0;
#line 1258
  result->show_graph = (psiconv_bool_t )0;
#line 1259
  tmp___3 = (psiconv_bool_t )1;
#line 1259
  result->show_side_graph_toolbar = tmp___3;
#line 1259
  tmp___2 = tmp___3;
#line 1259
  result->show_top_graph_toolbar = tmp___2;
#line 1259
  tmp___1 = tmp___2;
#line 1259
  result->show_side_sheet_toolbar = tmp___1;
#line 1259
  result->show_top_sheet_toolbar = tmp___1;
#line 1262
  tmp___4 = (psiconv_u32 )0;
#line 1262
  result->cursor_column = tmp___4;
#line 1262
  result->cursor_row = tmp___4;
#line 1263
  tmp___5 = (psiconv_u32 )1000;
#line 1263
  result->graph_display_size = tmp___5;
#line 1263
  result->sheet_display_size = tmp___5;
#line 1264
  return (result);
}
}
#line 1267 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_formula_list psiconv_empty_formula_list___0(void) 
{ 
  psiconv_list tmp ;

  {
  {
#line 1269
  tmp = psiconv_list_new(sizeof(struct psiconv_formula_s ));
  }
#line 1269
  return (tmp);
}
}
#line 1272 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sheet_workbook_section psiconv_empty_sheet_workbook_section___0(void) 
{ 
  psiconv_sheet_workbook_section result ;
  void *tmp ;
  psiconv_formula_list tmp___0 ;

  {
  {
#line 1275
  tmp = malloc(sizeof(*result));
#line 1275
  result = (psiconv_sheet_workbook_section )tmp;
  }
#line 1275
  if (! result) {
#line 1276
    goto ERROR1;
  }
  {
#line 1277
  tmp___0 = psiconv_empty_formula_list___0();
#line 1277
  result->formulas = tmp___0;
  }
#line 1277
  if (! tmp___0) {
#line 1278
    goto ERROR2;
  }
#line 1279
  return (result);
  ERROR2: 
  {
#line 1281
  free((void *)result);
  }
  ERROR1: 
#line 1283
  return ((psiconv_sheet_workbook_section )((void *)0));
}
}
#line 1287 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sheet_f psiconv_empty_sheet_f___0(void) 
{ 
  psiconv_sheet_f result ;
  void *tmp ;
  psiconv_page_layout_section tmp___0 ;
  psiconv_sheet_status_section tmp___1 ;
  psiconv_sheet_workbook_section tmp___2 ;

  {
  {
#line 1290
  tmp = malloc(sizeof(*result));
#line 1290
  result = (psiconv_sheet_f )tmp;
  }
#line 1290
  if (! result) {
#line 1291
    goto ERROR1;
  }
  {
#line 1292
  tmp___0 = psiconv_empty_page_layout_section___0();
#line 1292
  result->page_sec = tmp___0;
  }
#line 1292
  if (! tmp___0) {
#line 1293
    goto ERROR2;
  }
  {
#line 1294
  tmp___1 = psiconv_empty_sheet_status_section___0();
#line 1294
  result->status_sec = tmp___1;
  }
#line 1294
  if (! tmp___1) {
#line 1295
    goto ERROR3;
  }
  {
#line 1296
  tmp___2 = psiconv_empty_sheet_workbook_section___0();
#line 1296
  result->workbook_sec = tmp___2;
  }
#line 1296
  if (! tmp___2) {
#line 1297
    goto ERROR4;
  }
#line 1298
  return (result);
  ERROR4: 
  {
#line 1300
  psiconv_free_sheet_status_section(result->status_sec);
  }
  ERROR3: 
  {
#line 1302
  psiconv_free_page_layout_section(result->page_sec);
  }
  ERROR2: 
  {
#line 1304
  free((void *)result);
  }
  ERROR1: 
#line 1306
  return ((psiconv_sheet_f )((void *)0));
}
}
#line 1309 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_texted_f psiconv_empty_texted_f___0(void) 
{ 
  psiconv_texted_f result ;
  void *tmp ;
  psiconv_page_layout_section tmp___0 ;
  psiconv_texted_section tmp___1 ;

  {
  {
#line 1312
  tmp = malloc(sizeof(*result));
#line 1312
  result = (psiconv_texted_f )tmp;
  }
#line 1312
  if (! result) {
#line 1313
    goto ERROR1;
  }
  {
#line 1314
  tmp___0 = psiconv_empty_page_layout_section___0();
#line 1314
  result->page_sec = tmp___0;
  }
#line 1314
  if (! tmp___0) {
#line 1315
    goto ERROR2;
  }
  {
#line 1316
  tmp___1 = psiconv_empty_texted_section___0();
#line 1316
  result->texted_sec = tmp___1;
  }
#line 1316
  if (! tmp___1) {
#line 1317
    goto ERROR3;
  }
#line 1318
  return (result);
  ERROR3: 
  {
#line 1320
  psiconv_free_page_layout_section(result->page_sec);
  }
  ERROR2: 
  {
#line 1322
  free((void *)result);
  }
  ERROR1: 
#line 1324
  return ((psiconv_texted_f )((void *)0));
}
}
#line 1327 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_paint_data_section psiconv_empty_paint_data_section___0(void) 
{ 
  psiconv_paint_data_section result ;
  void *tmp ;
  psiconv_u32 tmp___0 ;
  psiconv_length_t tmp___1 ;
  psiconv_length_t tmp___2 ;
  float *tmp___3 ;
  void *tmp___4 ;
  float *tmp___5 ;
  void *tmp___6 ;
  float *tmp___7 ;
  void *tmp___8 ;

  {
  {
#line 1330
  tmp = malloc(sizeof(*result));
#line 1330
  result = (psiconv_paint_data_section )tmp;
  }
#line 1330
  if (! result) {
#line 1331
    goto ERROR1;
  }
  {
#line 1333
  tmp___2 = (psiconv_length_t )0;
#line 1333
  result->pic_ysize = tmp___2;
#line 1333
  tmp___1 = tmp___2;
#line 1333
  result->pic_xsize = tmp___1;
#line 1333
  tmp___0 = (psiconv_u32 )tmp___1;
#line 1333
  result->ysize = tmp___0;
#line 1333
  result->xsize = tmp___0;
#line 1335
  tmp___4 = malloc((size_t )0);
#line 1335
  tmp___3 = (float *)tmp___4;
#line 1335
  result->red = tmp___3;
  }
#line 1335
  if (! tmp___3) {
#line 1336
    goto ERROR2;
  }
  {
#line 1337
  tmp___6 = malloc((size_t )0);
#line 1337
  tmp___5 = (float *)tmp___6;
#line 1337
  result->green = tmp___5;
  }
#line 1337
  if (! tmp___5) {
#line 1338
    goto ERROR3;
  }
  {
#line 1339
  tmp___8 = malloc((size_t )0);
#line 1339
  tmp___7 = (float *)tmp___8;
#line 1339
  result->blue = tmp___7;
  }
#line 1339
  if (! tmp___7) {
#line 1340
    goto ERROR4;
  }
#line 1341
  return (result);
  ERROR4: 
  {
#line 1343
  free((void *)result->green);
  }
  ERROR3: 
  {
#line 1345
  free((void *)result->red);
  }
  ERROR2: 
  {
#line 1347
  free((void *)result);
  }
  ERROR1: 
#line 1349
  return ((psiconv_paint_data_section )((void *)0));
}
}
#line 1353 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_pictures psiconv_empty_pictures___0(void) 
{ 
  psiconv_pictures result ;
  psiconv_paint_data_section pds ;
  int tmp ;

  {
  {
#line 1357
  result = psiconv_list_new(sizeof(struct psiconv_paint_data_section_s ));
  }
#line 1357
  if (! result) {
#line 1358
    goto ERROR1;
  }
  {
#line 1359
  pds = psiconv_empty_paint_data_section___0();
  }
#line 1359
  if (! pds) {
#line 1360
    goto ERROR2;
  }
  {
#line 1361
  tmp = psiconv_list_add(result, (void const   *)pds);
  }
#line 1361
  if (tmp) {
#line 1362
    goto ERROR3;
  }
  {
#line 1363
  free((void *)pds);
  }
#line 1364
  return (result);
  ERROR3: 
  {
#line 1366
  psiconv_free_paint_data_section(pds);
  }
  ERROR2: 
  {
#line 1368
  psiconv_list_free(result);
  }
  ERROR1: 
#line 1370
  return ((psiconv_pictures )((void *)0));
}
}
#line 1373 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_mbm_f psiconv_empty_mbm_f___0(void) 
{ 
  psiconv_mbm_f result ;
  void *tmp ;
  psiconv_pictures tmp___0 ;

  {
  {
#line 1376
  tmp = malloc(sizeof(*result));
#line 1376
  result = (psiconv_mbm_f )tmp;
  }
#line 1376
  if (! result) {
#line 1377
    goto ERROR1;
  }
  {
#line 1378
  tmp___0 = psiconv_empty_pictures___0();
#line 1378
  result->sections = tmp___0;
  }
#line 1378
  if (! tmp___0) {
#line 1379
    goto ERROR2;
  }
#line 1380
  return (result);
  ERROR2: 
  {
#line 1382
  free((void *)result);
  }
  ERROR1: 
#line 1384
  return ((psiconv_mbm_f )((void *)0));
}
}
#line 1387 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sketch_section psiconv_empty_sketch_section___0(void) 
{ 
  psiconv_sketch_section result ;
  void *tmp ;
  psiconv_u16 tmp___0 ;
  psiconv_u16 tmp___1 ;
  psiconv_u16 tmp___2 ;
  psiconv_u16 tmp___3 ;
  psiconv_u16 tmp___4 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;
  float tmp___8 ;
  psiconv_paint_data_section tmp___9 ;

  {
  {
#line 1390
  tmp = malloc(sizeof(*result));
#line 1390
  result = (psiconv_sketch_section )tmp;
  }
#line 1390
  if (! result) {
#line 1391
    goto ERROR1;
  }
  {
#line 1392
  result->displayed_xsize = (psiconv_u16 )320;
#line 1393
  result->displayed_ysize = (psiconv_u16 )200;
#line 1394
  tmp___4 = (psiconv_u16 )0;
#line 1394
  result->displayed_size_y_offset = tmp___4;
#line 1394
  tmp___3 = tmp___4;
#line 1394
  result->displayed_size_x_offset = tmp___3;
#line 1394
  tmp___2 = tmp___3;
#line 1394
  result->form_ysize = tmp___2;
#line 1394
  tmp___1 = tmp___2;
#line 1394
  result->form_xsize = tmp___1;
#line 1394
  tmp___0 = tmp___1;
#line 1394
  result->picture_data_y_offset = tmp___0;
#line 1394
  result->picture_data_x_offset = tmp___0;
#line 1397
  tmp___5 = (float )1.0;
#line 1397
  result->magnification_y = tmp___5;
#line 1397
  result->magnification_x = tmp___5;
#line 1398
  tmp___8 = (float )0.0;
#line 1398
  result->cut_bottom = tmp___8;
#line 1398
  tmp___7 = tmp___8;
#line 1398
  result->cut_top = tmp___7;
#line 1398
  tmp___6 = tmp___7;
#line 1398
  result->cut_right = tmp___6;
#line 1398
  result->cut_left = tmp___6;
#line 1400
  tmp___9 = psiconv_empty_paint_data_section___0();
#line 1400
  result->picture = tmp___9;
  }
#line 1400
  if (! tmp___9) {
#line 1401
    goto ERROR2;
  }
#line 1402
  return (result);
  ERROR2: 
  {
#line 1404
  free((void *)result);
  }
  ERROR1: 
#line 1406
  return ((psiconv_sketch_section )((void *)0));
}
}
#line 1409 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sketch_f psiconv_empty_sketch_f___0(void) 
{ 
  psiconv_sketch_f result ;
  void *tmp ;
  psiconv_sketch_section tmp___0 ;

  {
  {
#line 1412
  tmp = malloc(sizeof(*result));
#line 1412
  result = (psiconv_sketch_f )tmp;
  }
#line 1412
  if (! result) {
#line 1413
    goto ERROR1;
  }
  {
#line 1414
  tmp___0 = psiconv_empty_sketch_section___0();
#line 1414
  result->sketch_sec = tmp___0;
  }
#line 1414
  if (! tmp___0) {
#line 1415
    goto ERROR2;
  }
#line 1416
  return (result);
  ERROR2: 
  {
#line 1418
  free((void *)result);
  }
  ERROR1: 
#line 1420
  return ((psiconv_sketch_f )((void *)0));
}
}
#line 1423 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_cliparts psiconv_empty_cliparts___0(void) 
{ 
  psiconv_list tmp ;

  {
  {
#line 1426
  tmp = psiconv_list_new(sizeof(struct psiconv_clipart_section_s ));
  }
#line 1426
  return (tmp);
}
}
#line 1429 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_clipart_f psiconv_empty_clipart_f___0(void) 
{ 
  psiconv_clipart_f result ;
  void *tmp ;
  psiconv_cliparts tmp___0 ;

  {
  {
#line 1432
  tmp = malloc(sizeof(*result));
#line 1432
  result = (psiconv_clipart_f )tmp;
  }
#line 1432
  if (! result) {
#line 1433
    goto ERROR1;
  }
  {
#line 1434
  tmp___0 = psiconv_empty_cliparts___0();
#line 1434
  result->sections = tmp___0;
  }
#line 1434
  if (! tmp___0) {
#line 1435
    goto ERROR2;
  }
#line 1436
  return (result);
  ERROR2: 
  {
#line 1438
  free((void *)result);
  }
  ERROR1: 
#line 1440
  return ((psiconv_clipart_f )((void *)0));
}
}
#line 40 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static struct formula_element formula_elements___0[256]  = 
#line 40 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
  {      {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )1, 2, "<"}, 
        {(psiconv_formula_type_t )2, 2, "<="}, 
        {(psiconv_formula_type_t )3, 2, ">"}, 
        {(psiconv_formula_type_t )4, 2, ">="}, 
        {(psiconv_formula_type_t )5, 2, "<>"}, 
        {(psiconv_formula_type_t )6, 2, "="}, 
        {(psiconv_formula_type_t )7, 2, "+"}, 
        {(psiconv_formula_type_t )8, 2, "-"}, 
        {(psiconv_formula_type_t )9, 2, "*"}, 
        {(psiconv_formula_type_t )10, 2, "/"}, 
        {(psiconv_formula_type_t )11, 2, "^"}, 
        {(psiconv_formula_type_t )12, 1, "+"}, 
        {(psiconv_formula_type_t )13, 1, "-"}, 
        {(psiconv_formula_type_t )14, 1, "NOT"}, 
        {(psiconv_formula_type_t )15, 2, "AND"}, 
        {(psiconv_formula_type_t )16, 2, "OR"}, 
        {(psiconv_formula_type_t )17, 2, "&"}, 
        {(psiconv_formula_type_t )18, 1, "()"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )19, 0, "End of formula"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )20, 0, "Floating point number"}, 
        {(psiconv_formula_type_t )21, 0, "Signed integer number"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )22, 0, "Named variable"}, 
        {(psiconv_formula_type_t )23, 0, "String"}, 
        {(psiconv_formula_type_t )24, 0, "Cell reference"}, 
        {(psiconv_formula_type_t )25, 0, "Cell block"}, 
        {(psiconv_formula_type_t )26, 0, "Cell block {varargs}"}, 
        {(psiconv_formula_type_t )27, 0, "Operand separator"}, 
        {(psiconv_formula_type_t )28, 0, "Operand list end"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )29, 0, "FALSE"}, 
        {(psiconv_formula_type_t )30, 3, "IF"}, 
        {(psiconv_formula_type_t )31, 0, "TRUE"}, 
        {(psiconv_formula_type_t )32, 2, "CELL"}, 
        {(psiconv_formula_type_t )33, 0, "ERRORTYPE"}, 
        {(psiconv_formula_type_t )34, 1, "ISBLANK"}, 
        {(psiconv_formula_type_t )35, 1, "ISERR"}, 
        {(psiconv_formula_type_t )36, 1, "ISERROR"}, 
        {(psiconv_formula_type_t )37, 1, "ISLOGICAL"}, 
        {(psiconv_formula_type_t )38, 1, "ISNA"}, 
        {(psiconv_formula_type_t )39, 1, "ISNONTEXT"}, 
        {(psiconv_formula_type_t )40, 1, "ISNUMBER"}, 
        {(psiconv_formula_type_t )41, 1, "ISTEXT"}, 
        {(psiconv_formula_type_t )42, 1, "N"}, 
        {(psiconv_formula_type_t )43, 1, "TYPE"}, 
        {(psiconv_formula_type_t )44, 2, "ADDRESS"}, 
        {(psiconv_formula_type_t )45, 1, "COLUMN"}, 
        {(psiconv_formula_type_t )46, 1, "COLUMNS"}, 
        {(psiconv_formula_type_t )47, 3, "HLOOKUP"}, 
        {(psiconv_formula_type_t )48, 3, "INDEX"}, 
        {(psiconv_formula_type_t )49, 1, "INDIRECT"}, 
        {(psiconv_formula_type_t )50, 3, "LOOKUP"}, 
        {(psiconv_formula_type_t )51, 3, "OFFSET"}, 
        {(psiconv_formula_type_t )52, 1, "ROW"}, 
        {(psiconv_formula_type_t )53, 1, "ROWS"}, 
        {(psiconv_formula_type_t )54, 3, "VLOOKUP"}, 
        {(psiconv_formula_type_t )55, 1, "CHAR"}, 
        {(psiconv_formula_type_t )56, 1, "CODE"}, 
        {(psiconv_formula_type_t )57, 2, "EXACT"}, 
        {(psiconv_formula_type_t )58, 3, "FIND"}, 
        {(psiconv_formula_type_t )59, 2, "LEFT"}, 
        {(psiconv_formula_type_t )60, 1, "LEN"}, 
        {(psiconv_formula_type_t )61, 1, "LOWER"}, 
        {(psiconv_formula_type_t )62, 3, "MID"}, 
        {(psiconv_formula_type_t )63, 1, "PROPER"}, 
        {(psiconv_formula_type_t )64, 4, "REPLACE"}, 
        {(psiconv_formula_type_t )65, 2, "REPT"}, 
        {(psiconv_formula_type_t )66, 2, "RIGHT"}, 
        {(psiconv_formula_type_t )67, 2, "STRING"}, 
        {(psiconv_formula_type_t )68, 1, "T"}, 
        {(psiconv_formula_type_t )69, 1, "TRIM"}, 
        {(psiconv_formula_type_t )70, 1, "UPPER"}, 
        {(psiconv_formula_type_t )71, 1, "VALUE"}, 
        {(psiconv_formula_type_t )72, 3, "DATE"}, 
        {(psiconv_formula_type_t )73, 1, "DATEVALUE"}, 
        {(psiconv_formula_type_t )74, 1, "DAY"}, 
        {(psiconv_formula_type_t )75, 1, "HOUR"}, 
        {(psiconv_formula_type_t )76, 1, "MINUTE"}, 
        {(psiconv_formula_type_t )77, 1, "MONTH"}, 
        {(psiconv_formula_type_t )78, 0, "NOW"}, 
        {(psiconv_formula_type_t )79, 1, "SECOND"}, 
        {(psiconv_formula_type_t )80, 0, "TODAY"}, 
        {(psiconv_formula_type_t )81, 3, "TIME"}, 
        {(psiconv_formula_type_t )82, 1, "TIMEVALUE"}, 
        {(psiconv_formula_type_t )83, 1, "YEAR"}, 
        {(psiconv_formula_type_t )84, 1, "ABS"}, 
        {(psiconv_formula_type_t )85, 1, "ACOS"}, 
        {(psiconv_formula_type_t )86, 1, "ASIN"}, 
        {(psiconv_formula_type_t )87, 1, "ATAN"}, 
        {(psiconv_formula_type_t )88, 2, "ATAN2"}, 
        {(psiconv_formula_type_t )89, 1, "COS"}, 
        {(psiconv_formula_type_t )90, 0, "DEGREES"}, 
        {(psiconv_formula_type_t )91, 1, "EXP"}, 
        {(psiconv_formula_type_t )92, 1, "FACT"}, 
        {(psiconv_formula_type_t )93, 1, "INT"}, 
        {(psiconv_formula_type_t )94, 1, "LN"}, 
        {(psiconv_formula_type_t )95, 1, "LOG10"}, 
        {(psiconv_formula_type_t )96, 2, "MOD"}, 
        {(psiconv_formula_type_t )97, 0, "PI"}, 
        {(psiconv_formula_type_t )98, 1, "RADIANS"}, 
        {(psiconv_formula_type_t )99, 0, "RAND"}, 
        {(psiconv_formula_type_t )100, 2, "ROUND"}, 
        {(psiconv_formula_type_t )101, 1, "SIGN"}, 
        {(psiconv_formula_type_t )102, 1, "SIN"}, 
        {(psiconv_formula_type_t )103, 1, "SQRT"}, 
        {(psiconv_formula_type_t )104, 2, "SUMPRODUCT"}, 
        {(psiconv_formula_type_t )105, 1, "TAN"}, 
        {(psiconv_formula_type_t )106, 1, "TRUNC"}, 
        {(psiconv_formula_type_t )107, 3, "CTERM"}, 
        {(psiconv_formula_type_t )108, 4, "DDB"}, 
        {(psiconv_formula_type_t )109, 3, "FV"}, 
        {(psiconv_formula_type_t )110, 2, "IRR"}, 
        {(psiconv_formula_type_t )111, 2, "NPV"}, 
        {(psiconv_formula_type_t )112, 3, "PMT"}, 
        {(psiconv_formula_type_t )113, 3, "PV"}, 
        {(psiconv_formula_type_t )114, 3, "RATE"}, 
        {(psiconv_formula_type_t )115, 3, "SLN"}, 
        {(psiconv_formula_type_t )116, 4, "SYD"}, 
        {(psiconv_formula_type_t )117, 3, "TERM"}, 
        {(psiconv_formula_type_t )118, 2, "COMBIN"}, 
        {(psiconv_formula_type_t )119, 2, "PERMUT"}, 
        {(psiconv_formula_type_t )120, -1, "AVERAGE"}, 
        {(psiconv_formula_type_t )121, -1, "CHOOSE"}, 
        {(psiconv_formula_type_t )122, -1, "COUNT"}, 
        {(psiconv_formula_type_t )123, -1, "COUNTA"}, 
        {(psiconv_formula_type_t )124, -1, "COUNTBLANK"}, 
        {(psiconv_formula_type_t )125, -1, "MAX"}, 
        {(psiconv_formula_type_t )126, -1, "MIN"}, 
        {(psiconv_formula_type_t )127, -1, "PRODUCT"}, 
        {(psiconv_formula_type_t )128, -1, "STDEVP"}, 
        {(psiconv_formula_type_t )129, -1, "STDEV"}, 
        {(psiconv_formula_type_t )130, -1, "SUM"}, 
        {(psiconv_formula_type_t )131, -1, "SUMSQ"}, 
        {(psiconv_formula_type_t )132, -1, "VARP"}, 
        {(psiconv_formula_type_t )133, -1, "VAR"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}};
#line 296 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static int psiconv_parse_sheet_ref___0(psiconv_config const   config , psiconv_buffer const   buf ,
                                       int lev , psiconv_u32 off , int *length , psiconv_sheet_ref_t *result ) 
{ 
  int res ;
  psiconv_u16 temp ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 304
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a sheet ref");
#line 305
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the offset encoding");
#line 306
  temp = psiconv_read_u16(config, buf, lev + 2, off, & res);
  }
#line 307
  if (res) {
#line 308
    if (length) {
#line 309
      *length = 0;
    }
#line 310
    return (res);
  }
  {
#line 312
  psiconv_debug((psiconv_config )config, lev + 2, off, "Encoded word: %04x", (int )temp);
  }
#line 313
  if ((int )temp & 16384) {
#line 313
    result->absolute = (psiconv_bool_t )1;
  } else {
#line 313
    result->absolute = (psiconv_bool_t )0;
  }
#line 314
  if ((int )temp & 32768) {
#line 314
    tmp = -1;
  } else {
#line 314
    tmp = 1;
  }
#line 314
  result->offset = (psiconv_s16 )(((int )temp & 16383) * tmp);
#line 315
  if (result->absolute) {
#line 315
    tmp___0 = "absolute";
  } else {
#line 315
    tmp___0 = "relative";
  }
  {
#line 315
  psiconv_debug((psiconv_config )config, lev + 2, off, "Reference: %s offset %d",
                tmp___0, (int )result->offset);
  }
#line 317
  if (length) {
#line 318
    *length = 2;
  }
#line 319
  return (0);
}
}
#line 322 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static int psiconv_parse_sheet_cell_reference___0(psiconv_config const   config ,
                                                  psiconv_buffer const   buf , int lev ,
                                                  psiconv_u32 off , int *length ,
                                                  psiconv_sheet_cell_reference_t *result ) 
{ 
  int len ;
  int leng ;
  int res ;
  psiconv_u8 temp ;

  {
  {
#line 327
  len = 0;
#line 331
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read a sheet cell reference");
#line 332
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the row reference");
#line 333
  res = psiconv_parse_sheet_ref___0(config, buf, lev + 2, off + (psiconv_u32 )len,
                                    & leng, & result->row);
  }
#line 333
  if (res) {
#line 334
    goto ERROR;
  }
  {
#line 335
  len += leng;
#line 336
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the column reference");
#line 337
  res = psiconv_parse_sheet_ref___0(config, buf, lev + 2, off + (psiconv_u32 )len,
                                    & leng, & result->column);
  }
#line 337
  if (res) {
#line 338
    goto ERROR;
  }
  {
#line 339
  len += leng;
#line 341
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the trailing byte (%02x expected)",
                   0);
#line 343
  temp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 344
  if (res) {
#line 345
    goto ERROR;
  }
#line 346
  if ((int )temp != 0) {
    {
#line 347
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unknown byte in cell reference (ignored");
#line 348
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Trailing byte: %02x",
                  (int )temp);
    }
  }
  {
#line 350
  len ++;
#line 351
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of cell reference (total length: %08x)",
                   len);
  }
#line 353
  if (length) {
#line 354
    *length = len;
  }
#line 355
  return (0);
  ERROR: 
#line 357
  if (length) {
#line 358
    *length = 0;
  }
#line 359
  return (res);
}
}
#line 362 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static int psiconv_parse_sheet_cell_block___0(psiconv_config const   config , psiconv_buffer const   buf ,
                                              int lev , psiconv_u32 off , int *length ,
                                              psiconv_sheet_cell_block_t *result ) 
{ 
  int len ;
  int leng ;
  int res ;

  {
  {
#line 367
  len = 0;
#line 370
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read a sheet cell block");
#line 371
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the first cell");
#line 372
  res = psiconv_parse_sheet_cell_reference___0(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & leng, & result->first);
  }
#line 372
  if (res) {
#line 374
    goto ERROR;
  }
  {
#line 375
  len += leng;
#line 376
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the last cell");
#line 377
  res = psiconv_parse_sheet_cell_reference___0(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & leng, & result->last);
  }
#line 377
  if (res) {
#line 379
    goto ERROR;
  }
  {
#line 380
  len += leng;
#line 381
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of cell block (total length: %08x)",
                   len);
  }
#line 383
  if (length) {
#line 384
    *length = len;
  }
#line 385
  return (0);
  ERROR: 
#line 387
  if (length) {
#line 388
    *length = 0;
  }
#line 389
  return (res);
}
}
#line 392 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static int psiconv_parse_formula_element_list___0(psiconv_config const   config ,
                                                  psiconv_buffer const   buf , int lev ,
                                                  psiconv_u32 off , int *length ,
                                                  psiconv_formula *result , psiconv_u32 maxlen ) 
{ 
  int res ;
  int len ;
  int leng ;
  int eof ;
  psiconv_u8 marker ;
  psiconv_u8 submarker ;
  psiconv_u8 submarker2 ;
  psiconv_formula_list formula_stack ;
  psiconv_formula formula ;
  psiconv_formula subformula ;
  psiconv_formula subformula1 ;
  psiconv_formula subformula2 ;
  psiconv_formula subformula3 ;
  psiconv_formula subformula4 ;
  psiconv_u16 temp ;
  psiconv_u16 nr_of_subs ;
  psiconv_formula tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  psiconv_formula_list tmp___6 ;
  psiconv_formula_list tmp___7 ;
  psiconv_formula_type_t tmp___8 ;
  psiconv_formula_type_t tmp___9 ;
  psiconv_formula_type_t tmp___10 ;
  psiconv_formula_type_t tmp___11 ;
  psiconv_u32 tmp___12 ;
  psiconv_u32 tmp___13 ;

  {
  {
#line 398
  res = 0;
#line 399
  len = 0;
#line 401
  eof = 0;
#line 408
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a formula element list");
#line 409
  tmp___0 = malloc(sizeof(*(*result)));
#line 409
  tmp = (psiconv_formula )tmp___0;
#line 409
  *result = tmp;
  }
#line 409
  if (! tmp) {
#line 410
    goto ERROR1;
  }
  {
#line 411
  formula_stack = psiconv_list_new(sizeof(struct psiconv_formula_s ));
  }
#line 411
  if (! formula_stack) {
#line 412
    goto ERROR2;
  }
  {
#line 413
  tmp___1 = malloc(sizeof(*formula));
#line 413
  formula = (psiconv_formula )tmp___1;
  }
#line 413
  if (! formula) {
#line 414
    goto ERROR3;
  }
  {
#line 416
  formula->type = (psiconv_formula_type_t )0;
#line 417
  tmp___2 = malloc(sizeof(*subformula1));
#line 417
  subformula1 = (psiconv_formula )tmp___2;
  }
#line 417
  if (! subformula1) {
#line 418
    goto ERROR4;
  }
  {
#line 419
  subformula1->type = (psiconv_formula_type_t )0;
#line 420
  tmp___3 = malloc(sizeof(*subformula2));
#line 420
  subformula2 = (psiconv_formula )tmp___3;
  }
#line 420
  if (! subformula2) {
#line 421
    goto ERROR5;
  }
  {
#line 422
  subformula2->type = (psiconv_formula_type_t )0;
#line 423
  tmp___4 = malloc(sizeof(*subformula3));
#line 423
  subformula3 = (psiconv_formula )tmp___4;
  }
#line 423
  if (! subformula3) {
#line 424
    goto ERROR6;
  }
  {
#line 425
  subformula3->type = (psiconv_formula_type_t )0;
#line 426
  tmp___5 = malloc(sizeof(*subformula4));
#line 426
  subformula4 = (psiconv_formula )tmp___5;
  }
#line 426
  if (! subformula4) {
#line 427
    goto ERROR7;
  }
#line 428
  subformula4->type = (psiconv_formula_type_t )0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! eof) {
#line 430
      if (! ((psiconv_u32 )len + off < maxlen)) {
#line 430
        goto while_break;
      }
    } else {
#line 430
      goto while_break;
    }
    {
#line 431
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read a formula item marker");
#line 432
    marker = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
    }
#line 433
    if (res) {
#line 434
      goto ERROR8;
    }
    {
#line 435
    psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Marker: %02x (%s)",
                  (int )marker, formula_elements___0[marker].name);
#line 437
    len ++;
    }
#line 439
    if ((unsigned int )formula_elements___0[marker].formula_type == 0U) {
      {
#line 440
      psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Unknown formula marker found!");
      }
#line 441
      goto ERROR8;
    } else
#line 442
    if ((unsigned int )formula_elements___0[marker].formula_type == 19U) {
      {
#line 448
      len --;
#line 449
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "End of this formula list");
#line 450
      eof = 1;
      }
    } else
#line 442
    if ((unsigned int )formula_elements___0[marker].formula_type == 28U) {
      {
#line 448
      len --;
#line 449
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "End of this formula list");
#line 450
      eof = 1;
      }
    } else
#line 442
    if ((unsigned int )formula_elements___0[marker].formula_type == 27U) {
      {
#line 448
      len --;
#line 449
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "End of this formula list");
#line 450
      eof = 1;
      }
    } else
#line 451
    if ((unsigned int )formula_elements___0[marker].formula_type == 21U) {
      {
#line 453
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: an integer");
#line 454
      formula->data.dat_int = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & res);
      }
#line 455
      if (res) {
#line 456
        goto ERROR8;
      }
      {
#line 457
      formula->type = formula_elements___0[marker].formula_type;
#line 458
      psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Value: %08x",
                    formula->data.dat_int);
#line 459
      len += 4;
#line 460
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 460
      if (res) {
#line 461
        goto ERROR8;
      }
#line 462
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 463
    if ((unsigned int )formula_elements___0[marker].formula_type == 20U) {
      {
#line 465
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a float");
#line 466
      formula->data.dat_float = psiconv_read_float(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                   & leng, & res);
      }
#line 468
      if (res) {
#line 469
        goto ERROR8;
      }
      {
#line 470
      formula->type = formula_elements___0[marker].formula_type;
#line 471
      psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Value: %f",
                    formula->data.dat_float);
#line 472
      len += leng;
#line 473
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 473
      if (res) {
#line 474
        goto ERROR8;
      }
#line 475
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 476
    if ((unsigned int )formula_elements___0[marker].formula_type == 24U) {
      {
#line 478
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a cell reference");
#line 479
      res = psiconv_parse_sheet_cell_reference___0(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                   & leng, & formula->data.dat_cellref);
      }
#line 479
      if (res) {
#line 481
        goto ERROR8;
      }
      {
#line 482
      formula->type = formula_elements___0[marker].formula_type;
#line 483
      len += leng;
#line 484
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 484
      if (res) {
#line 485
        goto ERROR8;
      }
#line 486
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 487
    if ((unsigned int )formula_elements___0[marker].formula_type == 25U) {
#line 487
      goto _L;
    } else
#line 487
    if ((unsigned int )formula_elements___0[marker].formula_type == 26U) {
      _L: /* CIL Label */ 
      {
#line 491
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a cell block");
#line 492
      res = psiconv_parse_sheet_cell_block___0(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & leng, & formula->data.dat_cellblock);
      }
#line 492
      if (res) {
#line 494
        goto ERROR8;
      }
      {
#line 495
      formula->type = formula_elements___0[marker].formula_type;
#line 496
      len += leng;
#line 497
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 497
      if (res) {
#line 498
        goto ERROR8;
      }
#line 499
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 500
    if ((unsigned int )formula_elements___0[marker].formula_type == 23U) {
      {
#line 502
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a string");
#line 503
      formula->data.dat_string = psiconv_read_short_string(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                           & leng, & res);
      }
#line 505
      if (res) {
#line 506
        goto ERROR8;
      }
      {
#line 507
      formula->type = formula_elements___0[marker].formula_type;
#line 508
      len += leng;
#line 509
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 509
      if (res) {
#line 510
        goto ERROR8;
      }
#line 511
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 512
    if ((unsigned int )formula_elements___0[marker].formula_type == 22U) {
      {
#line 514
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a variable reference");
#line 515
      formula->data.dat_variable = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                    & res);
      }
#line 516
      if (res) {
#line 517
        goto ERROR8;
      }
      {
#line 518
      formula->type = formula_elements___0[marker].formula_type;
#line 519
      len += 4;
#line 520
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 520
      if (res) {
#line 521
        goto ERROR8;
      }
#line 522
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 523
    if (formula_elements___0[marker].number_of_args == -1) {
      {
#line 524
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Going to parse a vararg function");
#line 525
      tmp___6 = psiconv_list_new(sizeof(*formula));
#line 525
      formula->data.fun_operands = tmp___6;
      }
#line 525
      if (! tmp___6) {
#line 527
        goto ERROR8;
      }
#line 528
      formula->type = formula_elements___0[marker].formula_type;
#line 529
      nr_of_subs = (psiconv_u16 )0;
      {
#line 530
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 531
        nr_of_subs = (psiconv_u16 )((int )nr_of_subs + 1);
#line 532
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read vararg argument %d", (int )nr_of_subs);
#line 534
        res = psiconv_parse_formula_element_list___0(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                     & leng, & subformula, maxlen);
        }
#line 534
        if (res) {
#line 536
          goto ERROR8;
        }
        {
#line 537
        len += leng;
#line 538
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula);
        }
#line 538
        if (res) {
          {
#line 539
          psiconv_free_formula(subformula);
          }
#line 540
          goto ERROR8;
        }
        {
#line 542
        free((void *)subformula);
#line 543
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read the next marker");
#line 544
        submarker = psiconv_read_u8(config, buf, lev + 4, off + (psiconv_u32 )len,
                                    & res);
#line 545
        len ++;
        }
#line 546
        if (res) {
#line 547
          goto ERROR8;
        }
        {
#line 548
        submarker2 = psiconv_read_u8(config, buf, lev + 4, off + (psiconv_u32 )len,
                                     & res);
        }
#line 549
        if (res) {
#line 550
          goto ERROR8;
        }
#line 530
        if ((unsigned int )formula_elements___0[submarker].formula_type == 27U) {
#line 530
          if (! ((unsigned int )formula_elements___0[submarker2].formula_type != 28U)) {
#line 530
            goto while_break___0;
          }
        } else {
#line 530
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 555
      if ((unsigned int )formula_elements___0[submarker].formula_type == 27U) {
#line 555
        if ((unsigned int )formula_elements___0[submarker2].formula_type == 28U) {
#line 559
          submarker = submarker2;
#line 560
          len ++;
        }
      }
#line 562
      if ((unsigned int )formula_elements___0[submarker].formula_type != 28U) {
        {
#line 564
        psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Formula corrupted!");
#line 565
        psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Found unexpected marker %02x",
                      (int )submarker);
        }
#line 566
        goto ERROR8;
      }
      {
#line 568
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Going to read the repeated marker %02x", (int )marker);
#line 570
      submarker = psiconv_read_u8(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
      }
#line 571
      if (res) {
#line 572
        goto ERROR8;
      }
#line 573
      if ((int )submarker != (int )marker) {
        {
#line 574
        psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Formula corrupted!");
#line 575
        psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Expected marker %02x, found %02x",
                      (int )marker, (int )submarker);
        }
#line 577
        goto ERROR8;
      }
      {
#line 579
      len ++;
#line 580
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Going to read the number of arguments (%d expected)", (int )nr_of_subs);
#line 583
      temp = psiconv_read_u16(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
      }
#line 584
      if (res) {
#line 585
        goto ERROR8;
      }
#line 586
      if ((int )temp != (int )nr_of_subs) {
        {
#line 587
        psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Formula corrupted!");
#line 588
        psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Read %d arguments, but formula says there are %d",
                      (int )nr_of_subs, (int )temp);
        }
#line 591
        goto ERROR8;
      }
      {
#line 593
      len += 2;
#line 594
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 594
      if (res) {
#line 595
        goto ERROR8;
      }
#line 596
      formula->type = (psiconv_formula_type_t )0;
    } else {
#line 598
      if (formula_elements___0[marker].number_of_args > 0) {
        {
#line 599
        res = psiconv_list_pop(formula_stack, (void *)subformula1);
        }
#line 599
        if (res) {
#line 600
          goto ERROR8;
        }
      }
#line 601
      if (formula_elements___0[marker].number_of_args > 1) {
        {
#line 602
        res = psiconv_list_pop(formula_stack, (void *)subformula2);
        }
#line 602
        if (res) {
#line 603
          goto ERROR8;
        }
      }
#line 604
      if (formula_elements___0[marker].number_of_args > 2) {
        {
#line 605
        res = psiconv_list_pop(formula_stack, (void *)subformula3);
        }
#line 605
        if (res) {
#line 606
          goto ERROR8;
        }
      }
#line 607
      if (formula_elements___0[marker].number_of_args > 3) {
        {
#line 608
        res = psiconv_list_pop(formula_stack, (void *)subformula4);
        }
#line 608
        if (res) {
#line 609
          goto ERROR8;
        }
      }
      {
#line 610
      tmp___7 = psiconv_list_new(sizeof(*formula));
#line 610
      formula->data.fun_operands = tmp___7;
      }
#line 610
      if (! tmp___7) {
#line 612
        goto ERROR8;
      }
#line 613
      formula->type = formula_elements___0[marker].formula_type;
#line 614
      if (formula_elements___0[marker].number_of_args > 3) {
        {
#line 615
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula4);
        }
#line 615
        if (res) {
#line 616
          goto ERROR8;
        }
      }
#line 617
      if (formula_elements___0[marker].number_of_args > 2) {
        {
#line 618
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula3);
        }
#line 618
        if (res) {
#line 619
          goto ERROR8;
        }
      }
#line 620
      if (formula_elements___0[marker].number_of_args > 1) {
        {
#line 621
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula2);
        }
#line 621
        if (res) {
#line 622
          goto ERROR8;
        }
      }
#line 623
      if (formula_elements___0[marker].number_of_args > 0) {
        {
#line 624
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula1);
        }
#line 624
        if (res) {
#line 625
          goto ERROR8;
        }
      }
      {
#line 626
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 626
      if (res) {
#line 627
        goto ERROR8;
      }
#line 628
      tmp___11 = (psiconv_formula_type_t )0;
#line 628
      formula->type = tmp___11;
#line 628
      tmp___10 = tmp___11;
#line 628
      subformula1->type = tmp___10;
#line 628
      tmp___9 = tmp___10;
#line 628
      subformula2->type = tmp___9;
#line 628
      tmp___8 = tmp___9;
#line 628
      subformula3->type = tmp___8;
#line 628
      subformula4->type = tmp___8;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  if ((psiconv_u32 )len + off > maxlen) {
    {
#line 633
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Formula corrupted!");
#line 634
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Expected end: %04x, found end: %04x",
                  maxlen, (psiconv_u32 )len + off);
    }
#line 636
    goto ERROR8;
  } else
#line 632
  if (! eof) {
    {
#line 633
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Formula corrupted!");
#line 634
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Expected end: %04x, found end: %04x",
                  maxlen, (psiconv_u32 )len + off);
    }
#line 636
    goto ERROR8;
  }
  {
#line 638
  tmp___13 = psiconv_list_length((psiconv_list const   )formula_stack);
  }
#line 638
  if (tmp___13 != 1U) {
    {
#line 639
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Formula corrupted!");
#line 640
    tmp___12 = psiconv_list_length((psiconv_list const   )formula_stack);
#line 640
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "More than one item left on the stack (%d)",
                  tmp___12);
    }
#line 642
    goto ERROR8;
  }
  {
#line 644
  res = psiconv_list_pop(formula_stack, (void *)*result);
  }
#line 644
  if (res) {
#line 645
    goto ERROR8;
  }
  {
#line 646
  psiconv_list_free(formula_stack);
#line 647
  free((void *)formula);
  }
#line 649
  if (length) {
#line 650
    *length = len;
  }
  {
#line 652
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of formula element list (total length: %08x)",
                   len);
  }
#line 654
  return (0);
  ERROR8: 
  {
#line 657
  psiconv_free_formula(subformula4);
  }
  ERROR7: 
  {
#line 659
  psiconv_free_formula(subformula3);
  }
  ERROR6: 
  {
#line 661
  psiconv_free_formula(subformula2);
  }
  ERROR5: 
  {
#line 663
  psiconv_free_formula(subformula1);
  }
  ERROR4: 
  {
#line 665
  psiconv_free_formula(formula);
  }
  ERROR3: 
  {
#line 667
  psiconv_free_formula_list(formula_stack);
  }
  ERROR2: 
  {
#line 669
  free((void *)*result);
  }
  ERROR1: 
  {
#line 671
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of formula element list failed");
  }
#line 672
  if (length) {
#line 673
    *length = 0;
  }
#line 674
  if (! res) {
#line 675
    return (-2);
  } else {
#line 677
    return (res);
  }
}
}
#line 34 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_simple.c"
static int psiconv_write_string_aux___0(psiconv_config const   config , psiconv_buffer buf ,
                                        int lev , psiconv_string_t const   value ,
                                        int kind ) ;
#line 222 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_simple.c"
static int psiconv_write_string_aux___0(psiconv_config const   config , psiconv_buffer buf ,
                                        int lev , psiconv_string_t const   value ,
                                        int kind ) 
{ 
  int res ;
  int i ;
  int len ;
  char *printable ;

  {
  {
#line 228
  len = psiconv_unicode_strlen((psiconv_ucs2 const   *)value);
  }
#line 229
  if (! value) {
    {
#line 230
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "NULL string");
    }
#line 231
    return (-4);
  }
  {
#line 234
  printable = psiconv_make_printable(config, value);
  }
#line 234
  if (! printable) {
    {
#line 235
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Out of memory error");
    }
#line 236
    return (-2);
  }
  {
#line 238
  psiconv_debug((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Value: %s", printable);
#line 239
  free((void *)printable);
  }
#line 241
  if (kind == -1) {
    {
#line 242
    res = psiconv_write_S(config, buf, lev + 2, (psiconv_u32 const   )len);
    }
  } else
#line 243
  if (kind == -2) {
    {
#line 244
    res = psiconv_write_u8(config, buf, lev + 2, (psiconv_u8 const   )len);
    }
  } else {
#line 246
    res = 0;
  }
#line 247
  if (res) {
#line 248
    return (res);
  }
#line 250
  i = 0;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (i < len)) {
#line 250
      goto while_break;
    }
    {
#line 251
    res = psiconv_unicode_write_char(config, buf, lev + 2, *(value + i));
    }
#line 251
    if (res) {
#line 252
      return (res);
    }
#line 250
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  return (0);
}
}
#line 28 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/checkuid.c"
static psiconv_u32 uid1___1[32]  = 
#line 28 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/checkuid.c"
  {      (psiconv_u32 )17824,      (psiconv_u32 )35648,      (psiconv_u32 )1697,      (psiconv_u32 )3394, 
        (psiconv_u32 )6788,      (psiconv_u32 )13576,      (psiconv_u32 )27152,      (psiconv_u32 )54304, 
        (psiconv_u32 )1168113664,      2336227328U,      (psiconv_u32 )111214592,      (psiconv_u32 )222429184, 
        (psiconv_u32 )444858368,      (psiconv_u32 )889716736,      (psiconv_u32 )1779433472,      3558866944U, 
        (psiconv_u32 )43601,      (psiconv_u32 )17539,      (psiconv_u32 )35078,      (psiconv_u32 )557, 
        (psiconv_u32 )1114,      (psiconv_u32 )2228,      (psiconv_u32 )4456,      (psiconv_u32 )8912, 
        2857435136U,      (psiconv_u32 )1149435904,      2298871808U,      (psiconv_u32 )36503552, 
        (psiconv_u32 )73007104,      (psiconv_u32 )146014208,      (psiconv_u32 )292028416,      (psiconv_u32 )584056832};
#line 62 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/checkuid.c"
static psiconv_u32 uid2___1[32]  = 
#line 62
  {      (psiconv_u32 )30388,      (psiconv_u32 )60776,      (psiconv_u32 )51953,      (psiconv_u32 )34243, 
        (psiconv_u32 )7079,      (psiconv_u32 )14158,      (psiconv_u32 )28316,      (psiconv_u32 )56632, 
        (psiconv_u32 )1991507968,      3983015936U,      3404791808U,      2244149248U, 
        (psiconv_u32 )463929344,      (psiconv_u32 )927858688,      (psiconv_u32 )1855717376,      3711434752U, 
        (psiconv_u32 )14128,      (psiconv_u32 )28256,      (psiconv_u32 )56512,      (psiconv_u32 )43425, 
        (psiconv_u32 )17251,      (psiconv_u32 )34502,      (psiconv_u32 )7597,      (psiconv_u32 )15194, 
        (psiconv_u32 )925892608,      (psiconv_u32 )1851785216,      3703570432U,      2845900800U, 
        (psiconv_u32 )1130561536,      2261123072U,      (psiconv_u32 )497876992,      (psiconv_u32 )995753984};
#line 96 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/checkuid.c"
static psiconv_u32 uid3___1[32]  = 
#line 96
  {      (psiconv_u32 )13105,      (psiconv_u32 )26210,      (psiconv_u32 )52420,      (psiconv_u32 )35241, 
        (psiconv_u32 )883,      (psiconv_u32 )1766,      (psiconv_u32 )3532,      (psiconv_u32 )7064, 
        (psiconv_u32 )858849280,      (psiconv_u32 )1717698560,      3435397120U,      2309554176U, 
        (psiconv_u32 )57868288,      (psiconv_u32 )115736576,      (psiconv_u32 )231473152,      (psiconv_u32 )462946304, 
        (psiconv_u32 )4129,      (psiconv_u32 )8258,      (psiconv_u32 )16516,      (psiconv_u32 )33032, 
        (psiconv_u32 )4657,      (psiconv_u32 )9314,      (psiconv_u32 )18628,      (psiconv_u32 )37256, 
        (psiconv_u32 )270598144,      (psiconv_u32 )541196288,      (psiconv_u32 )1082392576,      2164785152U, 
        (psiconv_u32 )305201152,      (psiconv_u32 )610402304,      (psiconv_u32 )1220804608,      2441609216U};
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/error.c"
static void psiconv_default_error_handler___0(int kind , psiconv_u32 off , char const   *message ) 
{ 


  {
  {
#line 36
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          message);
  }
#line 37
  return;
}
}
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
static psiconv_sheet_cell_layout psiconv_basic_cell_layout___0(void) 
{ 
  psiconv_sheet_cell_layout result ;
  void *tmp ;
  psiconv_character_layout tmp___0 ;
  psiconv_paragraph_layout tmp___1 ;
  psiconv_sheet_numberformat tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 35
  tmp = malloc(sizeof(*result));
#line 35
  result = (psiconv_sheet_cell_layout )tmp;
  }
#line 35
  if (! result) {
#line 36
    goto ERROR1;
  }
  {
#line 37
  tmp___0 = psiconv_basic_character_layout();
#line 37
  result->character = tmp___0;
  }
#line 37
  if (! tmp___0) {
#line 38
    goto ERROR2;
  }
  {
#line 39
  tmp___1 = psiconv_basic_paragraph_layout();
#line 39
  result->paragraph = tmp___1;
  }
#line 39
  if (! tmp___1) {
#line 40
    goto ERROR3;
  }
  {
#line 41
  tmp___3 = malloc(sizeof(*(result->numberformat)));
#line 41
  tmp___2 = (psiconv_sheet_numberformat )tmp___3;
#line 41
  result->numberformat = tmp___2;
  }
#line 41
  if (! tmp___2) {
#line 42
    goto ERROR4;
  }
#line 43
  (result->numberformat)->code = (psiconv_sheet_numberformat_code_t )0;
#line 44
  (result->numberformat)->decimal = (psiconv_u8 )2;
#line 45
  return (result);
  ERROR4: 
  {
#line 47
  psiconv_free_paragraph_layout(result->paragraph);
  }
  ERROR3: 
  {
#line 49
  psiconv_free_character_layout(result->character);
  }
  ERROR2: 
  {
#line 51
  free((void *)result);
  }
  ERROR1: 
#line 53
  return ((psiconv_sheet_cell_layout )((void *)0));
}
}
#line 56 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
static psiconv_sheet_cell_layout psiconv_clone_cell_layout___0(psiconv_sheet_cell_layout original ) 
{ 
  psiconv_sheet_cell_layout result ;
  void *tmp ;
  psiconv_character_layout tmp___0 ;
  psiconv_paragraph_layout tmp___1 ;
  psiconv_sheet_numberformat tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 60
  tmp = malloc(sizeof(*result));
#line 60
  result = (psiconv_sheet_cell_layout )tmp;
  }
#line 60
  if (! result) {
#line 61
    goto ERROR1;
  }
  {
#line 62
  tmp___0 = psiconv_clone_character_layout(original->character);
#line 62
  result->character = tmp___0;
  }
#line 62
  if (! tmp___0) {
#line 64
    goto ERROR2;
  }
  {
#line 65
  tmp___1 = psiconv_clone_paragraph_layout(original->paragraph);
#line 65
  result->paragraph = tmp___1;
  }
#line 65
  if (! tmp___1) {
#line 67
    goto ERROR3;
  }
  {
#line 68
  tmp___3 = malloc(sizeof(*(result->numberformat)));
#line 68
  tmp___2 = (psiconv_sheet_numberformat )tmp___3;
#line 68
  result->numberformat = tmp___2;
  }
#line 68
  if (! tmp___2) {
#line 69
    goto ERROR4;
  }
#line 70
  (result->numberformat)->code = (original->numberformat)->code;
#line 71
  (result->numberformat)->decimal = (original->numberformat)->decimal;
#line 72
  return (result);
  ERROR4: 
  {
#line 74
  psiconv_free_paragraph_layout(result->paragraph);
  }
  ERROR3: 
  {
#line 76
  psiconv_free_character_layout(result->character);
  }
  ERROR2: 
  {
#line 78
  free((void *)result);
  }
  ERROR1: 
#line 80
  return ((psiconv_sheet_cell_layout )((void *)0));
}
}
#line 83 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
static psiconv_sheet_cell_reference_t psiconv_read_var_cellref___0(psiconv_config const   config ,
                                                                   psiconv_buffer const   buf ,
                                                                   int lev , psiconv_u32 off ,
                                                                   int *length , int *status ) 
{ 
  int len ;
  int res ;
  psiconv_sheet_cell_reference_t result ;
  psiconv_u32 temp ;
  psiconv_u8 tmp ;

  {
  {
#line 89
  len = 0;
#line 94
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read a sheet cell reference");
#line 95
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the initial byte (%02x expected)",
                   0);
#line 97
  tmp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 97
  temp = (psiconv_u32 )tmp;
  }
#line 98
  if (res) {
#line 99
    goto ERROR1;
  }
#line 100
  if (temp != 0U) {
    {
#line 101
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet cell reference initial byte unknown value (ignored)");
#line 103
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Initial byte: %02x",
                  temp);
    }
  }
  {
#line 105
  len ++;
#line 107
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 108
  if (res) {
#line 109
    goto ERROR1;
  }
#line 110
  if (temp & 4294901760U) {
    {
#line 111
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet cell row reference to unknown row (reset)");
    }
  }
  {
#line 114
  result.row.offset = (psiconv_s16 )temp;
#line 115
  result.row.absolute = (psiconv_bool_t )1;
#line 116
  len += 4;
#line 118
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 119
  if (res) {
#line 120
    goto ERROR1;
  }
#line 121
  if (temp & 4294901760U) {
    {
#line 122
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet cell column reference to unknown row (reset)");
    }
  }
#line 125
  result.column.offset = (psiconv_s16 )temp;
#line 126
  result.column.absolute = (psiconv_bool_t )1;
#line 127
  len += 4;
#line 129
  if (length) {
#line 130
    *length = len;
  }
  {
#line 132
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet column reference (total length: %08x)",
                   len);
  }
#line 134
  return (result);
  ERROR1: 
  {
#line 136
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Column Reference failed");
  }
#line 137
  if (length) {
#line 138
    *length = 0;
  }
#line 139
  if (status) {
#line 140
    if (res) {
#line 140
      *status = res;
    } else {
#line 140
      *status = -2;
    }
  }
#line 141
  return (result);
}
}
#line 144 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
static psiconv_sheet_cell_block_t psiconv_read_var_cellblock___0(psiconv_config const   config ,
                                                                 psiconv_buffer const   buf ,
                                                                 int lev , psiconv_u32 off ,
                                                                 int *length , int *status ) 
{ 
  int len ;
  int res ;
  psiconv_sheet_cell_block_t result ;
  psiconv_u32 temp ;
  psiconv_u8 tmp ;

  {
  {
#line 150
  len = 0;
#line 155
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read a sheet cell block reference");
#line 156
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the initial byte (%02x expected)",
                   0);
#line 158
  tmp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 158
  temp = (psiconv_u32 )tmp;
  }
#line 159
  if (res) {
#line 160
    goto ERROR1;
  }
#line 161
  if (temp != 0U) {
    {
#line 162
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet cell reference initial byte unknown value (ignored)");
#line 164
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Initial byte: %02x",
                  temp);
    }
  }
  {
#line 166
  len ++;
#line 168
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 169
  if (res) {
#line 170
    goto ERROR1;
  }
#line 171
  if (temp & 4294901760U) {
    {
#line 172
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet block initial row reference to unknown row (reset)");
    }
  }
  {
#line 175
  result.first.row.offset = (psiconv_s16 )temp;
#line 176
  result.first.row.absolute = (psiconv_bool_t )1;
#line 177
  len += 4;
#line 179
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 180
  if (res) {
#line 181
    goto ERROR1;
  }
#line 182
  if (temp & 4294901760U) {
    {
#line 183
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet block initial column reference to unknown row (reset)");
    }
  }
  {
#line 186
  result.first.column.offset = (psiconv_s16 )temp;
#line 187
  result.first.column.absolute = (psiconv_bool_t )1;
#line 188
  len += 4;
#line 190
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 191
  if (res) {
#line 192
    goto ERROR1;
  }
#line 193
  if (temp & 4294901760U) {
    {
#line 194
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet block final row reference to unknown row (reset)");
    }
  }
  {
#line 197
  result.last.row.offset = (psiconv_s16 )temp;
#line 198
  result.last.row.absolute = (psiconv_bool_t )1;
#line 199
  len += 4;
#line 201
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 202
  if (res) {
#line 203
    goto ERROR1;
  }
#line 204
  if (temp & 4294901760U) {
    {
#line 205
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet block final column reference to unknown row (reset)");
    }
  }
#line 208
  result.last.column.offset = (psiconv_s16 )temp;
#line 209
  result.last.column.absolute = (psiconv_bool_t )1;
#line 210
  len += 4;
#line 212
  if (length) {
#line 213
    *length = len;
  }
  {
#line 215
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet cell block reference (total length: %08x)",
                   len);
  }
#line 218
  return (result);
  ERROR1: 
  {
#line 220
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Cell Block Reference failed");
  }
#line 221
  if (length) {
#line 222
    *length = 0;
  }
#line 223
  if (status) {
#line 224
    if (res) {
#line 224
      *status = res;
    } else {
#line 224
      *status = -2;
    }
  }
#line 225
  return (result);
}
}
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
static psiconv_ucs2 unicode_paint___0[10]  = 
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
  {      (psiconv_ucs2 )'P',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'i',      (psiconv_ucs2 )'n', 
        (psiconv_ucs2 )'t',      (psiconv_ucs2 )'.',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'p', 
        (psiconv_ucs2 )'p',      (psiconv_ucs2 )0};
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
static psiconv_ucs2 unicode_texted___0[11]  = 
#line 33
  {      (psiconv_ucs2 )'T',      (psiconv_ucs2 )'e',      (psiconv_ucs2 )'x',      (psiconv_ucs2 )'t', 
        (psiconv_ucs2 )'E',      (psiconv_ucs2 )'d',      (psiconv_ucs2 )'.',      (psiconv_ucs2 )'a', 
        (psiconv_ucs2 )'p',      (psiconv_ucs2 )'p',      (psiconv_ucs2 )0};
#line 34 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
static psiconv_ucs2 unicode_word___0[9]  = 
#line 34
  {      (psiconv_ucs2 )'W',      (psiconv_ucs2 )'o',      (psiconv_ucs2 )'r',      (psiconv_ucs2 )'d', 
        (psiconv_ucs2 )'.',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'p',      (psiconv_ucs2 )'p', 
        (psiconv_ucs2 )0};
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
static int psiconv_parse_layout_section___0(psiconv_config const   config , psiconv_buffer const   buf ,
                                            int lev , psiconv_u32 off , int *length ,
                                            psiconv_text_and_layout result , psiconv_word_styles_section styles___1 ,
                                            int with_styles ) ;
#line 40
static psiconv_file_type_t psiconv_determine_embedded_object_type___0(psiconv_config const   config ,
                                                                      psiconv_buffer const   buf ,
                                                                      int lev , int *status ) ;
#line 391 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
static int psiconv_parse_layout_section___0(psiconv_config const   config , psiconv_buffer const   buf ,
                                            int lev , psiconv_u32 off , int *length ,
                                            psiconv_text_and_layout result , psiconv_word_styles_section styles___1 ,
                                            int with_styles ) 
{ 
  int res ;
  int len ;
  psiconv_u32 temp ;
  int parse_styles ;
  int nr ;
  int i ;
  int j ;
  int total ;
  int leng ;
  int line_length ;
  anon_style_list anon_styles ;
  struct anon_style_s anon ;
  anon_style anon_ptr ;
  psiconv_character_layout temp_char ;
  psiconv_paragraph_layout temp_para ;
  psiconv_word_style temp_style ;
  psiconv_paragraph para ;
  struct psiconv_in_line_layout_s in_line ;
  int *inline_count ;
  psiconv_u16 tmp ;
  psiconv_u8 tmp___0 ;
  psiconv_u32 tmp___1 ;
  psiconv_u8 tmp___2 ;
  psiconv_u32 tmp___3 ;
  psiconv_u32 tmp___4 ;
  psiconv_u32 tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  psiconv_in_line_layouts tmp___8 ;
  psiconv_character_layout tmp___9 ;
  psiconv_paragraph_layout tmp___10 ;
  psiconv_u32 tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  psiconv_u8 tmp___15 ;
  void *tmp___16 ;
  psiconv_u32 tmp___17 ;
  psiconv_u32 tmp___18 ;
  psiconv_u8 tmp___19 ;
  psiconv_u32 tmp___20 ;
  psiconv_u32 tmp___21 ;
  void *tmp___22 ;
  psiconv_u8 tmp___23 ;
  psiconv_u32 tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  psiconv_u32 tmp___27 ;
  void *tmp___28 ;
  psiconv_u32 tmp___29 ;
  void *tmp___30 ;
  psiconv_u32 tmp___31 ;

  {
  {
#line 399
  res = 0;
#line 400
  len = 0;
#line 416
  anon_ptr = (anon_style )((void *)0);
#line 427
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read the layout section");
#line 429
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the section type");
#line 430
  tmp = psiconv_read_u16(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 430
  temp = (psiconv_u32 )tmp;
  }
#line 431
  if (res) {
#line 432
    goto ERROR1;
  }
  {
#line 433
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Type: %02x",
                temp);
#line 434
  parse_styles = with_styles;
  }
#line 435
  if (temp == 1U) {
#line 435
    if (! with_styles) {
      {
#line 436
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Styleless layout section expected, but styled section found!");
#line 438
      parse_styles = 1;
      }
    } else {
#line 435
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 439
  if (temp == 0U) {
#line 439
    if (with_styles) {
      {
#line 440
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Styled layout section expected, but styleless section found!");
#line 442
      parse_styles = 0;
      }
    } else {
#line 439
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 443
  if (temp != 0U) {
#line 443
    if (temp != 1U) {
      {
#line 444
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Layout section type indicator has unknown value!");
      }
    }
  }
  {
#line 447
  len += 2;
#line 449
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read paragraph type list");
#line 450
  anon_styles = psiconv_list_new(sizeof(anon));
  }
#line 450
  if (! anon_styles) {
#line 451
    goto ERROR1;
  }
  {
#line 452
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read paragraph type list length");
#line 453
  tmp___0 = psiconv_read_u8(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
#line 453
  nr = (int )tmp___0;
  }
#line 454
  if (res) {
#line 455
    goto ERROR2;
  }
  {
#line 456
  psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Length: %02x",
                nr);
#line 457
  len ++;
#line 459
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the paragraph type list elements");
#line 461
  i = 0;
  }
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    if (! (i < nr)) {
#line 461
      goto while_break;
    }
    {
#line 462
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Element %d",
                     i);
#line 463
    tmp___1 = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
#line 463
    anon.nr = (int )tmp___1;
    }
#line 464
    if (res) {
#line 465
      goto ERROR3;
    }
    {
#line 466
    psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Number: %08x",
                  anon.nr);
#line 467
    len += 4;
#line 469
    psiconv_progress((psiconv_config )config, lev + 4, off, "Going to determine the base style");
    }
#line 470
    if (parse_styles) {
      {
#line 471
      temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
      }
#line 472
      if (res) {
#line 473
        goto ERROR3;
      }
      {
#line 474
      tmp___2 = psiconv_read_u8(config, buf, lev + 3, ((off + (psiconv_u32 )len) + 4U) + temp,
                                & res);
#line 474
      anon.base_style = (psiconv_s16 )tmp___2;
      }
#line 475
      if (res) {
#line 476
        goto ERROR3;
      }
      {
#line 477
      psiconv_debug((psiconv_config )config, lev + 4, (off + (psiconv_u32 )len) + temp,
                    "Style indicator: %02x", (int )anon.base_style);
      }
    } else {
#line 480
      anon.base_style = (psiconv_s16 )0;
    }
    {
#line 481
    temp_style = psiconv_get_style(styles___1, (int )anon.base_style);
    }
#line 481
    if (! temp_style) {
      {
#line 482
      psiconv_warn((psiconv_config )config, lev + 4, off, "Unknown Style referenced");
#line 483
      temp_style = psiconv_get_style(styles___1, (int )anon.base_style);
      }
#line 483
      if (! temp_style) {
        {
#line 484
        psiconv_warn((psiconv_config )config, lev + 4, off, "Base style unknown");
        }
#line 485
        goto ERROR3;
      }
    }
    {
#line 488
    anon.paragraph = psiconv_clone_paragraph_layout(temp_style->paragraph);
    }
#line 488
    if (! anon.paragraph) {
#line 490
      goto ERROR3;
    }
    {
#line 491
    anon.character = psiconv_clone_character_layout(temp_style->character);
    }
#line 491
    if (! anon.character) {
#line 493
      goto ERROR3_1;
    }
    {
#line 495
    psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to read the paragraph layout");
#line 496
    res = psiconv_parse_paragraph_layout_list(config, buf, lev + 4, off + (psiconv_u32 )len,
                                              & leng, anon.paragraph);
    }
#line 496
    if (res) {
#line 498
      goto ERROR3_2;
    }
#line 499
    len += leng;
#line 500
    if (parse_styles) {
#line 501
      len ++;
    }
    {
#line 503
    psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to read the character layout");
#line 504
    res = psiconv_parse_character_layout_list(config, buf, lev + 4, off + (psiconv_u32 )len,
                                              & leng, anon.character);
    }
#line 504
    if (res) {
#line 506
      goto ERROR3_2;
    }
    {
#line 507
    len += leng;
#line 508
    res = psiconv_list_add(anon_styles, (void const   *)(& anon));
    }
#line 508
    if (res) {
#line 509
      goto ERROR3_2;
    }
#line 461
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 512
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to parse the paragraph element list");
#line 513
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the number of paragraphs");
#line 514
  tmp___3 = psiconv_read_u32(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
#line 514
  nr = (int )tmp___3;
  }
#line 515
  if (res) {
#line 516
    goto ERROR3;
  }
  {
#line 517
  tmp___5 = psiconv_list_length((psiconv_list const   )result);
  }
#line 517
  if ((psiconv_u32 )nr != tmp___5) {
    {
#line 518
    psiconv_warn((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Number of text paragraphs and paragraph elements does not match");
#line 520
    tmp___4 = psiconv_list_length((psiconv_list const   )result);
#line 520
    psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "%d text paragraphs, %d paragraph elements",
                  tmp___4, nr);
    }
  }
  {
#line 524
  psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Number of paragraphs: %d",
                nr);
#line 525
  len += 4;
#line 526
  tmp___6 = malloc((unsigned long )nr * sizeof(*inline_count));
#line 526
  inline_count = (int *)tmp___6;
  }
#line 526
  if (! inline_count) {
#line 527
    goto ERROR3;
  }
  {
#line 529
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the paragraph elements");
#line 530
  i = 0;
  }
  {
#line 530
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 530
    if (! (i < nr)) {
#line 530
      goto while_break___0;
    }
    {
#line 531
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Element %d",
                     i);
#line 532
    tmp___11 = psiconv_list_length((psiconv_list const   )result);
    }
#line 532
    if ((psiconv_u32 )i >= tmp___11) {
      {
#line 533
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to allocate a new element");
#line 534
      tmp___7 = malloc(sizeof(*para));
#line 534
      para = (psiconv_paragraph )tmp___7;
      }
#line 534
      if (! para) {
#line 535
        goto ERROR4;
      }
      {
#line 536
      tmp___8 = psiconv_list_new(sizeof(struct psiconv_in_line_layout_s ));
#line 536
      para->in_lines = tmp___8;
      }
#line 536
      if (! tmp___8) {
#line 538
        goto ERROR4_1;
      }
      {
#line 539
      para->base_style = (psiconv_s16 )0;
#line 540
      tmp___9 = psiconv_basic_character_layout();
#line 540
      para->base_character = tmp___9;
      }
#line 540
      if (! tmp___9) {
#line 541
        goto ERROR4_2;
      }
      {
#line 542
      tmp___10 = psiconv_basic_paragraph_layout();
#line 542
      para->base_paragraph = tmp___10;
      }
#line 542
      if (! tmp___10) {
#line 543
        goto ERROR4_3;
      }
      {
#line 544
      res = psiconv_list_add(result, (void const   *)para);
      }
#line 544
      if (res) {
#line 545
        goto ERROR4_4;
      }
      {
#line 546
      free((void *)para);
      }
    }
    {
#line 548
    tmp___12 = psiconv_list_get((psiconv_list const   )result, (psiconv_u32 )i);
#line 548
    para = (psiconv_paragraph )tmp___12;
    }
#line 548
    if (! para) {
#line 549
      goto ERROR4;
    }
    {
#line 551
    psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to read the paragraph length");
#line 552
    temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
    }
#line 553
    if (res) {
#line 554
      goto ERROR4;
    }
    {
#line 555
    tmp___14 = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
    }
#line 555
    if (temp != (psiconv_u32 )(tmp___14 + 1)) {
      {
#line 556
      psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Disagreement of the length of paragraph in layout section");
#line 558
      tmp___13 = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
#line 558
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Paragraph length: layout section says %d, counted %d",
                    temp, tmp___13 + 1);
      }
    } else {
      {
#line 562
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Paragraph length: %d",
                    temp);
      }
    }
    {
#line 563
    len += 4;
#line 565
    psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to read the paragraph type");
#line 566
    tmp___15 = psiconv_read_u8(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
#line 566
    temp = (psiconv_u32 )tmp___15;
    }
#line 567
    if (res) {
#line 568
      goto ERROR4;
    }
#line 569
    if (temp != 0U) {
      {
#line 570
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Type: %02x",
                    temp);
#line 571
      j = 0;
      }
      {
#line 571
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 571
        tmp___17 = psiconv_list_length((psiconv_list const   )anon_styles);
        }
#line 571
        if (! ((psiconv_u32 )j < tmp___17)) {
#line 571
          goto while_break___1;
        }
        {
#line 572
        tmp___16 = psiconv_list_get((psiconv_list const   )anon_styles, (psiconv_u32 )j);
#line 572
        anon_ptr = (anon_style )tmp___16;
        }
#line 572
        if (! anon_ptr) {
          {
#line 573
          psiconv_error((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Data structure corruption");
          }
#line 574
          goto ERROR4;
        }
#line 576
        if (temp == (psiconv_u32 )anon_ptr->nr) {
#line 577
          goto while_break___1;
        }
#line 571
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 579
      tmp___18 = psiconv_list_length((psiconv_list const   )anon_styles);
      }
#line 579
      if ((psiconv_u32 )j == tmp___18) {
        {
#line 580
        psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Layout section paragraph type unknown");
#line 581
        psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Unknown type - using base styles instead");
#line 582
        para->base_style = (psiconv_s16 )0;
#line 583
        temp_style = psiconv_get_style(styles___1, 0);
        }
#line 583
        if (! temp_style) {
          {
#line 584
          psiconv_error((psiconv_config )config, lev + 4, off, "Base style unknown");
          }
#line 585
          goto ERROR4;
        }
        {
#line 587
        temp_para = psiconv_clone_paragraph_layout(temp_style->paragraph);
        }
#line 587
        if (! temp_para) {
#line 589
          goto ERROR4;
        }
        {
#line 590
        psiconv_free_paragraph_layout(para->base_paragraph);
#line 591
        para->base_paragraph = temp_para;
#line 593
        temp_char = psiconv_clone_character_layout(temp_style->character);
        }
#line 593
        if (! temp_char) {
#line 595
          goto ERROR4;
        }
        {
#line 596
        psiconv_free_character_layout(para->base_character);
#line 597
        para->base_character = temp_char;
        }
      } else {
        {
#line 599
        para->base_style = anon_ptr->base_style;
#line 600
        temp_para = psiconv_clone_paragraph_layout(anon_ptr->paragraph);
        }
#line 600
        if (! temp_para) {
#line 601
          goto ERROR4;
        }
        {
#line 602
        psiconv_free_paragraph_layout(para->base_paragraph);
#line 603
        para->base_paragraph = temp_para;
#line 605
        temp_char = psiconv_clone_character_layout(anon_ptr->character);
        }
#line 605
        if (! temp_char) {
#line 606
          goto ERROR4;
        }
        {
#line 607
        psiconv_free_character_layout(para->base_character);
#line 608
        para->base_character = temp_char;
        }
      }
#line 610
      *(inline_count + i) = 0;
#line 611
      len ++;
    } else {
      {
#line 613
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Type: %02x (not based on a paragraph type)",
                    temp);
#line 615
      len ++;
      }
#line 616
      if (parse_styles) {
        {
#line 617
        temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
        }
#line 618
        if (res) {
#line 619
          goto ERROR4;
        }
        {
#line 620
        psiconv_progress((psiconv_config )config, lev + 4, ((off + (psiconv_u32 )len) + temp) + 4U,
                         "Going to read the paragraph element base style");
#line 622
        tmp___19 = psiconv_read_u8(config, buf, lev + 4, ((off + (psiconv_u32 )len) + temp) + 4U,
                                   & res);
#line 622
        temp = (psiconv_u32 )tmp___19;
        }
#line 623
        if (res) {
#line 624
          goto ERROR4;
        }
        {
#line 625
        psiconv_debug((psiconv_config )config, lev + 4, ((off + (psiconv_u32 )len) + temp) + 4U,
                      "Style: %02x", temp);
        }
      } else {
#line 627
        temp = (psiconv_u32 )0;
      }
      {
#line 629
      temp_style = psiconv_get_style(styles___1, (int )temp);
      }
#line 629
      if (! temp_style) {
        {
#line 630
        psiconv_warn((psiconv_config )config, lev + 4, off, "Unknown Style referenced");
#line 631
        temp_style = psiconv_get_style(styles___1, 0);
        }
#line 631
        if (! temp_style) {
          {
#line 632
          psiconv_error((psiconv_config )config, lev + 4, off, "Base style unknown");
          }
#line 633
          goto ERROR4;
        }
      }
      {
#line 637
      temp_para = psiconv_clone_paragraph_layout(temp_style->paragraph);
      }
#line 637
      if (! temp_para) {
#line 638
        goto ERROR4;
      }
      {
#line 639
      psiconv_free_paragraph_layout(para->base_paragraph);
#line 640
      para->base_paragraph = temp_para;
#line 642
      temp_char = psiconv_clone_character_layout(temp_style->character);
      }
#line 642
      if (! temp_char) {
#line 643
        goto ERROR4;
      }
      {
#line 644
      psiconv_free_character_layout(para->base_character);
#line 645
      para->base_character = temp_char;
#line 647
      para->base_style = (psiconv_s16 )temp;
#line 648
      psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                       "Going to read paragraph layout");
#line 649
      res = psiconv_parse_paragraph_layout_list(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                & leng, para->base_paragraph);
      }
#line 649
      if (res) {
#line 651
        goto ERROR4;
      }
#line 652
      len += leng;
#line 653
      if (parse_styles) {
#line 654
        len ++;
      }
      {
#line 655
      psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                       "Going to read number of in-line layout elements");
#line 657
      tmp___20 = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
#line 657
      *(inline_count + i) = (int )tmp___20;
      }
#line 658
      if (res) {
#line 659
        goto ERROR4;
      }
      {
#line 660
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Nr: %08x",
                    *(inline_count + i));
#line 661
      len += 4;
      }
    }
#line 530
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 665
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the text layout inline list");
#line 667
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the number of elements");
#line 668
  tmp___21 = psiconv_read_u32(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
#line 668
  nr = (int )tmp___21;
  }
#line 669
  if (res) {
#line 670
    goto ERROR4;
  }
  {
#line 671
  psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Elements: %08x",
                nr);
#line 672
  len += 4;
#line 674
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the text layout inline elements");
#line 676
  total = 0;
#line 677
  i = 0;
  }
  {
#line 677
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 677
    tmp___27 = psiconv_list_length((psiconv_list const   )result);
    }
#line 677
    if (! ((psiconv_u32 )i < tmp___27)) {
#line 677
      goto while_break___2;
    }
    {
#line 678
    tmp___22 = psiconv_list_get((psiconv_list const   )result, (psiconv_u32 )i);
#line 678
    para = (psiconv_paragraph )tmp___22;
    }
#line 678
    if (! para) {
      {
#line 679
      psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Data structure corruption");
      }
#line 680
      goto ERROR4;
    }
#line 682
    line_length = -1;
#line 683
    j = 0;
    {
#line 683
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 683
      if (! (j < *(inline_count + i))) {
#line 683
        goto while_break___3;
      }
      {
#line 684
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Element %d: Paragraph %d, element %d", total, i, j);
      }
#line 686
      if (total >= nr) {
        {
#line 687
        psiconv_warn((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Layout section inlines: not enough element");
#line 689
        psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Can\'t read element!");
        }
      } else {
        {
#line 691
        total ++;
#line 692
        in_line.object = (psiconv_embedded_object_section )((void *)0);
#line 693
        in_line.layout = (psiconv_character_layout )((void *)0);
#line 694
        in_line.layout = psiconv_clone_character_layout(para->base_character);
        }
#line 694
        if (! in_line.layout) {
#line 696
          goto ERROR4;
        }
        {
#line 697
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read the element type");
#line 698
        tmp___23 = psiconv_read_u8(config, buf, lev + 4, (psiconv_u32 )len + off,
                                   & res);
#line 698
        temp = (psiconv_u32 )tmp___23;
        }
#line 699
        if (res) {
#line 700
          goto ERROR5;
        }
        {
#line 701
        len ++;
#line 702
        psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Type: %02x",
                      temp);
#line 703
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read the number of characters it applies to");
#line 705
        tmp___24 = psiconv_read_u32(config, buf, lev + 4, (psiconv_u32 )len + off,
                                    & res);
#line 705
        in_line.length = (int )tmp___24;
        }
#line 706
        if (res) {
#line 707
          goto ERROR5;
        }
        {
#line 708
        psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Length: %02x",
                      in_line.length);
#line 709
        len += 4;
#line 710
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read the character layout");
#line 711
        res = psiconv_parse_character_layout_list(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                  & leng, in_line.layout);
        }
#line 711
        if (res) {
#line 713
          goto ERROR5;
        }
#line 714
        len += leng;
#line 716
        if (temp == 1U) {
          {
#line 717
          psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Found an embedded object");
#line 718
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to read the object marker (0x%08x expected)", 268435537);
#line 720
          temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
          }
#line 721
          if (res) {
#line 722
            goto ERROR5;
          }
#line 723
          if (temp != 268435537U) {
            {
#line 724
            psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Unknown id marks embedded object");
#line 725
            psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                          "Marker: read %08x, expected %08x", temp, 268435537);
            }
          }
          {
#line 728
          len += 4;
#line 729
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to read the Embedded Object Section offset");
#line 731
          temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
          }
#line 732
          if (res) {
#line 733
            goto ERROR5;
          }
          {
#line 734
          psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Offset: %08x", temp);
#line 735
          len += 4;
#line 736
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to parse the Embedded Object Section");
#line 738
          res = psiconv_parse_embedded_object_section(config, buf, lev + 4, temp,
                                                      (int *)((void *)0), & in_line.object);
          }
#line 738
          if (res) {
#line 740
            goto ERROR5;
          }
          {
#line 741
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to read the object width");
#line 743
          in_line.object_width = psiconv_read_length(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                     & leng, & res);
          }
#line 745
          if (res) {
#line 746
            goto ERROR5;
          }
          {
#line 747
          psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Object width: %f cm", (double )in_line.object_width);
#line 749
          len += leng;
#line 750
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to read the object height");
#line 752
          in_line.object_height = psiconv_read_length(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                      & leng, & res);
          }
#line 754
          if (res) {
#line 755
            goto ERROR5;
          }
          {
#line 756
          psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Object height: %f cm", (double )in_line.object_height);
#line 758
          len += leng;
          }
        } else
#line 759
        if (temp != 0U) {
          {
#line 760
          psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                       "Layout section unknown inline type");
          }
        }
        {
#line 762
        tmp___26 = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
        }
#line 762
        if (line_length + in_line.length > tmp___26) {
          {
#line 763
          psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                       "Layout section inlines: line length mismatch");
#line 765
          res = -1;
#line 766
          tmp___25 = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
#line 766
          in_line.length = tmp___25 - line_length;
          }
        }
        {
#line 768
        line_length += in_line.length;
#line 769
        res = psiconv_list_add(para->in_lines, (void const   *)(& in_line));
        }
#line 769
        if (res) {
#line 770
          goto ERROR5;
        }
      }
#line 683
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 677
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 775
  if (total != nr) {
    {
#line 776
    psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Layout section too many inlines, skipping remaining");
    }
  }
  {
#line 780
  free((void *)inline_count);
#line 782
  i = 0;
  }
  {
#line 782
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 782
    tmp___29 = psiconv_list_length((psiconv_list const   )anon_styles);
    }
#line 782
    if (! ((psiconv_u32 )i < tmp___29)) {
#line 782
      goto while_break___4;
    }
    {
#line 783
    tmp___28 = psiconv_list_get((psiconv_list const   )anon_styles, (psiconv_u32 )i);
#line 783
    anon_ptr = (anon_style )tmp___28;
    }
#line 783
    if (! anon_ptr) {
      {
#line 784
      psiconv_error((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Data structure corruption");
      }
#line 785
      goto ERROR2;
    }
    {
#line 787
    psiconv_free_character_layout(anon_ptr->character);
#line 788
    psiconv_free_paragraph_layout(anon_ptr->paragraph);
#line 782
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 790
  psiconv_list_free(anon_styles);
  }
#line 792
  if (length) {
#line 793
    *length = len;
  }
  {
#line 795
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of layout section (total length: %08x)", len);
  }
#line 798
  return (0);
  ERROR4_4: 
  {
#line 801
  psiconv_free_paragraph_layout(para->base_paragraph);
  }
  ERROR4_3: 
  {
#line 803
  psiconv_free_character_layout(para->base_character);
  }
  ERROR4_2: 
  {
#line 805
  psiconv_list_free(para->in_lines);
  }
  ERROR4_1: 
  {
#line 807
  free((void *)para);
  }
#line 808
  goto ERROR4;
  ERROR3_2: 
  {
#line 811
  psiconv_free_character_layout(anon.character);
  }
  ERROR3_1: 
  {
#line 813
  psiconv_free_paragraph_layout(anon.paragraph);
  }
#line 814
  goto ERROR3;
  ERROR5: 
#line 817
  if (in_line.layout) {
    {
#line 818
    psiconv_free_character_layout(in_line.layout);
    }
  }
#line 819
  if (in_line.object) {
    {
#line 820
    psiconv_free_embedded_object_section(in_line.object);
    }
  }
  ERROR4: 
  {
#line 822
  free((void *)inline_count);
  }
  ERROR3: 
#line 824
  i = 0;
  {
#line 824
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 824
    tmp___31 = psiconv_list_length((psiconv_list const   )anon_styles);
    }
#line 824
    if (! ((psiconv_u32 )i < tmp___31)) {
#line 824
      goto while_break___5;
    }
    {
#line 825
    tmp___30 = psiconv_list_get((psiconv_list const   )anon_styles, (psiconv_u32 )i);
#line 825
    anon_ptr = (anon_style )tmp___30;
    }
#line 825
    if (! anon_ptr) {
      {
#line 826
      psiconv_error((psiconv_config )config, lev + 1, off, "Data structure corruption");
      }
#line 827
      goto while_break___5;
    }
    {
#line 829
    psiconv_free_paragraph_layout(anon_ptr->paragraph);
#line 830
    psiconv_free_character_layout(anon_ptr->character);
#line 824
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  ERROR2: 
  {
#line 834
  psiconv_list_free(anon_styles);
  }
  ERROR1: 
  {
#line 836
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Layout Section failed");
  }
#line 837
  if (length) {
#line 838
    *length = 0;
  }
#line 839
  if (! res) {
#line 840
    return (-2);
  } else {
#line 842
    return (res);
  }
}
}
#line 1063 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
static psiconv_file_type_t psiconv_determine_embedded_object_type___0(psiconv_config const   config ,
                                                                      psiconv_buffer const   buf ,
                                                                      int lev , int *status ) 
{ 
  psiconv_u32 off ;
  psiconv_section_table_section table ;
  int res ;
  int i ;
  psiconv_file_type_t file_type ;
  psiconv_section_table_entry entry ;
  psiconv_application_id_section applid ;
  void *tmp ;
  psiconv_u32 tmp___0 ;
  psiconv_u32 tmp___1 ;

  {
  {
#line 1071
  file_type = (psiconv_file_type_t )0;
#line 1075
  psiconv_progress((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Going to determine embedded object file type");
#line 1076
  psiconv_progress((psiconv_config )config, lev + 2, (psiconv_u32 )0, "Going to read the Section Table Offset Section");
#line 1077
  off = psiconv_read_u32(config, buf, lev, (psiconv_u32 )0, & res);
  }
#line 1078
  if (res) {
#line 1079
    goto ERROR1;
  }
  {
#line 1080
  psiconv_debug((psiconv_config )config, lev + 2, (psiconv_u32 )0, "Offset: %08x",
                off);
#line 1082
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the Section Table Section");
#line 1083
  res = psiconv_parse_section_table_section(config, buf, lev + 2, off, (int *)((void *)0),
                                            & table);
  }
#line 1083
  if (res) {
#line 1084
    goto ERROR1;
  }
  {
#line 1086
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to search the Section Table Section for the Application ID Section");
#line 1088
  i = 0;
  }
  {
#line 1088
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1088
    tmp___0 = psiconv_list_length((psiconv_list const   )table);
    }
#line 1088
    if (! ((psiconv_u32 )i < tmp___0)) {
#line 1088
      goto while_break;
    }
    {
#line 1089
    psiconv_progress((psiconv_config )config, lev + 3, off, "Going to read entry %d",
                     i);
#line 1090
    tmp = psiconv_list_get((psiconv_list const   )table, (psiconv_u32 )i);
#line 1090
    entry = (psiconv_section_table_entry )tmp;
    }
#line 1090
    if (! entry) {
#line 1091
      goto ERROR2;
    }
#line 1092
    if (entry->id == 268435593U) {
      {
#line 1093
      psiconv_progress((psiconv_config )config, lev + 3, off, "Found the Application ID Section at offset %08x",
                       entry->offset);
#line 1096
      off = entry->offset;
      }
#line 1097
      goto while_break;
    }
#line 1088
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1100
  tmp___1 = psiconv_list_length((psiconv_list const   )table);
  }
#line 1100
  if ((psiconv_u32 )i == tmp___1) {
    {
#line 1101
    psiconv_error((psiconv_config )config, lev + 2, off, "No Application ID Section found");
#line 1102
    res = 3;
    }
#line 1103
    goto ERROR2;
  }
  {
#line 1106
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the Application ID Section");
#line 1107
  res = psiconv_parse_application_id_section(config, buf, lev + 2, off, (int *)((void *)0),
                                             & applid);
  }
#line 1107
  if (res) {
#line 1108
    goto ERROR2;
  }
  {
#line 1111
  if (applid->id == 268435583U) {
#line 1111
    goto case_268435583;
  }
#line 1114
  if (applid->id == 268435589U) {
#line 1114
    goto case_268435589;
  }
#line 1117
  if (applid->id == 268435581U) {
#line 1117
    goto case_268435581;
  }
#line 1120
  if (applid->id == 268435592U) {
#line 1120
    goto case_268435592;
  }
#line 1123
  goto switch_default;
  case_268435583: /* CIL Label */ 
  {
#line 1111
  file_type = (psiconv_file_type_t )1;
#line 1112
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found a Word file");
  }
#line 1113
  goto switch_break;
  case_268435589: /* CIL Label */ 
  {
#line 1114
  file_type = (psiconv_file_type_t )2;
#line 1115
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found a TextEd file");
  }
#line 1116
  goto switch_break;
  case_268435581: /* CIL Label */ 
  {
#line 1117
  file_type = (psiconv_file_type_t )4;
#line 1118
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found a Sketch file");
  }
#line 1119
  goto switch_break;
  case_268435592: /* CIL Label */ 
  {
#line 1120
  file_type = (psiconv_file_type_t )6;
#line 1121
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found a Sheet file");
  }
#line 1122
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1123
  psiconv_warn((psiconv_config )config, lev + 2, off, "Found an unknown file type");
#line 1124
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found ID %08x", applid->id);
  }
  switch_break: /* CIL Label */ ;
  }
  ERROR2: 
  {
#line 1128
  psiconv_free_application_id_section(applid);
  }
  ERROR1: 
  {
#line 1130
  psiconv_free_section_table_section(table);
  }
#line 1131
  if (status) {
#line 1132
    *status = res;
  }
#line 1133
  return (file_type);
}
}
#line 43 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
static struct psiconv_config_s default_config___1  = 
#line 43 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
     {3, 2, 0, 0, 0, (psiconv_bool_t )0, (psiconv_error_handler_t *)((void *)0), (psiconv_u8 )'?',
    (psiconv_ucs2 )'?', {(psiconv_ucs2 )0}, (psiconv_bool_t )0};
#line 46
static void psiconv_config_parse_statement___1(char const   *filename , int linenr ,
                                               char const   *var , int value , psiconv_config *config ) ;
#line 51
static void psiconv_config_parse_line___1(char const   *filename , int linenr , char const   *line ,
                                          psiconv_config *config ) ;
#line 54
static void psiconv_config_parse_file___1(char const   *filename , psiconv_config *config ) ;
#line 71 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
static void psiconv_config_parse_statement___1(char const   *filename , int linenr ,
                                               char const   *var , int value , psiconv_config *config ) 
{ 
  int charnr ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 78
  tmp___9 = strcasecmp(var, "verbosity");
  }
#line 78
  if (tmp___9) {
    {
#line 84
    tmp___8 = strcasecmp(var, "color");
    }
#line 84
    if (tmp___8) {
      {
#line 90
      tmp___7 = strcasecmp(var, "colordepth");
      }
#line 90
      if (tmp___7) {
        {
#line 96
        tmp___6 = strcasecmp(var, "redbits");
        }
#line 96
        if (tmp___6) {
          {
#line 102
          tmp___5 = strcasecmp(var, "greenbits");
          }
#line 102
          if (tmp___5) {
            {
#line 108
            tmp___4 = strcasecmp(var, "bluebits");
            }
#line 108
            if (tmp___4) {
              {
#line 114
              tmp___3 = strcasecmp(var, "characterset");
              }
#line 114
              if (tmp___3) {
                {
#line 121
                tmp___2 = strcasecmp(var, "unknownunicodechar");
                }
#line 121
                if (tmp___2) {
                  {
#line 128
                  tmp___1 = strcasecmp(var, "unknownepocchar");
                  }
#line 128
                  if (tmp___1) {
                    {
#line 135
                    tmp = sscanf((char const   */* __restrict  */)var, (char const   */* __restrict  */)"char%d",
                                 & charnr);
#line 135
                    tmp___0 = strlen(var);
                    }
#line 135
                    if ((size_t )tmp == tmp___0) {
#line 136
                      if (charnr < 0) {
                        {
#line 137
                        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharXXX should have XXX between 0 and 255",
                                      filename, linenr);
                        }
                      } else
#line 136
                      if (charnr > 255) {
                        {
#line 137
                        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharXXX should have XXX between 0 and 255",
                                      filename, linenr);
                        }
                      }
#line 140
                      if (value >= 1) {
#line 140
                        if (value <= 65536) {
#line 141
                          (*config)->unicode_table[charnr] = (psiconv_ucs2 )value;
                        } else {
                          {
#line 143
                          psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharXXX should be between 1 and 65535",
                                        filename, linenr);
                          }
                        }
                      } else {
                        {
#line 143
                        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharXXX should be between 1 and 65535",
                                      filename, linenr);
                        }
                      }
                    } else {
                      {
#line 147
                      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Unknown variable %s",
                                    filename, linenr, var);
                      }
                    }
                  } else
#line 129
                  if (value >= 1) {
#line 129
                    if (value < 256) {
#line 130
                      (*config)->unknown_epoc_char = (psiconv_u8 )value;
                    } else {
                      {
#line 132
                      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: UnknownEPOCChar should be between 1 and 255",
                                    filename, linenr);
                      }
                    }
                  } else {
                    {
#line 132
                    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: UnknownEPOCChar should be between 1 and 255",
                                  filename, linenr);
                    }
                  }
                } else
#line 122
                if (value >= 1) {
#line 122
                  if (value < 65536) {
#line 123
                    (*config)->unknown_unicode_char = (psiconv_ucs2 )value;
                  } else {
                    {
#line 125
                    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: UnknownUnicodeChar should be between 1 and 65535",
                                  filename, linenr);
                    }
                  }
                } else {
                  {
#line 125
                  psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: UnknownUnicodeChar should be between 1 and 65535",
                                filename, linenr);
                  }
                }
              } else
#line 115
              if (value >= 0) {
#line 115
                if (value <= 1) {
                  {
#line 116
                  psiconv_unicode_select_characterset((psiconv_config const   )*config,
                                                      value);
                  }
                } else {
                  {
#line 118
                  psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharacterSet should be between 0 and 1",
                                filename, linenr);
                  }
                }
              } else {
                {
#line 118
                psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharacterSet should be between 0 and 1",
                              filename, linenr);
                }
              }
            } else
#line 109
            if (value >= 0) {
#line 109
              if (value <= 32) {
#line 110
                (*config)->bluebits = value;
              } else {
                {
#line 112
                psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: BlueBits should be between 1 and 32 or 0",
                              filename, linenr);
                }
              }
            } else {
              {
#line 112
              psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: BlueBits should be between 1 and 32 or 0",
                            filename, linenr);
              }
            }
          } else
#line 103
          if (value >= 0) {
#line 103
            if (value <= 32) {
#line 104
              (*config)->greenbits = value;
            } else {
              {
#line 106
              psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: GreenBits should be between 1 and 32 or 0",
                            filename, linenr);
              }
            }
          } else {
            {
#line 106
            psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: GreenBits should be between 1 and 32 or 0",
                          filename, linenr);
            }
          }
        } else
#line 97
        if (value >= 0) {
#line 97
          if (value <= 32) {
#line 98
            (*config)->redbits = value;
          } else {
            {
#line 100
            psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: RedBits should be between 1 and 32 or 0",
                          filename, linenr);
            }
          }
        } else {
          {
#line 100
          psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: RedBits should be between 1 and 32 or 0",
                        filename, linenr);
          }
        }
      } else
#line 91
      if (value > 0) {
#line 91
        if (value <= 32) {
#line 92
          (*config)->colordepth = value;
        } else {
          {
#line 94
          psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: ColorDepth should be between 1 and 32",
                        filename, linenr);
          }
        }
      } else {
        {
#line 94
        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: ColorDepth should be between 1 and 32",
                      filename, linenr);
        }
      }
    } else
#line 85
    if (value == 0) {
#line 86
      (*config)->color = (psiconv_bool_t )value;
    } else
#line 85
    if (value == 1) {
#line 86
      (*config)->color = (psiconv_bool_t )value;
    } else {
      {
#line 88
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Color should be 0 or 1",
                    filename, linenr);
      }
    }
  } else
#line 79
  if (value >= 1) {
#line 79
    if (value <= 5) {
#line 80
      (*config)->verbosity = value;
    } else {
      {
#line 82
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Verbosity should be between 1 and 5",
                    filename, linenr);
      }
    }
  } else {
    {
#line 82
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Verbosity should be between 1 and 5",
                  filename, linenr);
    }
  }
  {
#line 150
  psiconv_debug(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Set variable %s to %d",
                filename, linenr, var, value);
  }
#line 152
  return;
}
}
#line 155 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
static void psiconv_config_parse_line___1(char const   *filename , int linenr , char const   *line ,
                                          psiconv_config *config ) 
{ 
  int sovar ;
  int eovar ;
  int soval ;
  int eoval ;
  int eol ;
  char *var ;
  long val ;
  void *tmp ;

  {
  {
#line 163
  psiconv_debug(*config, 0, (psiconv_u32 )0, "Going to parse line %d: %s", linenr,
                line);
#line 164
  sovar = 0;
  }
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (*(line + sovar)) {
#line 165
      if (! ((int const   )*(line + sovar) < 32)) {
#line 165
        goto while_break;
      }
    } else {
#line 165
      goto while_break;
    }
#line 166
    sovar ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  if (! *(line + sovar)) {
#line 168
    return;
  } else
#line 167
  if ((int const   )*(line + sovar) == 35) {
#line 168
    return;
  }
#line 169
  eovar = sovar;
  {
#line 170
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 170
    if (*(line + eovar)) {
#line 170
      if ((int const   )*(line + eovar) >= 65) {
#line 170
        if (! ((int const   )*(line + eovar) <= 90)) {
#line 170
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 170
      if ((int const   )*(line + eovar) >= 97) {
#line 170
        if (! ((int const   )*(line + eovar) <= 122)) {
#line 170
          goto while_break___0;
        }
      } else {
#line 170
        goto while_break___0;
      }
    } else {
#line 170
      goto while_break___0;
    }
#line 172
    eovar ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 173
  if (sovar == eovar) {
    {
#line 174
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (no variable found)",
                  filename, linenr);
    }
#line 176
    return;
  }
#line 178
  soval = eovar;
  {
#line 179
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 179
    if (*(line + soval)) {
#line 179
      if (! ((int const   )*(line + soval) <= 32)) {
#line 179
        goto while_break___1;
      }
    } else {
#line 179
      goto while_break___1;
    }
#line 180
    soval ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 181
  if ((int const   )*(line + soval) != 61) {
    {
#line 182
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (no = token found)",
                  filename, linenr);
    }
#line 184
    return;
  }
#line 186
  soval ++;
  {
#line 187
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 187
    if (*(line + soval)) {
#line 187
      if (! ((int const   )*(line + soval) <= 32)) {
#line 187
        goto while_break___2;
      }
    } else {
#line 187
      goto while_break___2;
    }
#line 188
    soval ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 189
  eoval = soval;
  {
#line 190
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 190
    if (*(line + eoval)) {
#line 190
      if ((int const   )*(line + eoval) >= 48) {
#line 190
        if (! ((int const   )*(line + eoval) <= 57)) {
#line 190
          goto while_break___3;
        }
      } else {
#line 190
        goto while_break___3;
      }
    } else {
#line 190
      goto while_break___3;
    }
#line 191
    eoval ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 192
  if (eoval == soval) {
    {
#line 193
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (no value found)",
                  filename, linenr);
    }
#line 195
    return;
  }
#line 197
  if (soval - eoval > 7) {
    {
#line 198
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (value too large)",
                  filename, linenr);
    }
#line 200
    return;
  }
#line 202
  eol = eoval;
  {
#line 203
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 203
    if (*(line + eol)) {
#line 203
      if (! ((int const   )*(line + eol) < 32)) {
#line 203
        goto while_break___4;
      }
    } else {
#line 203
      goto while_break___4;
    }
#line 204
    eol ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 205
  if (*(line + eol)) {
    {
#line 206
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (trailing garbage)",
                  filename, linenr);
    }
#line 208
    return;
  }
  {
#line 211
  tmp = malloc((size_t )((eovar - sovar) + 1));
#line 211
  var = (char *)tmp;
#line 212
  memcpy((void */* __restrict  */)var, (void const   */* __restrict  */)(line + sovar),
         (size_t )(eovar - sovar));
#line 213
  *(var + (eovar - sovar)) = (char)0;
#line 215
  val = atol(line + soval);
#line 217
  psiconv_config_parse_statement___1(filename, linenr, (char const   *)var, (int )val,
                                     config);
#line 218
  free((void *)var);
  }
#line 219
  return;
}
}
#line 222 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
static void psiconv_config_parse_file___1(char const   *filename , psiconv_config *config ) 
{ 
  int file ;
  int linenr ;
  struct stat stat_buf ;
  off_t filesize ;
  off_t bytes_left ;
  off_t bytes_read ;
  off_t sol ;
  off_t eol ;
  char *filebuffer ;
  char *filebuffer_ptr ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 229
  psiconv_progress(*config, 0, (psiconv_u32 )0, "Going to access configuration file %s",
                   filename);
#line 233
  file = open(filename, 0);
  }
#line 233
  if (file == -1) {
#line 234
    goto ERROR0;
  }
  {
#line 237
  tmp___0 = fstat(file, & stat_buf);
  }
#line 237
  if (tmp___0) {
    {
#line 238
    tmp = close(file);
    }
#line 238
    if (tmp) {
      {
#line 239
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Couldn\'t close file",
                    filename);
      }
    }
#line 241
    return;
  }
  {
#line 244
  filesize = stat_buf.st_size;
#line 245
  tmp___1 = malloc((size_t )(filesize + 1L));
#line 245
  filebuffer = (char *)tmp___1;
  }
#line 245
  if (! filebuffer) {
    {
#line 246
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Out of memory error",
                  filename);
    }
#line 248
    goto ERROR1;
  }
#line 251
  filebuffer_ptr = filebuffer;
#line 252
  bytes_left = filesize;
#line 253
  bytes_read = (off_t )1;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (bytes_read > 0L) {
#line 254
      if (! bytes_left) {
#line 254
        goto while_break;
      }
    } else {
#line 254
      goto while_break;
    }
    {
#line 255
    bytes_read = read(file, (void *)filebuffer_ptr, (size_t )bytes_left);
    }
#line 256
    if (bytes_read > 0L) {
#line 257
      filebuffer_ptr += bytes_read;
#line 258
      bytes_left -= bytes_read;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  if (bytes_left) {
#line 263
    if (bytes_left != filesize) {
      {
#line 264
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Couldn\'t read file into memory",
                    filename);
      }
#line 266
      goto ERROR2;
    }
  }
  {
#line 269
  tmp___2 = close(file);
  }
#line 269
  if (tmp___2) {
    {
#line 270
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Couldn\'t close file",
                  filename);
#line 272
    file = -1;
    }
#line 273
    goto ERROR2;
  }
  {
#line 275
  file = -1;
#line 277
  psiconv_progress(*config, 0, (psiconv_u32 )0, "Going to parse configuration file %s: ",
                   filename);
#line 280
  linenr = 0;
#line 281
  sol = (off_t )0;
  }
  {
#line 283
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 283
    if (! (sol < filesize)) {
#line 283
      goto while_break___0;
    }
#line 284
    linenr ++;
#line 285
    eol = sol;
    {
#line 286
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 286
      if (eol < filesize) {
#line 286
        if ((int )*(filebuffer + eol) != 13) {
#line 286
          if ((int )*(filebuffer + eol) != 10) {
#line 286
            if (! ((int )*(filebuffer + eol) != 0)) {
#line 286
              goto while_break___1;
            }
          } else {
#line 286
            goto while_break___1;
          }
        } else {
#line 286
          goto while_break___1;
        }
      } else {
#line 286
        goto while_break___1;
      }
#line 288
      eol ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 290
    if (eol < filesize) {
#line 290
      if ((int )*(filebuffer + eol) == 0) {
        {
#line 291
        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Unexpected character \000 found",
                      filename, linenr);
        }
#line 293
        goto ERROR2;
      }
    }
#line 295
    if (eol < filesize + 1L) {
#line 295
      if ((int )*(filebuffer + eol) == 13) {
#line 295
        if ((int )*(filebuffer + (eol + 1L)) == 10) {
#line 298
          *(filebuffer + eol) = (char)0;
#line 299
          eol ++;
        } else {
#line 295
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 295
      if ((int )*(filebuffer + eol) == 10) {
#line 295
        if ((int )*(filebuffer + (eol + 1L)) == 13) {
#line 298
          *(filebuffer + eol) = (char)0;
#line 299
          eol ++;
        }
      }
    }
    {
#line 301
    *(filebuffer + eol) = (char)0;
#line 302
    psiconv_config_parse_line___1(filename, linenr, (char const   *)(filebuffer + sol),
                                  config);
#line 303
    sol = eol + 1L;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 305
  free((void *)filebuffer);
  }
#line 306
  return;
  ERROR2: 
  {
#line 309
  free((void *)filebuffer);
  }
  ERROR1: 
#line 311
  if (file != -1) {
    {
#line 311
    tmp___3 = close(file);
    }
#line 311
    if (tmp___3) {
      {
#line 312
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Couldn\'t close file",
                    filename);
      }
    }
  }
  ERROR0: 
#line 315
  return;
}
}
#line 34 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
static psiconv_float_t pow2___1(int n ) ;
#line 35
static psiconv_string_t psiconv_read_string_aux___1(psiconv_config const   config ,
                                                    psiconv_buffer const   buf , int lev ,
                                                    psiconv_u32 off , int *length ,
                                                    int *status , int kind ) ;
#line 42 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
static psiconv_float_t pow2___1(int n ) 
{ 
  psiconv_float_t res ;
  int i ;
  int tmp ;
  psiconv_float_t tmp___0 ;

  {
#line 44
  res = 1.0;
#line 47
  i = 0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (n < 0) {
#line 47
      tmp = - n;
    } else {
#line 47
      tmp = n;
    }
#line 47
    if (! (i < tmp)) {
#line 47
      goto while_break;
    }
#line 48
    res *= 2.0;
#line 47
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  if (n < 0) {
#line 50
    tmp___0 = (psiconv_float_t )1 / res;
  } else {
#line 50
    tmp___0 = res;
  }
#line 50
  return (tmp___0);
}
}
#line 325 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
static psiconv_string_t psiconv_read_string_aux___1(psiconv_config const   config ,
                                                    psiconv_buffer const   buf , int lev ,
                                                    psiconv_u32 off , int *length ,
                                                    int *status , int kind ) 
{ 
  int bytecount ;
  int i ;
  int leng ;
  int len ;
  int localstatus ;
  psiconv_string_t result ;
  char *res_copy ;
  psiconv_list string ;
  psiconv_ucs2 nextchar ;
  psiconv_ucs2 *nextcharptr ;
  psiconv_u32 tmp ;
  psiconv_u8 tmp___0 ;
  psiconv_u32 tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  psiconv_u32 tmp___4 ;

  {
  {
#line 337
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a string");
  }
#line 339
  if (kind == -1) {
    {
#line 340
    tmp = psiconv_read_S(config, buf, lev + 2, off, & leng, & localstatus);
#line 340
    bytecount = (int )tmp;
    }
  } else
#line 341
  if (kind == -2) {
    {
#line 342
    tmp___0 = psiconv_read_u8(config, buf, lev + 2, off, & localstatus);
#line 342
    bytecount = (int )tmp___0;
#line 343
    leng = 1;
    }
  } else {
#line 345
    bytecount = kind;
#line 346
    leng = 0;
#line 347
    localstatus = 0;
  }
#line 349
  if (localstatus) {
#line 350
    goto ERROR1;
  }
  {
#line 351
  psiconv_debug((psiconv_config )config, lev + 2, off, "Length: %i", bytecount);
#line 352
  len = leng;
#line 354
  string = psiconv_list_new(sizeof(*result));
  }
#line 354
  if (! string) {
#line 355
    goto ERROR1;
  }
#line 358
  i = 0;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! (i < bytecount)) {
#line 359
      goto while_break;
    }
    {
#line 360
    nextchar = psiconv_unicode_read_char(config, (psiconv_buffer )buf, lev, (off + (psiconv_u32 )i) + (psiconv_u32 )len,
                                         & leng, & localstatus);
    }
#line 362
    if (localstatus) {
#line 363
      goto ERROR2;
    }
    {
#line 364
    localstatus = psiconv_list_add(string, (void const   *)(& nextchar));
    }
#line 364
    if (localstatus) {
#line 365
      goto ERROR2;
    }
#line 366
    i += leng;
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  if (i > bytecount) {
    {
#line 369
    psiconv_error((psiconv_config )config, lev, (off + (psiconv_u32 )i) + (psiconv_u32 )len,
                  "Malformed string");
#line 370
    localstatus = 3;
    }
#line 371
    goto ERROR2;
  }
  {
#line 373
  len += bytecount;
#line 376
  tmp___1 = psiconv_list_length((psiconv_list const   )string);
#line 376
  tmp___2 = malloc(sizeof(*result) * (unsigned long )(tmp___1 + 1U));
#line 376
  result = (psiconv_string_t )tmp___2;
  }
#line 376
  if (! result) {
#line 377
    goto ERROR2;
  }
#line 378
  i = 0;
  {
#line 378
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 378
    tmp___4 = psiconv_list_length((psiconv_list const   )string);
    }
#line 378
    if (! ((psiconv_u32 )i < tmp___4)) {
#line 378
      goto while_break___0;
    }
    {
#line 379
    tmp___3 = psiconv_list_get((psiconv_list const   )string, (psiconv_u32 )i);
#line 379
    nextcharptr = (psiconv_ucs2 *)tmp___3;
    }
#line 379
    if (! nextcharptr) {
      {
#line 380
      psiconv_error((psiconv_config )config, lev, (off + (psiconv_u32 )i) + (psiconv_u32 )len,
                    "Data structure corruption");
      }
#line 381
      goto ERROR3;
    }
#line 383
    *(result + i) = *nextcharptr;
#line 378
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 385
  *(result + i) = (psiconv_ucs2 )0;
#line 387
  res_copy = psiconv_make_printable(config, (psiconv_string_t const   )result);
  }
#line 388
  if (! res_copy) {
#line 389
    goto ERROR3;
  }
  {
#line 390
  psiconv_debug((psiconv_config )config, lev + 2, off, "Contents: `%s\'", res_copy);
#line 391
  free((void *)res_copy);
#line 393
  psiconv_list_free(string);
  }
#line 395
  if (length) {
#line 396
    *length = len;
  }
#line 398
  if (status) {
#line 399
    *status = 0;
  }
  {
#line 401
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of string (total length: %08x)", len);
  }
#line 403
  return (result);
  ERROR3: 
  {
#line 406
  free((void *)result);
  }
  ERROR2: 
  {
#line 408
  psiconv_list_free(string);
  }
  ERROR1: 
  {
#line 410
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of string failed");
  }
#line 411
  if (status) {
#line 412
    *status = localstatus;
  }
#line 413
  if (length) {
#line 414
    *length = 0;
  }
#line 415
  return ((psiconv_string_t )((void *)0));
}
}
#line 36 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle8___1(psiconv_config const   config , int lev , psiconv_u32 off ,
                                   psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) ;
#line 41
static int psiconv_decode_rle12___1(psiconv_config const   config , int lev , psiconv_u32 off ,
                                    psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) ;
#line 46
static int psiconv_decode_rle16___1(psiconv_config const   config , int lev , psiconv_u32 off ,
                                    psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) ;
#line 51
static int psiconv_decode_rle24___1(psiconv_config const   config , int lev , psiconv_u32 off ,
                                    psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) ;
#line 56
static int psiconv_bytes_to_pixel_data___1(psiconv_config const   config , int lev ,
                                           psiconv_u32 off , psiconv_pixel_bytes const   bytes ,
                                           psiconv_pixel_ints *pixels , int colordepth ,
                                           int xsize , int ysize ) ;
#line 62
static int psiconv_pixel_data_to_floats___1(psiconv_config const   config , int lev ,
                                            psiconv_u32 off , psiconv_pixel_ints const   pixels ,
                                            psiconv_pixel_floats_t *floats , int colordepth ,
                                            int color___1 , int redbits , int bluebits ,
                                            int greenbits , psiconv_pixel_floats_t const   palet ) ;
#line 647 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle8___1(psiconv_config const   config , int lev , psiconv_u32 off ,
                                   psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) 
{ 
  int res ;
  psiconv_u8 *marker ;
  psiconv_u8 *value ;
  int i ;
  int j ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  psiconv_u32 tmp___3 ;

  {
  {
#line 651
  res = 0;
#line 655
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to decode the RLE8 encoding");
#line 656
  tmp = psiconv_list_new(sizeof(psiconv_u8 ));
#line 656
  *decoded = tmp;
  }
#line 656
  if (! tmp) {
#line 657
    goto ERROR1;
  }
#line 659
  i = 0;
  {
#line 659
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 659
    tmp___3 = psiconv_list_length(encoded);
    }
#line 659
    if (! ((psiconv_u32 )i < tmp___3)) {
#line 659
      goto while_break;
    }
    {
#line 663
    tmp___0 = psiconv_list_get(encoded, (psiconv_u32 )i);
#line 663
    marker = (psiconv_u8 *)tmp___0;
    }
#line 663
    if (! marker) {
#line 664
      goto ERROR2;
    }
#line 668
    if ((int )*marker < 128) {
      {
#line 674
      tmp___1 = psiconv_list_get(encoded, (psiconv_u32 )(i + 1));
#line 674
      value = (psiconv_u8 *)tmp___1;
      }
#line 674
      if (! value) {
#line 675
        goto ERROR2;
      }
#line 681
      j = 0;
      {
#line 681
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 681
        if (! (j < (int )*marker + 1)) {
#line 681
          goto while_break___0;
        }
        {
#line 682
        res = psiconv_list_add(*decoded, (void const   *)value);
        }
#line 682
        if (res) {
#line 683
          goto ERROR2;
        }
#line 681
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 684
      i += 2;
    } else {
#line 690
      j = 0;
      {
#line 690
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 690
        if (! (j < 256 - (int )*marker)) {
#line 690
          goto while_break___1;
        }
        {
#line 695
        tmp___2 = psiconv_list_get(encoded, (psiconv_u32 )((i + j) + 1));
#line 695
        value = (psiconv_u8 *)tmp___2;
        }
#line 695
        if (! value) {
#line 696
          goto ERROR2;
        }
        {
#line 700
        res = psiconv_list_add(*decoded, (void const   *)value);
        }
#line 700
        if (res) {
#line 701
          goto ERROR2;
        }
#line 690
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 703
      i += (256 - (int )*marker) + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 706
  psiconv_progress((psiconv_config )config, lev, off, "End of RLE8 decoding process");
  }
#line 708
  return (0);
  ERROR2: 
  {
#line 711
  psiconv_list_free(*decoded);
  }
  ERROR1: 
  {
#line 713
  psiconv_error((psiconv_config )config, lev + 1, off, "Decoding of RLE8 failed");
  }
#line 714
  if (! res) {
#line 715
    return (-2);
  } else {
#line 717
    return (res);
  }
}
}
#line 720 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle12___1(psiconv_config const   config , int lev , psiconv_u32 off ,
                                    psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) 
{ 
  int res ;
  psiconv_u8 *value0 ;
  psiconv_u8 *value1 ;
  psiconv_u32 value ;
  psiconv_u32 repeat ;
  int i ;
  int j ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  psiconv_u32 tmp___2 ;

  {
  {
#line 724
  res = 0;
#line 729
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to decode the RLE12 encoding");
#line 730
  tmp = psiconv_list_new(sizeof(psiconv_u8 ));
#line 730
  *decoded = tmp;
  }
#line 730
  if (! tmp) {
#line 731
    goto ERROR1;
  }
#line 733
  i = 0;
  {
#line 733
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 733
    tmp___2 = psiconv_list_length(encoded);
    }
#line 733
    if (! ((psiconv_u32 )i < tmp___2)) {
#line 733
      goto while_break;
    }
    {
#line 734
    psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read data word at %04x",
                     i);
#line 735
    tmp___0 = psiconv_list_get(encoded, (psiconv_u32 )i);
#line 735
    value0 = (psiconv_u8 *)tmp___0;
    }
#line 735
    if (! value0) {
#line 736
      goto ERROR2;
    }
    {
#line 737
    tmp___1 = psiconv_list_get(encoded, (psiconv_u32 )(i + 1));
#line 737
    value1 = (psiconv_u8 *)tmp___1;
    }
#line 737
    if (! value1) {
#line 738
      goto ERROR2;
    }
    {
#line 739
    psiconv_debug((psiconv_config )config, lev + 2, off, "Data Word: %04x", (int )*value0 + ((int )*value1 << 8));
#line 740
    value = (psiconv_u32 )((int )*value0 + (((int )*value1 & 15) << 8));
#line 741
    repeat = (psiconv_u32 )(((int )*value1 >> 4) + 1);
#line 742
    psiconv_progress((psiconv_config )config, lev + 2, off, "Adding %02x pixels %03x",
                     repeat, value);
#line 744
    j = 0;
    }
    {
#line 744
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 744
      if (! ((psiconv_u32 )j < repeat)) {
#line 744
        goto while_break___0;
      }
      {
#line 745
      res = psiconv_list_add(*decoded, (void const   *)(& value));
      }
#line 745
      if (res) {
#line 746
        goto ERROR2;
      }
#line 744
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 747
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 749
  psiconv_progress((psiconv_config )config, lev, off, "End of RLE12 decoding process");
  }
#line 751
  return (0);
  ERROR2: 
  {
#line 754
  psiconv_list_free(*decoded);
  }
  ERROR1: 
  {
#line 756
  psiconv_error((psiconv_config )config, lev + 1, off, "Decoding of RLE12 failed");
  }
#line 757
  if (! res) {
#line 758
    return (-2);
  } else {
#line 760
    return (res);
  }
}
}
#line 763 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle16___1(psiconv_config const   config , int lev , psiconv_u32 off ,
                                    psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) 
{ 
  int res ;
  psiconv_u8 *marker ;
  psiconv_u8 *value0 ;
  psiconv_u8 *value1 ;
  psiconv_u32 value ;
  int i ;
  int j ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  psiconv_u32 tmp___5 ;

  {
  {
#line 767
  res = 0;
#line 772
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to decode the RLE16 encoding");
#line 773
  tmp = psiconv_list_new(sizeof(psiconv_u8 ));
#line 773
  *decoded = tmp;
  }
#line 773
  if (! tmp) {
#line 774
    goto ERROR1;
  }
#line 776
  i = 0;
  {
#line 776
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 776
    tmp___5 = psiconv_list_length(encoded);
    }
#line 776
    if (! ((psiconv_u32 )i < tmp___5)) {
#line 776
      goto while_break;
    }
    {
#line 777
    psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read marker byte at %04x",
                     i);
#line 778
    tmp___0 = psiconv_list_get(encoded, (psiconv_u32 )i);
#line 778
    marker = (psiconv_u8 *)tmp___0;
    }
#line 778
    if (! marker) {
#line 779
      goto ERROR2;
    }
    {
#line 780
    psiconv_debug((psiconv_config )config, lev + 2, off, "Marker byte: %02x", (int )*marker);
    }
#line 781
    if ((int )*marker < 128) {
      {
#line 782
      psiconv_debug((psiconv_config )config, lev + 2, off, "Marker: repeat value word %02x times",
                    (int )*marker + 1);
#line 784
      psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read value word at %04x",
                       i + 1);
#line 785
      tmp___1 = psiconv_list_get(encoded, (psiconv_u32 )(i + 1));
#line 785
      value0 = (psiconv_u8 *)tmp___1;
      }
#line 785
      if (! value0) {
#line 786
        goto ERROR2;
      }
      {
#line 787
      tmp___2 = psiconv_list_get(encoded, (psiconv_u32 )(i + 2));
#line 787
      value1 = (psiconv_u8 *)tmp___2;
      }
#line 787
      if (! value1) {
#line 788
        goto ERROR2;
      }
      {
#line 789
      value = (psiconv_u32 )((int )*value0 + ((int )*value1 << 8));
#line 790
      psiconv_debug((psiconv_config )config, lev + 2, off, "Value word: %02x", value);
#line 791
      psiconv_progress((psiconv_config )config, lev + 2, off, "Adding %02x pixels %04x",
                       (int )*marker + 1, value);
#line 793
      j = 0;
      }
      {
#line 793
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 793
        if (! (j < (int )*marker + 1)) {
#line 793
          goto while_break___0;
        }
        {
#line 794
        res = psiconv_list_add(*decoded, (void const   *)(& value));
        }
#line 794
        if (res) {
#line 795
          goto ERROR2;
        }
#line 793
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 796
      i += 3;
    } else {
      {
#line 798
      psiconv_debug((psiconv_config )config, lev + 2, off, "Marker: %02x value words follow",
                    256 - (int )*marker);
#line 800
      j = 0;
      }
      {
#line 800
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 800
        if (! (j < 256 - (int )*marker)) {
#line 800
          goto while_break___1;
        }
        {
#line 801
        psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read value word at %04x",
                         (i + j * 2) + 1);
#line 803
        tmp___3 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 2) + 1));
#line 803
        value0 = (psiconv_u8 *)tmp___3;
        }
#line 803
        if (! value0) {
#line 804
          goto ERROR2;
        }
        {
#line 805
        tmp___4 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 2) + 2));
#line 805
        value1 = (psiconv_u8 *)tmp___4;
        }
#line 805
        if (! value1) {
#line 806
          goto ERROR2;
        }
        {
#line 807
        value = (psiconv_u32 )((int )*value0 + ((int )*value1 << 8));
#line 808
        psiconv_debug((psiconv_config )config, lev + 2, off, "Value: %04x", value);
#line 809
        res = psiconv_list_add(*decoded, (void const   *)(& value));
        }
#line 809
        if (res) {
#line 810
          goto ERROR2;
        }
#line 800
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 812
      i += (256 - (int )*marker) * 2 + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 815
  psiconv_progress((psiconv_config )config, lev, off, "End of RLE16 decoding process");
  }
#line 817
  return (0);
  ERROR2: 
  {
#line 820
  psiconv_list_free(*decoded);
  }
  ERROR1: 
  {
#line 822
  psiconv_error((psiconv_config )config, lev + 1, off, "Decoding of RLE16 failed");
  }
#line 823
  if (! res) {
#line 824
    return (-2);
  } else {
#line 826
    return (res);
  }
}
}
#line 829 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle24___1(psiconv_config const   config , int lev , psiconv_u32 off ,
                                    psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) 
{ 
  int res ;
  psiconv_u8 *marker ;
  psiconv_u8 *value0 ;
  psiconv_u8 *value1 ;
  psiconv_u8 *value2 ;
  psiconv_u32 value ;
  int i ;
  int j ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  psiconv_u32 tmp___7 ;

  {
  {
#line 833
  res = 0;
#line 838
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to decode the RLE24 encoding");
#line 839
  tmp = psiconv_list_new(sizeof(psiconv_u8 ));
#line 839
  *decoded = tmp;
  }
#line 839
  if (! tmp) {
#line 840
    goto ERROR1;
  }
#line 842
  i = 0;
  {
#line 842
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 842
    tmp___7 = psiconv_list_length(encoded);
    }
#line 842
    if (! ((psiconv_u32 )i < tmp___7)) {
#line 842
      goto while_break;
    }
    {
#line 843
    psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read marker byte at %04x",
                     i);
#line 844
    tmp___0 = psiconv_list_get(encoded, (psiconv_u32 )i);
#line 844
    marker = (psiconv_u8 *)tmp___0;
    }
#line 844
    if (! marker) {
#line 845
      goto ERROR2;
    }
    {
#line 846
    psiconv_debug((psiconv_config )config, lev + 2, off, "Marker byte: %02x", (int )*marker);
    }
#line 847
    if ((int )*marker < 128) {
      {
#line 848
      psiconv_debug((psiconv_config )config, lev + 2, off, "Marker: repeat value byte triplet %02x times",
                    (int )*marker + 1);
#line 850
      psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read value byte triplet at %04x",
                       i + 1);
#line 851
      tmp___1 = psiconv_list_get(encoded, (psiconv_u32 )(i + 1));
#line 851
      value0 = (psiconv_u8 *)tmp___1;
      }
#line 851
      if (! value0) {
#line 852
        goto ERROR2;
      }
      {
#line 853
      tmp___2 = psiconv_list_get(encoded, (psiconv_u32 )(i + 2));
#line 853
      value1 = (psiconv_u8 *)tmp___2;
      }
#line 853
      if (! value1) {
#line 854
        goto ERROR2;
      }
      {
#line 855
      tmp___3 = psiconv_list_get(encoded, (psiconv_u32 )(i + 3));
#line 855
      value2 = (psiconv_u8 *)tmp___3;
      }
#line 855
      if (! value2) {
#line 856
        goto ERROR2;
      }
      {
#line 857
      value = (psiconv_u32 )(((int )*value0 + ((int )*value1 << 8)) + ((int )*value2 << 16));
#line 858
      psiconv_debug((psiconv_config )config, lev + 2, off, "Value byte triplet: %06x",
                    value);
#line 859
      psiconv_progress((psiconv_config )config, lev + 2, off, "Adding %02x pixels %06x",
                       (int )*marker + 1, value);
#line 861
      j = 0;
      }
      {
#line 861
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 861
        if (! (j < (int )*marker + 1)) {
#line 861
          goto while_break___0;
        }
        {
#line 862
        res = psiconv_list_add(*decoded, (void const   *)(& value));
        }
#line 862
        if (res) {
#line 863
          goto ERROR2;
        }
#line 861
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 864
      i += 4;
    } else {
      {
#line 866
      psiconv_debug((psiconv_config )config, lev + 2, off, "Marker: %02x value byte triplets follow",
                    256 - (int )*marker);
#line 868
      j = 0;
      }
      {
#line 868
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 868
        if (! (j < 256 - (int )*marker)) {
#line 868
          goto while_break___1;
        }
        {
#line 869
        psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read value byte triplets at %04x",
                         (i + j * 3) + 1);
#line 871
        tmp___4 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 3) + 1));
#line 871
        value0 = (psiconv_u8 *)tmp___4;
        }
#line 871
        if (! value0) {
#line 872
          goto ERROR2;
        }
        {
#line 873
        tmp___5 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 3) + 2));
#line 873
        value1 = (psiconv_u8 *)tmp___5;
        }
#line 873
        if (! value1) {
#line 874
          goto ERROR2;
        }
        {
#line 875
        tmp___6 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 3) + 3));
#line 875
        value2 = (psiconv_u8 *)tmp___6;
        }
#line 875
        if (! value2) {
#line 876
          goto ERROR2;
        }
        {
#line 877
        value = (psiconv_u32 )(((int )*value0 + ((int )*value1 << 8)) + ((int )*value2 << 16));
#line 878
        psiconv_debug((psiconv_config )config, lev + 2, off, "Value: %06x", value);
#line 879
        res = psiconv_list_add(*decoded, (void const   *)(& value));
        }
#line 879
        if (res) {
#line 880
          goto ERROR2;
        }
#line 868
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 882
      i += (256 - (int )*marker) * 3 + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 885
  psiconv_progress((psiconv_config )config, lev, off, "End of RLE24 decoding process");
  }
#line 887
  return (0);
  ERROR2: 
  {
#line 890
  psiconv_list_free(*decoded);
  }
  ERROR1: 
  {
#line 892
  psiconv_error((psiconv_config )config, lev + 1, off, "Decoding of RLE24 failed");
  }
#line 893
  if (! res) {
#line 894
    return (-2);
  } else {
#line 896
    return (res);
  }
}
}
#line 899 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_bytes_to_pixel_data___1(psiconv_config const   config , int lev ,
                                           psiconv_u32 off , psiconv_pixel_bytes const   bytes ,
                                           psiconv_pixel_ints *pixels , int colordepth ,
                                           int xsize , int ysize ) 
{ 
  int res ;
  int ibits ;
  int obits ;
  int x ;
  int y ;
  int bits ;
  psiconv_u8 input ;
  psiconv_u32 nr ;
  psiconv_u32 output ;
  psiconv_u8 *ientry ;
  psiconv_pixel_ints tmp ;
  void *tmp___0 ;

  {
  {
#line 905
  res = 0;
#line 911
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to convert the bytes to pixels");
#line 912
  tmp = psiconv_list_new(sizeof(psiconv_u32 ));
#line 912
  *pixels = tmp;
  }
#line 912
  if (! tmp) {
#line 913
    goto ERROR1;
  }
#line 915
  nr = (psiconv_u32 )0;
#line 916
  y = 0;
  {
#line 916
  while (1) {
    while_continue: /* CIL Label */ ;
#line 916
    if (! (y < ysize)) {
#line 916
      goto while_break;
    }
    {
#line 918
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 918
      if (! (nr % 4U)) {
#line 918
        goto while_break___0;
      }
#line 919
      nr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 920
    input = (psiconv_u8 )0;
#line 921
    ibits = 0;
#line 922
    x = 0;
    {
#line 922
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 922
      if (! (x < xsize)) {
#line 922
        goto while_break___1;
      }
#line 927
      output = (psiconv_u32 )0;
#line 928
      obits = 0;
      {
#line 929
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 929
        if (! (obits < colordepth)) {
#line 929
          goto while_break___2;
        }
#line 930
        if (ibits == 0) {
          {
#line 935
          tmp___0 = psiconv_list_get(bytes, nr);
#line 935
          ientry = (psiconv_u8 *)tmp___0;
          }
#line 935
          if (! ientry) {
#line 936
            goto ERROR2;
          }
#line 940
          input = *ientry;
#line 941
          ibits = 8;
#line 942
          nr ++;
        }
#line 944
        if (ibits + obits > colordepth) {
#line 944
          bits = colordepth - obits;
        } else {
#line 944
          bits = ibits;
        }
#line 945
        output <<= bits;
#line 946
        output |= (unsigned int )((int )input & ((1 << bits) - 1));
#line 947
        input = (psiconv_u8 )((int )input >> bits);
#line 948
        ibits -= bits;
#line 949
        obits += bits;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 954
      res = psiconv_list_add(*pixels, (void const   *)(& output));
      }
#line 954
      if (res) {
#line 955
        goto ERROR2;
      }
#line 922
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 916
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 959
  psiconv_progress((psiconv_config )config, lev, off, "Converting bytes to pixels completed");
  }
#line 961
  return (0);
  ERROR2: 
  {
#line 965
  psiconv_list_free(*pixels);
  }
  ERROR1: 
  {
#line 967
  psiconv_error((psiconv_config )config, lev + 1, off, "Converting bytes to pixels failed");
  }
#line 968
  if (! res) {
#line 969
    return (-2);
  } else {
#line 971
    return (res);
  }
}
}
#line 974 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_pixel_data_to_floats___1(psiconv_config const   config , int lev ,
                                            psiconv_u32 off , psiconv_pixel_ints const   pixels ,
                                            psiconv_pixel_floats_t *floats , int colordepth ,
                                            int color___1 , int redbits , int bluebits ,
                                            int greenbits , psiconv_pixel_floats_t const   palet ) 
{ 
  int res ;
  psiconv_u32 i ;
  psiconv_u32 *pixel ;
  float *tmp ;
  psiconv_u32 tmp___0 ;
  void *tmp___1 ;
  float *tmp___2 ;
  psiconv_u32 tmp___3 ;
  void *tmp___4 ;
  float *tmp___5 ;
  psiconv_u32 tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  float tmp___9 ;
  float tmp___10 ;
  psiconv_u32 tmp___11 ;

  {
  {
#line 982
  res = 0;
#line 986
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to convert pixels to floats");
#line 987
  tmp___0 = psiconv_list_length(pixels);
#line 987
  tmp___1 = malloc((unsigned long )tmp___0 * sizeof(*(floats->red)));
#line 987
  tmp = (float *)tmp___1;
#line 987
  floats->red = tmp;
  }
#line 987
  if (! tmp) {
#line 989
    goto ERROR1;
  }
  {
#line 990
  tmp___3 = psiconv_list_length(pixels);
#line 990
  tmp___4 = malloc((unsigned long )tmp___3 * sizeof(*(floats->green)));
#line 990
  tmp___2 = (float *)tmp___4;
#line 990
  floats->green = tmp___2;
  }
#line 990
  if (! tmp___2) {
#line 992
    goto ERROR2;
  }
  {
#line 993
  tmp___6 = psiconv_list_length(pixels);
#line 993
  tmp___7 = malloc((unsigned long )tmp___6 * sizeof(*(floats->blue)));
#line 993
  tmp___5 = (float *)tmp___7;
#line 993
  floats->blue = tmp___5;
  }
#line 993
  if (! tmp___5) {
#line 995
    goto ERROR3;
  }
  {
#line 996
  floats->length = psiconv_list_length(pixels);
#line 998
  i = (psiconv_u32 )0;
  }
  {
#line 998
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 998
    tmp___11 = psiconv_list_length(pixels);
    }
#line 998
    if (! (i < tmp___11)) {
#line 998
      goto while_break;
    }
    {
#line 999
    tmp___8 = psiconv_list_get(pixels, i);
#line 999
    pixel = (psiconv_u32 *)tmp___8;
    }
#line 999
    if (! pixel) {
#line 1000
      goto ERROR4;
    }
#line 1004
    if (! palet.length) {
#line 1005
      if (color___1) {
#line 1006
        *(floats->blue + i) = (float )(*pixel & (unsigned int )((1 << bluebits) - 1)) / (float )((1 << bluebits) - 1);
#line 1008
        *(floats->green + i) = (float )((*pixel >> bluebits) & (unsigned int )((1 << greenbits) - 1)) / (float )((1 << greenbits) - 1);
#line 1010
        *(floats->red + i) = (float )((*pixel >> (bluebits + greenbits)) & (unsigned int )((1 << redbits) - 1)) / (float )((1 << redbits) - 1);
      } else {
#line 1013
        tmp___10 = (float )*pixel / (float )((1 << colordepth) - 1);
#line 1013
        *(floats->blue + i) = tmp___10;
#line 1013
        tmp___9 = tmp___10;
#line 1013
        *(floats->green + i) = tmp___9;
#line 1013
        *(floats->red + i) = tmp___9;
      }
    } else
#line 1018
    if (*pixel >= (psiconv_u32 )palet.length) {
      {
#line 1019
      psiconv_warn((psiconv_config )config, lev + 2, off, "Invalid palet color found (using color 0x00)");
#line 1021
      *(floats->red + i) = *(palet.red + 0);
#line 1022
      *(floats->green + i) = *(palet.green + 0);
#line 1023
      *(floats->blue + i) = *(palet.blue + 0);
      }
    } else {
#line 1025
      *(floats->red + i) = *(palet.red + *pixel);
#line 1026
      *(floats->green + i) = *(palet.green + *pixel);
#line 1027
      *(floats->blue + i) = *(palet.blue + *pixel);
    }
#line 998
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1035
  psiconv_progress((psiconv_config )config, lev + 1, off, "Finished converting pixels to floats");
  }
#line 1036
  return (0);
  ERROR4: 
  {
#line 1039
  free((void *)floats->blue);
  }
  ERROR3: 
  {
#line 1041
  free((void *)floats->green);
  }
  ERROR2: 
  {
#line 1043
  free((void *)floats->red);
  }
  ERROR1: 
  {
#line 1045
  psiconv_error((psiconv_config )config, lev + 1, off, "Converting pixels to floats failed");
  }
#line 1046
  if (! res) {
#line 1047
    return (-2);
  } else {
#line 1049
    return (res);
  }
}
}
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_common.c"
static int psiconv_write_layout_section___1(psiconv_config const   config , psiconv_buffer buf ,
                                            int lev , psiconv_text_and_layout const   value ,
                                            psiconv_word_styles_section const   styles___1 ,
                                            int with_styles ) ;
#line 166 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_common.c"
static int psiconv_write_layout_section___1(psiconv_config const   config , psiconv_buffer buf ,
                                            int lev , psiconv_text_and_layout const   value ,
                                            psiconv_word_styles_section const   styles___1 ,
                                            int with_styles ) 
{ 
  psiconv_u32 obj_id ;
  psiconv_list paragraph_type_list ;
  psiconv_paragraph_type_list paragraph_type ;
  struct psiconv_paragraph_type_list_s new_type ;
  psiconv_buffer buf_types ;
  psiconv_buffer buf_elements ;
  psiconv_buffer buf_inlines ;
  psiconv_buffer buf_objects ;
  psiconv_paragraph paragraph___3 ;
  psiconv_in_line_layout in_line ;
  psiconv_word_style style___1 ;
  psiconv_character_layout para_charlayout ;
  int i ;
  int j ;
  int para_type ;
  int nr_of_inlines ;
  int res ;
  int ptl_length ;
  int pel_length ;
  int thislen ;
  int paralen ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  psiconv_u32 tmp___2 ;
  psiconv_u32 tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  psiconv_u32 tmp___8 ;
  psiconv_u32 tmp___9 ;
  void *tmp___10 ;
  psiconv_u32 tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  psiconv_u32 tmp___15 ;
  psiconv_u32 tmp___16 ;
  psiconv_u32 tmp___17 ;
  psiconv_u32 tmp___18 ;
  psiconv_u32 tmp___19 ;
  psiconv_u32 tmp___20 ;
  psiconv_u32 tmp___21 ;
  int tmp___22 ;

  {
  {
#line 185
  in_line = (psiconv_in_line_layout )((void *)0);
#line 188
  nr_of_inlines = 0;
#line 190
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing layout section");
  }
#line 191
  if (! value) {
    {
#line 192
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null text section");
#line 193
    res = -4;
    }
#line 194
    goto ERROR1;
  }
  {
#line 197
  paragraph_type_list = psiconv_list_new(sizeof(new_type));
  }
#line 197
  if (! paragraph_type_list) {
    {
#line 198
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 199
    res = -2;
    }
#line 200
    goto ERROR1;
  }
  {
#line 203
  buf_types = psiconv_buffer_new();
  }
#line 203
  if (! buf_types) {
    {
#line 204
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 205
    res = -2;
    }
#line 206
    goto ERROR2;
  }
  {
#line 209
  buf_elements = psiconv_buffer_new();
  }
#line 209
  if (! buf_elements) {
    {
#line 210
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 211
    res = -2;
    }
#line 212
    goto ERROR3;
  }
  {
#line 215
  buf_inlines = psiconv_buffer_new();
  }
#line 215
  if (! buf_inlines) {
    {
#line 216
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 217
    res = -2;
    }
#line 218
    goto ERROR4;
  }
  {
#line 221
  buf_objects = psiconv_buffer_new();
  }
#line 221
  if (! buf_objects) {
    {
#line 222
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 223
    res = -2;
    }
#line 224
    goto ERROR5;
  }
#line 227
  i = 0;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 227
    tmp___18 = psiconv_list_length(value);
    }
#line 227
    if (! ((psiconv_u32 )i < tmp___18)) {
#line 227
      goto while_break;
    }
    {
#line 228
    tmp = psiconv_list_get(value, (psiconv_u32 )i);
#line 228
    paragraph___3 = (psiconv_paragraph )tmp;
    }
#line 228
    if (! paragraph___3) {
      {
#line 229
      psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Data structure corruption");
#line 230
      res = -2;
      }
#line 231
      goto ERROR6;
    }
    {
#line 233
    tmp___0 = psiconv_unicode_strlen((psiconv_ucs2 const   *)paragraph___3->text);
#line 233
    res = psiconv_write_u32(config, buf_elements, lev + 1, (psiconv_u32 const   )(tmp___0 + 1));
    }
#line 233
    if (res) {
#line 235
      goto ERROR6;
    }
    {
#line 238
    tmp___2 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
    }
#line 238
    if (tmp___2 == 1U) {
      {
#line 239
      tmp___1 = psiconv_list_get((psiconv_list const   )paragraph___3->in_lines, (psiconv_u32 )0);
#line 239
      in_line = (psiconv_in_line_layout )tmp___1;
      }
#line 239
      if (! in_line) {
        {
#line 240
        psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Data structure corruption");
#line 241
        res = -2;
        }
#line 242
        goto ERROR6;
      }
    }
    {
#line 245
    tmp___16 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
    }
#line 245
    if (tmp___16 > 1U) {
#line 245
      goto _L;
    } else {
      {
#line 245
      tmp___17 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
      }
#line 245
      if (tmp___17 == 1U) {
#line 245
        if ((unsigned long )in_line->object != (unsigned long )((void *)0)) {
          _L: /* CIL Label */ 
          {
#line 250
          res = psiconv_write_u8(config, buf_elements, lev + 1, (psiconv_u8 const   )0);
          }
#line 250
          if (res) {
#line 251
            goto ERROR6;
          }
          {
#line 252
          style___1 = psiconv_get_style((psiconv_word_styles_section )styles___1,
                                        (int )paragraph___3->base_style);
          }
#line 252
          if (! style___1) {
            {
#line 253
            psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Unknown style");
#line 254
            res = -4;
            }
#line 255
            goto ERROR6;
          }
          {
#line 257
          res = psiconv_write_paragraph_layout_list(config, buf_elements, lev + 1,
                                                    (psiconv_paragraph_layout const   )paragraph___3->base_paragraph,
                                                    (psiconv_paragraph_layout const   )style___1->paragraph);
          }
#line 257
          if (res) {
#line 260
            goto ERROR6;
          }
#line 261
          if (with_styles) {
            {
#line 262
            res = psiconv_write_u8(config, buf_elements, lev + 1, (psiconv_u8 const   )paragraph___3->base_style);
            }
#line 262
            if (res) {
#line 263
              goto ERROR6;
            }
          }
          {
#line 264
          tmp___3 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
#line 264
          res = psiconv_write_u32(config, buf_elements, lev + 1, (psiconv_u32 const   )tmp___3);
          }
#line 264
          if (res) {
#line 266
            goto ERROR6;
          }
#line 269
          paralen = 0;
#line 270
          j = 0;
          {
#line 270
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 270
            tmp___9 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
            }
#line 270
            if (! ((psiconv_u32 )j < tmp___9)) {
#line 270
              goto while_break___0;
            }
            {
#line 271
            nr_of_inlines ++;
#line 272
            tmp___4 = psiconv_list_get((psiconv_list const   )paragraph___3->in_lines,
                                       (psiconv_u32 )j);
#line 272
            in_line = (psiconv_in_line_layout )tmp___4;
            }
#line 272
            if (! in_line) {
              {
#line 273
              psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Data structure corruption");
#line 274
              res = -2;
              }
#line 275
              goto ERROR6;
            }
#line 277
            if (in_line->object) {
#line 277
              tmp___5 = 1;
            } else {
#line 277
              tmp___5 = 0;
            }
            {
#line 277
            res = psiconv_write_u8(config, buf_inlines, lev + 1, (psiconv_u8 const   )tmp___5);
            }
#line 277
            if (res) {
#line 278
              goto ERROR6;
            }
            {
#line 279
            thislen = in_line->length;
#line 280
            paralen += thislen;
#line 283
            tmp___8 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
            }
#line 283
            if ((psiconv_u32 )j == tmp___8 - 1U) {
              {
#line 284
              tmp___6 = psiconv_unicode_strlen((psiconv_ucs2 const   *)paragraph___3->text);
              }
#line 284
              if (paralen > tmp___6 + 1) {
                {
#line 285
                psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Inline formatting data length and line length are inconsistent");
#line 286
                res = -4;
                }
#line 287
                goto ERROR6;
              }
              {
#line 289
              tmp___7 = psiconv_unicode_strlen((psiconv_ucs2 const   *)paragraph___3->text);
#line 289
              thislen += (tmp___7 + 1) - paralen;
              }
            }
            {
#line 291
            res = psiconv_write_u32(config, buf_inlines, lev + 1, (psiconv_u32 const   )thislen);
            }
#line 291
            if (res) {
#line 292
              goto ERROR6;
            }
            {
#line 293
            res = psiconv_write_character_layout_list(config, buf_inlines, lev + 1,
                                                      (psiconv_character_layout const   )in_line->layout,
                                                      (psiconv_character_layout const   )style___1->character);
            }
#line 293
            if (res) {
#line 296
              goto ERROR6;
            }
#line 297
            if (in_line->object) {
              {
#line 298
              res = psiconv_write_u32(config, buf_inlines, lev + 1, (psiconv_u32 const   )268435537);
              }
#line 298
              if (res) {
#line 299
                goto ERROR6;
              }
              {
#line 300
              obj_id = psiconv_buffer_unique_id();
#line 301
              res = psiconv_buffer_add_reference(buf_inlines, (int )obj_id);
              }
#line 301
              if (res) {
                {
#line 302
                psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
                }
#line 303
                goto ERROR6;
              }
              {
#line 305
              res = psiconv_buffer_add_target(buf_objects, (int )obj_id);
              }
#line 305
              if (res) {
                {
#line 306
                psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
                }
#line 307
                goto ERROR6;
              }
              {
#line 309
              res = psiconv_write_embedded_object_section(config, buf_objects, lev + 1,
                                                          (psiconv_embedded_object_section const   )in_line->object);
              }
#line 309
              if (res) {
#line 311
                goto ERROR6;
              }
              {
#line 312
              res = psiconv_write_length(config, buf_inlines, lev + 1, (psiconv_length_t const   )in_line->object_width);
              }
#line 312
              if (res) {
#line 313
                goto ERROR6;
              }
              {
#line 314
              res = psiconv_write_length(config, buf_inlines, lev + 1, (psiconv_length_t const   )in_line->object_height);
              }
#line 314
              if (res) {
#line 315
                goto ERROR6;
              }
            }
#line 270
            j ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
#line 245
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 320
        para_type = 0;
#line 322
        tmp___11 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
        }
#line 322
        if (tmp___11 == 0U) {
#line 323
          para_charlayout = paragraph___3->base_character;
        } else {
          {
#line 325
          tmp___10 = psiconv_list_get((psiconv_list const   )paragraph___3->in_lines,
                                      (psiconv_u32 )0);
#line 325
          in_line = (psiconv_in_line_layout )tmp___10;
          }
#line 325
          if (! in_line) {
            {
#line 326
            psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Data structure corruption");
#line 327
            res = -2;
            }
#line 328
            goto ERROR6;
          }
#line 330
          para_charlayout = in_line->layout;
        }
#line 332
        j = 0;
        {
#line 332
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 332
          tmp___15 = psiconv_list_length((psiconv_list const   )paragraph_type_list);
          }
#line 332
          if (! ((psiconv_u32 )j < tmp___15)) {
#line 332
            goto while_break___1;
          }
          {
#line 333
          tmp___12 = psiconv_list_get((psiconv_list const   )paragraph_type_list,
                                      (psiconv_u32 )j);
#line 333
          paragraph_type = (psiconv_paragraph_type_list )tmp___12;
          }
#line 333
          if (! paragraph_type) {
            {
#line 334
            psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Data structure corruption");
#line 335
            res = -2;
            }
#line 336
            goto ERROR6;
          }
#line 338
          if ((int )paragraph___3->base_style == (int )paragraph_type->style) {
            {
#line 338
            tmp___13 = psiconv_compare_character_layout((psiconv_character_layout const   )para_charlayout,
                                                        (psiconv_character_layout const   )paragraph_type->character);
            }
#line 338
            if (! tmp___13) {
              {
#line 338
              tmp___14 = psiconv_compare_paragraph_layout((psiconv_paragraph_layout const   )paragraph___3->base_paragraph,
                                                          (psiconv_paragraph_layout const   )paragraph_type->paragraph);
              }
#line 338
              if (! tmp___14) {
#line 343
                para_type = (int )paragraph_type->nr;
#line 344
                goto while_break___1;
              }
            }
          }
#line 332
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 347
        if (! para_type) {
          {
#line 349
          new_type.nr = (psiconv_u8 )(j + 1);
#line 349
          para_type = (int )new_type.nr;
#line 351
          new_type.paragraph = paragraph___3->base_paragraph;
#line 352
          new_type.character = para_charlayout;
#line 353
          new_type.style = (psiconv_u8 )paragraph___3->base_style;
#line 354
          paragraph_type = & new_type;
#line 355
          res = psiconv_list_add(paragraph_type_list, (void const   *)paragraph_type);
          }
#line 355
          if (res) {
            {
#line 356
            psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
            }
#line 357
            goto ERROR6;
          }
          {
#line 359
          res = psiconv_write_u32(config, buf_types, lev + 1, (psiconv_u32 const   )paragraph_type->nr);
          }
#line 359
          if (res) {
#line 360
            goto ERROR6;
          }
          {
#line 361
          style___1 = psiconv_get_style((psiconv_word_styles_section )styles___1,
                                        (int )paragraph_type->style);
          }
#line 361
          if (! style___1) {
            {
#line 362
            psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Unknown style");
#line 363
            res = -4;
            }
#line 364
            goto ERROR6;
          }
          {
#line 366
          res = psiconv_write_paragraph_layout_list(config, buf_types, lev + 1, (psiconv_paragraph_layout const   )paragraph_type->paragraph,
                                                    (psiconv_paragraph_layout const   )style___1->paragraph);
          }
#line 366
          if (res) {
#line 368
            goto ERROR6;
          }
#line 369
          if (with_styles) {
            {
#line 370
            res = psiconv_write_u8(config, buf_types, lev + 1, (psiconv_u8 const   )paragraph_type->style);
            }
#line 370
            if (res) {
#line 371
              goto ERROR6;
            }
          }
          {
#line 372
          res = psiconv_write_character_layout_list(config, buf_types, lev + 1, (psiconv_character_layout const   )paragraph_type->character,
                                                    (psiconv_character_layout const   )style___1->character);
          }
#line 372
          if (res) {
#line 374
            goto ERROR6;
          }
        }
        {
#line 376
        res = psiconv_write_u8(config, buf_elements, lev + 1, (psiconv_u8 const   )para_type);
        }
#line 376
        if (res) {
#line 377
          goto ERROR6;
        }
      }
    }
#line 227
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 382
  tmp___21 = psiconv_list_length(value);
  }
#line 382
  if (tmp___21) {
    {
#line 400
    tmp___19 = psiconv_list_length(value);
#line 400
    pel_length = (int )tmp___19;
#line 401
    tmp___20 = psiconv_list_length((psiconv_list const   )paragraph_type_list);
#line 401
    ptl_length = (int )tmp___20;
    }
  } else {
    {
#line 383
    res = psiconv_write_u32(config, buf_types, lev + 1, (psiconv_u32 const   )1);
    }
#line 383
    if (res) {
#line 384
      goto ERROR6;
    }
    {
#line 385
    res = psiconv_write_u32(config, buf_types, lev + 1, (psiconv_u32 const   )0);
    }
#line 385
    if (res) {
#line 386
      goto ERROR6;
    }
#line 387
    if (with_styles) {
      {
#line 388
      res = psiconv_write_u8(config, buf_types, lev + 1, (psiconv_u8 const   )0);
      }
#line 388
      if (res) {
#line 389
        goto ERROR6;
      }
    }
    {
#line 390
    res = psiconv_write_u32(config, buf_types, lev + 1, (psiconv_u32 const   )0);
    }
#line 390
    if (res) {
#line 391
      goto ERROR6;
    }
    {
#line 393
    res = psiconv_write_u32(config, buf_elements, lev + 1, (psiconv_u32 const   )1);
    }
#line 393
    if (res) {
#line 394
      goto ERROR6;
    }
    {
#line 395
    res = psiconv_write_u8(config, buf_elements, lev + 1, (psiconv_u8 const   )1);
    }
#line 395
    if (res) {
#line 396
      goto ERROR6;
    }
#line 397
    pel_length = 1;
#line 398
    ptl_length = 1;
  }
#line 405
  if (with_styles) {
#line 405
    tmp___22 = 1;
  } else {
#line 405
    tmp___22 = 0;
  }
  {
#line 405
  res = psiconv_write_u16(config, buf, lev + 1, (psiconv_u16 const   )tmp___22);
  }
#line 405
  if (res) {
#line 406
    goto ERROR6;
  }
  {
#line 407
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )ptl_length);
  }
#line 407
  if (res) {
#line 408
    goto ERROR6;
  }
  {
#line 409
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )buf_types);
  }
#line 409
  if (res) {
    {
#line 410
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 411
    goto ERROR6;
  }
  {
#line 413
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )pel_length);
  }
#line 413
  if (res) {
#line 414
    goto ERROR6;
  }
  {
#line 415
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )buf_elements);
  }
#line 415
  if (res) {
    {
#line 416
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 417
    goto ERROR6;
  }
  {
#line 419
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )nr_of_inlines);
  }
#line 419
  if (res) {
#line 420
    goto ERROR6;
  }
  {
#line 421
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )buf_inlines);
  }
#line 421
  if (res) {
    {
#line 422
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 423
    goto ERROR6;
  }
  {
#line 425
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )buf_objects);
  }
#line 425
  if (res) {
    {
#line 426
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 427
    goto ERROR6;
  }
  ERROR6: 
  {
#line 431
  psiconv_buffer_free(buf_objects);
  }
  ERROR5: 
  {
#line 433
  psiconv_buffer_free(buf_inlines);
  }
  ERROR4: 
  {
#line 435
  psiconv_buffer_free(buf_elements);
  }
  ERROR3: 
  {
#line 437
  psiconv_buffer_free(buf_types);
  }
  ERROR2: 
  {
#line 439
  psiconv_list_free(paragraph_type_list);
  }
  ERROR1: 
#line 441
  if (res) {
    {
#line 442
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of layout section failed");
    }
  } else {
    {
#line 444
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of layout section");
    }
  }
#line 445
  return (res);
}
}
#line 36 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_driver.c"
static psiconv_bool_t applid_matches___1(psiconv_string_t found , char const   *sought ) 
{ 
  int i ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 40
  tmp = psiconv_unicode_strlen((psiconv_ucs2 const   *)found);
#line 40
  tmp___0 = strlen(sought);
  }
#line 40
  if ((size_t )tmp != tmp___0) {
#line 41
    return ((psiconv_bool_t )0);
  }
#line 42
  i = 0;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 42
    tmp___1 = strlen(sought);
    }
#line 42
    if (! ((size_t )i < tmp___1)) {
#line 42
      goto while_break;
    }
#line 43
    if ((int )*(found + i) != (int )*(sought + i)) {
#line 43
      if ((int const   )*(sought + i) < 97) {
#line 46
        return ((psiconv_bool_t )0);
      } else
#line 43
      if ((int const   )*(sought + i) > 122) {
#line 46
        return ((psiconv_bool_t )0);
      } else
#line 43
      if ((int )*(found + i) != (int )(((int const   )*(sought + i) + 65) - 97)) {
#line 46
        return ((psiconv_bool_t )0);
      }
    }
#line 42
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return ((psiconv_bool_t )1);
}
}
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_collect_pixel_data___1(psiconv_pixel_ints *pixels , int xsize ,
                                          int ysize , psiconv_pixel_floats_t const   data ,
                                          int colordepth , int color___1 , int redbits ,
                                          int bluebits , int greenbits , psiconv_pixel_floats_t const   palet ) ;
#line 39
static int psiconv_pixel_data_to_bytes___1(psiconv_config const   config , int lev ,
                                           psiconv_pixel_bytes *bytes , int xsize ,
                                           int ysize , psiconv_pixel_ints const   pixels ,
                                           int colordepth ) ;
#line 43
static int psiconv_encode_rle8___1(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                   psiconv_pixel_bytes *encoded_bytes ) ;
#line 46
static int psiconv_encode_rle12___1(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                    psiconv_pixel_bytes *encoded_bytes ) ;
#line 49
static int psiconv_encode_rle16___1(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                    psiconv_pixel_bytes *encoded_bytes ) ;
#line 52
static int psiconv_encode_rle24___1(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                    psiconv_pixel_bytes *encoded_bytes ) ;
#line 240 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_collect_pixel_data___1(psiconv_pixel_ints *pixels , int xsize ,
                                          int ysize , psiconv_pixel_floats_t const   data ,
                                          int colordepth , int color___1 , int redbits ,
                                          int bluebits , int greenbits , psiconv_pixel_floats_t const   palet ) 
{ 
  int res ;
  int x ;
  int y ;
  int i ;
  psiconv_u32 index___0 ;
  psiconv_u32 pixel ;
  float p_red ;
  float p_green ;
  float p_blue ;
  float dist ;
  float new_dist ;
  psiconv_pixel_ints tmp ;

  {
  {
#line 250
  tmp = psiconv_list_new(sizeof(psiconv_u32 ));
#line 250
  *pixels = tmp;
  }
#line 250
  if (! tmp) {
#line 251
    res = -2;
#line 252
    goto ERROR1;
  }
#line 255
  y = 0;
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! (y < ysize)) {
#line 255
      goto while_break;
    }
#line 256
    x = 0;
    {
#line 256
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 256
      if (! (x < xsize)) {
#line 256
        goto while_break___0;
      }
#line 257
      index___0 = (psiconv_u32 )(y * xsize + x);
#line 258
      p_red = *(data.red + index___0);
#line 259
      p_green = *(data.green + index___0);
#line 260
      p_blue = *(data.blue + index___0);
#line 261
      if (! palet.length) {
#line 262
        if (color___1) {
#line 263
          pixel = (((psiconv_u32 )((double )(p_red * (float )(1 << redbits)) + 0.5) << (greenbits + bluebits)) + ((psiconv_u32 )((double )(p_green * (float )(1 << greenbits)) + 0.5) << bluebits)) + (psiconv_u32 )((double )(p_blue * (float )(1 << bluebits)) + 0.5);
        } else {
#line 269
          pixel = (psiconv_u32 )(((0.212671 * (double )p_red + 0.715160 * (double )p_green) + 0.072169 * (double )p_blue) * ((double )(1 << colordepth) * 0.999));
        }
      } else {
#line 271
        dist = (float )4;
#line 272
        pixel = (psiconv_u32 )-1;
#line 273
        i = 0;
        {
#line 273
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 273
          if (! ((psiconv_u32 const   )i < palet.length)) {
#line 273
            goto while_break___1;
          }
#line 274
          new_dist = ((p_red - *(palet.red + i)) * (p_red - *(palet.red + i)) + (p_green - *(palet.green + i)) * (p_green - *(palet.green + i))) + (p_blue - *(palet.blue + i)) * (p_blue - *(palet.blue + i));
#line 277
          if (new_dist < dist) {
#line 278
            pixel = (psiconv_u32 )i;
#line 279
            dist = new_dist;
          }
#line 273
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 283
      res = psiconv_list_add(*pixels, (void const   *)(& pixel));
      }
#line 283
      if (res) {
#line 284
        goto ERROR2;
      }
#line 256
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 255
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  return (0);
  ERROR2: 
  {
#line 290
  psiconv_list_free(*pixels);
  }
  ERROR1: 
#line 292
  return (res);
}
}
#line 295 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_pixel_data_to_bytes___1(psiconv_config const   config , int lev ,
                                           psiconv_pixel_bytes *bytes , int xsize ,
                                           int ysize , psiconv_pixel_ints const   pixels ,
                                           int colordepth ) 
{ 
  int res ;
  int x ;
  int y ;
  psiconv_u32 inputdata ;
  psiconv_u8 outputbyte ;
  psiconv_u32 *pixelptr ;
  int inputbitsleft ;
  int outputbitnr ;
  int bitsfit ;
  int outputbytenr ;
  psiconv_u32 tmp ;
  psiconv_pixel_bytes tmp___0 ;
  void *tmp___1 ;

  {
#line 309
  if (! bytes) {
    {
#line 310
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "NULL pixel data");
#line 311
    res = -4;
    }
#line 312
    goto ERROR1;
  }
#line 314
  if (! pixels) {
    {
#line 315
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "NULL pixel data");
#line 316
    res = -4;
    }
#line 317
    goto ERROR1;
  }
  {
#line 319
  tmp = psiconv_list_length(pixels);
  }
#line 319
  if (tmp != (psiconv_u32 )(xsize * ysize)) {
    {
#line 320
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Pixel number is not correct");
#line 321
    res = -4;
    }
#line 322
    goto ERROR1;
  }
  {
#line 325
  tmp___0 = psiconv_list_new(sizeof(psiconv_u8 ));
#line 325
  *bytes = tmp___0;
  }
#line 325
  if (! tmp___0) {
#line 326
    res = -2;
#line 327
    goto ERROR1;
  }
#line 331
  outputbitnr = 0;
#line 332
  outputbyte = (psiconv_u8 )0;
#line 333
  y = 0;
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 333
    if (! (y < ysize)) {
#line 333
      goto while_break;
    }
#line 334
    outputbytenr = 0;
#line 335
    x = 0;
    {
#line 335
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 335
      if (! (x < xsize)) {
#line 335
        goto while_break___0;
      }
      {
#line 336
      tmp___1 = psiconv_list_get(pixels, (psiconv_u32 )(y * xsize + x));
#line 336
      pixelptr = (psiconv_u32 *)tmp___1;
      }
#line 336
      if (! pixelptr) {
        {
#line 337
        psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Data structure corruption");
#line 338
        res = -2;
        }
#line 339
        goto ERROR2;
      }
#line 341
      inputbitsleft = colordepth;
#line 342
      inputdata = *pixelptr;
      {
#line 343
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 343
        if (! inputbitsleft) {
#line 343
          goto while_break___1;
        }
#line 344
        if (inputbitsleft + outputbitnr <= 8) {
#line 344
          bitsfit = inputbitsleft;
        } else {
#line 344
          bitsfit = 8 - outputbitnr;
        }
#line 345
        outputbyte = (psiconv_u8 )((unsigned int )outputbyte | ((inputdata & (unsigned int )((1 << bitsfit) - 1)) << outputbitnr));
#line 346
        inputdata >>= bitsfit;
#line 347
        inputbitsleft -= bitsfit;
#line 348
        outputbitnr += bitsfit;
#line 349
        if (outputbitnr == 8) {
          {
#line 350
          res = psiconv_list_add(*bytes, (void const   *)(& outputbyte));
          }
#line 350
          if (res) {
#line 351
            goto ERROR2;
          }
#line 352
          outputbitnr = 0;
#line 353
          outputbyte = (psiconv_u8 )0;
#line 354
          outputbytenr ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 335
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 359
    if (outputbitnr != 0) {
      {
#line 360
      res = psiconv_list_add(*bytes, (void const   *)(& outputbyte));
      }
#line 360
      if (res) {
#line 361
        goto ERROR2;
      }
#line 362
      outputbitnr = 0;
#line 363
      outputbyte = (psiconv_u8 )0;
#line 364
      outputbytenr ++;
    }
    {
#line 367
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 367
      if (! (outputbytenr % 4)) {
#line 367
        goto while_break___2;
      }
      {
#line 368
      res = psiconv_list_add(*bytes, (void const   *)(& outputbyte));
      }
#line 368
      if (res) {
#line 369
        goto ERROR2;
      }
#line 370
      outputbytenr ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 333
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return (0);
  ERROR2: 
  {
#line 377
  psiconv_list_free(*bytes);
  }
  ERROR1: 
#line 379
  return (res);
}
}
#line 386 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_encode_rle8___1(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                   psiconv_pixel_bytes *encoded_bytes ) 
{ 
  int res ;
  int i ;
  int j ;
  int len ;
  psiconv_u8 *entry ;
  psiconv_u8 *next ;
  psiconv_u8 temp ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  psiconv_u32 tmp___3 ;
  void *tmp___4 ;
  psiconv_u32 tmp___5 ;
  void *tmp___6 ;
  psiconv_u32 tmp___7 ;
  psiconv_u32 tmp___8 ;

  {
  {
#line 394
  tmp = psiconv_list_new(sizeof(*entry));
#line 394
  *encoded_bytes = tmp;
  }
#line 394
  if (! tmp) {
#line 395
    res = -2;
#line 396
    goto ERROR1;
  }
#line 399
  i = 0;
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 399
    tmp___8 = psiconv_list_length(plain_bytes);
    }
#line 399
    if (! ((psiconv_u32 )i < tmp___8)) {
#line 399
      goto while_break;
    }
    {
#line 400
    tmp___0 = psiconv_list_get(plain_bytes, (psiconv_u32 )i);
#line 400
    entry = (psiconv_u8 *)tmp___0;
    }
#line 400
    if (! entry) {
#line 401
      res = -2;
#line 402
      goto ERROR2;
    }
    {
#line 404
    tmp___1 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 1));
#line 404
    next = (psiconv_u8 *)tmp___1;
    }
#line 404
    if (! next) {
#line 405
      res = -2;
#line 406
      goto ERROR2;
    }
    {
#line 408
    tmp___7 = psiconv_list_length(plain_bytes);
    }
#line 408
    if ((psiconv_u32 )i == tmp___7 - 2U) {
      {
#line 409
      temp = (psiconv_u8 )254;
#line 410
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 410
      if (res) {
#line 411
        goto ERROR2;
      }
      {
#line 412
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry);
      }
#line 412
      if (res) {
#line 413
        goto ERROR2;
      }
      {
#line 414
      res = psiconv_list_add(*encoded_bytes, (void const   *)next);
      }
#line 414
      if (res) {
#line 415
        goto ERROR2;
      }
#line 416
      i += 2;
    } else
#line 417
    if ((int )*next == (int )*entry) {
#line 418
      len = 1;
      {
#line 419
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 419
        if ((int )*next == (int )*entry) {
          {
#line 419
          tmp___3 = psiconv_list_length(plain_bytes);
          }
#line 419
          if ((psiconv_u32 )((i + len) + 2) < tmp___3) {
#line 419
            if (! (len < 128)) {
#line 419
              goto while_break___0;
            }
          } else {
#line 419
            goto while_break___0;
          }
        } else {
#line 419
          goto while_break___0;
        }
        {
#line 422
        len ++;
#line 423
        tmp___2 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len));
#line 423
        next = (psiconv_u8 *)tmp___2;
        }
#line 423
        if (! next) {
#line 424
          res = -2;
#line 425
          goto ERROR2;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 428
      temp = (psiconv_u8 )(len - 1);
#line 429
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 429
      if (res) {
#line 430
        goto ERROR2;
      }
      {
#line 431
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry);
      }
#line 431
      if (res) {
#line 432
        goto ERROR2;
      }
#line 433
      i += len;
    } else {
#line 435
      len = 1;
      {
#line 436
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 436
        if ((int )*next != (int )*entry) {
          {
#line 436
          tmp___5 = psiconv_list_length(plain_bytes);
          }
#line 436
          if ((psiconv_u32 )((i + len) + 1) < tmp___5) {
#line 436
            if (! (len < 128)) {
#line 436
              goto while_break___1;
            }
          } else {
#line 436
            goto while_break___1;
          }
        } else {
#line 436
          goto while_break___1;
        }
        {
#line 439
        len ++;
#line 440
        entry = next;
#line 441
        tmp___4 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len));
#line 441
        next = (psiconv_u8 *)tmp___4;
        }
#line 441
        if (! next) {
#line 442
          res = -2;
#line 443
          goto ERROR2;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 446
      len --;
#line 447
      temp = (psiconv_u8 )(256 - len);
#line 448
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 448
      if (res) {
#line 449
        goto ERROR2;
      }
#line 450
      j = 0;
      {
#line 450
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 450
        if (! (j < len)) {
#line 450
          goto while_break___2;
        }
        {
#line 451
        tmp___6 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + j));
#line 451
        next = (psiconv_u8 *)tmp___6;
        }
#line 451
        if (! next) {
#line 452
          res = -2;
#line 453
          goto ERROR2;
        }
        {
#line 455
        res = psiconv_list_add(*encoded_bytes, (void const   *)next);
        }
#line 455
        if (res) {
#line 456
          goto ERROR2;
        }
#line 450
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 458
      i += len;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 461
  return (0);
  ERROR2: 
  {
#line 464
  psiconv_list_free(*encoded_bytes);
  }
  ERROR1: 
#line 466
  return (res);
}
}
#line 472 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_encode_rle12___1(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                    psiconv_pixel_bytes *encoded_bytes ) 
{ 
  psiconv_word_data data ;
  int res ;
  int i ;
  int len ;
  int location ;
  psiconv_u16 *word_entry ;
  psiconv_u16 *word_next ;
  psiconv_u16 word_data ;
  psiconv_u8 byte_temp ;
  psiconv_u8 *byte_entry ;
  void *tmp ;
  psiconv_u32 tmp___0 ;
  psiconv_pixel_bytes tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  psiconv_u32 tmp___6 ;
  void *tmp___7 ;
  psiconv_u32 tmp___8 ;
  int tmp___9 ;
  psiconv_u32 tmp___10 ;

  {
  {
#line 486
  data = psiconv_list_new(sizeof(psiconv_u16 ));
  }
#line 486
  if (! data) {
#line 487
    res = -2;
#line 488
    goto ERROR1;
  }
#line 491
  i = 0;
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 491
    tmp___0 = psiconv_list_length(plain_bytes);
    }
#line 491
    if (! ((psiconv_u32 )i < tmp___0)) {
#line 491
      goto while_break;
    }
    {
#line 492
    tmp = psiconv_list_get(plain_bytes, (psiconv_u32 )i);
#line 492
    byte_entry = (psiconv_u8 *)tmp;
    }
#line 492
    if (! byte_entry) {
#line 493
      res = -2;
#line 494
      goto ERROR2;
    }
#line 496
    location = 0;
#line 497
    if (location == 0) {
#line 498
      word_data = (psiconv_u16 )*byte_entry;
#line 499
      location ++;
    } else
#line 500
    if (location == 1) {
      {
#line 501
      word_data = (psiconv_u16 )(((int )word_data << 4) + ((int )*byte_entry & 15));
#line 502
      res = psiconv_list_add(data, (void const   *)(& word_data));
      }
#line 502
      if (res) {
#line 503
        goto ERROR2;
      }
#line 504
      word_data = (psiconv_u16 )((int )*byte_entry >> 4);
#line 505
      location ++;
    } else {
      {
#line 507
      word_data = (psiconv_u16 )(((int )word_data << 8) + (int )*byte_entry);
#line 508
      res = psiconv_list_add(data, (void const   *)(& word_data));
      }
#line 508
      if (res) {
#line 509
        goto ERROR2;
      }
#line 510
      location = 0;
    }
#line 491
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 514
  tmp___1 = psiconv_list_new(sizeof(psiconv_u8 ));
#line 514
  *encoded_bytes = tmp___1;
  }
#line 514
  if (! tmp___1) {
#line 515
    res = -2;
#line 516
    goto ERROR2;
  }
#line 519
  i = 0;
  {
#line 519
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 519
    tmp___10 = psiconv_list_length((psiconv_list const   )data);
    }
#line 519
    if (! ((psiconv_u32 )i < tmp___10)) {
#line 519
      goto while_break___0;
    }
    {
#line 520
    tmp___2 = psiconv_list_get((psiconv_list const   )data, (psiconv_u32 )i);
#line 520
    word_entry = (psiconv_u16 *)tmp___2;
    }
#line 520
    if (! word_entry) {
#line 521
      res = -2;
#line 522
      goto ERROR3;
    }
    {
#line 525
    tmp___3 = psiconv_list_get((psiconv_list const   )data, (psiconv_u32 )(i + 1));
#line 525
    word_next = (psiconv_u16 *)tmp___3;
    }
#line 525
    if (! word_next) {
#line 526
      res = -2;
#line 527
      goto ERROR3;
    }
    {
#line 530
    tmp___6 = psiconv_list_length((psiconv_list const   )data);
    }
#line 530
    if ((psiconv_u32 )i == tmp___6 - 2U) {
#line 531
      if (*word_entry) {
#line 531
        tmp___4 = 1;
      } else {
#line 531
        tmp___4 = 0;
      }
      {
#line 531
      byte_temp = (psiconv_u8 )tmp___4;
#line 532
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
      }
#line 532
      if (res) {
#line 533
        goto ERROR3;
      }
      {
#line 534
      byte_temp = (psiconv_u8 )((int )*word_entry >> 8);
#line 535
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
      }
#line 535
      if (res) {
#line 536
        goto ERROR3;
      }
#line 537
      if (*word_next) {
#line 537
        tmp___5 = 1;
      } else {
#line 537
        tmp___5 = 0;
      }
      {
#line 537
      byte_temp = (psiconv_u8 )tmp___5;
#line 538
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
      }
#line 538
      if (res) {
#line 539
        goto ERROR3;
      }
      {
#line 540
      byte_temp = (psiconv_u8 )((int )*word_next >> 8);
#line 541
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
      }
#line 541
      if (res) {
#line 542
        goto ERROR3;
      }
#line 543
      i += 2;
    }
#line 546
    len = 0;
    {
#line 547
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 547
      if ((int )*word_entry == (int )*word_next) {
#line 547
        if (len < 16) {
          {
#line 547
          tmp___8 = psiconv_list_length((psiconv_list const   )data);
          }
#line 547
          if (! ((psiconv_u32 )((i + len) + 1) < tmp___8)) {
#line 547
            goto while_break___1;
          }
        } else {
#line 547
          goto while_break___1;
        }
      } else {
#line 547
        goto while_break___1;
      }
      {
#line 549
      len ++;
#line 550
      tmp___7 = psiconv_list_get((psiconv_list const   )data, (psiconv_u32 )(i + len));
#line 550
      word_next = (psiconv_u16 *)tmp___7;
      }
#line 550
      if (! word_next) {
#line 551
        res = -2;
#line 552
        goto ERROR3;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 556
    if (*word_entry) {
#line 556
      tmp___9 = 1;
    } else {
#line 556
      tmp___9 = 0;
    }
    {
#line 556
    byte_temp = (psiconv_u8 )tmp___9;
#line 557
    res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
    }
#line 557
    if (res) {
#line 558
      goto ERROR3;
    }
    {
#line 559
    byte_temp = (psiconv_u8 )(((int )*word_entry >> 8) + ((len - 1) << 4));
#line 560
    res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
    }
#line 560
    if (res) {
#line 561
      goto ERROR3;
    }
#line 562
    i += len;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 564
  return (0);
  ERROR3: 
  {
#line 567
  psiconv_list_free(*encoded_bytes);
  }
  ERROR2: 
  {
#line 569
  psiconv_list_free(data);
  }
  ERROR1: 
#line 571
  return (res);
}
}
#line 578 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_encode_rle16___1(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                    psiconv_pixel_bytes *encoded_bytes ) 
{ 
  int res ;
  int i ;
  int j ;
  int len ;
  psiconv_u8 *entry1 ;
  psiconv_u8 *entry2 ;
  psiconv_u8 *next1 ;
  psiconv_u8 *next2 ;
  psiconv_u8 temp ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  psiconv_u32 tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  psiconv_u32 tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  psiconv_u32 tmp___12 ;
  psiconv_u32 tmp___13 ;

  {
  {
#line 586
  tmp = psiconv_list_new(sizeof(*entry1));
#line 586
  *encoded_bytes = tmp;
  }
#line 586
  if (! tmp) {
#line 587
    res = -2;
#line 588
    goto ERROR1;
  }
#line 591
  i = 0;
  {
#line 591
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 591
    tmp___13 = psiconv_list_length(plain_bytes);
    }
#line 591
    if (! ((psiconv_u32 )i < tmp___13)) {
#line 591
      goto while_break;
    }
    {
#line 592
    tmp___0 = psiconv_list_get(plain_bytes, (psiconv_u32 )i);
#line 592
    entry1 = (psiconv_u8 *)tmp___0;
    }
#line 592
    if (! entry1) {
#line 593
      res = -2;
#line 594
      goto ERROR2;
    }
    {
#line 596
    tmp___1 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 1));
#line 596
    entry2 = (psiconv_u8 *)tmp___1;
    }
#line 596
    if (! entry2) {
#line 597
      res = -2;
#line 598
      goto ERROR2;
    }
    {
#line 600
    tmp___2 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 2));
#line 600
    next1 = (psiconv_u8 *)tmp___2;
    }
#line 600
    if (! next1) {
#line 601
      res = -2;
#line 602
      goto ERROR2;
    }
    {
#line 604
    tmp___3 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 3));
#line 604
    next2 = (psiconv_u8 *)tmp___3;
    }
#line 604
    if (! next2) {
#line 605
      res = -2;
#line 606
      goto ERROR2;
    }
    {
#line 608
    tmp___12 = psiconv_list_length(plain_bytes);
    }
#line 608
    if ((psiconv_u32 )i == tmp___12 - 4U) {
      {
#line 609
      temp = (psiconv_u8 )254;
#line 610
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 610
      if (res) {
#line 611
        goto ERROR2;
      }
      {
#line 612
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry1);
      }
#line 612
      if (res) {
#line 613
        goto ERROR2;
      }
      {
#line 614
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry2);
      }
#line 614
      if (res) {
#line 615
        goto ERROR2;
      }
      {
#line 616
      res = psiconv_list_add(*encoded_bytes, (void const   *)next1);
      }
#line 616
      if (res) {
#line 617
        goto ERROR2;
      }
      {
#line 618
      res = psiconv_list_add(*encoded_bytes, (void const   *)next2);
      }
#line 618
      if (res) {
#line 619
        goto ERROR2;
      }
#line 620
      i += 4;
    } else
#line 621
    if ((int )*next1 == (int )*entry1) {
#line 621
      if ((int )*next2 == (int )*entry2) {
#line 622
        len = 0;
        {
#line 623
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 623
          if ((int )*next1 == (int )*entry1) {
#line 623
            if ((int )*next2 == (int )*entry2) {
              {
#line 623
              tmp___6 = psiconv_list_length(plain_bytes);
              }
#line 623
              if ((psiconv_u32 )((i + 2 * len) + 4) < tmp___6) {
#line 623
                if (! (len < 128)) {
#line 623
                  goto while_break___0;
                }
              } else {
#line 623
                goto while_break___0;
              }
            } else {
#line 623
              goto while_break___0;
            }
          } else {
#line 623
            goto while_break___0;
          }
          {
#line 626
          len ++;
#line 627
          tmp___4 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len * 2));
#line 627
          next1 = (psiconv_u8 *)tmp___4;
          }
#line 627
          if (! next1) {
#line 628
            res = -2;
#line 629
            goto ERROR2;
          }
          {
#line 631
          tmp___5 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 2) + 1));
#line 631
          next2 = (psiconv_u8 *)tmp___5;
          }
#line 631
          if (! next2) {
#line 632
            res = -2;
#line 633
            goto ERROR2;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 636
        temp = (psiconv_u8 )(len - 1);
#line 637
        res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
        }
#line 637
        if (res) {
#line 638
          goto ERROR2;
        }
        {
#line 639
        res = psiconv_list_add(*encoded_bytes, (void const   *)entry1);
        }
#line 639
        if (res) {
#line 640
          goto ERROR2;
        }
        {
#line 641
        res = psiconv_list_add(*encoded_bytes, (void const   *)entry2);
        }
#line 641
        if (res) {
#line 642
          goto ERROR2;
        }
#line 643
        i += len * 2;
      } else {
#line 621
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 645
      len = 1;
      {
#line 646
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 646
        if ((int )*next1 != (int )*entry1) {
#line 646
          goto _L;
        } else
#line 646
        if ((int )*next2 != (int )*entry2) {
          _L: /* CIL Label */ 
          {
#line 646
          tmp___9 = psiconv_list_length(plain_bytes);
          }
#line 646
          if ((psiconv_u32 )((i + len * 2) + 4) < tmp___9) {
#line 646
            if (! (len < 128)) {
#line 646
              goto while_break___1;
            }
          } else {
#line 646
            goto while_break___1;
          }
        } else {
#line 646
          goto while_break___1;
        }
        {
#line 649
        len ++;
#line 650
        entry1 = next1;
#line 651
        entry2 = next2;
#line 652
        tmp___7 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len * 2));
#line 652
        next1 = (psiconv_u8 *)tmp___7;
        }
#line 652
        if (! next1) {
#line 653
          res = -2;
#line 654
          goto ERROR2;
        }
        {
#line 656
        tmp___8 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 2) + 1));
#line 656
        next2 = (psiconv_u8 *)tmp___8;
        }
#line 656
        if (! next2) {
#line 657
          res = -2;
#line 658
          goto ERROR2;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 661
      len --;
#line 662
      temp = (psiconv_u8 )(256 - len);
#line 663
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 663
      if (res) {
#line 664
        goto ERROR2;
      }
#line 665
      j = 0;
      {
#line 665
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 665
        if (! (j < len)) {
#line 665
          goto while_break___2;
        }
        {
#line 666
        tmp___10 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + j * 2));
#line 666
        next1 = (psiconv_u8 *)tmp___10;
        }
#line 666
        if (! next1) {
#line 667
          res = -2;
#line 668
          goto ERROR2;
        }
        {
#line 670
        tmp___11 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + j * 2) + 1));
#line 670
        next2 = (psiconv_u8 *)tmp___11;
        }
#line 670
        if (! next2) {
#line 671
          res = -2;
#line 672
          goto ERROR2;
        }
        {
#line 674
        res = psiconv_list_add(*encoded_bytes, (void const   *)next1);
        }
#line 674
        if (res) {
#line 675
          goto ERROR2;
        }
        {
#line 676
        res = psiconv_list_add(*encoded_bytes, (void const   *)next2);
        }
#line 676
        if (res) {
#line 677
          goto ERROR2;
        }
#line 665
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 679
      i += len * 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 682
  return (0);
  ERROR2: 
  {
#line 685
  psiconv_list_free(*encoded_bytes);
  }
  ERROR1: 
#line 687
  return (res);
}
}
#line 694 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_encode_rle24___1(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                    psiconv_pixel_bytes *encoded_bytes ) 
{ 
  int res ;
  int i ;
  int j ;
  int len ;
  psiconv_u8 *entry1 ;
  psiconv_u8 *entry2 ;
  psiconv_u8 *entry3 ;
  psiconv_u8 *next1 ;
  psiconv_u8 *next2 ;
  psiconv_u8 *next3 ;
  psiconv_u8 temp ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  psiconv_u32 tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  psiconv_u32 tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  psiconv_u32 tmp___17 ;
  psiconv_u32 tmp___18 ;

  {
  {
#line 702
  tmp = psiconv_list_new(sizeof(*entry1));
#line 702
  *encoded_bytes = tmp;
  }
#line 702
  if (! tmp) {
#line 703
    res = -2;
#line 704
    goto ERROR1;
  }
#line 707
  i = 0;
  {
#line 707
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 707
    tmp___18 = psiconv_list_length(plain_bytes);
    }
#line 707
    if (! ((psiconv_u32 )i < tmp___18)) {
#line 707
      goto while_break;
    }
    {
#line 708
    tmp___0 = psiconv_list_get(plain_bytes, (psiconv_u32 )i);
#line 708
    entry1 = (psiconv_u8 *)tmp___0;
    }
#line 708
    if (! entry1) {
#line 709
      res = -2;
#line 710
      goto ERROR2;
    }
    {
#line 712
    tmp___1 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 1));
#line 712
    entry2 = (psiconv_u8 *)tmp___1;
    }
#line 712
    if (! entry2) {
#line 713
      res = -2;
#line 714
      goto ERROR2;
    }
    {
#line 716
    tmp___2 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 2));
#line 716
    entry3 = (psiconv_u8 *)tmp___2;
    }
#line 716
    if (! entry3) {
#line 717
      res = -2;
#line 718
      goto ERROR2;
    }
    {
#line 720
    tmp___3 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 3));
#line 720
    next1 = (psiconv_u8 *)tmp___3;
    }
#line 720
    if (! next1) {
#line 721
      res = -2;
#line 722
      goto ERROR2;
    }
    {
#line 724
    tmp___4 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 4));
#line 724
    next2 = (psiconv_u8 *)tmp___4;
    }
#line 724
    if (! next2) {
#line 725
      res = -2;
#line 726
      goto ERROR2;
    }
    {
#line 728
    tmp___5 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 5));
#line 728
    next3 = (psiconv_u8 *)tmp___5;
    }
#line 728
    if (! next3) {
#line 729
      res = -2;
#line 730
      goto ERROR2;
    }
    {
#line 732
    tmp___17 = psiconv_list_length(plain_bytes);
    }
#line 732
    if ((psiconv_u32 )i == tmp___17 - 6U) {
      {
#line 733
      temp = (psiconv_u8 )254;
#line 734
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 734
      if (res) {
#line 735
        goto ERROR2;
      }
      {
#line 736
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry1);
      }
#line 736
      if (res) {
#line 737
        goto ERROR2;
      }
      {
#line 738
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry2);
      }
#line 738
      if (res) {
#line 739
        goto ERROR2;
      }
      {
#line 740
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry3);
      }
#line 740
      if (res) {
#line 741
        goto ERROR2;
      }
      {
#line 742
      res = psiconv_list_add(*encoded_bytes, (void const   *)next1);
      }
#line 742
      if (res) {
#line 743
        goto ERROR2;
      }
      {
#line 744
      res = psiconv_list_add(*encoded_bytes, (void const   *)next2);
      }
#line 744
      if (res) {
#line 745
        goto ERROR2;
      }
      {
#line 746
      res = psiconv_list_add(*encoded_bytes, (void const   *)next3);
      }
#line 746
      if (res) {
#line 747
        goto ERROR2;
      }
#line 748
      i += 4;
    } else
#line 749
    if ((int )*next1 == (int )*entry1) {
#line 749
      if ((int )*next2 == (int )*entry2) {
#line 749
        if ((int )*next3 == (int )*entry3) {
#line 751
          len = 0;
          {
#line 752
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 752
            if ((int )*next1 == (int )*entry1) {
#line 752
              if ((int )*next2 == (int )*entry2) {
#line 752
                if ((int )*next3 == (int )*entry3) {
                  {
#line 752
                  tmp___9 = psiconv_list_length(plain_bytes);
                  }
#line 752
                  if ((psiconv_u32 )((i + 3 * len) + 6) < tmp___9) {
#line 752
                    if (! (len < 128)) {
#line 752
                      goto while_break___0;
                    }
                  } else {
#line 752
                    goto while_break___0;
                  }
                } else {
#line 752
                  goto while_break___0;
                }
              } else {
#line 752
                goto while_break___0;
              }
            } else {
#line 752
              goto while_break___0;
            }
            {
#line 756
            len ++;
#line 757
            tmp___6 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len * 3));
#line 757
            next1 = (psiconv_u8 *)tmp___6;
            }
#line 757
            if (! next1) {
#line 758
              res = -2;
#line 759
              goto ERROR2;
            }
            {
#line 761
            tmp___7 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 3) + 1));
#line 761
            next2 = (psiconv_u8 *)tmp___7;
            }
#line 761
            if (! next2) {
#line 762
              res = -2;
#line 763
              goto ERROR2;
            }
            {
#line 765
            tmp___8 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 3) + 2));
#line 765
            next3 = (psiconv_u8 *)tmp___8;
            }
#line 765
            if (! next3) {
#line 766
              res = -2;
#line 767
              goto ERROR2;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 770
          temp = (psiconv_u8 )(len - 1);
#line 771
          res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
          }
#line 771
          if (res) {
#line 772
            goto ERROR2;
          }
          {
#line 773
          res = psiconv_list_add(*encoded_bytes, (void const   *)entry1);
          }
#line 773
          if (res) {
#line 774
            goto ERROR2;
          }
          {
#line 775
          res = psiconv_list_add(*encoded_bytes, (void const   *)entry2);
          }
#line 775
          if (res) {
#line 776
            goto ERROR2;
          }
          {
#line 777
          res = psiconv_list_add(*encoded_bytes, (void const   *)entry3);
          }
#line 777
          if (res) {
#line 778
            goto ERROR2;
          }
#line 779
          i += len * 3;
        } else {
#line 749
          goto _L___1;
        }
      } else {
#line 749
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 781
      len = 1;
      {
#line 782
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 782
        if ((int )*next1 != (int )*entry1) {
#line 782
          goto _L;
        } else
#line 782
        if ((int )*next2 != (int )*entry2) {
#line 782
          goto _L;
        } else
#line 782
        if ((int )*next3 != (int )*entry3) {
          _L: /* CIL Label */ 
          {
#line 782
          tmp___13 = psiconv_list_length(plain_bytes);
          }
#line 782
          if ((psiconv_u32 )((i + len * 3) + 6) < tmp___13) {
#line 782
            if (! (len < 128)) {
#line 782
              goto while_break___1;
            }
          } else {
#line 782
            goto while_break___1;
          }
        } else {
#line 782
          goto while_break___1;
        }
        {
#line 786
        len ++;
#line 787
        entry1 = next1;
#line 788
        entry2 = next2;
#line 789
        entry3 = next3;
#line 790
        tmp___10 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len * 3));
#line 790
        next1 = (psiconv_u8 *)tmp___10;
        }
#line 790
        if (! next1) {
#line 791
          res = -2;
#line 792
          goto ERROR2;
        }
        {
#line 794
        tmp___11 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 3) + 1));
#line 794
        next2 = (psiconv_u8 *)tmp___11;
        }
#line 794
        if (! next2) {
#line 795
          res = -2;
#line 796
          goto ERROR2;
        }
        {
#line 798
        tmp___12 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 3) + 2));
#line 798
        next3 = (psiconv_u8 *)tmp___12;
        }
#line 798
        if (! next3) {
#line 799
          res = -2;
#line 800
          goto ERROR2;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 803
      len --;
#line 804
      temp = (psiconv_u8 )(256 - len);
#line 805
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 805
      if (res) {
#line 806
        goto ERROR2;
      }
#line 807
      j = 0;
      {
#line 807
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 807
        if (! (j < len)) {
#line 807
          goto while_break___2;
        }
        {
#line 808
        tmp___14 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + j * 3));
#line 808
        next1 = (psiconv_u8 *)tmp___14;
        }
#line 808
        if (! next1) {
#line 809
          res = -2;
#line 810
          goto ERROR2;
        }
        {
#line 812
        tmp___15 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + j * 3) + 1));
#line 812
        next2 = (psiconv_u8 *)tmp___15;
        }
#line 812
        if (! next2) {
#line 813
          res = -2;
#line 814
          goto ERROR2;
        }
        {
#line 816
        tmp___16 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + j * 3) + 2));
#line 816
        next2 = (psiconv_u8 *)tmp___16;
        }
#line 816
        if (! next2) {
#line 817
          res = -2;
#line 818
          goto ERROR2;
        }
        {
#line 820
        res = psiconv_list_add(*encoded_bytes, (void const   *)next1);
        }
#line 820
        if (res) {
#line 821
          goto ERROR2;
        }
        {
#line 822
        res = psiconv_list_add(*encoded_bytes, (void const   *)next2);
        }
#line 822
        if (res) {
#line 823
          goto ERROR2;
        }
        {
#line 824
        res = psiconv_list_add(*encoded_bytes, (void const   *)next3);
        }
#line 824
        if (res) {
#line 825
          goto ERROR2;
        }
#line 807
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 827
      i += len * 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 830
  return (0);
  ERROR2: 
  {
#line 833
  psiconv_list_free(*encoded_bytes);
  }
  ERROR1: 
#line 835
  return (res);
}
}
#line 39 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_4_red___1[16]  = 
#line 39 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
  {      (float )((double )0 / 255.0),      (float )((double )85 / 255.0),      (float )((double )128 / 255.0),      (float )((double )128 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )128 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )170 / 255.0),      (float )((double )255 / 255.0)};
#line 46 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_4_green___1[16]  = 
#line 46
  {      (float )((double )0 / 255.0),      (float )((double )85 / 255.0),      (float )((double )0 / 255.0),      (float )((double )128 / 255.0), 
        (float )((double )128 / 255.0),      (float )((double )0 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )128 / 255.0),      (float )((double )170 / 255.0),      (float )((double )255 / 255.0)};
#line 53 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_4_blue___1[16]  = 
#line 53
  {      (float )((double )0 / 255.0),      (float )((double )85 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )255 / 255.0),      (float )((double )128 / 255.0), 
        (float )((double )128 / 255.0),      (float )((double )128 / 255.0),      (float )((double )170 / 255.0),      (float )((double )255 / 255.0)};
#line 69 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_8_red___1[256]  = 
#line 69
  {      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )17 / 255.0),      (float )((double )34 / 255.0),      (float )((double )68 / 255.0),      (float )((double )85 / 255.0), 
        (float )((double )119 / 255.0),      (float )((double )17 / 255.0),      (float )((double )34 / 255.0),      (float )((double )68 / 255.0), 
        (float )((double )85 / 255.0),      (float )((double )119 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )136 / 255.0),      (float )((double )170 / 255.0), 
        (float )((double )187 / 255.0),      (float )((double )221 / 255.0),      (float )((double )238 / 255.0),      (float )((double )136 / 255.0), 
        (float )((double )170 / 255.0),      (float )((double )187 / 255.0),      (float )((double )221 / 255.0),      (float )((double )238 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0)};
#line 136 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_8_green___1[256]  = 
#line 136
  {      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )17 / 255.0),      (float )((double )34 / 255.0),      (float )((double )68 / 255.0),      (float )((double )85 / 255.0), 
        (float )((double )119 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )17 / 255.0),      (float )((double )34 / 255.0), 
        (float )((double )68 / 255.0),      (float )((double )85 / 255.0),      (float )((double )119 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )136 / 255.0),      (float )((double )170 / 255.0),      (float )((double )187 / 255.0), 
        (float )((double )221 / 255.0),      (float )((double )238 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )136 / 255.0), 
        (float )((double )170 / 255.0),      (float )((double )187 / 255.0),      (float )((double )221 / 255.0),      (float )((double )238 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0)};
#line 203 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_8_blue___1[256]  = 
#line 203
  {      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )17 / 255.0),      (float )((double )34 / 255.0),      (float )((double )68 / 255.0),      (float )((double )85 / 255.0), 
        (float )((double )119 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )17 / 255.0), 
        (float )((double )34 / 255.0),      (float )((double )68 / 255.0),      (float )((double )85 / 255.0),      (float )((double )119 / 255.0), 
        (float )((double )136 / 255.0),      (float )((double )170 / 255.0),      (float )((double )187 / 255.0),      (float )((double )221 / 255.0), 
        (float )((double )238 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )136 / 255.0), 
        (float )((double )170 / 255.0),      (float )((double )187 / 255.0),      (float )((double )221 / 255.0),      (float )((double )238 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0)};
#line 36 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
static int psiconv_list_resize___1(psiconv_list l , psiconv_u32 nr ) ;
#line 178 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
static int psiconv_list_resize___1(psiconv_list l , psiconv_u32 nr ) 
{ 
  void *temp ;

  {
#line 181
  if (nr > l->max_len) {
    {
#line 182
    l->max_len = (psiconv_u32 )(1.1 * (double )nr);
#line 183
    l->max_len += 16U - l->max_len % 16U;
#line 184
    temp = realloc(l->els, (size_t )l->max_len * l->el_size);
    }
#line 185
    if (temp) {
#line 186
      l->els = temp;
#line 187
      return (0);
    } else {
#line 189
      return (-2);
    }
  }
#line 191
  return (0);
}
}
#line 45 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/buffer.c"
static psiconv_u32 unique_id___1  =    (psiconv_u32 )1;
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_color clone_color___1(psiconv_color color___1 ) ;
#line 34
static psiconv_font clone_font___1(psiconv_font font___9 ) ;
#line 35
static psiconv_border clone_border___1(psiconv_border border___1 ) ;
#line 36
static psiconv_bullet clone_bullet___1(psiconv_bullet bullet___4 ) ;
#line 37
static psiconv_all_tabs clone_all_tabs___1(psiconv_all_tabs all_tabs ) ;
#line 38
static void psiconv_free_style_aux___1(void *style___1 ) ;
#line 39
static void psiconv_free_in_line_layout_aux___1(void *layout ) ;
#line 40
static void psiconv_free_paragraph_aux___1(void *paragraph___3 ) ;
#line 41
static void psiconv_free_paint_data_section_aux___1(void *section ) ;
#line 42
static void psiconv_free_clipart_section_aux___1(void *section ) ;
#line 43
static void psiconv_free_formula_aux___1(void *data ) ;
#line 44
static void psiconv_free_sheet_worksheet_aux___1(void *data ) ;
#line 45
static void psiconv_free_sheet_variable_aux___1(void *variable ) ;
#line 46
static void psiconv_free_sheet_cell_aux___1(void *cell ) ;
#line 47
static void psiconv_free_sheet_line_aux___1(void *line ) ;
#line 50
static psiconv_word_styles_section psiconv_empty_word_styles_section___1(void) ;
#line 51
static psiconv_text_and_layout psiconv_empty_text_and_layout___1(void) ;
#line 52
static psiconv_texted_section psiconv_empty_texted_section___1(void) ;
#line 53
static psiconv_page_header psiconv_empty_page_header___1(void) ;
#line 54
static psiconv_page_layout_section psiconv_empty_page_layout_section___1(void) ;
#line 55
static psiconv_word_status_section psiconv_empty_word_status_section___1(void) ;
#line 56
static psiconv_word_f psiconv_empty_word_f___1(void) ;
#line 57
static psiconv_sheet_status_section psiconv_empty_sheet_status_section___1(void) ;
#line 58
static psiconv_formula_list psiconv_empty_formula_list___1(void) ;
#line 59
static psiconv_sheet_workbook_section psiconv_empty_sheet_workbook_section___1(void) ;
#line 61
static psiconv_sheet_f psiconv_empty_sheet_f___1(void) ;
#line 62
static psiconv_texted_f psiconv_empty_texted_f___1(void) ;
#line 63
static psiconv_paint_data_section psiconv_empty_paint_data_section___1(void) ;
#line 64
static psiconv_pictures psiconv_empty_pictures___1(void) ;
#line 65
static psiconv_mbm_f psiconv_empty_mbm_f___1(void) ;
#line 66
static psiconv_sketch_section psiconv_empty_sketch_section___1(void) ;
#line 67
static psiconv_sketch_f psiconv_empty_sketch_f___1(void) ;
#line 68
static psiconv_clipart_f psiconv_empty_clipart_f___1(void) ;
#line 69
static psiconv_cliparts psiconv_empty_cliparts___1(void) ;
#line 77 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_color_s black___3  =    {(psiconv_u8 )0, (psiconv_u8 )0, (psiconv_u8 )0};
#line 83 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_color_s white___3  =    {(psiconv_u8 )255, (psiconv_u8 )255, (psiconv_u8 )255};
#line 89 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_ucs2 font_times___3[16]  = 
#line 89
  {      (psiconv_ucs2 )'T',      (psiconv_ucs2 )'i',      (psiconv_ucs2 )'m',      (psiconv_ucs2 )'e', 
        (psiconv_ucs2 )'s',      (psiconv_ucs2 )' ',      (psiconv_ucs2 )'N',      (psiconv_ucs2 )'e', 
        (psiconv_ucs2 )'w',      (psiconv_ucs2 )' ',      (psiconv_ucs2 )'R',      (psiconv_ucs2 )'o', 
        (psiconv_ucs2 )'m',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'n',      (psiconv_ucs2 )0};
#line 92 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_font_s font___3  =    {font_times___3, (psiconv_screenfont_t )3};
#line 117 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_ucs2 font_times___4[16]  = 
#line 117
  {      (psiconv_ucs2 )'T',      (psiconv_ucs2 )'i',      (psiconv_ucs2 )'m',      (psiconv_ucs2 )'e', 
        (psiconv_ucs2 )'s',      (psiconv_ucs2 )' ',      (psiconv_ucs2 )'N',      (psiconv_ucs2 )'e', 
        (psiconv_ucs2 )'w',      (psiconv_ucs2 )' ',      (psiconv_ucs2 )'R',      (psiconv_ucs2 )'o', 
        (psiconv_ucs2 )'m',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'n',      (psiconv_ucs2 )0};
#line 121 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_font_s font___4  =    {font_times___4, (psiconv_screenfont_t )2};
#line 126 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_color_s black___4  =    {(psiconv_u8 )0, (psiconv_u8 )0, (psiconv_u8 )0};
#line 132 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_color_s white___4  =    {(psiconv_u8 )255, (psiconv_u8 )255, (psiconv_u8 )255};
#line 138 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_border_s no_border___1  =    {(psiconv_border_kind_t )0, (psiconv_size_t )1, & black___4};
#line 144 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_bullet_s bullet___1  =    {(psiconv_bool_t )0, (psiconv_size_t )10.0, (psiconv_ucs2 )8221, (psiconv_bool_t )1,
    & black___4, & font___4};
#line 153 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_all_tabs_s tabs___1  =    {(psiconv_length_t )0.64, (psiconv_tab_list )((void *)0)};
#line 192 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_color clone_color___1(psiconv_color color___1 ) 
{ 
  psiconv_color result ;
  void *tmp ;

  {
  {
#line 195
  tmp = malloc(sizeof(*result));
#line 195
  result = (psiconv_color )tmp;
  }
#line 195
  if (! result) {
#line 196
    return ((psiconv_color )((void *)0));
  }
#line 197
  *result = *color___1;
#line 198
  return (result);
}
}
#line 201 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_font clone_font___1(psiconv_font font___9 ) 
{ 
  psiconv_font result ;
  void *tmp ;
  psiconv_string_t tmp___0 ;

  {
  {
#line 204
  tmp = malloc(sizeof(*result));
#line 204
  result = (psiconv_font )tmp;
  }
#line 204
  if (! result) {
#line 205
    goto ERROR1;
  }
  {
#line 206
  *result = *font___9;
#line 207
  tmp___0 = psiconv_unicode_strdup((psiconv_ucs2 const   *)result->name);
#line 207
  result->name = tmp___0;
  }
#line 207
  if (! tmp___0) {
#line 208
    goto ERROR2;
  }
#line 209
  return (result);
  ERROR2: 
  {
#line 211
  free((void *)result);
  }
  ERROR1: 
#line 213
  return ((psiconv_font )((void *)0));
}
}
#line 216 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_border clone_border___1(psiconv_border border___1 ) 
{ 
  psiconv_border result ;
  void *tmp ;
  psiconv_color tmp___0 ;

  {
  {
#line 219
  tmp = malloc(sizeof(*result));
#line 219
  result = (psiconv_border )tmp;
  }
#line 219
  if (! result) {
#line 220
    goto ERROR1;
  }
  {
#line 221
  *result = *border___1;
#line 222
  tmp___0 = clone_color___1(result->color);
#line 222
  result->color = tmp___0;
  }
#line 222
  if (! tmp___0) {
#line 223
    goto ERROR2;
  }
#line 224
  return (result);
  ERROR2: 
  {
#line 226
  free((void *)result);
  }
  ERROR1: 
#line 228
  return ((psiconv_border )((void *)0));
}
}
#line 231 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_bullet clone_bullet___1(psiconv_bullet bullet___4 ) 
{ 
  psiconv_bullet result ;
  void *tmp ;
  psiconv_font tmp___0 ;
  psiconv_color tmp___1 ;

  {
  {
#line 234
  tmp = malloc(sizeof(*result));
#line 234
  result = (psiconv_bullet )tmp;
  }
#line 234
  if (! result) {
#line 235
    goto ERROR1;
  }
  {
#line 236
  *result = *bullet___4;
#line 237
  tmp___0 = clone_font___1(result->font);
#line 237
  result->font = tmp___0;
  }
#line 237
  if (! tmp___0) {
#line 238
    goto ERROR2;
  }
  {
#line 239
  tmp___1 = clone_color___1(result->color);
#line 239
  result->color = tmp___1;
  }
#line 239
  if (! tmp___1) {
#line 240
    goto ERROR3;
  }
#line 241
  return (result);
  ERROR3: 
  {
#line 243
  psiconv_free_font(result->font);
  }
  ERROR2: 
  {
#line 245
  free((void *)result);
  }
  ERROR1: 
#line 247
  return ((psiconv_bullet )((void *)0));
}
}
#line 250 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_all_tabs clone_all_tabs___1(psiconv_all_tabs all_tabs ) 
{ 
  psiconv_all_tabs result ;
  void *tmp ;
  psiconv_tab_list tmp___0 ;

  {
  {
#line 253
  tmp = malloc(sizeof(*result));
#line 253
  result = (psiconv_all_tabs )tmp;
  }
#line 253
  if (! result) {
#line 254
    goto ERROR1;
  }
  {
#line 255
  *result = *all_tabs;
#line 256
  tmp___0 = psiconv_list_clone((psiconv_list const   )result->extras);
#line 256
  result->extras = tmp___0;
  }
#line 256
  if (! tmp___0) {
#line 257
    goto ERROR2;
  }
#line 258
  return (result);
  ERROR2: 
  {
#line 260
  free((void *)result);
  }
  ERROR1: 
#line 262
  return ((psiconv_all_tabs )((void *)0));
}
}
#line 464 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_style_aux___1(void *style___1 ) 
{ 


  {
#line 466
  if (((psiconv_word_style )style___1)->name) {
    {
#line 467
    free((void *)((psiconv_word_style )style___1)->name);
    }
  }
  {
#line 468
  psiconv_free_character_layout(((psiconv_word_style )style___1)->character);
#line 469
  psiconv_free_paragraph_layout(((psiconv_word_style )style___1)->paragraph);
  }
#line 470
  return;
}
}
#line 548 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_in_line_layout_aux___1(void *layout ) 
{ 


  {
  {
#line 550
  psiconv_free_character_layout(((psiconv_in_line_layout )layout)->layout);
#line 551
  psiconv_free_embedded_object_section(((psiconv_in_line_layout )layout)->object);
  }
#line 553
  return;
}
}
#line 581 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_paragraph_aux___1(void *paragraph___3 ) 
{ 


  {
#line 583
  if (((psiconv_paragraph )paragraph___3)->text) {
    {
#line 584
    free((void *)((psiconv_paragraph )paragraph___3)->text);
    }
  }
  {
#line 585
  psiconv_free_character_layout(((psiconv_paragraph )paragraph___3)->base_character);
#line 587
  psiconv_free_paragraph_layout(((psiconv_paragraph )paragraph___3)->base_paragraph);
#line 589
  psiconv_free_in_line_layouts(((psiconv_paragraph )paragraph___3)->in_lines);
#line 591
  psiconv_free_replacements(((psiconv_paragraph )paragraph___3)->replacements);
  }
#line 593
  return;
}
}
#line 672 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_sheet_cell_aux___1(void *cell ) 
{ 
  psiconv_sheet_cell data ;

  {
  {
#line 674
  data = (psiconv_sheet_cell )cell;
#line 676
  psiconv_free_sheet_cell_layout(data->layout);
  }
#line 678
  if ((unsigned int )data->type == 5U) {
#line 678
    if (data->data.dat_string) {
      {
#line 679
      free((void *)data->data.dat_string);
      }
    }
  }
#line 680
  return;
}
}
#line 696 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_sheet_line_aux___1(void *line ) 
{ 
  psiconv_sheet_line data ;

  {
  {
#line 698
  data = (psiconv_sheet_line )line;
#line 700
  psiconv_free_sheet_cell_layout(data->layout);
  }
#line 701
  return;
}
}
#line 747 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_sheet_worksheet_aux___1(void *data ) 
{ 
  psiconv_sheet_worksheet section ;

  {
  {
#line 749
  section = (psiconv_sheet_worksheet )data;
#line 750
  psiconv_free_sheet_cell_layout(section->default_layout);
#line 751
  psiconv_free_sheet_cell_list(section->cells);
#line 752
  psiconv_free_sheet_line_list(section->row_default_layouts);
#line 753
  psiconv_free_sheet_line_list(section->col_default_layouts);
#line 754
  psiconv_free_sheet_grid_section(section->grid);
  }
#line 755
  return;
}
}
#line 771 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_formula_aux___1(void *data ) 
{ 
  psiconv_formula formula ;

  {
#line 774
  formula = (psiconv_formula )data;
#line 775
  if ((unsigned int )formula->type == 23U) {
    {
#line 776
    free((void *)formula->data.dat_string);
    }
  } else
#line 777
  if ((unsigned int )formula->type != 21U) {
#line 777
    if ((unsigned int )formula->type != 22U) {
#line 777
      if ((unsigned int )formula->type != 20U) {
#line 777
        if ((unsigned int )formula->type != 24U) {
#line 777
          if ((unsigned int )formula->type != 25U) {
#line 777
            if ((unsigned int )formula->type != 26U) {
#line 777
              if ((unsigned int )formula->type != 27U) {
#line 777
                if ((unsigned int )formula->type != 28U) {
#line 777
                  if ((unsigned int )formula->type != 19U) {
#line 777
                    if ((unsigned int )formula->type != 0U) {
                      {
#line 787
                      psiconv_free_formula_list(formula->data.fun_operands);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 788
  return;
}
}
#line 820 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_sheet_variable_aux___1(void *variable ) 
{ 
  psiconv_sheet_variable var ;

  {
#line 822
  var = (psiconv_sheet_variable )variable;
#line 823
  if (var->name) {
    {
#line 824
    free((void *)var->name);
    }
  }
#line 825
  if ((unsigned int )var->type == 2U) {
    {
#line 826
    free((void *)var->data.dat_string);
    }
  }
#line 827
  return;
}
}
#line 874 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_paint_data_section_aux___1(void *section ) 
{ 


  {
#line 876
  if (((psiconv_paint_data_section )section)->red) {
    {
#line 877
    free((void *)((psiconv_paint_data_section )section)->red);
    }
  }
#line 878
  if (((psiconv_paint_data_section )section)->green) {
    {
#line 879
    free((void *)((psiconv_paint_data_section )section)->green);
    }
  }
#line 880
  if (((psiconv_paint_data_section )section)->blue) {
    {
#line 881
    free((void *)((psiconv_paint_data_section )section)->blue);
    }
  }
#line 882
  return;
}
}
#line 928 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_clipart_section_aux___1(void *section ) 
{ 


  {
#line 930
  if (section) {
    {
#line 931
    psiconv_free_paint_data_section(((psiconv_clipart_section )section)->picture);
    }
  }
#line 932
  return;
}
}
#line 1112 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_word_styles_section psiconv_empty_word_styles_section___1(void) 
{ 
  psiconv_word_styles_section result ;
  void *tmp ;
  psiconv_word_style_list tmp___0 ;
  psiconv_word_style tmp___1 ;
  void *tmp___2 ;
  psiconv_character_layout tmp___3 ;
  psiconv_paragraph_layout tmp___4 ;

  {
  {
#line 1115
  tmp = malloc(sizeof(*result));
#line 1115
  result = (psiconv_word_styles_section )tmp;
  }
#line 1115
  if (! result) {
#line 1116
    goto ERROR1;
  }
  {
#line 1117
  tmp___0 = psiconv_list_new(sizeof(struct psiconv_word_style_s ));
#line 1117
  result->styles = tmp___0;
  }
#line 1117
  if (! tmp___0) {
#line 1118
    goto ERROR2;
  }
  {
#line 1119
  tmp___2 = malloc(sizeof(struct psiconv_word_style_s ));
#line 1119
  tmp___1 = (psiconv_word_style )tmp___2;
#line 1119
  result->normal = tmp___1;
  }
#line 1119
  if (! tmp___1) {
#line 1120
    goto ERROR3;
  }
  {
#line 1121
  tmp___3 = psiconv_basic_character_layout();
#line 1121
  (result->normal)->character = tmp___3;
  }
#line 1121
  if (! tmp___3) {
#line 1122
    goto ERROR4;
  }
  {
#line 1123
  tmp___4 = psiconv_basic_paragraph_layout();
#line 1123
  (result->normal)->paragraph = tmp___4;
  }
#line 1123
  if (! tmp___4) {
#line 1124
    goto ERROR5;
  }
#line 1125
  (result->normal)->hotkey = (psiconv_ucs2 )'N';
#line 1126
  (result->normal)->name = (psiconv_string_t )((void *)0);
#line 1127
  (result->normal)->built_in = (psiconv_bool_t )1;
#line 1128
  (result->normal)->outline_level = (psiconv_u32 )0;
#line 1129
  return (result);
  ERROR5: 
  {
#line 1131
  psiconv_free_character_layout((result->normal)->character);
  }
  ERROR4: 
  {
#line 1133
  free((void *)result->normal);
  }
  ERROR3: 
  {
#line 1135
  psiconv_list_free(result->styles);
  }
  ERROR2: 
  {
#line 1137
  free((void *)result);
  }
  ERROR1: 
#line 1139
  return ((psiconv_word_styles_section )((void *)0));
}
}
#line 1142 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_text_and_layout psiconv_empty_text_and_layout___1(void) 
{ 
  psiconv_list tmp ;

  {
  {
#line 1144
  tmp = psiconv_list_new(sizeof(struct psiconv_paragraph_s ));
  }
#line 1144
  return (tmp);
}
}
#line 1147 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_texted_section psiconv_empty_texted_section___1(void) 
{ 
  psiconv_texted_section result ;
  void *tmp ;
  psiconv_text_and_layout tmp___0 ;

  {
  {
#line 1150
  tmp = malloc(sizeof(*result));
#line 1150
  result = (psiconv_texted_section )tmp;
  }
#line 1150
  if (! result) {
#line 1151
    goto ERROR1;
  }
  {
#line 1152
  tmp___0 = psiconv_empty_text_and_layout___1();
#line 1152
  result->paragraphs = tmp___0;
  }
#line 1152
  if (! tmp___0) {
#line 1153
    goto ERROR2;
  }
#line 1154
  return (result);
  ERROR2: 
  {
#line 1156
  free((void *)result);
  }
  ERROR1: 
#line 1158
  return ((psiconv_texted_section )((void *)0));
}
}
#line 1161 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_page_header psiconv_empty_page_header___1(void) 
{ 
  psiconv_page_header result ;
  void *tmp ;
  psiconv_paragraph_layout tmp___0 ;
  psiconv_character_layout tmp___1 ;
  psiconv_texted_section tmp___2 ;

  {
  {
#line 1164
  tmp = malloc(sizeof(*result));
#line 1164
  result = (psiconv_page_header )tmp;
  }
#line 1164
  if (! result) {
#line 1165
    goto ERROR1;
  }
  {
#line 1166
  result->on_first_page = (psiconv_bool_t )1;
#line 1167
  tmp___0 = psiconv_basic_paragraph_layout();
#line 1167
  result->base_paragraph_layout = tmp___0;
  }
#line 1167
  if (! tmp___0) {
#line 1168
    goto ERROR2;
  }
  {
#line 1169
  tmp___1 = psiconv_basic_character_layout();
#line 1169
  result->base_character_layout = tmp___1;
  }
#line 1169
  if (! tmp___1) {
#line 1170
    goto ERROR3;
  }
  {
#line 1171
  tmp___2 = psiconv_empty_texted_section___1();
#line 1171
  result->text = tmp___2;
  }
#line 1171
  if (! tmp___2) {
#line 1172
    goto ERROR4;
  }
#line 1173
  return (result);
  ERROR4: 
  {
#line 1175
  psiconv_free_character_layout(result->base_character_layout);
  }
  ERROR3: 
  {
#line 1177
  psiconv_free_paragraph_layout(result->base_paragraph_layout);
  }
  ERROR2: 
  {
#line 1179
  free((void *)result);
  }
  ERROR1: 
#line 1181
  return ((psiconv_page_header )((void *)0));
}
}
#line 1184 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_page_layout_section psiconv_empty_page_layout_section___1(void) 
{ 
  psiconv_page_layout_section result ;
  void *tmp ;
  psiconv_length_t tmp___0 ;
  psiconv_length_t tmp___1 ;
  psiconv_length_t tmp___2 ;
  psiconv_page_header tmp___3 ;
  psiconv_page_header tmp___4 ;

  {
  {
#line 1187
  tmp = malloc(sizeof(*result));
#line 1187
  result = (psiconv_page_layout_section )tmp;
  }
#line 1187
  if (! result) {
#line 1188
    goto ERROR1;
  }
  {
#line 1189
  result->first_page_nr = (psiconv_u32 )1;
#line 1190
  tmp___0 = (psiconv_length_t )1.27;
#line 1190
  result->footer_dist = tmp___0;
#line 1190
  result->header_dist = tmp___0;
#line 1191
  tmp___1 = (psiconv_length_t )3.175;
#line 1191
  result->right_margin = tmp___1;
#line 1191
  result->left_margin = tmp___1;
#line 1192
  tmp___2 = (psiconv_length_t )2.54;
#line 1192
  result->bottom_margin = tmp___2;
#line 1192
  result->top_margin = tmp___2;
#line 1193
  result->page_width = (psiconv_length_t )21.0;
#line 1194
  result->page_height = (psiconv_length_t )29.7;
#line 1195
  result->landscape = (psiconv_bool_t )0;
#line 1196
  tmp___3 = psiconv_empty_page_header___1();
#line 1196
  result->header = tmp___3;
  }
#line 1196
  if (! tmp___3) {
#line 1197
    goto ERROR2;
  }
  {
#line 1198
  tmp___4 = psiconv_empty_page_header___1();
#line 1198
  result->footer = tmp___4;
  }
#line 1198
  if (! tmp___4) {
#line 1199
    goto ERROR3;
  }
#line 1200
  return (result);
  ERROR3: 
  {
#line 1202
  psiconv_free_page_header(result->header);
  }
  ERROR2: 
  {
#line 1204
  free((void *)result);
  }
  ERROR1: 
#line 1206
  return ((psiconv_page_layout_section )((void *)0));
}
}
#line 1209 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_word_status_section psiconv_empty_word_status_section___1(void) 
{ 
  psiconv_word_status_section result ;
  void *tmp ;
  psiconv_bool_t tmp___0 ;
  psiconv_bool_t tmp___1 ;
  psiconv_bool_t tmp___2 ;
  psiconv_bool_t tmp___3 ;
  psiconv_bool_t tmp___4 ;
  psiconv_bool_t tmp___5 ;
  psiconv_bool_t tmp___6 ;
  psiconv_bool_t tmp___7 ;

  {
  {
#line 1212
  tmp = malloc(sizeof(*result));
#line 1212
  result = (psiconv_word_status_section )tmp;
  }
#line 1212
  if (! result) {
#line 1213
    return ((psiconv_word_status_section )((void *)0));
  }
#line 1214
  tmp___4 = (psiconv_bool_t )0;
#line 1214
  result->fit_lines_to_screen = tmp___4;
#line 1214
  tmp___3 = tmp___4;
#line 1214
  result->show_hard_space = tmp___3;
#line 1214
  tmp___2 = tmp___3;
#line 1214
  result->show_hard_minus = tmp___2;
#line 1214
  tmp___1 = tmp___2;
#line 1214
  result->show_paragraph_ends = tmp___1;
#line 1214
  tmp___0 = tmp___1;
#line 1214
  result->show_spaces = tmp___0;
#line 1214
  result->show_tabs = tmp___0;
#line 1217
  tmp___7 = (psiconv_bool_t )1;
#line 1217
  result->show_side_toolbar = tmp___7;
#line 1217
  tmp___6 = tmp___7;
#line 1217
  result->show_top_toolbar = tmp___6;
#line 1217
  tmp___5 = tmp___6;
#line 1217
  result->show_full_graphs = tmp___5;
#line 1217
  result->show_full_pictures = tmp___5;
#line 1220
  result->cursor_position = (psiconv_u32 )0;
#line 1221
  result->display_size = (psiconv_u32 )1000;
#line 1222
  return (result);
}
}
#line 1225 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_word_f psiconv_empty_word_f___1(void) 
{ 
  psiconv_word_f result ;
  void *tmp ;
  psiconv_page_layout_section tmp___0 ;
  psiconv_text_and_layout tmp___1 ;
  psiconv_word_status_section tmp___2 ;
  psiconv_word_styles_section tmp___3 ;

  {
  {
#line 1228
  tmp = malloc(sizeof(*result));
#line 1228
  result = (psiconv_word_f )tmp;
  }
#line 1228
  if (! result) {
#line 1229
    goto ERROR1;
  }
  {
#line 1230
  tmp___0 = psiconv_empty_page_layout_section___1();
#line 1230
  result->page_sec = tmp___0;
  }
#line 1230
  if (! tmp___0) {
#line 1231
    goto ERROR2;
  }
  {
#line 1232
  tmp___1 = psiconv_empty_text_and_layout___1();
#line 1232
  result->paragraphs = tmp___1;
  }
#line 1232
  if (! tmp___1) {
#line 1233
    goto ERROR3;
  }
  {
#line 1234
  tmp___2 = psiconv_empty_word_status_section___1();
#line 1234
  result->status_sec = tmp___2;
  }
#line 1234
  if (! tmp___2) {
#line 1235
    goto ERROR4;
  }
  {
#line 1236
  tmp___3 = psiconv_empty_word_styles_section___1();
#line 1236
  result->styles_sec = tmp___3;
  }
#line 1236
  if (! tmp___3) {
#line 1237
    goto ERROR5;
  }
#line 1238
  return (result);
  ERROR5: 
  {
#line 1240
  psiconv_free_word_status_section(result->status_sec);
  }
  ERROR4: 
  {
#line 1242
  psiconv_free_text_and_layout(result->paragraphs);
  }
  ERROR3: 
  {
#line 1244
  psiconv_free_page_layout_section(result->page_sec);
  }
  ERROR2: 
  {
#line 1246
  free((void *)result);
  }
  ERROR1: 
#line 1248
  return ((psiconv_word_f )((void *)0));
}
}
#line 1251 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sheet_status_section psiconv_empty_sheet_status_section___1(void) 
{ 
  psiconv_sheet_status_section result ;
  void *tmp ;
  psiconv_triple_t tmp___0 ;
  psiconv_bool_t tmp___1 ;
  psiconv_bool_t tmp___2 ;
  psiconv_bool_t tmp___3 ;
  psiconv_u32 tmp___4 ;
  psiconv_u32 tmp___5 ;

  {
  {
#line 1254
  tmp = malloc(sizeof(*result));
#line 1254
  result = (psiconv_sheet_status_section )tmp;
  }
#line 1254
  if (! result) {
#line 1255
    return ((psiconv_sheet_status_section )((void *)0));
  }
#line 1256
  tmp___0 = (psiconv_triple_t )2;
#line 1256
  result->show_vertical_scrollbar = tmp___0;
#line 1256
  result->show_horizontal_scrollbar = tmp___0;
#line 1258
  result->show_graph = (psiconv_bool_t )0;
#line 1259
  tmp___3 = (psiconv_bool_t )1;
#line 1259
  result->show_side_graph_toolbar = tmp___3;
#line 1259
  tmp___2 = tmp___3;
#line 1259
  result->show_top_graph_toolbar = tmp___2;
#line 1259
  tmp___1 = tmp___2;
#line 1259
  result->show_side_sheet_toolbar = tmp___1;
#line 1259
  result->show_top_sheet_toolbar = tmp___1;
#line 1262
  tmp___4 = (psiconv_u32 )0;
#line 1262
  result->cursor_column = tmp___4;
#line 1262
  result->cursor_row = tmp___4;
#line 1263
  tmp___5 = (psiconv_u32 )1000;
#line 1263
  result->graph_display_size = tmp___5;
#line 1263
  result->sheet_display_size = tmp___5;
#line 1264
  return (result);
}
}
#line 1267 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_formula_list psiconv_empty_formula_list___1(void) 
{ 
  psiconv_list tmp ;

  {
  {
#line 1269
  tmp = psiconv_list_new(sizeof(struct psiconv_formula_s ));
  }
#line 1269
  return (tmp);
}
}
#line 1272 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sheet_workbook_section psiconv_empty_sheet_workbook_section___1(void) 
{ 
  psiconv_sheet_workbook_section result ;
  void *tmp ;
  psiconv_formula_list tmp___0 ;

  {
  {
#line 1275
  tmp = malloc(sizeof(*result));
#line 1275
  result = (psiconv_sheet_workbook_section )tmp;
  }
#line 1275
  if (! result) {
#line 1276
    goto ERROR1;
  }
  {
#line 1277
  tmp___0 = psiconv_empty_formula_list___1();
#line 1277
  result->formulas = tmp___0;
  }
#line 1277
  if (! tmp___0) {
#line 1278
    goto ERROR2;
  }
#line 1279
  return (result);
  ERROR2: 
  {
#line 1281
  free((void *)result);
  }
  ERROR1: 
#line 1283
  return ((psiconv_sheet_workbook_section )((void *)0));
}
}
#line 1287 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sheet_f psiconv_empty_sheet_f___1(void) 
{ 
  psiconv_sheet_f result ;
  void *tmp ;
  psiconv_page_layout_section tmp___0 ;
  psiconv_sheet_status_section tmp___1 ;
  psiconv_sheet_workbook_section tmp___2 ;

  {
  {
#line 1290
  tmp = malloc(sizeof(*result));
#line 1290
  result = (psiconv_sheet_f )tmp;
  }
#line 1290
  if (! result) {
#line 1291
    goto ERROR1;
  }
  {
#line 1292
  tmp___0 = psiconv_empty_page_layout_section___1();
#line 1292
  result->page_sec = tmp___0;
  }
#line 1292
  if (! tmp___0) {
#line 1293
    goto ERROR2;
  }
  {
#line 1294
  tmp___1 = psiconv_empty_sheet_status_section___1();
#line 1294
  result->status_sec = tmp___1;
  }
#line 1294
  if (! tmp___1) {
#line 1295
    goto ERROR3;
  }
  {
#line 1296
  tmp___2 = psiconv_empty_sheet_workbook_section___1();
#line 1296
  result->workbook_sec = tmp___2;
  }
#line 1296
  if (! tmp___2) {
#line 1297
    goto ERROR4;
  }
#line 1298
  return (result);
  ERROR4: 
  {
#line 1300
  psiconv_free_sheet_status_section(result->status_sec);
  }
  ERROR3: 
  {
#line 1302
  psiconv_free_page_layout_section(result->page_sec);
  }
  ERROR2: 
  {
#line 1304
  free((void *)result);
  }
  ERROR1: 
#line 1306
  return ((psiconv_sheet_f )((void *)0));
}
}
#line 1309 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_texted_f psiconv_empty_texted_f___1(void) 
{ 
  psiconv_texted_f result ;
  void *tmp ;
  psiconv_page_layout_section tmp___0 ;
  psiconv_texted_section tmp___1 ;

  {
  {
#line 1312
  tmp = malloc(sizeof(*result));
#line 1312
  result = (psiconv_texted_f )tmp;
  }
#line 1312
  if (! result) {
#line 1313
    goto ERROR1;
  }
  {
#line 1314
  tmp___0 = psiconv_empty_page_layout_section___1();
#line 1314
  result->page_sec = tmp___0;
  }
#line 1314
  if (! tmp___0) {
#line 1315
    goto ERROR2;
  }
  {
#line 1316
  tmp___1 = psiconv_empty_texted_section___1();
#line 1316
  result->texted_sec = tmp___1;
  }
#line 1316
  if (! tmp___1) {
#line 1317
    goto ERROR3;
  }
#line 1318
  return (result);
  ERROR3: 
  {
#line 1320
  psiconv_free_page_layout_section(result->page_sec);
  }
  ERROR2: 
  {
#line 1322
  free((void *)result);
  }
  ERROR1: 
#line 1324
  return ((psiconv_texted_f )((void *)0));
}
}
#line 1327 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_paint_data_section psiconv_empty_paint_data_section___1(void) 
{ 
  psiconv_paint_data_section result ;
  void *tmp ;
  psiconv_u32 tmp___0 ;
  psiconv_length_t tmp___1 ;
  psiconv_length_t tmp___2 ;
  float *tmp___3 ;
  void *tmp___4 ;
  float *tmp___5 ;
  void *tmp___6 ;
  float *tmp___7 ;
  void *tmp___8 ;

  {
  {
#line 1330
  tmp = malloc(sizeof(*result));
#line 1330
  result = (psiconv_paint_data_section )tmp;
  }
#line 1330
  if (! result) {
#line 1331
    goto ERROR1;
  }
  {
#line 1333
  tmp___2 = (psiconv_length_t )0;
#line 1333
  result->pic_ysize = tmp___2;
#line 1333
  tmp___1 = tmp___2;
#line 1333
  result->pic_xsize = tmp___1;
#line 1333
  tmp___0 = (psiconv_u32 )tmp___1;
#line 1333
  result->ysize = tmp___0;
#line 1333
  result->xsize = tmp___0;
#line 1335
  tmp___4 = malloc((size_t )0);
#line 1335
  tmp___3 = (float *)tmp___4;
#line 1335
  result->red = tmp___3;
  }
#line 1335
  if (! tmp___3) {
#line 1336
    goto ERROR2;
  }
  {
#line 1337
  tmp___6 = malloc((size_t )0);
#line 1337
  tmp___5 = (float *)tmp___6;
#line 1337
  result->green = tmp___5;
  }
#line 1337
  if (! tmp___5) {
#line 1338
    goto ERROR3;
  }
  {
#line 1339
  tmp___8 = malloc((size_t )0);
#line 1339
  tmp___7 = (float *)tmp___8;
#line 1339
  result->blue = tmp___7;
  }
#line 1339
  if (! tmp___7) {
#line 1340
    goto ERROR4;
  }
#line 1341
  return (result);
  ERROR4: 
  {
#line 1343
  free((void *)result->green);
  }
  ERROR3: 
  {
#line 1345
  free((void *)result->red);
  }
  ERROR2: 
  {
#line 1347
  free((void *)result);
  }
  ERROR1: 
#line 1349
  return ((psiconv_paint_data_section )((void *)0));
}
}
#line 1353 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_pictures psiconv_empty_pictures___1(void) 
{ 
  psiconv_pictures result ;
  psiconv_paint_data_section pds ;
  int tmp ;

  {
  {
#line 1357
  result = psiconv_list_new(sizeof(struct psiconv_paint_data_section_s ));
  }
#line 1357
  if (! result) {
#line 1358
    goto ERROR1;
  }
  {
#line 1359
  pds = psiconv_empty_paint_data_section___1();
  }
#line 1359
  if (! pds) {
#line 1360
    goto ERROR2;
  }
  {
#line 1361
  tmp = psiconv_list_add(result, (void const   *)pds);
  }
#line 1361
  if (tmp) {
#line 1362
    goto ERROR3;
  }
  {
#line 1363
  free((void *)pds);
  }
#line 1364
  return (result);
  ERROR3: 
  {
#line 1366
  psiconv_free_paint_data_section(pds);
  }
  ERROR2: 
  {
#line 1368
  psiconv_list_free(result);
  }
  ERROR1: 
#line 1370
  return ((psiconv_pictures )((void *)0));
}
}
#line 1373 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_mbm_f psiconv_empty_mbm_f___1(void) 
{ 
  psiconv_mbm_f result ;
  void *tmp ;
  psiconv_pictures tmp___0 ;

  {
  {
#line 1376
  tmp = malloc(sizeof(*result));
#line 1376
  result = (psiconv_mbm_f )tmp;
  }
#line 1376
  if (! result) {
#line 1377
    goto ERROR1;
  }
  {
#line 1378
  tmp___0 = psiconv_empty_pictures___1();
#line 1378
  result->sections = tmp___0;
  }
#line 1378
  if (! tmp___0) {
#line 1379
    goto ERROR2;
  }
#line 1380
  return (result);
  ERROR2: 
  {
#line 1382
  free((void *)result);
  }
  ERROR1: 
#line 1384
  return ((psiconv_mbm_f )((void *)0));
}
}
#line 1387 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sketch_section psiconv_empty_sketch_section___1(void) 
{ 
  psiconv_sketch_section result ;
  void *tmp ;
  psiconv_u16 tmp___0 ;
  psiconv_u16 tmp___1 ;
  psiconv_u16 tmp___2 ;
  psiconv_u16 tmp___3 ;
  psiconv_u16 tmp___4 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;
  float tmp___8 ;
  psiconv_paint_data_section tmp___9 ;

  {
  {
#line 1390
  tmp = malloc(sizeof(*result));
#line 1390
  result = (psiconv_sketch_section )tmp;
  }
#line 1390
  if (! result) {
#line 1391
    goto ERROR1;
  }
  {
#line 1392
  result->displayed_xsize = (psiconv_u16 )320;
#line 1393
  result->displayed_ysize = (psiconv_u16 )200;
#line 1394
  tmp___4 = (psiconv_u16 )0;
#line 1394
  result->displayed_size_y_offset = tmp___4;
#line 1394
  tmp___3 = tmp___4;
#line 1394
  result->displayed_size_x_offset = tmp___3;
#line 1394
  tmp___2 = tmp___3;
#line 1394
  result->form_ysize = tmp___2;
#line 1394
  tmp___1 = tmp___2;
#line 1394
  result->form_xsize = tmp___1;
#line 1394
  tmp___0 = tmp___1;
#line 1394
  result->picture_data_y_offset = tmp___0;
#line 1394
  result->picture_data_x_offset = tmp___0;
#line 1397
  tmp___5 = (float )1.0;
#line 1397
  result->magnification_y = tmp___5;
#line 1397
  result->magnification_x = tmp___5;
#line 1398
  tmp___8 = (float )0.0;
#line 1398
  result->cut_bottom = tmp___8;
#line 1398
  tmp___7 = tmp___8;
#line 1398
  result->cut_top = tmp___7;
#line 1398
  tmp___6 = tmp___7;
#line 1398
  result->cut_right = tmp___6;
#line 1398
  result->cut_left = tmp___6;
#line 1400
  tmp___9 = psiconv_empty_paint_data_section___1();
#line 1400
  result->picture = tmp___9;
  }
#line 1400
  if (! tmp___9) {
#line 1401
    goto ERROR2;
  }
#line 1402
  return (result);
  ERROR2: 
  {
#line 1404
  free((void *)result);
  }
  ERROR1: 
#line 1406
  return ((psiconv_sketch_section )((void *)0));
}
}
#line 1409 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sketch_f psiconv_empty_sketch_f___1(void) 
{ 
  psiconv_sketch_f result ;
  void *tmp ;
  psiconv_sketch_section tmp___0 ;

  {
  {
#line 1412
  tmp = malloc(sizeof(*result));
#line 1412
  result = (psiconv_sketch_f )tmp;
  }
#line 1412
  if (! result) {
#line 1413
    goto ERROR1;
  }
  {
#line 1414
  tmp___0 = psiconv_empty_sketch_section___1();
#line 1414
  result->sketch_sec = tmp___0;
  }
#line 1414
  if (! tmp___0) {
#line 1415
    goto ERROR2;
  }
#line 1416
  return (result);
  ERROR2: 
  {
#line 1418
  free((void *)result);
  }
  ERROR1: 
#line 1420
  return ((psiconv_sketch_f )((void *)0));
}
}
#line 1423 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_cliparts psiconv_empty_cliparts___1(void) 
{ 
  psiconv_list tmp ;

  {
  {
#line 1426
  tmp = psiconv_list_new(sizeof(struct psiconv_clipart_section_s ));
  }
#line 1426
  return (tmp);
}
}
#line 1429 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_clipart_f psiconv_empty_clipart_f___1(void) 
{ 
  psiconv_clipart_f result ;
  void *tmp ;
  psiconv_cliparts tmp___0 ;

  {
  {
#line 1432
  tmp = malloc(sizeof(*result));
#line 1432
  result = (psiconv_clipart_f )tmp;
  }
#line 1432
  if (! result) {
#line 1433
    goto ERROR1;
  }
  {
#line 1434
  tmp___0 = psiconv_empty_cliparts___1();
#line 1434
  result->sections = tmp___0;
  }
#line 1434
  if (! tmp___0) {
#line 1435
    goto ERROR2;
  }
#line 1436
  return (result);
  ERROR2: 
  {
#line 1438
  free((void *)result);
  }
  ERROR1: 
#line 1440
  return ((psiconv_clipart_f )((void *)0));
}
}
#line 40 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static struct formula_element formula_elements___1[256]  = 
#line 40 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
  {      {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )1, 2, "<"}, 
        {(psiconv_formula_type_t )2, 2, "<="}, 
        {(psiconv_formula_type_t )3, 2, ">"}, 
        {(psiconv_formula_type_t )4, 2, ">="}, 
        {(psiconv_formula_type_t )5, 2, "<>"}, 
        {(psiconv_formula_type_t )6, 2, "="}, 
        {(psiconv_formula_type_t )7, 2, "+"}, 
        {(psiconv_formula_type_t )8, 2, "-"}, 
        {(psiconv_formula_type_t )9, 2, "*"}, 
        {(psiconv_formula_type_t )10, 2, "/"}, 
        {(psiconv_formula_type_t )11, 2, "^"}, 
        {(psiconv_formula_type_t )12, 1, "+"}, 
        {(psiconv_formula_type_t )13, 1, "-"}, 
        {(psiconv_formula_type_t )14, 1, "NOT"}, 
        {(psiconv_formula_type_t )15, 2, "AND"}, 
        {(psiconv_formula_type_t )16, 2, "OR"}, 
        {(psiconv_formula_type_t )17, 2, "&"}, 
        {(psiconv_formula_type_t )18, 1, "()"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )19, 0, "End of formula"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )20, 0, "Floating point number"}, 
        {(psiconv_formula_type_t )21, 0, "Signed integer number"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )22, 0, "Named variable"}, 
        {(psiconv_formula_type_t )23, 0, "String"}, 
        {(psiconv_formula_type_t )24, 0, "Cell reference"}, 
        {(psiconv_formula_type_t )25, 0, "Cell block"}, 
        {(psiconv_formula_type_t )26, 0, "Cell block {varargs}"}, 
        {(psiconv_formula_type_t )27, 0, "Operand separator"}, 
        {(psiconv_formula_type_t )28, 0, "Operand list end"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )29, 0, "FALSE"}, 
        {(psiconv_formula_type_t )30, 3, "IF"}, 
        {(psiconv_formula_type_t )31, 0, "TRUE"}, 
        {(psiconv_formula_type_t )32, 2, "CELL"}, 
        {(psiconv_formula_type_t )33, 0, "ERRORTYPE"}, 
        {(psiconv_formula_type_t )34, 1, "ISBLANK"}, 
        {(psiconv_formula_type_t )35, 1, "ISERR"}, 
        {(psiconv_formula_type_t )36, 1, "ISERROR"}, 
        {(psiconv_formula_type_t )37, 1, "ISLOGICAL"}, 
        {(psiconv_formula_type_t )38, 1, "ISNA"}, 
        {(psiconv_formula_type_t )39, 1, "ISNONTEXT"}, 
        {(psiconv_formula_type_t )40, 1, "ISNUMBER"}, 
        {(psiconv_formula_type_t )41, 1, "ISTEXT"}, 
        {(psiconv_formula_type_t )42, 1, "N"}, 
        {(psiconv_formula_type_t )43, 1, "TYPE"}, 
        {(psiconv_formula_type_t )44, 2, "ADDRESS"}, 
        {(psiconv_formula_type_t )45, 1, "COLUMN"}, 
        {(psiconv_formula_type_t )46, 1, "COLUMNS"}, 
        {(psiconv_formula_type_t )47, 3, "HLOOKUP"}, 
        {(psiconv_formula_type_t )48, 3, "INDEX"}, 
        {(psiconv_formula_type_t )49, 1, "INDIRECT"}, 
        {(psiconv_formula_type_t )50, 3, "LOOKUP"}, 
        {(psiconv_formula_type_t )51, 3, "OFFSET"}, 
        {(psiconv_formula_type_t )52, 1, "ROW"}, 
        {(psiconv_formula_type_t )53, 1, "ROWS"}, 
        {(psiconv_formula_type_t )54, 3, "VLOOKUP"}, 
        {(psiconv_formula_type_t )55, 1, "CHAR"}, 
        {(psiconv_formula_type_t )56, 1, "CODE"}, 
        {(psiconv_formula_type_t )57, 2, "EXACT"}, 
        {(psiconv_formula_type_t )58, 3, "FIND"}, 
        {(psiconv_formula_type_t )59, 2, "LEFT"}, 
        {(psiconv_formula_type_t )60, 1, "LEN"}, 
        {(psiconv_formula_type_t )61, 1, "LOWER"}, 
        {(psiconv_formula_type_t )62, 3, "MID"}, 
        {(psiconv_formula_type_t )63, 1, "PROPER"}, 
        {(psiconv_formula_type_t )64, 4, "REPLACE"}, 
        {(psiconv_formula_type_t )65, 2, "REPT"}, 
        {(psiconv_formula_type_t )66, 2, "RIGHT"}, 
        {(psiconv_formula_type_t )67, 2, "STRING"}, 
        {(psiconv_formula_type_t )68, 1, "T"}, 
        {(psiconv_formula_type_t )69, 1, "TRIM"}, 
        {(psiconv_formula_type_t )70, 1, "UPPER"}, 
        {(psiconv_formula_type_t )71, 1, "VALUE"}, 
        {(psiconv_formula_type_t )72, 3, "DATE"}, 
        {(psiconv_formula_type_t )73, 1, "DATEVALUE"}, 
        {(psiconv_formula_type_t )74, 1, "DAY"}, 
        {(psiconv_formula_type_t )75, 1, "HOUR"}, 
        {(psiconv_formula_type_t )76, 1, "MINUTE"}, 
        {(psiconv_formula_type_t )77, 1, "MONTH"}, 
        {(psiconv_formula_type_t )78, 0, "NOW"}, 
        {(psiconv_formula_type_t )79, 1, "SECOND"}, 
        {(psiconv_formula_type_t )80, 0, "TODAY"}, 
        {(psiconv_formula_type_t )81, 3, "TIME"}, 
        {(psiconv_formula_type_t )82, 1, "TIMEVALUE"}, 
        {(psiconv_formula_type_t )83, 1, "YEAR"}, 
        {(psiconv_formula_type_t )84, 1, "ABS"}, 
        {(psiconv_formula_type_t )85, 1, "ACOS"}, 
        {(psiconv_formula_type_t )86, 1, "ASIN"}, 
        {(psiconv_formula_type_t )87, 1, "ATAN"}, 
        {(psiconv_formula_type_t )88, 2, "ATAN2"}, 
        {(psiconv_formula_type_t )89, 1, "COS"}, 
        {(psiconv_formula_type_t )90, 0, "DEGREES"}, 
        {(psiconv_formula_type_t )91, 1, "EXP"}, 
        {(psiconv_formula_type_t )92, 1, "FACT"}, 
        {(psiconv_formula_type_t )93, 1, "INT"}, 
        {(psiconv_formula_type_t )94, 1, "LN"}, 
        {(psiconv_formula_type_t )95, 1, "LOG10"}, 
        {(psiconv_formula_type_t )96, 2, "MOD"}, 
        {(psiconv_formula_type_t )97, 0, "PI"}, 
        {(psiconv_formula_type_t )98, 1, "RADIANS"}, 
        {(psiconv_formula_type_t )99, 0, "RAND"}, 
        {(psiconv_formula_type_t )100, 2, "ROUND"}, 
        {(psiconv_formula_type_t )101, 1, "SIGN"}, 
        {(psiconv_formula_type_t )102, 1, "SIN"}, 
        {(psiconv_formula_type_t )103, 1, "SQRT"}, 
        {(psiconv_formula_type_t )104, 2, "SUMPRODUCT"}, 
        {(psiconv_formula_type_t )105, 1, "TAN"}, 
        {(psiconv_formula_type_t )106, 1, "TRUNC"}, 
        {(psiconv_formula_type_t )107, 3, "CTERM"}, 
        {(psiconv_formula_type_t )108, 4, "DDB"}, 
        {(psiconv_formula_type_t )109, 3, "FV"}, 
        {(psiconv_formula_type_t )110, 2, "IRR"}, 
        {(psiconv_formula_type_t )111, 2, "NPV"}, 
        {(psiconv_formula_type_t )112, 3, "PMT"}, 
        {(psiconv_formula_type_t )113, 3, "PV"}, 
        {(psiconv_formula_type_t )114, 3, "RATE"}, 
        {(psiconv_formula_type_t )115, 3, "SLN"}, 
        {(psiconv_formula_type_t )116, 4, "SYD"}, 
        {(psiconv_formula_type_t )117, 3, "TERM"}, 
        {(psiconv_formula_type_t )118, 2, "COMBIN"}, 
        {(psiconv_formula_type_t )119, 2, "PERMUT"}, 
        {(psiconv_formula_type_t )120, -1, "AVERAGE"}, 
        {(psiconv_formula_type_t )121, -1, "CHOOSE"}, 
        {(psiconv_formula_type_t )122, -1, "COUNT"}, 
        {(psiconv_formula_type_t )123, -1, "COUNTA"}, 
        {(psiconv_formula_type_t )124, -1, "COUNTBLANK"}, 
        {(psiconv_formula_type_t )125, -1, "MAX"}, 
        {(psiconv_formula_type_t )126, -1, "MIN"}, 
        {(psiconv_formula_type_t )127, -1, "PRODUCT"}, 
        {(psiconv_formula_type_t )128, -1, "STDEVP"}, 
        {(psiconv_formula_type_t )129, -1, "STDEV"}, 
        {(psiconv_formula_type_t )130, -1, "SUM"}, 
        {(psiconv_formula_type_t )131, -1, "SUMSQ"}, 
        {(psiconv_formula_type_t )132, -1, "VARP"}, 
        {(psiconv_formula_type_t )133, -1, "VAR"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}};
#line 296 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static int psiconv_parse_sheet_ref___1(psiconv_config const   config , psiconv_buffer const   buf ,
                                       int lev , psiconv_u32 off , int *length , psiconv_sheet_ref_t *result ) 
{ 
  int res ;
  psiconv_u16 temp ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 304
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a sheet ref");
#line 305
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the offset encoding");
#line 306
  temp = psiconv_read_u16(config, buf, lev + 2, off, & res);
  }
#line 307
  if (res) {
#line 308
    if (length) {
#line 309
      *length = 0;
    }
#line 310
    return (res);
  }
  {
#line 312
  psiconv_debug((psiconv_config )config, lev + 2, off, "Encoded word: %04x", (int )temp);
  }
#line 313
  if ((int )temp & 16384) {
#line 313
    result->absolute = (psiconv_bool_t )1;
  } else {
#line 313
    result->absolute = (psiconv_bool_t )0;
  }
#line 314
  if ((int )temp & 32768) {
#line 314
    tmp = -1;
  } else {
#line 314
    tmp = 1;
  }
#line 314
  result->offset = (psiconv_s16 )(((int )temp & 16383) * tmp);
#line 315
  if (result->absolute) {
#line 315
    tmp___0 = "absolute";
  } else {
#line 315
    tmp___0 = "relative";
  }
  {
#line 315
  psiconv_debug((psiconv_config )config, lev + 2, off, "Reference: %s offset %d",
                tmp___0, (int )result->offset);
  }
#line 317
  if (length) {
#line 318
    *length = 2;
  }
#line 319
  return (0);
}
}
#line 322 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static int psiconv_parse_sheet_cell_reference___1(psiconv_config const   config ,
                                                  psiconv_buffer const   buf , int lev ,
                                                  psiconv_u32 off , int *length ,
                                                  psiconv_sheet_cell_reference_t *result ) 
{ 
  int len ;
  int leng ;
  int res ;
  psiconv_u8 temp ;

  {
  {
#line 327
  len = 0;
#line 331
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read a sheet cell reference");
#line 332
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the row reference");
#line 333
  res = psiconv_parse_sheet_ref___1(config, buf, lev + 2, off + (psiconv_u32 )len,
                                    & leng, & result->row);
  }
#line 333
  if (res) {
#line 334
    goto ERROR;
  }
  {
#line 335
  len += leng;
#line 336
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the column reference");
#line 337
  res = psiconv_parse_sheet_ref___1(config, buf, lev + 2, off + (psiconv_u32 )len,
                                    & leng, & result->column);
  }
#line 337
  if (res) {
#line 338
    goto ERROR;
  }
  {
#line 339
  len += leng;
#line 341
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the trailing byte (%02x expected)",
                   0);
#line 343
  temp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 344
  if (res) {
#line 345
    goto ERROR;
  }
#line 346
  if ((int )temp != 0) {
    {
#line 347
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unknown byte in cell reference (ignored");
#line 348
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Trailing byte: %02x",
                  (int )temp);
    }
  }
  {
#line 350
  len ++;
#line 351
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of cell reference (total length: %08x)",
                   len);
  }
#line 353
  if (length) {
#line 354
    *length = len;
  }
#line 355
  return (0);
  ERROR: 
#line 357
  if (length) {
#line 358
    *length = 0;
  }
#line 359
  return (res);
}
}
#line 362 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static int psiconv_parse_sheet_cell_block___1(psiconv_config const   config , psiconv_buffer const   buf ,
                                              int lev , psiconv_u32 off , int *length ,
                                              psiconv_sheet_cell_block_t *result ) 
{ 
  int len ;
  int leng ;
  int res ;

  {
  {
#line 367
  len = 0;
#line 370
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read a sheet cell block");
#line 371
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the first cell");
#line 372
  res = psiconv_parse_sheet_cell_reference___1(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & leng, & result->first);
  }
#line 372
  if (res) {
#line 374
    goto ERROR;
  }
  {
#line 375
  len += leng;
#line 376
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the last cell");
#line 377
  res = psiconv_parse_sheet_cell_reference___1(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & leng, & result->last);
  }
#line 377
  if (res) {
#line 379
    goto ERROR;
  }
  {
#line 380
  len += leng;
#line 381
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of cell block (total length: %08x)",
                   len);
  }
#line 383
  if (length) {
#line 384
    *length = len;
  }
#line 385
  return (0);
  ERROR: 
#line 387
  if (length) {
#line 388
    *length = 0;
  }
#line 389
  return (res);
}
}
#line 392 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static int psiconv_parse_formula_element_list___1(psiconv_config const   config ,
                                                  psiconv_buffer const   buf , int lev ,
                                                  psiconv_u32 off , int *length ,
                                                  psiconv_formula *result , psiconv_u32 maxlen ) 
{ 
  int res ;
  int len ;
  int leng ;
  int eof ;
  psiconv_u8 marker ;
  psiconv_u8 submarker ;
  psiconv_u8 submarker2 ;
  psiconv_formula_list formula_stack ;
  psiconv_formula formula ;
  psiconv_formula subformula ;
  psiconv_formula subformula1 ;
  psiconv_formula subformula2 ;
  psiconv_formula subformula3 ;
  psiconv_formula subformula4 ;
  psiconv_u16 temp ;
  psiconv_u16 nr_of_subs ;
  psiconv_formula tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  psiconv_formula_list tmp___6 ;
  psiconv_formula_list tmp___7 ;
  psiconv_formula_type_t tmp___8 ;
  psiconv_formula_type_t tmp___9 ;
  psiconv_formula_type_t tmp___10 ;
  psiconv_formula_type_t tmp___11 ;
  psiconv_u32 tmp___12 ;
  psiconv_u32 tmp___13 ;

  {
  {
#line 398
  res = 0;
#line 399
  len = 0;
#line 401
  eof = 0;
#line 408
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a formula element list");
#line 409
  tmp___0 = malloc(sizeof(*(*result)));
#line 409
  tmp = (psiconv_formula )tmp___0;
#line 409
  *result = tmp;
  }
#line 409
  if (! tmp) {
#line 410
    goto ERROR1;
  }
  {
#line 411
  formula_stack = psiconv_list_new(sizeof(struct psiconv_formula_s ));
  }
#line 411
  if (! formula_stack) {
#line 412
    goto ERROR2;
  }
  {
#line 413
  tmp___1 = malloc(sizeof(*formula));
#line 413
  formula = (psiconv_formula )tmp___1;
  }
#line 413
  if (! formula) {
#line 414
    goto ERROR3;
  }
  {
#line 416
  formula->type = (psiconv_formula_type_t )0;
#line 417
  tmp___2 = malloc(sizeof(*subformula1));
#line 417
  subformula1 = (psiconv_formula )tmp___2;
  }
#line 417
  if (! subformula1) {
#line 418
    goto ERROR4;
  }
  {
#line 419
  subformula1->type = (psiconv_formula_type_t )0;
#line 420
  tmp___3 = malloc(sizeof(*subformula2));
#line 420
  subformula2 = (psiconv_formula )tmp___3;
  }
#line 420
  if (! subformula2) {
#line 421
    goto ERROR5;
  }
  {
#line 422
  subformula2->type = (psiconv_formula_type_t )0;
#line 423
  tmp___4 = malloc(sizeof(*subformula3));
#line 423
  subformula3 = (psiconv_formula )tmp___4;
  }
#line 423
  if (! subformula3) {
#line 424
    goto ERROR6;
  }
  {
#line 425
  subformula3->type = (psiconv_formula_type_t )0;
#line 426
  tmp___5 = malloc(sizeof(*subformula4));
#line 426
  subformula4 = (psiconv_formula )tmp___5;
  }
#line 426
  if (! subformula4) {
#line 427
    goto ERROR7;
  }
#line 428
  subformula4->type = (psiconv_formula_type_t )0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! eof) {
#line 430
      if (! ((psiconv_u32 )len + off < maxlen)) {
#line 430
        goto while_break;
      }
    } else {
#line 430
      goto while_break;
    }
    {
#line 431
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read a formula item marker");
#line 432
    marker = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
    }
#line 433
    if (res) {
#line 434
      goto ERROR8;
    }
    {
#line 435
    psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Marker: %02x (%s)",
                  (int )marker, formula_elements___1[marker].name);
#line 437
    len ++;
    }
#line 439
    if ((unsigned int )formula_elements___1[marker].formula_type == 0U) {
      {
#line 440
      psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Unknown formula marker found!");
      }
#line 441
      goto ERROR8;
    } else
#line 442
    if ((unsigned int )formula_elements___1[marker].formula_type == 19U) {
      {
#line 448
      len --;
#line 449
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "End of this formula list");
#line 450
      eof = 1;
      }
    } else
#line 442
    if ((unsigned int )formula_elements___1[marker].formula_type == 28U) {
      {
#line 448
      len --;
#line 449
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "End of this formula list");
#line 450
      eof = 1;
      }
    } else
#line 442
    if ((unsigned int )formula_elements___1[marker].formula_type == 27U) {
      {
#line 448
      len --;
#line 449
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "End of this formula list");
#line 450
      eof = 1;
      }
    } else
#line 451
    if ((unsigned int )formula_elements___1[marker].formula_type == 21U) {
      {
#line 453
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: an integer");
#line 454
      formula->data.dat_int = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & res);
      }
#line 455
      if (res) {
#line 456
        goto ERROR8;
      }
      {
#line 457
      formula->type = formula_elements___1[marker].formula_type;
#line 458
      psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Value: %08x",
                    formula->data.dat_int);
#line 459
      len += 4;
#line 460
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 460
      if (res) {
#line 461
        goto ERROR8;
      }
#line 462
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 463
    if ((unsigned int )formula_elements___1[marker].formula_type == 20U) {
      {
#line 465
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a float");
#line 466
      formula->data.dat_float = psiconv_read_float(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                   & leng, & res);
      }
#line 468
      if (res) {
#line 469
        goto ERROR8;
      }
      {
#line 470
      formula->type = formula_elements___1[marker].formula_type;
#line 471
      psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Value: %f",
                    formula->data.dat_float);
#line 472
      len += leng;
#line 473
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 473
      if (res) {
#line 474
        goto ERROR8;
      }
#line 475
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 476
    if ((unsigned int )formula_elements___1[marker].formula_type == 24U) {
      {
#line 478
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a cell reference");
#line 479
      res = psiconv_parse_sheet_cell_reference___1(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                   & leng, & formula->data.dat_cellref);
      }
#line 479
      if (res) {
#line 481
        goto ERROR8;
      }
      {
#line 482
      formula->type = formula_elements___1[marker].formula_type;
#line 483
      len += leng;
#line 484
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 484
      if (res) {
#line 485
        goto ERROR8;
      }
#line 486
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 487
    if ((unsigned int )formula_elements___1[marker].formula_type == 25U) {
#line 487
      goto _L;
    } else
#line 487
    if ((unsigned int )formula_elements___1[marker].formula_type == 26U) {
      _L: /* CIL Label */ 
      {
#line 491
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a cell block");
#line 492
      res = psiconv_parse_sheet_cell_block___1(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & leng, & formula->data.dat_cellblock);
      }
#line 492
      if (res) {
#line 494
        goto ERROR8;
      }
      {
#line 495
      formula->type = formula_elements___1[marker].formula_type;
#line 496
      len += leng;
#line 497
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 497
      if (res) {
#line 498
        goto ERROR8;
      }
#line 499
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 500
    if ((unsigned int )formula_elements___1[marker].formula_type == 23U) {
      {
#line 502
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a string");
#line 503
      formula->data.dat_string = psiconv_read_short_string(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                           & leng, & res);
      }
#line 505
      if (res) {
#line 506
        goto ERROR8;
      }
      {
#line 507
      formula->type = formula_elements___1[marker].formula_type;
#line 508
      len += leng;
#line 509
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 509
      if (res) {
#line 510
        goto ERROR8;
      }
#line 511
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 512
    if ((unsigned int )formula_elements___1[marker].formula_type == 22U) {
      {
#line 514
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a variable reference");
#line 515
      formula->data.dat_variable = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                    & res);
      }
#line 516
      if (res) {
#line 517
        goto ERROR8;
      }
      {
#line 518
      formula->type = formula_elements___1[marker].formula_type;
#line 519
      len += 4;
#line 520
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 520
      if (res) {
#line 521
        goto ERROR8;
      }
#line 522
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 523
    if (formula_elements___1[marker].number_of_args == -1) {
      {
#line 524
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Going to parse a vararg function");
#line 525
      tmp___6 = psiconv_list_new(sizeof(*formula));
#line 525
      formula->data.fun_operands = tmp___6;
      }
#line 525
      if (! tmp___6) {
#line 527
        goto ERROR8;
      }
#line 528
      formula->type = formula_elements___1[marker].formula_type;
#line 529
      nr_of_subs = (psiconv_u16 )0;
      {
#line 530
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 531
        nr_of_subs = (psiconv_u16 )((int )nr_of_subs + 1);
#line 532
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read vararg argument %d", (int )nr_of_subs);
#line 534
        res = psiconv_parse_formula_element_list___1(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                     & leng, & subformula, maxlen);
        }
#line 534
        if (res) {
#line 536
          goto ERROR8;
        }
        {
#line 537
        len += leng;
#line 538
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula);
        }
#line 538
        if (res) {
          {
#line 539
          psiconv_free_formula(subformula);
          }
#line 540
          goto ERROR8;
        }
        {
#line 542
        free((void *)subformula);
#line 543
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read the next marker");
#line 544
        submarker = psiconv_read_u8(config, buf, lev + 4, off + (psiconv_u32 )len,
                                    & res);
#line 545
        len ++;
        }
#line 546
        if (res) {
#line 547
          goto ERROR8;
        }
        {
#line 548
        submarker2 = psiconv_read_u8(config, buf, lev + 4, off + (psiconv_u32 )len,
                                     & res);
        }
#line 549
        if (res) {
#line 550
          goto ERROR8;
        }
#line 530
        if ((unsigned int )formula_elements___1[submarker].formula_type == 27U) {
#line 530
          if (! ((unsigned int )formula_elements___1[submarker2].formula_type != 28U)) {
#line 530
            goto while_break___0;
          }
        } else {
#line 530
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 555
      if ((unsigned int )formula_elements___1[submarker].formula_type == 27U) {
#line 555
        if ((unsigned int )formula_elements___1[submarker2].formula_type == 28U) {
#line 559
          submarker = submarker2;
#line 560
          len ++;
        }
      }
#line 562
      if ((unsigned int )formula_elements___1[submarker].formula_type != 28U) {
        {
#line 564
        psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Formula corrupted!");
#line 565
        psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Found unexpected marker %02x",
                      (int )submarker);
        }
#line 566
        goto ERROR8;
      }
      {
#line 568
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Going to read the repeated marker %02x", (int )marker);
#line 570
      submarker = psiconv_read_u8(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
      }
#line 571
      if (res) {
#line 572
        goto ERROR8;
      }
#line 573
      if ((int )submarker != (int )marker) {
        {
#line 574
        psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Formula corrupted!");
#line 575
        psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Expected marker %02x, found %02x",
                      (int )marker, (int )submarker);
        }
#line 577
        goto ERROR8;
      }
      {
#line 579
      len ++;
#line 580
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Going to read the number of arguments (%d expected)", (int )nr_of_subs);
#line 583
      temp = psiconv_read_u16(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
      }
#line 584
      if (res) {
#line 585
        goto ERROR8;
      }
#line 586
      if ((int )temp != (int )nr_of_subs) {
        {
#line 587
        psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Formula corrupted!");
#line 588
        psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Read %d arguments, but formula says there are %d",
                      (int )nr_of_subs, (int )temp);
        }
#line 591
        goto ERROR8;
      }
      {
#line 593
      len += 2;
#line 594
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 594
      if (res) {
#line 595
        goto ERROR8;
      }
#line 596
      formula->type = (psiconv_formula_type_t )0;
    } else {
#line 598
      if (formula_elements___1[marker].number_of_args > 0) {
        {
#line 599
        res = psiconv_list_pop(formula_stack, (void *)subformula1);
        }
#line 599
        if (res) {
#line 600
          goto ERROR8;
        }
      }
#line 601
      if (formula_elements___1[marker].number_of_args > 1) {
        {
#line 602
        res = psiconv_list_pop(formula_stack, (void *)subformula2);
        }
#line 602
        if (res) {
#line 603
          goto ERROR8;
        }
      }
#line 604
      if (formula_elements___1[marker].number_of_args > 2) {
        {
#line 605
        res = psiconv_list_pop(formula_stack, (void *)subformula3);
        }
#line 605
        if (res) {
#line 606
          goto ERROR8;
        }
      }
#line 607
      if (formula_elements___1[marker].number_of_args > 3) {
        {
#line 608
        res = psiconv_list_pop(formula_stack, (void *)subformula4);
        }
#line 608
        if (res) {
#line 609
          goto ERROR8;
        }
      }
      {
#line 610
      tmp___7 = psiconv_list_new(sizeof(*formula));
#line 610
      formula->data.fun_operands = tmp___7;
      }
#line 610
      if (! tmp___7) {
#line 612
        goto ERROR8;
      }
#line 613
      formula->type = formula_elements___1[marker].formula_type;
#line 614
      if (formula_elements___1[marker].number_of_args > 3) {
        {
#line 615
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula4);
        }
#line 615
        if (res) {
#line 616
          goto ERROR8;
        }
      }
#line 617
      if (formula_elements___1[marker].number_of_args > 2) {
        {
#line 618
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula3);
        }
#line 618
        if (res) {
#line 619
          goto ERROR8;
        }
      }
#line 620
      if (formula_elements___1[marker].number_of_args > 1) {
        {
#line 621
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula2);
        }
#line 621
        if (res) {
#line 622
          goto ERROR8;
        }
      }
#line 623
      if (formula_elements___1[marker].number_of_args > 0) {
        {
#line 624
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula1);
        }
#line 624
        if (res) {
#line 625
          goto ERROR8;
        }
      }
      {
#line 626
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 626
      if (res) {
#line 627
        goto ERROR8;
      }
#line 628
      tmp___11 = (psiconv_formula_type_t )0;
#line 628
      formula->type = tmp___11;
#line 628
      tmp___10 = tmp___11;
#line 628
      subformula1->type = tmp___10;
#line 628
      tmp___9 = tmp___10;
#line 628
      subformula2->type = tmp___9;
#line 628
      tmp___8 = tmp___9;
#line 628
      subformula3->type = tmp___8;
#line 628
      subformula4->type = tmp___8;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  if ((psiconv_u32 )len + off > maxlen) {
    {
#line 633
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Formula corrupted!");
#line 634
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Expected end: %04x, found end: %04x",
                  maxlen, (psiconv_u32 )len + off);
    }
#line 636
    goto ERROR8;
  } else
#line 632
  if (! eof) {
    {
#line 633
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Formula corrupted!");
#line 634
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Expected end: %04x, found end: %04x",
                  maxlen, (psiconv_u32 )len + off);
    }
#line 636
    goto ERROR8;
  }
  {
#line 638
  tmp___13 = psiconv_list_length((psiconv_list const   )formula_stack);
  }
#line 638
  if (tmp___13 != 1U) {
    {
#line 639
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Formula corrupted!");
#line 640
    tmp___12 = psiconv_list_length((psiconv_list const   )formula_stack);
#line 640
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "More than one item left on the stack (%d)",
                  tmp___12);
    }
#line 642
    goto ERROR8;
  }
  {
#line 644
  res = psiconv_list_pop(formula_stack, (void *)*result);
  }
#line 644
  if (res) {
#line 645
    goto ERROR8;
  }
  {
#line 646
  psiconv_list_free(formula_stack);
#line 647
  free((void *)formula);
  }
#line 649
  if (length) {
#line 650
    *length = len;
  }
  {
#line 652
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of formula element list (total length: %08x)",
                   len);
  }
#line 654
  return (0);
  ERROR8: 
  {
#line 657
  psiconv_free_formula(subformula4);
  }
  ERROR7: 
  {
#line 659
  psiconv_free_formula(subformula3);
  }
  ERROR6: 
  {
#line 661
  psiconv_free_formula(subformula2);
  }
  ERROR5: 
  {
#line 663
  psiconv_free_formula(subformula1);
  }
  ERROR4: 
  {
#line 665
  psiconv_free_formula(formula);
  }
  ERROR3: 
  {
#line 667
  psiconv_free_formula_list(formula_stack);
  }
  ERROR2: 
  {
#line 669
  free((void *)*result);
  }
  ERROR1: 
  {
#line 671
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of formula element list failed");
  }
#line 672
  if (length) {
#line 673
    *length = 0;
  }
#line 674
  if (! res) {
#line 675
    return (-2);
  } else {
#line 677
    return (res);
  }
}
}
#line 34 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_simple.c"
static int psiconv_write_string_aux___1(psiconv_config const   config , psiconv_buffer buf ,
                                        int lev , psiconv_string_t const   value ,
                                        int kind ) ;
#line 222 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_simple.c"
static int psiconv_write_string_aux___1(psiconv_config const   config , psiconv_buffer buf ,
                                        int lev , psiconv_string_t const   value ,
                                        int kind ) 
{ 
  int res ;
  int i ;
  int len ;
  char *printable ;

  {
  {
#line 228
  len = psiconv_unicode_strlen((psiconv_ucs2 const   *)value);
  }
#line 229
  if (! value) {
    {
#line 230
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "NULL string");
    }
#line 231
    return (-4);
  }
  {
#line 234
  printable = psiconv_make_printable(config, value);
  }
#line 234
  if (! printable) {
    {
#line 235
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Out of memory error");
    }
#line 236
    return (-2);
  }
  {
#line 238
  psiconv_debug((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Value: %s", printable);
#line 239
  free((void *)printable);
  }
#line 241
  if (kind == -1) {
    {
#line 242
    res = psiconv_write_S(config, buf, lev + 2, (psiconv_u32 const   )len);
    }
  } else
#line 243
  if (kind == -2) {
    {
#line 244
    res = psiconv_write_u8(config, buf, lev + 2, (psiconv_u8 const   )len);
    }
  } else {
#line 246
    res = 0;
  }
#line 247
  if (res) {
#line 248
    return (res);
  }
#line 250
  i = 0;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (i < len)) {
#line 250
      goto while_break;
    }
    {
#line 251
    res = psiconv_unicode_write_char(config, buf, lev + 2, *(value + i));
    }
#line 251
    if (res) {
#line 252
      return (res);
    }
#line 250
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  return (0);
}
}
#line 28 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/checkuid.c"
static psiconv_u32 uid1___2[32]  = 
#line 28 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/checkuid.c"
  {      (psiconv_u32 )17824,      (psiconv_u32 )35648,      (psiconv_u32 )1697,      (psiconv_u32 )3394, 
        (psiconv_u32 )6788,      (psiconv_u32 )13576,      (psiconv_u32 )27152,      (psiconv_u32 )54304, 
        (psiconv_u32 )1168113664,      2336227328U,      (psiconv_u32 )111214592,      (psiconv_u32 )222429184, 
        (psiconv_u32 )444858368,      (psiconv_u32 )889716736,      (psiconv_u32 )1779433472,      3558866944U, 
        (psiconv_u32 )43601,      (psiconv_u32 )17539,      (psiconv_u32 )35078,      (psiconv_u32 )557, 
        (psiconv_u32 )1114,      (psiconv_u32 )2228,      (psiconv_u32 )4456,      (psiconv_u32 )8912, 
        2857435136U,      (psiconv_u32 )1149435904,      2298871808U,      (psiconv_u32 )36503552, 
        (psiconv_u32 )73007104,      (psiconv_u32 )146014208,      (psiconv_u32 )292028416,      (psiconv_u32 )584056832};
#line 62 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/checkuid.c"
static psiconv_u32 uid2___2[32]  = 
#line 62
  {      (psiconv_u32 )30388,      (psiconv_u32 )60776,      (psiconv_u32 )51953,      (psiconv_u32 )34243, 
        (psiconv_u32 )7079,      (psiconv_u32 )14158,      (psiconv_u32 )28316,      (psiconv_u32 )56632, 
        (psiconv_u32 )1991507968,      3983015936U,      3404791808U,      2244149248U, 
        (psiconv_u32 )463929344,      (psiconv_u32 )927858688,      (psiconv_u32 )1855717376,      3711434752U, 
        (psiconv_u32 )14128,      (psiconv_u32 )28256,      (psiconv_u32 )56512,      (psiconv_u32 )43425, 
        (psiconv_u32 )17251,      (psiconv_u32 )34502,      (psiconv_u32 )7597,      (psiconv_u32 )15194, 
        (psiconv_u32 )925892608,      (psiconv_u32 )1851785216,      3703570432U,      2845900800U, 
        (psiconv_u32 )1130561536,      2261123072U,      (psiconv_u32 )497876992,      (psiconv_u32 )995753984};
#line 96 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/checkuid.c"
static psiconv_u32 uid3___2[32]  = 
#line 96
  {      (psiconv_u32 )13105,      (psiconv_u32 )26210,      (psiconv_u32 )52420,      (psiconv_u32 )35241, 
        (psiconv_u32 )883,      (psiconv_u32 )1766,      (psiconv_u32 )3532,      (psiconv_u32 )7064, 
        (psiconv_u32 )858849280,      (psiconv_u32 )1717698560,      3435397120U,      2309554176U, 
        (psiconv_u32 )57868288,      (psiconv_u32 )115736576,      (psiconv_u32 )231473152,      (psiconv_u32 )462946304, 
        (psiconv_u32 )4129,      (psiconv_u32 )8258,      (psiconv_u32 )16516,      (psiconv_u32 )33032, 
        (psiconv_u32 )4657,      (psiconv_u32 )9314,      (psiconv_u32 )18628,      (psiconv_u32 )37256, 
        (psiconv_u32 )270598144,      (psiconv_u32 )541196288,      (psiconv_u32 )1082392576,      2164785152U, 
        (psiconv_u32 )305201152,      (psiconv_u32 )610402304,      (psiconv_u32 )1220804608,      2441609216U};
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/error.c"
static void psiconv_default_error_handler___1(int kind , psiconv_u32 off , char const   *message ) 
{ 


  {
  {
#line 36
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          message);
  }
#line 37
  return;
}
}
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
static psiconv_sheet_cell_layout psiconv_basic_cell_layout___1(void) 
{ 
  psiconv_sheet_cell_layout result ;
  void *tmp ;
  psiconv_character_layout tmp___0 ;
  psiconv_paragraph_layout tmp___1 ;
  psiconv_sheet_numberformat tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 35
  tmp = malloc(sizeof(*result));
#line 35
  result = (psiconv_sheet_cell_layout )tmp;
  }
#line 35
  if (! result) {
#line 36
    goto ERROR1;
  }
  {
#line 37
  tmp___0 = psiconv_basic_character_layout();
#line 37
  result->character = tmp___0;
  }
#line 37
  if (! tmp___0) {
#line 38
    goto ERROR2;
  }
  {
#line 39
  tmp___1 = psiconv_basic_paragraph_layout();
#line 39
  result->paragraph = tmp___1;
  }
#line 39
  if (! tmp___1) {
#line 40
    goto ERROR3;
  }
  {
#line 41
  tmp___3 = malloc(sizeof(*(result->numberformat)));
#line 41
  tmp___2 = (psiconv_sheet_numberformat )tmp___3;
#line 41
  result->numberformat = tmp___2;
  }
#line 41
  if (! tmp___2) {
#line 42
    goto ERROR4;
  }
#line 43
  (result->numberformat)->code = (psiconv_sheet_numberformat_code_t )0;
#line 44
  (result->numberformat)->decimal = (psiconv_u8 )2;
#line 45
  return (result);
  ERROR4: 
  {
#line 47
  psiconv_free_paragraph_layout(result->paragraph);
  }
  ERROR3: 
  {
#line 49
  psiconv_free_character_layout(result->character);
  }
  ERROR2: 
  {
#line 51
  free((void *)result);
  }
  ERROR1: 
#line 53
  return ((psiconv_sheet_cell_layout )((void *)0));
}
}
#line 56 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
static psiconv_sheet_cell_layout psiconv_clone_cell_layout___1(psiconv_sheet_cell_layout original ) 
{ 
  psiconv_sheet_cell_layout result ;
  void *tmp ;
  psiconv_character_layout tmp___0 ;
  psiconv_paragraph_layout tmp___1 ;
  psiconv_sheet_numberformat tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 60
  tmp = malloc(sizeof(*result));
#line 60
  result = (psiconv_sheet_cell_layout )tmp;
  }
#line 60
  if (! result) {
#line 61
    goto ERROR1;
  }
  {
#line 62
  tmp___0 = psiconv_clone_character_layout(original->character);
#line 62
  result->character = tmp___0;
  }
#line 62
  if (! tmp___0) {
#line 64
    goto ERROR2;
  }
  {
#line 65
  tmp___1 = psiconv_clone_paragraph_layout(original->paragraph);
#line 65
  result->paragraph = tmp___1;
  }
#line 65
  if (! tmp___1) {
#line 67
    goto ERROR3;
  }
  {
#line 68
  tmp___3 = malloc(sizeof(*(result->numberformat)));
#line 68
  tmp___2 = (psiconv_sheet_numberformat )tmp___3;
#line 68
  result->numberformat = tmp___2;
  }
#line 68
  if (! tmp___2) {
#line 69
    goto ERROR4;
  }
#line 70
  (result->numberformat)->code = (original->numberformat)->code;
#line 71
  (result->numberformat)->decimal = (original->numberformat)->decimal;
#line 72
  return (result);
  ERROR4: 
  {
#line 74
  psiconv_free_paragraph_layout(result->paragraph);
  }
  ERROR3: 
  {
#line 76
  psiconv_free_character_layout(result->character);
  }
  ERROR2: 
  {
#line 78
  free((void *)result);
  }
  ERROR1: 
#line 80
  return ((psiconv_sheet_cell_layout )((void *)0));
}
}
#line 83 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
static psiconv_sheet_cell_reference_t psiconv_read_var_cellref___1(psiconv_config const   config ,
                                                                   psiconv_buffer const   buf ,
                                                                   int lev , psiconv_u32 off ,
                                                                   int *length , int *status ) 
{ 
  int len ;
  int res ;
  psiconv_sheet_cell_reference_t result ;
  psiconv_u32 temp ;
  psiconv_u8 tmp ;

  {
  {
#line 89
  len = 0;
#line 94
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read a sheet cell reference");
#line 95
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the initial byte (%02x expected)",
                   0);
#line 97
  tmp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 97
  temp = (psiconv_u32 )tmp;
  }
#line 98
  if (res) {
#line 99
    goto ERROR1;
  }
#line 100
  if (temp != 0U) {
    {
#line 101
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet cell reference initial byte unknown value (ignored)");
#line 103
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Initial byte: %02x",
                  temp);
    }
  }
  {
#line 105
  len ++;
#line 107
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 108
  if (res) {
#line 109
    goto ERROR1;
  }
#line 110
  if (temp & 4294901760U) {
    {
#line 111
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet cell row reference to unknown row (reset)");
    }
  }
  {
#line 114
  result.row.offset = (psiconv_s16 )temp;
#line 115
  result.row.absolute = (psiconv_bool_t )1;
#line 116
  len += 4;
#line 118
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 119
  if (res) {
#line 120
    goto ERROR1;
  }
#line 121
  if (temp & 4294901760U) {
    {
#line 122
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet cell column reference to unknown row (reset)");
    }
  }
#line 125
  result.column.offset = (psiconv_s16 )temp;
#line 126
  result.column.absolute = (psiconv_bool_t )1;
#line 127
  len += 4;
#line 129
  if (length) {
#line 130
    *length = len;
  }
  {
#line 132
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet column reference (total length: %08x)",
                   len);
  }
#line 134
  return (result);
  ERROR1: 
  {
#line 136
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Column Reference failed");
  }
#line 137
  if (length) {
#line 138
    *length = 0;
  }
#line 139
  if (status) {
#line 140
    if (res) {
#line 140
      *status = res;
    } else {
#line 140
      *status = -2;
    }
  }
#line 141
  return (result);
}
}
#line 144 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
static psiconv_sheet_cell_block_t psiconv_read_var_cellblock___1(psiconv_config const   config ,
                                                                 psiconv_buffer const   buf ,
                                                                 int lev , psiconv_u32 off ,
                                                                 int *length , int *status ) 
{ 
  int len ;
  int res ;
  psiconv_sheet_cell_block_t result ;
  psiconv_u32 temp ;
  psiconv_u8 tmp ;

  {
  {
#line 150
  len = 0;
#line 155
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read a sheet cell block reference");
#line 156
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the initial byte (%02x expected)",
                   0);
#line 158
  tmp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 158
  temp = (psiconv_u32 )tmp;
  }
#line 159
  if (res) {
#line 160
    goto ERROR1;
  }
#line 161
  if (temp != 0U) {
    {
#line 162
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet cell reference initial byte unknown value (ignored)");
#line 164
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Initial byte: %02x",
                  temp);
    }
  }
  {
#line 166
  len ++;
#line 168
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 169
  if (res) {
#line 170
    goto ERROR1;
  }
#line 171
  if (temp & 4294901760U) {
    {
#line 172
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet block initial row reference to unknown row (reset)");
    }
  }
  {
#line 175
  result.first.row.offset = (psiconv_s16 )temp;
#line 176
  result.first.row.absolute = (psiconv_bool_t )1;
#line 177
  len += 4;
#line 179
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 180
  if (res) {
#line 181
    goto ERROR1;
  }
#line 182
  if (temp & 4294901760U) {
    {
#line 183
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet block initial column reference to unknown row (reset)");
    }
  }
  {
#line 186
  result.first.column.offset = (psiconv_s16 )temp;
#line 187
  result.first.column.absolute = (psiconv_bool_t )1;
#line 188
  len += 4;
#line 190
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 191
  if (res) {
#line 192
    goto ERROR1;
  }
#line 193
  if (temp & 4294901760U) {
    {
#line 194
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet block final row reference to unknown row (reset)");
    }
  }
  {
#line 197
  result.last.row.offset = (psiconv_s16 )temp;
#line 198
  result.last.row.absolute = (psiconv_bool_t )1;
#line 199
  len += 4;
#line 201
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 202
  if (res) {
#line 203
    goto ERROR1;
  }
#line 204
  if (temp & 4294901760U) {
    {
#line 205
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet block final column reference to unknown row (reset)");
    }
  }
#line 208
  result.last.column.offset = (psiconv_s16 )temp;
#line 209
  result.last.column.absolute = (psiconv_bool_t )1;
#line 210
  len += 4;
#line 212
  if (length) {
#line 213
    *length = len;
  }
  {
#line 215
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet cell block reference (total length: %08x)",
                   len);
  }
#line 218
  return (result);
  ERROR1: 
  {
#line 220
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Cell Block Reference failed");
  }
#line 221
  if (length) {
#line 222
    *length = 0;
  }
#line 223
  if (status) {
#line 224
    if (res) {
#line 224
      *status = res;
    } else {
#line 224
      *status = -2;
    }
  }
#line 225
  return (result);
}
}
#line 25 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/extra/empty.c"
void help(void) 
{ 


  {
  {
#line 27
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Syntax: empty TYPE FILENAME\n  TYPE may be Word or TextEd; only the first character is checked\n");
#line 29
  exit(1);
  }
}
}
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
static psiconv_ucs2 unicode_paint___1[10]  = 
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
  {      (psiconv_ucs2 )'P',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'i',      (psiconv_ucs2 )'n', 
        (psiconv_ucs2 )'t',      (psiconv_ucs2 )'.',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'p', 
        (psiconv_ucs2 )'p',      (psiconv_ucs2 )0};
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
static psiconv_ucs2 unicode_texted___1[11]  = 
#line 33
  {      (psiconv_ucs2 )'T',      (psiconv_ucs2 )'e',      (psiconv_ucs2 )'x',      (psiconv_ucs2 )'t', 
        (psiconv_ucs2 )'E',      (psiconv_ucs2 )'d',      (psiconv_ucs2 )'.',      (psiconv_ucs2 )'a', 
        (psiconv_ucs2 )'p',      (psiconv_ucs2 )'p',      (psiconv_ucs2 )0};
#line 34 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
static psiconv_ucs2 unicode_word___1[9]  = 
#line 34
  {      (psiconv_ucs2 )'W',      (psiconv_ucs2 )'o',      (psiconv_ucs2 )'r',      (psiconv_ucs2 )'d', 
        (psiconv_ucs2 )'.',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'p',      (psiconv_ucs2 )'p', 
        (psiconv_ucs2 )0};
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
static int psiconv_parse_layout_section___1(psiconv_config const   config , psiconv_buffer const   buf ,
                                            int lev , psiconv_u32 off , int *length ,
                                            psiconv_text_and_layout result , psiconv_word_styles_section styles___1 ,
                                            int with_styles ) ;
#line 40
static psiconv_file_type_t psiconv_determine_embedded_object_type___1(psiconv_config const   config ,
                                                                      psiconv_buffer const   buf ,
                                                                      int lev , int *status ) ;
#line 391 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
static int psiconv_parse_layout_section___1(psiconv_config const   config , psiconv_buffer const   buf ,
                                            int lev , psiconv_u32 off , int *length ,
                                            psiconv_text_and_layout result , psiconv_word_styles_section styles___1 ,
                                            int with_styles ) 
{ 
  int res ;
  int len ;
  psiconv_u32 temp ;
  int parse_styles ;
  int nr ;
  int i ;
  int j ;
  int total ;
  int leng ;
  int line_length ;
  anon_style_list anon_styles ;
  struct anon_style_s anon ;
  anon_style anon_ptr ;
  psiconv_character_layout temp_char ;
  psiconv_paragraph_layout temp_para ;
  psiconv_word_style temp_style ;
  psiconv_paragraph para ;
  struct psiconv_in_line_layout_s in_line ;
  int *inline_count ;
  psiconv_u16 tmp ;
  psiconv_u8 tmp___0 ;
  psiconv_u32 tmp___1 ;
  psiconv_u8 tmp___2 ;
  psiconv_u32 tmp___3 ;
  psiconv_u32 tmp___4 ;
  psiconv_u32 tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  psiconv_in_line_layouts tmp___8 ;
  psiconv_character_layout tmp___9 ;
  psiconv_paragraph_layout tmp___10 ;
  psiconv_u32 tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  psiconv_u8 tmp___15 ;
  void *tmp___16 ;
  psiconv_u32 tmp___17 ;
  psiconv_u32 tmp___18 ;
  psiconv_u8 tmp___19 ;
  psiconv_u32 tmp___20 ;
  psiconv_u32 tmp___21 ;
  void *tmp___22 ;
  psiconv_u8 tmp___23 ;
  psiconv_u32 tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  psiconv_u32 tmp___27 ;
  void *tmp___28 ;
  psiconv_u32 tmp___29 ;
  void *tmp___30 ;
  psiconv_u32 tmp___31 ;

  {
  {
#line 399
  res = 0;
#line 400
  len = 0;
#line 416
  anon_ptr = (anon_style )((void *)0);
#line 427
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read the layout section");
#line 429
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the section type");
#line 430
  tmp = psiconv_read_u16(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 430
  temp = (psiconv_u32 )tmp;
  }
#line 431
  if (res) {
#line 432
    goto ERROR1;
  }
  {
#line 433
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Type: %02x",
                temp);
#line 434
  parse_styles = with_styles;
  }
#line 435
  if (temp == 1U) {
#line 435
    if (! with_styles) {
      {
#line 436
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Styleless layout section expected, but styled section found!");
#line 438
      parse_styles = 1;
      }
    } else {
#line 435
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 439
  if (temp == 0U) {
#line 439
    if (with_styles) {
      {
#line 440
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Styled layout section expected, but styleless section found!");
#line 442
      parse_styles = 0;
      }
    } else {
#line 439
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 443
  if (temp != 0U) {
#line 443
    if (temp != 1U) {
      {
#line 444
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Layout section type indicator has unknown value!");
      }
    }
  }
  {
#line 447
  len += 2;
#line 449
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read paragraph type list");
#line 450
  anon_styles = psiconv_list_new(sizeof(anon));
  }
#line 450
  if (! anon_styles) {
#line 451
    goto ERROR1;
  }
  {
#line 452
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read paragraph type list length");
#line 453
  tmp___0 = psiconv_read_u8(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
#line 453
  nr = (int )tmp___0;
  }
#line 454
  if (res) {
#line 455
    goto ERROR2;
  }
  {
#line 456
  psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Length: %02x",
                nr);
#line 457
  len ++;
#line 459
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the paragraph type list elements");
#line 461
  i = 0;
  }
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    if (! (i < nr)) {
#line 461
      goto while_break;
    }
    {
#line 462
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Element %d",
                     i);
#line 463
    tmp___1 = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
#line 463
    anon.nr = (int )tmp___1;
    }
#line 464
    if (res) {
#line 465
      goto ERROR3;
    }
    {
#line 466
    psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Number: %08x",
                  anon.nr);
#line 467
    len += 4;
#line 469
    psiconv_progress((psiconv_config )config, lev + 4, off, "Going to determine the base style");
    }
#line 470
    if (parse_styles) {
      {
#line 471
      temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
      }
#line 472
      if (res) {
#line 473
        goto ERROR3;
      }
      {
#line 474
      tmp___2 = psiconv_read_u8(config, buf, lev + 3, ((off + (psiconv_u32 )len) + 4U) + temp,
                                & res);
#line 474
      anon.base_style = (psiconv_s16 )tmp___2;
      }
#line 475
      if (res) {
#line 476
        goto ERROR3;
      }
      {
#line 477
      psiconv_debug((psiconv_config )config, lev + 4, (off + (psiconv_u32 )len) + temp,
                    "Style indicator: %02x", (int )anon.base_style);
      }
    } else {
#line 480
      anon.base_style = (psiconv_s16 )0;
    }
    {
#line 481
    temp_style = psiconv_get_style(styles___1, (int )anon.base_style);
    }
#line 481
    if (! temp_style) {
      {
#line 482
      psiconv_warn((psiconv_config )config, lev + 4, off, "Unknown Style referenced");
#line 483
      temp_style = psiconv_get_style(styles___1, (int )anon.base_style);
      }
#line 483
      if (! temp_style) {
        {
#line 484
        psiconv_warn((psiconv_config )config, lev + 4, off, "Base style unknown");
        }
#line 485
        goto ERROR3;
      }
    }
    {
#line 488
    anon.paragraph = psiconv_clone_paragraph_layout(temp_style->paragraph);
    }
#line 488
    if (! anon.paragraph) {
#line 490
      goto ERROR3;
    }
    {
#line 491
    anon.character = psiconv_clone_character_layout(temp_style->character);
    }
#line 491
    if (! anon.character) {
#line 493
      goto ERROR3_1;
    }
    {
#line 495
    psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to read the paragraph layout");
#line 496
    res = psiconv_parse_paragraph_layout_list(config, buf, lev + 4, off + (psiconv_u32 )len,
                                              & leng, anon.paragraph);
    }
#line 496
    if (res) {
#line 498
      goto ERROR3_2;
    }
#line 499
    len += leng;
#line 500
    if (parse_styles) {
#line 501
      len ++;
    }
    {
#line 503
    psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to read the character layout");
#line 504
    res = psiconv_parse_character_layout_list(config, buf, lev + 4, off + (psiconv_u32 )len,
                                              & leng, anon.character);
    }
#line 504
    if (res) {
#line 506
      goto ERROR3_2;
    }
    {
#line 507
    len += leng;
#line 508
    res = psiconv_list_add(anon_styles, (void const   *)(& anon));
    }
#line 508
    if (res) {
#line 509
      goto ERROR3_2;
    }
#line 461
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 512
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to parse the paragraph element list");
#line 513
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the number of paragraphs");
#line 514
  tmp___3 = psiconv_read_u32(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
#line 514
  nr = (int )tmp___3;
  }
#line 515
  if (res) {
#line 516
    goto ERROR3;
  }
  {
#line 517
  tmp___5 = psiconv_list_length((psiconv_list const   )result);
  }
#line 517
  if ((psiconv_u32 )nr != tmp___5) {
    {
#line 518
    psiconv_warn((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Number of text paragraphs and paragraph elements does not match");
#line 520
    tmp___4 = psiconv_list_length((psiconv_list const   )result);
#line 520
    psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "%d text paragraphs, %d paragraph elements",
                  tmp___4, nr);
    }
  }
  {
#line 524
  psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Number of paragraphs: %d",
                nr);
#line 525
  len += 4;
#line 526
  tmp___6 = malloc((unsigned long )nr * sizeof(*inline_count));
#line 526
  inline_count = (int *)tmp___6;
  }
#line 526
  if (! inline_count) {
#line 527
    goto ERROR3;
  }
  {
#line 529
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the paragraph elements");
#line 530
  i = 0;
  }
  {
#line 530
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 530
    if (! (i < nr)) {
#line 530
      goto while_break___0;
    }
    {
#line 531
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Element %d",
                     i);
#line 532
    tmp___11 = psiconv_list_length((psiconv_list const   )result);
    }
#line 532
    if ((psiconv_u32 )i >= tmp___11) {
      {
#line 533
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to allocate a new element");
#line 534
      tmp___7 = malloc(sizeof(*para));
#line 534
      para = (psiconv_paragraph )tmp___7;
      }
#line 534
      if (! para) {
#line 535
        goto ERROR4;
      }
      {
#line 536
      tmp___8 = psiconv_list_new(sizeof(struct psiconv_in_line_layout_s ));
#line 536
      para->in_lines = tmp___8;
      }
#line 536
      if (! tmp___8) {
#line 538
        goto ERROR4_1;
      }
      {
#line 539
      para->base_style = (psiconv_s16 )0;
#line 540
      tmp___9 = psiconv_basic_character_layout();
#line 540
      para->base_character = tmp___9;
      }
#line 540
      if (! tmp___9) {
#line 541
        goto ERROR4_2;
      }
      {
#line 542
      tmp___10 = psiconv_basic_paragraph_layout();
#line 542
      para->base_paragraph = tmp___10;
      }
#line 542
      if (! tmp___10) {
#line 543
        goto ERROR4_3;
      }
      {
#line 544
      res = psiconv_list_add(result, (void const   *)para);
      }
#line 544
      if (res) {
#line 545
        goto ERROR4_4;
      }
      {
#line 546
      free((void *)para);
      }
    }
    {
#line 548
    tmp___12 = psiconv_list_get((psiconv_list const   )result, (psiconv_u32 )i);
#line 548
    para = (psiconv_paragraph )tmp___12;
    }
#line 548
    if (! para) {
#line 549
      goto ERROR4;
    }
    {
#line 551
    psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to read the paragraph length");
#line 552
    temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
    }
#line 553
    if (res) {
#line 554
      goto ERROR4;
    }
    {
#line 555
    tmp___14 = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
    }
#line 555
    if (temp != (psiconv_u32 )(tmp___14 + 1)) {
      {
#line 556
      psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Disagreement of the length of paragraph in layout section");
#line 558
      tmp___13 = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
#line 558
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Paragraph length: layout section says %d, counted %d",
                    temp, tmp___13 + 1);
      }
    } else {
      {
#line 562
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Paragraph length: %d",
                    temp);
      }
    }
    {
#line 563
    len += 4;
#line 565
    psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to read the paragraph type");
#line 566
    tmp___15 = psiconv_read_u8(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
#line 566
    temp = (psiconv_u32 )tmp___15;
    }
#line 567
    if (res) {
#line 568
      goto ERROR4;
    }
#line 569
    if (temp != 0U) {
      {
#line 570
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Type: %02x",
                    temp);
#line 571
      j = 0;
      }
      {
#line 571
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 571
        tmp___17 = psiconv_list_length((psiconv_list const   )anon_styles);
        }
#line 571
        if (! ((psiconv_u32 )j < tmp___17)) {
#line 571
          goto while_break___1;
        }
        {
#line 572
        tmp___16 = psiconv_list_get((psiconv_list const   )anon_styles, (psiconv_u32 )j);
#line 572
        anon_ptr = (anon_style )tmp___16;
        }
#line 572
        if (! anon_ptr) {
          {
#line 573
          psiconv_error((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Data structure corruption");
          }
#line 574
          goto ERROR4;
        }
#line 576
        if (temp == (psiconv_u32 )anon_ptr->nr) {
#line 577
          goto while_break___1;
        }
#line 571
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 579
      tmp___18 = psiconv_list_length((psiconv_list const   )anon_styles);
      }
#line 579
      if ((psiconv_u32 )j == tmp___18) {
        {
#line 580
        psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Layout section paragraph type unknown");
#line 581
        psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Unknown type - using base styles instead");
#line 582
        para->base_style = (psiconv_s16 )0;
#line 583
        temp_style = psiconv_get_style(styles___1, 0);
        }
#line 583
        if (! temp_style) {
          {
#line 584
          psiconv_error((psiconv_config )config, lev + 4, off, "Base style unknown");
          }
#line 585
          goto ERROR4;
        }
        {
#line 587
        temp_para = psiconv_clone_paragraph_layout(temp_style->paragraph);
        }
#line 587
        if (! temp_para) {
#line 589
          goto ERROR4;
        }
        {
#line 590
        psiconv_free_paragraph_layout(para->base_paragraph);
#line 591
        para->base_paragraph = temp_para;
#line 593
        temp_char = psiconv_clone_character_layout(temp_style->character);
        }
#line 593
        if (! temp_char) {
#line 595
          goto ERROR4;
        }
        {
#line 596
        psiconv_free_character_layout(para->base_character);
#line 597
        para->base_character = temp_char;
        }
      } else {
        {
#line 599
        para->base_style = anon_ptr->base_style;
#line 600
        temp_para = psiconv_clone_paragraph_layout(anon_ptr->paragraph);
        }
#line 600
        if (! temp_para) {
#line 601
          goto ERROR4;
        }
        {
#line 602
        psiconv_free_paragraph_layout(para->base_paragraph);
#line 603
        para->base_paragraph = temp_para;
#line 605
        temp_char = psiconv_clone_character_layout(anon_ptr->character);
        }
#line 605
        if (! temp_char) {
#line 606
          goto ERROR4;
        }
        {
#line 607
        psiconv_free_character_layout(para->base_character);
#line 608
        para->base_character = temp_char;
        }
      }
#line 610
      *(inline_count + i) = 0;
#line 611
      len ++;
    } else {
      {
#line 613
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Type: %02x (not based on a paragraph type)",
                    temp);
#line 615
      len ++;
      }
#line 616
      if (parse_styles) {
        {
#line 617
        temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
        }
#line 618
        if (res) {
#line 619
          goto ERROR4;
        }
        {
#line 620
        psiconv_progress((psiconv_config )config, lev + 4, ((off + (psiconv_u32 )len) + temp) + 4U,
                         "Going to read the paragraph element base style");
#line 622
        tmp___19 = psiconv_read_u8(config, buf, lev + 4, ((off + (psiconv_u32 )len) + temp) + 4U,
                                   & res);
#line 622
        temp = (psiconv_u32 )tmp___19;
        }
#line 623
        if (res) {
#line 624
          goto ERROR4;
        }
        {
#line 625
        psiconv_debug((psiconv_config )config, lev + 4, ((off + (psiconv_u32 )len) + temp) + 4U,
                      "Style: %02x", temp);
        }
      } else {
#line 627
        temp = (psiconv_u32 )0;
      }
      {
#line 629
      temp_style = psiconv_get_style(styles___1, (int )temp);
      }
#line 629
      if (! temp_style) {
        {
#line 630
        psiconv_warn((psiconv_config )config, lev + 4, off, "Unknown Style referenced");
#line 631
        temp_style = psiconv_get_style(styles___1, 0);
        }
#line 631
        if (! temp_style) {
          {
#line 632
          psiconv_error((psiconv_config )config, lev + 4, off, "Base style unknown");
          }
#line 633
          goto ERROR4;
        }
      }
      {
#line 637
      temp_para = psiconv_clone_paragraph_layout(temp_style->paragraph);
      }
#line 637
      if (! temp_para) {
#line 638
        goto ERROR4;
      }
      {
#line 639
      psiconv_free_paragraph_layout(para->base_paragraph);
#line 640
      para->base_paragraph = temp_para;
#line 642
      temp_char = psiconv_clone_character_layout(temp_style->character);
      }
#line 642
      if (! temp_char) {
#line 643
        goto ERROR4;
      }
      {
#line 644
      psiconv_free_character_layout(para->base_character);
#line 645
      para->base_character = temp_char;
#line 647
      para->base_style = (psiconv_s16 )temp;
#line 648
      psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                       "Going to read paragraph layout");
#line 649
      res = psiconv_parse_paragraph_layout_list(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                & leng, para->base_paragraph);
      }
#line 649
      if (res) {
#line 651
        goto ERROR4;
      }
#line 652
      len += leng;
#line 653
      if (parse_styles) {
#line 654
        len ++;
      }
      {
#line 655
      psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                       "Going to read number of in-line layout elements");
#line 657
      tmp___20 = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
#line 657
      *(inline_count + i) = (int )tmp___20;
      }
#line 658
      if (res) {
#line 659
        goto ERROR4;
      }
      {
#line 660
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Nr: %08x",
                    *(inline_count + i));
#line 661
      len += 4;
      }
    }
#line 530
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 665
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the text layout inline list");
#line 667
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the number of elements");
#line 668
  tmp___21 = psiconv_read_u32(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
#line 668
  nr = (int )tmp___21;
  }
#line 669
  if (res) {
#line 670
    goto ERROR4;
  }
  {
#line 671
  psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Elements: %08x",
                nr);
#line 672
  len += 4;
#line 674
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the text layout inline elements");
#line 676
  total = 0;
#line 677
  i = 0;
  }
  {
#line 677
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 677
    tmp___27 = psiconv_list_length((psiconv_list const   )result);
    }
#line 677
    if (! ((psiconv_u32 )i < tmp___27)) {
#line 677
      goto while_break___2;
    }
    {
#line 678
    tmp___22 = psiconv_list_get((psiconv_list const   )result, (psiconv_u32 )i);
#line 678
    para = (psiconv_paragraph )tmp___22;
    }
#line 678
    if (! para) {
      {
#line 679
      psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Data structure corruption");
      }
#line 680
      goto ERROR4;
    }
#line 682
    line_length = -1;
#line 683
    j = 0;
    {
#line 683
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 683
      if (! (j < *(inline_count + i))) {
#line 683
        goto while_break___3;
      }
      {
#line 684
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Element %d: Paragraph %d, element %d", total, i, j);
      }
#line 686
      if (total >= nr) {
        {
#line 687
        psiconv_warn((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Layout section inlines: not enough element");
#line 689
        psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Can\'t read element!");
        }
      } else {
        {
#line 691
        total ++;
#line 692
        in_line.object = (psiconv_embedded_object_section )((void *)0);
#line 693
        in_line.layout = (psiconv_character_layout )((void *)0);
#line 694
        in_line.layout = psiconv_clone_character_layout(para->base_character);
        }
#line 694
        if (! in_line.layout) {
#line 696
          goto ERROR4;
        }
        {
#line 697
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read the element type");
#line 698
        tmp___23 = psiconv_read_u8(config, buf, lev + 4, (psiconv_u32 )len + off,
                                   & res);
#line 698
        temp = (psiconv_u32 )tmp___23;
        }
#line 699
        if (res) {
#line 700
          goto ERROR5;
        }
        {
#line 701
        len ++;
#line 702
        psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Type: %02x",
                      temp);
#line 703
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read the number of characters it applies to");
#line 705
        tmp___24 = psiconv_read_u32(config, buf, lev + 4, (psiconv_u32 )len + off,
                                    & res);
#line 705
        in_line.length = (int )tmp___24;
        }
#line 706
        if (res) {
#line 707
          goto ERROR5;
        }
        {
#line 708
        psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Length: %02x",
                      in_line.length);
#line 709
        len += 4;
#line 710
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read the character layout");
#line 711
        res = psiconv_parse_character_layout_list(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                  & leng, in_line.layout);
        }
#line 711
        if (res) {
#line 713
          goto ERROR5;
        }
#line 714
        len += leng;
#line 716
        if (temp == 1U) {
          {
#line 717
          psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Found an embedded object");
#line 718
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to read the object marker (0x%08x expected)", 268435537);
#line 720
          temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
          }
#line 721
          if (res) {
#line 722
            goto ERROR5;
          }
#line 723
          if (temp != 268435537U) {
            {
#line 724
            psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Unknown id marks embedded object");
#line 725
            psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                          "Marker: read %08x, expected %08x", temp, 268435537);
            }
          }
          {
#line 728
          len += 4;
#line 729
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to read the Embedded Object Section offset");
#line 731
          temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
          }
#line 732
          if (res) {
#line 733
            goto ERROR5;
          }
          {
#line 734
          psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Offset: %08x", temp);
#line 735
          len += 4;
#line 736
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to parse the Embedded Object Section");
#line 738
          res = psiconv_parse_embedded_object_section(config, buf, lev + 4, temp,
                                                      (int *)((void *)0), & in_line.object);
          }
#line 738
          if (res) {
#line 740
            goto ERROR5;
          }
          {
#line 741
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to read the object width");
#line 743
          in_line.object_width = psiconv_read_length(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                     & leng, & res);
          }
#line 745
          if (res) {
#line 746
            goto ERROR5;
          }
          {
#line 747
          psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Object width: %f cm", (double )in_line.object_width);
#line 749
          len += leng;
#line 750
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to read the object height");
#line 752
          in_line.object_height = psiconv_read_length(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                      & leng, & res);
          }
#line 754
          if (res) {
#line 755
            goto ERROR5;
          }
          {
#line 756
          psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Object height: %f cm", (double )in_line.object_height);
#line 758
          len += leng;
          }
        } else
#line 759
        if (temp != 0U) {
          {
#line 760
          psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                       "Layout section unknown inline type");
          }
        }
        {
#line 762
        tmp___26 = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
        }
#line 762
        if (line_length + in_line.length > tmp___26) {
          {
#line 763
          psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                       "Layout section inlines: line length mismatch");
#line 765
          res = -1;
#line 766
          tmp___25 = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
#line 766
          in_line.length = tmp___25 - line_length;
          }
        }
        {
#line 768
        line_length += in_line.length;
#line 769
        res = psiconv_list_add(para->in_lines, (void const   *)(& in_line));
        }
#line 769
        if (res) {
#line 770
          goto ERROR5;
        }
      }
#line 683
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 677
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 775
  if (total != nr) {
    {
#line 776
    psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Layout section too many inlines, skipping remaining");
    }
  }
  {
#line 780
  free((void *)inline_count);
#line 782
  i = 0;
  }
  {
#line 782
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 782
    tmp___29 = psiconv_list_length((psiconv_list const   )anon_styles);
    }
#line 782
    if (! ((psiconv_u32 )i < tmp___29)) {
#line 782
      goto while_break___4;
    }
    {
#line 783
    tmp___28 = psiconv_list_get((psiconv_list const   )anon_styles, (psiconv_u32 )i);
#line 783
    anon_ptr = (anon_style )tmp___28;
    }
#line 783
    if (! anon_ptr) {
      {
#line 784
      psiconv_error((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Data structure corruption");
      }
#line 785
      goto ERROR2;
    }
    {
#line 787
    psiconv_free_character_layout(anon_ptr->character);
#line 788
    psiconv_free_paragraph_layout(anon_ptr->paragraph);
#line 782
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 790
  psiconv_list_free(anon_styles);
  }
#line 792
  if (length) {
#line 793
    *length = len;
  }
  {
#line 795
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of layout section (total length: %08x)", len);
  }
#line 798
  return (0);
  ERROR4_4: 
  {
#line 801
  psiconv_free_paragraph_layout(para->base_paragraph);
  }
  ERROR4_3: 
  {
#line 803
  psiconv_free_character_layout(para->base_character);
  }
  ERROR4_2: 
  {
#line 805
  psiconv_list_free(para->in_lines);
  }
  ERROR4_1: 
  {
#line 807
  free((void *)para);
  }
#line 808
  goto ERROR4;
  ERROR3_2: 
  {
#line 811
  psiconv_free_character_layout(anon.character);
  }
  ERROR3_1: 
  {
#line 813
  psiconv_free_paragraph_layout(anon.paragraph);
  }
#line 814
  goto ERROR3;
  ERROR5: 
#line 817
  if (in_line.layout) {
    {
#line 818
    psiconv_free_character_layout(in_line.layout);
    }
  }
#line 819
  if (in_line.object) {
    {
#line 820
    psiconv_free_embedded_object_section(in_line.object);
    }
  }
  ERROR4: 
  {
#line 822
  free((void *)inline_count);
  }
  ERROR3: 
#line 824
  i = 0;
  {
#line 824
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 824
    tmp___31 = psiconv_list_length((psiconv_list const   )anon_styles);
    }
#line 824
    if (! ((psiconv_u32 )i < tmp___31)) {
#line 824
      goto while_break___5;
    }
    {
#line 825
    tmp___30 = psiconv_list_get((psiconv_list const   )anon_styles, (psiconv_u32 )i);
#line 825
    anon_ptr = (anon_style )tmp___30;
    }
#line 825
    if (! anon_ptr) {
      {
#line 826
      psiconv_error((psiconv_config )config, lev + 1, off, "Data structure corruption");
      }
#line 827
      goto while_break___5;
    }
    {
#line 829
    psiconv_free_paragraph_layout(anon_ptr->paragraph);
#line 830
    psiconv_free_character_layout(anon_ptr->character);
#line 824
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  ERROR2: 
  {
#line 834
  psiconv_list_free(anon_styles);
  }
  ERROR1: 
  {
#line 836
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Layout Section failed");
  }
#line 837
  if (length) {
#line 838
    *length = 0;
  }
#line 839
  if (! res) {
#line 840
    return (-2);
  } else {
#line 842
    return (res);
  }
}
}
#line 1063 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
static psiconv_file_type_t psiconv_determine_embedded_object_type___1(psiconv_config const   config ,
                                                                      psiconv_buffer const   buf ,
                                                                      int lev , int *status ) 
{ 
  psiconv_u32 off ;
  psiconv_section_table_section table ;
  int res ;
  int i ;
  psiconv_file_type_t file_type ;
  psiconv_section_table_entry entry ;
  psiconv_application_id_section applid ;
  void *tmp ;
  psiconv_u32 tmp___0 ;
  psiconv_u32 tmp___1 ;

  {
  {
#line 1071
  file_type = (psiconv_file_type_t )0;
#line 1075
  psiconv_progress((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Going to determine embedded object file type");
#line 1076
  psiconv_progress((psiconv_config )config, lev + 2, (psiconv_u32 )0, "Going to read the Section Table Offset Section");
#line 1077
  off = psiconv_read_u32(config, buf, lev, (psiconv_u32 )0, & res);
  }
#line 1078
  if (res) {
#line 1079
    goto ERROR1;
  }
  {
#line 1080
  psiconv_debug((psiconv_config )config, lev + 2, (psiconv_u32 )0, "Offset: %08x",
                off);
#line 1082
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the Section Table Section");
#line 1083
  res = psiconv_parse_section_table_section(config, buf, lev + 2, off, (int *)((void *)0),
                                            & table);
  }
#line 1083
  if (res) {
#line 1084
    goto ERROR1;
  }
  {
#line 1086
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to search the Section Table Section for the Application ID Section");
#line 1088
  i = 0;
  }
  {
#line 1088
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1088
    tmp___0 = psiconv_list_length((psiconv_list const   )table);
    }
#line 1088
    if (! ((psiconv_u32 )i < tmp___0)) {
#line 1088
      goto while_break;
    }
    {
#line 1089
    psiconv_progress((psiconv_config )config, lev + 3, off, "Going to read entry %d",
                     i);
#line 1090
    tmp = psiconv_list_get((psiconv_list const   )table, (psiconv_u32 )i);
#line 1090
    entry = (psiconv_section_table_entry )tmp;
    }
#line 1090
    if (! entry) {
#line 1091
      goto ERROR2;
    }
#line 1092
    if (entry->id == 268435593U) {
      {
#line 1093
      psiconv_progress((psiconv_config )config, lev + 3, off, "Found the Application ID Section at offset %08x",
                       entry->offset);
#line 1096
      off = entry->offset;
      }
#line 1097
      goto while_break;
    }
#line 1088
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1100
  tmp___1 = psiconv_list_length((psiconv_list const   )table);
  }
#line 1100
  if ((psiconv_u32 )i == tmp___1) {
    {
#line 1101
    psiconv_error((psiconv_config )config, lev + 2, off, "No Application ID Section found");
#line 1102
    res = 3;
    }
#line 1103
    goto ERROR2;
  }
  {
#line 1106
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the Application ID Section");
#line 1107
  res = psiconv_parse_application_id_section(config, buf, lev + 2, off, (int *)((void *)0),
                                             & applid);
  }
#line 1107
  if (res) {
#line 1108
    goto ERROR2;
  }
  {
#line 1111
  if (applid->id == 268435583U) {
#line 1111
    goto case_268435583;
  }
#line 1114
  if (applid->id == 268435589U) {
#line 1114
    goto case_268435589;
  }
#line 1117
  if (applid->id == 268435581U) {
#line 1117
    goto case_268435581;
  }
#line 1120
  if (applid->id == 268435592U) {
#line 1120
    goto case_268435592;
  }
#line 1123
  goto switch_default;
  case_268435583: /* CIL Label */ 
  {
#line 1111
  file_type = (psiconv_file_type_t )1;
#line 1112
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found a Word file");
  }
#line 1113
  goto switch_break;
  case_268435589: /* CIL Label */ 
  {
#line 1114
  file_type = (psiconv_file_type_t )2;
#line 1115
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found a TextEd file");
  }
#line 1116
  goto switch_break;
  case_268435581: /* CIL Label */ 
  {
#line 1117
  file_type = (psiconv_file_type_t )4;
#line 1118
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found a Sketch file");
  }
#line 1119
  goto switch_break;
  case_268435592: /* CIL Label */ 
  {
#line 1120
  file_type = (psiconv_file_type_t )6;
#line 1121
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found a Sheet file");
  }
#line 1122
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1123
  psiconv_warn((psiconv_config )config, lev + 2, off, "Found an unknown file type");
#line 1124
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found ID %08x", applid->id);
  }
  switch_break: /* CIL Label */ ;
  }
  ERROR2: 
  {
#line 1128
  psiconv_free_application_id_section(applid);
  }
  ERROR1: 
  {
#line 1130
  psiconv_free_section_table_section(table);
  }
#line 1131
  if (status) {
#line 1132
    *status = res;
  }
#line 1133
  return (file_type);
}
}
#line 580 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 23 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/extra/checkuid.c"
unsigned long uid1[32]  = 
#line 23 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/extra/checkuid.c"
  {      17824UL,      35648UL,      1697UL,      3394UL, 
        6788UL,      13576UL,      27152UL,      54304UL, 
        1168113664UL,      2336227328UL,      111214592UL,      222429184UL, 
        444858368UL,      889716736UL,      1779433472UL,      3558866944UL, 
        43601UL,      17539UL,      35078UL,      557UL, 
        1114UL,      2228UL,      4456UL,      8912UL, 
        2857435136UL,      1149435904UL,      2298871808UL,      36503552UL, 
        73007104UL,      146014208UL,      292028416UL,      584056832UL};
#line 56 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/extra/checkuid.c"
unsigned long uid2[32]  = 
#line 56
  {      30388UL,      60776UL,      51953UL,      34243UL, 
        6311UL,      14158UL,      28316UL,      56632UL, 
        1991507968UL,      3983015936UL,      3404791808UL,      2244149248UL, 
        413597696UL,      927858688UL,      1855717376UL,      3711434752UL, 
        14128UL,      28256UL,      56512UL,      43425UL, 
        17251UL,      34502UL,      7597UL,      15194UL, 
        925892608UL,      1851785216UL,      3703570432UL,      2845900800UL, 
        1130561536UL,      2261123072UL,      497876992UL,      995753984UL};
#line 89 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/extra/checkuid.c"
unsigned long uid3[32]  = 
#line 89
  {      13105UL,      26210UL,      52420UL,      35241UL, 
        883UL,      1766UL,      3532UL,      7064UL, 
        858849280UL,      1717698560UL,      3435397120UL,      2309554176UL, 
        57868288UL,      115736576UL,      231473152UL,      462946304UL, 
        4129UL,      8258UL,      16516UL,      33032UL, 
        4657UL,      9314UL,      18628UL,      37256UL, 
        270598144UL,      541196288UL,      1082392576UL,      2164785152UL, 
        305201152UL,      610402304UL,      1220804608UL,      2441609216UL};
#line 123 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/extra/checkuid.c"
unsigned long checkuid(unsigned long id1 , unsigned long id2 , unsigned long id3 ) 
{ 
  int i ;
  unsigned long res ;

  {
#line 126
  res = 0UL;
#line 127
  i = 0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < 32)) {
#line 127
      goto while_break;
    }
#line 128
    if (id1 & (unsigned long )(1 << i)) {
#line 129
      res ^= uid1[i];
    }
#line 130
    if (id2 & (unsigned long )(1 << i)) {
#line 131
      res ^= uid2[i];
    }
#line 132
    if (id3 & (unsigned long )(1 << i)) {
#line 133
      res ^= uid3[i];
    }
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  return (res);
}
}
#line 138 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/extra/checkuid.c"
void printhexdigit(char digit ) 
{ 


  {
#line 140
  if ((int )digit < 10) {
    {
#line 141
    putchar((int )digit + 48);
    }
  } else {
    {
#line 143
    putchar(((int )digit + 65) - 10);
    }
  }
#line 144
  return;
}
}
#line 146 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/extra/checkuid.c"
void printhex(unsigned long id ) 
{ 
  int i ;

  {
#line 149
  i = 0;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! (i < 8)) {
#line 149
      goto while_break;
    }
    {
#line 150
    printhexdigit((char )((id & 4026531840UL) >> 28));
#line 151
    id <<= 4;
#line 149
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return;
}
}
#line 36 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_driver.c"
static psiconv_bool_t applid_matches___2(psiconv_string_t found , char const   *sought ) 
{ 
  int i ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 40
  tmp = psiconv_unicode_strlen((psiconv_ucs2 const   *)found);
#line 40
  tmp___0 = strlen(sought);
  }
#line 40
  if ((size_t )tmp != tmp___0) {
#line 41
    return ((psiconv_bool_t )0);
  }
#line 42
  i = 0;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 42
    tmp___1 = strlen(sought);
    }
#line 42
    if (! ((size_t )i < tmp___1)) {
#line 42
      goto while_break;
    }
#line 43
    if ((int )*(found + i) != (int )*(sought + i)) {
#line 43
      if ((int const   )*(sought + i) < 97) {
#line 46
        return ((psiconv_bool_t )0);
      } else
#line 43
      if ((int const   )*(sought + i) > 122) {
#line 46
        return ((psiconv_bool_t )0);
      } else
#line 43
      if ((int )*(found + i) != (int )(((int const   )*(sought + i) + 65) - 97)) {
#line 46
        return ((psiconv_bool_t )0);
      }
    }
#line 42
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return ((psiconv_bool_t )1);
}
}
#line 40 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static struct formula_element formula_elements___2[256]  = 
#line 40 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
  {      {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )1, 2, "<"}, 
        {(psiconv_formula_type_t )2, 2, "<="}, 
        {(psiconv_formula_type_t )3, 2, ">"}, 
        {(psiconv_formula_type_t )4, 2, ">="}, 
        {(psiconv_formula_type_t )5, 2, "<>"}, 
        {(psiconv_formula_type_t )6, 2, "="}, 
        {(psiconv_formula_type_t )7, 2, "+"}, 
        {(psiconv_formula_type_t )8, 2, "-"}, 
        {(psiconv_formula_type_t )9, 2, "*"}, 
        {(psiconv_formula_type_t )10, 2, "/"}, 
        {(psiconv_formula_type_t )11, 2, "^"}, 
        {(psiconv_formula_type_t )12, 1, "+"}, 
        {(psiconv_formula_type_t )13, 1, "-"}, 
        {(psiconv_formula_type_t )14, 1, "NOT"}, 
        {(psiconv_formula_type_t )15, 2, "AND"}, 
        {(psiconv_formula_type_t )16, 2, "OR"}, 
        {(psiconv_formula_type_t )17, 2, "&"}, 
        {(psiconv_formula_type_t )18, 1, "()"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )19, 0, "End of formula"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )20, 0, "Floating point number"}, 
        {(psiconv_formula_type_t )21, 0, "Signed integer number"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )22, 0, "Named variable"}, 
        {(psiconv_formula_type_t )23, 0, "String"}, 
        {(psiconv_formula_type_t )24, 0, "Cell reference"}, 
        {(psiconv_formula_type_t )25, 0, "Cell block"}, 
        {(psiconv_formula_type_t )26, 0, "Cell block {varargs}"}, 
        {(psiconv_formula_type_t )27, 0, "Operand separator"}, 
        {(psiconv_formula_type_t )28, 0, "Operand list end"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )29, 0, "FALSE"}, 
        {(psiconv_formula_type_t )30, 3, "IF"}, 
        {(psiconv_formula_type_t )31, 0, "TRUE"}, 
        {(psiconv_formula_type_t )32, 2, "CELL"}, 
        {(psiconv_formula_type_t )33, 0, "ERRORTYPE"}, 
        {(psiconv_formula_type_t )34, 1, "ISBLANK"}, 
        {(psiconv_formula_type_t )35, 1, "ISERR"}, 
        {(psiconv_formula_type_t )36, 1, "ISERROR"}, 
        {(psiconv_formula_type_t )37, 1, "ISLOGICAL"}, 
        {(psiconv_formula_type_t )38, 1, "ISNA"}, 
        {(psiconv_formula_type_t )39, 1, "ISNONTEXT"}, 
        {(psiconv_formula_type_t )40, 1, "ISNUMBER"}, 
        {(psiconv_formula_type_t )41, 1, "ISTEXT"}, 
        {(psiconv_formula_type_t )42, 1, "N"}, 
        {(psiconv_formula_type_t )43, 1, "TYPE"}, 
        {(psiconv_formula_type_t )44, 2, "ADDRESS"}, 
        {(psiconv_formula_type_t )45, 1, "COLUMN"}, 
        {(psiconv_formula_type_t )46, 1, "COLUMNS"}, 
        {(psiconv_formula_type_t )47, 3, "HLOOKUP"}, 
        {(psiconv_formula_type_t )48, 3, "INDEX"}, 
        {(psiconv_formula_type_t )49, 1, "INDIRECT"}, 
        {(psiconv_formula_type_t )50, 3, "LOOKUP"}, 
        {(psiconv_formula_type_t )51, 3, "OFFSET"}, 
        {(psiconv_formula_type_t )52, 1, "ROW"}, 
        {(psiconv_formula_type_t )53, 1, "ROWS"}, 
        {(psiconv_formula_type_t )54, 3, "VLOOKUP"}, 
        {(psiconv_formula_type_t )55, 1, "CHAR"}, 
        {(psiconv_formula_type_t )56, 1, "CODE"}, 
        {(psiconv_formula_type_t )57, 2, "EXACT"}, 
        {(psiconv_formula_type_t )58, 3, "FIND"}, 
        {(psiconv_formula_type_t )59, 2, "LEFT"}, 
        {(psiconv_formula_type_t )60, 1, "LEN"}, 
        {(psiconv_formula_type_t )61, 1, "LOWER"}, 
        {(psiconv_formula_type_t )62, 3, "MID"}, 
        {(psiconv_formula_type_t )63, 1, "PROPER"}, 
        {(psiconv_formula_type_t )64, 4, "REPLACE"}, 
        {(psiconv_formula_type_t )65, 2, "REPT"}, 
        {(psiconv_formula_type_t )66, 2, "RIGHT"}, 
        {(psiconv_formula_type_t )67, 2, "STRING"}, 
        {(psiconv_formula_type_t )68, 1, "T"}, 
        {(psiconv_formula_type_t )69, 1, "TRIM"}, 
        {(psiconv_formula_type_t )70, 1, "UPPER"}, 
        {(psiconv_formula_type_t )71, 1, "VALUE"}, 
        {(psiconv_formula_type_t )72, 3, "DATE"}, 
        {(psiconv_formula_type_t )73, 1, "DATEVALUE"}, 
        {(psiconv_formula_type_t )74, 1, "DAY"}, 
        {(psiconv_formula_type_t )75, 1, "HOUR"}, 
        {(psiconv_formula_type_t )76, 1, "MINUTE"}, 
        {(psiconv_formula_type_t )77, 1, "MONTH"}, 
        {(psiconv_formula_type_t )78, 0, "NOW"}, 
        {(psiconv_formula_type_t )79, 1, "SECOND"}, 
        {(psiconv_formula_type_t )80, 0, "TODAY"}, 
        {(psiconv_formula_type_t )81, 3, "TIME"}, 
        {(psiconv_formula_type_t )82, 1, "TIMEVALUE"}, 
        {(psiconv_formula_type_t )83, 1, "YEAR"}, 
        {(psiconv_formula_type_t )84, 1, "ABS"}, 
        {(psiconv_formula_type_t )85, 1, "ACOS"}, 
        {(psiconv_formula_type_t )86, 1, "ASIN"}, 
        {(psiconv_formula_type_t )87, 1, "ATAN"}, 
        {(psiconv_formula_type_t )88, 2, "ATAN2"}, 
        {(psiconv_formula_type_t )89, 1, "COS"}, 
        {(psiconv_formula_type_t )90, 0, "DEGREES"}, 
        {(psiconv_formula_type_t )91, 1, "EXP"}, 
        {(psiconv_formula_type_t )92, 1, "FACT"}, 
        {(psiconv_formula_type_t )93, 1, "INT"}, 
        {(psiconv_formula_type_t )94, 1, "LN"}, 
        {(psiconv_formula_type_t )95, 1, "LOG10"}, 
        {(psiconv_formula_type_t )96, 2, "MOD"}, 
        {(psiconv_formula_type_t )97, 0, "PI"}, 
        {(psiconv_formula_type_t )98, 1, "RADIANS"}, 
        {(psiconv_formula_type_t )99, 0, "RAND"}, 
        {(psiconv_formula_type_t )100, 2, "ROUND"}, 
        {(psiconv_formula_type_t )101, 1, "SIGN"}, 
        {(psiconv_formula_type_t )102, 1, "SIN"}, 
        {(psiconv_formula_type_t )103, 1, "SQRT"}, 
        {(psiconv_formula_type_t )104, 2, "SUMPRODUCT"}, 
        {(psiconv_formula_type_t )105, 1, "TAN"}, 
        {(psiconv_formula_type_t )106, 1, "TRUNC"}, 
        {(psiconv_formula_type_t )107, 3, "CTERM"}, 
        {(psiconv_formula_type_t )108, 4, "DDB"}, 
        {(psiconv_formula_type_t )109, 3, "FV"}, 
        {(psiconv_formula_type_t )110, 2, "IRR"}, 
        {(psiconv_formula_type_t )111, 2, "NPV"}, 
        {(psiconv_formula_type_t )112, 3, "PMT"}, 
        {(psiconv_formula_type_t )113, 3, "PV"}, 
        {(psiconv_formula_type_t )114, 3, "RATE"}, 
        {(psiconv_formula_type_t )115, 3, "SLN"}, 
        {(psiconv_formula_type_t )116, 4, "SYD"}, 
        {(psiconv_formula_type_t )117, 3, "TERM"}, 
        {(psiconv_formula_type_t )118, 2, "COMBIN"}, 
        {(psiconv_formula_type_t )119, 2, "PERMUT"}, 
        {(psiconv_formula_type_t )120, -1, "AVERAGE"}, 
        {(psiconv_formula_type_t )121, -1, "CHOOSE"}, 
        {(psiconv_formula_type_t )122, -1, "COUNT"}, 
        {(psiconv_formula_type_t )123, -1, "COUNTA"}, 
        {(psiconv_formula_type_t )124, -1, "COUNTBLANK"}, 
        {(psiconv_formula_type_t )125, -1, "MAX"}, 
        {(psiconv_formula_type_t )126, -1, "MIN"}, 
        {(psiconv_formula_type_t )127, -1, "PRODUCT"}, 
        {(psiconv_formula_type_t )128, -1, "STDEVP"}, 
        {(psiconv_formula_type_t )129, -1, "STDEV"}, 
        {(psiconv_formula_type_t )130, -1, "SUM"}, 
        {(psiconv_formula_type_t )131, -1, "SUMSQ"}, 
        {(psiconv_formula_type_t )132, -1, "VARP"}, 
        {(psiconv_formula_type_t )133, -1, "VAR"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}};
#line 296 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static int psiconv_parse_sheet_ref___2(psiconv_config const   config , psiconv_buffer const   buf ,
                                       int lev , psiconv_u32 off , int *length , psiconv_sheet_ref_t *result ) 
{ 
  int res ;
  psiconv_u16 temp ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 304
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a sheet ref");
#line 305
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the offset encoding");
#line 306
  temp = psiconv_read_u16(config, buf, lev + 2, off, & res);
  }
#line 307
  if (res) {
#line 308
    if (length) {
#line 309
      *length = 0;
    }
#line 310
    return (res);
  }
  {
#line 312
  psiconv_debug((psiconv_config )config, lev + 2, off, "Encoded word: %04x", (int )temp);
  }
#line 313
  if ((int )temp & 16384) {
#line 313
    result->absolute = (psiconv_bool_t )1;
  } else {
#line 313
    result->absolute = (psiconv_bool_t )0;
  }
#line 314
  if ((int )temp & 32768) {
#line 314
    tmp = -1;
  } else {
#line 314
    tmp = 1;
  }
#line 314
  result->offset = (psiconv_s16 )(((int )temp & 16383) * tmp);
#line 315
  if (result->absolute) {
#line 315
    tmp___0 = "absolute";
  } else {
#line 315
    tmp___0 = "relative";
  }
  {
#line 315
  psiconv_debug((psiconv_config )config, lev + 2, off, "Reference: %s offset %d",
                tmp___0, (int )result->offset);
  }
#line 317
  if (length) {
#line 318
    *length = 2;
  }
#line 319
  return (0);
}
}
#line 322 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static int psiconv_parse_sheet_cell_reference___2(psiconv_config const   config ,
                                                  psiconv_buffer const   buf , int lev ,
                                                  psiconv_u32 off , int *length ,
                                                  psiconv_sheet_cell_reference_t *result ) 
{ 
  int len ;
  int leng ;
  int res ;
  psiconv_u8 temp ;

  {
  {
#line 327
  len = 0;
#line 331
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read a sheet cell reference");
#line 332
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the row reference");
#line 333
  res = psiconv_parse_sheet_ref___2(config, buf, lev + 2, off + (psiconv_u32 )len,
                                    & leng, & result->row);
  }
#line 333
  if (res) {
#line 334
    goto ERROR;
  }
  {
#line 335
  len += leng;
#line 336
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the column reference");
#line 337
  res = psiconv_parse_sheet_ref___2(config, buf, lev + 2, off + (psiconv_u32 )len,
                                    & leng, & result->column);
  }
#line 337
  if (res) {
#line 338
    goto ERROR;
  }
  {
#line 339
  len += leng;
#line 341
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the trailing byte (%02x expected)",
                   0);
#line 343
  temp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 344
  if (res) {
#line 345
    goto ERROR;
  }
#line 346
  if ((int )temp != 0) {
    {
#line 347
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unknown byte in cell reference (ignored");
#line 348
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Trailing byte: %02x",
                  (int )temp);
    }
  }
  {
#line 350
  len ++;
#line 351
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of cell reference (total length: %08x)",
                   len);
  }
#line 353
  if (length) {
#line 354
    *length = len;
  }
#line 355
  return (0);
  ERROR: 
#line 357
  if (length) {
#line 358
    *length = 0;
  }
#line 359
  return (res);
}
}
#line 362 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static int psiconv_parse_sheet_cell_block___2(psiconv_config const   config , psiconv_buffer const   buf ,
                                              int lev , psiconv_u32 off , int *length ,
                                              psiconv_sheet_cell_block_t *result ) 
{ 
  int len ;
  int leng ;
  int res ;

  {
  {
#line 367
  len = 0;
#line 370
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read a sheet cell block");
#line 371
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the first cell");
#line 372
  res = psiconv_parse_sheet_cell_reference___2(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & leng, & result->first);
  }
#line 372
  if (res) {
#line 374
    goto ERROR;
  }
  {
#line 375
  len += leng;
#line 376
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the last cell");
#line 377
  res = psiconv_parse_sheet_cell_reference___2(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & leng, & result->last);
  }
#line 377
  if (res) {
#line 379
    goto ERROR;
  }
  {
#line 380
  len += leng;
#line 381
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of cell block (total length: %08x)",
                   len);
  }
#line 383
  if (length) {
#line 384
    *length = len;
  }
#line 385
  return (0);
  ERROR: 
#line 387
  if (length) {
#line 388
    *length = 0;
  }
#line 389
  return (res);
}
}
#line 392 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static int psiconv_parse_formula_element_list___2(psiconv_config const   config ,
                                                  psiconv_buffer const   buf , int lev ,
                                                  psiconv_u32 off , int *length ,
                                                  psiconv_formula *result , psiconv_u32 maxlen ) 
{ 
  int res ;
  int len ;
  int leng ;
  int eof ;
  psiconv_u8 marker ;
  psiconv_u8 submarker ;
  psiconv_u8 submarker2 ;
  psiconv_formula_list formula_stack ;
  psiconv_formula formula ;
  psiconv_formula subformula ;
  psiconv_formula subformula1 ;
  psiconv_formula subformula2 ;
  psiconv_formula subformula3 ;
  psiconv_formula subformula4 ;
  psiconv_u16 temp ;
  psiconv_u16 nr_of_subs ;
  psiconv_formula tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  psiconv_formula_list tmp___6 ;
  psiconv_formula_list tmp___7 ;
  psiconv_formula_type_t tmp___8 ;
  psiconv_formula_type_t tmp___9 ;
  psiconv_formula_type_t tmp___10 ;
  psiconv_formula_type_t tmp___11 ;
  psiconv_u32 tmp___12 ;
  psiconv_u32 tmp___13 ;

  {
  {
#line 398
  res = 0;
#line 399
  len = 0;
#line 401
  eof = 0;
#line 408
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a formula element list");
#line 409
  tmp___0 = malloc(sizeof(*(*result)));
#line 409
  tmp = (psiconv_formula )tmp___0;
#line 409
  *result = tmp;
  }
#line 409
  if (! tmp) {
#line 410
    goto ERROR1;
  }
  {
#line 411
  formula_stack = psiconv_list_new(sizeof(struct psiconv_formula_s ));
  }
#line 411
  if (! formula_stack) {
#line 412
    goto ERROR2;
  }
  {
#line 413
  tmp___1 = malloc(sizeof(*formula));
#line 413
  formula = (psiconv_formula )tmp___1;
  }
#line 413
  if (! formula) {
#line 414
    goto ERROR3;
  }
  {
#line 416
  formula->type = (psiconv_formula_type_t )0;
#line 417
  tmp___2 = malloc(sizeof(*subformula1));
#line 417
  subformula1 = (psiconv_formula )tmp___2;
  }
#line 417
  if (! subformula1) {
#line 418
    goto ERROR4;
  }
  {
#line 419
  subformula1->type = (psiconv_formula_type_t )0;
#line 420
  tmp___3 = malloc(sizeof(*subformula2));
#line 420
  subformula2 = (psiconv_formula )tmp___3;
  }
#line 420
  if (! subformula2) {
#line 421
    goto ERROR5;
  }
  {
#line 422
  subformula2->type = (psiconv_formula_type_t )0;
#line 423
  tmp___4 = malloc(sizeof(*subformula3));
#line 423
  subformula3 = (psiconv_formula )tmp___4;
  }
#line 423
  if (! subformula3) {
#line 424
    goto ERROR6;
  }
  {
#line 425
  subformula3->type = (psiconv_formula_type_t )0;
#line 426
  tmp___5 = malloc(sizeof(*subformula4));
#line 426
  subformula4 = (psiconv_formula )tmp___5;
  }
#line 426
  if (! subformula4) {
#line 427
    goto ERROR7;
  }
#line 428
  subformula4->type = (psiconv_formula_type_t )0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! eof) {
#line 430
      if (! ((psiconv_u32 )len + off < maxlen)) {
#line 430
        goto while_break;
      }
    } else {
#line 430
      goto while_break;
    }
    {
#line 431
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read a formula item marker");
#line 432
    marker = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
    }
#line 433
    if (res) {
#line 434
      goto ERROR8;
    }
    {
#line 435
    psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Marker: %02x (%s)",
                  (int )marker, formula_elements___2[marker].name);
#line 437
    len ++;
    }
#line 439
    if ((unsigned int )formula_elements___2[marker].formula_type == 0U) {
      {
#line 440
      psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Unknown formula marker found!");
      }
#line 441
      goto ERROR8;
    } else
#line 442
    if ((unsigned int )formula_elements___2[marker].formula_type == 19U) {
      {
#line 448
      len --;
#line 449
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "End of this formula list");
#line 450
      eof = 1;
      }
    } else
#line 442
    if ((unsigned int )formula_elements___2[marker].formula_type == 28U) {
      {
#line 448
      len --;
#line 449
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "End of this formula list");
#line 450
      eof = 1;
      }
    } else
#line 442
    if ((unsigned int )formula_elements___2[marker].formula_type == 27U) {
      {
#line 448
      len --;
#line 449
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "End of this formula list");
#line 450
      eof = 1;
      }
    } else
#line 451
    if ((unsigned int )formula_elements___2[marker].formula_type == 21U) {
      {
#line 453
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: an integer");
#line 454
      formula->data.dat_int = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & res);
      }
#line 455
      if (res) {
#line 456
        goto ERROR8;
      }
      {
#line 457
      formula->type = formula_elements___2[marker].formula_type;
#line 458
      psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Value: %08x",
                    formula->data.dat_int);
#line 459
      len += 4;
#line 460
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 460
      if (res) {
#line 461
        goto ERROR8;
      }
#line 462
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 463
    if ((unsigned int )formula_elements___2[marker].formula_type == 20U) {
      {
#line 465
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a float");
#line 466
      formula->data.dat_float = psiconv_read_float(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                   & leng, & res);
      }
#line 468
      if (res) {
#line 469
        goto ERROR8;
      }
      {
#line 470
      formula->type = formula_elements___2[marker].formula_type;
#line 471
      psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Value: %f",
                    formula->data.dat_float);
#line 472
      len += leng;
#line 473
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 473
      if (res) {
#line 474
        goto ERROR8;
      }
#line 475
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 476
    if ((unsigned int )formula_elements___2[marker].formula_type == 24U) {
      {
#line 478
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a cell reference");
#line 479
      res = psiconv_parse_sheet_cell_reference___2(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                   & leng, & formula->data.dat_cellref);
      }
#line 479
      if (res) {
#line 481
        goto ERROR8;
      }
      {
#line 482
      formula->type = formula_elements___2[marker].formula_type;
#line 483
      len += leng;
#line 484
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 484
      if (res) {
#line 485
        goto ERROR8;
      }
#line 486
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 487
    if ((unsigned int )formula_elements___2[marker].formula_type == 25U) {
#line 487
      goto _L;
    } else
#line 487
    if ((unsigned int )formula_elements___2[marker].formula_type == 26U) {
      _L: /* CIL Label */ 
      {
#line 491
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a cell block");
#line 492
      res = psiconv_parse_sheet_cell_block___2(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & leng, & formula->data.dat_cellblock);
      }
#line 492
      if (res) {
#line 494
        goto ERROR8;
      }
      {
#line 495
      formula->type = formula_elements___2[marker].formula_type;
#line 496
      len += leng;
#line 497
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 497
      if (res) {
#line 498
        goto ERROR8;
      }
#line 499
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 500
    if ((unsigned int )formula_elements___2[marker].formula_type == 23U) {
      {
#line 502
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a string");
#line 503
      formula->data.dat_string = psiconv_read_short_string(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                           & leng, & res);
      }
#line 505
      if (res) {
#line 506
        goto ERROR8;
      }
      {
#line 507
      formula->type = formula_elements___2[marker].formula_type;
#line 508
      len += leng;
#line 509
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 509
      if (res) {
#line 510
        goto ERROR8;
      }
#line 511
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 512
    if ((unsigned int )formula_elements___2[marker].formula_type == 22U) {
      {
#line 514
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a variable reference");
#line 515
      formula->data.dat_variable = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                    & res);
      }
#line 516
      if (res) {
#line 517
        goto ERROR8;
      }
      {
#line 518
      formula->type = formula_elements___2[marker].formula_type;
#line 519
      len += 4;
#line 520
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 520
      if (res) {
#line 521
        goto ERROR8;
      }
#line 522
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 523
    if (formula_elements___2[marker].number_of_args == -1) {
      {
#line 524
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Going to parse a vararg function");
#line 525
      tmp___6 = psiconv_list_new(sizeof(*formula));
#line 525
      formula->data.fun_operands = tmp___6;
      }
#line 525
      if (! tmp___6) {
#line 527
        goto ERROR8;
      }
#line 528
      formula->type = formula_elements___2[marker].formula_type;
#line 529
      nr_of_subs = (psiconv_u16 )0;
      {
#line 530
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 531
        nr_of_subs = (psiconv_u16 )((int )nr_of_subs + 1);
#line 532
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read vararg argument %d", (int )nr_of_subs);
#line 534
        res = psiconv_parse_formula_element_list___2(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                     & leng, & subformula, maxlen);
        }
#line 534
        if (res) {
#line 536
          goto ERROR8;
        }
        {
#line 537
        len += leng;
#line 538
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula);
        }
#line 538
        if (res) {
          {
#line 539
          psiconv_free_formula(subformula);
          }
#line 540
          goto ERROR8;
        }
        {
#line 542
        free((void *)subformula);
#line 543
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read the next marker");
#line 544
        submarker = psiconv_read_u8(config, buf, lev + 4, off + (psiconv_u32 )len,
                                    & res);
#line 545
        len ++;
        }
#line 546
        if (res) {
#line 547
          goto ERROR8;
        }
        {
#line 548
        submarker2 = psiconv_read_u8(config, buf, lev + 4, off + (psiconv_u32 )len,
                                     & res);
        }
#line 549
        if (res) {
#line 550
          goto ERROR8;
        }
#line 530
        if ((unsigned int )formula_elements___2[submarker].formula_type == 27U) {
#line 530
          if (! ((unsigned int )formula_elements___2[submarker2].formula_type != 28U)) {
#line 530
            goto while_break___0;
          }
        } else {
#line 530
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 555
      if ((unsigned int )formula_elements___2[submarker].formula_type == 27U) {
#line 555
        if ((unsigned int )formula_elements___2[submarker2].formula_type == 28U) {
#line 559
          submarker = submarker2;
#line 560
          len ++;
        }
      }
#line 562
      if ((unsigned int )formula_elements___2[submarker].formula_type != 28U) {
        {
#line 564
        psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Formula corrupted!");
#line 565
        psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Found unexpected marker %02x",
                      (int )submarker);
        }
#line 566
        goto ERROR8;
      }
      {
#line 568
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Going to read the repeated marker %02x", (int )marker);
#line 570
      submarker = psiconv_read_u8(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
      }
#line 571
      if (res) {
#line 572
        goto ERROR8;
      }
#line 573
      if ((int )submarker != (int )marker) {
        {
#line 574
        psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Formula corrupted!");
#line 575
        psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Expected marker %02x, found %02x",
                      (int )marker, (int )submarker);
        }
#line 577
        goto ERROR8;
      }
      {
#line 579
      len ++;
#line 580
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Going to read the number of arguments (%d expected)", (int )nr_of_subs);
#line 583
      temp = psiconv_read_u16(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
      }
#line 584
      if (res) {
#line 585
        goto ERROR8;
      }
#line 586
      if ((int )temp != (int )nr_of_subs) {
        {
#line 587
        psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Formula corrupted!");
#line 588
        psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Read %d arguments, but formula says there are %d",
                      (int )nr_of_subs, (int )temp);
        }
#line 591
        goto ERROR8;
      }
      {
#line 593
      len += 2;
#line 594
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 594
      if (res) {
#line 595
        goto ERROR8;
      }
#line 596
      formula->type = (psiconv_formula_type_t )0;
    } else {
#line 598
      if (formula_elements___2[marker].number_of_args > 0) {
        {
#line 599
        res = psiconv_list_pop(formula_stack, (void *)subformula1);
        }
#line 599
        if (res) {
#line 600
          goto ERROR8;
        }
      }
#line 601
      if (formula_elements___2[marker].number_of_args > 1) {
        {
#line 602
        res = psiconv_list_pop(formula_stack, (void *)subformula2);
        }
#line 602
        if (res) {
#line 603
          goto ERROR8;
        }
      }
#line 604
      if (formula_elements___2[marker].number_of_args > 2) {
        {
#line 605
        res = psiconv_list_pop(formula_stack, (void *)subformula3);
        }
#line 605
        if (res) {
#line 606
          goto ERROR8;
        }
      }
#line 607
      if (formula_elements___2[marker].number_of_args > 3) {
        {
#line 608
        res = psiconv_list_pop(formula_stack, (void *)subformula4);
        }
#line 608
        if (res) {
#line 609
          goto ERROR8;
        }
      }
      {
#line 610
      tmp___7 = psiconv_list_new(sizeof(*formula));
#line 610
      formula->data.fun_operands = tmp___7;
      }
#line 610
      if (! tmp___7) {
#line 612
        goto ERROR8;
      }
#line 613
      formula->type = formula_elements___2[marker].formula_type;
#line 614
      if (formula_elements___2[marker].number_of_args > 3) {
        {
#line 615
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula4);
        }
#line 615
        if (res) {
#line 616
          goto ERROR8;
        }
      }
#line 617
      if (formula_elements___2[marker].number_of_args > 2) {
        {
#line 618
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula3);
        }
#line 618
        if (res) {
#line 619
          goto ERROR8;
        }
      }
#line 620
      if (formula_elements___2[marker].number_of_args > 1) {
        {
#line 621
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula2);
        }
#line 621
        if (res) {
#line 622
          goto ERROR8;
        }
      }
#line 623
      if (formula_elements___2[marker].number_of_args > 0) {
        {
#line 624
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula1);
        }
#line 624
        if (res) {
#line 625
          goto ERROR8;
        }
      }
      {
#line 626
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 626
      if (res) {
#line 627
        goto ERROR8;
      }
#line 628
      tmp___11 = (psiconv_formula_type_t )0;
#line 628
      formula->type = tmp___11;
#line 628
      tmp___10 = tmp___11;
#line 628
      subformula1->type = tmp___10;
#line 628
      tmp___9 = tmp___10;
#line 628
      subformula2->type = tmp___9;
#line 628
      tmp___8 = tmp___9;
#line 628
      subformula3->type = tmp___8;
#line 628
      subformula4->type = tmp___8;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  if ((psiconv_u32 )len + off > maxlen) {
    {
#line 633
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Formula corrupted!");
#line 634
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Expected end: %04x, found end: %04x",
                  maxlen, (psiconv_u32 )len + off);
    }
#line 636
    goto ERROR8;
  } else
#line 632
  if (! eof) {
    {
#line 633
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Formula corrupted!");
#line 634
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Expected end: %04x, found end: %04x",
                  maxlen, (psiconv_u32 )len + off);
    }
#line 636
    goto ERROR8;
  }
  {
#line 638
  tmp___13 = psiconv_list_length((psiconv_list const   )formula_stack);
  }
#line 638
  if (tmp___13 != 1U) {
    {
#line 639
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Formula corrupted!");
#line 640
    tmp___12 = psiconv_list_length((psiconv_list const   )formula_stack);
#line 640
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "More than one item left on the stack (%d)",
                  tmp___12);
    }
#line 642
    goto ERROR8;
  }
  {
#line 644
  res = psiconv_list_pop(formula_stack, (void *)*result);
  }
#line 644
  if (res) {
#line 645
    goto ERROR8;
  }
  {
#line 646
  psiconv_list_free(formula_stack);
#line 647
  free((void *)formula);
  }
#line 649
  if (length) {
#line 650
    *length = len;
  }
  {
#line 652
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of formula element list (total length: %08x)",
                   len);
  }
#line 654
  return (0);
  ERROR8: 
  {
#line 657
  psiconv_free_formula(subformula4);
  }
  ERROR7: 
  {
#line 659
  psiconv_free_formula(subformula3);
  }
  ERROR6: 
  {
#line 661
  psiconv_free_formula(subformula2);
  }
  ERROR5: 
  {
#line 663
  psiconv_free_formula(subformula1);
  }
  ERROR4: 
  {
#line 665
  psiconv_free_formula(formula);
  }
  ERROR3: 
  {
#line 667
  psiconv_free_formula_list(formula_stack);
  }
  ERROR2: 
  {
#line 669
  free((void *)*result);
  }
  ERROR1: 
  {
#line 671
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of formula element list failed");
  }
#line 672
  if (length) {
#line 673
    *length = 0;
  }
#line 674
  if (! res) {
#line 675
    return (-2);
  } else {
#line 677
    return (res);
  }
}
}
#line 34 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
static psiconv_float_t pow2___2(int n ) ;
#line 35
static psiconv_string_t psiconv_read_string_aux___2(psiconv_config const   config ,
                                                    psiconv_buffer const   buf , int lev ,
                                                    psiconv_u32 off , int *length ,
                                                    int *status , int kind ) ;
#line 42 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
static psiconv_float_t pow2___2(int n ) 
{ 
  psiconv_float_t res ;
  int i ;
  int tmp ;
  psiconv_float_t tmp___0 ;

  {
#line 44
  res = 1.0;
#line 47
  i = 0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (n < 0) {
#line 47
      tmp = - n;
    } else {
#line 47
      tmp = n;
    }
#line 47
    if (! (i < tmp)) {
#line 47
      goto while_break;
    }
#line 48
    res *= 2.0;
#line 47
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  if (n < 0) {
#line 50
    tmp___0 = (psiconv_float_t )1 / res;
  } else {
#line 50
    tmp___0 = res;
  }
#line 50
  return (tmp___0);
}
}
#line 325 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
static psiconv_string_t psiconv_read_string_aux___2(psiconv_config const   config ,
                                                    psiconv_buffer const   buf , int lev ,
                                                    psiconv_u32 off , int *length ,
                                                    int *status , int kind ) 
{ 
  int bytecount ;
  int i ;
  int leng ;
  int len ;
  int localstatus ;
  psiconv_string_t result ;
  char *res_copy ;
  psiconv_list string ;
  psiconv_ucs2 nextchar ;
  psiconv_ucs2 *nextcharptr ;
  psiconv_u32 tmp ;
  psiconv_u8 tmp___0 ;
  psiconv_u32 tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  psiconv_u32 tmp___4 ;

  {
  {
#line 337
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a string");
  }
#line 339
  if (kind == -1) {
    {
#line 340
    tmp = psiconv_read_S(config, buf, lev + 2, off, & leng, & localstatus);
#line 340
    bytecount = (int )tmp;
    }
  } else
#line 341
  if (kind == -2) {
    {
#line 342
    tmp___0 = psiconv_read_u8(config, buf, lev + 2, off, & localstatus);
#line 342
    bytecount = (int )tmp___0;
#line 343
    leng = 1;
    }
  } else {
#line 345
    bytecount = kind;
#line 346
    leng = 0;
#line 347
    localstatus = 0;
  }
#line 349
  if (localstatus) {
#line 350
    goto ERROR1;
  }
  {
#line 351
  psiconv_debug((psiconv_config )config, lev + 2, off, "Length: %i", bytecount);
#line 352
  len = leng;
#line 354
  string = psiconv_list_new(sizeof(*result));
  }
#line 354
  if (! string) {
#line 355
    goto ERROR1;
  }
#line 358
  i = 0;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! (i < bytecount)) {
#line 359
      goto while_break;
    }
    {
#line 360
    nextchar = psiconv_unicode_read_char(config, (psiconv_buffer )buf, lev, (off + (psiconv_u32 )i) + (psiconv_u32 )len,
                                         & leng, & localstatus);
    }
#line 362
    if (localstatus) {
#line 363
      goto ERROR2;
    }
    {
#line 364
    localstatus = psiconv_list_add(string, (void const   *)(& nextchar));
    }
#line 364
    if (localstatus) {
#line 365
      goto ERROR2;
    }
#line 366
    i += leng;
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  if (i > bytecount) {
    {
#line 369
    psiconv_error((psiconv_config )config, lev, (off + (psiconv_u32 )i) + (psiconv_u32 )len,
                  "Malformed string");
#line 370
    localstatus = 3;
    }
#line 371
    goto ERROR2;
  }
  {
#line 373
  len += bytecount;
#line 376
  tmp___1 = psiconv_list_length((psiconv_list const   )string);
#line 376
  tmp___2 = malloc(sizeof(*result) * (unsigned long )(tmp___1 + 1U));
#line 376
  result = (psiconv_string_t )tmp___2;
  }
#line 376
  if (! result) {
#line 377
    goto ERROR2;
  }
#line 378
  i = 0;
  {
#line 378
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 378
    tmp___4 = psiconv_list_length((psiconv_list const   )string);
    }
#line 378
    if (! ((psiconv_u32 )i < tmp___4)) {
#line 378
      goto while_break___0;
    }
    {
#line 379
    tmp___3 = psiconv_list_get((psiconv_list const   )string, (psiconv_u32 )i);
#line 379
    nextcharptr = (psiconv_ucs2 *)tmp___3;
    }
#line 379
    if (! nextcharptr) {
      {
#line 380
      psiconv_error((psiconv_config )config, lev, (off + (psiconv_u32 )i) + (psiconv_u32 )len,
                    "Data structure corruption");
      }
#line 381
      goto ERROR3;
    }
#line 383
    *(result + i) = *nextcharptr;
#line 378
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 385
  *(result + i) = (psiconv_ucs2 )0;
#line 387
  res_copy = psiconv_make_printable(config, (psiconv_string_t const   )result);
  }
#line 388
  if (! res_copy) {
#line 389
    goto ERROR3;
  }
  {
#line 390
  psiconv_debug((psiconv_config )config, lev + 2, off, "Contents: `%s\'", res_copy);
#line 391
  free((void *)res_copy);
#line 393
  psiconv_list_free(string);
  }
#line 395
  if (length) {
#line 396
    *length = len;
  }
#line 398
  if (status) {
#line 399
    *status = 0;
  }
  {
#line 401
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of string (total length: %08x)", len);
  }
#line 403
  return (result);
  ERROR3: 
  {
#line 406
  free((void *)result);
  }
  ERROR2: 
  {
#line 408
  psiconv_list_free(string);
  }
  ERROR1: 
  {
#line 410
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of string failed");
  }
#line 411
  if (status) {
#line 412
    *status = localstatus;
  }
#line 413
  if (length) {
#line 414
    *length = 0;
  }
#line 415
  return ((psiconv_string_t )((void *)0));
}
}
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_collect_pixel_data___2(psiconv_pixel_ints *pixels , int xsize ,
                                          int ysize , psiconv_pixel_floats_t const   data ,
                                          int colordepth , int color___1 , int redbits ,
                                          int bluebits , int greenbits , psiconv_pixel_floats_t const   palet ) ;
#line 39
static int psiconv_pixel_data_to_bytes___2(psiconv_config const   config , int lev ,
                                           psiconv_pixel_bytes *bytes , int xsize ,
                                           int ysize , psiconv_pixel_ints const   pixels ,
                                           int colordepth ) ;
#line 43
static int psiconv_encode_rle8___2(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                   psiconv_pixel_bytes *encoded_bytes ) ;
#line 46
static int psiconv_encode_rle12___2(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                    psiconv_pixel_bytes *encoded_bytes ) ;
#line 49
static int psiconv_encode_rle16___2(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                    psiconv_pixel_bytes *encoded_bytes ) ;
#line 52
static int psiconv_encode_rle24___2(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                    psiconv_pixel_bytes *encoded_bytes ) ;
#line 240 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_collect_pixel_data___2(psiconv_pixel_ints *pixels , int xsize ,
                                          int ysize , psiconv_pixel_floats_t const   data ,
                                          int colordepth , int color___1 , int redbits ,
                                          int bluebits , int greenbits , psiconv_pixel_floats_t const   palet ) 
{ 
  int res ;
  int x ;
  int y ;
  int i ;
  psiconv_u32 index___0 ;
  psiconv_u32 pixel ;
  float p_red ;
  float p_green ;
  float p_blue ;
  float dist ;
  float new_dist ;
  psiconv_pixel_ints tmp ;

  {
  {
#line 250
  tmp = psiconv_list_new(sizeof(psiconv_u32 ));
#line 250
  *pixels = tmp;
  }
#line 250
  if (! tmp) {
#line 251
    res = -2;
#line 252
    goto ERROR1;
  }
#line 255
  y = 0;
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! (y < ysize)) {
#line 255
      goto while_break;
    }
#line 256
    x = 0;
    {
#line 256
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 256
      if (! (x < xsize)) {
#line 256
        goto while_break___0;
      }
#line 257
      index___0 = (psiconv_u32 )(y * xsize + x);
#line 258
      p_red = *(data.red + index___0);
#line 259
      p_green = *(data.green + index___0);
#line 260
      p_blue = *(data.blue + index___0);
#line 261
      if (! palet.length) {
#line 262
        if (color___1) {
#line 263
          pixel = (((psiconv_u32 )((double )(p_red * (float )(1 << redbits)) + 0.5) << (greenbits + bluebits)) + ((psiconv_u32 )((double )(p_green * (float )(1 << greenbits)) + 0.5) << bluebits)) + (psiconv_u32 )((double )(p_blue * (float )(1 << bluebits)) + 0.5);
        } else {
#line 269
          pixel = (psiconv_u32 )(((0.212671 * (double )p_red + 0.715160 * (double )p_green) + 0.072169 * (double )p_blue) * ((double )(1 << colordepth) * 0.999));
        }
      } else {
#line 271
        dist = (float )4;
#line 272
        pixel = (psiconv_u32 )-1;
#line 273
        i = 0;
        {
#line 273
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 273
          if (! ((psiconv_u32 const   )i < palet.length)) {
#line 273
            goto while_break___1;
          }
#line 274
          new_dist = ((p_red - *(palet.red + i)) * (p_red - *(palet.red + i)) + (p_green - *(palet.green + i)) * (p_green - *(palet.green + i))) + (p_blue - *(palet.blue + i)) * (p_blue - *(palet.blue + i));
#line 277
          if (new_dist < dist) {
#line 278
            pixel = (psiconv_u32 )i;
#line 279
            dist = new_dist;
          }
#line 273
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 283
      res = psiconv_list_add(*pixels, (void const   *)(& pixel));
      }
#line 283
      if (res) {
#line 284
        goto ERROR2;
      }
#line 256
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 255
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  return (0);
  ERROR2: 
  {
#line 290
  psiconv_list_free(*pixels);
  }
  ERROR1: 
#line 292
  return (res);
}
}
#line 295 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_pixel_data_to_bytes___2(psiconv_config const   config , int lev ,
                                           psiconv_pixel_bytes *bytes , int xsize ,
                                           int ysize , psiconv_pixel_ints const   pixels ,
                                           int colordepth ) 
{ 
  int res ;
  int x ;
  int y ;
  psiconv_u32 inputdata ;
  psiconv_u8 outputbyte ;
  psiconv_u32 *pixelptr ;
  int inputbitsleft ;
  int outputbitnr ;
  int bitsfit ;
  int outputbytenr ;
  psiconv_u32 tmp ;
  psiconv_pixel_bytes tmp___0 ;
  void *tmp___1 ;

  {
#line 309
  if (! bytes) {
    {
#line 310
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "NULL pixel data");
#line 311
    res = -4;
    }
#line 312
    goto ERROR1;
  }
#line 314
  if (! pixels) {
    {
#line 315
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "NULL pixel data");
#line 316
    res = -4;
    }
#line 317
    goto ERROR1;
  }
  {
#line 319
  tmp = psiconv_list_length(pixels);
  }
#line 319
  if (tmp != (psiconv_u32 )(xsize * ysize)) {
    {
#line 320
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Pixel number is not correct");
#line 321
    res = -4;
    }
#line 322
    goto ERROR1;
  }
  {
#line 325
  tmp___0 = psiconv_list_new(sizeof(psiconv_u8 ));
#line 325
  *bytes = tmp___0;
  }
#line 325
  if (! tmp___0) {
#line 326
    res = -2;
#line 327
    goto ERROR1;
  }
#line 331
  outputbitnr = 0;
#line 332
  outputbyte = (psiconv_u8 )0;
#line 333
  y = 0;
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 333
    if (! (y < ysize)) {
#line 333
      goto while_break;
    }
#line 334
    outputbytenr = 0;
#line 335
    x = 0;
    {
#line 335
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 335
      if (! (x < xsize)) {
#line 335
        goto while_break___0;
      }
      {
#line 336
      tmp___1 = psiconv_list_get(pixels, (psiconv_u32 )(y * xsize + x));
#line 336
      pixelptr = (psiconv_u32 *)tmp___1;
      }
#line 336
      if (! pixelptr) {
        {
#line 337
        psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Data structure corruption");
#line 338
        res = -2;
        }
#line 339
        goto ERROR2;
      }
#line 341
      inputbitsleft = colordepth;
#line 342
      inputdata = *pixelptr;
      {
#line 343
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 343
        if (! inputbitsleft) {
#line 343
          goto while_break___1;
        }
#line 344
        if (inputbitsleft + outputbitnr <= 8) {
#line 344
          bitsfit = inputbitsleft;
        } else {
#line 344
          bitsfit = 8 - outputbitnr;
        }
#line 345
        outputbyte = (psiconv_u8 )((unsigned int )outputbyte | ((inputdata & (unsigned int )((1 << bitsfit) - 1)) << outputbitnr));
#line 346
        inputdata >>= bitsfit;
#line 347
        inputbitsleft -= bitsfit;
#line 348
        outputbitnr += bitsfit;
#line 349
        if (outputbitnr == 8) {
          {
#line 350
          res = psiconv_list_add(*bytes, (void const   *)(& outputbyte));
          }
#line 350
          if (res) {
#line 351
            goto ERROR2;
          }
#line 352
          outputbitnr = 0;
#line 353
          outputbyte = (psiconv_u8 )0;
#line 354
          outputbytenr ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 335
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 359
    if (outputbitnr != 0) {
      {
#line 360
      res = psiconv_list_add(*bytes, (void const   *)(& outputbyte));
      }
#line 360
      if (res) {
#line 361
        goto ERROR2;
      }
#line 362
      outputbitnr = 0;
#line 363
      outputbyte = (psiconv_u8 )0;
#line 364
      outputbytenr ++;
    }
    {
#line 367
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 367
      if (! (outputbytenr % 4)) {
#line 367
        goto while_break___2;
      }
      {
#line 368
      res = psiconv_list_add(*bytes, (void const   *)(& outputbyte));
      }
#line 368
      if (res) {
#line 369
        goto ERROR2;
      }
#line 370
      outputbytenr ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 333
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return (0);
  ERROR2: 
  {
#line 377
  psiconv_list_free(*bytes);
  }
  ERROR1: 
#line 379
  return (res);
}
}
#line 386 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_encode_rle8___2(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                   psiconv_pixel_bytes *encoded_bytes ) 
{ 
  int res ;
  int i ;
  int j ;
  int len ;
  psiconv_u8 *entry ;
  psiconv_u8 *next ;
  psiconv_u8 temp ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  psiconv_u32 tmp___3 ;
  void *tmp___4 ;
  psiconv_u32 tmp___5 ;
  void *tmp___6 ;
  psiconv_u32 tmp___7 ;
  psiconv_u32 tmp___8 ;

  {
  {
#line 394
  tmp = psiconv_list_new(sizeof(*entry));
#line 394
  *encoded_bytes = tmp;
  }
#line 394
  if (! tmp) {
#line 395
    res = -2;
#line 396
    goto ERROR1;
  }
#line 399
  i = 0;
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 399
    tmp___8 = psiconv_list_length(plain_bytes);
    }
#line 399
    if (! ((psiconv_u32 )i < tmp___8)) {
#line 399
      goto while_break;
    }
    {
#line 400
    tmp___0 = psiconv_list_get(plain_bytes, (psiconv_u32 )i);
#line 400
    entry = (psiconv_u8 *)tmp___0;
    }
#line 400
    if (! entry) {
#line 401
      res = -2;
#line 402
      goto ERROR2;
    }
    {
#line 404
    tmp___1 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 1));
#line 404
    next = (psiconv_u8 *)tmp___1;
    }
#line 404
    if (! next) {
#line 405
      res = -2;
#line 406
      goto ERROR2;
    }
    {
#line 408
    tmp___7 = psiconv_list_length(plain_bytes);
    }
#line 408
    if ((psiconv_u32 )i == tmp___7 - 2U) {
      {
#line 409
      temp = (psiconv_u8 )254;
#line 410
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 410
      if (res) {
#line 411
        goto ERROR2;
      }
      {
#line 412
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry);
      }
#line 412
      if (res) {
#line 413
        goto ERROR2;
      }
      {
#line 414
      res = psiconv_list_add(*encoded_bytes, (void const   *)next);
      }
#line 414
      if (res) {
#line 415
        goto ERROR2;
      }
#line 416
      i += 2;
    } else
#line 417
    if ((int )*next == (int )*entry) {
#line 418
      len = 1;
      {
#line 419
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 419
        if ((int )*next == (int )*entry) {
          {
#line 419
          tmp___3 = psiconv_list_length(plain_bytes);
          }
#line 419
          if ((psiconv_u32 )((i + len) + 2) < tmp___3) {
#line 419
            if (! (len < 128)) {
#line 419
              goto while_break___0;
            }
          } else {
#line 419
            goto while_break___0;
          }
        } else {
#line 419
          goto while_break___0;
        }
        {
#line 422
        len ++;
#line 423
        tmp___2 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len));
#line 423
        next = (psiconv_u8 *)tmp___2;
        }
#line 423
        if (! next) {
#line 424
          res = -2;
#line 425
          goto ERROR2;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 428
      temp = (psiconv_u8 )(len - 1);
#line 429
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 429
      if (res) {
#line 430
        goto ERROR2;
      }
      {
#line 431
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry);
      }
#line 431
      if (res) {
#line 432
        goto ERROR2;
      }
#line 433
      i += len;
    } else {
#line 435
      len = 1;
      {
#line 436
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 436
        if ((int )*next != (int )*entry) {
          {
#line 436
          tmp___5 = psiconv_list_length(plain_bytes);
          }
#line 436
          if ((psiconv_u32 )((i + len) + 1) < tmp___5) {
#line 436
            if (! (len < 128)) {
#line 436
              goto while_break___1;
            }
          } else {
#line 436
            goto while_break___1;
          }
        } else {
#line 436
          goto while_break___1;
        }
        {
#line 439
        len ++;
#line 440
        entry = next;
#line 441
        tmp___4 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len));
#line 441
        next = (psiconv_u8 *)tmp___4;
        }
#line 441
        if (! next) {
#line 442
          res = -2;
#line 443
          goto ERROR2;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 446
      len --;
#line 447
      temp = (psiconv_u8 )(256 - len);
#line 448
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 448
      if (res) {
#line 449
        goto ERROR2;
      }
#line 450
      j = 0;
      {
#line 450
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 450
        if (! (j < len)) {
#line 450
          goto while_break___2;
        }
        {
#line 451
        tmp___6 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + j));
#line 451
        next = (psiconv_u8 *)tmp___6;
        }
#line 451
        if (! next) {
#line 452
          res = -2;
#line 453
          goto ERROR2;
        }
        {
#line 455
        res = psiconv_list_add(*encoded_bytes, (void const   *)next);
        }
#line 455
        if (res) {
#line 456
          goto ERROR2;
        }
#line 450
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 458
      i += len;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 461
  return (0);
  ERROR2: 
  {
#line 464
  psiconv_list_free(*encoded_bytes);
  }
  ERROR1: 
#line 466
  return (res);
}
}
#line 472 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_encode_rle12___2(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                    psiconv_pixel_bytes *encoded_bytes ) 
{ 
  psiconv_word_data data ;
  int res ;
  int i ;
  int len ;
  int location ;
  psiconv_u16 *word_entry ;
  psiconv_u16 *word_next ;
  psiconv_u16 word_data ;
  psiconv_u8 byte_temp ;
  psiconv_u8 *byte_entry ;
  void *tmp ;
  psiconv_u32 tmp___0 ;
  psiconv_pixel_bytes tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  psiconv_u32 tmp___6 ;
  void *tmp___7 ;
  psiconv_u32 tmp___8 ;
  int tmp___9 ;
  psiconv_u32 tmp___10 ;

  {
  {
#line 486
  data = psiconv_list_new(sizeof(psiconv_u16 ));
  }
#line 486
  if (! data) {
#line 487
    res = -2;
#line 488
    goto ERROR1;
  }
#line 491
  i = 0;
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 491
    tmp___0 = psiconv_list_length(plain_bytes);
    }
#line 491
    if (! ((psiconv_u32 )i < tmp___0)) {
#line 491
      goto while_break;
    }
    {
#line 492
    tmp = psiconv_list_get(plain_bytes, (psiconv_u32 )i);
#line 492
    byte_entry = (psiconv_u8 *)tmp;
    }
#line 492
    if (! byte_entry) {
#line 493
      res = -2;
#line 494
      goto ERROR2;
    }
#line 496
    location = 0;
#line 497
    if (location == 0) {
#line 498
      word_data = (psiconv_u16 )*byte_entry;
#line 499
      location ++;
    } else
#line 500
    if (location == 1) {
      {
#line 501
      word_data = (psiconv_u16 )(((int )word_data << 4) + ((int )*byte_entry & 15));
#line 502
      res = psiconv_list_add(data, (void const   *)(& word_data));
      }
#line 502
      if (res) {
#line 503
        goto ERROR2;
      }
#line 504
      word_data = (psiconv_u16 )((int )*byte_entry >> 4);
#line 505
      location ++;
    } else {
      {
#line 507
      word_data = (psiconv_u16 )(((int )word_data << 8) + (int )*byte_entry);
#line 508
      res = psiconv_list_add(data, (void const   *)(& word_data));
      }
#line 508
      if (res) {
#line 509
        goto ERROR2;
      }
#line 510
      location = 0;
    }
#line 491
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 514
  tmp___1 = psiconv_list_new(sizeof(psiconv_u8 ));
#line 514
  *encoded_bytes = tmp___1;
  }
#line 514
  if (! tmp___1) {
#line 515
    res = -2;
#line 516
    goto ERROR2;
  }
#line 519
  i = 0;
  {
#line 519
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 519
    tmp___10 = psiconv_list_length((psiconv_list const   )data);
    }
#line 519
    if (! ((psiconv_u32 )i < tmp___10)) {
#line 519
      goto while_break___0;
    }
    {
#line 520
    tmp___2 = psiconv_list_get((psiconv_list const   )data, (psiconv_u32 )i);
#line 520
    word_entry = (psiconv_u16 *)tmp___2;
    }
#line 520
    if (! word_entry) {
#line 521
      res = -2;
#line 522
      goto ERROR3;
    }
    {
#line 525
    tmp___3 = psiconv_list_get((psiconv_list const   )data, (psiconv_u32 )(i + 1));
#line 525
    word_next = (psiconv_u16 *)tmp___3;
    }
#line 525
    if (! word_next) {
#line 526
      res = -2;
#line 527
      goto ERROR3;
    }
    {
#line 530
    tmp___6 = psiconv_list_length((psiconv_list const   )data);
    }
#line 530
    if ((psiconv_u32 )i == tmp___6 - 2U) {
#line 531
      if (*word_entry) {
#line 531
        tmp___4 = 1;
      } else {
#line 531
        tmp___4 = 0;
      }
      {
#line 531
      byte_temp = (psiconv_u8 )tmp___4;
#line 532
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
      }
#line 532
      if (res) {
#line 533
        goto ERROR3;
      }
      {
#line 534
      byte_temp = (psiconv_u8 )((int )*word_entry >> 8);
#line 535
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
      }
#line 535
      if (res) {
#line 536
        goto ERROR3;
      }
#line 537
      if (*word_next) {
#line 537
        tmp___5 = 1;
      } else {
#line 537
        tmp___5 = 0;
      }
      {
#line 537
      byte_temp = (psiconv_u8 )tmp___5;
#line 538
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
      }
#line 538
      if (res) {
#line 539
        goto ERROR3;
      }
      {
#line 540
      byte_temp = (psiconv_u8 )((int )*word_next >> 8);
#line 541
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
      }
#line 541
      if (res) {
#line 542
        goto ERROR3;
      }
#line 543
      i += 2;
    }
#line 546
    len = 0;
    {
#line 547
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 547
      if ((int )*word_entry == (int )*word_next) {
#line 547
        if (len < 16) {
          {
#line 547
          tmp___8 = psiconv_list_length((psiconv_list const   )data);
          }
#line 547
          if (! ((psiconv_u32 )((i + len) + 1) < tmp___8)) {
#line 547
            goto while_break___1;
          }
        } else {
#line 547
          goto while_break___1;
        }
      } else {
#line 547
        goto while_break___1;
      }
      {
#line 549
      len ++;
#line 550
      tmp___7 = psiconv_list_get((psiconv_list const   )data, (psiconv_u32 )(i + len));
#line 550
      word_next = (psiconv_u16 *)tmp___7;
      }
#line 550
      if (! word_next) {
#line 551
        res = -2;
#line 552
        goto ERROR3;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 556
    if (*word_entry) {
#line 556
      tmp___9 = 1;
    } else {
#line 556
      tmp___9 = 0;
    }
    {
#line 556
    byte_temp = (psiconv_u8 )tmp___9;
#line 557
    res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
    }
#line 557
    if (res) {
#line 558
      goto ERROR3;
    }
    {
#line 559
    byte_temp = (psiconv_u8 )(((int )*word_entry >> 8) + ((len - 1) << 4));
#line 560
    res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
    }
#line 560
    if (res) {
#line 561
      goto ERROR3;
    }
#line 562
    i += len;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 564
  return (0);
  ERROR3: 
  {
#line 567
  psiconv_list_free(*encoded_bytes);
  }
  ERROR2: 
  {
#line 569
  psiconv_list_free(data);
  }
  ERROR1: 
#line 571
  return (res);
}
}
#line 578 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_encode_rle16___2(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                    psiconv_pixel_bytes *encoded_bytes ) 
{ 
  int res ;
  int i ;
  int j ;
  int len ;
  psiconv_u8 *entry1 ;
  psiconv_u8 *entry2 ;
  psiconv_u8 *next1 ;
  psiconv_u8 *next2 ;
  psiconv_u8 temp ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  psiconv_u32 tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  psiconv_u32 tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  psiconv_u32 tmp___12 ;
  psiconv_u32 tmp___13 ;

  {
  {
#line 586
  tmp = psiconv_list_new(sizeof(*entry1));
#line 586
  *encoded_bytes = tmp;
  }
#line 586
  if (! tmp) {
#line 587
    res = -2;
#line 588
    goto ERROR1;
  }
#line 591
  i = 0;
  {
#line 591
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 591
    tmp___13 = psiconv_list_length(plain_bytes);
    }
#line 591
    if (! ((psiconv_u32 )i < tmp___13)) {
#line 591
      goto while_break;
    }
    {
#line 592
    tmp___0 = psiconv_list_get(plain_bytes, (psiconv_u32 )i);
#line 592
    entry1 = (psiconv_u8 *)tmp___0;
    }
#line 592
    if (! entry1) {
#line 593
      res = -2;
#line 594
      goto ERROR2;
    }
    {
#line 596
    tmp___1 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 1));
#line 596
    entry2 = (psiconv_u8 *)tmp___1;
    }
#line 596
    if (! entry2) {
#line 597
      res = -2;
#line 598
      goto ERROR2;
    }
    {
#line 600
    tmp___2 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 2));
#line 600
    next1 = (psiconv_u8 *)tmp___2;
    }
#line 600
    if (! next1) {
#line 601
      res = -2;
#line 602
      goto ERROR2;
    }
    {
#line 604
    tmp___3 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 3));
#line 604
    next2 = (psiconv_u8 *)tmp___3;
    }
#line 604
    if (! next2) {
#line 605
      res = -2;
#line 606
      goto ERROR2;
    }
    {
#line 608
    tmp___12 = psiconv_list_length(plain_bytes);
    }
#line 608
    if ((psiconv_u32 )i == tmp___12 - 4U) {
      {
#line 609
      temp = (psiconv_u8 )254;
#line 610
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 610
      if (res) {
#line 611
        goto ERROR2;
      }
      {
#line 612
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry1);
      }
#line 612
      if (res) {
#line 613
        goto ERROR2;
      }
      {
#line 614
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry2);
      }
#line 614
      if (res) {
#line 615
        goto ERROR2;
      }
      {
#line 616
      res = psiconv_list_add(*encoded_bytes, (void const   *)next1);
      }
#line 616
      if (res) {
#line 617
        goto ERROR2;
      }
      {
#line 618
      res = psiconv_list_add(*encoded_bytes, (void const   *)next2);
      }
#line 618
      if (res) {
#line 619
        goto ERROR2;
      }
#line 620
      i += 4;
    } else
#line 621
    if ((int )*next1 == (int )*entry1) {
#line 621
      if ((int )*next2 == (int )*entry2) {
#line 622
        len = 0;
        {
#line 623
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 623
          if ((int )*next1 == (int )*entry1) {
#line 623
            if ((int )*next2 == (int )*entry2) {
              {
#line 623
              tmp___6 = psiconv_list_length(plain_bytes);
              }
#line 623
              if ((psiconv_u32 )((i + 2 * len) + 4) < tmp___6) {
#line 623
                if (! (len < 128)) {
#line 623
                  goto while_break___0;
                }
              } else {
#line 623
                goto while_break___0;
              }
            } else {
#line 623
              goto while_break___0;
            }
          } else {
#line 623
            goto while_break___0;
          }
          {
#line 626
          len ++;
#line 627
          tmp___4 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len * 2));
#line 627
          next1 = (psiconv_u8 *)tmp___4;
          }
#line 627
          if (! next1) {
#line 628
            res = -2;
#line 629
            goto ERROR2;
          }
          {
#line 631
          tmp___5 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 2) + 1));
#line 631
          next2 = (psiconv_u8 *)tmp___5;
          }
#line 631
          if (! next2) {
#line 632
            res = -2;
#line 633
            goto ERROR2;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 636
        temp = (psiconv_u8 )(len - 1);
#line 637
        res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
        }
#line 637
        if (res) {
#line 638
          goto ERROR2;
        }
        {
#line 639
        res = psiconv_list_add(*encoded_bytes, (void const   *)entry1);
        }
#line 639
        if (res) {
#line 640
          goto ERROR2;
        }
        {
#line 641
        res = psiconv_list_add(*encoded_bytes, (void const   *)entry2);
        }
#line 641
        if (res) {
#line 642
          goto ERROR2;
        }
#line 643
        i += len * 2;
      } else {
#line 621
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 645
      len = 1;
      {
#line 646
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 646
        if ((int )*next1 != (int )*entry1) {
#line 646
          goto _L;
        } else
#line 646
        if ((int )*next2 != (int )*entry2) {
          _L: /* CIL Label */ 
          {
#line 646
          tmp___9 = psiconv_list_length(plain_bytes);
          }
#line 646
          if ((psiconv_u32 )((i + len * 2) + 4) < tmp___9) {
#line 646
            if (! (len < 128)) {
#line 646
              goto while_break___1;
            }
          } else {
#line 646
            goto while_break___1;
          }
        } else {
#line 646
          goto while_break___1;
        }
        {
#line 649
        len ++;
#line 650
        entry1 = next1;
#line 651
        entry2 = next2;
#line 652
        tmp___7 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len * 2));
#line 652
        next1 = (psiconv_u8 *)tmp___7;
        }
#line 652
        if (! next1) {
#line 653
          res = -2;
#line 654
          goto ERROR2;
        }
        {
#line 656
        tmp___8 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 2) + 1));
#line 656
        next2 = (psiconv_u8 *)tmp___8;
        }
#line 656
        if (! next2) {
#line 657
          res = -2;
#line 658
          goto ERROR2;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 661
      len --;
#line 662
      temp = (psiconv_u8 )(256 - len);
#line 663
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 663
      if (res) {
#line 664
        goto ERROR2;
      }
#line 665
      j = 0;
      {
#line 665
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 665
        if (! (j < len)) {
#line 665
          goto while_break___2;
        }
        {
#line 666
        tmp___10 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + j * 2));
#line 666
        next1 = (psiconv_u8 *)tmp___10;
        }
#line 666
        if (! next1) {
#line 667
          res = -2;
#line 668
          goto ERROR2;
        }
        {
#line 670
        tmp___11 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + j * 2) + 1));
#line 670
        next2 = (psiconv_u8 *)tmp___11;
        }
#line 670
        if (! next2) {
#line 671
          res = -2;
#line 672
          goto ERROR2;
        }
        {
#line 674
        res = psiconv_list_add(*encoded_bytes, (void const   *)next1);
        }
#line 674
        if (res) {
#line 675
          goto ERROR2;
        }
        {
#line 676
        res = psiconv_list_add(*encoded_bytes, (void const   *)next2);
        }
#line 676
        if (res) {
#line 677
          goto ERROR2;
        }
#line 665
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 679
      i += len * 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 682
  return (0);
  ERROR2: 
  {
#line 685
  psiconv_list_free(*encoded_bytes);
  }
  ERROR1: 
#line 687
  return (res);
}
}
#line 694 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_encode_rle24___2(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                    psiconv_pixel_bytes *encoded_bytes ) 
{ 
  int res ;
  int i ;
  int j ;
  int len ;
  psiconv_u8 *entry1 ;
  psiconv_u8 *entry2 ;
  psiconv_u8 *entry3 ;
  psiconv_u8 *next1 ;
  psiconv_u8 *next2 ;
  psiconv_u8 *next3 ;
  psiconv_u8 temp ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  psiconv_u32 tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  psiconv_u32 tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  psiconv_u32 tmp___17 ;
  psiconv_u32 tmp___18 ;

  {
  {
#line 702
  tmp = psiconv_list_new(sizeof(*entry1));
#line 702
  *encoded_bytes = tmp;
  }
#line 702
  if (! tmp) {
#line 703
    res = -2;
#line 704
    goto ERROR1;
  }
#line 707
  i = 0;
  {
#line 707
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 707
    tmp___18 = psiconv_list_length(plain_bytes);
    }
#line 707
    if (! ((psiconv_u32 )i < tmp___18)) {
#line 707
      goto while_break;
    }
    {
#line 708
    tmp___0 = psiconv_list_get(plain_bytes, (psiconv_u32 )i);
#line 708
    entry1 = (psiconv_u8 *)tmp___0;
    }
#line 708
    if (! entry1) {
#line 709
      res = -2;
#line 710
      goto ERROR2;
    }
    {
#line 712
    tmp___1 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 1));
#line 712
    entry2 = (psiconv_u8 *)tmp___1;
    }
#line 712
    if (! entry2) {
#line 713
      res = -2;
#line 714
      goto ERROR2;
    }
    {
#line 716
    tmp___2 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 2));
#line 716
    entry3 = (psiconv_u8 *)tmp___2;
    }
#line 716
    if (! entry3) {
#line 717
      res = -2;
#line 718
      goto ERROR2;
    }
    {
#line 720
    tmp___3 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 3));
#line 720
    next1 = (psiconv_u8 *)tmp___3;
    }
#line 720
    if (! next1) {
#line 721
      res = -2;
#line 722
      goto ERROR2;
    }
    {
#line 724
    tmp___4 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 4));
#line 724
    next2 = (psiconv_u8 *)tmp___4;
    }
#line 724
    if (! next2) {
#line 725
      res = -2;
#line 726
      goto ERROR2;
    }
    {
#line 728
    tmp___5 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 5));
#line 728
    next3 = (psiconv_u8 *)tmp___5;
    }
#line 728
    if (! next3) {
#line 729
      res = -2;
#line 730
      goto ERROR2;
    }
    {
#line 732
    tmp___17 = psiconv_list_length(plain_bytes);
    }
#line 732
    if ((psiconv_u32 )i == tmp___17 - 6U) {
      {
#line 733
      temp = (psiconv_u8 )254;
#line 734
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 734
      if (res) {
#line 735
        goto ERROR2;
      }
      {
#line 736
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry1);
      }
#line 736
      if (res) {
#line 737
        goto ERROR2;
      }
      {
#line 738
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry2);
      }
#line 738
      if (res) {
#line 739
        goto ERROR2;
      }
      {
#line 740
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry3);
      }
#line 740
      if (res) {
#line 741
        goto ERROR2;
      }
      {
#line 742
      res = psiconv_list_add(*encoded_bytes, (void const   *)next1);
      }
#line 742
      if (res) {
#line 743
        goto ERROR2;
      }
      {
#line 744
      res = psiconv_list_add(*encoded_bytes, (void const   *)next2);
      }
#line 744
      if (res) {
#line 745
        goto ERROR2;
      }
      {
#line 746
      res = psiconv_list_add(*encoded_bytes, (void const   *)next3);
      }
#line 746
      if (res) {
#line 747
        goto ERROR2;
      }
#line 748
      i += 4;
    } else
#line 749
    if ((int )*next1 == (int )*entry1) {
#line 749
      if ((int )*next2 == (int )*entry2) {
#line 749
        if ((int )*next3 == (int )*entry3) {
#line 751
          len = 0;
          {
#line 752
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 752
            if ((int )*next1 == (int )*entry1) {
#line 752
              if ((int )*next2 == (int )*entry2) {
#line 752
                if ((int )*next3 == (int )*entry3) {
                  {
#line 752
                  tmp___9 = psiconv_list_length(plain_bytes);
                  }
#line 752
                  if ((psiconv_u32 )((i + 3 * len) + 6) < tmp___9) {
#line 752
                    if (! (len < 128)) {
#line 752
                      goto while_break___0;
                    }
                  } else {
#line 752
                    goto while_break___0;
                  }
                } else {
#line 752
                  goto while_break___0;
                }
              } else {
#line 752
                goto while_break___0;
              }
            } else {
#line 752
              goto while_break___0;
            }
            {
#line 756
            len ++;
#line 757
            tmp___6 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len * 3));
#line 757
            next1 = (psiconv_u8 *)tmp___6;
            }
#line 757
            if (! next1) {
#line 758
              res = -2;
#line 759
              goto ERROR2;
            }
            {
#line 761
            tmp___7 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 3) + 1));
#line 761
            next2 = (psiconv_u8 *)tmp___7;
            }
#line 761
            if (! next2) {
#line 762
              res = -2;
#line 763
              goto ERROR2;
            }
            {
#line 765
            tmp___8 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 3) + 2));
#line 765
            next3 = (psiconv_u8 *)tmp___8;
            }
#line 765
            if (! next3) {
#line 766
              res = -2;
#line 767
              goto ERROR2;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 770
          temp = (psiconv_u8 )(len - 1);
#line 771
          res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
          }
#line 771
          if (res) {
#line 772
            goto ERROR2;
          }
          {
#line 773
          res = psiconv_list_add(*encoded_bytes, (void const   *)entry1);
          }
#line 773
          if (res) {
#line 774
            goto ERROR2;
          }
          {
#line 775
          res = psiconv_list_add(*encoded_bytes, (void const   *)entry2);
          }
#line 775
          if (res) {
#line 776
            goto ERROR2;
          }
          {
#line 777
          res = psiconv_list_add(*encoded_bytes, (void const   *)entry3);
          }
#line 777
          if (res) {
#line 778
            goto ERROR2;
          }
#line 779
          i += len * 3;
        } else {
#line 749
          goto _L___1;
        }
      } else {
#line 749
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 781
      len = 1;
      {
#line 782
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 782
        if ((int )*next1 != (int )*entry1) {
#line 782
          goto _L;
        } else
#line 782
        if ((int )*next2 != (int )*entry2) {
#line 782
          goto _L;
        } else
#line 782
        if ((int )*next3 != (int )*entry3) {
          _L: /* CIL Label */ 
          {
#line 782
          tmp___13 = psiconv_list_length(plain_bytes);
          }
#line 782
          if ((psiconv_u32 )((i + len * 3) + 6) < tmp___13) {
#line 782
            if (! (len < 128)) {
#line 782
              goto while_break___1;
            }
          } else {
#line 782
            goto while_break___1;
          }
        } else {
#line 782
          goto while_break___1;
        }
        {
#line 786
        len ++;
#line 787
        entry1 = next1;
#line 788
        entry2 = next2;
#line 789
        entry3 = next3;
#line 790
        tmp___10 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len * 3));
#line 790
        next1 = (psiconv_u8 *)tmp___10;
        }
#line 790
        if (! next1) {
#line 791
          res = -2;
#line 792
          goto ERROR2;
        }
        {
#line 794
        tmp___11 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 3) + 1));
#line 794
        next2 = (psiconv_u8 *)tmp___11;
        }
#line 794
        if (! next2) {
#line 795
          res = -2;
#line 796
          goto ERROR2;
        }
        {
#line 798
        tmp___12 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 3) + 2));
#line 798
        next3 = (psiconv_u8 *)tmp___12;
        }
#line 798
        if (! next3) {
#line 799
          res = -2;
#line 800
          goto ERROR2;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 803
      len --;
#line 804
      temp = (psiconv_u8 )(256 - len);
#line 805
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 805
      if (res) {
#line 806
        goto ERROR2;
      }
#line 807
      j = 0;
      {
#line 807
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 807
        if (! (j < len)) {
#line 807
          goto while_break___2;
        }
        {
#line 808
        tmp___14 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + j * 3));
#line 808
        next1 = (psiconv_u8 *)tmp___14;
        }
#line 808
        if (! next1) {
#line 809
          res = -2;
#line 810
          goto ERROR2;
        }
        {
#line 812
        tmp___15 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + j * 3) + 1));
#line 812
        next2 = (psiconv_u8 *)tmp___15;
        }
#line 812
        if (! next2) {
#line 813
          res = -2;
#line 814
          goto ERROR2;
        }
        {
#line 816
        tmp___16 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + j * 3) + 2));
#line 816
        next2 = (psiconv_u8 *)tmp___16;
        }
#line 816
        if (! next2) {
#line 817
          res = -2;
#line 818
          goto ERROR2;
        }
        {
#line 820
        res = psiconv_list_add(*encoded_bytes, (void const   *)next1);
        }
#line 820
        if (res) {
#line 821
          goto ERROR2;
        }
        {
#line 822
        res = psiconv_list_add(*encoded_bytes, (void const   *)next2);
        }
#line 822
        if (res) {
#line 823
          goto ERROR2;
        }
        {
#line 824
        res = psiconv_list_add(*encoded_bytes, (void const   *)next3);
        }
#line 824
        if (res) {
#line 825
          goto ERROR2;
        }
#line 807
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 827
      i += len * 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 830
  return (0);
  ERROR2: 
  {
#line 833
  psiconv_list_free(*encoded_bytes);
  }
  ERROR1: 
#line 835
  return (res);
}
}
#line 43 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
static struct psiconv_config_s default_config___2  = 
#line 43 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
     {3, 2, 0, 0, 0, (psiconv_bool_t )0, (psiconv_error_handler_t *)((void *)0), (psiconv_u8 )'?',
    (psiconv_ucs2 )'?', {(psiconv_ucs2 )0}, (psiconv_bool_t )0};
#line 46
static void psiconv_config_parse_statement___2(char const   *filename , int linenr ,
                                               char const   *var , int value , psiconv_config *config ) ;
#line 51
static void psiconv_config_parse_line___2(char const   *filename , int linenr , char const   *line ,
                                          psiconv_config *config ) ;
#line 54
static void psiconv_config_parse_file___2(char const   *filename , psiconv_config *config ) ;
#line 71 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
static void psiconv_config_parse_statement___2(char const   *filename , int linenr ,
                                               char const   *var , int value , psiconv_config *config ) 
{ 
  int charnr ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 78
  tmp___9 = strcasecmp(var, "verbosity");
  }
#line 78
  if (tmp___9) {
    {
#line 84
    tmp___8 = strcasecmp(var, "color");
    }
#line 84
    if (tmp___8) {
      {
#line 90
      tmp___7 = strcasecmp(var, "colordepth");
      }
#line 90
      if (tmp___7) {
        {
#line 96
        tmp___6 = strcasecmp(var, "redbits");
        }
#line 96
        if (tmp___6) {
          {
#line 102
          tmp___5 = strcasecmp(var, "greenbits");
          }
#line 102
          if (tmp___5) {
            {
#line 108
            tmp___4 = strcasecmp(var, "bluebits");
            }
#line 108
            if (tmp___4) {
              {
#line 114
              tmp___3 = strcasecmp(var, "characterset");
              }
#line 114
              if (tmp___3) {
                {
#line 121
                tmp___2 = strcasecmp(var, "unknownunicodechar");
                }
#line 121
                if (tmp___2) {
                  {
#line 128
                  tmp___1 = strcasecmp(var, "unknownepocchar");
                  }
#line 128
                  if (tmp___1) {
                    {
#line 135
                    tmp = sscanf((char const   */* __restrict  */)var, (char const   */* __restrict  */)"char%d",
                                 & charnr);
#line 135
                    tmp___0 = strlen(var);
                    }
#line 135
                    if ((size_t )tmp == tmp___0) {
#line 136
                      if (charnr < 0) {
                        {
#line 137
                        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharXXX should have XXX between 0 and 255",
                                      filename, linenr);
                        }
                      } else
#line 136
                      if (charnr > 255) {
                        {
#line 137
                        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharXXX should have XXX between 0 and 255",
                                      filename, linenr);
                        }
                      }
#line 140
                      if (value >= 1) {
#line 140
                        if (value <= 65536) {
#line 141
                          (*config)->unicode_table[charnr] = (psiconv_ucs2 )value;
                        } else {
                          {
#line 143
                          psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharXXX should be between 1 and 65535",
                                        filename, linenr);
                          }
                        }
                      } else {
                        {
#line 143
                        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharXXX should be between 1 and 65535",
                                      filename, linenr);
                        }
                      }
                    } else {
                      {
#line 147
                      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Unknown variable %s",
                                    filename, linenr, var);
                      }
                    }
                  } else
#line 129
                  if (value >= 1) {
#line 129
                    if (value < 256) {
#line 130
                      (*config)->unknown_epoc_char = (psiconv_u8 )value;
                    } else {
                      {
#line 132
                      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: UnknownEPOCChar should be between 1 and 255",
                                    filename, linenr);
                      }
                    }
                  } else {
                    {
#line 132
                    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: UnknownEPOCChar should be between 1 and 255",
                                  filename, linenr);
                    }
                  }
                } else
#line 122
                if (value >= 1) {
#line 122
                  if (value < 65536) {
#line 123
                    (*config)->unknown_unicode_char = (psiconv_ucs2 )value;
                  } else {
                    {
#line 125
                    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: UnknownUnicodeChar should be between 1 and 65535",
                                  filename, linenr);
                    }
                  }
                } else {
                  {
#line 125
                  psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: UnknownUnicodeChar should be between 1 and 65535",
                                filename, linenr);
                  }
                }
              } else
#line 115
              if (value >= 0) {
#line 115
                if (value <= 1) {
                  {
#line 116
                  psiconv_unicode_select_characterset((psiconv_config const   )*config,
                                                      value);
                  }
                } else {
                  {
#line 118
                  psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharacterSet should be between 0 and 1",
                                filename, linenr);
                  }
                }
              } else {
                {
#line 118
                psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharacterSet should be between 0 and 1",
                              filename, linenr);
                }
              }
            } else
#line 109
            if (value >= 0) {
#line 109
              if (value <= 32) {
#line 110
                (*config)->bluebits = value;
              } else {
                {
#line 112
                psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: BlueBits should be between 1 and 32 or 0",
                              filename, linenr);
                }
              }
            } else {
              {
#line 112
              psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: BlueBits should be between 1 and 32 or 0",
                            filename, linenr);
              }
            }
          } else
#line 103
          if (value >= 0) {
#line 103
            if (value <= 32) {
#line 104
              (*config)->greenbits = value;
            } else {
              {
#line 106
              psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: GreenBits should be between 1 and 32 or 0",
                            filename, linenr);
              }
            }
          } else {
            {
#line 106
            psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: GreenBits should be between 1 and 32 or 0",
                          filename, linenr);
            }
          }
        } else
#line 97
        if (value >= 0) {
#line 97
          if (value <= 32) {
#line 98
            (*config)->redbits = value;
          } else {
            {
#line 100
            psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: RedBits should be between 1 and 32 or 0",
                          filename, linenr);
            }
          }
        } else {
          {
#line 100
          psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: RedBits should be between 1 and 32 or 0",
                        filename, linenr);
          }
        }
      } else
#line 91
      if (value > 0) {
#line 91
        if (value <= 32) {
#line 92
          (*config)->colordepth = value;
        } else {
          {
#line 94
          psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: ColorDepth should be between 1 and 32",
                        filename, linenr);
          }
        }
      } else {
        {
#line 94
        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: ColorDepth should be between 1 and 32",
                      filename, linenr);
        }
      }
    } else
#line 85
    if (value == 0) {
#line 86
      (*config)->color = (psiconv_bool_t )value;
    } else
#line 85
    if (value == 1) {
#line 86
      (*config)->color = (psiconv_bool_t )value;
    } else {
      {
#line 88
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Color should be 0 or 1",
                    filename, linenr);
      }
    }
  } else
#line 79
  if (value >= 1) {
#line 79
    if (value <= 5) {
#line 80
      (*config)->verbosity = value;
    } else {
      {
#line 82
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Verbosity should be between 1 and 5",
                    filename, linenr);
      }
    }
  } else {
    {
#line 82
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Verbosity should be between 1 and 5",
                  filename, linenr);
    }
  }
  {
#line 150
  psiconv_debug(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Set variable %s to %d",
                filename, linenr, var, value);
  }
#line 152
  return;
}
}
#line 155 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
static void psiconv_config_parse_line___2(char const   *filename , int linenr , char const   *line ,
                                          psiconv_config *config ) 
{ 
  int sovar ;
  int eovar ;
  int soval ;
  int eoval ;
  int eol ;
  char *var ;
  long val ;
  void *tmp ;

  {
  {
#line 163
  psiconv_debug(*config, 0, (psiconv_u32 )0, "Going to parse line %d: %s", linenr,
                line);
#line 164
  sovar = 0;
  }
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (*(line + sovar)) {
#line 165
      if (! ((int const   )*(line + sovar) < 32)) {
#line 165
        goto while_break;
      }
    } else {
#line 165
      goto while_break;
    }
#line 166
    sovar ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  if (! *(line + sovar)) {
#line 168
    return;
  } else
#line 167
  if ((int const   )*(line + sovar) == 35) {
#line 168
    return;
  }
#line 169
  eovar = sovar;
  {
#line 170
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 170
    if (*(line + eovar)) {
#line 170
      if ((int const   )*(line + eovar) >= 65) {
#line 170
        if (! ((int const   )*(line + eovar) <= 90)) {
#line 170
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 170
      if ((int const   )*(line + eovar) >= 97) {
#line 170
        if (! ((int const   )*(line + eovar) <= 122)) {
#line 170
          goto while_break___0;
        }
      } else {
#line 170
        goto while_break___0;
      }
    } else {
#line 170
      goto while_break___0;
    }
#line 172
    eovar ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 173
  if (sovar == eovar) {
    {
#line 174
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (no variable found)",
                  filename, linenr);
    }
#line 176
    return;
  }
#line 178
  soval = eovar;
  {
#line 179
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 179
    if (*(line + soval)) {
#line 179
      if (! ((int const   )*(line + soval) <= 32)) {
#line 179
        goto while_break___1;
      }
    } else {
#line 179
      goto while_break___1;
    }
#line 180
    soval ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 181
  if ((int const   )*(line + soval) != 61) {
    {
#line 182
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (no = token found)",
                  filename, linenr);
    }
#line 184
    return;
  }
#line 186
  soval ++;
  {
#line 187
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 187
    if (*(line + soval)) {
#line 187
      if (! ((int const   )*(line + soval) <= 32)) {
#line 187
        goto while_break___2;
      }
    } else {
#line 187
      goto while_break___2;
    }
#line 188
    soval ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 189
  eoval = soval;
  {
#line 190
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 190
    if (*(line + eoval)) {
#line 190
      if ((int const   )*(line + eoval) >= 48) {
#line 190
        if (! ((int const   )*(line + eoval) <= 57)) {
#line 190
          goto while_break___3;
        }
      } else {
#line 190
        goto while_break___3;
      }
    } else {
#line 190
      goto while_break___3;
    }
#line 191
    eoval ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 192
  if (eoval == soval) {
    {
#line 193
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (no value found)",
                  filename, linenr);
    }
#line 195
    return;
  }
#line 197
  if (soval - eoval > 7) {
    {
#line 198
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (value too large)",
                  filename, linenr);
    }
#line 200
    return;
  }
#line 202
  eol = eoval;
  {
#line 203
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 203
    if (*(line + eol)) {
#line 203
      if (! ((int const   )*(line + eol) < 32)) {
#line 203
        goto while_break___4;
      }
    } else {
#line 203
      goto while_break___4;
    }
#line 204
    eol ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 205
  if (*(line + eol)) {
    {
#line 206
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (trailing garbage)",
                  filename, linenr);
    }
#line 208
    return;
  }
  {
#line 211
  tmp = malloc((size_t )((eovar - sovar) + 1));
#line 211
  var = (char *)tmp;
#line 212
  memcpy((void */* __restrict  */)var, (void const   */* __restrict  */)(line + sovar),
         (size_t )(eovar - sovar));
#line 213
  *(var + (eovar - sovar)) = (char)0;
#line 215
  val = atol(line + soval);
#line 217
  psiconv_config_parse_statement___2(filename, linenr, (char const   *)var, (int )val,
                                     config);
#line 218
  free((void *)var);
  }
#line 219
  return;
}
}
#line 222 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
static void psiconv_config_parse_file___2(char const   *filename , psiconv_config *config ) 
{ 
  int file ;
  int linenr ;
  struct stat stat_buf ;
  off_t filesize ;
  off_t bytes_left ;
  off_t bytes_read ;
  off_t sol ;
  off_t eol ;
  char *filebuffer ;
  char *filebuffer_ptr ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 229
  psiconv_progress(*config, 0, (psiconv_u32 )0, "Going to access configuration file %s",
                   filename);
#line 233
  file = open(filename, 0);
  }
#line 233
  if (file == -1) {
#line 234
    goto ERROR0;
  }
  {
#line 237
  tmp___0 = fstat(file, & stat_buf);
  }
#line 237
  if (tmp___0) {
    {
#line 238
    tmp = close(file);
    }
#line 238
    if (tmp) {
      {
#line 239
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Couldn\'t close file",
                    filename);
      }
    }
#line 241
    return;
  }
  {
#line 244
  filesize = stat_buf.st_size;
#line 245
  tmp___1 = malloc((size_t )(filesize + 1L));
#line 245
  filebuffer = (char *)tmp___1;
  }
#line 245
  if (! filebuffer) {
    {
#line 246
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Out of memory error",
                  filename);
    }
#line 248
    goto ERROR1;
  }
#line 251
  filebuffer_ptr = filebuffer;
#line 252
  bytes_left = filesize;
#line 253
  bytes_read = (off_t )1;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (bytes_read > 0L) {
#line 254
      if (! bytes_left) {
#line 254
        goto while_break;
      }
    } else {
#line 254
      goto while_break;
    }
    {
#line 255
    bytes_read = read(file, (void *)filebuffer_ptr, (size_t )bytes_left);
    }
#line 256
    if (bytes_read > 0L) {
#line 257
      filebuffer_ptr += bytes_read;
#line 258
      bytes_left -= bytes_read;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  if (bytes_left) {
#line 263
    if (bytes_left != filesize) {
      {
#line 264
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Couldn\'t read file into memory",
                    filename);
      }
#line 266
      goto ERROR2;
    }
  }
  {
#line 269
  tmp___2 = close(file);
  }
#line 269
  if (tmp___2) {
    {
#line 270
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Couldn\'t close file",
                  filename);
#line 272
    file = -1;
    }
#line 273
    goto ERROR2;
  }
  {
#line 275
  file = -1;
#line 277
  psiconv_progress(*config, 0, (psiconv_u32 )0, "Going to parse configuration file %s: ",
                   filename);
#line 280
  linenr = 0;
#line 281
  sol = (off_t )0;
  }
  {
#line 283
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 283
    if (! (sol < filesize)) {
#line 283
      goto while_break___0;
    }
#line 284
    linenr ++;
#line 285
    eol = sol;
    {
#line 286
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 286
      if (eol < filesize) {
#line 286
        if ((int )*(filebuffer + eol) != 13) {
#line 286
          if ((int )*(filebuffer + eol) != 10) {
#line 286
            if (! ((int )*(filebuffer + eol) != 0)) {
#line 286
              goto while_break___1;
            }
          } else {
#line 286
            goto while_break___1;
          }
        } else {
#line 286
          goto while_break___1;
        }
      } else {
#line 286
        goto while_break___1;
      }
#line 288
      eol ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 290
    if (eol < filesize) {
#line 290
      if ((int )*(filebuffer + eol) == 0) {
        {
#line 291
        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Unexpected character \000 found",
                      filename, linenr);
        }
#line 293
        goto ERROR2;
      }
    }
#line 295
    if (eol < filesize + 1L) {
#line 295
      if ((int )*(filebuffer + eol) == 13) {
#line 295
        if ((int )*(filebuffer + (eol + 1L)) == 10) {
#line 298
          *(filebuffer + eol) = (char)0;
#line 299
          eol ++;
        } else {
#line 295
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 295
      if ((int )*(filebuffer + eol) == 10) {
#line 295
        if ((int )*(filebuffer + (eol + 1L)) == 13) {
#line 298
          *(filebuffer + eol) = (char)0;
#line 299
          eol ++;
        }
      }
    }
    {
#line 301
    *(filebuffer + eol) = (char)0;
#line 302
    psiconv_config_parse_line___2(filename, linenr, (char const   *)(filebuffer + sol),
                                  config);
#line 303
    sol = eol + 1L;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 305
  free((void *)filebuffer);
  }
#line 306
  return;
  ERROR2: 
  {
#line 309
  free((void *)filebuffer);
  }
  ERROR1: 
#line 311
  if (file != -1) {
    {
#line 311
    tmp___3 = close(file);
    }
#line 311
    if (tmp___3) {
      {
#line 312
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Couldn\'t close file",
                    filename);
      }
    }
  }
  ERROR0: 
#line 315
  return;
}
}
#line 55 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/psiconv.h"
psiconv_list fileformat_list  ;
#line 35 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/general.h"
void output_char(psiconv_config config , psiconv_list list , psiconv_ucs2 character ,
                 encoding enc ) ;
#line 30 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen.h"
void init_txt(void) ;
#line 35 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_txt.c"
static void output_para(psiconv_config const   config , psiconv_list list , psiconv_paragraph const   para ,
                        encoding encoding_type ) ;
#line 37
static void gen_word(psiconv_config const   config , psiconv_list list , psiconv_word_f wf ,
                     encoding encoding_type ) ;
#line 39
static void gen_texted(psiconv_config const   config , psiconv_list list , psiconv_texted_f tf ,
                       encoding encoding_type ) ;
#line 41
static int gen_txt(psiconv_config const   config , psiconv_list list , psiconv_file const   file ,
                   char const   *dest , encoding const   encoding_type ) ;
#line 45 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_txt.c"
static struct fileformat_s ff  =    {"ASCII", "Plain text without much layout", 3, & gen_txt};
#line 54 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_txt.c"
static void output_para(psiconv_config const   config , psiconv_list list , psiconv_paragraph const   para ,
                        encoding encoding_type ) 
{ 
  int i ;
  int tmp ;

  {
#line 58
  if (para) {
#line 58
    if (para->base_paragraph) {
#line 58
      if ((para->base_paragraph)->bullet) {
#line 58
        if (((para->base_paragraph)->bullet)->on) {
          {
#line 60
          output_char((psiconv_config )config, list, ((para->base_paragraph)->bullet)->character,
                      encoding_type);
#line 62
          output_char((psiconv_config )config, list, (psiconv_ucs2 )' ', encoding_type);
#line 63
          output_char((psiconv_config )config, list, (psiconv_ucs2 )' ', encoding_type);
#line 64
          output_char((psiconv_config )config, list, (psiconv_ucs2 )' ', encoding_type);
          }
        }
      }
    }
  }
#line 66
  if (para) {
#line 66
    if (para->text) {
#line 67
      i = 0;
      {
#line 67
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 67
        tmp = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
        }
#line 67
        if (! (i < tmp)) {
#line 67
          goto while_break;
        }
        {
#line 71
        if ((int )*(para->text + i) == 8) {
#line 71
          goto case_8;
        }
#line 71
        if ((int )*(para->text + i) == 7) {
#line 71
          goto case_8;
        }
#line 71
        if ((int )*(para->text + i) == 6) {
#line 71
          goto case_8;
        }
#line 75
        if ((int )*(para->text + i) == 10) {
#line 75
          goto case_10;
        }
#line 75
        if ((int )*(para->text + i) == 9) {
#line 75
          goto case_10;
        }
#line 79
        if ((int )*(para->text + i) == 12) {
#line 79
          goto case_12;
        }
#line 79
        if ((int )*(para->text + i) == 11) {
#line 79
          goto case_12;
        }
#line 82
        if ((int )*(para->text + i) == 15) {
#line 82
          goto case_15;
        }
#line 106
        if ((int )*(para->text + i) == 31) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 30) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 29) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 28) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 26) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 25) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 24) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 23) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 22) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 21) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 20) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 19) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 18) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 17) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 16) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 14) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 5) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 4) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 3) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 2) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 1) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 0) {
#line 106
          goto case_31;
        }
#line 108
        goto switch_default;
        case_8: /* CIL Label */ 
        case_7: /* CIL Label */ 
        case_6: /* CIL Label */ 
        {
#line 72
        output_char((psiconv_config )config, list, (psiconv_ucs2 )'\n', encoding_type);
        }
#line 73
        goto switch_break;
        case_10: /* CIL Label */ 
        case_9: /* CIL Label */ 
        {
#line 76
        output_char((psiconv_config )config, list, (psiconv_ucs2 )'\t', encoding_type);
        }
#line 77
        goto switch_break;
        case_12: /* CIL Label */ 
        case_11: /* CIL Label */ 
        {
#line 80
        output_char((psiconv_config )config, list, (psiconv_ucs2 )'-', encoding_type);
        }
#line 81
        goto switch_break;
        case_15: /* CIL Label */ 
        {
#line 83
        output_char((psiconv_config )config, list, (psiconv_ucs2 )' ', encoding_type);
        }
#line 84
        goto switch_break;
        case_31: /* CIL Label */ 
        case_30: /* CIL Label */ 
        case_29: /* CIL Label */ 
        case_28: /* CIL Label */ 
        case_26: /* CIL Label */ 
        case_25: /* CIL Label */ 
        case_24: /* CIL Label */ 
        case_23: /* CIL Label */ 
        case_22: /* CIL Label */ 
        case_21: /* CIL Label */ 
        case_20: /* CIL Label */ 
        case_19: /* CIL Label */ 
        case_18: /* CIL Label */ 
        case_17: /* CIL Label */ 
        case_16: /* CIL Label */ 
        case_14: /* CIL Label */ 
        case_5: /* CIL Label */ 
        case_4: /* CIL Label */ 
        case_3: /* CIL Label */ 
        case_2: /* CIL Label */ 
        case_1: /* CIL Label */ 
        case_0: /* CIL Label */ 
#line 107
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 109
        output_char((psiconv_config )config, list, *(para->text + i), encoding_type);
        }
#line 110
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 67
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 112
      output_char((psiconv_config )config, list, (psiconv_ucs2 )'\n', encoding_type);
      }
    }
  }
#line 114
  return;
}
}
#line 116 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_txt.c"
static void gen_word(psiconv_config const   config , psiconv_list list , psiconv_word_f wf ,
                     encoding encoding_type ) 
{ 
  int i ;
  psiconv_paragraph para ;
  void *tmp ;
  psiconv_u32 tmp___0 ;
  void *tmp___1 ;
  psiconv_u32 tmp___2 ;
  void *tmp___3 ;
  psiconv_u32 tmp___4 ;

  {
#line 122
  if (wf) {
#line 122
    if (wf->page_sec) {
#line 122
      if ((wf->page_sec)->header) {
#line 122
        if (((wf->page_sec)->header)->text) {
#line 122
          if ((((wf->page_sec)->header)->text)->paragraphs) {
#line 124
            i = 0;
            {
#line 124
            while (1) {
              while_continue: /* CIL Label */ ;
              {
#line 124
              tmp___0 = psiconv_list_length((psiconv_list const   )(((wf->page_sec)->header)->text)->paragraphs);
              }
#line 124
              if (! ((psiconv_u32 )i < tmp___0)) {
#line 124
                goto while_break;
              }
              {
#line 127
              tmp = psiconv_list_get((psiconv_list const   )(((wf->page_sec)->header)->text)->paragraphs,
                                     (psiconv_u32 )i);
#line 127
              para = (psiconv_paragraph )tmp;
#line 129
              output_para(config, list, (psiconv_paragraph const   )para, encoding_type);
#line 124
              i ++;
              }
            }
            while_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
  {
#line 132
  output_char((psiconv_config )config, list, (psiconv_ucs2 )'\n', encoding_type);
  }
#line 134
  if (wf) {
#line 134
    if (wf->paragraphs) {
#line 135
      i = 0;
      {
#line 135
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 135
        tmp___2 = psiconv_list_length((psiconv_list const   )wf->paragraphs);
        }
#line 135
        if (! ((psiconv_u32 )i < tmp___2)) {
#line 135
          goto while_break___0;
        }
        {
#line 136
        tmp___1 = psiconv_list_get((psiconv_list const   )wf->paragraphs, (psiconv_u32 )i);
#line 136
        para = (psiconv_paragraph )tmp___1;
#line 137
        output_para(config, list, (psiconv_paragraph const   )para, encoding_type);
#line 135
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 140
  output_char((psiconv_config )config, list, (psiconv_ucs2 )'\n', encoding_type);
  }
#line 142
  if (wf) {
#line 142
    if (wf->page_sec) {
#line 142
      if ((wf->page_sec)->footer) {
#line 142
        if (((wf->page_sec)->footer)->text) {
#line 142
          if ((((wf->page_sec)->footer)->text)->paragraphs) {
#line 144
            i = 0;
            {
#line 144
            while (1) {
              while_continue___1: /* CIL Label */ ;
              {
#line 144
              tmp___4 = psiconv_list_length((psiconv_list const   )(((wf->page_sec)->footer)->text)->paragraphs);
              }
#line 144
              if (! ((psiconv_u32 )i < tmp___4)) {
#line 144
                goto while_break___1;
              }
              {
#line 147
              tmp___3 = psiconv_list_get((psiconv_list const   )(((wf->page_sec)->footer)->text)->paragraphs,
                                         (psiconv_u32 )i);
#line 147
              para = (psiconv_paragraph )tmp___3;
#line 148
              output_para(config, list, (psiconv_paragraph const   )para, encoding_type);
#line 144
              i ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
#line 151
  return;
}
}
#line 153 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_txt.c"
static void gen_texted(psiconv_config const   config , psiconv_list list , psiconv_texted_f tf ,
                       encoding encoding_type ) 
{ 
  int i ;
  psiconv_paragraph para ;
  void *tmp ;
  psiconv_u32 tmp___0 ;
  void *tmp___1 ;
  psiconv_u32 tmp___2 ;
  void *tmp___3 ;
  psiconv_u32 tmp___4 ;

  {
#line 159
  if (tf) {
#line 159
    if (tf->page_sec) {
#line 159
      if ((tf->page_sec)->header) {
#line 159
        if (((tf->page_sec)->header)->text) {
#line 159
          if ((((tf->page_sec)->header)->text)->paragraphs) {
#line 161
            i = 0;
            {
#line 161
            while (1) {
              while_continue: /* CIL Label */ ;
              {
#line 161
              tmp___0 = psiconv_list_length((psiconv_list const   )(((tf->page_sec)->header)->text)->paragraphs);
              }
#line 161
              if (! ((psiconv_u32 )i < tmp___0)) {
#line 161
                goto while_break;
              }
              {
#line 164
              tmp = psiconv_list_get((psiconv_list const   )(((tf->page_sec)->header)->text)->paragraphs,
                                     (psiconv_u32 )i);
#line 164
              para = (psiconv_paragraph )tmp;
#line 166
              output_para(config, list, (psiconv_paragraph const   )para, encoding_type);
#line 161
              i ++;
              }
            }
            while_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
  {
#line 169
  output_char((psiconv_config )config, list, (psiconv_ucs2 )'\n', encoding_type);
  }
#line 171
  if (tf) {
#line 171
    if (tf->texted_sec) {
#line 171
      if ((tf->texted_sec)->paragraphs) {
#line 172
        i = 0;
        {
#line 172
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 172
          tmp___2 = psiconv_list_length((psiconv_list const   )(tf->texted_sec)->paragraphs);
          }
#line 172
          if (! ((psiconv_u32 )i < tmp___2)) {
#line 172
            goto while_break___0;
          }
          {
#line 173
          tmp___1 = psiconv_list_get((psiconv_list const   )(tf->texted_sec)->paragraphs,
                                     (psiconv_u32 )i);
#line 173
          para = (psiconv_paragraph )tmp___1;
#line 174
          output_para(config, list, (psiconv_paragraph const   )para, encoding_type);
#line 172
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 177
  output_char((psiconv_config )config, list, (psiconv_ucs2 )'\n', encoding_type);
  }
#line 179
  if (tf) {
#line 179
    if (tf->page_sec) {
#line 179
      if ((tf->page_sec)->footer) {
#line 179
        if (((tf->page_sec)->footer)->text) {
#line 179
          if ((((tf->page_sec)->footer)->text)->paragraphs) {
#line 181
            i = 0;
            {
#line 181
            while (1) {
              while_continue___1: /* CIL Label */ ;
              {
#line 181
              tmp___4 = psiconv_list_length((psiconv_list const   )(((tf->page_sec)->footer)->text)->paragraphs);
              }
#line 181
              if (! ((psiconv_u32 )i < tmp___4)) {
#line 181
                goto while_break___1;
              }
              {
#line 184
              tmp___3 = psiconv_list_get((psiconv_list const   )(((tf->page_sec)->footer)->text)->paragraphs,
                                         (psiconv_u32 )i);
#line 184
              para = (psiconv_paragraph )tmp___3;
#line 185
              output_para(config, list, (psiconv_paragraph const   )para, encoding_type);
#line 181
              i ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
#line 188
  return;
}
}
#line 190 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_txt.c"
static int gen_txt(psiconv_config const   config , psiconv_list list , psiconv_file const   file ,
                   char const   *dest , encoding const   encoding_type ) 
{ 


  {
#line 194
  if ((unsigned int )file->type == 1U) {
    {
#line 195
    gen_word(config, list, (psiconv_word_f )file->file, (encoding )encoding_type);
    }
#line 196
    return (0);
  } else
#line 197
  if ((unsigned int )file->type == 2U) {
    {
#line 198
    gen_texted(config, list, (psiconv_texted_f )file->file, (encoding )encoding_type);
    }
#line 199
    return (0);
  } else {
#line 201
    return (-1);
  }
}
}
#line 204 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_txt.c"
void init_txt(void) 
{ 


  {
  {
#line 206
  psiconv_list_add(fileformat_list, (void const   *)(& ff));
  }
#line 207
  return;
}
}
#line 689 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 45 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/general.h"
void output_simple_chars(psiconv_config config , psiconv_list list , char *string ,
                         encoding enc ) ;
#line 35 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_html4.c"
static void text(psiconv_config const   config , psiconv_list list , psiconv_string_t data ,
                 encoding const   enc ) ;
#line 37
static void header(psiconv_config const   config , psiconv_list list , encoding const   enc ) ;
#line 39
static void footer(psiconv_config const   config , psiconv_list list , encoding const   enc ) ;
#line 41
static void characters(psiconv_config const   config , psiconv_list list , psiconv_string_t const   textstr ,
                       psiconv_character_layout const   layout , encoding const   enc ) ;
#line 44
static void paragraph(psiconv_config const   config , psiconv_list list , psiconv_paragraph para ,
                      encoding const   enc ) ;
#line 46
static void paragraphs(psiconv_config const   config , psiconv_list list , psiconv_text_and_layout paragraphs___3 ,
                       encoding const   enc ) ;
#line 48
static void gen_word___0(psiconv_config const   config , psiconv_list list , psiconv_word_f const   file ,
                         encoding const   enc ) ;
#line 50
static void gen_texted___0(psiconv_config const   config , psiconv_list list , psiconv_texted_f const   file ,
                           encoding const   enc ) ;
#line 52
static int gen_html4(psiconv_config const   config , psiconv_list list , psiconv_file const   file ,
                     char const   *dest , encoding const   enc ) ;
#line 57 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_html4.c"
static void text(psiconv_config const   config , psiconv_list list , psiconv_string_t data ,
                 encoding const   enc ) 
{ 
  int i ;
  int tmp ;

  {
#line 61
  i = 0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 61
    tmp = psiconv_unicode_strlen((psiconv_ucs2 const   *)data);
    }
#line 61
    if (! (i < tmp)) {
#line 61
      goto while_break;
    }
#line 62
    if ((int )*(data + i) == 6) {
      {
#line 63
      output_simple_chars((psiconv_config )config, list, (char *)"<BR>", (encoding )enc);
      }
    } else
#line 62
    if ((int )*(data + i) == 7) {
      {
#line 63
      output_simple_chars((psiconv_config )config, list, (char *)"<BR>", (encoding )enc);
      }
    } else
#line 62
    if ((int )*(data + i) == 8) {
      {
#line 63
      output_simple_chars((psiconv_config )config, list, (char *)"<BR>", (encoding )enc);
      }
    } else
#line 64
    if ((int )*(data + i) == 11) {
      {
#line 65
      output_simple_chars((psiconv_config )config, list, (char *)"-", (encoding )enc);
      }
    } else
#line 64
    if ((int )*(data + i) == 12) {
      {
#line 65
      output_simple_chars((psiconv_config )config, list, (char *)"-", (encoding )enc);
      }
    } else
#line 66
    if ((int )*(data + i) == 15) {
      {
#line 67
      output_simple_chars((psiconv_config )config, list, (char *)" ", (encoding )enc);
      }
    } else
#line 66
    if ((int )*(data + i) == 9) {
      {
#line 67
      output_simple_chars((psiconv_config )config, list, (char *)" ", (encoding )enc);
      }
    } else
#line 66
    if ((int )*(data + i) == 10) {
      {
#line 67
      output_simple_chars((psiconv_config )config, list, (char *)" ", (encoding )enc);
      }
    } else
#line 68
    if ((int )*(data + i) >= 32) {
      {
#line 69
      output_char((psiconv_config )config, list, *(data + i), (encoding )enc);
      }
    }
#line 61
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return;
}
}
#line 73 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_html4.c"
static void header(psiconv_config const   config , psiconv_list list , encoding const   enc ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 75
  output_simple_chars((psiconv_config )config, list, (char *)"<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n",
                      (encoding )enc);
#line 79
  output_simple_chars((psiconv_config )config, list, (char *)"<HTML>\n", (encoding )enc);
#line 80
  output_simple_chars((psiconv_config )config, list, (char *)"<HEAD>\n", (encoding )enc);
#line 81
  output_simple_chars((psiconv_config )config, list, (char *)"<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=",
                      (encoding )enc);
  }
#line 83
  if ((unsigned int const   )enc == 0U) {
#line 83
    tmp___1 = "UTF-8";
  } else {
#line 83
    if ((unsigned int const   )enc == 1U) {
#line 83
      tmp___0 = "UTF-16BE";
    } else {
#line 83
      if ((unsigned int const   )enc == 3U) {
#line 83
        tmp = "US-ASCII";
      } else {
#line 83
        tmp = "";
      }
#line 83
      tmp___0 = tmp;
    }
#line 83
    tmp___1 = tmp___0;
  }
  {
#line 83
  output_simple_chars((psiconv_config )config, list, (char *)tmp___1, (encoding )enc);
#line 87
  output_simple_chars((psiconv_config )config, list, (char *)"\">\n", (encoding )enc);
#line 88
  output_simple_chars((psiconv_config )config, list, (char *)"<TITLE>EPOC32 file converted by psiconv</TITLE>\n",
                      (encoding )enc);
#line 90
  output_simple_chars((psiconv_config )config, list, (char *)"</HEAD>\n", (encoding )enc);
#line 91
  output_simple_chars((psiconv_config )config, list, (char *)"<BODY>\n", (encoding )enc);
  }
#line 92
  return;
}
}
#line 94 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_html4.c"
static void footer(psiconv_config const   config , psiconv_list list , encoding const   enc ) 
{ 


  {
  {
#line 96
  output_simple_chars((psiconv_config )config, list, (char *)"</BODY>\n", (encoding )enc);
#line 97
  output_simple_chars((psiconv_config )config, list, (char *)"</HTML>\n", (encoding )enc);
  }
#line 98
  return;
}
}
#line 100 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_html4.c"
int character_layout_equal(psiconv_character_layout const   l1 , psiconv_character_layout const   l2 ) 
{ 
  int font_size1 ;
  int font_size2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 105
  if (l1->font_size < (psiconv_size_t )8) {
#line 105
    font_size1 = 1;
  } else {
#line 105
    if (l1->font_size < (psiconv_size_t )10) {
#line 105
      tmp___3 = 2;
    } else {
#line 105
      if (l1->font_size < (psiconv_size_t )13) {
#line 105
        tmp___2 = 3;
      } else {
#line 105
        if (l1->font_size < (psiconv_size_t )17) {
#line 105
          tmp___1 = 4;
        } else {
#line 105
          if (l1->font_size < (psiconv_size_t )24) {
#line 105
            tmp___0 = 5;
          } else {
#line 105
            if (l1->font_size < (psiconv_size_t )36) {
#line 105
              tmp = 6;
            } else {
#line 105
              tmp = 7;
            }
#line 105
            tmp___0 = tmp;
          }
#line 105
          tmp___1 = tmp___0;
        }
#line 105
        tmp___2 = tmp___1;
      }
#line 105
      tmp___3 = tmp___2;
    }
#line 105
    font_size1 = tmp___3;
  }
#line 111
  if (l2->font_size < (psiconv_size_t )8) {
#line 111
    font_size2 = 1;
  } else {
#line 111
    if (l2->font_size < (psiconv_size_t )10) {
#line 111
      tmp___8 = 2;
    } else {
#line 111
      if (l2->font_size < (psiconv_size_t )13) {
#line 111
        tmp___7 = 3;
      } else {
#line 111
        if (l2->font_size < (psiconv_size_t )17) {
#line 111
          tmp___6 = 4;
        } else {
#line 111
          if (l2->font_size < (psiconv_size_t )24) {
#line 111
            tmp___5 = 5;
          } else {
#line 111
            if (l2->font_size < (psiconv_size_t )36) {
#line 111
              tmp___4 = 6;
            } else {
#line 111
              tmp___4 = 7;
            }
#line 111
            tmp___5 = tmp___4;
          }
#line 111
          tmp___6 = tmp___5;
        }
#line 111
        tmp___7 = tmp___6;
      }
#line 111
      tmp___8 = tmp___7;
    }
#line 111
    font_size2 = tmp___8;
  }
#line 118
  if (l1) {
#line 118
    if (l2) {
#line 118
      if ((int )(l1->color)->red == (int )(l2->color)->red) {
#line 118
        if ((int )(l1->color)->green == (int )(l2->color)->green) {
#line 118
          if ((int )(l1->color)->blue == (int )(l2->color)->blue) {
#line 118
            if (font_size1 == font_size2) {
#line 118
              if ((unsigned int )l1->italic == (unsigned int )l2->italic) {
#line 118
                if ((unsigned int )l1->bold == (unsigned int )l2->bold) {
#line 118
                  if ((unsigned int )l1->super_sub == (unsigned int )l2->super_sub) {
#line 118
                    if ((unsigned int )l1->underline == (unsigned int )l2->underline) {
#line 118
                      if ((unsigned int )l1->strikethrough == (unsigned int )l2->strikethrough) {
#line 118
                        if ((unsigned int )(l1->font)->screenfont == (unsigned int )(l2->font)->screenfont) {
#line 118
                          tmp___9 = 1;
                        } else {
#line 118
                          tmp___9 = 0;
                        }
                      } else {
#line 118
                        tmp___9 = 0;
                      }
                    } else {
#line 118
                      tmp___9 = 0;
                    }
                  } else {
#line 118
                    tmp___9 = 0;
                  }
                } else {
#line 118
                  tmp___9 = 0;
                }
              } else {
#line 118
                tmp___9 = 0;
              }
            } else {
#line 118
              tmp___9 = 0;
            }
          } else {
#line 118
            tmp___9 = 0;
          }
        } else {
#line 118
          tmp___9 = 0;
        }
      } else {
#line 118
        tmp___9 = 0;
      }
    } else {
#line 118
      tmp___9 = 0;
    }
  } else {
#line 118
    tmp___9 = 0;
  }
#line 118
  return (tmp___9);
}
}
#line 131 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_html4.c"
static void characters(psiconv_config const   config , psiconv_list list , psiconv_string_t const   textstr ,
                       psiconv_character_layout const   layout , encoding const   enc ) 
{ 
  char tempstr[100] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;

  {
  {
#line 137
  output_simple_chars((psiconv_config )config, list, (char *)"<FONT face=\"", (encoding )enc);
  }
#line 138
  if ((unsigned int )(layout->font)->screenfont == 3U) {
#line 138
    tmp___2 = "serif";
  } else {
#line 138
    if ((unsigned int )(layout->font)->screenfont == 1U) {
#line 138
      tmp___1 = "sans-serif";
    } else {
#line 138
      if ((unsigned int )(layout->font)->screenfont == 2U) {
#line 138
        tmp___0 = "monospace";
      } else {
#line 138
        if ((unsigned int )(layout->font)->screenfont == 0U) {
#line 138
          tmp = "fantasy";
        } else {
#line 138
          tmp = "";
        }
#line 138
        tmp___0 = tmp;
      }
#line 138
      tmp___1 = tmp___0;
    }
#line 138
    tmp___2 = tmp___1;
  }
  {
#line 138
  output_simple_chars((psiconv_config )config, list, (char *)tmp___2, (encoding )enc);
#line 144
  output_simple_chars((psiconv_config )config, list, (char *)"\"", (encoding )enc);
  }
#line 146
  if (layout->font_size < (psiconv_size_t )10) {
#line 146
    goto _L;
  } else
#line 146
  if (layout->font_size >= (psiconv_size_t )13) {
    _L: /* CIL Label */ 
    {
#line 147
    output_simple_chars((psiconv_config )config, list, (char *)" size=", (encoding )enc);
    }
#line 148
    if (layout->font_size < (psiconv_size_t )8) {
#line 148
      tmp___8 = "1";
    } else {
#line 148
      if (layout->font_size < (psiconv_size_t )10) {
#line 148
        tmp___7 = "2";
      } else {
#line 148
        if (layout->font_size < (psiconv_size_t )13) {
#line 148
          tmp___6 = "3";
        } else {
#line 148
          if (layout->font_size < (psiconv_size_t )17) {
#line 148
            tmp___5 = "4";
          } else {
#line 148
            if (layout->font_size < (psiconv_size_t )24) {
#line 148
              tmp___4 = "5";
            } else {
#line 148
              if (layout->font_size < (psiconv_size_t )36) {
#line 148
                tmp___3 = "6";
              } else {
#line 148
                tmp___3 = "7";
              }
#line 148
              tmp___4 = tmp___3;
            }
#line 148
            tmp___5 = tmp___4;
          }
#line 148
          tmp___6 = tmp___5;
        }
#line 148
        tmp___7 = tmp___6;
      }
#line 148
      tmp___8 = tmp___7;
    }
    {
#line 148
    output_simple_chars((psiconv_config )config, list, (char *)tmp___8, (encoding )enc);
    }
  }
#line 156
  if ((int )(layout->color)->red != 0) {
    {
#line 158
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%02x%02x%02x",
             (int )(layout->color)->red, (int )(layout->color)->green, (int )(layout->color)->blue);
#line 160
    output_simple_chars((psiconv_config )config, list, (char *)" color=#", (encoding )enc);
#line 161
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
    }
  } else
#line 156
  if ((int )(layout->color)->green != 0) {
    {
#line 158
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%02x%02x%02x",
             (int )(layout->color)->red, (int )(layout->color)->green, (int )(layout->color)->blue);
#line 160
    output_simple_chars((psiconv_config )config, list, (char *)" color=#", (encoding )enc);
#line 161
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
    }
  } else
#line 156
  if ((int )(layout->color)->blue != 0) {
    {
#line 158
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%02x%02x%02x",
             (int )(layout->color)->red, (int )(layout->color)->green, (int )(layout->color)->blue);
#line 160
    output_simple_chars((psiconv_config )config, list, (char *)" color=#", (encoding )enc);
#line 161
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
    }
  }
  {
#line 163
  output_simple_chars((psiconv_config )config, list, (char *)">", (encoding )enc);
  }
#line 166
  if (layout->italic) {
    {
#line 167
    output_simple_chars((psiconv_config )config, list, (char *)"<I>", (encoding )enc);
    }
  }
#line 168
  if (layout->bold) {
    {
#line 169
    output_simple_chars((psiconv_config )config, list, (char *)"<B>", (encoding )enc);
    }
  }
#line 170
  if ((unsigned int )layout->super_sub != 0U) {
#line 171
    if ((unsigned int )layout->super_sub == 1U) {
#line 171
      tmp___10 = "<SUP>";
    } else {
#line 171
      if ((unsigned int )layout->super_sub == 2U) {
#line 171
        tmp___9 = "<SUB>";
      } else {
#line 171
        tmp___9 = "";
      }
#line 171
      tmp___10 = tmp___9;
    }
    {
#line 171
    output_simple_chars((psiconv_config )config, list, (char *)tmp___10, (encoding )enc);
    }
  }
#line 175
  if (layout->strikethrough) {
    {
#line 176
    output_simple_chars((psiconv_config )config, list, (char *)"<S>", (encoding )enc);
    }
  }
#line 177
  if (layout->underline) {
    {
#line 178
    output_simple_chars((psiconv_config )config, list, (char *)"<U>", (encoding )enc);
    }
  }
  {
#line 180
  text(config, list, (psiconv_string_t )textstr, enc);
  }
#line 182
  if (layout->underline) {
    {
#line 183
    output_simple_chars((psiconv_config )config, list, (char *)"</U>", (encoding )enc);
    }
  }
#line 184
  if (layout->strikethrough) {
    {
#line 185
    output_simple_chars((psiconv_config )config, list, (char *)"</S>", (encoding )enc);
    }
  }
#line 186
  if ((unsigned int )layout->super_sub != 0U) {
#line 187
    if ((unsigned int )layout->super_sub == 1U) {
#line 187
      tmp___12 = "</SUP>";
    } else {
#line 187
      if ((unsigned int )layout->super_sub == 2U) {
#line 187
        tmp___11 = "</SUB>";
      } else {
#line 187
        tmp___11 = "";
      }
#line 187
      tmp___12 = tmp___11;
    }
    {
#line 187
    output_simple_chars((psiconv_config )config, list, (char *)tmp___12, (encoding )enc);
    }
  }
#line 191
  if (layout->bold) {
    {
#line 192
    output_simple_chars((psiconv_config )config, list, (char *)"</B>", (encoding )enc);
    }
  }
#line 193
  if (layout->italic) {
    {
#line 194
    output_simple_chars((psiconv_config )config, list, (char *)"</I>", (encoding )enc);
    }
  }
  {
#line 195
  output_simple_chars((psiconv_config )config, list, (char *)"</FONT>", (encoding )enc);
  }
#line 196
  return;
}
}
#line 198 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_html4.c"
static void paragraph(psiconv_config const   config , psiconv_list list , psiconv_paragraph para ,
                      encoding const   enc ) 
{ 
  int i ;
  int charnr ;
  int start ;
  int len ;
  psiconv_string_t text___3 ;
  psiconv_in_line_layout layout ;
  psiconv_in_line_layout next_layout ;
  char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  psiconv_u32 tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  psiconv_u32 tmp___6 ;
  psiconv_u32 tmp___7 ;
  char const   *tmp___8 ;

  {
#line 206
  if (((para->base_paragraph)->bullet)->on) {
#line 206
    tmp = "<UL><LI";
  } else {
#line 206
    tmp = "<P";
  }
  {
#line 206
  output_simple_chars((psiconv_config )config, list, (char *)tmp, (encoding )enc);
  }
#line 209
  if ((unsigned int )(para->base_paragraph)->justify_hor == 1U) {
    {
#line 210
    output_simple_chars((psiconv_config )config, list, (char *)" align=center", (encoding )enc);
    }
  } else
#line 211
  if ((unsigned int )(para->base_paragraph)->justify_hor == 2U) {
    {
#line 212
    output_simple_chars((psiconv_config )config, list, (char *)" align=right", (encoding )enc);
    }
  } else
#line 213
  if ((unsigned int )(para->base_paragraph)->justify_hor == 3U) {
    {
#line 214
    output_simple_chars((psiconv_config )config, list, (char *)" align=justify", (encoding )enc);
    }
  }
  {
#line 216
  output_simple_chars((psiconv_config )config, list, (char *)">", (encoding )enc);
#line 218
  tmp___7 = psiconv_list_length((psiconv_list const   )para->in_lines);
  }
#line 218
  if (tmp___7 == 0U) {
    {
#line 219
    tmp___0 = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
    }
#line 219
    if (tmp___0) {
      {
#line 220
      characters(config, list, (psiconv_string_t const   )para->text, (psiconv_character_layout const   )para->base_character,
                 enc);
      }
    }
  } else {
#line 222
    charnr = 0;
#line 223
    start = -1;
#line 224
    i = 0;
    {
#line 224
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 224
      tmp___6 = psiconv_list_length((psiconv_list const   )para->in_lines);
      }
#line 224
      if (! ((psiconv_u32 )i < tmp___6)) {
#line 224
        goto while_break;
      }
#line 225
      if (start < 0) {
#line 226
        start = charnr;
      }
      {
#line 227
      tmp___1 = psiconv_list_get((psiconv_list const   )para->in_lines, (psiconv_u32 )i);
#line 227
      layout = (psiconv_in_line_layout )tmp___1;
      }
#line 227
      if (! layout) {
        {
#line 228
        fputs((char const   */* __restrict  */)"Internal data structures corruption\n",
              (FILE */* __restrict  */)stderr);
#line 229
        exit(1);
        }
      }
      {
#line 231
      tmp___3 = psiconv_list_length((psiconv_list const   )para->in_lines);
      }
#line 231
      if ((psiconv_u32 )(i + 1) < tmp___3) {
        {
#line 232
        tmp___2 = psiconv_list_get((psiconv_list const   )para->in_lines, (psiconv_u32 )(i + 1));
#line 232
        next_layout = (psiconv_in_line_layout )tmp___2;
        }
#line 232
        if (! next_layout) {
          {
#line 233
          fputs((char const   */* __restrict  */)"Internal data structures corruption\n",
                (FILE */* __restrict  */)stderr);
#line 234
          exit(1);
          }
        }
      } else {
#line 237
        next_layout = (psiconv_in_line_layout )((void *)0);
      }
#line 239
      if (next_layout) {
        {
#line 239
        tmp___4 = character_layout_equal((psiconv_character_layout const   )layout->layout,
                                         (psiconv_character_layout const   )next_layout->layout);
        }
#line 239
        if (tmp___4) {
#line 241
          charnr += layout->length;
#line 242
          goto __Cont;
        }
      }
#line 244
      len = (charnr - start) + layout->length;
#line 245
      if (len) {
        {
#line 246
        tmp___5 = malloc(sizeof(*text___3) * (unsigned long )(len + 1));
#line 246
        text___3 = (psiconv_string_t )tmp___5;
        }
#line 246
        if (! text___3) {
          {
#line 247
          fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 248
          exit(1);
          }
        }
        {
#line 250
        memcpy((void */* __restrict  */)text___3, (void const   */* __restrict  */)(para->text + charnr),
               (unsigned long )len * sizeof(*text___3));
#line 251
        *(text___3 + len) = (psiconv_ucs2 )0;
#line 252
        characters(config, list, (psiconv_string_t const   )text___3, (psiconv_character_layout const   )layout->layout,
                   enc);
#line 253
        free((void *)text___3);
        }
      }
#line 255
      charnr += layout->length;
#line 256
      start = -1;
      __Cont: /* CIL Label */ 
#line 224
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 259
  if (((para->base_paragraph)->bullet)->on) {
#line 259
    tmp___8 = "</UL>\n";
  } else {
#line 259
    tmp___8 = "\n";
  }
  {
#line 259
  output_simple_chars((psiconv_config )config, list, (char *)tmp___8, (encoding )enc);
  }
#line 261
  return;
}
}
#line 263 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_html4.c"
static void paragraphs(psiconv_config const   config , psiconv_list list , psiconv_text_and_layout paragraphs___3 ,
                       encoding const   enc ) 
{ 
  int i ;
  psiconv_paragraph para ;
  void *tmp ;
  psiconv_u32 tmp___0 ;

  {
#line 268
  i = 0;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 268
    tmp___0 = psiconv_list_length((psiconv_list const   )paragraphs___3);
    }
#line 268
    if (! ((psiconv_u32 )i < tmp___0)) {
#line 268
      goto while_break;
    }
    {
#line 269
    tmp = psiconv_list_get((psiconv_list const   )paragraphs___3, (psiconv_u32 )i);
#line 269
    para = (psiconv_paragraph )tmp;
    }
#line 269
    if (! para) {
      {
#line 270
      fputs((char const   */* __restrict  */)"Internal datastructure corruption\n",
            (FILE */* __restrict  */)stderr);
#line 271
      exit(1);
      }
    }
    {
#line 273
    paragraph(config, list, para, enc);
#line 268
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 275
  return;
}
}
#line 277 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_html4.c"
static void gen_word___0(psiconv_config const   config , psiconv_list list , psiconv_word_f const   file ,
                         encoding const   enc ) 
{ 


  {
#line 280
  if (! file) {
#line 281
    return;
  }
  {
#line 283
  header(config, list, enc);
#line 284
  paragraphs(config, list, file->paragraphs, enc);
#line 285
  footer(config, list, enc);
  }
#line 286
  return;
}
}
#line 289 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_html4.c"
static void gen_texted___0(psiconv_config const   config , psiconv_list list , psiconv_texted_f const   file ,
                           encoding const   enc ) 
{ 


  {
  {
#line 292
  header(config, list, enc);
#line 293
  paragraphs(config, list, (file->texted_sec)->paragraphs, enc);
#line 294
  footer(config, list, enc);
  }
#line 295
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_html4.c"
static int gen_html4(psiconv_config const   config , psiconv_list list , psiconv_file const   file ,
                     char const   *dest , encoding const   enc ) 
{ 
  encoding enc1 ;

  {
#line 301
  enc1 = (encoding )enc;
#line 303
  if ((unsigned int const   )enc == 2U) {
    {
#line 304
    fputs((char const   */* __restrict  */)"Unsupported encoding\n", (FILE */* __restrict  */)stderr);
    }
#line 305
    return (-1);
  } else
#line 306
  if ((unsigned int const   )enc == 3U) {
#line 307
    enc1 = (encoding )4;
  }
#line 309
  if ((unsigned int )file->type == 1U) {
    {
#line 310
    gen_word___0(config, list, (psiconv_word_f const   )((psiconv_word_f )file->file),
                 (encoding const   )enc1);
    }
#line 311
    return (0);
  } else
#line 312
  if ((unsigned int )file->type == 2U) {
    {
#line 313
    gen_texted___0(config, list, (psiconv_texted_f const   )((psiconv_texted_f )file->file),
                   (encoding const   )enc1);
    }
#line 314
    return (0);
  } else {
#line 316
    return (-1);
  }
}
}
#line 320 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_html4.c"
static struct fileformat_s fileformats[2]  = {      {"HTML4", "HTML 4.01 Transitional, without CSS", 3, & gen_html4}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), 0, (output_function *)((void *)0)}};
#line 337 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_html4.c"
void init_html4(void) 
{ 
  int i ;

  {
#line 340
  i = 0;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 340
    if (! fileformats[i].name) {
#line 340
      goto while_break;
    }
    {
#line 341
    psiconv_list_add(fileformat_list, (void const   *)(fileformats + i));
#line 340
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return;
}
}
#line 45 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/buffer.c"
static psiconv_u32 unique_id___2  =    (psiconv_u32 )1;
#line 39 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_4_red___2[16]  = 
#line 39 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
  {      (float )((double )0 / 255.0),      (float )((double )85 / 255.0),      (float )((double )128 / 255.0),      (float )((double )128 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )128 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )170 / 255.0),      (float )((double )255 / 255.0)};
#line 46 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_4_green___2[16]  = 
#line 46
  {      (float )((double )0 / 255.0),      (float )((double )85 / 255.0),      (float )((double )0 / 255.0),      (float )((double )128 / 255.0), 
        (float )((double )128 / 255.0),      (float )((double )0 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )128 / 255.0),      (float )((double )170 / 255.0),      (float )((double )255 / 255.0)};
#line 53 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_4_blue___2[16]  = 
#line 53
  {      (float )((double )0 / 255.0),      (float )((double )85 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )255 / 255.0),      (float )((double )128 / 255.0), 
        (float )((double )128 / 255.0),      (float )((double )128 / 255.0),      (float )((double )170 / 255.0),      (float )((double )255 / 255.0)};
#line 69 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_8_red___2[256]  = 
#line 69
  {      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )17 / 255.0),      (float )((double )34 / 255.0),      (float )((double )68 / 255.0),      (float )((double )85 / 255.0), 
        (float )((double )119 / 255.0),      (float )((double )17 / 255.0),      (float )((double )34 / 255.0),      (float )((double )68 / 255.0), 
        (float )((double )85 / 255.0),      (float )((double )119 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )136 / 255.0),      (float )((double )170 / 255.0), 
        (float )((double )187 / 255.0),      (float )((double )221 / 255.0),      (float )((double )238 / 255.0),      (float )((double )136 / 255.0), 
        (float )((double )170 / 255.0),      (float )((double )187 / 255.0),      (float )((double )221 / 255.0),      (float )((double )238 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0)};
#line 136 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_8_green___2[256]  = 
#line 136
  {      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )17 / 255.0),      (float )((double )34 / 255.0),      (float )((double )68 / 255.0),      (float )((double )85 / 255.0), 
        (float )((double )119 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )17 / 255.0),      (float )((double )34 / 255.0), 
        (float )((double )68 / 255.0),      (float )((double )85 / 255.0),      (float )((double )119 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )136 / 255.0),      (float )((double )170 / 255.0),      (float )((double )187 / 255.0), 
        (float )((double )221 / 255.0),      (float )((double )238 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )136 / 255.0), 
        (float )((double )170 / 255.0),      (float )((double )187 / 255.0),      (float )((double )221 / 255.0),      (float )((double )238 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0)};
#line 203 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_8_blue___2[256]  = 
#line 203
  {      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )17 / 255.0),      (float )((double )34 / 255.0),      (float )((double )68 / 255.0),      (float )((double )85 / 255.0), 
        (float )((double )119 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )17 / 255.0), 
        (float )((double )34 / 255.0),      (float )((double )68 / 255.0),      (float )((double )85 / 255.0),      (float )((double )119 / 255.0), 
        (float )((double )136 / 255.0),      (float )((double )170 / 255.0),      (float )((double )187 / 255.0),      (float )((double )221 / 255.0), 
        (float )((double )238 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )136 / 255.0), 
        (float )((double )170 / 255.0),      (float )((double )187 / 255.0),      (float )((double )221 / 255.0),      (float )((double )238 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0)};
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/error.c"
static void psiconv_default_error_handler___2(int kind , psiconv_u32 off , char const   *message ) 
{ 


  {
  {
#line 36
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          message);
  }
#line 37
  return;
}
}
#line 36 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
static int psiconv_list_resize___2(psiconv_list l , psiconv_u32 nr ) ;
#line 178 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
static int psiconv_list_resize___2(psiconv_list l , psiconv_u32 nr ) 
{ 
  void *temp ;

  {
#line 181
  if (nr > l->max_len) {
    {
#line 182
    l->max_len = (psiconv_u32 )(1.1 * (double )nr);
#line 183
    l->max_len += 16U - l->max_len % 16U;
#line 184
    temp = realloc(l->els, (size_t )l->max_len * l->el_size);
    }
#line 185
    if (temp) {
#line 186
      l->els = temp;
#line 187
      return (0);
    } else {
#line 189
      return (-2);
    }
  }
#line 191
  return (0);
}
}
#line 39 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/general.h"
void output_string(psiconv_config config , psiconv_list list , psiconv_ucs2 *string ,
                   encoding enc ) ;
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/general.c"
void output_char(psiconv_config config , psiconv_list list , psiconv_ucs2 character ,
                 encoding enc ) 
{ 
  psiconv_u8 temp ;
  psiconv_u8 *byteptr ;
  int res ;
  int i ;
  psiconv_buffer buf ;
  char tempstr[80] ;
  psiconv_u32 tmp ;

  {
#line 42
  if ((unsigned int )enc == 1U) {
    {
#line 43
    temp = (psiconv_u8 )((int )character >> 8);
#line 44
    res = psiconv_list_add(list, (void const   *)(& temp));
    }
#line 44
    if (res) {
      {
#line 45
      fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 46
      exit(1);
      }
    }
    {
#line 48
    temp = (psiconv_u8 )((int )character & 255);
#line 49
    res = psiconv_list_add(list, (void const   *)(& temp));
    }
#line 49
    if (res) {
      {
#line 50
      fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 51
      exit(1);
      }
    }
  } else
#line 53
  if ((unsigned int )enc == 0U) {
#line 54
    if ((int )character < 128) {
      {
#line 55
      temp = (psiconv_u8 )character;
#line 56
      res = psiconv_list_add(list, (void const   *)(& temp));
      }
#line 56
      if (res) {
        {
#line 57
        fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 58
        exit(1);
        }
      }
    } else
#line 60
    if ((int )character < 2048) {
      {
#line 61
      temp = (psiconv_u8 )(192 + ((int )character >> 6));
#line 62
      res = psiconv_list_add(list, (void const   *)(& temp));
      }
#line 62
      if (res) {
        {
#line 63
        fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 64
        exit(1);
        }
      }
      {
#line 66
      temp = (psiconv_u8 )(128 + ((int )character & 63));
#line 67
      res = psiconv_list_add(list, (void const   *)(& temp));
      }
#line 67
      if (res) {
        {
#line 68
        fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 69
        exit(1);
        }
      }
    } else {
      {
#line 72
      temp = (psiconv_u8 )(224 + ((int )character >> 12));
#line 73
      res = psiconv_list_add(list, (void const   *)(& temp));
      }
#line 73
      if (res) {
        {
#line 74
        fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 75
        exit(1);
        }
      }
      {
#line 77
      temp = (psiconv_u8 )(128 + (((int )character >> 6) & 63));
#line 78
      res = psiconv_list_add(list, (void const   *)(& temp));
      }
#line 78
      if (res) {
        {
#line 79
        fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 80
        exit(1);
        }
      }
      {
#line 82
      temp = (psiconv_u8 )(128 + ((int )character & 63));
#line 83
      res = psiconv_list_add(list, (void const   *)(& temp));
      }
#line 83
      if (res) {
        {
#line 84
        fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 85
        exit(1);
        }
      }
    }
  } else
#line 88
  if ((unsigned int )enc == 3U) {
#line 89
    if ((int )character == 160) {
#line 90
      temp = (psiconv_u8 )' ';
    } else
#line 91
    if ((int )character >= 128) {
#line 92
      temp = (psiconv_u8 )'?';
    } else {
#line 94
      temp = (psiconv_u8 )character;
    }
    {
#line 95
    res = psiconv_list_add(list, (void const   *)(& temp));
    }
#line 95
    if (res) {
      {
#line 96
      fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 97
      exit(1);
      }
    }
  } else
#line 99
  if ((unsigned int )enc == 4U) {
#line 100
    if ((int )character >= 128) {
      {
#line 101
      snprintf((char */* __restrict  */)(tempstr), (size_t )80, (char const   */* __restrict  */)"&#x%x;",
               (int )character);
#line 102
      output_simple_chars(config, list, tempstr, enc);
      }
    } else {
      {
#line 104
      temp = (psiconv_u8 )character;
#line 105
      res = psiconv_list_add(list, (void const   *)(& temp));
      }
#line 105
      if (res) {
        {
#line 106
        fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 107
        exit(1);
        }
      }
    }
  } else
#line 110
  if ((unsigned int )enc == 2U) {
    {
#line 111
    buf = psiconv_buffer_new();
    }
#line 111
    if (! buf) {
      {
#line 112
      fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 113
      exit(1);
      }
    }
    {
#line 115
    psiconv_unicode_write_char((psiconv_config const   )config, buf, 0, character);
#line 116
    i = 0;
    }
    {
#line 116
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 116
      tmp = psiconv_buffer_length((psiconv_buffer const   )buf);
      }
#line 116
      if (! ((psiconv_u32 )i < tmp)) {
#line 116
        goto while_break;
      }
      {
#line 117
      byteptr = psiconv_buffer_get((psiconv_buffer const   )buf, (psiconv_u32 )i);
      }
#line 117
      if (! byteptr) {
        {
#line 118
        fputs((char const   */* __restrict  */)"Internal memory corruption\n", (FILE */* __restrict  */)stderr);
#line 119
        exit(1);
        }
      }
      {
#line 121
      res = psiconv_list_add(list, (void const   *)byteptr);
      }
#line 121
      if (res) {
        {
#line 122
        fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 123
        exit(1);
        }
      }
#line 116
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 126
    psiconv_buffer_free(buf);
    }
  }
#line 128
  return;
}
}
#line 130 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/general.c"
void output_string(psiconv_config config , psiconv_list list , psiconv_ucs2 *string ,
                   encoding enc ) 
{ 
  int i ;

  {
#line 133
  i = 0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! *(string + i)) {
#line 135
      goto while_break;
    }
    {
#line 136
    output_char(config, list, *(string + i), enc);
#line 137
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  return;
}
}
#line 141 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/general.c"
void output_simple_chars(psiconv_config config , psiconv_list list , char *string ,
                         encoding enc ) 
{ 
  psiconv_ucs2 *ucs_string ;
  int i ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 147
  tmp = strlen((char const   *)string);
#line 147
  tmp___0 = malloc(sizeof(*ucs_string) * (tmp + 1UL));
#line 147
  ucs_string = (psiconv_ucs2 *)tmp___0;
  }
#line 147
  if (! ucs_string) {
    {
#line 148
    fputs((char const   */* __restrict  */)"Out of memory error", (FILE */* __restrict  */)stderr);
#line 149
    exit(1);
    }
  }
#line 151
  i = 0;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 151
    tmp___1 = strlen((char const   *)string);
    }
#line 151
    if (! ((size_t )i < tmp___1)) {
#line 151
      goto while_break;
    }
#line 152
    if ((int )*(string + i) != 10) {
#line 152
      if ((int )*(string + i) < 32) {
        {
#line 153
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"output_simple_chars unknown char: %02x",
                (int )*(string + i));
#line 154
        exit(1);
        }
      } else
#line 152
      if ((int )*(string + i) > 126) {
        {
#line 153
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"output_simple_chars unknown char: %02x",
                (int )*(string + i));
#line 154
        exit(1);
        }
      }
    }
#line 156
    *(ucs_string + i) = (psiconv_ucs2 )*(string + i);
#line 151
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 158
  *(ucs_string + i) = (psiconv_ucs2 )*(string + i);
#line 159
  output_string(config, list, ucs_string, enc);
#line 160
  free((void *)ucs_string);
  }
#line 161
  return;
}
}
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
static psiconv_ucs2 unicode_paint___2[10]  = 
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
  {      (psiconv_ucs2 )'P',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'i',      (psiconv_ucs2 )'n', 
        (psiconv_ucs2 )'t',      (psiconv_ucs2 )'.',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'p', 
        (psiconv_ucs2 )'p',      (psiconv_ucs2 )0};
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
static psiconv_ucs2 unicode_texted___2[11]  = 
#line 33
  {      (psiconv_ucs2 )'T',      (psiconv_ucs2 )'e',      (psiconv_ucs2 )'x',      (psiconv_ucs2 )'t', 
        (psiconv_ucs2 )'E',      (psiconv_ucs2 )'d',      (psiconv_ucs2 )'.',      (psiconv_ucs2 )'a', 
        (psiconv_ucs2 )'p',      (psiconv_ucs2 )'p',      (psiconv_ucs2 )0};
#line 34 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
static psiconv_ucs2 unicode_word___2[9]  = 
#line 34
  {      (psiconv_ucs2 )'W',      (psiconv_ucs2 )'o',      (psiconv_ucs2 )'r',      (psiconv_ucs2 )'d', 
        (psiconv_ucs2 )'.',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'p',      (psiconv_ucs2 )'p', 
        (psiconv_ucs2 )0};
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
static psiconv_sheet_cell_layout psiconv_basic_cell_layout___2(void) 
{ 
  psiconv_sheet_cell_layout result ;
  void *tmp ;
  psiconv_character_layout tmp___0 ;
  psiconv_paragraph_layout tmp___1 ;
  psiconv_sheet_numberformat tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 35
  tmp = malloc(sizeof(*result));
#line 35
  result = (psiconv_sheet_cell_layout )tmp;
  }
#line 35
  if (! result) {
#line 36
    goto ERROR1;
  }
  {
#line 37
  tmp___0 = psiconv_basic_character_layout();
#line 37
  result->character = tmp___0;
  }
#line 37
  if (! tmp___0) {
#line 38
    goto ERROR2;
  }
  {
#line 39
  tmp___1 = psiconv_basic_paragraph_layout();
#line 39
  result->paragraph = tmp___1;
  }
#line 39
  if (! tmp___1) {
#line 40
    goto ERROR3;
  }
  {
#line 41
  tmp___3 = malloc(sizeof(*(result->numberformat)));
#line 41
  tmp___2 = (psiconv_sheet_numberformat )tmp___3;
#line 41
  result->numberformat = tmp___2;
  }
#line 41
  if (! tmp___2) {
#line 42
    goto ERROR4;
  }
#line 43
  (result->numberformat)->code = (psiconv_sheet_numberformat_code_t )0;
#line 44
  (result->numberformat)->decimal = (psiconv_u8 )2;
#line 45
  return (result);
  ERROR4: 
  {
#line 47
  psiconv_free_paragraph_layout(result->paragraph);
  }
  ERROR3: 
  {
#line 49
  psiconv_free_character_layout(result->character);
  }
  ERROR2: 
  {
#line 51
  free((void *)result);
  }
  ERROR1: 
#line 53
  return ((psiconv_sheet_cell_layout )((void *)0));
}
}
#line 56 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
static psiconv_sheet_cell_layout psiconv_clone_cell_layout___2(psiconv_sheet_cell_layout original ) 
{ 
  psiconv_sheet_cell_layout result ;
  void *tmp ;
  psiconv_character_layout tmp___0 ;
  psiconv_paragraph_layout tmp___1 ;
  psiconv_sheet_numberformat tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 60
  tmp = malloc(sizeof(*result));
#line 60
  result = (psiconv_sheet_cell_layout )tmp;
  }
#line 60
  if (! result) {
#line 61
    goto ERROR1;
  }
  {
#line 62
  tmp___0 = psiconv_clone_character_layout(original->character);
#line 62
  result->character = tmp___0;
  }
#line 62
  if (! tmp___0) {
#line 64
    goto ERROR2;
  }
  {
#line 65
  tmp___1 = psiconv_clone_paragraph_layout(original->paragraph);
#line 65
  result->paragraph = tmp___1;
  }
#line 65
  if (! tmp___1) {
#line 67
    goto ERROR3;
  }
  {
#line 68
  tmp___3 = malloc(sizeof(*(result->numberformat)));
#line 68
  tmp___2 = (psiconv_sheet_numberformat )tmp___3;
#line 68
  result->numberformat = tmp___2;
  }
#line 68
  if (! tmp___2) {
#line 69
    goto ERROR4;
  }
#line 70
  (result->numberformat)->code = (original->numberformat)->code;
#line 71
  (result->numberformat)->decimal = (original->numberformat)->decimal;
#line 72
  return (result);
  ERROR4: 
  {
#line 74
  psiconv_free_paragraph_layout(result->paragraph);
  }
  ERROR3: 
  {
#line 76
  psiconv_free_character_layout(result->character);
  }
  ERROR2: 
  {
#line 78
  free((void *)result);
  }
  ERROR1: 
#line 80
  return ((psiconv_sheet_cell_layout )((void *)0));
}
}
#line 83 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
static psiconv_sheet_cell_reference_t psiconv_read_var_cellref___2(psiconv_config const   config ,
                                                                   psiconv_buffer const   buf ,
                                                                   int lev , psiconv_u32 off ,
                                                                   int *length , int *status ) 
{ 
  int len ;
  int res ;
  psiconv_sheet_cell_reference_t result ;
  psiconv_u32 temp ;
  psiconv_u8 tmp ;

  {
  {
#line 89
  len = 0;
#line 94
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read a sheet cell reference");
#line 95
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the initial byte (%02x expected)",
                   0);
#line 97
  tmp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 97
  temp = (psiconv_u32 )tmp;
  }
#line 98
  if (res) {
#line 99
    goto ERROR1;
  }
#line 100
  if (temp != 0U) {
    {
#line 101
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet cell reference initial byte unknown value (ignored)");
#line 103
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Initial byte: %02x",
                  temp);
    }
  }
  {
#line 105
  len ++;
#line 107
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 108
  if (res) {
#line 109
    goto ERROR1;
  }
#line 110
  if (temp & 4294901760U) {
    {
#line 111
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet cell row reference to unknown row (reset)");
    }
  }
  {
#line 114
  result.row.offset = (psiconv_s16 )temp;
#line 115
  result.row.absolute = (psiconv_bool_t )1;
#line 116
  len += 4;
#line 118
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 119
  if (res) {
#line 120
    goto ERROR1;
  }
#line 121
  if (temp & 4294901760U) {
    {
#line 122
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet cell column reference to unknown row (reset)");
    }
  }
#line 125
  result.column.offset = (psiconv_s16 )temp;
#line 126
  result.column.absolute = (psiconv_bool_t )1;
#line 127
  len += 4;
#line 129
  if (length) {
#line 130
    *length = len;
  }
  {
#line 132
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet column reference (total length: %08x)",
                   len);
  }
#line 134
  return (result);
  ERROR1: 
  {
#line 136
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Column Reference failed");
  }
#line 137
  if (length) {
#line 138
    *length = 0;
  }
#line 139
  if (status) {
#line 140
    if (res) {
#line 140
      *status = res;
    } else {
#line 140
      *status = -2;
    }
  }
#line 141
  return (result);
}
}
#line 144 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
static psiconv_sheet_cell_block_t psiconv_read_var_cellblock___2(psiconv_config const   config ,
                                                                 psiconv_buffer const   buf ,
                                                                 int lev , psiconv_u32 off ,
                                                                 int *length , int *status ) 
{ 
  int len ;
  int res ;
  psiconv_sheet_cell_block_t result ;
  psiconv_u32 temp ;
  psiconv_u8 tmp ;

  {
  {
#line 150
  len = 0;
#line 155
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read a sheet cell block reference");
#line 156
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the initial byte (%02x expected)",
                   0);
#line 158
  tmp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 158
  temp = (psiconv_u32 )tmp;
  }
#line 159
  if (res) {
#line 160
    goto ERROR1;
  }
#line 161
  if (temp != 0U) {
    {
#line 162
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet cell reference initial byte unknown value (ignored)");
#line 164
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Initial byte: %02x",
                  temp);
    }
  }
  {
#line 166
  len ++;
#line 168
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 169
  if (res) {
#line 170
    goto ERROR1;
  }
#line 171
  if (temp & 4294901760U) {
    {
#line 172
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet block initial row reference to unknown row (reset)");
    }
  }
  {
#line 175
  result.first.row.offset = (psiconv_s16 )temp;
#line 176
  result.first.row.absolute = (psiconv_bool_t )1;
#line 177
  len += 4;
#line 179
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 180
  if (res) {
#line 181
    goto ERROR1;
  }
#line 182
  if (temp & 4294901760U) {
    {
#line 183
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet block initial column reference to unknown row (reset)");
    }
  }
  {
#line 186
  result.first.column.offset = (psiconv_s16 )temp;
#line 187
  result.first.column.absolute = (psiconv_bool_t )1;
#line 188
  len += 4;
#line 190
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 191
  if (res) {
#line 192
    goto ERROR1;
  }
#line 193
  if (temp & 4294901760U) {
    {
#line 194
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet block final row reference to unknown row (reset)");
    }
  }
  {
#line 197
  result.last.row.offset = (psiconv_s16 )temp;
#line 198
  result.last.row.absolute = (psiconv_bool_t )1;
#line 199
  len += 4;
#line 201
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 202
  if (res) {
#line 203
    goto ERROR1;
  }
#line 204
  if (temp & 4294901760U) {
    {
#line 205
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet block final column reference to unknown row (reset)");
    }
  }
#line 208
  result.last.column.offset = (psiconv_s16 )temp;
#line 209
  result.last.column.absolute = (psiconv_bool_t )1;
#line 210
  len += 4;
#line 212
  if (length) {
#line 213
    *length = len;
  }
  {
#line 215
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet cell block reference (total length: %08x)",
                   len);
  }
#line 218
  return (result);
  ERROR1: 
  {
#line 220
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Cell Block Reference failed");
  }
#line 221
  if (length) {
#line 222
    *length = 0;
  }
#line 223
  if (status) {
#line 224
    if (res) {
#line 224
      *status = res;
    } else {
#line 224
      *status = -2;
    }
  }
#line 225
  return (result);
}
}
#line 34 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_simple.c"
static int psiconv_write_string_aux___2(psiconv_config const   config , psiconv_buffer buf ,
                                        int lev , psiconv_string_t const   value ,
                                        int kind ) ;
#line 222 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_simple.c"
static int psiconv_write_string_aux___2(psiconv_config const   config , psiconv_buffer buf ,
                                        int lev , psiconv_string_t const   value ,
                                        int kind ) 
{ 
  int res ;
  int i ;
  int len ;
  char *printable ;

  {
  {
#line 228
  len = psiconv_unicode_strlen((psiconv_ucs2 const   *)value);
  }
#line 229
  if (! value) {
    {
#line 230
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "NULL string");
    }
#line 231
    return (-4);
  }
  {
#line 234
  printable = psiconv_make_printable(config, value);
  }
#line 234
  if (! printable) {
    {
#line 235
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Out of memory error");
    }
#line 236
    return (-2);
  }
  {
#line 238
  psiconv_debug((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Value: %s", printable);
#line 239
  free((void *)printable);
  }
#line 241
  if (kind == -1) {
    {
#line 242
    res = psiconv_write_S(config, buf, lev + 2, (psiconv_u32 const   )len);
    }
  } else
#line 243
  if (kind == -2) {
    {
#line 244
    res = psiconv_write_u8(config, buf, lev + 2, (psiconv_u8 const   )len);
    }
  } else {
#line 246
    res = 0;
  }
#line 247
  if (res) {
#line 248
    return (res);
  }
#line 250
  i = 0;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (i < len)) {
#line 250
      goto while_break;
    }
    {
#line 251
    res = psiconv_unicode_write_char(config, buf, lev + 2, *(value + i));
    }
#line 251
    if (res) {
#line 252
      return (res);
    }
#line 250
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  return (0);
}
}
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
static int psiconv_parse_layout_section___2(psiconv_config const   config , psiconv_buffer const   buf ,
                                            int lev , psiconv_u32 off , int *length ,
                                            psiconv_text_and_layout result , psiconv_word_styles_section styles___1 ,
                                            int with_styles ) ;
#line 40
static psiconv_file_type_t psiconv_determine_embedded_object_type___2(psiconv_config const   config ,
                                                                      psiconv_buffer const   buf ,
                                                                      int lev , int *status ) ;
#line 391 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
static int psiconv_parse_layout_section___2(psiconv_config const   config , psiconv_buffer const   buf ,
                                            int lev , psiconv_u32 off , int *length ,
                                            psiconv_text_and_layout result , psiconv_word_styles_section styles___1 ,
                                            int with_styles ) 
{ 
  int res ;
  int len ;
  psiconv_u32 temp ;
  int parse_styles ;
  int nr ;
  int i ;
  int j ;
  int total ;
  int leng ;
  int line_length ;
  anon_style_list anon_styles ;
  struct anon_style_s anon ;
  anon_style anon_ptr ;
  psiconv_character_layout temp_char ;
  psiconv_paragraph_layout temp_para ;
  psiconv_word_style temp_style ;
  psiconv_paragraph para ;
  struct psiconv_in_line_layout_s in_line ;
  int *inline_count ;
  psiconv_u16 tmp ;
  psiconv_u8 tmp___0 ;
  psiconv_u32 tmp___1 ;
  psiconv_u8 tmp___2 ;
  psiconv_u32 tmp___3 ;
  psiconv_u32 tmp___4 ;
  psiconv_u32 tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  psiconv_in_line_layouts tmp___8 ;
  psiconv_character_layout tmp___9 ;
  psiconv_paragraph_layout tmp___10 ;
  psiconv_u32 tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  psiconv_u8 tmp___15 ;
  void *tmp___16 ;
  psiconv_u32 tmp___17 ;
  psiconv_u32 tmp___18 ;
  psiconv_u8 tmp___19 ;
  psiconv_u32 tmp___20 ;
  psiconv_u32 tmp___21 ;
  void *tmp___22 ;
  psiconv_u8 tmp___23 ;
  psiconv_u32 tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  psiconv_u32 tmp___27 ;
  void *tmp___28 ;
  psiconv_u32 tmp___29 ;
  void *tmp___30 ;
  psiconv_u32 tmp___31 ;

  {
  {
#line 399
  res = 0;
#line 400
  len = 0;
#line 416
  anon_ptr = (anon_style )((void *)0);
#line 427
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read the layout section");
#line 429
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the section type");
#line 430
  tmp = psiconv_read_u16(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 430
  temp = (psiconv_u32 )tmp;
  }
#line 431
  if (res) {
#line 432
    goto ERROR1;
  }
  {
#line 433
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Type: %02x",
                temp);
#line 434
  parse_styles = with_styles;
  }
#line 435
  if (temp == 1U) {
#line 435
    if (! with_styles) {
      {
#line 436
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Styleless layout section expected, but styled section found!");
#line 438
      parse_styles = 1;
      }
    } else {
#line 435
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 439
  if (temp == 0U) {
#line 439
    if (with_styles) {
      {
#line 440
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Styled layout section expected, but styleless section found!");
#line 442
      parse_styles = 0;
      }
    } else {
#line 439
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 443
  if (temp != 0U) {
#line 443
    if (temp != 1U) {
      {
#line 444
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Layout section type indicator has unknown value!");
      }
    }
  }
  {
#line 447
  len += 2;
#line 449
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read paragraph type list");
#line 450
  anon_styles = psiconv_list_new(sizeof(anon));
  }
#line 450
  if (! anon_styles) {
#line 451
    goto ERROR1;
  }
  {
#line 452
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read paragraph type list length");
#line 453
  tmp___0 = psiconv_read_u8(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
#line 453
  nr = (int )tmp___0;
  }
#line 454
  if (res) {
#line 455
    goto ERROR2;
  }
  {
#line 456
  psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Length: %02x",
                nr);
#line 457
  len ++;
#line 459
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the paragraph type list elements");
#line 461
  i = 0;
  }
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    if (! (i < nr)) {
#line 461
      goto while_break;
    }
    {
#line 462
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Element %d",
                     i);
#line 463
    tmp___1 = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
#line 463
    anon.nr = (int )tmp___1;
    }
#line 464
    if (res) {
#line 465
      goto ERROR3;
    }
    {
#line 466
    psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Number: %08x",
                  anon.nr);
#line 467
    len += 4;
#line 469
    psiconv_progress((psiconv_config )config, lev + 4, off, "Going to determine the base style");
    }
#line 470
    if (parse_styles) {
      {
#line 471
      temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
      }
#line 472
      if (res) {
#line 473
        goto ERROR3;
      }
      {
#line 474
      tmp___2 = psiconv_read_u8(config, buf, lev + 3, ((off + (psiconv_u32 )len) + 4U) + temp,
                                & res);
#line 474
      anon.base_style = (psiconv_s16 )tmp___2;
      }
#line 475
      if (res) {
#line 476
        goto ERROR3;
      }
      {
#line 477
      psiconv_debug((psiconv_config )config, lev + 4, (off + (psiconv_u32 )len) + temp,
                    "Style indicator: %02x", (int )anon.base_style);
      }
    } else {
#line 480
      anon.base_style = (psiconv_s16 )0;
    }
    {
#line 481
    temp_style = psiconv_get_style(styles___1, (int )anon.base_style);
    }
#line 481
    if (! temp_style) {
      {
#line 482
      psiconv_warn((psiconv_config )config, lev + 4, off, "Unknown Style referenced");
#line 483
      temp_style = psiconv_get_style(styles___1, (int )anon.base_style);
      }
#line 483
      if (! temp_style) {
        {
#line 484
        psiconv_warn((psiconv_config )config, lev + 4, off, "Base style unknown");
        }
#line 485
        goto ERROR3;
      }
    }
    {
#line 488
    anon.paragraph = psiconv_clone_paragraph_layout(temp_style->paragraph);
    }
#line 488
    if (! anon.paragraph) {
#line 490
      goto ERROR3;
    }
    {
#line 491
    anon.character = psiconv_clone_character_layout(temp_style->character);
    }
#line 491
    if (! anon.character) {
#line 493
      goto ERROR3_1;
    }
    {
#line 495
    psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to read the paragraph layout");
#line 496
    res = psiconv_parse_paragraph_layout_list(config, buf, lev + 4, off + (psiconv_u32 )len,
                                              & leng, anon.paragraph);
    }
#line 496
    if (res) {
#line 498
      goto ERROR3_2;
    }
#line 499
    len += leng;
#line 500
    if (parse_styles) {
#line 501
      len ++;
    }
    {
#line 503
    psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to read the character layout");
#line 504
    res = psiconv_parse_character_layout_list(config, buf, lev + 4, off + (psiconv_u32 )len,
                                              & leng, anon.character);
    }
#line 504
    if (res) {
#line 506
      goto ERROR3_2;
    }
    {
#line 507
    len += leng;
#line 508
    res = psiconv_list_add(anon_styles, (void const   *)(& anon));
    }
#line 508
    if (res) {
#line 509
      goto ERROR3_2;
    }
#line 461
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 512
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to parse the paragraph element list");
#line 513
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the number of paragraphs");
#line 514
  tmp___3 = psiconv_read_u32(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
#line 514
  nr = (int )tmp___3;
  }
#line 515
  if (res) {
#line 516
    goto ERROR3;
  }
  {
#line 517
  tmp___5 = psiconv_list_length((psiconv_list const   )result);
  }
#line 517
  if ((psiconv_u32 )nr != tmp___5) {
    {
#line 518
    psiconv_warn((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Number of text paragraphs and paragraph elements does not match");
#line 520
    tmp___4 = psiconv_list_length((psiconv_list const   )result);
#line 520
    psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "%d text paragraphs, %d paragraph elements",
                  tmp___4, nr);
    }
  }
  {
#line 524
  psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Number of paragraphs: %d",
                nr);
#line 525
  len += 4;
#line 526
  tmp___6 = malloc((unsigned long )nr * sizeof(*inline_count));
#line 526
  inline_count = (int *)tmp___6;
  }
#line 526
  if (! inline_count) {
#line 527
    goto ERROR3;
  }
  {
#line 529
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the paragraph elements");
#line 530
  i = 0;
  }
  {
#line 530
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 530
    if (! (i < nr)) {
#line 530
      goto while_break___0;
    }
    {
#line 531
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Element %d",
                     i);
#line 532
    tmp___11 = psiconv_list_length((psiconv_list const   )result);
    }
#line 532
    if ((psiconv_u32 )i >= tmp___11) {
      {
#line 533
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to allocate a new element");
#line 534
      tmp___7 = malloc(sizeof(*para));
#line 534
      para = (psiconv_paragraph )tmp___7;
      }
#line 534
      if (! para) {
#line 535
        goto ERROR4;
      }
      {
#line 536
      tmp___8 = psiconv_list_new(sizeof(struct psiconv_in_line_layout_s ));
#line 536
      para->in_lines = tmp___8;
      }
#line 536
      if (! tmp___8) {
#line 538
        goto ERROR4_1;
      }
      {
#line 539
      para->base_style = (psiconv_s16 )0;
#line 540
      tmp___9 = psiconv_basic_character_layout();
#line 540
      para->base_character = tmp___9;
      }
#line 540
      if (! tmp___9) {
#line 541
        goto ERROR4_2;
      }
      {
#line 542
      tmp___10 = psiconv_basic_paragraph_layout();
#line 542
      para->base_paragraph = tmp___10;
      }
#line 542
      if (! tmp___10) {
#line 543
        goto ERROR4_3;
      }
      {
#line 544
      res = psiconv_list_add(result, (void const   *)para);
      }
#line 544
      if (res) {
#line 545
        goto ERROR4_4;
      }
      {
#line 546
      free((void *)para);
      }
    }
    {
#line 548
    tmp___12 = psiconv_list_get((psiconv_list const   )result, (psiconv_u32 )i);
#line 548
    para = (psiconv_paragraph )tmp___12;
    }
#line 548
    if (! para) {
#line 549
      goto ERROR4;
    }
    {
#line 551
    psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to read the paragraph length");
#line 552
    temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
    }
#line 553
    if (res) {
#line 554
      goto ERROR4;
    }
    {
#line 555
    tmp___14 = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
    }
#line 555
    if (temp != (psiconv_u32 )(tmp___14 + 1)) {
      {
#line 556
      psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Disagreement of the length of paragraph in layout section");
#line 558
      tmp___13 = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
#line 558
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Paragraph length: layout section says %d, counted %d",
                    temp, tmp___13 + 1);
      }
    } else {
      {
#line 562
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Paragraph length: %d",
                    temp);
      }
    }
    {
#line 563
    len += 4;
#line 565
    psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to read the paragraph type");
#line 566
    tmp___15 = psiconv_read_u8(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
#line 566
    temp = (psiconv_u32 )tmp___15;
    }
#line 567
    if (res) {
#line 568
      goto ERROR4;
    }
#line 569
    if (temp != 0U) {
      {
#line 570
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Type: %02x",
                    temp);
#line 571
      j = 0;
      }
      {
#line 571
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 571
        tmp___17 = psiconv_list_length((psiconv_list const   )anon_styles);
        }
#line 571
        if (! ((psiconv_u32 )j < tmp___17)) {
#line 571
          goto while_break___1;
        }
        {
#line 572
        tmp___16 = psiconv_list_get((psiconv_list const   )anon_styles, (psiconv_u32 )j);
#line 572
        anon_ptr = (anon_style )tmp___16;
        }
#line 572
        if (! anon_ptr) {
          {
#line 573
          psiconv_error((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Data structure corruption");
          }
#line 574
          goto ERROR4;
        }
#line 576
        if (temp == (psiconv_u32 )anon_ptr->nr) {
#line 577
          goto while_break___1;
        }
#line 571
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 579
      tmp___18 = psiconv_list_length((psiconv_list const   )anon_styles);
      }
#line 579
      if ((psiconv_u32 )j == tmp___18) {
        {
#line 580
        psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Layout section paragraph type unknown");
#line 581
        psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Unknown type - using base styles instead");
#line 582
        para->base_style = (psiconv_s16 )0;
#line 583
        temp_style = psiconv_get_style(styles___1, 0);
        }
#line 583
        if (! temp_style) {
          {
#line 584
          psiconv_error((psiconv_config )config, lev + 4, off, "Base style unknown");
          }
#line 585
          goto ERROR4;
        }
        {
#line 587
        temp_para = psiconv_clone_paragraph_layout(temp_style->paragraph);
        }
#line 587
        if (! temp_para) {
#line 589
          goto ERROR4;
        }
        {
#line 590
        psiconv_free_paragraph_layout(para->base_paragraph);
#line 591
        para->base_paragraph = temp_para;
#line 593
        temp_char = psiconv_clone_character_layout(temp_style->character);
        }
#line 593
        if (! temp_char) {
#line 595
          goto ERROR4;
        }
        {
#line 596
        psiconv_free_character_layout(para->base_character);
#line 597
        para->base_character = temp_char;
        }
      } else {
        {
#line 599
        para->base_style = anon_ptr->base_style;
#line 600
        temp_para = psiconv_clone_paragraph_layout(anon_ptr->paragraph);
        }
#line 600
        if (! temp_para) {
#line 601
          goto ERROR4;
        }
        {
#line 602
        psiconv_free_paragraph_layout(para->base_paragraph);
#line 603
        para->base_paragraph = temp_para;
#line 605
        temp_char = psiconv_clone_character_layout(anon_ptr->character);
        }
#line 605
        if (! temp_char) {
#line 606
          goto ERROR4;
        }
        {
#line 607
        psiconv_free_character_layout(para->base_character);
#line 608
        para->base_character = temp_char;
        }
      }
#line 610
      *(inline_count + i) = 0;
#line 611
      len ++;
    } else {
      {
#line 613
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Type: %02x (not based on a paragraph type)",
                    temp);
#line 615
      len ++;
      }
#line 616
      if (parse_styles) {
        {
#line 617
        temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
        }
#line 618
        if (res) {
#line 619
          goto ERROR4;
        }
        {
#line 620
        psiconv_progress((psiconv_config )config, lev + 4, ((off + (psiconv_u32 )len) + temp) + 4U,
                         "Going to read the paragraph element base style");
#line 622
        tmp___19 = psiconv_read_u8(config, buf, lev + 4, ((off + (psiconv_u32 )len) + temp) + 4U,
                                   & res);
#line 622
        temp = (psiconv_u32 )tmp___19;
        }
#line 623
        if (res) {
#line 624
          goto ERROR4;
        }
        {
#line 625
        psiconv_debug((psiconv_config )config, lev + 4, ((off + (psiconv_u32 )len) + temp) + 4U,
                      "Style: %02x", temp);
        }
      } else {
#line 627
        temp = (psiconv_u32 )0;
      }
      {
#line 629
      temp_style = psiconv_get_style(styles___1, (int )temp);
      }
#line 629
      if (! temp_style) {
        {
#line 630
        psiconv_warn((psiconv_config )config, lev + 4, off, "Unknown Style referenced");
#line 631
        temp_style = psiconv_get_style(styles___1, 0);
        }
#line 631
        if (! temp_style) {
          {
#line 632
          psiconv_error((psiconv_config )config, lev + 4, off, "Base style unknown");
          }
#line 633
          goto ERROR4;
        }
      }
      {
#line 637
      temp_para = psiconv_clone_paragraph_layout(temp_style->paragraph);
      }
#line 637
      if (! temp_para) {
#line 638
        goto ERROR4;
      }
      {
#line 639
      psiconv_free_paragraph_layout(para->base_paragraph);
#line 640
      para->base_paragraph = temp_para;
#line 642
      temp_char = psiconv_clone_character_layout(temp_style->character);
      }
#line 642
      if (! temp_char) {
#line 643
        goto ERROR4;
      }
      {
#line 644
      psiconv_free_character_layout(para->base_character);
#line 645
      para->base_character = temp_char;
#line 647
      para->base_style = (psiconv_s16 )temp;
#line 648
      psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                       "Going to read paragraph layout");
#line 649
      res = psiconv_parse_paragraph_layout_list(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                & leng, para->base_paragraph);
      }
#line 649
      if (res) {
#line 651
        goto ERROR4;
      }
#line 652
      len += leng;
#line 653
      if (parse_styles) {
#line 654
        len ++;
      }
      {
#line 655
      psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                       "Going to read number of in-line layout elements");
#line 657
      tmp___20 = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
#line 657
      *(inline_count + i) = (int )tmp___20;
      }
#line 658
      if (res) {
#line 659
        goto ERROR4;
      }
      {
#line 660
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Nr: %08x",
                    *(inline_count + i));
#line 661
      len += 4;
      }
    }
#line 530
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 665
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the text layout inline list");
#line 667
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the number of elements");
#line 668
  tmp___21 = psiconv_read_u32(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
#line 668
  nr = (int )tmp___21;
  }
#line 669
  if (res) {
#line 670
    goto ERROR4;
  }
  {
#line 671
  psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Elements: %08x",
                nr);
#line 672
  len += 4;
#line 674
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the text layout inline elements");
#line 676
  total = 0;
#line 677
  i = 0;
  }
  {
#line 677
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 677
    tmp___27 = psiconv_list_length((psiconv_list const   )result);
    }
#line 677
    if (! ((psiconv_u32 )i < tmp___27)) {
#line 677
      goto while_break___2;
    }
    {
#line 678
    tmp___22 = psiconv_list_get((psiconv_list const   )result, (psiconv_u32 )i);
#line 678
    para = (psiconv_paragraph )tmp___22;
    }
#line 678
    if (! para) {
      {
#line 679
      psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Data structure corruption");
      }
#line 680
      goto ERROR4;
    }
#line 682
    line_length = -1;
#line 683
    j = 0;
    {
#line 683
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 683
      if (! (j < *(inline_count + i))) {
#line 683
        goto while_break___3;
      }
      {
#line 684
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Element %d: Paragraph %d, element %d", total, i, j);
      }
#line 686
      if (total >= nr) {
        {
#line 687
        psiconv_warn((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Layout section inlines: not enough element");
#line 689
        psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Can\'t read element!");
        }
      } else {
        {
#line 691
        total ++;
#line 692
        in_line.object = (psiconv_embedded_object_section )((void *)0);
#line 693
        in_line.layout = (psiconv_character_layout )((void *)0);
#line 694
        in_line.layout = psiconv_clone_character_layout(para->base_character);
        }
#line 694
        if (! in_line.layout) {
#line 696
          goto ERROR4;
        }
        {
#line 697
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read the element type");
#line 698
        tmp___23 = psiconv_read_u8(config, buf, lev + 4, (psiconv_u32 )len + off,
                                   & res);
#line 698
        temp = (psiconv_u32 )tmp___23;
        }
#line 699
        if (res) {
#line 700
          goto ERROR5;
        }
        {
#line 701
        len ++;
#line 702
        psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Type: %02x",
                      temp);
#line 703
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read the number of characters it applies to");
#line 705
        tmp___24 = psiconv_read_u32(config, buf, lev + 4, (psiconv_u32 )len + off,
                                    & res);
#line 705
        in_line.length = (int )tmp___24;
        }
#line 706
        if (res) {
#line 707
          goto ERROR5;
        }
        {
#line 708
        psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Length: %02x",
                      in_line.length);
#line 709
        len += 4;
#line 710
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read the character layout");
#line 711
        res = psiconv_parse_character_layout_list(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                  & leng, in_line.layout);
        }
#line 711
        if (res) {
#line 713
          goto ERROR5;
        }
#line 714
        len += leng;
#line 716
        if (temp == 1U) {
          {
#line 717
          psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Found an embedded object");
#line 718
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to read the object marker (0x%08x expected)", 268435537);
#line 720
          temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
          }
#line 721
          if (res) {
#line 722
            goto ERROR5;
          }
#line 723
          if (temp != 268435537U) {
            {
#line 724
            psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Unknown id marks embedded object");
#line 725
            psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                          "Marker: read %08x, expected %08x", temp, 268435537);
            }
          }
          {
#line 728
          len += 4;
#line 729
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to read the Embedded Object Section offset");
#line 731
          temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
          }
#line 732
          if (res) {
#line 733
            goto ERROR5;
          }
          {
#line 734
          psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Offset: %08x", temp);
#line 735
          len += 4;
#line 736
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to parse the Embedded Object Section");
#line 738
          res = psiconv_parse_embedded_object_section(config, buf, lev + 4, temp,
                                                      (int *)((void *)0), & in_line.object);
          }
#line 738
          if (res) {
#line 740
            goto ERROR5;
          }
          {
#line 741
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to read the object width");
#line 743
          in_line.object_width = psiconv_read_length(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                     & leng, & res);
          }
#line 745
          if (res) {
#line 746
            goto ERROR5;
          }
          {
#line 747
          psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Object width: %f cm", (double )in_line.object_width);
#line 749
          len += leng;
#line 750
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to read the object height");
#line 752
          in_line.object_height = psiconv_read_length(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                      & leng, & res);
          }
#line 754
          if (res) {
#line 755
            goto ERROR5;
          }
          {
#line 756
          psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Object height: %f cm", (double )in_line.object_height);
#line 758
          len += leng;
          }
        } else
#line 759
        if (temp != 0U) {
          {
#line 760
          psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                       "Layout section unknown inline type");
          }
        }
        {
#line 762
        tmp___26 = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
        }
#line 762
        if (line_length + in_line.length > tmp___26) {
          {
#line 763
          psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                       "Layout section inlines: line length mismatch");
#line 765
          res = -1;
#line 766
          tmp___25 = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
#line 766
          in_line.length = tmp___25 - line_length;
          }
        }
        {
#line 768
        line_length += in_line.length;
#line 769
        res = psiconv_list_add(para->in_lines, (void const   *)(& in_line));
        }
#line 769
        if (res) {
#line 770
          goto ERROR5;
        }
      }
#line 683
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 677
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 775
  if (total != nr) {
    {
#line 776
    psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Layout section too many inlines, skipping remaining");
    }
  }
  {
#line 780
  free((void *)inline_count);
#line 782
  i = 0;
  }
  {
#line 782
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 782
    tmp___29 = psiconv_list_length((psiconv_list const   )anon_styles);
    }
#line 782
    if (! ((psiconv_u32 )i < tmp___29)) {
#line 782
      goto while_break___4;
    }
    {
#line 783
    tmp___28 = psiconv_list_get((psiconv_list const   )anon_styles, (psiconv_u32 )i);
#line 783
    anon_ptr = (anon_style )tmp___28;
    }
#line 783
    if (! anon_ptr) {
      {
#line 784
      psiconv_error((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Data structure corruption");
      }
#line 785
      goto ERROR2;
    }
    {
#line 787
    psiconv_free_character_layout(anon_ptr->character);
#line 788
    psiconv_free_paragraph_layout(anon_ptr->paragraph);
#line 782
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 790
  psiconv_list_free(anon_styles);
  }
#line 792
  if (length) {
#line 793
    *length = len;
  }
  {
#line 795
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of layout section (total length: %08x)", len);
  }
#line 798
  return (0);
  ERROR4_4: 
  {
#line 801
  psiconv_free_paragraph_layout(para->base_paragraph);
  }
  ERROR4_3: 
  {
#line 803
  psiconv_free_character_layout(para->base_character);
  }
  ERROR4_2: 
  {
#line 805
  psiconv_list_free(para->in_lines);
  }
  ERROR4_1: 
  {
#line 807
  free((void *)para);
  }
#line 808
  goto ERROR4;
  ERROR3_2: 
  {
#line 811
  psiconv_free_character_layout(anon.character);
  }
  ERROR3_1: 
  {
#line 813
  psiconv_free_paragraph_layout(anon.paragraph);
  }
#line 814
  goto ERROR3;
  ERROR5: 
#line 817
  if (in_line.layout) {
    {
#line 818
    psiconv_free_character_layout(in_line.layout);
    }
  }
#line 819
  if (in_line.object) {
    {
#line 820
    psiconv_free_embedded_object_section(in_line.object);
    }
  }
  ERROR4: 
  {
#line 822
  free((void *)inline_count);
  }
  ERROR3: 
#line 824
  i = 0;
  {
#line 824
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 824
    tmp___31 = psiconv_list_length((psiconv_list const   )anon_styles);
    }
#line 824
    if (! ((psiconv_u32 )i < tmp___31)) {
#line 824
      goto while_break___5;
    }
    {
#line 825
    tmp___30 = psiconv_list_get((psiconv_list const   )anon_styles, (psiconv_u32 )i);
#line 825
    anon_ptr = (anon_style )tmp___30;
    }
#line 825
    if (! anon_ptr) {
      {
#line 826
      psiconv_error((psiconv_config )config, lev + 1, off, "Data structure corruption");
      }
#line 827
      goto while_break___5;
    }
    {
#line 829
    psiconv_free_paragraph_layout(anon_ptr->paragraph);
#line 830
    psiconv_free_character_layout(anon_ptr->character);
#line 824
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  ERROR2: 
  {
#line 834
  psiconv_list_free(anon_styles);
  }
  ERROR1: 
  {
#line 836
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Layout Section failed");
  }
#line 837
  if (length) {
#line 838
    *length = 0;
  }
#line 839
  if (! res) {
#line 840
    return (-2);
  } else {
#line 842
    return (res);
  }
}
}
#line 1063 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
static psiconv_file_type_t psiconv_determine_embedded_object_type___2(psiconv_config const   config ,
                                                                      psiconv_buffer const   buf ,
                                                                      int lev , int *status ) 
{ 
  psiconv_u32 off ;
  psiconv_section_table_section table ;
  int res ;
  int i ;
  psiconv_file_type_t file_type ;
  psiconv_section_table_entry entry ;
  psiconv_application_id_section applid ;
  void *tmp ;
  psiconv_u32 tmp___0 ;
  psiconv_u32 tmp___1 ;

  {
  {
#line 1071
  file_type = (psiconv_file_type_t )0;
#line 1075
  psiconv_progress((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Going to determine embedded object file type");
#line 1076
  psiconv_progress((psiconv_config )config, lev + 2, (psiconv_u32 )0, "Going to read the Section Table Offset Section");
#line 1077
  off = psiconv_read_u32(config, buf, lev, (psiconv_u32 )0, & res);
  }
#line 1078
  if (res) {
#line 1079
    goto ERROR1;
  }
  {
#line 1080
  psiconv_debug((psiconv_config )config, lev + 2, (psiconv_u32 )0, "Offset: %08x",
                off);
#line 1082
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the Section Table Section");
#line 1083
  res = psiconv_parse_section_table_section(config, buf, lev + 2, off, (int *)((void *)0),
                                            & table);
  }
#line 1083
  if (res) {
#line 1084
    goto ERROR1;
  }
  {
#line 1086
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to search the Section Table Section for the Application ID Section");
#line 1088
  i = 0;
  }
  {
#line 1088
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1088
    tmp___0 = psiconv_list_length((psiconv_list const   )table);
    }
#line 1088
    if (! ((psiconv_u32 )i < tmp___0)) {
#line 1088
      goto while_break;
    }
    {
#line 1089
    psiconv_progress((psiconv_config )config, lev + 3, off, "Going to read entry %d",
                     i);
#line 1090
    tmp = psiconv_list_get((psiconv_list const   )table, (psiconv_u32 )i);
#line 1090
    entry = (psiconv_section_table_entry )tmp;
    }
#line 1090
    if (! entry) {
#line 1091
      goto ERROR2;
    }
#line 1092
    if (entry->id == 268435593U) {
      {
#line 1093
      psiconv_progress((psiconv_config )config, lev + 3, off, "Found the Application ID Section at offset %08x",
                       entry->offset);
#line 1096
      off = entry->offset;
      }
#line 1097
      goto while_break;
    }
#line 1088
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1100
  tmp___1 = psiconv_list_length((psiconv_list const   )table);
  }
#line 1100
  if ((psiconv_u32 )i == tmp___1) {
    {
#line 1101
    psiconv_error((psiconv_config )config, lev + 2, off, "No Application ID Section found");
#line 1102
    res = 3;
    }
#line 1103
    goto ERROR2;
  }
  {
#line 1106
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the Application ID Section");
#line 1107
  res = psiconv_parse_application_id_section(config, buf, lev + 2, off, (int *)((void *)0),
                                             & applid);
  }
#line 1107
  if (res) {
#line 1108
    goto ERROR2;
  }
  {
#line 1111
  if (applid->id == 268435583U) {
#line 1111
    goto case_268435583;
  }
#line 1114
  if (applid->id == 268435589U) {
#line 1114
    goto case_268435589;
  }
#line 1117
  if (applid->id == 268435581U) {
#line 1117
    goto case_268435581;
  }
#line 1120
  if (applid->id == 268435592U) {
#line 1120
    goto case_268435592;
  }
#line 1123
  goto switch_default;
  case_268435583: /* CIL Label */ 
  {
#line 1111
  file_type = (psiconv_file_type_t )1;
#line 1112
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found a Word file");
  }
#line 1113
  goto switch_break;
  case_268435589: /* CIL Label */ 
  {
#line 1114
  file_type = (psiconv_file_type_t )2;
#line 1115
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found a TextEd file");
  }
#line 1116
  goto switch_break;
  case_268435581: /* CIL Label */ 
  {
#line 1117
  file_type = (psiconv_file_type_t )4;
#line 1118
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found a Sketch file");
  }
#line 1119
  goto switch_break;
  case_268435592: /* CIL Label */ 
  {
#line 1120
  file_type = (psiconv_file_type_t )6;
#line 1121
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found a Sheet file");
  }
#line 1122
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1123
  psiconv_warn((psiconv_config )config, lev + 2, off, "Found an unknown file type");
#line 1124
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found ID %08x", applid->id);
  }
  switch_break: /* CIL Label */ ;
  }
  ERROR2: 
  {
#line 1128
  psiconv_free_application_id_section(applid);
  }
  ERROR1: 
  {
#line 1130
  psiconv_free_section_table_section(table);
  }
#line 1131
  if (status) {
#line 1132
    *status = res;
  }
#line 1133
  return (file_type);
}
}
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_common.c"
static int psiconv_write_layout_section___2(psiconv_config const   config , psiconv_buffer buf ,
                                            int lev , psiconv_text_and_layout const   value ,
                                            psiconv_word_styles_section const   styles___1 ,
                                            int with_styles ) ;
#line 166 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_common.c"
static int psiconv_write_layout_section___2(psiconv_config const   config , psiconv_buffer buf ,
                                            int lev , psiconv_text_and_layout const   value ,
                                            psiconv_word_styles_section const   styles___1 ,
                                            int with_styles ) 
{ 
  psiconv_u32 obj_id ;
  psiconv_list paragraph_type_list ;
  psiconv_paragraph_type_list paragraph_type ;
  struct psiconv_paragraph_type_list_s new_type ;
  psiconv_buffer buf_types ;
  psiconv_buffer buf_elements ;
  psiconv_buffer buf_inlines ;
  psiconv_buffer buf_objects ;
  psiconv_paragraph paragraph___3 ;
  psiconv_in_line_layout in_line ;
  psiconv_word_style style___1 ;
  psiconv_character_layout para_charlayout ;
  int i ;
  int j ;
  int para_type ;
  int nr_of_inlines ;
  int res ;
  int ptl_length ;
  int pel_length ;
  int thislen ;
  int paralen ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  psiconv_u32 tmp___2 ;
  psiconv_u32 tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  psiconv_u32 tmp___8 ;
  psiconv_u32 tmp___9 ;
  void *tmp___10 ;
  psiconv_u32 tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  psiconv_u32 tmp___15 ;
  psiconv_u32 tmp___16 ;
  psiconv_u32 tmp___17 ;
  psiconv_u32 tmp___18 ;
  psiconv_u32 tmp___19 ;
  psiconv_u32 tmp___20 ;
  psiconv_u32 tmp___21 ;
  int tmp___22 ;

  {
  {
#line 185
  in_line = (psiconv_in_line_layout )((void *)0);
#line 188
  nr_of_inlines = 0;
#line 190
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing layout section");
  }
#line 191
  if (! value) {
    {
#line 192
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null text section");
#line 193
    res = -4;
    }
#line 194
    goto ERROR1;
  }
  {
#line 197
  paragraph_type_list = psiconv_list_new(sizeof(new_type));
  }
#line 197
  if (! paragraph_type_list) {
    {
#line 198
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 199
    res = -2;
    }
#line 200
    goto ERROR1;
  }
  {
#line 203
  buf_types = psiconv_buffer_new();
  }
#line 203
  if (! buf_types) {
    {
#line 204
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 205
    res = -2;
    }
#line 206
    goto ERROR2;
  }
  {
#line 209
  buf_elements = psiconv_buffer_new();
  }
#line 209
  if (! buf_elements) {
    {
#line 210
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 211
    res = -2;
    }
#line 212
    goto ERROR3;
  }
  {
#line 215
  buf_inlines = psiconv_buffer_new();
  }
#line 215
  if (! buf_inlines) {
    {
#line 216
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 217
    res = -2;
    }
#line 218
    goto ERROR4;
  }
  {
#line 221
  buf_objects = psiconv_buffer_new();
  }
#line 221
  if (! buf_objects) {
    {
#line 222
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 223
    res = -2;
    }
#line 224
    goto ERROR5;
  }
#line 227
  i = 0;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 227
    tmp___18 = psiconv_list_length(value);
    }
#line 227
    if (! ((psiconv_u32 )i < tmp___18)) {
#line 227
      goto while_break;
    }
    {
#line 228
    tmp = psiconv_list_get(value, (psiconv_u32 )i);
#line 228
    paragraph___3 = (psiconv_paragraph )tmp;
    }
#line 228
    if (! paragraph___3) {
      {
#line 229
      psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Data structure corruption");
#line 230
      res = -2;
      }
#line 231
      goto ERROR6;
    }
    {
#line 233
    tmp___0 = psiconv_unicode_strlen((psiconv_ucs2 const   *)paragraph___3->text);
#line 233
    res = psiconv_write_u32(config, buf_elements, lev + 1, (psiconv_u32 const   )(tmp___0 + 1));
    }
#line 233
    if (res) {
#line 235
      goto ERROR6;
    }
    {
#line 238
    tmp___2 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
    }
#line 238
    if (tmp___2 == 1U) {
      {
#line 239
      tmp___1 = psiconv_list_get((psiconv_list const   )paragraph___3->in_lines, (psiconv_u32 )0);
#line 239
      in_line = (psiconv_in_line_layout )tmp___1;
      }
#line 239
      if (! in_line) {
        {
#line 240
        psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Data structure corruption");
#line 241
        res = -2;
        }
#line 242
        goto ERROR6;
      }
    }
    {
#line 245
    tmp___16 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
    }
#line 245
    if (tmp___16 > 1U) {
#line 245
      goto _L;
    } else {
      {
#line 245
      tmp___17 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
      }
#line 245
      if (tmp___17 == 1U) {
#line 245
        if ((unsigned long )in_line->object != (unsigned long )((void *)0)) {
          _L: /* CIL Label */ 
          {
#line 250
          res = psiconv_write_u8(config, buf_elements, lev + 1, (psiconv_u8 const   )0);
          }
#line 250
          if (res) {
#line 251
            goto ERROR6;
          }
          {
#line 252
          style___1 = psiconv_get_style((psiconv_word_styles_section )styles___1,
                                        (int )paragraph___3->base_style);
          }
#line 252
          if (! style___1) {
            {
#line 253
            psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Unknown style");
#line 254
            res = -4;
            }
#line 255
            goto ERROR6;
          }
          {
#line 257
          res = psiconv_write_paragraph_layout_list(config, buf_elements, lev + 1,
                                                    (psiconv_paragraph_layout const   )paragraph___3->base_paragraph,
                                                    (psiconv_paragraph_layout const   )style___1->paragraph);
          }
#line 257
          if (res) {
#line 260
            goto ERROR6;
          }
#line 261
          if (with_styles) {
            {
#line 262
            res = psiconv_write_u8(config, buf_elements, lev + 1, (psiconv_u8 const   )paragraph___3->base_style);
            }
#line 262
            if (res) {
#line 263
              goto ERROR6;
            }
          }
          {
#line 264
          tmp___3 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
#line 264
          res = psiconv_write_u32(config, buf_elements, lev + 1, (psiconv_u32 const   )tmp___3);
          }
#line 264
          if (res) {
#line 266
            goto ERROR6;
          }
#line 269
          paralen = 0;
#line 270
          j = 0;
          {
#line 270
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 270
            tmp___9 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
            }
#line 270
            if (! ((psiconv_u32 )j < tmp___9)) {
#line 270
              goto while_break___0;
            }
            {
#line 271
            nr_of_inlines ++;
#line 272
            tmp___4 = psiconv_list_get((psiconv_list const   )paragraph___3->in_lines,
                                       (psiconv_u32 )j);
#line 272
            in_line = (psiconv_in_line_layout )tmp___4;
            }
#line 272
            if (! in_line) {
              {
#line 273
              psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Data structure corruption");
#line 274
              res = -2;
              }
#line 275
              goto ERROR6;
            }
#line 277
            if (in_line->object) {
#line 277
              tmp___5 = 1;
            } else {
#line 277
              tmp___5 = 0;
            }
            {
#line 277
            res = psiconv_write_u8(config, buf_inlines, lev + 1, (psiconv_u8 const   )tmp___5);
            }
#line 277
            if (res) {
#line 278
              goto ERROR6;
            }
            {
#line 279
            thislen = in_line->length;
#line 280
            paralen += thislen;
#line 283
            tmp___8 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
            }
#line 283
            if ((psiconv_u32 )j == tmp___8 - 1U) {
              {
#line 284
              tmp___6 = psiconv_unicode_strlen((psiconv_ucs2 const   *)paragraph___3->text);
              }
#line 284
              if (paralen > tmp___6 + 1) {
                {
#line 285
                psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Inline formatting data length and line length are inconsistent");
#line 286
                res = -4;
                }
#line 287
                goto ERROR6;
              }
              {
#line 289
              tmp___7 = psiconv_unicode_strlen((psiconv_ucs2 const   *)paragraph___3->text);
#line 289
              thislen += (tmp___7 + 1) - paralen;
              }
            }
            {
#line 291
            res = psiconv_write_u32(config, buf_inlines, lev + 1, (psiconv_u32 const   )thislen);
            }
#line 291
            if (res) {
#line 292
              goto ERROR6;
            }
            {
#line 293
            res = psiconv_write_character_layout_list(config, buf_inlines, lev + 1,
                                                      (psiconv_character_layout const   )in_line->layout,
                                                      (psiconv_character_layout const   )style___1->character);
            }
#line 293
            if (res) {
#line 296
              goto ERROR6;
            }
#line 297
            if (in_line->object) {
              {
#line 298
              res = psiconv_write_u32(config, buf_inlines, lev + 1, (psiconv_u32 const   )268435537);
              }
#line 298
              if (res) {
#line 299
                goto ERROR6;
              }
              {
#line 300
              obj_id = psiconv_buffer_unique_id();
#line 301
              res = psiconv_buffer_add_reference(buf_inlines, (int )obj_id);
              }
#line 301
              if (res) {
                {
#line 302
                psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
                }
#line 303
                goto ERROR6;
              }
              {
#line 305
              res = psiconv_buffer_add_target(buf_objects, (int )obj_id);
              }
#line 305
              if (res) {
                {
#line 306
                psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
                }
#line 307
                goto ERROR6;
              }
              {
#line 309
              res = psiconv_write_embedded_object_section(config, buf_objects, lev + 1,
                                                          (psiconv_embedded_object_section const   )in_line->object);
              }
#line 309
              if (res) {
#line 311
                goto ERROR6;
              }
              {
#line 312
              res = psiconv_write_length(config, buf_inlines, lev + 1, (psiconv_length_t const   )in_line->object_width);
              }
#line 312
              if (res) {
#line 313
                goto ERROR6;
              }
              {
#line 314
              res = psiconv_write_length(config, buf_inlines, lev + 1, (psiconv_length_t const   )in_line->object_height);
              }
#line 314
              if (res) {
#line 315
                goto ERROR6;
              }
            }
#line 270
            j ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
#line 245
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 320
        para_type = 0;
#line 322
        tmp___11 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
        }
#line 322
        if (tmp___11 == 0U) {
#line 323
          para_charlayout = paragraph___3->base_character;
        } else {
          {
#line 325
          tmp___10 = psiconv_list_get((psiconv_list const   )paragraph___3->in_lines,
                                      (psiconv_u32 )0);
#line 325
          in_line = (psiconv_in_line_layout )tmp___10;
          }
#line 325
          if (! in_line) {
            {
#line 326
            psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Data structure corruption");
#line 327
            res = -2;
            }
#line 328
            goto ERROR6;
          }
#line 330
          para_charlayout = in_line->layout;
        }
#line 332
        j = 0;
        {
#line 332
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 332
          tmp___15 = psiconv_list_length((psiconv_list const   )paragraph_type_list);
          }
#line 332
          if (! ((psiconv_u32 )j < tmp___15)) {
#line 332
            goto while_break___1;
          }
          {
#line 333
          tmp___12 = psiconv_list_get((psiconv_list const   )paragraph_type_list,
                                      (psiconv_u32 )j);
#line 333
          paragraph_type = (psiconv_paragraph_type_list )tmp___12;
          }
#line 333
          if (! paragraph_type) {
            {
#line 334
            psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Data structure corruption");
#line 335
            res = -2;
            }
#line 336
            goto ERROR6;
          }
#line 338
          if ((int )paragraph___3->base_style == (int )paragraph_type->style) {
            {
#line 338
            tmp___13 = psiconv_compare_character_layout((psiconv_character_layout const   )para_charlayout,
                                                        (psiconv_character_layout const   )paragraph_type->character);
            }
#line 338
            if (! tmp___13) {
              {
#line 338
              tmp___14 = psiconv_compare_paragraph_layout((psiconv_paragraph_layout const   )paragraph___3->base_paragraph,
                                                          (psiconv_paragraph_layout const   )paragraph_type->paragraph);
              }
#line 338
              if (! tmp___14) {
#line 343
                para_type = (int )paragraph_type->nr;
#line 344
                goto while_break___1;
              }
            }
          }
#line 332
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 347
        if (! para_type) {
          {
#line 349
          new_type.nr = (psiconv_u8 )(j + 1);
#line 349
          para_type = (int )new_type.nr;
#line 351
          new_type.paragraph = paragraph___3->base_paragraph;
#line 352
          new_type.character = para_charlayout;
#line 353
          new_type.style = (psiconv_u8 )paragraph___3->base_style;
#line 354
          paragraph_type = & new_type;
#line 355
          res = psiconv_list_add(paragraph_type_list, (void const   *)paragraph_type);
          }
#line 355
          if (res) {
            {
#line 356
            psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
            }
#line 357
            goto ERROR6;
          }
          {
#line 359
          res = psiconv_write_u32(config, buf_types, lev + 1, (psiconv_u32 const   )paragraph_type->nr);
          }
#line 359
          if (res) {
#line 360
            goto ERROR6;
          }
          {
#line 361
          style___1 = psiconv_get_style((psiconv_word_styles_section )styles___1,
                                        (int )paragraph_type->style);
          }
#line 361
          if (! style___1) {
            {
#line 362
            psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Unknown style");
#line 363
            res = -4;
            }
#line 364
            goto ERROR6;
          }
          {
#line 366
          res = psiconv_write_paragraph_layout_list(config, buf_types, lev + 1, (psiconv_paragraph_layout const   )paragraph_type->paragraph,
                                                    (psiconv_paragraph_layout const   )style___1->paragraph);
          }
#line 366
          if (res) {
#line 368
            goto ERROR6;
          }
#line 369
          if (with_styles) {
            {
#line 370
            res = psiconv_write_u8(config, buf_types, lev + 1, (psiconv_u8 const   )paragraph_type->style);
            }
#line 370
            if (res) {
#line 371
              goto ERROR6;
            }
          }
          {
#line 372
          res = psiconv_write_character_layout_list(config, buf_types, lev + 1, (psiconv_character_layout const   )paragraph_type->character,
                                                    (psiconv_character_layout const   )style___1->character);
          }
#line 372
          if (res) {
#line 374
            goto ERROR6;
          }
        }
        {
#line 376
        res = psiconv_write_u8(config, buf_elements, lev + 1, (psiconv_u8 const   )para_type);
        }
#line 376
        if (res) {
#line 377
          goto ERROR6;
        }
      }
    }
#line 227
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 382
  tmp___21 = psiconv_list_length(value);
  }
#line 382
  if (tmp___21) {
    {
#line 400
    tmp___19 = psiconv_list_length(value);
#line 400
    pel_length = (int )tmp___19;
#line 401
    tmp___20 = psiconv_list_length((psiconv_list const   )paragraph_type_list);
#line 401
    ptl_length = (int )tmp___20;
    }
  } else {
    {
#line 383
    res = psiconv_write_u32(config, buf_types, lev + 1, (psiconv_u32 const   )1);
    }
#line 383
    if (res) {
#line 384
      goto ERROR6;
    }
    {
#line 385
    res = psiconv_write_u32(config, buf_types, lev + 1, (psiconv_u32 const   )0);
    }
#line 385
    if (res) {
#line 386
      goto ERROR6;
    }
#line 387
    if (with_styles) {
      {
#line 388
      res = psiconv_write_u8(config, buf_types, lev + 1, (psiconv_u8 const   )0);
      }
#line 388
      if (res) {
#line 389
        goto ERROR6;
      }
    }
    {
#line 390
    res = psiconv_write_u32(config, buf_types, lev + 1, (psiconv_u32 const   )0);
    }
#line 390
    if (res) {
#line 391
      goto ERROR6;
    }
    {
#line 393
    res = psiconv_write_u32(config, buf_elements, lev + 1, (psiconv_u32 const   )1);
    }
#line 393
    if (res) {
#line 394
      goto ERROR6;
    }
    {
#line 395
    res = psiconv_write_u8(config, buf_elements, lev + 1, (psiconv_u8 const   )1);
    }
#line 395
    if (res) {
#line 396
      goto ERROR6;
    }
#line 397
    pel_length = 1;
#line 398
    ptl_length = 1;
  }
#line 405
  if (with_styles) {
#line 405
    tmp___22 = 1;
  } else {
#line 405
    tmp___22 = 0;
  }
  {
#line 405
  res = psiconv_write_u16(config, buf, lev + 1, (psiconv_u16 const   )tmp___22);
  }
#line 405
  if (res) {
#line 406
    goto ERROR6;
  }
  {
#line 407
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )ptl_length);
  }
#line 407
  if (res) {
#line 408
    goto ERROR6;
  }
  {
#line 409
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )buf_types);
  }
#line 409
  if (res) {
    {
#line 410
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 411
    goto ERROR6;
  }
  {
#line 413
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )pel_length);
  }
#line 413
  if (res) {
#line 414
    goto ERROR6;
  }
  {
#line 415
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )buf_elements);
  }
#line 415
  if (res) {
    {
#line 416
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 417
    goto ERROR6;
  }
  {
#line 419
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )nr_of_inlines);
  }
#line 419
  if (res) {
#line 420
    goto ERROR6;
  }
  {
#line 421
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )buf_inlines);
  }
#line 421
  if (res) {
    {
#line 422
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 423
    goto ERROR6;
  }
  {
#line 425
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )buf_objects);
  }
#line 425
  if (res) {
    {
#line 426
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 427
    goto ERROR6;
  }
  ERROR6: 
  {
#line 431
  psiconv_buffer_free(buf_objects);
  }
  ERROR5: 
  {
#line 433
  psiconv_buffer_free(buf_inlines);
  }
  ERROR4: 
  {
#line 435
  psiconv_buffer_free(buf_elements);
  }
  ERROR3: 
  {
#line 437
  psiconv_buffer_free(buf_types);
  }
  ERROR2: 
  {
#line 439
  psiconv_list_free(paragraph_type_list);
  }
  ERROR1: 
#line 441
  if (res) {
    {
#line 442
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of layout section failed");
    }
  } else {
    {
#line 444
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of layout section");
    }
  }
#line 445
  return (res);
}
}
#line 36 "../../compat/getopt.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 140
extern int getopt_long(int __argc , char * const  *__argv , char const   *__shortopts ,
                       struct option  const  *__longopts , int *__longind ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 695
extern int puts(char const   *__s ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 26 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen.h"
void init_xhtml(void) ;
#line 34
void init_image(void) ;
#line 47 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/psiconv.c"
static void print_help(void) ;
#line 48
static void print_version(void) ;
#line 49
static void strtoupper(char *str ) ;
#line 51 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/psiconv.c"
static void print_help(void) 
{ 
  fileformat ff___1 ;
  int i ;
  int j ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  psiconv_u32 tmp___8 ;

  {
  {
#line 56
  puts("Syntax: psiconv [OPTIONS..] [FILE]");
#line 57
  puts("Convert the psion file FILE to other formats");
#line 58
  puts("If FILE is not specified, use stdin");
#line 59
  puts("  -c, --configfile=FILE Read extra configuration file after normal ones");
#line 60
  puts("  -e, --encoding=ENC    Output encoding (default: UTF8)");
#line 61
  puts("  -h, --help            Display this help and exit");
#line 62
  puts("  -n, --noise=LEVEL     Select what to print on stderr (overrides psiconv.conf)");
#line 63
  puts("  -o, --outputfile      Output to file instead of stdout");
#line 64
  puts("  -T, --type=FILETYPE   Output type (default: XHTML or TIFF");
#line 65
  puts("  -V, --version         Display the program version and exit");
#line 66
  puts("");
#line 67
  puts("The following encodings are currently supported:");
#line 68
  puts("  UTF8    Variable length Unicode encoding");
#line 69
  puts("  UCS2    Fixed 16-bit length Unicode encoding");
#line 70
  puts("  Psion   The encoding your Psion uses (as in psiconv.conf)");
#line 71
  puts("  ASCII   7-bit ASCII (other symbols are substituted by \'?\')");
#line 72
  puts("");
#line 73
  puts("The following noise levels are currently supported:");
#line 74
  puts("  1 or F: Fatal errors only");
#line 75
  puts("  2 or E: Errors");
#line 76
  puts("  3 or W: Warnings");
#line 77
  puts("  4 or P: Progress indicators");
#line 78
  puts("  5 or D: Debug data");
#line 79
  puts("");
#line 80
  puts("The following abbreviations are used in the output types list:");
#line 81
  puts("  C  - processes ClipArt files");
#line 82
  puts("  c  - processes ClipArt files containing only one image");
#line 83
  puts("  M  - processes MBM files");
#line 84
  puts("  m  - processes MBM files containing only one image");
#line 85
  puts("  S  - processes Sketch files");
#line 86
  puts("  T  - processes TextEd files");
#line 87
  puts("  W  - processes Word files");
#line 88
  puts("");
#line 89
  puts("The following output types are known:");
#line 90
  i = 0;
  }
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 90
    tmp___8 = psiconv_list_length((psiconv_list const   )fileformat_list);
    }
#line 90
    if (! ((psiconv_u32 )i < tmp___8)) {
#line 90
      goto while_break;
    }
    {
#line 91
    tmp = psiconv_list_get((psiconv_list const   )fileformat_list, (psiconv_u32 )i);
#line 91
    ff___1 = (fileformat )tmp;
#line 92
    printf((char const   */* __restrict  */)"  %s", ff___1->name);
#line 93
    tmp___0 = strlen(ff___1->name);
#line 93
    j = (int )tmp___0;
    }
    {
#line 93
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 93
      if (! (j < 10)) {
#line 93
        goto while_break___0;
      }
      {
#line 94
      putchar(' ');
#line 93
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 95
    if (ff___1->supported_format & 1) {
#line 95
      tmp___1 = 'W';
    } else {
#line 95
      tmp___1 = ' ';
    }
#line 95
    if (ff___1->supported_format & 2) {
#line 95
      tmp___2 = 'T';
    } else {
#line 95
      tmp___2 = ' ';
    }
#line 95
    if (ff___1->supported_format & 64) {
#line 95
      tmp___3 = 'S';
    } else {
#line 95
      tmp___3 = ' ';
    }
#line 95
    if (ff___1->supported_format & 32) {
#line 95
      tmp___5 = 'M';
    } else {
#line 95
      if (ff___1->supported_format & 16) {
#line 95
        tmp___4 = 'm';
      } else {
#line 95
        tmp___4 = ' ';
      }
#line 95
      tmp___5 = tmp___4;
    }
#line 95
    if (ff___1->supported_format & 8) {
#line 95
      tmp___7 = 'C';
    } else {
#line 95
      if (ff___1->supported_format & 4) {
#line 95
        tmp___6 = 'c';
      } else {
#line 95
        tmp___6 = ' ';
      }
#line 95
      tmp___7 = tmp___6;
    }
    {
#line 95
    printf((char const   */* __restrict  */)"[%c%c%c%c%c] ", tmp___7, tmp___5, tmp___3,
           tmp___2, tmp___1);
#line 103
    puts(ff___1->description);
#line 90
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 105
  puts("");
#line 106
  puts("When using UTF8 with LaTeX type, the resulting LaTeX source should be converted");
#line 107
  puts(" to a suitable encoding for your LaTeX installation before being typeset");
  }
#line 108
  return;
}
}
#line 110 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/psiconv.c"
static void print_version(void) 
{ 


  {
  {
#line 112
  printf((char const   */* __restrict  */)"Version %s\n", "0.9.8");
  }
#line 113
  return;
}
}
#line 115 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/psiconv.c"
static void strtoupper(char *str ) 
{ 
  int i ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 118
    tmp___0 = strlen((char const   *)str);
    }
#line 118
    if (! ((size_t )i < tmp___0)) {
#line 118
      goto while_break;
    }
    {
#line 119
    tmp = toupper((int )*(str + i));
#line 119
    *(str + i) = (char )tmp;
#line 118
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return;
}
}
#line 36 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle8___2(psiconv_config const   config , int lev , psiconv_u32 off ,
                                   psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) ;
#line 41
static int psiconv_decode_rle12___2(psiconv_config const   config , int lev , psiconv_u32 off ,
                                    psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) ;
#line 46
static int psiconv_decode_rle16___2(psiconv_config const   config , int lev , psiconv_u32 off ,
                                    psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) ;
#line 51
static int psiconv_decode_rle24___2(psiconv_config const   config , int lev , psiconv_u32 off ,
                                    psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) ;
#line 56
static int psiconv_bytes_to_pixel_data___2(psiconv_config const   config , int lev ,
                                           psiconv_u32 off , psiconv_pixel_bytes const   bytes ,
                                           psiconv_pixel_ints *pixels , int colordepth ,
                                           int xsize , int ysize ) ;
#line 62
static int psiconv_pixel_data_to_floats___2(psiconv_config const   config , int lev ,
                                            psiconv_u32 off , psiconv_pixel_ints const   pixels ,
                                            psiconv_pixel_floats_t *floats , int colordepth ,
                                            int color___1 , int redbits , int bluebits ,
                                            int greenbits , psiconv_pixel_floats_t const   palet ) ;
#line 647 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle8___2(psiconv_config const   config , int lev , psiconv_u32 off ,
                                   psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) 
{ 
  int res ;
  psiconv_u8 *marker ;
  psiconv_u8 *value ;
  int i ;
  int j ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  psiconv_u32 tmp___3 ;

  {
  {
#line 651
  res = 0;
#line 655
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to decode the RLE8 encoding");
#line 656
  tmp = psiconv_list_new(sizeof(psiconv_u8 ));
#line 656
  *decoded = tmp;
  }
#line 656
  if (! tmp) {
#line 657
    goto ERROR1;
  }
#line 659
  i = 0;
  {
#line 659
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 659
    tmp___3 = psiconv_list_length(encoded);
    }
#line 659
    if (! ((psiconv_u32 )i < tmp___3)) {
#line 659
      goto while_break;
    }
    {
#line 663
    tmp___0 = psiconv_list_get(encoded, (psiconv_u32 )i);
#line 663
    marker = (psiconv_u8 *)tmp___0;
    }
#line 663
    if (! marker) {
#line 664
      goto ERROR2;
    }
#line 668
    if ((int )*marker < 128) {
      {
#line 674
      tmp___1 = psiconv_list_get(encoded, (psiconv_u32 )(i + 1));
#line 674
      value = (psiconv_u8 *)tmp___1;
      }
#line 674
      if (! value) {
#line 675
        goto ERROR2;
      }
#line 681
      j = 0;
      {
#line 681
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 681
        if (! (j < (int )*marker + 1)) {
#line 681
          goto while_break___0;
        }
        {
#line 682
        res = psiconv_list_add(*decoded, (void const   *)value);
        }
#line 682
        if (res) {
#line 683
          goto ERROR2;
        }
#line 681
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 684
      i += 2;
    } else {
#line 690
      j = 0;
      {
#line 690
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 690
        if (! (j < 256 - (int )*marker)) {
#line 690
          goto while_break___1;
        }
        {
#line 695
        tmp___2 = psiconv_list_get(encoded, (psiconv_u32 )((i + j) + 1));
#line 695
        value = (psiconv_u8 *)tmp___2;
        }
#line 695
        if (! value) {
#line 696
          goto ERROR2;
        }
        {
#line 700
        res = psiconv_list_add(*decoded, (void const   *)value);
        }
#line 700
        if (res) {
#line 701
          goto ERROR2;
        }
#line 690
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 703
      i += (256 - (int )*marker) + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 706
  psiconv_progress((psiconv_config )config, lev, off, "End of RLE8 decoding process");
  }
#line 708
  return (0);
  ERROR2: 
  {
#line 711
  psiconv_list_free(*decoded);
  }
  ERROR1: 
  {
#line 713
  psiconv_error((psiconv_config )config, lev + 1, off, "Decoding of RLE8 failed");
  }
#line 714
  if (! res) {
#line 715
    return (-2);
  } else {
#line 717
    return (res);
  }
}
}
#line 720 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle12___2(psiconv_config const   config , int lev , psiconv_u32 off ,
                                    psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) 
{ 
  int res ;
  psiconv_u8 *value0 ;
  psiconv_u8 *value1 ;
  psiconv_u32 value ;
  psiconv_u32 repeat ;
  int i ;
  int j ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  psiconv_u32 tmp___2 ;

  {
  {
#line 724
  res = 0;
#line 729
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to decode the RLE12 encoding");
#line 730
  tmp = psiconv_list_new(sizeof(psiconv_u8 ));
#line 730
  *decoded = tmp;
  }
#line 730
  if (! tmp) {
#line 731
    goto ERROR1;
  }
#line 733
  i = 0;
  {
#line 733
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 733
    tmp___2 = psiconv_list_length(encoded);
    }
#line 733
    if (! ((psiconv_u32 )i < tmp___2)) {
#line 733
      goto while_break;
    }
    {
#line 734
    psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read data word at %04x",
                     i);
#line 735
    tmp___0 = psiconv_list_get(encoded, (psiconv_u32 )i);
#line 735
    value0 = (psiconv_u8 *)tmp___0;
    }
#line 735
    if (! value0) {
#line 736
      goto ERROR2;
    }
    {
#line 737
    tmp___1 = psiconv_list_get(encoded, (psiconv_u32 )(i + 1));
#line 737
    value1 = (psiconv_u8 *)tmp___1;
    }
#line 737
    if (! value1) {
#line 738
      goto ERROR2;
    }
    {
#line 739
    psiconv_debug((psiconv_config )config, lev + 2, off, "Data Word: %04x", (int )*value0 + ((int )*value1 << 8));
#line 740
    value = (psiconv_u32 )((int )*value0 + (((int )*value1 & 15) << 8));
#line 741
    repeat = (psiconv_u32 )(((int )*value1 >> 4) + 1);
#line 742
    psiconv_progress((psiconv_config )config, lev + 2, off, "Adding %02x pixels %03x",
                     repeat, value);
#line 744
    j = 0;
    }
    {
#line 744
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 744
      if (! ((psiconv_u32 )j < repeat)) {
#line 744
        goto while_break___0;
      }
      {
#line 745
      res = psiconv_list_add(*decoded, (void const   *)(& value));
      }
#line 745
      if (res) {
#line 746
        goto ERROR2;
      }
#line 744
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 747
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 749
  psiconv_progress((psiconv_config )config, lev, off, "End of RLE12 decoding process");
  }
#line 751
  return (0);
  ERROR2: 
  {
#line 754
  psiconv_list_free(*decoded);
  }
  ERROR1: 
  {
#line 756
  psiconv_error((psiconv_config )config, lev + 1, off, "Decoding of RLE12 failed");
  }
#line 757
  if (! res) {
#line 758
    return (-2);
  } else {
#line 760
    return (res);
  }
}
}
#line 763 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle16___2(psiconv_config const   config , int lev , psiconv_u32 off ,
                                    psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) 
{ 
  int res ;
  psiconv_u8 *marker ;
  psiconv_u8 *value0 ;
  psiconv_u8 *value1 ;
  psiconv_u32 value ;
  int i ;
  int j ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  psiconv_u32 tmp___5 ;

  {
  {
#line 767
  res = 0;
#line 772
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to decode the RLE16 encoding");
#line 773
  tmp = psiconv_list_new(sizeof(psiconv_u8 ));
#line 773
  *decoded = tmp;
  }
#line 773
  if (! tmp) {
#line 774
    goto ERROR1;
  }
#line 776
  i = 0;
  {
#line 776
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 776
    tmp___5 = psiconv_list_length(encoded);
    }
#line 776
    if (! ((psiconv_u32 )i < tmp___5)) {
#line 776
      goto while_break;
    }
    {
#line 777
    psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read marker byte at %04x",
                     i);
#line 778
    tmp___0 = psiconv_list_get(encoded, (psiconv_u32 )i);
#line 778
    marker = (psiconv_u8 *)tmp___0;
    }
#line 778
    if (! marker) {
#line 779
      goto ERROR2;
    }
    {
#line 780
    psiconv_debug((psiconv_config )config, lev + 2, off, "Marker byte: %02x", (int )*marker);
    }
#line 781
    if ((int )*marker < 128) {
      {
#line 782
      psiconv_debug((psiconv_config )config, lev + 2, off, "Marker: repeat value word %02x times",
                    (int )*marker + 1);
#line 784
      psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read value word at %04x",
                       i + 1);
#line 785
      tmp___1 = psiconv_list_get(encoded, (psiconv_u32 )(i + 1));
#line 785
      value0 = (psiconv_u8 *)tmp___1;
      }
#line 785
      if (! value0) {
#line 786
        goto ERROR2;
      }
      {
#line 787
      tmp___2 = psiconv_list_get(encoded, (psiconv_u32 )(i + 2));
#line 787
      value1 = (psiconv_u8 *)tmp___2;
      }
#line 787
      if (! value1) {
#line 788
        goto ERROR2;
      }
      {
#line 789
      value = (psiconv_u32 )((int )*value0 + ((int )*value1 << 8));
#line 790
      psiconv_debug((psiconv_config )config, lev + 2, off, "Value word: %02x", value);
#line 791
      psiconv_progress((psiconv_config )config, lev + 2, off, "Adding %02x pixels %04x",
                       (int )*marker + 1, value);
#line 793
      j = 0;
      }
      {
#line 793
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 793
        if (! (j < (int )*marker + 1)) {
#line 793
          goto while_break___0;
        }
        {
#line 794
        res = psiconv_list_add(*decoded, (void const   *)(& value));
        }
#line 794
        if (res) {
#line 795
          goto ERROR2;
        }
#line 793
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 796
      i += 3;
    } else {
      {
#line 798
      psiconv_debug((psiconv_config )config, lev + 2, off, "Marker: %02x value words follow",
                    256 - (int )*marker);
#line 800
      j = 0;
      }
      {
#line 800
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 800
        if (! (j < 256 - (int )*marker)) {
#line 800
          goto while_break___1;
        }
        {
#line 801
        psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read value word at %04x",
                         (i + j * 2) + 1);
#line 803
        tmp___3 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 2) + 1));
#line 803
        value0 = (psiconv_u8 *)tmp___3;
        }
#line 803
        if (! value0) {
#line 804
          goto ERROR2;
        }
        {
#line 805
        tmp___4 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 2) + 2));
#line 805
        value1 = (psiconv_u8 *)tmp___4;
        }
#line 805
        if (! value1) {
#line 806
          goto ERROR2;
        }
        {
#line 807
        value = (psiconv_u32 )((int )*value0 + ((int )*value1 << 8));
#line 808
        psiconv_debug((psiconv_config )config, lev + 2, off, "Value: %04x", value);
#line 809
        res = psiconv_list_add(*decoded, (void const   *)(& value));
        }
#line 809
        if (res) {
#line 810
          goto ERROR2;
        }
#line 800
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 812
      i += (256 - (int )*marker) * 2 + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 815
  psiconv_progress((psiconv_config )config, lev, off, "End of RLE16 decoding process");
  }
#line 817
  return (0);
  ERROR2: 
  {
#line 820
  psiconv_list_free(*decoded);
  }
  ERROR1: 
  {
#line 822
  psiconv_error((psiconv_config )config, lev + 1, off, "Decoding of RLE16 failed");
  }
#line 823
  if (! res) {
#line 824
    return (-2);
  } else {
#line 826
    return (res);
  }
}
}
#line 829 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle24___2(psiconv_config const   config , int lev , psiconv_u32 off ,
                                    psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) 
{ 
  int res ;
  psiconv_u8 *marker ;
  psiconv_u8 *value0 ;
  psiconv_u8 *value1 ;
  psiconv_u8 *value2 ;
  psiconv_u32 value ;
  int i ;
  int j ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  psiconv_u32 tmp___7 ;

  {
  {
#line 833
  res = 0;
#line 838
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to decode the RLE24 encoding");
#line 839
  tmp = psiconv_list_new(sizeof(psiconv_u8 ));
#line 839
  *decoded = tmp;
  }
#line 839
  if (! tmp) {
#line 840
    goto ERROR1;
  }
#line 842
  i = 0;
  {
#line 842
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 842
    tmp___7 = psiconv_list_length(encoded);
    }
#line 842
    if (! ((psiconv_u32 )i < tmp___7)) {
#line 842
      goto while_break;
    }
    {
#line 843
    psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read marker byte at %04x",
                     i);
#line 844
    tmp___0 = psiconv_list_get(encoded, (psiconv_u32 )i);
#line 844
    marker = (psiconv_u8 *)tmp___0;
    }
#line 844
    if (! marker) {
#line 845
      goto ERROR2;
    }
    {
#line 846
    psiconv_debug((psiconv_config )config, lev + 2, off, "Marker byte: %02x", (int )*marker);
    }
#line 847
    if ((int )*marker < 128) {
      {
#line 848
      psiconv_debug((psiconv_config )config, lev + 2, off, "Marker: repeat value byte triplet %02x times",
                    (int )*marker + 1);
#line 850
      psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read value byte triplet at %04x",
                       i + 1);
#line 851
      tmp___1 = psiconv_list_get(encoded, (psiconv_u32 )(i + 1));
#line 851
      value0 = (psiconv_u8 *)tmp___1;
      }
#line 851
      if (! value0) {
#line 852
        goto ERROR2;
      }
      {
#line 853
      tmp___2 = psiconv_list_get(encoded, (psiconv_u32 )(i + 2));
#line 853
      value1 = (psiconv_u8 *)tmp___2;
      }
#line 853
      if (! value1) {
#line 854
        goto ERROR2;
      }
      {
#line 855
      tmp___3 = psiconv_list_get(encoded, (psiconv_u32 )(i + 3));
#line 855
      value2 = (psiconv_u8 *)tmp___3;
      }
#line 855
      if (! value2) {
#line 856
        goto ERROR2;
      }
      {
#line 857
      value = (psiconv_u32 )(((int )*value0 + ((int )*value1 << 8)) + ((int )*value2 << 16));
#line 858
      psiconv_debug((psiconv_config )config, lev + 2, off, "Value byte triplet: %06x",
                    value);
#line 859
      psiconv_progress((psiconv_config )config, lev + 2, off, "Adding %02x pixels %06x",
                       (int )*marker + 1, value);
#line 861
      j = 0;
      }
      {
#line 861
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 861
        if (! (j < (int )*marker + 1)) {
#line 861
          goto while_break___0;
        }
        {
#line 862
        res = psiconv_list_add(*decoded, (void const   *)(& value));
        }
#line 862
        if (res) {
#line 863
          goto ERROR2;
        }
#line 861
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 864
      i += 4;
    } else {
      {
#line 866
      psiconv_debug((psiconv_config )config, lev + 2, off, "Marker: %02x value byte triplets follow",
                    256 - (int )*marker);
#line 868
      j = 0;
      }
      {
#line 868
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 868
        if (! (j < 256 - (int )*marker)) {
#line 868
          goto while_break___1;
        }
        {
#line 869
        psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read value byte triplets at %04x",
                         (i + j * 3) + 1);
#line 871
        tmp___4 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 3) + 1));
#line 871
        value0 = (psiconv_u8 *)tmp___4;
        }
#line 871
        if (! value0) {
#line 872
          goto ERROR2;
        }
        {
#line 873
        tmp___5 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 3) + 2));
#line 873
        value1 = (psiconv_u8 *)tmp___5;
        }
#line 873
        if (! value1) {
#line 874
          goto ERROR2;
        }
        {
#line 875
        tmp___6 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 3) + 3));
#line 875
        value2 = (psiconv_u8 *)tmp___6;
        }
#line 875
        if (! value2) {
#line 876
          goto ERROR2;
        }
        {
#line 877
        value = (psiconv_u32 )(((int )*value0 + ((int )*value1 << 8)) + ((int )*value2 << 16));
#line 878
        psiconv_debug((psiconv_config )config, lev + 2, off, "Value: %06x", value);
#line 879
        res = psiconv_list_add(*decoded, (void const   *)(& value));
        }
#line 879
        if (res) {
#line 880
          goto ERROR2;
        }
#line 868
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 882
      i += (256 - (int )*marker) * 3 + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 885
  psiconv_progress((psiconv_config )config, lev, off, "End of RLE24 decoding process");
  }
#line 887
  return (0);
  ERROR2: 
  {
#line 890
  psiconv_list_free(*decoded);
  }
  ERROR1: 
  {
#line 892
  psiconv_error((psiconv_config )config, lev + 1, off, "Decoding of RLE24 failed");
  }
#line 893
  if (! res) {
#line 894
    return (-2);
  } else {
#line 896
    return (res);
  }
}
}
#line 899 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_bytes_to_pixel_data___2(psiconv_config const   config , int lev ,
                                           psiconv_u32 off , psiconv_pixel_bytes const   bytes ,
                                           psiconv_pixel_ints *pixels , int colordepth ,
                                           int xsize , int ysize ) 
{ 
  int res ;
  int ibits ;
  int obits ;
  int x ;
  int y ;
  int bits ;
  psiconv_u8 input ;
  psiconv_u32 nr ;
  psiconv_u32 output ;
  psiconv_u8 *ientry ;
  psiconv_pixel_ints tmp ;
  void *tmp___0 ;

  {
  {
#line 905
  res = 0;
#line 911
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to convert the bytes to pixels");
#line 912
  tmp = psiconv_list_new(sizeof(psiconv_u32 ));
#line 912
  *pixels = tmp;
  }
#line 912
  if (! tmp) {
#line 913
    goto ERROR1;
  }
#line 915
  nr = (psiconv_u32 )0;
#line 916
  y = 0;
  {
#line 916
  while (1) {
    while_continue: /* CIL Label */ ;
#line 916
    if (! (y < ysize)) {
#line 916
      goto while_break;
    }
    {
#line 918
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 918
      if (! (nr % 4U)) {
#line 918
        goto while_break___0;
      }
#line 919
      nr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 920
    input = (psiconv_u8 )0;
#line 921
    ibits = 0;
#line 922
    x = 0;
    {
#line 922
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 922
      if (! (x < xsize)) {
#line 922
        goto while_break___1;
      }
#line 927
      output = (psiconv_u32 )0;
#line 928
      obits = 0;
      {
#line 929
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 929
        if (! (obits < colordepth)) {
#line 929
          goto while_break___2;
        }
#line 930
        if (ibits == 0) {
          {
#line 935
          tmp___0 = psiconv_list_get(bytes, nr);
#line 935
          ientry = (psiconv_u8 *)tmp___0;
          }
#line 935
          if (! ientry) {
#line 936
            goto ERROR2;
          }
#line 940
          input = *ientry;
#line 941
          ibits = 8;
#line 942
          nr ++;
        }
#line 944
        if (ibits + obits > colordepth) {
#line 944
          bits = colordepth - obits;
        } else {
#line 944
          bits = ibits;
        }
#line 945
        output <<= bits;
#line 946
        output |= (unsigned int )((int )input & ((1 << bits) - 1));
#line 947
        input = (psiconv_u8 )((int )input >> bits);
#line 948
        ibits -= bits;
#line 949
        obits += bits;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 954
      res = psiconv_list_add(*pixels, (void const   *)(& output));
      }
#line 954
      if (res) {
#line 955
        goto ERROR2;
      }
#line 922
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 916
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 959
  psiconv_progress((psiconv_config )config, lev, off, "Converting bytes to pixels completed");
  }
#line 961
  return (0);
  ERROR2: 
  {
#line 965
  psiconv_list_free(*pixels);
  }
  ERROR1: 
  {
#line 967
  psiconv_error((psiconv_config )config, lev + 1, off, "Converting bytes to pixels failed");
  }
#line 968
  if (! res) {
#line 969
    return (-2);
  } else {
#line 971
    return (res);
  }
}
}
#line 974 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_pixel_data_to_floats___2(psiconv_config const   config , int lev ,
                                            psiconv_u32 off , psiconv_pixel_ints const   pixels ,
                                            psiconv_pixel_floats_t *floats , int colordepth ,
                                            int color___1 , int redbits , int bluebits ,
                                            int greenbits , psiconv_pixel_floats_t const   palet ) 
{ 
  int res ;
  psiconv_u32 i ;
  psiconv_u32 *pixel ;
  float *tmp ;
  psiconv_u32 tmp___0 ;
  void *tmp___1 ;
  float *tmp___2 ;
  psiconv_u32 tmp___3 ;
  void *tmp___4 ;
  float *tmp___5 ;
  psiconv_u32 tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  float tmp___9 ;
  float tmp___10 ;
  psiconv_u32 tmp___11 ;

  {
  {
#line 982
  res = 0;
#line 986
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to convert pixels to floats");
#line 987
  tmp___0 = psiconv_list_length(pixels);
#line 987
  tmp___1 = malloc((unsigned long )tmp___0 * sizeof(*(floats->red)));
#line 987
  tmp = (float *)tmp___1;
#line 987
  floats->red = tmp;
  }
#line 987
  if (! tmp) {
#line 989
    goto ERROR1;
  }
  {
#line 990
  tmp___3 = psiconv_list_length(pixels);
#line 990
  tmp___4 = malloc((unsigned long )tmp___3 * sizeof(*(floats->green)));
#line 990
  tmp___2 = (float *)tmp___4;
#line 990
  floats->green = tmp___2;
  }
#line 990
  if (! tmp___2) {
#line 992
    goto ERROR2;
  }
  {
#line 993
  tmp___6 = psiconv_list_length(pixels);
#line 993
  tmp___7 = malloc((unsigned long )tmp___6 * sizeof(*(floats->blue)));
#line 993
  tmp___5 = (float *)tmp___7;
#line 993
  floats->blue = tmp___5;
  }
#line 993
  if (! tmp___5) {
#line 995
    goto ERROR3;
  }
  {
#line 996
  floats->length = psiconv_list_length(pixels);
#line 998
  i = (psiconv_u32 )0;
  }
  {
#line 998
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 998
    tmp___11 = psiconv_list_length(pixels);
    }
#line 998
    if (! (i < tmp___11)) {
#line 998
      goto while_break;
    }
    {
#line 999
    tmp___8 = psiconv_list_get(pixels, i);
#line 999
    pixel = (psiconv_u32 *)tmp___8;
    }
#line 999
    if (! pixel) {
#line 1000
      goto ERROR4;
    }
#line 1004
    if (! palet.length) {
#line 1005
      if (color___1) {
#line 1006
        *(floats->blue + i) = (float )(*pixel & (unsigned int )((1 << bluebits) - 1)) / (float )((1 << bluebits) - 1);
#line 1008
        *(floats->green + i) = (float )((*pixel >> bluebits) & (unsigned int )((1 << greenbits) - 1)) / (float )((1 << greenbits) - 1);
#line 1010
        *(floats->red + i) = (float )((*pixel >> (bluebits + greenbits)) & (unsigned int )((1 << redbits) - 1)) / (float )((1 << redbits) - 1);
      } else {
#line 1013
        tmp___10 = (float )*pixel / (float )((1 << colordepth) - 1);
#line 1013
        *(floats->blue + i) = tmp___10;
#line 1013
        tmp___9 = tmp___10;
#line 1013
        *(floats->green + i) = tmp___9;
#line 1013
        *(floats->red + i) = tmp___9;
      }
    } else
#line 1018
    if (*pixel >= (psiconv_u32 )palet.length) {
      {
#line 1019
      psiconv_warn((psiconv_config )config, lev + 2, off, "Invalid palet color found (using color 0x00)");
#line 1021
      *(floats->red + i) = *(palet.red + 0);
#line 1022
      *(floats->green + i) = *(palet.green + 0);
#line 1023
      *(floats->blue + i) = *(palet.blue + 0);
      }
    } else {
#line 1025
      *(floats->red + i) = *(palet.red + *pixel);
#line 1026
      *(floats->green + i) = *(palet.green + *pixel);
#line 1027
      *(floats->blue + i) = *(palet.blue + *pixel);
    }
#line 998
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1035
  psiconv_progress((psiconv_config )config, lev + 1, off, "Finished converting pixels to floats");
  }
#line 1036
  return (0);
  ERROR4: 
  {
#line 1039
  free((void *)floats->blue);
  }
  ERROR3: 
  {
#line 1041
  free((void *)floats->green);
  }
  ERROR2: 
  {
#line 1043
  free((void *)floats->red);
  }
  ERROR1: 
  {
#line 1045
  psiconv_error((psiconv_config )config, lev + 1, off, "Converting pixels to floats failed");
  }
#line 1046
  if (! res) {
#line 1047
    return (-2);
  } else {
#line 1049
    return (res);
  }
}
}
#line 36 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void text___0(psiconv_config const   config , psiconv_list list , psiconv_string_t data ,
                     encoding const   enc ) ;
#line 38
static void color(psiconv_config const   config , psiconv_list list , psiconv_color color___1 ,
                  int may_be_transparant , encoding const   enc ) ;
#line 40
static void border(psiconv_config const   config , psiconv_list list , psiconv_border_kind_t border___1 ,
                   encoding const   enc ) ;
#line 42
static void style_name(psiconv_config const   config , psiconv_list list , psiconv_string_t const   name ,
                       encoding const   enc ) ;
#line 44
static int character_layout_equal___0(psiconv_character_layout const   l1 , psiconv_character_layout const   l2 ) ;
#line 46
static void character_layout_diffs(psiconv_config const   config , psiconv_list list ,
                                   psiconv_character_layout const   new , psiconv_character_layout const   base ,
                                   encoding const   enc ) ;
#line 51
static void paragraph_layout_diffs(psiconv_config const   config , psiconv_list list ,
                                   psiconv_paragraph_layout const   new , psiconv_paragraph_layout const   base ,
                                   encoding const   enc ) ;
#line 56
static void style(psiconv_config const   config , psiconv_list list , psiconv_word_style const   style___1 ,
                  psiconv_paragraph_layout const   base_para , psiconv_character_layout const   base_char ,
                  encoding const   enc ) ;
#line 61
static void styles(psiconv_config const   config , psiconv_list list , psiconv_word_styles_section const   styles_sec ,
                   encoding const   enc ) ;
#line 63
static void header___0(psiconv_config const   config , psiconv_list list , psiconv_word_styles_section const   styles_sec ,
                       encoding const   enc ) ;
#line 65
static void footer___0(psiconv_config const   config , psiconv_list list , encoding const   enc ) ;
#line 67
static void characters___0(psiconv_config const   config , psiconv_list list , psiconv_string_t const   textstr ,
                           psiconv_character_layout const   layout , psiconv_character_layout const   base ,
                           encoding const   enc ) ;
#line 72
static void paragraphs___0(psiconv_config const   config , psiconv_list list , psiconv_text_and_layout paragraphs___3 ,
                           psiconv_word_styles_section const   styles___1 , encoding const   enc ) ;
#line 76
static void paragraph___0(psiconv_config const   config , psiconv_list list , psiconv_paragraph const   para ,
                          psiconv_word_styles_section const   styles_sec , encoding const   enc ) ;
#line 80
static void gen_word___1(psiconv_config const   config , psiconv_list list , psiconv_word_f const   file ,
                         encoding const   enc ) ;
#line 82
static void gen_texted___1(psiconv_config const   config , psiconv_list list , psiconv_texted_f const   file ,
                           encoding const   enc ) ;
#line 84
static int gen_xhtml(psiconv_config const   config , psiconv_list list , psiconv_file const   file ,
                     char const   *dest , encoding const   enc ) ;
#line 90 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void text___0(psiconv_config const   config , psiconv_list list , psiconv_string_t data ,
                     encoding const   enc ) 
{ 
  int i ;
  int tmp ;

  {
#line 94
  i = 0;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 94
    tmp = psiconv_unicode_strlen((psiconv_ucs2 const   *)data);
    }
#line 94
    if (! (i < tmp)) {
#line 94
      goto while_break;
    }
#line 95
    if ((int )*(data + i) == 6) {
      {
#line 96
      output_simple_chars((psiconv_config )config, list, (char *)"<br/>", (encoding )enc);
      }
    } else
#line 95
    if ((int )*(data + i) == 7) {
      {
#line 96
      output_simple_chars((psiconv_config )config, list, (char *)"<br/>", (encoding )enc);
      }
    } else
#line 95
    if ((int )*(data + i) == 8) {
      {
#line 96
      output_simple_chars((psiconv_config )config, list, (char *)"<br/>", (encoding )enc);
      }
    } else
#line 97
    if ((int )*(data + i) == 11) {
      {
#line 98
      output_simple_chars((psiconv_config )config, list, (char *)"-", (encoding )enc);
      }
    } else
#line 97
    if ((int )*(data + i) == 12) {
      {
#line 98
      output_simple_chars((psiconv_config )config, list, (char *)"-", (encoding )enc);
      }
    } else
#line 99
    if ((int )*(data + i) == 15) {
      {
#line 100
      output_simple_chars((psiconv_config )config, list, (char *)" ", (encoding )enc);
      }
    } else
#line 99
    if ((int )*(data + i) == 9) {
      {
#line 100
      output_simple_chars((psiconv_config )config, list, (char *)" ", (encoding )enc);
      }
    } else
#line 99
    if ((int )*(data + i) == 10) {
      {
#line 100
      output_simple_chars((psiconv_config )config, list, (char *)" ", (encoding )enc);
      }
    } else
#line 101
    if ((int )*(data + i) >= 32) {
      {
#line 102
      output_char((psiconv_config )config, list, *(data + i), (encoding )enc);
      }
    }
#line 94
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 106 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void color(psiconv_config const   config , psiconv_list list , psiconv_color color___1 ,
                  int may_be_transparant , encoding const   enc ) 
{ 
  char tempstr[100] ;

  {
#line 110
  if (may_be_transparant) {
#line 110
    if ((int )color___1->red == 255) {
#line 110
      if ((int )color___1->blue == 255) {
#line 110
        if ((int )color___1->green == 255) {
          {
#line 114
          output_simple_chars((psiconv_config )config, list, (char *)"transparant",
                              (encoding )enc);
          }
        } else {
          {
#line 116
          snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"rgb(%d,%d,%d)",
                   (int )color___1->red, (int )color___1->green, (int )color___1->blue);
#line 120
          output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
          }
        }
      } else {
        {
#line 116
        snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"rgb(%d,%d,%d)",
                 (int )color___1->red, (int )color___1->green, (int )color___1->blue);
#line 120
        output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
        }
      }
    } else {
      {
#line 116
      snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"rgb(%d,%d,%d)",
               (int )color___1->red, (int )color___1->green, (int )color___1->blue);
#line 120
      output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
      }
    }
  } else {
    {
#line 116
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"rgb(%d,%d,%d)",
             (int )color___1->red, (int )color___1->green, (int )color___1->blue);
#line 120
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
    }
  }
#line 122
  return;
}
}
#line 124 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void border(psiconv_config const   config , psiconv_list list , psiconv_border_kind_t border___1 ,
                   encoding const   enc ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
#line 127
  if ((unsigned int )border___1 == 0U) {
#line 127
    tmp___5 = "none";
  } else {
#line 127
    if ((unsigned int )border___1 == 1U) {
#line 127
      tmp___4 = "solid";
    } else {
#line 127
      if ((unsigned int )border___1 == 2U) {
#line 127
        tmp___3 = "double";
      } else {
#line 127
        if ((unsigned int )border___1 == 3U) {
#line 127
          tmp___2 = "dotted";
        } else {
#line 127
          if ((unsigned int )border___1 == 4U) {
#line 127
            tmp___1 = "dashed";
          } else {
#line 127
            if ((unsigned int )border___1 == 5U) {
#line 127
              tmp___0 = "dashed";
            } else {
#line 127
              if ((unsigned int )border___1 == 6U) {
#line 127
                tmp = "dashed";
              } else {
#line 127
                tmp = "";
              }
#line 127
              tmp___0 = tmp;
            }
#line 127
            tmp___1 = tmp___0;
          }
#line 127
          tmp___2 = tmp___1;
        }
#line 127
        tmp___3 = tmp___2;
      }
#line 127
      tmp___4 = tmp___3;
    }
#line 127
    tmp___5 = tmp___4;
  }
  {
#line 127
  output_simple_chars((psiconv_config )config, list, (char *)tmp___5, (encoding )enc);
  }
#line 135
  return;
}
}
#line 137 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void style_name(psiconv_config const   config , psiconv_list list , psiconv_string_t const   name ,
                       encoding const   enc ) 
{ 
  psiconv_string_t name_copy ;
  int i ;
  int tmp ;

  {
#line 143
  if (! name) {
#line 144
    return;
  }
  {
#line 146
  name_copy = psiconv_unicode_strdup((psiconv_ucs2 const   *)name);
  }
#line 146
  if (! name_copy) {
    {
#line 147
    fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 148
    exit(1);
    }
  }
#line 150
  i = 0;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 150
    tmp = psiconv_unicode_strlen((psiconv_ucs2 const   *)name_copy);
    }
#line 150
    if (! (i < tmp)) {
#line 150
      goto while_break;
    }
#line 151
    if ((int )*(name_copy + i) < 33) {
#line 153
      *(name_copy + i) = (psiconv_ucs2 )'_';
    } else
#line 151
    if ((int )*(name_copy + i) >= 127) {
#line 151
      if ((int )*(name_copy + i) <= 160) {
#line 153
        *(name_copy + i) = (psiconv_ucs2 )'_';
      }
    }
#line 150
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 155
  output_string((psiconv_config )config, list, name_copy, (encoding )enc);
#line 156
  free((void *)name_copy);
  }
#line 157
  return;
}
}
#line 160 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static int character_layout_equal___0(psiconv_character_layout const   l1 , psiconv_character_layout const   l2 ) 
{ 
  int tmp ;

  {
#line 163
  if (l1) {
#line 163
    if (l2) {
#line 163
      if ((int )(l1->color)->red == (int )(l2->color)->red) {
#line 163
        if ((int )(l1->color)->green == (int )(l2->color)->green) {
#line 163
          if ((int )(l1->color)->blue == (int )(l2->color)->blue) {
#line 163
            if ((int )(l1->back_color)->red == (int )(l2->back_color)->red) {
#line 163
              if ((int )(l1->back_color)->green == (int )(l2->back_color)->green) {
#line 163
                if ((int )(l1->back_color)->blue == (int )(l2->back_color)->blue) {
#line 163
                  if (l1->font_size == l2->font_size) {
#line 163
                    if ((unsigned int )l1->italic == (unsigned int )l2->italic) {
#line 163
                      if ((unsigned int )l1->bold == (unsigned int )l2->bold) {
#line 163
                        if ((unsigned int )l1->super_sub == (unsigned int )l2->super_sub) {
#line 163
                          if ((unsigned int )l1->underline == (unsigned int )l2->underline) {
#line 163
                            if ((unsigned int )l1->strikethrough == (unsigned int )l2->strikethrough) {
#line 163
                              if ((unsigned int )(l1->font)->screenfont == (unsigned int )(l2->font)->screenfont) {
#line 163
                                tmp = 1;
                              } else {
#line 163
                                tmp = 0;
                              }
                            } else {
#line 163
                              tmp = 0;
                            }
                          } else {
#line 163
                            tmp = 0;
                          }
                        } else {
#line 163
                          tmp = 0;
                        }
                      } else {
#line 163
                        tmp = 0;
                      }
                    } else {
#line 163
                      tmp = 0;
                    }
                  } else {
#line 163
                    tmp = 0;
                  }
                } else {
#line 163
                  tmp = 0;
                }
              } else {
#line 163
                tmp = 0;
              }
            } else {
#line 163
              tmp = 0;
            }
          } else {
#line 163
            tmp = 0;
          }
        } else {
#line 163
          tmp = 0;
        }
      } else {
#line 163
        tmp = 0;
      }
    } else {
#line 163
      tmp = 0;
    }
  } else {
#line 163
    tmp = 0;
  }
#line 163
  return (tmp);
}
}
#line 179 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void character_layout_diffs(psiconv_config const   config , psiconv_list list ,
                                   psiconv_character_layout const   new , psiconv_character_layout const   base ,
                                   encoding const   enc ) 
{ 
  char tempstr[100] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;

  {
#line 186
  if (! base) {
    {
#line 189
    output_simple_chars((psiconv_config )config, list, (char *)"color:", (encoding )enc);
#line 190
    color(config, list, new->color, 0, enc);
#line 191
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 186
  if ((int )(new->color)->red != (int )(base->color)->red) {
    {
#line 189
    output_simple_chars((psiconv_config )config, list, (char *)"color:", (encoding )enc);
#line 190
    color(config, list, new->color, 0, enc);
#line 191
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 186
  if ((int )(new->color)->green != (int )(base->color)->green) {
    {
#line 189
    output_simple_chars((psiconv_config )config, list, (char *)"color:", (encoding )enc);
#line 190
    color(config, list, new->color, 0, enc);
#line 191
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 186
  if ((int )(new->color)->blue != (int )(base->color)->blue) {
    {
#line 189
    output_simple_chars((psiconv_config )config, list, (char *)"color:", (encoding )enc);
#line 190
    color(config, list, new->color, 0, enc);
#line 191
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  }
#line 194
  if (! base) {
    {
#line 197
    output_simple_chars((psiconv_config )config, list, (char *)"background-color:",
                        (encoding )enc);
#line 198
    color(config, list, new->back_color, 1, enc);
#line 199
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 194
  if ((int )(new->back_color)->red != (int )(base->back_color)->red) {
    {
#line 197
    output_simple_chars((psiconv_config )config, list, (char *)"background-color:",
                        (encoding )enc);
#line 198
    color(config, list, new->back_color, 1, enc);
#line 199
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 194
  if ((int )(new->back_color)->green != (int )(base->back_color)->green) {
    {
#line 197
    output_simple_chars((psiconv_config )config, list, (char *)"background-color:",
                        (encoding )enc);
#line 198
    color(config, list, new->back_color, 1, enc);
#line 199
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 194
  if ((int )(new->back_color)->blue != (int )(base->back_color)->blue) {
    {
#line 197
    output_simple_chars((psiconv_config )config, list, (char *)"background-color:",
                        (encoding )enc);
#line 198
    color(config, list, new->back_color, 1, enc);
#line 199
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  }
#line 202
  if (! base) {
    {
#line 203
    output_simple_chars((psiconv_config )config, list, (char *)"font-size:", (encoding )enc);
#line 204
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )new->font_size);
#line 205
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 206
    output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
    }
  } else
#line 202
  if (new->font_size != base->font_size) {
    {
#line 203
    output_simple_chars((psiconv_config )config, list, (char *)"font-size:", (encoding )enc);
#line 204
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )new->font_size);
#line 205
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 206
    output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
    }
  }
#line 209
  if (! base) {
#line 209
    goto _L;
  } else
#line 209
  if ((unsigned int )new->italic != (unsigned int )base->italic) {
    _L: /* CIL Label */ 
    {
#line 210
    output_simple_chars((psiconv_config )config, list, (char *)"font-style:", (encoding )enc);
    }
#line 211
    if (new->italic) {
#line 211
      tmp = "italic";
    } else {
#line 211
      tmp = "normal";
    }
    {
#line 211
    output_simple_chars((psiconv_config )config, list, (char *)tmp, (encoding )enc);
#line 212
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  }
#line 214
  if (! base) {
#line 214
    goto _L___0;
  } else
#line 214
  if ((unsigned int )new->bold != (unsigned int )base->bold) {
    _L___0: /* CIL Label */ 
    {
#line 215
    output_simple_chars((psiconv_config )config, list, (char *)"font-weight:", (encoding )enc);
    }
#line 216
    if (new->bold) {
#line 216
      tmp___0 = "bold";
    } else {
#line 216
      tmp___0 = "normal";
    }
    {
#line 216
    output_simple_chars((psiconv_config )config, list, (char *)tmp___0, (encoding )enc);
#line 217
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  }
#line 219
  if (! base) {
#line 219
    goto _L___1;
  } else
#line 219
  if ((unsigned int )new->super_sub != (unsigned int )base->super_sub) {
    _L___1: /* CIL Label */ 
    {
#line 220
    output_simple_chars((psiconv_config )config, list, (char *)"font-style:", (encoding )enc);
    }
#line 221
    if ((unsigned int )new->super_sub == 1U) {
#line 221
      tmp___2 = "super";
    } else {
#line 221
      if ((unsigned int )new->super_sub == 2U) {
#line 221
        tmp___1 = "sub";
      } else {
#line 221
        tmp___1 = "normal";
      }
#line 221
      tmp___2 = tmp___1;
    }
    {
#line 221
    output_simple_chars((psiconv_config )config, list, (char *)tmp___2, (encoding )enc);
#line 225
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  }
#line 227
  if (! base) {
#line 227
    goto _L___2;
  } else
#line 227
  if ((unsigned int )new->underline != (unsigned int )base->underline) {
#line 227
    goto _L___2;
  } else
#line 227
  if ((unsigned int )new->strikethrough != (unsigned int )base->strikethrough) {
    _L___2: /* CIL Label */ 
    {
#line 229
    output_simple_chars((psiconv_config )config, list, (char *)"text-decoration:",
                        (encoding )enc);
    }
#line 230
    if (new->underline) {
#line 230
      tmp___4 = "underline";
    } else {
#line 230
      if (new->strikethrough) {
#line 230
        tmp___3 = "line-through";
      } else {
#line 230
        tmp___3 = "none";
      }
#line 230
      tmp___4 = tmp___3;
    }
    {
#line 230
    output_simple_chars((psiconv_config )config, list, (char *)tmp___4, (encoding )enc);
#line 233
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  }
#line 235
  if (! base) {
#line 235
    goto _L___3;
  } else
#line 235
  if ((unsigned int )(new->font)->screenfont != (unsigned int )(base->font)->screenfont) {
    _L___3: /* CIL Label */ 
    {
#line 236
    output_simple_chars((psiconv_config )config, list, (char *)"font-family:", (encoding )enc);
    }
#line 237
    if ((unsigned int )(new->font)->screenfont == 3U) {
#line 237
      tmp___8 = "serif";
    } else {
#line 237
      if ((unsigned int )(new->font)->screenfont == 1U) {
#line 237
        tmp___7 = "sans-serif";
      } else {
#line 237
        if ((unsigned int )(new->font)->screenfont == 2U) {
#line 237
          tmp___6 = "monospace";
        } else {
#line 237
          if ((unsigned int )(new->font)->screenfont == 0U) {
#line 237
            tmp___5 = "fantasy";
          } else {
#line 237
            tmp___5 = "";
          }
#line 237
          tmp___6 = tmp___5;
        }
#line 237
        tmp___7 = tmp___6;
      }
#line 237
      tmp___8 = tmp___7;
    }
    {
#line 237
    output_simple_chars((psiconv_config )config, list, (char *)tmp___8, (encoding )enc);
    }
  }
#line 244
  return;
}
}
#line 246 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void paragraph_layout_diffs(psiconv_config const   config , psiconv_list list ,
                                   psiconv_paragraph_layout const   new , psiconv_paragraph_layout const   base ,
                                   encoding const   enc ) 
{ 
  char tempstr[100] ;
  float pad_left_base ;
  float pad_left_new ;
  float text_indent_base ;
  float text_indent_new ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 252
  pad_left_base = (float )0.0;
#line 252
  text_indent_base = (float )0.0;
#line 254
  if ((new->bullet)->on) {
#line 255
    if (new->indent_left < new->indent_first) {
#line 255
      pad_left_new = new->indent_left;
    } else {
#line 255
      pad_left_new = new->indent_first;
    }
#line 257
    text_indent_new = (float )0.0;
  } else {
#line 259
    pad_left_new = new->indent_left;
#line 260
    text_indent_new = new->indent_first;
  }
#line 262
  if (base) {
#line 263
    if ((base->bullet)->on) {
#line 264
      if (base->indent_left < base->indent_first) {
#line 264
        pad_left_base = base->indent_left;
      } else {
#line 264
        pad_left_base = base->indent_first;
      }
#line 266
      text_indent_base = (float )0.0;
    } else {
#line 268
      pad_left_base = base->indent_left;
#line 269
      text_indent_base = base->indent_first;
    }
  }
#line 274
  if (! base) {
    {
#line 277
    output_simple_chars((psiconv_config )config, list, (char *)"background-color:",
                        (encoding )enc);
#line 278
    color(config, list, new->back_color, 1, enc);
#line 279
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 274
  if ((int )(new->back_color)->red != (int )(base->back_color)->red) {
    {
#line 277
    output_simple_chars((psiconv_config )config, list, (char *)"background-color:",
                        (encoding )enc);
#line 278
    color(config, list, new->back_color, 1, enc);
#line 279
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 274
  if ((int )(new->back_color)->green != (int )(base->back_color)->green) {
    {
#line 277
    output_simple_chars((psiconv_config )config, list, (char *)"background-color:",
                        (encoding )enc);
#line 278
    color(config, list, new->back_color, 1, enc);
#line 279
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 274
  if ((int )(new->back_color)->blue != (int )(base->back_color)->blue) {
    {
#line 277
    output_simple_chars((psiconv_config )config, list, (char *)"background-color:",
                        (encoding )enc);
#line 278
    color(config, list, new->back_color, 1, enc);
#line 279
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  }
#line 282
  if (! base) {
    {
#line 283
    output_simple_chars((psiconv_config )config, list, (char *)"padding-left:", (encoding )enc);
#line 284
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )pad_left_new);
#line 285
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 286
    output_simple_chars((psiconv_config )config, list, (char *)"cm;", (encoding )enc);
    }
  } else
#line 282
  if (pad_left_new != pad_left_base) {
    {
#line 283
    output_simple_chars((psiconv_config )config, list, (char *)"padding-left:", (encoding )enc);
#line 284
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )pad_left_new);
#line 285
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 286
    output_simple_chars((psiconv_config )config, list, (char *)"cm;", (encoding )enc);
    }
  }
#line 289
  if (! base) {
    {
#line 290
    output_simple_chars((psiconv_config )config, list, (char *)"padding-right:", (encoding )enc);
#line 291
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )new->indent_right);
#line 292
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 293
    output_simple_chars((psiconv_config )config, list, (char *)"cm;", (encoding )enc);
    }
  } else
#line 289
  if (new->indent_right != base->indent_right) {
    {
#line 290
    output_simple_chars((psiconv_config )config, list, (char *)"padding-right:", (encoding )enc);
#line 291
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )new->indent_right);
#line 292
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 293
    output_simple_chars((psiconv_config )config, list, (char *)"cm;", (encoding )enc);
    }
  }
#line 296
  if (! base) {
    {
#line 297
    output_simple_chars((psiconv_config )config, list, (char *)"text-indent:", (encoding )enc);
#line 298
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )text_indent_new);
#line 299
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 300
    output_simple_chars((psiconv_config )config, list, (char *)"cm;", (encoding )enc);
    }
  } else
#line 296
  if (text_indent_new != text_indent_base) {
    {
#line 297
    output_simple_chars((psiconv_config )config, list, (char *)"text-indent:", (encoding )enc);
#line 298
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )text_indent_new);
#line 299
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 300
    output_simple_chars((psiconv_config )config, list, (char *)"cm;", (encoding )enc);
    }
  }
#line 303
  if (! base) {
#line 303
    goto _L;
  } else
#line 303
  if ((unsigned int )new->justify_hor != (unsigned int )base->justify_hor) {
    _L: /* CIL Label */ 
    {
#line 304
    output_simple_chars((psiconv_config )config, list, (char *)"font-style:", (encoding )enc);
    }
#line 305
    if ((unsigned int )new->justify_hor == 0U) {
#line 305
      tmp___2 = "left";
    } else {
#line 305
      if ((unsigned int )new->justify_hor == 1U) {
#line 305
        tmp___1 = "center";
      } else {
#line 305
        if ((unsigned int )new->justify_hor == 2U) {
#line 305
          tmp___0 = "right";
        } else {
#line 305
          if ((unsigned int )new->justify_hor == 3U) {
#line 305
            tmp = "justify";
          } else {
#line 305
            tmp = "";
          }
#line 305
          tmp___0 = tmp;
        }
#line 305
        tmp___1 = tmp___0;
      }
#line 305
      tmp___2 = tmp___1;
    }
    {
#line 305
    output_simple_chars((psiconv_config )config, list, (char *)tmp___2, (encoding )enc);
#line 311
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  }
#line 324
  if (! base) {
    {
#line 325
    output_simple_chars((psiconv_config )config, list, (char *)"padding-top:", (encoding )enc);
#line 326
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )new->space_above);
#line 327
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 328
    output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
    }
  } else
#line 324
  if (new->space_above != base->space_above) {
    {
#line 325
    output_simple_chars((psiconv_config )config, list, (char *)"padding-top:", (encoding )enc);
#line 326
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )new->space_above);
#line 327
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 328
    output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
    }
  }
#line 331
  if (! base) {
    {
#line 332
    output_simple_chars((psiconv_config )config, list, (char *)"padding-bottom:",
                        (encoding )enc);
#line 333
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )new->space_below);
#line 334
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 335
    output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
    }
  } else
#line 331
  if (new->space_below != base->space_below) {
    {
#line 332
    output_simple_chars((psiconv_config )config, list, (char *)"padding-bottom:",
                        (encoding )enc);
#line 333
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )new->space_below);
#line 334
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 335
    output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
    }
  }
#line 338
  if (! base) {
    {
#line 339
    output_simple_chars((psiconv_config )config, list, (char *)"border-right-style:",
                        (encoding )enc);
#line 340
    border(config, list, (new->right_border)->kind, enc);
#line 341
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 338
  if ((unsigned int )(new->right_border)->kind != (unsigned int )(base->right_border)->kind) {
    {
#line 339
    output_simple_chars((psiconv_config )config, list, (char *)"border-right-style:",
                        (encoding )enc);
#line 340
    border(config, list, (new->right_border)->kind, enc);
#line 341
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  }
#line 343
  if (! base) {
    {
#line 344
    output_simple_chars((psiconv_config )config, list, (char *)"border-bottom-style:",
                        (encoding )enc);
#line 345
    border(config, list, (new->bottom_border)->kind, enc);
#line 346
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 343
  if ((unsigned int )(new->bottom_border)->kind != (unsigned int )(base->bottom_border)->kind) {
    {
#line 344
    output_simple_chars((psiconv_config )config, list, (char *)"border-bottom-style:",
                        (encoding )enc);
#line 345
    border(config, list, (new->bottom_border)->kind, enc);
#line 346
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  }
#line 348
  if (! base) {
    {
#line 349
    output_simple_chars((psiconv_config )config, list, (char *)"border-top-style:",
                        (encoding )enc);
#line 350
    border(config, list, (new->top_border)->kind, enc);
#line 351
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 348
  if ((unsigned int )(new->top_border)->kind != (unsigned int )(base->top_border)->kind) {
    {
#line 349
    output_simple_chars((psiconv_config )config, list, (char *)"border-top-style:",
                        (encoding )enc);
#line 350
    border(config, list, (new->top_border)->kind, enc);
#line 351
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  }
#line 353
  if (! base) {
    {
#line 354
    output_simple_chars((psiconv_config )config, list, (char *)"border-left-style:",
                        (encoding )enc);
#line 355
    border(config, list, (new->left_border)->kind, enc);
#line 356
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 353
  if ((unsigned int )(new->left_border)->kind != (unsigned int )(base->left_border)->kind) {
    {
#line 354
    output_simple_chars((psiconv_config )config, list, (char *)"border-left-style:",
                        (encoding )enc);
#line 355
    border(config, list, (new->left_border)->kind, enc);
#line 356
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  }
#line 359
  if (! base) {
    {
#line 362
    output_simple_chars((psiconv_config )config, list, (char *)"border-right-width:",
                        (encoding )enc);
#line 363
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )(new->right_border)->thickness);
#line 364
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 365
    output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
    }
  } else
#line 359
  if ((unsigned int )(new->right_border)->kind != 0U) {
#line 359
    if ((new->right_border)->thickness != (base->right_border)->thickness) {
      {
#line 362
      output_simple_chars((psiconv_config )config, list, (char *)"border-right-width:",
                          (encoding )enc);
#line 363
      snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
               (double )(new->right_border)->thickness);
#line 364
      output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 365
      output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
      }
    }
  }
#line 367
  if (! base) {
    {
#line 370
    output_simple_chars((psiconv_config )config, list, (char *)"border-bottom-width:",
                        (encoding )enc);
#line 371
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )(new->bottom_border)->thickness);
#line 372
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 373
    output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
    }
  } else
#line 367
  if ((unsigned int )(new->bottom_border)->kind != 0U) {
#line 367
    if ((new->bottom_border)->thickness != (base->bottom_border)->thickness) {
      {
#line 370
      output_simple_chars((psiconv_config )config, list, (char *)"border-bottom-width:",
                          (encoding )enc);
#line 371
      snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
               (double )(new->bottom_border)->thickness);
#line 372
      output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 373
      output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
      }
    }
  }
#line 375
  if (! base) {
    {
#line 378
    output_simple_chars((psiconv_config )config, list, (char *)"border-top-width:",
                        (encoding )enc);
#line 379
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )(new->top_border)->thickness);
#line 380
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 381
    output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
    }
  } else
#line 375
  if ((unsigned int )(new->top_border)->kind != 0U) {
#line 375
    if ((new->top_border)->thickness != (base->top_border)->thickness) {
      {
#line 378
      output_simple_chars((psiconv_config )config, list, (char *)"border-top-width:",
                          (encoding )enc);
#line 379
      snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
               (double )(new->top_border)->thickness);
#line 380
      output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 381
      output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
      }
    }
  }
#line 383
  if (! base) {
    {
#line 386
    output_simple_chars((psiconv_config )config, list, (char *)"border-left-width:",
                        (encoding )enc);
#line 387
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )(new->left_border)->thickness);
#line 388
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 389
    output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
    }
  } else
#line 383
  if ((unsigned int )(new->left_border)->kind != 0U) {
#line 383
    if ((new->left_border)->thickness != (base->left_border)->thickness) {
      {
#line 386
      output_simple_chars((psiconv_config )config, list, (char *)"border-left-width:",
                          (encoding )enc);
#line 387
      snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
               (double )(new->left_border)->thickness);
#line 388
      output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 389
      output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
      }
    }
  }
#line 392
  if (! base) {
    {
#line 397
    output_simple_chars((psiconv_config )config, list, (char *)"border-right-color:",
                        (encoding )enc);
#line 398
    color(config, list, (new->right_border)->color, 0, enc);
#line 399
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 392
  if ((unsigned int )(new->right_border)->kind != 0U) {
#line 392
    if ((int )((new->right_border)->color)->red != (int )((base->right_border)->color)->red) {
      {
#line 397
      output_simple_chars((psiconv_config )config, list, (char *)"border-right-color:",
                          (encoding )enc);
#line 398
      color(config, list, (new->right_border)->color, 0, enc);
#line 399
      output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
      }
    } else
#line 392
    if ((int )((new->right_border)->color)->green != (int )((base->right_border)->color)->green) {
      {
#line 397
      output_simple_chars((psiconv_config )config, list, (char *)"border-right-color:",
                          (encoding )enc);
#line 398
      color(config, list, (new->right_border)->color, 0, enc);
#line 399
      output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
      }
    } else
#line 392
    if ((int )((new->right_border)->color)->blue != (int )((base->right_border)->color)->blue) {
      {
#line 397
      output_simple_chars((psiconv_config )config, list, (char *)"border-right-color:",
                          (encoding )enc);
#line 398
      color(config, list, (new->right_border)->color, 0, enc);
#line 399
      output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
      }
    }
  }
#line 401
  if (! base) {
    {
#line 406
    output_simple_chars((psiconv_config )config, list, (char *)"border-top-color:",
                        (encoding )enc);
#line 407
    color(config, list, (new->top_border)->color, 0, enc);
#line 408
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 401
  if ((unsigned int )(new->top_border)->kind != 0U) {
#line 401
    if ((int )((new->top_border)->color)->red != (int )((base->top_border)->color)->red) {
      {
#line 406
      output_simple_chars((psiconv_config )config, list, (char *)"border-top-color:",
                          (encoding )enc);
#line 407
      color(config, list, (new->top_border)->color, 0, enc);
#line 408
      output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
      }
    } else
#line 401
    if ((int )((new->top_border)->color)->green != (int )((base->top_border)->color)->green) {
      {
#line 406
      output_simple_chars((psiconv_config )config, list, (char *)"border-top-color:",
                          (encoding )enc);
#line 407
      color(config, list, (new->top_border)->color, 0, enc);
#line 408
      output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
      }
    } else
#line 401
    if ((int )((new->top_border)->color)->blue != (int )((base->top_border)->color)->blue) {
      {
#line 406
      output_simple_chars((psiconv_config )config, list, (char *)"border-top-color:",
                          (encoding )enc);
#line 407
      color(config, list, (new->top_border)->color, 0, enc);
#line 408
      output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
      }
    }
  }
#line 410
  if (! base) {
    {
#line 415
    output_simple_chars((psiconv_config )config, list, (char *)"border-bottom-color:",
                        (encoding )enc);
#line 416
    color(config, list, (new->bottom_border)->color, 0, enc);
#line 417
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 410
  if ((unsigned int )(new->bottom_border)->kind != 0U) {
#line 410
    if ((int )((new->bottom_border)->color)->red != (int )((base->bottom_border)->color)->red) {
      {
#line 415
      output_simple_chars((psiconv_config )config, list, (char *)"border-bottom-color:",
                          (encoding )enc);
#line 416
      color(config, list, (new->bottom_border)->color, 0, enc);
#line 417
      output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
      }
    } else
#line 410
    if ((int )((new->bottom_border)->color)->green != (int )((base->bottom_border)->color)->green) {
      {
#line 415
      output_simple_chars((psiconv_config )config, list, (char *)"border-bottom-color:",
                          (encoding )enc);
#line 416
      color(config, list, (new->bottom_border)->color, 0, enc);
#line 417
      output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
      }
    } else
#line 410
    if ((int )((new->bottom_border)->color)->blue != (int )((base->bottom_border)->color)->blue) {
      {
#line 415
      output_simple_chars((psiconv_config )config, list, (char *)"border-bottom-color:",
                          (encoding )enc);
#line 416
      color(config, list, (new->bottom_border)->color, 0, enc);
#line 417
      output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
      }
    }
  }
#line 419
  if (! base) {
    {
#line 424
    output_simple_chars((psiconv_config )config, list, (char *)"border-left-color:",
                        (encoding )enc);
#line 425
    color(config, list, (new->left_border)->color, 0, enc);
#line 426
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 419
  if ((unsigned int )(new->left_border)->kind != 0U) {
#line 419
    if ((int )((new->left_border)->color)->red != (int )((base->left_border)->color)->red) {
      {
#line 424
      output_simple_chars((psiconv_config )config, list, (char *)"border-left-color:",
                          (encoding )enc);
#line 425
      color(config, list, (new->left_border)->color, 0, enc);
#line 426
      output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
      }
    } else
#line 419
    if ((int )((new->left_border)->color)->green != (int )((base->left_border)->color)->green) {
      {
#line 424
      output_simple_chars((psiconv_config )config, list, (char *)"border-left-color:",
                          (encoding )enc);
#line 425
      color(config, list, (new->left_border)->color, 0, enc);
#line 426
      output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
      }
    } else
#line 419
    if ((int )((new->left_border)->color)->blue != (int )((base->left_border)->color)->blue) {
      {
#line 424
      output_simple_chars((psiconv_config )config, list, (char *)"border-left-color:",
                          (encoding )enc);
#line 425
      color(config, list, (new->left_border)->color, 0, enc);
#line 426
      output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
      }
    }
  }
#line 428
  return;
}
}
#line 430 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void style(psiconv_config const   config , psiconv_list list , psiconv_word_style const   style___1 ,
                  psiconv_paragraph_layout const   base_para , psiconv_character_layout const   base_char ,
                  encoding const   enc ) 
{ 


  {
  {
#line 436
  output_simple_chars((psiconv_config )config, list, (char *)"*.style_", (encoding )enc);
#line 437
  style_name(config, list, (psiconv_string_t const   )style___1->name, enc);
#line 438
  output_simple_chars((psiconv_config )config, list, (char *)" {", (encoding )enc);
#line 439
  paragraph_layout_diffs(config, list, (psiconv_paragraph_layout const   )style___1->paragraph,
                         base_para, enc);
#line 440
  character_layout_diffs(config, list, (psiconv_character_layout const   )style___1->character,
                         base_char, enc);
#line 441
  output_simple_chars((psiconv_config )config, list, (char *)"}\n", (encoding )enc);
  }
#line 442
  return;
}
}
#line 444 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void styles(psiconv_config const   config , psiconv_list list , psiconv_word_styles_section const   styles_sec ,
                   encoding const   enc ) 
{ 
  int i ;
  psiconv_word_style styl ;
  psiconv_character_layout base_char ;
  psiconv_paragraph_layout base_para ;
  void *tmp ;
  psiconv_u32 tmp___0 ;

  {
  {
#line 452
  base_char = psiconv_basic_character_layout();
  }
#line 452
  if (! base_char) {
    {
#line 453
    fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 454
    exit(1);
    }
  }
  {
#line 456
  base_para = psiconv_basic_paragraph_layout();
  }
#line 456
  if (! base_para) {
    {
#line 457
    fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 458
    exit(1);
    }
  }
  {
#line 461
  output_simple_chars((psiconv_config )config, list, (char *)"<style type=\"text/css\">\n",
                      (encoding )enc);
#line 464
  output_simple_chars((psiconv_config )config, list, (char *)"body {", (encoding )enc);
#line 465
  paragraph_layout_diffs(config, list, (psiconv_paragraph_layout const   )base_para,
                         (psiconv_paragraph_layout const   )((void *)0), enc);
#line 466
  character_layout_diffs(config, list, (psiconv_character_layout const   )base_char,
                         (psiconv_character_layout const   )((void *)0), enc);
#line 467
  output_simple_chars((psiconv_config )config, list, (char *)"}\n", (encoding )enc);
  }
#line 469
  if (styles_sec) {
    {
#line 470
    style(config, list, (psiconv_word_style const   )styles_sec->normal, (psiconv_paragraph_layout const   )base_para,
          (psiconv_character_layout const   )base_char, enc);
#line 472
    i = 0;
    }
    {
#line 472
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 472
      tmp___0 = psiconv_list_length((psiconv_list const   )styles_sec->styles);
      }
#line 472
      if (! ((psiconv_u32 )i < tmp___0)) {
#line 472
        goto while_break;
      }
      {
#line 473
      tmp = psiconv_list_get((psiconv_list const   )styles_sec->styles, (psiconv_u32 )i);
#line 473
      styl = (psiconv_word_style )tmp;
      }
#line 473
      if (! styl) {
        {
#line 474
        fputs((char const   */* __restrict  */)"Internal datastructure corruption\n",
              (FILE */* __restrict  */)stderr);
#line 475
        exit(1);
        }
      }
      {
#line 477
      style(config, list, (psiconv_word_style const   )styl, (psiconv_paragraph_layout const   )base_para,
            (psiconv_character_layout const   )base_char, enc);
#line 472
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 482
  output_simple_chars((psiconv_config )config, list, (char *)"</style>\n", (encoding )enc);
  }
#line 483
  return;
}
}
#line 485 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void header___0(psiconv_config const   config , psiconv_list list , psiconv_word_styles_section const   styles_sec ,
                       encoding const   enc ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 488
  output_simple_chars((psiconv_config )config, list, (char *)"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n",
                      (encoding )enc);
#line 490
  output_simple_chars((psiconv_config )config, list, (char *)"<!DOCTYPE html PUBLIC ",
                      (encoding )enc);
#line 491
  output_simple_chars((psiconv_config )config, list, (char *)"\"-//W3C//DTD XHTML 1.0 Strict//EN\" ",
                      (encoding )enc);
#line 492
  output_simple_chars((psiconv_config )config, list, (char *)"\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">",
                      (encoding )enc);
#line 495
  output_simple_chars((psiconv_config )config, list, (char *)"\n<html", (encoding )enc);
#line 496
  output_simple_chars((psiconv_config )config, list, (char *)" xmlns=\"http://www.w3.org/1999/xhtml\"",
                      (encoding )enc);
#line 498
  output_simple_chars((psiconv_config )config, list, (char *)">\n", (encoding )enc);
#line 499
  output_simple_chars((psiconv_config )config, list, (char *)"<head>\n", (encoding )enc);
#line 500
  output_simple_chars((psiconv_config )config, list, (char *)"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=",
                      (encoding )enc);
  }
#line 502
  if ((unsigned int const   )enc == 0U) {
#line 502
    tmp___1 = "UTF-8";
  } else {
#line 502
    if ((unsigned int const   )enc == 1U) {
#line 502
      tmp___0 = "UTF-16BE";
    } else {
#line 502
      if ((unsigned int const   )enc == 3U) {
#line 502
        tmp = "US-ASCII";
      } else {
#line 502
        tmp = "";
      }
#line 502
      tmp___0 = tmp;
    }
#line 502
    tmp___1 = tmp___0;
  }
  {
#line 502
  output_simple_chars((psiconv_config )config, list, (char *)tmp___1, (encoding )enc);
#line 506
  output_simple_chars((psiconv_config )config, list, (char *)"\">\n", (encoding )enc);
#line 507
  output_simple_chars((psiconv_config )config, list, (char *)"<meta http-equiv=\"Content-Style-Type\" content=\"text/css\">\n",
                      (encoding )enc);
#line 509
  output_simple_chars((psiconv_config )config, list, (char *)"<title>EPOC32 file converted by psiconv</title>\n",
                      (encoding )enc);
#line 511
  styles(config, list, styles_sec, enc);
#line 512
  output_simple_chars((psiconv_config )config, list, (char *)"</head>\n", (encoding )enc);
#line 513
  output_simple_chars((psiconv_config )config, list, (char *)"<body>\n", (encoding )enc);
  }
#line 514
  return;
}
}
#line 516 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void footer___0(psiconv_config const   config , psiconv_list list , encoding const   enc ) 
{ 


  {
  {
#line 518
  output_simple_chars((psiconv_config )config, list, (char *)"</body>\n", (encoding )enc);
#line 519
  output_simple_chars((psiconv_config )config, list, (char *)"</html>\n", (encoding )enc);
  }
#line 520
  return;
}
}
#line 522 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void characters___0(psiconv_config const   config , psiconv_list list , psiconv_string_t const   textstr ,
                           psiconv_character_layout const   layout , psiconv_character_layout const   base ,
                           encoding const   enc ) 
{ 
  psiconv_list templist ;
  int tmp ;
  psiconv_u32 tmp___0 ;
  psiconv_u32 tmp___1 ;

  {
  {
#line 530
  templist = psiconv_list_new(sizeof(psiconv_u8 ));
  }
#line 530
  if (! templist) {
    {
#line 531
    fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 532
    exit(1);
    }
  }
  {
#line 534
  character_layout_diffs(config, templist, layout, base, enc);
#line 536
  tmp___0 = psiconv_list_length((psiconv_list const   )templist);
  }
#line 536
  if (tmp___0) {
    {
#line 537
    output_simple_chars((psiconv_config )config, list, (char *)"<span style=\"", (encoding )enc);
#line 538
    tmp = psiconv_list_concat(list, (psiconv_list const   )templist);
    }
#line 538
    if (tmp) {
      {
#line 539
      fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 540
      exit(1);
      }
    }
    {
#line 542
    output_simple_chars((psiconv_config )config, list, (char *)"\">", (encoding )enc);
    }
  }
  {
#line 545
  text___0(config, list, (psiconv_string_t )textstr, enc);
#line 547
  tmp___1 = psiconv_list_length((psiconv_list const   )templist);
  }
#line 547
  if (tmp___1) {
    {
#line 548
    output_simple_chars((psiconv_config )config, list, (char *)"</span>", (encoding )enc);
    }
  }
  {
#line 551
  psiconv_list_free(templist);
  }
#line 552
  return;
}
}
#line 554 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void paragraph___0(psiconv_config const   config , psiconv_list list , psiconv_paragraph const   para ,
                          psiconv_word_styles_section const   styles_sec , encoding const   enc ) 
{ 
  int i ;
  int charnr ;
  int start ;
  int len ;
  psiconv_string_t text___3 ;
  psiconv_in_line_layout layout ;
  psiconv_in_line_layout next_layout ;
  psiconv_word_style style___1 ;
  psiconv_paragraph_layout base_para ;
  psiconv_character_layout base_char ;
  psiconv_list templist ;
  char const   *tmp ;
  int tmp___0 ;
  psiconv_u32 tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  psiconv_u32 tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  psiconv_u32 tmp___8 ;
  psiconv_u32 tmp___9 ;
  char const   *tmp___10 ;

  {
  {
#line 562
  style___1 = (psiconv_word_style )((void *)0);
#line 567
  templist = psiconv_list_new(sizeof(psiconv_u8 ));
  }
#line 567
  if (! templist) {
    {
#line 568
    fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 569
    exit(1);
    }
  }
#line 572
  if (styles_sec) {
    {
#line 573
    style___1 = psiconv_get_style((psiconv_word_styles_section )styles_sec, (int )para->base_style);
    }
#line 573
    if (! style___1) {
      {
#line 574
      fputs((char const   */* __restrict  */)"Unknown style found; data corrupt\n",
            (FILE */* __restrict  */)stderr);
#line 575
      exit(1);
      }
    }
#line 577
    base_para = style___1->paragraph;
#line 578
    base_char = style___1->character;
  } else {
    {
#line 580
    base_para = psiconv_basic_paragraph_layout();
#line 581
    base_char = psiconv_basic_character_layout();
    }
#line 582
    if (! base_para) {
      {
#line 583
      fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 584
      exit(1);
      }
    } else
#line 582
    if (! base_char) {
      {
#line 583
      fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 584
      exit(1);
      }
    }
  }
#line 588
  if (((para->base_paragraph)->bullet)->on) {
#line 588
    tmp = "<ul><li ";
  } else {
#line 588
    tmp = "<p ";
  }
  {
#line 588
  output_simple_chars((psiconv_config )config, list, (char *)tmp, (encoding )enc);
  }
#line 592
  if (styles_sec) {
    {
#line 593
    output_simple_chars((psiconv_config )config, list, (char *)"class=\"style_", (encoding )enc);
#line 594
    style_name(config, list, (psiconv_string_t const   )style___1->name, enc);
#line 595
    output_simple_chars((psiconv_config )config, list, (char *)"\" ", (encoding )enc);
    }
  }
  {
#line 598
  paragraph_layout_diffs(config, templist, (psiconv_paragraph_layout const   )para->base_paragraph,
                         (psiconv_paragraph_layout const   )base_para, enc);
#line 599
  character_layout_diffs(config, templist, (psiconv_character_layout const   )para->base_character,
                         (psiconv_character_layout const   )base_char, enc);
#line 601
  tmp___1 = psiconv_list_length((psiconv_list const   )templist);
  }
#line 601
  if (tmp___1) {
    {
#line 602
    output_simple_chars((psiconv_config )config, list, (char *)"style=\"", (encoding )enc);
#line 603
    tmp___0 = psiconv_list_concat(list, (psiconv_list const   )templist);
    }
#line 603
    if (tmp___0) {
      {
#line 604
      fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 605
      exit(1);
      }
    }
    {
#line 607
    output_simple_chars((psiconv_config )config, list, (char *)"\"", (encoding )enc);
    }
  }
  {
#line 609
  output_simple_chars((psiconv_config )config, list, (char *)">", (encoding )enc);
#line 611
  tmp___9 = psiconv_list_length((psiconv_list const   )para->in_lines);
  }
#line 611
  if (tmp___9 == 0U) {
    {
#line 612
    tmp___2 = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
    }
#line 612
    if (tmp___2) {
      {
#line 613
      characters___0(config, list, (psiconv_string_t const   )para->text, (psiconv_character_layout const   )para->base_character,
                     (psiconv_character_layout const   )para->base_character, enc);
      }
    }
  } else {
#line 616
    charnr = 0;
#line 617
    start = -1;
#line 618
    i = 0;
    {
#line 618
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 618
      tmp___8 = psiconv_list_length((psiconv_list const   )para->in_lines);
      }
#line 618
      if (! ((psiconv_u32 )i < tmp___8)) {
#line 618
        goto while_break;
      }
#line 619
      if (start < 0) {
#line 620
        start = charnr;
      }
      {
#line 621
      tmp___3 = psiconv_list_get((psiconv_list const   )para->in_lines, (psiconv_u32 )i);
#line 621
      layout = (psiconv_in_line_layout )tmp___3;
      }
#line 621
      if (! layout) {
        {
#line 622
        fputs((char const   */* __restrict  */)"Internal data structures corruption\n",
              (FILE */* __restrict  */)stderr);
#line 623
        exit(1);
        }
      }
      {
#line 625
      tmp___5 = psiconv_list_length((psiconv_list const   )para->in_lines);
      }
#line 625
      if ((psiconv_u32 )(i + 1) < tmp___5) {
        {
#line 626
        tmp___4 = psiconv_list_get((psiconv_list const   )para->in_lines, (psiconv_u32 )(i + 1));
#line 626
        next_layout = (psiconv_in_line_layout )tmp___4;
        }
#line 626
        if (! next_layout) {
          {
#line 627
          fputs((char const   */* __restrict  */)"Internal data structures corruption\n",
                (FILE */* __restrict  */)stderr);
#line 628
          exit(1);
          }
        }
      } else {
#line 631
        next_layout = (psiconv_in_line_layout )((void *)0);
      }
#line 633
      if (next_layout) {
        {
#line 633
        tmp___6 = character_layout_equal___0((psiconv_character_layout const   )layout->layout,
                                             (psiconv_character_layout const   )next_layout->layout);
        }
#line 633
        if (tmp___6) {
#line 635
          charnr += layout->length;
#line 636
          goto __Cont;
        }
      }
#line 638
      len = (charnr - start) + layout->length;
#line 639
      if (len) {
        {
#line 640
        tmp___7 = malloc(sizeof(*text___3) * (unsigned long )(len + 1));
#line 640
        text___3 = (psiconv_string_t )tmp___7;
        }
#line 640
        if (! text___3) {
          {
#line 641
          fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 642
          exit(1);
          }
        }
        {
#line 644
        memcpy((void */* __restrict  */)text___3, (void const   */* __restrict  */)(para->text + start),
               (unsigned long )len * sizeof(*text___3));
#line 645
        *(text___3 + len) = (psiconv_ucs2 )0;
#line 646
        characters___0(config, list, (psiconv_string_t const   )text___3, (psiconv_character_layout const   )layout->layout,
                       (psiconv_character_layout const   )para->base_character, enc);
#line 647
        free((void *)text___3);
        }
      }
#line 649
      charnr += layout->length;
#line 650
      start = -1;
      __Cont: /* CIL Label */ 
#line 618
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 653
  if (((para->base_paragraph)->bullet)->on) {
#line 653
    tmp___10 = "</li></ul>\n";
  } else {
#line 653
    tmp___10 = "</p>\n";
  }
  {
#line 653
  output_simple_chars((psiconv_config )config, list, (char *)tmp___10, (encoding )enc);
  }
#line 656
  if (! styles_sec) {
    {
#line 657
    psiconv_free_paragraph_layout(base_para);
#line 658
    psiconv_free_character_layout(base_char);
    }
  }
  {
#line 660
  psiconv_list_free(templist);
  }
#line 661
  return;
}
}
#line 663 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void paragraphs___0(psiconv_config const   config , psiconv_list list , psiconv_text_and_layout paragraphs___3 ,
                           psiconv_word_styles_section const   styles___1 , encoding const   enc ) 
{ 
  int i ;
  psiconv_paragraph para ;
  void *tmp ;
  psiconv_u32 tmp___0 ;

  {
#line 670
  i = 0;
  {
#line 670
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 670
    tmp___0 = psiconv_list_length((psiconv_list const   )paragraphs___3);
    }
#line 670
    if (! ((psiconv_u32 )i < tmp___0)) {
#line 670
      goto while_break;
    }
    {
#line 671
    tmp = psiconv_list_get((psiconv_list const   )paragraphs___3, (psiconv_u32 )i);
#line 671
    para = (psiconv_paragraph )tmp;
    }
#line 671
    if (! para) {
      {
#line 672
      fputs((char const   */* __restrict  */)"Internal datastructure corruption\n",
            (FILE */* __restrict  */)stderr);
#line 673
      exit(1);
      }
    }
    {
#line 675
    paragraph___0(config, list, (psiconv_paragraph const   )para, styles___1, enc);
#line 670
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 677
  return;
}
}
#line 679 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void gen_word___1(psiconv_config const   config , psiconv_list list , psiconv_word_f const   file ,
                         encoding const   enc ) 
{ 


  {
#line 682
  if (! file) {
#line 683
    return;
  }
  {
#line 685
  header___0(config, list, (psiconv_word_styles_section const   )file->styles_sec,
             enc);
#line 686
  paragraphs___0(config, list, file->paragraphs, (psiconv_word_styles_section const   )file->styles_sec,
                 enc);
#line 687
  footer___0(config, list, enc);
  }
#line 688
  return;
}
}
#line 691 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void gen_texted___1(psiconv_config const   config , psiconv_list list , psiconv_texted_f const   file ,
                           encoding const   enc ) 
{ 


  {
  {
#line 694
  header___0(config, list, (psiconv_word_styles_section const   )((void *)0), enc);
#line 695
  paragraphs___0(config, list, (file->texted_sec)->paragraphs, (psiconv_word_styles_section const   )((void *)0),
                 enc);
#line 696
  footer___0(config, list, enc);
  }
#line 697
  return;
}
}
#line 699 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static int gen_xhtml(psiconv_config const   config , psiconv_list list , psiconv_file const   file ,
                     char const   *dest , encoding const   enc ) 
{ 
  encoding enc1 ;

  {
#line 703
  enc1 = (encoding )enc;
#line 705
  if ((unsigned int const   )enc == 2U) {
    {
#line 706
    fputs((char const   */* __restrict  */)"Unsupported encoding\n", (FILE */* __restrict  */)stderr);
    }
#line 707
    return (-1);
  } else
#line 708
  if ((unsigned int const   )enc == 3U) {
#line 709
    enc1 = (encoding )4;
  }
#line 711
  if ((unsigned int )file->type == 1U) {
    {
#line 712
    gen_word___1(config, list, (psiconv_word_f const   )((psiconv_word_f )file->file),
                 (encoding const   )enc1);
    }
#line 713
    return (0);
  } else
#line 714
  if ((unsigned int )file->type == 2U) {
    {
#line 715
    gen_texted___1(config, list, (psiconv_texted_f const   )((psiconv_texted_f )file->file),
                   (encoding const   )enc1);
    }
#line 716
    return (0);
  } else {
#line 718
    return (-1);
  }
}
}
#line 722 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static struct fileformat_s fileformats___0[2]  = {      {"XHTML", "XHTML 1.0 Strict, using CSS for formatting", 3, & gen_xhtml}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), 0, (output_function *)((void *)0)}};
#line 739 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
void init_xhtml(void) 
{ 
  int i ;

  {
#line 742
  i = 0;
  {
#line 742
  while (1) {
    while_continue: /* CIL Label */ ;
#line 742
    if (! fileformats___0[i].name) {
#line 742
      goto while_break;
    }
    {
#line 743
    psiconv_list_add(fileformat_list, (void const   *)(fileformats___0 + i));
#line 742
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 744
  return;
}
}
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_color clone_color___2(psiconv_color color___1 ) ;
#line 34
static psiconv_font clone_font___2(psiconv_font font___9 ) ;
#line 35
static psiconv_border clone_border___2(psiconv_border border___1 ) ;
#line 36
static psiconv_bullet clone_bullet___2(psiconv_bullet bullet___4 ) ;
#line 37
static psiconv_all_tabs clone_all_tabs___2(psiconv_all_tabs all_tabs ) ;
#line 38
static void psiconv_free_style_aux___2(void *style___1 ) ;
#line 39
static void psiconv_free_in_line_layout_aux___2(void *layout ) ;
#line 40
static void psiconv_free_paragraph_aux___2(void *paragraph___3 ) ;
#line 41
static void psiconv_free_paint_data_section_aux___2(void *section ) ;
#line 42
static void psiconv_free_clipart_section_aux___2(void *section ) ;
#line 43
static void psiconv_free_formula_aux___2(void *data ) ;
#line 44
static void psiconv_free_sheet_worksheet_aux___2(void *data ) ;
#line 45
static void psiconv_free_sheet_variable_aux___2(void *variable ) ;
#line 46
static void psiconv_free_sheet_cell_aux___2(void *cell ) ;
#line 47
static void psiconv_free_sheet_line_aux___2(void *line ) ;
#line 50
static psiconv_word_styles_section psiconv_empty_word_styles_section___2(void) ;
#line 51
static psiconv_text_and_layout psiconv_empty_text_and_layout___2(void) ;
#line 52
static psiconv_texted_section psiconv_empty_texted_section___2(void) ;
#line 53
static psiconv_page_header psiconv_empty_page_header___2(void) ;
#line 54
static psiconv_page_layout_section psiconv_empty_page_layout_section___2(void) ;
#line 55
static psiconv_word_status_section psiconv_empty_word_status_section___2(void) ;
#line 56
static psiconv_word_f psiconv_empty_word_f___2(void) ;
#line 57
static psiconv_sheet_status_section psiconv_empty_sheet_status_section___2(void) ;
#line 58
static psiconv_formula_list psiconv_empty_formula_list___2(void) ;
#line 59
static psiconv_sheet_workbook_section psiconv_empty_sheet_workbook_section___2(void) ;
#line 61
static psiconv_sheet_f psiconv_empty_sheet_f___2(void) ;
#line 62
static psiconv_texted_f psiconv_empty_texted_f___2(void) ;
#line 63
static psiconv_paint_data_section psiconv_empty_paint_data_section___2(void) ;
#line 64
static psiconv_pictures psiconv_empty_pictures___2(void) ;
#line 65
static psiconv_mbm_f psiconv_empty_mbm_f___2(void) ;
#line 66
static psiconv_sketch_section psiconv_empty_sketch_section___2(void) ;
#line 67
static psiconv_sketch_f psiconv_empty_sketch_f___2(void) ;
#line 68
static psiconv_clipart_f psiconv_empty_clipart_f___2(void) ;
#line 69
static psiconv_cliparts psiconv_empty_cliparts___2(void) ;
#line 77 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_color_s black___5  =    {(psiconv_u8 )0, (psiconv_u8 )0, (psiconv_u8 )0};
#line 83 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_color_s white___5  =    {(psiconv_u8 )255, (psiconv_u8 )255, (psiconv_u8 )255};
#line 89 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_ucs2 font_times___5[16]  = 
#line 89
  {      (psiconv_ucs2 )'T',      (psiconv_ucs2 )'i',      (psiconv_ucs2 )'m',      (psiconv_ucs2 )'e', 
        (psiconv_ucs2 )'s',      (psiconv_ucs2 )' ',      (psiconv_ucs2 )'N',      (psiconv_ucs2 )'e', 
        (psiconv_ucs2 )'w',      (psiconv_ucs2 )' ',      (psiconv_ucs2 )'R',      (psiconv_ucs2 )'o', 
        (psiconv_ucs2 )'m',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'n',      (psiconv_ucs2 )0};
#line 92 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_font_s font___5  =    {font_times___5, (psiconv_screenfont_t )3};
#line 117 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_ucs2 font_times___6[16]  = 
#line 117
  {      (psiconv_ucs2 )'T',      (psiconv_ucs2 )'i',      (psiconv_ucs2 )'m',      (psiconv_ucs2 )'e', 
        (psiconv_ucs2 )'s',      (psiconv_ucs2 )' ',      (psiconv_ucs2 )'N',      (psiconv_ucs2 )'e', 
        (psiconv_ucs2 )'w',      (psiconv_ucs2 )' ',      (psiconv_ucs2 )'R',      (psiconv_ucs2 )'o', 
        (psiconv_ucs2 )'m',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'n',      (psiconv_ucs2 )0};
#line 121 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_font_s font___6  =    {font_times___6, (psiconv_screenfont_t )2};
#line 126 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_color_s black___6  =    {(psiconv_u8 )0, (psiconv_u8 )0, (psiconv_u8 )0};
#line 132 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_color_s white___6  =    {(psiconv_u8 )255, (psiconv_u8 )255, (psiconv_u8 )255};
#line 138 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_border_s no_border___2  =    {(psiconv_border_kind_t )0, (psiconv_size_t )1, & black___6};
#line 144 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_bullet_s bullet___2  =    {(psiconv_bool_t )0, (psiconv_size_t )10.0, (psiconv_ucs2 )8221, (psiconv_bool_t )1,
    & black___6, & font___6};
#line 153 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_all_tabs_s tabs___2  =    {(psiconv_length_t )0.64, (psiconv_tab_list )((void *)0)};
#line 192 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_color clone_color___2(psiconv_color color___1 ) 
{ 
  psiconv_color result ;
  void *tmp ;

  {
  {
#line 195
  tmp = malloc(sizeof(*result));
#line 195
  result = (psiconv_color )tmp;
  }
#line 195
  if (! result) {
#line 196
    return ((psiconv_color )((void *)0));
  }
#line 197
  *result = *color___1;
#line 198
  return (result);
}
}
#line 201 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_font clone_font___2(psiconv_font font___9 ) 
{ 
  psiconv_font result ;
  void *tmp ;
  psiconv_string_t tmp___0 ;

  {
  {
#line 204
  tmp = malloc(sizeof(*result));
#line 204
  result = (psiconv_font )tmp;
  }
#line 204
  if (! result) {
#line 205
    goto ERROR1;
  }
  {
#line 206
  *result = *font___9;
#line 207
  tmp___0 = psiconv_unicode_strdup((psiconv_ucs2 const   *)result->name);
#line 207
  result->name = tmp___0;
  }
#line 207
  if (! tmp___0) {
#line 208
    goto ERROR2;
  }
#line 209
  return (result);
  ERROR2: 
  {
#line 211
  free((void *)result);
  }
  ERROR1: 
#line 213
  return ((psiconv_font )((void *)0));
}
}
#line 216 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_border clone_border___2(psiconv_border border___1 ) 
{ 
  psiconv_border result ;
  void *tmp ;
  psiconv_color tmp___0 ;

  {
  {
#line 219
  tmp = malloc(sizeof(*result));
#line 219
  result = (psiconv_border )tmp;
  }
#line 219
  if (! result) {
#line 220
    goto ERROR1;
  }
  {
#line 221
  *result = *border___1;
#line 222
  tmp___0 = clone_color___2(result->color);
#line 222
  result->color = tmp___0;
  }
#line 222
  if (! tmp___0) {
#line 223
    goto ERROR2;
  }
#line 224
  return (result);
  ERROR2: 
  {
#line 226
  free((void *)result);
  }
  ERROR1: 
#line 228
  return ((psiconv_border )((void *)0));
}
}
#line 231 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_bullet clone_bullet___2(psiconv_bullet bullet___4 ) 
{ 
  psiconv_bullet result ;
  void *tmp ;
  psiconv_font tmp___0 ;
  psiconv_color tmp___1 ;

  {
  {
#line 234
  tmp = malloc(sizeof(*result));
#line 234
  result = (psiconv_bullet )tmp;
  }
#line 234
  if (! result) {
#line 235
    goto ERROR1;
  }
  {
#line 236
  *result = *bullet___4;
#line 237
  tmp___0 = clone_font___2(result->font);
#line 237
  result->font = tmp___0;
  }
#line 237
  if (! tmp___0) {
#line 238
    goto ERROR2;
  }
  {
#line 239
  tmp___1 = clone_color___2(result->color);
#line 239
  result->color = tmp___1;
  }
#line 239
  if (! tmp___1) {
#line 240
    goto ERROR3;
  }
#line 241
  return (result);
  ERROR3: 
  {
#line 243
  psiconv_free_font(result->font);
  }
  ERROR2: 
  {
#line 245
  free((void *)result);
  }
  ERROR1: 
#line 247
  return ((psiconv_bullet )((void *)0));
}
}
#line 250 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_all_tabs clone_all_tabs___2(psiconv_all_tabs all_tabs ) 
{ 
  psiconv_all_tabs result ;
  void *tmp ;
  psiconv_tab_list tmp___0 ;

  {
  {
#line 253
  tmp = malloc(sizeof(*result));
#line 253
  result = (psiconv_all_tabs )tmp;
  }
#line 253
  if (! result) {
#line 254
    goto ERROR1;
  }
  {
#line 255
  *result = *all_tabs;
#line 256
  tmp___0 = psiconv_list_clone((psiconv_list const   )result->extras);
#line 256
  result->extras = tmp___0;
  }
#line 256
  if (! tmp___0) {
#line 257
    goto ERROR2;
  }
#line 258
  return (result);
  ERROR2: 
  {
#line 260
  free((void *)result);
  }
  ERROR1: 
#line 262
  return ((psiconv_all_tabs )((void *)0));
}
}
#line 464 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_style_aux___2(void *style___1 ) 
{ 


  {
#line 466
  if (((psiconv_word_style )style___1)->name) {
    {
#line 467
    free((void *)((psiconv_word_style )style___1)->name);
    }
  }
  {
#line 468
  psiconv_free_character_layout(((psiconv_word_style )style___1)->character);
#line 469
  psiconv_free_paragraph_layout(((psiconv_word_style )style___1)->paragraph);
  }
#line 470
  return;
}
}
#line 548 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_in_line_layout_aux___2(void *layout ) 
{ 


  {
  {
#line 550
  psiconv_free_character_layout(((psiconv_in_line_layout )layout)->layout);
#line 551
  psiconv_free_embedded_object_section(((psiconv_in_line_layout )layout)->object);
  }
#line 553
  return;
}
}
#line 581 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_paragraph_aux___2(void *paragraph___3 ) 
{ 


  {
#line 583
  if (((psiconv_paragraph )paragraph___3)->text) {
    {
#line 584
    free((void *)((psiconv_paragraph )paragraph___3)->text);
    }
  }
  {
#line 585
  psiconv_free_character_layout(((psiconv_paragraph )paragraph___3)->base_character);
#line 587
  psiconv_free_paragraph_layout(((psiconv_paragraph )paragraph___3)->base_paragraph);
#line 589
  psiconv_free_in_line_layouts(((psiconv_paragraph )paragraph___3)->in_lines);
#line 591
  psiconv_free_replacements(((psiconv_paragraph )paragraph___3)->replacements);
  }
#line 593
  return;
}
}
#line 672 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_sheet_cell_aux___2(void *cell ) 
{ 
  psiconv_sheet_cell data ;

  {
  {
#line 674
  data = (psiconv_sheet_cell )cell;
#line 676
  psiconv_free_sheet_cell_layout(data->layout);
  }
#line 678
  if ((unsigned int )data->type == 5U) {
#line 678
    if (data->data.dat_string) {
      {
#line 679
      free((void *)data->data.dat_string);
      }
    }
  }
#line 680
  return;
}
}
#line 696 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_sheet_line_aux___2(void *line ) 
{ 
  psiconv_sheet_line data ;

  {
  {
#line 698
  data = (psiconv_sheet_line )line;
#line 700
  psiconv_free_sheet_cell_layout(data->layout);
  }
#line 701
  return;
}
}
#line 747 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_sheet_worksheet_aux___2(void *data ) 
{ 
  psiconv_sheet_worksheet section ;

  {
  {
#line 749
  section = (psiconv_sheet_worksheet )data;
#line 750
  psiconv_free_sheet_cell_layout(section->default_layout);
#line 751
  psiconv_free_sheet_cell_list(section->cells);
#line 752
  psiconv_free_sheet_line_list(section->row_default_layouts);
#line 753
  psiconv_free_sheet_line_list(section->col_default_layouts);
#line 754
  psiconv_free_sheet_grid_section(section->grid);
  }
#line 755
  return;
}
}
#line 771 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_formula_aux___2(void *data ) 
{ 
  psiconv_formula formula ;

  {
#line 774
  formula = (psiconv_formula )data;
#line 775
  if ((unsigned int )formula->type == 23U) {
    {
#line 776
    free((void *)formula->data.dat_string);
    }
  } else
#line 777
  if ((unsigned int )formula->type != 21U) {
#line 777
    if ((unsigned int )formula->type != 22U) {
#line 777
      if ((unsigned int )formula->type != 20U) {
#line 777
        if ((unsigned int )formula->type != 24U) {
#line 777
          if ((unsigned int )formula->type != 25U) {
#line 777
            if ((unsigned int )formula->type != 26U) {
#line 777
              if ((unsigned int )formula->type != 27U) {
#line 777
                if ((unsigned int )formula->type != 28U) {
#line 777
                  if ((unsigned int )formula->type != 19U) {
#line 777
                    if ((unsigned int )formula->type != 0U) {
                      {
#line 787
                      psiconv_free_formula_list(formula->data.fun_operands);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 788
  return;
}
}
#line 820 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_sheet_variable_aux___2(void *variable ) 
{ 
  psiconv_sheet_variable var ;

  {
#line 822
  var = (psiconv_sheet_variable )variable;
#line 823
  if (var->name) {
    {
#line 824
    free((void *)var->name);
    }
  }
#line 825
  if ((unsigned int )var->type == 2U) {
    {
#line 826
    free((void *)var->data.dat_string);
    }
  }
#line 827
  return;
}
}
#line 874 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_paint_data_section_aux___2(void *section ) 
{ 


  {
#line 876
  if (((psiconv_paint_data_section )section)->red) {
    {
#line 877
    free((void *)((psiconv_paint_data_section )section)->red);
    }
  }
#line 878
  if (((psiconv_paint_data_section )section)->green) {
    {
#line 879
    free((void *)((psiconv_paint_data_section )section)->green);
    }
  }
#line 880
  if (((psiconv_paint_data_section )section)->blue) {
    {
#line 881
    free((void *)((psiconv_paint_data_section )section)->blue);
    }
  }
#line 882
  return;
}
}
#line 928 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_clipart_section_aux___2(void *section ) 
{ 


  {
#line 930
  if (section) {
    {
#line 931
    psiconv_free_paint_data_section(((psiconv_clipart_section )section)->picture);
    }
  }
#line 932
  return;
}
}
#line 1112 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_word_styles_section psiconv_empty_word_styles_section___2(void) 
{ 
  psiconv_word_styles_section result ;
  void *tmp ;
  psiconv_word_style_list tmp___0 ;
  psiconv_word_style tmp___1 ;
  void *tmp___2 ;
  psiconv_character_layout tmp___3 ;
  psiconv_paragraph_layout tmp___4 ;

  {
  {
#line 1115
  tmp = malloc(sizeof(*result));
#line 1115
  result = (psiconv_word_styles_section )tmp;
  }
#line 1115
  if (! result) {
#line 1116
    goto ERROR1;
  }
  {
#line 1117
  tmp___0 = psiconv_list_new(sizeof(struct psiconv_word_style_s ));
#line 1117
  result->styles = tmp___0;
  }
#line 1117
  if (! tmp___0) {
#line 1118
    goto ERROR2;
  }
  {
#line 1119
  tmp___2 = malloc(sizeof(struct psiconv_word_style_s ));
#line 1119
  tmp___1 = (psiconv_word_style )tmp___2;
#line 1119
  result->normal = tmp___1;
  }
#line 1119
  if (! tmp___1) {
#line 1120
    goto ERROR3;
  }
  {
#line 1121
  tmp___3 = psiconv_basic_character_layout();
#line 1121
  (result->normal)->character = tmp___3;
  }
#line 1121
  if (! tmp___3) {
#line 1122
    goto ERROR4;
  }
  {
#line 1123
  tmp___4 = psiconv_basic_paragraph_layout();
#line 1123
  (result->normal)->paragraph = tmp___4;
  }
#line 1123
  if (! tmp___4) {
#line 1124
    goto ERROR5;
  }
#line 1125
  (result->normal)->hotkey = (psiconv_ucs2 )'N';
#line 1126
  (result->normal)->name = (psiconv_string_t )((void *)0);
#line 1127
  (result->normal)->built_in = (psiconv_bool_t )1;
#line 1128
  (result->normal)->outline_level = (psiconv_u32 )0;
#line 1129
  return (result);
  ERROR5: 
  {
#line 1131
  psiconv_free_character_layout((result->normal)->character);
  }
  ERROR4: 
  {
#line 1133
  free((void *)result->normal);
  }
  ERROR3: 
  {
#line 1135
  psiconv_list_free(result->styles);
  }
  ERROR2: 
  {
#line 1137
  free((void *)result);
  }
  ERROR1: 
#line 1139
  return ((psiconv_word_styles_section )((void *)0));
}
}
#line 1142 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_text_and_layout psiconv_empty_text_and_layout___2(void) 
{ 
  psiconv_list tmp ;

  {
  {
#line 1144
  tmp = psiconv_list_new(sizeof(struct psiconv_paragraph_s ));
  }
#line 1144
  return (tmp);
}
}
#line 1147 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_texted_section psiconv_empty_texted_section___2(void) 
{ 
  psiconv_texted_section result ;
  void *tmp ;
  psiconv_text_and_layout tmp___0 ;

  {
  {
#line 1150
  tmp = malloc(sizeof(*result));
#line 1150
  result = (psiconv_texted_section )tmp;
  }
#line 1150
  if (! result) {
#line 1151
    goto ERROR1;
  }
  {
#line 1152
  tmp___0 = psiconv_empty_text_and_layout___2();
#line 1152
  result->paragraphs = tmp___0;
  }
#line 1152
  if (! tmp___0) {
#line 1153
    goto ERROR2;
  }
#line 1154
  return (result);
  ERROR2: 
  {
#line 1156
  free((void *)result);
  }
  ERROR1: 
#line 1158
  return ((psiconv_texted_section )((void *)0));
}
}
#line 1161 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_page_header psiconv_empty_page_header___2(void) 
{ 
  psiconv_page_header result ;
  void *tmp ;
  psiconv_paragraph_layout tmp___0 ;
  psiconv_character_layout tmp___1 ;
  psiconv_texted_section tmp___2 ;

  {
  {
#line 1164
  tmp = malloc(sizeof(*result));
#line 1164
  result = (psiconv_page_header )tmp;
  }
#line 1164
  if (! result) {
#line 1165
    goto ERROR1;
  }
  {
#line 1166
  result->on_first_page = (psiconv_bool_t )1;
#line 1167
  tmp___0 = psiconv_basic_paragraph_layout();
#line 1167
  result->base_paragraph_layout = tmp___0;
  }
#line 1167
  if (! tmp___0) {
#line 1168
    goto ERROR2;
  }
  {
#line 1169
  tmp___1 = psiconv_basic_character_layout();
#line 1169
  result->base_character_layout = tmp___1;
  }
#line 1169
  if (! tmp___1) {
#line 1170
    goto ERROR3;
  }
  {
#line 1171
  tmp___2 = psiconv_empty_texted_section___2();
#line 1171
  result->text = tmp___2;
  }
#line 1171
  if (! tmp___2) {
#line 1172
    goto ERROR4;
  }
#line 1173
  return (result);
  ERROR4: 
  {
#line 1175
  psiconv_free_character_layout(result->base_character_layout);
  }
  ERROR3: 
  {
#line 1177
  psiconv_free_paragraph_layout(result->base_paragraph_layout);
  }
  ERROR2: 
  {
#line 1179
  free((void *)result);
  }
  ERROR1: 
#line 1181
  return ((psiconv_page_header )((void *)0));
}
}
#line 1184 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_page_layout_section psiconv_empty_page_layout_section___2(void) 
{ 
  psiconv_page_layout_section result ;
  void *tmp ;
  psiconv_length_t tmp___0 ;
  psiconv_length_t tmp___1 ;
  psiconv_length_t tmp___2 ;
  psiconv_page_header tmp___3 ;
  psiconv_page_header tmp___4 ;

  {
  {
#line 1187
  tmp = malloc(sizeof(*result));
#line 1187
  result = (psiconv_page_layout_section )tmp;
  }
#line 1187
  if (! result) {
#line 1188
    goto ERROR1;
  }
  {
#line 1189
  result->first_page_nr = (psiconv_u32 )1;
#line 1190
  tmp___0 = (psiconv_length_t )1.27;
#line 1190
  result->footer_dist = tmp___0;
#line 1190
  result->header_dist = tmp___0;
#line 1191
  tmp___1 = (psiconv_length_t )3.175;
#line 1191
  result->right_margin = tmp___1;
#line 1191
  result->left_margin = tmp___1;
#line 1192
  tmp___2 = (psiconv_length_t )2.54;
#line 1192
  result->bottom_margin = tmp___2;
#line 1192
  result->top_margin = tmp___2;
#line 1193
  result->page_width = (psiconv_length_t )21.0;
#line 1194
  result->page_height = (psiconv_length_t )29.7;
#line 1195
  result->landscape = (psiconv_bool_t )0;
#line 1196
  tmp___3 = psiconv_empty_page_header___2();
#line 1196
  result->header = tmp___3;
  }
#line 1196
  if (! tmp___3) {
#line 1197
    goto ERROR2;
  }
  {
#line 1198
  tmp___4 = psiconv_empty_page_header___2();
#line 1198
  result->footer = tmp___4;
  }
#line 1198
  if (! tmp___4) {
#line 1199
    goto ERROR3;
  }
#line 1200
  return (result);
  ERROR3: 
  {
#line 1202
  psiconv_free_page_header(result->header);
  }
  ERROR2: 
  {
#line 1204
  free((void *)result);
  }
  ERROR1: 
#line 1206
  return ((psiconv_page_layout_section )((void *)0));
}
}
#line 1209 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_word_status_section psiconv_empty_word_status_section___2(void) 
{ 
  psiconv_word_status_section result ;
  void *tmp ;
  psiconv_bool_t tmp___0 ;
  psiconv_bool_t tmp___1 ;
  psiconv_bool_t tmp___2 ;
  psiconv_bool_t tmp___3 ;
  psiconv_bool_t tmp___4 ;
  psiconv_bool_t tmp___5 ;
  psiconv_bool_t tmp___6 ;
  psiconv_bool_t tmp___7 ;

  {
  {
#line 1212
  tmp = malloc(sizeof(*result));
#line 1212
  result = (psiconv_word_status_section )tmp;
  }
#line 1212
  if (! result) {
#line 1213
    return ((psiconv_word_status_section )((void *)0));
  }
#line 1214
  tmp___4 = (psiconv_bool_t )0;
#line 1214
  result->fit_lines_to_screen = tmp___4;
#line 1214
  tmp___3 = tmp___4;
#line 1214
  result->show_hard_space = tmp___3;
#line 1214
  tmp___2 = tmp___3;
#line 1214
  result->show_hard_minus = tmp___2;
#line 1214
  tmp___1 = tmp___2;
#line 1214
  result->show_paragraph_ends = tmp___1;
#line 1214
  tmp___0 = tmp___1;
#line 1214
  result->show_spaces = tmp___0;
#line 1214
  result->show_tabs = tmp___0;
#line 1217
  tmp___7 = (psiconv_bool_t )1;
#line 1217
  result->show_side_toolbar = tmp___7;
#line 1217
  tmp___6 = tmp___7;
#line 1217
  result->show_top_toolbar = tmp___6;
#line 1217
  tmp___5 = tmp___6;
#line 1217
  result->show_full_graphs = tmp___5;
#line 1217
  result->show_full_pictures = tmp___5;
#line 1220
  result->cursor_position = (psiconv_u32 )0;
#line 1221
  result->display_size = (psiconv_u32 )1000;
#line 1222
  return (result);
}
}
#line 1225 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_word_f psiconv_empty_word_f___2(void) 
{ 
  psiconv_word_f result ;
  void *tmp ;
  psiconv_page_layout_section tmp___0 ;
  psiconv_text_and_layout tmp___1 ;
  psiconv_word_status_section tmp___2 ;
  psiconv_word_styles_section tmp___3 ;

  {
  {
#line 1228
  tmp = malloc(sizeof(*result));
#line 1228
  result = (psiconv_word_f )tmp;
  }
#line 1228
  if (! result) {
#line 1229
    goto ERROR1;
  }
  {
#line 1230
  tmp___0 = psiconv_empty_page_layout_section___2();
#line 1230
  result->page_sec = tmp___0;
  }
#line 1230
  if (! tmp___0) {
#line 1231
    goto ERROR2;
  }
  {
#line 1232
  tmp___1 = psiconv_empty_text_and_layout___2();
#line 1232
  result->paragraphs = tmp___1;
  }
#line 1232
  if (! tmp___1) {
#line 1233
    goto ERROR3;
  }
  {
#line 1234
  tmp___2 = psiconv_empty_word_status_section___2();
#line 1234
  result->status_sec = tmp___2;
  }
#line 1234
  if (! tmp___2) {
#line 1235
    goto ERROR4;
  }
  {
#line 1236
  tmp___3 = psiconv_empty_word_styles_section___2();
#line 1236
  result->styles_sec = tmp___3;
  }
#line 1236
  if (! tmp___3) {
#line 1237
    goto ERROR5;
  }
#line 1238
  return (result);
  ERROR5: 
  {
#line 1240
  psiconv_free_word_status_section(result->status_sec);
  }
  ERROR4: 
  {
#line 1242
  psiconv_free_text_and_layout(result->paragraphs);
  }
  ERROR3: 
  {
#line 1244
  psiconv_free_page_layout_section(result->page_sec);
  }
  ERROR2: 
  {
#line 1246
  free((void *)result);
  }
  ERROR1: 
#line 1248
  return ((psiconv_word_f )((void *)0));
}
}
#line 1251 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sheet_status_section psiconv_empty_sheet_status_section___2(void) 
{ 
  psiconv_sheet_status_section result ;
  void *tmp ;
  psiconv_triple_t tmp___0 ;
  psiconv_bool_t tmp___1 ;
  psiconv_bool_t tmp___2 ;
  psiconv_bool_t tmp___3 ;
  psiconv_u32 tmp___4 ;
  psiconv_u32 tmp___5 ;

  {
  {
#line 1254
  tmp = malloc(sizeof(*result));
#line 1254
  result = (psiconv_sheet_status_section )tmp;
  }
#line 1254
  if (! result) {
#line 1255
    return ((psiconv_sheet_status_section )((void *)0));
  }
#line 1256
  tmp___0 = (psiconv_triple_t )2;
#line 1256
  result->show_vertical_scrollbar = tmp___0;
#line 1256
  result->show_horizontal_scrollbar = tmp___0;
#line 1258
  result->show_graph = (psiconv_bool_t )0;
#line 1259
  tmp___3 = (psiconv_bool_t )1;
#line 1259
  result->show_side_graph_toolbar = tmp___3;
#line 1259
  tmp___2 = tmp___3;
#line 1259
  result->show_top_graph_toolbar = tmp___2;
#line 1259
  tmp___1 = tmp___2;
#line 1259
  result->show_side_sheet_toolbar = tmp___1;
#line 1259
  result->show_top_sheet_toolbar = tmp___1;
#line 1262
  tmp___4 = (psiconv_u32 )0;
#line 1262
  result->cursor_column = tmp___4;
#line 1262
  result->cursor_row = tmp___4;
#line 1263
  tmp___5 = (psiconv_u32 )1000;
#line 1263
  result->graph_display_size = tmp___5;
#line 1263
  result->sheet_display_size = tmp___5;
#line 1264
  return (result);
}
}
#line 1267 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_formula_list psiconv_empty_formula_list___2(void) 
{ 
  psiconv_list tmp ;

  {
  {
#line 1269
  tmp = psiconv_list_new(sizeof(struct psiconv_formula_s ));
  }
#line 1269
  return (tmp);
}
}
#line 1272 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sheet_workbook_section psiconv_empty_sheet_workbook_section___2(void) 
{ 
  psiconv_sheet_workbook_section result ;
  void *tmp ;
  psiconv_formula_list tmp___0 ;

  {
  {
#line 1275
  tmp = malloc(sizeof(*result));
#line 1275
  result = (psiconv_sheet_workbook_section )tmp;
  }
#line 1275
  if (! result) {
#line 1276
    goto ERROR1;
  }
  {
#line 1277
  tmp___0 = psiconv_empty_formula_list___2();
#line 1277
  result->formulas = tmp___0;
  }
#line 1277
  if (! tmp___0) {
#line 1278
    goto ERROR2;
  }
#line 1279
  return (result);
  ERROR2: 
  {
#line 1281
  free((void *)result);
  }
  ERROR1: 
#line 1283
  return ((psiconv_sheet_workbook_section )((void *)0));
}
}
#line 1287 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sheet_f psiconv_empty_sheet_f___2(void) 
{ 
  psiconv_sheet_f result ;
  void *tmp ;
  psiconv_page_layout_section tmp___0 ;
  psiconv_sheet_status_section tmp___1 ;
  psiconv_sheet_workbook_section tmp___2 ;

  {
  {
#line 1290
  tmp = malloc(sizeof(*result));
#line 1290
  result = (psiconv_sheet_f )tmp;
  }
#line 1290
  if (! result) {
#line 1291
    goto ERROR1;
  }
  {
#line 1292
  tmp___0 = psiconv_empty_page_layout_section___2();
#line 1292
  result->page_sec = tmp___0;
  }
#line 1292
  if (! tmp___0) {
#line 1293
    goto ERROR2;
  }
  {
#line 1294
  tmp___1 = psiconv_empty_sheet_status_section___2();
#line 1294
  result->status_sec = tmp___1;
  }
#line 1294
  if (! tmp___1) {
#line 1295
    goto ERROR3;
  }
  {
#line 1296
  tmp___2 = psiconv_empty_sheet_workbook_section___2();
#line 1296
  result->workbook_sec = tmp___2;
  }
#line 1296
  if (! tmp___2) {
#line 1297
    goto ERROR4;
  }
#line 1298
  return (result);
  ERROR4: 
  {
#line 1300
  psiconv_free_sheet_status_section(result->status_sec);
  }
  ERROR3: 
  {
#line 1302
  psiconv_free_page_layout_section(result->page_sec);
  }
  ERROR2: 
  {
#line 1304
  free((void *)result);
  }
  ERROR1: 
#line 1306
  return ((psiconv_sheet_f )((void *)0));
}
}
#line 1309 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_texted_f psiconv_empty_texted_f___2(void) 
{ 
  psiconv_texted_f result ;
  void *tmp ;
  psiconv_page_layout_section tmp___0 ;
  psiconv_texted_section tmp___1 ;

  {
  {
#line 1312
  tmp = malloc(sizeof(*result));
#line 1312
  result = (psiconv_texted_f )tmp;
  }
#line 1312
  if (! result) {
#line 1313
    goto ERROR1;
  }
  {
#line 1314
  tmp___0 = psiconv_empty_page_layout_section___2();
#line 1314
  result->page_sec = tmp___0;
  }
#line 1314
  if (! tmp___0) {
#line 1315
    goto ERROR2;
  }
  {
#line 1316
  tmp___1 = psiconv_empty_texted_section___2();
#line 1316
  result->texted_sec = tmp___1;
  }
#line 1316
  if (! tmp___1) {
#line 1317
    goto ERROR3;
  }
#line 1318
  return (result);
  ERROR3: 
  {
#line 1320
  psiconv_free_page_layout_section(result->page_sec);
  }
  ERROR2: 
  {
#line 1322
  free((void *)result);
  }
  ERROR1: 
#line 1324
  return ((psiconv_texted_f )((void *)0));
}
}
#line 1327 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_paint_data_section psiconv_empty_paint_data_section___2(void) 
{ 
  psiconv_paint_data_section result ;
  void *tmp ;
  psiconv_u32 tmp___0 ;
  psiconv_length_t tmp___1 ;
  psiconv_length_t tmp___2 ;
  float *tmp___3 ;
  void *tmp___4 ;
  float *tmp___5 ;
  void *tmp___6 ;
  float *tmp___7 ;
  void *tmp___8 ;

  {
  {
#line 1330
  tmp = malloc(sizeof(*result));
#line 1330
  result = (psiconv_paint_data_section )tmp;
  }
#line 1330
  if (! result) {
#line 1331
    goto ERROR1;
  }
  {
#line 1333
  tmp___2 = (psiconv_length_t )0;
#line 1333
  result->pic_ysize = tmp___2;
#line 1333
  tmp___1 = tmp___2;
#line 1333
  result->pic_xsize = tmp___1;
#line 1333
  tmp___0 = (psiconv_u32 )tmp___1;
#line 1333
  result->ysize = tmp___0;
#line 1333
  result->xsize = tmp___0;
#line 1335
  tmp___4 = malloc((size_t )0);
#line 1335
  tmp___3 = (float *)tmp___4;
#line 1335
  result->red = tmp___3;
  }
#line 1335
  if (! tmp___3) {
#line 1336
    goto ERROR2;
  }
  {
#line 1337
  tmp___6 = malloc((size_t )0);
#line 1337
  tmp___5 = (float *)tmp___6;
#line 1337
  result->green = tmp___5;
  }
#line 1337
  if (! tmp___5) {
#line 1338
    goto ERROR3;
  }
  {
#line 1339
  tmp___8 = malloc((size_t )0);
#line 1339
  tmp___7 = (float *)tmp___8;
#line 1339
  result->blue = tmp___7;
  }
#line 1339
  if (! tmp___7) {
#line 1340
    goto ERROR4;
  }
#line 1341
  return (result);
  ERROR4: 
  {
#line 1343
  free((void *)result->green);
  }
  ERROR3: 
  {
#line 1345
  free((void *)result->red);
  }
  ERROR2: 
  {
#line 1347
  free((void *)result);
  }
  ERROR1: 
#line 1349
  return ((psiconv_paint_data_section )((void *)0));
}
}
#line 1353 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_pictures psiconv_empty_pictures___2(void) 
{ 
  psiconv_pictures result ;
  psiconv_paint_data_section pds ;
  int tmp ;

  {
  {
#line 1357
  result = psiconv_list_new(sizeof(struct psiconv_paint_data_section_s ));
  }
#line 1357
  if (! result) {
#line 1358
    goto ERROR1;
  }
  {
#line 1359
  pds = psiconv_empty_paint_data_section___2();
  }
#line 1359
  if (! pds) {
#line 1360
    goto ERROR2;
  }
  {
#line 1361
  tmp = psiconv_list_add(result, (void const   *)pds);
  }
#line 1361
  if (tmp) {
#line 1362
    goto ERROR3;
  }
  {
#line 1363
  free((void *)pds);
  }
#line 1364
  return (result);
  ERROR3: 
  {
#line 1366
  psiconv_free_paint_data_section(pds);
  }
  ERROR2: 
  {
#line 1368
  psiconv_list_free(result);
  }
  ERROR1: 
#line 1370
  return ((psiconv_pictures )((void *)0));
}
}
#line 1373 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_mbm_f psiconv_empty_mbm_f___2(void) 
{ 
  psiconv_mbm_f result ;
  void *tmp ;
  psiconv_pictures tmp___0 ;

  {
  {
#line 1376
  tmp = malloc(sizeof(*result));
#line 1376
  result = (psiconv_mbm_f )tmp;
  }
#line 1376
  if (! result) {
#line 1377
    goto ERROR1;
  }
  {
#line 1378
  tmp___0 = psiconv_empty_pictures___2();
#line 1378
  result->sections = tmp___0;
  }
#line 1378
  if (! tmp___0) {
#line 1379
    goto ERROR2;
  }
#line 1380
  return (result);
  ERROR2: 
  {
#line 1382
  free((void *)result);
  }
  ERROR1: 
#line 1384
  return ((psiconv_mbm_f )((void *)0));
}
}
#line 1387 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sketch_section psiconv_empty_sketch_section___2(void) 
{ 
  psiconv_sketch_section result ;
  void *tmp ;
  psiconv_u16 tmp___0 ;
  psiconv_u16 tmp___1 ;
  psiconv_u16 tmp___2 ;
  psiconv_u16 tmp___3 ;
  psiconv_u16 tmp___4 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;
  float tmp___8 ;
  psiconv_paint_data_section tmp___9 ;

  {
  {
#line 1390
  tmp = malloc(sizeof(*result));
#line 1390
  result = (psiconv_sketch_section )tmp;
  }
#line 1390
  if (! result) {
#line 1391
    goto ERROR1;
  }
  {
#line 1392
  result->displayed_xsize = (psiconv_u16 )320;
#line 1393
  result->displayed_ysize = (psiconv_u16 )200;
#line 1394
  tmp___4 = (psiconv_u16 )0;
#line 1394
  result->displayed_size_y_offset = tmp___4;
#line 1394
  tmp___3 = tmp___4;
#line 1394
  result->displayed_size_x_offset = tmp___3;
#line 1394
  tmp___2 = tmp___3;
#line 1394
  result->form_ysize = tmp___2;
#line 1394
  tmp___1 = tmp___2;
#line 1394
  result->form_xsize = tmp___1;
#line 1394
  tmp___0 = tmp___1;
#line 1394
  result->picture_data_y_offset = tmp___0;
#line 1394
  result->picture_data_x_offset = tmp___0;
#line 1397
  tmp___5 = (float )1.0;
#line 1397
  result->magnification_y = tmp___5;
#line 1397
  result->magnification_x = tmp___5;
#line 1398
  tmp___8 = (float )0.0;
#line 1398
  result->cut_bottom = tmp___8;
#line 1398
  tmp___7 = tmp___8;
#line 1398
  result->cut_top = tmp___7;
#line 1398
  tmp___6 = tmp___7;
#line 1398
  result->cut_right = tmp___6;
#line 1398
  result->cut_left = tmp___6;
#line 1400
  tmp___9 = psiconv_empty_paint_data_section___2();
#line 1400
  result->picture = tmp___9;
  }
#line 1400
  if (! tmp___9) {
#line 1401
    goto ERROR2;
  }
#line 1402
  return (result);
  ERROR2: 
  {
#line 1404
  free((void *)result);
  }
  ERROR1: 
#line 1406
  return ((psiconv_sketch_section )((void *)0));
}
}
#line 1409 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sketch_f psiconv_empty_sketch_f___2(void) 
{ 
  psiconv_sketch_f result ;
  void *tmp ;
  psiconv_sketch_section tmp___0 ;

  {
  {
#line 1412
  tmp = malloc(sizeof(*result));
#line 1412
  result = (psiconv_sketch_f )tmp;
  }
#line 1412
  if (! result) {
#line 1413
    goto ERROR1;
  }
  {
#line 1414
  tmp___0 = psiconv_empty_sketch_section___2();
#line 1414
  result->sketch_sec = tmp___0;
  }
#line 1414
  if (! tmp___0) {
#line 1415
    goto ERROR2;
  }
#line 1416
  return (result);
  ERROR2: 
  {
#line 1418
  free((void *)result);
  }
  ERROR1: 
#line 1420
  return ((psiconv_sketch_f )((void *)0));
}
}
#line 1423 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_cliparts psiconv_empty_cliparts___2(void) 
{ 
  psiconv_list tmp ;

  {
  {
#line 1426
  tmp = psiconv_list_new(sizeof(struct psiconv_clipart_section_s ));
  }
#line 1426
  return (tmp);
}
}
#line 1429 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_clipart_f psiconv_empty_clipart_f___2(void) 
{ 
  psiconv_clipart_f result ;
  void *tmp ;
  psiconv_cliparts tmp___0 ;

  {
  {
#line 1432
  tmp = malloc(sizeof(*result));
#line 1432
  result = (psiconv_clipart_f )tmp;
  }
#line 1432
  if (! result) {
#line 1433
    goto ERROR1;
  }
  {
#line 1434
  tmp___0 = psiconv_empty_cliparts___2();
#line 1434
  result->sections = tmp___0;
  }
#line 1434
  if (! tmp___0) {
#line 1435
    goto ERROR2;
  }
#line 1436
  return (result);
  ERROR2: 
  {
#line 1438
  free((void *)result);
  }
  ERROR1: 
#line 1440
  return ((psiconv_clipart_f )((void *)0));
}
}
#line 234 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_image.c"
void init_image(void) 
{ 


  {
#line 252
  return;
}
}
#line 28 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/checkuid.c"
static psiconv_u32 uid1___3[32]  = 
#line 28 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/checkuid.c"
  {      (psiconv_u32 )17824,      (psiconv_u32 )35648,      (psiconv_u32 )1697,      (psiconv_u32 )3394, 
        (psiconv_u32 )6788,      (psiconv_u32 )13576,      (psiconv_u32 )27152,      (psiconv_u32 )54304, 
        (psiconv_u32 )1168113664,      2336227328U,      (psiconv_u32 )111214592,      (psiconv_u32 )222429184, 
        (psiconv_u32 )444858368,      (psiconv_u32 )889716736,      (psiconv_u32 )1779433472,      3558866944U, 
        (psiconv_u32 )43601,      (psiconv_u32 )17539,      (psiconv_u32 )35078,      (psiconv_u32 )557, 
        (psiconv_u32 )1114,      (psiconv_u32 )2228,      (psiconv_u32 )4456,      (psiconv_u32 )8912, 
        2857435136U,      (psiconv_u32 )1149435904,      2298871808U,      (psiconv_u32 )36503552, 
        (psiconv_u32 )73007104,      (psiconv_u32 )146014208,      (psiconv_u32 )292028416,      (psiconv_u32 )584056832};
#line 62 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/checkuid.c"
static psiconv_u32 uid2___3[32]  = 
#line 62
  {      (psiconv_u32 )30388,      (psiconv_u32 )60776,      (psiconv_u32 )51953,      (psiconv_u32 )34243, 
        (psiconv_u32 )7079,      (psiconv_u32 )14158,      (psiconv_u32 )28316,      (psiconv_u32 )56632, 
        (psiconv_u32 )1991507968,      3983015936U,      3404791808U,      2244149248U, 
        (psiconv_u32 )463929344,      (psiconv_u32 )927858688,      (psiconv_u32 )1855717376,      3711434752U, 
        (psiconv_u32 )14128,      (psiconv_u32 )28256,      (psiconv_u32 )56512,      (psiconv_u32 )43425, 
        (psiconv_u32 )17251,      (psiconv_u32 )34502,      (psiconv_u32 )7597,      (psiconv_u32 )15194, 
        (psiconv_u32 )925892608,      (psiconv_u32 )1851785216,      3703570432U,      2845900800U, 
        (psiconv_u32 )1130561536,      2261123072U,      (psiconv_u32 )497876992,      (psiconv_u32 )995753984};
#line 96 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/checkuid.c"
static psiconv_u32 uid3___3[32]  = 
#line 96
  {      (psiconv_u32 )13105,      (psiconv_u32 )26210,      (psiconv_u32 )52420,      (psiconv_u32 )35241, 
        (psiconv_u32 )883,      (psiconv_u32 )1766,      (psiconv_u32 )3532,      (psiconv_u32 )7064, 
        (psiconv_u32 )858849280,      (psiconv_u32 )1717698560,      3435397120U,      2309554176U, 
        (psiconv_u32 )57868288,      (psiconv_u32 )115736576,      (psiconv_u32 )231473152,      (psiconv_u32 )462946304, 
        (psiconv_u32 )4129,      (psiconv_u32 )8258,      (psiconv_u32 )16516,      (psiconv_u32 )33032, 
        (psiconv_u32 )4657,      (psiconv_u32 )9314,      (psiconv_u32 )18628,      (psiconv_u32 )37256, 
        (psiconv_u32 )270598144,      (psiconv_u32 )541196288,      (psiconv_u32 )1082392576,      2164785152U, 
        (psiconv_u32 )305201152,      (psiconv_u32 )610402304,      (psiconv_u32 )1220804608,      2441609216U};
#line 36 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_driver.c"
static psiconv_bool_t applid_matches___3(psiconv_string_t found , char const   *sought ) 
{ 
  int i ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 40
  tmp = psiconv_unicode_strlen((psiconv_ucs2 const   *)found);
#line 40
  tmp___0 = strlen(sought);
  }
#line 40
  if ((size_t )tmp != tmp___0) {
#line 41
    return ((psiconv_bool_t )0);
  }
#line 42
  i = 0;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 42
    tmp___1 = strlen(sought);
    }
#line 42
    if (! ((size_t )i < tmp___1)) {
#line 42
      goto while_break;
    }
#line 43
    if ((int )*(found + i) != (int )*(sought + i)) {
#line 43
      if ((int const   )*(sought + i) < 97) {
#line 46
        return ((psiconv_bool_t )0);
      } else
#line 43
      if ((int const   )*(sought + i) > 122) {
#line 46
        return ((psiconv_bool_t )0);
      } else
#line 43
      if ((int )*(found + i) != (int )(((int const   )*(sought + i) + 65) - 97)) {
#line 46
        return ((psiconv_bool_t )0);
      }
    }
#line 42
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return ((psiconv_bool_t )1);
}
}
#line 40 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static struct formula_element formula_elements___3[256]  = 
#line 40 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
  {      {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )1, 2, "<"}, 
        {(psiconv_formula_type_t )2, 2, "<="}, 
        {(psiconv_formula_type_t )3, 2, ">"}, 
        {(psiconv_formula_type_t )4, 2, ">="}, 
        {(psiconv_formula_type_t )5, 2, "<>"}, 
        {(psiconv_formula_type_t )6, 2, "="}, 
        {(psiconv_formula_type_t )7, 2, "+"}, 
        {(psiconv_formula_type_t )8, 2, "-"}, 
        {(psiconv_formula_type_t )9, 2, "*"}, 
        {(psiconv_formula_type_t )10, 2, "/"}, 
        {(psiconv_formula_type_t )11, 2, "^"}, 
        {(psiconv_formula_type_t )12, 1, "+"}, 
        {(psiconv_formula_type_t )13, 1, "-"}, 
        {(psiconv_formula_type_t )14, 1, "NOT"}, 
        {(psiconv_formula_type_t )15, 2, "AND"}, 
        {(psiconv_formula_type_t )16, 2, "OR"}, 
        {(psiconv_formula_type_t )17, 2, "&"}, 
        {(psiconv_formula_type_t )18, 1, "()"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )19, 0, "End of formula"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )20, 0, "Floating point number"}, 
        {(psiconv_formula_type_t )21, 0, "Signed integer number"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )22, 0, "Named variable"}, 
        {(psiconv_formula_type_t )23, 0, "String"}, 
        {(psiconv_formula_type_t )24, 0, "Cell reference"}, 
        {(psiconv_formula_type_t )25, 0, "Cell block"}, 
        {(psiconv_formula_type_t )26, 0, "Cell block {varargs}"}, 
        {(psiconv_formula_type_t )27, 0, "Operand separator"}, 
        {(psiconv_formula_type_t )28, 0, "Operand list end"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )29, 0, "FALSE"}, 
        {(psiconv_formula_type_t )30, 3, "IF"}, 
        {(psiconv_formula_type_t )31, 0, "TRUE"}, 
        {(psiconv_formula_type_t )32, 2, "CELL"}, 
        {(psiconv_formula_type_t )33, 0, "ERRORTYPE"}, 
        {(psiconv_formula_type_t )34, 1, "ISBLANK"}, 
        {(psiconv_formula_type_t )35, 1, "ISERR"}, 
        {(psiconv_formula_type_t )36, 1, "ISERROR"}, 
        {(psiconv_formula_type_t )37, 1, "ISLOGICAL"}, 
        {(psiconv_formula_type_t )38, 1, "ISNA"}, 
        {(psiconv_formula_type_t )39, 1, "ISNONTEXT"}, 
        {(psiconv_formula_type_t )40, 1, "ISNUMBER"}, 
        {(psiconv_formula_type_t )41, 1, "ISTEXT"}, 
        {(psiconv_formula_type_t )42, 1, "N"}, 
        {(psiconv_formula_type_t )43, 1, "TYPE"}, 
        {(psiconv_formula_type_t )44, 2, "ADDRESS"}, 
        {(psiconv_formula_type_t )45, 1, "COLUMN"}, 
        {(psiconv_formula_type_t )46, 1, "COLUMNS"}, 
        {(psiconv_formula_type_t )47, 3, "HLOOKUP"}, 
        {(psiconv_formula_type_t )48, 3, "INDEX"}, 
        {(psiconv_formula_type_t )49, 1, "INDIRECT"}, 
        {(psiconv_formula_type_t )50, 3, "LOOKUP"}, 
        {(psiconv_formula_type_t )51, 3, "OFFSET"}, 
        {(psiconv_formula_type_t )52, 1, "ROW"}, 
        {(psiconv_formula_type_t )53, 1, "ROWS"}, 
        {(psiconv_formula_type_t )54, 3, "VLOOKUP"}, 
        {(psiconv_formula_type_t )55, 1, "CHAR"}, 
        {(psiconv_formula_type_t )56, 1, "CODE"}, 
        {(psiconv_formula_type_t )57, 2, "EXACT"}, 
        {(psiconv_formula_type_t )58, 3, "FIND"}, 
        {(psiconv_formula_type_t )59, 2, "LEFT"}, 
        {(psiconv_formula_type_t )60, 1, "LEN"}, 
        {(psiconv_formula_type_t )61, 1, "LOWER"}, 
        {(psiconv_formula_type_t )62, 3, "MID"}, 
        {(psiconv_formula_type_t )63, 1, "PROPER"}, 
        {(psiconv_formula_type_t )64, 4, "REPLACE"}, 
        {(psiconv_formula_type_t )65, 2, "REPT"}, 
        {(psiconv_formula_type_t )66, 2, "RIGHT"}, 
        {(psiconv_formula_type_t )67, 2, "STRING"}, 
        {(psiconv_formula_type_t )68, 1, "T"}, 
        {(psiconv_formula_type_t )69, 1, "TRIM"}, 
        {(psiconv_formula_type_t )70, 1, "UPPER"}, 
        {(psiconv_formula_type_t )71, 1, "VALUE"}, 
        {(psiconv_formula_type_t )72, 3, "DATE"}, 
        {(psiconv_formula_type_t )73, 1, "DATEVALUE"}, 
        {(psiconv_formula_type_t )74, 1, "DAY"}, 
        {(psiconv_formula_type_t )75, 1, "HOUR"}, 
        {(psiconv_formula_type_t )76, 1, "MINUTE"}, 
        {(psiconv_formula_type_t )77, 1, "MONTH"}, 
        {(psiconv_formula_type_t )78, 0, "NOW"}, 
        {(psiconv_formula_type_t )79, 1, "SECOND"}, 
        {(psiconv_formula_type_t )80, 0, "TODAY"}, 
        {(psiconv_formula_type_t )81, 3, "TIME"}, 
        {(psiconv_formula_type_t )82, 1, "TIMEVALUE"}, 
        {(psiconv_formula_type_t )83, 1, "YEAR"}, 
        {(psiconv_formula_type_t )84, 1, "ABS"}, 
        {(psiconv_formula_type_t )85, 1, "ACOS"}, 
        {(psiconv_formula_type_t )86, 1, "ASIN"}, 
        {(psiconv_formula_type_t )87, 1, "ATAN"}, 
        {(psiconv_formula_type_t )88, 2, "ATAN2"}, 
        {(psiconv_formula_type_t )89, 1, "COS"}, 
        {(psiconv_formula_type_t )90, 0, "DEGREES"}, 
        {(psiconv_formula_type_t )91, 1, "EXP"}, 
        {(psiconv_formula_type_t )92, 1, "FACT"}, 
        {(psiconv_formula_type_t )93, 1, "INT"}, 
        {(psiconv_formula_type_t )94, 1, "LN"}, 
        {(psiconv_formula_type_t )95, 1, "LOG10"}, 
        {(psiconv_formula_type_t )96, 2, "MOD"}, 
        {(psiconv_formula_type_t )97, 0, "PI"}, 
        {(psiconv_formula_type_t )98, 1, "RADIANS"}, 
        {(psiconv_formula_type_t )99, 0, "RAND"}, 
        {(psiconv_formula_type_t )100, 2, "ROUND"}, 
        {(psiconv_formula_type_t )101, 1, "SIGN"}, 
        {(psiconv_formula_type_t )102, 1, "SIN"}, 
        {(psiconv_formula_type_t )103, 1, "SQRT"}, 
        {(psiconv_formula_type_t )104, 2, "SUMPRODUCT"}, 
        {(psiconv_formula_type_t )105, 1, "TAN"}, 
        {(psiconv_formula_type_t )106, 1, "TRUNC"}, 
        {(psiconv_formula_type_t )107, 3, "CTERM"}, 
        {(psiconv_formula_type_t )108, 4, "DDB"}, 
        {(psiconv_formula_type_t )109, 3, "FV"}, 
        {(psiconv_formula_type_t )110, 2, "IRR"}, 
        {(psiconv_formula_type_t )111, 2, "NPV"}, 
        {(psiconv_formula_type_t )112, 3, "PMT"}, 
        {(psiconv_formula_type_t )113, 3, "PV"}, 
        {(psiconv_formula_type_t )114, 3, "RATE"}, 
        {(psiconv_formula_type_t )115, 3, "SLN"}, 
        {(psiconv_formula_type_t )116, 4, "SYD"}, 
        {(psiconv_formula_type_t )117, 3, "TERM"}, 
        {(psiconv_formula_type_t )118, 2, "COMBIN"}, 
        {(psiconv_formula_type_t )119, 2, "PERMUT"}, 
        {(psiconv_formula_type_t )120, -1, "AVERAGE"}, 
        {(psiconv_formula_type_t )121, -1, "CHOOSE"}, 
        {(psiconv_formula_type_t )122, -1, "COUNT"}, 
        {(psiconv_formula_type_t )123, -1, "COUNTA"}, 
        {(psiconv_formula_type_t )124, -1, "COUNTBLANK"}, 
        {(psiconv_formula_type_t )125, -1, "MAX"}, 
        {(psiconv_formula_type_t )126, -1, "MIN"}, 
        {(psiconv_formula_type_t )127, -1, "PRODUCT"}, 
        {(psiconv_formula_type_t )128, -1, "STDEVP"}, 
        {(psiconv_formula_type_t )129, -1, "STDEV"}, 
        {(psiconv_formula_type_t )130, -1, "SUM"}, 
        {(psiconv_formula_type_t )131, -1, "SUMSQ"}, 
        {(psiconv_formula_type_t )132, -1, "VARP"}, 
        {(psiconv_formula_type_t )133, -1, "VAR"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}, 
        {(psiconv_formula_type_t )0, 0, "*UNKNOWN*"}};
#line 296 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static int psiconv_parse_sheet_ref___3(psiconv_config const   config , psiconv_buffer const   buf ,
                                       int lev , psiconv_u32 off , int *length , psiconv_sheet_ref_t *result ) 
{ 
  int res ;
  psiconv_u16 temp ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 304
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a sheet ref");
#line 305
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the offset encoding");
#line 306
  temp = psiconv_read_u16(config, buf, lev + 2, off, & res);
  }
#line 307
  if (res) {
#line 308
    if (length) {
#line 309
      *length = 0;
    }
#line 310
    return (res);
  }
  {
#line 312
  psiconv_debug((psiconv_config )config, lev + 2, off, "Encoded word: %04x", (int )temp);
  }
#line 313
  if ((int )temp & 16384) {
#line 313
    result->absolute = (psiconv_bool_t )1;
  } else {
#line 313
    result->absolute = (psiconv_bool_t )0;
  }
#line 314
  if ((int )temp & 32768) {
#line 314
    tmp = -1;
  } else {
#line 314
    tmp = 1;
  }
#line 314
  result->offset = (psiconv_s16 )(((int )temp & 16383) * tmp);
#line 315
  if (result->absolute) {
#line 315
    tmp___0 = "absolute";
  } else {
#line 315
    tmp___0 = "relative";
  }
  {
#line 315
  psiconv_debug((psiconv_config )config, lev + 2, off, "Reference: %s offset %d",
                tmp___0, (int )result->offset);
  }
#line 317
  if (length) {
#line 318
    *length = 2;
  }
#line 319
  return (0);
}
}
#line 322 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static int psiconv_parse_sheet_cell_reference___3(psiconv_config const   config ,
                                                  psiconv_buffer const   buf , int lev ,
                                                  psiconv_u32 off , int *length ,
                                                  psiconv_sheet_cell_reference_t *result ) 
{ 
  int len ;
  int leng ;
  int res ;
  psiconv_u8 temp ;

  {
  {
#line 327
  len = 0;
#line 331
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read a sheet cell reference");
#line 332
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the row reference");
#line 333
  res = psiconv_parse_sheet_ref___3(config, buf, lev + 2, off + (psiconv_u32 )len,
                                    & leng, & result->row);
  }
#line 333
  if (res) {
#line 334
    goto ERROR;
  }
  {
#line 335
  len += leng;
#line 336
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the column reference");
#line 337
  res = psiconv_parse_sheet_ref___3(config, buf, lev + 2, off + (psiconv_u32 )len,
                                    & leng, & result->column);
  }
#line 337
  if (res) {
#line 338
    goto ERROR;
  }
  {
#line 339
  len += leng;
#line 341
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the trailing byte (%02x expected)",
                   0);
#line 343
  temp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 344
  if (res) {
#line 345
    goto ERROR;
  }
#line 346
  if ((int )temp != 0) {
    {
#line 347
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Unknown byte in cell reference (ignored");
#line 348
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Trailing byte: %02x",
                  (int )temp);
    }
  }
  {
#line 350
  len ++;
#line 351
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of cell reference (total length: %08x)",
                   len);
  }
#line 353
  if (length) {
#line 354
    *length = len;
  }
#line 355
  return (0);
  ERROR: 
#line 357
  if (length) {
#line 358
    *length = 0;
  }
#line 359
  return (res);
}
}
#line 362 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static int psiconv_parse_sheet_cell_block___3(psiconv_config const   config , psiconv_buffer const   buf ,
                                              int lev , psiconv_u32 off , int *length ,
                                              psiconv_sheet_cell_block_t *result ) 
{ 
  int len ;
  int leng ;
  int res ;

  {
  {
#line 367
  len = 0;
#line 370
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read a sheet cell block");
#line 371
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the first cell");
#line 372
  res = psiconv_parse_sheet_cell_reference___3(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & leng, & result->first);
  }
#line 372
  if (res) {
#line 374
    goto ERROR;
  }
  {
#line 375
  len += leng;
#line 376
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the last cell");
#line 377
  res = psiconv_parse_sheet_cell_reference___3(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & leng, & result->last);
  }
#line 377
  if (res) {
#line 379
    goto ERROR;
  }
  {
#line 380
  len += leng;
#line 381
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of cell block (total length: %08x)",
                   len);
  }
#line 383
  if (length) {
#line 384
    *length = len;
  }
#line 385
  return (0);
  ERROR: 
#line 387
  if (length) {
#line 388
    *length = 0;
  }
#line 389
  return (res);
}
}
#line 392 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_formula.c"
static int psiconv_parse_formula_element_list___3(psiconv_config const   config ,
                                                  psiconv_buffer const   buf , int lev ,
                                                  psiconv_u32 off , int *length ,
                                                  psiconv_formula *result , psiconv_u32 maxlen ) 
{ 
  int res ;
  int len ;
  int leng ;
  int eof ;
  psiconv_u8 marker ;
  psiconv_u8 submarker ;
  psiconv_u8 submarker2 ;
  psiconv_formula_list formula_stack ;
  psiconv_formula formula ;
  psiconv_formula subformula ;
  psiconv_formula subformula1 ;
  psiconv_formula subformula2 ;
  psiconv_formula subformula3 ;
  psiconv_formula subformula4 ;
  psiconv_u16 temp ;
  psiconv_u16 nr_of_subs ;
  psiconv_formula tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  psiconv_formula_list tmp___6 ;
  psiconv_formula_list tmp___7 ;
  psiconv_formula_type_t tmp___8 ;
  psiconv_formula_type_t tmp___9 ;
  psiconv_formula_type_t tmp___10 ;
  psiconv_formula_type_t tmp___11 ;
  psiconv_u32 tmp___12 ;
  psiconv_u32 tmp___13 ;

  {
  {
#line 398
  res = 0;
#line 399
  len = 0;
#line 401
  eof = 0;
#line 408
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a formula element list");
#line 409
  tmp___0 = malloc(sizeof(*(*result)));
#line 409
  tmp = (psiconv_formula )tmp___0;
#line 409
  *result = tmp;
  }
#line 409
  if (! tmp) {
#line 410
    goto ERROR1;
  }
  {
#line 411
  formula_stack = psiconv_list_new(sizeof(struct psiconv_formula_s ));
  }
#line 411
  if (! formula_stack) {
#line 412
    goto ERROR2;
  }
  {
#line 413
  tmp___1 = malloc(sizeof(*formula));
#line 413
  formula = (psiconv_formula )tmp___1;
  }
#line 413
  if (! formula) {
#line 414
    goto ERROR3;
  }
  {
#line 416
  formula->type = (psiconv_formula_type_t )0;
#line 417
  tmp___2 = malloc(sizeof(*subformula1));
#line 417
  subformula1 = (psiconv_formula )tmp___2;
  }
#line 417
  if (! subformula1) {
#line 418
    goto ERROR4;
  }
  {
#line 419
  subformula1->type = (psiconv_formula_type_t )0;
#line 420
  tmp___3 = malloc(sizeof(*subformula2));
#line 420
  subformula2 = (psiconv_formula )tmp___3;
  }
#line 420
  if (! subformula2) {
#line 421
    goto ERROR5;
  }
  {
#line 422
  subformula2->type = (psiconv_formula_type_t )0;
#line 423
  tmp___4 = malloc(sizeof(*subformula3));
#line 423
  subformula3 = (psiconv_formula )tmp___4;
  }
#line 423
  if (! subformula3) {
#line 424
    goto ERROR6;
  }
  {
#line 425
  subformula3->type = (psiconv_formula_type_t )0;
#line 426
  tmp___5 = malloc(sizeof(*subformula4));
#line 426
  subformula4 = (psiconv_formula )tmp___5;
  }
#line 426
  if (! subformula4) {
#line 427
    goto ERROR7;
  }
#line 428
  subformula4->type = (psiconv_formula_type_t )0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! eof) {
#line 430
      if (! ((psiconv_u32 )len + off < maxlen)) {
#line 430
        goto while_break;
      }
    } else {
#line 430
      goto while_break;
    }
    {
#line 431
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read a formula item marker");
#line 432
    marker = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
    }
#line 433
    if (res) {
#line 434
      goto ERROR8;
    }
    {
#line 435
    psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Marker: %02x (%s)",
                  (int )marker, formula_elements___3[marker].name);
#line 437
    len ++;
    }
#line 439
    if ((unsigned int )formula_elements___3[marker].formula_type == 0U) {
      {
#line 440
      psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Unknown formula marker found!");
      }
#line 441
      goto ERROR8;
    } else
#line 442
    if ((unsigned int )formula_elements___3[marker].formula_type == 19U) {
      {
#line 448
      len --;
#line 449
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "End of this formula list");
#line 450
      eof = 1;
      }
    } else
#line 442
    if ((unsigned int )formula_elements___3[marker].formula_type == 28U) {
      {
#line 448
      len --;
#line 449
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "End of this formula list");
#line 450
      eof = 1;
      }
    } else
#line 442
    if ((unsigned int )formula_elements___3[marker].formula_type == 27U) {
      {
#line 448
      len --;
#line 449
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "End of this formula list");
#line 450
      eof = 1;
      }
    } else
#line 451
    if ((unsigned int )formula_elements___3[marker].formula_type == 21U) {
      {
#line 453
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: an integer");
#line 454
      formula->data.dat_int = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & res);
      }
#line 455
      if (res) {
#line 456
        goto ERROR8;
      }
      {
#line 457
      formula->type = formula_elements___3[marker].formula_type;
#line 458
      psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Value: %08x",
                    formula->data.dat_int);
#line 459
      len += 4;
#line 460
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 460
      if (res) {
#line 461
        goto ERROR8;
      }
#line 462
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 463
    if ((unsigned int )formula_elements___3[marker].formula_type == 20U) {
      {
#line 465
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a float");
#line 466
      formula->data.dat_float = psiconv_read_float(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                   & leng, & res);
      }
#line 468
      if (res) {
#line 469
        goto ERROR8;
      }
      {
#line 470
      formula->type = formula_elements___3[marker].formula_type;
#line 471
      psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Value: %f",
                    formula->data.dat_float);
#line 472
      len += leng;
#line 473
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 473
      if (res) {
#line 474
        goto ERROR8;
      }
#line 475
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 476
    if ((unsigned int )formula_elements___3[marker].formula_type == 24U) {
      {
#line 478
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a cell reference");
#line 479
      res = psiconv_parse_sheet_cell_reference___3(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                   & leng, & formula->data.dat_cellref);
      }
#line 479
      if (res) {
#line 481
        goto ERROR8;
      }
      {
#line 482
      formula->type = formula_elements___3[marker].formula_type;
#line 483
      len += leng;
#line 484
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 484
      if (res) {
#line 485
        goto ERROR8;
      }
#line 486
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 487
    if ((unsigned int )formula_elements___3[marker].formula_type == 25U) {
#line 487
      goto _L;
    } else
#line 487
    if ((unsigned int )formula_elements___3[marker].formula_type == 26U) {
      _L: /* CIL Label */ 
      {
#line 491
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a cell block");
#line 492
      res = psiconv_parse_sheet_cell_block___3(config, buf, lev + 2, off + (psiconv_u32 )len,
                                               & leng, & formula->data.dat_cellblock);
      }
#line 492
      if (res) {
#line 494
        goto ERROR8;
      }
      {
#line 495
      formula->type = formula_elements___3[marker].formula_type;
#line 496
      len += leng;
#line 497
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 497
      if (res) {
#line 498
        goto ERROR8;
      }
#line 499
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 500
    if ((unsigned int )formula_elements___3[marker].formula_type == 23U) {
      {
#line 502
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a string");
#line 503
      formula->data.dat_string = psiconv_read_short_string(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                           & leng, & res);
      }
#line 505
      if (res) {
#line 506
        goto ERROR8;
      }
      {
#line 507
      formula->type = formula_elements___3[marker].formula_type;
#line 508
      len += leng;
#line 509
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 509
      if (res) {
#line 510
        goto ERROR8;
      }
#line 511
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 512
    if ((unsigned int )formula_elements___3[marker].formula_type == 22U) {
      {
#line 514
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Next item: a variable reference");
#line 515
      formula->data.dat_variable = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len,
                                                    & res);
      }
#line 516
      if (res) {
#line 517
        goto ERROR8;
      }
      {
#line 518
      formula->type = formula_elements___3[marker].formula_type;
#line 519
      len += 4;
#line 520
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 520
      if (res) {
#line 521
        goto ERROR8;
      }
#line 522
      formula->type = (psiconv_formula_type_t )0;
    } else
#line 523
    if (formula_elements___3[marker].number_of_args == -1) {
      {
#line 524
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Going to parse a vararg function");
#line 525
      tmp___6 = psiconv_list_new(sizeof(*formula));
#line 525
      formula->data.fun_operands = tmp___6;
      }
#line 525
      if (! tmp___6) {
#line 527
        goto ERROR8;
      }
#line 528
      formula->type = formula_elements___3[marker].formula_type;
#line 529
      nr_of_subs = (psiconv_u16 )0;
      {
#line 530
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 531
        nr_of_subs = (psiconv_u16 )((int )nr_of_subs + 1);
#line 532
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read vararg argument %d", (int )nr_of_subs);
#line 534
        res = psiconv_parse_formula_element_list___3(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                     & leng, & subformula, maxlen);
        }
#line 534
        if (res) {
#line 536
          goto ERROR8;
        }
        {
#line 537
        len += leng;
#line 538
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula);
        }
#line 538
        if (res) {
          {
#line 539
          psiconv_free_formula(subformula);
          }
#line 540
          goto ERROR8;
        }
        {
#line 542
        free((void *)subformula);
#line 543
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read the next marker");
#line 544
        submarker = psiconv_read_u8(config, buf, lev + 4, off + (psiconv_u32 )len,
                                    & res);
#line 545
        len ++;
        }
#line 546
        if (res) {
#line 547
          goto ERROR8;
        }
        {
#line 548
        submarker2 = psiconv_read_u8(config, buf, lev + 4, off + (psiconv_u32 )len,
                                     & res);
        }
#line 549
        if (res) {
#line 550
          goto ERROR8;
        }
#line 530
        if ((unsigned int )formula_elements___3[submarker].formula_type == 27U) {
#line 530
          if (! ((unsigned int )formula_elements___3[submarker2].formula_type != 28U)) {
#line 530
            goto while_break___0;
          }
        } else {
#line 530
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 555
      if ((unsigned int )formula_elements___3[submarker].formula_type == 27U) {
#line 555
        if ((unsigned int )formula_elements___3[submarker2].formula_type == 28U) {
#line 559
          submarker = submarker2;
#line 560
          len ++;
        }
      }
#line 562
      if ((unsigned int )formula_elements___3[submarker].formula_type != 28U) {
        {
#line 564
        psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Formula corrupted!");
#line 565
        psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Found unexpected marker %02x",
                      (int )submarker);
        }
#line 566
        goto ERROR8;
      }
      {
#line 568
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Going to read the repeated marker %02x", (int )marker);
#line 570
      submarker = psiconv_read_u8(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
      }
#line 571
      if (res) {
#line 572
        goto ERROR8;
      }
#line 573
      if ((int )submarker != (int )marker) {
        {
#line 574
        psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Formula corrupted!");
#line 575
        psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Expected marker %02x, found %02x",
                      (int )marker, (int )submarker);
        }
#line 577
        goto ERROR8;
      }
      {
#line 579
      len ++;
#line 580
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Going to read the number of arguments (%d expected)", (int )nr_of_subs);
#line 583
      temp = psiconv_read_u16(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
      }
#line 584
      if (res) {
#line 585
        goto ERROR8;
      }
#line 586
      if ((int )temp != (int )nr_of_subs) {
        {
#line 587
        psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Formula corrupted!");
#line 588
        psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Read %d arguments, but formula says there are %d",
                      (int )nr_of_subs, (int )temp);
        }
#line 591
        goto ERROR8;
      }
      {
#line 593
      len += 2;
#line 594
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 594
      if (res) {
#line 595
        goto ERROR8;
      }
#line 596
      formula->type = (psiconv_formula_type_t )0;
    } else {
#line 598
      if (formula_elements___3[marker].number_of_args > 0) {
        {
#line 599
        res = psiconv_list_pop(formula_stack, (void *)subformula1);
        }
#line 599
        if (res) {
#line 600
          goto ERROR8;
        }
      }
#line 601
      if (formula_elements___3[marker].number_of_args > 1) {
        {
#line 602
        res = psiconv_list_pop(formula_stack, (void *)subformula2);
        }
#line 602
        if (res) {
#line 603
          goto ERROR8;
        }
      }
#line 604
      if (formula_elements___3[marker].number_of_args > 2) {
        {
#line 605
        res = psiconv_list_pop(formula_stack, (void *)subformula3);
        }
#line 605
        if (res) {
#line 606
          goto ERROR8;
        }
      }
#line 607
      if (formula_elements___3[marker].number_of_args > 3) {
        {
#line 608
        res = psiconv_list_pop(formula_stack, (void *)subformula4);
        }
#line 608
        if (res) {
#line 609
          goto ERROR8;
        }
      }
      {
#line 610
      tmp___7 = psiconv_list_new(sizeof(*formula));
#line 610
      formula->data.fun_operands = tmp___7;
      }
#line 610
      if (! tmp___7) {
#line 612
        goto ERROR8;
      }
#line 613
      formula->type = formula_elements___3[marker].formula_type;
#line 614
      if (formula_elements___3[marker].number_of_args > 3) {
        {
#line 615
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula4);
        }
#line 615
        if (res) {
#line 616
          goto ERROR8;
        }
      }
#line 617
      if (formula_elements___3[marker].number_of_args > 2) {
        {
#line 618
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula3);
        }
#line 618
        if (res) {
#line 619
          goto ERROR8;
        }
      }
#line 620
      if (formula_elements___3[marker].number_of_args > 1) {
        {
#line 621
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula2);
        }
#line 621
        if (res) {
#line 622
          goto ERROR8;
        }
      }
#line 623
      if (formula_elements___3[marker].number_of_args > 0) {
        {
#line 624
        res = psiconv_list_add(formula->data.fun_operands, (void const   *)subformula1);
        }
#line 624
        if (res) {
#line 625
          goto ERROR8;
        }
      }
      {
#line 626
      res = psiconv_list_add(formula_stack, (void const   *)formula);
      }
#line 626
      if (res) {
#line 627
        goto ERROR8;
      }
#line 628
      tmp___11 = (psiconv_formula_type_t )0;
#line 628
      formula->type = tmp___11;
#line 628
      tmp___10 = tmp___11;
#line 628
      subformula1->type = tmp___10;
#line 628
      tmp___9 = tmp___10;
#line 628
      subformula2->type = tmp___9;
#line 628
      tmp___8 = tmp___9;
#line 628
      subformula3->type = tmp___8;
#line 628
      subformula4->type = tmp___8;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  if ((psiconv_u32 )len + off > maxlen) {
    {
#line 633
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Formula corrupted!");
#line 634
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Expected end: %04x, found end: %04x",
                  maxlen, (psiconv_u32 )len + off);
    }
#line 636
    goto ERROR8;
  } else
#line 632
  if (! eof) {
    {
#line 633
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Formula corrupted!");
#line 634
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Expected end: %04x, found end: %04x",
                  maxlen, (psiconv_u32 )len + off);
    }
#line 636
    goto ERROR8;
  }
  {
#line 638
  tmp___13 = psiconv_list_length((psiconv_list const   )formula_stack);
  }
#line 638
  if (tmp___13 != 1U) {
    {
#line 639
    psiconv_error((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Formula corrupted!");
#line 640
    tmp___12 = psiconv_list_length((psiconv_list const   )formula_stack);
#line 640
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "More than one item left on the stack (%d)",
                  tmp___12);
    }
#line 642
    goto ERROR8;
  }
  {
#line 644
  res = psiconv_list_pop(formula_stack, (void *)*result);
  }
#line 644
  if (res) {
#line 645
    goto ERROR8;
  }
  {
#line 646
  psiconv_list_free(formula_stack);
#line 647
  free((void *)formula);
  }
#line 649
  if (length) {
#line 650
    *length = len;
  }
  {
#line 652
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of formula element list (total length: %08x)",
                   len);
  }
#line 654
  return (0);
  ERROR8: 
  {
#line 657
  psiconv_free_formula(subformula4);
  }
  ERROR7: 
  {
#line 659
  psiconv_free_formula(subformula3);
  }
  ERROR6: 
  {
#line 661
  psiconv_free_formula(subformula2);
  }
  ERROR5: 
  {
#line 663
  psiconv_free_formula(subformula1);
  }
  ERROR4: 
  {
#line 665
  psiconv_free_formula(formula);
  }
  ERROR3: 
  {
#line 667
  psiconv_free_formula_list(formula_stack);
  }
  ERROR2: 
  {
#line 669
  free((void *)*result);
  }
  ERROR1: 
  {
#line 671
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of formula element list failed");
  }
#line 672
  if (length) {
#line 673
    *length = 0;
  }
#line 674
  if (! res) {
#line 675
    return (-2);
  } else {
#line 677
    return (res);
  }
}
}
#line 34 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
static psiconv_float_t pow2___3(int n ) ;
#line 35
static psiconv_string_t psiconv_read_string_aux___3(psiconv_config const   config ,
                                                    psiconv_buffer const   buf , int lev ,
                                                    psiconv_u32 off , int *length ,
                                                    int *status , int kind ) ;
#line 42 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
static psiconv_float_t pow2___3(int n ) 
{ 
  psiconv_float_t res ;
  int i ;
  int tmp ;
  psiconv_float_t tmp___0 ;

  {
#line 44
  res = 1.0;
#line 47
  i = 0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (n < 0) {
#line 47
      tmp = - n;
    } else {
#line 47
      tmp = n;
    }
#line 47
    if (! (i < tmp)) {
#line 47
      goto while_break;
    }
#line 48
    res *= 2.0;
#line 47
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  if (n < 0) {
#line 50
    tmp___0 = (psiconv_float_t )1 / res;
  } else {
#line 50
    tmp___0 = res;
  }
#line 50
  return (tmp___0);
}
}
#line 325 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_simple.c"
static psiconv_string_t psiconv_read_string_aux___3(psiconv_config const   config ,
                                                    psiconv_buffer const   buf , int lev ,
                                                    psiconv_u32 off , int *length ,
                                                    int *status , int kind ) 
{ 
  int bytecount ;
  int i ;
  int leng ;
  int len ;
  int localstatus ;
  psiconv_string_t result ;
  char *res_copy ;
  psiconv_list string ;
  psiconv_ucs2 nextchar ;
  psiconv_ucs2 *nextcharptr ;
  psiconv_u32 tmp ;
  psiconv_u8 tmp___0 ;
  psiconv_u32 tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  psiconv_u32 tmp___4 ;

  {
  {
#line 337
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read a string");
  }
#line 339
  if (kind == -1) {
    {
#line 340
    tmp = psiconv_read_S(config, buf, lev + 2, off, & leng, & localstatus);
#line 340
    bytecount = (int )tmp;
    }
  } else
#line 341
  if (kind == -2) {
    {
#line 342
    tmp___0 = psiconv_read_u8(config, buf, lev + 2, off, & localstatus);
#line 342
    bytecount = (int )tmp___0;
#line 343
    leng = 1;
    }
  } else {
#line 345
    bytecount = kind;
#line 346
    leng = 0;
#line 347
    localstatus = 0;
  }
#line 349
  if (localstatus) {
#line 350
    goto ERROR1;
  }
  {
#line 351
  psiconv_debug((psiconv_config )config, lev + 2, off, "Length: %i", bytecount);
#line 352
  len = leng;
#line 354
  string = psiconv_list_new(sizeof(*result));
  }
#line 354
  if (! string) {
#line 355
    goto ERROR1;
  }
#line 358
  i = 0;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! (i < bytecount)) {
#line 359
      goto while_break;
    }
    {
#line 360
    nextchar = psiconv_unicode_read_char(config, (psiconv_buffer )buf, lev, (off + (psiconv_u32 )i) + (psiconv_u32 )len,
                                         & leng, & localstatus);
    }
#line 362
    if (localstatus) {
#line 363
      goto ERROR2;
    }
    {
#line 364
    localstatus = psiconv_list_add(string, (void const   *)(& nextchar));
    }
#line 364
    if (localstatus) {
#line 365
      goto ERROR2;
    }
#line 366
    i += leng;
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  if (i > bytecount) {
    {
#line 369
    psiconv_error((psiconv_config )config, lev, (off + (psiconv_u32 )i) + (psiconv_u32 )len,
                  "Malformed string");
#line 370
    localstatus = 3;
    }
#line 371
    goto ERROR2;
  }
  {
#line 373
  len += bytecount;
#line 376
  tmp___1 = psiconv_list_length((psiconv_list const   )string);
#line 376
  tmp___2 = malloc(sizeof(*result) * (unsigned long )(tmp___1 + 1U));
#line 376
  result = (psiconv_string_t )tmp___2;
  }
#line 376
  if (! result) {
#line 377
    goto ERROR2;
  }
#line 378
  i = 0;
  {
#line 378
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 378
    tmp___4 = psiconv_list_length((psiconv_list const   )string);
    }
#line 378
    if (! ((psiconv_u32 )i < tmp___4)) {
#line 378
      goto while_break___0;
    }
    {
#line 379
    tmp___3 = psiconv_list_get((psiconv_list const   )string, (psiconv_u32 )i);
#line 379
    nextcharptr = (psiconv_ucs2 *)tmp___3;
    }
#line 379
    if (! nextcharptr) {
      {
#line 380
      psiconv_error((psiconv_config )config, lev, (off + (psiconv_u32 )i) + (psiconv_u32 )len,
                    "Data structure corruption");
      }
#line 381
      goto ERROR3;
    }
#line 383
    *(result + i) = *nextcharptr;
#line 378
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 385
  *(result + i) = (psiconv_ucs2 )0;
#line 387
  res_copy = psiconv_make_printable(config, (psiconv_string_t const   )result);
  }
#line 388
  if (! res_copy) {
#line 389
    goto ERROR3;
  }
  {
#line 390
  psiconv_debug((psiconv_config )config, lev + 2, off, "Contents: `%s\'", res_copy);
#line 391
  free((void *)res_copy);
#line 393
  psiconv_list_free(string);
  }
#line 395
  if (length) {
#line 396
    *length = len;
  }
#line 398
  if (status) {
#line 399
    *status = 0;
  }
  {
#line 401
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of string (total length: %08x)", len);
  }
#line 403
  return (result);
  ERROR3: 
  {
#line 406
  free((void *)result);
  }
  ERROR2: 
  {
#line 408
  psiconv_list_free(string);
  }
  ERROR1: 
  {
#line 410
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of string failed");
  }
#line 411
  if (status) {
#line 412
    *status = localstatus;
  }
#line 413
  if (length) {
#line 414
    *length = 0;
  }
#line 415
  return ((psiconv_string_t )((void *)0));
}
}
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_collect_pixel_data___3(psiconv_pixel_ints *pixels , int xsize ,
                                          int ysize , psiconv_pixel_floats_t const   data ,
                                          int colordepth , int color___1 , int redbits ,
                                          int bluebits , int greenbits , psiconv_pixel_floats_t const   palet ) ;
#line 39
static int psiconv_pixel_data_to_bytes___3(psiconv_config const   config , int lev ,
                                           psiconv_pixel_bytes *bytes , int xsize ,
                                           int ysize , psiconv_pixel_ints const   pixels ,
                                           int colordepth ) ;
#line 43
static int psiconv_encode_rle8___3(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                   psiconv_pixel_bytes *encoded_bytes ) ;
#line 46
static int psiconv_encode_rle12___3(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                    psiconv_pixel_bytes *encoded_bytes ) ;
#line 49
static int psiconv_encode_rle16___3(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                    psiconv_pixel_bytes *encoded_bytes ) ;
#line 52
static int psiconv_encode_rle24___3(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                    psiconv_pixel_bytes *encoded_bytes ) ;
#line 240 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_collect_pixel_data___3(psiconv_pixel_ints *pixels , int xsize ,
                                          int ysize , psiconv_pixel_floats_t const   data ,
                                          int colordepth , int color___1 , int redbits ,
                                          int bluebits , int greenbits , psiconv_pixel_floats_t const   palet ) 
{ 
  int res ;
  int x ;
  int y ;
  int i ;
  psiconv_u32 index___0 ;
  psiconv_u32 pixel ;
  float p_red ;
  float p_green ;
  float p_blue ;
  float dist ;
  float new_dist ;
  psiconv_pixel_ints tmp ;

  {
  {
#line 250
  tmp = psiconv_list_new(sizeof(psiconv_u32 ));
#line 250
  *pixels = tmp;
  }
#line 250
  if (! tmp) {
#line 251
    res = -2;
#line 252
    goto ERROR1;
  }
#line 255
  y = 0;
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! (y < ysize)) {
#line 255
      goto while_break;
    }
#line 256
    x = 0;
    {
#line 256
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 256
      if (! (x < xsize)) {
#line 256
        goto while_break___0;
      }
#line 257
      index___0 = (psiconv_u32 )(y * xsize + x);
#line 258
      p_red = *(data.red + index___0);
#line 259
      p_green = *(data.green + index___0);
#line 260
      p_blue = *(data.blue + index___0);
#line 261
      if (! palet.length) {
#line 262
        if (color___1) {
#line 263
          pixel = (((psiconv_u32 )((double )(p_red * (float )(1 << redbits)) + 0.5) << (greenbits + bluebits)) + ((psiconv_u32 )((double )(p_green * (float )(1 << greenbits)) + 0.5) << bluebits)) + (psiconv_u32 )((double )(p_blue * (float )(1 << bluebits)) + 0.5);
        } else {
#line 269
          pixel = (psiconv_u32 )(((0.212671 * (double )p_red + 0.715160 * (double )p_green) + 0.072169 * (double )p_blue) * ((double )(1 << colordepth) * 0.999));
        }
      } else {
#line 271
        dist = (float )4;
#line 272
        pixel = (psiconv_u32 )-1;
#line 273
        i = 0;
        {
#line 273
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 273
          if (! ((psiconv_u32 const   )i < palet.length)) {
#line 273
            goto while_break___1;
          }
#line 274
          new_dist = ((p_red - *(palet.red + i)) * (p_red - *(palet.red + i)) + (p_green - *(palet.green + i)) * (p_green - *(palet.green + i))) + (p_blue - *(palet.blue + i)) * (p_blue - *(palet.blue + i));
#line 277
          if (new_dist < dist) {
#line 278
            pixel = (psiconv_u32 )i;
#line 279
            dist = new_dist;
          }
#line 273
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 283
      res = psiconv_list_add(*pixels, (void const   *)(& pixel));
      }
#line 283
      if (res) {
#line 284
        goto ERROR2;
      }
#line 256
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 255
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  return (0);
  ERROR2: 
  {
#line 290
  psiconv_list_free(*pixels);
  }
  ERROR1: 
#line 292
  return (res);
}
}
#line 295 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_pixel_data_to_bytes___3(psiconv_config const   config , int lev ,
                                           psiconv_pixel_bytes *bytes , int xsize ,
                                           int ysize , psiconv_pixel_ints const   pixels ,
                                           int colordepth ) 
{ 
  int res ;
  int x ;
  int y ;
  psiconv_u32 inputdata ;
  psiconv_u8 outputbyte ;
  psiconv_u32 *pixelptr ;
  int inputbitsleft ;
  int outputbitnr ;
  int bitsfit ;
  int outputbytenr ;
  psiconv_u32 tmp ;
  psiconv_pixel_bytes tmp___0 ;
  void *tmp___1 ;

  {
#line 309
  if (! bytes) {
    {
#line 310
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "NULL pixel data");
#line 311
    res = -4;
    }
#line 312
    goto ERROR1;
  }
#line 314
  if (! pixels) {
    {
#line 315
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "NULL pixel data");
#line 316
    res = -4;
    }
#line 317
    goto ERROR1;
  }
  {
#line 319
  tmp = psiconv_list_length(pixels);
  }
#line 319
  if (tmp != (psiconv_u32 )(xsize * ysize)) {
    {
#line 320
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Pixel number is not correct");
#line 321
    res = -4;
    }
#line 322
    goto ERROR1;
  }
  {
#line 325
  tmp___0 = psiconv_list_new(sizeof(psiconv_u8 ));
#line 325
  *bytes = tmp___0;
  }
#line 325
  if (! tmp___0) {
#line 326
    res = -2;
#line 327
    goto ERROR1;
  }
#line 331
  outputbitnr = 0;
#line 332
  outputbyte = (psiconv_u8 )0;
#line 333
  y = 0;
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 333
    if (! (y < ysize)) {
#line 333
      goto while_break;
    }
#line 334
    outputbytenr = 0;
#line 335
    x = 0;
    {
#line 335
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 335
      if (! (x < xsize)) {
#line 335
        goto while_break___0;
      }
      {
#line 336
      tmp___1 = psiconv_list_get(pixels, (psiconv_u32 )(y * xsize + x));
#line 336
      pixelptr = (psiconv_u32 *)tmp___1;
      }
#line 336
      if (! pixelptr) {
        {
#line 337
        psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Data structure corruption");
#line 338
        res = -2;
        }
#line 339
        goto ERROR2;
      }
#line 341
      inputbitsleft = colordepth;
#line 342
      inputdata = *pixelptr;
      {
#line 343
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 343
        if (! inputbitsleft) {
#line 343
          goto while_break___1;
        }
#line 344
        if (inputbitsleft + outputbitnr <= 8) {
#line 344
          bitsfit = inputbitsleft;
        } else {
#line 344
          bitsfit = 8 - outputbitnr;
        }
#line 345
        outputbyte = (psiconv_u8 )((unsigned int )outputbyte | ((inputdata & (unsigned int )((1 << bitsfit) - 1)) << outputbitnr));
#line 346
        inputdata >>= bitsfit;
#line 347
        inputbitsleft -= bitsfit;
#line 348
        outputbitnr += bitsfit;
#line 349
        if (outputbitnr == 8) {
          {
#line 350
          res = psiconv_list_add(*bytes, (void const   *)(& outputbyte));
          }
#line 350
          if (res) {
#line 351
            goto ERROR2;
          }
#line 352
          outputbitnr = 0;
#line 353
          outputbyte = (psiconv_u8 )0;
#line 354
          outputbytenr ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 335
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 359
    if (outputbitnr != 0) {
      {
#line 360
      res = psiconv_list_add(*bytes, (void const   *)(& outputbyte));
      }
#line 360
      if (res) {
#line 361
        goto ERROR2;
      }
#line 362
      outputbitnr = 0;
#line 363
      outputbyte = (psiconv_u8 )0;
#line 364
      outputbytenr ++;
    }
    {
#line 367
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 367
      if (! (outputbytenr % 4)) {
#line 367
        goto while_break___2;
      }
      {
#line 368
      res = psiconv_list_add(*bytes, (void const   *)(& outputbyte));
      }
#line 368
      if (res) {
#line 369
        goto ERROR2;
      }
#line 370
      outputbytenr ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 333
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return (0);
  ERROR2: 
  {
#line 377
  psiconv_list_free(*bytes);
  }
  ERROR1: 
#line 379
  return (res);
}
}
#line 386 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_encode_rle8___3(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                   psiconv_pixel_bytes *encoded_bytes ) 
{ 
  int res ;
  int i ;
  int j ;
  int len ;
  psiconv_u8 *entry ;
  psiconv_u8 *next ;
  psiconv_u8 temp ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  psiconv_u32 tmp___3 ;
  void *tmp___4 ;
  psiconv_u32 tmp___5 ;
  void *tmp___6 ;
  psiconv_u32 tmp___7 ;
  psiconv_u32 tmp___8 ;

  {
  {
#line 394
  tmp = psiconv_list_new(sizeof(*entry));
#line 394
  *encoded_bytes = tmp;
  }
#line 394
  if (! tmp) {
#line 395
    res = -2;
#line 396
    goto ERROR1;
  }
#line 399
  i = 0;
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 399
    tmp___8 = psiconv_list_length(plain_bytes);
    }
#line 399
    if (! ((psiconv_u32 )i < tmp___8)) {
#line 399
      goto while_break;
    }
    {
#line 400
    tmp___0 = psiconv_list_get(plain_bytes, (psiconv_u32 )i);
#line 400
    entry = (psiconv_u8 *)tmp___0;
    }
#line 400
    if (! entry) {
#line 401
      res = -2;
#line 402
      goto ERROR2;
    }
    {
#line 404
    tmp___1 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 1));
#line 404
    next = (psiconv_u8 *)tmp___1;
    }
#line 404
    if (! next) {
#line 405
      res = -2;
#line 406
      goto ERROR2;
    }
    {
#line 408
    tmp___7 = psiconv_list_length(plain_bytes);
    }
#line 408
    if ((psiconv_u32 )i == tmp___7 - 2U) {
      {
#line 409
      temp = (psiconv_u8 )254;
#line 410
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 410
      if (res) {
#line 411
        goto ERROR2;
      }
      {
#line 412
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry);
      }
#line 412
      if (res) {
#line 413
        goto ERROR2;
      }
      {
#line 414
      res = psiconv_list_add(*encoded_bytes, (void const   *)next);
      }
#line 414
      if (res) {
#line 415
        goto ERROR2;
      }
#line 416
      i += 2;
    } else
#line 417
    if ((int )*next == (int )*entry) {
#line 418
      len = 1;
      {
#line 419
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 419
        if ((int )*next == (int )*entry) {
          {
#line 419
          tmp___3 = psiconv_list_length(plain_bytes);
          }
#line 419
          if ((psiconv_u32 )((i + len) + 2) < tmp___3) {
#line 419
            if (! (len < 128)) {
#line 419
              goto while_break___0;
            }
          } else {
#line 419
            goto while_break___0;
          }
        } else {
#line 419
          goto while_break___0;
        }
        {
#line 422
        len ++;
#line 423
        tmp___2 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len));
#line 423
        next = (psiconv_u8 *)tmp___2;
        }
#line 423
        if (! next) {
#line 424
          res = -2;
#line 425
          goto ERROR2;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 428
      temp = (psiconv_u8 )(len - 1);
#line 429
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 429
      if (res) {
#line 430
        goto ERROR2;
      }
      {
#line 431
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry);
      }
#line 431
      if (res) {
#line 432
        goto ERROR2;
      }
#line 433
      i += len;
    } else {
#line 435
      len = 1;
      {
#line 436
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 436
        if ((int )*next != (int )*entry) {
          {
#line 436
          tmp___5 = psiconv_list_length(plain_bytes);
          }
#line 436
          if ((psiconv_u32 )((i + len) + 1) < tmp___5) {
#line 436
            if (! (len < 128)) {
#line 436
              goto while_break___1;
            }
          } else {
#line 436
            goto while_break___1;
          }
        } else {
#line 436
          goto while_break___1;
        }
        {
#line 439
        len ++;
#line 440
        entry = next;
#line 441
        tmp___4 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len));
#line 441
        next = (psiconv_u8 *)tmp___4;
        }
#line 441
        if (! next) {
#line 442
          res = -2;
#line 443
          goto ERROR2;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 446
      len --;
#line 447
      temp = (psiconv_u8 )(256 - len);
#line 448
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 448
      if (res) {
#line 449
        goto ERROR2;
      }
#line 450
      j = 0;
      {
#line 450
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 450
        if (! (j < len)) {
#line 450
          goto while_break___2;
        }
        {
#line 451
        tmp___6 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + j));
#line 451
        next = (psiconv_u8 *)tmp___6;
        }
#line 451
        if (! next) {
#line 452
          res = -2;
#line 453
          goto ERROR2;
        }
        {
#line 455
        res = psiconv_list_add(*encoded_bytes, (void const   *)next);
        }
#line 455
        if (res) {
#line 456
          goto ERROR2;
        }
#line 450
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 458
      i += len;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 461
  return (0);
  ERROR2: 
  {
#line 464
  psiconv_list_free(*encoded_bytes);
  }
  ERROR1: 
#line 466
  return (res);
}
}
#line 472 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_encode_rle12___3(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                    psiconv_pixel_bytes *encoded_bytes ) 
{ 
  psiconv_word_data data ;
  int res ;
  int i ;
  int len ;
  int location ;
  psiconv_u16 *word_entry ;
  psiconv_u16 *word_next ;
  psiconv_u16 word_data ;
  psiconv_u8 byte_temp ;
  psiconv_u8 *byte_entry ;
  void *tmp ;
  psiconv_u32 tmp___0 ;
  psiconv_pixel_bytes tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  psiconv_u32 tmp___6 ;
  void *tmp___7 ;
  psiconv_u32 tmp___8 ;
  int tmp___9 ;
  psiconv_u32 tmp___10 ;

  {
  {
#line 486
  data = psiconv_list_new(sizeof(psiconv_u16 ));
  }
#line 486
  if (! data) {
#line 487
    res = -2;
#line 488
    goto ERROR1;
  }
#line 491
  i = 0;
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 491
    tmp___0 = psiconv_list_length(plain_bytes);
    }
#line 491
    if (! ((psiconv_u32 )i < tmp___0)) {
#line 491
      goto while_break;
    }
    {
#line 492
    tmp = psiconv_list_get(plain_bytes, (psiconv_u32 )i);
#line 492
    byte_entry = (psiconv_u8 *)tmp;
    }
#line 492
    if (! byte_entry) {
#line 493
      res = -2;
#line 494
      goto ERROR2;
    }
#line 496
    location = 0;
#line 497
    if (location == 0) {
#line 498
      word_data = (psiconv_u16 )*byte_entry;
#line 499
      location ++;
    } else
#line 500
    if (location == 1) {
      {
#line 501
      word_data = (psiconv_u16 )(((int )word_data << 4) + ((int )*byte_entry & 15));
#line 502
      res = psiconv_list_add(data, (void const   *)(& word_data));
      }
#line 502
      if (res) {
#line 503
        goto ERROR2;
      }
#line 504
      word_data = (psiconv_u16 )((int )*byte_entry >> 4);
#line 505
      location ++;
    } else {
      {
#line 507
      word_data = (psiconv_u16 )(((int )word_data << 8) + (int )*byte_entry);
#line 508
      res = psiconv_list_add(data, (void const   *)(& word_data));
      }
#line 508
      if (res) {
#line 509
        goto ERROR2;
      }
#line 510
      location = 0;
    }
#line 491
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 514
  tmp___1 = psiconv_list_new(sizeof(psiconv_u8 ));
#line 514
  *encoded_bytes = tmp___1;
  }
#line 514
  if (! tmp___1) {
#line 515
    res = -2;
#line 516
    goto ERROR2;
  }
#line 519
  i = 0;
  {
#line 519
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 519
    tmp___10 = psiconv_list_length((psiconv_list const   )data);
    }
#line 519
    if (! ((psiconv_u32 )i < tmp___10)) {
#line 519
      goto while_break___0;
    }
    {
#line 520
    tmp___2 = psiconv_list_get((psiconv_list const   )data, (psiconv_u32 )i);
#line 520
    word_entry = (psiconv_u16 *)tmp___2;
    }
#line 520
    if (! word_entry) {
#line 521
      res = -2;
#line 522
      goto ERROR3;
    }
    {
#line 525
    tmp___3 = psiconv_list_get((psiconv_list const   )data, (psiconv_u32 )(i + 1));
#line 525
    word_next = (psiconv_u16 *)tmp___3;
    }
#line 525
    if (! word_next) {
#line 526
      res = -2;
#line 527
      goto ERROR3;
    }
    {
#line 530
    tmp___6 = psiconv_list_length((psiconv_list const   )data);
    }
#line 530
    if ((psiconv_u32 )i == tmp___6 - 2U) {
#line 531
      if (*word_entry) {
#line 531
        tmp___4 = 1;
      } else {
#line 531
        tmp___4 = 0;
      }
      {
#line 531
      byte_temp = (psiconv_u8 )tmp___4;
#line 532
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
      }
#line 532
      if (res) {
#line 533
        goto ERROR3;
      }
      {
#line 534
      byte_temp = (psiconv_u8 )((int )*word_entry >> 8);
#line 535
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
      }
#line 535
      if (res) {
#line 536
        goto ERROR3;
      }
#line 537
      if (*word_next) {
#line 537
        tmp___5 = 1;
      } else {
#line 537
        tmp___5 = 0;
      }
      {
#line 537
      byte_temp = (psiconv_u8 )tmp___5;
#line 538
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
      }
#line 538
      if (res) {
#line 539
        goto ERROR3;
      }
      {
#line 540
      byte_temp = (psiconv_u8 )((int )*word_next >> 8);
#line 541
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
      }
#line 541
      if (res) {
#line 542
        goto ERROR3;
      }
#line 543
      i += 2;
    }
#line 546
    len = 0;
    {
#line 547
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 547
      if ((int )*word_entry == (int )*word_next) {
#line 547
        if (len < 16) {
          {
#line 547
          tmp___8 = psiconv_list_length((psiconv_list const   )data);
          }
#line 547
          if (! ((psiconv_u32 )((i + len) + 1) < tmp___8)) {
#line 547
            goto while_break___1;
          }
        } else {
#line 547
          goto while_break___1;
        }
      } else {
#line 547
        goto while_break___1;
      }
      {
#line 549
      len ++;
#line 550
      tmp___7 = psiconv_list_get((psiconv_list const   )data, (psiconv_u32 )(i + len));
#line 550
      word_next = (psiconv_u16 *)tmp___7;
      }
#line 550
      if (! word_next) {
#line 551
        res = -2;
#line 552
        goto ERROR3;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 556
    if (*word_entry) {
#line 556
      tmp___9 = 1;
    } else {
#line 556
      tmp___9 = 0;
    }
    {
#line 556
    byte_temp = (psiconv_u8 )tmp___9;
#line 557
    res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
    }
#line 557
    if (res) {
#line 558
      goto ERROR3;
    }
    {
#line 559
    byte_temp = (psiconv_u8 )(((int )*word_entry >> 8) + ((len - 1) << 4));
#line 560
    res = psiconv_list_add(*encoded_bytes, (void const   *)(& byte_temp));
    }
#line 560
    if (res) {
#line 561
      goto ERROR3;
    }
#line 562
    i += len;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 564
  return (0);
  ERROR3: 
  {
#line 567
  psiconv_list_free(*encoded_bytes);
  }
  ERROR2: 
  {
#line 569
  psiconv_list_free(data);
  }
  ERROR1: 
#line 571
  return (res);
}
}
#line 578 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_encode_rle16___3(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                    psiconv_pixel_bytes *encoded_bytes ) 
{ 
  int res ;
  int i ;
  int j ;
  int len ;
  psiconv_u8 *entry1 ;
  psiconv_u8 *entry2 ;
  psiconv_u8 *next1 ;
  psiconv_u8 *next2 ;
  psiconv_u8 temp ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  psiconv_u32 tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  psiconv_u32 tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  psiconv_u32 tmp___12 ;
  psiconv_u32 tmp___13 ;

  {
  {
#line 586
  tmp = psiconv_list_new(sizeof(*entry1));
#line 586
  *encoded_bytes = tmp;
  }
#line 586
  if (! tmp) {
#line 587
    res = -2;
#line 588
    goto ERROR1;
  }
#line 591
  i = 0;
  {
#line 591
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 591
    tmp___13 = psiconv_list_length(plain_bytes);
    }
#line 591
    if (! ((psiconv_u32 )i < tmp___13)) {
#line 591
      goto while_break;
    }
    {
#line 592
    tmp___0 = psiconv_list_get(plain_bytes, (psiconv_u32 )i);
#line 592
    entry1 = (psiconv_u8 *)tmp___0;
    }
#line 592
    if (! entry1) {
#line 593
      res = -2;
#line 594
      goto ERROR2;
    }
    {
#line 596
    tmp___1 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 1));
#line 596
    entry2 = (psiconv_u8 *)tmp___1;
    }
#line 596
    if (! entry2) {
#line 597
      res = -2;
#line 598
      goto ERROR2;
    }
    {
#line 600
    tmp___2 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 2));
#line 600
    next1 = (psiconv_u8 *)tmp___2;
    }
#line 600
    if (! next1) {
#line 601
      res = -2;
#line 602
      goto ERROR2;
    }
    {
#line 604
    tmp___3 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 3));
#line 604
    next2 = (psiconv_u8 *)tmp___3;
    }
#line 604
    if (! next2) {
#line 605
      res = -2;
#line 606
      goto ERROR2;
    }
    {
#line 608
    tmp___12 = psiconv_list_length(plain_bytes);
    }
#line 608
    if ((psiconv_u32 )i == tmp___12 - 4U) {
      {
#line 609
      temp = (psiconv_u8 )254;
#line 610
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 610
      if (res) {
#line 611
        goto ERROR2;
      }
      {
#line 612
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry1);
      }
#line 612
      if (res) {
#line 613
        goto ERROR2;
      }
      {
#line 614
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry2);
      }
#line 614
      if (res) {
#line 615
        goto ERROR2;
      }
      {
#line 616
      res = psiconv_list_add(*encoded_bytes, (void const   *)next1);
      }
#line 616
      if (res) {
#line 617
        goto ERROR2;
      }
      {
#line 618
      res = psiconv_list_add(*encoded_bytes, (void const   *)next2);
      }
#line 618
      if (res) {
#line 619
        goto ERROR2;
      }
#line 620
      i += 4;
    } else
#line 621
    if ((int )*next1 == (int )*entry1) {
#line 621
      if ((int )*next2 == (int )*entry2) {
#line 622
        len = 0;
        {
#line 623
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 623
          if ((int )*next1 == (int )*entry1) {
#line 623
            if ((int )*next2 == (int )*entry2) {
              {
#line 623
              tmp___6 = psiconv_list_length(plain_bytes);
              }
#line 623
              if ((psiconv_u32 )((i + 2 * len) + 4) < tmp___6) {
#line 623
                if (! (len < 128)) {
#line 623
                  goto while_break___0;
                }
              } else {
#line 623
                goto while_break___0;
              }
            } else {
#line 623
              goto while_break___0;
            }
          } else {
#line 623
            goto while_break___0;
          }
          {
#line 626
          len ++;
#line 627
          tmp___4 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len * 2));
#line 627
          next1 = (psiconv_u8 *)tmp___4;
          }
#line 627
          if (! next1) {
#line 628
            res = -2;
#line 629
            goto ERROR2;
          }
          {
#line 631
          tmp___5 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 2) + 1));
#line 631
          next2 = (psiconv_u8 *)tmp___5;
          }
#line 631
          if (! next2) {
#line 632
            res = -2;
#line 633
            goto ERROR2;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 636
        temp = (psiconv_u8 )(len - 1);
#line 637
        res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
        }
#line 637
        if (res) {
#line 638
          goto ERROR2;
        }
        {
#line 639
        res = psiconv_list_add(*encoded_bytes, (void const   *)entry1);
        }
#line 639
        if (res) {
#line 640
          goto ERROR2;
        }
        {
#line 641
        res = psiconv_list_add(*encoded_bytes, (void const   *)entry2);
        }
#line 641
        if (res) {
#line 642
          goto ERROR2;
        }
#line 643
        i += len * 2;
      } else {
#line 621
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 645
      len = 1;
      {
#line 646
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 646
        if ((int )*next1 != (int )*entry1) {
#line 646
          goto _L;
        } else
#line 646
        if ((int )*next2 != (int )*entry2) {
          _L: /* CIL Label */ 
          {
#line 646
          tmp___9 = psiconv_list_length(plain_bytes);
          }
#line 646
          if ((psiconv_u32 )((i + len * 2) + 4) < tmp___9) {
#line 646
            if (! (len < 128)) {
#line 646
              goto while_break___1;
            }
          } else {
#line 646
            goto while_break___1;
          }
        } else {
#line 646
          goto while_break___1;
        }
        {
#line 649
        len ++;
#line 650
        entry1 = next1;
#line 651
        entry2 = next2;
#line 652
        tmp___7 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len * 2));
#line 652
        next1 = (psiconv_u8 *)tmp___7;
        }
#line 652
        if (! next1) {
#line 653
          res = -2;
#line 654
          goto ERROR2;
        }
        {
#line 656
        tmp___8 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 2) + 1));
#line 656
        next2 = (psiconv_u8 *)tmp___8;
        }
#line 656
        if (! next2) {
#line 657
          res = -2;
#line 658
          goto ERROR2;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 661
      len --;
#line 662
      temp = (psiconv_u8 )(256 - len);
#line 663
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 663
      if (res) {
#line 664
        goto ERROR2;
      }
#line 665
      j = 0;
      {
#line 665
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 665
        if (! (j < len)) {
#line 665
          goto while_break___2;
        }
        {
#line 666
        tmp___10 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + j * 2));
#line 666
        next1 = (psiconv_u8 *)tmp___10;
        }
#line 666
        if (! next1) {
#line 667
          res = -2;
#line 668
          goto ERROR2;
        }
        {
#line 670
        tmp___11 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + j * 2) + 1));
#line 670
        next2 = (psiconv_u8 *)tmp___11;
        }
#line 670
        if (! next2) {
#line 671
          res = -2;
#line 672
          goto ERROR2;
        }
        {
#line 674
        res = psiconv_list_add(*encoded_bytes, (void const   *)next1);
        }
#line 674
        if (res) {
#line 675
          goto ERROR2;
        }
        {
#line 676
        res = psiconv_list_add(*encoded_bytes, (void const   *)next2);
        }
#line 676
        if (res) {
#line 677
          goto ERROR2;
        }
#line 665
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 679
      i += len * 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 682
  return (0);
  ERROR2: 
  {
#line 685
  psiconv_list_free(*encoded_bytes);
  }
  ERROR1: 
#line 687
  return (res);
}
}
#line 694 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_image.c"
static int psiconv_encode_rle24___3(psiconv_config const   config , psiconv_pixel_bytes const   plain_bytes ,
                                    psiconv_pixel_bytes *encoded_bytes ) 
{ 
  int res ;
  int i ;
  int j ;
  int len ;
  psiconv_u8 *entry1 ;
  psiconv_u8 *entry2 ;
  psiconv_u8 *entry3 ;
  psiconv_u8 *next1 ;
  psiconv_u8 *next2 ;
  psiconv_u8 *next3 ;
  psiconv_u8 temp ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  psiconv_u32 tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  psiconv_u32 tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  psiconv_u32 tmp___17 ;
  psiconv_u32 tmp___18 ;

  {
  {
#line 702
  tmp = psiconv_list_new(sizeof(*entry1));
#line 702
  *encoded_bytes = tmp;
  }
#line 702
  if (! tmp) {
#line 703
    res = -2;
#line 704
    goto ERROR1;
  }
#line 707
  i = 0;
  {
#line 707
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 707
    tmp___18 = psiconv_list_length(plain_bytes);
    }
#line 707
    if (! ((psiconv_u32 )i < tmp___18)) {
#line 707
      goto while_break;
    }
    {
#line 708
    tmp___0 = psiconv_list_get(plain_bytes, (psiconv_u32 )i);
#line 708
    entry1 = (psiconv_u8 *)tmp___0;
    }
#line 708
    if (! entry1) {
#line 709
      res = -2;
#line 710
      goto ERROR2;
    }
    {
#line 712
    tmp___1 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 1));
#line 712
    entry2 = (psiconv_u8 *)tmp___1;
    }
#line 712
    if (! entry2) {
#line 713
      res = -2;
#line 714
      goto ERROR2;
    }
    {
#line 716
    tmp___2 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 2));
#line 716
    entry3 = (psiconv_u8 *)tmp___2;
    }
#line 716
    if (! entry3) {
#line 717
      res = -2;
#line 718
      goto ERROR2;
    }
    {
#line 720
    tmp___3 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 3));
#line 720
    next1 = (psiconv_u8 *)tmp___3;
    }
#line 720
    if (! next1) {
#line 721
      res = -2;
#line 722
      goto ERROR2;
    }
    {
#line 724
    tmp___4 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 4));
#line 724
    next2 = (psiconv_u8 *)tmp___4;
    }
#line 724
    if (! next2) {
#line 725
      res = -2;
#line 726
      goto ERROR2;
    }
    {
#line 728
    tmp___5 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + 5));
#line 728
    next3 = (psiconv_u8 *)tmp___5;
    }
#line 728
    if (! next3) {
#line 729
      res = -2;
#line 730
      goto ERROR2;
    }
    {
#line 732
    tmp___17 = psiconv_list_length(plain_bytes);
    }
#line 732
    if ((psiconv_u32 )i == tmp___17 - 6U) {
      {
#line 733
      temp = (psiconv_u8 )254;
#line 734
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 734
      if (res) {
#line 735
        goto ERROR2;
      }
      {
#line 736
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry1);
      }
#line 736
      if (res) {
#line 737
        goto ERROR2;
      }
      {
#line 738
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry2);
      }
#line 738
      if (res) {
#line 739
        goto ERROR2;
      }
      {
#line 740
      res = psiconv_list_add(*encoded_bytes, (void const   *)entry3);
      }
#line 740
      if (res) {
#line 741
        goto ERROR2;
      }
      {
#line 742
      res = psiconv_list_add(*encoded_bytes, (void const   *)next1);
      }
#line 742
      if (res) {
#line 743
        goto ERROR2;
      }
      {
#line 744
      res = psiconv_list_add(*encoded_bytes, (void const   *)next2);
      }
#line 744
      if (res) {
#line 745
        goto ERROR2;
      }
      {
#line 746
      res = psiconv_list_add(*encoded_bytes, (void const   *)next3);
      }
#line 746
      if (res) {
#line 747
        goto ERROR2;
      }
#line 748
      i += 4;
    } else
#line 749
    if ((int )*next1 == (int )*entry1) {
#line 749
      if ((int )*next2 == (int )*entry2) {
#line 749
        if ((int )*next3 == (int )*entry3) {
#line 751
          len = 0;
          {
#line 752
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 752
            if ((int )*next1 == (int )*entry1) {
#line 752
              if ((int )*next2 == (int )*entry2) {
#line 752
                if ((int )*next3 == (int )*entry3) {
                  {
#line 752
                  tmp___9 = psiconv_list_length(plain_bytes);
                  }
#line 752
                  if ((psiconv_u32 )((i + 3 * len) + 6) < tmp___9) {
#line 752
                    if (! (len < 128)) {
#line 752
                      goto while_break___0;
                    }
                  } else {
#line 752
                    goto while_break___0;
                  }
                } else {
#line 752
                  goto while_break___0;
                }
              } else {
#line 752
                goto while_break___0;
              }
            } else {
#line 752
              goto while_break___0;
            }
            {
#line 756
            len ++;
#line 757
            tmp___6 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len * 3));
#line 757
            next1 = (psiconv_u8 *)tmp___6;
            }
#line 757
            if (! next1) {
#line 758
              res = -2;
#line 759
              goto ERROR2;
            }
            {
#line 761
            tmp___7 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 3) + 1));
#line 761
            next2 = (psiconv_u8 *)tmp___7;
            }
#line 761
            if (! next2) {
#line 762
              res = -2;
#line 763
              goto ERROR2;
            }
            {
#line 765
            tmp___8 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 3) + 2));
#line 765
            next3 = (psiconv_u8 *)tmp___8;
            }
#line 765
            if (! next3) {
#line 766
              res = -2;
#line 767
              goto ERROR2;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 770
          temp = (psiconv_u8 )(len - 1);
#line 771
          res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
          }
#line 771
          if (res) {
#line 772
            goto ERROR2;
          }
          {
#line 773
          res = psiconv_list_add(*encoded_bytes, (void const   *)entry1);
          }
#line 773
          if (res) {
#line 774
            goto ERROR2;
          }
          {
#line 775
          res = psiconv_list_add(*encoded_bytes, (void const   *)entry2);
          }
#line 775
          if (res) {
#line 776
            goto ERROR2;
          }
          {
#line 777
          res = psiconv_list_add(*encoded_bytes, (void const   *)entry3);
          }
#line 777
          if (res) {
#line 778
            goto ERROR2;
          }
#line 779
          i += len * 3;
        } else {
#line 749
          goto _L___1;
        }
      } else {
#line 749
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 781
      len = 1;
      {
#line 782
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 782
        if ((int )*next1 != (int )*entry1) {
#line 782
          goto _L;
        } else
#line 782
        if ((int )*next2 != (int )*entry2) {
#line 782
          goto _L;
        } else
#line 782
        if ((int )*next3 != (int )*entry3) {
          _L: /* CIL Label */ 
          {
#line 782
          tmp___13 = psiconv_list_length(plain_bytes);
          }
#line 782
          if ((psiconv_u32 )((i + len * 3) + 6) < tmp___13) {
#line 782
            if (! (len < 128)) {
#line 782
              goto while_break___1;
            }
          } else {
#line 782
            goto while_break___1;
          }
        } else {
#line 782
          goto while_break___1;
        }
        {
#line 786
        len ++;
#line 787
        entry1 = next1;
#line 788
        entry2 = next2;
#line 789
        entry3 = next3;
#line 790
        tmp___10 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + len * 3));
#line 790
        next1 = (psiconv_u8 *)tmp___10;
        }
#line 790
        if (! next1) {
#line 791
          res = -2;
#line 792
          goto ERROR2;
        }
        {
#line 794
        tmp___11 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 3) + 1));
#line 794
        next2 = (psiconv_u8 *)tmp___11;
        }
#line 794
        if (! next2) {
#line 795
          res = -2;
#line 796
          goto ERROR2;
        }
        {
#line 798
        tmp___12 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + len * 3) + 2));
#line 798
        next3 = (psiconv_u8 *)tmp___12;
        }
#line 798
        if (! next3) {
#line 799
          res = -2;
#line 800
          goto ERROR2;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 803
      len --;
#line 804
      temp = (psiconv_u8 )(256 - len);
#line 805
      res = psiconv_list_add(*encoded_bytes, (void const   *)(& temp));
      }
#line 805
      if (res) {
#line 806
        goto ERROR2;
      }
#line 807
      j = 0;
      {
#line 807
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 807
        if (! (j < len)) {
#line 807
          goto while_break___2;
        }
        {
#line 808
        tmp___14 = psiconv_list_get(plain_bytes, (psiconv_u32 )(i + j * 3));
#line 808
        next1 = (psiconv_u8 *)tmp___14;
        }
#line 808
        if (! next1) {
#line 809
          res = -2;
#line 810
          goto ERROR2;
        }
        {
#line 812
        tmp___15 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + j * 3) + 1));
#line 812
        next2 = (psiconv_u8 *)tmp___15;
        }
#line 812
        if (! next2) {
#line 813
          res = -2;
#line 814
          goto ERROR2;
        }
        {
#line 816
        tmp___16 = psiconv_list_get(plain_bytes, (psiconv_u32 )((i + j * 3) + 2));
#line 816
        next2 = (psiconv_u8 *)tmp___16;
        }
#line 816
        if (! next2) {
#line 817
          res = -2;
#line 818
          goto ERROR2;
        }
        {
#line 820
        res = psiconv_list_add(*encoded_bytes, (void const   *)next1);
        }
#line 820
        if (res) {
#line 821
          goto ERROR2;
        }
        {
#line 822
        res = psiconv_list_add(*encoded_bytes, (void const   *)next2);
        }
#line 822
        if (res) {
#line 823
          goto ERROR2;
        }
        {
#line 824
        res = psiconv_list_add(*encoded_bytes, (void const   *)next3);
        }
#line 824
        if (res) {
#line 825
          goto ERROR2;
        }
#line 807
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 827
      i += len * 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 830
  return (0);
  ERROR2: 
  {
#line 833
  psiconv_list_free(*encoded_bytes);
  }
  ERROR1: 
#line 835
  return (res);
}
}
#line 43 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
static struct psiconv_config_s default_config___3  = 
#line 43 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
     {3, 2, 0, 0, 0, (psiconv_bool_t )0, (psiconv_error_handler_t *)((void *)0), (psiconv_u8 )'?',
    (psiconv_ucs2 )'?', {(psiconv_ucs2 )0}, (psiconv_bool_t )0};
#line 46
static void psiconv_config_parse_statement___3(char const   *filename , int linenr ,
                                               char const   *var , int value , psiconv_config *config ) ;
#line 51
static void psiconv_config_parse_line___3(char const   *filename , int linenr , char const   *line ,
                                          psiconv_config *config ) ;
#line 54
static void psiconv_config_parse_file___3(char const   *filename , psiconv_config *config ) ;
#line 71 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
static void psiconv_config_parse_statement___3(char const   *filename , int linenr ,
                                               char const   *var , int value , psiconv_config *config ) 
{ 
  int charnr ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 78
  tmp___9 = strcasecmp(var, "verbosity");
  }
#line 78
  if (tmp___9) {
    {
#line 84
    tmp___8 = strcasecmp(var, "color");
    }
#line 84
    if (tmp___8) {
      {
#line 90
      tmp___7 = strcasecmp(var, "colordepth");
      }
#line 90
      if (tmp___7) {
        {
#line 96
        tmp___6 = strcasecmp(var, "redbits");
        }
#line 96
        if (tmp___6) {
          {
#line 102
          tmp___5 = strcasecmp(var, "greenbits");
          }
#line 102
          if (tmp___5) {
            {
#line 108
            tmp___4 = strcasecmp(var, "bluebits");
            }
#line 108
            if (tmp___4) {
              {
#line 114
              tmp___3 = strcasecmp(var, "characterset");
              }
#line 114
              if (tmp___3) {
                {
#line 121
                tmp___2 = strcasecmp(var, "unknownunicodechar");
                }
#line 121
                if (tmp___2) {
                  {
#line 128
                  tmp___1 = strcasecmp(var, "unknownepocchar");
                  }
#line 128
                  if (tmp___1) {
                    {
#line 135
                    tmp = sscanf((char const   */* __restrict  */)var, (char const   */* __restrict  */)"char%d",
                                 & charnr);
#line 135
                    tmp___0 = strlen(var);
                    }
#line 135
                    if ((size_t )tmp == tmp___0) {
#line 136
                      if (charnr < 0) {
                        {
#line 137
                        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharXXX should have XXX between 0 and 255",
                                      filename, linenr);
                        }
                      } else
#line 136
                      if (charnr > 255) {
                        {
#line 137
                        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharXXX should have XXX between 0 and 255",
                                      filename, linenr);
                        }
                      }
#line 140
                      if (value >= 1) {
#line 140
                        if (value <= 65536) {
#line 141
                          (*config)->unicode_table[charnr] = (psiconv_ucs2 )value;
                        } else {
                          {
#line 143
                          psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharXXX should be between 1 and 65535",
                                        filename, linenr);
                          }
                        }
                      } else {
                        {
#line 143
                        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharXXX should be between 1 and 65535",
                                      filename, linenr);
                        }
                      }
                    } else {
                      {
#line 147
                      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Unknown variable %s",
                                    filename, linenr, var);
                      }
                    }
                  } else
#line 129
                  if (value >= 1) {
#line 129
                    if (value < 256) {
#line 130
                      (*config)->unknown_epoc_char = (psiconv_u8 )value;
                    } else {
                      {
#line 132
                      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: UnknownEPOCChar should be between 1 and 255",
                                    filename, linenr);
                      }
                    }
                  } else {
                    {
#line 132
                    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: UnknownEPOCChar should be between 1 and 255",
                                  filename, linenr);
                    }
                  }
                } else
#line 122
                if (value >= 1) {
#line 122
                  if (value < 65536) {
#line 123
                    (*config)->unknown_unicode_char = (psiconv_ucs2 )value;
                  } else {
                    {
#line 125
                    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: UnknownUnicodeChar should be between 1 and 65535",
                                  filename, linenr);
                    }
                  }
                } else {
                  {
#line 125
                  psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: UnknownUnicodeChar should be between 1 and 65535",
                                filename, linenr);
                  }
                }
              } else
#line 115
              if (value >= 0) {
#line 115
                if (value <= 1) {
                  {
#line 116
                  psiconv_unicode_select_characterset((psiconv_config const   )*config,
                                                      value);
                  }
                } else {
                  {
#line 118
                  psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharacterSet should be between 0 and 1",
                                filename, linenr);
                  }
                }
              } else {
                {
#line 118
                psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: CharacterSet should be between 0 and 1",
                              filename, linenr);
                }
              }
            } else
#line 109
            if (value >= 0) {
#line 109
              if (value <= 32) {
#line 110
                (*config)->bluebits = value;
              } else {
                {
#line 112
                psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: BlueBits should be between 1 and 32 or 0",
                              filename, linenr);
                }
              }
            } else {
              {
#line 112
              psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: BlueBits should be between 1 and 32 or 0",
                            filename, linenr);
              }
            }
          } else
#line 103
          if (value >= 0) {
#line 103
            if (value <= 32) {
#line 104
              (*config)->greenbits = value;
            } else {
              {
#line 106
              psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: GreenBits should be between 1 and 32 or 0",
                            filename, linenr);
              }
            }
          } else {
            {
#line 106
            psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: GreenBits should be between 1 and 32 or 0",
                          filename, linenr);
            }
          }
        } else
#line 97
        if (value >= 0) {
#line 97
          if (value <= 32) {
#line 98
            (*config)->redbits = value;
          } else {
            {
#line 100
            psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: RedBits should be between 1 and 32 or 0",
                          filename, linenr);
            }
          }
        } else {
          {
#line 100
          psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: RedBits should be between 1 and 32 or 0",
                        filename, linenr);
          }
        }
      } else
#line 91
      if (value > 0) {
#line 91
        if (value <= 32) {
#line 92
          (*config)->colordepth = value;
        } else {
          {
#line 94
          psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: ColorDepth should be between 1 and 32",
                        filename, linenr);
          }
        }
      } else {
        {
#line 94
        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: ColorDepth should be between 1 and 32",
                      filename, linenr);
        }
      }
    } else
#line 85
    if (value == 0) {
#line 86
      (*config)->color = (psiconv_bool_t )value;
    } else
#line 85
    if (value == 1) {
#line 86
      (*config)->color = (psiconv_bool_t )value;
    } else {
      {
#line 88
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Color should be 0 or 1",
                    filename, linenr);
      }
    }
  } else
#line 79
  if (value >= 1) {
#line 79
    if (value <= 5) {
#line 80
      (*config)->verbosity = value;
    } else {
      {
#line 82
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Verbosity should be between 1 and 5",
                    filename, linenr);
      }
    }
  } else {
    {
#line 82
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Verbosity should be between 1 and 5",
                  filename, linenr);
    }
  }
  {
#line 150
  psiconv_debug(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Set variable %s to %d",
                filename, linenr, var, value);
  }
#line 152
  return;
}
}
#line 155 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
static void psiconv_config_parse_line___3(char const   *filename , int linenr , char const   *line ,
                                          psiconv_config *config ) 
{ 
  int sovar ;
  int eovar ;
  int soval ;
  int eoval ;
  int eol ;
  char *var ;
  long val ;
  void *tmp ;

  {
  {
#line 163
  psiconv_debug(*config, 0, (psiconv_u32 )0, "Going to parse line %d: %s", linenr,
                line);
#line 164
  sovar = 0;
  }
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (*(line + sovar)) {
#line 165
      if (! ((int const   )*(line + sovar) < 32)) {
#line 165
        goto while_break;
      }
    } else {
#line 165
      goto while_break;
    }
#line 166
    sovar ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  if (! *(line + sovar)) {
#line 168
    return;
  } else
#line 167
  if ((int const   )*(line + sovar) == 35) {
#line 168
    return;
  }
#line 169
  eovar = sovar;
  {
#line 170
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 170
    if (*(line + eovar)) {
#line 170
      if ((int const   )*(line + eovar) >= 65) {
#line 170
        if (! ((int const   )*(line + eovar) <= 90)) {
#line 170
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 170
      if ((int const   )*(line + eovar) >= 97) {
#line 170
        if (! ((int const   )*(line + eovar) <= 122)) {
#line 170
          goto while_break___0;
        }
      } else {
#line 170
        goto while_break___0;
      }
    } else {
#line 170
      goto while_break___0;
    }
#line 172
    eovar ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 173
  if (sovar == eovar) {
    {
#line 174
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (no variable found)",
                  filename, linenr);
    }
#line 176
    return;
  }
#line 178
  soval = eovar;
  {
#line 179
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 179
    if (*(line + soval)) {
#line 179
      if (! ((int const   )*(line + soval) <= 32)) {
#line 179
        goto while_break___1;
      }
    } else {
#line 179
      goto while_break___1;
    }
#line 180
    soval ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 181
  if ((int const   )*(line + soval) != 61) {
    {
#line 182
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (no = token found)",
                  filename, linenr);
    }
#line 184
    return;
  }
#line 186
  soval ++;
  {
#line 187
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 187
    if (*(line + soval)) {
#line 187
      if (! ((int const   )*(line + soval) <= 32)) {
#line 187
        goto while_break___2;
      }
    } else {
#line 187
      goto while_break___2;
    }
#line 188
    soval ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 189
  eoval = soval;
  {
#line 190
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 190
    if (*(line + eoval)) {
#line 190
      if ((int const   )*(line + eoval) >= 48) {
#line 190
        if (! ((int const   )*(line + eoval) <= 57)) {
#line 190
          goto while_break___3;
        }
      } else {
#line 190
        goto while_break___3;
      }
    } else {
#line 190
      goto while_break___3;
    }
#line 191
    eoval ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 192
  if (eoval == soval) {
    {
#line 193
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (no value found)",
                  filename, linenr);
    }
#line 195
    return;
  }
#line 197
  if (soval - eoval > 7) {
    {
#line 198
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (value too large)",
                  filename, linenr);
    }
#line 200
    return;
  }
#line 202
  eol = eoval;
  {
#line 203
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 203
    if (*(line + eol)) {
#line 203
      if (! ((int const   )*(line + eol) < 32)) {
#line 203
        goto while_break___4;
      }
    } else {
#line 203
      goto while_break___4;
    }
#line 204
    eol ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 205
  if (*(line + eol)) {
    {
#line 206
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Syntax error (trailing garbage)",
                  filename, linenr);
    }
#line 208
    return;
  }
  {
#line 211
  tmp = malloc((size_t )((eovar - sovar) + 1));
#line 211
  var = (char *)tmp;
#line 212
  memcpy((void */* __restrict  */)var, (void const   */* __restrict  */)(line + sovar),
         (size_t )(eovar - sovar));
#line 213
  *(var + (eovar - sovar)) = (char)0;
#line 215
  val = atol(line + soval);
#line 217
  psiconv_config_parse_statement___3(filename, linenr, (char const   *)var, (int )val,
                                     config);
#line 218
  free((void *)var);
  }
#line 219
  return;
}
}
#line 222 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/configuration.c"
static void psiconv_config_parse_file___3(char const   *filename , psiconv_config *config ) 
{ 
  int file ;
  int linenr ;
  struct stat stat_buf ;
  off_t filesize ;
  off_t bytes_left ;
  off_t bytes_read ;
  off_t sol ;
  off_t eol ;
  char *filebuffer ;
  char *filebuffer_ptr ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 229
  psiconv_progress(*config, 0, (psiconv_u32 )0, "Going to access configuration file %s",
                   filename);
#line 233
  file = open(filename, 0);
  }
#line 233
  if (file == -1) {
#line 234
    goto ERROR0;
  }
  {
#line 237
  tmp___0 = fstat(file, & stat_buf);
  }
#line 237
  if (tmp___0) {
    {
#line 238
    tmp = close(file);
    }
#line 238
    if (tmp) {
      {
#line 239
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Couldn\'t close file",
                    filename);
      }
    }
#line 241
    return;
  }
  {
#line 244
  filesize = stat_buf.st_size;
#line 245
  tmp___1 = malloc((size_t )(filesize + 1L));
#line 245
  filebuffer = (char *)tmp___1;
  }
#line 245
  if (! filebuffer) {
    {
#line 246
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Out of memory error",
                  filename);
    }
#line 248
    goto ERROR1;
  }
#line 251
  filebuffer_ptr = filebuffer;
#line 252
  bytes_left = filesize;
#line 253
  bytes_read = (off_t )1;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (bytes_read > 0L) {
#line 254
      if (! bytes_left) {
#line 254
        goto while_break;
      }
    } else {
#line 254
      goto while_break;
    }
    {
#line 255
    bytes_read = read(file, (void *)filebuffer_ptr, (size_t )bytes_left);
    }
#line 256
    if (bytes_read > 0L) {
#line 257
      filebuffer_ptr += bytes_read;
#line 258
      bytes_left -= bytes_read;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  if (bytes_left) {
#line 263
    if (bytes_left != filesize) {
      {
#line 264
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Couldn\'t read file into memory",
                    filename);
      }
#line 266
      goto ERROR2;
    }
  }
  {
#line 269
  tmp___2 = close(file);
  }
#line 269
  if (tmp___2) {
    {
#line 270
    psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Couldn\'t close file",
                  filename);
#line 272
    file = -1;
    }
#line 273
    goto ERROR2;
  }
  {
#line 275
  file = -1;
#line 277
  psiconv_progress(*config, 0, (psiconv_u32 )0, "Going to parse configuration file %s: ",
                   filename);
#line 280
  linenr = 0;
#line 281
  sol = (off_t )0;
  }
  {
#line 283
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 283
    if (! (sol < filesize)) {
#line 283
      goto while_break___0;
    }
#line 284
    linenr ++;
#line 285
    eol = sol;
    {
#line 286
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 286
      if (eol < filesize) {
#line 286
        if ((int )*(filebuffer + eol) != 13) {
#line 286
          if ((int )*(filebuffer + eol) != 10) {
#line 286
            if (! ((int )*(filebuffer + eol) != 0)) {
#line 286
              goto while_break___1;
            }
          } else {
#line 286
            goto while_break___1;
          }
        } else {
#line 286
          goto while_break___1;
        }
      } else {
#line 286
        goto while_break___1;
      }
#line 288
      eol ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 290
    if (eol < filesize) {
#line 290
      if ((int )*(filebuffer + eol) == 0) {
        {
#line 291
        psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s, line %d: Unexpected character \000 found",
                      filename, linenr);
        }
#line 293
        goto ERROR2;
      }
    }
#line 295
    if (eol < filesize + 1L) {
#line 295
      if ((int )*(filebuffer + eol) == 13) {
#line 295
        if ((int )*(filebuffer + (eol + 1L)) == 10) {
#line 298
          *(filebuffer + eol) = (char)0;
#line 299
          eol ++;
        } else {
#line 295
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 295
      if ((int )*(filebuffer + eol) == 10) {
#line 295
        if ((int )*(filebuffer + (eol + 1L)) == 13) {
#line 298
          *(filebuffer + eol) = (char)0;
#line 299
          eol ++;
        }
      }
    }
    {
#line 301
    *(filebuffer + eol) = (char)0;
#line 302
    psiconv_config_parse_line___3(filename, linenr, (char const   *)(filebuffer + sol),
                                  config);
#line 303
    sol = eol + 1L;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 305
  free((void *)filebuffer);
  }
#line 306
  return;
  ERROR2: 
  {
#line 309
  free((void *)filebuffer);
  }
  ERROR1: 
#line 311
  if (file != -1) {
    {
#line 311
    tmp___3 = close(file);
    }
#line 311
    if (tmp___3) {
      {
#line 312
      psiconv_error(*config, 0, (psiconv_u32 )0, "Configuration file %s: Couldn\'t close file",
                    filename);
      }
    }
  }
  ERROR0: 
#line 315
  return;
}
}
#line 35 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_txt.c"
static void output_para___0(psiconv_config const   config , psiconv_list list , psiconv_paragraph const   para ,
                            encoding encoding_type ) ;
#line 37
static void gen_word___2(psiconv_config const   config , psiconv_list list , psiconv_word_f wf ,
                         encoding encoding_type ) ;
#line 39
static void gen_texted___2(psiconv_config const   config , psiconv_list list , psiconv_texted_f tf ,
                           encoding encoding_type ) ;
#line 41
static int gen_txt___0(psiconv_config const   config , psiconv_list list , psiconv_file const   file ,
                       char const   *dest , encoding const   encoding_type ) ;
#line 45 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_txt.c"
static struct fileformat_s ff___0  =    {"ASCII", "Plain text without much layout", 3, & gen_txt___0};
#line 54 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_txt.c"
static void output_para___0(psiconv_config const   config , psiconv_list list , psiconv_paragraph const   para ,
                            encoding encoding_type ) 
{ 
  int i ;
  int tmp ;

  {
#line 58
  if (para) {
#line 58
    if (para->base_paragraph) {
#line 58
      if ((para->base_paragraph)->bullet) {
#line 58
        if (((para->base_paragraph)->bullet)->on) {
          {
#line 60
          output_char((psiconv_config )config, list, ((para->base_paragraph)->bullet)->character,
                      encoding_type);
#line 62
          output_char((psiconv_config )config, list, (psiconv_ucs2 )' ', encoding_type);
#line 63
          output_char((psiconv_config )config, list, (psiconv_ucs2 )' ', encoding_type);
#line 64
          output_char((psiconv_config )config, list, (psiconv_ucs2 )' ', encoding_type);
          }
        }
      }
    }
  }
#line 66
  if (para) {
#line 66
    if (para->text) {
#line 67
      i = 0;
      {
#line 67
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 67
        tmp = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
        }
#line 67
        if (! (i < tmp)) {
#line 67
          goto while_break;
        }
        {
#line 71
        if ((int )*(para->text + i) == 8) {
#line 71
          goto case_8;
        }
#line 71
        if ((int )*(para->text + i) == 7) {
#line 71
          goto case_8;
        }
#line 71
        if ((int )*(para->text + i) == 6) {
#line 71
          goto case_8;
        }
#line 75
        if ((int )*(para->text + i) == 10) {
#line 75
          goto case_10;
        }
#line 75
        if ((int )*(para->text + i) == 9) {
#line 75
          goto case_10;
        }
#line 79
        if ((int )*(para->text + i) == 12) {
#line 79
          goto case_12;
        }
#line 79
        if ((int )*(para->text + i) == 11) {
#line 79
          goto case_12;
        }
#line 82
        if ((int )*(para->text + i) == 15) {
#line 82
          goto case_15;
        }
#line 106
        if ((int )*(para->text + i) == 31) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 30) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 29) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 28) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 26) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 25) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 24) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 23) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 22) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 21) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 20) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 19) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 18) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 17) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 16) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 14) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 5) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 4) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 3) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 2) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 1) {
#line 106
          goto case_31;
        }
#line 106
        if ((int )*(para->text + i) == 0) {
#line 106
          goto case_31;
        }
#line 108
        goto switch_default;
        case_8: /* CIL Label */ 
        case_7: /* CIL Label */ 
        case_6: /* CIL Label */ 
        {
#line 72
        output_char((psiconv_config )config, list, (psiconv_ucs2 )'\n', encoding_type);
        }
#line 73
        goto switch_break;
        case_10: /* CIL Label */ 
        case_9: /* CIL Label */ 
        {
#line 76
        output_char((psiconv_config )config, list, (psiconv_ucs2 )'\t', encoding_type);
        }
#line 77
        goto switch_break;
        case_12: /* CIL Label */ 
        case_11: /* CIL Label */ 
        {
#line 80
        output_char((psiconv_config )config, list, (psiconv_ucs2 )'-', encoding_type);
        }
#line 81
        goto switch_break;
        case_15: /* CIL Label */ 
        {
#line 83
        output_char((psiconv_config )config, list, (psiconv_ucs2 )' ', encoding_type);
        }
#line 84
        goto switch_break;
        case_31: /* CIL Label */ 
        case_30: /* CIL Label */ 
        case_29: /* CIL Label */ 
        case_28: /* CIL Label */ 
        case_26: /* CIL Label */ 
        case_25: /* CIL Label */ 
        case_24: /* CIL Label */ 
        case_23: /* CIL Label */ 
        case_22: /* CIL Label */ 
        case_21: /* CIL Label */ 
        case_20: /* CIL Label */ 
        case_19: /* CIL Label */ 
        case_18: /* CIL Label */ 
        case_17: /* CIL Label */ 
        case_16: /* CIL Label */ 
        case_14: /* CIL Label */ 
        case_5: /* CIL Label */ 
        case_4: /* CIL Label */ 
        case_3: /* CIL Label */ 
        case_2: /* CIL Label */ 
        case_1: /* CIL Label */ 
        case_0: /* CIL Label */ 
#line 107
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 109
        output_char((psiconv_config )config, list, *(para->text + i), encoding_type);
        }
#line 110
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 67
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 112
      output_char((psiconv_config )config, list, (psiconv_ucs2 )'\n', encoding_type);
      }
    }
  }
#line 114
  return;
}
}
#line 116 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_txt.c"
static void gen_word___2(psiconv_config const   config , psiconv_list list , psiconv_word_f wf ,
                         encoding encoding_type ) 
{ 
  int i ;
  psiconv_paragraph para ;
  void *tmp ;
  psiconv_u32 tmp___0 ;
  void *tmp___1 ;
  psiconv_u32 tmp___2 ;
  void *tmp___3 ;
  psiconv_u32 tmp___4 ;

  {
#line 122
  if (wf) {
#line 122
    if (wf->page_sec) {
#line 122
      if ((wf->page_sec)->header) {
#line 122
        if (((wf->page_sec)->header)->text) {
#line 122
          if ((((wf->page_sec)->header)->text)->paragraphs) {
#line 124
            i = 0;
            {
#line 124
            while (1) {
              while_continue: /* CIL Label */ ;
              {
#line 124
              tmp___0 = psiconv_list_length((psiconv_list const   )(((wf->page_sec)->header)->text)->paragraphs);
              }
#line 124
              if (! ((psiconv_u32 )i < tmp___0)) {
#line 124
                goto while_break;
              }
              {
#line 127
              tmp = psiconv_list_get((psiconv_list const   )(((wf->page_sec)->header)->text)->paragraphs,
                                     (psiconv_u32 )i);
#line 127
              para = (psiconv_paragraph )tmp;
#line 129
              output_para___0(config, list, (psiconv_paragraph const   )para, encoding_type);
#line 124
              i ++;
              }
            }
            while_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
  {
#line 132
  output_char((psiconv_config )config, list, (psiconv_ucs2 )'\n', encoding_type);
  }
#line 134
  if (wf) {
#line 134
    if (wf->paragraphs) {
#line 135
      i = 0;
      {
#line 135
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 135
        tmp___2 = psiconv_list_length((psiconv_list const   )wf->paragraphs);
        }
#line 135
        if (! ((psiconv_u32 )i < tmp___2)) {
#line 135
          goto while_break___0;
        }
        {
#line 136
        tmp___1 = psiconv_list_get((psiconv_list const   )wf->paragraphs, (psiconv_u32 )i);
#line 136
        para = (psiconv_paragraph )tmp___1;
#line 137
        output_para___0(config, list, (psiconv_paragraph const   )para, encoding_type);
#line 135
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 140
  output_char((psiconv_config )config, list, (psiconv_ucs2 )'\n', encoding_type);
  }
#line 142
  if (wf) {
#line 142
    if (wf->page_sec) {
#line 142
      if ((wf->page_sec)->footer) {
#line 142
        if (((wf->page_sec)->footer)->text) {
#line 142
          if ((((wf->page_sec)->footer)->text)->paragraphs) {
#line 144
            i = 0;
            {
#line 144
            while (1) {
              while_continue___1: /* CIL Label */ ;
              {
#line 144
              tmp___4 = psiconv_list_length((psiconv_list const   )(((wf->page_sec)->footer)->text)->paragraphs);
              }
#line 144
              if (! ((psiconv_u32 )i < tmp___4)) {
#line 144
                goto while_break___1;
              }
              {
#line 147
              tmp___3 = psiconv_list_get((psiconv_list const   )(((wf->page_sec)->footer)->text)->paragraphs,
                                         (psiconv_u32 )i);
#line 147
              para = (psiconv_paragraph )tmp___3;
#line 148
              output_para___0(config, list, (psiconv_paragraph const   )para, encoding_type);
#line 144
              i ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
#line 151
  return;
}
}
#line 153 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_txt.c"
static void gen_texted___2(psiconv_config const   config , psiconv_list list , psiconv_texted_f tf ,
                           encoding encoding_type ) 
{ 
  int i ;
  psiconv_paragraph para ;
  void *tmp ;
  psiconv_u32 tmp___0 ;
  void *tmp___1 ;
  psiconv_u32 tmp___2 ;
  void *tmp___3 ;
  psiconv_u32 tmp___4 ;

  {
#line 159
  if (tf) {
#line 159
    if (tf->page_sec) {
#line 159
      if ((tf->page_sec)->header) {
#line 159
        if (((tf->page_sec)->header)->text) {
#line 159
          if ((((tf->page_sec)->header)->text)->paragraphs) {
#line 161
            i = 0;
            {
#line 161
            while (1) {
              while_continue: /* CIL Label */ ;
              {
#line 161
              tmp___0 = psiconv_list_length((psiconv_list const   )(((tf->page_sec)->header)->text)->paragraphs);
              }
#line 161
              if (! ((psiconv_u32 )i < tmp___0)) {
#line 161
                goto while_break;
              }
              {
#line 164
              tmp = psiconv_list_get((psiconv_list const   )(((tf->page_sec)->header)->text)->paragraphs,
                                     (psiconv_u32 )i);
#line 164
              para = (psiconv_paragraph )tmp;
#line 166
              output_para___0(config, list, (psiconv_paragraph const   )para, encoding_type);
#line 161
              i ++;
              }
            }
            while_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
  {
#line 169
  output_char((psiconv_config )config, list, (psiconv_ucs2 )'\n', encoding_type);
  }
#line 171
  if (tf) {
#line 171
    if (tf->texted_sec) {
#line 171
      if ((tf->texted_sec)->paragraphs) {
#line 172
        i = 0;
        {
#line 172
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 172
          tmp___2 = psiconv_list_length((psiconv_list const   )(tf->texted_sec)->paragraphs);
          }
#line 172
          if (! ((psiconv_u32 )i < tmp___2)) {
#line 172
            goto while_break___0;
          }
          {
#line 173
          tmp___1 = psiconv_list_get((psiconv_list const   )(tf->texted_sec)->paragraphs,
                                     (psiconv_u32 )i);
#line 173
          para = (psiconv_paragraph )tmp___1;
#line 174
          output_para___0(config, list, (psiconv_paragraph const   )para, encoding_type);
#line 172
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 177
  output_char((psiconv_config )config, list, (psiconv_ucs2 )'\n', encoding_type);
  }
#line 179
  if (tf) {
#line 179
    if (tf->page_sec) {
#line 179
      if ((tf->page_sec)->footer) {
#line 179
        if (((tf->page_sec)->footer)->text) {
#line 179
          if ((((tf->page_sec)->footer)->text)->paragraphs) {
#line 181
            i = 0;
            {
#line 181
            while (1) {
              while_continue___1: /* CIL Label */ ;
              {
#line 181
              tmp___4 = psiconv_list_length((psiconv_list const   )(((tf->page_sec)->footer)->text)->paragraphs);
              }
#line 181
              if (! ((psiconv_u32 )i < tmp___4)) {
#line 181
                goto while_break___1;
              }
              {
#line 184
              tmp___3 = psiconv_list_get((psiconv_list const   )(((tf->page_sec)->footer)->text)->paragraphs,
                                         (psiconv_u32 )i);
#line 184
              para = (psiconv_paragraph )tmp___3;
#line 185
              output_para___0(config, list, (psiconv_paragraph const   )para, encoding_type);
#line 181
              i ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
#line 188
  return;
}
}
#line 190 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_txt.c"
static int gen_txt___0(psiconv_config const   config , psiconv_list list , psiconv_file const   file ,
                       char const   *dest , encoding const   encoding_type ) 
{ 


  {
#line 194
  if ((unsigned int )file->type == 1U) {
    {
#line 195
    gen_word___2(config, list, (psiconv_word_f )file->file, (encoding )encoding_type);
    }
#line 196
    return (0);
  } else
#line 197
  if ((unsigned int )file->type == 2U) {
    {
#line 198
    gen_texted___2(config, list, (psiconv_texted_f )file->file, (encoding )encoding_type);
    }
#line 199
    return (0);
  } else {
#line 201
    return (-1);
  }
}
}
#line 35 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_html4.c"
static void text___1(psiconv_config const   config , psiconv_list list , psiconv_string_t data ,
                     encoding const   enc ) ;
#line 37
static void header___1(psiconv_config const   config , psiconv_list list , encoding const   enc ) ;
#line 39
static void footer___1(psiconv_config const   config , psiconv_list list , encoding const   enc ) ;
#line 41
static void characters___1(psiconv_config const   config , psiconv_list list , psiconv_string_t const   textstr ,
                           psiconv_character_layout const   layout , encoding const   enc ) ;
#line 44
static void paragraph___1(psiconv_config const   config , psiconv_list list , psiconv_paragraph para ,
                          encoding const   enc ) ;
#line 46
static void paragraphs___1(psiconv_config const   config , psiconv_list list , psiconv_text_and_layout paragraphs___3 ,
                           encoding const   enc ) ;
#line 48
static void gen_word___3(psiconv_config const   config , psiconv_list list , psiconv_word_f const   file ,
                         encoding const   enc ) ;
#line 50
static void gen_texted___3(psiconv_config const   config , psiconv_list list , psiconv_texted_f const   file ,
                           encoding const   enc ) ;
#line 52
static int gen_html4___0(psiconv_config const   config , psiconv_list list , psiconv_file const   file ,
                         char const   *dest , encoding const   enc ) ;
#line 57 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_html4.c"
static void text___1(psiconv_config const   config , psiconv_list list , psiconv_string_t data ,
                     encoding const   enc ) 
{ 
  int i ;
  int tmp ;

  {
#line 61
  i = 0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 61
    tmp = psiconv_unicode_strlen((psiconv_ucs2 const   *)data);
    }
#line 61
    if (! (i < tmp)) {
#line 61
      goto while_break;
    }
#line 62
    if ((int )*(data + i) == 6) {
      {
#line 63
      output_simple_chars((psiconv_config )config, list, (char *)"<BR>", (encoding )enc);
      }
    } else
#line 62
    if ((int )*(data + i) == 7) {
      {
#line 63
      output_simple_chars((psiconv_config )config, list, (char *)"<BR>", (encoding )enc);
      }
    } else
#line 62
    if ((int )*(data + i) == 8) {
      {
#line 63
      output_simple_chars((psiconv_config )config, list, (char *)"<BR>", (encoding )enc);
      }
    } else
#line 64
    if ((int )*(data + i) == 11) {
      {
#line 65
      output_simple_chars((psiconv_config )config, list, (char *)"-", (encoding )enc);
      }
    } else
#line 64
    if ((int )*(data + i) == 12) {
      {
#line 65
      output_simple_chars((psiconv_config )config, list, (char *)"-", (encoding )enc);
      }
    } else
#line 66
    if ((int )*(data + i) == 15) {
      {
#line 67
      output_simple_chars((psiconv_config )config, list, (char *)" ", (encoding )enc);
      }
    } else
#line 66
    if ((int )*(data + i) == 9) {
      {
#line 67
      output_simple_chars((psiconv_config )config, list, (char *)" ", (encoding )enc);
      }
    } else
#line 66
    if ((int )*(data + i) == 10) {
      {
#line 67
      output_simple_chars((psiconv_config )config, list, (char *)" ", (encoding )enc);
      }
    } else
#line 68
    if ((int )*(data + i) >= 32) {
      {
#line 69
      output_char((psiconv_config )config, list, *(data + i), (encoding )enc);
      }
    }
#line 61
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return;
}
}
#line 73 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_html4.c"
static void header___1(psiconv_config const   config , psiconv_list list , encoding const   enc ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 75
  output_simple_chars((psiconv_config )config, list, (char *)"<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n",
                      (encoding )enc);
#line 79
  output_simple_chars((psiconv_config )config, list, (char *)"<HTML>\n", (encoding )enc);
#line 80
  output_simple_chars((psiconv_config )config, list, (char *)"<HEAD>\n", (encoding )enc);
#line 81
  output_simple_chars((psiconv_config )config, list, (char *)"<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=",
                      (encoding )enc);
  }
#line 83
  if ((unsigned int const   )enc == 0U) {
#line 83
    tmp___1 = "UTF-8";
  } else {
#line 83
    if ((unsigned int const   )enc == 1U) {
#line 83
      tmp___0 = "UTF-16BE";
    } else {
#line 83
      if ((unsigned int const   )enc == 3U) {
#line 83
        tmp = "US-ASCII";
      } else {
#line 83
        tmp = "";
      }
#line 83
      tmp___0 = tmp;
    }
#line 83
    tmp___1 = tmp___0;
  }
  {
#line 83
  output_simple_chars((psiconv_config )config, list, (char *)tmp___1, (encoding )enc);
#line 87
  output_simple_chars((psiconv_config )config, list, (char *)"\">\n", (encoding )enc);
#line 88
  output_simple_chars((psiconv_config )config, list, (char *)"<TITLE>EPOC32 file converted by psiconv</TITLE>\n",
                      (encoding )enc);
#line 90
  output_simple_chars((psiconv_config )config, list, (char *)"</HEAD>\n", (encoding )enc);
#line 91
  output_simple_chars((psiconv_config )config, list, (char *)"<BODY>\n", (encoding )enc);
  }
#line 92
  return;
}
}
#line 94 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_html4.c"
static void footer___1(psiconv_config const   config , psiconv_list list , encoding const   enc ) 
{ 


  {
  {
#line 96
  output_simple_chars((psiconv_config )config, list, (char *)"</BODY>\n", (encoding )enc);
#line 97
  output_simple_chars((psiconv_config )config, list, (char *)"</HTML>\n", (encoding )enc);
  }
#line 98
  return;
}
}
#line 131 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_html4.c"
static void characters___1(psiconv_config const   config , psiconv_list list , psiconv_string_t const   textstr ,
                           psiconv_character_layout const   layout , encoding const   enc ) 
{ 
  char tempstr[100] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;

  {
  {
#line 137
  output_simple_chars((psiconv_config )config, list, (char *)"<FONT face=\"", (encoding )enc);
  }
#line 138
  if ((unsigned int )(layout->font)->screenfont == 3U) {
#line 138
    tmp___2 = "serif";
  } else {
#line 138
    if ((unsigned int )(layout->font)->screenfont == 1U) {
#line 138
      tmp___1 = "sans-serif";
    } else {
#line 138
      if ((unsigned int )(layout->font)->screenfont == 2U) {
#line 138
        tmp___0 = "monospace";
      } else {
#line 138
        if ((unsigned int )(layout->font)->screenfont == 0U) {
#line 138
          tmp = "fantasy";
        } else {
#line 138
          tmp = "";
        }
#line 138
        tmp___0 = tmp;
      }
#line 138
      tmp___1 = tmp___0;
    }
#line 138
    tmp___2 = tmp___1;
  }
  {
#line 138
  output_simple_chars((psiconv_config )config, list, (char *)tmp___2, (encoding )enc);
#line 144
  output_simple_chars((psiconv_config )config, list, (char *)"\"", (encoding )enc);
  }
#line 146
  if (layout->font_size < (psiconv_size_t )10) {
#line 146
    goto _L;
  } else
#line 146
  if (layout->font_size >= (psiconv_size_t )13) {
    _L: /* CIL Label */ 
    {
#line 147
    output_simple_chars((psiconv_config )config, list, (char *)" size=", (encoding )enc);
    }
#line 148
    if (layout->font_size < (psiconv_size_t )8) {
#line 148
      tmp___8 = "1";
    } else {
#line 148
      if (layout->font_size < (psiconv_size_t )10) {
#line 148
        tmp___7 = "2";
      } else {
#line 148
        if (layout->font_size < (psiconv_size_t )13) {
#line 148
          tmp___6 = "3";
        } else {
#line 148
          if (layout->font_size < (psiconv_size_t )17) {
#line 148
            tmp___5 = "4";
          } else {
#line 148
            if (layout->font_size < (psiconv_size_t )24) {
#line 148
              tmp___4 = "5";
            } else {
#line 148
              if (layout->font_size < (psiconv_size_t )36) {
#line 148
                tmp___3 = "6";
              } else {
#line 148
                tmp___3 = "7";
              }
#line 148
              tmp___4 = tmp___3;
            }
#line 148
            tmp___5 = tmp___4;
          }
#line 148
          tmp___6 = tmp___5;
        }
#line 148
        tmp___7 = tmp___6;
      }
#line 148
      tmp___8 = tmp___7;
    }
    {
#line 148
    output_simple_chars((psiconv_config )config, list, (char *)tmp___8, (encoding )enc);
    }
  }
#line 156
  if ((int )(layout->color)->red != 0) {
    {
#line 158
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%02x%02x%02x",
             (int )(layout->color)->red, (int )(layout->color)->green, (int )(layout->color)->blue);
#line 160
    output_simple_chars((psiconv_config )config, list, (char *)" color=#", (encoding )enc);
#line 161
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
    }
  } else
#line 156
  if ((int )(layout->color)->green != 0) {
    {
#line 158
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%02x%02x%02x",
             (int )(layout->color)->red, (int )(layout->color)->green, (int )(layout->color)->blue);
#line 160
    output_simple_chars((psiconv_config )config, list, (char *)" color=#", (encoding )enc);
#line 161
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
    }
  } else
#line 156
  if ((int )(layout->color)->blue != 0) {
    {
#line 158
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%02x%02x%02x",
             (int )(layout->color)->red, (int )(layout->color)->green, (int )(layout->color)->blue);
#line 160
    output_simple_chars((psiconv_config )config, list, (char *)" color=#", (encoding )enc);
#line 161
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
    }
  }
  {
#line 163
  output_simple_chars((psiconv_config )config, list, (char *)">", (encoding )enc);
  }
#line 166
  if (layout->italic) {
    {
#line 167
    output_simple_chars((psiconv_config )config, list, (char *)"<I>", (encoding )enc);
    }
  }
#line 168
  if (layout->bold) {
    {
#line 169
    output_simple_chars((psiconv_config )config, list, (char *)"<B>", (encoding )enc);
    }
  }
#line 170
  if ((unsigned int )layout->super_sub != 0U) {
#line 171
    if ((unsigned int )layout->super_sub == 1U) {
#line 171
      tmp___10 = "<SUP>";
    } else {
#line 171
      if ((unsigned int )layout->super_sub == 2U) {
#line 171
        tmp___9 = "<SUB>";
      } else {
#line 171
        tmp___9 = "";
      }
#line 171
      tmp___10 = tmp___9;
    }
    {
#line 171
    output_simple_chars((psiconv_config )config, list, (char *)tmp___10, (encoding )enc);
    }
  }
#line 175
  if (layout->strikethrough) {
    {
#line 176
    output_simple_chars((psiconv_config )config, list, (char *)"<S>", (encoding )enc);
    }
  }
#line 177
  if (layout->underline) {
    {
#line 178
    output_simple_chars((psiconv_config )config, list, (char *)"<U>", (encoding )enc);
    }
  }
  {
#line 180
  text___1(config, list, (psiconv_string_t )textstr, enc);
  }
#line 182
  if (layout->underline) {
    {
#line 183
    output_simple_chars((psiconv_config )config, list, (char *)"</U>", (encoding )enc);
    }
  }
#line 184
  if (layout->strikethrough) {
    {
#line 185
    output_simple_chars((psiconv_config )config, list, (char *)"</S>", (encoding )enc);
    }
  }
#line 186
  if ((unsigned int )layout->super_sub != 0U) {
#line 187
    if ((unsigned int )layout->super_sub == 1U) {
#line 187
      tmp___12 = "</SUP>";
    } else {
#line 187
      if ((unsigned int )layout->super_sub == 2U) {
#line 187
        tmp___11 = "</SUB>";
      } else {
#line 187
        tmp___11 = "";
      }
#line 187
      tmp___12 = tmp___11;
    }
    {
#line 187
    output_simple_chars((psiconv_config )config, list, (char *)tmp___12, (encoding )enc);
    }
  }
#line 191
  if (layout->bold) {
    {
#line 192
    output_simple_chars((psiconv_config )config, list, (char *)"</B>", (encoding )enc);
    }
  }
#line 193
  if (layout->italic) {
    {
#line 194
    output_simple_chars((psiconv_config )config, list, (char *)"</I>", (encoding )enc);
    }
  }
  {
#line 195
  output_simple_chars((psiconv_config )config, list, (char *)"</FONT>", (encoding )enc);
  }
#line 196
  return;
}
}
#line 198 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_html4.c"
static void paragraph___1(psiconv_config const   config , psiconv_list list , psiconv_paragraph para ,
                          encoding const   enc ) 
{ 
  int i ;
  int charnr ;
  int start ;
  int len ;
  psiconv_string_t text___3 ;
  psiconv_in_line_layout layout ;
  psiconv_in_line_layout next_layout ;
  char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  psiconv_u32 tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  psiconv_u32 tmp___6 ;
  psiconv_u32 tmp___7 ;
  char const   *tmp___8 ;

  {
#line 206
  if (((para->base_paragraph)->bullet)->on) {
#line 206
    tmp = "<UL><LI";
  } else {
#line 206
    tmp = "<P";
  }
  {
#line 206
  output_simple_chars((psiconv_config )config, list, (char *)tmp, (encoding )enc);
  }
#line 209
  if ((unsigned int )(para->base_paragraph)->justify_hor == 1U) {
    {
#line 210
    output_simple_chars((psiconv_config )config, list, (char *)" align=center", (encoding )enc);
    }
  } else
#line 211
  if ((unsigned int )(para->base_paragraph)->justify_hor == 2U) {
    {
#line 212
    output_simple_chars((psiconv_config )config, list, (char *)" align=right", (encoding )enc);
    }
  } else
#line 213
  if ((unsigned int )(para->base_paragraph)->justify_hor == 3U) {
    {
#line 214
    output_simple_chars((psiconv_config )config, list, (char *)" align=justify", (encoding )enc);
    }
  }
  {
#line 216
  output_simple_chars((psiconv_config )config, list, (char *)">", (encoding )enc);
#line 218
  tmp___7 = psiconv_list_length((psiconv_list const   )para->in_lines);
  }
#line 218
  if (tmp___7 == 0U) {
    {
#line 219
    tmp___0 = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
    }
#line 219
    if (tmp___0) {
      {
#line 220
      characters___1(config, list, (psiconv_string_t const   )para->text, (psiconv_character_layout const   )para->base_character,
                     enc);
      }
    }
  } else {
#line 222
    charnr = 0;
#line 223
    start = -1;
#line 224
    i = 0;
    {
#line 224
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 224
      tmp___6 = psiconv_list_length((psiconv_list const   )para->in_lines);
      }
#line 224
      if (! ((psiconv_u32 )i < tmp___6)) {
#line 224
        goto while_break;
      }
#line 225
      if (start < 0) {
#line 226
        start = charnr;
      }
      {
#line 227
      tmp___1 = psiconv_list_get((psiconv_list const   )para->in_lines, (psiconv_u32 )i);
#line 227
      layout = (psiconv_in_line_layout )tmp___1;
      }
#line 227
      if (! layout) {
        {
#line 228
        fputs((char const   */* __restrict  */)"Internal data structures corruption\n",
              (FILE */* __restrict  */)stderr);
#line 229
        exit(1);
        }
      }
      {
#line 231
      tmp___3 = psiconv_list_length((psiconv_list const   )para->in_lines);
      }
#line 231
      if ((psiconv_u32 )(i + 1) < tmp___3) {
        {
#line 232
        tmp___2 = psiconv_list_get((psiconv_list const   )para->in_lines, (psiconv_u32 )(i + 1));
#line 232
        next_layout = (psiconv_in_line_layout )tmp___2;
        }
#line 232
        if (! next_layout) {
          {
#line 233
          fputs((char const   */* __restrict  */)"Internal data structures corruption\n",
                (FILE */* __restrict  */)stderr);
#line 234
          exit(1);
          }
        }
      } else {
#line 237
        next_layout = (psiconv_in_line_layout )((void *)0);
      }
#line 239
      if (next_layout) {
        {
#line 239
        tmp___4 = character_layout_equal((psiconv_character_layout const   )layout->layout,
                                         (psiconv_character_layout const   )next_layout->layout);
        }
#line 239
        if (tmp___4) {
#line 241
          charnr += layout->length;
#line 242
          goto __Cont;
        }
      }
#line 244
      len = (charnr - start) + layout->length;
#line 245
      if (len) {
        {
#line 246
        tmp___5 = malloc(sizeof(*text___3) * (unsigned long )(len + 1));
#line 246
        text___3 = (psiconv_string_t )tmp___5;
        }
#line 246
        if (! text___3) {
          {
#line 247
          fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 248
          exit(1);
          }
        }
        {
#line 250
        memcpy((void */* __restrict  */)text___3, (void const   */* __restrict  */)(para->text + charnr),
               (unsigned long )len * sizeof(*text___3));
#line 251
        *(text___3 + len) = (psiconv_ucs2 )0;
#line 252
        characters___1(config, list, (psiconv_string_t const   )text___3, (psiconv_character_layout const   )layout->layout,
                       enc);
#line 253
        free((void *)text___3);
        }
      }
#line 255
      charnr += layout->length;
#line 256
      start = -1;
      __Cont: /* CIL Label */ 
#line 224
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 259
  if (((para->base_paragraph)->bullet)->on) {
#line 259
    tmp___8 = "</UL>\n";
  } else {
#line 259
    tmp___8 = "\n";
  }
  {
#line 259
  output_simple_chars((psiconv_config )config, list, (char *)tmp___8, (encoding )enc);
  }
#line 261
  return;
}
}
#line 263 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_html4.c"
static void paragraphs___1(psiconv_config const   config , psiconv_list list , psiconv_text_and_layout paragraphs___3 ,
                           encoding const   enc ) 
{ 
  int i ;
  psiconv_paragraph para ;
  void *tmp ;
  psiconv_u32 tmp___0 ;

  {
#line 268
  i = 0;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 268
    tmp___0 = psiconv_list_length((psiconv_list const   )paragraphs___3);
    }
#line 268
    if (! ((psiconv_u32 )i < tmp___0)) {
#line 268
      goto while_break;
    }
    {
#line 269
    tmp = psiconv_list_get((psiconv_list const   )paragraphs___3, (psiconv_u32 )i);
#line 269
    para = (psiconv_paragraph )tmp;
    }
#line 269
    if (! para) {
      {
#line 270
      fputs((char const   */* __restrict  */)"Internal datastructure corruption\n",
            (FILE */* __restrict  */)stderr);
#line 271
      exit(1);
      }
    }
    {
#line 273
    paragraph___1(config, list, para, enc);
#line 268
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 275
  return;
}
}
#line 277 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_html4.c"
static void gen_word___3(psiconv_config const   config , psiconv_list list , psiconv_word_f const   file ,
                         encoding const   enc ) 
{ 


  {
#line 280
  if (! file) {
#line 281
    return;
  }
  {
#line 283
  header___1(config, list, enc);
#line 284
  paragraphs___1(config, list, file->paragraphs, enc);
#line 285
  footer___1(config, list, enc);
  }
#line 286
  return;
}
}
#line 289 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_html4.c"
static void gen_texted___3(psiconv_config const   config , psiconv_list list , psiconv_texted_f const   file ,
                           encoding const   enc ) 
{ 


  {
  {
#line 292
  header___1(config, list, enc);
#line 293
  paragraphs___1(config, list, (file->texted_sec)->paragraphs, enc);
#line 294
  footer___1(config, list, enc);
  }
#line 295
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_html4.c"
static int gen_html4___0(psiconv_config const   config , psiconv_list list , psiconv_file const   file ,
                         char const   *dest , encoding const   enc ) 
{ 
  encoding enc1 ;

  {
#line 301
  enc1 = (encoding )enc;
#line 303
  if ((unsigned int const   )enc == 2U) {
    {
#line 304
    fputs((char const   */* __restrict  */)"Unsupported encoding\n", (FILE */* __restrict  */)stderr);
    }
#line 305
    return (-1);
  } else
#line 306
  if ((unsigned int const   )enc == 3U) {
#line 307
    enc1 = (encoding )4;
  }
#line 309
  if ((unsigned int )file->type == 1U) {
    {
#line 310
    gen_word___3(config, list, (psiconv_word_f const   )((psiconv_word_f )file->file),
                 (encoding const   )enc1);
    }
#line 311
    return (0);
  } else
#line 312
  if ((unsigned int )file->type == 2U) {
    {
#line 313
    gen_texted___3(config, list, (psiconv_texted_f const   )((psiconv_texted_f )file->file),
                   (encoding const   )enc1);
    }
#line 314
    return (0);
  } else {
#line 316
    return (-1);
  }
}
}
#line 320 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_html4.c"
static struct fileformat_s fileformats___1[2]  = {      {"HTML4", "HTML 4.01 Transitional, without CSS", 3, & gen_html4___0}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), 0, (output_function *)((void *)0)}};
#line 45 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/buffer.c"
static psiconv_u32 unique_id___3  =    (psiconv_u32 )1;
#line 39 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_4_red___3[16]  = 
#line 39 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
  {      (float )((double )0 / 255.0),      (float )((double )85 / 255.0),      (float )((double )128 / 255.0),      (float )((double )128 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )128 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )170 / 255.0),      (float )((double )255 / 255.0)};
#line 46 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_4_green___3[16]  = 
#line 46
  {      (float )((double )0 / 255.0),      (float )((double )85 / 255.0),      (float )((double )0 / 255.0),      (float )((double )128 / 255.0), 
        (float )((double )128 / 255.0),      (float )((double )0 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )128 / 255.0),      (float )((double )170 / 255.0),      (float )((double )255 / 255.0)};
#line 53 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_4_blue___3[16]  = 
#line 53
  {      (float )((double )0 / 255.0),      (float )((double )85 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )255 / 255.0),      (float )((double )128 / 255.0), 
        (float )((double )128 / 255.0),      (float )((double )128 / 255.0),      (float )((double )170 / 255.0),      (float )((double )255 / 255.0)};
#line 69 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_8_red___3[256]  = 
#line 69
  {      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )17 / 255.0),      (float )((double )34 / 255.0),      (float )((double )68 / 255.0),      (float )((double )85 / 255.0), 
        (float )((double )119 / 255.0),      (float )((double )17 / 255.0),      (float )((double )34 / 255.0),      (float )((double )68 / 255.0), 
        (float )((double )85 / 255.0),      (float )((double )119 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )136 / 255.0),      (float )((double )170 / 255.0), 
        (float )((double )187 / 255.0),      (float )((double )221 / 255.0),      (float )((double )238 / 255.0),      (float )((double )136 / 255.0), 
        (float )((double )170 / 255.0),      (float )((double )187 / 255.0),      (float )((double )221 / 255.0),      (float )((double )238 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0)};
#line 136 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_8_green___3[256]  = 
#line 136
  {      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )17 / 255.0),      (float )((double )34 / 255.0),      (float )((double )68 / 255.0),      (float )((double )85 / 255.0), 
        (float )((double )119 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )17 / 255.0),      (float )((double )34 / 255.0), 
        (float )((double )68 / 255.0),      (float )((double )85 / 255.0),      (float )((double )119 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )136 / 255.0),      (float )((double )170 / 255.0),      (float )((double )187 / 255.0), 
        (float )((double )221 / 255.0),      (float )((double )238 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )136 / 255.0), 
        (float )((double )170 / 255.0),      (float )((double )187 / 255.0),      (float )((double )221 / 255.0),      (float )((double )238 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0)};
#line 203 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/image.c"
static float palet_color_8_blue___3[256]  = 
#line 203
  {      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0),      (float )((double )51 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0),      (float )((double )102 / 255.0), 
        (float )((double )17 / 255.0),      (float )((double )34 / 255.0),      (float )((double )68 / 255.0),      (float )((double )85 / 255.0), 
        (float )((double )119 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )17 / 255.0), 
        (float )((double )34 / 255.0),      (float )((double )68 / 255.0),      (float )((double )85 / 255.0),      (float )((double )119 / 255.0), 
        (float )((double )136 / 255.0),      (float )((double )170 / 255.0),      (float )((double )187 / 255.0),      (float )((double )221 / 255.0), 
        (float )((double )238 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0), 
        (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )0 / 255.0),      (float )((double )136 / 255.0), 
        (float )((double )170 / 255.0),      (float )((double )187 / 255.0),      (float )((double )221 / 255.0),      (float )((double )238 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0),      (float )((double )153 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0),      (float )((double )204 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0), 
        (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0),      (float )((double )255 / 255.0)};
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/error.c"
static void psiconv_default_error_handler___3(int kind , psiconv_u32 off , char const   *message ) 
{ 


  {
  {
#line 36
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          message);
  }
#line 37
  return;
}
}
#line 36 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
static int psiconv_list_resize___3(psiconv_list l , psiconv_u32 nr ) ;
#line 178 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/list.c"
static int psiconv_list_resize___3(psiconv_list l , psiconv_u32 nr ) 
{ 
  void *temp ;

  {
#line 181
  if (nr > l->max_len) {
    {
#line 182
    l->max_len = (psiconv_u32 )(1.1 * (double )nr);
#line 183
    l->max_len += 16U - l->max_len % 16U;
#line 184
    temp = realloc(l->els, (size_t )l->max_len * l->el_size);
    }
#line 185
    if (temp) {
#line 186
      l->els = temp;
#line 187
      return (0);
    } else {
#line 189
      return (-2);
    }
  }
#line 191
  return (0);
}
}
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
static psiconv_ucs2 unicode_paint___3[10]  = 
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
  {      (psiconv_ucs2 )'P',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'i',      (psiconv_ucs2 )'n', 
        (psiconv_ucs2 )'t',      (psiconv_ucs2 )'.',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'p', 
        (psiconv_ucs2 )'p',      (psiconv_ucs2 )0};
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
static psiconv_ucs2 unicode_texted___3[11]  = 
#line 33
  {      (psiconv_ucs2 )'T',      (psiconv_ucs2 )'e',      (psiconv_ucs2 )'x',      (psiconv_ucs2 )'t', 
        (psiconv_ucs2 )'E',      (psiconv_ucs2 )'d',      (psiconv_ucs2 )'.',      (psiconv_ucs2 )'a', 
        (psiconv_ucs2 )'p',      (psiconv_ucs2 )'p',      (psiconv_ucs2 )0};
#line 34 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_driver.c"
static psiconv_ucs2 unicode_word___3[9]  = 
#line 34
  {      (psiconv_ucs2 )'W',      (psiconv_ucs2 )'o',      (psiconv_ucs2 )'r',      (psiconv_ucs2 )'d', 
        (psiconv_ucs2 )'.',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'p',      (psiconv_ucs2 )'p', 
        (psiconv_ucs2 )0};
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
static psiconv_sheet_cell_layout psiconv_basic_cell_layout___3(void) 
{ 
  psiconv_sheet_cell_layout result ;
  void *tmp ;
  psiconv_character_layout tmp___0 ;
  psiconv_paragraph_layout tmp___1 ;
  psiconv_sheet_numberformat tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 35
  tmp = malloc(sizeof(*result));
#line 35
  result = (psiconv_sheet_cell_layout )tmp;
  }
#line 35
  if (! result) {
#line 36
    goto ERROR1;
  }
  {
#line 37
  tmp___0 = psiconv_basic_character_layout();
#line 37
  result->character = tmp___0;
  }
#line 37
  if (! tmp___0) {
#line 38
    goto ERROR2;
  }
  {
#line 39
  tmp___1 = psiconv_basic_paragraph_layout();
#line 39
  result->paragraph = tmp___1;
  }
#line 39
  if (! tmp___1) {
#line 40
    goto ERROR3;
  }
  {
#line 41
  tmp___3 = malloc(sizeof(*(result->numberformat)));
#line 41
  tmp___2 = (psiconv_sheet_numberformat )tmp___3;
#line 41
  result->numberformat = tmp___2;
  }
#line 41
  if (! tmp___2) {
#line 42
    goto ERROR4;
  }
#line 43
  (result->numberformat)->code = (psiconv_sheet_numberformat_code_t )0;
#line 44
  (result->numberformat)->decimal = (psiconv_u8 )2;
#line 45
  return (result);
  ERROR4: 
  {
#line 47
  psiconv_free_paragraph_layout(result->paragraph);
  }
  ERROR3: 
  {
#line 49
  psiconv_free_character_layout(result->character);
  }
  ERROR2: 
  {
#line 51
  free((void *)result);
  }
  ERROR1: 
#line 53
  return ((psiconv_sheet_cell_layout )((void *)0));
}
}
#line 56 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
static psiconv_sheet_cell_layout psiconv_clone_cell_layout___3(psiconv_sheet_cell_layout original ) 
{ 
  psiconv_sheet_cell_layout result ;
  void *tmp ;
  psiconv_character_layout tmp___0 ;
  psiconv_paragraph_layout tmp___1 ;
  psiconv_sheet_numberformat tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 60
  tmp = malloc(sizeof(*result));
#line 60
  result = (psiconv_sheet_cell_layout )tmp;
  }
#line 60
  if (! result) {
#line 61
    goto ERROR1;
  }
  {
#line 62
  tmp___0 = psiconv_clone_character_layout(original->character);
#line 62
  result->character = tmp___0;
  }
#line 62
  if (! tmp___0) {
#line 64
    goto ERROR2;
  }
  {
#line 65
  tmp___1 = psiconv_clone_paragraph_layout(original->paragraph);
#line 65
  result->paragraph = tmp___1;
  }
#line 65
  if (! tmp___1) {
#line 67
    goto ERROR3;
  }
  {
#line 68
  tmp___3 = malloc(sizeof(*(result->numberformat)));
#line 68
  tmp___2 = (psiconv_sheet_numberformat )tmp___3;
#line 68
  result->numberformat = tmp___2;
  }
#line 68
  if (! tmp___2) {
#line 69
    goto ERROR4;
  }
#line 70
  (result->numberformat)->code = (original->numberformat)->code;
#line 71
  (result->numberformat)->decimal = (original->numberformat)->decimal;
#line 72
  return (result);
  ERROR4: 
  {
#line 74
  psiconv_free_paragraph_layout(result->paragraph);
  }
  ERROR3: 
  {
#line 76
  psiconv_free_character_layout(result->character);
  }
  ERROR2: 
  {
#line 78
  free((void *)result);
  }
  ERROR1: 
#line 80
  return ((psiconv_sheet_cell_layout )((void *)0));
}
}
#line 83 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
static psiconv_sheet_cell_reference_t psiconv_read_var_cellref___3(psiconv_config const   config ,
                                                                   psiconv_buffer const   buf ,
                                                                   int lev , psiconv_u32 off ,
                                                                   int *length , int *status ) 
{ 
  int len ;
  int res ;
  psiconv_sheet_cell_reference_t result ;
  psiconv_u32 temp ;
  psiconv_u8 tmp ;

  {
  {
#line 89
  len = 0;
#line 94
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read a sheet cell reference");
#line 95
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the initial byte (%02x expected)",
                   0);
#line 97
  tmp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 97
  temp = (psiconv_u32 )tmp;
  }
#line 98
  if (res) {
#line 99
    goto ERROR1;
  }
#line 100
  if (temp != 0U) {
    {
#line 101
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet cell reference initial byte unknown value (ignored)");
#line 103
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Initial byte: %02x",
                  temp);
    }
  }
  {
#line 105
  len ++;
#line 107
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 108
  if (res) {
#line 109
    goto ERROR1;
  }
#line 110
  if (temp & 4294901760U) {
    {
#line 111
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet cell row reference to unknown row (reset)");
    }
  }
  {
#line 114
  result.row.offset = (psiconv_s16 )temp;
#line 115
  result.row.absolute = (psiconv_bool_t )1;
#line 116
  len += 4;
#line 118
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 119
  if (res) {
#line 120
    goto ERROR1;
  }
#line 121
  if (temp & 4294901760U) {
    {
#line 122
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet cell column reference to unknown row (reset)");
    }
  }
#line 125
  result.column.offset = (psiconv_s16 )temp;
#line 126
  result.column.absolute = (psiconv_bool_t )1;
#line 127
  len += 4;
#line 129
  if (length) {
#line 130
    *length = len;
  }
  {
#line 132
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet column reference (total length: %08x)",
                   len);
  }
#line 134
  return (result);
  ERROR1: 
  {
#line 136
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Column Reference failed");
  }
#line 137
  if (length) {
#line 138
    *length = 0;
  }
#line 139
  if (status) {
#line 140
    if (res) {
#line 140
      *status = res;
    } else {
#line 140
      *status = -2;
    }
  }
#line 141
  return (result);
}
}
#line 144 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_sheet.c"
static psiconv_sheet_cell_block_t psiconv_read_var_cellblock___3(psiconv_config const   config ,
                                                                 psiconv_buffer const   buf ,
                                                                 int lev , psiconv_u32 off ,
                                                                 int *length , int *status ) 
{ 
  int len ;
  int res ;
  psiconv_sheet_cell_block_t result ;
  psiconv_u32 temp ;
  psiconv_u8 tmp ;

  {
  {
#line 150
  len = 0;
#line 155
  psiconv_progress((psiconv_config )config, lev + 1, off + (psiconv_u32 )len, "Going to read a sheet cell block reference");
#line 156
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the initial byte (%02x expected)",
                   0);
#line 158
  tmp = psiconv_read_u8(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 158
  temp = (psiconv_u32 )tmp;
  }
#line 159
  if (res) {
#line 160
    goto ERROR1;
  }
#line 161
  if (temp != 0U) {
    {
#line 162
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet cell reference initial byte unknown value (ignored)");
#line 164
    psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Initial byte: %02x",
                  temp);
    }
  }
  {
#line 166
  len ++;
#line 168
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 169
  if (res) {
#line 170
    goto ERROR1;
  }
#line 171
  if (temp & 4294901760U) {
    {
#line 172
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet block initial row reference to unknown row (reset)");
    }
  }
  {
#line 175
  result.first.row.offset = (psiconv_s16 )temp;
#line 176
  result.first.row.absolute = (psiconv_bool_t )1;
#line 177
  len += 4;
#line 179
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 180
  if (res) {
#line 181
    goto ERROR1;
  }
#line 182
  if (temp & 4294901760U) {
    {
#line 183
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet block initial column reference to unknown row (reset)");
    }
  }
  {
#line 186
  result.first.column.offset = (psiconv_s16 )temp;
#line 187
  result.first.column.absolute = (psiconv_bool_t )1;
#line 188
  len += 4;
#line 190
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 191
  if (res) {
#line 192
    goto ERROR1;
  }
#line 193
  if (temp & 4294901760U) {
    {
#line 194
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet block final row reference to unknown row (reset)");
    }
  }
  {
#line 197
  result.last.row.offset = (psiconv_s16 )temp;
#line 198
  result.last.row.absolute = (psiconv_bool_t )1;
#line 199
  len += 4;
#line 201
  temp = psiconv_read_u32(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
  }
#line 202
  if (res) {
#line 203
    goto ERROR1;
  }
#line 204
  if (temp & 4294901760U) {
    {
#line 205
    psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Sheet block final column reference to unknown row (reset)");
    }
  }
#line 208
  result.last.column.offset = (psiconv_s16 )temp;
#line 209
  result.last.column.absolute = (psiconv_bool_t )1;
#line 210
  len += 4;
#line 212
  if (length) {
#line 213
    *length = len;
  }
  {
#line 215
  psiconv_progress((psiconv_config )config, lev, (off + (psiconv_u32 )len) - 1U, "End of sheet cell block reference (total length: %08x)",
                   len);
  }
#line 218
  return (result);
  ERROR1: 
  {
#line 220
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Sheet Cell Block Reference failed");
  }
#line 221
  if (length) {
#line 222
    *length = 0;
  }
#line 223
  if (status) {
#line 224
    if (res) {
#line 224
      *status = res;
    } else {
#line 224
      *status = -2;
    }
  }
#line 225
  return (result);
}
}
#line 34 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_simple.c"
static int psiconv_write_string_aux___3(psiconv_config const   config , psiconv_buffer buf ,
                                        int lev , psiconv_string_t const   value ,
                                        int kind ) ;
#line 222 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_simple.c"
static int psiconv_write_string_aux___3(psiconv_config const   config , psiconv_buffer buf ,
                                        int lev , psiconv_string_t const   value ,
                                        int kind ) 
{ 
  int res ;
  int i ;
  int len ;
  char *printable ;

  {
  {
#line 228
  len = psiconv_unicode_strlen((psiconv_ucs2 const   *)value);
  }
#line 229
  if (! value) {
    {
#line 230
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "NULL string");
    }
#line 231
    return (-4);
  }
  {
#line 234
  printable = psiconv_make_printable(config, value);
  }
#line 234
  if (! printable) {
    {
#line 235
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Out of memory error");
    }
#line 236
    return (-2);
  }
  {
#line 238
  psiconv_debug((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Value: %s", printable);
#line 239
  free((void *)printable);
  }
#line 241
  if (kind == -1) {
    {
#line 242
    res = psiconv_write_S(config, buf, lev + 2, (psiconv_u32 const   )len);
    }
  } else
#line 243
  if (kind == -2) {
    {
#line 244
    res = psiconv_write_u8(config, buf, lev + 2, (psiconv_u8 const   )len);
    }
  } else {
#line 246
    res = 0;
  }
#line 247
  if (res) {
#line 248
    return (res);
  }
#line 250
  i = 0;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (i < len)) {
#line 250
      goto while_break;
    }
    {
#line 251
    res = psiconv_unicode_write_char(config, buf, lev + 2, *(value + i));
    }
#line 251
    if (res) {
#line 252
      return (res);
    }
#line 250
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  return (0);
}
}
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
static int psiconv_parse_layout_section___3(psiconv_config const   config , psiconv_buffer const   buf ,
                                            int lev , psiconv_u32 off , int *length ,
                                            psiconv_text_and_layout result , psiconv_word_styles_section styles___1 ,
                                            int with_styles ) ;
#line 40
static psiconv_file_type_t psiconv_determine_embedded_object_type___3(psiconv_config const   config ,
                                                                      psiconv_buffer const   buf ,
                                                                      int lev , int *status ) ;
#line 391 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
static int psiconv_parse_layout_section___3(psiconv_config const   config , psiconv_buffer const   buf ,
                                            int lev , psiconv_u32 off , int *length ,
                                            psiconv_text_and_layout result , psiconv_word_styles_section styles___1 ,
                                            int with_styles ) 
{ 
  int res ;
  int len ;
  psiconv_u32 temp ;
  int parse_styles ;
  int nr ;
  int i ;
  int j ;
  int total ;
  int leng ;
  int line_length ;
  anon_style_list anon_styles ;
  struct anon_style_s anon ;
  anon_style anon_ptr ;
  psiconv_character_layout temp_char ;
  psiconv_paragraph_layout temp_para ;
  psiconv_word_style temp_style ;
  psiconv_paragraph para ;
  struct psiconv_in_line_layout_s in_line ;
  int *inline_count ;
  psiconv_u16 tmp ;
  psiconv_u8 tmp___0 ;
  psiconv_u32 tmp___1 ;
  psiconv_u8 tmp___2 ;
  psiconv_u32 tmp___3 ;
  psiconv_u32 tmp___4 ;
  psiconv_u32 tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  psiconv_in_line_layouts tmp___8 ;
  psiconv_character_layout tmp___9 ;
  psiconv_paragraph_layout tmp___10 ;
  psiconv_u32 tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  psiconv_u8 tmp___15 ;
  void *tmp___16 ;
  psiconv_u32 tmp___17 ;
  psiconv_u32 tmp___18 ;
  psiconv_u8 tmp___19 ;
  psiconv_u32 tmp___20 ;
  psiconv_u32 tmp___21 ;
  void *tmp___22 ;
  psiconv_u8 tmp___23 ;
  psiconv_u32 tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  psiconv_u32 tmp___27 ;
  void *tmp___28 ;
  psiconv_u32 tmp___29 ;
  void *tmp___30 ;
  psiconv_u32 tmp___31 ;

  {
  {
#line 399
  res = 0;
#line 400
  len = 0;
#line 416
  anon_ptr = (anon_style )((void *)0);
#line 427
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to read the layout section");
#line 429
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the section type");
#line 430
  tmp = psiconv_read_u16(config, buf, lev + 2, off + (psiconv_u32 )len, & res);
#line 430
  temp = (psiconv_u32 )tmp;
  }
#line 431
  if (res) {
#line 432
    goto ERROR1;
  }
  {
#line 433
  psiconv_debug((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Type: %02x",
                temp);
#line 434
  parse_styles = with_styles;
  }
#line 435
  if (temp == 1U) {
#line 435
    if (! with_styles) {
      {
#line 436
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Styleless layout section expected, but styled section found!");
#line 438
      parse_styles = 1;
      }
    } else {
#line 435
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 439
  if (temp == 0U) {
#line 439
    if (with_styles) {
      {
#line 440
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Styled layout section expected, but styleless section found!");
#line 442
      parse_styles = 0;
      }
    } else {
#line 439
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 443
  if (temp != 0U) {
#line 443
    if (temp != 1U) {
      {
#line 444
      psiconv_warn((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Layout section type indicator has unknown value!");
      }
    }
  }
  {
#line 447
  len += 2;
#line 449
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read paragraph type list");
#line 450
  anon_styles = psiconv_list_new(sizeof(anon));
  }
#line 450
  if (! anon_styles) {
#line 451
    goto ERROR1;
  }
  {
#line 452
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read paragraph type list length");
#line 453
  tmp___0 = psiconv_read_u8(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
#line 453
  nr = (int )tmp___0;
  }
#line 454
  if (res) {
#line 455
    goto ERROR2;
  }
  {
#line 456
  psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Length: %02x",
                nr);
#line 457
  len ++;
#line 459
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the paragraph type list elements");
#line 461
  i = 0;
  }
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    if (! (i < nr)) {
#line 461
      goto while_break;
    }
    {
#line 462
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Element %d",
                     i);
#line 463
    tmp___1 = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
#line 463
    anon.nr = (int )tmp___1;
    }
#line 464
    if (res) {
#line 465
      goto ERROR3;
    }
    {
#line 466
    psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Number: %08x",
                  anon.nr);
#line 467
    len += 4;
#line 469
    psiconv_progress((psiconv_config )config, lev + 4, off, "Going to determine the base style");
    }
#line 470
    if (parse_styles) {
      {
#line 471
      temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
      }
#line 472
      if (res) {
#line 473
        goto ERROR3;
      }
      {
#line 474
      tmp___2 = psiconv_read_u8(config, buf, lev + 3, ((off + (psiconv_u32 )len) + 4U) + temp,
                                & res);
#line 474
      anon.base_style = (psiconv_s16 )tmp___2;
      }
#line 475
      if (res) {
#line 476
        goto ERROR3;
      }
      {
#line 477
      psiconv_debug((psiconv_config )config, lev + 4, (off + (psiconv_u32 )len) + temp,
                    "Style indicator: %02x", (int )anon.base_style);
      }
    } else {
#line 480
      anon.base_style = (psiconv_s16 )0;
    }
    {
#line 481
    temp_style = psiconv_get_style(styles___1, (int )anon.base_style);
    }
#line 481
    if (! temp_style) {
      {
#line 482
      psiconv_warn((psiconv_config )config, lev + 4, off, "Unknown Style referenced");
#line 483
      temp_style = psiconv_get_style(styles___1, (int )anon.base_style);
      }
#line 483
      if (! temp_style) {
        {
#line 484
        psiconv_warn((psiconv_config )config, lev + 4, off, "Base style unknown");
        }
#line 485
        goto ERROR3;
      }
    }
    {
#line 488
    anon.paragraph = psiconv_clone_paragraph_layout(temp_style->paragraph);
    }
#line 488
    if (! anon.paragraph) {
#line 490
      goto ERROR3;
    }
    {
#line 491
    anon.character = psiconv_clone_character_layout(temp_style->character);
    }
#line 491
    if (! anon.character) {
#line 493
      goto ERROR3_1;
    }
    {
#line 495
    psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to read the paragraph layout");
#line 496
    res = psiconv_parse_paragraph_layout_list(config, buf, lev + 4, off + (psiconv_u32 )len,
                                              & leng, anon.paragraph);
    }
#line 496
    if (res) {
#line 498
      goto ERROR3_2;
    }
#line 499
    len += leng;
#line 500
    if (parse_styles) {
#line 501
      len ++;
    }
    {
#line 503
    psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to read the character layout");
#line 504
    res = psiconv_parse_character_layout_list(config, buf, lev + 4, off + (psiconv_u32 )len,
                                              & leng, anon.character);
    }
#line 504
    if (res) {
#line 506
      goto ERROR3_2;
    }
    {
#line 507
    len += leng;
#line 508
    res = psiconv_list_add(anon_styles, (void const   *)(& anon));
    }
#line 508
    if (res) {
#line 509
      goto ERROR3_2;
    }
#line 461
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 512
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to parse the paragraph element list");
#line 513
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the number of paragraphs");
#line 514
  tmp___3 = psiconv_read_u32(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
#line 514
  nr = (int )tmp___3;
  }
#line 515
  if (res) {
#line 516
    goto ERROR3;
  }
  {
#line 517
  tmp___5 = psiconv_list_length((psiconv_list const   )result);
  }
#line 517
  if ((psiconv_u32 )nr != tmp___5) {
    {
#line 518
    psiconv_warn((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Number of text paragraphs and paragraph elements does not match");
#line 520
    tmp___4 = psiconv_list_length((psiconv_list const   )result);
#line 520
    psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "%d text paragraphs, %d paragraph elements",
                  tmp___4, nr);
    }
  }
  {
#line 524
  psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Number of paragraphs: %d",
                nr);
#line 525
  len += 4;
#line 526
  tmp___6 = malloc((unsigned long )nr * sizeof(*inline_count));
#line 526
  inline_count = (int *)tmp___6;
  }
#line 526
  if (! inline_count) {
#line 527
    goto ERROR3;
  }
  {
#line 529
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the paragraph elements");
#line 530
  i = 0;
  }
  {
#line 530
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 530
    if (! (i < nr)) {
#line 530
      goto while_break___0;
    }
    {
#line 531
    psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Element %d",
                     i);
#line 532
    tmp___11 = psiconv_list_length((psiconv_list const   )result);
    }
#line 532
    if ((psiconv_u32 )i >= tmp___11) {
      {
#line 533
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to allocate a new element");
#line 534
      tmp___7 = malloc(sizeof(*para));
#line 534
      para = (psiconv_paragraph )tmp___7;
      }
#line 534
      if (! para) {
#line 535
        goto ERROR4;
      }
      {
#line 536
      tmp___8 = psiconv_list_new(sizeof(struct psiconv_in_line_layout_s ));
#line 536
      para->in_lines = tmp___8;
      }
#line 536
      if (! tmp___8) {
#line 538
        goto ERROR4_1;
      }
      {
#line 539
      para->base_style = (psiconv_s16 )0;
#line 540
      tmp___9 = psiconv_basic_character_layout();
#line 540
      para->base_character = tmp___9;
      }
#line 540
      if (! tmp___9) {
#line 541
        goto ERROR4_2;
      }
      {
#line 542
      tmp___10 = psiconv_basic_paragraph_layout();
#line 542
      para->base_paragraph = tmp___10;
      }
#line 542
      if (! tmp___10) {
#line 543
        goto ERROR4_3;
      }
      {
#line 544
      res = psiconv_list_add(result, (void const   *)para);
      }
#line 544
      if (res) {
#line 545
        goto ERROR4_4;
      }
      {
#line 546
      free((void *)para);
      }
    }
    {
#line 548
    tmp___12 = psiconv_list_get((psiconv_list const   )result, (psiconv_u32 )i);
#line 548
    para = (psiconv_paragraph )tmp___12;
    }
#line 548
    if (! para) {
#line 549
      goto ERROR4;
    }
    {
#line 551
    psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to read the paragraph length");
#line 552
    temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
    }
#line 553
    if (res) {
#line 554
      goto ERROR4;
    }
    {
#line 555
    tmp___14 = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
    }
#line 555
    if (temp != (psiconv_u32 )(tmp___14 + 1)) {
      {
#line 556
      psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Disagreement of the length of paragraph in layout section");
#line 558
      tmp___13 = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
#line 558
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Paragraph length: layout section says %d, counted %d",
                    temp, tmp___13 + 1);
      }
    } else {
      {
#line 562
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Paragraph length: %d",
                    temp);
      }
    }
    {
#line 563
    len += 4;
#line 565
    psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Going to read the paragraph type");
#line 566
    tmp___15 = psiconv_read_u8(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
#line 566
    temp = (psiconv_u32 )tmp___15;
    }
#line 567
    if (res) {
#line 568
      goto ERROR4;
    }
#line 569
    if (temp != 0U) {
      {
#line 570
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Type: %02x",
                    temp);
#line 571
      j = 0;
      }
      {
#line 571
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 571
        tmp___17 = psiconv_list_length((psiconv_list const   )anon_styles);
        }
#line 571
        if (! ((psiconv_u32 )j < tmp___17)) {
#line 571
          goto while_break___1;
        }
        {
#line 572
        tmp___16 = psiconv_list_get((psiconv_list const   )anon_styles, (psiconv_u32 )j);
#line 572
        anon_ptr = (anon_style )tmp___16;
        }
#line 572
        if (! anon_ptr) {
          {
#line 573
          psiconv_error((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Data structure corruption");
          }
#line 574
          goto ERROR4;
        }
#line 576
        if (temp == (psiconv_u32 )anon_ptr->nr) {
#line 577
          goto while_break___1;
        }
#line 571
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 579
      tmp___18 = psiconv_list_length((psiconv_list const   )anon_styles);
      }
#line 579
      if ((psiconv_u32 )j == tmp___18) {
        {
#line 580
        psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Layout section paragraph type unknown");
#line 581
        psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Unknown type - using base styles instead");
#line 582
        para->base_style = (psiconv_s16 )0;
#line 583
        temp_style = psiconv_get_style(styles___1, 0);
        }
#line 583
        if (! temp_style) {
          {
#line 584
          psiconv_error((psiconv_config )config, lev + 4, off, "Base style unknown");
          }
#line 585
          goto ERROR4;
        }
        {
#line 587
        temp_para = psiconv_clone_paragraph_layout(temp_style->paragraph);
        }
#line 587
        if (! temp_para) {
#line 589
          goto ERROR4;
        }
        {
#line 590
        psiconv_free_paragraph_layout(para->base_paragraph);
#line 591
        para->base_paragraph = temp_para;
#line 593
        temp_char = psiconv_clone_character_layout(temp_style->character);
        }
#line 593
        if (! temp_char) {
#line 595
          goto ERROR4;
        }
        {
#line 596
        psiconv_free_character_layout(para->base_character);
#line 597
        para->base_character = temp_char;
        }
      } else {
        {
#line 599
        para->base_style = anon_ptr->base_style;
#line 600
        temp_para = psiconv_clone_paragraph_layout(anon_ptr->paragraph);
        }
#line 600
        if (! temp_para) {
#line 601
          goto ERROR4;
        }
        {
#line 602
        psiconv_free_paragraph_layout(para->base_paragraph);
#line 603
        para->base_paragraph = temp_para;
#line 605
        temp_char = psiconv_clone_character_layout(anon_ptr->character);
        }
#line 605
        if (! temp_char) {
#line 606
          goto ERROR4;
        }
        {
#line 607
        psiconv_free_character_layout(para->base_character);
#line 608
        para->base_character = temp_char;
        }
      }
#line 610
      *(inline_count + i) = 0;
#line 611
      len ++;
    } else {
      {
#line 613
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Type: %02x (not based on a paragraph type)",
                    temp);
#line 615
      len ++;
      }
#line 616
      if (parse_styles) {
        {
#line 617
        temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
        }
#line 618
        if (res) {
#line 619
          goto ERROR4;
        }
        {
#line 620
        psiconv_progress((psiconv_config )config, lev + 4, ((off + (psiconv_u32 )len) + temp) + 4U,
                         "Going to read the paragraph element base style");
#line 622
        tmp___19 = psiconv_read_u8(config, buf, lev + 4, ((off + (psiconv_u32 )len) + temp) + 4U,
                                   & res);
#line 622
        temp = (psiconv_u32 )tmp___19;
        }
#line 623
        if (res) {
#line 624
          goto ERROR4;
        }
        {
#line 625
        psiconv_debug((psiconv_config )config, lev + 4, ((off + (psiconv_u32 )len) + temp) + 4U,
                      "Style: %02x", temp);
        }
      } else {
#line 627
        temp = (psiconv_u32 )0;
      }
      {
#line 629
      temp_style = psiconv_get_style(styles___1, (int )temp);
      }
#line 629
      if (! temp_style) {
        {
#line 630
        psiconv_warn((psiconv_config )config, lev + 4, off, "Unknown Style referenced");
#line 631
        temp_style = psiconv_get_style(styles___1, 0);
        }
#line 631
        if (! temp_style) {
          {
#line 632
          psiconv_error((psiconv_config )config, lev + 4, off, "Base style unknown");
          }
#line 633
          goto ERROR4;
        }
      }
      {
#line 637
      temp_para = psiconv_clone_paragraph_layout(temp_style->paragraph);
      }
#line 637
      if (! temp_para) {
#line 638
        goto ERROR4;
      }
      {
#line 639
      psiconv_free_paragraph_layout(para->base_paragraph);
#line 640
      para->base_paragraph = temp_para;
#line 642
      temp_char = psiconv_clone_character_layout(temp_style->character);
      }
#line 642
      if (! temp_char) {
#line 643
        goto ERROR4;
      }
      {
#line 644
      psiconv_free_character_layout(para->base_character);
#line 645
      para->base_character = temp_char;
#line 647
      para->base_style = (psiconv_s16 )temp;
#line 648
      psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                       "Going to read paragraph layout");
#line 649
      res = psiconv_parse_paragraph_layout_list(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                & leng, para->base_paragraph);
      }
#line 649
      if (res) {
#line 651
        goto ERROR4;
      }
#line 652
      len += leng;
#line 653
      if (parse_styles) {
#line 654
        len ++;
      }
      {
#line 655
      psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                       "Going to read number of in-line layout elements");
#line 657
      tmp___20 = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
#line 657
      *(inline_count + i) = (int )tmp___20;
      }
#line 658
      if (res) {
#line 659
        goto ERROR4;
      }
      {
#line 660
      psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Nr: %08x",
                    *(inline_count + i));
#line 661
      len += 4;
      }
    }
#line 530
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 665
  psiconv_progress((psiconv_config )config, lev + 2, off + (psiconv_u32 )len, "Going to read the text layout inline list");
#line 667
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the number of elements");
#line 668
  tmp___21 = psiconv_read_u32(config, buf, lev + 3, off + (psiconv_u32 )len, & res);
#line 668
  nr = (int )tmp___21;
  }
#line 669
  if (res) {
#line 670
    goto ERROR4;
  }
  {
#line 671
  psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Elements: %08x",
                nr);
#line 672
  len += 4;
#line 674
  psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Going to read the text layout inline elements");
#line 676
  total = 0;
#line 677
  i = 0;
  }
  {
#line 677
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 677
    tmp___27 = psiconv_list_length((psiconv_list const   )result);
    }
#line 677
    if (! ((psiconv_u32 )i < tmp___27)) {
#line 677
      goto while_break___2;
    }
    {
#line 678
    tmp___22 = psiconv_list_get((psiconv_list const   )result, (psiconv_u32 )i);
#line 678
    para = (psiconv_paragraph )tmp___22;
    }
#line 678
    if (! para) {
      {
#line 679
      psiconv_error((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Data structure corruption");
      }
#line 680
      goto ERROR4;
    }
#line 682
    line_length = -1;
#line 683
    j = 0;
    {
#line 683
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 683
      if (! (j < *(inline_count + i))) {
#line 683
        goto while_break___3;
      }
      {
#line 684
      psiconv_progress((psiconv_config )config, lev + 3, off + (psiconv_u32 )len,
                       "Element %d: Paragraph %d, element %d", total, i, j);
      }
#line 686
      if (total >= nr) {
        {
#line 687
        psiconv_warn((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Layout section inlines: not enough element");
#line 689
        psiconv_debug((psiconv_config )config, lev + 3, off + (psiconv_u32 )len, "Can\'t read element!");
        }
      } else {
        {
#line 691
        total ++;
#line 692
        in_line.object = (psiconv_embedded_object_section )((void *)0);
#line 693
        in_line.layout = (psiconv_character_layout )((void *)0);
#line 694
        in_line.layout = psiconv_clone_character_layout(para->base_character);
        }
#line 694
        if (! in_line.layout) {
#line 696
          goto ERROR4;
        }
        {
#line 697
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read the element type");
#line 698
        tmp___23 = psiconv_read_u8(config, buf, lev + 4, (psiconv_u32 )len + off,
                                   & res);
#line 698
        temp = (psiconv_u32 )tmp___23;
        }
#line 699
        if (res) {
#line 700
          goto ERROR5;
        }
        {
#line 701
        len ++;
#line 702
        psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Type: %02x",
                      temp);
#line 703
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read the number of characters it applies to");
#line 705
        tmp___24 = psiconv_read_u32(config, buf, lev + 4, (psiconv_u32 )len + off,
                                    & res);
#line 705
        in_line.length = (int )tmp___24;
        }
#line 706
        if (res) {
#line 707
          goto ERROR5;
        }
        {
#line 708
        psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Length: %02x",
                      in_line.length);
#line 709
        len += 4;
#line 710
        psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Going to read the character layout");
#line 711
        res = psiconv_parse_character_layout_list(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                  & leng, in_line.layout);
        }
#line 711
        if (res) {
#line 713
          goto ERROR5;
        }
#line 714
        len += leng;
#line 716
        if (temp == 1U) {
          {
#line 717
          psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Found an embedded object");
#line 718
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to read the object marker (0x%08x expected)", 268435537);
#line 720
          temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
          }
#line 721
          if (res) {
#line 722
            goto ERROR5;
          }
#line 723
          if (temp != 268435537U) {
            {
#line 724
            psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                         "Unknown id marks embedded object");
#line 725
            psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                          "Marker: read %08x, expected %08x", temp, 268435537);
            }
          }
          {
#line 728
          len += 4;
#line 729
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to read the Embedded Object Section offset");
#line 731
          temp = psiconv_read_u32(config, buf, lev + 4, off + (psiconv_u32 )len, & res);
          }
#line 732
          if (res) {
#line 733
            goto ERROR5;
          }
          {
#line 734
          psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Offset: %08x", temp);
#line 735
          len += 4;
#line 736
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to parse the Embedded Object Section");
#line 738
          res = psiconv_parse_embedded_object_section(config, buf, lev + 4, temp,
                                                      (int *)((void *)0), & in_line.object);
          }
#line 738
          if (res) {
#line 740
            goto ERROR5;
          }
          {
#line 741
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to read the object width");
#line 743
          in_line.object_width = psiconv_read_length(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                     & leng, & res);
          }
#line 745
          if (res) {
#line 746
            goto ERROR5;
          }
          {
#line 747
          psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Object width: %f cm", (double )in_line.object_width);
#line 749
          len += leng;
#line 750
          psiconv_progress((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                           "Going to read the object height");
#line 752
          in_line.object_height = psiconv_read_length(config, buf, lev + 4, off + (psiconv_u32 )len,
                                                      & leng, & res);
          }
#line 754
          if (res) {
#line 755
            goto ERROR5;
          }
          {
#line 756
          psiconv_debug((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                        "Object height: %f cm", (double )in_line.object_height);
#line 758
          len += leng;
          }
        } else
#line 759
        if (temp != 0U) {
          {
#line 760
          psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                       "Layout section unknown inline type");
          }
        }
        {
#line 762
        tmp___26 = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
        }
#line 762
        if (line_length + in_line.length > tmp___26) {
          {
#line 763
          psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len,
                       "Layout section inlines: line length mismatch");
#line 765
          res = -1;
#line 766
          tmp___25 = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
#line 766
          in_line.length = tmp___25 - line_length;
          }
        }
        {
#line 768
        line_length += in_line.length;
#line 769
        res = psiconv_list_add(para->in_lines, (void const   *)(& in_line));
        }
#line 769
        if (res) {
#line 770
          goto ERROR5;
        }
      }
#line 683
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 677
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 775
  if (total != nr) {
    {
#line 776
    psiconv_warn((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Layout section too many inlines, skipping remaining");
    }
  }
  {
#line 780
  free((void *)inline_count);
#line 782
  i = 0;
  }
  {
#line 782
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 782
    tmp___29 = psiconv_list_length((psiconv_list const   )anon_styles);
    }
#line 782
    if (! ((psiconv_u32 )i < tmp___29)) {
#line 782
      goto while_break___4;
    }
    {
#line 783
    tmp___28 = psiconv_list_get((psiconv_list const   )anon_styles, (psiconv_u32 )i);
#line 783
    anon_ptr = (anon_style )tmp___28;
    }
#line 783
    if (! anon_ptr) {
      {
#line 784
      psiconv_error((psiconv_config )config, lev + 4, off + (psiconv_u32 )len, "Data structure corruption");
      }
#line 785
      goto ERROR2;
    }
    {
#line 787
    psiconv_free_character_layout(anon_ptr->character);
#line 788
    psiconv_free_paragraph_layout(anon_ptr->paragraph);
#line 782
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 790
  psiconv_list_free(anon_styles);
  }
#line 792
  if (length) {
#line 793
    *length = len;
  }
  {
#line 795
  psiconv_progress((psiconv_config )config, lev + 1, (off + (psiconv_u32 )len) - 1U,
                   "End of layout section (total length: %08x)", len);
  }
#line 798
  return (0);
  ERROR4_4: 
  {
#line 801
  psiconv_free_paragraph_layout(para->base_paragraph);
  }
  ERROR4_3: 
  {
#line 803
  psiconv_free_character_layout(para->base_character);
  }
  ERROR4_2: 
  {
#line 805
  psiconv_list_free(para->in_lines);
  }
  ERROR4_1: 
  {
#line 807
  free((void *)para);
  }
#line 808
  goto ERROR4;
  ERROR3_2: 
  {
#line 811
  psiconv_free_character_layout(anon.character);
  }
  ERROR3_1: 
  {
#line 813
  psiconv_free_paragraph_layout(anon.paragraph);
  }
#line 814
  goto ERROR3;
  ERROR5: 
#line 817
  if (in_line.layout) {
    {
#line 818
    psiconv_free_character_layout(in_line.layout);
    }
  }
#line 819
  if (in_line.object) {
    {
#line 820
    psiconv_free_embedded_object_section(in_line.object);
    }
  }
  ERROR4: 
  {
#line 822
  free((void *)inline_count);
  }
  ERROR3: 
#line 824
  i = 0;
  {
#line 824
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 824
    tmp___31 = psiconv_list_length((psiconv_list const   )anon_styles);
    }
#line 824
    if (! ((psiconv_u32 )i < tmp___31)) {
#line 824
      goto while_break___5;
    }
    {
#line 825
    tmp___30 = psiconv_list_get((psiconv_list const   )anon_styles, (psiconv_u32 )i);
#line 825
    anon_ptr = (anon_style )tmp___30;
    }
#line 825
    if (! anon_ptr) {
      {
#line 826
      psiconv_error((psiconv_config )config, lev + 1, off, "Data structure corruption");
      }
#line 827
      goto while_break___5;
    }
    {
#line 829
    psiconv_free_paragraph_layout(anon_ptr->paragraph);
#line 830
    psiconv_free_character_layout(anon_ptr->character);
#line 824
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  ERROR2: 
  {
#line 834
  psiconv_list_free(anon_styles);
  }
  ERROR1: 
  {
#line 836
  psiconv_error((psiconv_config )config, lev + 1, off, "Reading of Layout Section failed");
  }
#line 837
  if (length) {
#line 838
    *length = 0;
  }
#line 839
  if (! res) {
#line 840
    return (-2);
  } else {
#line 842
    return (res);
  }
}
}
#line 1063 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_common.c"
static psiconv_file_type_t psiconv_determine_embedded_object_type___3(psiconv_config const   config ,
                                                                      psiconv_buffer const   buf ,
                                                                      int lev , int *status ) 
{ 
  psiconv_u32 off ;
  psiconv_section_table_section table ;
  int res ;
  int i ;
  psiconv_file_type_t file_type ;
  psiconv_section_table_entry entry ;
  psiconv_application_id_section applid ;
  void *tmp ;
  psiconv_u32 tmp___0 ;
  psiconv_u32 tmp___1 ;

  {
  {
#line 1071
  file_type = (psiconv_file_type_t )0;
#line 1075
  psiconv_progress((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Going to determine embedded object file type");
#line 1076
  psiconv_progress((psiconv_config )config, lev + 2, (psiconv_u32 )0, "Going to read the Section Table Offset Section");
#line 1077
  off = psiconv_read_u32(config, buf, lev, (psiconv_u32 )0, & res);
  }
#line 1078
  if (res) {
#line 1079
    goto ERROR1;
  }
  {
#line 1080
  psiconv_debug((psiconv_config )config, lev + 2, (psiconv_u32 )0, "Offset: %08x",
                off);
#line 1082
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the Section Table Section");
#line 1083
  res = psiconv_parse_section_table_section(config, buf, lev + 2, off, (int *)((void *)0),
                                            & table);
  }
#line 1083
  if (res) {
#line 1084
    goto ERROR1;
  }
  {
#line 1086
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to search the Section Table Section for the Application ID Section");
#line 1088
  i = 0;
  }
  {
#line 1088
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1088
    tmp___0 = psiconv_list_length((psiconv_list const   )table);
    }
#line 1088
    if (! ((psiconv_u32 )i < tmp___0)) {
#line 1088
      goto while_break;
    }
    {
#line 1089
    psiconv_progress((psiconv_config )config, lev + 3, off, "Going to read entry %d",
                     i);
#line 1090
    tmp = psiconv_list_get((psiconv_list const   )table, (psiconv_u32 )i);
#line 1090
    entry = (psiconv_section_table_entry )tmp;
    }
#line 1090
    if (! entry) {
#line 1091
      goto ERROR2;
    }
#line 1092
    if (entry->id == 268435593U) {
      {
#line 1093
      psiconv_progress((psiconv_config )config, lev + 3, off, "Found the Application ID Section at offset %08x",
                       entry->offset);
#line 1096
      off = entry->offset;
      }
#line 1097
      goto while_break;
    }
#line 1088
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1100
  tmp___1 = psiconv_list_length((psiconv_list const   )table);
  }
#line 1100
  if ((psiconv_u32 )i == tmp___1) {
    {
#line 1101
    psiconv_error((psiconv_config )config, lev + 2, off, "No Application ID Section found");
#line 1102
    res = 3;
    }
#line 1103
    goto ERROR2;
  }
  {
#line 1106
  psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read the Application ID Section");
#line 1107
  res = psiconv_parse_application_id_section(config, buf, lev + 2, off, (int *)((void *)0),
                                             & applid);
  }
#line 1107
  if (res) {
#line 1108
    goto ERROR2;
  }
  {
#line 1111
  if (applid->id == 268435583U) {
#line 1111
    goto case_268435583;
  }
#line 1114
  if (applid->id == 268435589U) {
#line 1114
    goto case_268435589;
  }
#line 1117
  if (applid->id == 268435581U) {
#line 1117
    goto case_268435581;
  }
#line 1120
  if (applid->id == 268435592U) {
#line 1120
    goto case_268435592;
  }
#line 1123
  goto switch_default;
  case_268435583: /* CIL Label */ 
  {
#line 1111
  file_type = (psiconv_file_type_t )1;
#line 1112
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found a Word file");
  }
#line 1113
  goto switch_break;
  case_268435589: /* CIL Label */ 
  {
#line 1114
  file_type = (psiconv_file_type_t )2;
#line 1115
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found a TextEd file");
  }
#line 1116
  goto switch_break;
  case_268435581: /* CIL Label */ 
  {
#line 1117
  file_type = (psiconv_file_type_t )4;
#line 1118
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found a Sketch file");
  }
#line 1119
  goto switch_break;
  case_268435592: /* CIL Label */ 
  {
#line 1120
  file_type = (psiconv_file_type_t )6;
#line 1121
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found a Sheet file");
  }
#line 1122
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1123
  psiconv_warn((psiconv_config )config, lev + 2, off, "Found an unknown file type");
#line 1124
  psiconv_debug((psiconv_config )config, lev + 2, off, "Found ID %08x", applid->id);
  }
  switch_break: /* CIL Label */ ;
  }
  ERROR2: 
  {
#line 1128
  psiconv_free_application_id_section(applid);
  }
  ERROR1: 
  {
#line 1130
  psiconv_free_section_table_section(table);
  }
#line 1131
  if (status) {
#line 1132
    *status = res;
  }
#line 1133
  return (file_type);
}
}
#line 32 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_common.c"
static int psiconv_write_layout_section___3(psiconv_config const   config , psiconv_buffer buf ,
                                            int lev , psiconv_text_and_layout const   value ,
                                            psiconv_word_styles_section const   styles___1 ,
                                            int with_styles ) ;
#line 166 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/generate_common.c"
static int psiconv_write_layout_section___3(psiconv_config const   config , psiconv_buffer buf ,
                                            int lev , psiconv_text_and_layout const   value ,
                                            psiconv_word_styles_section const   styles___1 ,
                                            int with_styles ) 
{ 
  psiconv_u32 obj_id ;
  psiconv_list paragraph_type_list ;
  psiconv_paragraph_type_list paragraph_type ;
  struct psiconv_paragraph_type_list_s new_type ;
  psiconv_buffer buf_types ;
  psiconv_buffer buf_elements ;
  psiconv_buffer buf_inlines ;
  psiconv_buffer buf_objects ;
  psiconv_paragraph paragraph___3 ;
  psiconv_in_line_layout in_line ;
  psiconv_word_style style___1 ;
  psiconv_character_layout para_charlayout ;
  int i ;
  int j ;
  int para_type ;
  int nr_of_inlines ;
  int res ;
  int ptl_length ;
  int pel_length ;
  int thislen ;
  int paralen ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  psiconv_u32 tmp___2 ;
  psiconv_u32 tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  psiconv_u32 tmp___8 ;
  psiconv_u32 tmp___9 ;
  void *tmp___10 ;
  psiconv_u32 tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  psiconv_u32 tmp___15 ;
  psiconv_u32 tmp___16 ;
  psiconv_u32 tmp___17 ;
  psiconv_u32 tmp___18 ;
  psiconv_u32 tmp___19 ;
  psiconv_u32 tmp___20 ;
  psiconv_u32 tmp___21 ;
  int tmp___22 ;

  {
  {
#line 185
  in_line = (psiconv_in_line_layout )((void *)0);
#line 188
  nr_of_inlines = 0;
#line 190
  psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "Writing layout section");
  }
#line 191
  if (! value) {
    {
#line 192
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Null text section");
#line 193
    res = -4;
    }
#line 194
    goto ERROR1;
  }
  {
#line 197
  paragraph_type_list = psiconv_list_new(sizeof(new_type));
  }
#line 197
  if (! paragraph_type_list) {
    {
#line 198
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 199
    res = -2;
    }
#line 200
    goto ERROR1;
  }
  {
#line 203
  buf_types = psiconv_buffer_new();
  }
#line 203
  if (! buf_types) {
    {
#line 204
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 205
    res = -2;
    }
#line 206
    goto ERROR2;
  }
  {
#line 209
  buf_elements = psiconv_buffer_new();
  }
#line 209
  if (! buf_elements) {
    {
#line 210
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 211
    res = -2;
    }
#line 212
    goto ERROR3;
  }
  {
#line 215
  buf_inlines = psiconv_buffer_new();
  }
#line 215
  if (! buf_inlines) {
    {
#line 216
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 217
    res = -2;
    }
#line 218
    goto ERROR4;
  }
  {
#line 221
  buf_objects = psiconv_buffer_new();
  }
#line 221
  if (! buf_objects) {
    {
#line 222
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
#line 223
    res = -2;
    }
#line 224
    goto ERROR5;
  }
#line 227
  i = 0;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 227
    tmp___18 = psiconv_list_length(value);
    }
#line 227
    if (! ((psiconv_u32 )i < tmp___18)) {
#line 227
      goto while_break;
    }
    {
#line 228
    tmp = psiconv_list_get(value, (psiconv_u32 )i);
#line 228
    paragraph___3 = (psiconv_paragraph )tmp;
    }
#line 228
    if (! paragraph___3) {
      {
#line 229
      psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Data structure corruption");
#line 230
      res = -2;
      }
#line 231
      goto ERROR6;
    }
    {
#line 233
    tmp___0 = psiconv_unicode_strlen((psiconv_ucs2 const   *)paragraph___3->text);
#line 233
    res = psiconv_write_u32(config, buf_elements, lev + 1, (psiconv_u32 const   )(tmp___0 + 1));
    }
#line 233
    if (res) {
#line 235
      goto ERROR6;
    }
    {
#line 238
    tmp___2 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
    }
#line 238
    if (tmp___2 == 1U) {
      {
#line 239
      tmp___1 = psiconv_list_get((psiconv_list const   )paragraph___3->in_lines, (psiconv_u32 )0);
#line 239
      in_line = (psiconv_in_line_layout )tmp___1;
      }
#line 239
      if (! in_line) {
        {
#line 240
        psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Data structure corruption");
#line 241
        res = -2;
        }
#line 242
        goto ERROR6;
      }
    }
    {
#line 245
    tmp___16 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
    }
#line 245
    if (tmp___16 > 1U) {
#line 245
      goto _L;
    } else {
      {
#line 245
      tmp___17 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
      }
#line 245
      if (tmp___17 == 1U) {
#line 245
        if ((unsigned long )in_line->object != (unsigned long )((void *)0)) {
          _L: /* CIL Label */ 
          {
#line 250
          res = psiconv_write_u8(config, buf_elements, lev + 1, (psiconv_u8 const   )0);
          }
#line 250
          if (res) {
#line 251
            goto ERROR6;
          }
          {
#line 252
          style___1 = psiconv_get_style((psiconv_word_styles_section )styles___1,
                                        (int )paragraph___3->base_style);
          }
#line 252
          if (! style___1) {
            {
#line 253
            psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Unknown style");
#line 254
            res = -4;
            }
#line 255
            goto ERROR6;
          }
          {
#line 257
          res = psiconv_write_paragraph_layout_list(config, buf_elements, lev + 1,
                                                    (psiconv_paragraph_layout const   )paragraph___3->base_paragraph,
                                                    (psiconv_paragraph_layout const   )style___1->paragraph);
          }
#line 257
          if (res) {
#line 260
            goto ERROR6;
          }
#line 261
          if (with_styles) {
            {
#line 262
            res = psiconv_write_u8(config, buf_elements, lev + 1, (psiconv_u8 const   )paragraph___3->base_style);
            }
#line 262
            if (res) {
#line 263
              goto ERROR6;
            }
          }
          {
#line 264
          tmp___3 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
#line 264
          res = psiconv_write_u32(config, buf_elements, lev + 1, (psiconv_u32 const   )tmp___3);
          }
#line 264
          if (res) {
#line 266
            goto ERROR6;
          }
#line 269
          paralen = 0;
#line 270
          j = 0;
          {
#line 270
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 270
            tmp___9 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
            }
#line 270
            if (! ((psiconv_u32 )j < tmp___9)) {
#line 270
              goto while_break___0;
            }
            {
#line 271
            nr_of_inlines ++;
#line 272
            tmp___4 = psiconv_list_get((psiconv_list const   )paragraph___3->in_lines,
                                       (psiconv_u32 )j);
#line 272
            in_line = (psiconv_in_line_layout )tmp___4;
            }
#line 272
            if (! in_line) {
              {
#line 273
              psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Data structure corruption");
#line 274
              res = -2;
              }
#line 275
              goto ERROR6;
            }
#line 277
            if (in_line->object) {
#line 277
              tmp___5 = 1;
            } else {
#line 277
              tmp___5 = 0;
            }
            {
#line 277
            res = psiconv_write_u8(config, buf_inlines, lev + 1, (psiconv_u8 const   )tmp___5);
            }
#line 277
            if (res) {
#line 278
              goto ERROR6;
            }
            {
#line 279
            thislen = in_line->length;
#line 280
            paralen += thislen;
#line 283
            tmp___8 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
            }
#line 283
            if ((psiconv_u32 )j == tmp___8 - 1U) {
              {
#line 284
              tmp___6 = psiconv_unicode_strlen((psiconv_ucs2 const   *)paragraph___3->text);
              }
#line 284
              if (paralen > tmp___6 + 1) {
                {
#line 285
                psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Inline formatting data length and line length are inconsistent");
#line 286
                res = -4;
                }
#line 287
                goto ERROR6;
              }
              {
#line 289
              tmp___7 = psiconv_unicode_strlen((psiconv_ucs2 const   *)paragraph___3->text);
#line 289
              thislen += (tmp___7 + 1) - paralen;
              }
            }
            {
#line 291
            res = psiconv_write_u32(config, buf_inlines, lev + 1, (psiconv_u32 const   )thislen);
            }
#line 291
            if (res) {
#line 292
              goto ERROR6;
            }
            {
#line 293
            res = psiconv_write_character_layout_list(config, buf_inlines, lev + 1,
                                                      (psiconv_character_layout const   )in_line->layout,
                                                      (psiconv_character_layout const   )style___1->character);
            }
#line 293
            if (res) {
#line 296
              goto ERROR6;
            }
#line 297
            if (in_line->object) {
              {
#line 298
              res = psiconv_write_u32(config, buf_inlines, lev + 1, (psiconv_u32 const   )268435537);
              }
#line 298
              if (res) {
#line 299
                goto ERROR6;
              }
              {
#line 300
              obj_id = psiconv_buffer_unique_id();
#line 301
              res = psiconv_buffer_add_reference(buf_inlines, (int )obj_id);
              }
#line 301
              if (res) {
                {
#line 302
                psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
                }
#line 303
                goto ERROR6;
              }
              {
#line 305
              res = psiconv_buffer_add_target(buf_objects, (int )obj_id);
              }
#line 305
              if (res) {
                {
#line 306
                psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
                }
#line 307
                goto ERROR6;
              }
              {
#line 309
              res = psiconv_write_embedded_object_section(config, buf_objects, lev + 1,
                                                          (psiconv_embedded_object_section const   )in_line->object);
              }
#line 309
              if (res) {
#line 311
                goto ERROR6;
              }
              {
#line 312
              res = psiconv_write_length(config, buf_inlines, lev + 1, (psiconv_length_t const   )in_line->object_width);
              }
#line 312
              if (res) {
#line 313
                goto ERROR6;
              }
              {
#line 314
              res = psiconv_write_length(config, buf_inlines, lev + 1, (psiconv_length_t const   )in_line->object_height);
              }
#line 314
              if (res) {
#line 315
                goto ERROR6;
              }
            }
#line 270
            j ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
#line 245
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 320
        para_type = 0;
#line 322
        tmp___11 = psiconv_list_length((psiconv_list const   )paragraph___3->in_lines);
        }
#line 322
        if (tmp___11 == 0U) {
#line 323
          para_charlayout = paragraph___3->base_character;
        } else {
          {
#line 325
          tmp___10 = psiconv_list_get((psiconv_list const   )paragraph___3->in_lines,
                                      (psiconv_u32 )0);
#line 325
          in_line = (psiconv_in_line_layout )tmp___10;
          }
#line 325
          if (! in_line) {
            {
#line 326
            psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Data structure corruption");
#line 327
            res = -2;
            }
#line 328
            goto ERROR6;
          }
#line 330
          para_charlayout = in_line->layout;
        }
#line 332
        j = 0;
        {
#line 332
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 332
          tmp___15 = psiconv_list_length((psiconv_list const   )paragraph_type_list);
          }
#line 332
          if (! ((psiconv_u32 )j < tmp___15)) {
#line 332
            goto while_break___1;
          }
          {
#line 333
          tmp___12 = psiconv_list_get((psiconv_list const   )paragraph_type_list,
                                      (psiconv_u32 )j);
#line 333
          paragraph_type = (psiconv_paragraph_type_list )tmp___12;
          }
#line 333
          if (! paragraph_type) {
            {
#line 334
            psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Data structure corruption");
#line 335
            res = -2;
            }
#line 336
            goto ERROR6;
          }
#line 338
          if ((int )paragraph___3->base_style == (int )paragraph_type->style) {
            {
#line 338
            tmp___13 = psiconv_compare_character_layout((psiconv_character_layout const   )para_charlayout,
                                                        (psiconv_character_layout const   )paragraph_type->character);
            }
#line 338
            if (! tmp___13) {
              {
#line 338
              tmp___14 = psiconv_compare_paragraph_layout((psiconv_paragraph_layout const   )paragraph___3->base_paragraph,
                                                          (psiconv_paragraph_layout const   )paragraph_type->paragraph);
              }
#line 338
              if (! tmp___14) {
#line 343
                para_type = (int )paragraph_type->nr;
#line 344
                goto while_break___1;
              }
            }
          }
#line 332
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 347
        if (! para_type) {
          {
#line 349
          new_type.nr = (psiconv_u8 )(j + 1);
#line 349
          para_type = (int )new_type.nr;
#line 351
          new_type.paragraph = paragraph___3->base_paragraph;
#line 352
          new_type.character = para_charlayout;
#line 353
          new_type.style = (psiconv_u8 )paragraph___3->base_style;
#line 354
          paragraph_type = & new_type;
#line 355
          res = psiconv_list_add(paragraph_type_list, (void const   *)paragraph_type);
          }
#line 355
          if (res) {
            {
#line 356
            psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
            }
#line 357
            goto ERROR6;
          }
          {
#line 359
          res = psiconv_write_u32(config, buf_types, lev + 1, (psiconv_u32 const   )paragraph_type->nr);
          }
#line 359
          if (res) {
#line 360
            goto ERROR6;
          }
          {
#line 361
          style___1 = psiconv_get_style((psiconv_word_styles_section )styles___1,
                                        (int )paragraph_type->style);
          }
#line 361
          if (! style___1) {
            {
#line 362
            psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Unknown style");
#line 363
            res = -4;
            }
#line 364
            goto ERROR6;
          }
          {
#line 366
          res = psiconv_write_paragraph_layout_list(config, buf_types, lev + 1, (psiconv_paragraph_layout const   )paragraph_type->paragraph,
                                                    (psiconv_paragraph_layout const   )style___1->paragraph);
          }
#line 366
          if (res) {
#line 368
            goto ERROR6;
          }
#line 369
          if (with_styles) {
            {
#line 370
            res = psiconv_write_u8(config, buf_types, lev + 1, (psiconv_u8 const   )paragraph_type->style);
            }
#line 370
            if (res) {
#line 371
              goto ERROR6;
            }
          }
          {
#line 372
          res = psiconv_write_character_layout_list(config, buf_types, lev + 1, (psiconv_character_layout const   )paragraph_type->character,
                                                    (psiconv_character_layout const   )style___1->character);
          }
#line 372
          if (res) {
#line 374
            goto ERROR6;
          }
        }
        {
#line 376
        res = psiconv_write_u8(config, buf_elements, lev + 1, (psiconv_u8 const   )para_type);
        }
#line 376
        if (res) {
#line 377
          goto ERROR6;
        }
      }
    }
#line 227
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 382
  tmp___21 = psiconv_list_length(value);
  }
#line 382
  if (tmp___21) {
    {
#line 400
    tmp___19 = psiconv_list_length(value);
#line 400
    pel_length = (int )tmp___19;
#line 401
    tmp___20 = psiconv_list_length((psiconv_list const   )paragraph_type_list);
#line 401
    ptl_length = (int )tmp___20;
    }
  } else {
    {
#line 383
    res = psiconv_write_u32(config, buf_types, lev + 1, (psiconv_u32 const   )1);
    }
#line 383
    if (res) {
#line 384
      goto ERROR6;
    }
    {
#line 385
    res = psiconv_write_u32(config, buf_types, lev + 1, (psiconv_u32 const   )0);
    }
#line 385
    if (res) {
#line 386
      goto ERROR6;
    }
#line 387
    if (with_styles) {
      {
#line 388
      res = psiconv_write_u8(config, buf_types, lev + 1, (psiconv_u8 const   )0);
      }
#line 388
      if (res) {
#line 389
        goto ERROR6;
      }
    }
    {
#line 390
    res = psiconv_write_u32(config, buf_types, lev + 1, (psiconv_u32 const   )0);
    }
#line 390
    if (res) {
#line 391
      goto ERROR6;
    }
    {
#line 393
    res = psiconv_write_u32(config, buf_elements, lev + 1, (psiconv_u32 const   )1);
    }
#line 393
    if (res) {
#line 394
      goto ERROR6;
    }
    {
#line 395
    res = psiconv_write_u8(config, buf_elements, lev + 1, (psiconv_u8 const   )1);
    }
#line 395
    if (res) {
#line 396
      goto ERROR6;
    }
#line 397
    pel_length = 1;
#line 398
    ptl_length = 1;
  }
#line 405
  if (with_styles) {
#line 405
    tmp___22 = 1;
  } else {
#line 405
    tmp___22 = 0;
  }
  {
#line 405
  res = psiconv_write_u16(config, buf, lev + 1, (psiconv_u16 const   )tmp___22);
  }
#line 405
  if (res) {
#line 406
    goto ERROR6;
  }
  {
#line 407
  res = psiconv_write_u8(config, buf, lev + 1, (psiconv_u8 const   )ptl_length);
  }
#line 407
  if (res) {
#line 408
    goto ERROR6;
  }
  {
#line 409
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )buf_types);
  }
#line 409
  if (res) {
    {
#line 410
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 411
    goto ERROR6;
  }
  {
#line 413
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )pel_length);
  }
#line 413
  if (res) {
#line 414
    goto ERROR6;
  }
  {
#line 415
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )buf_elements);
  }
#line 415
  if (res) {
    {
#line 416
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 417
    goto ERROR6;
  }
  {
#line 419
  res = psiconv_write_u32(config, buf, lev + 1, (psiconv_u32 const   )nr_of_inlines);
  }
#line 419
  if (res) {
#line 420
    goto ERROR6;
  }
  {
#line 421
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )buf_inlines);
  }
#line 421
  if (res) {
    {
#line 422
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 423
    goto ERROR6;
  }
  {
#line 425
  res = psiconv_buffer_concat(buf, (psiconv_buffer const   )buf_objects);
  }
#line 425
  if (res) {
    {
#line 426
    psiconv_error((psiconv_config )config, lev + 1, (psiconv_u32 )0, "Out of memory error");
    }
#line 427
    goto ERROR6;
  }
  ERROR6: 
  {
#line 431
  psiconv_buffer_free(buf_objects);
  }
  ERROR5: 
  {
#line 433
  psiconv_buffer_free(buf_inlines);
  }
  ERROR4: 
  {
#line 435
  psiconv_buffer_free(buf_elements);
  }
  ERROR3: 
  {
#line 437
  psiconv_buffer_free(buf_types);
  }
  ERROR2: 
  {
#line 439
  psiconv_list_free(paragraph_type_list);
  }
  ERROR1: 
#line 441
  if (res) {
    {
#line 442
    psiconv_error((psiconv_config )config, lev, (psiconv_u32 )0, "Writing of layout section failed");
    }
  } else {
    {
#line 444
    psiconv_progress((psiconv_config )config, lev, (psiconv_u32 )0, "End of layout section");
    }
  }
#line 445
  return (res);
}
}
#line 47 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/psiconv.c"
static void print_help___0(void) ;
#line 48
static void print_version___0(void) ;
#line 49
static void strtoupper___0(char *str ) ;
#line 51 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/psiconv.c"
static void print_help___0(void) 
{ 
  fileformat ff___1 ;
  int i ;
  int j ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  psiconv_u32 tmp___8 ;

  {
  {
#line 56
  puts("Syntax: psiconv [OPTIONS..] [FILE]");
#line 57
  puts("Convert the psion file FILE to other formats");
#line 58
  puts("If FILE is not specified, use stdin");
#line 59
  puts("  -c, --configfile=FILE Read extra configuration file after normal ones");
#line 60
  puts("  -e, --encoding=ENC    Output encoding (default: UTF8)");
#line 61
  puts("  -h, --help            Display this help and exit");
#line 62
  puts("  -n, --noise=LEVEL     Select what to print on stderr (overrides psiconv.conf)");
#line 63
  puts("  -o, --outputfile      Output to file instead of stdout");
#line 64
  puts("  -T, --type=FILETYPE   Output type (default: XHTML or TIFF");
#line 65
  puts("  -V, --version         Display the program version and exit");
#line 66
  puts("");
#line 67
  puts("The following encodings are currently supported:");
#line 68
  puts("  UTF8    Variable length Unicode encoding");
#line 69
  puts("  UCS2    Fixed 16-bit length Unicode encoding");
#line 70
  puts("  Psion   The encoding your Psion uses (as in psiconv.conf)");
#line 71
  puts("  ASCII   7-bit ASCII (other symbols are substituted by \'?\')");
#line 72
  puts("");
#line 73
  puts("The following noise levels are currently supported:");
#line 74
  puts("  1 or F: Fatal errors only");
#line 75
  puts("  2 or E: Errors");
#line 76
  puts("  3 or W: Warnings");
#line 77
  puts("  4 or P: Progress indicators");
#line 78
  puts("  5 or D: Debug data");
#line 79
  puts("");
#line 80
  puts("The following abbreviations are used in the output types list:");
#line 81
  puts("  C  - processes ClipArt files");
#line 82
  puts("  c  - processes ClipArt files containing only one image");
#line 83
  puts("  M  - processes MBM files");
#line 84
  puts("  m  - processes MBM files containing only one image");
#line 85
  puts("  S  - processes Sketch files");
#line 86
  puts("  T  - processes TextEd files");
#line 87
  puts("  W  - processes Word files");
#line 88
  puts("");
#line 89
  puts("The following output types are known:");
#line 90
  i = 0;
  }
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 90
    tmp___8 = psiconv_list_length((psiconv_list const   )fileformat_list);
    }
#line 90
    if (! ((psiconv_u32 )i < tmp___8)) {
#line 90
      goto while_break;
    }
    {
#line 91
    tmp = psiconv_list_get((psiconv_list const   )fileformat_list, (psiconv_u32 )i);
#line 91
    ff___1 = (fileformat )tmp;
#line 92
    printf((char const   */* __restrict  */)"  %s", ff___1->name);
#line 93
    tmp___0 = strlen(ff___1->name);
#line 93
    j = (int )tmp___0;
    }
    {
#line 93
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 93
      if (! (j < 10)) {
#line 93
        goto while_break___0;
      }
      {
#line 94
      putchar(' ');
#line 93
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 95
    if (ff___1->supported_format & 1) {
#line 95
      tmp___1 = 'W';
    } else {
#line 95
      tmp___1 = ' ';
    }
#line 95
    if (ff___1->supported_format & 2) {
#line 95
      tmp___2 = 'T';
    } else {
#line 95
      tmp___2 = ' ';
    }
#line 95
    if (ff___1->supported_format & 64) {
#line 95
      tmp___3 = 'S';
    } else {
#line 95
      tmp___3 = ' ';
    }
#line 95
    if (ff___1->supported_format & 32) {
#line 95
      tmp___5 = 'M';
    } else {
#line 95
      if (ff___1->supported_format & 16) {
#line 95
        tmp___4 = 'm';
      } else {
#line 95
        tmp___4 = ' ';
      }
#line 95
      tmp___5 = tmp___4;
    }
#line 95
    if (ff___1->supported_format & 8) {
#line 95
      tmp___7 = 'C';
    } else {
#line 95
      if (ff___1->supported_format & 4) {
#line 95
        tmp___6 = 'c';
      } else {
#line 95
        tmp___6 = ' ';
      }
#line 95
      tmp___7 = tmp___6;
    }
    {
#line 95
    printf((char const   */* __restrict  */)"[%c%c%c%c%c] ", tmp___7, tmp___5, tmp___3,
           tmp___2, tmp___1);
#line 103
    puts(ff___1->description);
#line 90
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 105
  puts("");
#line 106
  puts("When using UTF8 with LaTeX type, the resulting LaTeX source should be converted");
#line 107
  puts(" to a suitable encoding for your LaTeX installation before being typeset");
  }
#line 108
  return;
}
}
#line 110 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/psiconv.c"
static void print_version___0(void) 
{ 


  {
  {
#line 112
  printf((char const   */* __restrict  */)"Version %s\n", "0.9.8");
  }
#line 113
  return;
}
}
#line 115 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/psiconv.c"
static void strtoupper___0(char *str ) 
{ 
  int i ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 118
    tmp___0 = strlen((char const   *)str);
    }
#line 118
    if (! ((size_t )i < tmp___0)) {
#line 118
      goto while_break;
    }
    {
#line 119
    tmp = toupper((int )*(str + i));
#line 119
    *(str + i) = (char )tmp;
#line 118
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return;
}
}
#line 36 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle8___3(psiconv_config const   config , int lev , psiconv_u32 off ,
                                   psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) ;
#line 41
static int psiconv_decode_rle12___3(psiconv_config const   config , int lev , psiconv_u32 off ,
                                    psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) ;
#line 46
static int psiconv_decode_rle16___3(psiconv_config const   config , int lev , psiconv_u32 off ,
                                    psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) ;
#line 51
static int psiconv_decode_rle24___3(psiconv_config const   config , int lev , psiconv_u32 off ,
                                    psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) ;
#line 56
static int psiconv_bytes_to_pixel_data___3(psiconv_config const   config , int lev ,
                                           psiconv_u32 off , psiconv_pixel_bytes const   bytes ,
                                           psiconv_pixel_ints *pixels , int colordepth ,
                                           int xsize , int ysize ) ;
#line 62
static int psiconv_pixel_data_to_floats___3(psiconv_config const   config , int lev ,
                                            psiconv_u32 off , psiconv_pixel_ints const   pixels ,
                                            psiconv_pixel_floats_t *floats , int colordepth ,
                                            int color___1 , int redbits , int bluebits ,
                                            int greenbits , psiconv_pixel_floats_t const   palet ) ;
#line 647 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle8___3(psiconv_config const   config , int lev , psiconv_u32 off ,
                                   psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) 
{ 
  int res ;
  psiconv_u8 *marker ;
  psiconv_u8 *value ;
  int i ;
  int j ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  psiconv_u32 tmp___3 ;

  {
  {
#line 651
  res = 0;
#line 655
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to decode the RLE8 encoding");
#line 656
  tmp = psiconv_list_new(sizeof(psiconv_u8 ));
#line 656
  *decoded = tmp;
  }
#line 656
  if (! tmp) {
#line 657
    goto ERROR1;
  }
#line 659
  i = 0;
  {
#line 659
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 659
    tmp___3 = psiconv_list_length(encoded);
    }
#line 659
    if (! ((psiconv_u32 )i < tmp___3)) {
#line 659
      goto while_break;
    }
    {
#line 663
    tmp___0 = psiconv_list_get(encoded, (psiconv_u32 )i);
#line 663
    marker = (psiconv_u8 *)tmp___0;
    }
#line 663
    if (! marker) {
#line 664
      goto ERROR2;
    }
#line 668
    if ((int )*marker < 128) {
      {
#line 674
      tmp___1 = psiconv_list_get(encoded, (psiconv_u32 )(i + 1));
#line 674
      value = (psiconv_u8 *)tmp___1;
      }
#line 674
      if (! value) {
#line 675
        goto ERROR2;
      }
#line 681
      j = 0;
      {
#line 681
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 681
        if (! (j < (int )*marker + 1)) {
#line 681
          goto while_break___0;
        }
        {
#line 682
        res = psiconv_list_add(*decoded, (void const   *)value);
        }
#line 682
        if (res) {
#line 683
          goto ERROR2;
        }
#line 681
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 684
      i += 2;
    } else {
#line 690
      j = 0;
      {
#line 690
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 690
        if (! (j < 256 - (int )*marker)) {
#line 690
          goto while_break___1;
        }
        {
#line 695
        tmp___2 = psiconv_list_get(encoded, (psiconv_u32 )((i + j) + 1));
#line 695
        value = (psiconv_u8 *)tmp___2;
        }
#line 695
        if (! value) {
#line 696
          goto ERROR2;
        }
        {
#line 700
        res = psiconv_list_add(*decoded, (void const   *)value);
        }
#line 700
        if (res) {
#line 701
          goto ERROR2;
        }
#line 690
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 703
      i += (256 - (int )*marker) + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 706
  psiconv_progress((psiconv_config )config, lev, off, "End of RLE8 decoding process");
  }
#line 708
  return (0);
  ERROR2: 
  {
#line 711
  psiconv_list_free(*decoded);
  }
  ERROR1: 
  {
#line 713
  psiconv_error((psiconv_config )config, lev + 1, off, "Decoding of RLE8 failed");
  }
#line 714
  if (! res) {
#line 715
    return (-2);
  } else {
#line 717
    return (res);
  }
}
}
#line 720 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle12___3(psiconv_config const   config , int lev , psiconv_u32 off ,
                                    psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) 
{ 
  int res ;
  psiconv_u8 *value0 ;
  psiconv_u8 *value1 ;
  psiconv_u32 value ;
  psiconv_u32 repeat ;
  int i ;
  int j ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  psiconv_u32 tmp___2 ;

  {
  {
#line 724
  res = 0;
#line 729
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to decode the RLE12 encoding");
#line 730
  tmp = psiconv_list_new(sizeof(psiconv_u8 ));
#line 730
  *decoded = tmp;
  }
#line 730
  if (! tmp) {
#line 731
    goto ERROR1;
  }
#line 733
  i = 0;
  {
#line 733
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 733
    tmp___2 = psiconv_list_length(encoded);
    }
#line 733
    if (! ((psiconv_u32 )i < tmp___2)) {
#line 733
      goto while_break;
    }
    {
#line 734
    psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read data word at %04x",
                     i);
#line 735
    tmp___0 = psiconv_list_get(encoded, (psiconv_u32 )i);
#line 735
    value0 = (psiconv_u8 *)tmp___0;
    }
#line 735
    if (! value0) {
#line 736
      goto ERROR2;
    }
    {
#line 737
    tmp___1 = psiconv_list_get(encoded, (psiconv_u32 )(i + 1));
#line 737
    value1 = (psiconv_u8 *)tmp___1;
    }
#line 737
    if (! value1) {
#line 738
      goto ERROR2;
    }
    {
#line 739
    psiconv_debug((psiconv_config )config, lev + 2, off, "Data Word: %04x", (int )*value0 + ((int )*value1 << 8));
#line 740
    value = (psiconv_u32 )((int )*value0 + (((int )*value1 & 15) << 8));
#line 741
    repeat = (psiconv_u32 )(((int )*value1 >> 4) + 1);
#line 742
    psiconv_progress((psiconv_config )config, lev + 2, off, "Adding %02x pixels %03x",
                     repeat, value);
#line 744
    j = 0;
    }
    {
#line 744
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 744
      if (! ((psiconv_u32 )j < repeat)) {
#line 744
        goto while_break___0;
      }
      {
#line 745
      res = psiconv_list_add(*decoded, (void const   *)(& value));
      }
#line 745
      if (res) {
#line 746
        goto ERROR2;
      }
#line 744
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 747
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 749
  psiconv_progress((psiconv_config )config, lev, off, "End of RLE12 decoding process");
  }
#line 751
  return (0);
  ERROR2: 
  {
#line 754
  psiconv_list_free(*decoded);
  }
  ERROR1: 
  {
#line 756
  psiconv_error((psiconv_config )config, lev + 1, off, "Decoding of RLE12 failed");
  }
#line 757
  if (! res) {
#line 758
    return (-2);
  } else {
#line 760
    return (res);
  }
}
}
#line 763 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle16___3(psiconv_config const   config , int lev , psiconv_u32 off ,
                                    psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) 
{ 
  int res ;
  psiconv_u8 *marker ;
  psiconv_u8 *value0 ;
  psiconv_u8 *value1 ;
  psiconv_u32 value ;
  int i ;
  int j ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  psiconv_u32 tmp___5 ;

  {
  {
#line 767
  res = 0;
#line 772
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to decode the RLE16 encoding");
#line 773
  tmp = psiconv_list_new(sizeof(psiconv_u8 ));
#line 773
  *decoded = tmp;
  }
#line 773
  if (! tmp) {
#line 774
    goto ERROR1;
  }
#line 776
  i = 0;
  {
#line 776
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 776
    tmp___5 = psiconv_list_length(encoded);
    }
#line 776
    if (! ((psiconv_u32 )i < tmp___5)) {
#line 776
      goto while_break;
    }
    {
#line 777
    psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read marker byte at %04x",
                     i);
#line 778
    tmp___0 = psiconv_list_get(encoded, (psiconv_u32 )i);
#line 778
    marker = (psiconv_u8 *)tmp___0;
    }
#line 778
    if (! marker) {
#line 779
      goto ERROR2;
    }
    {
#line 780
    psiconv_debug((psiconv_config )config, lev + 2, off, "Marker byte: %02x", (int )*marker);
    }
#line 781
    if ((int )*marker < 128) {
      {
#line 782
      psiconv_debug((psiconv_config )config, lev + 2, off, "Marker: repeat value word %02x times",
                    (int )*marker + 1);
#line 784
      psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read value word at %04x",
                       i + 1);
#line 785
      tmp___1 = psiconv_list_get(encoded, (psiconv_u32 )(i + 1));
#line 785
      value0 = (psiconv_u8 *)tmp___1;
      }
#line 785
      if (! value0) {
#line 786
        goto ERROR2;
      }
      {
#line 787
      tmp___2 = psiconv_list_get(encoded, (psiconv_u32 )(i + 2));
#line 787
      value1 = (psiconv_u8 *)tmp___2;
      }
#line 787
      if (! value1) {
#line 788
        goto ERROR2;
      }
      {
#line 789
      value = (psiconv_u32 )((int )*value0 + ((int )*value1 << 8));
#line 790
      psiconv_debug((psiconv_config )config, lev + 2, off, "Value word: %02x", value);
#line 791
      psiconv_progress((psiconv_config )config, lev + 2, off, "Adding %02x pixels %04x",
                       (int )*marker + 1, value);
#line 793
      j = 0;
      }
      {
#line 793
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 793
        if (! (j < (int )*marker + 1)) {
#line 793
          goto while_break___0;
        }
        {
#line 794
        res = psiconv_list_add(*decoded, (void const   *)(& value));
        }
#line 794
        if (res) {
#line 795
          goto ERROR2;
        }
#line 793
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 796
      i += 3;
    } else {
      {
#line 798
      psiconv_debug((psiconv_config )config, lev + 2, off, "Marker: %02x value words follow",
                    256 - (int )*marker);
#line 800
      j = 0;
      }
      {
#line 800
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 800
        if (! (j < 256 - (int )*marker)) {
#line 800
          goto while_break___1;
        }
        {
#line 801
        psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read value word at %04x",
                         (i + j * 2) + 1);
#line 803
        tmp___3 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 2) + 1));
#line 803
        value0 = (psiconv_u8 *)tmp___3;
        }
#line 803
        if (! value0) {
#line 804
          goto ERROR2;
        }
        {
#line 805
        tmp___4 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 2) + 2));
#line 805
        value1 = (psiconv_u8 *)tmp___4;
        }
#line 805
        if (! value1) {
#line 806
          goto ERROR2;
        }
        {
#line 807
        value = (psiconv_u32 )((int )*value0 + ((int )*value1 << 8));
#line 808
        psiconv_debug((psiconv_config )config, lev + 2, off, "Value: %04x", value);
#line 809
        res = psiconv_list_add(*decoded, (void const   *)(& value));
        }
#line 809
        if (res) {
#line 810
          goto ERROR2;
        }
#line 800
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 812
      i += (256 - (int )*marker) * 2 + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 815
  psiconv_progress((psiconv_config )config, lev, off, "End of RLE16 decoding process");
  }
#line 817
  return (0);
  ERROR2: 
  {
#line 820
  psiconv_list_free(*decoded);
  }
  ERROR1: 
  {
#line 822
  psiconv_error((psiconv_config )config, lev + 1, off, "Decoding of RLE16 failed");
  }
#line 823
  if (! res) {
#line 824
    return (-2);
  } else {
#line 826
    return (res);
  }
}
}
#line 829 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_decode_rle24___3(psiconv_config const   config , int lev , psiconv_u32 off ,
                                    psiconv_pixel_bytes const   encoded , psiconv_pixel_bytes *decoded ) 
{ 
  int res ;
  psiconv_u8 *marker ;
  psiconv_u8 *value0 ;
  psiconv_u8 *value1 ;
  psiconv_u8 *value2 ;
  psiconv_u32 value ;
  int i ;
  int j ;
  psiconv_pixel_bytes tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  psiconv_u32 tmp___7 ;

  {
  {
#line 833
  res = 0;
#line 838
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to decode the RLE24 encoding");
#line 839
  tmp = psiconv_list_new(sizeof(psiconv_u8 ));
#line 839
  *decoded = tmp;
  }
#line 839
  if (! tmp) {
#line 840
    goto ERROR1;
  }
#line 842
  i = 0;
  {
#line 842
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 842
    tmp___7 = psiconv_list_length(encoded);
    }
#line 842
    if (! ((psiconv_u32 )i < tmp___7)) {
#line 842
      goto while_break;
    }
    {
#line 843
    psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read marker byte at %04x",
                     i);
#line 844
    tmp___0 = psiconv_list_get(encoded, (psiconv_u32 )i);
#line 844
    marker = (psiconv_u8 *)tmp___0;
    }
#line 844
    if (! marker) {
#line 845
      goto ERROR2;
    }
    {
#line 846
    psiconv_debug((psiconv_config )config, lev + 2, off, "Marker byte: %02x", (int )*marker);
    }
#line 847
    if ((int )*marker < 128) {
      {
#line 848
      psiconv_debug((psiconv_config )config, lev + 2, off, "Marker: repeat value byte triplet %02x times",
                    (int )*marker + 1);
#line 850
      psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read value byte triplet at %04x",
                       i + 1);
#line 851
      tmp___1 = psiconv_list_get(encoded, (psiconv_u32 )(i + 1));
#line 851
      value0 = (psiconv_u8 *)tmp___1;
      }
#line 851
      if (! value0) {
#line 852
        goto ERROR2;
      }
      {
#line 853
      tmp___2 = psiconv_list_get(encoded, (psiconv_u32 )(i + 2));
#line 853
      value1 = (psiconv_u8 *)tmp___2;
      }
#line 853
      if (! value1) {
#line 854
        goto ERROR2;
      }
      {
#line 855
      tmp___3 = psiconv_list_get(encoded, (psiconv_u32 )(i + 3));
#line 855
      value2 = (psiconv_u8 *)tmp___3;
      }
#line 855
      if (! value2) {
#line 856
        goto ERROR2;
      }
      {
#line 857
      value = (psiconv_u32 )(((int )*value0 + ((int )*value1 << 8)) + ((int )*value2 << 16));
#line 858
      psiconv_debug((psiconv_config )config, lev + 2, off, "Value byte triplet: %06x",
                    value);
#line 859
      psiconv_progress((psiconv_config )config, lev + 2, off, "Adding %02x pixels %06x",
                       (int )*marker + 1, value);
#line 861
      j = 0;
      }
      {
#line 861
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 861
        if (! (j < (int )*marker + 1)) {
#line 861
          goto while_break___0;
        }
        {
#line 862
        res = psiconv_list_add(*decoded, (void const   *)(& value));
        }
#line 862
        if (res) {
#line 863
          goto ERROR2;
        }
#line 861
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 864
      i += 4;
    } else {
      {
#line 866
      psiconv_debug((psiconv_config )config, lev + 2, off, "Marker: %02x value byte triplets follow",
                    256 - (int )*marker);
#line 868
      j = 0;
      }
      {
#line 868
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 868
        if (! (j < 256 - (int )*marker)) {
#line 868
          goto while_break___1;
        }
        {
#line 869
        psiconv_progress((psiconv_config )config, lev + 2, off, "Going to read value byte triplets at %04x",
                         (i + j * 3) + 1);
#line 871
        tmp___4 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 3) + 1));
#line 871
        value0 = (psiconv_u8 *)tmp___4;
        }
#line 871
        if (! value0) {
#line 872
          goto ERROR2;
        }
        {
#line 873
        tmp___5 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 3) + 2));
#line 873
        value1 = (psiconv_u8 *)tmp___5;
        }
#line 873
        if (! value1) {
#line 874
          goto ERROR2;
        }
        {
#line 875
        tmp___6 = psiconv_list_get(encoded, (psiconv_u32 )((i + j * 3) + 3));
#line 875
        value2 = (psiconv_u8 *)tmp___6;
        }
#line 875
        if (! value2) {
#line 876
          goto ERROR2;
        }
        {
#line 877
        value = (psiconv_u32 )(((int )*value0 + ((int )*value1 << 8)) + ((int )*value2 << 16));
#line 878
        psiconv_debug((psiconv_config )config, lev + 2, off, "Value: %06x", value);
#line 879
        res = psiconv_list_add(*decoded, (void const   *)(& value));
        }
#line 879
        if (res) {
#line 880
          goto ERROR2;
        }
#line 868
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 882
      i += (256 - (int )*marker) * 3 + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 885
  psiconv_progress((psiconv_config )config, lev, off, "End of RLE24 decoding process");
  }
#line 887
  return (0);
  ERROR2: 
  {
#line 890
  psiconv_list_free(*decoded);
  }
  ERROR1: 
  {
#line 892
  psiconv_error((psiconv_config )config, lev + 1, off, "Decoding of RLE24 failed");
  }
#line 893
  if (! res) {
#line 894
    return (-2);
  } else {
#line 896
    return (res);
  }
}
}
#line 899 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_bytes_to_pixel_data___3(psiconv_config const   config , int lev ,
                                           psiconv_u32 off , psiconv_pixel_bytes const   bytes ,
                                           psiconv_pixel_ints *pixels , int colordepth ,
                                           int xsize , int ysize ) 
{ 
  int res ;
  int ibits ;
  int obits ;
  int x ;
  int y ;
  int bits ;
  psiconv_u8 input ;
  psiconv_u32 nr ;
  psiconv_u32 output ;
  psiconv_u8 *ientry ;
  psiconv_pixel_ints tmp ;
  void *tmp___0 ;

  {
  {
#line 905
  res = 0;
#line 911
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to convert the bytes to pixels");
#line 912
  tmp = psiconv_list_new(sizeof(psiconv_u32 ));
#line 912
  *pixels = tmp;
  }
#line 912
  if (! tmp) {
#line 913
    goto ERROR1;
  }
#line 915
  nr = (psiconv_u32 )0;
#line 916
  y = 0;
  {
#line 916
  while (1) {
    while_continue: /* CIL Label */ ;
#line 916
    if (! (y < ysize)) {
#line 916
      goto while_break;
    }
    {
#line 918
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 918
      if (! (nr % 4U)) {
#line 918
        goto while_break___0;
      }
#line 919
      nr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 920
    input = (psiconv_u8 )0;
#line 921
    ibits = 0;
#line 922
    x = 0;
    {
#line 922
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 922
      if (! (x < xsize)) {
#line 922
        goto while_break___1;
      }
#line 927
      output = (psiconv_u32 )0;
#line 928
      obits = 0;
      {
#line 929
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 929
        if (! (obits < colordepth)) {
#line 929
          goto while_break___2;
        }
#line 930
        if (ibits == 0) {
          {
#line 935
          tmp___0 = psiconv_list_get(bytes, nr);
#line 935
          ientry = (psiconv_u8 *)tmp___0;
          }
#line 935
          if (! ientry) {
#line 936
            goto ERROR2;
          }
#line 940
          input = *ientry;
#line 941
          ibits = 8;
#line 942
          nr ++;
        }
#line 944
        if (ibits + obits > colordepth) {
#line 944
          bits = colordepth - obits;
        } else {
#line 944
          bits = ibits;
        }
#line 945
        output <<= bits;
#line 946
        output |= (unsigned int )((int )input & ((1 << bits) - 1));
#line 947
        input = (psiconv_u8 )((int )input >> bits);
#line 948
        ibits -= bits;
#line 949
        obits += bits;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 954
      res = psiconv_list_add(*pixels, (void const   *)(& output));
      }
#line 954
      if (res) {
#line 955
        goto ERROR2;
      }
#line 922
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 916
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 959
  psiconv_progress((psiconv_config )config, lev, off, "Converting bytes to pixels completed");
  }
#line 961
  return (0);
  ERROR2: 
  {
#line 965
  psiconv_list_free(*pixels);
  }
  ERROR1: 
  {
#line 967
  psiconv_error((psiconv_config )config, lev + 1, off, "Converting bytes to pixels failed");
  }
#line 968
  if (! res) {
#line 969
    return (-2);
  } else {
#line 971
    return (res);
  }
}
}
#line 974 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/parse_image.c"
static int psiconv_pixel_data_to_floats___3(psiconv_config const   config , int lev ,
                                            psiconv_u32 off , psiconv_pixel_ints const   pixels ,
                                            psiconv_pixel_floats_t *floats , int colordepth ,
                                            int color___1 , int redbits , int bluebits ,
                                            int greenbits , psiconv_pixel_floats_t const   palet ) 
{ 
  int res ;
  psiconv_u32 i ;
  psiconv_u32 *pixel ;
  float *tmp ;
  psiconv_u32 tmp___0 ;
  void *tmp___1 ;
  float *tmp___2 ;
  psiconv_u32 tmp___3 ;
  void *tmp___4 ;
  float *tmp___5 ;
  psiconv_u32 tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  float tmp___9 ;
  float tmp___10 ;
  psiconv_u32 tmp___11 ;

  {
  {
#line 982
  res = 0;
#line 986
  psiconv_progress((psiconv_config )config, lev + 1, off, "Going to convert pixels to floats");
#line 987
  tmp___0 = psiconv_list_length(pixels);
#line 987
  tmp___1 = malloc((unsigned long )tmp___0 * sizeof(*(floats->red)));
#line 987
  tmp = (float *)tmp___1;
#line 987
  floats->red = tmp;
  }
#line 987
  if (! tmp) {
#line 989
    goto ERROR1;
  }
  {
#line 990
  tmp___3 = psiconv_list_length(pixels);
#line 990
  tmp___4 = malloc((unsigned long )tmp___3 * sizeof(*(floats->green)));
#line 990
  tmp___2 = (float *)tmp___4;
#line 990
  floats->green = tmp___2;
  }
#line 990
  if (! tmp___2) {
#line 992
    goto ERROR2;
  }
  {
#line 993
  tmp___6 = psiconv_list_length(pixels);
#line 993
  tmp___7 = malloc((unsigned long )tmp___6 * sizeof(*(floats->blue)));
#line 993
  tmp___5 = (float *)tmp___7;
#line 993
  floats->blue = tmp___5;
  }
#line 993
  if (! tmp___5) {
#line 995
    goto ERROR3;
  }
  {
#line 996
  floats->length = psiconv_list_length(pixels);
#line 998
  i = (psiconv_u32 )0;
  }
  {
#line 998
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 998
    tmp___11 = psiconv_list_length(pixels);
    }
#line 998
    if (! (i < tmp___11)) {
#line 998
      goto while_break;
    }
    {
#line 999
    tmp___8 = psiconv_list_get(pixels, i);
#line 999
    pixel = (psiconv_u32 *)tmp___8;
    }
#line 999
    if (! pixel) {
#line 1000
      goto ERROR4;
    }
#line 1004
    if (! palet.length) {
#line 1005
      if (color___1) {
#line 1006
        *(floats->blue + i) = (float )(*pixel & (unsigned int )((1 << bluebits) - 1)) / (float )((1 << bluebits) - 1);
#line 1008
        *(floats->green + i) = (float )((*pixel >> bluebits) & (unsigned int )((1 << greenbits) - 1)) / (float )((1 << greenbits) - 1);
#line 1010
        *(floats->red + i) = (float )((*pixel >> (bluebits + greenbits)) & (unsigned int )((1 << redbits) - 1)) / (float )((1 << redbits) - 1);
      } else {
#line 1013
        tmp___10 = (float )*pixel / (float )((1 << colordepth) - 1);
#line 1013
        *(floats->blue + i) = tmp___10;
#line 1013
        tmp___9 = tmp___10;
#line 1013
        *(floats->green + i) = tmp___9;
#line 1013
        *(floats->red + i) = tmp___9;
      }
    } else
#line 1018
    if (*pixel >= (psiconv_u32 )palet.length) {
      {
#line 1019
      psiconv_warn((psiconv_config )config, lev + 2, off, "Invalid palet color found (using color 0x00)");
#line 1021
      *(floats->red + i) = *(palet.red + 0);
#line 1022
      *(floats->green + i) = *(palet.green + 0);
#line 1023
      *(floats->blue + i) = *(palet.blue + 0);
      }
    } else {
#line 1025
      *(floats->red + i) = *(palet.red + *pixel);
#line 1026
      *(floats->green + i) = *(palet.green + *pixel);
#line 1027
      *(floats->blue + i) = *(palet.blue + *pixel);
    }
#line 998
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1035
  psiconv_progress((psiconv_config )config, lev + 1, off, "Finished converting pixels to floats");
  }
#line 1036
  return (0);
  ERROR4: 
  {
#line 1039
  free((void *)floats->blue);
  }
  ERROR3: 
  {
#line 1041
  free((void *)floats->green);
  }
  ERROR2: 
  {
#line 1043
  free((void *)floats->red);
  }
  ERROR1: 
  {
#line 1045
  psiconv_error((psiconv_config )config, lev + 1, off, "Converting pixels to floats failed");
  }
#line 1046
  if (! res) {
#line 1047
    return (-2);
  } else {
#line 1049
    return (res);
  }
}
}
#line 36 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void text___2(psiconv_config const   config , psiconv_list list , psiconv_string_t data ,
                     encoding const   enc ) ;
#line 38
static void color___0(psiconv_config const   config , psiconv_list list , psiconv_color color___1 ,
                      int may_be_transparant , encoding const   enc ) ;
#line 40
static void border___0(psiconv_config const   config , psiconv_list list , psiconv_border_kind_t border___1 ,
                       encoding const   enc ) ;
#line 42
static void style_name___0(psiconv_config const   config , psiconv_list list , psiconv_string_t const   name ,
                           encoding const   enc ) ;
#line 44
static int character_layout_equal___1(psiconv_character_layout const   l1 , psiconv_character_layout const   l2 ) ;
#line 46
static void character_layout_diffs___0(psiconv_config const   config , psiconv_list list ,
                                       psiconv_character_layout const   new , psiconv_character_layout const   base ,
                                       encoding const   enc ) ;
#line 51
static void paragraph_layout_diffs___0(psiconv_config const   config , psiconv_list list ,
                                       psiconv_paragraph_layout const   new , psiconv_paragraph_layout const   base ,
                                       encoding const   enc ) ;
#line 56
static void style___0(psiconv_config const   config , psiconv_list list , psiconv_word_style const   style___1 ,
                      psiconv_paragraph_layout const   base_para , psiconv_character_layout const   base_char ,
                      encoding const   enc ) ;
#line 61
static void styles___0(psiconv_config const   config , psiconv_list list , psiconv_word_styles_section const   styles_sec ,
                       encoding const   enc ) ;
#line 63
static void header___2(psiconv_config const   config , psiconv_list list , psiconv_word_styles_section const   styles_sec ,
                       encoding const   enc ) ;
#line 65
static void footer___2(psiconv_config const   config , psiconv_list list , encoding const   enc ) ;
#line 67
static void characters___2(psiconv_config const   config , psiconv_list list , psiconv_string_t const   textstr ,
                           psiconv_character_layout const   layout , psiconv_character_layout const   base ,
                           encoding const   enc ) ;
#line 72
static void paragraphs___2(psiconv_config const   config , psiconv_list list , psiconv_text_and_layout paragraphs___3 ,
                           psiconv_word_styles_section const   styles___1 , encoding const   enc ) ;
#line 76
static void paragraph___2(psiconv_config const   config , psiconv_list list , psiconv_paragraph const   para ,
                          psiconv_word_styles_section const   styles_sec , encoding const   enc ) ;
#line 80
static void gen_word___4(psiconv_config const   config , psiconv_list list , psiconv_word_f const   file ,
                         encoding const   enc ) ;
#line 82
static void gen_texted___4(psiconv_config const   config , psiconv_list list , psiconv_texted_f const   file ,
                           encoding const   enc ) ;
#line 84
static int gen_xhtml___0(psiconv_config const   config , psiconv_list list , psiconv_file const   file ,
                         char const   *dest , encoding const   enc ) ;
#line 90 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void text___2(psiconv_config const   config , psiconv_list list , psiconv_string_t data ,
                     encoding const   enc ) 
{ 
  int i ;
  int tmp ;

  {
#line 94
  i = 0;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 94
    tmp = psiconv_unicode_strlen((psiconv_ucs2 const   *)data);
    }
#line 94
    if (! (i < tmp)) {
#line 94
      goto while_break;
    }
#line 95
    if ((int )*(data + i) == 6) {
      {
#line 96
      output_simple_chars((psiconv_config )config, list, (char *)"<br/>", (encoding )enc);
      }
    } else
#line 95
    if ((int )*(data + i) == 7) {
      {
#line 96
      output_simple_chars((psiconv_config )config, list, (char *)"<br/>", (encoding )enc);
      }
    } else
#line 95
    if ((int )*(data + i) == 8) {
      {
#line 96
      output_simple_chars((psiconv_config )config, list, (char *)"<br/>", (encoding )enc);
      }
    } else
#line 97
    if ((int )*(data + i) == 11) {
      {
#line 98
      output_simple_chars((psiconv_config )config, list, (char *)"-", (encoding )enc);
      }
    } else
#line 97
    if ((int )*(data + i) == 12) {
      {
#line 98
      output_simple_chars((psiconv_config )config, list, (char *)"-", (encoding )enc);
      }
    } else
#line 99
    if ((int )*(data + i) == 15) {
      {
#line 100
      output_simple_chars((psiconv_config )config, list, (char *)" ", (encoding )enc);
      }
    } else
#line 99
    if ((int )*(data + i) == 9) {
      {
#line 100
      output_simple_chars((psiconv_config )config, list, (char *)" ", (encoding )enc);
      }
    } else
#line 99
    if ((int )*(data + i) == 10) {
      {
#line 100
      output_simple_chars((psiconv_config )config, list, (char *)" ", (encoding )enc);
      }
    } else
#line 101
    if ((int )*(data + i) >= 32) {
      {
#line 102
      output_char((psiconv_config )config, list, *(data + i), (encoding )enc);
      }
    }
#line 94
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 106 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void color___0(psiconv_config const   config , psiconv_list list , psiconv_color color___1 ,
                      int may_be_transparant , encoding const   enc ) 
{ 
  char tempstr[100] ;

  {
#line 110
  if (may_be_transparant) {
#line 110
    if ((int )color___1->red == 255) {
#line 110
      if ((int )color___1->blue == 255) {
#line 110
        if ((int )color___1->green == 255) {
          {
#line 114
          output_simple_chars((psiconv_config )config, list, (char *)"transparant",
                              (encoding )enc);
          }
        } else {
          {
#line 116
          snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"rgb(%d,%d,%d)",
                   (int )color___1->red, (int )color___1->green, (int )color___1->blue);
#line 120
          output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
          }
        }
      } else {
        {
#line 116
        snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"rgb(%d,%d,%d)",
                 (int )color___1->red, (int )color___1->green, (int )color___1->blue);
#line 120
        output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
        }
      }
    } else {
      {
#line 116
      snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"rgb(%d,%d,%d)",
               (int )color___1->red, (int )color___1->green, (int )color___1->blue);
#line 120
      output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
      }
    }
  } else {
    {
#line 116
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"rgb(%d,%d,%d)",
             (int )color___1->red, (int )color___1->green, (int )color___1->blue);
#line 120
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
    }
  }
#line 122
  return;
}
}
#line 124 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void border___0(psiconv_config const   config , psiconv_list list , psiconv_border_kind_t border___1 ,
                       encoding const   enc ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
#line 127
  if ((unsigned int )border___1 == 0U) {
#line 127
    tmp___5 = "none";
  } else {
#line 127
    if ((unsigned int )border___1 == 1U) {
#line 127
      tmp___4 = "solid";
    } else {
#line 127
      if ((unsigned int )border___1 == 2U) {
#line 127
        tmp___3 = "double";
      } else {
#line 127
        if ((unsigned int )border___1 == 3U) {
#line 127
          tmp___2 = "dotted";
        } else {
#line 127
          if ((unsigned int )border___1 == 4U) {
#line 127
            tmp___1 = "dashed";
          } else {
#line 127
            if ((unsigned int )border___1 == 5U) {
#line 127
              tmp___0 = "dashed";
            } else {
#line 127
              if ((unsigned int )border___1 == 6U) {
#line 127
                tmp = "dashed";
              } else {
#line 127
                tmp = "";
              }
#line 127
              tmp___0 = tmp;
            }
#line 127
            tmp___1 = tmp___0;
          }
#line 127
          tmp___2 = tmp___1;
        }
#line 127
        tmp___3 = tmp___2;
      }
#line 127
      tmp___4 = tmp___3;
    }
#line 127
    tmp___5 = tmp___4;
  }
  {
#line 127
  output_simple_chars((psiconv_config )config, list, (char *)tmp___5, (encoding )enc);
  }
#line 135
  return;
}
}
#line 137 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void style_name___0(psiconv_config const   config , psiconv_list list , psiconv_string_t const   name ,
                           encoding const   enc ) 
{ 
  psiconv_string_t name_copy ;
  int i ;
  int tmp ;

  {
#line 143
  if (! name) {
#line 144
    return;
  }
  {
#line 146
  name_copy = psiconv_unicode_strdup((psiconv_ucs2 const   *)name);
  }
#line 146
  if (! name_copy) {
    {
#line 147
    fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 148
    exit(1);
    }
  }
#line 150
  i = 0;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 150
    tmp = psiconv_unicode_strlen((psiconv_ucs2 const   *)name_copy);
    }
#line 150
    if (! (i < tmp)) {
#line 150
      goto while_break;
    }
#line 151
    if ((int )*(name_copy + i) < 33) {
#line 153
      *(name_copy + i) = (psiconv_ucs2 )'_';
    } else
#line 151
    if ((int )*(name_copy + i) >= 127) {
#line 151
      if ((int )*(name_copy + i) <= 160) {
#line 153
        *(name_copy + i) = (psiconv_ucs2 )'_';
      }
    }
#line 150
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 155
  output_string((psiconv_config )config, list, name_copy, (encoding )enc);
#line 156
  free((void *)name_copy);
  }
#line 157
  return;
}
}
#line 160 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static int character_layout_equal___1(psiconv_character_layout const   l1 , psiconv_character_layout const   l2 ) 
{ 
  int tmp ;

  {
#line 163
  if (l1) {
#line 163
    if (l2) {
#line 163
      if ((int )(l1->color)->red == (int )(l2->color)->red) {
#line 163
        if ((int )(l1->color)->green == (int )(l2->color)->green) {
#line 163
          if ((int )(l1->color)->blue == (int )(l2->color)->blue) {
#line 163
            if ((int )(l1->back_color)->red == (int )(l2->back_color)->red) {
#line 163
              if ((int )(l1->back_color)->green == (int )(l2->back_color)->green) {
#line 163
                if ((int )(l1->back_color)->blue == (int )(l2->back_color)->blue) {
#line 163
                  if (l1->font_size == l2->font_size) {
#line 163
                    if ((unsigned int )l1->italic == (unsigned int )l2->italic) {
#line 163
                      if ((unsigned int )l1->bold == (unsigned int )l2->bold) {
#line 163
                        if ((unsigned int )l1->super_sub == (unsigned int )l2->super_sub) {
#line 163
                          if ((unsigned int )l1->underline == (unsigned int )l2->underline) {
#line 163
                            if ((unsigned int )l1->strikethrough == (unsigned int )l2->strikethrough) {
#line 163
                              if ((unsigned int )(l1->font)->screenfont == (unsigned int )(l2->font)->screenfont) {
#line 163
                                tmp = 1;
                              } else {
#line 163
                                tmp = 0;
                              }
                            } else {
#line 163
                              tmp = 0;
                            }
                          } else {
#line 163
                            tmp = 0;
                          }
                        } else {
#line 163
                          tmp = 0;
                        }
                      } else {
#line 163
                        tmp = 0;
                      }
                    } else {
#line 163
                      tmp = 0;
                    }
                  } else {
#line 163
                    tmp = 0;
                  }
                } else {
#line 163
                  tmp = 0;
                }
              } else {
#line 163
                tmp = 0;
              }
            } else {
#line 163
              tmp = 0;
            }
          } else {
#line 163
            tmp = 0;
          }
        } else {
#line 163
          tmp = 0;
        }
      } else {
#line 163
        tmp = 0;
      }
    } else {
#line 163
      tmp = 0;
    }
  } else {
#line 163
    tmp = 0;
  }
#line 163
  return (tmp);
}
}
#line 179 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void character_layout_diffs___0(psiconv_config const   config , psiconv_list list ,
                                       psiconv_character_layout const   new , psiconv_character_layout const   base ,
                                       encoding const   enc ) 
{ 
  char tempstr[100] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;

  {
#line 186
  if (! base) {
    {
#line 189
    output_simple_chars((psiconv_config )config, list, (char *)"color:", (encoding )enc);
#line 190
    color___0(config, list, new->color, 0, enc);
#line 191
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 186
  if ((int )(new->color)->red != (int )(base->color)->red) {
    {
#line 189
    output_simple_chars((psiconv_config )config, list, (char *)"color:", (encoding )enc);
#line 190
    color___0(config, list, new->color, 0, enc);
#line 191
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 186
  if ((int )(new->color)->green != (int )(base->color)->green) {
    {
#line 189
    output_simple_chars((psiconv_config )config, list, (char *)"color:", (encoding )enc);
#line 190
    color___0(config, list, new->color, 0, enc);
#line 191
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 186
  if ((int )(new->color)->blue != (int )(base->color)->blue) {
    {
#line 189
    output_simple_chars((psiconv_config )config, list, (char *)"color:", (encoding )enc);
#line 190
    color___0(config, list, new->color, 0, enc);
#line 191
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  }
#line 194
  if (! base) {
    {
#line 197
    output_simple_chars((psiconv_config )config, list, (char *)"background-color:",
                        (encoding )enc);
#line 198
    color___0(config, list, new->back_color, 1, enc);
#line 199
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 194
  if ((int )(new->back_color)->red != (int )(base->back_color)->red) {
    {
#line 197
    output_simple_chars((psiconv_config )config, list, (char *)"background-color:",
                        (encoding )enc);
#line 198
    color___0(config, list, new->back_color, 1, enc);
#line 199
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 194
  if ((int )(new->back_color)->green != (int )(base->back_color)->green) {
    {
#line 197
    output_simple_chars((psiconv_config )config, list, (char *)"background-color:",
                        (encoding )enc);
#line 198
    color___0(config, list, new->back_color, 1, enc);
#line 199
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 194
  if ((int )(new->back_color)->blue != (int )(base->back_color)->blue) {
    {
#line 197
    output_simple_chars((psiconv_config )config, list, (char *)"background-color:",
                        (encoding )enc);
#line 198
    color___0(config, list, new->back_color, 1, enc);
#line 199
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  }
#line 202
  if (! base) {
    {
#line 203
    output_simple_chars((psiconv_config )config, list, (char *)"font-size:", (encoding )enc);
#line 204
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )new->font_size);
#line 205
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 206
    output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
    }
  } else
#line 202
  if (new->font_size != base->font_size) {
    {
#line 203
    output_simple_chars((psiconv_config )config, list, (char *)"font-size:", (encoding )enc);
#line 204
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )new->font_size);
#line 205
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 206
    output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
    }
  }
#line 209
  if (! base) {
#line 209
    goto _L;
  } else
#line 209
  if ((unsigned int )new->italic != (unsigned int )base->italic) {
    _L: /* CIL Label */ 
    {
#line 210
    output_simple_chars((psiconv_config )config, list, (char *)"font-style:", (encoding )enc);
    }
#line 211
    if (new->italic) {
#line 211
      tmp = "italic";
    } else {
#line 211
      tmp = "normal";
    }
    {
#line 211
    output_simple_chars((psiconv_config )config, list, (char *)tmp, (encoding )enc);
#line 212
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  }
#line 214
  if (! base) {
#line 214
    goto _L___0;
  } else
#line 214
  if ((unsigned int )new->bold != (unsigned int )base->bold) {
    _L___0: /* CIL Label */ 
    {
#line 215
    output_simple_chars((psiconv_config )config, list, (char *)"font-weight:", (encoding )enc);
    }
#line 216
    if (new->bold) {
#line 216
      tmp___0 = "bold";
    } else {
#line 216
      tmp___0 = "normal";
    }
    {
#line 216
    output_simple_chars((psiconv_config )config, list, (char *)tmp___0, (encoding )enc);
#line 217
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  }
#line 219
  if (! base) {
#line 219
    goto _L___1;
  } else
#line 219
  if ((unsigned int )new->super_sub != (unsigned int )base->super_sub) {
    _L___1: /* CIL Label */ 
    {
#line 220
    output_simple_chars((psiconv_config )config, list, (char *)"font-style:", (encoding )enc);
    }
#line 221
    if ((unsigned int )new->super_sub == 1U) {
#line 221
      tmp___2 = "super";
    } else {
#line 221
      if ((unsigned int )new->super_sub == 2U) {
#line 221
        tmp___1 = "sub";
      } else {
#line 221
        tmp___1 = "normal";
      }
#line 221
      tmp___2 = tmp___1;
    }
    {
#line 221
    output_simple_chars((psiconv_config )config, list, (char *)tmp___2, (encoding )enc);
#line 225
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  }
#line 227
  if (! base) {
#line 227
    goto _L___2;
  } else
#line 227
  if ((unsigned int )new->underline != (unsigned int )base->underline) {
#line 227
    goto _L___2;
  } else
#line 227
  if ((unsigned int )new->strikethrough != (unsigned int )base->strikethrough) {
    _L___2: /* CIL Label */ 
    {
#line 229
    output_simple_chars((psiconv_config )config, list, (char *)"text-decoration:",
                        (encoding )enc);
    }
#line 230
    if (new->underline) {
#line 230
      tmp___4 = "underline";
    } else {
#line 230
      if (new->strikethrough) {
#line 230
        tmp___3 = "line-through";
      } else {
#line 230
        tmp___3 = "none";
      }
#line 230
      tmp___4 = tmp___3;
    }
    {
#line 230
    output_simple_chars((psiconv_config )config, list, (char *)tmp___4, (encoding )enc);
#line 233
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  }
#line 235
  if (! base) {
#line 235
    goto _L___3;
  } else
#line 235
  if ((unsigned int )(new->font)->screenfont != (unsigned int )(base->font)->screenfont) {
    _L___3: /* CIL Label */ 
    {
#line 236
    output_simple_chars((psiconv_config )config, list, (char *)"font-family:", (encoding )enc);
    }
#line 237
    if ((unsigned int )(new->font)->screenfont == 3U) {
#line 237
      tmp___8 = "serif";
    } else {
#line 237
      if ((unsigned int )(new->font)->screenfont == 1U) {
#line 237
        tmp___7 = "sans-serif";
      } else {
#line 237
        if ((unsigned int )(new->font)->screenfont == 2U) {
#line 237
          tmp___6 = "monospace";
        } else {
#line 237
          if ((unsigned int )(new->font)->screenfont == 0U) {
#line 237
            tmp___5 = "fantasy";
          } else {
#line 237
            tmp___5 = "";
          }
#line 237
          tmp___6 = tmp___5;
        }
#line 237
        tmp___7 = tmp___6;
      }
#line 237
      tmp___8 = tmp___7;
    }
    {
#line 237
    output_simple_chars((psiconv_config )config, list, (char *)tmp___8, (encoding )enc);
    }
  }
#line 244
  return;
}
}
#line 246 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void paragraph_layout_diffs___0(psiconv_config const   config , psiconv_list list ,
                                       psiconv_paragraph_layout const   new , psiconv_paragraph_layout const   base ,
                                       encoding const   enc ) 
{ 
  char tempstr[100] ;
  float pad_left_base ;
  float pad_left_new ;
  float text_indent_base ;
  float text_indent_new ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 252
  pad_left_base = (float )0.0;
#line 252
  text_indent_base = (float )0.0;
#line 254
  if ((new->bullet)->on) {
#line 255
    if (new->indent_left < new->indent_first) {
#line 255
      pad_left_new = new->indent_left;
    } else {
#line 255
      pad_left_new = new->indent_first;
    }
#line 257
    text_indent_new = (float )0.0;
  } else {
#line 259
    pad_left_new = new->indent_left;
#line 260
    text_indent_new = new->indent_first;
  }
#line 262
  if (base) {
#line 263
    if ((base->bullet)->on) {
#line 264
      if (base->indent_left < base->indent_first) {
#line 264
        pad_left_base = base->indent_left;
      } else {
#line 264
        pad_left_base = base->indent_first;
      }
#line 266
      text_indent_base = (float )0.0;
    } else {
#line 268
      pad_left_base = base->indent_left;
#line 269
      text_indent_base = base->indent_first;
    }
  }
#line 274
  if (! base) {
    {
#line 277
    output_simple_chars((psiconv_config )config, list, (char *)"background-color:",
                        (encoding )enc);
#line 278
    color___0(config, list, new->back_color, 1, enc);
#line 279
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 274
  if ((int )(new->back_color)->red != (int )(base->back_color)->red) {
    {
#line 277
    output_simple_chars((psiconv_config )config, list, (char *)"background-color:",
                        (encoding )enc);
#line 278
    color___0(config, list, new->back_color, 1, enc);
#line 279
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 274
  if ((int )(new->back_color)->green != (int )(base->back_color)->green) {
    {
#line 277
    output_simple_chars((psiconv_config )config, list, (char *)"background-color:",
                        (encoding )enc);
#line 278
    color___0(config, list, new->back_color, 1, enc);
#line 279
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 274
  if ((int )(new->back_color)->blue != (int )(base->back_color)->blue) {
    {
#line 277
    output_simple_chars((psiconv_config )config, list, (char *)"background-color:",
                        (encoding )enc);
#line 278
    color___0(config, list, new->back_color, 1, enc);
#line 279
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  }
#line 282
  if (! base) {
    {
#line 283
    output_simple_chars((psiconv_config )config, list, (char *)"padding-left:", (encoding )enc);
#line 284
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )pad_left_new);
#line 285
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 286
    output_simple_chars((psiconv_config )config, list, (char *)"cm;", (encoding )enc);
    }
  } else
#line 282
  if (pad_left_new != pad_left_base) {
    {
#line 283
    output_simple_chars((psiconv_config )config, list, (char *)"padding-left:", (encoding )enc);
#line 284
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )pad_left_new);
#line 285
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 286
    output_simple_chars((psiconv_config )config, list, (char *)"cm;", (encoding )enc);
    }
  }
#line 289
  if (! base) {
    {
#line 290
    output_simple_chars((psiconv_config )config, list, (char *)"padding-right:", (encoding )enc);
#line 291
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )new->indent_right);
#line 292
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 293
    output_simple_chars((psiconv_config )config, list, (char *)"cm;", (encoding )enc);
    }
  } else
#line 289
  if (new->indent_right != base->indent_right) {
    {
#line 290
    output_simple_chars((psiconv_config )config, list, (char *)"padding-right:", (encoding )enc);
#line 291
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )new->indent_right);
#line 292
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 293
    output_simple_chars((psiconv_config )config, list, (char *)"cm;", (encoding )enc);
    }
  }
#line 296
  if (! base) {
    {
#line 297
    output_simple_chars((psiconv_config )config, list, (char *)"text-indent:", (encoding )enc);
#line 298
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )text_indent_new);
#line 299
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 300
    output_simple_chars((psiconv_config )config, list, (char *)"cm;", (encoding )enc);
    }
  } else
#line 296
  if (text_indent_new != text_indent_base) {
    {
#line 297
    output_simple_chars((psiconv_config )config, list, (char *)"text-indent:", (encoding )enc);
#line 298
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )text_indent_new);
#line 299
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 300
    output_simple_chars((psiconv_config )config, list, (char *)"cm;", (encoding )enc);
    }
  }
#line 303
  if (! base) {
#line 303
    goto _L;
  } else
#line 303
  if ((unsigned int )new->justify_hor != (unsigned int )base->justify_hor) {
    _L: /* CIL Label */ 
    {
#line 304
    output_simple_chars((psiconv_config )config, list, (char *)"font-style:", (encoding )enc);
    }
#line 305
    if ((unsigned int )new->justify_hor == 0U) {
#line 305
      tmp___2 = "left";
    } else {
#line 305
      if ((unsigned int )new->justify_hor == 1U) {
#line 305
        tmp___1 = "center";
      } else {
#line 305
        if ((unsigned int )new->justify_hor == 2U) {
#line 305
          tmp___0 = "right";
        } else {
#line 305
          if ((unsigned int )new->justify_hor == 3U) {
#line 305
            tmp = "justify";
          } else {
#line 305
            tmp = "";
          }
#line 305
          tmp___0 = tmp;
        }
#line 305
        tmp___1 = tmp___0;
      }
#line 305
      tmp___2 = tmp___1;
    }
    {
#line 305
    output_simple_chars((psiconv_config )config, list, (char *)tmp___2, (encoding )enc);
#line 311
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  }
#line 324
  if (! base) {
    {
#line 325
    output_simple_chars((psiconv_config )config, list, (char *)"padding-top:", (encoding )enc);
#line 326
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )new->space_above);
#line 327
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 328
    output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
    }
  } else
#line 324
  if (new->space_above != base->space_above) {
    {
#line 325
    output_simple_chars((psiconv_config )config, list, (char *)"padding-top:", (encoding )enc);
#line 326
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )new->space_above);
#line 327
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 328
    output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
    }
  }
#line 331
  if (! base) {
    {
#line 332
    output_simple_chars((psiconv_config )config, list, (char *)"padding-bottom:",
                        (encoding )enc);
#line 333
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )new->space_below);
#line 334
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 335
    output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
    }
  } else
#line 331
  if (new->space_below != base->space_below) {
    {
#line 332
    output_simple_chars((psiconv_config )config, list, (char *)"padding-bottom:",
                        (encoding )enc);
#line 333
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )new->space_below);
#line 334
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 335
    output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
    }
  }
#line 338
  if (! base) {
    {
#line 339
    output_simple_chars((psiconv_config )config, list, (char *)"border-right-style:",
                        (encoding )enc);
#line 340
    border___0(config, list, (new->right_border)->kind, enc);
#line 341
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 338
  if ((unsigned int )(new->right_border)->kind != (unsigned int )(base->right_border)->kind) {
    {
#line 339
    output_simple_chars((psiconv_config )config, list, (char *)"border-right-style:",
                        (encoding )enc);
#line 340
    border___0(config, list, (new->right_border)->kind, enc);
#line 341
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  }
#line 343
  if (! base) {
    {
#line 344
    output_simple_chars((psiconv_config )config, list, (char *)"border-bottom-style:",
                        (encoding )enc);
#line 345
    border___0(config, list, (new->bottom_border)->kind, enc);
#line 346
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 343
  if ((unsigned int )(new->bottom_border)->kind != (unsigned int )(base->bottom_border)->kind) {
    {
#line 344
    output_simple_chars((psiconv_config )config, list, (char *)"border-bottom-style:",
                        (encoding )enc);
#line 345
    border___0(config, list, (new->bottom_border)->kind, enc);
#line 346
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  }
#line 348
  if (! base) {
    {
#line 349
    output_simple_chars((psiconv_config )config, list, (char *)"border-top-style:",
                        (encoding )enc);
#line 350
    border___0(config, list, (new->top_border)->kind, enc);
#line 351
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 348
  if ((unsigned int )(new->top_border)->kind != (unsigned int )(base->top_border)->kind) {
    {
#line 349
    output_simple_chars((psiconv_config )config, list, (char *)"border-top-style:",
                        (encoding )enc);
#line 350
    border___0(config, list, (new->top_border)->kind, enc);
#line 351
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  }
#line 353
  if (! base) {
    {
#line 354
    output_simple_chars((psiconv_config )config, list, (char *)"border-left-style:",
                        (encoding )enc);
#line 355
    border___0(config, list, (new->left_border)->kind, enc);
#line 356
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 353
  if ((unsigned int )(new->left_border)->kind != (unsigned int )(base->left_border)->kind) {
    {
#line 354
    output_simple_chars((psiconv_config )config, list, (char *)"border-left-style:",
                        (encoding )enc);
#line 355
    border___0(config, list, (new->left_border)->kind, enc);
#line 356
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  }
#line 359
  if (! base) {
    {
#line 362
    output_simple_chars((psiconv_config )config, list, (char *)"border-right-width:",
                        (encoding )enc);
#line 363
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )(new->right_border)->thickness);
#line 364
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 365
    output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
    }
  } else
#line 359
  if ((unsigned int )(new->right_border)->kind != 0U) {
#line 359
    if ((new->right_border)->thickness != (base->right_border)->thickness) {
      {
#line 362
      output_simple_chars((psiconv_config )config, list, (char *)"border-right-width:",
                          (encoding )enc);
#line 363
      snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
               (double )(new->right_border)->thickness);
#line 364
      output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 365
      output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
      }
    }
  }
#line 367
  if (! base) {
    {
#line 370
    output_simple_chars((psiconv_config )config, list, (char *)"border-bottom-width:",
                        (encoding )enc);
#line 371
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )(new->bottom_border)->thickness);
#line 372
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 373
    output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
    }
  } else
#line 367
  if ((unsigned int )(new->bottom_border)->kind != 0U) {
#line 367
    if ((new->bottom_border)->thickness != (base->bottom_border)->thickness) {
      {
#line 370
      output_simple_chars((psiconv_config )config, list, (char *)"border-bottom-width:",
                          (encoding )enc);
#line 371
      snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
               (double )(new->bottom_border)->thickness);
#line 372
      output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 373
      output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
      }
    }
  }
#line 375
  if (! base) {
    {
#line 378
    output_simple_chars((psiconv_config )config, list, (char *)"border-top-width:",
                        (encoding )enc);
#line 379
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )(new->top_border)->thickness);
#line 380
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 381
    output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
    }
  } else
#line 375
  if ((unsigned int )(new->top_border)->kind != 0U) {
#line 375
    if ((new->top_border)->thickness != (base->top_border)->thickness) {
      {
#line 378
      output_simple_chars((psiconv_config )config, list, (char *)"border-top-width:",
                          (encoding )enc);
#line 379
      snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
               (double )(new->top_border)->thickness);
#line 380
      output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 381
      output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
      }
    }
  }
#line 383
  if (! base) {
    {
#line 386
    output_simple_chars((psiconv_config )config, list, (char *)"border-left-width:",
                        (encoding )enc);
#line 387
    snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
             (double )(new->left_border)->thickness);
#line 388
    output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 389
    output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
    }
  } else
#line 383
  if ((unsigned int )(new->left_border)->kind != 0U) {
#line 383
    if ((new->left_border)->thickness != (base->left_border)->thickness) {
      {
#line 386
      output_simple_chars((psiconv_config )config, list, (char *)"border-left-width:",
                          (encoding )enc);
#line 387
      snprintf((char */* __restrict  */)(tempstr), (size_t )100, (char const   */* __restrict  */)"%f",
               (double )(new->left_border)->thickness);
#line 388
      output_simple_chars((psiconv_config )config, list, tempstr, (encoding )enc);
#line 389
      output_simple_chars((psiconv_config )config, list, (char *)"pt;", (encoding )enc);
      }
    }
  }
#line 392
  if (! base) {
    {
#line 397
    output_simple_chars((psiconv_config )config, list, (char *)"border-right-color:",
                        (encoding )enc);
#line 398
    color___0(config, list, (new->right_border)->color, 0, enc);
#line 399
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 392
  if ((unsigned int )(new->right_border)->kind != 0U) {
#line 392
    if ((int )((new->right_border)->color)->red != (int )((base->right_border)->color)->red) {
      {
#line 397
      output_simple_chars((psiconv_config )config, list, (char *)"border-right-color:",
                          (encoding )enc);
#line 398
      color___0(config, list, (new->right_border)->color, 0, enc);
#line 399
      output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
      }
    } else
#line 392
    if ((int )((new->right_border)->color)->green != (int )((base->right_border)->color)->green) {
      {
#line 397
      output_simple_chars((psiconv_config )config, list, (char *)"border-right-color:",
                          (encoding )enc);
#line 398
      color___0(config, list, (new->right_border)->color, 0, enc);
#line 399
      output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
      }
    } else
#line 392
    if ((int )((new->right_border)->color)->blue != (int )((base->right_border)->color)->blue) {
      {
#line 397
      output_simple_chars((psiconv_config )config, list, (char *)"border-right-color:",
                          (encoding )enc);
#line 398
      color___0(config, list, (new->right_border)->color, 0, enc);
#line 399
      output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
      }
    }
  }
#line 401
  if (! base) {
    {
#line 406
    output_simple_chars((psiconv_config )config, list, (char *)"border-top-color:",
                        (encoding )enc);
#line 407
    color___0(config, list, (new->top_border)->color, 0, enc);
#line 408
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 401
  if ((unsigned int )(new->top_border)->kind != 0U) {
#line 401
    if ((int )((new->top_border)->color)->red != (int )((base->top_border)->color)->red) {
      {
#line 406
      output_simple_chars((psiconv_config )config, list, (char *)"border-top-color:",
                          (encoding )enc);
#line 407
      color___0(config, list, (new->top_border)->color, 0, enc);
#line 408
      output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
      }
    } else
#line 401
    if ((int )((new->top_border)->color)->green != (int )((base->top_border)->color)->green) {
      {
#line 406
      output_simple_chars((psiconv_config )config, list, (char *)"border-top-color:",
                          (encoding )enc);
#line 407
      color___0(config, list, (new->top_border)->color, 0, enc);
#line 408
      output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
      }
    } else
#line 401
    if ((int )((new->top_border)->color)->blue != (int )((base->top_border)->color)->blue) {
      {
#line 406
      output_simple_chars((psiconv_config )config, list, (char *)"border-top-color:",
                          (encoding )enc);
#line 407
      color___0(config, list, (new->top_border)->color, 0, enc);
#line 408
      output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
      }
    }
  }
#line 410
  if (! base) {
    {
#line 415
    output_simple_chars((psiconv_config )config, list, (char *)"border-bottom-color:",
                        (encoding )enc);
#line 416
    color___0(config, list, (new->bottom_border)->color, 0, enc);
#line 417
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 410
  if ((unsigned int )(new->bottom_border)->kind != 0U) {
#line 410
    if ((int )((new->bottom_border)->color)->red != (int )((base->bottom_border)->color)->red) {
      {
#line 415
      output_simple_chars((psiconv_config )config, list, (char *)"border-bottom-color:",
                          (encoding )enc);
#line 416
      color___0(config, list, (new->bottom_border)->color, 0, enc);
#line 417
      output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
      }
    } else
#line 410
    if ((int )((new->bottom_border)->color)->green != (int )((base->bottom_border)->color)->green) {
      {
#line 415
      output_simple_chars((psiconv_config )config, list, (char *)"border-bottom-color:",
                          (encoding )enc);
#line 416
      color___0(config, list, (new->bottom_border)->color, 0, enc);
#line 417
      output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
      }
    } else
#line 410
    if ((int )((new->bottom_border)->color)->blue != (int )((base->bottom_border)->color)->blue) {
      {
#line 415
      output_simple_chars((psiconv_config )config, list, (char *)"border-bottom-color:",
                          (encoding )enc);
#line 416
      color___0(config, list, (new->bottom_border)->color, 0, enc);
#line 417
      output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
      }
    }
  }
#line 419
  if (! base) {
    {
#line 424
    output_simple_chars((psiconv_config )config, list, (char *)"border-left-color:",
                        (encoding )enc);
#line 425
    color___0(config, list, (new->left_border)->color, 0, enc);
#line 426
    output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
    }
  } else
#line 419
  if ((unsigned int )(new->left_border)->kind != 0U) {
#line 419
    if ((int )((new->left_border)->color)->red != (int )((base->left_border)->color)->red) {
      {
#line 424
      output_simple_chars((psiconv_config )config, list, (char *)"border-left-color:",
                          (encoding )enc);
#line 425
      color___0(config, list, (new->left_border)->color, 0, enc);
#line 426
      output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
      }
    } else
#line 419
    if ((int )((new->left_border)->color)->green != (int )((base->left_border)->color)->green) {
      {
#line 424
      output_simple_chars((psiconv_config )config, list, (char *)"border-left-color:",
                          (encoding )enc);
#line 425
      color___0(config, list, (new->left_border)->color, 0, enc);
#line 426
      output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
      }
    } else
#line 419
    if ((int )((new->left_border)->color)->blue != (int )((base->left_border)->color)->blue) {
      {
#line 424
      output_simple_chars((psiconv_config )config, list, (char *)"border-left-color:",
                          (encoding )enc);
#line 425
      color___0(config, list, (new->left_border)->color, 0, enc);
#line 426
      output_simple_chars((psiconv_config )config, list, (char *)";", (encoding )enc);
      }
    }
  }
#line 428
  return;
}
}
#line 430 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void style___0(psiconv_config const   config , psiconv_list list , psiconv_word_style const   style___1 ,
                      psiconv_paragraph_layout const   base_para , psiconv_character_layout const   base_char ,
                      encoding const   enc ) 
{ 


  {
  {
#line 436
  output_simple_chars((psiconv_config )config, list, (char *)"*.style_", (encoding )enc);
#line 437
  style_name___0(config, list, (psiconv_string_t const   )style___1->name, enc);
#line 438
  output_simple_chars((psiconv_config )config, list, (char *)" {", (encoding )enc);
#line 439
  paragraph_layout_diffs___0(config, list, (psiconv_paragraph_layout const   )style___1->paragraph,
                             base_para, enc);
#line 440
  character_layout_diffs___0(config, list, (psiconv_character_layout const   )style___1->character,
                             base_char, enc);
#line 441
  output_simple_chars((psiconv_config )config, list, (char *)"}\n", (encoding )enc);
  }
#line 442
  return;
}
}
#line 444 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void styles___0(psiconv_config const   config , psiconv_list list , psiconv_word_styles_section const   styles_sec ,
                       encoding const   enc ) 
{ 
  int i ;
  psiconv_word_style styl ;
  psiconv_character_layout base_char ;
  psiconv_paragraph_layout base_para ;
  void *tmp ;
  psiconv_u32 tmp___0 ;

  {
  {
#line 452
  base_char = psiconv_basic_character_layout();
  }
#line 452
  if (! base_char) {
    {
#line 453
    fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 454
    exit(1);
    }
  }
  {
#line 456
  base_para = psiconv_basic_paragraph_layout();
  }
#line 456
  if (! base_para) {
    {
#line 457
    fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 458
    exit(1);
    }
  }
  {
#line 461
  output_simple_chars((psiconv_config )config, list, (char *)"<style type=\"text/css\">\n",
                      (encoding )enc);
#line 464
  output_simple_chars((psiconv_config )config, list, (char *)"body {", (encoding )enc);
#line 465
  paragraph_layout_diffs___0(config, list, (psiconv_paragraph_layout const   )base_para,
                             (psiconv_paragraph_layout const   )((void *)0), enc);
#line 466
  character_layout_diffs___0(config, list, (psiconv_character_layout const   )base_char,
                             (psiconv_character_layout const   )((void *)0), enc);
#line 467
  output_simple_chars((psiconv_config )config, list, (char *)"}\n", (encoding )enc);
  }
#line 469
  if (styles_sec) {
    {
#line 470
    style___0(config, list, (psiconv_word_style const   )styles_sec->normal, (psiconv_paragraph_layout const   )base_para,
              (psiconv_character_layout const   )base_char, enc);
#line 472
    i = 0;
    }
    {
#line 472
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 472
      tmp___0 = psiconv_list_length((psiconv_list const   )styles_sec->styles);
      }
#line 472
      if (! ((psiconv_u32 )i < tmp___0)) {
#line 472
        goto while_break;
      }
      {
#line 473
      tmp = psiconv_list_get((psiconv_list const   )styles_sec->styles, (psiconv_u32 )i);
#line 473
      styl = (psiconv_word_style )tmp;
      }
#line 473
      if (! styl) {
        {
#line 474
        fputs((char const   */* __restrict  */)"Internal datastructure corruption\n",
              (FILE */* __restrict  */)stderr);
#line 475
        exit(1);
        }
      }
      {
#line 477
      style___0(config, list, (psiconv_word_style const   )styl, (psiconv_paragraph_layout const   )base_para,
                (psiconv_character_layout const   )base_char, enc);
#line 472
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 482
  output_simple_chars((psiconv_config )config, list, (char *)"</style>\n", (encoding )enc);
  }
#line 483
  return;
}
}
#line 485 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void header___2(psiconv_config const   config , psiconv_list list , psiconv_word_styles_section const   styles_sec ,
                       encoding const   enc ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 488
  output_simple_chars((psiconv_config )config, list, (char *)"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n",
                      (encoding )enc);
#line 490
  output_simple_chars((psiconv_config )config, list, (char *)"<!DOCTYPE html PUBLIC ",
                      (encoding )enc);
#line 491
  output_simple_chars((psiconv_config )config, list, (char *)"\"-//W3C//DTD XHTML 1.0 Strict//EN\" ",
                      (encoding )enc);
#line 492
  output_simple_chars((psiconv_config )config, list, (char *)"\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">",
                      (encoding )enc);
#line 495
  output_simple_chars((psiconv_config )config, list, (char *)"\n<html", (encoding )enc);
#line 496
  output_simple_chars((psiconv_config )config, list, (char *)" xmlns=\"http://www.w3.org/1999/xhtml\"",
                      (encoding )enc);
#line 498
  output_simple_chars((psiconv_config )config, list, (char *)">\n", (encoding )enc);
#line 499
  output_simple_chars((psiconv_config )config, list, (char *)"<head>\n", (encoding )enc);
#line 500
  output_simple_chars((psiconv_config )config, list, (char *)"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=",
                      (encoding )enc);
  }
#line 502
  if ((unsigned int const   )enc == 0U) {
#line 502
    tmp___1 = "UTF-8";
  } else {
#line 502
    if ((unsigned int const   )enc == 1U) {
#line 502
      tmp___0 = "UTF-16BE";
    } else {
#line 502
      if ((unsigned int const   )enc == 3U) {
#line 502
        tmp = "US-ASCII";
      } else {
#line 502
        tmp = "";
      }
#line 502
      tmp___0 = tmp;
    }
#line 502
    tmp___1 = tmp___0;
  }
  {
#line 502
  output_simple_chars((psiconv_config )config, list, (char *)tmp___1, (encoding )enc);
#line 506
  output_simple_chars((psiconv_config )config, list, (char *)"\">\n", (encoding )enc);
#line 507
  output_simple_chars((psiconv_config )config, list, (char *)"<meta http-equiv=\"Content-Style-Type\" content=\"text/css\">\n",
                      (encoding )enc);
#line 509
  output_simple_chars((psiconv_config )config, list, (char *)"<title>EPOC32 file converted by psiconv</title>\n",
                      (encoding )enc);
#line 511
  styles___0(config, list, styles_sec, enc);
#line 512
  output_simple_chars((psiconv_config )config, list, (char *)"</head>\n", (encoding )enc);
#line 513
  output_simple_chars((psiconv_config )config, list, (char *)"<body>\n", (encoding )enc);
  }
#line 514
  return;
}
}
#line 516 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void footer___2(psiconv_config const   config , psiconv_list list , encoding const   enc ) 
{ 


  {
  {
#line 518
  output_simple_chars((psiconv_config )config, list, (char *)"</body>\n", (encoding )enc);
#line 519
  output_simple_chars((psiconv_config )config, list, (char *)"</html>\n", (encoding )enc);
  }
#line 520
  return;
}
}
#line 522 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void characters___2(psiconv_config const   config , psiconv_list list , psiconv_string_t const   textstr ,
                           psiconv_character_layout const   layout , psiconv_character_layout const   base ,
                           encoding const   enc ) 
{ 
  psiconv_list templist ;
  int tmp ;
  psiconv_u32 tmp___0 ;
  psiconv_u32 tmp___1 ;

  {
  {
#line 530
  templist = psiconv_list_new(sizeof(psiconv_u8 ));
  }
#line 530
  if (! templist) {
    {
#line 531
    fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 532
    exit(1);
    }
  }
  {
#line 534
  character_layout_diffs___0(config, templist, layout, base, enc);
#line 536
  tmp___0 = psiconv_list_length((psiconv_list const   )templist);
  }
#line 536
  if (tmp___0) {
    {
#line 537
    output_simple_chars((psiconv_config )config, list, (char *)"<span style=\"", (encoding )enc);
#line 538
    tmp = psiconv_list_concat(list, (psiconv_list const   )templist);
    }
#line 538
    if (tmp) {
      {
#line 539
      fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 540
      exit(1);
      }
    }
    {
#line 542
    output_simple_chars((psiconv_config )config, list, (char *)"\">", (encoding )enc);
    }
  }
  {
#line 545
  text___2(config, list, (psiconv_string_t )textstr, enc);
#line 547
  tmp___1 = psiconv_list_length((psiconv_list const   )templist);
  }
#line 547
  if (tmp___1) {
    {
#line 548
    output_simple_chars((psiconv_config )config, list, (char *)"</span>", (encoding )enc);
    }
  }
  {
#line 551
  psiconv_list_free(templist);
  }
#line 552
  return;
}
}
#line 554 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void paragraph___2(psiconv_config const   config , psiconv_list list , psiconv_paragraph const   para ,
                          psiconv_word_styles_section const   styles_sec , encoding const   enc ) 
{ 
  int i ;
  int charnr ;
  int start ;
  int len ;
  psiconv_string_t text___3 ;
  psiconv_in_line_layout layout ;
  psiconv_in_line_layout next_layout ;
  psiconv_word_style style___1 ;
  psiconv_paragraph_layout base_para ;
  psiconv_character_layout base_char ;
  psiconv_list templist ;
  char const   *tmp ;
  int tmp___0 ;
  psiconv_u32 tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  psiconv_u32 tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  psiconv_u32 tmp___8 ;
  psiconv_u32 tmp___9 ;
  char const   *tmp___10 ;

  {
  {
#line 562
  style___1 = (psiconv_word_style )((void *)0);
#line 567
  templist = psiconv_list_new(sizeof(psiconv_u8 ));
  }
#line 567
  if (! templist) {
    {
#line 568
    fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 569
    exit(1);
    }
  }
#line 572
  if (styles_sec) {
    {
#line 573
    style___1 = psiconv_get_style((psiconv_word_styles_section )styles_sec, (int )para->base_style);
    }
#line 573
    if (! style___1) {
      {
#line 574
      fputs((char const   */* __restrict  */)"Unknown style found; data corrupt\n",
            (FILE */* __restrict  */)stderr);
#line 575
      exit(1);
      }
    }
#line 577
    base_para = style___1->paragraph;
#line 578
    base_char = style___1->character;
  } else {
    {
#line 580
    base_para = psiconv_basic_paragraph_layout();
#line 581
    base_char = psiconv_basic_character_layout();
    }
#line 582
    if (! base_para) {
      {
#line 583
      fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 584
      exit(1);
      }
    } else
#line 582
    if (! base_char) {
      {
#line 583
      fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 584
      exit(1);
      }
    }
  }
#line 588
  if (((para->base_paragraph)->bullet)->on) {
#line 588
    tmp = "<ul><li ";
  } else {
#line 588
    tmp = "<p ";
  }
  {
#line 588
  output_simple_chars((psiconv_config )config, list, (char *)tmp, (encoding )enc);
  }
#line 592
  if (styles_sec) {
    {
#line 593
    output_simple_chars((psiconv_config )config, list, (char *)"class=\"style_", (encoding )enc);
#line 594
    style_name___0(config, list, (psiconv_string_t const   )style___1->name, enc);
#line 595
    output_simple_chars((psiconv_config )config, list, (char *)"\" ", (encoding )enc);
    }
  }
  {
#line 598
  paragraph_layout_diffs___0(config, templist, (psiconv_paragraph_layout const   )para->base_paragraph,
                             (psiconv_paragraph_layout const   )base_para, enc);
#line 599
  character_layout_diffs___0(config, templist, (psiconv_character_layout const   )para->base_character,
                             (psiconv_character_layout const   )base_char, enc);
#line 601
  tmp___1 = psiconv_list_length((psiconv_list const   )templist);
  }
#line 601
  if (tmp___1) {
    {
#line 602
    output_simple_chars((psiconv_config )config, list, (char *)"style=\"", (encoding )enc);
#line 603
    tmp___0 = psiconv_list_concat(list, (psiconv_list const   )templist);
    }
#line 603
    if (tmp___0) {
      {
#line 604
      fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 605
      exit(1);
      }
    }
    {
#line 607
    output_simple_chars((psiconv_config )config, list, (char *)"\"", (encoding )enc);
    }
  }
  {
#line 609
  output_simple_chars((psiconv_config )config, list, (char *)">", (encoding )enc);
#line 611
  tmp___9 = psiconv_list_length((psiconv_list const   )para->in_lines);
  }
#line 611
  if (tmp___9 == 0U) {
    {
#line 612
    tmp___2 = psiconv_unicode_strlen((psiconv_ucs2 const   *)para->text);
    }
#line 612
    if (tmp___2) {
      {
#line 613
      characters___2(config, list, (psiconv_string_t const   )para->text, (psiconv_character_layout const   )para->base_character,
                     (psiconv_character_layout const   )para->base_character, enc);
      }
    }
  } else {
#line 616
    charnr = 0;
#line 617
    start = -1;
#line 618
    i = 0;
    {
#line 618
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 618
      tmp___8 = psiconv_list_length((psiconv_list const   )para->in_lines);
      }
#line 618
      if (! ((psiconv_u32 )i < tmp___8)) {
#line 618
        goto while_break;
      }
#line 619
      if (start < 0) {
#line 620
        start = charnr;
      }
      {
#line 621
      tmp___3 = psiconv_list_get((psiconv_list const   )para->in_lines, (psiconv_u32 )i);
#line 621
      layout = (psiconv_in_line_layout )tmp___3;
      }
#line 621
      if (! layout) {
        {
#line 622
        fputs((char const   */* __restrict  */)"Internal data structures corruption\n",
              (FILE */* __restrict  */)stderr);
#line 623
        exit(1);
        }
      }
      {
#line 625
      tmp___5 = psiconv_list_length((psiconv_list const   )para->in_lines);
      }
#line 625
      if ((psiconv_u32 )(i + 1) < tmp___5) {
        {
#line 626
        tmp___4 = psiconv_list_get((psiconv_list const   )para->in_lines, (psiconv_u32 )(i + 1));
#line 626
        next_layout = (psiconv_in_line_layout )tmp___4;
        }
#line 626
        if (! next_layout) {
          {
#line 627
          fputs((char const   */* __restrict  */)"Internal data structures corruption\n",
                (FILE */* __restrict  */)stderr);
#line 628
          exit(1);
          }
        }
      } else {
#line 631
        next_layout = (psiconv_in_line_layout )((void *)0);
      }
#line 633
      if (next_layout) {
        {
#line 633
        tmp___6 = character_layout_equal___1((psiconv_character_layout const   )layout->layout,
                                             (psiconv_character_layout const   )next_layout->layout);
        }
#line 633
        if (tmp___6) {
#line 635
          charnr += layout->length;
#line 636
          goto __Cont;
        }
      }
#line 638
      len = (charnr - start) + layout->length;
#line 639
      if (len) {
        {
#line 640
        tmp___7 = malloc(sizeof(*text___3) * (unsigned long )(len + 1));
#line 640
        text___3 = (psiconv_string_t )tmp___7;
        }
#line 640
        if (! text___3) {
          {
#line 641
          fputs((char const   */* __restrict  */)"Out of memory error\n", (FILE */* __restrict  */)stderr);
#line 642
          exit(1);
          }
        }
        {
#line 644
        memcpy((void */* __restrict  */)text___3, (void const   */* __restrict  */)(para->text + start),
               (unsigned long )len * sizeof(*text___3));
#line 645
        *(text___3 + len) = (psiconv_ucs2 )0;
#line 646
        characters___2(config, list, (psiconv_string_t const   )text___3, (psiconv_character_layout const   )layout->layout,
                       (psiconv_character_layout const   )para->base_character, enc);
#line 647
        free((void *)text___3);
        }
      }
#line 649
      charnr += layout->length;
#line 650
      start = -1;
      __Cont: /* CIL Label */ 
#line 618
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 653
  if (((para->base_paragraph)->bullet)->on) {
#line 653
    tmp___10 = "</li></ul>\n";
  } else {
#line 653
    tmp___10 = "</p>\n";
  }
  {
#line 653
  output_simple_chars((psiconv_config )config, list, (char *)tmp___10, (encoding )enc);
  }
#line 656
  if (! styles_sec) {
    {
#line 657
    psiconv_free_paragraph_layout(base_para);
#line 658
    psiconv_free_character_layout(base_char);
    }
  }
  {
#line 660
  psiconv_list_free(templist);
  }
#line 661
  return;
}
}
#line 663 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void paragraphs___2(psiconv_config const   config , psiconv_list list , psiconv_text_and_layout paragraphs___3 ,
                           psiconv_word_styles_section const   styles___1 , encoding const   enc ) 
{ 
  int i ;
  psiconv_paragraph para ;
  void *tmp ;
  psiconv_u32 tmp___0 ;

  {
#line 670
  i = 0;
  {
#line 670
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 670
    tmp___0 = psiconv_list_length((psiconv_list const   )paragraphs___3);
    }
#line 670
    if (! ((psiconv_u32 )i < tmp___0)) {
#line 670
      goto while_break;
    }
    {
#line 671
    tmp = psiconv_list_get((psiconv_list const   )paragraphs___3, (psiconv_u32 )i);
#line 671
    para = (psiconv_paragraph )tmp;
    }
#line 671
    if (! para) {
      {
#line 672
      fputs((char const   */* __restrict  */)"Internal datastructure corruption\n",
            (FILE */* __restrict  */)stderr);
#line 673
      exit(1);
      }
    }
    {
#line 675
    paragraph___2(config, list, (psiconv_paragraph const   )para, styles___1, enc);
#line 670
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 677
  return;
}
}
#line 679 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void gen_word___4(psiconv_config const   config , psiconv_list list , psiconv_word_f const   file ,
                         encoding const   enc ) 
{ 


  {
#line 682
  if (! file) {
#line 683
    return;
  }
  {
#line 685
  header___2(config, list, (psiconv_word_styles_section const   )file->styles_sec,
             enc);
#line 686
  paragraphs___2(config, list, file->paragraphs, (psiconv_word_styles_section const   )file->styles_sec,
                 enc);
#line 687
  footer___2(config, list, enc);
  }
#line 688
  return;
}
}
#line 691 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static void gen_texted___4(psiconv_config const   config , psiconv_list list , psiconv_texted_f const   file ,
                           encoding const   enc ) 
{ 


  {
  {
#line 694
  header___2(config, list, (psiconv_word_styles_section const   )((void *)0), enc);
#line 695
  paragraphs___2(config, list, (file->texted_sec)->paragraphs, (psiconv_word_styles_section const   )((void *)0),
                 enc);
#line 696
  footer___2(config, list, enc);
  }
#line 697
  return;
}
}
#line 699 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static int gen_xhtml___0(psiconv_config const   config , psiconv_list list , psiconv_file const   file ,
                         char const   *dest , encoding const   enc ) 
{ 
  encoding enc1 ;

  {
#line 703
  enc1 = (encoding )enc;
#line 705
  if ((unsigned int const   )enc == 2U) {
    {
#line 706
    fputs((char const   */* __restrict  */)"Unsupported encoding\n", (FILE */* __restrict  */)stderr);
    }
#line 707
    return (-1);
  } else
#line 708
  if ((unsigned int const   )enc == 3U) {
#line 709
    enc1 = (encoding )4;
  }
#line 711
  if ((unsigned int )file->type == 1U) {
    {
#line 712
    gen_word___4(config, list, (psiconv_word_f const   )((psiconv_word_f )file->file),
                 (encoding const   )enc1);
    }
#line 713
    return (0);
  } else
#line 714
  if ((unsigned int )file->type == 2U) {
    {
#line 715
    gen_texted___4(config, list, (psiconv_texted_f const   )((psiconv_texted_f )file->file),
                   (encoding const   )enc1);
    }
#line 716
    return (0);
  } else {
#line 718
    return (-1);
  }
}
}
#line 722 "/home/wheatley/newnew/temp/psiconv-0.9.8/program/psiconv/gen_xhtml.c"
static struct fileformat_s fileformats___2[2]  = {      {"XHTML", "XHTML 1.0 Strict, using CSS for formatting", 3, & gen_xhtml___0}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), 0, (output_function *)((void *)0)}};
#line 33 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_color clone_color___3(psiconv_color color___1 ) ;
#line 34
static psiconv_font clone_font___3(psiconv_font font___9 ) ;
#line 35
static psiconv_border clone_border___3(psiconv_border border___1 ) ;
#line 36
static psiconv_bullet clone_bullet___3(psiconv_bullet bullet___4 ) ;
#line 37
static psiconv_all_tabs clone_all_tabs___3(psiconv_all_tabs all_tabs ) ;
#line 38
static void psiconv_free_style_aux___3(void *style___1 ) ;
#line 39
static void psiconv_free_in_line_layout_aux___3(void *layout ) ;
#line 40
static void psiconv_free_paragraph_aux___3(void *paragraph___3 ) ;
#line 41
static void psiconv_free_paint_data_section_aux___3(void *section ) ;
#line 42
static void psiconv_free_clipart_section_aux___3(void *section ) ;
#line 43
static void psiconv_free_formula_aux___3(void *data ) ;
#line 44
static void psiconv_free_sheet_worksheet_aux___3(void *data ) ;
#line 45
static void psiconv_free_sheet_variable_aux___3(void *variable ) ;
#line 46
static void psiconv_free_sheet_cell_aux___3(void *cell ) ;
#line 47
static void psiconv_free_sheet_line_aux___3(void *line ) ;
#line 50
static psiconv_word_styles_section psiconv_empty_word_styles_section___3(void) ;
#line 51
static psiconv_text_and_layout psiconv_empty_text_and_layout___3(void) ;
#line 52
static psiconv_texted_section psiconv_empty_texted_section___3(void) ;
#line 53
static psiconv_page_header psiconv_empty_page_header___3(void) ;
#line 54
static psiconv_page_layout_section psiconv_empty_page_layout_section___3(void) ;
#line 55
static psiconv_word_status_section psiconv_empty_word_status_section___3(void) ;
#line 56
static psiconv_word_f psiconv_empty_word_f___3(void) ;
#line 57
static psiconv_sheet_status_section psiconv_empty_sheet_status_section___3(void) ;
#line 58
static psiconv_formula_list psiconv_empty_formula_list___3(void) ;
#line 59
static psiconv_sheet_workbook_section psiconv_empty_sheet_workbook_section___3(void) ;
#line 61
static psiconv_sheet_f psiconv_empty_sheet_f___3(void) ;
#line 62
static psiconv_texted_f psiconv_empty_texted_f___3(void) ;
#line 63
static psiconv_paint_data_section psiconv_empty_paint_data_section___3(void) ;
#line 64
static psiconv_pictures psiconv_empty_pictures___3(void) ;
#line 65
static psiconv_mbm_f psiconv_empty_mbm_f___3(void) ;
#line 66
static psiconv_sketch_section psiconv_empty_sketch_section___3(void) ;
#line 67
static psiconv_sketch_f psiconv_empty_sketch_f___3(void) ;
#line 68
static psiconv_clipart_f psiconv_empty_clipart_f___3(void) ;
#line 69
static psiconv_cliparts psiconv_empty_cliparts___3(void) ;
#line 77 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_color_s black___7  =    {(psiconv_u8 )0, (psiconv_u8 )0, (psiconv_u8 )0};
#line 83 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_color_s white___7  =    {(psiconv_u8 )255, (psiconv_u8 )255, (psiconv_u8 )255};
#line 89 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_ucs2 font_times___7[16]  = 
#line 89
  {      (psiconv_ucs2 )'T',      (psiconv_ucs2 )'i',      (psiconv_ucs2 )'m',      (psiconv_ucs2 )'e', 
        (psiconv_ucs2 )'s',      (psiconv_ucs2 )' ',      (psiconv_ucs2 )'N',      (psiconv_ucs2 )'e', 
        (psiconv_ucs2 )'w',      (psiconv_ucs2 )' ',      (psiconv_ucs2 )'R',      (psiconv_ucs2 )'o', 
        (psiconv_ucs2 )'m',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'n',      (psiconv_ucs2 )0};
#line 92 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_font_s font___7  =    {font_times___7, (psiconv_screenfont_t )3};
#line 117 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_ucs2 font_times___8[16]  = 
#line 117
  {      (psiconv_ucs2 )'T',      (psiconv_ucs2 )'i',      (psiconv_ucs2 )'m',      (psiconv_ucs2 )'e', 
        (psiconv_ucs2 )'s',      (psiconv_ucs2 )' ',      (psiconv_ucs2 )'N',      (psiconv_ucs2 )'e', 
        (psiconv_ucs2 )'w',      (psiconv_ucs2 )' ',      (psiconv_ucs2 )'R',      (psiconv_ucs2 )'o', 
        (psiconv_ucs2 )'m',      (psiconv_ucs2 )'a',      (psiconv_ucs2 )'n',      (psiconv_ucs2 )0};
#line 121 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_font_s font___8  =    {font_times___8, (psiconv_screenfont_t )2};
#line 126 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_color_s black___8  =    {(psiconv_u8 )0, (psiconv_u8 )0, (psiconv_u8 )0};
#line 132 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_color_s white___8  =    {(psiconv_u8 )255, (psiconv_u8 )255, (psiconv_u8 )255};
#line 138 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_border_s no_border___3  =    {(psiconv_border_kind_t )0, (psiconv_size_t )1, & black___8};
#line 144 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_bullet_s bullet___3  =    {(psiconv_bool_t )0, (psiconv_size_t )10.0, (psiconv_ucs2 )8221, (psiconv_bool_t )1,
    & black___8, & font___8};
#line 153 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static struct psiconv_all_tabs_s tabs___3  =    {(psiconv_length_t )0.64, (psiconv_tab_list )((void *)0)};
#line 192 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_color clone_color___3(psiconv_color color___1 ) 
{ 
  psiconv_color result ;
  void *tmp ;

  {
  {
#line 195
  tmp = malloc(sizeof(*result));
#line 195
  result = (psiconv_color )tmp;
  }
#line 195
  if (! result) {
#line 196
    return ((psiconv_color )((void *)0));
  }
#line 197
  *result = *color___1;
#line 198
  return (result);
}
}
#line 201 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_font clone_font___3(psiconv_font font___9 ) 
{ 
  psiconv_font result ;
  void *tmp ;
  psiconv_string_t tmp___0 ;

  {
  {
#line 204
  tmp = malloc(sizeof(*result));
#line 204
  result = (psiconv_font )tmp;
  }
#line 204
  if (! result) {
#line 205
    goto ERROR1;
  }
  {
#line 206
  *result = *font___9;
#line 207
  tmp___0 = psiconv_unicode_strdup((psiconv_ucs2 const   *)result->name);
#line 207
  result->name = tmp___0;
  }
#line 207
  if (! tmp___0) {
#line 208
    goto ERROR2;
  }
#line 209
  return (result);
  ERROR2: 
  {
#line 211
  free((void *)result);
  }
  ERROR1: 
#line 213
  return ((psiconv_font )((void *)0));
}
}
#line 216 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_border clone_border___3(psiconv_border border___1 ) 
{ 
  psiconv_border result ;
  void *tmp ;
  psiconv_color tmp___0 ;

  {
  {
#line 219
  tmp = malloc(sizeof(*result));
#line 219
  result = (psiconv_border )tmp;
  }
#line 219
  if (! result) {
#line 220
    goto ERROR1;
  }
  {
#line 221
  *result = *border___1;
#line 222
  tmp___0 = clone_color___3(result->color);
#line 222
  result->color = tmp___0;
  }
#line 222
  if (! tmp___0) {
#line 223
    goto ERROR2;
  }
#line 224
  return (result);
  ERROR2: 
  {
#line 226
  free((void *)result);
  }
  ERROR1: 
#line 228
  return ((psiconv_border )((void *)0));
}
}
#line 231 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_bullet clone_bullet___3(psiconv_bullet bullet___4 ) 
{ 
  psiconv_bullet result ;
  void *tmp ;
  psiconv_font tmp___0 ;
  psiconv_color tmp___1 ;

  {
  {
#line 234
  tmp = malloc(sizeof(*result));
#line 234
  result = (psiconv_bullet )tmp;
  }
#line 234
  if (! result) {
#line 235
    goto ERROR1;
  }
  {
#line 236
  *result = *bullet___4;
#line 237
  tmp___0 = clone_font___3(result->font);
#line 237
  result->font = tmp___0;
  }
#line 237
  if (! tmp___0) {
#line 238
    goto ERROR2;
  }
  {
#line 239
  tmp___1 = clone_color___3(result->color);
#line 239
  result->color = tmp___1;
  }
#line 239
  if (! tmp___1) {
#line 240
    goto ERROR3;
  }
#line 241
  return (result);
  ERROR3: 
  {
#line 243
  psiconv_free_font(result->font);
  }
  ERROR2: 
  {
#line 245
  free((void *)result);
  }
  ERROR1: 
#line 247
  return ((psiconv_bullet )((void *)0));
}
}
#line 250 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_all_tabs clone_all_tabs___3(psiconv_all_tabs all_tabs ) 
{ 
  psiconv_all_tabs result ;
  void *tmp ;
  psiconv_tab_list tmp___0 ;

  {
  {
#line 253
  tmp = malloc(sizeof(*result));
#line 253
  result = (psiconv_all_tabs )tmp;
  }
#line 253
  if (! result) {
#line 254
    goto ERROR1;
  }
  {
#line 255
  *result = *all_tabs;
#line 256
  tmp___0 = psiconv_list_clone((psiconv_list const   )result->extras);
#line 256
  result->extras = tmp___0;
  }
#line 256
  if (! tmp___0) {
#line 257
    goto ERROR2;
  }
#line 258
  return (result);
  ERROR2: 
  {
#line 260
  free((void *)result);
  }
  ERROR1: 
#line 262
  return ((psiconv_all_tabs )((void *)0));
}
}
#line 464 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_style_aux___3(void *style___1 ) 
{ 


  {
#line 466
  if (((psiconv_word_style )style___1)->name) {
    {
#line 467
    free((void *)((psiconv_word_style )style___1)->name);
    }
  }
  {
#line 468
  psiconv_free_character_layout(((psiconv_word_style )style___1)->character);
#line 469
  psiconv_free_paragraph_layout(((psiconv_word_style )style___1)->paragraph);
  }
#line 470
  return;
}
}
#line 548 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_in_line_layout_aux___3(void *layout ) 
{ 


  {
  {
#line 550
  psiconv_free_character_layout(((psiconv_in_line_layout )layout)->layout);
#line 551
  psiconv_free_embedded_object_section(((psiconv_in_line_layout )layout)->object);
  }
#line 553
  return;
}
}
#line 581 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_paragraph_aux___3(void *paragraph___3 ) 
{ 


  {
#line 583
  if (((psiconv_paragraph )paragraph___3)->text) {
    {
#line 584
    free((void *)((psiconv_paragraph )paragraph___3)->text);
    }
  }
  {
#line 585
  psiconv_free_character_layout(((psiconv_paragraph )paragraph___3)->base_character);
#line 587
  psiconv_free_paragraph_layout(((psiconv_paragraph )paragraph___3)->base_paragraph);
#line 589
  psiconv_free_in_line_layouts(((psiconv_paragraph )paragraph___3)->in_lines);
#line 591
  psiconv_free_replacements(((psiconv_paragraph )paragraph___3)->replacements);
  }
#line 593
  return;
}
}
#line 672 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_sheet_cell_aux___3(void *cell ) 
{ 
  psiconv_sheet_cell data ;

  {
  {
#line 674
  data = (psiconv_sheet_cell )cell;
#line 676
  psiconv_free_sheet_cell_layout(data->layout);
  }
#line 678
  if ((unsigned int )data->type == 5U) {
#line 678
    if (data->data.dat_string) {
      {
#line 679
      free((void *)data->data.dat_string);
      }
    }
  }
#line 680
  return;
}
}
#line 696 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_sheet_line_aux___3(void *line ) 
{ 
  psiconv_sheet_line data ;

  {
  {
#line 698
  data = (psiconv_sheet_line )line;
#line 700
  psiconv_free_sheet_cell_layout(data->layout);
  }
#line 701
  return;
}
}
#line 747 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_sheet_worksheet_aux___3(void *data ) 
{ 
  psiconv_sheet_worksheet section ;

  {
  {
#line 749
  section = (psiconv_sheet_worksheet )data;
#line 750
  psiconv_free_sheet_cell_layout(section->default_layout);
#line 751
  psiconv_free_sheet_cell_list(section->cells);
#line 752
  psiconv_free_sheet_line_list(section->row_default_layouts);
#line 753
  psiconv_free_sheet_line_list(section->col_default_layouts);
#line 754
  psiconv_free_sheet_grid_section(section->grid);
  }
#line 755
  return;
}
}
#line 771 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_formula_aux___3(void *data ) 
{ 
  psiconv_formula formula ;

  {
#line 774
  formula = (psiconv_formula )data;
#line 775
  if ((unsigned int )formula->type == 23U) {
    {
#line 776
    free((void *)formula->data.dat_string);
    }
  } else
#line 777
  if ((unsigned int )formula->type != 21U) {
#line 777
    if ((unsigned int )formula->type != 22U) {
#line 777
      if ((unsigned int )formula->type != 20U) {
#line 777
        if ((unsigned int )formula->type != 24U) {
#line 777
          if ((unsigned int )formula->type != 25U) {
#line 777
            if ((unsigned int )formula->type != 26U) {
#line 777
              if ((unsigned int )formula->type != 27U) {
#line 777
                if ((unsigned int )formula->type != 28U) {
#line 777
                  if ((unsigned int )formula->type != 19U) {
#line 777
                    if ((unsigned int )formula->type != 0U) {
                      {
#line 787
                      psiconv_free_formula_list(formula->data.fun_operands);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 788
  return;
}
}
#line 820 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_sheet_variable_aux___3(void *variable ) 
{ 
  psiconv_sheet_variable var ;

  {
#line 822
  var = (psiconv_sheet_variable )variable;
#line 823
  if (var->name) {
    {
#line 824
    free((void *)var->name);
    }
  }
#line 825
  if ((unsigned int )var->type == 2U) {
    {
#line 826
    free((void *)var->data.dat_string);
    }
  }
#line 827
  return;
}
}
#line 874 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_paint_data_section_aux___3(void *section ) 
{ 


  {
#line 876
  if (((psiconv_paint_data_section )section)->red) {
    {
#line 877
    free((void *)((psiconv_paint_data_section )section)->red);
    }
  }
#line 878
  if (((psiconv_paint_data_section )section)->green) {
    {
#line 879
    free((void *)((psiconv_paint_data_section )section)->green);
    }
  }
#line 880
  if (((psiconv_paint_data_section )section)->blue) {
    {
#line 881
    free((void *)((psiconv_paint_data_section )section)->blue);
    }
  }
#line 882
  return;
}
}
#line 928 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static void psiconv_free_clipart_section_aux___3(void *section ) 
{ 


  {
#line 930
  if (section) {
    {
#line 931
    psiconv_free_paint_data_section(((psiconv_clipart_section )section)->picture);
    }
  }
#line 932
  return;
}
}
#line 1112 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_word_styles_section psiconv_empty_word_styles_section___3(void) 
{ 
  psiconv_word_styles_section result ;
  void *tmp ;
  psiconv_word_style_list tmp___0 ;
  psiconv_word_style tmp___1 ;
  void *tmp___2 ;
  psiconv_character_layout tmp___3 ;
  psiconv_paragraph_layout tmp___4 ;

  {
  {
#line 1115
  tmp = malloc(sizeof(*result));
#line 1115
  result = (psiconv_word_styles_section )tmp;
  }
#line 1115
  if (! result) {
#line 1116
    goto ERROR1;
  }
  {
#line 1117
  tmp___0 = psiconv_list_new(sizeof(struct psiconv_word_style_s ));
#line 1117
  result->styles = tmp___0;
  }
#line 1117
  if (! tmp___0) {
#line 1118
    goto ERROR2;
  }
  {
#line 1119
  tmp___2 = malloc(sizeof(struct psiconv_word_style_s ));
#line 1119
  tmp___1 = (psiconv_word_style )tmp___2;
#line 1119
  result->normal = tmp___1;
  }
#line 1119
  if (! tmp___1) {
#line 1120
    goto ERROR3;
  }
  {
#line 1121
  tmp___3 = psiconv_basic_character_layout();
#line 1121
  (result->normal)->character = tmp___3;
  }
#line 1121
  if (! tmp___3) {
#line 1122
    goto ERROR4;
  }
  {
#line 1123
  tmp___4 = psiconv_basic_paragraph_layout();
#line 1123
  (result->normal)->paragraph = tmp___4;
  }
#line 1123
  if (! tmp___4) {
#line 1124
    goto ERROR5;
  }
#line 1125
  (result->normal)->hotkey = (psiconv_ucs2 )'N';
#line 1126
  (result->normal)->name = (psiconv_string_t )((void *)0);
#line 1127
  (result->normal)->built_in = (psiconv_bool_t )1;
#line 1128
  (result->normal)->outline_level = (psiconv_u32 )0;
#line 1129
  return (result);
  ERROR5: 
  {
#line 1131
  psiconv_free_character_layout((result->normal)->character);
  }
  ERROR4: 
  {
#line 1133
  free((void *)result->normal);
  }
  ERROR3: 
  {
#line 1135
  psiconv_list_free(result->styles);
  }
  ERROR2: 
  {
#line 1137
  free((void *)result);
  }
  ERROR1: 
#line 1139
  return ((psiconv_word_styles_section )((void *)0));
}
}
#line 1142 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_text_and_layout psiconv_empty_text_and_layout___3(void) 
{ 
  psiconv_list tmp ;

  {
  {
#line 1144
  tmp = psiconv_list_new(sizeof(struct psiconv_paragraph_s ));
  }
#line 1144
  return (tmp);
}
}
#line 1147 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_texted_section psiconv_empty_texted_section___3(void) 
{ 
  psiconv_texted_section result ;
  void *tmp ;
  psiconv_text_and_layout tmp___0 ;

  {
  {
#line 1150
  tmp = malloc(sizeof(*result));
#line 1150
  result = (psiconv_texted_section )tmp;
  }
#line 1150
  if (! result) {
#line 1151
    goto ERROR1;
  }
  {
#line 1152
  tmp___0 = psiconv_empty_text_and_layout___3();
#line 1152
  result->paragraphs = tmp___0;
  }
#line 1152
  if (! tmp___0) {
#line 1153
    goto ERROR2;
  }
#line 1154
  return (result);
  ERROR2: 
  {
#line 1156
  free((void *)result);
  }
  ERROR1: 
#line 1158
  return ((psiconv_texted_section )((void *)0));
}
}
#line 1161 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_page_header psiconv_empty_page_header___3(void) 
{ 
  psiconv_page_header result ;
  void *tmp ;
  psiconv_paragraph_layout tmp___0 ;
  psiconv_character_layout tmp___1 ;
  psiconv_texted_section tmp___2 ;

  {
  {
#line 1164
  tmp = malloc(sizeof(*result));
#line 1164
  result = (psiconv_page_header )tmp;
  }
#line 1164
  if (! result) {
#line 1165
    goto ERROR1;
  }
  {
#line 1166
  result->on_first_page = (psiconv_bool_t )1;
#line 1167
  tmp___0 = psiconv_basic_paragraph_layout();
#line 1167
  result->base_paragraph_layout = tmp___0;
  }
#line 1167
  if (! tmp___0) {
#line 1168
    goto ERROR2;
  }
  {
#line 1169
  tmp___1 = psiconv_basic_character_layout();
#line 1169
  result->base_character_layout = tmp___1;
  }
#line 1169
  if (! tmp___1) {
#line 1170
    goto ERROR3;
  }
  {
#line 1171
  tmp___2 = psiconv_empty_texted_section___3();
#line 1171
  result->text = tmp___2;
  }
#line 1171
  if (! tmp___2) {
#line 1172
    goto ERROR4;
  }
#line 1173
  return (result);
  ERROR4: 
  {
#line 1175
  psiconv_free_character_layout(result->base_character_layout);
  }
  ERROR3: 
  {
#line 1177
  psiconv_free_paragraph_layout(result->base_paragraph_layout);
  }
  ERROR2: 
  {
#line 1179
  free((void *)result);
  }
  ERROR1: 
#line 1181
  return ((psiconv_page_header )((void *)0));
}
}
#line 1184 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_page_layout_section psiconv_empty_page_layout_section___3(void) 
{ 
  psiconv_page_layout_section result ;
  void *tmp ;
  psiconv_length_t tmp___0 ;
  psiconv_length_t tmp___1 ;
  psiconv_length_t tmp___2 ;
  psiconv_page_header tmp___3 ;
  psiconv_page_header tmp___4 ;

  {
  {
#line 1187
  tmp = malloc(sizeof(*result));
#line 1187
  result = (psiconv_page_layout_section )tmp;
  }
#line 1187
  if (! result) {
#line 1188
    goto ERROR1;
  }
  {
#line 1189
  result->first_page_nr = (psiconv_u32 )1;
#line 1190
  tmp___0 = (psiconv_length_t )1.27;
#line 1190
  result->footer_dist = tmp___0;
#line 1190
  result->header_dist = tmp___0;
#line 1191
  tmp___1 = (psiconv_length_t )3.175;
#line 1191
  result->right_margin = tmp___1;
#line 1191
  result->left_margin = tmp___1;
#line 1192
  tmp___2 = (psiconv_length_t )2.54;
#line 1192
  result->bottom_margin = tmp___2;
#line 1192
  result->top_margin = tmp___2;
#line 1193
  result->page_width = (psiconv_length_t )21.0;
#line 1194
  result->page_height = (psiconv_length_t )29.7;
#line 1195
  result->landscape = (psiconv_bool_t )0;
#line 1196
  tmp___3 = psiconv_empty_page_header___3();
#line 1196
  result->header = tmp___3;
  }
#line 1196
  if (! tmp___3) {
#line 1197
    goto ERROR2;
  }
  {
#line 1198
  tmp___4 = psiconv_empty_page_header___3();
#line 1198
  result->footer = tmp___4;
  }
#line 1198
  if (! tmp___4) {
#line 1199
    goto ERROR3;
  }
#line 1200
  return (result);
  ERROR3: 
  {
#line 1202
  psiconv_free_page_header(result->header);
  }
  ERROR2: 
  {
#line 1204
  free((void *)result);
  }
  ERROR1: 
#line 1206
  return ((psiconv_page_layout_section )((void *)0));
}
}
#line 1209 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_word_status_section psiconv_empty_word_status_section___3(void) 
{ 
  psiconv_word_status_section result ;
  void *tmp ;
  psiconv_bool_t tmp___0 ;
  psiconv_bool_t tmp___1 ;
  psiconv_bool_t tmp___2 ;
  psiconv_bool_t tmp___3 ;
  psiconv_bool_t tmp___4 ;
  psiconv_bool_t tmp___5 ;
  psiconv_bool_t tmp___6 ;
  psiconv_bool_t tmp___7 ;

  {
  {
#line 1212
  tmp = malloc(sizeof(*result));
#line 1212
  result = (psiconv_word_status_section )tmp;
  }
#line 1212
  if (! result) {
#line 1213
    return ((psiconv_word_status_section )((void *)0));
  }
#line 1214
  tmp___4 = (psiconv_bool_t )0;
#line 1214
  result->fit_lines_to_screen = tmp___4;
#line 1214
  tmp___3 = tmp___4;
#line 1214
  result->show_hard_space = tmp___3;
#line 1214
  tmp___2 = tmp___3;
#line 1214
  result->show_hard_minus = tmp___2;
#line 1214
  tmp___1 = tmp___2;
#line 1214
  result->show_paragraph_ends = tmp___1;
#line 1214
  tmp___0 = tmp___1;
#line 1214
  result->show_spaces = tmp___0;
#line 1214
  result->show_tabs = tmp___0;
#line 1217
  tmp___7 = (psiconv_bool_t )1;
#line 1217
  result->show_side_toolbar = tmp___7;
#line 1217
  tmp___6 = tmp___7;
#line 1217
  result->show_top_toolbar = tmp___6;
#line 1217
  tmp___5 = tmp___6;
#line 1217
  result->show_full_graphs = tmp___5;
#line 1217
  result->show_full_pictures = tmp___5;
#line 1220
  result->cursor_position = (psiconv_u32 )0;
#line 1221
  result->display_size = (psiconv_u32 )1000;
#line 1222
  return (result);
}
}
#line 1225 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_word_f psiconv_empty_word_f___3(void) 
{ 
  psiconv_word_f result ;
  void *tmp ;
  psiconv_page_layout_section tmp___0 ;
  psiconv_text_and_layout tmp___1 ;
  psiconv_word_status_section tmp___2 ;
  psiconv_word_styles_section tmp___3 ;

  {
  {
#line 1228
  tmp = malloc(sizeof(*result));
#line 1228
  result = (psiconv_word_f )tmp;
  }
#line 1228
  if (! result) {
#line 1229
    goto ERROR1;
  }
  {
#line 1230
  tmp___0 = psiconv_empty_page_layout_section___3();
#line 1230
  result->page_sec = tmp___0;
  }
#line 1230
  if (! tmp___0) {
#line 1231
    goto ERROR2;
  }
  {
#line 1232
  tmp___1 = psiconv_empty_text_and_layout___3();
#line 1232
  result->paragraphs = tmp___1;
  }
#line 1232
  if (! tmp___1) {
#line 1233
    goto ERROR3;
  }
  {
#line 1234
  tmp___2 = psiconv_empty_word_status_section___3();
#line 1234
  result->status_sec = tmp___2;
  }
#line 1234
  if (! tmp___2) {
#line 1235
    goto ERROR4;
  }
  {
#line 1236
  tmp___3 = psiconv_empty_word_styles_section___3();
#line 1236
  result->styles_sec = tmp___3;
  }
#line 1236
  if (! tmp___3) {
#line 1237
    goto ERROR5;
  }
#line 1238
  return (result);
  ERROR5: 
  {
#line 1240
  psiconv_free_word_status_section(result->status_sec);
  }
  ERROR4: 
  {
#line 1242
  psiconv_free_text_and_layout(result->paragraphs);
  }
  ERROR3: 
  {
#line 1244
  psiconv_free_page_layout_section(result->page_sec);
  }
  ERROR2: 
  {
#line 1246
  free((void *)result);
  }
  ERROR1: 
#line 1248
  return ((psiconv_word_f )((void *)0));
}
}
#line 1251 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sheet_status_section psiconv_empty_sheet_status_section___3(void) 
{ 
  psiconv_sheet_status_section result ;
  void *tmp ;
  psiconv_triple_t tmp___0 ;
  psiconv_bool_t tmp___1 ;
  psiconv_bool_t tmp___2 ;
  psiconv_bool_t tmp___3 ;
  psiconv_u32 tmp___4 ;
  psiconv_u32 tmp___5 ;

  {
  {
#line 1254
  tmp = malloc(sizeof(*result));
#line 1254
  result = (psiconv_sheet_status_section )tmp;
  }
#line 1254
  if (! result) {
#line 1255
    return ((psiconv_sheet_status_section )((void *)0));
  }
#line 1256
  tmp___0 = (psiconv_triple_t )2;
#line 1256
  result->show_vertical_scrollbar = tmp___0;
#line 1256
  result->show_horizontal_scrollbar = tmp___0;
#line 1258
  result->show_graph = (psiconv_bool_t )0;
#line 1259
  tmp___3 = (psiconv_bool_t )1;
#line 1259
  result->show_side_graph_toolbar = tmp___3;
#line 1259
  tmp___2 = tmp___3;
#line 1259
  result->show_top_graph_toolbar = tmp___2;
#line 1259
  tmp___1 = tmp___2;
#line 1259
  result->show_side_sheet_toolbar = tmp___1;
#line 1259
  result->show_top_sheet_toolbar = tmp___1;
#line 1262
  tmp___4 = (psiconv_u32 )0;
#line 1262
  result->cursor_column = tmp___4;
#line 1262
  result->cursor_row = tmp___4;
#line 1263
  tmp___5 = (psiconv_u32 )1000;
#line 1263
  result->graph_display_size = tmp___5;
#line 1263
  result->sheet_display_size = tmp___5;
#line 1264
  return (result);
}
}
#line 1267 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_formula_list psiconv_empty_formula_list___3(void) 
{ 
  psiconv_list tmp ;

  {
  {
#line 1269
  tmp = psiconv_list_new(sizeof(struct psiconv_formula_s ));
  }
#line 1269
  return (tmp);
}
}
#line 1272 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sheet_workbook_section psiconv_empty_sheet_workbook_section___3(void) 
{ 
  psiconv_sheet_workbook_section result ;
  void *tmp ;
  psiconv_formula_list tmp___0 ;

  {
  {
#line 1275
  tmp = malloc(sizeof(*result));
#line 1275
  result = (psiconv_sheet_workbook_section )tmp;
  }
#line 1275
  if (! result) {
#line 1276
    goto ERROR1;
  }
  {
#line 1277
  tmp___0 = psiconv_empty_formula_list___3();
#line 1277
  result->formulas = tmp___0;
  }
#line 1277
  if (! tmp___0) {
#line 1278
    goto ERROR2;
  }
#line 1279
  return (result);
  ERROR2: 
  {
#line 1281
  free((void *)result);
  }
  ERROR1: 
#line 1283
  return ((psiconv_sheet_workbook_section )((void *)0));
}
}
#line 1287 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sheet_f psiconv_empty_sheet_f___3(void) 
{ 
  psiconv_sheet_f result ;
  void *tmp ;
  psiconv_page_layout_section tmp___0 ;
  psiconv_sheet_status_section tmp___1 ;
  psiconv_sheet_workbook_section tmp___2 ;

  {
  {
#line 1290
  tmp = malloc(sizeof(*result));
#line 1290
  result = (psiconv_sheet_f )tmp;
  }
#line 1290
  if (! result) {
#line 1291
    goto ERROR1;
  }
  {
#line 1292
  tmp___0 = psiconv_empty_page_layout_section___3();
#line 1292
  result->page_sec = tmp___0;
  }
#line 1292
  if (! tmp___0) {
#line 1293
    goto ERROR2;
  }
  {
#line 1294
  tmp___1 = psiconv_empty_sheet_status_section___3();
#line 1294
  result->status_sec = tmp___1;
  }
#line 1294
  if (! tmp___1) {
#line 1295
    goto ERROR3;
  }
  {
#line 1296
  tmp___2 = psiconv_empty_sheet_workbook_section___3();
#line 1296
  result->workbook_sec = tmp___2;
  }
#line 1296
  if (! tmp___2) {
#line 1297
    goto ERROR4;
  }
#line 1298
  return (result);
  ERROR4: 
  {
#line 1300
  psiconv_free_sheet_status_section(result->status_sec);
  }
  ERROR3: 
  {
#line 1302
  psiconv_free_page_layout_section(result->page_sec);
  }
  ERROR2: 
  {
#line 1304
  free((void *)result);
  }
  ERROR1: 
#line 1306
  return ((psiconv_sheet_f )((void *)0));
}
}
#line 1309 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_texted_f psiconv_empty_texted_f___3(void) 
{ 
  psiconv_texted_f result ;
  void *tmp ;
  psiconv_page_layout_section tmp___0 ;
  psiconv_texted_section tmp___1 ;

  {
  {
#line 1312
  tmp = malloc(sizeof(*result));
#line 1312
  result = (psiconv_texted_f )tmp;
  }
#line 1312
  if (! result) {
#line 1313
    goto ERROR1;
  }
  {
#line 1314
  tmp___0 = psiconv_empty_page_layout_section___3();
#line 1314
  result->page_sec = tmp___0;
  }
#line 1314
  if (! tmp___0) {
#line 1315
    goto ERROR2;
  }
  {
#line 1316
  tmp___1 = psiconv_empty_texted_section___3();
#line 1316
  result->texted_sec = tmp___1;
  }
#line 1316
  if (! tmp___1) {
#line 1317
    goto ERROR3;
  }
#line 1318
  return (result);
  ERROR3: 
  {
#line 1320
  psiconv_free_page_layout_section(result->page_sec);
  }
  ERROR2: 
  {
#line 1322
  free((void *)result);
  }
  ERROR1: 
#line 1324
  return ((psiconv_texted_f )((void *)0));
}
}
#line 1327 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_paint_data_section psiconv_empty_paint_data_section___3(void) 
{ 
  psiconv_paint_data_section result ;
  void *tmp ;
  psiconv_u32 tmp___0 ;
  psiconv_length_t tmp___1 ;
  psiconv_length_t tmp___2 ;
  float *tmp___3 ;
  void *tmp___4 ;
  float *tmp___5 ;
  void *tmp___6 ;
  float *tmp___7 ;
  void *tmp___8 ;

  {
  {
#line 1330
  tmp = malloc(sizeof(*result));
#line 1330
  result = (psiconv_paint_data_section )tmp;
  }
#line 1330
  if (! result) {
#line 1331
    goto ERROR1;
  }
  {
#line 1333
  tmp___2 = (psiconv_length_t )0;
#line 1333
  result->pic_ysize = tmp___2;
#line 1333
  tmp___1 = tmp___2;
#line 1333
  result->pic_xsize = tmp___1;
#line 1333
  tmp___0 = (psiconv_u32 )tmp___1;
#line 1333
  result->ysize = tmp___0;
#line 1333
  result->xsize = tmp___0;
#line 1335
  tmp___4 = malloc((size_t )0);
#line 1335
  tmp___3 = (float *)tmp___4;
#line 1335
  result->red = tmp___3;
  }
#line 1335
  if (! tmp___3) {
#line 1336
    goto ERROR2;
  }
  {
#line 1337
  tmp___6 = malloc((size_t )0);
#line 1337
  tmp___5 = (float *)tmp___6;
#line 1337
  result->green = tmp___5;
  }
#line 1337
  if (! tmp___5) {
#line 1338
    goto ERROR3;
  }
  {
#line 1339
  tmp___8 = malloc((size_t )0);
#line 1339
  tmp___7 = (float *)tmp___8;
#line 1339
  result->blue = tmp___7;
  }
#line 1339
  if (! tmp___7) {
#line 1340
    goto ERROR4;
  }
#line 1341
  return (result);
  ERROR4: 
  {
#line 1343
  free((void *)result->green);
  }
  ERROR3: 
  {
#line 1345
  free((void *)result->red);
  }
  ERROR2: 
  {
#line 1347
  free((void *)result);
  }
  ERROR1: 
#line 1349
  return ((psiconv_paint_data_section )((void *)0));
}
}
#line 1353 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_pictures psiconv_empty_pictures___3(void) 
{ 
  psiconv_pictures result ;
  psiconv_paint_data_section pds ;
  int tmp ;

  {
  {
#line 1357
  result = psiconv_list_new(sizeof(struct psiconv_paint_data_section_s ));
  }
#line 1357
  if (! result) {
#line 1358
    goto ERROR1;
  }
  {
#line 1359
  pds = psiconv_empty_paint_data_section___3();
  }
#line 1359
  if (! pds) {
#line 1360
    goto ERROR2;
  }
  {
#line 1361
  tmp = psiconv_list_add(result, (void const   *)pds);
  }
#line 1361
  if (tmp) {
#line 1362
    goto ERROR3;
  }
  {
#line 1363
  free((void *)pds);
  }
#line 1364
  return (result);
  ERROR3: 
  {
#line 1366
  psiconv_free_paint_data_section(pds);
  }
  ERROR2: 
  {
#line 1368
  psiconv_list_free(result);
  }
  ERROR1: 
#line 1370
  return ((psiconv_pictures )((void *)0));
}
}
#line 1373 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_mbm_f psiconv_empty_mbm_f___3(void) 
{ 
  psiconv_mbm_f result ;
  void *tmp ;
  psiconv_pictures tmp___0 ;

  {
  {
#line 1376
  tmp = malloc(sizeof(*result));
#line 1376
  result = (psiconv_mbm_f )tmp;
  }
#line 1376
  if (! result) {
#line 1377
    goto ERROR1;
  }
  {
#line 1378
  tmp___0 = psiconv_empty_pictures___3();
#line 1378
  result->sections = tmp___0;
  }
#line 1378
  if (! tmp___0) {
#line 1379
    goto ERROR2;
  }
#line 1380
  return (result);
  ERROR2: 
  {
#line 1382
  free((void *)result);
  }
  ERROR1: 
#line 1384
  return ((psiconv_mbm_f )((void *)0));
}
}
#line 1387 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sketch_section psiconv_empty_sketch_section___3(void) 
{ 
  psiconv_sketch_section result ;
  void *tmp ;
  psiconv_u16 tmp___0 ;
  psiconv_u16 tmp___1 ;
  psiconv_u16 tmp___2 ;
  psiconv_u16 tmp___3 ;
  psiconv_u16 tmp___4 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;
  float tmp___8 ;
  psiconv_paint_data_section tmp___9 ;

  {
  {
#line 1390
  tmp = malloc(sizeof(*result));
#line 1390
  result = (psiconv_sketch_section )tmp;
  }
#line 1390
  if (! result) {
#line 1391
    goto ERROR1;
  }
  {
#line 1392
  result->displayed_xsize = (psiconv_u16 )320;
#line 1393
  result->displayed_ysize = (psiconv_u16 )200;
#line 1394
  tmp___4 = (psiconv_u16 )0;
#line 1394
  result->displayed_size_y_offset = tmp___4;
#line 1394
  tmp___3 = tmp___4;
#line 1394
  result->displayed_size_x_offset = tmp___3;
#line 1394
  tmp___2 = tmp___3;
#line 1394
  result->form_ysize = tmp___2;
#line 1394
  tmp___1 = tmp___2;
#line 1394
  result->form_xsize = tmp___1;
#line 1394
  tmp___0 = tmp___1;
#line 1394
  result->picture_data_y_offset = tmp___0;
#line 1394
  result->picture_data_x_offset = tmp___0;
#line 1397
  tmp___5 = (float )1.0;
#line 1397
  result->magnification_y = tmp___5;
#line 1397
  result->magnification_x = tmp___5;
#line 1398
  tmp___8 = (float )0.0;
#line 1398
  result->cut_bottom = tmp___8;
#line 1398
  tmp___7 = tmp___8;
#line 1398
  result->cut_top = tmp___7;
#line 1398
  tmp___6 = tmp___7;
#line 1398
  result->cut_right = tmp___6;
#line 1398
  result->cut_left = tmp___6;
#line 1400
  tmp___9 = psiconv_empty_paint_data_section___3();
#line 1400
  result->picture = tmp___9;
  }
#line 1400
  if (! tmp___9) {
#line 1401
    goto ERROR2;
  }
#line 1402
  return (result);
  ERROR2: 
  {
#line 1404
  free((void *)result);
  }
  ERROR1: 
#line 1406
  return ((psiconv_sketch_section )((void *)0));
}
}
#line 1409 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_sketch_f psiconv_empty_sketch_f___3(void) 
{ 
  psiconv_sketch_f result ;
  void *tmp ;
  psiconv_sketch_section tmp___0 ;

  {
  {
#line 1412
  tmp = malloc(sizeof(*result));
#line 1412
  result = (psiconv_sketch_f )tmp;
  }
#line 1412
  if (! result) {
#line 1413
    goto ERROR1;
  }
  {
#line 1414
  tmp___0 = psiconv_empty_sketch_section___3();
#line 1414
  result->sketch_sec = tmp___0;
  }
#line 1414
  if (! tmp___0) {
#line 1415
    goto ERROR2;
  }
#line 1416
  return (result);
  ERROR2: 
  {
#line 1418
  free((void *)result);
  }
  ERROR1: 
#line 1420
  return ((psiconv_sketch_f )((void *)0));
}
}
#line 1423 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_cliparts psiconv_empty_cliparts___3(void) 
{ 
  psiconv_list tmp ;

  {
  {
#line 1426
  tmp = psiconv_list_new(sizeof(struct psiconv_clipart_section_s ));
  }
#line 1426
  return (tmp);
}
}
#line 1429 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/data.c"
static psiconv_clipart_f psiconv_empty_clipart_f___3(void) 
{ 
  psiconv_clipart_f result ;
  void *tmp ;
  psiconv_cliparts tmp___0 ;

  {
  {
#line 1432
  tmp = malloc(sizeof(*result));
#line 1432
  result = (psiconv_clipart_f )tmp;
  }
#line 1432
  if (! result) {
#line 1433
    goto ERROR1;
  }
  {
#line 1434
  tmp___0 = psiconv_empty_cliparts___3();
#line 1434
  result->sections = tmp___0;
  }
#line 1434
  if (! tmp___0) {
#line 1435
    goto ERROR2;
  }
#line 1436
  return (result);
  ERROR2: 
  {
#line 1438
  free((void *)result);
  }
  ERROR1: 
#line 1440
  return ((psiconv_clipart_f )((void *)0));
}
}
#line 28 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/checkuid.c"
static psiconv_u32 uid1___4[32]  = 
#line 28 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/checkuid.c"
  {      (psiconv_u32 )17824,      (psiconv_u32 )35648,      (psiconv_u32 )1697,      (psiconv_u32 )3394, 
        (psiconv_u32 )6788,      (psiconv_u32 )13576,      (psiconv_u32 )27152,      (psiconv_u32 )54304, 
        (psiconv_u32 )1168113664,      2336227328U,      (psiconv_u32 )111214592,      (psiconv_u32 )222429184, 
        (psiconv_u32 )444858368,      (psiconv_u32 )889716736,      (psiconv_u32 )1779433472,      3558866944U, 
        (psiconv_u32 )43601,      (psiconv_u32 )17539,      (psiconv_u32 )35078,      (psiconv_u32 )557, 
        (psiconv_u32 )1114,      (psiconv_u32 )2228,      (psiconv_u32 )4456,      (psiconv_u32 )8912, 
        2857435136U,      (psiconv_u32 )1149435904,      2298871808U,      (psiconv_u32 )36503552, 
        (psiconv_u32 )73007104,      (psiconv_u32 )146014208,      (psiconv_u32 )292028416,      (psiconv_u32 )584056832};
#line 62 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/checkuid.c"
static psiconv_u32 uid2___4[32]  = 
#line 62
  {      (psiconv_u32 )30388,      (psiconv_u32 )60776,      (psiconv_u32 )51953,      (psiconv_u32 )34243, 
        (psiconv_u32 )7079,      (psiconv_u32 )14158,      (psiconv_u32 )28316,      (psiconv_u32 )56632, 
        (psiconv_u32 )1991507968,      3983015936U,      3404791808U,      2244149248U, 
        (psiconv_u32 )463929344,      (psiconv_u32 )927858688,      (psiconv_u32 )1855717376,      3711434752U, 
        (psiconv_u32 )14128,      (psiconv_u32 )28256,      (psiconv_u32 )56512,      (psiconv_u32 )43425, 
        (psiconv_u32 )17251,      (psiconv_u32 )34502,      (psiconv_u32 )7597,      (psiconv_u32 )15194, 
        (psiconv_u32 )925892608,      (psiconv_u32 )1851785216,      3703570432U,      2845900800U, 
        (psiconv_u32 )1130561536,      2261123072U,      (psiconv_u32 )497876992,      (psiconv_u32 )995753984};
#line 96 "/home/wheatley/newnew/temp/psiconv-0.9.8/lib/psiconv/checkuid.c"
static psiconv_u32 uid3___4[32]  = 
#line 96
  {      (psiconv_u32 )13105,      (psiconv_u32 )26210,      (psiconv_u32 )52420,      (psiconv_u32 )35241, 
        (psiconv_u32 )883,      (psiconv_u32 )1766,      (psiconv_u32 )3532,      (psiconv_u32 )7064, 
        (psiconv_u32 )858849280,      (psiconv_u32 )1717698560,      3435397120U,      2309554176U, 
        (psiconv_u32 )57868288,      (psiconv_u32 )115736576,      (psiconv_u32 )231473152,      (psiconv_u32 )462946304, 
        (psiconv_u32 )4129,      (psiconv_u32 )8258,      (psiconv_u32 )16516,      (psiconv_u32 )33032, 
        (psiconv_u32 )4657,      (psiconv_u32 )9314,      (psiconv_u32 )18628,      (psiconv_u32 )37256, 
        (psiconv_u32 )270598144,      (psiconv_u32 )541196288,      (psiconv_u32 )1082392576,      2164785152U, 
        (psiconv_u32 )305201152,      (psiconv_u32 )610402304,      (psiconv_u32 )1220804608,      2441609216U};
