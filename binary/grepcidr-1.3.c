/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_26 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_26 regmatch_t;
#line 48 "/home/june/repo/benchmarks/collector/temp/grepcidr-1.3/grepcidr.c"
struct netspec {
   unsigned int min ;
   unsigned int max ;
};
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 755
extern void *( __attribute__((__nonnull__(1,2,5))) bsearch)(void const   *__key ,
                                                            void const   *__base ,
                                                            size_t __nmemb , size_t __size ,
                                                            int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/grepcidr-1.3/grepcidr.c"
unsigned int patterns  =    0U;
#line 62 "/home/june/repo/benchmarks/collector/temp/grepcidr-1.3/grepcidr.c"
unsigned int capacity  =    0U;
#line 63 "/home/june/repo/benchmarks/collector/temp/grepcidr-1.3/grepcidr.c"
struct netspec *array  =    (struct netspec *)((void *)0);
#line 70 "/home/june/repo/benchmarks/collector/temp/grepcidr-1.3/grepcidr.c"
void array_insert(struct netspec *newspec ) 
{ 
  void *tmp ;
  unsigned int tmp___0 ;

  {
#line 72
  if (patterns == capacity) {
    {
#line 74
    capacity *= 2U;
#line 75
    tmp = realloc((void *)array, (unsigned long )capacity * sizeof(struct netspec ));
#line 75
    array = (struct netspec *)tmp;
    }
  }
#line 77
  tmp___0 = patterns;
#line 77
  patterns ++;
#line 77
  *(array + tmp___0) = *newspec;
#line 78
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/grepcidr-1.3/grepcidr.c"
unsigned int ip_to_uint(char const   *ip ) 
{ 
  unsigned int IP[4] ;
  int tmp ;

  {
  {
#line 88
  tmp = sscanf((char const   */* __restrict  */)ip, (char const   */* __restrict  */)"%u.%u.%u.%u",
               & IP[0], & IP[1], & IP[2], & IP[3]);
  }
#line 88
  if (tmp == 4) {
#line 88
    if (IP[0] < 256U) {
#line 88
      if (IP[1] < 256U) {
#line 88
        if (IP[2] < 256U) {
#line 88
          if (IP[3] < 256U) {
#line 89
            return ((((IP[0] << 24) | (IP[1] << 16)) | (IP[2] << 8)) | IP[3]);
          } else {
#line 91
            return (0U);
          }
        } else {
#line 91
          return (0U);
        }
      } else {
#line 91
        return (0U);
      }
    } else {
#line 91
      return (0U);
    }
  } else {
#line 91
    return (0U);
  }
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/grepcidr-1.3/grepcidr.c"
int net_parse(char const   *line , struct netspec *spec ) 
{ 
  unsigned int IP1[4] ;
  unsigned int IP2[4] ;
  int maskbits ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 103
  maskbits = 32;
#line 106
  tmp___2 = strchr(line, '/');
  }
#line 106
  if (tmp___2) {
    {
#line 106
    tmp___3 = sscanf((char const   */* __restrict  */)line, (char const   */* __restrict  */)"%u.%u.%u.%u/%d",
                     & IP1[0], & IP1[1], & IP1[2], & IP1[3], & maskbits);
    }
#line 106
    if (tmp___3 == 5) {
#line 106
      if (IP1[0] < 256U) {
#line 106
        if (IP1[1] < 256U) {
#line 106
          if (IP1[2] < 256U) {
#line 106
            if (IP1[3] < 256U) {
#line 106
              if (maskbits >= 1) {
#line 106
                if (maskbits <= 32) {
#line 109
                  spec->min = ((((IP1[0] << 24) | (IP1[1] << 16)) | (IP1[2] << 8)) | IP1[3]) & ((unsigned int )(~ ((1 << (32 - maskbits)) - 1)) & 4294967295U);
#line 110
                  spec->max = spec->min | ((unsigned int )((1 << (32 - maskbits)) - 1) & 4294967295U);
#line 111
                  return (1);
                } else {
#line 106
                  goto _L___5;
                }
              } else {
#line 106
                goto _L___5;
              }
            } else {
#line 106
              goto _L___5;
            }
          } else {
#line 106
            goto _L___5;
          }
        } else {
#line 106
          goto _L___5;
        }
      } else {
#line 106
        goto _L___5;
      }
    } else {
#line 106
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ 
    {
#line 114
    tmp___0 = strchr(line, '-');
    }
#line 114
    if (tmp___0) {
      {
#line 114
      tmp___1 = sscanf((char const   */* __restrict  */)line, (char const   */* __restrict  */)"%u.%u.%u.%u - %u.%u.%u.%u",
                       & IP1[0], & IP1[1], & IP1[2], & IP1[3], & IP2[0], & IP2[1],
                       & IP2[2], & IP2[3]);
      }
#line 114
      if (tmp___1 == 8) {
#line 114
        if (IP1[0] < 256U) {
#line 114
          if (IP1[1] < 256U) {
#line 114
            if (IP1[2] < 256U) {
#line 114
              if (IP1[3] < 256U) {
#line 114
                if (IP2[0] < 256U) {
#line 114
                  if (IP2[1] < 256U) {
#line 114
                    if (IP2[2] < 256U) {
#line 114
                      if (IP2[3] < 256U) {
#line 117
                        spec->min = (((IP1[0] << 24) | (IP1[1] << 16)) | (IP1[2] << 8)) | IP1[3];
#line 118
                        spec->max = (((IP2[0] << 24) | (IP2[1] << 16)) | (IP2[2] << 8)) | IP2[3];
#line 119
                        if (spec->max >= spec->min) {
#line 120
                          return (1);
                        } else {
#line 122
                          return (0);
                        }
                      } else {
#line 114
                        goto _L___1;
                      }
                    } else {
#line 114
                      goto _L___1;
                    }
                  } else {
#line 114
                    goto _L___1;
                  }
                } else {
#line 114
                  goto _L___1;
                }
              } else {
#line 114
                goto _L___1;
              }
            } else {
#line 114
              goto _L___1;
            }
          } else {
#line 114
            goto _L___1;
          }
        } else {
#line 114
          goto _L___1;
        }
      } else {
#line 114
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 125
      tmp = sscanf((char const   */* __restrict  */)line, (char const   */* __restrict  */)"%u.%u.%u.%u",
                   & IP1[0], & IP1[1], & IP1[2], & IP1[3]);
      }
#line 125
      if (tmp == 4) {
#line 125
        if (IP1[0] < 256U) {
#line 125
          if (IP1[1] < 256U) {
#line 125
            if (IP1[2] < 256U) {
#line 125
              if (IP1[3] < 256U) {
#line 127
                spec->min = (((IP1[0] << 24) | (IP1[1] << 16)) | (IP1[2] << 8)) | IP1[3];
#line 128
                spec->max = spec->min;
#line 129
                return (1);
              }
            }
          }
        }
      }
    }
  }
#line 131
  return (0);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/grepcidr-1.3/grepcidr.c"
int netsort(void const   *a , void const   *b ) 
{ 
  unsigned int c1 ;
  unsigned int c2 ;

  {
#line 138
  c1 = ((struct netspec *)a)->min;
#line 139
  c2 = ((struct netspec *)b)->min;
#line 140
  if (c1 < c2) {
#line 140
    return (-1);
  }
#line 141
  if (c1 > c2) {
#line 141
    return (1);
  }
#line 142
  return (0);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/grepcidr-1.3/grepcidr.c"
int netsearch(void const   *a , void const   *b ) 
{ 
  unsigned int key ;
  unsigned int min ;
  unsigned int max ;

  {
#line 148
  key = ((struct netspec *)a)->min;
#line 149
  min = ((struct netspec *)b)->min;
#line 150
  max = ((struct netspec *)b)->max;
#line 151
  if (key < min) {
#line 151
    return (-1);
  }
#line 152
  if (key > max) {
#line 152
    return (1);
  }
#line 153
  return (0);
}
}
#line 159
int main(int argc , char **argv ) ;
#line 159 "/home/june/repo/benchmarks/collector/temp/grepcidr-1.3/grepcidr.c"
static char shortopts[8]  = 
#line 159
  {      (char )'c',      (char )'e',      (char )':',      (char )'f', 
        (char )':',      (char )'v',      (char )'V',      (char )'\000'};
#line 168 "/home/june/repo/benchmarks/collector/temp/grepcidr-1.3/grepcidr.c"
static regex_t preg  ;
#line 157 "/home/june/repo/benchmarks/collector/temp/grepcidr-1.3/grepcidr.c"
int main(int argc , char **argv ) 
{ 
  FILE *inp_stream ;
  char *pat_filename ;
  char *pat_strings ;
  unsigned int counting ;
  int invert ;
  char line[512] ;
  int foundopt ;
  int anymatch ;
  int tmp ;
  void *tmp___0 ;
  FILE *data ;
  FILE *tmp___1 ;
  struct netspec spec ;
  int tmp___2 ;
  char *tmp___3 ;
  char *token ;
  char *tmp___4 ;
  struct netspec spec___0 ;
  int tmp___5 ;
  unsigned int item ;
  int tmp___6 ;
  struct netspec key ;
  regoff_t offset ;
  regmatch_t pmatch ;
  int match ;
  void *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
#line 160
  inp_stream = stdin;
#line 161
  pat_filename = (char *)((void *)0);
#line 162
  pat_strings = (char *)((void *)0);
#line 163
  counting = 0U;
#line 164
  invert = 0;
#line 167
  anymatch = 0;
#line 170
  if (argc == 1) {
    {
#line 172
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:\n\tgrepcidr [-V] [-c] [-v] PATTERN [FILE]\n\tgrepcidr [-V] [-c] [-v] [-e PATTERN | -f FILE] [FILE]\n");
    }
#line 173
    return (2);
  }
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 176
    foundopt = getopt(argc, (char * const  *)argv, (char const   *)(shortopts));
    }
#line 176
    if (! (foundopt != -1)) {
#line 176
      goto while_break;
    }
    {
#line 180
    if (foundopt == 86) {
#line 180
      goto case_86;
    }
#line 184
    if (foundopt == 99) {
#line 184
      goto case_99;
    }
#line 188
    if (foundopt == 118) {
#line 188
      goto case_118;
    }
#line 192
    if (foundopt == 101) {
#line 192
      goto case_101;
    }
#line 196
    if (foundopt == 102) {
#line 196
      goto case_102;
    }
#line 200
    goto switch_default;
    case_86: /* CIL Label */ 
    {
#line 181
    puts("grepcidr 1.3\nCopyright (C) 2004, 2005  Jem E. Berkes <jberkes@pc-tools.net>\n");
    }
#line 182
    return (2);
    case_99: /* CIL Label */ 
#line 185
    counting = 1U;
#line 186
    goto switch_break;
    case_118: /* CIL Label */ 
#line 189
    invert = 1;
#line 190
    goto switch_break;
    case_101: /* CIL Label */ 
#line 193
    pat_strings = optarg;
#line 194
    goto switch_break;
    case_102: /* CIL Label */ 
#line 197
    pat_filename = optarg;
#line 198
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 201
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:\n\tgrepcidr [-V] [-c] [-v] PATTERN [FILE]\n\tgrepcidr [-V] [-c] [-v] [-e PATTERN | -f FILE] [FILE]\n");
    }
#line 202
    return (2);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  if (! pat_filename) {
#line 206
    if (! pat_strings) {
#line 208
      if (optind < argc) {
#line 209
        tmp = optind;
#line 209
        optind ++;
#line 209
        pat_strings = *(argv + tmp);
      } else {
        {
#line 212
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Specify PATTERN or -f FILE to read patterns from\n");
        }
#line 213
        return (2);
      }
    }
  }
#line 217
  if (optind < argc) {
    {
#line 219
    inp_stream = fopen((char const   */* __restrict  */)*(argv + optind), (char const   */* __restrict  */)"r");
    }
#line 220
    if (! inp_stream) {
      {
#line 222
      perror((char const   *)*(argv + optind));
      }
#line 223
      return (2);
    }
  }
  {
#line 228
  capacity = 8192U;
#line 229
  tmp___0 = malloc((unsigned long )capacity * sizeof(struct netspec ));
#line 229
  array = (struct netspec *)tmp___0;
  }
#line 232
  if (pat_filename) {
    {
#line 234
    tmp___1 = fopen((char const   */* __restrict  */)pat_filename, (char const   */* __restrict  */)"r");
#line 234
    data = tmp___1;
    }
#line 235
    if (data) {
      {
#line 237
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 237
        tmp___3 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)data);
        }
#line 237
        if (! tmp___3) {
#line 237
          goto while_break___0;
        }
#line 240
        if ((int )line[0] != 35) {
          {
#line 240
          tmp___2 = net_parse((char const   *)(line), & spec);
          }
#line 240
          if (tmp___2) {
            {
#line 241
            array_insert(& spec);
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 243
      fclose(data);
      }
    } else {
      {
#line 247
      perror((char const   *)pat_filename);
      }
#line 248
      return (2);
    }
  }
#line 251
  if (pat_strings) {
    {
#line 253
    tmp___4 = strtok((char */* __restrict  */)pat_strings, (char const   */* __restrict  */)"\t,\r\n");
#line 253
    token = tmp___4;
    }
    {
#line 254
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 254
      if (! token) {
#line 254
        goto while_break___1;
      }
      {
#line 257
      tmp___5 = net_parse((char const   *)token, & spec___0);
      }
#line 257
      if (tmp___5) {
        {
#line 258
        array_insert(& spec___0);
        }
      }
      {
#line 259
      token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\t,\r\n");
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 266
  qsort((void *)array, (size_t )patterns, sizeof(struct netspec ), & netsort);
#line 268
  item = 1U;
  }
  {
#line 268
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 268
    if (! (item < patterns)) {
#line 268
      goto while_break___2;
    }
#line 270
    if ((array + item)->max <= (array + (item - 1U))->max) {
#line 271
      *(array + item) = *(array + (item - 1U));
    } else
#line 272
    if ((array + item)->min <= (array + (item - 1U))->max) {
#line 273
      (array + item)->min = (array + (item - 1U))->max + 1U;
    }
#line 268
    item ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 278
  tmp___6 = regcomp((regex_t */* __restrict  */)(& preg), (char const   */* __restrict  */)"[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+",
                    1);
  }
#line 278
  if (tmp___6 != 0) {
    {
#line 280
    fputs((char const   */* __restrict  */)"regcomp() failed\n", (FILE */* __restrict  */)stderr);
    }
#line 281
    return (2);
  }
  {
#line 285
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 285
    tmp___9 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)inp_stream);
    }
#line 285
    if (! tmp___9) {
#line 285
      goto while_break___3;
    }
#line 290
    offset = 0;
    {
#line 290
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 290
      tmp___8 = regexec((regex_t const   */* __restrict  */)(& preg), (char const   */* __restrict  */)(& line[offset]),
                        (size_t )1, (regmatch_t */* __restrict  */)(& pmatch), 0);
      }
#line 290
      if (! (tmp___8 == 0)) {
#line 290
        goto while_break___4;
      }
      {
#line 292
      key.min = ip_to_uint((char const   *)(& line[offset + pmatch.rm_so]));
      }
#line 292
      if (key.min) {
        {
#line 294
        match = 0;
#line 295
        tmp___7 = bsearch((void const   *)(& key), (void const   *)array, (size_t )patterns,
                          sizeof(struct netspec ), & netsearch);
        }
#line 295
        if (tmp___7) {
#line 296
          match = 1;
        }
#line 297
        if (invert ^ match) {
#line 299
          anymatch = 1;
#line 300
          if (counting) {
#line 301
            counting ++;
          } else {
            {
#line 303
            printf((char const   */* __restrict  */)"%s", line);
            }
          }
#line 304
          goto while_break___4;
        }
      }
#line 290
      offset += pmatch.rm_eo;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 311
  if ((unsigned long )inp_stream != (unsigned long )stdin) {
    {
#line 312
    fclose(inp_stream);
    }
  }
#line 313
  if (array) {
    {
#line 314
    free((void *)array);
    }
  }
  {
#line 315
  regfree(& preg);
  }
#line 317
  if (counting) {
    {
#line 318
    printf((char const   */* __restrict  */)"%u\n", counting - 1U);
    }
  }
#line 319
  if (anymatch) {
#line 320
    return (0);
  } else {
#line 322
    return (1);
  }
}
}
