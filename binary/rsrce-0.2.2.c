/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 46 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/main.c"
enum __anonenum_state_29 {
    BOA = 0,
    UNQUOTED = 1,
    QUOTED = 2,
    BACKSLASHED = 3,
    COMMENT = 4,
    EOC = 5
} ;
#line 98 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/main.c"
struct __anonstruct_opts_30 {
   FILE *cmdin ;
   int e ;
   char const   *ifname ;
   char const   *ofname ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 24 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.h"
typedef char restype_t[4];
#line 26
struct resource;
#line 24 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/translate.h"
struct translator;
#line 148 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/translate.c"
struct translator {
   char type[4] ;
   char const   *ext ;
   int (*export)(FILE *f , void *data , int len ) ;
   int (*import)(FILE *f , void **data , int *len ) ;
};
#line 195 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef short int16_t;
#line 25 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.h"
struct res_fork;
#line 360 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
struct command {
   char const   *cmd ;
   int (*f)(char **argv ) ;
   char const   *help ;
};
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 3 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/rsrc-fmt.h"
struct reshdr {
   uint32_t dofs ;
   uint32_t mofs ;
   uint32_t dlen ;
   uint32_t mlen ;
};
#line 8 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/rsrc-fmt.h"
struct resmaphdr {
   uint8_t reserved[22] ;
   uint16_t attr ;
   uint16_t tlistofs ;
   uint16_t nlistofs ;
   uint16_t tnum ;
};
#line 17 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/rsrc-fmt.h"
struct restype {
   restype_t type ;
   uint16_t rnum ;
   uint16_t refofs ;
};
#line 24 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/rsrc-fmt.h"
struct resref {
   uint16_t id ;
   uint16_t nameofs ;
   unsigned int attr : 8 ;
   unsigned int dataofs : 24 ;
   uint32_t reserved ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/rsrc-fmt.h"
struct resname {
   uint8_t len ;
   char name[0] ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/rsrc-fmt.h"
struct resdata {
   uint32_t len ;
   uint8_t data[0] ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
struct resource {
   struct res_fork *f ;
   int ti ;
   struct resource *next ;
   int16_t id ;
   uint8_t attr ;
   char *name ;
   char *data ;
   int namelen ;
   int datalen ;
};
#line 41 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
struct __anonstruct_tt_33 {
   restype_t type ;
   struct resource *rlist ;
};
#line 41 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
struct res_fork {
   uint16_t attr ;
   int rlen ;
   int tn ;
   struct __anonstruct_tt_33 *tt ;
};
#line 246 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
struct res_parsecontext {
   struct res_fork *f ;
   char *buf ;
   char *dbase ;
   char *tbase ;
   char *nbase ;
   int len ;
};
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 76
extern int opterr ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.h"
int cmd_exec(char **argv ) ;
#line 22
void cmd_init(char const   *ifname , char const   *ofname ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/main.c"
static char backslashed(char c ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/main.c"
static char const   bsc[8]  = 
#line 36
  {      (char const   )'a',      (char const   )'b',      (char const   )'f',      (char const   )'n', 
        (char const   )'r',      (char const   )'t',      (char const   )'v',      (char const   )'\000'};
#line 36 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/main.c"
static char const   bse[8]  = 
#line 36
  {      (char const   )'\a',      (char const   )'\b',      (char const   )'\f',      (char const   )'\n', 
        (char const   )'\r',      (char const   )'\t',      (char const   )'\v',      (char const   )'\000'};
#line 34 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/main.c"
static char backslashed(char c ) 
{ 
  char *bsi ;
  int tmp ;

  {
  {
#line 38
  bsi = strchr(bsc, (int )c);
  }
#line 38
  if (bsi) {
#line 38
    tmp = (int const   )bse[bsi - (char *)(bsc)];
  } else {
#line 38
    tmp = (int const   )c;
  }
#line 38
  return ((char )tmp);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/main.c"
static int parse_command(FILE *f ) 
{ 
  char buf[1024] ;
  char *argv[8] ;
  int ok ;
  int pos ;
  int argc ;
  int c ;
  enum __anonenum_state_29 state ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 44
  ok = 1;
#line 44
  pos = 0;
#line 44
  argc = 0;
#line 46
  state = (enum __anonenum_state_29 )0;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if ((unsigned int )state != 5U) {
      {
#line 50
      c = fgetc(f);
      }
#line 50
      if (! (c > 0)) {
#line 50
        goto while_break;
      }
    } else {
#line 50
      goto while_break;
    }
#line 51
    if (pos >= 1023) {
#line 52
      ok = 0;
#line 52
      pos = 0;
#line 52
      argc = 0;
    } else
#line 51
    if (argc >= 7) {
#line 52
      ok = 0;
#line 52
      pos = 0;
#line 52
      argc = 0;
    }
    {
#line 55
    if ((unsigned int )state == 0U) {
#line 55
      goto case_0;
    }
#line 63
    if ((unsigned int )state == 1U) {
#line 63
      goto case_1;
    }
#line 69
    if ((unsigned int )state == 2U) {
#line 69
      goto case_2;
    }
#line 75
    if ((unsigned int )state == 3U) {
#line 75
      goto case_3;
    }
#line 79
    if ((unsigned int )state == 4U) {
#line 79
      goto case_4;
    }
#line 54
    goto switch_break;
    case_0: /* CIL Label */ 
#line 56
    if (c == 35) {
#line 56
      state = (enum __anonenum_state_29 )4;
#line 56
      goto switch_break;
    }
#line 57
    if (c == 10) {
#line 57
      state = (enum __anonenum_state_29 )5;
#line 57
      goto switch_break;
    }
    {
#line 58
    tmp = __ctype_b_loc();
    }
#line 58
    if ((int const   )*(*tmp + c) & 8192) {
#line 58
      goto switch_break;
    }
#line 60
    tmp___0 = argc;
#line 60
    argc ++;
#line 60
    argv[tmp___0] = buf + pos;
#line 61
    state = (enum __anonenum_state_29 )1;
    case_1: /* CIL Label */ 
#line 64
    if (c == 10) {
#line 64
      state = (enum __anonenum_state_29 )5;
#line 64
      goto switch_break;
    }
    {
#line 65
    tmp___2 = __ctype_b_loc();
    }
#line 65
    if ((int const   )*(*tmp___2 + c) & 8192) {
#line 65
      tmp___1 = pos;
#line 65
      pos ++;
#line 65
      buf[tmp___1] = (char )'\000';
#line 65
      state = (enum __anonenum_state_29 )0;
#line 65
      goto switch_break;
    }
#line 67
    if (c == 92) {
#line 67
      state = (enum __anonenum_state_29 )3;
#line 67
      goto switch_break;
    }
#line 68
    if (c == 39) {
#line 68
      state = (enum __anonenum_state_29 )2;
#line 68
      goto switch_break;
    }
    case_2: /* CIL Label */ 
#line 70
    if (c == 39) {
#line 70
      state = (enum __anonenum_state_29 )1;
#line 70
      goto switch_break;
    }
#line 72
    tmp___3 = pos;
#line 72
    pos ++;
#line 72
    buf[tmp___3] = (char )c;
#line 73
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 76
    tmp___4 = pos;
#line 76
    pos ++;
#line 76
    buf[tmp___4] = backslashed((char )c);
#line 77
    state = (enum __anonenum_state_29 )1;
    }
#line 77
    goto switch_break;
    case_4: /* CIL Label */ 
#line 80
    if (c == 10) {
#line 80
      state = (enum __anonenum_state_29 )5;
#line 80
      goto switch_break;
    }
#line 81
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  buf[pos] = (char )'\000';
#line 85
  argv[argc] = (char *)((void *)0);
#line 87
  if (! ok) {
    {
#line 88
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Max lenght of commands: %d!\n",
            1023);
    }
#line 89
    return (-1);
  }
  {
#line 92
  tmp___5 = cmd_exec(argv);
  }
#line 92
  return (tmp___5);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/main.c"
static struct __anonstruct_opts_30 opts  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/main.c"
static void usage(char const   *myname ) 
{ 


  {
  {
#line 106
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-e] [-f <script>] [-o <output-file>] [<input-file>]\n",
          myname);
  }
#line 108
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/main.c"
static void do_cmdline(int argc , char **argv ) 
{ 
  int opt ;

  {
#line 114
  opts.cmdin = stdin;
#line 115
  opts.ofname = (char const   *)((void *)0);
#line 115
  opts.ifname = opts.ofname;
#line 116
  opts.e = 0;
#line 118
  opterr = 1;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 119
    opt = getopt(argc, (char * const  *)argv, "ef:o:");
    }
#line 119
    if (! (opt != -1)) {
#line 119
      goto while_break;
    }
    {
#line 121
    if (opt == 101) {
#line 121
      goto case_101;
    }
#line 124
    if (opt == 102) {
#line 124
      goto case_102;
    }
#line 131
    if (opt == 111) {
#line 131
      goto case_111;
    }
#line 134
    goto switch_default;
    case_101: /* CIL Label */ 
#line 122
    opts.e = 1;
#line 123
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 125
    opts.cmdin = fopen((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"r");
    }
#line 126
    if (! opts.cmdin) {
      {
#line 127
      perror((char const   *)optarg);
#line 128
      exit(1);
      }
    }
#line 130
    goto switch_break;
    case_111: /* CIL Label */ 
#line 132
    opts.ofname = (char const   *)optarg;
#line 133
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 135
    usage((char const   *)*(argv + 0));
#line 136
    exit(2);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  opts.ifname = (char const   *)*(argv + optind);
#line 140
  return;
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/main.c"
int main(int argc , char **argv ) 
{ 
  int tty ;
  int r ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 147
  do_cmdline(argc, argv);
#line 149
  cmd_init(opts.ifname, opts.ofname);
#line 150
  tmp = fileno(opts.cmdin);
#line 150
  tty = isatty(tmp);
  }
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 152
    tmp___0 = feof(opts.cmdin);
    }
#line 152
    if (tmp___0) {
#line 152
      goto while_break;
    }
#line 153
    if (tty) {
      {
#line 153
      fputs((char const   */* __restrict  */)"rsrce> ", (FILE */* __restrict  */)stdout);
      }
    }
    {
#line 154
    r = parse_command(opts.cmdin);
    }
#line 155
    if (opts.e) {
#line 155
      if (r) {
        {
#line 155
        exit(1);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  if (tty) {
    {
#line 157
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 159
  return (0);
}
}
#line 573 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 96
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.h"
void res_getdata(struct resource *r , void **dp , int *len ) ;
#line 30
void res_setdata(struct resource *r , void *p , int len ) ;
#line 31
void res_gettype(struct resource *r , char *type ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/translate.h"
struct translator *tr_lookup(struct resource *r , char const   *ext ) ;
#line 25
char const   *tr_ext(struct translator *tr ) ;
#line 26
int tr_export(struct translator *tr , struct resource *r , FILE *out ) ;
#line 27
int tr_import(struct translator *tr , struct resource *r , FILE *in ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/translate.c"
int tr_raw_export(FILE *f , void *data , int len ) 
{ 
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 31
  tmp___1 = fwrite((void const   */* __restrict  */)data, (size_t )1, (size_t )len,
                   (FILE */* __restrict  */)f);
  }
#line 31
  if (tmp___1 == (size_t )len) {
#line 31
    tmp___0 = 0;
  } else {
#line 31
    tmp___0 = -1;
  }
#line 31
  return (tmp___0);
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/translate.c"
int tr_raw_import(FILE *f , void **data , int *len ) 
{ 
  int sz ;
  int n ;
  size_t tmp ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 38
  sz = *len;
#line 39
  *len = 0;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (*len + 512 > sz) {
      {
#line 43
      sz += 512;
#line 44
      *data = realloc(*data, (size_t )sz);
      }
    }
    {
#line 46
    tmp = fread((void */* __restrict  */)(*data + *len), (size_t )1, (size_t )(sz - *len),
                (FILE */* __restrict  */)f);
#line 46
    n = (int )tmp;
    }
#line 47
    if (n == 0) {
      {
#line 47
      tmp___2 = feof(f);
      }
#line 47
      if (tmp___2) {
#line 47
        tmp___1 = 0;
      } else {
#line 47
        tmp___1 = -1;
      }
#line 47
      return (tmp___1);
    }
#line 48
    *len += n;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/translate.c"
int tr_str_export(FILE *f , void *data , int len ) 
{ 
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 54
  tmp___2 = fwrite((void const   */* __restrict  */)(data + 1), (size_t )1, (size_t )(len - 1),
                   (FILE */* __restrict  */)f);
  }
#line 54
  if (tmp___2 == (size_t )(len - 1)) {
    {
#line 54
    tmp___3 = fputc('\n', f);
    }
#line 54
    if (tmp___3 == 10) {
#line 54
      tmp___1 = 0;
    } else {
#line 54
      tmp___1 = -1;
    }
  } else {
#line 54
    tmp___1 = -1;
  }
#line 54
  return (tmp___1);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/translate.c"
int tr_str_import(FILE *f , void **data , int *len ) 
{ 
  int sz ;
  int c ;
  int tmp ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 62
  sz = 512;
#line 62
  *data = realloc(*data, (size_t )sz);
#line 63
  *len = 1;
  }
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 65
    c = fgetc(f);
    }
#line 65
    if (c >= 0) {
#line 65
      if (! (c != 10)) {
#line 65
        goto while_break;
      }
    } else {
#line 65
      goto while_break;
    }
#line 66
    if (*len >= sz) {
      {
#line 66
      sz += 512;
#line 66
      *data = realloc(*data, (size_t )sz);
      }
    }
#line 67
    tmp = *len;
#line 67
    (*len) ++;
#line 67
    *((unsigned char *)*data + tmp) = (unsigned char )c;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 69
  *((unsigned char *)*data) = (unsigned char )(*len - 1);
#line 71
  tmp___2 = feof(f);
  }
#line 71
  if (tmp___2) {
#line 71
    tmp___1 = 0;
  } else
#line 71
  if (c == 10) {
#line 71
    tmp___1 = 0;
  } else {
#line 71
    tmp___1 = -1;
  }
#line 71
  return (tmp___1);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/translate.c"
int tr_strhash_export(FILE *f , void *data , int len ) 
{ 
  uint8_t *buf ;
  int strn ;
  int pos ;
  uint16_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 76
  buf = (uint8_t *)data;
#line 79
  if (len >= 2) {
    {
#line 79
    tmp = htons(*((uint16_t *)data));
#line 79
    strn = (int )tmp;
    }
  } else {
#line 79
    strn = 1;
  }
#line 80
  pos = (int )sizeof(uint16_t );
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    tmp___1 = strn;
#line 82
    strn --;
#line 82
    if (! tmp___1) {
#line 82
      goto while_break;
    }
#line 83
    if (pos + 1 > len) {
      {
#line 84
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"W: unexpected end of resource data\n");
      }
#line 85
      return (0);
    } else
#line 83
    if ((pos + 1) + (int )*(buf + pos) > len) {
      {
#line 84
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"W: unexpected end of resource data\n");
      }
#line 85
      return (0);
    }
    {
#line 87
    tmp___0 = tr_str_export(f, (void *)(buf + pos), 1 + (int )*(buf + pos));
    }
#line 87
    if (tmp___0 != 0) {
#line 88
      return (-1);
    }
#line 89
    pos += 1 + (int )*(buf + pos);
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return (0);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/translate.c"
int tr_strhash_import(FILE *f , void **data , int *len ) 
{ 
  void *sd ;
  int sl ;
  int sn ;
  int tmp ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 97
  sd = (void *)0;
#line 98
  sl = 0;
#line 100
  *len = (int )sizeof(unsigned short );
#line 101
  *data = realloc(*data, (size_t )*len);
#line 103
  sn = 0;
  }
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 103
    tmp = tr_str_import(f, & sd, & sl);
    }
#line 103
    if (tmp) {
#line 103
      goto while_break;
    } else {
      {
#line 103
      tmp___0 = feof(f);
      }
#line 103
      if (tmp___0) {
#line 103
        if (! (sl > 1)) {
#line 103
          goto while_break;
        }
      }
    }
    {
#line 104
    *data = realloc(*data, (size_t )(*len + sl));
#line 105
    memcpy((void */* __restrict  */)(*data + *len), (void const   */* __restrict  */)sd,
           (size_t )sl);
#line 106
    *len += sl;
#line 103
    sn ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 108
  *((unsigned short *)*data) = htons((uint16_t )sn);
#line 110
  tmp___3 = feof(f);
  }
#line 110
  if (tmp___3) {
#line 110
    tmp___2 = 0;
  } else {
#line 110
    tmp___2 = -1;
  }
#line 110
  return (tmp___2);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/translate.c"
int tr_cmdl_export(FILE *f , void *data , int len ) 
{ 
  char empty[1] ;
  void *tmp ;

  {
#line 115
  empty[0] = (char )'\000';
#line 117
  if (! len) {
#line 118
    data = (void *)(empty);
#line 119
    len = (int )sizeof(len);
  }
  {
#line 121
  tmp = memchr((void const   *)data, '\000', (size_t )len);
  }
#line 121
  if (! tmp) {
    {
#line 122
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No terminating null byte.\n");
    }
#line 123
    return (-1);
  }
  {
#line 125
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s\n", (char *)data);
  }
#line 127
  return (0);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/translate.c"
int tr_cmdl_import(FILE *f , void **data , int *len ) 
{ 
  char buf[512] ;
  char *c ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 134
  c = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)f);
  }
#line 135
  if (! c) {
    {
#line 136
    perror((char const   *)((void *)0));
    }
#line 137
    return (-1);
  }
  {
#line 139
  c = strchr((char const   *)(buf), '\n');
  }
#line 140
  if (c) {
#line 140
    tmp = c;
#line 140
    c ++;
#line 140
    *tmp = (char )'\000';
  }
  {
#line 142
  tmp___0 = strlen((char const   *)(buf));
#line 142
  *len = (int )(tmp___0 + 1UL);
#line 143
  *data = realloc(*data, (size_t )*len);
#line 144
  strcpy((char */* __restrict  */)*data, (char const   */* __restrict  */)(buf));
  }
#line 145
  return (0);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/translate.c"
struct translator tr_table[5]  = {      {{(char )'S', (char )'T', (char )'R', (char )' '}, "txt", & tr_str_export, & tr_str_import}, 
        {{(char )'S',
       (char )'T', (char )'R', (char )'#'}, "txt", & tr_strhash_export, & tr_strhash_import}, 
        {{(char )'C',
       (char )'M', (char )'D', (char )'L'}, "txt", & tr_cmdl_export, & tr_cmdl_import}, 
        {{(char )'\000'},
      "bin", & tr_raw_export, & tr_raw_import}, 
        {{(char )'\000'}, (char const   *)((void *)0), (int (*)(FILE *f , void *data ,
                                                             int len ))((void *)0),
      (int (*)(FILE *f , void **data , int *len ))((void *)0)}};
#line 161 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/translate.c"
struct translator *tr_lookup(struct resource *r , char const   *ext ) 
{ 
  struct translator *tr ;
  restype_t type ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 166
  res_gettype(r, (char *)(type));
#line 167
  tr = tr_table;
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! tr->export) {
#line 167
      goto while_break;
    }
#line 168
    if (tr->type[0]) {
      {
#line 168
      tmp = memcmp((void const   *)(tr->type), (void const   *)(type), sizeof(type));
      }
#line 168
      if (tmp) {
#line 169
        goto __Cont;
      }
    }
#line 170
    if (ext) {
#line 170
      if (tr->ext) {
        {
#line 170
        tmp___0 = strcmp(tr->ext, ext);
        }
#line 170
        if (tmp___0) {
#line 171
          goto __Cont;
        }
      }
    }
#line 173
    return (tr);
    __Cont: /* CIL Label */ 
#line 167
    tr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  return ((struct translator *)((void *)0));
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/translate.c"
char const   *tr_ext(struct translator *tr ) 
{ 


  {
#line 180
  return (tr->ext);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/translate.c"
int tr_export(struct translator *tr , struct resource *r , FILE *out ) 
{ 
  void *data ;
  int len ;
  int tmp ;

  {
  {
#line 188
  res_getdata(r, & data, & len);
#line 189
  tmp = (*(tr->export))(out, data, len);
  }
#line 189
  return (tmp);
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/translate.c"
int tr_import(struct translator *tr , struct resource *r , FILE *in ) 
{ 
  void *data ;
  int len ;
  int ret ;

  {
  {
#line 197
  data = (void *)0;
#line 198
  len = 0;
#line 199
  ret = (*(tr->import))(in, & data, & len);
  }
#line 201
  if (! ret) {
    {
#line 202
    res_setdata(r, data, len);
    }
  } else {
    {
#line 204
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t import resource data\n");
    }
  }
#line 205
  if (data) {
    {
#line 206
    free(data);
    }
  }
#line 208
  return (ret);
}
}
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 620
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 717
extern int system(char const   *__command ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.h"
struct resource *res_new(struct res_fork *f , char *type , int16_t id ) ;
#line 32
void res_rename(struct resource *r , char *name , int nlen ) ;
#line 33
void res_chattr(struct resource *r , char const   *spec ) ;
#line 34
void res_delete(struct resource *r ) ;
#line 36
struct res_fork *res_newfork(void) ;
#line 37
struct res_fork *res_read(char const   *fname ) ;
#line 38
int res_write(struct res_fork *f , char const   *fname ) ;
#line 39
struct resource *res_lookup(struct res_fork *f , char *type , int16_t id ) ;
#line 40
void res_ls(FILE *s , struct res_fork *f ) ;
#line 41
void res_delfork(struct res_fork *f ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
static struct res_fork *cmd_rf  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
static restype_t cmd_res_type  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
static int cmd_res_id  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
static struct resource *cmd_res  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
int cmd_parseresource(char const   *spec ) 
{ 
  char *colon ;

  {
#line 38
  if (! spec) {
    {
#line 39
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Please specify a resource to act on.\n");
    }
#line 40
    return (1);
  }
  {
#line 43
  colon = strrchr(spec, ':');
  }
#line 44
  if (! colon) {
    {
#line 45
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Incorrect resource specification\n");
    }
#line 46
    return (1);
  } else
#line 44
  if ((unsigned long )colon > (unsigned long )(spec + 4)) {
    {
#line 45
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Incorrect resource specification\n");
    }
#line 46
    return (1);
  }
  {
#line 48
  memset((void *)(cmd_res_type), ' ', sizeof(cmd_res_type));
#line 49
  memcpy((void */* __restrict  */)(cmd_res_type), (void const   */* __restrict  */)spec,
         (size_t )(colon - (char *)spec));
#line 50
  cmd_res_id = atoi((char const   *)(colon + 1));
  }
#line 52
  return (0);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
int cmd_selectresource(char const   *spec ) 
{ 
  int tmp ;

  {
  {
#line 57
  tmp = cmd_parseresource(spec);
  }
#line 57
  if (tmp) {
#line 58
    return (1);
  }
  {
#line 60
  cmd_res = res_lookup(cmd_rf, (char *)(cmd_res_type), (int16_t )cmd_res_id);
  }
#line 61
  if (! cmd_res) {
    {
#line 62
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No such resource.\n");
    }
#line 63
    return (1);
  }
#line 66
  return (0);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
static char *cmd_ifname  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
static char *cmd_ofname  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
int cmd_read(char **argv ) 
{ 
  struct res_fork *rf ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 76
  if (*(argv + 1)) {
    {
#line 77
    tmp = strlen((char const   *)*(argv + 1));
#line 77
    tmp___0 = realloc((void *)cmd_ifname, tmp + 1UL);
#line 77
    cmd_ifname = (char *)tmp___0;
#line 78
    strcpy((char */* __restrict  */)cmd_ifname, (char const   */* __restrict  */)*(argv + 1));
    }
  }
#line 80
  if (! cmd_ifname) {
    {
#line 81
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Read which file ?\n");
    }
#line 82
    return (1);
  }
  {
#line 85
  rf = res_read((char const   *)cmd_ifname);
  }
#line 86
  if (! rf) {
    {
#line 87
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error while reading %s\n",
            *(argv + 1));
    }
#line 88
    return (1);
  }
  {
#line 91
  res_delfork(cmd_rf);
#line 92
  cmd_rf = rf;
  }
#line 93
  return (0);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
int cmd_write(char **argv ) 
{ 
  char const   *fname ;
  int ret ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 101
  if (*(argv + 1)) {
    {
#line 102
    tmp = strlen((char const   *)*(argv + 1));
#line 102
    tmp___0 = realloc((void *)cmd_ofname, tmp + 1UL);
#line 102
    cmd_ofname = (char *)tmp___0;
#line 103
    strcpy((char */* __restrict  */)cmd_ofname, (char const   */* __restrict  */)*(argv + 1));
    }
  }
#line 105
  if (cmd_ofname) {
#line 105
    fname = (char const   *)cmd_ofname;
  } else {
#line 105
    fname = (char const   *)cmd_ifname;
  }
#line 106
  if (! fname) {
    {
#line 107
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Write to which file ?\n");
    }
#line 108
    return (1);
  }
  {
#line 111
  ret = res_write(cmd_rf, fname);
  }
#line 112
  if (ret < 0) {
    {
#line 113
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Write error\n");
    }
#line 114
    return (1);
  }
#line 117
  return (0);
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
int cmd_create(char **argv ) 
{ 
  int tmp ;

  {
#line 122
  if (! *(argv + 1)) {
    {
#line 123
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s <resource>\n",
            *(argv + 0));
    }
#line 124
    return (1);
  }
  {
#line 127
  tmp = cmd_parseresource((char const   *)*(argv + 1));
  }
#line 127
  if (tmp) {
#line 128
    return (1);
  }
  {
#line 130
  cmd_res = res_lookup(cmd_rf, (char *)(cmd_res_type), (int16_t )cmd_res_id);
  }
#line 131
  if (cmd_res) {
    {
#line 132
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Resource already exists.\n");
    }
#line 133
    return (1);
  }
  {
#line 136
  cmd_res = res_new(cmd_rf, (char *)(cmd_res_type), (int16_t )cmd_res_id);
  }
#line 137
  return (0);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
int cmd_delete(char **argv ) 
{ 
  int tmp ;

  {
#line 142
  if (! *(argv + 1)) {
    {
#line 143
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s <resource>\n",
            *(argv + 0));
    }
#line 144
    return (1);
  }
  {
#line 147
  tmp = cmd_selectresource((char const   *)*(argv + 1));
  }
#line 147
  if (tmp) {
#line 148
    return (1);
  }
  {
#line 150
  res_delete(cmd_res);
  }
#line 151
  return (0);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
int cmd_rename(char **argv ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
#line 156
  if (! *(argv + 2)) {
    {
#line 157
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s <resource> <name>\n",
            *(argv + 0));
    }
#line 158
    return (1);
  }
  {
#line 161
  tmp = cmd_selectresource((char const   *)*(argv + 1));
  }
#line 161
  if (tmp) {
#line 162
    return (1);
  }
  {
#line 164
  tmp___0 = strlen((char const   *)*(argv + 2));
#line 164
  res_rename(cmd_res, *(argv + 2), (int )tmp___0);
  }
#line 165
  return (0);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
int cmd_chattr(char **argv ) 
{ 
  int tmp ;

  {
#line 170
  if (! *(argv + 2)) {
    {
#line 171
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s <resource> <attributes>\n",
            *(argv + 0));
    }
#line 172
    return (1);
  }
  {
#line 175
  tmp = cmd_selectresource((char const   *)*(argv + 1));
  }
#line 175
  if (tmp) {
#line 176
    return (1);
  }
  {
#line 178
  res_chattr(cmd_res, (char const   *)*(argv + 2));
  }
#line 179
  return (0);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
int cmd_ls(char **argv ) 
{ 


  {
  {
#line 184
  res_ls(stdout, cmd_rf);
  }
#line 185
  return (0);
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
int cmd_hexdump(char **argv ) 
{ 
  int i ;
  int j ;
  unsigned char *data ;
  int len ;
  int tmp ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  {
#line 194
  tmp = cmd_selectresource((char const   *)*(argv + 1));
  }
#line 194
  if (tmp) {
#line 195
    return (1);
  }
  {
#line 197
  res_getdata(cmd_res, (void **)(& data), & len);
#line 199
  i = 0;
  }
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! (i < len)) {
#line 199
      goto while_break;
    }
    {
#line 200
    printf((char const   */* __restrict  */)"%8x ", i);
#line 201
    j = 0;
    }
    {
#line 201
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 201
      if (! (j < 16)) {
#line 201
        goto while_break___0;
      }
#line 202
      if (i + j < len) {
        {
#line 203
        printf((char const   */* __restrict  */)" %02x", (int )*(data + (i + j)));
        }
      } else {
        {
#line 205
        printf((char const   */* __restrict  */)"   ");
        }
      }
#line 201
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 207
    printf((char const   */* __restrict  */)"  |");
#line 208
    j = 0;
    }
    {
#line 208
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 208
      if (j < 16) {
#line 208
        if (! (i + j < len)) {
#line 208
          goto while_break___1;
        }
      } else {
#line 208
        goto while_break___1;
      }
      {
#line 209
      tmp___2 = __ctype_b_loc();
      }
#line 209
      if ((int const   )*(*tmp___2 + (int )*(data + (i + j))) & 16384) {
#line 209
        tmp___1 = (int )*(data + (i + j));
      } else {
#line 209
        tmp___1 = '.';
      }
      {
#line 209
      printf((char const   */* __restrict  */)"%c", tmp___1);
#line 208
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 210
    printf((char const   */* __restrict  */)"|\n");
#line 199
    i += 16;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  return (0);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
int cmd_export(char **argv ) 
{ 
  struct translator *tr ;
  FILE *f ;
  char *c ;
  int what ;
  int r ;
  int tmp ;
  int tmp___0 ;
  struct _IO_FILE *tmp___2 ;
  char const   *tmp___3 ;
  FILE *tmp___4 ;
  int tmp___5 ;
  int (*tmp___6)(struct translator *t , struct resource *r , FILE *o ) ;
  int tmp___7 ;

  {
  {
#line 224
  tmp = strcmp((char const   *)*(argv + 0), "export");
#line 224
  what = tmp == 0;
  }
#line 226
  if (! *(argv + 2)) {
    {
#line 227
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s <resource> <file> [<type>]\n",
            *(argv + 0));
    }
#line 228
    return (1);
  }
#line 230
  if (! *(argv + 3)) {
    {
#line 231
    c = strrchr((char const   *)*(argv + 2), '.');
    }
#line 232
    if (c) {
#line 232
      *(argv + 3) = c + 1;
    } else {
#line 232
      *(argv + 3) = (char *)((void *)0);
    }
  }
  {
#line 235
  tmp___0 = cmd_selectresource((char const   *)*(argv + 1));
  }
#line 235
  if (tmp___0) {
#line 236
    return (1);
  }
  {
#line 238
  tr = tr_lookup(cmd_res, (char const   *)*(argv + 3));
  }
#line 239
  if (! tr) {
    {
#line 240
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"I don\'t know how to translate this.\n");
    }
#line 241
    return (1);
  }
  {
#line 244
  tmp___5 = strcmp((char const   *)*(argv + 2), "-");
  }
#line 244
  if (tmp___5 == 0) {
#line 244
    if (what) {
#line 244
      tmp___2 = stdout;
    } else {
#line 244
      tmp___2 = stdin;
    }
#line 244
    f = tmp___2;
  } else {
#line 244
    if (what) {
#line 244
      tmp___3 = "w";
    } else {
#line 244
      tmp___3 = "r";
    }
    {
#line 244
    tmp___4 = fopen((char const   */* __restrict  */)*(argv + 2), (char const   */* __restrict  */)tmp___3);
#line 244
    f = tmp___4;
    }
  }
#line 246
  if (! f) {
    {
#line 247
    perror((char const   *)*(argv + 2));
    }
#line 248
    return (1);
  }
#line 251
  if (what) {
#line 251
    tmp___6 = & tr_export;
  } else {
#line 251
    tmp___6 = & tr_import;
  }
  {
#line 251
  r = (*tmp___6)(tr, cmd_res, f);
#line 252
  tmp___7 = strcmp((char const   *)*(argv + 2), "-");
  }
#line 252
  if (tmp___7 != 0) {
    {
#line 253
    fclose(f);
    }
  }
#line 255
  return (r);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
static char *cmd_edit_export(struct translator *tr ) 
{ 
  char filename[18] ;
  char *nfname ;
  char *ret ;
  char const   *ext ;
  int fd ;
  int r ;
  FILE *f ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 261
  filename[0] = (char )'/';
#line 261
  filename[1] = (char )'t';
#line 261
  filename[2] = (char )'m';
#line 261
  filename[3] = (char )'p';
#line 261
  filename[4] = (char )'/';
#line 261
  filename[5] = (char )'r';
#line 261
  filename[6] = (char )'s';
#line 261
  filename[7] = (char )'r';
#line 261
  filename[8] = (char )'c';
#line 261
  filename[9] = (char )'e';
#line 261
  filename[10] = (char )'.';
#line 261
  filename[11] = (char )'X';
#line 261
  filename[12] = (char )'X';
#line 261
  filename[13] = (char )'X';
#line 261
  filename[14] = (char )'X';
#line 261
  filename[15] = (char )'X';
#line 261
  filename[16] = (char )'X';
#line 261
  filename[17] = (char )'\000';
#line 261
  ret = (char *)((void *)0);
#line 264
  f = (FILE *)((void *)0);
#line 266
  fd = mkstemp(filename);
  }
#line 267
  if (fd < 0) {
    {
#line 268
    perror((char const   *)(filename));
    }
#line 269
    return ((char *)((void *)0));
  }
  {
#line 272
  ext = tr_ext(tr);
#line 273
  tmp = strlen((char const   *)(filename));
#line 273
  tmp___0 = strlen(ext);
#line 273
  tmp___1 = malloc((tmp + tmp___0) + 2UL);
#line 273
  nfname = (char *)tmp___1;
#line 274
  sprintf((char */* __restrict  */)nfname, (char const   */* __restrict  */)"%s.%s",
          filename, ext);
#line 276
  r = rename((char const   *)(filename), (char const   *)nfname);
  }
#line 276
  if (r < 0) {
    {
#line 277
    perror((char const   *)nfname);
    }
  } else {
    {
#line 278
    f = fdopen(fd, "w");
    }
#line 278
    if ((unsigned long )f == (unsigned long )((void *)0)) {
      {
#line 279
      perror("fdopen");
      }
    } else {
      {
#line 280
      tmp___2 = tr_export(tr, cmd_res, f);
      }
#line 280
      if (tmp___2 < 0) {
        {
#line 281
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t translate resource data\n");
        }
      } else {
#line 283
        ret = nfname;
      }
    }
  }
#line 285
  if (! ret) {
#line 286
    if (r < 0) {
#line 286
      tmp___3 = filename;
    } else {
#line 286
      tmp___3 = nfname;
    }
    {
#line 286
    unlink((char const   *)tmp___3);
#line 287
    free((void *)nfname);
    }
  }
#line 289
  if (f) {
    {
#line 289
    fclose(f);
    }
  } else {
    {
#line 289
    close(fd);
    }
  }
#line 291
  return (ret);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
static int cmd_edit_edit(char const   *fname ) 
{ 
  char *cmd ;
  int ret ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 302
  tmp = strlen("/usr/bin/sensible-editor");
#line 302
  tmp___0 = strlen(fname);
#line 302
  tmp___1 = malloc((tmp + tmp___0) + 2UL);
#line 302
  cmd = (char *)tmp___1;
#line 303
  sprintf((char */* __restrict  */)cmd, (char const   */* __restrict  */)"%s %s",
          "/usr/bin/sensible-editor", fname);
#line 304
  ret = system((char const   *)cmd);
#line 305
  free((void *)cmd);
  }
#line 307
  return (ret);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
static int cmd_edit_import(struct translator *tr , char const   *filename ) 
{ 
  FILE *f ;
  int ret ;

  {
  {
#line 316
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 317
  if (! f) {
    {
#line 318
    perror(filename);
    }
#line 319
    return (-1);
  }
  {
#line 322
  ret = tr_import(tr, cmd_res, f);
#line 323
  fclose(f);
  }
#line 325
  return (ret);
}
}
#line 328 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
int cmd_edit(char **argv ) 
{ 
  struct translator *tr ;
  int ret ;
  char *fname ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 334
  tmp = cmd_selectresource((char const   *)*(argv + 1));
  }
#line 334
  if (tmp != 0) {
#line 335
    return (1);
  }
  {
#line 337
  tr = tr_lookup(cmd_res, (char const   *)*(argv + 2));
  }
#line 338
  if (! tr) {
    {
#line 339
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"I don\'t know how to translate this.\n");
    }
#line 340
    return (1);
  }
  {
#line 343
  fname = cmd_edit_export(tr);
  }
#line 344
  if (! fname) {
#line 345
    return (1);
  }
  {
#line 346
  tmp___0 = cmd_edit_edit((char const   *)fname);
  }
#line 346
  if (tmp___0 == 0) {
    {
#line 346
    tmp___1 = cmd_edit_import(tr, (char const   *)fname);
    }
#line 346
    if (tmp___1 == 0) {
#line 346
      tmp___2 = 1;
    } else {
#line 346
      tmp___2 = 0;
    }
  } else {
#line 346
    tmp___2 = 0;
  }
  {
#line 346
  ret = tmp___2;
#line 347
  unlink((char const   *)fname);
#line 348
  free((void *)fname);
  }
#line 350
  if (ret) {
#line 350
    tmp___3 = 0;
  } else {
#line 350
    tmp___3 = 1;
  }
#line 350
  return (tmp___3);
}
}
#line 353
int cmd_help(char **argv ) ;
#line 355 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
int cmd_exit(char **argv ) 
{ 


  {
  {
#line 357
  exit(0);
  }
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
struct command cmd_table[14]  = 
#line 360
  {      {"read", & cmd_read, "Read the resource fork from a file"}, 
        {"write", & cmd_write, "Write the resource fork to a file"}, 
        {"create", & cmd_create, "Create resource"}, 
        {"delete", & cmd_delete, "Delete resource"}, 
        {"rename", & cmd_rename, "Change the resource name"}, 
        {"chattr", & cmd_chattr, "Change the resource attributes"}, 
        {"ls", & cmd_ls, "List resources"}, 
        {"hexdump", & cmd_hexdump, "Show an hexdump of the resource data"}, 
        {"import", & cmd_export, "Import resource data from a file"}, 
        {"export", & cmd_export, "Export resource data to a file"}, 
        {"edit", & cmd_edit, "Edit resource data"}, 
        {"help", & cmd_help, "This short help listing"}, 
        {"exit", & cmd_exit, "Exit (don\'t forget to write first!)"}, 
        {(char const   *)((void *)0), (int (*)(char **argv ))((void *)0), (char const   *)((void *)0)}};
#line 381 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
int cmd_help(char **argv ) 
{ 
  int i ;

  {
#line 385
  i = 0;
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 385
    if (! cmd_table[i].cmd) {
#line 385
      goto while_break;
    }
    {
#line 386
    printf((char const   */* __restrict  */)"%10s -- %s\n", cmd_table[i].cmd, cmd_table[i].help);
#line 385
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  return (0);
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
int cmd_exec(char **argv ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 397
  if (! *(argv + 0)) {
#line 398
    return (0);
  }
#line 400
  i = 0;
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! cmd_table[i].cmd) {
#line 400
      goto while_break;
    }
    {
#line 401
    tmp___0 = strcmp(cmd_table[i].cmd, (char const   *)*(argv + 0));
    }
#line 401
    if (tmp___0 == 0) {
      {
#line 402
      tmp = (*(cmd_table[i].f))(argv);
      }
#line 402
      return (tmp);
    }
#line 400
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 405
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: no such command\n",
          *(argv + 0));
  }
#line 406
  return (1);
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/command.c"
void cmd_init(char const   *ifname , char const   *ofname ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  struct res_fork *tmp___1 ;
  struct res_fork *tmp___2 ;

  {
#line 411
  if (ifname) {
    {
#line 411
    tmp = strdup(ifname);
#line 411
    cmd_ifname = tmp;
    }
  } else {
#line 411
    cmd_ifname = (char *)((void *)0);
  }
#line 412
  if (ofname) {
    {
#line 412
    tmp___0 = strdup(ofname);
#line 412
    cmd_ofname = tmp___0;
    }
  } else {
#line 412
    cmd_ofname = (char *)((void *)0);
  }
#line 413
  if (cmd_ifname) {
    {
#line 413
    tmp___1 = res_read((char const   *)cmd_ifname);
#line 413
    cmd_rf = tmp___1;
    }
  } else {
    {
#line 413
    tmp___2 = res_newfork();
#line 413
    cmd_rf = tmp___2;
    }
  }
#line 414
  if (! cmd_rf) {
    {
#line 415
    exit(1);
    }
  }
#line 417
  return;
}
}
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
static int res_lookup_type(struct res_fork *f , char *type ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 55
  i = 0;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (i < f->tn) {
      {
#line 55
      tmp = memcmp((void const   *)((f->tt + i)->type), (void const   *)type, sizeof(type));
      }
#line 55
      if (! tmp) {
#line 55
        goto while_break;
      }
    } else {
#line 55
      goto while_break;
    }
#line 55
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  if (i < f->tn) {
#line 56
    tmp___0 = i;
  } else {
#line 56
    tmp___0 = -1;
  }
#line 56
  return (tmp___0);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
static struct resource **res_lookup_rp(struct res_fork *f , int ti , int id ) 
{ 
  struct resource **rp ;

  {
#line 62
  rp = & (f->tt + ti)->rlist;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (*rp) {
#line 62
      if (! ((int )(*rp)->id != id)) {
#line 62
        goto while_break;
      }
    } else {
#line 62
      goto while_break;
    }
#line 62
    rp = & (*rp)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return (rp);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
struct resource *res_lookup(struct res_fork *f , char *type , int16_t id ) 
{ 
  int ti ;
  int tmp ;
  struct resource **tmp___0 ;
  struct resource *tmp___1 ;

  {
  {
#line 68
  tmp = res_lookup_type(f, type);
#line 68
  ti = tmp;
  }
#line 69
  if (ti >= 0) {
    {
#line 69
    tmp___0 = res_lookup_rp(f, ti, (int )id);
#line 69
    tmp___1 = *tmp___0;
    }
  } else {
#line 69
    tmp___1 = (struct resource *)((void *)0);
  }
#line 69
  return (tmp___1);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
static int res_getti(struct res_fork *f , char *type ) 
{ 
  int ti ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 77
  ti = res_lookup_type(f, type);
  }
#line 78
  if (ti < 0) {
    {
#line 79
    tmp = f->tn;
#line 79
    (f->tn) ++;
#line 79
    ti = tmp;
#line 80
    tmp___0 = realloc((void *)f->tt, (unsigned long )f->tn * sizeof(*(f->tt)));
#line 80
    f->tt = (struct __anonstruct_tt_33 *)tmp___0;
#line 81
    memcpy((void */* __restrict  */)((f->tt + ti)->type), (void const   */* __restrict  */)type,
           sizeof(type));
#line 82
    (f->tt + ti)->rlist = (struct resource *)((void *)0);
    }
  }
#line 85
  return (ti);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
struct resource *res_new(struct res_fork *f , char *type , int16_t id ) 
{ 
  struct resource *r ;
  struct resource **rp ;
  int ti ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 91
  tmp = res_getti(f, type);
#line 91
  ti = tmp;
#line 94
  rp = res_lookup_rp(f, ti, -1);
  }
#line 95
  if (*rp) {
    {
#line 96
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"W: reusing duplicate resource %.4s:%d!\n",
            type, (int )id);
    }
#line 98
    return (*rp);
  }
  {
#line 101
  tmp___0 = malloc(sizeof(*r));
#line 101
  r = (struct resource *)tmp___0;
#line 102
  memset((void *)r, 0, sizeof(*r));
#line 103
  r->f = f;
#line 104
  r->ti = ti;
#line 105
  r->id = id;
#line 107
  *rp = r;
  }
#line 108
  return (r);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
void res_getdata(struct resource *r , void **dp , int *len ) 
{ 


  {
#line 113
  *dp = (void *)r->data;
#line 114
  *len = r->datalen;
#line 115
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
void res_setdata(struct resource *r , void *p , int len ) 
{ 
  void *tmp ;

  {
#line 119
  if (r->data) {
    {
#line 119
    free((void *)r->data);
    }
  }
#line 121
  r->datalen = len;
#line 122
  if (len) {
    {
#line 123
    tmp = malloc((size_t )len);
#line 123
    r->data = (char *)tmp;
#line 124
    memcpy((void */* __restrict  */)r->data, (void const   */* __restrict  */)p, (size_t )len);
    }
  } else {
#line 126
    r->data = (char *)((void *)0);
  }
#line 127
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
void res_gettype(struct resource *r , char *type ) 
{ 


  {
  {
#line 131
  memcpy((void */* __restrict  */)type, (void const   */* __restrict  */)(((r->f)->tt + r->ti)->type),
         sizeof(type));
  }
#line 132
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
void res_rename(struct resource *r , char *name , int nlen ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
#line 136
  if (r->name) {
    {
#line 136
    free((void *)r->name);
    }
  }
#line 138
  if (nlen >= 0) {
#line 138
    r->namelen = nlen;
  } else {
    {
#line 138
    tmp = strlen((char const   *)name);
#line 138
    r->namelen = (int )tmp;
    }
  }
  {
#line 139
  tmp___0 = malloc((size_t )(r->namelen + 1));
#line 139
  r->name = (char *)tmp___0;
#line 140
  memcpy((void */* __restrict  */)r->name, (void const   */* __restrict  */)name,
         (size_t )r->namelen);
#line 141
  *(r->name + r->namelen) = (char )'\000';
  }
#line 142
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
char const   * const  res_attrch  =    (char const   */* const  */)"7spLPlw0";
#line 145 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
void res_chattr(struct resource *r , char const   *spec ) 
{ 
  int v ;
  int op ;
  int mask ;
  char *pos ;

  {
#line 150
  v = 0;
#line 151
  op = 255;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! *spec) {
#line 152
      goto while_break;
    }
    {
#line 153
    pos = strchr((char const   *)res_attrch, (int )*spec);
    }
#line 154
    if (pos) {
#line 155
      mask = 128 >> (pos - (char *)res_attrch);
#line 156
      v &= ~ mask;
#line 157
      v |= op & mask;
#line 158
      r->attr = (uint8_t )v;
    } else
#line 159
    if ((int const   )*spec == 43) {
#line 160
      v = (int )r->attr;
#line 161
      op = 255;
    } else
#line 162
    if ((int const   )*spec == 45) {
#line 163
      v = (int )r->attr;
#line 164
      op = 0;
    } else {
      {
#line 166
      r->attr = (uint8_t )v;
#line 167
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown attribute \'%c\'\n",
              (int const   )*spec);
      }
    }
#line 169
    spec ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
static void res_deltype(struct res_fork *f , int ti ) 
{ 
  struct resource *r ;
  void *tmp ;

  {
  {
#line 177
  (f->tn) --;
#line 177
  memmove((void *)(f->tt + ti), (void const   *)((f->tt + ti) + 1), (unsigned long )(f->tn - ti) * sizeof(*(f->tt)));
#line 178
  tmp = realloc((void *)f->tt, (unsigned long )f->tn * sizeof(*(f->tt)));
#line 178
  f->tt = (struct __anonstruct_tt_33 *)tmp;
  }
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! (ti < f->tn)) {
#line 180
      goto while_break;
    }
#line 181
    r = (f->tt + ti)->rlist;
    {
#line 181
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 181
      if (! r) {
#line 181
        goto while_break___0;
      }
#line 182
      r->ti = ti;
#line 181
      r = r->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 183
    ti ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  return;
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
void res_delete(struct resource *r ) 
{ 
  struct resource **rp ;

  {
  {
#line 191
  rp = res_lookup_rp(r->f, r->ti, (int )r->id);
  }
#line 192
  if (! *rp) {
    {
#line 192
    __assert_fail("*rp", "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c",
                  192U, "res_delete");
    }
  }
#line 193
  *rp = r->next;
#line 195
  if (! ((r->f)->tt + r->ti)->rlist) {
    {
#line 196
    res_deltype(r->f, r->ti);
    }
  }
  {
#line 198
  free((void *)r);
  }
#line 199
  return;
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
static void res_printinfo(struct resource *r , FILE *s ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 205
  fprintf((FILE */* __restrict  */)s, (char const   */* __restrict  */)"%.4s %11d ",
          ((r->f)->tt + r->ti)->type, (int )r->id);
#line 206
  i = 0;
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! (i < 8)) {
#line 206
      goto while_break;
    }
#line 207
    if (((int )r->attr << i) & 128) {
#line 207
      tmp = (int const   )*(res_attrch + i);
    } else {
#line 207
      tmp = (int const   )'-';
    }
    {
#line 207
    fprintf((FILE */* __restrict  */)s, (char const   */* __restrict  */)"%c", tmp);
#line 206
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 208
  fprintf((FILE */* __restrict  */)s, (char const   */* __restrict  */)" %10d", r->datalen);
  }
#line 209
  if (r->name) {
    {
#line 210
    fprintf((FILE */* __restrict  */)s, (char const   */* __restrict  */)" %s", r->name);
    }
  }
  {
#line 211
  fprintf((FILE */* __restrict  */)s, (char const   */* __restrict  */)"\n");
  }
#line 212
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
void res_ls(FILE *s , struct res_fork *f ) 
{ 
  struct resource *r ;
  int ti ;

  {
#line 219
  ti = 0;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! (ti < f->tn)) {
#line 219
      goto while_break;
    }
#line 220
    r = (f->tt + ti)->rlist;
    {
#line 220
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 220
      if (! r) {
#line 220
        goto while_break___0;
      }
      {
#line 221
      res_printinfo(r, s);
#line 220
      r = r->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 219
    ti ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return;
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
struct res_fork *res_newfork(void) 
{ 
  struct res_fork *f ;
  void *tmp ;

  {
  {
#line 229
  tmp = malloc(sizeof(*f));
#line 229
  f = (struct res_fork *)tmp;
#line 230
  memset((void *)f, 0, sizeof(*f));
#line 231
  f->rlen = (int )sizeof(struct reshdr );
  }
#line 233
  return (f);
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
void res_delfork(struct res_fork *f ) 
{ 


  {
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! f->tn) {
#line 238
      goto while_break;
    }
    {
#line 238
    res_delete((f->tt + 0)->rlist);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 239
  free((void *)f);
  }
#line 240
  return;
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
static int res_readbuf(struct res_parsecontext *c , FILE *stream ) 
{ 
  int n ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 266
    tmp = realloc((void *)c->buf, (size_t )(c->len + 4096));
#line 266
    c->buf = (char *)tmp;
#line 267
    tmp___0 = fread((void */* __restrict  */)(c->buf + c->len), (size_t )1, (size_t )4096,
                    (FILE */* __restrict  */)stream);
#line 267
    n = (int )tmp___0;
#line 268
    c->len += n;
    }
#line 265
    if (n == 4096) {
#line 265
      if (! (c->len < 104857600)) {
#line 265
        goto while_break;
      }
    } else {
#line 265
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 271
  if (c->len >= 104857600) {
    {
#line 272
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This resource fork is rather huge !\n");
    }
#line 273
    return (-1);
  } else {
    {
#line 274
    tmp___1 = feof(stream);
    }
#line 274
    if (! tmp___1) {
      {
#line 275
      perror((char const   *)((void *)0));
      }
#line 276
      return (-1);
    }
  }
#line 279
  return (0);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
static int res_parse_reflist(struct res_parsecontext *c , struct restype *t ) 
{ 
  struct resource *r ;
  struct resref *ref ;
  struct resname *name ;
  struct resdata *data ;
  int i ;
  uint16_t tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint16_t tmp___8 ;

  {
  {
#line 290
  tmp = ntohs(t->refofs);
#line 290
  ref = (struct resref *)(c->tbase + (int )tmp);
#line 291
  i = 0;
  }
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 291
    tmp___8 = ntohs(t->rnum);
    }
#line 291
    if (! (i < (int )tmp___8 + 1)) {
#line 291
      goto while_break;
    }
#line 292
    if ((unsigned long )((char *)(ref + i)) < (unsigned long )c->buf) {
      {
#line 292
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wild reference offset!\n");
      }
#line 292
      return (-1);
    } else
#line 292
    if ((unsigned long )((char *)(ref + i) + sizeof(*(ref + i))) > (unsigned long )(c->buf + c->len)) {
      {
#line 292
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wild reference offset!\n");
      }
#line 292
      return (-1);
    }
    {
#line 293
    tmp___0 = ntohs((ref + i)->id);
#line 293
    r = res_new(c->f, (char *)(t->type), (int16_t )tmp___0);
#line 294
    r->attr = (uint8_t )(ref + i)->attr;
#line 296
    tmp___2 = ntohs((ref + i)->nameofs);
    }
#line 296
    if ((int )tmp___2 != 65535) {
      {
#line 297
      tmp___1 = ntohs((ref + i)->nameofs);
#line 297
      name = (struct resname *)(c->nbase + (int )tmp___1);
      }
#line 299
      if ((unsigned long )((char *)name) < (unsigned long )c->buf) {
        {
#line 299
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wild name offset!\n");
        }
#line 299
        return (-1);
      } else
#line 299
      if ((unsigned long )((char *)name + sizeof(*name)) > (unsigned long )(c->buf + c->len)) {
        {
#line 299
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wild name offset!\n");
        }
#line 299
        return (-1);
      }
#line 300
      if ((unsigned long )((name->name + (int )name->len) - 1) < (unsigned long )c->buf) {
        {
#line 300
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wild name offset!\n");
        }
#line 300
        return (-1);
      } else
#line 300
      if ((unsigned long )(((name->name + (int )name->len) - 1) + sizeof(*((name->name + (int )name->len) - 1))) > (unsigned long )(c->buf + c->len)) {
        {
#line 300
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wild name offset!\n");
        }
#line 300
        return (-1);
      }
      {
#line 301
      res_rename(r, name->name, (int )name->len);
      }
    }
    {
#line 304
    tmp___3 = ntohl((ref + i)->dataofs);
#line 304
    data = (struct resdata *)(c->dbase + (tmp___3 >> 8));
    }
#line 305
    if ((unsigned long )((char *)data) < (unsigned long )c->buf) {
      {
#line 305
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wild data offset!\n");
      }
#line 305
      return (-1);
    } else
#line 305
    if ((unsigned long )((char *)data + sizeof(*data)) > (unsigned long )(c->buf + c->len)) {
      {
#line 305
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wild data offset!\n");
      }
#line 305
      return (-1);
    }
    {
#line 306
    tmp___4 = ntohl(data->len);
    }
#line 306
    if ((unsigned long )((char *)((data->data + tmp___4) - 1)) < (unsigned long )c->buf) {
      {
#line 306
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wild data offset!\n");
      }
#line 306
      return (-1);
    } else {
      {
#line 306
      tmp___5 = ntohl(data->len);
      }
#line 306
      if ((unsigned long )((char *)((data->data + tmp___5) - 1) + sizeof(*((data->data + tmp___6) - 1))) > (unsigned long )(c->buf + c->len)) {
        {
#line 306
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wild data offset!\n");
        }
#line 306
        return (-1);
      }
    }
    {
#line 307
    tmp___7 = ntohl(data->len);
#line 307
    res_setdata(r, (void *)(data->data), (int )tmp___7);
#line 291
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  return (0);
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
static int res_parse_typelist(struct res_parsecontext *c ) 
{ 
  uint16_t *tnp ;
  uint16_t tn ;
  uint16_t tmp ;
  struct restype *l ;
  int i ;
  int tmp___0 ;

  {
  {
#line 315
  tnp = (uint16_t *)c->tbase;
#line 315
  tmp = ntohs(*tnp);
#line 315
  tn = (uint16_t )((int )tmp + 1);
#line 316
  l = (struct restype *)(tnp + 1);
#line 319
  i = 0;
  }
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (! (i < (int )tn)) {
#line 319
      goto while_break;
    }
    {
#line 320
    tmp___0 = res_parse_reflist(c, l + i);
    }
#line 320
    if (tmp___0 < 0) {
#line 321
      return (-1);
    }
#line 319
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 324
  return (0);
}
}
#line 327 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
static int res_parsebuf(struct res_parsecontext *c ) 
{ 
  struct reshdr *rh ;
  struct resmaphdr *mh ;
  uint32_t tmp ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint16_t tmp___7 ;
  uint16_t tmp___8 ;
  int tmp___9 ;

  {
  {
#line 332
  rh = (struct reshdr *)c->buf;
#line 333
  tmp = ntohl(rh->mofs);
#line 333
  mh = (struct resmaphdr *)(c->buf + tmp);
  }
#line 334
  if ((unsigned long )((char *)mh) < (unsigned long )c->buf) {
    {
#line 334
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wild resource map offset!\n");
    }
#line 334
    return (-1);
  } else
#line 334
  if ((unsigned long )((char *)mh + sizeof(*mh)) > (unsigned long )(c->buf + c->len)) {
    {
#line 334
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wild resource map offset!\n");
    }
#line 334
    return (-1);
  }
  {
#line 335
  tmp___4 = ntohl(rh->dofs);
#line 335
  tmp___5 = ntohl(rh->mofs);
  }
#line 335
  if (tmp___4 < tmp___5) {
    {
#line 335
    tmp___2 = ntohl(rh->dofs);
#line 335
    (c->f)->rlen = (int )tmp___2;
    }
  } else {
    {
#line 335
    tmp___3 = ntohl(rh->mofs);
#line 335
    (c->f)->rlen = (int )tmp___3;
    }
  }
  {
#line 338
  tmp___6 = ntohl(rh->dofs);
#line 338
  c->dbase = c->buf + tmp___6;
#line 339
  tmp___7 = ntohs(mh->tlistofs);
#line 339
  c->tbase = (char *)mh + (int )tmp___7;
#line 340
  tmp___8 = ntohs(mh->nlistofs);
#line 340
  c->nbase = (char *)mh + (int )tmp___8;
#line 341
  tmp___9 = res_parse_typelist(c);
  }
#line 341
  return (tmp___9);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
struct res_fork *res_read(char const   *fname ) 
{ 
  FILE *stream ;
  struct res_parsecontext c ;
  int ok ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 350
  stream = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
  }
#line 351
  if (! stream) {
    {
#line 352
    perror(fname);
    }
#line 353
    return ((struct res_fork *)((void *)0));
  }
  {
#line 356
  memset((void *)(& c), 0, sizeof(c));
#line 357
  c.f = res_newfork();
#line 358
  tmp = res_readbuf(& c, stream);
  }
#line 358
  if (tmp >= 0) {
    {
#line 358
    tmp___0 = res_parsebuf(& c);
    }
#line 358
    if (tmp___0 >= 0) {
#line 358
      tmp___1 = 1;
    } else {
#line 358
      tmp___1 = 0;
    }
  } else {
#line 358
    tmp___1 = 0;
  }
  {
#line 358
  ok = tmp___1;
#line 359
  free((void *)c.buf);
#line 360
  fclose(stream);
  }
#line 362
  if (! ok) {
    {
#line 363
    res_delfork(c.f);
    }
#line 364
    return ((struct res_fork *)((void *)0));
  }
#line 367
  return (c.f);
}
}
#line 371 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
static int res_write_data(struct resource *r , FILE *stream ) 
{ 
  uint32_t len ;
  uint32_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 373
  tmp = htonl((uint32_t )r->datalen);
#line 373
  len = tmp;
#line 375
  tmp___0 = fwrite((void const   */* __restrict  */)(& len), sizeof(len), (size_t )1,
                   (FILE */* __restrict  */)stream);
  }
#line 375
  if (tmp___0 != 1UL) {
#line 376
    return (-1);
  }
  {
#line 377
  tmp___1 = fwrite((void const   */* __restrict  */)r->data, (size_t )1, (size_t )r->datalen,
                   (FILE */* __restrict  */)stream);
  }
#line 377
  if (tmp___1 != (size_t )r->datalen) {
#line 378
    return (-1);
  }
#line 380
  return (0);
}
}
#line 385 "/home/june/repo/benchmarks/collector/temp/rsrce-0.2.2/resource.c"
int res_write(struct res_fork *f , char const   *fname ) 
{ 
  int mlen ;
  int dlen ;
  int nlen ;
  int rlen ;
  int rnum ;
  int dofs ;
  int nofs ;
  int rofs ;
  struct reshdr rh ;
  struct resmaphdr mh ;
  struct restype type ;
  struct resref ref ;
  FILE *stream ;
  struct resource *r ;
  int ti ;
  int i ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  uint32_t tmp___5 ;
  size_t tmp___6 ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;

  {
  {
#line 399
  stream = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"w");
  }
#line 400
  if (! stream) {
    {
#line 401
    perror(fname);
    }
#line 402
    return (-1);
  }
#line 406
  dlen = 0;
#line 407
  mlen = (int )sizeof(struct resmaphdr );
#line 408
  rlen = 0;
#line 409
  nlen = 0;
#line 410
  ti = 0;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
#line 410
    if (! (ti < f->tn)) {
#line 410
      goto while_break;
    }
#line 411
    mlen = (int )((unsigned long )mlen + sizeof(struct restype ));
#line 412
    r = (f->tt + ti)->rlist;
    {
#line 412
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 412
      if (! r) {
#line 412
        goto while_break___0;
      }
#line 413
      dlen = (int )((unsigned long )dlen + (sizeof(struct resdata ) + (unsigned long )r->datalen));
#line 414
      rlen = (int )((unsigned long )rlen + sizeof(struct resref ));
#line 415
      if (r->name) {
#line 416
        nlen = (int )((unsigned long )nlen + (sizeof(struct resname ) + (unsigned long )r->namelen));
      }
#line 412
      r = r->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 410
    ti ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 421
  rh.dofs = htonl((uint32_t )f->rlen);
#line 422
  rh.mofs = htonl((uint32_t )(f->rlen + dlen));
#line 423
  rh.dlen = htonl((uint32_t )dlen);
#line 424
  rh.mlen = htonl((uint32_t )((mlen + rlen) + nlen));
#line 425
  tmp = fwrite((void const   */* __restrict  */)(& rh), sizeof(rh), (size_t )1, (FILE */* __restrict  */)stream);
  }
#line 425
  if (tmp != 1UL) {
#line 426
    return (-1);
  }
#line 429
  i = (int )sizeof(rh);
  {
#line 429
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 429
    if (! (i < f->rlen)) {
#line 429
      goto while_break___1;
    }
    {
#line 430
    tmp___0 = fputc(0, stream);
    }
#line 430
    if (tmp___0 == -1) {
#line 431
      return (-1);
    }
#line 429
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 434
  ti = 0;
  {
#line 434
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 434
    if (! (ti < f->tn)) {
#line 434
      goto while_break___2;
    }
#line 435
    r = (f->tt + ti)->rlist;
    {
#line 435
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 435
      if (! r) {
#line 435
        goto while_break___3;
      }
      {
#line 436
      tmp___1 = res_write_data(r, stream);
      }
#line 436
      if (tmp___1) {
#line 437
        return (-1);
      }
#line 435
      r = r->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 434
    ti ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 440
  memset((void *)(& mh.reserved), 0, sizeof(mh.reserved));
#line 441
  mh.attr = htons(f->attr);
#line 442
  mh.tlistofs = htons((uint16_t )((char *)(& mh.tnum) - (char *)(& mh)));
#line 443
  mh.nlistofs = htons((uint16_t )(mlen + rlen));
#line 444
  mh.tnum = htons((uint16_t )(f->tn - 1));
#line 445
  tmp___2 = fwrite((void const   */* __restrict  */)(& mh), sizeof(mh), (size_t )1,
                   (FILE */* __restrict  */)stream);
  }
#line 445
  if (tmp___2 != 1UL) {
#line 446
    return (-1);
  }
#line 449
  rofs = (int )(sizeof(mh.tnum) + (unsigned long )f->tn * sizeof(type));
#line 450
  ti = 0;
  {
#line 450
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 450
    if (! (ti < f->tn)) {
#line 450
      goto while_break___4;
    }
#line 452
    r = (f->tt + ti)->rlist;
#line 452
    rnum = 0;
    {
#line 452
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 452
      if (! r) {
#line 452
        goto while_break___5;
      }
#line 452
      r = r->next;
#line 452
      rnum ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 454
    memcpy((void */* __restrict  */)(type.type), (void const   */* __restrict  */)(& (f->tt + ti)->type),
           sizeof(restype_t ));
#line 455
    type.rnum = htons((uint16_t )(rnum - 1));
#line 456
    type.refofs = htons((uint16_t )rofs);
#line 457
    tmp___3 = fwrite((void const   */* __restrict  */)(& type), sizeof(type), (size_t )1,
                     (FILE */* __restrict  */)stream);
    }
#line 457
    if (tmp___3 != 1UL) {
#line 458
      return (-1);
    }
#line 460
    rofs = (int )((unsigned long )rofs + (unsigned long )rnum * sizeof(ref));
#line 450
    ti ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 464
  dofs = 0;
#line 464
  nofs = dofs;
#line 465
  ti = 0;
  {
#line 465
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 465
    if (! (ti < f->tn)) {
#line 465
      goto while_break___6;
    }
#line 466
    r = (f->tt + ti)->rlist;
    {
#line 466
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 466
      if (! r) {
#line 466
        goto while_break___7;
      }
      {
#line 467
      ref.id = htons((uint16_t )r->id);
      }
#line 468
      if (r->name) {
#line 468
        tmp___4 = nofs;
      } else {
#line 468
        tmp___4 = -1;
      }
      {
#line 468
      ref.nameofs = htons((uint16_t )tmp___4);
#line 469
      tmp___5 = htonl((uint32_t )dofs);
#line 469
      ref.dataofs = tmp___5 >> 8;
#line 470
      ref.attr = (unsigned int )r->attr;
#line 471
      ref.reserved = htonl((uint32_t )0);
#line 472
      tmp___6 = fwrite((void const   */* __restrict  */)(& ref), sizeof(ref), (size_t )1,
                       (FILE */* __restrict  */)stream);
      }
#line 472
      if (tmp___6 != 1UL) {
#line 473
        return (-1);
      }
#line 475
      if (r->name) {
#line 475
        tmp___7 = sizeof(struct resname ) + (unsigned long )r->namelen;
      } else {
#line 475
        tmp___7 = 0UL;
      }
#line 475
      nofs = (int )((unsigned long )nofs + tmp___7);
#line 476
      dofs = (int )((unsigned long )dofs + (sizeof(struct resdata ) + (unsigned long )r->datalen));
#line 466
      r = r->next;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 465
    ti ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 480
  ti = 0;
  {
#line 480
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 480
    if (! (ti < f->tn)) {
#line 480
      goto while_break___8;
    }
#line 481
    r = (f->tt + ti)->rlist;
    {
#line 481
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 481
      if (! r) {
#line 481
        goto while_break___9;
      }
#line 482
      if (! r->name) {
#line 482
        goto __Cont;
      }
      {
#line 484
      tmp___8 = fputc(r->namelen, stream);
      }
#line 484
      if (tmp___8 != r->namelen) {
#line 485
        return (-1);
      }
      {
#line 486
      tmp___9 = fwrite((void const   */* __restrict  */)r->name, (size_t )1, (size_t )r->namelen,
                       (FILE */* __restrict  */)stream);
      }
#line 486
      if (tmp___9 != (size_t )r->namelen) {
#line 487
        return (-1);
      }
      __Cont: /* CIL Label */ 
#line 481
      r = r->next;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 480
    ti ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 490
  fclose(stream);
  }
#line 491
  return (0);
}
}
