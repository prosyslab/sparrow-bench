/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_12 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_12 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 90
struct sockaddr_in6;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_67 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_67 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 36 "/home/june/collector/temp/authbind-2.1.1/libauthbind.c"
typedef void anyfn_type(void);
#line 37 "/home/june/collector/temp/authbind-2.1.1/libauthbind.c"
typedef int bindfn_type(int fd , struct sockaddr  const  *addr , socklen_t addrlen );
#line 216 "/home/june/collector/temp/authbind-2.1.1/libauthbind.c"
union __anonunion_68 {
   int __in ;
   int __i ;
};
#line 215 "/home/june/collector/temp/authbind-2.1.1/libauthbind.c"
union __anonunion_69 {
   int __in ;
   int __i ;
};
#line 214 "/home/june/collector/temp/authbind-2.1.1/libauthbind.c"
union __anonunion_70 {
   int __in ;
   int __i ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 237 "/usr/include/unistd.h"
typedef __uid_t uid_t;
#line 64 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(2), __leaf__)) dlsym)(void * __restrict  __handle ,
                                                                                              char const   * __restrict  __name ) ;
#line 82
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) dlerror)(void) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
#line 588
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unsetenv)(char const   *__name ) ;
#line 218 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigfillset)(sigset_t *__set ) ;
#line 224
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigdelset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 123 "/usr/include/x86_64-linux-gnu/sys/socket.h"
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int fd , struct sockaddr  const  * __restrict  addr ,
                                                                    socklen_t addrlen ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 43 "/home/june/collector/temp/authbind-2.1.1/libauthbind.c"
static char const   *dlerr  ;
#line 42 "/home/june/collector/temp/authbind-2.1.1/libauthbind.c"
static anyfn_type *find_any(char const   *name ) 
{ 
  anyfn_type *kv ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 46
  tmp = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)name);
#line 46
  kv = (anyfn_type *)tmp;
  }
#line 46
  if (kv) {
#line 46
    return (kv);
  }
  {
#line 47
  tmp___0 = dlerror();
#line 47
  dlerr = (char const   *)tmp___0;
  }
#line 47
  if (! dlerr) {
#line 47
    dlerr = "dlsym() failed for no reason";
  }
  {
#line 48
  write(2, (void const   *)"libauthbind: error finding original version of ", sizeof("libauthbind: error finding original version of ") - 1UL);
#line 49
  tmp___1 = strlen(name);
#line 49
  write(2, (void const   *)name, tmp___1);
#line 50
  write(2, (void const   *)": ", sizeof(": ") - 1UL);
#line 51
  tmp___2 = strlen(dlerr);
#line 51
  write(2, (void const   *)dlerr, tmp___2);
#line 52
  tmp___3 = strlen("\n");
#line 52
  write(2, (void const   *)"\n", tmp___3);
#line 53
  tmp___4 = __errno_location();
#line 53
  *tmp___4 = 38;
  }
#line 54
  return ((anyfn_type *)0);
}
}
#line 57
static int find_bind(int fd , struct sockaddr  const  *addr , socklen_t addrlen ) ;
#line 57 "/home/june/collector/temp/authbind-2.1.1/libauthbind.c"
static bindfn_type *old_bind  =    & find_bind;
#line 59 "/home/june/collector/temp/authbind-2.1.1/libauthbind.c"
static int find_bind(int fd , struct sockaddr  const  *addr , socklen_t addrlen ) 
{ 
  anyfn_type *anyfn ;
  int tmp ;

  {
  {
#line 61
  anyfn = find_any("bind");
  }
#line 61
  if (! anyfn) {
#line 61
    return (-1);
  }
  {
#line 62
  old_bind = (bindfn_type *)anyfn;
#line 63
  tmp = (*old_bind)(fd, addr, addrlen);
  }
#line 63
  return (tmp);
}
}
#line 66 "/home/june/collector/temp/authbind-2.1.1/libauthbind.c"
static int exiterrno(int e ) 
{ 
  int tmp ;

  {
#line 67
  if (e > 0) {
#line 67
    if (e < 128) {
#line 67
      tmp = e;
    } else {
#line 67
      tmp = -1;
    }
  } else {
#line 67
    tmp = -1;
  }
  {
#line 67
  _exit(tmp);
  }
}
}
#line 70 "/home/june/collector/temp/authbind-2.1.1/libauthbind.c"
static void removepreload(void) 
{ 
  char const   *myself ;
  char const   *found ;
  char *newval ;
  char *preload ;
  int lpreload ;
  int lmyself ;
  int before ;
  int after ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 75
  preload = getenv("LD_PRELOAD");
#line 76
  tmp = getenv("AUTHBIND_LIB");
#line 76
  myself = (char const   *)tmp;
  }
#line 77
  if (! myself) {
#line 77
    return;
  } else
#line 77
  if (! preload) {
#line 77
    return;
  }
  {
#line 79
  tmp___0 = strlen((char const   *)preload);
#line 79
  lpreload = (int )tmp___0;
#line 80
  tmp___1 = strlen(myself);
#line 80
  lmyself = (int )tmp___1;
  }
#line 82
  if (lmyself < 1) {
#line 82
    return;
  } else
#line 82
  if (lpreload < lmyself) {
#line 82
    return;
  }
#line 83
  if (lpreload == lmyself) {
    {
#line 84
    tmp___2 = strcmp((char const   *)preload, myself);
    }
#line 84
    if (! tmp___2) {
      {
#line 84
      unsetenv("LD_PRELOAD");
      }
    }
#line 85
    return;
  }
  {
#line 87
  tmp___5 = memcmp((void const   *)preload, (void const   *)myself, (size_t )lmyself);
  }
#line 87
  if (tmp___5) {
    _L___0: /* CIL Label */ 
    {
#line 89
    tmp___4 = memcmp((void const   *)((preload + lpreload) - lmyself), (void const   *)myself,
                     (size_t )lmyself);
    }
#line 89
    if (tmp___4) {
      _L: /* CIL Label */ 
#line 93
      if (lpreload < lmyself + 2) {
#line 93
        return;
      }
#line 94
      found = (char const   *)(preload + 1);
      {
#line 95
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 96
        tmp___3 = strstr(found, myself);
#line 96
        found = (char const   *)tmp___3;
        }
#line 96
        if (! found) {
#line 96
          return;
        }
#line 97
        if ((unsigned long )found > (unsigned long )((preload + lpreload) - (lmyself + 1))) {
#line 97
          return;
        }
#line 98
        if ((int const   )*(found + -1) == 58) {
#line 98
          if ((int const   )*(found + lmyself) == 58) {
#line 98
            goto while_break;
          }
        }
#line 99
        found ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 101
      before = (int )(found - (char const   *)preload);
#line 102
      after = lpreload - ((before + lmyself) + 1);
    } else
#line 89
    if ((int )*(preload + (lpreload - (lmyself + 1))) == 58) {
#line 91
      before = lpreload - (lmyself + 1);
#line 91
      after = 0;
    } else {
#line 89
      goto _L;
    }
  } else
#line 87
  if ((int )*(preload + lmyself) == 58) {
#line 88
    before = 0;
#line 88
    after = lpreload - (lmyself + 1);
  } else {
#line 87
    goto _L___0;
  }
  {
#line 104
  tmp___6 = malloc((size_t )((before + after) + 1));
#line 104
  newval = (char *)tmp___6;
  }
#line 105
  if (newval) {
    {
#line 106
    memcpy((void */* __restrict  */)newval, (void const   */* __restrict  */)preload,
           (size_t )before);
#line 107
    strcpy((char */* __restrict  */)(newval + before), (char const   */* __restrict  */)((preload + lpreload) - after));
#line 108
    tmp___7 = setenv("LD_PRELOAD", (char const   *)newval, 1);
    }
#line 108
    if (tmp___7) {
#line 108
      return;
    }
    {
#line 109
    free((void *)newval);
    }
  }
  {
#line 111
  strcpy((char */* __restrict  */)(preload + before), (char const   */* __restrict  */)((preload + lpreload) - after));
  }
#line 112
  return;
}
}
#line 115
int _init(void) ;
#line 116 "/home/june/collector/temp/authbind-2.1.1/libauthbind.c"
int _init(void) 
{ 
  char *levels ;
  int levelno ;

  {
  {
#line 127
  levels = getenv("AUTHBIND_LEVELS");
  }
#line 128
  if (levels) {
#line 129
    if ((int )*(levels + 0) == 121) {
#line 129
      return (0);
    }
    {
#line 130
    levelno = atoi((char const   *)levels);
    }
#line 131
    if (levelno > 0) {
#line 132
      levelno --;
#line 133
      if (levelno > 0) {
        {
#line 133
        sprintf((char */* __restrict  */)levels, (char const   */* __restrict  */)"%d",
                levelno);
        }
      } else {
        {
#line 134
        unsetenv("AUTHBIND_LEVELS");
        }
      }
#line 135
      return (0);
    }
    {
#line 137
    unsetenv("AUTHBIND_LEVELS");
    }
  }
  {
#line 139
  removepreload();
  }
#line 140
  return (0);
}
}
#line 143 "/home/june/collector/temp/authbind-2.1.1/libauthbind.c"
static int const   evilsignals[5]  = {      (int const   )8,      (int const   )4,      (int const   )11,      (int const   )7, 
        (int const   )0};
#line 145
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int fd , struct sockaddr  const  * __restrict  addr ,
                                                                    socklen_t addrlen ) ;
#line 145 "/home/june/collector/temp/authbind-2.1.1/libauthbind.c"
int ( __attribute__((__leaf__)) bind)(int fd , struct sockaddr  const  * __restrict  addr ,
                                      socklen_t addrlen ) 
{ 
  pid_t child ;
  pid_t rchild ;
  char portarg[5] ;
  char addrarg[33] ;
  char const   *afarg ;
  int i ;
  int r ;
  int status ;
  int const   *evilsignal ;
  sigset_t block ;
  sigset_t saved ;
  unsigned int portval ;
  int tmp ;
  __uid_t tmp___0 ;
  uint16_t tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  union __anonunion_68 __constr_expr_0 ;
  int *tmp___12 ;
  int *tmp___13 ;
  union __anonunion_69 __constr_expr_1 ;
  int *tmp___14 ;
  union __anonunion_70 __constr_expr_2 ;
  int tmp___15 ;

  {
  {
#line 155
  if ((int const   )addr->sa_family == 2) {
#line 155
    goto case_2;
  }
#line 159
  if ((int const   )addr->sa_family == 10) {
#line 159
    goto case_10;
  }
#line 163
  goto switch_default;
  case_2: /* CIL Label */ 
#line 156
  portval = (unsigned int )((struct sockaddr_in *)addr)->sin_port;
#line 157
  if ((unsigned long )addrlen != sizeof(struct sockaddr_in )) {
#line 157
    goto bail;
  }
#line 158
  goto switch_break;
  case_10: /* CIL Label */ 
#line 160
  portval = (unsigned int )((struct sockaddr_in6 *)addr)->sin6_port;
#line 161
  if ((unsigned long )addrlen != sizeof(struct sockaddr_in6 )) {
#line 161
    goto bail;
  }
#line 162
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 164
  goto bail;
  switch_break: /* CIL Label */ ;
  }
  {
#line 167
  tmp___0 = geteuid();
  }
#line 167
  if (tmp___0) {
#line 167
    if (portval == 0U) {
#line 167
      goto bail;
    } else {
      {
#line 167
      tmp___1 = ntohs((uint16_t )portval);
      }
#line 167
      if ((int )tmp___1 >= 1024) {
        bail: 
        {
#line 169
        tmp = (*old_bind)(fd, (struct sockaddr  const  *)addr, addrlen);
        }
#line 169
        return (tmp);
      }
    }
  } else {
#line 167
    goto bail;
  }
  {
#line 172
  sigfillset(& block);
#line 173
  evilsignal = evilsignals;
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! *evilsignal) {
#line 173
      goto while_break;
    }
    {
#line 176
    sigdelset(& block, (int )*evilsignal);
#line 173
    evilsignal ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  tmp___2 = sigprocmask(0, (sigset_t const   */* __restrict  */)(& block), (sigset_t */* __restrict  */)(& saved));
  }
#line 177
  if (tmp___2) {
#line 177
    return (-1);
  }
  {
#line 180
  if ((int const   )addr->sa_family == 2) {
#line 180
    goto case_2___0;
  }
#line 186
  if ((int const   )addr->sa_family == 10) {
#line 186
    goto case_10___0;
  }
#line 192
  goto switch_default___0;
  case_2___0: /* CIL Label */ 
  {
#line 181
  afarg = (char const   *)0;
#line 182
  sprintf((char */* __restrict  */)(addrarg), (char const   */* __restrict  */)"%08lx",
          (unsigned long )((struct sockaddr_in *)addr)->sin_addr.s_addr & 4294967295UL);
  }
#line 185
  goto switch_break___0;
  case_10___0: /* CIL Label */ 
#line 187
  afarg = "6";
#line 188
  i = 0;
  {
#line 188
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 188
    if (! (i < 16)) {
#line 188
      goto while_break___0;
    }
    {
#line 189
    sprintf((char */* __restrict  */)(addrarg + i * 2), (char const   */* __restrict  */)"%02x",
            (int )((struct sockaddr_in6 *)addr)->sin6_addr.__in6_u.__u6_addr8[i]);
#line 188
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 191
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 193
  abort();
  }
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 195
  sprintf((char */* __restrict  */)(portarg), (char const   */* __restrict  */)"%04x",
          portval & 65535U);
#line 198
  child = fork();
  }
#line 198
  if (child == -1) {
#line 198
    goto x_err;
  }
#line 200
  if (! child) {
    {
#line 201
    tmp___4 = dup2(fd, 0);
    }
#line 201
    if (tmp___4) {
      {
#line 201
      tmp___3 = __errno_location();
#line 201
      exiterrno(*tmp___3);
      }
    }
    {
#line 202
    removepreload();
#line 203
    execl("/usr/local/lib/authbind/helper", "/usr/local/lib/authbind/helper", addrarg,
          portarg, afarg, (char *)0);
#line 204
    tmp___8 = __errno_location();
    }
#line 204
    if (*tmp___8 > 0) {
      {
#line 204
      tmp___9 = __errno_location();
      }
#line 204
      if (*tmp___9 < 127) {
        {
#line 204
        tmp___7 = __errno_location();
#line 204
        status = *tmp___7;
        }
      } else {
#line 204
        status = 127;
      }
    } else {
#line 204
      status = 127;
    }
    {
#line 205
    write(2, (void const   *)"libauthbind: possible installation problem - could not invoke /usr/local/lib/authbind/helper\n",
          sizeof("libauthbind: possible installation problem - could not invoke /usr/local/lib/authbind/helper\n") - 1UL);
#line 207
    exiterrno(status);
    }
  }
  {
#line 210
  rchild = waitpid(child, & status, 0);
  }
#line 211
  if (rchild == -1) {
#line 211
    goto x_err;
  }
#line 212
  if (rchild != child) {
    {
#line 212
    tmp___10 = __errno_location();
#line 212
    *tmp___10 = 10;
    }
#line 212
    goto x_err;
  }
#line 214
  __constr_expr_2.__in = status;
#line 214
  if ((__constr_expr_2.__i & 127) == 0) {
#line 215
    __constr_expr_1.__in = status;
#line 215
    if ((__constr_expr_1.__i & 65280) >> 8) {
      {
#line 216
      tmp___11 = __errno_location();
#line 216
      __constr_expr_0.__in = status;
#line 216
      *tmp___11 = (__constr_expr_0.__i & 65280) >> 8;
#line 217
      tmp___13 = __errno_location();
      }
#line 217
      if (*tmp___13 >= 127) {
        {
#line 217
        tmp___12 = __errno_location();
#line 217
        *tmp___12 = 6;
        }
      }
#line 218
      goto x_err;
    }
#line 220
    r = 0;
#line 221
    goto x;
  } else {
    {
#line 223
    tmp___14 = __errno_location();
#line 223
    *tmp___14 = 38;
    }
#line 224
    goto x_err;
  }
  x_err: 
#line 228
  r = -1;
  x: 
  {
#line 230
  tmp___15 = sigprocmask(2, (sigset_t const   */* __restrict  */)(& saved), (sigset_t */* __restrict  */)0);
  }
#line 230
  if (tmp___15) {
    {
#line 230
    abort();
    }
  }
#line 231
  return (r);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 58 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_pton)(int __af ,
                                                                                char const   * __restrict  __cp ,
                                                                                void * __restrict  __buf ) ;
#line 64
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 37 "/home/june/collector/temp/authbind-2.1.1/helper.c"
static void exiterrno___0(int e ) 
{ 
  int tmp ;

  {
#line 38
  if (e > 0) {
#line 38
    if (e < 128) {
#line 38
      tmp = e;
    } else {
#line 38
      tmp = 38;
    }
  } else {
#line 38
    tmp = 38;
  }
  {
#line 38
  exit(tmp);
  }
}
}
#line 41 "/home/june/collector/temp/authbind-2.1.1/helper.c"
static void perrorfail(char const   *m ) 
{ 
  int e ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 43
  tmp = __errno_location();
#line 43
  e = *tmp;
#line 44
  tmp___0 = strerror(e);
#line 44
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libauthbind\'s helper: %s: %s\n",
          m, tmp___0);
#line 45
  exiterrno___0(e);
  }
#line 46
  return;
}
}
#line 48 "/home/june/collector/temp/authbind-2.1.1/helper.c"
static void badusage(void) 
{ 


  {
  {
#line 49
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libauthbind\'s helper: bad usage\n");
#line 50
  exit(38);
  }
}
}
#line 53 "/home/june/collector/temp/authbind-2.1.1/helper.c"
static struct sockaddr_in saddr4  ;
#line 54 "/home/june/collector/temp/authbind-2.1.1/helper.c"
static struct sockaddr_in6 saddr6  ;
#line 56 "/home/june/collector/temp/authbind-2.1.1/helper.c"
static struct sockaddr *saddr_any  ;
#line 57 "/home/june/collector/temp/authbind-2.1.1/helper.c"
static void const   *addr_any  ;
#line 58 "/home/june/collector/temp/authbind-2.1.1/helper.c"
static size_t saddrlen_any  ;
#line 58 "/home/june/collector/temp/authbind-2.1.1/helper.c"
static size_t addrlen_any  ;
#line 60 "/home/june/collector/temp/authbind-2.1.1/helper.c"
static void authorised(void) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 61
  tmp___0 = bind(0, (struct sockaddr  const  */* __restrict  */)saddr_any, (socklen_t )saddrlen_any);
  }
#line 61
  if (tmp___0) {
    {
#line 61
    tmp = __errno_location();
#line 61
    exiterrno___0(*tmp);
    }
  } else {
    {
#line 62
    _exit(0);
    }
  }
#line 63
  return;
}
}
#line 65 "/home/june/collector/temp/authbind-2.1.1/helper.c"
static void checkexecflagfile(char const   *file ) 
{ 
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 66
  tmp = access(file, 1);
  }
#line 66
  if (! tmp) {
    {
#line 66
    authorised();
    }
  }
  {
#line 67
  tmp___1 = __errno_location();
  }
#line 67
  if (*tmp___1 != 2) {
    {
#line 67
    tmp___0 = __errno_location();
#line 67
    exiterrno___0(*tmp___0);
    }
  }
#line 68
  return;
}
}
#line 70 "/home/june/collector/temp/authbind-2.1.1/helper.c"
static void hex2bytes(char const   *string , unsigned char *out , int len ) 
{ 
  int i ;
  char hex[3] ;
  char *ep ;
  char const   *tmp ;
  char const   *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 72
  i = 0;
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (! (i < len)) {
#line 72
      goto while_break;
    }
#line 74
    tmp = string;
#line 74
    string ++;
#line 74
    hex[0] = (char )*tmp;
#line 74
    if (! hex[0]) {
      {
#line 74
      badusage();
      }
    }
#line 75
    tmp___0 = string;
#line 75
    string ++;
#line 75
    hex[1] = (char )*tmp___0;
#line 75
    if (! hex[1]) {
      {
#line 75
      badusage();
      }
    }
    {
#line 76
    hex[2] = (char)0;
#line 77
    tmp___1 = out;
#line 77
    out ++;
#line 77
    tmp___2 = strtoul((char const   */* __restrict  */)(hex), (char **/* __restrict  */)(& ep),
                      16);
#line 77
    *tmp___1 = (unsigned char )tmp___2;
    }
#line 78
    if ((unsigned long )ep != (unsigned long )(& hex[2])) {
      {
#line 78
      badusage();
      }
    }
#line 72
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return;
}
}
#line 82 "/home/june/collector/temp/authbind-2.1.1/helper.c"
int main(int argc , char const   * const  *argv ) 
{ 
  uid_t uid ;
  char fnbuf[300] ;
  char *ep ;
  char const   *np ;
  char const   *tophalfchar ;
  unsigned long port ;
  unsigned long addr4 ;
  unsigned long haddr4 ;
  unsigned int hport ;
  int af ;
  FILE *file ;
  uint32_t tmp ;
  int tmp___0 ;
  uint16_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char npbuf[62] ;
  char *sbuf ;
  unsigned long __lengthofsbuf ;
  void *tmp___6 ;
  char *sp ;
  unsigned char const   *ip ;
  int i ;
  unsigned int val ;
  unsigned char const   *tmp___7 ;
  unsigned char const   *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  unsigned int a1 ;
  unsigned int a2 ;
  unsigned int a3 ;
  unsigned int a4 ;
  unsigned int alen ;
  unsigned int pmin ;
  unsigned int pmax ;
  int nchar ;
  unsigned long thaddr ;
  unsigned long thmask ;
  char *comma ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *slash ;
  char *tmp___17 ;
  char *hyphen ;
  char *tmp___18 ;
  int alen___0 ;
  char *tmp___19 ;
  size_t tmp___20 ;
  unsigned char *thaddr___0 ;
  unsigned long __lengthofthaddr___0 ;
  void *tmp___21 ;
  int tmp___22 ;
  int pfxlen_remain ;
  int i___0 ;
  int pfxlen_thisbyte ;
  int tmp___23 ;
  unsigned int mask_thisbyte ;
  unsigned int thaddr_thisbyte ;
  unsigned int addr_thisbyte ;
  char const   *min ;
  char const   *max ;
  char *tmp___24 ;
  unsigned char *minaddr ;
  unsigned long __lengthofminaddr ;
  void *tmp___25 ;
  unsigned char *maxaddr ;
  unsigned long __lengthofmaxaddr ;
  void *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  size_t tmp___31 ;
  size_t tmp___32 ;
  size_t tmp___33 ;
  char *tmp___34 ;
  int tmp___35 ;

  {
#line 87
  tophalfchar = "";
#line 88
  addr4 = 0UL;
#line 88
  haddr4 = 0UL;
#line 93
  if (argc == 3) {
    {
#line 94
    af = 2;
#line 95
    saddr_any = (struct sockaddr *)((void *)(& saddr4));
#line 96
    saddrlen_any = sizeof(saddr4);
#line 97
    addr_any = (void const   *)(& saddr4.sin_addr.s_addr);
#line 98
    addrlen_any = sizeof(saddr4.sin_addr.s_addr);
#line 99
    addr4 = strtoul((char const   */* __restrict  */)*(argv + 1), (char **/* __restrict  */)(& ep),
                    16);
    }
#line 100
    if (*ep) {
      {
#line 100
      badusage();
      }
    } else
#line 100
    if (addr4 & 0xffffffff00000000UL) {
      {
#line 100
      badusage();
      }
    }
    {
#line 101
    tmp = ntohl((uint32_t )addr4);
#line 101
    haddr4 = (unsigned long )tmp;
    }
  } else
#line 102
  if (argc == 4) {
    {
#line 102
    tmp___0 = strcmp((char const   *)*(argv + 3), "6");
    }
#line 102
    if (tmp___0) {
      {
#line 111
      badusage();
#line 112
      abort();
      }
    } else {
      {
#line 103
      af = 10;
#line 104
      saddr_any = (struct sockaddr *)((void *)(& saddr6));
#line 105
      saddrlen_any = sizeof(saddr6);
#line 106
      addr_any = (void const   *)(& saddr6.sin6_addr.__in6_u.__u6_addr8);
#line 107
      addrlen_any = sizeof(saddr6.sin6_addr.__in6_u.__u6_addr8);
#line 108
      hex2bytes((char const   *)*(argv + 1), saddr6.sin6_addr.__in6_u.__u6_addr8,
                (int )sizeof(saddr6.sin6_addr.__in6_u.__u6_addr8));
      }
    }
  } else {
    {
#line 111
    badusage();
#line 112
    abort();
    }
  }
  {
#line 115
  port = strtoul((char const   */* __restrict  */)*(argv + 2), (char **/* __restrict  */)(& ep),
                 16);
  }
#line 115
  if (*ep) {
    {
#line 115
    badusage();
    }
  } else
#line 115
  if (port & 0xffffffffffff0000UL) {
    {
#line 115
    badusage();
    }
  }
  {
#line 116
  tmp___1 = htons((uint16_t )port);
#line 116
  hport = (unsigned int )tmp___1;
  }
#line 117
  if (hport >= 512U) {
#line 117
    tophalfchar = "!";
  }
  {
#line 119
  tmp___2 = chdir("/etc/authbind");
  }
#line 119
  if (tmp___2) {
    {
#line 119
    perrorfail("chdir /etc/authbind");
    }
  }
#line 121
  fnbuf[sizeof(fnbuf) - 1UL] = (char)0;
  {
#line 124
  if (af == 2) {
#line 124
    goto case_2;
  }
#line 129
  if (af == 10) {
#line 129
    goto case_10;
  }
#line 133
  goto switch_default;
  case_2: /* CIL Label */ 
#line 125
  saddr4.sin_family = (sa_family_t )af;
#line 126
  saddr4.sin_port = (in_port_t )port;
#line 127
  saddr4.sin_addr.s_addr = (in_addr_t )addr4;
#line 128
  goto switch_break;
  case_10: /* CIL Label */ 
#line 130
  saddr6.sin6_family = (sa_family_t )af;
#line 131
  saddr6.sin6_port = (in_port_t )port;
#line 132
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 134
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 137
  snprintf((char */* __restrict  */)(fnbuf), sizeof(fnbuf) - 1UL, (char const   */* __restrict  */)"byport/%s%u",
           tophalfchar, hport);
#line 138
  tmp___3 = access((char const   *)(fnbuf), 1);
  }
#line 138
  if (! tmp___3) {
    {
#line 138
    authorised();
    }
  }
  {
#line 139
  tmp___5 = __errno_location();
  }
#line 139
  if (*tmp___5 != 2) {
    {
#line 139
    tmp___4 = __errno_location();
#line 139
    exiterrno___0(*tmp___4);
    }
  }
  {
#line 142
  np = inet_ntop(af, (void const   */* __restrict  */)addr_any, (char */* __restrict  */)(npbuf),
                 (socklen_t )sizeof(npbuf));
  }
#line 143
  if (! np) {
    {
#line 143
    __assert_fail("np", "/home/june/collector/temp/authbind-2.1.1/helper.c", 143U,
                  "main");
    }
  }
#line 145
  if (af == 2) {
    {
#line 146
    snprintf((char */* __restrict  */)(fnbuf), sizeof(fnbuf) - 1UL, (char const   */* __restrict  */)"byaddr/%s%s:%u",
             tophalfchar, np, hport);
#line 147
    checkexecflagfile((char const   *)(fnbuf));
    }
  }
  {
#line 150
  snprintf((char */* __restrict  */)(fnbuf), sizeof(fnbuf) - 1UL, (char const   */* __restrict  */)"byaddr/%s%s,%u",
           tophalfchar, np, hport);
#line 151
  checkexecflagfile((char const   *)(fnbuf));
  }
#line 153
  if (af == 10) {
    {
#line 154
    __lengthofsbuf = addrlen_any * 3UL + 1UL;
#line 154
    tmp___6 = __builtin_alloca(sizeof(*sbuf) * __lengthofsbuf);
#line 154
    sbuf = (char *)tmp___6;
#line 154
    sp = sbuf;
#line 155
    ip = (unsigned char const   *)addr_any;
#line 157
    i = 0;
    }
    {
#line 157
    while (1) {
      while_continue: /* CIL Label */ ;
#line 157
      if (! (i < 8)) {
#line 157
        goto while_break;
      }
#line 158
      val = 0U;
#line 159
      tmp___7 = ip;
#line 159
      ip ++;
#line 159
      val |= (unsigned int )*tmp___7;
#line 159
      val <<= 8;
#line 160
      tmp___8 = ip;
#line 160
      ip ++;
#line 160
      val |= (unsigned int )*tmp___8;
#line 161
      if (i) {
#line 161
        tmp___9 = sp;
#line 161
        sp ++;
#line 161
        *tmp___9 = (char )':';
      }
      {
#line 162
      tmp___10 = sprintf((char */* __restrict  */)sp, (char const   */* __restrict  */)"%x",
                         val);
#line 162
      sp += tmp___10;
#line 157
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 164
    snprintf((char */* __restrict  */)(fnbuf), sizeof(fnbuf) - 1UL, (char const   */* __restrict  */)"byaddr/%s%s,%u",
             tophalfchar, sbuf, hport);
#line 165
    checkexecflagfile((char const   *)(fnbuf));
    }
  }
  {
#line 168
  uid = getuid();
  }
#line 168
  if (uid == 4294967295U) {
    {
#line 168
    perrorfail("getuid");
    }
  }
  {
#line 169
  snprintf((char */* __restrict  */)(fnbuf), sizeof(fnbuf) - 1UL, (char const   */* __restrict  */)"byuid/%s%lu",
           tophalfchar, (unsigned long )uid);
#line 171
  file = fopen((char const   */* __restrict  */)(fnbuf), (char const   */* __restrict  */)"r");
  }
#line 172
  if (! file) {
    {
#line 172
    tmp___14 = __errno_location();
    }
#line 172
    if (*tmp___14 == 2) {
#line 172
      tmp___13 = 1;
    } else {
      {
#line 172
      tmp___12 = __errno_location();
#line 172
      tmp___13 = *tmp___12;
      }
    }
    {
#line 172
    exiterrno___0(tmp___13);
    }
  }
  {
#line 174
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 174
    tmp___34 = fgets((char */* __restrict  */)(fnbuf), (int )(sizeof(fnbuf) - 1UL),
                     (FILE */* __restrict  */)file);
    }
#line 174
    if (! tmp___34) {
#line 174
      goto while_break___0;
    }
#line 178
    if (af == 2) {
      {
#line 178
      nchar = -1;
#line 178
      sscanf((char const   */* __restrict  */)(fnbuf), (char const   */* __restrict  */)" %u.%u.%u.%u/%u: %u,%u %n",
             & a1, & a2, & a3, & a4, & alen, & pmin, & pmax, & nchar);
#line 178
      tmp___33 = strlen((char const   *)(fnbuf));
      }
#line 178
      if ((size_t )nchar == tmp___33) {
#line 184
        if (alen > 32U) {
#line 186
          goto while_continue___0;
        } else
#line 184
        if (pmin & 4294901760U) {
#line 186
          goto while_continue___0;
        } else
#line 184
        if (pmax & 4294901760U) {
#line 186
          goto while_continue___0;
        } else
#line 184
        if (a1 & 4294967040U) {
#line 186
          goto while_continue___0;
        } else
#line 184
        if (a2 & 4294967040U) {
#line 186
          goto while_continue___0;
        } else
#line 184
        if (a3 & 4294967040U) {
#line 186
          goto while_continue___0;
        } else
#line 184
        if (a4 & 4294967040U) {
#line 186
          goto while_continue___0;
        }
#line 189
        thaddr = (unsigned long )((((a1 << 24) | (a2 << 16)) | (a3 << 8)) | a4);
#line 190
        if (alen) {
#line 190
          thmask = 4294967295UL << (32U - alen);
        } else {
#line 190
          thmask = 0UL;
        }
#line 191
        if ((haddr4 & thmask) != thaddr) {
#line 191
          goto while_continue___0;
        }
      } else {
#line 178
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 195
      tmp___15 = strchr((char const   *)(fnbuf), ',');
#line 195
      comma = tmp___15;
      }
#line 196
      if (! comma) {
#line 196
        goto while_continue___0;
      }
      {
#line 197
      tmp___16 = comma;
#line 197
      comma ++;
#line 197
      *tmp___16 = (char )'\000';
#line 199
      tmp___17 = strchr((char const   *)(fnbuf), '/');
#line 199
      slash = tmp___17;
#line 200
      tmp___18 = strchr((char const   *)(fnbuf), '-');
#line 200
      hyphen = tmp___18;
      }
#line 202
      if (slash) {
#line 202
        if (hyphen) {
#line 203
          goto while_continue___0;
        }
      }
#line 205
      if (slash) {
        {
#line 207
        tmp___19 = slash;
#line 207
        slash ++;
#line 207
        *tmp___19 = (char )'\000';
#line 208
        nchar = -1;
#line 209
        sscanf((char const   */* __restrict  */)slash, (char const   */* __restrict  */)" %u %n",
               & alen___0, & nchar);
#line 210
        tmp___20 = strlen((char const   *)slash);
        }
#line 210
        if ((size_t )nchar != tmp___20) {
#line 211
          goto while_continue___0;
        }
        {
#line 212
        __lengthofthaddr___0 = addrlen_any;
#line 212
        tmp___21 = __builtin_alloca(sizeof(*thaddr___0) * __lengthofthaddr___0);
#line 212
        thaddr___0 = (unsigned char *)tmp___21;
#line 213
        tmp___22 = inet_pton(af, (char const   */* __restrict  */)(fnbuf), (void */* __restrict  */)thaddr___0);
        }
#line 213
        if (tmp___22 != 1) {
#line 214
          goto while_continue___0;
        }
#line 215
        pfxlen_remain = alen___0;
#line 217
        i___0 = 0;
        {
#line 217
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 217
          if (! ((size_t )i___0 < addrlen_any)) {
#line 217
            goto while_break___1;
          }
#line 218
          if (pfxlen_remain < 8) {
#line 218
            tmp___23 = pfxlen_remain;
          } else {
#line 218
            tmp___23 = 8;
          }
#line 218
          pfxlen_thisbyte = tmp___23;
#line 219
          pfxlen_remain -= pfxlen_thisbyte;
#line 220
          mask_thisbyte = (unsigned int )(255 ^ (255 >> pfxlen_thisbyte));
#line 221
          thaddr_thisbyte = (unsigned int )*(thaddr___0 + i___0);
#line 222
          addr_thisbyte = (unsigned int )*((unsigned char *)addr_any + i___0);
#line 223
          if ((addr_thisbyte & mask_thisbyte) != thaddr_thisbyte) {
#line 224
            goto badline;
          }
#line 217
          i___0 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 226
        if (pfxlen_remain) {
          badline: 
#line 226
          goto while_continue___0;
        }
      } else {
#line 230
        if (hyphen) {
#line 231
          tmp___24 = hyphen;
#line 231
          hyphen ++;
#line 231
          *tmp___24 = (char )'\000';
#line 232
          min = (char const   *)(fnbuf);
#line 233
          max = (char const   *)hyphen;
        } else {
#line 235
          min = (char const   *)(fnbuf);
#line 236
          max = (char const   *)(fnbuf);
        }
        {
#line 238
        __lengthofminaddr = addrlen_any;
#line 238
        tmp___25 = __builtin_alloca(sizeof(*minaddr) * __lengthofminaddr);
#line 238
        minaddr = (unsigned char *)tmp___25;
#line 239
        __lengthofmaxaddr = addrlen_any;
#line 239
        tmp___26 = __builtin_alloca(sizeof(*maxaddr) * __lengthofmaxaddr);
#line 239
        maxaddr = (unsigned char *)tmp___26;
#line 240
        tmp___27 = inet_pton(af, (char const   */* __restrict  */)min, (void */* __restrict  */)minaddr);
        }
#line 240
        if (tmp___27 != 1) {
#line 242
          goto while_continue___0;
        } else {
          {
#line 240
          tmp___28 = inet_pton(af, (char const   */* __restrict  */)max, (void */* __restrict  */)maxaddr);
          }
#line 240
          if (tmp___28 != 1) {
#line 242
            goto while_continue___0;
          }
        }
        {
#line 243
        tmp___29 = memcmp(addr_any, (void const   *)minaddr, addrlen_any);
        }
#line 243
        if (tmp___29 < 0) {
#line 245
          goto while_continue___0;
        } else {
          {
#line 243
          tmp___30 = memcmp(addr_any, (void const   *)maxaddr, addrlen_any);
          }
#line 243
          if (tmp___30 > 0) {
#line 245
            goto while_continue___0;
          }
        }
      }
      {
#line 248
      nchar = -1;
#line 248
      sscanf((char const   */* __restrict  */)comma, (char const   */* __restrict  */)" %u-%u %n",
             & pmin, & pmax, & nchar);
#line 248
      tmp___32 = strlen((char const   *)comma);
      }
#line 248
      if (! ((size_t )nchar == tmp___32)) {
        {
#line 253
        nchar = -1;
#line 253
        sscanf((char const   */* __restrict  */)comma, (char const   */* __restrict  */)" %u %n",
               & pmin, & nchar);
#line 253
        tmp___31 = strlen((char const   *)comma);
        }
#line 253
        if ((size_t )nchar == tmp___31) {
#line 257
          pmax = pmin;
        } else {
#line 259
          goto while_continue___0;
        }
      }
    }
#line 263
    if (hport < pmin) {
#line 263
      goto while_continue___0;
    } else
#line 263
    if (hport > pmax) {
#line 263
      goto while_continue___0;
    }
    {
#line 265
    authorised();
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 267
  tmp___35 = ferror(file);
  }
#line 267
  if (tmp___35) {
    {
#line 267
    perrorfail("read per-uid file");
    }
  }
  {
#line 268
  _exit(2);
  }
}
}
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 846
extern void perror(char const   *__s ) ;
#line 578 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 30 "/home/june/collector/temp/authbind-2.1.1/authbind.c"
static void printusage(FILE *f ) 
{ 
  int tmp ;

  {
  {
#line 31
  tmp = fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"usage:       authbind [<options>] <program> <arg> <arg> ...\noptions:     --deep    --depth <levels>\n");
  }
#line 31
  if (tmp == -1) {
    {
#line 34
    perror("printf usage");
#line 34
    exit(-1);
    }
  }
#line 35
  return;
}
}
#line 37 "/home/june/collector/temp/authbind-2.1.1/authbind.c"
static void usageerror(char const   *msg ) 
{ 


  {
  {
#line 38
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage error: %s\n",
          msg);
#line 39
  printusage(stderr);
#line 40
  exit(-1);
  }
}
}
#line 43 "/home/june/collector/temp/authbind-2.1.1/authbind.c"
static void mustsetenv(char const   *var , char const   *val ) 
{ 
  int tmp ;

  {
  {
#line 44
  tmp = setenv(var, val, 1);
  }
#line 44
  if (tmp) {
    {
#line 44
    perror("authbind: setenv");
#line 44
    exit(-1);
    }
  }
#line 45
  return;
}
}
