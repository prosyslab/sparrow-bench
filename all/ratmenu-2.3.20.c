/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_42 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_43 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_42 __wait_terminated ;
   struct __anonstruct___wait_stopped_43 __wait_stopped ;
};
#line 66 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 74 "/usr/include/X11/X.h"
typedef unsigned long Atom;
#line 76 "/usr/include/X11/X.h"
typedef unsigned long VisualID;
#line 77 "/usr/include/X11/X.h"
typedef unsigned long Time;
#line 96 "/usr/include/X11/X.h"
typedef XID Window;
#line 97 "/usr/include/X11/X.h"
typedef XID Drawable;
#line 100 "/usr/include/X11/X.h"
typedef XID Font;
#line 102 "/usr/include/X11/X.h"
typedef XID Pixmap;
#line 104 "/usr/include/X11/X.h"
typedef XID Colormap;
#line 106 "/usr/include/X11/X.h"
typedef XID KeySym;
#line 92 "/usr/include/X11/Xlib.h"
typedef char *XPointer;
#line 160 "/usr/include/X11/Xlib.h"
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
#line 160 "/usr/include/X11/Xlib.h"
typedef struct _XExtData XExtData;
#line 193 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGCValues_54 {
   int function ;
   unsigned long plane_mask ;
   unsigned long foreground ;
   unsigned long background ;
   int line_width ;
   int line_style ;
   int cap_style ;
   int join_style ;
   int fill_style ;
   int fill_rule ;
   int arc_mode ;
   Pixmap tile ;
   Pixmap stipple ;
   int ts_x_origin ;
   int ts_y_origin ;
   Font font ;
   int subwindow_mode ;
   int graphics_exposures ;
   int clip_x_origin ;
   int clip_y_origin ;
   Pixmap clip_mask ;
   int dash_offset ;
   char dashes ;
};
#line 193 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGCValues_54 XGCValues;
#line 226
struct _XGC;
#line 226 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 239 "/usr/include/X11/Xlib.h"
struct __anonstruct_Visual_55 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
#line 239 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Visual_55 Visual;
#line 255 "/usr/include/X11/Xlib.h"
struct __anonstruct_Depth_56 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
#line 255 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Depth_56 Depth;
#line 267
struct _XDisplay;
#line 267
struct _XDisplay;
#line 269 "/usr/include/X11/Xlib.h"
struct __anonstruct_Screen_57 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
#line 269 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Screen_57 Screen;
#line 292 "/usr/include/X11/Xlib.h"
struct __anonstruct_ScreenFormat_58 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
#line 292 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_ScreenFormat_58 ScreenFormat;
#line 422 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColor_64 {
   unsigned long pixel ;
   unsigned short red ;
   unsigned short green ;
   unsigned short blue ;
   char flags ;
   char pad ;
};
#line 422 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColor_64 XColor;
#line 442 "/usr/include/X11/Xlib.h"
struct __anonstruct_XRectangle_67 {
   short x ;
   short y ;
   unsigned short width ;
   unsigned short height ;
};
#line 442 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XRectangle_67 XRectangle;
#line 499 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 502
struct _XPrivate;
#line 502
struct _XPrivate;
#line 503
struct _XrmHashBucketRec;
#line 503
struct _XrmHashBucketRec;
#line 505 "/usr/include/X11/Xlib.h"
struct __anonstruct__XPrivDisplay_73 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
#line 505 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct__XPrivDisplay_73 *_XPrivDisplay;
#line 569 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyEvent_74 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
#line 569 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyEvent_74 XKeyEvent;
#line 587 "/usr/include/X11/Xlib.h"
struct __anonstruct_XButtonEvent_75 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
#line 587 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XButtonEvent_75 XButtonEvent;
#line 605 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMotionEvent_76 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
#line 605 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMotionEvent_76 XMotionEvent;
#line 622 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCrossingEvent_77 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
#line 622 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCrossingEvent_77 XCrossingEvent;
#line 646 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFocusChangeEvent_78 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
#line 646 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFocusChangeEvent_78 XFocusChangeEvent;
#line 665 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeymapEvent_79 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
#line 665 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeymapEvent_79 XKeymapEvent;
#line 674 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExposeEvent_80 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
#line 674 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExposeEvent_80 XExposeEvent;
#line 685 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGraphicsExposeEvent_81 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
#line 685 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGraphicsExposeEvent_81 XGraphicsExposeEvent;
#line 698 "/usr/include/X11/Xlib.h"
struct __anonstruct_XNoExposeEvent_82 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
#line 698 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XNoExposeEvent_82 XNoExposeEvent;
#line 708 "/usr/include/X11/Xlib.h"
struct __anonstruct_XVisibilityEvent_83 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
#line 708 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XVisibilityEvent_83 XVisibilityEvent;
#line 717 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCreateWindowEvent_84 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
#line 717 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCreateWindowEvent_84 XCreateWindowEvent;
#line 730 "/usr/include/X11/Xlib.h"
struct __anonstruct_XDestroyWindowEvent_85 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
#line 730 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XDestroyWindowEvent_85 XDestroyWindowEvent;
#line 739 "/usr/include/X11/Xlib.h"
struct __anonstruct_XUnmapEvent_86 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
#line 739 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XUnmapEvent_86 XUnmapEvent;
#line 749 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapEvent_87 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
#line 749 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapEvent_87 XMapEvent;
#line 759 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapRequestEvent_88 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
#line 759 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapRequestEvent_88 XMapRequestEvent;
#line 768 "/usr/include/X11/Xlib.h"
struct __anonstruct_XReparentEvent_89 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
#line 768 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XReparentEvent_89 XReparentEvent;
#line 780 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureEvent_90 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
#line 780 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureEvent_90 XConfigureEvent;
#line 794 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGravityEvent_91 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
#line 794 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGravityEvent_91 XGravityEvent;
#line 804 "/usr/include/X11/Xlib.h"
struct __anonstruct_XResizeRequestEvent_92 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
#line 804 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XResizeRequestEvent_92 XResizeRequestEvent;
#line 813 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureRequestEvent_93 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
#line 813 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureRequestEvent_93 XConfigureRequestEvent;
#line 828 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateEvent_94 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
#line 828 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateEvent_94 XCirculateEvent;
#line 838 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateRequestEvent_95 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
#line 838 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateRequestEvent_95 XCirculateRequestEvent;
#line 848 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPropertyEvent_96 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
#line 848 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPropertyEvent_96 XPropertyEvent;
#line 859 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionClearEvent_97 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
#line 859 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionClearEvent_97 XSelectionClearEvent;
#line 869 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionRequestEvent_98 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 869 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionRequestEvent_98 XSelectionRequestEvent;
#line 882 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionEvent_99 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 882 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionEvent_99 XSelectionEvent;
#line 894 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColormapEvent_100 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
#line 894 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColormapEvent_100 XColormapEvent;
#line 909 "/usr/include/X11/Xlib.h"
union __anonunion_data_102 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
#line 909 "/usr/include/X11/Xlib.h"
struct __anonstruct_XClientMessageEvent_101 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_102 data ;
};
#line 909 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XClientMessageEvent_101 XClientMessageEvent;
#line 924 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMappingEvent_103 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
#line 924 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMappingEvent_103 XMappingEvent;
#line 936 "/usr/include/X11/Xlib.h"
struct __anonstruct_XErrorEvent_104 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
#line 936 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XErrorEvent_104 XErrorEvent;
#line 946 "/usr/include/X11/Xlib.h"
struct __anonstruct_XAnyEvent_105 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
#line 946 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XAnyEvent_105 XAnyEvent;
#line 960 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEvent_106 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
#line 960 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEvent_106 XGenericEvent;
#line 970 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEventCookie_107 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
#line 970 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEventCookie_107 XGenericEventCookie;
#line 985 "/usr/include/X11/Xlib.h"
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
#line 985 "/usr/include/X11/Xlib.h"
typedef union _XEvent XEvent;
#line 1096 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontSetExtents_115 {
   XRectangle max_ink_extent ;
   XRectangle max_logical_extent ;
};
#line 1096 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontSetExtents_115 XFontSetExtents;
#line 1106
struct _XOC;
#line 1106 "/usr/include/X11/Xlib.h"
typedef struct _XOC *XFontSet;
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_min_aspect_133 {
   int x ;
   int y ;
};
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_XSizeHints_132 {
   long flags ;
   int x ;
   int y ;
   int width ;
   int height ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   int width_inc ;
   int height_inc ;
   struct __anonstruct_min_aspect_133 min_aspect ;
   struct __anonstruct_min_aspect_133 max_aspect ;
   int base_width ;
   int base_height ;
   int win_gravity ;
};
#line 81 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XSizeHints_132 XSizeHints;
#line 119 "/usr/include/X11/Xutil.h"
struct __anonstruct_XWMHints_134 {
   long flags ;
   int input ;
   int initial_state ;
   Pixmap icon_pixmap ;
   Window icon_window ;
   int icon_x ;
   int icon_y ;
   Pixmap icon_mask ;
   XID window_group ;
};
#line 119 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XWMHints_134 XWMHints;
#line 163 "/usr/include/X11/Xutil.h"
struct __anonstruct_XTextProperty_135 {
   unsigned char *value ;
   Atom encoding ;
   int format ;
   unsigned long nitems ;
};
#line 163 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XTextProperty_135 XTextProperty;
#line 189 "/usr/include/X11/Xutil.h"
struct __anonstruct_XClassHint_138 {
   char *res_name ;
   char *res_class ;
};
#line 189 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XClassHint_138 XClassHint;
#line 231 "/usr/include/X11/Xutil.h"
struct _XComposeStatus {
   XPointer compose_ptr ;
   int chars_matched ;
};
#line 231 "/usr/include/X11/Xutil.h"
typedef struct _XComposeStatus XComposeStatus;
#line 116 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
enum __anonenum_align_145 {
    unset = 0,
    left = 1,
    yes = 1,
    snazzy = 1,
    center = 2,
    no = 2,
    dreary = 2,
    right = 3
} ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 573 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 1495 "/usr/include/X11/Xlib.h"
extern Display *XOpenDisplay(char const   * ) ;
#line 1522
extern char *XGetDefault(Display * , char const   * , char const   * ) ;
#line 1548
extern Atom XInternAtom(Display * , char const   * , int  ) ;
#line 1596
extern GC XCreateGC(Display * , Drawable  , unsigned long  , XGCValues * ) ;
#line 1633
extern Window XCreateSimpleWindow(Display * , Window  , int  , int  , unsigned int  ,
                                  unsigned int  , unsigned int  , unsigned long  ,
                                  unsigned long  ) ;
#line 1900
extern int XSetWMProtocols(Display * , Window  , Atom * , int  ) ;
#line 1934
extern void XFreeStringList(char ** ) ;
#line 1970
extern int XAllocColor(Display * , Colormap  , XColor * ) ;
#line 2167
extern int XClearWindow(Display * , Window  ) ;
#line 2172
extern int XCloseDisplay(Display * ) ;
#line 2501
extern int XFillRectangle(Display * , Drawable  , GC  , int  , int  , unsigned int  ,
                          unsigned int  ) ;
#line 2818
extern int XMapWindow(Display * , Window  ) ;
#line 2853
extern int XNextEvent(Display * , XEvent * ) ;
#line 2862
extern int XParseColor(Display * , Colormap  , char const   * , XColor * ) ;
#line 3141
extern int XSelectInput(Display * , Window  , long  ) ;
#line 3621
extern XFontSet XCreateFontSet(Display * , char const   * , char *** , int * , char ** ) ;
#line 3660
extern XFontSetExtents *XExtentsOfFontSet(XFontSet  ) ;
#line 3664
extern int XmbTextEscapement(XFontSet  , char const   * , int  ) ;
#line 3772
extern void XmbDrawString(Display * , Drawable  , XFontSet  , GC  , int  , int  ,
                          char const   * , int  ) ;
#line 366 "/usr/include/X11/Xutil.h"
extern XClassHint *XAllocClassHint(void) ;
#line 374
extern XSizeHints *XAllocSizeHints(void) ;
#line 382
extern XWMHints *XAllocWMHints(void) ;
#line 534
extern int XLookupString(XKeyEvent * , char * , int  , KeySym * , XComposeStatus * ) ;
#line 665
extern void XSetWMProperties(Display * , Window  , XTextProperty * , XTextProperty * ,
                             char ** , int  , XSizeHints * , XWMHints * , XClassHint * ) ;
#line 733
extern int XStringListToTextProperty(char ** , int  , XTextProperty * ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
char version[25]  = 
#line 72 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
  {      (char )'@',      (char )'(',      (char )'#',      (char )')', 
        (char )' ',      (char )'r',      (char )'a',      (char )'t', 
        (char )'m',      (char )'e',      (char )'n',      (char )'u', 
        (char )' ',      (char )'v',      (char )'e',      (char )'r', 
        (char )'s',      (char )'i',      (char )'o',      (char )'n', 
        (char )' ',      (char )'2',      (char )'.',      (char )'3', 
        (char )'\000'};
#line 79
XFontSet XLoadQueryFontSet(Display *disp , char const   *fontset_name ) ;
#line 81 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
Display *dpy  ;
#line 82 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
int screen  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
Window root  ;
#line 84 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
Window menuwin  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
GC gc  ;
#line 86 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
unsigned long fg  ;
#line 87 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
unsigned long bg  ;
#line 88 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
char *fgcname  =    (char *)((void *)0);
#line 89 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
char *bgcname  =    (char *)((void *)0);
#line 90 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
Colormap dcmap  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
XColor color  ;
#line 92 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
XFontSet font  ;
#line 93 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
short font__ascent  ;
#line 93 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
short font__descent  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
Atom wm_protocols  ;
#line 95 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
Atom wm_delete_window  ;
#line 96 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
int g_argc  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
char **g_argv  ;
#line 98 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
int savex  ;
#line 98 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
int savey  ;
#line 99 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
int dpyheight  ;
#line 100 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
Window savewindow  ;
#line 103 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
char *progname  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
char *displayname  ;
#line 105 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
char *fontname  =    (char *)((void *)0);
#line 106 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
char *labelname  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
char **labels  ;
#line 109 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
char **commands  ;
#line 110 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
int numitems  ;
#line 111 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
int startitem  ;
#line 112 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
int curitem  ;
#line 113 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
int olditem  ;
#line 114 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
int visible  ;
#line 115 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
int off  ;
#line 116 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
enum __anonenum_align_145 align  ;
#line 116 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
enum __anonenum_align_145 persist  ;
#line 116 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
enum __anonenum_align_145 menustyle  ;
#line 118 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
char *shell  =    (char *)"/bin/sh";
#line 119 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
char *prevmenu  =    (char *)((void *)0);
#line 121
void ask_wm_for_delete(void) ;
#line 122
void reap(int s ) ;
#line 123
void redraw_snazzy(int curitem___0 , int high , int wide , int fullredraw ) ;
#line 124
void redraw_dreary(int curitem___0 , int high , int wide , int fullredraw ) ;
#line 125 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
void (*redraw)(int  , int  , int  , int  )  ;
#line 126
void run_menu(void) ;
#line 127
void set_wm_hints(int wide , int high ) ;
#line 128
void spawn(char *com ) ;
#line 129
void usage(void) ;
#line 130
void xresources(void) ;
#line 131
void defaults(void) ;
#line 133 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
XFontSet XLoadQueryFontSet(Display *disp , char const   *fontset_name ) 
{ 
  XFontSet fontset ;
  int missing_charset_count ;
  char **missing_charset_list ;
  char *def_string ;

  {
  {
#line 140
  fontset = XCreateFontSet(disp, fontset_name, & missing_charset_list, & missing_charset_count,
                           & def_string);
  }
#line 143
  if (missing_charset_count) {
    {
#line 144
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing charsets in FontSet(%s) creation.\n",
            fontset_name);
#line 145
    XFreeStringList(missing_charset_list);
    }
  }
#line 147
  return (fontset);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int j ;
  char *cp ;
  XGCValues gv ;
  unsigned long mask ;
  XFontSetExtents *extent ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
  {
#line 162
  g_argc = argc;
#line 163
  g_argv = argv;
#line 165
  setlocale(0, "");
#line 168
  cp = strrchr((char const   *)*(argv + 0), '/');
  }
#line 168
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 169
    labelname = *(argv + 0);
  } else {
#line 171
    cp ++;
#line 171
    labelname = cp;
  }
#line 174
  progname = labelname;
#line 176
  i = 1;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (i < argc)) {
#line 176
      goto while_break;
    }
    {
#line 177
    tmp___16 = strcmp((char const   *)*(argv + i), "-display");
    }
#line 177
    if (tmp___16 == 0) {
#line 178
      i ++;
#line 178
      displayname = *(argv + i);
    } else {
      {
#line 179
      tmp___15 = strcmp((char const   *)*(argv + i), "-font");
      }
#line 179
      if (tmp___15 == 0) {
#line 180
        i ++;
#line 180
        fontname = *(argv + i);
      } else {
        {
#line 181
        tmp___14 = strcmp((char const   *)*(argv + i), "-label");
        }
#line 181
        if (tmp___14 == 0) {
#line 182
          i ++;
#line 182
          labelname = *(argv + i);
        } else {
          {
#line 183
          tmp___13 = strcmp((char const   *)*(argv + i), "-shell");
          }
#line 183
          if (tmp___13 == 0) {
#line 184
            i ++;
#line 184
            shell = *(argv + i);
          } else {
            {
#line 185
            tmp___12 = strcmp((char const   *)*(argv + i), "-back");
            }
#line 185
            if (tmp___12 == 0) {
#line 186
              i ++;
#line 186
              prevmenu = *(argv + i);
            } else {
              {
#line 187
              tmp___11 = strcmp((char const   *)*(argv + i), "-fg");
              }
#line 187
              if (tmp___11 == 0) {
#line 188
                i ++;
#line 188
                fgcname = *(argv + i);
              } else {
                {
#line 189
                tmp___10 = strcmp((char const   *)*(argv + i), "-bg");
                }
#line 189
                if (tmp___10 == 0) {
#line 190
                  i ++;
#line 190
                  bgcname = *(argv + i);
                } else {
                  {
#line 191
                  tmp___9 = strcmp((char const   *)*(argv + i), "-io");
                  }
#line 191
                  if (tmp___9 == 0) {
                    {
#line 192
                    i ++;
#line 192
                    tmp = atoi((char const   *)*(argv + i));
#line 192
                    startitem = tmp - 1;
                    }
                  } else {
                    {
#line 193
                    tmp___8 = strcmp((char const   *)*(argv + i), "-persist");
                    }
#line 193
                    if (tmp___8 == 0) {
#line 194
                      persist = (enum __anonenum_align_145 )1;
                    } else {
                      {
#line 195
                      tmp___7 = strcmp((char const   *)*(argv + i), "-align");
                      }
#line 195
                      if (tmp___7 == 0) {
                        {
#line 196
                        tmp___2 = strcmp((char const   *)*(argv + (i + 1)), "left");
                        }
#line 196
                        if (tmp___2 == 0) {
#line 197
                          align = (enum __anonenum_align_145 )1;
                        } else {
                          {
#line 198
                          tmp___1 = strcmp((char const   *)*(argv + (i + 1)), "center");
                          }
#line 198
                          if (tmp___1 == 0) {
#line 199
                            align = (enum __anonenum_align_145 )2;
                          } else {
                            {
#line 200
                            tmp___0 = strcmp((char const   *)*(argv + (i + 1)), "right");
                            }
#line 200
                            if (tmp___0 == 0) {
#line 201
                              align = (enum __anonenum_align_145 )3;
                            } else {
                              {
#line 203
                              usage();
                              }
                            }
                          }
                        }
#line 205
                        i ++;
                      } else {
                        {
#line 206
                        tmp___6 = strcmp((char const   *)*(argv + i), "-style");
                        }
#line 206
                        if (tmp___6 == 0) {
                          {
#line 207
                          tmp___4 = strcmp((char const   *)*(argv + (i + 1)), "snazzy");
                          }
#line 207
                          if (tmp___4 == 0) {
#line 208
                            menustyle = (enum __anonenum_align_145 )1;
                          } else {
                            {
#line 209
                            tmp___3 = strcmp((char const   *)*(argv + (i + 1)), "dreary");
                            }
#line 209
                            if (tmp___3 == 0) {
#line 210
                              menustyle = (enum __anonenum_align_145 )2;
                            } else {
                              {
#line 212
                              usage();
                              }
                            }
                          }
#line 214
                          i ++;
                        } else {
                          {
#line 215
                          tmp___5 = strcmp((char const   *)*(argv + i), "-version");
                          }
#line 215
                          if (tmp___5 == 0) {
                            {
#line 216
                            printf((char const   */* __restrict  */)"%s\n", version);
#line 217
                            exit(0);
                            }
                          } else
#line 218
                          if ((int )*(*(argv + i) + 0) == 45) {
                            {
#line 219
                            usage();
                            }
                          } else {
#line 221
                            goto while_break;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 176
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  if ((argc - i) % 2 == 1) {
    {
#line 226
    usage();
    }
  }
#line 228
  if ((argc - i) * 2 <= 0) {
    {
#line 229
    usage();
    }
  }
  {
#line 231
  numitems = (argc - i) / 2;
#line 233
  tmp___17 = malloc((unsigned long )numitems * sizeof(char *));
#line 233
  labels = (char **)tmp___17;
#line 234
  tmp___18 = malloc((unsigned long )numitems * sizeof(char *));
#line 234
  commands = (char **)tmp___18;
  }
#line 236
  if ((unsigned long )commands == (unsigned long )((void *)0)) {
    {
#line 237
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: no memory!\n",
            progname);
#line 238
    exit(1);
    }
  } else
#line 236
  if ((unsigned long )labels == (unsigned long )((void *)0)) {
    {
#line 237
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: no memory!\n",
            progname);
#line 238
    exit(1);
    }
  }
#line 241
  j = 0;
  {
#line 241
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 241
    if (! (i < argc)) {
#line 241
      goto while_break___0;
    }
#line 242
    tmp___19 = i;
#line 242
    i ++;
#line 242
    *(labels + j) = *(argv + tmp___19);
#line 243
    tmp___20 = i;
#line 243
    i ++;
#line 243
    *(commands + j) = *(argv + tmp___20);
#line 241
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 246
  dpy = XOpenDisplay((char const   *)displayname);
  }
#line 247
  if ((unsigned long )dpy == (unsigned long )((void *)0)) {
    {
#line 248
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot open display",
            progname);
    }
#line 249
    if ((unsigned long )displayname != (unsigned long )((void *)0)) {
      {
#line 250
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %s",
              displayname);
      }
    }
    {
#line 251
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 252
    exit(1);
    }
  }
  {
#line 254
  screen = ((_XPrivDisplay )dpy)->default_screen;
#line 255
  dcmap = (((_XPrivDisplay )dpy)->screens + screen)->cmap;
#line 257
  xresources();
#line 258
  defaults();
#line 260
  font = XLoadQueryFontSet(dpy, (char const   *)fontname);
  }
#line 260
  if ((unsigned long )font == (unsigned long )((void *)0)) {
    {
#line 261
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: fatal: cannot load font %s\n",
            progname, fontname);
#line 262
    exit(1);
    }
  }
  {
#line 264
  extent = XExtentsOfFontSet(font);
#line 265
  font__ascent = (short )(((int )extent->max_logical_extent.height * 4) / 5);
#line 266
  font__descent = (short )((int )extent->max_logical_extent.height / 5);
#line 268
  gv.foreground = fg ^ bg;
#line 269
  gv.background = bg;
#line 270
  gv.function = 6;
#line 271
  gv.line_width = 0;
#line 272
  mask = (unsigned long )((((1L << 2) | (1L << 3)) | 1L) | (1L << 4));
#line 274
  root = (((_XPrivDisplay )dpy)->screens + screen)->root;
#line 275
  gc = XCreateGC(dpy, root, mask, & gv);
#line 277
  dpyheight = (((_XPrivDisplay )dpy)->screens + screen)->height;
#line 279
  signal(17, & reap);
#line 281
  run_menu();
#line 283
  XCloseDisplay(dpy);
#line 284
  exit(0);
  }
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
void spawn(char *com ) 
{ 
  char *sh_basename ;

  {
  {
#line 294
  sh_basename = strrchr((char const   *)shell, '/');
  }
#line 294
  if ((unsigned long )sh_basename != (unsigned long )((void *)0)) {
#line 295
    sh_basename ++;
  } else {
#line 297
    sh_basename = shell;
  }
  {
#line 300
  XCloseDisplay(dpy);
#line 301
  execl((char const   *)shell, (char const   *)sh_basename, "-c", com, (void *)0);
#line 302
  execl("/bin/sh", "sh", "-c", com, (void *)0);
#line 303
  exit(1);
  }
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
void reap(int s ) 
{ 


  {
  {
#line 311
  wait((union wait *)((int *)((void *)0)));
#line 312
  signal(s, & reap);
  }
#line 313
  return;
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
void usage(void) 
{ 


  {
  {
#line 320
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s [-display displayname] [-style {snazzy|dreary}]\n[-shell shell] [-label name] [-align {left|center|right}]\n[-fg fgcolor] [-bg bgcolor] [-font fname] [-back prevmenu]\n[-persist] [-version] [-io offset] [menuitem command] ...\n",
          progname);
#line 324
  exit(0);
  }
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
void run_menu(void) 
{ 
  KeySym key ;
  XEvent ev ;
  XClientMessageEvent *cmsg ;
  int i ;
  int wide ;
  int high ;
  int dx ;
  int dy ;
  size_t tmp ;
  int tmp___0 ;
  char keystr[10] ;
  int keystr_len ;
  int tmp___1 ;

  {
#line 337
  i = 0;
#line 337
  dx = 0;
#line 337
  wide = 0;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! (i < numitems)) {
#line 337
      goto while_break;
    }
    {
#line 338
    tmp = strlen((char const   *)*(labels + i));
#line 338
    tmp___0 = XmbTextEscapement(font, (char const   *)*(labels + i), (int )tmp);
#line 338
    wide = tmp___0 + 4;
    }
#line 339
    if (wide > dx) {
#line 340
      dx = wide;
    }
#line 337
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  wide = dx;
#line 344
  high = ((int )font__ascent + (int )font__descent) + 1;
#line 345
  visible = dpyheight / high;
#line 346
  if (visible > numitems) {
#line 346
    visible = numitems;
  }
  {
#line 347
  dy = visible * high;
#line 349
  set_wm_hints(dx, dy);
#line 351
  ask_wm_for_delete();
#line 354
  XSelectInput(dpy, menuwin, ((1L << 15) | (1L << 17)) | 1L);
#line 356
  XMapWindow(dpy, menuwin);
  }
#line 358
  if (startitem < 0) {
#line 359
    curitem = 0;
  } else
#line 360
  if (startitem >= numitems) {
#line 361
    curitem = numitems - 1;
  } else {
#line 363
    curitem = startitem;
  }
#line 366
  if ((unsigned int )menustyle == 1U) {
#line 367
    redraw = & redraw_snazzy;
  } else
#line 368
  if ((unsigned int )menustyle == 2U) {
#line 369
    redraw = & redraw_dreary;
#line 370
    olditem = curitem;
  }
#line 373
  off = 0;
  {
#line 375
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 378
    XNextEvent(dpy, & ev);
    }
    {
#line 380
    if (ev.type == 2) {
#line 380
      goto case_2;
    }
#line 434
    if (ev.type == 12) {
#line 434
      goto case_12;
    }
#line 434
    if (ev.type == 19) {
#line 434
      goto case_12;
    }
#line 435
    if (ev.type == 18) {
#line 435
      goto case_18;
    }
#line 436
    if (ev.type == 26) {
#line 436
      goto case_26;
    }
#line 437
    if (ev.type == 33) {
#line 437
      goto case_33;
    }
#line 379
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 381
    keystr_len = XLookupString(& ev.xkey, keystr, (int )sizeof(keystr), & key, (XComposeStatus *)((void *)0));
    }
#line 382
    if (keystr_len == 1) {
      {
#line 391
      if ((int )keystr[0] == 7) {
#line 391
        goto case_7;
      }
#line 391
      if ((int )keystr[0] == 27) {
#line 391
        goto case_7;
      }
#line 391
      if ((int )keystr[0] == 113) {
#line 391
        goto case_7;
      }
#line 394
      if ((int )keystr[0] == 16) {
#line 394
        goto case_16;
      }
#line 398
      if ((int )keystr[0] == 9) {
#line 398
        goto case_9;
      }
#line 398
      if ((int )keystr[0] == 14) {
#line 398
        goto case_9;
      }
#line 403
      if ((int )keystr[0] == 6) {
#line 403
        goto case_6;
      }
#line 403
      if ((int )keystr[0] == 10) {
#line 403
        goto case_6;
      }
#line 403
      if ((int )keystr[0] == 13) {
#line 403
        goto case_6;
      }
#line 406
      if ((int )keystr[0] == 2) {
#line 406
        goto case_2___0;
      }
#line 388
      goto switch_break___0;
      case_7: /* CIL Label */ 
      case_27: /* CIL Label */ 
      case_113: /* CIL Label */ 
#line 392
      key = (KeySym )65307;
#line 393
      goto switch_break___0;
      case_16: /* CIL Label */ 
#line 395
      key = (KeySym )65362;
#line 396
      goto switch_break___0;
      case_9: /* CIL Label */ 
      case_14: /* CIL Label */ 
#line 399
      key = (KeySym )65364;
#line 400
      goto switch_break___0;
      case_6: /* CIL Label */ 
      case_10: /* CIL Label */ 
      case_13: /* CIL Label */ 
#line 404
      key = (KeySym )65363;
#line 405
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
#line 407
      key = (KeySym )65361;
#line 408
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    {
#line 413
    if (key == 113UL) {
#line 413
      goto case_113___0;
    }
#line 413
    if (key == 65307UL) {
#line 413
      goto case_113___0;
    }
#line 416
    if (key == 104UL) {
#line 416
      goto case_104;
    }
#line 416
    if (key == 65361UL) {
#line 416
      goto case_104;
    }
#line 421
    if (key == 108UL) {
#line 421
      goto case_108;
    }
#line 421
    if (key == 65293UL) {
#line 421
      goto case_108;
    }
#line 421
    if (key == 65363UL) {
#line 421
      goto case_108;
    }
#line 424
    if (key == 43UL) {
#line 424
      goto case_43;
    }
#line 424
    if (key == 106UL) {
#line 424
      goto case_43;
    }
#line 424
    if (key == 65364UL) {
#line 424
      goto case_43;
    }
#line 424
    if (key == 32UL) {
#line 424
      goto case_43;
    }
#line 424
    if (key == 65289UL) {
#line 424
      goto case_43;
    }
#line 428
    if (key == 45UL) {
#line 428
      goto case_45;
    }
#line 428
    if (key == 107UL) {
#line 428
      goto case_45;
    }
#line 428
    if (key == 65362UL) {
#line 428
      goto case_45;
    }
#line 428
    if (key == 65288UL) {
#line 428
      goto case_45;
    }
#line 412
    goto switch_break___1;
    case_113___0: /* CIL Label */ 
    case_65307: /* CIL Label */ 
#line 414
    return;
#line 415
    goto switch_break___1;
    case_104: /* CIL Label */ 
    case_65361: /* CIL Label */ 
#line 417
    if (prevmenu) {
      {
#line 418
      spawn(prevmenu);
      }
    }
#line 420
    goto switch_break___1;
    case_108: /* CIL Label */ 
    case_65293: /* CIL Label */ 
    case_65363: /* CIL Label */ 
    {
#line 422
    spawn(*(commands + curitem));
    }
#line 423
    goto switch_break___1;
    case_43: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_65364: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_65289: /* CIL Label */ 
#line 425
    curitem ++;
#line 425
    if (curitem >= numitems) {
#line 425
      curitem = 0;
    }
    {
#line 426
    (*redraw)(curitem, high, wide, 0);
    }
#line 427
    goto switch_break___1;
    case_45: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_65362: /* CIL Label */ 
    case_65288: /* CIL Label */ 
#line 429
    tmp___1 = curitem;
#line 429
    curitem --;
#line 429
    if (tmp___1 <= 0) {
#line 429
      curitem = numitems - 1;
    }
    {
#line 430
    (*redraw)(curitem, high, wide, 0);
    }
#line 431
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 433
    goto switch_break;
    case_12: /* CIL Label */ 
    case_19: /* CIL Label */ 
    {
#line 434
    (*redraw)(curitem, high, wide, 1);
    }
#line 434
    goto switch_break;
    case_18: /* CIL Label */ 
#line 435
    if ((unsigned int )persist == 2U) {
#line 435
      return;
    } else {
      {
#line 435
      XClearWindow(dpy, menuwin);
      }
    }
#line 435
    goto switch_break;
    case_26: /* CIL Label */ 
#line 436
    if ((unsigned int )persist == 2U) {
#line 436
      return;
    }
#line 436
    goto switch_break;
    case_33: /* CIL Label */ 
#line 438
    cmsg = & ev.xclient;
#line 439
    if (cmsg->message_type == wm_protocols) {
#line 439
      if ((Atom )cmsg->data.l[0] == wm_delete_window) {
#line 441
        return;
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 448 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
void set_wm_hints(int wide , int high ) 
{ 
  XWMHints *wmhints ;
  XSizeHints *sizehints ;
  XClassHint *classhints ;
  XTextProperty wname ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 456
  sizehints = XAllocSizeHints();
  }
#line 456
  if ((unsigned long )sizehints == (unsigned long )((void *)0)) {
    {
#line 457
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: could not allocate size hints\n",
            progname);
#line 459
    exit(1);
    }
  }
  {
#line 462
  wmhints = XAllocWMHints();
  }
#line 462
  if ((unsigned long )wmhints == (unsigned long )((void *)0)) {
    {
#line 463
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: could not allocate window manager hints\n",
            progname);
#line 465
    exit(1);
    }
  }
  {
#line 468
  classhints = XAllocClassHint();
  }
#line 468
  if ((unsigned long )classhints == (unsigned long )((void *)0)) {
    {
#line 469
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: could not allocate class hints\n",
            progname);
#line 471
    exit(1);
    }
  }
  {
#line 475
  tmp___0 = wide;
#line 475
  sizehints->max_width = tmp___0;
#line 475
  tmp = tmp___0;
#line 475
  sizehints->min_width = tmp;
#line 475
  sizehints->width = tmp;
#line 476
  tmp___2 = high;
#line 476
  sizehints->max_height = tmp___2;
#line 476
  tmp___1 = tmp___2;
#line 476
  sizehints->min_height = tmp___1;
#line 476
  sizehints->height = tmp___1;
#line 477
  sizehints->flags = (((1L << 1) | (1L << 3)) | (1L << 4)) | (1L << 5);
#line 479
  tmp___3 = XStringListToTextProperty(& labelname, 1, & wname);
  }
#line 479
  if (tmp___3 == 0) {
    {
#line 480
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: could not allocate window name structure\n",
            progname);
#line 482
    exit(1);
    }
  }
  {
#line 485
  menuwin = XCreateSimpleWindow(dpy, root, sizehints->x, sizehints->y, (unsigned int )sizehints->width,
                                (unsigned int )sizehints->height, 1U, fg, bg);
#line 488
  wmhints->input = 1;
#line 489
  wmhints->initial_state = 1;
#line 490
  wmhints->flags = (1L << 1) | 1L;
#line 492
  classhints->res_name = progname;
#line 493
  classhints->res_class = (char *)"ratmenu";
#line 495
  XSetWMProperties(dpy, menuwin, & wname, (XTextProperty *)((void *)0), g_argv, g_argc,
                   sizehints, wmhints, classhints);
  }
#line 497
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
void ask_wm_for_delete(void) 
{ 
  int status ;

  {
  {
#line 506
  wm_protocols = XInternAtom(dpy, "WM_PROTOCOLS", 0);
#line 507
  wm_delete_window = XInternAtom(dpy, "WM_DELETE_WINDOW", 0);
#line 508
  status = XSetWMProtocols(dpy, menuwin, & wm_delete_window, 1);
  }
#line 510
  if (status != 1) {
    {
#line 511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: could not ask for clean delete\n",
            progname);
    }
  }
#line 513
  return;
}
}
#line 517 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
void redraw_snazzy(int curitem___0 , int high , int wide , int fullredraw ) 
{ 
  int i ;
  int j ;
  int ty ;
  int tx ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 522
  XClearWindow(dpy, menuwin);
#line 523
  i = 0;
#line 523
  j = curitem___0;
  }
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if (! (i < visible)) {
#line 523
      goto while_break;
    }
#line 524
    j %= numitems;
#line 525
    if ((unsigned int )align == 1U) {
#line 526
      tx = 0;
    } else
#line 527
    if ((unsigned int )align == 2U) {
      {
#line 528
      tmp = strlen((char const   *)*(labels + j));
#line 528
      tmp___0 = XmbTextEscapement(font, (char const   *)*(labels + j), (int )tmp);
#line 528
      tx = (wide - tmp___0) / 2;
      }
    } else {
      {
#line 530
      tmp___1 = strlen((char const   *)*(labels + j));
#line 530
      tmp___2 = XmbTextEscapement(font, (char const   *)*(labels + j), (int )tmp___1);
#line 530
      tx = wide - tmp___2;
      }
    }
    {
#line 532
    ty = (i * high + (int )font__ascent) + 1;
#line 533
    tmp___3 = strlen((char const   *)*(labels + j));
#line 533
    XmbDrawString(dpy, menuwin, font, gc, tx, ty, (char const   *)*(labels + j), (int )tmp___3);
#line 523
    i ++;
#line 523
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 535
  XFillRectangle(dpy, menuwin, gc, 0, 0, (unsigned int )wide, (unsigned int )high);
  }
#line 536
  return;
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
void redraw_dreary(int curitem___0 , int high , int wide , int fullredraw ) 
{ 
  int i ;
  int ty ;
  int tx ;
  int oldoff ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 543
  oldoff = off;
#line 544
  if (curitem___0 + 1 > visible + off) {
#line 545
    off = (curitem___0 + 1) - visible;
  } else
#line 546
  if (curitem___0 + 1 <= off) {
#line 547
    off = curitem___0;
  }
#line 549
  if (fullredraw) {
#line 549
    goto _L;
  } else
#line 549
  if (oldoff != off) {
    _L: /* CIL Label */ 
    {
#line 550
    XClearWindow(dpy, menuwin);
#line 551
    i = 0;
    }
    {
#line 551
    while (1) {
      while_continue: /* CIL Label */ ;
#line 551
      if (! (i < visible)) {
#line 551
        goto while_break;
      }
#line 552
      if ((unsigned int )align == 1U) {
#line 553
        tx = 0;
      } else
#line 554
      if ((unsigned int )align == 2U) {
        {
#line 555
        tmp = strlen((char const   *)*(labels + (i + off)));
#line 555
        tmp___0 = XmbTextEscapement(font, (char const   *)*(labels + (i + off)), (int )tmp);
#line 555
        tx = (wide - tmp___0) / 2;
        }
      } else {
        {
#line 557
        tmp___1 = strlen((char const   *)*(labels + (i + off)));
#line 557
        tmp___2 = XmbTextEscapement(font, (char const   *)*(labels + (i + off)), (int )tmp___1);
#line 557
        tx = wide - tmp___2;
        }
      }
      {
#line 559
      ty = (i * high + (int )font__ascent) + 1;
#line 560
      tmp___3 = strlen((char const   *)*(labels + (i + off)));
#line 560
      XmbDrawString(dpy, menuwin, font, gc, tx, ty, (char const   *)*(labels + (i + off)),
                    (int )tmp___3);
#line 551
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 562
    XFillRectangle(dpy, menuwin, gc, 0, (curitem___0 - off) * high, (unsigned int )wide,
                   (unsigned int )high);
    }
  } else {
    {
#line 564
    XFillRectangle(dpy, menuwin, gc, 0, (olditem - off) * high, (unsigned int )wide,
                   (unsigned int )high);
#line 565
    XFillRectangle(dpy, menuwin, gc, 0, (curitem___0 - off) * high, (unsigned int )wide,
                   (unsigned int )high);
    }
  }
#line 567
  olditem = curitem___0;
#line 568
  return;
}
}
#line 570 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
void xresources(void) 
{ 
  char *res ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 575
  if ((unsigned long )bgcname == (unsigned long )((void *)0)) {
    {
#line 576
    res = XGetDefault(dpy, (char const   *)progname, "bgcolor");
    }
#line 576
    if ((unsigned long )res != (unsigned long )((void *)0)) {
      {
#line 577
      bgcname = strdup((char const   *)res);
      }
    }
  }
#line 580
  if ((unsigned long )fgcname == (unsigned long )((void *)0)) {
    {
#line 581
    res = XGetDefault(dpy, (char const   *)progname, "fgcolor");
    }
#line 581
    if ((unsigned long )res != (unsigned long )((void *)0)) {
      {
#line 582
      fgcname = strdup((char const   *)res);
      }
    }
  }
#line 585
  if ((unsigned long )fontname == (unsigned long )((void *)0)) {
    {
#line 586
    res = XGetDefault(dpy, (char const   *)progname, "font");
    }
#line 586
    if ((unsigned long )res != (unsigned long )((void *)0)) {
      {
#line 587
      fontname = strdup((char const   *)res);
      }
    }
  }
#line 590
  if ((unsigned int )menustyle == 0U) {
    {
#line 591
    res = XGetDefault(dpy, (char const   *)progname, "style");
    }
#line 591
    if ((unsigned long )res != (unsigned long )((void *)0)) {
      {
#line 592
      tmp___0 = strcasecmp((char const   *)res, "dreary");
      }
#line 592
      if (tmp___0 == 0) {
#line 592
        menustyle = (enum __anonenum_align_145 )2;
      } else {
        {
#line 593
        tmp = strcasecmp((char const   *)res, "snazzy");
        }
#line 593
        if (tmp == 0) {
#line 593
          menustyle = (enum __anonenum_align_145 )1;
        }
      }
    }
  }
#line 596
  if ((unsigned int )persist == 0U) {
    {
#line 597
    res = XGetDefault(dpy, (char const   *)progname, "persist");
    }
#line 597
    if ((unsigned long )res != (unsigned long )((void *)0)) {
      {
#line 598
      tmp___6 = strcasecmp((char const   *)res, "on");
      }
#line 598
      if (tmp___6 == 0) {
#line 598
        persist = (enum __anonenum_align_145 )1;
      } else {
        {
#line 599
        tmp___5 = strcasecmp((char const   *)res, "off");
        }
#line 599
        if (tmp___5 == 0) {
#line 599
          persist = (enum __anonenum_align_145 )2;
        } else {
          {
#line 600
          tmp___4 = strcasecmp((char const   *)res, "yes");
          }
#line 600
          if (tmp___4 == 0) {
#line 600
            persist = (enum __anonenum_align_145 )1;
          } else {
            {
#line 601
            tmp___3 = strcasecmp((char const   *)res, "no");
            }
#line 601
            if (tmp___3 == 0) {
#line 601
              persist = (enum __anonenum_align_145 )2;
            } else {
              {
#line 602
              tmp___2 = strcasecmp((char const   *)res, "true");
              }
#line 602
              if (tmp___2 == 0) {
#line 602
                persist = (enum __anonenum_align_145 )1;
              } else {
                {
#line 603
                tmp___1 = strcasecmp((char const   *)res, "false");
                }
#line 603
                if (tmp___1 == 0) {
#line 603
                  persist = (enum __anonenum_align_145 )2;
                }
              }
            }
          }
        }
      }
    }
  }
#line 606
  if ((unsigned int )align == 0U) {
    {
#line 607
    res = XGetDefault(dpy, (char const   *)progname, "align");
    }
#line 607
    if ((unsigned long )res != (unsigned long )((void *)0)) {
      {
#line 608
      tmp___9 = strcasecmp((char const   *)res, "left");
      }
#line 608
      if (tmp___9 == 0) {
#line 608
        align = (enum __anonenum_align_145 )1;
      } else {
        {
#line 609
        tmp___8 = strcasecmp((char const   *)res, "center");
        }
#line 609
        if (tmp___8 == 0) {
#line 609
          align = (enum __anonenum_align_145 )2;
        } else {
          {
#line 610
          tmp___7 = strcasecmp((char const   *)res, "right");
          }
#line 610
          if (tmp___7 == 0) {
#line 610
            align = (enum __anonenum_align_145 )3;
          }
        }
      }
    }
  }
#line 613
  return;
}
}
#line 615 "/home/june/repo/benchmarks/collector/temp/ratmenu-2.3.20/ratmenu.c"
void defaults(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 618
  if ((unsigned long )bgcname == (unsigned long )((void *)0)) {
#line 619
    bg = (((_XPrivDisplay )dpy)->screens + screen)->black_pixel;
  } else {
    {
#line 618
    tmp = XParseColor(dpy, dcmap, (char const   *)bgcname, & color);
    }
#line 618
    if (tmp == 0) {
#line 619
      bg = (((_XPrivDisplay )dpy)->screens + screen)->black_pixel;
    } else {
      {
#line 618
      tmp___0 = XAllocColor(dpy, dcmap, & color);
      }
#line 618
      if (tmp___0 == 0) {
#line 619
        bg = (((_XPrivDisplay )dpy)->screens + screen)->black_pixel;
      } else {
#line 620
        bg = color.pixel;
      }
    }
  }
#line 621
  if ((unsigned long )fgcname == (unsigned long )((void *)0)) {
#line 622
    fg = (((_XPrivDisplay )dpy)->screens + screen)->white_pixel;
  } else {
    {
#line 621
    tmp___1 = XParseColor(dpy, dcmap, (char const   *)fgcname, & color);
    }
#line 621
    if (tmp___1 == 0) {
#line 622
      fg = (((_XPrivDisplay )dpy)->screens + screen)->white_pixel;
    } else {
      {
#line 621
      tmp___2 = XAllocColor(dpy, dcmap, & color);
      }
#line 621
      if (tmp___2 == 0) {
#line 622
        fg = (((_XPrivDisplay )dpy)->screens + screen)->white_pixel;
      } else {
#line 623
        fg = color.pixel;
      }
    }
  }
#line 624
  if ((unsigned long )fontname == (unsigned long )((void *)0)) {
#line 624
    fontname = (char *)"9x15bold";
  }
#line 625
  if ((unsigned int )persist == 0U) {
#line 625
    persist = (enum __anonenum_align_145 )2;
  }
#line 626
  if ((unsigned int )align == 0U) {
#line 626
    align = (enum __anonenum_align_145 )1;
  }
#line 627
  if ((unsigned int )menustyle == 0U) {
#line 627
    menustyle = (enum __anonenum_align_145 )1;
  }
#line 628
  return;
}
}
