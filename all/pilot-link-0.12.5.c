/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 66 "../include/pi-buffer.h"
struct pi_buffer_t {
   unsigned char *data ;
   size_t allocated ;
   size_t used ;
};
#line 66 "../include/pi-buffer.h"
typedef struct pi_buffer_t pi_buffer_t;
#line 151 "../include/pi-socket.h"
struct pi_protocol;
#line 154
struct sockaddr;
#line 154
struct pi_device;
#line 154 "../include/pi-socket.h"
struct pi_socket {
   int sd ;
   int type ;
   int protocol ;
   int cmd ;
   struct sockaddr *laddr ;
   size_t laddrlen ;
   struct sockaddr *raddr ;
   size_t raddrlen ;
   struct pi_protocol **protocol_queue ;
   int queue_len ;
   struct pi_protocol **cmd_queue ;
   int cmd_len ;
   struct pi_device *device ;
   int state ;
   int honor_rx_to ;
   int command ;
   int accept_to ;
   int dlprecord ;
   int dlpversion ;
   unsigned long maxrecsize ;
   int last_error ;
   int palmos_error ;
};
#line 154 "../include/pi-socket.h"
typedef struct pi_socket pi_socket_t;
#line 91 "../include/pi-source.h"
struct pi_protocol {
   int level ;
   struct pi_protocol *(*dup)(struct pi_protocol * ) ;
   void (*free)(struct pi_protocol * ) ;
   ssize_t (*read)(pi_socket_t *ps , pi_buffer_t *buf , size_t expect , int flags ) ;
   ssize_t (*write)(pi_socket_t *ps , unsigned char const   *buf , size_t len , int flags ) ;
   int (*flush)(pi_socket_t *ps , int flags ) ;
   int (*getsockopt)(pi_socket_t *ps , int level , int option_name , void *option_value ,
                     size_t *option_len ) ;
   int (*setsockopt)(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                     size_t *option_len ) ;
   void *data ;
};
#line 91 "../include/pi-source.h"
typedef struct pi_protocol pi_protocol_t;
#line 116 "../include/pi-source.h"
struct pi_device {
   void (*free)(struct pi_device *dev ) ;
   struct pi_protocol *(*protocol)(struct pi_device *dev ) ;
   int (*bind)(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
   int (*listen)(pi_socket_t *ps , int backlog ) ;
   int (*accept)(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) ;
   int (*connect)(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
   int (*close)(pi_socket_t *ps ) ;
   void *data ;
};
#line 43 "../include/pi-net.h"
struct pi_net_data {
   int type ;
   int split_writes ;
   size_t write_chunksize ;
   unsigned char txid ;
};
#line 43 "../include/pi-net.h"
typedef struct pi_net_data pi_net_data_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 48 "../include/pi-padp.h"
struct padp {
   unsigned char type ;
   unsigned char flags ;
   int size ;
};
#line 54 "../include/pi-padp.h"
struct pi_padp_data {
   int type ;
   int last_type ;
   int freeze_txid ;
   int use_long_format ;
   unsigned char txid ;
   unsigned int next_txid ;
   unsigned char last_ack_txid ;
   struct padp last_ack_padp ;
};
#line 54 "../include/pi-padp.h"
typedef struct pi_padp_data pi_padp_data_t;
#line 48 "../include/pi-threadsafe.h"
typedef int pi_mutex_t;
#line 30 "../include/pi-appinfo.h"
struct CategoryAppInfo {
   unsigned int renamed[16] ;
   char name[16][16] ;
   unsigned char ID[16] ;
   unsigned char lastUniqueID ;
};
#line 30 "../include/pi-appinfo.h"
typedef struct CategoryAppInfo CategoryAppInfo_t;
#line 32 "../include/pi-address.h"
enum __anonenum_addressType_28 {
    address_v1 = 0
} ;
#line 32 "../include/pi-address.h"
typedef enum __anonenum_addressType_28 addressType;
#line 59 "../include/pi-address.h"
struct Address {
   int phoneLabel[5] ;
   int showPhone ;
   char *entry[19] ;
};
#line 59 "../include/pi-address.h"
typedef struct Address Address_t;
#line 66 "../include/pi-address.h"
struct AddressAppInfo {
   addressType type ;
   struct CategoryAppInfo category ;
   char labels[22][16] ;
   int labelRenamed[22] ;
   char phoneLabels[8][16] ;
   int country ;
   int sortByCompany ;
};
#line 66 "../include/pi-address.h"
typedef struct AddressAppInfo AddressAppInfo_t;
#line 30 "../include/pi-money.h"
struct Transaction {
   char flags ;
   unsigned int checknum ;
   long amount ;
   long total ;
   int amountc ;
   int totalc ;
   int second ;
   int minute ;
   int hour ;
   int day ;
   int month ;
   int year ;
   int wday ;
   char repeat ;
   char flags2 ;
   char type ;
   char reserved[2] ;
   char xfer ;
   char description[19] ;
   char note[401] ;
};
#line 30 "../include/pi-money.h"
typedef struct Transaction Transaction_t;
#line 55 "../include/pi-money.h"
struct MoneyAppInfo {
   struct CategoryAppInfo category ;
   char typeLabels[20][10] ;
   char tranLabels[20][20] ;
};
#line 55 "../include/pi-money.h"
typedef struct MoneyAppInfo MoneyAppInfo_t;
#line 195 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef short int16_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 42 "../include/pi-blob.h"
struct __anonstruct_Blob_t_25 {
   char type[4] ;
   int16_t length ;
   uint8_t *data ;
};
#line 42 "../include/pi-blob.h"
typedef struct __anonstruct_Blob_t_25 Blob_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_10 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_10 fd_set;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 24 "../include/pi-sockaddr.h"
struct pi_sockaddr {
   unsigned short pi_family ;
   char pi_device[255] ;
};
#line 116 "../include/pi-source.h"
typedef struct pi_device pi_device_t;
#line 33 "../include/pi-serial.h"
struct pi_serial_impl {
   int (*open)(pi_socket_t *ps , struct pi_sockaddr *addr , size_t addrlen ) ;
   int (*close)(pi_socket_t *ps ) ;
   int (*changebaud)(pi_socket_t *ps ) ;
   ssize_t (*write)(pi_socket_t *ps , unsigned char const   *buf , size_t len , int flags ) ;
   ssize_t (*read)(pi_socket_t *ps , pi_buffer_t *buf , size_t expect , int flags ) ;
   int (*flush)(pi_socket_t *ps , int flags ) ;
   int (*poll)(pi_socket_t *ps , int timeout ) ;
};
#line 46 "../include/pi-serial.h"
struct pi_serial_data {
   struct pi_serial_impl impl ;
   unsigned char buf[256] ;
   size_t buf_size ;
   struct termios tco ;
   int rate ;
   int establishrate ;
   int establishhighrate ;
   int timeout ;
   int rx_bytes ;
   int rx_errors ;
   int tx_bytes ;
   int tx_errors ;
};
#line 31 "../include/pi-memo.h"
enum __anonenum_memoType_25 {
    memo_v1 = 0
} ;
#line 31 "../include/pi-memo.h"
typedef enum __anonenum_memoType_25 memoType;
#line 35 "../include/pi-memo.h"
struct Memo {
   char *text ;
};
#line 39 "../include/pi-memo.h"
struct MemoAppInfo {
   memoType type ;
   struct CategoryAppInfo category ;
   int sortByAlpha ;
};
#line 30 "../include/pi-veo.h"
struct VeoAppInfo {
   int dirty ;
   int sortByPriority ;
   struct CategoryAppInfo category ;
};
#line 45 "../include/pi-veo.h"
struct Veo {
   unsigned char res1[1] ;
   unsigned char quality ;
   unsigned char resolution ;
   unsigned char res2[12] ;
   unsigned long picnum ;
   unsigned short day ;
   unsigned short month ;
   unsigned short year ;
   unsigned short width ;
   unsigned short height ;
   int sd ;
   int db ;
   char name[32] ;
};
#line 45 "../include/pi-veo.h"
typedef struct Veo Veo_t;
#line 33 "../include/pi-location.h"
enum DayOfWeek {
    sunday = 0,
    monday = 1,
    tuesday = 2,
    wednesday = 3,
    thursday = 4,
    friday = 5,
    saturday = 6
} ;
#line 37
enum WeekOfMonth {
    first = 0,
    second = 1,
    third = 2,
    fourth = 3,
    last = 4
} ;
#line 41
enum Month {
    none = 0,
    january = 1,
    february = 2,
    march = 3,
    april = 4,
    may = 5,
    june = 6,
    july = 7,
    august = 8,
    september = 9,
    october = 10,
    november = 11,
    december = 12
} ;
#line 46 "../include/pi-location.h"
struct __anonstruct_DST_t_25 {
   enum DayOfWeek dayOfWeek ;
   enum WeekOfMonth weekOfMonth ;
   enum Month month ;
   uint8_t unknown ;
};
#line 46 "../include/pi-location.h"
typedef struct __anonstruct_DST_t_25 DST_t;
#line 60 "../include/pi-location.h"
struct __anonstruct_Timezone_t_27 {
   int16_t offset ;
   uint8_t t2 ;
   DST_t dstStart ;
   DST_t dstEnd ;
   uint8_t dstObserved ;
   uint8_t t4 ;
   uint8_t unknown ;
   char *name ;
};
#line 60 "../include/pi-location.h"
typedef struct __anonstruct_Timezone_t_27 Timezone_t;
#line 39 "../include/pi-calendar.h"
enum __anonenum_calendarType_30 {
    calendar_v1 = 0
} ;
#line 39 "../include/pi-calendar.h"
typedef enum __anonenum_calendarType_30 calendarType;
#line 43
enum calendarRepeatType {
    calendarRepeatNone = 0,
    calendarRepeatDaily = 1,
    calendarRepeatWeekly = 2,
    calendarRepeatMonthlyByDay = 3,
    calendarRepeatMonthlyByDate = 4,
    calendarRepeatYearly = 5
} ;
#line 57
enum calendarDayOfMonthType {
    calendar_1stSun = 0,
    calendar_1stMon = 1,
    calendar_1stTue = 2,
    calendar_1stWen = 3,
    calendar_1stThu = 4,
    calendar_1stFri = 5,
    calendar_1stSat = 6,
    calendar_2ndSun = 7,
    calendar_2ndMon = 8,
    calendar_2ndTue = 9,
    calendar_2ndWen = 10,
    calendar_2ndThu = 11,
    calendar_2ndFri = 12,
    calendar_2ndSat = 13,
    calendar_3rdSun = 14,
    calendar_3rdMon = 15,
    calendar_3rdTue = 16,
    calendar_3rdWen = 17,
    calendar_3rdThu = 18,
    calendar_3rdFri = 19,
    calendar_3rdSat = 20,
    calendar_4thSun = 21,
    calendar_4thMon = 22,
    calendar_4thTue = 23,
    calendar_4thWen = 24,
    calendar_4thThu = 25,
    calendar_4thFri = 26,
    calendar_4thSat = 27,
    calendar_LastSun = 28,
    calendar_LastMon = 29,
    calendar_LastTue = 30,
    calendar_LastWen = 31,
    calendar_LastThu = 32,
    calendar_LastFri = 33,
    calendar_LastSat = 34
} ;
#line 80 "../include/pi-calendar.h"
struct CalendarEvent {
   int event ;
   struct tm begin ;
   struct tm end ;
   int alarm ;
   int advance ;
   int advanceUnits ;
   enum calendarRepeatType repeatType ;
   int repeatForever ;
   struct tm repeatEnd ;
   int repeatFrequency ;
   enum calendarDayOfMonthType repeatDay ;
   int repeatDays[7] ;
   int repeatWeekstart ;
   int exceptions ;
   struct tm *exception ;
   char *description ;
   char *note ;
   char *location ;
   Blob_t *blob[10] ;
   Timezone_t *tz ;
};
#line 80 "../include/pi-calendar.h"
typedef struct CalendarEvent CalendarEvent_t;
#line 103 "../include/pi-calendar.h"
struct CalendarAppInfo {
   calendarType type ;
   struct CategoryAppInfo category ;
   int startOfWeek ;
   uint8_t internal[18] ;
};
#line 103 "../include/pi-calendar.h"
typedef struct CalendarAppInfo CalendarAppInfo_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 39 "../include/pi-palmpix.h"
struct PalmPixState {
   int (*getrecord)(struct PalmPixState *self , int recno , void **buffer , size_t *bufsize ) ;
   char pixname[33] ;
   int highest_recno ;
   int offset_r ;
   int offset_g ;
   int offset_b ;
   int output_type ;
   unsigned char *pixmap ;
   int bias ;
   int flags ;
};
#line 72 "../include/pi-palmpix.h"
struct PalmPixHeader {
   int w ;
   int h ;
   int resolution ;
   int zoom ;
   int num ;
   int year ;
   int month ;
   int day ;
   int hour ;
   int min ;
   int sec ;
   int numRec ;
   int thumbLen ;
   int chansize[4] ;
};
#line 30 "../include/pi-notepad.h"
struct NotePadAppInfo {
   int dirty ;
   int sortByPriority ;
   struct CategoryAppInfo category ;
};
#line 30 "../include/pi-notepad.h"
typedef struct NotePadAppInfo NotePadAppInfo_t;
#line 36 "../include/pi-notepad.h"
struct __anonstruct_noteDate_t_25 {
   unsigned short sec ;
   unsigned short min ;
   unsigned short hour ;
   unsigned short day ;
   unsigned short month ;
   unsigned short year ;
   unsigned short s ;
};
#line 36 "../include/pi-notepad.h"
typedef struct __anonstruct_noteDate_t_25 noteDate_t;
#line 82 "../include/pi-notepad.h"
struct body {
   unsigned long bodyLen ;
   unsigned long width ;
   unsigned long height ;
   unsigned long l1 ;
   unsigned long dataType ;
   unsigned int dataLen ;
};
#line 82 "../include/pi-notepad.h"
typedef struct body body_t;
#line 91 "../include/pi-notepad.h"
struct dataRec {
   unsigned char repeat ;
   unsigned char data ;
};
#line 91 "../include/pi-notepad.h"
typedef struct dataRec dataRec_t;
#line 96 "../include/pi-notepad.h"
struct NotePad {
   noteDate_t createDate ;
   noteDate_t changeDate ;
   unsigned short flags ;
   char *name ;
   noteDate_t alarmDate ;
   body_t body ;
   dataRec_t *data ;
};
#line 96 "../include/pi-notepad.h"
typedef struct NotePad NotePad_t;
#line 58 "../include/pi-slp.h"
struct pi_slp_data {
   int dest ;
   int last_dest ;
   int src ;
   int last_src ;
   int type ;
   int last_type ;
   unsigned char txid ;
   unsigned char last_txid ;
};
#line 72 "../include/pi-slp.h"
struct slp {
   unsigned char _be ;
   unsigned char _ef ;
   unsigned char _ed ;
   unsigned char dest ;
   unsigned char src ;
   unsigned char type ;
   unsigned short dlen ;
   unsigned char id_ ;
   unsigned char csum ;
};
#line 39 "../include/pi-expense.h"
enum ExpenseSort {
    esDate = 0,
    esType = 1
} ;
#line 43
enum ExpenseDistance {
    edMiles = 0,
    edKilometers = 1
} ;
#line 47
enum ExpensePayment {
    epAmEx = 0,
    epCash = 1,
    epCheck = 2,
    epCreditCard = 3,
    epMasterCard = 4,
    epPrepaid = 5,
    epVISA = 6,
    epUnfiled = 7
} ;
#line 53
enum ExpenseType {
    etAirfare = 0,
    etBreakfast = 1,
    etBus = 2,
    etBusinessMeals = 3,
    etCarRental = 4,
    etDinner = 5,
    etEntertainment = 6,
    etFax = 7,
    etGas = 8,
    etGifts = 9,
    etHotel = 10,
    etIncidentals = 11,
    etLaundry = 12,
    etLimo = 13,
    etLodging = 14,
    etLunch = 15,
    etMileage = 16,
    etOther = 17,
    etParking = 18,
    etPostage = 19,
    etSnack = 20,
    etSubway = 21,
    etSupplies = 22,
    etTaxi = 23,
    etTelephone = 24,
    etTips = 25,
    etTolls = 26,
    etTrain = 27
} ;
#line 66 "../include/pi-expense.h"
struct ExpenseCustomCurrency {
   char name[16] ;
   char symbol[4] ;
   char rate[8] ;
};
#line 72 "../include/pi-expense.h"
struct Expense {
   struct tm date ;
   enum ExpenseType type ;
   enum ExpensePayment payment ;
   int currency ;
   char *amount ;
   char *vendor ;
   char *city ;
   char *attendees ;
   char *note ;
};
#line 84 "../include/pi-expense.h"
struct ExpenseAppInfo {
   struct CategoryAppInfo category ;
   enum ExpenseSort sortOrder ;
   struct ExpenseCustomCurrency currencies[4] ;
};
#line 92 "../include/pi-expense.h"
struct ExpensePref {
   int currentCategory ;
   int defaultCurrency ;
   int attendeeFont ;
   int showAllCategories ;
   int showCurrency ;
   int saveBackup ;
   int allowQuickFill ;
   enum ExpenseDistance unitOfDistance ;
   int currencies[5] ;
   int unknown[2] ;
   int noteFont ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 48 "../include/pi-error.h"
typedef int PI_ERR;
#line 186 "../include/pi-socket.h"
struct pi_socket_list {
   pi_socket_t *ps ;
   struct pi_socket_list *next ;
};
#line 186 "../include/pi-socket.h"
typedef struct pi_socket_list pi_socket_list_t;
#line 31 "../include/pi-mail.h"
struct Mail {
   int read ;
   int signature ;
   int confirmRead ;
   int confirmDelivery ;
   int priority ;
   int addressing ;
   int dated ;
   struct tm date ;
   char *subject ;
   char *from ;
   char *to ;
   char *cc ;
   char *bcc ;
   char *replyTo ;
   char *sentTo ;
   char *body ;
};
#line 52 "../include/pi-mail.h"
struct MailAppInfo {
   struct CategoryAppInfo category ;
   int dirty ;
   int sortOrder ;
   unsigned long unsentMessage ;
};
#line 62 "../include/pi-mail.h"
struct MailSyncPref {
   int syncType ;
   int getHigh ;
   int getContaining ;
   int truncate ;
   char *filterTo ;
   char *filterFrom ;
   char *filterSubject ;
};
#line 72 "../include/pi-mail.h"
struct MailSignaturePref {
   char *signature ;
};
#line 66 "../include/pi-contact.h"
enum __anonenum_contactsType_25 {
    contacts_v10 = 0,
    contacts_v11 = 1
} ;
#line 66 "../include/pi-contact.h"
typedef enum __anonenum_contactsType_25 contactsType;
#line 120 "../include/pi-contact.h"
struct ContactBlob {
   char type[4] ;
   int length ;
   unsigned char *data ;
};
#line 127 "../include/pi-contact.h"
struct ContactPicture {
   unsigned int dirty ;
   unsigned int length ;
   unsigned char *data ;
};
#line 137 "../include/pi-contact.h"
struct Contact {
   int phoneLabel[7] ;
   int addressLabel[3] ;
   int IMLabel[2] ;
   int showPhone ;
   int birthdayFlag ;
   int reminder ;
   int advance ;
   int advanceUnits ;
   struct tm birthday ;
   char *entry[39] ;
   struct ContactBlob *blob[10] ;
   struct ContactPicture *picture ;
};
#line 152 "../include/pi-contact.h"
struct ContactAppInfo {
   contactsType type ;
   int num_labels ;
   struct CategoryAppInfo category ;
   char internal[26] ;
   char labels[53][16] ;
   int country ;
   int sortByCompany ;
   int numCustoms ;
   char customLabels[9][16] ;
   char phoneLabels[8][16] ;
   char addrLabels[3][16] ;
   char IMLabels[5][16] ;
};
#line 221 "../include/pi-dlp.h"
struct SysInfo {
   unsigned long romVersion ;
   unsigned long locale ;
   unsigned char prodIDLength ;
   char prodID[128] ;
   unsigned short dlpMajorVersion ;
   unsigned short dlpMinorVersion ;
   unsigned short compatMajorVersion ;
   unsigned short compatMinorVersion ;
   unsigned long maxRecSize ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 32 "../include/pi-inet.h"
struct pi_inet_data {
   int timeout ;
   int rx_bytes ;
   int rx_errors ;
   int tx_bytes ;
   int tx_errors ;
};
#line 32 "../include/pi-inet.h"
typedef struct pi_inet_data pi_inet_data_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 39 "../include/pi-usb.h"
struct pi_usb_data;
#line 41 "../include/pi-usb.h"
struct pi_usb_impl {
   int (*open)(pi_socket_t *ps , struct pi_sockaddr *addr , size_t addrlen ) ;
   int (*close)(pi_socket_t *ps ) ;
   ssize_t (*write)(pi_socket_t *ps , unsigned char const   *buf , size_t len , int flags ) ;
   ssize_t (*read)(pi_socket_t *ps , pi_buffer_t *buf , size_t expect , int flags ) ;
   int (*flush)(pi_socket_t *ps , int flags ) ;
   int (*poll)(pi_socket_t *ps , int timeout ) ;
   int (*wait_for_device)(pi_socket_t *ps , int *timeout ) ;
   int (*changebaud)(pi_socket_t *ps ) ;
   int (*control_request)(struct pi_usb_data *usb_data , int request_type , int request ,
                          int value , int reqindex , void *data , int size , int timeout ) ;
};
#line 65 "../include/pi-usb.h"
struct pi_usb_dev {
   u_int16_t vendor ;
   u_int16_t product ;
   u_int32_t flags ;
   char *idstr ;
};
#line 65 "../include/pi-usb.h"
typedef struct pi_usb_dev pi_usb_dev_t;
#line 71 "../include/pi-usb.h"
struct pi_usb_data {
   struct pi_usb_impl impl ;
   struct pi_usb_dev dev ;
   unsigned char buf[256] ;
   size_t buf_size ;
   void *ref ;
   int rate ;
   int establishrate ;
   int establishhighrate ;
   int timeout ;
};
#line 71 "../include/pi-usb.h"
typedef struct pi_usb_data pi_usb_data_t;
#line 109 "../include/pi-usb.h"
struct __anonstruct_connections_57 {
   u_int8_t port_function_id ;
   u_int8_t port ;
};
#line 109 "../include/pi-usb.h"
struct __anonstruct_visor_connection_info_t_56 {
   u_int16_t num_ports ;
   struct __anonstruct_connections_57 connections[2] ;
};
#line 109 "../include/pi-usb.h"
typedef struct __anonstruct_visor_connection_info_t_56 visor_connection_info_t;
#line 133 "../include/pi-usb.h"
struct __anonstruct_connections_59 {
   char port_function_id[4] ;
   u_int8_t port ;
   u_int8_t endpoint_info ;
   u_int16_t reserved ;
};
#line 133 "../include/pi-usb.h"
struct __anonstruct_palm_ext_connection_info_t_58 {
   u_int8_t num_ports ;
   u_int8_t endpoint_numbers_different ;
   u_int16_t reserved1 ;
   struct __anonstruct_connections_59 connections[2] ;
};
#line 133 "../include/pi-usb.h"
typedef struct __anonstruct_palm_ext_connection_info_t_58 palm_ext_connection_info_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 30 "../include/pi-syspkt.h"
struct Pilot_registers {
   unsigned long A[7] ;
   unsigned long D[8] ;
   unsigned long USP ;
   unsigned long SSP ;
   unsigned long PC ;
   unsigned long SR ;
};
#line 37 "../include/pi-syspkt.h"
struct Pilot_breakpoint {
   unsigned long address ;
   int enabled ;
};
#line 42 "../include/pi-syspkt.h"
struct Pilot_state {
   struct Pilot_registers regs ;
   int reset ;
   int exception ;
   int instructions[30] ;
   struct Pilot_breakpoint breakpoint[6] ;
   unsigned long func_start ;
   unsigned long func_end ;
   char func_name[32] ;
   int trap_rev ;
};
#line 53 "../include/pi-syspkt.h"
struct Pilot_watch {
   unsigned long address ;
   unsigned long length ;
   unsigned long checksum ;
};
#line 59 "../include/pi-syspkt.h"
struct RPC_param {
   int byRef ;
   size_t size ;
   int invert ;
   int arg ;
   void *data ;
};
#line 67 "../include/pi-syspkt.h"
struct RPC_params {
   int trap ;
   int reply ;
   int args ;
   struct RPC_param param[20] ;
};
#line 65 "../include/pi-cmp.h"
struct pi_cmp_data {
   unsigned char type ;
   unsigned char flags ;
   unsigned int version ;
   int baudrate ;
};
#line 30 "../include/pi-hinote.h"
struct HiNoteNote {
   int flags ;
   int level ;
   char *text ;
};
#line 36 "../include/pi-hinote.h"
struct HiNoteAppInfo {
   struct CategoryAppInfo category ;
   unsigned char reserved[48] ;
};
#line 34 "../include/pi-md5.h"
struct MD5Context {
   uint32_t buf[4] ;
   uint32_t bytes[2] ;
   uint32_t in[16] ;
};
#line 53 "../include/pi-location.h"
enum CompassDirection {
    north = 0,
    east = 1,
    south = 2,
    west = 3
} ;
#line 54 "../include/pi-location.h"
struct __anonstruct_EarthPoint_t_29 {
   int16_t degrees ;
   int16_t minutes ;
   enum CompassDirection direction ;
};
#line 54 "../include/pi-location.h"
typedef struct __anonstruct_EarthPoint_t_29 EarthPoint_t;
#line 71 "../include/pi-location.h"
struct __anonstruct_Location_t_31 {
   Timezone_t tz ;
   uint8_t unknownExists ;
   uint8_t unknown ;
   EarthPoint_t latitude ;
   EarthPoint_t longitude ;
   char *note ;
};
#line 71 "../include/pi-location.h"
typedef struct __anonstruct_Location_t_31 Location_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 90 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 27 "../include/pi-macros.h"
typedef unsigned long recordid_t;
#line 238 "../include/pi-dlp.h"
struct DBInfo {
   int more ;
   char name[34] ;
   unsigned int flags ;
   unsigned int miscFlags ;
   unsigned int version ;
   unsigned long type ;
   unsigned long creator ;
   unsigned long modnum ;
   unsigned int index ;
   time_t createDate ;
   time_t modifyDate ;
   time_t backupDate ;
};
#line 257 "../include/pi-dlp.h"
struct DBSizeInfo {
   unsigned long numRecords ;
   unsigned long totalBytes ;
   unsigned long dataBytes ;
   unsigned long appBlockSize ;
   unsigned long sortBlockSize ;
   unsigned long maxRecSize ;
};
#line 55 "../include/pi-file.h"
struct pi_file_entry {
   int offset ;
   int size ;
   int resource_id ;
   int attrs ;
   unsigned long type ;
   recordid_t uid ;
};
#line 55 "../include/pi-file.h"
typedef struct pi_file_entry pi_file_entry_t;
#line 64 "../include/pi-file.h"
struct pi_file {
   int err ;
   int for_writing ;
   int app_info_size ;
   int sort_info_size ;
   int next_record_list_id ;
   int resource_flag ;
   int ent_hdr_size ;
   int num_entries ;
   int num_entries_allocated ;
   int rbuf_size ;
   FILE *f ;
   pi_buffer_t *tmpbuf ;
   char *file_name ;
   void *app_info ;
   void *sort_info ;
   void *rbuf ;
   unsigned long unique_id_seed ;
   struct DBInfo info ;
   struct pi_file_entry *entries ;
};
#line 64 "../include/pi-file.h"
typedef struct pi_file pi_file_t;
#line 94 "../include/pi-file.h"
struct __anonstruct_db_31 {
   pi_file_t *pf ;
   struct DBSizeInfo size ;
   int transferred_records ;
};
#line 94 "../include/pi-file.h"
struct __anonstruct_vfs_32 {
   char *path ;
   long total_bytes ;
};
#line 94 "../include/pi-file.h"
union __anonunion_data_30 {
   struct __anonstruct_db_31 db ;
   struct __anonstruct_vfs_32 vfs ;
};
#line 94 "../include/pi-file.h"
struct __anonstruct_pi_progress_t_29 {
   int type ;
   int transferred_bytes ;
   void *userinfo ;
   union __anonunion_data_30 data ;
};
#line 94 "../include/pi-file.h"
typedef struct __anonstruct_pi_progress_t_29 pi_progress_t;
#line 117 "../include/pi-dlp.h"
typedef unsigned long FileRef;
#line 120 "../include/pi-dlp.h"
struct VFSDirInfo {
   unsigned long attr ;
   char name[256] ;
};
#line 126 "../include/pi-dlp.h"
struct VFSAnyMountParam {
   unsigned short volRefNum ;
   unsigned short reserved ;
   unsigned long mountClass ;
};
#line 133 "../include/pi-dlp.h"
struct VFSSlotMountParam {
   struct VFSAnyMountParam vfsMountParam ;
   unsigned short slotLibRefNum ;
   unsigned short slotRefNum ;
};
#line 140 "../include/pi-dlp.h"
struct VFSInfo {
   unsigned long attributes ;
   unsigned long fsType ;
   unsigned long fsCreator ;
   unsigned long mountClass ;
   int slotLibRefNum ;
   int slotRefNum ;
   unsigned long mediaType ;
   unsigned long reserved ;
};
#line 206 "../include/pi-dlp.h"
struct PilotUser {
   size_t passwordLength ;
   char username[128] ;
   char password[128] ;
   unsigned long userID ;
   unsigned long viewerID ;
   unsigned long lastSyncPC ;
   time_t successfulSyncDate ;
   time_t lastSyncDate ;
};
#line 271 "../include/pi-dlp.h"
struct CardInfo {
   int card ;
   int version ;
   int more ;
   time_t creation ;
   unsigned long romSize ;
   unsigned long ramSize ;
   unsigned long ramFree ;
   char name[128] ;
   char manufacturer[128] ;
};
#line 287 "../include/pi-dlp.h"
struct NetSyncInfo {
   int lanSync ;
   char hostName[256] ;
   char hostAddress[40] ;
   char hostSubnetMask[40] ;
};
#line 295
enum dlpFunctions {
    dlpReservedFunc = 15,
    dlpFuncReadUserInfo = 16,
    dlpFuncWriteUserInfo = 17,
    dlpFuncReadSysInfo = 18,
    dlpFuncGetSysDateTime = 19,
    dlpFuncSetSysDateTime = 20,
    dlpFuncReadStorageInfo = 21,
    dlpFuncReadDBList = 22,
    dlpFuncOpenDB = 23,
    dlpFuncCreateDB = 24,
    dlpFuncCloseDB = 25,
    dlpFuncDeleteDB = 26,
    dlpFuncReadAppBlock = 27,
    dlpFuncWriteAppBlock = 28,
    dlpFuncReadSortBlock = 29,
    dlpFuncWriteSortBlock = 30,
    dlpFuncReadNextModifiedRec = 31,
    dlpFuncReadRecord = 32,
    dlpFuncWriteRecord = 33,
    dlpFuncDeleteRecord = 34,
    dlpFuncReadResource = 35,
    dlpFuncWriteResource = 36,
    dlpFuncDeleteResource = 37,
    dlpFuncCleanUpDatabase = 38,
    dlpFuncResetSyncFlags = 39,
    dlpFuncCallApplication = 40,
    dlpFuncResetSystem = 41,
    dlpFuncAddSyncLogEntry = 42,
    dlpFuncReadOpenDBInfo = 43,
    dlpFuncMoveCategory = 44,
    dlpProcessRPC = 45,
    dlpFuncOpenConduit = 46,
    dlpFuncEndOfSync = 47,
    dlpFuncResetRecordIndex = 48,
    dlpFuncReadRecordIDList = 49,
    dlpFuncReadNextRecInCategory = 50,
    dlpFuncReadNextModifiedRecInCategory = 51,
    dlpFuncReadAppPreference = 52,
    dlpFuncWriteAppPreference = 53,
    dlpFuncReadNetSyncInfo = 54,
    dlpFuncWriteNetSyncInfo = 55,
    dlpFuncReadFeature = 56,
    dlpFuncFindDB = 57,
    dlpFuncSetDBInfo = 58,
    dlpLoopBackTest = 59,
    dlpFuncExpSlotEnumerate = 60,
    dlpFuncExpCardPresent = 61,
    dlpFuncExpCardInfo = 62,
    dlpFuncVFSCustomControl = 63,
    dlpFuncVFSGetDefaultDir = 64,
    dlpFuncVFSImportDatabaseFromFile = 65,
    dlpFuncVFSExportDatabaseToFile = 66,
    dlpFuncVFSFileCreate = 67,
    dlpFuncVFSFileOpen = 68,
    dlpFuncVFSFileClose = 69,
    dlpFuncVFSFileWrite = 70,
    dlpFuncVFSFileRead = 71,
    dlpFuncVFSFileDelete = 72,
    dlpFuncVFSFileRename = 73,
    dlpFuncVFSFileEOF = 74,
    dlpFuncVFSFileTell = 75,
    dlpFuncVFSFileGetAttributes = 76,
    dlpFuncVFSFileSetAttributes = 77,
    dlpFuncVFSFileGetDate = 78,
    dlpFuncVFSFileSetDate = 79,
    dlpFuncVFSDirCreate = 80,
    dlpFuncVFSDirEntryEnumerate = 81,
    dlpFuncVFSGetFile = 82,
    dlpFuncVFSPutFile = 83,
    dlpFuncVFSVolumeFormat = 84,
    dlpFuncVFSVolumeEnumerate = 85,
    dlpFuncVFSVolumeInfo = 86,
    dlpFuncVFSVolumeGetLabel = 87,
    dlpFuncVFSVolumeSetLabel = 88,
    dlpFuncVFSVolumeSize = 89,
    dlpFuncVFSFileSeek = 90,
    dlpFuncVFSFileResize = 91,
    dlpFuncVFSFileSize = 92,
    dlpFuncExpSlotMediaType = 93,
    dlpFuncWriteRecordEx = 94,
    dlpFuncWriteResourceEx = 95,
    dlpFuncReadRecordEx = 96,
    dlpFuncUnknown1 = 97,
    dlpFuncUnknown3 = 98,
    dlpFuncUnknown4 = 99,
    dlpFuncReadResourceEx = 100,
    dlpLastFunc = 101
} ;
#line 554
enum dlpErrors {
    dlpErrNoError = 0,
    dlpErrSystem = 1,
    dlpErrIllegalReq = 2,
    dlpErrMemory = 3,
    dlpErrParam = 4,
    dlpErrNotFound = 5,
    dlpErrNoneOpen = 6,
    dlpErrAlreadyOpen = 7,
    dlpErrTooManyOpen = 8,
    dlpErrExists = 9,
    dlpErrOpen = 10,
    dlpErrDeleted = 11,
    dlpErrBusy = 12,
    dlpErrNotSupp = 13,
    dlpErrUnused1 = 14,
    dlpErrReadOnly = 15,
    dlpErrSpace = 16,
    dlpErrLimit = 17,
    dlpErrSync = 18,
    dlpErrWrapper = 19,
    dlpErrArgument = 20,
    dlpErrSize = 21,
    dlpErrUnknown = 127
} ;
#line 585 "../include/pi-dlp.h"
struct dlpArg {
   int id_ ;
   size_t len ;
   char *data ;
};
#line 592 "../include/pi-dlp.h"
struct dlpRequest {
   enum dlpFunctions cmd ;
   int argc ;
   struct dlpArg **argv ;
};
#line 599 "../include/pi-dlp.h"
struct dlpResponse {
   enum dlpFunctions cmd ;
   enum dlpErrors err ;
   int argc ;
   struct dlpArg **argv ;
};
#line 33 "../include/pi-todo.h"
enum __anonenum_todoType_25 {
    todo_v1 = 0
} ;
#line 33 "../include/pi-todo.h"
typedef enum __anonenum_todoType_25 todoType;
#line 37 "../include/pi-todo.h"
struct ToDo {
   int indefinite ;
   struct tm due ;
   int priority ;
   int complete ;
   char *description ;
   char *note ;
};
#line 37 "../include/pi-todo.h"
typedef struct ToDo ToDo_t;
#line 46 "../include/pi-todo.h"
struct ToDoAppInfo {
   todoType type ;
   struct CategoryAppInfo category ;
   int dirty ;
   int sortByPriority ;
};
#line 46 "../include/pi-todo.h"
typedef struct ToDoAppInfo ToDoAppInfo_t;
#line 32 "../include/pi-datebook.h"
enum __anonenum_datebookType_25 {
    datebook_v1 = 0
} ;
#line 32 "../include/pi-datebook.h"
typedef enum __anonenum_datebookType_25 datebookType;
#line 41
enum repeatTypes {
    repeatNone = 0,
    repeatDaily = 1,
    repeatWeekly = 2,
    repeatMonthlyByDay = 3,
    repeatMonthlyByDate = 4,
    repeatYearly = 5
} ;
#line 55
enum DayOfMonthType {
    dom1stSun = 0,
    dom1stMon = 1,
    dom1stTue = 2,
    dom1stWen = 3,
    dom1stThu = 4,
    dom1stFri = 5,
    dom1stSat = 6,
    dom2ndSun = 7,
    dom2ndMon = 8,
    dom2ndTue = 9,
    dom2ndWen = 10,
    dom2ndThu = 11,
    dom2ndFri = 12,
    dom2ndSat = 13,
    dom3rdSun = 14,
    dom3rdMon = 15,
    dom3rdTue = 16,
    dom3rdWen = 17,
    dom3rdThu = 18,
    dom3rdFri = 19,
    dom3rdSat = 20,
    dom4thSun = 21,
    dom4thMon = 22,
    dom4thTue = 23,
    dom4thWen = 24,
    dom4thThu = 25,
    dom4thFri = 26,
    dom4thSat = 27,
    domLastSun = 28,
    domLastMon = 29,
    domLastTue = 30,
    domLastWen = 31,
    domLastThu = 32,
    domLastFri = 33,
    domLastSat = 34
} ;
#line 73 "../include/pi-datebook.h"
struct Appointment {
   int event ;
   struct tm begin ;
   struct tm end ;
   int alarm ;
   int advance ;
   int advanceUnits ;
   enum repeatTypes repeatType ;
   int repeatForever ;
   struct tm repeatEnd ;
   int repeatFrequency ;
   enum DayOfMonthType repeatDay ;
   int repeatDays[7] ;
   int repeatWeekstart ;
   int exceptions ;
   struct tm *exception ;
   char *description ;
   char *note ;
};
#line 92 "../include/pi-datebook.h"
struct AppointmentAppInfo {
   struct CategoryAppInfo category ;
   int startOfWeek ;
};
#line 33 "../include/pi-sys.h"
struct pi_sys_data {
   unsigned char txid ;
};
#line 33 "../include/pi-sys.h"
typedef struct pi_sys_data pi_sys_data_t;
#line 35 "../include/pi-versamail.h"
struct VersaMail {
   unsigned long imapuid ;
   struct tm date ;
   unsigned int category ;
   unsigned int accountNo ;
   unsigned int unknown1 ;
   unsigned int download ;
   unsigned int mark ;
   unsigned int unknown2 ;
   unsigned int reserved1 ;
   unsigned int reserved2 ;
   unsigned int read ;
   unsigned int msgSize ;
   unsigned int attachmentCount ;
   char *messageUID ;
   char *to ;
   char *from ;
   char *cc ;
   char *bcc ;
   char *subject ;
   char *dateString ;
   char *body ;
   char *replyTo ;
   void *unknown3 ;
   unsigned int unknown3length ;
};
#line 62 "../include/pi-versamail.h"
struct VersaMailAppInfo {
   struct CategoryAppInfo category ;
};
#line 29 "/usr/include/iconv.h"
typedef void *iconv_t;
#line 34 "../include/pi-sync.h"
struct _SyncHandler;
#line 34 "../include/pi-sync.h"
typedef struct _SyncHandler SyncHandler;
#line 35
struct _DesktopRecord;
#line 35 "../include/pi-sync.h"
typedef struct _DesktopRecord DesktopRecord;
#line 36
struct _PilotRecord;
#line 36 "../include/pi-sync.h"
typedef struct _PilotRecord PilotRecord;
#line 38 "../include/pi-sync.h"
struct _DesktopRecord {
   int recID ;
   int catID ;
   int flags ;
};
#line 44 "../include/pi-sync.h"
struct _PilotRecord {
   recordid_t recID ;
   int catID ;
   int flags ;
   void *buffer ;
   size_t len ;
};
#line 52 "../include/pi-sync.h"
struct _SyncHandler {
   int sd ;
   char *name ;
   int secret ;
   void *data ;
   int (*Pre)(SyncHandler * , int dbhandle , int *slow ) ;
   int (*Post)(SyncHandler * , int dbhandle ) ;
   int (*SetPilotID)(SyncHandler * , DesktopRecord * , recordid_t  ) ;
   int (*SetStatusCleared)(SyncHandler * , DesktopRecord * ) ;
   int (*ForEach)(SyncHandler * , DesktopRecord ** ) ;
   int (*ForEachModified)(SyncHandler * , DesktopRecord ** ) ;
   int (*Compare)(SyncHandler * , PilotRecord * , DesktopRecord * ) ;
   int (*AddRecord)(SyncHandler * , PilotRecord * ) ;
   int (*ReplaceRecord)(SyncHandler * , DesktopRecord * , PilotRecord * ) ;
   int (*DeleteRecord)(SyncHandler * , DesktopRecord * ) ;
   int (*ArchiveRecord)(SyncHandler * , DesktopRecord * , int archive ) ;
   int (*Match)(SyncHandler * , PilotRecord * , DesktopRecord ** ) ;
   int (*FreeMatch)(SyncHandler * , DesktopRecord * ) ;
   int (*Prepare)(SyncHandler * , DesktopRecord * , PilotRecord * ) ;
};
#line 32 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
enum __anonenum_RecordModifier_24 {
    PILOT = 0,
    DESKTOP = 1,
    BOTH = 2
} ;
#line 32 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
typedef enum __anonenum_RecordModifier_24 RecordModifier;
#line 38
struct _RecordQueueList;
#line 38 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
typedef struct _RecordQueueList RecordQueueList;
#line 39
struct _RecordQueue;
#line 39 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
typedef struct _RecordQueue RecordQueue;
#line 41 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
struct _RecordQueueList {
   DesktopRecord *drecord ;
   PilotRecord *precord ;
   RecordQueueList *next ;
};
#line 48 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
struct _RecordQueue {
   int count ;
   RecordQueueList *rql ;
};
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 49 "../include/pi-debug.h"
int pi_debug_get_types(void) ;
#line 52
int pi_debug_get_level(void) ;
#line 57
void pi_log(int type , int level , char const   *format  , ...) ;
#line 62
void pi_dumpdata(char const   *buf___3 , size_t len ) ;
#line 79 "../include/pi-buffer.h"
pi_buffer_t *pi_buffer_new(size_t capacity ) ;
#line 136
void pi_buffer_free(pi_buffer_t *buf___3 ) ;
#line 253 "../include/pi-socket.h"
int pi_getsockopt(int pi_sd , int level , int option_name , void *option_value , size_t *option_len ) ;
#line 269
int pi_setsockopt(int pi_sd , int level , int option_name , void const   *option_value ,
                  size_t *option_len ) ;
#line 283
struct pi_protocol *pi_protocol(int pi_sd , int level ) ;
#line 299
struct pi_protocol *pi_protocol_next(int pi_sd , int level ) ;
#line 481
int pi_set_error(int pi_sd , int error_code ) ;
#line 51 "../include/pi-net.h"
pi_protocol_t *net_protocol(void) ;
#line 54
int net_rx_handshake(pi_socket_t *ps ) ;
#line 56
int net_tx_handshake(pi_socket_t *ps ) ;
#line 58
ssize_t net_tx(pi_socket_t *ps , unsigned char const   *msg , size_t len , int flags ) ;
#line 61
ssize_t net_rx(pi_socket_t *ps , pi_buffer_t *msg , size_t len , int flags ) ;
#line 65
void net_dump_header(unsigned char *data , int rxtx , int sd ) ;
#line 67
void net_dump(unsigned char *header , unsigned char *data ) ;
#line 42 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static int net_flush(pi_socket_t *ps , int flags ) ;
#line 43
static int net_getsockopt(pi_socket_t *ps , int level , int option_name , void *option_value ,
                          size_t *option_len ) ;
#line 45
static int net_setsockopt(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                          size_t *option_len ) ;
#line 59 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static pi_protocol_t *net_protocol_dup(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  pi_net_data_t *data ;
  pi_net_data_t *new_data ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 62
  new_prot = (pi_protocol_t *)((void *)0);
#line 63
  data = (pi_net_data_t *)((void *)0);
#line 63
  new_data = (pi_net_data_t *)((void *)0);
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 66
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c",
             66, "prot != NULL");
      }
    }
#line 66
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 68
  tmp = malloc(sizeof(pi_protocol_t ));
#line 68
  new_prot = (pi_protocol_t *)tmp;
  }
#line 69
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
    {
#line 70
    tmp___0 = malloc(sizeof(pi_net_data_t ));
#line 70
    new_data = (pi_net_data_t *)tmp___0;
    }
#line 71
    if ((unsigned long )new_data == (unsigned long )((void *)0)) {
      {
#line 72
      free((void *)new_prot);
#line 73
      new_prot = (pi_protocol_t *)((void *)0);
      }
    }
  }
#line 77
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 77
    if ((unsigned long )new_data != (unsigned long )((void *)0)) {
#line 78
      new_prot->level = prot->level;
#line 79
      new_prot->dup = prot->dup;
#line 80
      new_prot->free = prot->free;
#line 81
      new_prot->read = prot->read;
#line 82
      new_prot->write = prot->write;
#line 83
      new_prot->flush = prot->flush;
#line 84
      new_prot->getsockopt = prot->getsockopt;
#line 85
      new_prot->setsockopt = prot->setsockopt;
#line 87
      data = (pi_net_data_t *)prot->data;
#line 88
      new_data->type = data->type;
#line 89
      new_data->split_writes = data->split_writes;
#line 90
      new_data->write_chunksize = data->write_chunksize;
#line 91
      new_data->txid = data->txid;
#line 92
      new_prot->data = (void *)new_data;
    }
  }
#line 95
  return (new_prot);
}
}
#line 110 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static void net_protocol_free(pi_protocol_t *prot ) 
{ 


  {
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 113
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c",
             113, "prot != NULL");
      }
    }
#line 113
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 116
    if ((unsigned long )prot->data != (unsigned long )((void *)0)) {
      {
#line 117
      free(prot->data);
      }
    }
    {
#line 118
    free((void *)prot);
    }
  }
#line 120
  return;
}
}
#line 134 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
pi_protocol_t *net_protocol(void) 
{ 
  pi_protocol_t *prot ;
  pi_net_data_t *data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 137
  prot = (pi_protocol_t *)((void *)0);
#line 138
  data = (pi_net_data_t *)((void *)0);
#line 140
  tmp = malloc(sizeof(pi_protocol_t ));
#line 140
  prot = (pi_protocol_t *)tmp;
  }
#line 141
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
    {
#line 142
    tmp___0 = malloc(sizeof(pi_net_data_t ));
#line 142
    data = (pi_net_data_t *)tmp___0;
    }
#line 143
    if ((unsigned long )data == (unsigned long )((void *)0)) {
      {
#line 144
      free((void *)prot);
#line 145
      prot = (pi_protocol_t *)((void *)0);
      }
    }
  }
#line 149
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 149
    if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 150
      prot->level = 3;
#line 151
      prot->dup = & net_protocol_dup;
#line 152
      prot->free = & net_protocol_free;
#line 153
      prot->read = & net_rx;
#line 154
      prot->write = & net_tx;
#line 155
      prot->flush = & net_flush;
#line 156
      prot->getsockopt = & net_getsockopt;
#line 157
      prot->setsockopt = & net_setsockopt;
#line 159
      data->type = 1;
#line 160
      data->split_writes = 1;
#line 161
      data->write_chunksize = (size_t )4096;
#line 162
      data->txid = (unsigned char)0;
#line 163
      prot->data = (void *)data;
    }
  }
#line 166
  return (prot);
}
}
#line 184 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static unsigned char const   msg1[51]  = 
#line 184
  {      (unsigned char const   )'\022',      (unsigned char const   )'\001',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )' ',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'$',      (unsigned char const   )'\377',      (unsigned char const   )'\377', 
        (unsigned char const   )'\377',      (unsigned char const   )'\377',      (unsigned char const   )'<',      (unsigned char const   )'\000', 
        (unsigned char const   )'<',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\300',      (unsigned char const   )'\250', 
        (unsigned char const   )'\245',      (unsigned char const   )'\037',      (unsigned char const   )'\004',      (unsigned char const   )'\'', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000'};
#line 189 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static unsigned char const   msg2[47]  = 
#line 189
  {      (unsigned char const   )'\023',      (unsigned char const   )'\001',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )' ',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )' ',      (unsigned char const   )'\377',      (unsigned char const   )'\377', 
        (unsigned char const   )'\377',      (unsigned char const   )'\377',      (unsigned char const   )'\000',      (unsigned char const   )'<', 
        (unsigned char const   )'\000',      (unsigned char const   )'<',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\001',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000'};
#line 181 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
int net_rx_handshake(pi_socket_t *ps ) 
{ 
  pi_buffer_t *buffer ;
  int err ;
  int *tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;

  {
  {
#line 197
  buffer = pi_buffer_new((size_t )256);
  }
#line 198
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 199
    tmp = __errno_location();
#line 199
    *tmp = 12;
#line 200
    tmp___0 = pi_set_error(ps->sd, -500);
    }
#line 200
    return (tmp___0);
  }
  {
#line 203
  tmp___1 = net_rx(ps, buffer, (size_t )256, 0);
#line 203
  err = (int )tmp___1;
  }
#line 203
  if (err >= 0) {
    {
#line 203
    tmp___2 = net_tx(ps, msg1, (size_t )50, 0);
#line 203
    err = (int )tmp___2;
    }
#line 203
    if (err >= 0) {
      {
#line 203
      tmp___3 = net_rx(ps, buffer, (size_t )50, 0);
#line 203
      err = (int )tmp___3;
      }
#line 203
      if (err >= 0) {
        {
#line 203
        tmp___4 = net_tx(ps, msg2, (size_t )46, 0);
#line 203
        err = (int )tmp___4;
        }
#line 203
        if (err >= 0) {
          {
#line 203
          tmp___5 = net_rx(ps, buffer, (size_t )8, 0);
#line 203
          err = (int )tmp___5;
          }
#line 203
          if (err >= 0) {
            {
#line 209
            pi_buffer_free(buffer);
            }
#line 210
            return (0);
          }
        }
      }
    }
  }
  {
#line 213
  pi_buffer_free(buffer);
  }
#line 214
  return (err);
}
}
#line 232 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static unsigned char const   msg1___0[23]  = 
#line 232
  {      (unsigned char const   )'\220',      (unsigned char const   )'\001',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )' ',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\b',      (unsigned char const   )'\001',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000'};
#line 235 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static unsigned char const   msg2___0[51]  = 
#line 235
  {      (unsigned char const   )'\222',      (unsigned char const   )'\001',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )' ',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'$',      (unsigned char const   )'\377',      (unsigned char const   )'\377', 
        (unsigned char const   )'\377',      (unsigned char const   )'\377',      (unsigned char const   )'\000',      (unsigned char const   )'<', 
        (unsigned char const   )'\000',      (unsigned char const   )'<',      (unsigned char const   )'@',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\001',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\300',      (unsigned char const   )'\250', 
        (unsigned char const   )'\245',      (unsigned char const   )'\036',      (unsigned char const   )'\004',      (unsigned char const   )'\001', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000'};
#line 240 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static unsigned char const   msg3[9]  = 
#line 240
  {      (unsigned char const   )'\223',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000'};
#line 229 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
int net_tx_handshake(pi_socket_t *ps ) 
{ 
  pi_buffer_t *buffer ;
  int err ;
  int *tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;

  {
  {
#line 245
  buffer = pi_buffer_new((size_t )256);
  }
#line 246
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 247
    tmp = __errno_location();
#line 247
    *tmp = 12;
#line 248
    tmp___0 = pi_set_error(ps->sd, -500);
    }
#line 248
    return (tmp___0);
  }
  {
#line 251
  tmp___1 = net_tx(ps, msg1___0, (size_t )22, 0);
#line 251
  err = (int )tmp___1;
  }
#line 251
  if (err >= 0) {
    {
#line 251
    tmp___2 = net_rx(ps, buffer, (size_t )256, 0);
#line 251
    err = (int )tmp___2;
    }
#line 251
    if (err >= 0) {
      {
#line 251
      tmp___3 = net_tx(ps, msg2___0, (size_t )50, 0);
#line 251
      err = (int )tmp___3;
      }
#line 251
      if (err >= 0) {
        {
#line 251
        tmp___4 = net_rx(ps, buffer, (size_t )256, 0);
#line 251
        err = (int )tmp___4;
        }
#line 251
        if (err >= 0) {
          {
#line 251
          tmp___5 = net_tx(ps, msg3, (size_t )8, 0);
#line 251
          err = (int )tmp___5;
          }
#line 251
          if (err >= 0) {
            {
#line 257
            pi_buffer_free(buffer);
            }
#line 258
            return (0);
          }
        }
      }
    }
  }
  {
#line 261
  pi_buffer_free(buffer);
  }
#line 262
  return (err);
}
}
#line 276 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static int net_flush(pi_socket_t *ps , int flags ) 
{ 
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 282
  prot = pi_protocol(ps->sd, 3);
  }
#line 283
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 284
    tmp = pi_set_error(ps->sd, -201);
    }
#line 284
    return (tmp);
  }
  {
#line 286
  next = pi_protocol_next(ps->sd, 3);
  }
#line 287
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 288
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 288
    return (tmp___0);
  }
  {
#line 290
  tmp___1 = (*(next->flush))(ps, flags);
  }
#line 290
  return (tmp___1);
}
}
#line 304 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
ssize_t net_tx(pi_socket_t *ps , unsigned char const   *msg , size_t len , int flags ) 
{ 
  int bytes ;
  int offset ;
  int remain ;
  int tosend ;
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  pi_net_data_t *data ;
  unsigned char *buf___3 ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 316
  prot = pi_protocol(ps->sd, 3);
  }
#line 317
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 318
    tmp = pi_set_error(ps->sd, -201);
    }
#line 318
    return ((ssize_t )tmp);
  }
  {
#line 319
  data = (pi_net_data_t *)prot->data;
#line 321
  next = pi_protocol_next(ps->sd, 3);
  }
#line 322
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 323
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 323
    return ((ssize_t )tmp___0);
  }
  {
#line 326
  tmp___1 = malloc(6UL + len);
#line 326
  buf___3 = (unsigned char *)tmp___1;
  }
#line 327
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
    {
#line 328
    tmp___2 = pi_set_error(ps->sd, -500);
    }
#line 328
    return ((ssize_t )tmp___2);
  }
#line 329
  *(buf___3 + 0) = (unsigned char )data->type;
#line 330
  if (data->type == 2) {
#line 331
    *(buf___3 + 1) = (unsigned char)255;
  } else {
#line 333
    *(buf___3 + 1) = data->txid;
  }
  {
#line 334
  *((buf___3 + 2) + 0) = (unsigned char )((int )((unsigned char )(len >> 24)) & 255);
#line 334
  *((buf___3 + 2) + 1) = (unsigned char )((len >> 16) & 255UL);
#line 334
  *((buf___3 + 2) + 2) = (unsigned char )((len >> 8) & 255UL);
#line 334
  *((buf___3 + 2) + 3) = (unsigned char )(len & 255UL);
#line 335
  memcpy((void */* __restrict  */)(buf___3 + 6), (void const   */* __restrict  */)msg,
         len);
  }
#line 342
  if (data->split_writes) {
    {
#line 352
    tmp___3 = (*(next->write))(ps, (unsigned char const   *)buf___3, (size_t )6, flags);
#line 352
    bytes = (int )tmp___3;
    }
#line 353
    if (bytes < 6) {
      {
#line 355
      free((void *)buf___3);
      }
#line 356
      return ((ssize_t )bytes);
    }
#line 358
    offset = 6;
#line 359
    remain = (int )len;
  } else {
#line 363
    offset = 0;
#line 364
    remain = (int )(6UL + len);
  }
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (! (remain > 0)) {
#line 367
      goto while_break;
    }
#line 369
    if (data->write_chunksize) {
#line 370
      if ((size_t )remain > data->write_chunksize) {
#line 370
        tosend = (int )data->write_chunksize;
      } else {
#line 370
        tosend = remain;
      }
    } else {
#line 372
      tosend = remain;
    }
    {
#line 374
    tmp___4 = (*(next->write))(ps, (unsigned char const   *)(buf___3 + offset), (size_t )tosend,
                               flags);
#line 374
    bytes = (int )tmp___4;
    }
#line 375
    if (bytes < tosend) {
      {
#line 377
      free((void *)buf___3);
      }
#line 378
      return ((ssize_t )bytes);
    }
#line 380
    remain -= bytes;
#line 381
    offset += bytes;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 384
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 384
    tmp___5 = pi_debug_get_types();
    }
#line 384
    if (tmp___5 & 32) {
      {
#line 384
      tmp___6 = pi_debug_get_level();
      }
#line 384
      if (tmp___6 >= 4) {
        {
#line 384
        net_dump_header(buf___3, 1, ps->sd);
        }
      }
    }
#line 384
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 385
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 385
    tmp___7 = pi_debug_get_types();
    }
#line 385
    if (tmp___7 & 32) {
      {
#line 385
      tmp___8 = pi_debug_get_level();
      }
#line 385
      if (tmp___8 >= 8) {
        {
#line 385
        pi_dumpdata((char const   *)((char *)msg), len);
        }
      }
    }
#line 385
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 387
  free((void *)buf___3);
  }
#line 388
  return ((ssize_t )len);
}
}
#line 406 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
ssize_t net_rx(pi_socket_t *ps , pi_buffer_t *msg , size_t len , int flags ) 
{ 
  int bytes ;
  int total_bytes ;
  int packet_len ;
  int timeout ;
  int honor_rx_timeout ;
  size_t size ;
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  pi_buffer_t *header ;
  pi_net_data_t *data ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  ssize_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 420
  prot = pi_protocol(ps->sd, 3);
  }
#line 421
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 422
    tmp = pi_set_error(ps->sd, -201);
    }
#line 422
    return ((ssize_t )tmp);
  }
  {
#line 424
  data = (pi_net_data_t *)prot->data;
#line 425
  next = pi_protocol_next(ps->sd, 3);
  }
#line 426
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 427
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 427
    return ((ssize_t )tmp___0);
  }
  {
#line 429
  size = sizeof(honor_rx_timeout);
#line 430
  pi_getsockopt(ps->sd, 7, 1, (void *)(& honor_rx_timeout), & size);
  }
#line 433
  if (honor_rx_timeout) {
#line 433
    timeout = 30000;
  } else {
#line 433
    timeout = 0;
  }
  {
#line 434
  size = sizeof(timeout);
#line 435
  pi_setsockopt(ps->sd, 0, 3, (void const   *)(& timeout), & size);
#line 438
  header = pi_buffer_new((size_t )6);
  }
#line 439
  if ((unsigned long )header == (unsigned long )((void *)0)) {
    {
#line 440
    tmp___1 = __errno_location();
#line 440
    *tmp___1 = 12;
#line 441
    tmp___2 = pi_set_error(ps->sd, -500);
    }
#line 441
    return ((ssize_t )tmp___2);
  }
#line 448
  total_bytes = 0;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (! (! total_bytes)) {
#line 449
      goto while_break;
    }
#line 450
    if ((int )data->txid == 0) {
      {
#line 452
      tmp___3 = (*(next->read))(ps, header, (size_t )1, flags);
#line 452
      bytes = (int )tmp___3;
      }
#line 453
      if (bytes <= 0) {
        {
#line 454
        pi_buffer_free(header);
        }
#line 455
        return ((ssize_t )bytes);
      }
      {
#line 458
      pi_log(32, 4, "NET RX (%i): Checking for headerless packet %d\n", ps->sd, (int )*(header->data + 0));
      }
#line 462
      if ((int )*(header->data + 0) == 144) {
        {
#line 464
        pi_log(32, 4, "NET RX (%i): Headerless packet\n", ps->sd);
#line 467
        total_bytes = 6;
#line 468
        *(header->data + 0) = (unsigned char)1;
#line 469
        *(header->data + 1) = (unsigned char)1;
#line 470
        *((header->data + 2) + 0) = (unsigned char )((int )((unsigned char )(21UL >> 24)) & 255);
#line 470
        *((header->data + 2) + 1) = (unsigned char )((21UL >> 16) & 255UL);
#line 470
        *((header->data + 2) + 2) = (unsigned char )((21UL >> 8) & 255UL);
#line 470
        *((header->data + 2) + 3) = (unsigned char)21;
        }
#line 471
        goto while_break;
      } else {
#line 473
        total_bytes += bytes;
      }
    }
    {
#line 478
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 478
      if (! (total_bytes < 6)) {
#line 478
        goto while_break___0;
      }
      {
#line 479
      tmp___4 = (*(next->read))(ps, header, (size_t )(6 - total_bytes), flags);
#line 479
      bytes = (int )tmp___4;
      }
#line 481
      if (bytes <= 0) {
        {
#line 482
        pi_buffer_free(header);
        }
#line 483
        return ((ssize_t )bytes);
      }
#line 485
      total_bytes += bytes;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 488
    packet_len = (int )(((((unsigned long )*((header->data + 2) + 0) << 24) | ((unsigned long )*((header->data + 2) + 1) << 16)) | ((unsigned long )*((header->data + 2) + 2) << 8)) | (unsigned long )*((header->data + 2) + 3));
#line 489
    data->type = (int )*(header->data + 0);
    {
#line 492
    if (data->type == 2) {
#line 492
      goto case_2;
    }
#line 508
    if (data->type == 1) {
#line 508
      goto case_1;
    }
#line 512
    goto switch_default;
    case_2: /* CIL Label */ 
#line 493
    if (packet_len != 0) {
      {
#line 494
      pi_log(32, 1, "NET RX (%i): tickle packet with non-zero length\n", ps->sd);
#line 497
      pi_buffer_free(header);
#line 498
      tmp___5 = pi_set_error(ps->sd, -102);
      }
#line 498
      return ((ssize_t )tmp___5);
    }
    {
#line 501
    pi_log(32, 8, "NET RX (%i): received tickle packet\n", ps->sd);
#line 504
    total_bytes = 0;
#line 505
    header->used = (size_t )0;
    }
#line 506
    goto switch_break;
    case_1: /* CIL Label */ 
#line 510
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 513
    pi_log(32, 1, "NET RX (%i): Unknown packet type\n", ps->sd);
    }
    {
#line 516
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 516
      tmp___6 = pi_debug_get_types();
      }
#line 516
      if (tmp___6 & 32) {
        {
#line 516
        tmp___7 = pi_debug_get_level();
        }
#line 516
        if (tmp___7 >= 4) {
          {
#line 516
          pi_dumpdata((char const   *)((char *)header->data), (size_t )6);
          }
        }
      }
#line 516
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 517
    pi_buffer_free(header);
#line 518
    tmp___8 = pi_set_error(ps->sd, -102);
    }
#line 518
    return ((ssize_t )tmp___8);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  total_bytes = 0;
#line 523
  packet_len = (int )(((((unsigned long )*((header->data + 2) + 0) << 24) | ((unsigned long )*((header->data + 2) + 1) << 16)) | ((unsigned long )*((header->data + 2) + 2) << 8)) | (unsigned long )*((header->data + 2) + 3));
#line 526
  if (packet_len < 0) {
    {
#line 528
    (*(next->flush))(ps, 1);
#line 529
    pi_log(32, 1, "NET RX (%i): Invalid packet length (%ld)\n", ps->sd, packet_len);
#line 530
    pi_buffer_free(header);
#line 531
    tmp___9 = pi_set_error(ps->sd, -102);
    }
#line 531
    return ((ssize_t )tmp___9);
  } else
#line 526
  if ((long )packet_len > 1048576L) {
    {
#line 528
    (*(next->flush))(ps, 1);
#line 529
    pi_log(32, 1, "NET RX (%i): Invalid packet length (%ld)\n", ps->sd, packet_len);
#line 530
    pi_buffer_free(header);
#line 531
    tmp___9 = pi_set_error(ps->sd, -102);
    }
#line 531
    return ((ssize_t )tmp___9);
  }
  {
#line 535
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 535
    if (! (total_bytes < packet_len)) {
#line 535
      goto while_break___2;
    }
    {
#line 536
    tmp___10 = (*(next->read))(ps, msg, (size_t )(packet_len - total_bytes), flags);
#line 536
    bytes = (int )tmp___10;
    }
#line 538
    if (bytes < 0) {
      {
#line 539
      pi_buffer_free(header);
      }
#line 540
      return ((ssize_t )bytes);
    }
#line 542
    total_bytes += bytes;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 545
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 545
    tmp___11 = pi_debug_get_types();
    }
#line 545
    if (tmp___11 & 32) {
      {
#line 545
      tmp___12 = pi_debug_get_level();
      }
#line 545
      if (tmp___12 >= 4) {
        {
#line 545
        net_dump_header(header->data, 0, ps->sd);
        }
      }
    }
#line 545
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 546
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 546
    tmp___13 = pi_debug_get_types();
    }
#line 546
    if (tmp___13 & 32) {
      {
#line 546
      tmp___14 = pi_debug_get_level();
      }
#line 546
      if (tmp___14 >= 8) {
        {
#line 546
        net_dump(header->data, msg->data);
        }
      }
    }
#line 546
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 549
  if (ps->state == 4) {
#line 550
    data->txid = *(header->data + 1);
  } else
#line 549
  if (ps->command == 1) {
#line 550
    data->txid = *(header->data + 1);
  } else {
#line 552
    data->txid = (unsigned char )((int )data->txid + 1);
#line 553
    if ((int )data->txid == 255) {
#line 554
      data->txid = (unsigned char)1;
    }
  }
  {
#line 557
  pi_buffer_free(header);
  }
#line 558
  return ((ssize_t )packet_len);
}
}
#line 572 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static int net_getsockopt(pi_socket_t *ps , int level , int option_name , void *option_value ,
                          size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  pi_net_data_t *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 579
  prot = pi_protocol(ps->sd, 3);
  }
#line 580
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 581
    tmp = pi_set_error(ps->sd, -201);
    }
#line 581
    return (tmp);
  }
#line 583
  data = (pi_net_data_t *)prot->data;
  {
#line 586
  if (option_name == 0) {
#line 586
    goto case_0;
  }
#line 585
  goto switch_break;
  case_0: /* CIL Label */ 
#line 587
  if (*option_len != sizeof(data->type)) {
    {
#line 588
    tmp___0 = __errno_location();
#line 588
    *tmp___0 = 22;
#line 589
    tmp___1 = pi_set_error(ps->sd, -501);
    }
#line 589
    return (tmp___1);
  }
  {
#line 591
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->type),
         sizeof(data->type));
#line 593
  *option_len = sizeof(data->type);
  }
#line 594
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 597
  return (0);
}
}
#line 612 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static int net_setsockopt(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                          size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  pi_net_data_t *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 619
  prot = pi_protocol(ps->sd, 3);
  }
#line 620
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 621
    tmp = pi_set_error(ps->sd, -201);
    }
#line 621
    return (tmp);
  }
#line 623
  data = (pi_net_data_t *)prot->data;
  {
#line 626
  if (option_name == 0) {
#line 626
    goto case_0;
  }
#line 639
  if (option_name == 1) {
#line 639
    goto case_1;
  }
#line 653
  if (option_name == 2) {
#line 653
    goto case_2;
  }
#line 625
  goto switch_break;
  case_0: /* CIL Label */ 
#line 627
  if (*option_len != sizeof(data->type)) {
    {
#line 628
    tmp___0 = __errno_location();
#line 628
    *tmp___0 = 22;
#line 629
    tmp___1 = pi_set_error(ps->sd, -501);
    }
#line 629
    return (tmp___1);
  }
  {
#line 631
  memcpy((void */* __restrict  */)(& data->type), (void const   */* __restrict  */)option_value,
         sizeof(data->type));
  }
#line 633
  goto switch_break;
  case_1: /* CIL Label */ 
#line 640
  if (*option_len != sizeof(data->split_writes)) {
    {
#line 641
    tmp___2 = __errno_location();
#line 641
    *tmp___2 = 22;
#line 642
    tmp___3 = pi_set_error(ps->sd, -501);
    }
#line 642
    return (tmp___3);
  }
  {
#line 644
  memcpy((void */* __restrict  */)(& data->split_writes), (void const   */* __restrict  */)option_value,
         sizeof(data->split_writes));
  }
#line 646
  goto switch_break;
  case_2: /* CIL Label */ 
#line 654
  if (*option_len != sizeof(data->write_chunksize)) {
    {
#line 655
    tmp___4 = __errno_location();
#line 655
    *tmp___4 = 22;
#line 656
    tmp___5 = pi_set_error(ps->sd, -501);
    }
#line 656
    return (tmp___5);
  }
  {
#line 658
  memcpy((void */* __restrict  */)(& data->write_chunksize), (void const   */* __restrict  */)option_value,
         sizeof(data->write_chunksize));
  }
#line 660
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 663
  return (0);
}
}
#line 677 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
void net_dump_header(unsigned char *data , int rxtx , int sd ) 
{ 
  char const   *tmp ;

  {
#line 680
  if (rxtx) {
#line 680
    tmp = "TX";
  } else {
#line 680
    tmp = "RX";
  }
  {
#line 680
  pi_log(32, 0, "NET %s sd=%i type=%d txid=0x%.2x len=0x%.4x\n", tmp, sd, (int )*((data + 0) + 0),
         (int )*((data + 1) + 0), ((((unsigned long )*((data + 2) + 0) << 24) | ((unsigned long )*((data + 2) + 1) << 16)) | ((unsigned long )*((data + 2) + 2) << 8)) | (unsigned long )*((data + 2) + 3));
  }
#line 687
  return;
}
}
#line 701 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
void net_dump(unsigned char *header , unsigned char *data ) 
{ 
  size_t size ;

  {
  {
#line 706
  size = ((((unsigned long )*((header + 2) + 0) << 24) | ((unsigned long )*((header + 2) + 1) << 16)) | ((unsigned long )*((header + 2) + 2) << 8)) | (unsigned long )*((header + 2) + 3);
#line 707
  pi_dumpdata((char const   *)((char *)data), size);
  }
#line 708
  return;
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) frexp)(double __x ,
                                                                               int *__exponent ) ;
#line 106
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ldexp)(double __x ,
                                                                               int __exponent ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 33 "../include/pi-macros.h"
double get_float(void *buffer ) ;
#line 34
void set_float(void *buffer , double value ) ;
#line 35
int compareTm(struct tm *a , struct tm *b ) ;
#line 140 "../include/pi-source.h"
int crc16(unsigned char *ptr , int count ) ;
#line 141
char *printlong(unsigned long val ) ;
#line 142
unsigned long makelong(char *c ) ;
#line 41 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/utils.c"
void pi_timeout_to_timespec(int timeout , struct timespec *ts ) ;
#line 42
void get_pilot_rate(int *establishrate , int *establishhighrate ) ;
#line 43
int pi_timespec_to_timeout(struct timespec  const  *ts ) ;
#line 44
int pi_timeout_expired(struct timespec  const  *ts ) ;
#line 45
size_t palm_strftime(char *s , size_t max , char const   *fmt , struct tm  const  *tm ) ;
#line 61 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/utils.c"
int crc16(unsigned char *ptr , int count ) 
{ 
  int crc ;
  int i ;
  unsigned char *tmp ;

  {
#line 66
  crc = 0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    count --;
#line 67
    if (! (count >= 0)) {
#line 67
      goto while_break;
    }
#line 68
    tmp = ptr;
#line 68
    ptr ++;
#line 68
    crc ^= (int )*tmp << 8;
#line 69
    i = 0;
    {
#line 69
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 69
      if (! (i < 8)) {
#line 69
        goto while_break___0;
      }
#line 70
      if (crc & 32768) {
#line 71
        crc = (crc << 1) ^ 4129;
      } else {
#line 73
        crc <<= 1;
      }
#line 69
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  return (crc & 65535);
}
}
#line 78 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/utils.c"
void get_pilot_rate(int *establishrate , int *establishhighrate ) 
{ 
  char *rate_env ;
  char *tmp ;

  {
  {
#line 81
  tmp = getenv("PILOTRATE");
#line 81
  rate_env = tmp;
  }
#line 82
  if (rate_env) {
#line 84
    if ((int )*(rate_env + 0) == 72) {
      {
#line 85
      *establishrate = atoi((char const   *)(rate_env + 1));
#line 86
      *establishhighrate = 1;
      }
    } else {
      {
#line 88
      *establishrate = atoi((char const   *)rate_env);
#line 89
      *establishhighrate = 0;
      }
    }
  } else {
#line 93
    *establishrate = -1;
  }
#line 95
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/utils.c"
static char buf[5]  ;
#line 289 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/utils.c"
char *printlong(unsigned long val ) 
{ 


  {
#line 293
  *((unsigned char *)(buf) + 0) = (unsigned char )((int )((unsigned char )(val >> 24)) & 255);
#line 293
  *((unsigned char *)(buf) + 1) = (unsigned char )((val >> 16) & 255UL);
#line 293
  *((unsigned char *)(buf) + 2) = (unsigned char )((val >> 8) & 255UL);
#line 293
  *((unsigned char *)(buf) + 3) = (unsigned char )(val & 255UL);
#line 294
  buf[4] = (char)0;
#line 295
  return (buf);
}
}
#line 298 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/utils.c"
unsigned long makelong(char *c ) 
{ 
  int l ;
  size_t tmp ;
  char c2[4] ;

  {
  {
#line 300
  tmp = strlen((char const   *)c);
#line 300
  l = (int )tmp;
  }
#line 303
  if (l >= 4) {
#line 304
    return (((((unsigned long )*((unsigned char *)c + 0) << 24) | ((unsigned long )*((unsigned char *)c + 1) << 16)) | ((unsigned long )*((unsigned char *)c + 2) << 8)) | (unsigned long )*((unsigned char *)c + 3));
  }
  {
#line 305
  memset((void *)(c2), ' ', (size_t )4);
#line 306
  memcpy((void */* __restrict  */)(c2), (void const   */* __restrict  */)c, (size_t )l);
  }
#line 307
  return (((((unsigned long )*((unsigned char *)(c2) + 0) << 24) | ((unsigned long )*((unsigned char *)(c2) + 1) << 16)) | ((unsigned long )*((unsigned char *)(c2) + 2) << 8)) | (unsigned long )*((unsigned char *)(c2) + 3));
}
}
#line 310 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/utils.c"
double get_float(void *buffer ) 
{ 
  unsigned char *buf___3 ;
  unsigned long frac ;
  int expr ;
  int tmp ;
  int sign ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 312
  buf___3 = (unsigned char *)buffer;
#line 313
  frac = ((((unsigned long )*(buf___3 + 0) << 24) | ((unsigned long )*(buf___3 + 1) << 16)) | ((unsigned long )*(buf___3 + 2) << 8)) | (unsigned long )*(buf___3 + 3);
#line 315
  if ((int )((unsigned short )(((int )*((buf___3 + 4) + 0) << 8) | (int )*((buf___3 + 4) + 1))) > 32767) {
#line 315
    tmp = (int )((short )((int )((unsigned short )(((int )*((buf___3 + 4) + 0) << 8) | (int )*((buf___3 + 4) + 1))) & 32767)) - 32768;
  } else {
#line 315
    tmp = (int )((short )((unsigned short )(((int )*((buf___3 + 4) + 0) << 8) | (int )*((buf___3 + 4) + 1))));
  }
#line 315
  expr = (int )((short )tmp);
#line 315
  sign = (int )*((buf___3 + 6) + 0);
#line 319
  if (sign) {
#line 319
    tmp___0 = (double )frac;
  } else {
#line 319
    tmp___0 = - ((double )frac);
  }
  {
#line 319
  tmp___1 = ldexp(tmp___0, expr);
  }
#line 319
  return (tmp___1);
}
}
#line 322 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/utils.c"
void set_float(void *buffer , double value ) 
{ 
  int expr ;
  int sign ;
  unsigned char *buf___3 ;
  unsigned long frac ;
  double r ;
  double tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 326
  buf___3 = (unsigned char *)buffer;
#line 331
  if (value < (double )0) {
#line 332
    sign = 0;
#line 333
    value = - value;
  } else {
#line 335
    sign = 255;
  }
  {
#line 338
  tmp = frexp(value, & expr);
#line 338
  r = ldexp(tmp, 32);
#line 339
  frac = (unsigned long )r;
#line 340
  expr -= 32;
#line 343
  *(buf___3 + 0) = (unsigned char )((int )((unsigned char )(frac >> 24)) & 255);
#line 343
  *(buf___3 + 1) = (unsigned char )((frac >> 16) & 255UL);
#line 343
  *(buf___3 + 2) = (unsigned char )((frac >> 8) & 255UL);
#line 343
  *(buf___3 + 3) = (unsigned char )(frac & 255UL);
  }
#line 344
  if ((int )((short )expr) < 0) {
#line 344
    tmp___0 = (int )((unsigned short )((int )((short )expr) + 32768)) | 32768;
  } else {
#line 344
    tmp___0 = expr;
  }
#line 344
  *((buf___3 + 4) + 0) = (unsigned char )(((int )((unsigned short )tmp___0) >> 8) & 255);
#line 344
  if ((int )((short )expr) < 0) {
#line 344
    tmp___1 = (int )((unsigned short )((int )((short )expr) + 32768)) | 32768;
  } else {
#line 344
    tmp___1 = expr;
  }
#line 344
  *((buf___3 + 4) + 1) = (unsigned char )((int )((unsigned short )tmp___1) & 255);
#line 345
  *((buf___3 + 6) + 0) = (unsigned char )sign;
#line 346
  *((buf___3 + 7) + 0) = (unsigned char)0;
#line 347
  return;
}
}
#line 349 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/utils.c"
int compareTm(struct tm *a , struct tm *b ) 
{ 
  int date ;

  {
#line 353
  date = a->tm_year - b->tm_year;
#line 354
  if (date) {
#line 355
    return (date);
  }
#line 356
  date = a->tm_mon - b->tm_mon;
#line 357
  if (date) {
#line 358
    return (date);
  }
#line 359
  date = a->tm_mday - b->tm_mday;
#line 360
  if (date) {
#line 361
    return (date);
  }
#line 362
  date = a->tm_hour - b->tm_hour;
#line 363
  if (date) {
#line 364
    return (date);
  }
#line 365
  date = a->tm_min - b->tm_min;
#line 366
  if (date) {
#line 367
    return (date);
  }
#line 368
  date = a->tm_sec - b->tm_sec;
#line 369
  return (date);
}
}
#line 372 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/utils.c"
void pi_timeout_to_timespec(int timeout , struct timespec *ts ) 
{ 
  struct timeval now ;

  {
  {
#line 376
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 377
  ts->tv_sec = now.tv_sec + (long )(timeout / 1000);
#line 378
  ts->tv_nsec = (now.tv_usec + ((long )timeout % 1000L) * 1000L) * 1000L;
  }
#line 379
  if (ts->tv_nsec >= 1000000000L) {
#line 380
    ts->tv_nsec -= 1000000000L;
#line 381
    (ts->tv_sec) ++;
  }
#line 383
  return;
}
}
#line 385 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/utils.c"
int pi_timespec_to_timeout(struct timespec  const  *ts ) 
{ 
  struct timeval now ;

  {
  {
#line 391
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
  }
#line 392
  return ((int )(((double )ts->tv_sec * 1000.0 + (double )ts->tv_nsec / 1000000.0) - ((double )now.tv_sec * 1000.0 + (double )now.tv_usec / 1000.0)));
}
}
#line 396 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/utils.c"
int pi_timeout_expired(struct timespec  const  *ts ) 
{ 
  int tmp ;

  {
  {
#line 398
  tmp = pi_timespec_to_timeout(ts);
  }
#line 398
  return (tmp <= 0);
}
}
#line 402 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/utils.c"
size_t palm_strftime(char *s , size_t max , char const   *fmt , struct tm  const  *tm ) 
{ 
  size_t tmp ;

  {
  {
#line 405
  tmp = strftime((char */* __restrict  */)s, max, (char const   */* __restrict  */)fmt,
                 (struct tm  const  */* __restrict  */)tm);
  }
#line 405
  return (tmp);
}
}
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 105 "../include/pi-buffer.h"
pi_buffer_t *pi_buffer_append(pi_buffer_t *buf___3 , void const   *data , size_t len ) ;
#line 456 "../include/pi-socket.h"
void pi_flush(int pi_sd , int flags ) ;
#line 69 "../include/pi-padp.h"
pi_protocol_t *padp_protocol(void) ;
#line 72
ssize_t padp_tx(pi_socket_t *ps , unsigned char const   *buf___3 , size_t len , int flags ) ;
#line 76
ssize_t padp_rx(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t expect , int flags ) ;
#line 80
void padp_dump_header(unsigned char const   *data , int rxtx ) ;
#line 82
void padp_dump(unsigned char const   *data ) ;
#line 45 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static int padp_flush(pi_socket_t *ps , int flags ) ;
#line 46
static int padp_getsockopt(pi_socket_t *ps , int level , int option_name , void *option_value ,
                           size_t *option_len ) ;
#line 48
static int padp_setsockopt(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                           size_t *option_len ) ;
#line 50
static int padp_sendack(struct pi_socket *ps , struct pi_padp_data *data , unsigned char txid ,
                        struct padp *padp , int flags ) ;
#line 65 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static pi_protocol_t *padp_protocol_dup(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  pi_padp_data_t *data ;
  pi_padp_data_t *new_data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 68
  new_prot = (pi_protocol_t *)((void *)0);
#line 69
  data = (pi_padp_data_t *)((void *)0);
#line 69
  new_data = (pi_padp_data_t *)((void *)0);
#line 72
  tmp = malloc(sizeof(pi_protocol_t ));
#line 72
  new_prot = (pi_protocol_t *)tmp;
  }
#line 73
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
    {
#line 74
    tmp___0 = malloc(sizeof(pi_padp_data_t ));
#line 74
    new_data = (pi_padp_data_t *)tmp___0;
    }
#line 75
    if ((unsigned long )new_data == (unsigned long )((void *)0)) {
      {
#line 76
      free((void *)new_prot);
#line 77
      new_prot = (pi_protocol_t *)((void *)0);
      }
    } else {
      {
#line 79
      new_prot->level = prot->level;
#line 80
      new_prot->dup = prot->dup;
#line 81
      new_prot->free = prot->free;
#line 82
      new_prot->read = prot->read;
#line 83
      new_prot->write = prot->write;
#line 84
      new_prot->flush = prot->flush;
#line 85
      new_prot->getsockopt = prot->getsockopt;
#line 86
      new_prot->setsockopt = prot->setsockopt;
#line 88
      data = (pi_padp_data_t *)prot->data;
#line 89
      memcpy((void */* __restrict  */)new_data, (void const   */* __restrict  */)data,
             sizeof(pi_padp_data_t ));
#line 90
      new_prot->data = (void *)new_data;
      }
    }
  }
#line 94
  return (new_prot);
}
}
#line 109 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static void padp_protocol_free(pi_protocol_t *prot ) 
{ 


  {
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 112
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c",
             112, "prot != NULL");
      }
    }
#line 112
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 115
    if ((unsigned long )prot->data != (unsigned long )((void *)0)) {
      {
#line 116
      free(prot->data);
      }
    }
    {
#line 117
    free((void *)prot);
    }
  }
#line 119
  return;
}
}
#line 133 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
pi_protocol_t *padp_protocol(void) 
{ 
  pi_protocol_t *prot ;
  pi_padp_data_t *data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 136
  prot = (pi_protocol_t *)((void *)0);
#line 137
  data = (pi_padp_data_t *)((void *)0);
#line 139
  tmp = malloc(sizeof(pi_protocol_t ));
#line 139
  prot = (pi_protocol_t *)tmp;
  }
#line 140
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
    {
#line 141
    tmp___0 = malloc(sizeof(pi_padp_data_t ));
#line 141
    data = (pi_padp_data_t *)tmp___0;
    }
#line 142
    if ((unsigned long )data == (unsigned long )((void *)0)) {
      {
#line 143
      free((void *)prot);
#line 144
      prot = (pi_protocol_t *)((void *)0);
      }
    } else {
#line 146
      prot->level = 2;
#line 147
      prot->dup = & padp_protocol_dup;
#line 148
      prot->free = & padp_protocol_free;
#line 149
      prot->read = & padp_rx;
#line 150
      prot->write = & padp_tx;
#line 151
      prot->flush = & padp_flush;
#line 152
      prot->getsockopt = & padp_getsockopt;
#line 153
      prot->setsockopt = & padp_setsockopt;
#line 155
      data->type = 1;
#line 156
      data->last_type = -1;
#line 157
      data->txid = (unsigned char)255;
#line 158
      data->next_txid = 255U;
#line 159
      data->freeze_txid = 0;
#line 160
      data->use_long_format = 0;
#line 161
      prot->data = (void *)data;
    }
  }
#line 165
  return (prot);
}
}
#line 179 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
ssize_t padp_tx(pi_socket_t *ps , unsigned char const   *buf___3 , size_t len , int flags ) 
{ 
  int fl ;
  int count ;
  int retries ;
  int result ;
  int type ;
  int socket___0 ;
  int timeout ;
  int header_size ;
  size_t size ;
  size_t tlen ;
  unsigned char txid ;
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  pi_padp_data_t *data ;
  pi_buffer_t *padp_buf ;
  struct padp padp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  ssize_t tmp___14 ;
  ssize_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  int *tmp___21 ;
  int *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;

  {
  {
#line 182
  fl = 128;
#line 182
  count = 0;
#line 198
  prot = pi_protocol(ps->sd, 2);
  }
#line 199
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 200
    tmp = pi_set_error(ps->sd, -201);
    }
#line 200
    return ((ssize_t )tmp);
  }
  {
#line 202
  data = (pi_padp_data_t *)prot->data;
#line 203
  next = pi_protocol_next(ps->sd, 2);
  }
#line 204
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 205
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 205
    return ((ssize_t )tmp___0);
  }
#line 207
  if (data->type == 257) {
#line 208
    data->txid = (unsigned char)255;
  }
#line 210
  if (! data->freeze_txid) {
#line 211
    if ((int )data->txid == 0) {
#line 212
      data->txid = (unsigned char)16;
    } else
#line 213
    if ((int )data->txid >= 254) {
#line 214
      data->next_txid = 1U;
    } else {
#line 216
      data->next_txid = (unsigned int )((int )data->txid + 1);
    }
  }
#line 219
  if (data->type != 2) {
#line 219
    if (ps->state == 2) {
#line 220
      data->txid = (unsigned char )data->next_txid;
    }
  }
  {
#line 222
  padp_buf = pi_buffer_new((size_t )1030);
  }
#line 223
  if ((unsigned long )padp_buf == (unsigned long )((void *)0)) {
    {
#line 224
    tmp___1 = pi_set_error(ps->sd, -500);
    }
#line 224
    return ((ssize_t )tmp___1);
  }
  {
#line 226
  pi_flush(ps->sd, 1);
  }
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    retries = 10;
    {
#line 230
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 231
      padp_buf->used = (size_t )0;
#line 233
      type = 2;
#line 234
      socket___0 = 3;
#line 235
      timeout = 2000;
#line 237
      size = sizeof(type);
#line 238
      pi_setsockopt(ps->sd, 1, 4, (void const   *)(& type), & size);
#line 239
      pi_setsockopt(ps->sd, 1, 0, (void const   *)(& socket___0), & size);
#line 240
      pi_setsockopt(ps->sd, 1, 2, (void const   *)(& socket___0), & size);
#line 241
      size = sizeof(timeout);
#line 242
      pi_setsockopt(ps->sd, 0, 3, (void const   *)(& timeout), & size);
#line 243
      size = sizeof(data->txid);
#line 244
      pi_setsockopt(ps->sd, 1, 6, (void const   *)(& data->txid), & size);
      }
#line 246
      if (len > 1024UL) {
#line 246
        tlen = (size_t )1024;
      } else {
#line 246
        tlen = len;
      }
#line 247
      if (data->use_long_format) {
#line 247
        header_size = 6;
      } else {
#line 247
        header_size = 4;
      }
#line 250
      *((padp_buf->data + 0) + 0) = (unsigned char )data->type;
#line 251
      if (len == tlen) {
#line 251
        tmp___2 = 64;
      } else {
#line 251
        tmp___2 = 0;
      }
#line 251
      if (data->use_long_format) {
#line 251
        tmp___3 = 16;
      } else {
#line 251
        tmp___3 = 0;
      }
#line 251
      *((padp_buf->data + 1) + 0) = (unsigned char )((fl | tmp___2) | tmp___3);
#line 254
      if (data->use_long_format) {
#line 255
        if (fl) {
#line 255
          tmp___4 = len;
        } else {
#line 255
          tmp___4 = (size_t )count;
        }
#line 255
        *((padp_buf->data + 2) + 0) = (unsigned char )((int )((unsigned char )(tmp___4 >> 24)) & 255);
#line 255
        if (fl) {
#line 255
          tmp___5 = len;
        } else {
#line 255
          tmp___5 = (size_t )count;
        }
#line 255
        *((padp_buf->data + 2) + 1) = (unsigned char )((tmp___5 >> 16) & 255UL);
#line 255
        if (fl) {
#line 255
          tmp___6 = len;
        } else {
#line 255
          tmp___6 = (size_t )count;
        }
#line 255
        *((padp_buf->data + 2) + 2) = (unsigned char )((tmp___6 >> 8) & 255UL);
#line 255
        if (fl) {
#line 255
          tmp___7 = len;
        } else {
#line 255
          tmp___7 = (size_t )count;
        }
#line 255
        *((padp_buf->data + 2) + 3) = (unsigned char )(tmp___7 & 255UL);
      } else {
#line 257
        if (fl) {
#line 257
          tmp___8 = len;
        } else {
#line 257
          tmp___8 = (size_t )count;
        }
#line 257
        *((padp_buf->data + 2) + 0) = (unsigned char )(((int )((unsigned short )tmp___8) >> 8) & 255);
#line 257
        if (fl) {
#line 257
          tmp___9 = len;
        } else {
#line 257
          tmp___9 = (size_t )count;
        }
#line 257
        *((padp_buf->data + 2) + 1) = (unsigned char )((int )((unsigned short )tmp___9) & 255);
      }
      {
#line 258
      memcpy((void */* __restrict  */)(padp_buf->data + header_size), (void const   */* __restrict  */)buf___3,
             tlen);
      }
      {
#line 260
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 260
        tmp___10 = pi_debug_get_types();
        }
#line 260
        if (tmp___10 & 8) {
          {
#line 260
          tmp___11 = pi_debug_get_level();
          }
#line 260
          if (tmp___11 >= 4) {
            {
#line 260
            padp_dump_header((unsigned char const   *)padp_buf->data, 1);
            }
          }
        }
#line 260
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 261
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 261
        tmp___12 = pi_debug_get_types();
        }
#line 261
        if (tmp___12 & 8) {
          {
#line 261
          tmp___13 = pi_debug_get_level();
          }
#line 261
          if (tmp___13 >= 8) {
            {
#line 261
            padp_dump((unsigned char const   *)padp_buf->data);
            }
          }
        }
#line 261
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 264
      tmp___14 = (*(next->write))(ps, (unsigned char const   *)padp_buf->data, (size_t )header_size + tlen,
                                  flags);
#line 264
      result = (int )tmp___14;
      }
#line 265
      if (result < 0) {
#line 266
        if (result == -200) {
#line 267
          goto disconnected;
        }
      }
#line 271
      if (data->type == 4) {
#line 272
        goto while_break___0;
      }
      keepwaiting: 
      {
#line 275
      pi_log(8, 8, "PADP TX waiting for ACK\n");
#line 276
      tmp___15 = (*(next->read))(ps, padp_buf, (size_t )1030, flags);
#line 276
      result = (int )tmp___15;
      }
#line 277
      if (result > 0) {
#line 278
        padp.type = *((padp_buf->data + 0) + 0);
#line 279
        padp.flags = *((padp_buf->data + 1) + 0);
#line 280
        if ((int )padp.flags & 16) {
#line 281
          header_size = 6;
#line 282
          padp.size = (int )(((((unsigned long )*((padp_buf->data + 2) + 0) << 24) | ((unsigned long )*((padp_buf->data + 2) + 1) << 16)) | ((unsigned long )*((padp_buf->data + 2) + 2) << 8)) | (unsigned long )*((padp_buf->data + 2) + 3));
        } else {
#line 284
          header_size = 4;
#line 285
          padp.size = (int )((unsigned short )(((int )*((padp_buf->data + 2) + 0) << 8) | (int )*((padp_buf->data + 2) + 1)));
        }
        {
#line 288
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 288
          tmp___16 = pi_debug_get_types();
          }
#line 288
          if (tmp___16 & 8) {
            {
#line 288
            tmp___17 = pi_debug_get_level();
            }
#line 288
            if (tmp___17 >= 4) {
              {
#line 288
              padp_dump_header((unsigned char const   *)padp_buf->data, 0);
              }
            }
          }
#line 288
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 289
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 289
          tmp___18 = pi_debug_get_types();
          }
#line 289
          if (tmp___18 & 8) {
            {
#line 289
            tmp___19 = pi_debug_get_level();
            }
#line 289
            if (tmp___19 >= 8) {
              {
#line 289
              padp_dump((unsigned char const   *)padp_buf->data);
              }
            }
          }
#line 289
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 291
        size = sizeof(type);
#line 292
        pi_getsockopt(ps->sd, 1, 5, (void *)(& type), & size);
#line 293
        size = sizeof(txid);
#line 294
        pi_getsockopt(ps->sd, 1, 7, (void *)(& txid), & size);
        }
#line 296
        if (type == 2) {
#line 296
          if ((int )padp.type == 1) {
#line 296
            if ((int )txid == (int )data->txid) {
#line 296
              if (len == tlen) {
                {
#line 305
                pi_log(8, 2, "PADP TX Missing Ack\n");
#line 307
                count = (int )((size_t )count + tlen);
                }
#line 308
                goto done;
              } else {
#line 296
                goto _L___7;
              }
            } else {
#line 296
              goto _L___7;
            }
          } else {
#line 296
            goto _L___7;
          }
        } else
        _L___7: /* CIL Label */ 
#line 309
        if ((int )padp.type == 4) {
#line 311
          goto keepwaiting;
        } else
#line 312
        if (type == 2) {
#line 312
          if ((int )padp.type == 2) {
#line 312
            if ((int )txid == (int )data->txid) {
#line 315
              if ((int )padp.flags & 32) {
                {
#line 317
                pi_log(8, 2, "PADP TX Memory Error\n");
#line 326
                tmp___20 = __errno_location();
#line 326
                *tmp___20 = 90;
#line 327
                count = -1;
                }
#line 328
                goto done;
              }
              {
#line 332
              buf___3 += tlen;
#line 333
              len -= tlen;
#line 334
              count = (int )((size_t )count + tlen);
#line 335
              fl = 0;
#line 336
              pi_log(8, 8, "PADP TX got ACK\n");
              }
#line 337
              goto while_break___0;
            } else {
#line 312
              goto _L___4;
            }
          } else {
#line 312
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 338
        if (type == 2) {
#line 338
          if ((int )padp.type == (int )data->last_ack_padp.type) {
#line 338
            if ((int )padp.flags == (int )data->last_ack_padp.flags) {
#line 338
              if (padp.size == data->last_ack_padp.size) {
#line 338
                if ((int )txid == (int )data->last_ack_txid) {
                  {
#line 345
                  pi_log(8, 2, "PADP TX resending lost ACK\n");
#line 347
                  padp_sendack(ps, data, txid, & padp, flags);
                  }
#line 348
                  goto __Cont;
                } else {
#line 338
                  goto _L___2;
                }
              } else {
#line 338
                goto _L___2;
              }
            } else {
#line 338
              goto _L___2;
            }
          } else {
#line 338
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
          {
#line 350
          pi_log(8, 1, "PADP TX Unexpected packet (possible port speed problem? out of sync packet?)\n");
#line 354
          padp_dump_header(buf___3, 1);
#line 356
          tmp___21 = __errno_location();
#line 356
          *tmp___21 = 5;
#line 357
          count = -1;
          }
#line 358
          goto done;
        }
      } else
#line 361
      if (result == -200) {
#line 362
        goto disconnected;
      }
      __Cont: /* CIL Label */ 
#line 230
      retries --;
#line 230
      if (! (retries > 0)) {
#line 230
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 366
    if (retries == 0) {
      {
#line 369
      pi_log(8, 1, "PADP TX too many retries");
#line 370
      tmp___22 = __errno_location();
#line 370
      *tmp___22 = 110;
#line 371
      pi_buffer_free(padp_buf);
#line 372
      ps->state = 8;
#line 373
      tmp___23 = pi_set_error(ps->sd, -200);
      }
#line 373
      return ((ssize_t )tmp___23);
    }
#line 228
    if (! len) {
#line 228
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 378
  if (data->type != 2) {
#line 378
    if (ps->state == 4) {
#line 379
      data->txid = (unsigned char )data->next_txid;
    }
  }
  {
#line 380
  pi_buffer_free(padp_buf);
  }
#line 381
  return ((ssize_t )count);
  disconnected: 
  {
#line 384
  pi_log(8, 1, "PADP TX disconnected");
#line 385
  pi_buffer_free(padp_buf);
#line 386
  ps->state = 8;
#line 387
  tmp___24 = pi_set_error(ps->sd, -200);
  }
#line 387
  return ((ssize_t )tmp___24);
}
}
#line 402 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
ssize_t padp_rx(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t expect , int flags ) 
{ 
  int bytes ;
  int offset ;
  int ouroffset ;
  int honor_rx_timeout ;
  int type ;
  int timeout ;
  int header_size ;
  unsigned char txid ;
  size_t total_bytes ;
  size_t size ;
  pi_protocol_t *next ;
  pi_protocol_t *prot ;
  pi_padp_data_t *data ;
  struct padp padp ;
  pi_buffer_t *padp_buf ;
  time_t endtime ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  time_t tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  time_t tmp___6 ;
  ssize_t tmp___7 ;
  int *tmp___8 ;
  time_t tmp___9 ;
  time_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  pi_buffer_t *tmp___17 ;
  time_t tmp___18 ;
  int *tmp___19 ;
  int tmp___20 ;
  time_t tmp___21 ;
  ssize_t tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int *tmp___28 ;
  time_t tmp___29 ;

  {
  {
#line 405
  offset = 0;
#line 405
  ouroffset = 0;
#line 421
  pi_log(8, 8, "PADP RX expect=%d flags=0x%04x\n", expect, flags);
#line 424
  prot = pi_protocol(ps->sd, 2);
  }
#line 425
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 426
    tmp = pi_set_error(ps->sd, -201);
    }
#line 426
    return ((ssize_t )tmp);
  }
  {
#line 428
  data = (pi_padp_data_t *)prot->data;
#line 429
  next = pi_protocol_next(ps->sd, 2);
  }
#line 430
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 431
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 431
    return ((ssize_t )tmp___0);
  }
  {
#line 433
  size = sizeof(honor_rx_timeout);
#line 434
  pi_getsockopt(ps->sd, 7, 1, (void *)(& honor_rx_timeout), & size);
#line 437
  padp_buf = pi_buffer_new((size_t )1028);
  }
#line 438
  if ((unsigned long )padp_buf == (unsigned long )((void *)0)) {
    {
#line 439
    tmp___1 = __errno_location();
#line 439
    *tmp___1 = 12;
#line 440
    tmp___2 = pi_set_error(ps->sd, -500);
    }
#line 440
    return ((ssize_t )tmp___2);
  }
#line 446
  if (! data->freeze_txid) {
#line 447
    if (ps->state == 2) {
#line 448
      if ((int )data->txid >= 254) {
#line 449
        data->next_txid = 1U;
      } else {
#line 451
        data->next_txid = (unsigned int )((int )data->txid + 1);
      }
    } else {
#line 453
      data->next_txid = (unsigned int )data->txid;
    }
  }
  {
#line 456
  tmp___3 = time((time_t *)((void *)0));
#line 456
  endtime = tmp___3 + 30L;
  }
  {
#line 458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 459
    if (honor_rx_timeout) {
      {
#line 459
      tmp___6 = time((time_t *)((void *)0));
      }
#line 459
      if (tmp___6 > endtime) {
        {
#line 460
        pi_log(8, 1, "PADP RX Timed out");
#line 463
        tmp___4 = __errno_location();
#line 463
        *tmp___4 = 110;
#line 464
        ps->state = 8;
#line 465
        pi_buffer_free(padp_buf);
#line 466
        tmp___5 = pi_set_error(ps->sd, -200);
        }
#line 466
        return ((ssize_t )tmp___5);
      }
    }
#line 469
    if (honor_rx_timeout) {
#line 469
      timeout = 32000;
    } else {
#line 469
      timeout = 0;
    }
    {
#line 470
    size = sizeof(timeout);
#line 471
    pi_setsockopt(ps->sd, 0, 3, (void const   *)(& timeout), & size);
#line 474
    total_bytes = (size_t )0;
#line 475
    padp_buf->used = (size_t )0;
#line 476
    header_size = 4;
    }
    {
#line 477
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 477
      if (! (total_bytes < (size_t )header_size)) {
#line 477
        goto while_break___0;
      }
      {
#line 478
      tmp___7 = (*(next->read))(ps, padp_buf, ((size_t )header_size + 1024UL) - total_bytes,
                                flags);
#line 478
      bytes = (int )tmp___7;
      }
#line 480
      if (bytes < 0) {
        {
#line 481
        pi_log(8, 1, "PADP RX Read Error\n");
#line 482
        pi_buffer_free(padp_buf);
        }
#line 483
        return ((ssize_t )bytes);
      }
#line 485
      total_bytes += (size_t )bytes;
#line 488
      if (header_size == 4) {
#line 488
        if (total_bytes >= 4UL) {
#line 488
          if ((int )*(padp_buf->data + 1) & 16) {
#line 491
            header_size += 2;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 495
    padp.type = *(padp_buf->data + 0);
#line 496
    padp.flags = *(padp_buf->data + 1);
#line 497
    if ((int )padp.flags & 16) {
#line 498
      padp.size = (int )(((((unsigned long )*((padp_buf->data + 2) + 0) << 24) | ((unsigned long )*((padp_buf->data + 2) + 1) << 16)) | ((unsigned long )*((padp_buf->data + 2) + 2) << 8)) | (unsigned long )*((padp_buf->data + 2) + 3));
    } else {
#line 500
      padp.size = (int )((unsigned short )(((int )*((padp_buf->data + 2) + 0) << 8) | (int )*((padp_buf->data + 2) + 1)));
    }
    {
#line 502
    size = sizeof(type);
#line 503
    pi_getsockopt(ps->sd, 1, 5, (void *)(& type), & size);
#line 504
    size = sizeof(txid);
#line 505
    pi_getsockopt(ps->sd, 1, 7, (void *)(& txid), & size);
    }
#line 507
    if ((int )padp.flags & 32) {
#line 508
      if ((int )txid == (int )data->txid) {
        {
#line 509
        pi_log(8, 2, "PADP RX Memory Error\n");
#line 511
        tmp___8 = __errno_location();
#line 511
        *tmp___8 = 90;
#line 512
        ouroffset = -1;
        }
#line 513
        goto done;
      }
#line 522
      goto __Cont;
    } else
#line 523
    if ((int )padp.type == 4) {
      {
#line 525
      pi_log(8, 2, "PADP RX Got Tickled\n");
#line 527
      tmp___9 = time((time_t *)((void *)0));
#line 527
      endtime = tmp___9 + 30L;
      }
#line 528
      goto __Cont;
    } else
#line 529
    if (type != 2) {
      {
#line 533
      pi_log(8, 1, "PADP RX Wrong packet type on queue(possible port speed problem? (loc1))\n");
      }
#line 536
      goto __Cont;
    } else
#line 529
    if ((int )padp.type != 1) {
      {
#line 533
      pi_log(8, 1, "PADP RX Wrong packet type on queue(possible port speed problem? (loc1))\n");
      }
#line 536
      goto __Cont;
    } else
#line 529
    if ((int )txid != (int )data->txid) {
      {
#line 533
      pi_log(8, 1, "PADP RX Wrong packet type on queue(possible port speed problem? (loc1))\n");
      }
#line 536
      goto __Cont;
    } else
#line 529
    if (! ((int )padp.flags & 128)) {
      {
#line 533
      pi_log(8, 1, "PADP RX Wrong packet type on queue(possible port speed problem? (loc1))\n");
      }
#line 536
      goto __Cont;
    }
#line 538
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 542
  tmp___10 = time((time_t *)((void *)0));
#line 542
  endtime = tmp___10 + 30L;
  }
  {
#line 544
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 545
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 545
      tmp___11 = pi_debug_get_types();
      }
#line 545
      if (tmp___11 & 8) {
        {
#line 545
        tmp___12 = pi_debug_get_level();
        }
#line 545
        if (tmp___12 >= 4) {
          {
#line 545
          padp_dump_header((unsigned char const   *)padp_buf->data, 0);
          }
        }
      }
#line 545
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 546
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 546
      tmp___13 = pi_debug_get_types();
      }
#line 546
      if (tmp___13 & 8) {
        {
#line 546
        tmp___14 = pi_debug_get_level();
        }
#line 546
        if (tmp___14 >= 8) {
          {
#line 546
          padp_dump((unsigned char const   *)padp_buf->data);
          }
        }
      }
#line 546
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 549
    padp_sendack(ps, data, data->txid, & padp, flags);
    }
#line 552
    if ((int )padp.flags & 128) {
#line 552
      offset = 0;
    } else {
#line 552
      offset = padp.size;
    }
#line 553
    total_bytes -= 4UL;
#line 556
    if (offset == ouroffset) {
      {
#line 557
      tmp___17 = pi_buffer_append(buf___3, (void const   *)(padp_buf->data + header_size),
                                  total_bytes);
      }
#line 557
      if ((unsigned long )tmp___17 == (unsigned long )((void *)0)) {
        {
#line 558
        tmp___15 = __errno_location();
#line 558
        *tmp___15 = 12;
#line 559
        tmp___16 = pi_set_error(ps->sd, -500);
        }
#line 559
        return ((ssize_t )tmp___16);
      }
#line 561
      ouroffset = (int )((size_t )ouroffset + total_bytes);
    }
#line 564
    if ((int )padp.flags & 64) {
#line 565
      goto while_break___1;
    }
    {
#line 567
    tmp___18 = time((time_t *)((void *)0));
#line 567
    endtime = tmp___18 + 30L;
    }
    {
#line 569
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 570
      if (honor_rx_timeout) {
        {
#line 570
        tmp___21 = time((time_t *)((void *)0));
        }
#line 570
        if (tmp___21 > endtime) {
          {
#line 571
          pi_log(8, 1, "PADP RX Segment Timeout");
#line 575
          tmp___19 = __errno_location();
#line 575
          *tmp___19 = 110;
#line 576
          ouroffset = -1;
#line 578
          ps->state = 8;
#line 579
          pi_buffer_free(padp_buf);
#line 580
          tmp___20 = pi_set_error(ps->sd, -200);
          }
#line 580
          return ((ssize_t )tmp___20);
        }
      }
#line 583
      if (honor_rx_timeout) {
#line 583
        timeout = 32000;
      } else {
#line 583
        timeout = 0;
      }
      {
#line 584
      size = sizeof(timeout);
#line 585
      pi_setsockopt(ps->sd, 0, 3, (void const   *)(& timeout), & size);
#line 587
      total_bytes = (size_t )0;
#line 588
      padp_buf->used = (size_t )0;
#line 589
      header_size = 4;
      }
      {
#line 591
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 591
        if (! (total_bytes < (size_t )header_size)) {
#line 591
          goto while_break___5;
        }
        {
#line 592
        tmp___22 = (*(next->read))(ps, padp_buf, (size_t )(header_size + 1024) - total_bytes,
                                   flags);
#line 592
        bytes = (int )tmp___22;
        }
#line 594
        if (bytes < 0) {
          {
#line 595
          pi_log(8, 1, "PADP RX Read Error");
#line 596
          pi_buffer_free(padp_buf);
#line 597
          tmp___23 = pi_set_error(ps->sd, bytes);
          }
#line 597
          return ((ssize_t )tmp___23);
        }
#line 599
        total_bytes += (size_t )bytes;
#line 602
        if (header_size == 4) {
#line 602
          if (total_bytes >= 4UL) {
#line 602
            if ((int )*(padp_buf->data + 1) & 16) {
#line 605
              header_size += 2;
            }
          }
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 609
      padp.type = *(padp_buf->data + 0);
#line 610
      padp.flags = *(padp_buf->data + 1);
#line 611
      if ((int )padp.flags & 16) {
#line 612
        padp.size = (int )(((((unsigned long )*((padp_buf->data + 2) + 0) << 24) | ((unsigned long )*((padp_buf->data + 2) + 1) << 16)) | ((unsigned long )*((padp_buf->data + 2) + 2) << 8)) | (unsigned long )*((padp_buf->data + 2) + 3));
      } else {
#line 614
        padp.size = (int )((unsigned short )(((int )*((padp_buf->data + 2) + 0) << 8) | (int )*((padp_buf->data + 2) + 1)));
      }
      {
#line 616
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 616
        tmp___24 = pi_debug_get_types();
        }
#line 616
        if (tmp___24 & 8) {
          {
#line 616
          tmp___25 = pi_debug_get_level();
          }
#line 616
          if (tmp___25 >= 4) {
            {
#line 616
            padp_dump_header((unsigned char const   *)padp_buf->data, 0);
            }
          }
        }
#line 616
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 617
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 617
        tmp___26 = pi_debug_get_types();
        }
#line 617
        if (tmp___26 & 8) {
          {
#line 617
          tmp___27 = pi_debug_get_level();
          }
#line 617
          if (tmp___27 >= 8) {
            {
#line 617
            padp_dump((unsigned char const   *)padp_buf->data);
            }
          }
        }
#line 617
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 619
      size = sizeof(type);
#line 620
      pi_getsockopt(ps->sd, 1, 5, (void *)(& type), & size);
#line 621
      size = sizeof(txid);
#line 622
      pi_getsockopt(ps->sd, 1, 7, (void *)(& txid), & size);
      }
#line 624
      if ((int )padp.flags & 32) {
#line 625
        if ((int )txid == (int )data->txid) {
          {
#line 631
          pi_log(8, 2, "PADP RX Memory Error");
#line 633
          tmp___28 = __errno_location();
#line 633
          *tmp___28 = 90;
#line 634
          ouroffset = -1;
          }
#line 635
          goto done;
        }
#line 637
        goto __Cont___0;
      }
#line 640
      if ((int )padp.type == 4) {
        {
#line 642
        tmp___29 = time((time_t *)((void *)0));
#line 642
        endtime = tmp___29 + 30L;
#line 644
        pi_log(8, 2, "PADP RX Got Tickled");
        }
#line 646
        goto __Cont___0;
      }
#line 649
      if (type != 2) {
        {
#line 653
        pi_log(8, 1, "PADP RX Wrong packet type on queue(possible port speed problem? (loc2))\n");
        }
#line 656
        goto __Cont___0;
      } else
#line 649
      if ((int )padp.type != 1) {
        {
#line 653
        pi_log(8, 1, "PADP RX Wrong packet type on queue(possible port speed problem? (loc2))\n");
        }
#line 656
        goto __Cont___0;
      } else
#line 649
      if ((int )txid != (int )data->txid) {
        {
#line 653
        pi_log(8, 1, "PADP RX Wrong packet type on queue(possible port speed problem? (loc2))\n");
        }
#line 656
        goto __Cont___0;
      } else
#line 649
      if ((int )padp.flags & 128) {
        {
#line 653
        pi_log(8, 1, "PADP RX Wrong packet type on queue(possible port speed problem? (loc2))\n");
        }
#line 656
        goto __Cont___0;
      }
#line 658
      goto while_break___4;
      __Cont___0: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  done: 
  {
#line 663
  data->txid = (unsigned char )data->next_txid;
#line 665
  pi_buffer_free(padp_buf);
  }
#line 667
  return ((ssize_t )ouroffset);
}
}
#line 681 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static int padp_flush(pi_socket_t *ps , int flags ) 
{ 
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 687
  prot = pi_protocol(ps->sd, 2);
  }
#line 688
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 689
    tmp = pi_set_error(ps->sd, -201);
    }
#line 689
    return (tmp);
  }
  {
#line 691
  next = pi_protocol_next(ps->sd, 2);
  }
#line 692
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 693
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 693
    return (tmp___0);
  }
  {
#line 695
  tmp___1 = (*(next->flush))(ps, flags);
  }
#line 695
  return (tmp___1);
}
}
#line 709 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static int padp_getsockopt(pi_socket_t *ps , int level , int option_name , void *option_value ,
                           size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  pi_padp_data_t *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 716
  prot = pi_protocol(ps->sd, 2);
  }
#line 717
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 718
    tmp = pi_set_error(ps->sd, -201);
    }
#line 718
    return (tmp);
  }
#line 719
  data = (pi_padp_data_t *)prot->data;
  {
#line 722
  if (option_name == 0) {
#line 722
    goto case_0;
  }
#line 728
  if (option_name == 1) {
#line 728
    goto case_1;
  }
#line 734
  if (option_name == 2) {
#line 734
    goto case_2;
  }
#line 740
  if (option_name == 3) {
#line 740
    goto case_3;
  }
#line 721
  goto switch_break;
  case_0: /* CIL Label */ 
#line 723
  if (*option_len != sizeof(data->type)) {
#line 724
    goto error;
  }
  {
#line 725
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->type),
         sizeof(data->type));
  }
#line 726
  goto switch_break;
  case_1: /* CIL Label */ 
#line 729
  if (*option_len != sizeof(data->last_type)) {
#line 730
    goto error;
  }
  {
#line 731
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->last_type),
         sizeof(data->last_type));
  }
#line 732
  goto switch_break;
  case_2: /* CIL Label */ 
#line 735
  if (*option_len != sizeof(data->freeze_txid)) {
#line 736
    goto error;
  }
  {
#line 737
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->freeze_txid),
         sizeof(data->freeze_txid));
  }
#line 738
  goto switch_break;
  case_3: /* CIL Label */ 
#line 741
  if (*option_len != sizeof(data->use_long_format)) {
#line 742
    goto error;
  }
  {
#line 743
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->use_long_format),
         sizeof(data->use_long_format));
  }
#line 744
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 747
  return (0);
  error: 
  {
#line 750
  tmp___0 = __errno_location();
#line 750
  *tmp___0 = 22;
#line 751
  tmp___1 = pi_set_error(ps->sd, -501);
  }
#line 751
  return (tmp___1);
}
}
#line 766 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static int padp_setsockopt(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                           size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  pi_padp_data_t *data ;
  int was_frozen ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 774
  prot = pi_protocol(ps->sd, 2);
  }
#line 775
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 776
    tmp = pi_set_error(ps->sd, -201);
    }
#line 776
    return (tmp);
  }
#line 777
  data = (pi_padp_data_t *)prot->data;
  {
#line 780
  if (option_name == 0) {
#line 780
    goto case_0;
  }
#line 786
  if (option_name == 2) {
#line 786
    goto case_2;
  }
#line 798
  if (option_name == 3) {
#line 798
    goto case_3;
  }
#line 779
  goto switch_break;
  case_0: /* CIL Label */ 
#line 781
  if (*option_len != sizeof(data->type)) {
#line 782
    goto error;
  }
  {
#line 783
  memcpy((void */* __restrict  */)(& data->type), (void const   */* __restrict  */)option_value,
         sizeof(data->type));
  }
#line 784
  goto switch_break;
  case_2: /* CIL Label */ 
#line 787
  if (*option_len != sizeof(data->freeze_txid)) {
#line 788
    goto error;
  }
  {
#line 789
  was_frozen = data->freeze_txid;
#line 790
  memcpy((void */* __restrict  */)(& data->freeze_txid), (void const   */* __restrict  */)option_value,
         sizeof(data->freeze_txid));
  }
#line 791
  if (was_frozen) {
#line 791
    if (! data->freeze_txid) {
#line 792
      (data->next_txid) ++;
#line 793
      if (data->next_txid >= 254U) {
#line 794
        data->next_txid = 1U;
      }
    }
  }
#line 796
  goto switch_break;
  case_3: /* CIL Label */ 
#line 799
  if (*option_len != sizeof(data->use_long_format)) {
#line 800
    goto error;
  }
  {
#line 801
  memcpy((void */* __restrict  */)(& data->use_long_format), (void const   */* __restrict  */)option_value,
         sizeof(data->use_long_format));
  }
#line 802
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 805
  return (0);
  error: 
  {
#line 808
  tmp___0 = __errno_location();
#line 808
  *tmp___0 = 22;
#line 809
  tmp___1 = pi_set_error(ps->sd, -501);
  }
#line 809
  return (tmp___1);
}
}
#line 823 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static int padp_sendack(struct pi_socket *ps , struct pi_padp_data *data , unsigned char txid ,
                        struct padp *padp , int flags ) 
{ 
  int type ;
  int socket___0 ;
  int result ;
  int header_size ;
  size_t size ;
  unsigned char npadp_buf[6] ;
  struct pi_protocol *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;

  {
  {
#line 840
  next = pi_protocol_next(ps->sd, 2);
  }
#line 841
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 842
    tmp = pi_set_error(ps->sd, -201);
    }
#line 842
    return (tmp);
  }
  {
#line 844
  type = 2;
#line 845
  socket___0 = 3;
#line 846
  size = sizeof(type);
#line 847
  pi_setsockopt(ps->sd, 1, 4, (void const   *)(& type), & size);
#line 848
  pi_setsockopt(ps->sd, 1, 0, (void const   *)(& socket___0), & size);
#line 849
  pi_setsockopt(ps->sd, 1, 2, (void const   *)(& socket___0), & size);
#line 850
  size = sizeof(txid);
#line 851
  pi_setsockopt(ps->sd, 1, 6, (void const   *)(& txid), & size);
#line 853
  header_size = 4;
#line 854
  *(& npadp_buf[0] + 0) = (unsigned char)2;
#line 855
  *(& npadp_buf[1] + 0) = padp->flags;
  }
#line 856
  if ((int )padp->flags & 16) {
#line 857
    header_size += 2;
#line 858
    *(& npadp_buf[2] + 0) = (unsigned char )((int )((unsigned char )((unsigned long )padp->size >> 24)) & 255);
#line 858
    *(& npadp_buf[2] + 1) = (unsigned char )(((unsigned long )padp->size >> 16) & 255UL);
#line 858
    *(& npadp_buf[2] + 2) = (unsigned char )(((unsigned long )padp->size >> 8) & 255UL);
#line 858
    *(& npadp_buf[2] + 3) = (unsigned char )((unsigned long )padp->size & 255UL);
  } else {
#line 860
    *(& npadp_buf[2] + 0) = (unsigned char )(((int )((unsigned short )padp->size) >> 8) & 255);
#line 860
    *(& npadp_buf[2] + 1) = (unsigned char )((int )((unsigned short )padp->size) & 255);
  }
  {
#line 863
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 863
    tmp___0 = pi_debug_get_types();
    }
#line 863
    if (tmp___0 & 8) {
      {
#line 863
      tmp___1 = pi_debug_get_level();
      }
#line 863
      if (tmp___1 >= 4) {
        {
#line 863
        padp_dump_header((unsigned char const   *)(npadp_buf), 1);
        }
      }
    }
#line 863
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 864
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 864
    tmp___2 = pi_debug_get_types();
    }
#line 864
    if (tmp___2 & 8) {
      {
#line 864
      tmp___3 = pi_debug_get_level();
      }
#line 864
      if (tmp___3 >= 8) {
        {
#line 864
        padp_dump((unsigned char const   *)(npadp_buf));
        }
      }
    }
#line 864
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 866
  tmp___4 = (*(next->write))(ps, (unsigned char const   *)(npadp_buf), (size_t )header_size,
                             flags);
#line 866
  result = (int )tmp___4;
  }
#line 868
  if (result >= 0) {
#line 869
    data->last_ack_txid = txid;
#line 870
    data->last_ack_padp.type = padp->type;
#line 871
    data->last_ack_padp.flags = padp->flags;
#line 872
    data->last_ack_padp.size = padp->size;
  }
#line 875
  return (result);
}
}
#line 889 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
void padp_dump_header(unsigned char const   *data , int rxtx ) 
{ 
  long s ;
  char *stype ;
  unsigned char type ;
  unsigned char flags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
#line 896
  type = *((unsigned char *)(data + 0) + 0);
  {
#line 898
  if ((int )type == 1) {
#line 898
    goto case_1;
  }
#line 901
  if ((int )type == 2) {
#line 901
    goto case_2;
  }
#line 904
  if ((int )type == 4) {
#line 904
    goto case_4;
  }
#line 907
  if ((int )type == 8) {
#line 907
    goto case_8;
  }
#line 910
  goto switch_default;
  case_1: /* CIL Label */ 
#line 899
  stype = (char *)"DATA";
#line 900
  goto switch_break;
  case_2: /* CIL Label */ 
#line 902
  stype = (char *)"ACK";
#line 903
  goto switch_break;
  case_4: /* CIL Label */ 
#line 905
  stype = (char *)"TICKLE";
#line 906
  goto switch_break;
  case_8: /* CIL Label */ 
#line 908
  stype = (char *)"ABORT";
#line 909
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 911
  stype = (char *)"UNK";
#line 912
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 915
  flags = *((unsigned char *)(data + 1) + 0);
#line 916
  if ((int )flags & 16) {
#line 917
    s = (long )(((((unsigned long )*((unsigned char *)(data + 2) + 0) << 24) | ((unsigned long )*((unsigned char *)(data + 2) + 1) << 16)) | ((unsigned long )*((unsigned char *)(data + 2) + 2) << 8)) | (unsigned long )*((unsigned char *)(data + 2) + 3));
  } else {
#line 919
    s = (long )((unsigned short )(((int )*((unsigned char *)(data + 2) + 0) << 8) | (int )*((unsigned char *)(data + 2) + 1)));
  }
#line 921
  if ((int )flags & 32) {
#line 921
    tmp = 'M';
  } else {
#line 921
    tmp = ' ';
  }
#line 921
  if ((int )flags & 64) {
#line 921
    tmp___0 = 'L';
  } else {
#line 921
    tmp___0 = ' ';
  }
#line 921
  if ((int )flags & 128) {
#line 921
    tmp___1 = 'F';
  } else {
#line 921
    tmp___1 = ' ';
  }
#line 921
  if (rxtx) {
#line 921
    tmp___2 = "TX";
  } else {
#line 921
    tmp___2 = "RX";
  }
  {
#line 921
  pi_log(8, 0, "PADP %s %c%c%c type=%s len=%ld\n", tmp___2, tmp___1, tmp___0, tmp,
         stype, s);
  }
#line 928
  return;
}
}
#line 942 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
void padp_dump(unsigned char const   *data ) 
{ 
  size_t size ;
  unsigned char type ;
  unsigned char flags ;
  int header_size ;

  {
#line 949
  header_size = 4;
#line 951
  type = *((unsigned char *)(data + 0) + 0);
#line 952
  flags = *((unsigned char *)(data + 1) + 0);
#line 953
  if ((int )flags & 16) {
#line 954
    header_size += 2;
#line 955
    size = ((((unsigned long )*((unsigned char *)(data + 2) + 0) << 24) | ((unsigned long )*((unsigned char *)(data + 2) + 1) << 16)) | ((unsigned long )*((unsigned char *)(data + 2) + 2) << 8)) | (unsigned long )*((unsigned char *)(data + 2) + 3);
  } else {
#line 957
    size = (size_t )((unsigned short )(((int )*((unsigned char *)(data + 2) + 0) << 8) | (int )*((unsigned char *)(data + 2) + 1)));
  }
#line 959
  if (size > 1024UL) {
#line 960
    size = (size_t )1024;
  }
#line 961
  if ((int )type != 2) {
    {
#line 962
    pi_dumpdata((char const   *)((char *)(data + header_size)), size);
    }
  }
#line 963
  return;
}
}
#line 51 "../include/pi-threadsafe.h"
int pi_mutex_lock(pi_mutex_t *mutex ) ;
#line 53
int pi_mutex_trylock(pi_mutex_t *mutex ) ;
#line 55
int pi_mutex_unlock(pi_mutex_t *mutex ) ;
#line 57
unsigned long pi_thread_id(void) ;
#line 27 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/threadsafe.c"
int pi_mutex_lock(pi_mutex_t *mutex ) 
{ 


  {
#line 32
  return (0);
}
}
#line 36 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/threadsafe.c"
int pi_mutex_trylock(pi_mutex_t *mutex ) 
{ 


  {
#line 41
  return (0);
}
}
#line 45 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/threadsafe.c"
int pi_mutex_unlock(pi_mutex_t *mutex ) 
{ 


  {
#line 50
  return (0);
}
}
#line 54 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/threadsafe.c"
unsigned long pi_thread_id(void) 
{ 


  {
#line 59
  return (0UL);
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 42 "../include/pi-appinfo.h"
int unpack_CategoryAppInfo(CategoryAppInfo_t *ai , unsigned char const   *record ,
                           size_t len ) ;
#line 44
int pack_CategoryAppInfo(CategoryAppInfo_t const   *ai , unsigned char *record , size_t len ) ;
#line 93 "../include/pi-buffer.h"
pi_buffer_t *pi_buffer_expect(pi_buffer_t *buf___3 , size_t expect ) ;
#line 76 "../include/pi-address.h"
void free_Address(Address_t *addr ) ;
#line 78
int unpack_Address(Address_t *addr , pi_buffer_t const   *buf___3 , addressType type ) ;
#line 80
int pack_Address(Address_t const   *addr , pi_buffer_t *buf___3 , addressType type ) ;
#line 82
int unpack_AddressAppInfo(AddressAppInfo_t *ai , unsigned char const   *record , size_t len ) ;
#line 84
int pack_AddressAppInfo(AddressAppInfo_t const   *ai , unsigned char *record , size_t len ) ;
#line 46 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/address.c"
void free_Address(Address_t *addr ) 
{ 
  int i ;

  {
#line 51
  i = 0;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! (i < 19)) {
#line 51
      goto while_break;
    }
#line 52
    if (addr->entry[i]) {
      {
#line 53
      free((void *)addr->entry[i]);
#line 54
      addr->entry[i] = (char *)((void *)0);
      }
    }
#line 51
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return;
}
}
#line 71 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/address.c"
int unpack_Address(Address_t *addr , pi_buffer_t const   *buf___3 , addressType type ) 
{ 
  unsigned long contents ;
  unsigned long v ;
  size_t ofs ;
  size_t tmp ;

  {
#line 78
  if ((unsigned int )type != 0U) {
#line 80
    return (-1);
  }
#line 82
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
#line 83
    return (-1);
  } else
#line 82
  if ((unsigned long )buf___3->data == (unsigned long )((void *)0)) {
#line 83
    return (-1);
  } else
#line 82
  if (buf___3->used < 9UL) {
#line 83
    return (-1);
  }
#line 86
  addr->showPhone = ((int )*((unsigned char *)(buf___3->data + 1) + 0) >> 4) & 15;
#line 87
  addr->phoneLabel[4] = (int )*((unsigned char *)(buf___3->data + 1) + 0) & 15;
#line 88
  addr->phoneLabel[3] = ((int )*((unsigned char *)(buf___3->data + 2) + 0) >> 4) & 15;
#line 89
  addr->phoneLabel[2] = (int )*((unsigned char *)(buf___3->data + 2) + 0) & 15;
#line 90
  addr->phoneLabel[1] = ((int )*((unsigned char *)(buf___3->data + 3) + 0) >> 4) & 15;
#line 91
  addr->phoneLabel[0] = (int )*((unsigned char *)(buf___3->data + 3) + 0) & 15;
#line 93
  contents = ((((unsigned long )*((unsigned char *)(buf___3->data + 4) + 0) << 24) | ((unsigned long )*((unsigned char *)(buf___3->data + 4) + 1) << 16)) | ((unsigned long )*((unsigned char *)(buf___3->data + 4) + 2) << 8)) | (unsigned long )*((unsigned char *)(buf___3->data + 4) + 3);
#line 97
  ofs = (size_t )9;
#line 106
  v = 0UL;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! (v < 19UL)) {
#line 106
      goto while_break;
    }
#line 107
    if (contents & (unsigned long )(1 << v)) {
#line 108
      if (buf___3->used - (size_t const   )ofs < 1UL) {
#line 109
        return (0);
      }
      {
#line 110
      addr->entry[v] = strdup((char const   *)((char *)(buf___3->data + ofs)));
#line 111
      tmp = strlen((char const   *)addr->entry[v]);
#line 111
      ofs += tmp + 1UL;
      }
    } else {
#line 113
      addr->entry[v] = (char *)0;
    }
#line 106
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  return (0);
}
}
#line 133 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/address.c"
int pack_Address(Address_t const   *addr , pi_buffer_t *buf___3 , addressType type ) 
{ 
  unsigned int l ;
  unsigned int destlen ;
  unsigned char *buffer ;
  unsigned long contents ;
  unsigned long v ;
  unsigned long phoneflag ;
  unsigned char offset ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 136
  destlen = 9U;
#line 146
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
#line 147
    return (-1);
  } else
#line 146
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
#line 147
    return (-1);
  }
#line 149
  if ((unsigned int )type != 0U) {
#line 151
    return (-1);
  }
#line 153
  v = 0UL;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! (v < 19UL)) {
#line 153
      goto while_break;
    }
#line 154
    if (addr->entry[v]) {
      {
#line 154
      tmp___0 = strlen((char const   *)addr->entry[v]);
      }
#line 154
      if (tmp___0) {
        {
#line 155
        tmp = strlen((char const   *)addr->entry[v]);
#line 155
        destlen = (unsigned int )((size_t )destlen + (tmp + 1UL));
        }
      }
    }
#line 153
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 157
  pi_buffer_expect(buf___3, (size_t )destlen);
#line 158
  buf___3->used = (size_t )destlen;
#line 160
  buffer = buf___3->data + 9;
#line 161
  phoneflag = 0UL;
#line 162
  contents = 0UL;
#line 163
  offset = (unsigned char)0;
#line 165
  v = 0UL;
  }
  {
#line 165
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 165
    if (! (v < 19UL)) {
#line 165
      goto while_break___0;
    }
#line 166
    if (addr->entry[v]) {
      {
#line 166
      tmp___2 = strlen((char const   *)addr->entry[v]);
      }
#line 166
      if (tmp___2) {
#line 167
        if (v == 2UL) {
#line 168
          offset = (unsigned char )((int )((unsigned char )(buffer - buf___3->data)) - 8);
        }
        {
#line 170
        contents |= (unsigned long )(1 << v);
#line 171
        tmp___1 = strlen((char const   *)addr->entry[v]);
#line 171
        l = (unsigned int )(tmp___1 + 1UL);
#line 172
        memcpy((void */* __restrict  */)buffer, (void const   */* __restrict  */)addr->entry[v],
               (size_t )l);
#line 173
        buffer += l;
        }
      }
    }
#line 165
    v ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 177
  phoneflag = (unsigned long )addr->phoneLabel[0];
#line 178
  phoneflag |= (unsigned long )addr->phoneLabel[1] << 4;
#line 179
  phoneflag |= (unsigned long )addr->phoneLabel[2] << 8;
#line 180
  phoneflag |= (unsigned long )addr->phoneLabel[3] << 12;
#line 181
  phoneflag |= (unsigned long )addr->phoneLabel[4] << 16;
#line 182
  phoneflag |= (unsigned long )addr->showPhone << 20;
#line 184
  *(buf___3->data + 0) = (unsigned char )((int )((unsigned char )(phoneflag >> 24)) & 255);
#line 184
  *(buf___3->data + 1) = (unsigned char )((phoneflag >> 16) & 255UL);
#line 184
  *(buf___3->data + 2) = (unsigned char )((phoneflag >> 8) & 255UL);
#line 184
  *(buf___3->data + 3) = (unsigned char )(phoneflag & 255UL);
#line 185
  *((buf___3->data + 4) + 0) = (unsigned char )((int )((unsigned char )(contents >> 24)) & 255);
#line 185
  *((buf___3->data + 4) + 1) = (unsigned char )((contents >> 16) & 255UL);
#line 185
  *((buf___3->data + 4) + 2) = (unsigned char )((contents >> 8) & 255UL);
#line 185
  *((buf___3->data + 4) + 3) = (unsigned char )(contents & 255UL);
#line 186
  *((buf___3->data + 8) + 0) = offset;
#line 188
  return (0);
}
}
#line 206 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/address.c"
int unpack_AddressAppInfo(AddressAppInfo_t *ai , unsigned char const   *record , size_t len ) 
{ 
  size_t i ;
  size_t destlen ;
  unsigned char *start ;
  unsigned long r ;
  int tmp ;

  {
  {
#line 209
  destlen = (size_t )360;
#line 212
  start = (unsigned char *)record;
#line 215
  ai->type = (addressType )0;
#line 217
  tmp = unpack_CategoryAppInfo(& ai->category, record, len);
#line 217
  i = (size_t )tmp;
  }
#line 218
  if (! record) {
#line 219
    return ((int )(i + destlen));
  }
#line 220
  if (! i) {
#line 221
    return ((int )i);
  }
#line 222
  record += i;
#line 223
  len -= i;
#line 225
  if (len < destlen) {
#line 226
    return (0);
  }
#line 228
  r = ((((unsigned long )*((unsigned char *)record + 0) << 24) | ((unsigned long )*((unsigned char *)record + 1) << 16)) | ((unsigned long )*((unsigned char *)record + 2) << 8)) | (unsigned long )*((unsigned char *)record + 3);
#line 229
  i = (size_t )0;
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (! (i < 22UL)) {
#line 229
      goto while_break;
    }
#line 230
    ai->labelRenamed[i] = ! (! (r & (unsigned long )(1 << i)));
#line 229
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 232
  record += 4;
#line 233
  memcpy((void */* __restrict  */)(ai->labels), (void const   */* __restrict  */)record,
         (size_t )352);
#line 234
  record += 352;
#line 235
  ai->country = (int )((unsigned short )(((int )*((unsigned char *)record + 0) << 8) | (int )*((unsigned char *)record + 1)));
#line 236
  record += 2;
#line 237
  ai->sortByCompany = (int )*((unsigned char *)record + 0);
#line 238
  record += 2;
#line 240
  i = (size_t )3;
  }
  {
#line 240
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 240
    if (! (i < 8UL)) {
#line 240
      goto while_break___0;
    }
    {
#line 241
    strcpy((char */* __restrict  */)(ai->phoneLabels[i - 3UL]), (char const   */* __restrict  */)(ai->labels[i]));
#line 240
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 242
  i = (size_t )19;
  {
#line 242
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 242
    if (! (i < 22UL)) {
#line 242
      goto while_break___1;
    }
    {
#line 243
    strcpy((char */* __restrict  */)(ai->phoneLabels[(i - 19UL) + 5UL]), (char const   */* __restrict  */)(ai->labels[i]));
#line 242
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 245
  return ((int )(record - (unsigned char const   *)start));
}
}
#line 262 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/address.c"
int pack_AddressAppInfo(AddressAppInfo_t const   *ai , unsigned char *record , size_t len ) 
{ 
  int i ;
  size_t destlen ;
  unsigned char *pos ;
  unsigned long r ;

  {
  {
#line 266
  destlen = (size_t )360;
#line 267
  pos = record;
#line 270
  i = pack_CategoryAppInfo(& ai->category, record, len);
  }
#line 271
  if (! record) {
#line 272
    return ((int )(destlen + (size_t )i));
  }
#line 273
  if (! i) {
#line 274
    return (i);
  }
#line 276
  pos += i;
#line 277
  len -= (size_t )i;
#line 279
  i = 3;
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (! (i < 8)) {
#line 279
      goto while_break;
    }
    {
#line 280
    strcpy((char */* __restrict  */)(ai->phoneLabels[i - 3]), (char const   */* __restrict  */)(ai->labels[i]));
#line 279
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  i = 19;
  {
#line 281
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 281
    if (! (i < 22)) {
#line 281
      goto while_break___0;
    }
    {
#line 282
    strcpy((char */* __restrict  */)(ai->phoneLabels[(i - 19) + 5]), (char const   */* __restrict  */)(ai->labels[i]));
#line 281
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 284
  memset((void *)pos, 0, destlen);
#line 286
  r = 0UL;
#line 287
  i = 0;
  }
  {
#line 287
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 287
    if (! (i < 22)) {
#line 287
      goto while_break___1;
    }
#line 288
    if (ai->labelRenamed[i]) {
#line 289
      r |= (unsigned long )(1 << i);
    }
#line 287
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 290
  *(pos + 0) = (unsigned char )((int )((unsigned char )(r >> 24)) & 255);
#line 290
  *(pos + 1) = (unsigned char )((r >> 16) & 255UL);
#line 290
  *(pos + 2) = (unsigned char )((r >> 8) & 255UL);
#line 290
  *(pos + 3) = (unsigned char )(r & 255UL);
#line 291
  pos += 4;
#line 293
  memcpy((void */* __restrict  */)pos, (void const   */* __restrict  */)(ai->labels),
         (size_t )352);
#line 294
  pos += 352;
#line 295
  *(pos + 0) = (unsigned char )(((int )((unsigned short )ai->country) >> 8) & 255);
#line 295
  *(pos + 1) = (unsigned char )((int )((unsigned short )ai->country) & 255);
#line 296
  pos += 2;
#line 297
  *(pos + 0) = (unsigned char )ai->sortByCompany;
#line 298
  pos += 2;
#line 300
  i = 3;
  }
  {
#line 300
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 300
    if (! (i < 8)) {
#line 300
      goto while_break___2;
    }
    {
#line 301
    strcpy((char */* __restrict  */)(ai->phoneLabels[i - 3]), (char const   */* __restrict  */)(ai->labels[i]));
#line 300
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 302
  i = 19;
  {
#line 302
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 302
    if (! (i < 22)) {
#line 302
      goto while_break___3;
    }
    {
#line 303
    strcpy((char */* __restrict  */)(ai->phoneLabels[(i - 19) + 5]), (char const   */* __restrict  */)(ai->labels[i]));
#line 302
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 305
  return ((int )(pos - record));
}
}
#line 61 "../include/pi-money.h"
int unpack_Transaction(Transaction_t *trans , unsigned char *buffer , size_t len ) ;
#line 63
int pack_Transaction(struct Transaction *trans , unsigned char *buffer , size_t len ) ;
#line 65
int unpack_MoneyAppInfo(MoneyAppInfo_t *appinfo , unsigned char *buffer , size_t len ) ;
#line 67
int pack_MoneyAppInfo(MoneyAppInfo_t *appinfo , unsigned char *buffer , size_t len ) ;
#line 41 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/money.c"
int unpack_Transaction(Transaction_t *trans , unsigned char *buffer , size_t len ) 
{ 
  unsigned char *p ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;

  {
#line 47
  if (len < 46UL) {
#line 48
    return (0);
  }
#line 50
  p = buffer;
#line 51
  trans->flags = (char )*(p + 0);
#line 52
  p += 2;
#line 53
  trans->checknum = (unsigned int )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1)));
#line 54
  p += 2;
#line 55
  if ((((((unsigned long )*(p + 0) << 24) | ((unsigned long )*(p + 1) << 16)) | ((unsigned long )*(p + 2) << 8)) | (unsigned long )*(p + 3)) > 2147483647UL) {
#line 55
    tmp = (long )((((((unsigned long )*(p + 0) << 24) | ((unsigned long )*(p + 1) << 16)) | ((unsigned long )*(p + 2) << 8)) | (unsigned long )*(p + 3)) & 2147483647UL) - 2147483648L;
  } else {
#line 55
    tmp = (long )(((((unsigned long )*(p + 0) << 24) | ((unsigned long )*(p + 1) << 16)) | ((unsigned long )*(p + 2) << 8)) | (unsigned long )*(p + 3));
  }
#line 55
  trans->amount = tmp;
#line 56
  p += 4;
#line 57
  if ((((((unsigned long )*(p + 0) << 24) | ((unsigned long )*(p + 1) << 16)) | ((unsigned long )*(p + 2) << 8)) | (unsigned long )*(p + 3)) > 2147483647UL) {
#line 57
    tmp___0 = (long )((((((unsigned long )*(p + 0) << 24) | ((unsigned long )*(p + 1) << 16)) | ((unsigned long )*(p + 2) << 8)) | (unsigned long )*(p + 3)) & 2147483647UL) - 2147483648L;
  } else {
#line 57
    tmp___0 = (long )(((((unsigned long )*(p + 0) << 24) | ((unsigned long )*(p + 1) << 16)) | ((unsigned long )*(p + 2) << 8)) | (unsigned long )*(p + 3));
  }
#line 57
  trans->total = tmp___0;
#line 58
  p += 4;
#line 59
  if ((int )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))) > 32767) {
#line 59
    tmp___1 = (int )((short )((int )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))) & 32767)) - 32768;
  } else {
#line 59
    tmp___1 = (int )((short )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))));
  }
#line 59
  trans->amountc = (int )((short )tmp___1);
#line 60
  p += 2;
#line 61
  if ((int )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))) > 32767) {
#line 61
    tmp___2 = (int )((short )((int )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))) & 32767)) - 32768;
  } else {
#line 61
    tmp___2 = (int )((short )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))));
  }
#line 61
  trans->totalc = (int )((short )tmp___2);
#line 62
  p += 2;
#line 64
  if ((int )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))) > 32767) {
#line 64
    tmp___3 = (int )((short )((int )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))) & 32767)) - 32768;
  } else {
#line 64
    tmp___3 = (int )((short )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))));
  }
#line 64
  trans->second = (int )((short )tmp___3);
#line 65
  p += 2;
#line 66
  if ((int )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))) > 32767) {
#line 66
    tmp___4 = (int )((short )((int )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))) & 32767)) - 32768;
  } else {
#line 66
    tmp___4 = (int )((short )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))));
  }
#line 66
  trans->minute = (int )((short )tmp___4);
#line 67
  p += 2;
#line 68
  if ((int )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))) > 32767) {
#line 68
    tmp___5 = (int )((short )((int )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))) & 32767)) - 32768;
  } else {
#line 68
    tmp___5 = (int )((short )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))));
  }
#line 68
  trans->hour = (int )((short )tmp___5);
#line 69
  p += 2;
#line 70
  if ((int )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))) > 32767) {
#line 70
    tmp___6 = (int )((short )((int )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))) & 32767)) - 32768;
  } else {
#line 70
    tmp___6 = (int )((short )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))));
  }
#line 70
  trans->day = (int )((short )tmp___6);
#line 71
  p += 2;
#line 72
  if ((int )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))) > 32767) {
#line 72
    tmp___7 = (int )((short )((int )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))) & 32767)) - 32768;
  } else {
#line 72
    tmp___7 = (int )((short )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))));
  }
#line 72
  trans->month = (int )((short )tmp___7);
#line 73
  p += 2;
#line 74
  if ((int )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))) > 32767) {
#line 74
    tmp___8 = (int )((short )((int )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))) & 32767)) - 32768;
  } else {
#line 74
    tmp___8 = (int )((short )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))));
  }
#line 74
  trans->year = (int )((short )tmp___8);
#line 75
  p += 2;
#line 76
  if ((int )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))) > 32767) {
#line 76
    tmp___9 = (int )((short )((int )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))) & 32767)) - 32768;
  } else {
#line 76
    tmp___9 = (int )((short )((unsigned short )(((int )*(p + 0) << 8) | (int )*(p + 1))));
  }
  {
#line 76
  trans->wday = (int )((short )tmp___9);
#line 77
  p += 2;
#line 79
  trans->repeat = (char )*(p + 0);
#line 80
  p ++;
#line 81
  trans->flags2 = (char )*(p + 0);
#line 82
  p ++;
#line 83
  trans->type = (char )*(p + 0);
#line 84
  p ++;
#line 86
  memcpy((void */* __restrict  */)(trans->reserved), (void const   */* __restrict  */)p,
         (size_t )2);
#line 87
  p += 2;
#line 89
  trans->xfer = (char )*(p + 0);
#line 90
  p ++;
#line 92
  strcpy((char */* __restrict  */)(trans->description), (char const   */* __restrict  */)((char *)p));
#line 93
  p += 19;
#line 94
  strcpy((char */* __restrict  */)(trans->note), (char const   */* __restrict  */)((char *)p));
#line 95
  tmp___10 = strlen((char const   *)((char *)p));
#line 95
  p += tmp___10 + 1UL;
  }
#line 97
  return ((int )(p - buffer));
}
}
#line 112 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/money.c"
int pack_Transaction(struct Transaction *trans , unsigned char *buffer , size_t len ) 
{ 
  size_t destlen ;
  size_t tmp ;
  unsigned char *p ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  size_t tmp___26 ;

  {
  {
#line 115
  tmp = strlen((char const   *)(trans->note));
#line 115
  destlen = (46UL + tmp) + 1UL;
  }
#line 118
  if (! buffer) {
#line 119
    return ((int )destlen);
  }
#line 120
  if (len < destlen) {
#line 121
    return (0);
  }
#line 123
  p = buffer;
#line 124
  *(p + 0) = (unsigned char )trans->flags;
#line 125
  p ++;
#line 126
  *(p + 0) = (unsigned char)0;
#line 127
  p ++;
#line 128
  *(p + 0) = (unsigned char )(((int )((unsigned short )trans->checknum) >> 8) & 255);
#line 128
  *(p + 1) = (unsigned char )((int )((unsigned short )trans->checknum) & 255);
#line 129
  p += 2;
#line 130
  if (trans->amount < 0L) {
#line 130
    tmp___0 = (unsigned long )(trans->amount + 2147483648L) | 2147483648UL;
  } else {
#line 130
    tmp___0 = (unsigned long )trans->amount;
  }
#line 130
  *(p + 0) = (unsigned char )((int )((unsigned char )(tmp___0 >> 24)) & 255);
#line 130
  if (trans->amount < 0L) {
#line 130
    tmp___1 = (unsigned long )(trans->amount + 2147483648L) | 2147483648UL;
  } else {
#line 130
    tmp___1 = (unsigned long )trans->amount;
  }
#line 130
  *(p + 1) = (unsigned char )((tmp___1 >> 16) & 255UL);
#line 130
  if (trans->amount < 0L) {
#line 130
    tmp___2 = (unsigned long )(trans->amount + 2147483648L) | 2147483648UL;
  } else {
#line 130
    tmp___2 = (unsigned long )trans->amount;
  }
#line 130
  *(p + 2) = (unsigned char )((tmp___2 >> 8) & 255UL);
#line 130
  if (trans->amount < 0L) {
#line 130
    tmp___3 = (unsigned long )(trans->amount + 2147483648L) | 2147483648UL;
  } else {
#line 130
    tmp___3 = (unsigned long )trans->amount;
  }
#line 130
  *(p + 3) = (unsigned char )(tmp___3 & 255UL);
#line 131
  p += 4;
#line 132
  if (trans->total < 0L) {
#line 132
    tmp___4 = (unsigned long )(trans->total + 2147483648L) | 2147483648UL;
  } else {
#line 132
    tmp___4 = (unsigned long )trans->total;
  }
#line 132
  *(p + 0) = (unsigned char )((int )((unsigned char )(tmp___4 >> 24)) & 255);
#line 132
  if (trans->total < 0L) {
#line 132
    tmp___5 = (unsigned long )(trans->total + 2147483648L) | 2147483648UL;
  } else {
#line 132
    tmp___5 = (unsigned long )trans->total;
  }
#line 132
  *(p + 1) = (unsigned char )((tmp___5 >> 16) & 255UL);
#line 132
  if (trans->total < 0L) {
#line 132
    tmp___6 = (unsigned long )(trans->total + 2147483648L) | 2147483648UL;
  } else {
#line 132
    tmp___6 = (unsigned long )trans->total;
  }
#line 132
  *(p + 2) = (unsigned char )((tmp___6 >> 8) & 255UL);
#line 132
  if (trans->total < 0L) {
#line 132
    tmp___7 = (unsigned long )(trans->total + 2147483648L) | 2147483648UL;
  } else {
#line 132
    tmp___7 = (unsigned long )trans->total;
  }
#line 132
  *(p + 3) = (unsigned char )(tmp___7 & 255UL);
#line 133
  p += 4;
#line 134
  if ((int )((short )trans->amountc) < 0) {
#line 134
    tmp___8 = (int )((unsigned short )((int )((short )trans->amountc) + 32768)) | 32768;
  } else {
#line 134
    tmp___8 = trans->amountc;
  }
#line 134
  *(p + 0) = (unsigned char )(((int )((unsigned short )tmp___8) >> 8) & 255);
#line 134
  if ((int )((short )trans->amountc) < 0) {
#line 134
    tmp___9 = (int )((unsigned short )((int )((short )trans->amountc) + 32768)) | 32768;
  } else {
#line 134
    tmp___9 = trans->amountc;
  }
#line 134
  *(p + 1) = (unsigned char )((int )((unsigned short )tmp___9) & 255);
#line 135
  p += 2;
#line 136
  if ((int )((short )trans->totalc) < 0) {
#line 136
    tmp___10 = (int )((unsigned short )((int )((short )trans->totalc) + 32768)) | 32768;
  } else {
#line 136
    tmp___10 = trans->totalc;
  }
#line 136
  *(p + 0) = (unsigned char )(((int )((unsigned short )tmp___10) >> 8) & 255);
#line 136
  if ((int )((short )trans->totalc) < 0) {
#line 136
    tmp___11 = (int )((unsigned short )((int )((short )trans->totalc) + 32768)) | 32768;
  } else {
#line 136
    tmp___11 = trans->totalc;
  }
#line 136
  *(p + 1) = (unsigned char )((int )((unsigned short )tmp___11) & 255);
#line 137
  p += 2;
#line 139
  if ((int )((short )trans->second) < 0) {
#line 139
    tmp___12 = (int )((unsigned short )((int )((short )trans->second) + 32768)) | 32768;
  } else {
#line 139
    tmp___12 = trans->second;
  }
#line 139
  *(p + 0) = (unsigned char )(((int )((unsigned short )tmp___12) >> 8) & 255);
#line 139
  if ((int )((short )trans->second) < 0) {
#line 139
    tmp___13 = (int )((unsigned short )((int )((short )trans->second) + 32768)) | 32768;
  } else {
#line 139
    tmp___13 = trans->second;
  }
#line 139
  *(p + 1) = (unsigned char )((int )((unsigned short )tmp___13) & 255);
#line 140
  p += 2;
#line 141
  if ((int )((short )trans->minute) < 0) {
#line 141
    tmp___14 = (int )((unsigned short )((int )((short )trans->minute) + 32768)) | 32768;
  } else {
#line 141
    tmp___14 = trans->minute;
  }
#line 141
  *(p + 0) = (unsigned char )(((int )((unsigned short )tmp___14) >> 8) & 255);
#line 141
  if ((int )((short )trans->minute) < 0) {
#line 141
    tmp___15 = (int )((unsigned short )((int )((short )trans->minute) + 32768)) | 32768;
  } else {
#line 141
    tmp___15 = trans->minute;
  }
#line 141
  *(p + 1) = (unsigned char )((int )((unsigned short )tmp___15) & 255);
#line 142
  p += 2;
#line 143
  if ((int )((short )trans->hour) < 0) {
#line 143
    tmp___16 = (int )((unsigned short )((int )((short )trans->hour) + 32768)) | 32768;
  } else {
#line 143
    tmp___16 = trans->hour;
  }
#line 143
  *(p + 0) = (unsigned char )(((int )((unsigned short )tmp___16) >> 8) & 255);
#line 143
  if ((int )((short )trans->hour) < 0) {
#line 143
    tmp___17 = (int )((unsigned short )((int )((short )trans->hour) + 32768)) | 32768;
  } else {
#line 143
    tmp___17 = trans->hour;
  }
#line 143
  *(p + 1) = (unsigned char )((int )((unsigned short )tmp___17) & 255);
#line 144
  p += 2;
#line 145
  if ((int )((short )trans->day) < 0) {
#line 145
    tmp___18 = (int )((unsigned short )((int )((short )trans->day) + 32768)) | 32768;
  } else {
#line 145
    tmp___18 = trans->day;
  }
#line 145
  *(p + 0) = (unsigned char )(((int )((unsigned short )tmp___18) >> 8) & 255);
#line 145
  if ((int )((short )trans->day) < 0) {
#line 145
    tmp___19 = (int )((unsigned short )((int )((short )trans->day) + 32768)) | 32768;
  } else {
#line 145
    tmp___19 = trans->day;
  }
#line 145
  *(p + 1) = (unsigned char )((int )((unsigned short )tmp___19) & 255);
#line 146
  p += 2;
#line 147
  if ((int )((short )trans->month) < 0) {
#line 147
    tmp___20 = (int )((unsigned short )((int )((short )trans->month) + 32768)) | 32768;
  } else {
#line 147
    tmp___20 = trans->month;
  }
#line 147
  *(p + 0) = (unsigned char )(((int )((unsigned short )tmp___20) >> 8) & 255);
#line 147
  if ((int )((short )trans->month) < 0) {
#line 147
    tmp___21 = (int )((unsigned short )((int )((short )trans->month) + 32768)) | 32768;
  } else {
#line 147
    tmp___21 = trans->month;
  }
#line 147
  *(p + 1) = (unsigned char )((int )((unsigned short )tmp___21) & 255);
#line 148
  p += 2;
#line 149
  if ((int )((short )trans->year) < 0) {
#line 149
    tmp___22 = (int )((unsigned short )((int )((short )trans->year) + 32768)) | 32768;
  } else {
#line 149
    tmp___22 = trans->year;
  }
#line 149
  *(p + 0) = (unsigned char )(((int )((unsigned short )tmp___22) >> 8) & 255);
#line 149
  if ((int )((short )trans->year) < 0) {
#line 149
    tmp___23 = (int )((unsigned short )((int )((short )trans->year) + 32768)) | 32768;
  } else {
#line 149
    tmp___23 = trans->year;
  }
#line 149
  *(p + 1) = (unsigned char )((int )((unsigned short )tmp___23) & 255);
#line 150
  p += 2;
#line 151
  if ((int )((short )trans->wday) < 0) {
#line 151
    tmp___24 = (int )((unsigned short )((int )((short )trans->wday) + 32768)) | 32768;
  } else {
#line 151
    tmp___24 = trans->wday;
  }
#line 151
  *(p + 0) = (unsigned char )(((int )((unsigned short )tmp___24) >> 8) & 255);
#line 151
  if ((int )((short )trans->wday) < 0) {
#line 151
    tmp___25 = (int )((unsigned short )((int )((short )trans->wday) + 32768)) | 32768;
  } else {
#line 151
    tmp___25 = trans->wday;
  }
  {
#line 151
  *(p + 1) = (unsigned char )((int )((unsigned short )tmp___25) & 255);
#line 152
  p += 2;
#line 154
  *(p + 0) = (unsigned char )trans->repeat;
#line 155
  p ++;
#line 156
  *(p + 0) = (unsigned char )trans->flags2;
#line 157
  p ++;
#line 158
  *(p + 0) = (unsigned char )trans->type;
#line 159
  p ++;
#line 162
  *(p + 0) = (unsigned char)0;
#line 162
  *(p + 1) = (unsigned char)0;
#line 163
  p += 2;
#line 165
  *(p + 0) = (unsigned char )trans->xfer;
#line 166
  p ++;
#line 168
  strcpy((char */* __restrict  */)((char *)p), (char const   */* __restrict  */)(trans->description));
#line 169
  p += 19;
#line 170
  strcpy((char */* __restrict  */)((char *)p), (char const   */* __restrict  */)(trans->note));
#line 171
  tmp___26 = strlen((char const   *)((char *)p));
#line 171
  p += tmp___26 + 1UL;
  }
#line 173
  return ((int )(p - buffer));
}
}
#line 188 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/money.c"
int unpack_MoneyAppInfo(MoneyAppInfo_t *appinfo , unsigned char *buffer , size_t len ) 
{ 
  int i ;
  int j ;
  unsigned char *p ;

  {
  {
#line 196
  i = unpack_CategoryAppInfo(& appinfo->category, (unsigned char const   *)buffer,
                             len);
  }
#line 197
  if (! i) {
#line 198
    return (0);
  }
#line 200
  p = buffer + i;
#line 202
  len -= (size_t )i;
#line 203
  if (len < 603UL) {
#line 204
    return (0);
  }
#line 206
  j = 0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! (j < 20)) {
#line 206
      goto while_break;
    }
    {
#line 207
    memcpy((void */* __restrict  */)(appinfo->typeLabels[j]), (void const   */* __restrict  */)p,
           (size_t )10);
#line 208
    p += 10;
#line 206
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  j = 0;
  {
#line 211
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 211
    if (! (j < 20)) {
#line 211
      goto while_break___0;
    }
    {
#line 212
    memcpy((void */* __restrict  */)(appinfo->tranLabels[j]), (void const   */* __restrict  */)p,
           (size_t )20);
#line 213
    p += 20;
#line 211
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 216
  return (i + 603);
}
}
#line 231 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/money.c"
int pack_MoneyAppInfo(MoneyAppInfo_t *appinfo , unsigned char *buffer , size_t len ) 
{ 
  int i ;
  int j ;
  unsigned char *p ;

  {
  {
#line 238
  i = pack_CategoryAppInfo((CategoryAppInfo_t const   *)(& appinfo->category), buffer,
                           len);
  }
#line 240
  if (! buffer) {
#line 241
    return (i + 603);
  }
#line 242
  if (! i) {
#line 243
    return (i);
  }
#line 245
  p = buffer + i;
#line 246
  len -= (size_t )i;
#line 247
  if (i < 603) {
#line 248
    return (0);
  }
#line 250
  j = 0;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (j < 20)) {
#line 250
      goto while_break;
    }
    {
#line 251
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(appinfo->typeLabels[j]),
           (size_t )10);
#line 252
    p += 10;
#line 250
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  j = 0;
  {
#line 255
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 255
    if (! (j < 20)) {
#line 255
      goto while_break___0;
    }
    {
#line 256
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(appinfo->tranLabels[j]),
           (size_t )20);
#line 257
    p += 20;
#line 255
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 260
  return (i + 603);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 49 "../include/pi-blob.h"
void free_Blob(Blob_t *blob ) ;
#line 52
int unpack_Blob_p(Blob_t *blob , unsigned char const   *data , size_t const   position ) ;
#line 55
int pack_Blob(Blob_t const   *blob , pi_buffer_t *buf___3 ) ;
#line 58
Blob_t *dup_Blob(Blob_t const   *blob ) ;
#line 53 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/blob.c"
void free_Blob(Blob_t *blob ) 
{ 


  {
#line 56
  if ((unsigned long )((void *)0) != (unsigned long )blob->data) {
    {
#line 57
    free((void *)blob->data);
#line 58
    blob->data = (uint8_t *)((void *)0);
    }
  }
#line 60
  return;
}
}
#line 73 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/blob.c"
Blob_t *dup_Blob(Blob_t const   *blob ) 
{ 
  Blob_t *retval ;
  void *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
#line 76
  if ((unsigned long )((void *)0) == (unsigned long )blob) {
#line 77
    return ((Blob_t *)((void *)0));
  }
  {
#line 80
  tmp = malloc(sizeof(Blob_t ));
#line 80
  retval = (Blob_t *)tmp;
  }
#line 81
  if ((unsigned long )((void *)0) == (unsigned long )retval) {
    {
#line 82
    tmp___0 = __errno_location();
#line 82
    *tmp___0 = 12;
    }
#line 83
    return ((Blob_t *)((void *)0));
  }
  {
#line 85
  memcpy((void */* __restrict  */)(retval->type), (void const   */* __restrict  */)(blob->type),
         (size_t )4);
#line 86
  retval->length = (int16_t )blob->length;
  }
#line 87
  if ((int const   )blob->length > 0) {
    {
#line 88
    tmp___1 = malloc((size_t )blob->length);
#line 88
    retval->data = (uint8_t *)tmp___1;
    }
#line 89
    if ((unsigned long )((void *)0) == (unsigned long )retval->data) {
      {
#line 90
      tmp___2 = __errno_location();
#line 90
      *tmp___2 = 12;
      }
#line 91
      return ((Blob_t *)((void *)0));
    } else {
      {
#line 93
      memcpy((void */* __restrict  */)retval->data, (void const   */* __restrict  */)blob->data,
             (size_t )blob->length);
      }
    }
  } else {
#line 96
    retval->data = (uint8_t *)((void *)0);
  }
#line 98
  return (retval);
}
}
#line 113 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/blob.c"
int unpack_Blob_p(Blob_t *blob , unsigned char const   *data , size_t const   position ) 
{ 
  size_t localPosition ;
  void *tmp ;

  {
  {
#line 115
  localPosition = (size_t )position;
#line 117
  memcpy((void */* __restrict  */)(blob->type), (void const   */* __restrict  */)((char *)data + localPosition),
         (size_t )4);
#line 118
  localPosition += 4UL;
#line 120
  blob->length = (int16_t )((unsigned short )(((int )*((unsigned char *)(data + localPosition) + 0) << 8) | (int )*((unsigned char *)(data + localPosition) + 1)));
#line 121
  localPosition += 2UL;
  }
#line 122
  if ((int )blob->length > 0) {
    {
#line 124
    tmp = malloc((size_t )blob->length);
#line 124
    blob->data = (uint8_t *)tmp;
    }
#line 125
    if ((unsigned long )((void *)0) == (unsigned long )blob->data) {
      {
#line 126
      printf((char const   */* __restrict  */)"Malloc failed!\n");
      }
#line 127
      return (-1);
    } else {
      {
#line 129
      memcpy((void */* __restrict  */)blob->data, (void const   */* __restrict  */)(data + localPosition),
             (size_t )blob->length);
      }
    }
#line 131
    localPosition += (size_t )blob->length;
  }
#line 134
  return ((int )(localPosition - (size_t )position));
}
}
#line 148 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/blob.c"
int pack_Blob(Blob_t const   *blob , pi_buffer_t *buf___3 ) 
{ 
  size_t offset ;

  {
  {
#line 152
  offset = buf___3->used;
#line 153
  pi_buffer_expect(buf___3, (buf___3->used + 6UL) + (size_t )blob->length);
#line 154
  buf___3->used = (buf___3->used + 6UL) + (size_t )blob->length;
#line 156
  memcpy((void */* __restrict  */)(buf___3->data + offset), (void const   */* __restrict  */)(blob->type),
         (size_t )4);
#line 157
  offset += 4UL;
#line 159
  *((buf___3->data + offset) + 0) = (unsigned char )(((int )((unsigned short )blob->length) >> 8) & 255);
#line 159
  *((buf___3->data + offset) + 1) = (unsigned char )((int )((unsigned short )blob->length) & 255);
#line 160
  offset += 2UL;
#line 162
  memcpy((void */* __restrict  */)(buf___3->data + offset), (void const   */* __restrict  */)blob->data,
         (size_t )blob->length);
#line 163
  offset += (size_t )blob->length;
  }
#line 165
  return (0);
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 734 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) realpath)(char const   * __restrict  __name ,
                                                                                 char * __restrict  __resolved ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 78 "../include/pi-serial.h"
pi_device_t *pi_serial_device(int type ) ;
#line 81
void pi_serial_impl_init(struct pi_serial_impl *impl ) ;
#line 75 "../include/pi-cmp.h"
int cmp_rx_handshake(pi_socket_t *ps , int establishrate , int establishhighrate ) ;
#line 78
int cmp_tx_handshake(pi_socket_t *ps ) ;
#line 57 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_connect(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
#line 59
static int pi_serial_bind(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
#line 61
static int pi_serial_listen(pi_socket_t *ps , int backlog ) ;
#line 62
static int pi_serial_accept(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) ;
#line 64
static int pi_serial_getsockopt(pi_socket_t *ps , int level , int option_name , void *option_value ,
                                size_t *option_len ) ;
#line 67
static int pi_serial_setsockopt(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                                size_t *option_len ) ;
#line 70
static int pi_serial_close(pi_socket_t *ps ) ;
#line 72
int pi_socket_init(pi_socket_t *ps ) ;
#line 87 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static pi_protocol_t *pi_serial_protocol_dup(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  void *tmp ;

  {
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 92
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c",
             92, "prot != NULL");
      }
    }
#line 92
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 94
  tmp = malloc(sizeof(pi_protocol_t ));
#line 94
  new_prot = (pi_protocol_t *)tmp;
  }
#line 96
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 97
    new_prot->level = prot->level;
#line 98
    new_prot->dup = prot->dup;
#line 99
    new_prot->free = prot->free;
#line 100
    new_prot->read = prot->read;
#line 101
    new_prot->write = prot->write;
#line 102
    new_prot->flush = prot->flush;
#line 103
    new_prot->getsockopt = prot->getsockopt;
#line 104
    new_prot->setsockopt = prot->setsockopt;
#line 105
    new_prot->data = (void *)0;
  }
#line 108
  return (new_prot);
}
}
#line 123 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static void pi_serial_protocol_free(pi_protocol_t *prot ) 
{ 


  {
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 126
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c",
             126, "prot != NULL");
      }
    }
#line 126
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
    {
#line 129
    free((void *)prot);
    }
  }
#line 130
  return;
}
}
#line 144 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static pi_protocol_t *pi_serial_protocol(pi_device_t *dev ) 
{ 
  pi_protocol_t *prot ;
  struct pi_serial_data *data ;
  void *tmp ;

  {
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! ((unsigned long )dev != (unsigned long )((void *)0))) {
      {
#line 150
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c",
             150, "dev != NULL");
      }
    }
#line 150
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 152
  tmp = malloc(sizeof(pi_protocol_t ));
#line 152
  prot = (pi_protocol_t *)tmp;
#line 154
  data = (struct pi_serial_data *)dev->data;
  }
#line 156
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 157
    prot->level = 0;
#line 158
    prot->dup = & pi_serial_protocol_dup;
#line 159
    prot->free = & pi_serial_protocol_free;
#line 160
    prot->read = data->impl.read;
#line 161
    prot->write = data->impl.write;
#line 162
    prot->flush = data->impl.flush;
#line 163
    prot->getsockopt = & pi_serial_getsockopt;
#line 164
    prot->setsockopt = & pi_serial_setsockopt;
#line 165
    prot->data = (void *)0;
  }
#line 168
  return (prot);
}
}
#line 184 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static void pi_serial_device_free(pi_device_t *dev ) 
{ 


  {
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )dev != (unsigned long )((void *)0))) {
      {
#line 187
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c",
             187, "dev != NULL");
      }
    }
#line 187
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 189
  free(dev->data);
#line 190
  free((void *)dev);
  }
#line 191
  return;
}
}
#line 205 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
pi_device_t *pi_serial_device(int type ) 
{ 
  pi_device_t *dev ;
  struct pi_serial_data *data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 211
  tmp = malloc(sizeof(pi_device_t ));
#line 211
  dev = (pi_device_t *)tmp;
  }
#line 212
  if ((unsigned long )dev == (unsigned long )((void *)0)) {
#line 213
    return ((pi_device_t *)((void *)0));
  }
  {
#line 215
  tmp___0 = malloc(sizeof(struct pi_serial_data ));
#line 215
  data = (struct pi_serial_data *)tmp___0;
  }
#line 216
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    {
#line 217
    free((void *)dev);
    }
#line 218
    return ((pi_device_t *)((void *)0));
  }
#line 221
  dev->free = & pi_serial_device_free;
#line 222
  dev->protocol = & pi_serial_protocol;
#line 223
  dev->bind = & pi_serial_bind;
#line 224
  dev->listen = & pi_serial_listen;
#line 225
  dev->accept = & pi_serial_accept;
#line 226
  dev->connect = & pi_serial_connect;
#line 227
  dev->close = & pi_serial_close;
  {
#line 230
  if (type == 1) {
#line 230
    goto case_1;
  }
#line 233
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 231
  pi_serial_impl_init(& data->impl);
  }
#line 232
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 234
  pi_serial_impl_init(& data->impl);
  }
#line 235
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 238
  data->buf_size = (size_t )0;
#line 239
  data->rate = -1;
#line 240
  data->establishrate = -1;
#line 241
  data->establishhighrate = -1;
#line 242
  data->timeout = 0;
#line 243
  data->rx_bytes = 0;
#line 244
  data->rx_errors = 0;
#line 245
  data->tx_bytes = 0;
#line 246
  data->tx_errors = 0;
#line 248
  dev->data = (void *)data;
#line 250
  return (dev);
}
}
#line 265 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_connect(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) 
{ 
  struct pi_serial_data *data ;
  struct pi_sockaddr *pa ;
  int err ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  int tmp___3 ;

  {
#line 269
  data = (struct pi_serial_data *)(ps->device)->data;
#line 271
  pa = (struct pi_sockaddr *)addr;
#line 274
  if (ps->type == 16) {
#line 275
    if (ps->protocol == 3) {
#line 276
      tmp = 57600;
#line 276
      data->rate = tmp;
#line 276
      data->establishrate = tmp;
    } else {
#line 278
      if (data->establishrate == -1) {
        {
#line 279
        get_pilot_rate(& data->establishrate, & data->establishhighrate);
        }
      }
#line 282
      data->rate = 9600;
    }
  } else
#line 284
  if (ps->type == 48) {
#line 286
    tmp___0 = 57600;
#line 286
    data->rate = tmp___0;
#line 286
    data->establishrate = tmp___0;
  }
  {
#line 289
  err = (*(data->impl.open))(ps, pa, addrlen);
  }
#line 289
  if (err < 0) {
#line 290
    return (err);
  }
  {
#line 292
  tmp___1 = malloc(addrlen);
#line 292
  ps->raddr = (struct sockaddr *)tmp___1;
#line 293
  memcpy((void */* __restrict  */)ps->raddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 294
  ps->raddrlen = addrlen;
#line 295
  tmp___2 = malloc(addrlen);
#line 295
  ps->laddr = (struct sockaddr *)tmp___2;
#line 296
  memcpy((void */* __restrict  */)ps->laddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 297
  ps->laddrlen = addrlen;
  }
#line 299
  if (ps->type == 16) {
    {
#line 302
    if (ps->cmd == 1) {
#line 302
      goto case_1;
    }
#line 314
    if (ps->cmd == 2) {
#line 314
      goto case_2;
    }
#line 319
    if (ps->cmd == 3) {
#line 319
      goto case_3;
    }
#line 301
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 303
    tmp___3 = cmp_tx_handshake(ps);
    }
#line 303
    if (tmp___3 < 0) {
#line 304
      goto fail;
    }
    {
#line 306
    size = sizeof(data->rate);
#line 307
    pi_getsockopt(ps->sd, 5, 3, (void *)(& data->rate), & size);
#line 310
    err = (*(data->impl.changebaud))(ps);
    }
#line 310
    if (err < 0) {
#line 311
      goto fail;
    }
#line 312
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 315
    err = (*(data->impl.changebaud))(ps);
    }
#line 315
    if (err < 0) {
#line 316
      goto fail;
    }
#line 317
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 320
    err = (*(data->impl.changebaud))(ps);
    }
#line 320
    if (err < 0) {
#line 321
      goto fail;
    }
#line 322
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 325
  ps->state = 4;
#line 326
  ps->command = 0;
#line 327
  return (0);
  fail: 
#line 330
  return (err);
}
}
#line 345 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_bind(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) 
{ 
  struct pi_serial_data *data ;
  struct pi_sockaddr *pa ;
  int err ;
  int count ;
  int tmp ;
  int save_errno ;
  int *tmp___0 ;
  char realport[4096] ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
#line 348
  data = (struct pi_serial_data *)(ps->device)->data;
#line 350
  pa = (struct pi_sockaddr *)addr;
#line 351
  count = 0;
#line 353
  if (ps->type == 16) {
#line 354
    if (data->establishrate == -1) {
      {
#line 355
      get_pilot_rate(& data->establishrate, & data->establishhighrate);
      }
    }
#line 358
    data->rate = 9600;
  } else
#line 359
  if (ps->type == 48) {
#line 361
    tmp = 57600;
#line 361
    data->rate = tmp;
#line 361
    data->establishrate = tmp;
  }
  begin: 
  {
#line 365
  err = (*(data->impl.open))(ps, pa, addrlen);
  }
#line 365
  if (err < 0) {
    {
#line 366
    tmp___0 = __errno_location();
#line 366
    save_errno = *tmp___0;
#line 377
    realpath((char const   */* __restrict  */)(pa->pi_device), (char */* __restrict  */)(realport));
#line 378
    tmp___1 = __errno_location();
#line 378
    *tmp___1 = save_errno;
#line 380
    tmp___7 = __errno_location();
    }
#line 380
    if (*tmp___7 == 2) {
      {
#line 381
      pi_log(2, 1, " The device %s does not exist..\n", pa->pi_device);
#line 384
      pi_log(2, 1, " Possible solution:\n\n\tmknod %s c <major> <minor>\n\n", pa->pi_device);
      }
    } else {
      {
#line 387
      tmp___6 = __errno_location();
      }
#line 387
      if (*tmp___6 == 13) {
        {
#line 388
        pi_log(2, 1, "   Please check the permissions on %s..\n", realport);
#line 391
        pi_log(2, 1, " Possible solution:\n\n\tchmod 0666 %s\n\n", realport);
        }
      } else {
        {
#line 394
        tmp___5 = __errno_location();
        }
#line 394
        if (*tmp___5 == 19) {
          {
#line 395
          while (1) {
            while_continue: /* CIL Label */ ;
#line 395
            if (! (count <= 5)) {
#line 395
              goto while_break;
            }
            {
#line 396
            tmp___2 = fileno(stdout);
#line 396
            tmp___3 = isatty(tmp___2);
            }
#line 396
            if (tmp___3) {
              {
#line 397
              pi_log(2, 1, "\r   Port not connected, sleeping for 2 seconds, ");
#line 400
              pi_log(2, 1, "%d retries..", 5 - count);
              }
            }
            {
#line 404
            sleep(2U);
#line 405
            count ++;
            }
#line 406
            goto begin;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 408
          pi_log(2, 1, "\n\n   Device not found on %s, \t\t\t\t\tDid you hit HotSync?\n\n",
                 realport);
          }
        } else {
          {
#line 411
          tmp___4 = __errno_location();
          }
#line 411
          if (*tmp___4 == 21) {
            {
#line 412
            pi_log(2, 1, " The port specified must contain a device name, and %s was a directory.\n   Please change that to reference a real device, and try again\n\n",
                   pa->pi_device);
            }
          }
        }
      }
    }
#line 420
    return (err);
  }
  {
#line 422
  tmp___8 = malloc(addrlen);
#line 422
  ps->raddr = (struct sockaddr *)tmp___8;
#line 423
  memcpy((void */* __restrict  */)ps->raddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 424
  ps->raddrlen = addrlen;
#line 425
  tmp___9 = malloc(addrlen);
#line 425
  ps->laddr = (struct sockaddr *)tmp___9;
#line 426
  memcpy((void */* __restrict  */)ps->laddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 427
  ps->laddrlen = addrlen;
  }
#line 429
  return (0);
}
}
#line 443 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_listen(pi_socket_t *ps , int backlog ) 
{ 
  int result ;
  struct pi_serial_data *data ;

  {
  {
#line 446
  data = (struct pi_serial_data *)(ps->device)->data;
#line 450
  result = (*(data->impl.changebaud))(ps);
  }
#line 451
  if (result == 0) {
#line 452
    ps->state = 1;
  }
#line 454
  return (result);
}
}
#line 468 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_accept(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) 
{ 
  struct pi_serial_data *data ;
  size_t size ;
  int err ;
  int result ;
  int tmp ;
  char buf___3[6] ;
  struct timeval tv ;
  unsigned char cmp_flags ;
  int use_long_format ;

  {
#line 472
  data = (struct pi_serial_data *)(ps->device)->data;
#line 479
  if (ps->accept_to) {
    {
#line 481
    tmp = (*(data->impl.poll))(ps, 1000);
#line 481
    result = tmp;
#line 482
    pi_log(2, 8, "%s: %d, poll result: %d.\n", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c",
           482, result);
    }
#line 484
    if (result < 0) {
      {
#line 485
      buf___3[0] = (char)1;
#line 485
      buf___3[1] = (char)0;
#line 485
      buf___3[2] = (char)0;
#line 485
      buf___3[3] = (char)0;
#line 485
      buf___3[4] = (char)0;
#line 485
      buf___3[5] = (char)0;
#line 486
      (*(data->impl.write))(ps, (unsigned char const   *)(buf___3), sizeof(buf___3),
                            1000);
      }
    }
  }
  {
#line 490
  err = (*(data->impl.poll))(ps, ps->accept_to * 1000);
  }
#line 490
  if (err < 0) {
#line 491
    goto fail;
  }
  {
#line 493
  data->timeout = ps->accept_to * 1000;
#line 495
  pi_socket_init(ps);
  }
#line 496
  if (ps->type == 16) {
    {
#line 501
    if (ps->cmd == 1) {
#line 501
      goto case_1;
    }
#line 531
    if (ps->cmd == 2) {
#line 531
      goto case_2;
    }
#line 500
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 502
    err = cmp_rx_handshake(ps, data->establishrate, data->establishhighrate);
    }
#line 502
    if (err < 0) {
#line 503
      goto fail;
    }
    {
#line 506
    size = sizeof(cmp_flags);
#line 507
    pi_getsockopt(ps->sd, 5, 1, (void *)(& cmp_flags), & size);
    }
#line 508
    if ((int )cmp_flags & 16) {
      {
#line 509
      use_long_format = 1;
#line 510
      size = sizeof(int );
#line 511
      pi_setsockopt(ps->sd, 2, 3, (void const   *)(& use_long_format), & size);
#line 513
      ps->command ^= 1;
#line 514
      pi_setsockopt(ps->sd, 2, 3, (void const   *)(& use_long_format), & size);
#line 516
      ps->command ^= 1;
      }
    }
    {
#line 520
    size = sizeof(data->rate);
#line 521
    pi_getsockopt(ps->sd, 5, 3, (void *)(& data->rate), & size);
#line 522
    err = (*(data->impl.changebaud))(ps);
    }
#line 522
    if (err < 0) {
#line 523
      goto fail;
    }
    {
#line 526
    tv.tv_sec = (__time_t )0;
#line 527
    tv.tv_usec = (__suseconds_t )50000;
#line 528
    select(0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0,
           (struct timeval */* __restrict  */)(& tv));
    }
#line 529
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 561
    err = net_rx_handshake(ps);
    }
#line 561
    if (err < 0) {
#line 562
      goto fail;
    }
#line 563
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 565
    ps->dlprecord = 0;
  }
#line 568
  data->timeout = 0;
#line 569
  ps->command = 0;
#line 570
  ps->state = 2;
#line 572
  return (ps->sd);
  fail: 
#line 575
  return (err);
}
}
#line 590 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_getsockopt(pi_socket_t *ps , int level , int option_name , void *option_value ,
                                size_t *option_len ) 
{ 
  struct pi_serial_data *data ;
  int *tmp ;
  int tmp___0 ;

  {
#line 594
  data = (struct pi_serial_data *)(ps->device)->data;
  {
#line 598
  if (option_name == 0) {
#line 598
    goto case_0;
  }
#line 604
  if (option_name == 1) {
#line 604
    goto case_1;
  }
#line 610
  if (option_name == 2) {
#line 610
    goto case_2;
  }
#line 616
  if (option_name == 3) {
#line 616
    goto case_3;
  }
#line 597
  goto switch_break;
  case_0: /* CIL Label */ 
#line 599
  if (*option_len != sizeof(data->rate)) {
#line 600
    goto error;
  }
  {
#line 601
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->rate),
         sizeof(data->rate));
  }
#line 602
  goto switch_break;
  case_1: /* CIL Label */ 
#line 605
  if (*option_len != sizeof(data->establishrate)) {
#line 606
    goto error;
  }
  {
#line 607
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->establishrate),
         sizeof(data->establishrate));
  }
#line 608
  goto switch_break;
  case_2: /* CIL Label */ 
#line 611
  if (*option_len != sizeof(data->establishhighrate)) {
#line 612
    goto error;
  }
  {
#line 613
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->establishhighrate),
         sizeof(data->establishhighrate));
  }
#line 614
  goto switch_break;
  case_3: /* CIL Label */ 
#line 617
  if (*option_len != sizeof(data->timeout)) {
#line 618
    goto error;
  }
  {
#line 619
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->timeout),
         sizeof(data->timeout));
  }
#line 620
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 623
  return (0);
  error: 
  {
#line 626
  tmp = __errno_location();
#line 626
  *tmp = 22;
#line 627
  tmp___0 = pi_set_error(ps->sd, -501);
  }
#line 627
  return (tmp___0);
}
}
#line 642 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_setsockopt(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                                size_t *option_len ) 
{ 
  struct pi_serial_data *data ;
  int *tmp ;
  int tmp___0 ;

  {
#line 646
  data = (struct pi_serial_data *)(ps->device)->data;
  {
#line 651
  if (option_name == 1) {
#line 651
    goto case_1;
  }
#line 657
  if (option_name == 2) {
#line 657
    goto case_2;
  }
#line 663
  if (option_name == 3) {
#line 663
    goto case_3;
  }
#line 650
  goto switch_break;
  case_1: /* CIL Label */ 
#line 652
  if (*option_len != sizeof(data->establishrate)) {
#line 653
    goto error;
  }
  {
#line 654
  memcpy((void */* __restrict  */)(& data->establishrate), (void const   */* __restrict  */)option_value,
         sizeof(data->establishrate));
  }
#line 655
  goto switch_break;
  case_2: /* CIL Label */ 
#line 658
  if (*option_len != sizeof(data->establishhighrate)) {
#line 659
    goto error;
  }
  {
#line 660
  memcpy((void */* __restrict  */)(& data->establishhighrate), (void const   */* __restrict  */)option_value,
         sizeof(data->establishhighrate));
  }
#line 661
  goto switch_break;
  case_3: /* CIL Label */ 
#line 664
  if (*option_len != sizeof(data->timeout)) {
#line 665
    goto error;
  }
  {
#line 666
  memcpy((void */* __restrict  */)(& data->timeout), (void const   */* __restrict  */)option_value,
         sizeof(data->timeout));
  }
#line 667
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 670
  return (0);
  error: 
  {
#line 673
  tmp = __errno_location();
#line 673
  *tmp = 22;
#line 674
  tmp___0 = pi_set_error(ps->sd, -501);
  }
#line 674
  return (tmp___0);
}
}
#line 689 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_close(pi_socket_t *ps ) 
{ 
  struct pi_serial_data *data ;

  {
#line 691
  data = (struct pi_serial_data *)(ps->device)->data;
#line 694
  if (ps->sd) {
    {
#line 695
    (*(data->impl.close))(ps);
#line 696
    ps->sd = 0;
    }
  }
#line 699
  if (ps->laddr) {
    {
#line 700
    free((void *)ps->laddr);
#line 701
    ps->laddr = (struct sockaddr *)((void *)0);
    }
  }
#line 704
  if (ps->raddr) {
    {
#line 705
    free((void *)ps->raddr);
#line 706
    ps->raddr = (struct sockaddr *)((void *)0);
    }
  }
#line 709
  return (0);
}
}
#line 49 "../include/pi-memo.h"
void free_Memo(struct Memo *memo ) ;
#line 50
int unpack_Memo(struct Memo *memo , pi_buffer_t const   *record , memoType type ) ;
#line 52
int pack_Memo(struct Memo  const  *memo , pi_buffer_t *record , memoType type ) ;
#line 54
int unpack_MemoAppInfo(struct MemoAppInfo *appinfo , unsigned char const   *record ,
                       size_t len ) ;
#line 57
int pack_MemoAppInfo(struct MemoAppInfo  const  *appinfo , unsigned char *record ,
                     size_t len ) ;
#line 41 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/memo.c"
void free_Memo(struct Memo *memo ) 
{ 


  {
#line 44
  if ((unsigned long )memo->text != (unsigned long )((void *)0)) {
    {
#line 45
    free((void *)memo->text);
#line 46
    memo->text = (char *)((void *)0);
    }
  }
#line 48
  return;
}
}
#line 62 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/memo.c"
int unpack_Memo(struct Memo *memo , pi_buffer_t const   *record , memoType type ) 
{ 


  {
#line 65
  if ((unsigned int )type != 0U) {
#line 67
    return (-1);
  }
#line 68
  if ((unsigned long )record == (unsigned long )((void *)0)) {
#line 69
    return (-1);
  } else
#line 68
  if ((unsigned long )record->data == (unsigned long )((void *)0)) {
#line 69
    return (-1);
  } else
#line 68
  if (record->used < 1UL) {
#line 69
    return (-1);
  }
  {
#line 70
  memo->text = strdup((char const   *)((char *)record->data));
  }
#line 71
  return (0);
}
}
#line 86 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/memo.c"
int pack_Memo(struct Memo  const  *memo , pi_buffer_t *record , memoType type ) 
{ 
  size_t destlen ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 89
  if (memo->text) {
    {
#line 89
    tmp = strlen((char const   *)memo->text);
#line 89
    tmp___0 = tmp;
    }
  } else {
#line 89
    tmp___0 = (size_t )0;
  }
#line 89
  destlen = tmp___0 + 1UL;
#line 91
  if ((unsigned int )type != 0U) {
#line 93
    return (-1);
  }
#line 94
  if ((unsigned long )record == (unsigned long )((void *)0)) {
#line 95
    return (-1);
  }
  {
#line 97
  pi_buffer_expect(record, destlen);
#line 98
  record->used = destlen;
  }
#line 100
  if (memo->text) {
    {
#line 101
    strcpy((char */* __restrict  */)((char *)record->data), (char const   */* __restrict  */)memo->text);
    }
  } else {
#line 103
    *(record->data + 0) = (unsigned char)0;
  }
#line 105
  return (0);
}
}
#line 120 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/memo.c"
int unpack_MemoAppInfo(struct MemoAppInfo *appinfo , unsigned char const   *record ,
                       size_t len ) 
{ 
  int i ;
  int tmp ;
  unsigned char *start ;

  {
  {
#line 124
  tmp = unpack_CategoryAppInfo(& appinfo->category, record, len);
#line 124
  i = tmp;
#line 125
  start = (unsigned char *)record;
#line 127
  appinfo->type = (memoType )0;
  }
#line 129
  if (! i) {
#line 130
    return (i);
  }
#line 131
  record += i;
#line 132
  len -= (size_t )i;
#line 133
  if (len >= 4UL) {
#line 134
    record += 2;
#line 135
    appinfo->sortByAlpha = (int )*((unsigned char *)record + 0);
#line 136
    record += 2;
  } else {
#line 138
    appinfo->sortByAlpha = 0;
  }
#line 140
  return ((int )(record - (unsigned char const   *)start));
}
}
#line 155 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/memo.c"
int pack_MemoAppInfo(struct MemoAppInfo  const  *appinfo , unsigned char *record ,
                     size_t len ) 
{ 
  int i ;
  unsigned char *start ;

  {
  {
#line 159
  start = record;
#line 161
  i = pack_CategoryAppInfo(& appinfo->category, record, len);
  }
#line 162
  if (! record) {
#line 163
    return (i + 4);
  }
#line 164
  if (i == 0) {
#line 165
    return (0);
  }
#line 166
  record += i;
#line 167
  len -= (size_t )i;
#line 168
  if (len < 4UL) {
#line 169
    return ((int )(record - start));
  }
#line 170
  *(record + 0) = (unsigned char)0;
#line 170
  *(record + 1) = (unsigned char)0;
#line 171
  record += 2;
#line 172
  *(record + 0) = (unsigned char )appinfo->sortByAlpha;
#line 173
  record ++;
#line 174
  *(record + 0) = (unsigned char)0;
#line 175
  record ++;
#line 177
  return ((int )(record - start));
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 64 "../include/pi-veo.h"
void free_Veo(Veo_t *veo ) ;
#line 65
int unpack_Veo(Veo_t *veo , unsigned char *buffer , size_t len ) ;
#line 66
int unpack_VeoAppInfo(struct VeoAppInfo *appinfo , unsigned char *record , size_t len ) ;
#line 67
int pack_Veo(Veo_t *veo , unsigned char *buf___3 , size_t len ) ;
#line 68
int pack_VeoAppInfo(struct VeoAppInfo *appinfo , unsigned char *record , size_t len ) ;
#line 37 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/veo.c"
void free_Veo(Veo_t *veo ) 
{ 


  {
#line 40
  return;
}
}
#line 49 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/veo.c"
int unpack_Veo(Veo_t *veo , unsigned char *buffer , size_t len ) 
{ 
  unsigned char *start ;

  {
#line 52
  start = buffer;
#line 55
  buffer ++;
#line 56
  veo->quality = *(buffer + 0);
#line 57
  buffer ++;
#line 58
  veo->resolution = *(buffer + 0);
#line 59
  buffer ++;
#line 61
  buffer += 12;
#line 62
  veo->picnum = ((((unsigned long )*(buffer + 0) << 24) | ((unsigned long )*(buffer + 1) << 16)) | ((unsigned long )*(buffer + 2) << 8)) | (unsigned long )*(buffer + 3);
#line 63
  buffer += 4;
#line 64
  veo->day = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 65
  buffer += 2;
#line 66
  veo->month = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 67
  buffer += 2;
#line 68
  veo->year = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 69
  buffer += 2;
#line 71
  if ((int )veo->resolution == 0) {
#line 73
    veo->width = (unsigned short)640;
#line 74
    veo->height = (unsigned short)480;
  } else
#line 76
  if ((int )veo->resolution == 1) {
#line 78
    veo->width = (unsigned short)320;
#line 79
    veo->height = (unsigned short)240;
  } else {
    {
#line 82
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unknown resolution\n");
    }
  }
#line 84
  return ((int )(buffer - start));
}
}
#line 95 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/veo.c"
int pack_Veo(Veo_t *veo , unsigned char *buf___3 , size_t len ) 
{ 


  {
#line 97
  return (0);
}
}
#line 108 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/veo.c"
int unpack_VeoAppInfo(struct VeoAppInfo *appinfo , unsigned char *record , size_t len ) 
{ 
  int i ;
  unsigned char *start ;

  {
  {
#line 112
  start = record;
#line 114
  i = unpack_CategoryAppInfo(& appinfo->category, (unsigned char const   *)record,
                             len);
  }
#line 115
  if (! i) {
#line 116
    return (0);
  }
#line 117
  record += i;
#line 118
  len -= (size_t )i;
#line 119
  if (len < 4UL) {
#line 120
    return (0);
  }
#line 121
  appinfo->dirty = (int )((unsigned short )(((int )*(record + 0) << 8) | (int )*(record + 1)));
#line 122
  record += 2;
#line 123
  appinfo->sortByPriority = (int )*(record + 0);
#line 124
  record += 2;
#line 125
  return ((int )(record - start));
}
}
#line 136 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/veo.c"
int pack_VeoAppInfo(struct VeoAppInfo *appinfo , unsigned char *record , size_t len ) 
{ 
  int i ;
  unsigned char *start ;

  {
  {
#line 140
  start = record;
#line 142
  i = pack_CategoryAppInfo((CategoryAppInfo_t const   *)(& appinfo->category), record,
                           len);
  }
#line 143
  if (! record) {
#line 144
    return (i + 4);
  }
#line 145
  if (! i) {
#line 146
    return (0);
  }
#line 147
  record += i;
#line 148
  len -= (size_t )i;
#line 149
  if (len < 4UL) {
#line 150
    return (0);
  }
#line 151
  *(record + 0) = (unsigned char )(((int )((unsigned short )appinfo->dirty) >> 8) & 255);
#line 151
  *(record + 1) = (unsigned char )((int )((unsigned short )appinfo->dirty) & 255);
#line 152
  *((record + 2) + 0) = (unsigned char )appinfo->sortByPriority;
#line 153
  *((record + 3) + 0) = (unsigned char)0;
#line 154
  record += 4;
#line 156
  return ((int )(record - start));
}
}
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 199 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp ) ;
#line 85 "../include/pi-location.h"
void free_Timezone(Timezone_t *tz ) ;
#line 96
int unpack_Timezone_p(Timezone_t *tz , unsigned char const   *data , size_t const   position ) ;
#line 108
Timezone_t *dup_Timezone(Timezone_t const   *tz ) ;
#line 110 "../include/pi-calendar.h"
void new_CalendarEvent(CalendarEvent_t *a ) ;
#line 112
void free_CalendarEvent(CalendarEvent_t *a ) ;
#line 114
int unpack_CalendarEvent(CalendarEvent_t *a , pi_buffer_t const   *buf___3 , calendarType type ) ;
#line 116
int pack_CalendarEvent(CalendarEvent_t const   *a , pi_buffer_t *buf___3 , calendarType type ) ;
#line 118
int unpack_CalendarAppInfo(CalendarAppInfo_t *ai , pi_buffer_t *buf___3 ) ;
#line 120
int pack_CalendarAppInfo(CalendarAppInfo_t const   *ai , pi_buffer_t *buf___3 ) ;
#line 123
int copy_CalendarEvent(CalendarEvent_t const   *source , CalendarEvent_t *dest ) ;
#line 61 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/calendar.c"
void new_CalendarEvent(CalendarEvent_t *a ) 
{ 
  int i ;

  {
#line 64
  i = 0;
#line 66
  a->event = 0;
#line 67
  a->begin.tm_hour = 0;
#line 68
  a->begin.tm_min = 0;
#line 69
  a->begin.tm_sec = 0;
#line 70
  a->begin.tm_year = 2000;
#line 71
  a->begin.tm_mon = 0;
#line 72
  a->begin.tm_mday = 0;
#line 73
  a->begin.tm_isdst = -1;
#line 74
  a->end.tm_hour = 0;
#line 75
  a->end.tm_min = 0;
#line 76
  a->end.tm_sec = 0;
#line 77
  a->end.tm_year = 2000;
#line 78
  a->end.tm_mon = 0;
#line 79
  a->end.tm_mday = 0;
#line 80
  a->end.tm_isdst = -1;
#line 81
  a->alarm = 0;
#line 82
  a->advance = 0;
#line 83
  a->advanceUnits = 0;
#line 84
  a->repeatType = (enum calendarRepeatType )0;
#line 85
  a->repeatForever = 0;
#line 86
  a->repeatEnd.tm_hour = 0;
#line 87
  a->repeatEnd.tm_min = 0;
#line 88
  a->repeatEnd.tm_sec = 0;
#line 89
  a->repeatEnd.tm_year = 2000;
#line 90
  a->repeatEnd.tm_mon = 0;
#line 91
  a->repeatEnd.tm_mday = 0;
#line 92
  a->repeatEnd.tm_isdst = -1;
#line 94
  a->repeatFrequency = 0;
#line 95
  a->repeatDay = (enum calendarDayOfMonthType )0;
#line 96
  i = 0;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! (i < 7)) {
#line 96
      goto while_break;
    }
#line 97
    a->repeatDays[i] = 0;
#line 96
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  a->repeatWeekstart = 0;
#line 100
  a->exceptions = 0;
#line 101
  a->exception = (struct tm *)((void *)0);
#line 102
  a->description = (char *)((void *)0);
#line 103
  a->note = (char *)((void *)0);
#line 104
  a->location = (char *)((void *)0);
#line 105
  a->tz = (Timezone_t *)((void *)0);
#line 108
  i = 0;
  {
#line 108
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 108
    if (! (i < 10)) {
#line 108
      goto while_break___0;
    }
#line 109
    a->blob[i] = (Blob_t *)((void *)0);
#line 108
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 111
  return;
}
}
#line 126 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/calendar.c"
int copy_CalendarEvent(CalendarEvent_t const   *source , CalendarEvent_t *dest ) 
{ 
  int i ;
  void *tmp ;
  int *tmp___0 ;

  {
  {
#line 129
  i = 0;
#line 131
  dest->event = (int )source->event;
#line 132
  memcpy((void */* __restrict  */)(& dest->begin), (void const   */* __restrict  */)(& source->begin),
         sizeof(struct tm ));
#line 133
  memcpy((void */* __restrict  */)(& dest->end), (void const   */* __restrict  */)(& source->end),
         sizeof(struct tm ));
#line 134
  dest->alarm = (int )source->alarm;
#line 135
  dest->advance = (int )source->advance;
#line 136
  dest->advanceUnits = (int )source->advanceUnits;
#line 137
  dest->repeatType = (enum calendarRepeatType )source->repeatType;
#line 138
  dest->repeatForever = (int )source->repeatForever;
#line 139
  memcpy((void */* __restrict  */)(& dest->repeatEnd), (void const   */* __restrict  */)(& source->repeatEnd),
         sizeof(struct tm ));
#line 141
  dest->repeatFrequency = (int )source->repeatFrequency;
#line 142
  dest->repeatDay = (enum calendarDayOfMonthType )source->repeatDay;
#line 143
  i = 0;
  }
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (i < 7)) {
#line 143
      goto while_break;
    }
#line 144
    dest->repeatDays[i] = source->repeatDays[i];
#line 143
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  dest->repeatWeekstart = (int )source->repeatWeekstart;
#line 147
  dest->exceptions = (int )source->exceptions;
#line 148
  if (source->exceptions > 0) {
    {
#line 149
    tmp = malloc((unsigned long )source->exceptions * sizeof(struct tm ));
#line 149
    dest->exception = (struct tm *)tmp;
    }
#line 150
    if ((unsigned long )((void *)0) == (unsigned long )dest->exception) {
      {
#line 151
      tmp___0 = __errno_location();
#line 151
      *tmp___0 = 12;
      }
#line 152
      return (-1);
    }
#line 154
    i = 0;
    {
#line 154
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 154
      if (! (i < (int )source->exceptions)) {
#line 154
        goto while_break___0;
      }
      {
#line 155
      memcpy((void */* __restrict  */)(dest->exception + i), (void const   */* __restrict  */)(source->exception + i),
             sizeof(struct tm ));
#line 154
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 158
  if ((unsigned long )((void *)0) != (unsigned long )source->description) {
    {
#line 159
    dest->description = strdup((char const   *)source->description);
    }
  } else {
#line 161
    dest->description = (char *)((void *)0);
  }
#line 163
  if ((unsigned long )((void *)0) != (unsigned long )source->note) {
    {
#line 164
    dest->note = strdup((char const   *)source->note);
    }
  } else {
#line 166
    dest->note = (char *)((void *)0);
  }
#line 168
  if ((unsigned long )((void *)0) != (unsigned long )source->location) {
    {
#line 169
    dest->location = strdup((char const   *)source->location);
    }
  } else {
#line 171
    dest->location = (char *)((void *)0);
  }
#line 175
  i = 0;
  {
#line 175
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 175
    if (! (i < 10)) {
#line 175
      goto while_break___1;
    }
#line 176
    if ((unsigned long )source->blob[i] != (unsigned long )((void *)0)) {
      {
#line 177
      dest->blob[i] = dup_Blob((Blob_t const   *)source->blob[i]);
      }
#line 178
      if ((unsigned long )((void *)0) == (unsigned long )dest->blob[i]) {
#line 179
        return (-1);
      }
    } else {
#line 182
      dest->blob[i] = (Blob_t *)((void *)0);
    }
#line 175
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 186
  if ((unsigned long )source->tz != (unsigned long )((void *)0)) {
    {
#line 187
    dest->tz = dup_Timezone((Timezone_t const   *)source->tz);
    }
#line 188
    if ((unsigned long )((void *)0) == (unsigned long )dest->tz) {
#line 189
      return (-1);
    }
  } else {
#line 192
    dest->tz = (Timezone_t *)((void *)0);
  }
#line 195
  return (0);
}
}
#line 209 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/calendar.c"
void free_CalendarEvent(CalendarEvent_t *a ) 
{ 
  int i ;

  {
#line 214
  if ((unsigned long )a->exception != (unsigned long )((void *)0)) {
    {
#line 215
    free((void *)a->exception);
#line 216
    a->exception = (struct tm *)((void *)0);
    }
  }
#line 219
  if ((unsigned long )a->description != (unsigned long )((void *)0)) {
    {
#line 220
    free((void *)a->description);
#line 221
    a->description = (char *)((void *)0);
    }
  }
#line 224
  if ((unsigned long )a->note != (unsigned long )((void *)0)) {
    {
#line 225
    free((void *)a->note);
#line 226
    a->note = (char *)((void *)0);
    }
  }
#line 229
  if ((unsigned long )a->location != (unsigned long )((void *)0)) {
    {
#line 230
    free((void *)a->location);
#line 231
    a->location = (char *)((void *)0);
    }
  }
#line 234
  if ((unsigned long )((void *)0) != (unsigned long )a->tz) {
    {
#line 235
    free_Timezone(a->tz);
#line 236
    free((void *)a->tz);
    }
  }
#line 239
  i = 0;
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 239
    if (! (i < 10)) {
#line 239
      goto while_break;
    }
#line 240
    if ((unsigned long )((void *)0) != (unsigned long )a->blob[i]) {
      {
#line 241
      free_Blob(a->blob[i]);
#line 243
      free((void *)a->blob[i]);
#line 244
      a->blob[i] = (Blob_t *)((void *)0);
      }
    }
#line 239
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 247
  return;
}
}
#line 261 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/calendar.c"
int unpack_CalendarEvent(CalendarEvent_t *a , pi_buffer_t const   *buf___3 , calendarType type ) 
{ 
  int iflags ;
  int j ;
  int destlen ;
  int i ;
  int result ;
  unsigned char *p2 ;
  unsigned long d ;
  int i___0 ;
  int on ;
  int i___1 ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  uint8_t blob_count ;
  void *tmp___3 ;
  int result___0 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
#line 272
  destlen = 8;
#line 274
  if ((unsigned int )type != 0U) {
#line 275
    return (-1);
  }
#line 277
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
#line 278
    return (-1);
  } else
#line 277
  if ((unsigned long )buf___3->data == (unsigned long )((void *)0)) {
#line 278
    return (-1);
  } else
#line 277
  if (buf___3->used < (size_t const   )destlen) {
#line 278
    return (-1);
  }
#line 281
  a->begin.tm_hour = (int )*((unsigned char *)buf___3->data + 0);
#line 282
  a->begin.tm_min = (int )*((unsigned char *)(buf___3->data + 1) + 0);
#line 283
  a->begin.tm_sec = 0;
#line 284
  d = (unsigned long )((unsigned short )(((int )*((unsigned char *)(buf___3->data + 4) + 0) << 8) | (int )*((unsigned char *)(buf___3->data + 4) + 1)));
#line 285
  a->begin.tm_year = (int )((d >> 9) + 4UL);
#line 286
  a->begin.tm_mon = (int )(((d >> 5) & 15UL) - 1UL);
#line 287
  a->begin.tm_mday = (int )(d & 31UL);
#line 288
  a->begin.tm_isdst = -1;
#line 289
  a->end = a->begin;
#line 291
  a->end.tm_hour = (int )*((unsigned char *)(buf___3->data + 2) + 0);
#line 292
  a->end.tm_min = (int )*((unsigned char *)(buf___3->data + 3) + 0);
#line 294
  if ((int )((unsigned short )(((int )*((unsigned char *)buf___3->data + 0) << 8) | (int )*((unsigned char *)buf___3->data + 1))) == 65535) {
#line 295
    a->event = 1;
#line 296
    a->begin.tm_hour = 0;
#line 297
    a->begin.tm_min = 0;
#line 298
    a->end.tm_hour = 0;
#line 299
    a->end.tm_min = 0;
  } else {
#line 301
    a->event = 0;
  }
  {
#line 304
  mktime(& a->begin);
#line 305
  mktime(& a->end);
#line 307
  iflags = (int )*((unsigned char *)(buf___3->data + 6) + 0);
#line 311
  p2 = (unsigned char *)buf___3->data + 8;
  }
#line 313
  if (iflags & 64) {
#line 314
    a->alarm = 1;
#line 315
    a->advance = (int )*(p2 + 0);
#line 316
    p2 ++;
#line 317
    a->advanceUnits = (int )*(p2 + 0);
#line 318
    p2 ++;
  } else {
#line 321
    a->alarm = 0;
#line 322
    a->advance = 0;
#line 323
    a->advanceUnits = 0;
  }
#line 326
  if (iflags & 32) {
#line 330
    a->repeatType = (enum calendarRepeatType )*(p2 + 0);
#line 331
    p2 += 2;
#line 332
    d = (unsigned long )((unsigned short )(((int )*(p2 + 0) << 8) | (int )*(p2 + 1)));
#line 333
    p2 += 2;
#line 334
    if (d == 65535UL) {
#line 335
      a->repeatForever = 1;
    } else {
      {
#line 337
      a->repeatEnd.tm_year = (int )((d >> 9) + 4UL);
#line 338
      a->repeatEnd.tm_mon = (int )(((d >> 5) & 15UL) - 1UL);
#line 339
      a->repeatEnd.tm_mday = (int )(d & 31UL);
#line 340
      a->repeatEnd.tm_min = 0;
#line 341
      a->repeatEnd.tm_hour = 0;
#line 342
      a->repeatEnd.tm_sec = 0;
#line 343
      a->repeatEnd.tm_isdst = -1;
#line 344
      mktime(& a->repeatEnd);
#line 345
      a->repeatForever = 0;
      }
    }
#line 347
    a->repeatFrequency = (int )*(p2 + 0);
#line 348
    p2 ++;
#line 349
    on = (int )*(p2 + 0);
#line 350
    p2 ++;
#line 351
    a->repeatDay = (enum calendarDayOfMonthType )0;
#line 352
    i___0 = 0;
    {
#line 352
    while (1) {
      while_continue: /* CIL Label */ ;
#line 352
      if (! (i___0 < 7)) {
#line 352
        goto while_break;
      }
#line 353
      a->repeatDays[i___0] = 0;
#line 352
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 355
    if ((unsigned int )a->repeatType == 3U) {
#line 356
      a->repeatDay = (enum calendarDayOfMonthType )on;
    } else
#line 357
    if ((unsigned int )a->repeatType == 2U) {
#line 358
      i___0 = 0;
      {
#line 358
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 358
        if (! (i___0 < 7)) {
#line 358
          goto while_break___0;
        }
#line 359
        a->repeatDays[i___0] = ! (! (on & (1 << i___0)));
#line 358
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 360
    a->repeatWeekstart = (int )*(p2 + 0);
#line 361
    p2 ++;
#line 362
    p2 ++;
  } else {
#line 366
    a->repeatType = (enum calendarRepeatType )0;
#line 367
    a->repeatForever = 1;
#line 368
    a->repeatFrequency = 0;
#line 369
    a->repeatDay = (enum calendarDayOfMonthType )0;
#line 370
    i___1 = 0;
    {
#line 370
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 370
      if (! (i___1 < 7)) {
#line 370
        goto while_break___1;
      }
#line 371
      a->repeatDays[i___1] = 0;
#line 370
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 372
    a->repeatWeekstart = 0;
  }
#line 375
  if (iflags & 8) {
    {
#line 376
    a->exceptions = (int )((unsigned short )(((int )*(p2 + 0) << 8) | (int )*(p2 + 1)));
#line 377
    p2 += 2;
#line 378
    tmp = malloc(sizeof(struct tm ) * (unsigned long )a->exceptions);
#line 378
    a->exception = (struct tm *)tmp;
#line 380
    j = 0;
    }
    {
#line 380
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 380
      if (! (j < a->exceptions)) {
#line 380
        goto while_break___2;
      }
      {
#line 381
      d = (unsigned long )((unsigned short )(((int )*(p2 + 0) << 8) | (int )*(p2 + 1)));
#line 382
      (a->exception + j)->tm_year = (int )((d >> 9) + 4UL);
#line 383
      (a->exception + j)->tm_mon = (int )(((d >> 5) & 15UL) - 1UL);
#line 384
      (a->exception + j)->tm_mday = (int )(d & 31UL);
#line 385
      (a->exception + j)->tm_hour = 0;
#line 386
      (a->exception + j)->tm_min = 0;
#line 387
      (a->exception + j)->tm_sec = 0;
#line 388
      (a->exception + j)->tm_isdst = -1;
#line 389
      mktime(a->exception + j);
#line 380
      j ++;
#line 380
      p2 += 2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 393
    a->exceptions = 0;
#line 394
    a->exception = (struct tm *)0;
  }
#line 397
  if (iflags & 4) {
    {
#line 398
    a->description = strdup((char const   *)((char *)p2));
#line 399
    tmp___0 = strlen((char const   *)((char *)p2));
#line 399
    p2 += tmp___0 + 1UL;
    }
  } else {
#line 401
    a->description = (char *)0;
  }
#line 403
  if (iflags & 16) {
    {
#line 404
    a->note = strdup((char const   *)((char *)p2));
#line 405
    tmp___1 = strlen((char const   *)((char *)p2));
#line 405
    p2 += tmp___1 + 1UL;
    }
  } else {
#line 407
    a->note = (char *)0;
  }
#line 410
  if (iflags & 2) {
    {
#line 411
    a->location = strdup((char const   *)((char *)p2));
#line 412
    tmp___2 = strlen((char const   *)((char *)p2));
#line 412
    p2 += tmp___2 + 1UL;
    }
  } else {
#line 414
    a->location = (char *)0;
  }
#line 418
  i = 0;
  {
#line 418
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 418
    if (! (i < 10)) {
#line 418
      goto while_break___3;
    }
#line 419
    a->blob[i] = (Blob_t *)((void *)0);
#line 418
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 422
  if ((size_t const   )(p2 - (unsigned char *)buf___3->data) < buf___3->used) {
#line 426
    a->tz = (Timezone_t *)((void *)0);
#line 427
    blob_count = (uint8_t )0;
    {
#line 427
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 427
      if (! (buf___3->used - (size_t const   )(p2 - (unsigned char *)buf___3->data) > 6UL)) {
#line 427
        goto while_break___4;
      }
#line 428
      if ((int )blob_count >= 10) {
        {
#line 430
        printf((char const   */* __restrict  */)"Error, found more than %d blobs: %d\n",
               10, (int )blob_count);
        }
#line 431
        return (-1);
      }
      {
#line 434
      tmp___3 = malloc(sizeof(Blob_t ));
#line 434
      a->blob[blob_count] = (Blob_t *)tmp___3;
#line 435
      result = unpack_Blob_p(a->blob[blob_count], (unsigned char const   *)p2, (size_t const   )0);
      }
#line 436
      if (-1 == result) {
#line 437
        return (-1);
      } else {
#line 439
        p2 += result;
      }
      {
#line 444
      tmp___5 = memcmp((void const   *)((a->blob[blob_count])->type), (void const   *)"Bd00",
                       (size_t )4);
      }
#line 444
      if (0 == tmp___5) {
#line 446
        if ((unsigned long )((void *)0) != (unsigned long )a->tz) {
          {
#line 447
          printf((char const   */* __restrict  */)"Warning: Found more than one timezone blob! Freeing the previous one and starting again\n");
#line 448
          free_Timezone(a->tz);
#line 449
          free((void *)a->tz);
          }
        }
        {
#line 451
        tmp___4 = malloc(sizeof(Timezone_t ));
#line 451
        a->tz = (Timezone_t *)tmp___4;
#line 452
        result___0 = unpack_Timezone_p(a->tz, (unsigned char const   *)(a->blob[blob_count])->data,
                                       (size_t const   )0);
        }
#line 453
        if (-1 == result___0) {
          {
#line 454
          printf((char const   */* __restrict  */)"Error unpacking timezone blob\n");
          }
#line 455
          return (-1);
        } else
#line 456
        if (result___0 != (int )(a->blob[blob_count])->length) {
          {
#line 457
          printf((char const   */* __restrict  */)"Read the wrong number of bytes for a timezone expected %d but was %d\n",
                 (int )(a->blob[blob_count])->length, result___0);
          }
#line 458
          return (-1);
        }
      }
#line 427
      blob_count = (uint8_t )((int )blob_count + 1);
    }
    while_break___4: /* CIL Label */ ;
    }
#line 463
    if ((size_t const   )(p2 - (unsigned char *)buf___3->data) < buf___3->used) {
      {
#line 464
      printf((char const   */* __restrict  */)"Extra data found %ld bytes\n", buf___3->used - (size_t const   )(p2 - (unsigned char *)buf___3->data));
      }
#line 465
      return (-1);
    }
  } else {
#line 468
    a->tz = (Timezone_t *)((void *)0);
  }
#line 471
  return (0);
}
}
#line 487 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/calendar.c"
int pack_CalendarEvent(CalendarEvent_t const   *a , pi_buffer_t *buf___3 , calendarType type ) 
{ 
  int iflags ;
  int destlen ;
  char *pos ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int i ;
  int on ;
  int i___0 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  uint8_t blob_index ;

  {
#line 490
  destlen = 8;
#line 494
  if ((unsigned int )type != 0U) {
#line 495
    return (-1);
  }
#line 497
  if ((unsigned long )a == (unsigned long )((void *)0)) {
#line 498
    return (-1);
  } else
#line 497
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
#line 498
    return (-1);
  }
#line 500
  if (a->alarm) {
#line 501
    destlen += 2;
  }
#line 502
  if (a->repeatType) {
#line 503
    destlen += 8;
  }
#line 504
  if (a->exceptions) {
#line 505
    destlen += 2 + 2 * (int )a->exceptions;
  }
#line 506
  if (a->note) {
    {
#line 507
    tmp = strlen((char const   *)a->note);
#line 507
    destlen = (int )((size_t )destlen + (tmp + 1UL));
    }
  }
#line 508
  if (a->description) {
    {
#line 509
    tmp___0 = strlen((char const   *)a->description);
#line 509
    destlen = (int )((size_t )destlen + (tmp___0 + 1UL));
    }
  }
#line 510
  if (a->location) {
    {
#line 511
    tmp___1 = strlen((char const   *)a->location);
#line 511
    destlen = (int )((size_t )destlen + (tmp___1 + 1UL));
    }
  }
  {
#line 513
  pi_buffer_expect(buf___3, (size_t )destlen);
#line 514
  buf___3->used = (size_t )destlen;
#line 516
  *(buf___3->data + 0) = (unsigned char )a->begin.tm_hour;
#line 517
  *((buf___3->data + 1) + 0) = (unsigned char )a->begin.tm_min;
#line 518
  *((buf___3->data + 2) + 0) = (unsigned char )a->end.tm_hour;
#line 519
  *((buf___3->data + 3) + 0) = (unsigned char )a->end.tm_min;
#line 520
  *((buf___3->data + 4) + 0) = (unsigned char )(((int )((unsigned short )((((a->begin.tm_year - 4) << 9) | ((a->begin.tm_mon + 1) << 5)) | a->begin.tm_mday)) >> 8) & 255);
#line 520
  *((buf___3->data + 4) + 1) = (unsigned char )((int )((unsigned short )((((a->begin.tm_year - 4) << 9) | ((a->begin.tm_mon + 1) << 5)) | a->begin.tm_mday)) & 255);
  }
#line 526
  if (a->event) {
#line 527
    *(buf___3->data + 0) = (unsigned char )((int )((unsigned char )(4294967295UL >> 24)) & 255);
#line 527
    *(buf___3->data + 1) = (unsigned char )((4294967295UL >> 16) & 255UL);
#line 527
    *(buf___3->data + 2) = (unsigned char )((4294967295UL >> 8) & 255UL);
#line 527
    *(buf___3->data + 3) = (unsigned char)255;
  }
#line 530
  iflags = 0;
#line 532
  pos = (char *)buf___3->data + 8;
#line 534
  if (a->alarm) {
#line 535
    iflags |= 64;
#line 537
    *((unsigned char *)pos + 0) = (unsigned char )a->advance;
#line 538
    *((unsigned char *)(pos + 1) + 0) = (unsigned char )a->advanceUnits;
#line 539
    pos += 2;
  }
#line 542
  if (a->repeatType) {
#line 546
    iflags |= 32;
#line 548
    if ((unsigned int const   )a->repeatType == 3U) {
#line 549
      on = (int )a->repeatDay;
    } else
#line 550
    if ((unsigned int const   )a->repeatType == 2U) {
#line 551
      on = 0;
#line 552
      i = 0;
      {
#line 552
      while (1) {
        while_continue: /* CIL Label */ ;
#line 552
        if (! (i < 7)) {
#line 552
          goto while_break;
        }
#line 553
        if (a->repeatDays[i]) {
#line 554
          on |= 1 << i;
        }
#line 552
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 556
      on = 0;
    }
#line 558
    *((unsigned char *)pos + 0) = (unsigned char )a->repeatType;
#line 559
    *((unsigned char *)(pos + 1) + 0) = (unsigned char)0;
#line 560
    pos += 2;
#line 562
    if (a->repeatForever) {
#line 563
      *((unsigned char *)pos + 0) = (unsigned char )((65535 >> 8) & 255);
#line 563
      *((unsigned char *)pos + 1) = (unsigned char)255;
    } else {
#line 565
      *((unsigned char *)pos + 0) = (unsigned char )(((int )((unsigned short )((((a->repeatEnd.tm_year - 4) << 9) | ((a->repeatEnd.tm_mon + 1) << 5)) | a->repeatEnd.tm_mday)) >> 8) & 255);
#line 565
      *((unsigned char *)pos + 1) = (unsigned char )((int )((unsigned short )((((a->repeatEnd.tm_year - 4) << 9) | ((a->repeatEnd.tm_mon + 1) << 5)) | a->repeatEnd.tm_mday)) & 255);
    }
#line 572
    pos += 2;
#line 574
    *((unsigned char *)pos + 0) = (unsigned char )a->repeatFrequency;
#line 575
    pos ++;
#line 576
    *((unsigned char *)pos + 0) = (unsigned char )on;
#line 577
    pos ++;
#line 578
    *((unsigned char *)pos + 0) = (unsigned char )a->repeatWeekstart;
#line 579
    pos ++;
#line 580
    *((unsigned char *)pos + 0) = (unsigned char)0;
#line 581
    pos ++;
  }
#line 584
  if (a->exceptions) {
#line 587
    iflags |= 8;
#line 589
    *((unsigned char *)pos + 0) = (unsigned char )(((int )((unsigned short )a->exceptions) >> 8) & 255);
#line 589
    *((unsigned char *)pos + 1) = (unsigned char )((int )((unsigned short )a->exceptions) & 255);
#line 590
    pos += 2;
#line 592
    i___0 = 0;
    {
#line 592
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 592
      if (! (i___0 < (int )a->exceptions)) {
#line 592
        goto while_break___0;
      }
#line 593
      *((unsigned char *)pos + 0) = (unsigned char )(((int )((unsigned short )(((((a->exception + i___0)->tm_year - 4) << 9) | (((a->exception + i___0)->tm_mon + 1) << 5)) | (a->exception + i___0)->tm_mday)) >> 8) & 255);
#line 593
      *((unsigned char *)pos + 1) = (unsigned char )((int )((unsigned short )(((((a->exception + i___0)->tm_year - 4) << 9) | (((a->exception + i___0)->tm_mon + 1) << 5)) | (a->exception + i___0)->tm_mday)) & 255);
#line 592
      i___0 ++;
#line 592
      pos += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 601
  if ((unsigned long )a->description != (unsigned long )((void *)0)) {
    {
#line 602
    iflags |= 4;
#line 604
    strcpy((char */* __restrict  */)pos, (char const   */* __restrict  */)a->description);
#line 605
    tmp___2 = strlen((char const   *)pos);
#line 605
    pos += tmp___2 + 1UL;
    }
  }
#line 608
  if ((unsigned long )a->note != (unsigned long )((void *)0)) {
    {
#line 609
    iflags |= 16;
#line 611
    strcpy((char */* __restrict  */)pos, (char const   */* __restrict  */)a->note);
#line 612
    tmp___3 = strlen((char const   *)pos);
#line 612
    pos += tmp___3 + 1UL;
    }
  }
#line 615
  if ((unsigned long )a->location != (unsigned long )((void *)0)) {
    {
#line 616
    iflags |= 2;
#line 618
    strcpy((char */* __restrict  */)pos, (char const   */* __restrict  */)a->location);
#line 619
    tmp___4 = strlen((char const   *)pos);
#line 619
    pos += tmp___4 + 1UL;
    }
  }
#line 622
  *((buf___3->data + 6) + 0) = (unsigned char )iflags;
#line 623
  *((buf___3->data + 7) + 0) = (unsigned char)0;
#line 629
  blob_index = (uint8_t )0;
  {
#line 629
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 629
    if (! ((int )blob_index < 10)) {
#line 629
      goto while_break___1;
    }
#line 630
    if ((unsigned long )((void *)0) != (unsigned long )a->blob[blob_index]) {
      {
#line 631
      pack_Blob((Blob_t const   *)a->blob[blob_index], buf___3);
      }
    }
#line 629
    blob_index = (uint8_t )((int )blob_index + 1);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 635
  return (0);
}
}
#line 651 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/calendar.c"
int unpack_CalendarAppInfo(CalendarAppInfo_t *ai , pi_buffer_t *buf___3 ) 
{ 
  int i ;
  int len ;
  unsigned char *record ;
  int used ;

  {
  {
#line 659
  len = (int )buf___3->used;
#line 660
  record = buf___3->data;
#line 661
  used = unpack_CategoryAppInfo(& ai->category, (unsigned char const   *)record, (size_t )len);
  }
#line 662
  if (! used) {
#line 663
    return (0);
  }
#line 664
  record += used;
#line 665
  len -= used;
#line 666
  if (len < 2) {
#line 667
    return (0);
  }
#line 668
  ai->startOfWeek = (int )*(record + 0);
#line 670
  record += 2;
#line 671
  used += 2;
#line 673
  i = 0;
  {
#line 673
  while (1) {
    while_continue: /* CIL Label */ ;
#line 673
    if (! (i < 18)) {
#line 673
      goto while_break;
    }
#line 674
    ai->internal[i] = *(record + 0);
#line 675
    record ++;
#line 676
    used ++;
#line 673
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 678
  ai->type = (calendarType )0;
#line 680
  return (used);
}
}
#line 697 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/calendar.c"
int pack_CalendarAppInfo(CalendarAppInfo_t const   *ai , pi_buffer_t *buf___3 ) 
{ 
  int i ;
  int len ;
  unsigned char *record ;
  int tmp ;

  {
#line 704
  if (! buf___3) {
#line 705
    return (298);
  }
  {
#line 709
  len = 300;
#line 710
  pi_buffer_expect(buf___3, (size_t )300);
#line 711
  tmp = pack_CategoryAppInfo(& ai->category, buf___3->data, buf___3->allocated);
#line 711
  buf___3->used = (size_t )tmp;
  }
#line 712
  if (! buf___3->used) {
#line 713
    return (0);
  }
#line 714
  record = buf___3->data + buf___3->used;
#line 715
  len = (int )((size_t )len - buf___3->used);
#line 716
  if (len < 2) {
#line 717
    return (0);
  }
#line 718
  *(record + 0) = (unsigned char)0;
#line 718
  *(record + 1) = (unsigned char)0;
#line 719
  *(record + 0) = (unsigned char )ai->startOfWeek;
#line 720
  record += 2;
#line 721
  buf___3->used += 2UL;
#line 723
  i = 0;
  {
#line 723
  while (1) {
    while_continue: /* CIL Label */ ;
#line 723
    if (! (i < 18)) {
#line 723
      goto while_break;
    }
#line 724
    *(record + 0) = ai->internal[i];
#line 725
    record ++;
#line 726
    (buf___3->used) ++;
#line 723
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 729
  return ((int )(record - buf___3->data));
}
}
#line 89 "../include/pi-palmpix.h"
int unpack_PalmPixHeader(struct PalmPixHeader *h , unsigned char const   *p , int len ) ;
#line 92
int unpack_PalmPix(struct PalmPixState *s , struct PalmPixHeader  const  *h , int header_recno ,
                   int wanted ) ;
#line 96
int free_PalmPix_data(struct PalmPixState *s ) ;
#line 72 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/palmpix.c"
int ColourCorrect(struct PalmPixHeader  const  *picHdr , uint8_t *r , uint8_t *gr ,
                  uint8_t *gb , uint8_t *b ) ;
#line 75
int Histogram(struct PalmPixHeader  const  *picHdr , uint8_t *r , uint8_t *gr , uint8_t *gb ,
              uint8_t *b ) ;
#line 78
void DecodeRow(uint8_t *compData , uint8_t *lastRow , uint8_t *unCompData , uint32_t *offset ,
               int32_t *firstWord , uint16_t *PPLutsW , uint8_t *PPLuts , uint16_t halfWidth ) ;
#line 82 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/palmpix.c"
uint8_t huffWidth[4096]  = 
#line 82
  {      (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )7,      (uint8_t )7,      (uint8_t )7,      (uint8_t )7, 
        (uint8_t )7,      (uint8_t )7,      (uint8_t )7,      (uint8_t )7, 
        (uint8_t )7,      (uint8_t )7,      (uint8_t )7,      (uint8_t )7, 
        (uint8_t )7,      (uint8_t )7,      (uint8_t )7,      (uint8_t )7, 
        (uint8_t )7,      (uint8_t )7,      (uint8_t )7,      (uint8_t )7, 
        (uint8_t )7,      (uint8_t )7,      (uint8_t )7,      (uint8_t )7, 
        (uint8_t )7,      (uint8_t )7,      (uint8_t )7,      (uint8_t )7, 
        (uint8_t )7,      (uint8_t )7,      (uint8_t )7,      (uint8_t )7, 
        (uint8_t )12,      (uint8_t )12,      (uint8_t )11,      (uint8_t )11, 
        (uint8_t )10,      (uint8_t )10,      (uint8_t )10,      (uint8_t )10, 
        (uint8_t )9,      (uint8_t )9,      (uint8_t )9,      (uint8_t )9, 
        (uint8_t )9,      (uint8_t )9,      (uint8_t )9,      (uint8_t )9, 
        (uint8_t )8,      (uint8_t )8,      (uint8_t )8,      (uint8_t )8, 
        (uint8_t )8,      (uint8_t )8,      (uint8_t )8,      (uint8_t )8, 
        (uint8_t )8,      (uint8_t )8,      (uint8_t )8,      (uint8_t )8, 
        (uint8_t )8,      (uint8_t )8,      (uint8_t )8,      (uint8_t )8, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )5, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )7,      (uint8_t )7,      (uint8_t )7,      (uint8_t )7, 
        (uint8_t )7,      (uint8_t )7,      (uint8_t )7,      (uint8_t )7, 
        (uint8_t )7,      (uint8_t )7,      (uint8_t )7,      (uint8_t )7, 
        (uint8_t )7,      (uint8_t )7,      (uint8_t )7,      (uint8_t )7, 
        (uint8_t )7,      (uint8_t )7,      (uint8_t )7,      (uint8_t )7, 
        (uint8_t )7,      (uint8_t )7,      (uint8_t )7,      (uint8_t )7, 
        (uint8_t )7,      (uint8_t )7,      (uint8_t )7,      (uint8_t )7, 
        (uint8_t )7,      (uint8_t )7,      (uint8_t )7,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )8,      (uint8_t )8,      (uint8_t )8, 
        (uint8_t )8,      (uint8_t )8,      (uint8_t )8,      (uint8_t )8, 
        (uint8_t )8,      (uint8_t )8,      (uint8_t )8,      (uint8_t )8, 
        (uint8_t )8,      (uint8_t )8,      (uint8_t )8,      (uint8_t )8, 
        (uint8_t )9,      (uint8_t )9,      (uint8_t )9,      (uint8_t )9, 
        (uint8_t )9,      (uint8_t )9,      (uint8_t )9,      (uint8_t )9, 
        (uint8_t )10,      (uint8_t )10,      (uint8_t )10,      (uint8_t )10, 
        (uint8_t )11,      (uint8_t )11,      (uint8_t )12,      (uint8_t )12};
#line 597 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/palmpix.c"
uint16_t huffTable[4096]  = 
#line 597
  {      (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )0,      (uint16_t )0,      (uint16_t )0,      (uint16_t )0, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )3,      (uint16_t )3,      (uint16_t )3,      (uint16_t )3, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533,      (uint16_t )65533, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527,      (uint16_t )65527, 
        (uint16_t )65512,      (uint16_t )65512,      (uint16_t )65512,      (uint16_t )65512, 
        (uint16_t )65512,      (uint16_t )65512,      (uint16_t )65512,      (uint16_t )65512, 
        (uint16_t )65512,      (uint16_t )65512,      (uint16_t )65512,      (uint16_t )65512, 
        (uint16_t )65512,      (uint16_t )65512,      (uint16_t )65512,      (uint16_t )65512, 
        (uint16_t )65512,      (uint16_t )65512,      (uint16_t )65512,      (uint16_t )65512, 
        (uint16_t )65512,      (uint16_t )65512,      (uint16_t )65512,      (uint16_t )65512, 
        (uint16_t )65512,      (uint16_t )65512,      (uint16_t )65512,      (uint16_t )65512, 
        (uint16_t )65512,      (uint16_t )65512,      (uint16_t )65512,      (uint16_t )65512, 
        (uint16_t )65376,      (uint16_t )65403,      (uint16_t )65445,      (uint16_t )65445, 
        (uint16_t )65469,      (uint16_t )65469,      (uint16_t )65469,      (uint16_t )65469, 
        (uint16_t )65488,      (uint16_t )65488,      (uint16_t )65488,      (uint16_t )65488, 
        (uint16_t )65488,      (uint16_t )65488,      (uint16_t )65488,      (uint16_t )65488, 
        (uint16_t )65500,      (uint16_t )65500,      (uint16_t )65500,      (uint16_t )65500, 
        (uint16_t )65500,      (uint16_t )65500,      (uint16_t )65500,      (uint16_t )65500, 
        (uint16_t )65500,      (uint16_t )65500,      (uint16_t )65500,      (uint16_t )65500, 
        (uint16_t )65500,      (uint16_t )65500,      (uint16_t )65500,      (uint16_t )65500, 
        (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519, 
        (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519, 
        (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519, 
        (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519, 
        (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519, 
        (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519, 
        (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519, 
        (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519, 
        (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519, 
        (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519, 
        (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519, 
        (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519, 
        (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519, 
        (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519, 
        (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519, 
        (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519,      (uint16_t )65519, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523,      (uint16_t )65523, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530,      (uint16_t )65530, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )6,      (uint16_t )6,      (uint16_t )6,      (uint16_t )6, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )9,      (uint16_t )9,      (uint16_t )9,      (uint16_t )9, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )13,      (uint16_t )13,      (uint16_t )13,      (uint16_t )13, 
        (uint16_t )17,      (uint16_t )17,      (uint16_t )17,      (uint16_t )17, 
        (uint16_t )17,      (uint16_t )17,      (uint16_t )17,      (uint16_t )17, 
        (uint16_t )17,      (uint16_t )17,      (uint16_t )17,      (uint16_t )17, 
        (uint16_t )17,      (uint16_t )17,      (uint16_t )17,      (uint16_t )17, 
        (uint16_t )17,      (uint16_t )17,      (uint16_t )17,      (uint16_t )17, 
        (uint16_t )17,      (uint16_t )17,      (uint16_t )17,      (uint16_t )17, 
        (uint16_t )17,      (uint16_t )17,      (uint16_t )17,      (uint16_t )17, 
        (uint16_t )17,      (uint16_t )17,      (uint16_t )17,      (uint16_t )17, 
        (uint16_t )17,      (uint16_t )17,      (uint16_t )17,      (uint16_t )17, 
        (uint16_t )17,      (uint16_t )17,      (uint16_t )17,      (uint16_t )17, 
        (uint16_t )17,      (uint16_t )17,      (uint16_t )17,      (uint16_t )17, 
        (uint16_t )17,      (uint16_t )17,      (uint16_t )17,      (uint16_t )17, 
        (uint16_t )17,      (uint16_t )17,      (uint16_t )17,      (uint16_t )17, 
        (uint16_t )17,      (uint16_t )17,      (uint16_t )17,      (uint16_t )17, 
        (uint16_t )17,      (uint16_t )17,      (uint16_t )17,      (uint16_t )17, 
        (uint16_t )17,      (uint16_t )17,      (uint16_t )17,      (uint16_t )17, 
        (uint16_t )24,      (uint16_t )24,      (uint16_t )24,      (uint16_t )24, 
        (uint16_t )24,      (uint16_t )24,      (uint16_t )24,      (uint16_t )24, 
        (uint16_t )24,      (uint16_t )24,      (uint16_t )24,      (uint16_t )24, 
        (uint16_t )24,      (uint16_t )24,      (uint16_t )24,      (uint16_t )24, 
        (uint16_t )24,      (uint16_t )24,      (uint16_t )24,      (uint16_t )24, 
        (uint16_t )24,      (uint16_t )24,      (uint16_t )24,      (uint16_t )24, 
        (uint16_t )24,      (uint16_t )24,      (uint16_t )24,      (uint16_t )24, 
        (uint16_t )24,      (uint16_t )24,      (uint16_t )24,      (uint16_t )24, 
        (uint16_t )36,      (uint16_t )36,      (uint16_t )36,      (uint16_t )36, 
        (uint16_t )36,      (uint16_t )36,      (uint16_t )36,      (uint16_t )36, 
        (uint16_t )36,      (uint16_t )36,      (uint16_t )36,      (uint16_t )36, 
        (uint16_t )36,      (uint16_t )36,      (uint16_t )36,      (uint16_t )36, 
        (uint16_t )48,      (uint16_t )48,      (uint16_t )48,      (uint16_t )48, 
        (uint16_t )48,      (uint16_t )48,      (uint16_t )48,      (uint16_t )48, 
        (uint16_t )67,      (uint16_t )67,      (uint16_t )67,      (uint16_t )67, 
        (uint16_t )91,      (uint16_t )91,      (uint16_t )133,      (uint16_t )160};
#line 1121 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/palmpix.c"
static void Bias(double bias , int width , int height , uint8_t *data ) 
{ 
  int i ;
  double num ;
  double denom ;
  double t ;

  {
  {
#line 1126
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bias factor : %lf\n",
          bias);
#line 1128
  i = 0;
  }
  {
#line 1128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1128
    if (! (i < width * height)) {
#line 1128
      goto while_break;
    }
#line 1130
    t = (double )*(data + i) / 256.0;
#line 1131
    num = t;
#line 1132
    denom = (1.0 / bias - (double )2) * (1.0 - t) + (double )1;
#line 1133
    *(data + i) = (uint8_t )((num / denom) * 256.0);
#line 1128
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1135
  return;
}
}
#line 1140 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/palmpix.c"
int ColourCorrect(struct PalmPixHeader  const  *picHdr , uint8_t *r , uint8_t *gr ,
                  uint8_t *gb , uint8_t *b ) 
{ 
  uint8_t gbMin ;
  uint8_t gbMax ;
  uint8_t grMin ;
  uint8_t grMax ;
  uint8_t rMin ;
  uint8_t rMax ;
  uint8_t bMin ;
  uint8_t bMax ;
  float grInc ;
  float gbInc ;
  float rInc ;
  float bInc ;
  float grCur ;
  float gbCur ;
  float rCur ;
  float bCur ;
  float rMean ;
  float grMean ;
  float gbMean ;
  float bMean ;
  float maxMean ;
  uint16_t width ;
  uint16_t height ;
  int i ;
  uint8_t red[256] ;
  uint8_t greenB[256] ;
  uint8_t greenR[256] ;
  uint8_t blue[256] ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___4 ;

  {
  {
#line 1145
  rMean = (float )0;
#line 1145
  grMean = (float )0;
#line 1145
  gbMean = (float )0;
#line 1145
  bMean = (float )0;
#line 1146
  width = (uint16_t )(picHdr->w / 2);
#line 1147
  height = (uint16_t )(picHdr->h / 2);
#line 1151
  memset((void *)(red), 0, 256UL * sizeof(uint8_t ));
#line 1152
  memset((void *)(greenR), 0, 256UL * sizeof(uint8_t ));
#line 1153
  memset((void *)(greenB), 0, 256UL * sizeof(uint8_t ));
#line 1154
  memset((void *)(blue), 0, 256UL * sizeof(uint8_t ));
#line 1156
  bMin = (uint8_t )255;
#line 1156
  rMin = bMin;
#line 1156
  grMin = rMin;
#line 1156
  gbMin = grMin;
#line 1157
  bMax = (uint8_t )0;
#line 1157
  rMax = bMax;
#line 1157
  grMax = rMax;
#line 1157
  gbMax = grMax;
#line 1159
  i = 0;
  }
  {
#line 1159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1159
    if (! (i < (int )width * (int )height)) {
#line 1159
      goto while_break;
    }
#line 1161
    if ((int )gbMin < (int )*(gb + i)) {
#line 1161
      gbMin = gbMin;
    } else {
#line 1161
      gbMin = *(gb + i);
    }
#line 1162
    if ((int )grMin < (int )*(gr + i)) {
#line 1162
      grMin = grMin;
    } else {
#line 1162
      grMin = *(gr + i);
    }
#line 1163
    if ((int )rMin < (int )*(r + i)) {
#line 1163
      rMin = rMin;
    } else {
#line 1163
      rMin = *(r + i);
    }
#line 1164
    if ((int )bMin < (int )*(b + i)) {
#line 1164
      bMin = bMin;
    } else {
#line 1164
      bMin = *(b + i);
    }
#line 1166
    if ((int )gbMax > (int )*(gb + i)) {
#line 1166
      gbMax = gbMax;
    } else {
#line 1166
      gbMax = *(gb + i);
    }
#line 1167
    if ((int )grMax > (int )*(gr + i)) {
#line 1167
      grMax = grMax;
    } else {
#line 1167
      grMax = *(gr + i);
    }
#line 1168
    if ((int )rMax > (int )*(r + i)) {
#line 1168
      rMax = rMax;
    } else {
#line 1168
      rMax = *(r + i);
    }
#line 1169
    if ((int )bMax > (int )*(b + i)) {
#line 1169
      bMax = bMax;
    } else {
#line 1169
      bMax = *(b + i);
    }
#line 1171
    rMean += (float )*(r + i);
#line 1172
    gbMean += (float )*(gb + i);
#line 1173
    grMean += (float )*(gr + i);
#line 1174
    bMean += (float )*(b + i);
#line 1159
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1177
  rMean /= (float )((int )width * (int )height);
#line 1178
  gbMean /= (float )((int )width * (int )height);
#line 1179
  grMean /= (float )((int )width * (int )height);
#line 1180
  bMean /= (float )((int )width * (int )height);
#line 1182
  if (gbMean - (float )gbMin > grMean - (float )grMin) {
#line 1182
    tmp___3 = gbMean - (float )gbMin;
  } else {
#line 1182
    tmp___3 = grMean - (float )grMin;
  }
#line 1182
  if (bMean - (float )bMin > rMean - (float )rMin) {
#line 1182
    tmp___4 = bMean - (float )bMin;
  } else {
#line 1182
    tmp___4 = rMean - (float )rMin;
  }
#line 1182
  if (tmp___3 > tmp___4) {
#line 1182
    if (gbMean - (float )gbMin > grMean - (float )grMin) {
#line 1182
      tmp___1 = gbMean - (float )gbMin;
    } else {
#line 1182
      tmp___1 = grMean - (float )grMin;
    }
#line 1182
    maxMean = tmp___1;
  } else {
#line 1182
    if (bMean - (float )bMin > rMean - (float )rMin) {
#line 1182
      tmp___2 = bMean - (float )bMin;
    } else {
#line 1182
      tmp___2 = rMean - (float )rMin;
    }
#line 1182
    maxMean = tmp___2;
  }
#line 1184
  rInc = maxMean / (rMean - (float )rMin);
#line 1185
  grInc = maxMean / (grMean - (float )grMin);
#line 1186
  gbInc = maxMean / (gbMean - (float )gbMin);
#line 1187
  bInc = maxMean / (bMean - (float )bMin);
#line 1189
  rCur = (float )0;
#line 1190
  grCur = (float )0;
#line 1191
  gbCur = (float )0;
#line 1192
  bCur = (float )0;
#line 1194
  i = 0;
  {
#line 1194
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1194
    if (! (i < 256)) {
#line 1194
      goto while_break___0;
    }
#line 1196
    if (i < (int )rMin) {
#line 1197
      red[i] = (uint8_t )0;
    } else {
#line 1200
      if (rCur < (float )255) {
#line 1201
        red[i] = (uint8_t )rCur;
      } else {
#line 1203
        red[i] = (uint8_t )255;
      }
#line 1205
      rCur += rInc;
    }
#line 1208
    if (i < (int )grMin) {
#line 1209
      greenR[i] = (uint8_t )0;
    } else {
#line 1212
      if (grCur < (float )255) {
#line 1213
        greenR[i] = (uint8_t )grCur;
      } else {
#line 1215
        greenR[i] = (uint8_t )255;
      }
#line 1217
      grCur += grInc;
    }
#line 1220
    if (i < (int )gbMin) {
#line 1221
      greenB[i] = (uint8_t )0;
    } else {
#line 1224
      if (gbCur < (float )255) {
#line 1225
        greenB[i] = (uint8_t )gbCur;
      } else {
#line 1227
        greenB[i] = (uint8_t )255;
      }
#line 1229
      gbCur += gbInc;
    }
#line 1232
    if (i < (int )bMin) {
#line 1233
      blue[i] = (uint8_t )0;
    } else {
#line 1236
      if (bCur < (float )255) {
#line 1237
        blue[i] = (uint8_t )bCur;
      } else {
#line 1239
        blue[i] = (uint8_t )255;
      }
#line 1241
      bCur += bInc;
    }
#line 1194
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1245
  i = 0;
  {
#line 1245
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1245
    if (! (i < (int )width * (int )height)) {
#line 1245
      goto while_break___1;
    }
#line 1247
    *(gb + i) = greenB[*(gb + i)];
#line 1248
    *(gr + i) = greenR[*(gr + i)];
#line 1249
    *(b + i) = blue[*(b + i)];
#line 1250
    *(r + i) = red[*(r + i)];
#line 1245
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1253
  return (1);
}
}
#line 1256 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/palmpix.c"
int Histogram(struct PalmPixHeader  const  *picHdr , uint8_t *r , uint8_t *gr , uint8_t *gb ,
              uint8_t *b ) 
{ 
  uint8_t gbMin ;
  uint8_t gbMax ;
  uint8_t grMin ;
  uint8_t grMax ;
  uint8_t rMin ;
  uint8_t rMax ;
  uint8_t bMin ;
  uint8_t bMax ;
  uint32_t rCum ;
  uint32_t grCum ;
  uint32_t gbCum ;
  uint32_t bCum ;
  uint32_t grC[256] ;
  uint32_t gbC[256] ;
  uint32_t rC[256] ;
  uint32_t bC[256] ;
  float grInc ;
  float gbInc ;
  float rInc ;
  float bInc ;
  float grCur ;
  float gbCur ;
  float rCur ;
  float bCur ;
  uint16_t width ;
  uint16_t height ;
  int i ;
  float clip ;
  uint8_t red[256] ;
  uint8_t greenB[256] ;
  uint8_t greenR[256] ;
  uint8_t blue[256] ;
  float redCeiling ;
  float greenCeiling ;
  float blueCeiling ;

  {
  {
#line 1263
  width = (uint16_t )(picHdr->w / 2);
#line 1264
  height = (uint16_t )(picHdr->h / 2);
#line 1268
  redCeiling = (float )254;
#line 1269
  greenCeiling = (float )252;
#line 1270
  blueCeiling = (float )255;
#line 1272
  memset((void *)(red), 0, 256UL * sizeof(uint8_t ));
#line 1273
  memset((void *)(greenR), 0, 256UL * sizeof(uint8_t ));
#line 1274
  memset((void *)(greenB), 0, 256UL * sizeof(uint8_t ));
#line 1275
  memset((void *)(blue), 0, 256UL * sizeof(uint8_t ));
#line 1277
  memset((void *)(rC), 0, 256UL * sizeof(uint32_t ));
#line 1278
  memset((void *)(grC), 0, 256UL * sizeof(uint32_t ));
#line 1279
  memset((void *)(gbC), 0, 256UL * sizeof(uint32_t ));
#line 1280
  memset((void *)(bC), 0, 256UL * sizeof(uint32_t ));
#line 1282
  bMin = (uint8_t )255;
#line 1282
  rMin = bMin;
#line 1282
  grMin = rMin;
#line 1282
  gbMin = grMin;
#line 1283
  bMax = (uint8_t )0;
#line 1283
  rMax = bMax;
#line 1283
  grMax = rMax;
#line 1283
  gbMax = grMax;
#line 1285
  i = 0;
  }
  {
#line 1285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1285
    if (! (i < (int )width * (int )height)) {
#line 1285
      goto while_break;
    }
#line 1287
    (rC[*(r + i)]) ++;
#line 1288
    (grC[*(gr + i)]) ++;
#line 1289
    (gbC[*(gb + i)]) ++;
#line 1290
    (bC[*(b + i)]) ++;
#line 1285
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1293
  bCum = (uint32_t )0;
#line 1293
  gbCum = bCum;
#line 1293
  grCum = gbCum;
#line 1293
  rCum = grCum;
#line 1295
  clip = (float )((0.05 * (double )width) * (double )height);
#line 1297
  i = 0;
  {
#line 1297
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1297
    if (! (i < 256)) {
#line 1297
      goto while_break___0;
    }
#line 1299
    rCum += rC[i];
#line 1301
    if ((int )rMin == 255) {
#line 1301
      if ((float )rCum > clip) {
#line 1302
        rMin = (uint8_t )i;
      }
    }
#line 1304
    grCum += grC[i];
#line 1306
    if ((int )grMin == 255) {
#line 1306
      if ((float )grCum > clip) {
#line 1307
        grMin = (uint8_t )i;
      }
    }
#line 1309
    gbCum += gbC[i];
#line 1311
    if ((int )gbMin == 255) {
#line 1311
      if ((float )gbCum > clip) {
#line 1312
        gbMin = (uint8_t )i;
      }
    }
#line 1314
    bCum += bC[i];
#line 1316
    if ((int )bMin == 255) {
#line 1316
      if ((float )bCum > clip) {
#line 1317
        bMin = (uint8_t )i;
      }
    }
#line 1319
    if ((int )rMin != 255) {
#line 1319
      if ((int )grMin != 255) {
#line 1319
        if ((int )gbMin != 255) {
#line 1319
          if ((int )bMin != 255) {
#line 1320
            goto while_break___0;
          }
        }
      }
    }
#line 1297
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1323
  bCum = (uint32_t )0;
#line 1323
  gbCum = bCum;
#line 1323
  grCum = gbCum;
#line 1323
  rCum = grCum;
#line 1325
  i = 255;
  {
#line 1325
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1325
    if (! (i > 0)) {
#line 1325
      goto while_break___1;
    }
#line 1327
    rCum += rC[i];
#line 1329
    if ((int )rMax == 0) {
#line 1329
      if ((float )rCum > clip) {
#line 1330
        rMax = (uint8_t )i;
      }
    }
#line 1332
    grCum += grC[i];
#line 1334
    if ((int )grMax == 0) {
#line 1334
      if ((float )grCum > clip) {
#line 1335
        grMax = (uint8_t )i;
      }
    }
#line 1337
    gbCum += gbC[i];
#line 1339
    if ((int )gbMax == 0) {
#line 1339
      if ((float )gbCum > clip) {
#line 1340
        gbMax = (uint8_t )i;
      }
    }
#line 1342
    bCum += bC[i];
#line 1344
    if ((int )bMax == 0) {
#line 1344
      if ((float )bCum > clip) {
#line 1345
        bMax = (uint8_t )i;
      }
    }
#line 1347
    if ((int )rMax != 0) {
#line 1347
      if ((int )grMax != 0) {
#line 1347
        if ((int )gbMax != 0) {
#line 1347
          if ((int )bMax != 0) {
#line 1348
            goto while_break___1;
          }
        }
      }
    }
#line 1325
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1351
  rInc = redCeiling / (float )((int )rMax - (int )rMin);
#line 1352
  grInc = greenCeiling / (float )((int )grMax - (int )grMin);
#line 1353
  gbInc = greenCeiling / (float )((int )gbMax - (int )gbMin);
#line 1354
  bInc = blueCeiling / (float )((int )bMax - (int )bMin);
#line 1356
  rCur = (float )0;
#line 1357
  grCur = (float )0;
#line 1358
  gbCur = (float )0;
#line 1359
  bCur = (float )0;
#line 1361
  i = 0;
  {
#line 1361
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1361
    if (! (i < 256)) {
#line 1361
      goto while_break___2;
    }
#line 1363
    if (i < (int )rMin) {
#line 1364
      red[i] = (uint8_t )0;
    } else {
#line 1367
      if (rCur < redCeiling) {
#line 1368
        red[i] = (uint8_t )rCur;
      } else {
#line 1370
        red[i] = (uint8_t )greenCeiling;
      }
#line 1372
      rCur += rInc;
    }
#line 1375
    if (i < (int )grMin) {
#line 1376
      greenR[i] = (uint8_t )0;
    } else {
#line 1379
      if (grCur < greenCeiling) {
#line 1380
        greenR[i] = (uint8_t )grCur;
      } else {
#line 1382
        greenR[i] = (uint8_t )greenCeiling;
      }
#line 1384
      grCur += grInc;
    }
#line 1387
    if (i < (int )gbMin) {
#line 1388
      greenB[i] = (uint8_t )0;
    } else {
#line 1391
      if (gbCur < greenCeiling) {
#line 1392
        greenB[i] = (uint8_t )gbCur;
      } else {
#line 1394
        greenB[i] = (uint8_t )blueCeiling;
      }
#line 1396
      gbCur += gbInc;
    }
#line 1399
    if (i < (int )bMin) {
#line 1400
      blue[i] = (uint8_t )0;
    } else {
#line 1403
      if (bCur < blueCeiling) {
#line 1404
        blue[i] = (uint8_t )bCur;
      } else {
#line 1406
        blue[i] = (uint8_t )blueCeiling;
      }
#line 1408
      bCur += bInc;
    }
#line 1361
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1412
  i = 0;
  {
#line 1412
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1412
    if (! (i < (int )width * (int )height)) {
#line 1412
      goto while_break___3;
    }
#line 1414
    *(gb + i) = greenB[*(gb + i)];
#line 1415
    *(gr + i) = greenR[*(gr + i)];
#line 1416
    *(b + i) = blue[*(b + i)];
#line 1417
    *(r + i) = red[*(r + i)];
#line 1412
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1420
  return (1);
}
}
#line 1429 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/palmpix.c"
static void Interpolate(struct PalmPixHeader  const  *pixHdr , uint8_t *red , uint8_t *greenR ,
                        uint8_t *greenB , uint8_t *blue , uint8_t *pp , int offset_r ,
                        int offset_g , int offset_b ) 
{ 
  int idx ;
  int offset ;
  int ppOff ;
  int x ;
  int y ;
  int rowOff ;
  uint8_t r ;
  uint8_t g ;
  uint8_t b ;
  int rawWidth ;

  {
#line 1434
  rawWidth = (int )(pixHdr->w / 2);
#line 1436
  y = 1;
  {
#line 1436
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1436
    if (! (y < (int )(pixHdr->h - 1))) {
#line 1436
      goto while_break;
    }
#line 1439
    idx = y / 2;
#line 1440
    offset = idx * rawWidth;
#line 1441
    ppOff = y * (int )pixHdr->w;
#line 1443
    if (y % 2 == 1) {
#line 1445
      x = 1;
      {
#line 1445
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1445
        if (! (x < rawWidth - 1)) {
#line 1445
          goto while_break___0;
        }
#line 1448
        rowOff = x * 2;
#line 1450
        r = (uint8_t )(((((int )*(red + ((offset + x) - 1)) + (int )*(red + (offset + x))) + (int )*(red + (((offset + rawWidth) + x) - 1))) + (int )*(red + ((offset + rawWidth) + x))) >> 2);
#line 1451
        g = (uint8_t )(((((int )*(greenR + (offset + x)) + (int )*(greenR + ((offset + x) + rawWidth))) + (int )*(greenB + ((offset + x) - 1))) + (int )*(greenB + (offset + x))) >> 2);
#line 1452
        b = *(blue + (offset + x));
#line 1453
        *(pp + (3 * (ppOff + rowOff) + offset_r)) = r;
#line 1454
        *(pp + (3 * (ppOff + rowOff) + offset_g)) = g;
#line 1455
        *(pp + (3 * (ppOff + rowOff) + offset_b)) = b;
#line 1457
        r = (uint8_t )(((int )*(red + (offset + x)) + (int )*(red + ((offset + rawWidth) + x))) >> 1);
#line 1458
        g = (uint8_t )(((((((int )*(greenB + (offset + x)) << 2) + (int )*(greenR + (offset + x))) + (int )*(greenR + ((offset + x) + 1))) + (int )*(greenR + ((offset + x) + rawWidth))) + (int )*(greenR + (((offset + x) + rawWidth) + 1))) >> 3);
#line 1459
        b = (uint8_t )(((int )*(blue + (offset + x)) + (int )*(blue + ((offset + x) + 1))) >> 1);
#line 1460
        *(pp + (3 * ((ppOff + rowOff) + 1) + offset_r)) = r;
#line 1461
        *(pp + (3 * ((ppOff + rowOff) + 1) + offset_g)) = g;
#line 1462
        *(pp + (3 * ((ppOff + rowOff) + 1) + offset_b)) = b;
#line 1445
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 1468
      x = 1;
      {
#line 1468
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1468
        if (! (x < rawWidth - 1)) {
#line 1468
          goto while_break___1;
        }
#line 1470
        rowOff = x * 2;
#line 1472
        r = (uint8_t )(((int )*(red + ((offset + x) - 1)) + (int )*(red + (offset + x))) >> 1);
#line 1473
        g = (uint8_t )(((((((int )*(greenR + (offset + x)) << 2) + (int )*(greenB + (((offset - rawWidth) + x) - 1))) + (int )*(greenB + ((offset - rawWidth) + x))) + (int )*(greenB + ((offset + x) - 1))) + (int )*(greenB + (offset + x))) >> 3);
#line 1474
        b = (uint8_t )(((int )*(blue + ((offset - rawWidth) + x)) + (int )*(blue + (offset + x))) >> 1);
#line 1475
        *(pp + (3 * (ppOff + rowOff) + offset_r)) = r;
#line 1476
        *(pp + (3 * (ppOff + rowOff) + offset_g)) = g;
#line 1477
        *(pp + (3 * (ppOff + rowOff) + offset_b)) = b;
#line 1479
        r = *(red + (offset + x));
#line 1480
        g = (uint8_t )(((((int )*(greenR + (offset + x)) + (int )*(greenR + ((offset + x) + 1))) + (int )*(greenB + ((offset - rawWidth) + x))) + (int )*(greenB + (offset + x))) >> 2);
#line 1481
        b = (uint8_t )(((((int )*(blue + ((offset + x) - rawWidth)) + (int )*(blue + (((offset + x) - rawWidth) - 1))) + (int )*(blue + (offset + x))) + (int )*(blue + ((offset + x) + 1))) >> 2);
#line 1482
        *(pp + (3 * ((ppOff + rowOff) + 1) + offset_r)) = r;
#line 1483
        *(pp + (3 * ((ppOff + rowOff) + 1) + offset_g)) = g;
#line 1484
        *(pp + (3 * ((ppOff + rowOff) + 1) + offset_b)) = b;
#line 1468
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 1436
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1490
  return;
}
}
#line 1492 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/palmpix.c"
void DecodeRow(uint8_t *compData , uint8_t *lastRow , uint8_t *unCompData , uint32_t *offset ,
               int32_t *firstWord , uint16_t *PPLutsW , uint8_t *PPLuts , uint16_t halfWidth ) 
{ 
  uint8_t *saveStartP ;
  uint8_t shiftOut ;
  int16_t tmpW3 ;
  int16_t tmpResult ;
  int16_t tmpW0 ;
  int16_t idx ;
  int16_t resultW ;
  uint32_t lutIdx ;
  uint32_t tmpL0 ;
  uint32_t tmpL2 ;
  uint32_t tmpL5 ;
  int16_t tmp ;

  {
#line 1498
  saveStartP = compData;
#line 1500
  tmpW3 = (int16_t )(32 - *firstWord);
#line 1502
  tmpResult = (int16_t )(32 - (int )tmpW3);
#line 1504
  tmpL5 = (uint32_t )(((((int )*(compData + 0) << 24) | ((int )*(compData + 1) << 16)) | ((int )*(compData + 2) << 8)) | (int )*(compData + 3));
#line 1505
  tmpL5 <<= (int )tmpResult;
#line 1506
  tmpL0 = tmpL5;
#line 1508
  compData += 4;
#line 1510
  tmpL0 >>= 24;
#line 1512
  *(unCompData + 0) = (uint8_t )tmpL0;
#line 1514
  tmpL5 <<= 8;
#line 1515
  tmpW3 = (int16_t )((int )tmpW3 - 8);
#line 1516
  idx = (int16_t )1;
  {
#line 1518
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1518
    if (! ((int )idx < (int )halfWidth)) {
#line 1518
      goto while_break;
    }
#line 1520
    if ((int )tmpW3 < 12) {
#line 1522
      tmpW0 = (int16_t )(16 - (int )tmpW3);
#line 1523
      tmpL2 = (uint32_t )((((int )*(compData + 0) << 8) | (int )*(compData + 1)) << (int )tmpW0);
#line 1524
      tmpL5 |= tmpL2;
#line 1525
      tmpW3 = (int16_t )((int )tmpW3 + 16);
#line 1526
      compData += 2;
    }
#line 1529
    lutIdx = tmpL5 >> 20;
#line 1531
    shiftOut = *(PPLuts + lutIdx);
#line 1533
    tmpL5 <<= (int )shiftOut;
#line 1535
    tmpW3 = (int16_t )((int )tmpW3 - (int )shiftOut);
#line 1537
    resultW = (int16_t )(((int )*(unCompData + ((int )idx - 1)) + (int )*(lastRow + idx)) >> 1);
#line 1539
    resultW = (int16_t )((int )resultW + (int )*(PPLutsW + lutIdx));
#line 1541
    if ((int )resultW > 255) {
#line 1542
      resultW = (int16_t )255;
    }
#line 1544
    if ((int )resultW < 0) {
#line 1545
      resultW = (int16_t )0;
    }
#line 1547
    tmp = idx;
#line 1547
    idx = (int16_t )((int )idx + 1);
#line 1547
    *(unCompData + tmp) = (uint8_t )resultW;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1551
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1551
    if (! ((int )tmpW3 > 0)) {
#line 1551
      goto while_break___0;
    }
#line 1553
    compData --;
#line 1554
    tmpW3 = (int16_t )((int )tmpW3 - 8);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1557
  *offset = (uint32_t )(compData - saveStartP);
#line 1558
  *firstWord = - ((int )tmpW3);
#line 1560
  return;
}
}
#line 1601 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/palmpix.c"
static int get_le_short(unsigned char const   *p ) 
{ 


  {
#line 1605
  return ((int )((int const   )*(p + 0) | ((int const   )*(p + 1) << 8)));
}
}
#line 1609 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/palmpix.c"
int unpack_PalmPixHeader(struct PalmPixHeader *h , unsigned char const   *p , int len ) 
{ 
  int magic1 ;
  int magic2 ;

  {
#line 1614
  if (len != 196) {
#line 1615
    return (0);
  }
  {
#line 1617
  magic1 = (int )*(p + 1);
#line 1618
  magic2 = get_le_short(p + 46);
#line 1628
  h->numRec = (int )*(p + 0);
#line 1629
  h->month = (int )*(p + 2);
#line 1630
  h->day = (int )*(p + 3);
#line 1631
  h->year = (int )((int const   )*(p + 4) * 100 + (int const   )*(p + 5));
#line 1632
  h->hour = (int )*(p + 6);
#line 1633
  h->min = (int )*(p + 7);
#line 1634
  h->sec = (int )*(p + 8);
#line 1635
  h->resolution = (int )*(p + 9);
#line 1636
  h->w = get_le_short(p + 10);
#line 1637
  h->h = get_le_short(p + 12);
#line 1638
  h->thumbLen = get_le_short(p + 14);
#line 1639
  h->chansize[0] = get_le_short(p + 16);
#line 1640
  h->chansize[1] = get_le_short(p + 19);
#line 1641
  h->chansize[2] = get_le_short(p + 22);
#line 1642
  h->chansize[3] = get_le_short(p + 25);
#line 1643
  h->num = get_le_short(p + 29);
#line 1644
  h->zoom = (int )*(p + 45);
  }
#line 1646
  return (196);
}
}
#line 1650 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/palmpix.c"
int unpack_PalmPix(struct PalmPixState *s , struct PalmPixHeader  const  *h , int header_recno ,
                   int wanted ) 
{ 
  int retcode ;
  void *buffer ;
  size_t bufsize ;
  int tmp ;
  int rawWidth ;
  int rawHeight ;
  unsigned char *raw ;
  unsigned char *chan[4] ;
  int chansize_max ;
  int recno ;
  int failed ;
  int k ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  long num_bytes ;
  long offset ;
  int32_t lastWord ;
  int j ;
  void *buffer___0 ;
  size_t bufsize___0 ;
  int tmp___3 ;
  uint32_t eaten ;

  {
#line 1653
  retcode = 1;
#line 1655
  if (wanted & 1) {
    {
#line 1660
    tmp = (*(s->getrecord))(s, header_recno + 1, & buffer, & bufsize);
    }
#line 1660
    if (tmp == 0) {
#line 1660
      if (bufsize == 32UL) {
        {
#line 1664
        memcpy((void */* __restrict  */)(s->pixname), (void const   */* __restrict  */)buffer,
               (size_t )32);
#line 1665
        s->pixname[32] = (char )'\000';
        }
      } else {
#line 1669
        retcode = 0;
      }
    } else {
#line 1669
      retcode = 0;
    }
  }
#line 1673
  if (wanted & 2) {
    {
#line 1677
    retcode = 0;
#line 1678
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"palmpix.c: thumbnail reader not implemented\n");
    }
  }
#line 1683
  if (wanted & 4) {
#line 1686
    rawWidth = (int )(h->w / 2);
#line 1687
    rawHeight = (int )(h->h / 2);
#line 1690
    chansize_max = 0;
#line 1691
    recno = header_recno;
#line 1692
    failed = 1;
#line 1695
    k = 0;
    {
#line 1695
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1695
      if (! (k < 4)) {
#line 1695
        goto while_break;
      }
#line 1696
      chan[k] = (unsigned char *)((void *)0);
#line 1695
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1697
    raw = (unsigned char *)((void *)0);
#line 1698
    s->pixmap = (unsigned char *)((void *)0);
#line 1700
    k = 0;
    {
#line 1700
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1700
      if (! (k < 4)) {
#line 1700
        goto while_break___0;
      }
      {
#line 1703
      tmp___0 = malloc((size_t )(rawWidth * rawHeight));
#line 1703
      chan[k] = (unsigned char *)tmp___0;
      }
#line 1704
      if ((unsigned long )chan[k] == (unsigned long )((void *)0)) {
#line 1705
        goto failed;
      }
      {
#line 1706
      memset((void *)chan[k], 0, (size_t )(rawWidth * rawHeight));
      }
#line 1707
      if (chansize_max < h->chansize[k]) {
#line 1708
        chansize_max = h->chansize[k];
      }
#line 1700
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1713
    tmp___1 = malloc((size_t )chansize_max);
#line 1713
    raw = (unsigned char *)tmp___1;
    }
#line 1714
    if ((unsigned long )raw == (unsigned long )((void *)0)) {
#line 1715
      goto failed;
    }
    {
#line 1717
    tmp___2 = malloc((size_t )((h->w * h->h) * 3));
#line 1717
    s->pixmap = (unsigned char *)tmp___2;
    }
#line 1718
    if ((unsigned long )s->pixmap == (unsigned long )((void *)0)) {
#line 1719
      goto failed;
    }
#line 1721
    recno += 4;
#line 1723
    k = 0;
    {
#line 1723
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1723
      if (! (k < 4)) {
#line 1723
        goto while_break___1;
      }
#line 1726
      lastWord = 0;
#line 1729
      num_bytes = 0L;
      {
#line 1729
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1729
        if (! (num_bytes < (long )h->chansize[k])) {
#line 1729
          goto while_break___2;
        }
        {
#line 1733
        tmp___3 = (*(s->getrecord))(s, recno, & buffer___0, & bufsize___0);
        }
#line 1733
        if (tmp___3 == 0) {
#line 1734
          if (bufsize___0 > (size_t )((long )h->chansize[k] - num_bytes)) {
#line 1735
            bufsize___0 = (size_t )((long )h->chansize[k] - num_bytes);
          }
          {
#line 1736
          memcpy((void */* __restrict  */)(raw + num_bytes), (void const   */* __restrict  */)buffer___0,
                 bufsize___0);
#line 1737
          num_bytes = (long )((size_t )num_bytes + bufsize___0);
          }
        } else {
#line 1741
          goto failed;
        }
#line 1729
        recno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1745
      offset = 0L;
#line 1746
      memcpy((void */* __restrict  */)chan[k], (void const   */* __restrict  */)(raw + offset),
             (size_t )rawWidth);
#line 1747
      offset += (long )rawWidth;
#line 1749
      j = 1;
      }
      {
#line 1749
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1749
        if (! (j < rawHeight)) {
#line 1749
          goto while_break___3;
        }
        {
#line 1752
        DecodeRow(raw + offset, chan[k] + rawWidth * (j - 1), chan[k] + rawWidth * j,
                  & eaten, & lastWord, huffTable, huffWidth, (uint16_t )rawWidth);
#line 1757
        offset += (long )eaten;
#line 1749
        j ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1723
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1763
    if (s->flags & 1) {
      {
#line 1764
      ColourCorrect(h, chan[1], chan[0], chan[3], chan[2]);
      }
    }
#line 1767
    if (s->bias != 50) {
      {
#line 1769
      Bias((double )s->bias / 100.0, rawWidth, rawHeight, chan[1]);
#line 1770
      Bias((double )s->bias / 100.0, rawWidth, rawHeight, chan[0]);
#line 1771
      Bias((double )s->bias / 100.0, rawWidth, rawHeight, chan[3]);
#line 1772
      Bias((double )s->bias / 100.0, rawWidth, rawHeight, chan[2]);
      }
    }
#line 1775
    if (s->flags & 2) {
      {
#line 1776
      Histogram(h, chan[1], chan[0], chan[3], chan[2]);
      }
    }
    {
#line 1779
    Interpolate(h, chan[1], chan[0], chan[3], chan[2], s->pixmap, s->offset_r, s->offset_g,
                s->offset_b);
#line 1784
    failed = 0;
    }
    failed: 
#line 1787
    k = 0;
    {
#line 1787
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1787
      if (! (k < 4)) {
#line 1787
        goto while_break___4;
      }
      {
#line 1788
      free((void *)chan[k]);
#line 1787
      k ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1789
    free((void *)raw);
    }
#line 1790
    if (failed) {
      {
#line 1792
      free((void *)s->pixmap);
#line 1793
      retcode = 0;
      }
    }
  }
#line 1797
  s->highest_recno = (header_recno + 3) + (int )h->numRec;
#line 1799
  return (retcode);
}
}
#line 1802 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/palmpix.c"
int free_PalmPix_data(struct PalmPixState *s ) 
{ 


  {
  {
#line 1805
  free((void *)s->pixmap);
  }
#line 1807
  return (1);
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 114 "../include/pi-buffer.h"
pi_buffer_t *pi_buffer_append_buffer(pi_buffer_t *dest , pi_buffer_t const   *src ) ;
#line 126
void pi_buffer_clear(pi_buffer_t *buf___3 ) ;
#line 30 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-buffer.c"
pi_buffer_t *pi_buffer_new(size_t capacity ) 
{ 
  pi_buffer_t *buf___3 ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 34
  tmp = malloc(sizeof(struct pi_buffer_t ));
#line 34
  buf___3 = (struct pi_buffer_t *)tmp;
  }
#line 35
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
#line 36
    return ((pi_buffer_t *)((void *)0));
  }
#line 38
  if (capacity <= 0UL) {
#line 39
    capacity = (size_t )16;
  }
  {
#line 41
  tmp___0 = malloc(capacity);
#line 41
  buf___3->data = (unsigned char *)tmp___0;
  }
#line 42
  if ((unsigned long )buf___3->data == (unsigned long )((void *)0)) {
    {
#line 43
    free((void *)buf___3);
    }
#line 44
    return ((pi_buffer_t *)((void *)0));
  }
#line 47
  buf___3->allocated = capacity;
#line 48
  buf___3->used = (size_t )0;
#line 49
  return (buf___3);
}
}
#line 52 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-buffer.c"
pi_buffer_t *pi_buffer_expect(pi_buffer_t *buf___3 , size_t expect ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 55
  if (buf___3->allocated - buf___3->used >= expect) {
#line 56
    return (buf___3);
  }
#line 58
  if (buf___3->data) {
    {
#line 59
    tmp = realloc((void *)buf___3->data, buf___3->used + expect);
#line 59
    buf___3->data = (unsigned char *)tmp;
    }
  } else {
    {
#line 61
    tmp___0 = malloc(expect);
#line 61
    buf___3->data = (unsigned char *)tmp___0;
    }
  }
#line 63
  if ((unsigned long )buf___3->data == (unsigned long )((void *)0)) {
#line 64
    buf___3->allocated = (size_t )0;
#line 65
    buf___3->used = (size_t )0;
#line 66
    return ((pi_buffer_t *)((void *)0));
  }
#line 69
  buf___3->allocated = buf___3->used + expect;
#line 70
  return (buf___3);
}
}
#line 73 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-buffer.c"
pi_buffer_t *pi_buffer_append(pi_buffer_t *buf___3 , void const   *data , size_t len ) 
{ 
  pi_buffer_t *tmp ;

  {
  {
#line 76
  tmp = pi_buffer_expect(buf___3, len);
  }
#line 76
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 77
    return ((pi_buffer_t *)((void *)0));
  }
  {
#line 79
  memcpy((void */* __restrict  */)(buf___3->data + buf___3->used), (void const   */* __restrict  */)data,
         len);
#line 80
  buf___3->used += len;
  }
#line 82
  return (buf___3);
}
}
#line 85 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-buffer.c"
pi_buffer_t *pi_buffer_append_buffer(pi_buffer_t *dest , pi_buffer_t const   *src ) 
{ 
  pi_buffer_t *tmp ;

  {
  {
#line 88
  tmp = pi_buffer_append(dest, (void const   *)src->data, (size_t )src->used);
  }
#line 88
  return (tmp);
}
}
#line 91 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-buffer.c"
void pi_buffer_clear(pi_buffer_t *buf___3 ) 
{ 
  void *tmp ;

  {
#line 94
  buf___3->used = (size_t )0;
#line 95
  if (buf___3->allocated > 65535UL) {
    {
#line 97
    tmp = realloc((void *)buf___3->data, (size_t )65535);
#line 97
    buf___3->data = (unsigned char *)tmp;
    }
#line 98
    if ((unsigned long )buf___3->data == (unsigned long )((void *)0)) {
#line 98
      buf___3->allocated = (size_t )0;
    } else {
#line 98
      buf___3->allocated = (size_t )65535;
    }
  }
#line 100
  return;
}
}
#line 102 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-buffer.c"
void pi_buffer_free(pi_buffer_t *buf___3 ) 
{ 


  {
#line 105
  if (buf___3) {
#line 106
    if (buf___3->data) {
      {
#line 107
      free((void *)buf___3->data);
      }
    }
    {
#line 108
    free((void *)buf___3);
    }
  }
#line 110
  return;
}
}
#line 106 "../include/pi-notepad.h"
void free_NotePad(NotePad_t *a ) ;
#line 107
int unpack_NotePad(NotePad_t *notepad , unsigned char *buffer , size_t len ) ;
#line 108
int unpack_NotePadAppInfo(NotePadAppInfo_t *appinfo , unsigned char *record , size_t len ) ;
#line 110
int pack_NotePad(NotePad_t *notepad , unsigned char *buf___3 , size_t len ) ;
#line 111
int pack_NotePadAppInfo(NotePadAppInfo_t *appinfo , unsigned char *record , size_t len ) ;
#line 49 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/notepad.c"
void free_NotePad(NotePad_t *a ) 
{ 


  {
#line 51
  if ((int )a->flags & 2) {
    {
#line 54
    free((void *)a->name);
    }
  }
#line 57
  if ((int )a->flags & 1) {
    {
#line 60
    free((void *)a->data);
    }
  }
#line 63
  return;
}
}
#line 73 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/notepad.c"
int unpack_NotePad(NotePad_t *notepad , unsigned char *buffer , size_t len ) 
{ 
  unsigned char *start ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 75
  start = buffer;
#line 77
  notepad->createDate.sec = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 78
  buffer += 2;
#line 79
  notepad->createDate.min = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 80
  buffer += 2;
#line 81
  notepad->createDate.hour = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 82
  buffer += 2;
#line 83
  notepad->createDate.day = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 84
  buffer += 2;
#line 85
  notepad->createDate.month = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 86
  buffer += 2;
#line 87
  notepad->createDate.year = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 88
  buffer += 2;
#line 90
  notepad->createDate.s = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 91
  buffer += 2;
#line 93
  notepad->changeDate.sec = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 94
  buffer += 2;
#line 95
  notepad->changeDate.min = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 96
  buffer += 2;
#line 97
  notepad->changeDate.hour = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 98
  buffer += 2;
#line 99
  notepad->changeDate.day = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 100
  buffer += 2;
#line 101
  notepad->changeDate.month = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 102
  buffer += 2;
#line 103
  notepad->changeDate.year = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 104
  buffer += 2;
#line 106
  notepad->changeDate.s = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 107
  buffer += 2;
#line 109
  notepad->flags = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 110
  buffer += 2;
#line 114
  if ((int )notepad->flags & 4) {
#line 117
    notepad->alarmDate.sec = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 118
    buffer += 2;
#line 119
    notepad->alarmDate.min = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 120
    buffer += 2;
#line 121
    notepad->alarmDate.hour = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 122
    buffer += 2;
#line 123
    notepad->alarmDate.day = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 124
    buffer += 2;
#line 125
    notepad->alarmDate.month = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 126
    buffer += 2;
#line 127
    notepad->alarmDate.year = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 128
    buffer += 2;
#line 130
    notepad->alarmDate.s = (unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1));
#line 131
    buffer += 2;
  }
#line 134
  if ((int )notepad->flags & 2) {
    {
#line 137
    notepad->name = strdup((char const   *)((char *)buffer));
#line 139
    tmp = strlen((char const   *)notepad->name);
#line 139
    buffer += tmp + 1UL;
#line 141
    tmp___0 = strlen((char const   *)notepad->name);
    }
#line 141
    if ((tmp___0 + 1UL) % 2UL == 1UL) {
#line 142
      buffer ++;
    }
  } else {
#line 147
    notepad->name = (char *)((void *)0);
  }
#line 151
  if ((int )notepad->flags & 1) {
    {
#line 154
    notepad->body.bodyLen = ((((unsigned long )*(buffer + 0) << 24) | ((unsigned long )*(buffer + 1) << 16)) | ((unsigned long )*(buffer + 2) << 8)) | (unsigned long )*(buffer + 3);
#line 155
    buffer += 4;
#line 157
    notepad->body.width = ((((unsigned long )*(buffer + 0) << 24) | ((unsigned long )*(buffer + 1) << 16)) | ((unsigned long )*(buffer + 2) << 8)) | (unsigned long )*(buffer + 3);
#line 158
    buffer += 4;
#line 160
    notepad->body.height = ((((unsigned long )*(buffer + 0) << 24) | ((unsigned long )*(buffer + 1) << 16)) | ((unsigned long )*(buffer + 2) << 8)) | (unsigned long )*(buffer + 3);
#line 161
    buffer += 4;
#line 163
    notepad->body.l1 = ((((unsigned long )*(buffer + 0) << 24) | ((unsigned long )*(buffer + 1) << 16)) | ((unsigned long )*(buffer + 2) << 8)) | (unsigned long )*(buffer + 3);
#line 164
    buffer += 4;
#line 166
    notepad->body.dataType = ((((unsigned long )*(buffer + 0) << 24) | ((unsigned long )*(buffer + 1) << 16)) | ((unsigned long )*(buffer + 2) << 8)) | (unsigned long )*(buffer + 3);
#line 167
    buffer += 4;
#line 169
    notepad->body.dataLen = (unsigned int )(((((unsigned long )*(buffer + 0) << 24) | ((unsigned long )*(buffer + 1) << 16)) | ((unsigned long )*(buffer + 2) << 8)) | (unsigned long )*(buffer + 3));
#line 170
    buffer += 4;
#line 172
    tmp___1 = malloc((size_t )notepad->body.dataLen);
#line 172
    notepad->data = (dataRec_t *)tmp___1;
    }
#line 174
    if ((unsigned long )notepad->data == (unsigned long )((void *)0)) {
      {
#line 176
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Body data alloc failed\n");
      }
#line 177
      return (0);
    }
    {
#line 180
    memcpy((void */* __restrict  */)notepad->data, (void const   */* __restrict  */)buffer,
           (size_t )notepad->body.dataLen);
    }
  }
#line 184
  return ((int )(buffer - start));
}
}
#line 195 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/notepad.c"
int pack_NotePad(NotePad_t *notepad , unsigned char *buf___3 , size_t len ) 
{ 


  {
#line 197
  return (0);
}
}
#line 208 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/notepad.c"
int unpack_NotePadAppInfo(NotePadAppInfo_t *appinfo , unsigned char *record , size_t len ) 
{ 
  int i ;
  unsigned char *start ;

  {
  {
#line 212
  start = record;
#line 214
  i = unpack_CategoryAppInfo(& appinfo->category, (unsigned char const   *)record,
                             len);
  }
#line 215
  if (! i) {
#line 216
    return (0);
  }
#line 217
  record += i;
#line 218
  len -= (size_t )i;
#line 219
  if (len < 4UL) {
#line 220
    return (0);
  }
#line 221
  appinfo->dirty = (int )((unsigned short )(((int )*(record + 0) << 8) | (int )*(record + 1)));
#line 222
  record += 2;
#line 223
  appinfo->sortByPriority = (int )*(record + 0);
#line 224
  record += 2;
#line 225
  return ((int )(record - start));
}
}
#line 235 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/notepad.c"
int pack_NotePadAppInfo(NotePadAppInfo_t *appinfo , unsigned char *record , size_t len ) 
{ 
  int i ;
  unsigned char *start ;

  {
  {
#line 240
  start = record;
#line 242
  i = pack_CategoryAppInfo((CategoryAppInfo_t const   *)(& appinfo->category), record,
                           len);
  }
#line 243
  if (! record) {
#line 244
    return (i + 4);
  }
#line 245
  if (! i) {
#line 246
    return (0);
  }
#line 247
  record += i;
#line 248
  len -= (size_t )i;
#line 249
  if (len < 4UL) {
#line 250
    return (0);
  }
#line 251
  *(record + 0) = (unsigned char )(((int )((unsigned short )appinfo->dirty) >> 8) & 255);
#line 251
  *(record + 1) = (unsigned char )((int )((unsigned short )appinfo->dirty) & 255);
#line 252
  *((record + 2) + 0) = (unsigned char )appinfo->sortByPriority;
#line 253
  *((record + 3) + 0) = (unsigned char)0;
#line 254
  record += 4;
#line 256
  return ((int )(record - start));
}
}
#line 84 "../include/pi-slp.h"
pi_protocol_t *slp_protocol(void) ;
#line 87
ssize_t slp_tx(pi_socket_t *ps , unsigned char const   *buf___3 , size_t len , int flags ) ;
#line 89
ssize_t slp_rx(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) ;
#line 92
void slp_dump_header(unsigned char const   *data , int rxtx ) ;
#line 94
void slp_dump(unsigned char const   *data ) ;
#line 47 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
static int slp_flush(pi_socket_t *ps , int flags ) ;
#line 48
static int slp_getsockopt(pi_socket_t *ps , int level , int option_name , void *option_value ,
                          size_t *option_len ) ;
#line 50
static int slp_setsockopt(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                          size_t *option_len ) ;
#line 65 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
static pi_protocol_t *slp_protocol_dup(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  struct pi_slp_data *data ;
  struct pi_slp_data *new_data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 73
  tmp = malloc(sizeof(pi_protocol_t ));
#line 73
  new_prot = (pi_protocol_t *)tmp;
#line 74
  tmp___0 = malloc(sizeof(struct pi_slp_data ));
#line 74
  new_data = (struct pi_slp_data *)tmp___0;
  }
#line 76
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 76
    if ((unsigned long )new_data != (unsigned long )((void *)0)) {
#line 77
      new_prot->level = prot->level;
#line 78
      new_prot->dup = prot->dup;
#line 79
      new_prot->free = prot->free;
#line 80
      new_prot->read = prot->read;
#line 81
      new_prot->write = prot->write;
#line 82
      new_prot->flush = prot->flush;
#line 83
      new_prot->getsockopt = prot->getsockopt;
#line 84
      new_prot->setsockopt = prot->setsockopt;
#line 86
      data = (struct pi_slp_data *)prot->data;
#line 88
      new_data->dest = data->dest;
#line 89
      new_data->last_dest = data->last_dest;
#line 90
      new_data->src = data->src;
#line 91
      new_data->last_src = data->last_src;
#line 92
      new_data->type = data->type;
#line 93
      new_data->last_type = data->last_type;
#line 94
      new_data->txid = data->txid;
#line 95
      new_data->last_txid = data->last_txid;
#line 97
      new_prot->data = (void *)new_data;
    } else {
#line 76
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 99
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
    {
#line 100
    free((void *)new_prot);
#line 101
    new_prot = (pi_protocol_t *)((void *)0);
    }
  } else
#line 102
  if ((unsigned long )new_data != (unsigned long )((void *)0)) {
    {
#line 103
    free((void *)new_data);
#line 104
    new_data = (struct pi_slp_data *)((void *)0);
    }
  }
#line 107
  return (new_prot);
}
}
#line 122 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
static void slp_protocol_free(pi_protocol_t *prot ) 
{ 


  {
#line 125
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 126
    if ((unsigned long )prot->data != (unsigned long )((void *)0)) {
      {
#line 127
      free(prot->data);
      }
    }
    {
#line 128
    free((void *)prot);
    }
  }
#line 130
  return;
}
}
#line 144 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
pi_protocol_t *slp_protocol(void) 
{ 
  pi_protocol_t *prot ;
  struct pi_slp_data *data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 150
  tmp = malloc(sizeof(pi_protocol_t ));
#line 150
  prot = (pi_protocol_t *)tmp;
#line 151
  tmp___0 = malloc(sizeof(struct pi_slp_data ));
#line 151
  data = (struct pi_slp_data *)tmp___0;
  }
#line 153
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 153
    if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 154
      prot->level = 1;
#line 155
      prot->dup = & slp_protocol_dup;
#line 156
      prot->free = & slp_protocol_free;
#line 157
      prot->read = & slp_rx;
#line 158
      prot->write = & slp_tx;
#line 159
      prot->flush = & slp_flush;
#line 160
      prot->getsockopt = & slp_getsockopt;
#line 161
      prot->setsockopt = & slp_setsockopt;
#line 163
      data->dest = 3;
#line 164
      data->last_dest = -1;
#line 165
      data->src = 3;
#line 166
      data->last_src = -1;
#line 167
      data->type = 2;
#line 168
      data->last_type = -1;
#line 169
      data->txid = (unsigned char)254;
#line 170
      data->last_txid = (unsigned char)255;
#line 171
      prot->data = (void *)data;
    } else {
#line 153
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 173
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
    {
#line 174
    free((void *)prot);
#line 175
    prot = (pi_protocol_t *)((void *)0);
    }
  } else
#line 176
  if ((unsigned long )data != (unsigned long )((void *)0)) {
    {
#line 177
    free((void *)data);
#line 178
    data = (struct pi_slp_data *)((void *)0);
    }
  }
#line 181
  return (prot);
}
}
#line 196 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
ssize_t slp_tx(pi_socket_t *ps , unsigned char const   *buf___3 , size_t len , int flags ) 
{ 
  int bytes ;
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  struct pi_slp_data *data ;
  struct slp *slp ;
  unsigned char *slp_buf ;
  unsigned int i ;
  unsigned int n ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 208
  prot = pi_protocol(ps->sd, 1);
  }
#line 209
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 210
    tmp = pi_set_error(ps->sd, -201);
    }
#line 210
    return ((ssize_t )tmp);
  }
  {
#line 212
  data = (struct pi_slp_data *)prot->data;
#line 213
  next = pi_protocol_next(ps->sd, 1);
  }
#line 214
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 215
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 215
    return ((ssize_t )tmp___0);
  }
  {
#line 217
  tmp___1 = malloc((size_t )65547);
#line 217
  slp_buf = (unsigned char *)tmp___1;
  }
#line 219
  if ((unsigned long )slp_buf == (unsigned long )((void *)0)) {
    {
#line 220
    tmp___2 = pi_set_error(ps->sd, -500);
    }
#line 220
    return ((ssize_t )tmp___2);
  }
#line 222
  slp = (struct slp *)slp_buf;
#line 225
  slp->_be = (unsigned char)190;
#line 226
  slp->_ef = (unsigned char)239;
#line 227
  slp->_ed = (unsigned char)237;
#line 228
  slp->dest = (unsigned char )data->dest;
#line 229
  slp->src = (unsigned char )data->src;
#line 230
  slp->type = (unsigned char )data->type;
#line 231
  *((unsigned char *)(& slp->dlen) + 0) = (unsigned char )(((int )((unsigned short )len) >> 8) & 255);
#line 231
  *((unsigned char *)(& slp->dlen) + 1) = (unsigned char )((int )((unsigned short )len) & 255);
#line 232
  slp->id_ = data->txid;
#line 234
  i = 0U;
#line 234
  n = i;
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (! (i < 9U)) {
#line 234
      goto while_break;
    }
#line 235
    n += (unsigned int )*(slp_buf + i);
#line 234
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 236
  slp->csum = (unsigned char )(255U & n);
#line 239
  memcpy((void */* __restrict  */)(slp_buf + 10), (void const   */* __restrict  */)buf___3,
         len);
#line 242
  tmp___3 = crc16(slp_buf, (int )(10UL + len));
#line 242
  *((slp_buf + (10UL + len)) + 0) = (unsigned char )(((int )((unsigned short )tmp___3) >> 8) & 255);
#line 242
  tmp___4 = crc16(slp_buf, (int )(10UL + len));
#line 242
  *((slp_buf + (10UL + len)) + 1) = (unsigned char )((int )((unsigned short )tmp___4) & 255);
#line 246
  tmp___5 = (*(next->write))(ps, (unsigned char const   *)slp_buf, (10UL + len) + 2UL,
                             flags);
#line 246
  bytes = (int )tmp___5;
  }
#line 249
  if (bytes >= 0) {
    {
#line 250
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 250
      tmp___6 = pi_debug_get_types();
      }
#line 250
      if (tmp___6 & 4) {
        {
#line 250
        tmp___7 = pi_debug_get_level();
        }
#line 250
        if (tmp___7 >= 4) {
          {
#line 250
          slp_dump_header((unsigned char const   *)slp_buf, 1);
          }
        }
      }
#line 250
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 251
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 251
      tmp___8 = pi_debug_get_types();
      }
#line 251
      if (tmp___8 & 4) {
        {
#line 251
        tmp___9 = pi_debug_get_level();
        }
#line 251
        if (tmp___9 >= 8) {
          {
#line 251
          slp_dump((unsigned char const   *)slp_buf);
          }
        }
      }
#line 251
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 254
  free((void *)slp_buf);
  }
#line 256
  return ((ssize_t )bytes);
}
}
#line 277 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
ssize_t slp_rx(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) 
{ 
  int i ;
  int computed_crc ;
  int received_crc ;
  int b1 ;
  int b2 ;
  int b3 ;
  int state ;
  int expect ;
  int packet_len ;
  int bytes ;
  unsigned char header_checksum ;
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  pi_buffer_t *slp_buf ;
  struct pi_slp_data *data ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  pi_buffer_t *tmp___10 ;
  ssize_t tmp___11 ;

  {
  {
#line 280
  expect = 0;
#line 297
  pi_log(4, 8, "SLP RX len=%d flags=0x%04x\n", len, flags);
#line 300
  prot = pi_protocol(ps->sd, 1);
  }
#line 301
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 302
    tmp = pi_set_error(ps->sd, -201);
    }
#line 302
    return ((ssize_t )tmp);
  }
  {
#line 304
  data = (struct pi_slp_data *)prot->data;
#line 305
  next = pi_protocol_next(ps->sd, 1);
  }
#line 306
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 307
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 307
    return ((ssize_t )tmp___0);
  }
  {
#line 309
  slp_buf = pi_buffer_new((size_t )65547);
  }
#line 310
  if ((unsigned long )slp_buf == (unsigned long )((void *)0)) {
    {
#line 311
    tmp___1 = __errno_location();
#line 311
    *tmp___1 = 12;
#line 312
    tmp___2 = pi_set_error(ps->sd, -500);
    }
#line 312
    return ((ssize_t )tmp___2);
  }
#line 315
  state = 0;
#line 316
  packet_len = 0;
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 320
    if (state == 0) {
#line 320
      goto case_0;
    }
#line 325
    if (state == 1) {
#line 325
      goto case_1;
    }
#line 346
    if (state == 2) {
#line 346
      goto case_2;
    }
#line 371
    if (state == 3) {
#line 371
      goto case_3;
    }
#line 376
    if (state == 4) {
#line 376
      goto case_4;
    }
#line 411
    goto switch_default;
    case_0: /* CIL Label */ 
#line 321
    expect = 3;
#line 322
    state ++;
#line 323
    goto switch_break;
    case_1: /* CIL Label */ 
#line 326
    b1 = (int )*(slp_buf->data + 0);
#line 327
    b2 = (int )*(slp_buf->data + 1);
#line 328
    b3 = (int )*(slp_buf->data + 2);
#line 329
    if (b1 == 190) {
#line 329
      if (b2 == 239) {
#line 329
        if (b3 == 237) {
#line 332
          state ++;
#line 333
          expect = 7;
        } else {
          {
#line 335
          *(slp_buf->data + 0) = *(slp_buf->data + 1);
#line 336
          *(slp_buf->data + 1) = *(slp_buf->data + 2);
#line 337
          expect = 1;
#line 338
          slp_buf->used = (size_t )2;
#line 339
          pi_log(4, 2, "SLP RX Unexpected signature 0x%.2x 0x%.2x 0x%.2x\n", b1, b2,
                 b3);
          }
        }
      } else {
        {
#line 335
        *(slp_buf->data + 0) = *(slp_buf->data + 1);
#line 336
        *(slp_buf->data + 1) = *(slp_buf->data + 2);
#line 337
        expect = 1;
#line 338
        slp_buf->used = (size_t )2;
#line 339
        pi_log(4, 2, "SLP RX Unexpected signature 0x%.2x 0x%.2x 0x%.2x\n", b1, b2,
               b3);
        }
      }
    } else {
      {
#line 335
      *(slp_buf->data + 0) = *(slp_buf->data + 1);
#line 336
      *(slp_buf->data + 1) = *(slp_buf->data + 2);
#line 337
      expect = 1;
#line 338
      slp_buf->used = (size_t )2;
#line 339
      pi_log(4, 2, "SLP RX Unexpected signature 0x%.2x 0x%.2x 0x%.2x\n", b1, b2, b3);
      }
    }
#line 344
    goto switch_break;
    case_2: /* CIL Label */ 
#line 348
    i = 0;
#line 348
    header_checksum = (unsigned char )i;
    {
#line 348
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 348
      if (! (i < 9)) {
#line 348
        goto while_break___0;
      }
#line 349
      header_checksum = (unsigned char )((int )header_checksum + (int )*(slp_buf->data + i));
#line 348
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 352
    if ((int )header_checksum == (int )*(slp_buf->data + 9)) {
#line 353
      state ++;
#line 354
      packet_len = (int )((unsigned short )(((int )*((slp_buf->data + 6) + 0) << 8) | (int )*((slp_buf->data + 6) + 1)));
#line 355
      if (packet_len > (int )len) {
        {
#line 356
        pi_log(4, 1, "SLP RX Packet size exceed buffer\n");
#line 358
        pi_buffer_free(slp_buf);
#line 359
        tmp___3 = pi_set_error(ps->sd, -102);
        }
#line 359
        return ((ssize_t )tmp___3);
      }
#line 361
      expect = packet_len;
    } else {
      {
#line 363
      pi_log(4, 2, "SLP RX Header checksum failed for header:\n");
#line 365
      pi_dumpdata((char const   *)slp_buf->data, (size_t )10);
#line 366
      pi_buffer_free(slp_buf);
      }
#line 367
      return ((ssize_t )0);
    }
#line 369
    goto switch_break;
    case_3: /* CIL Label */ 
#line 372
    state ++;
#line 373
    expect = 2;
#line 374
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 378
    computed_crc = crc16(slp_buf->data, 10 + packet_len);
#line 379
    received_crc = (int )((unsigned short )(((int )*((slp_buf->data + (10 + packet_len)) + 0) << 8) | (int )*((slp_buf->data + (10 + packet_len)) + 1)));
    }
#line 380
    if ((int )*((slp_buf->data + 5) + 0) == 3) {
#line 383
      if (computed_crc != received_crc) {
#line 384
        computed_crc |= 224;
      }
    }
#line 386
    if (computed_crc != received_crc) {
      {
#line 387
      pi_log(4, 1, "SLP RX packet crc failed: computed=0x%.4x received=0x%.4x\n",
             computed_crc, received_crc);
#line 391
      pi_buffer_free(slp_buf);
      }
#line 392
      return ((ssize_t )0);
    }
#line 396
    data->last_dest = (int )*((slp_buf->data + 3) + 0);
#line 397
    data->last_src = (int )*((slp_buf->data + 4) + 0);
#line 398
    data->last_type = (int )*((slp_buf->data + 5) + 0);
#line 399
    data->last_txid = *((slp_buf->data + 8) + 0);
    {
#line 401
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 401
      tmp___4 = pi_debug_get_types();
      }
#line 401
      if (tmp___4 & 4) {
        {
#line 401
        tmp___5 = pi_debug_get_level();
        }
#line 401
        if (tmp___5 >= 4) {
          {
#line 401
          slp_dump_header((unsigned char const   *)slp_buf->data, 0);
          }
        }
      }
#line 401
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 402
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 402
      tmp___6 = pi_debug_get_types();
      }
#line 402
      if (tmp___6 & 4) {
        {
#line 402
        tmp___7 = pi_debug_get_level();
        }
#line 402
        if (tmp___7 >= 8) {
          {
#line 402
          slp_dump((unsigned char const   *)slp_buf->data);
          }
        }
      }
#line 402
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 404
    tmp___10 = pi_buffer_append(buf___3, (void const   *)(slp_buf->data + 10), (size_t )packet_len);
    }
#line 404
    if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
      {
#line 405
      tmp___8 = __errno_location();
#line 405
      *tmp___8 = 12;
#line 406
      tmp___9 = pi_set_error(ps->sd, -500);
      }
#line 406
      return ((ssize_t )tmp___9);
    }
    {
#line 408
    pi_buffer_free(slp_buf);
    }
#line 409
    return ((ssize_t )packet_len);
    switch_default: /* CIL Label */ 
#line 412
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 415
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 416
      tmp___11 = (*(next->read))(ps, slp_buf, (size_t )expect, flags);
#line 416
      bytes = (int )tmp___11;
      }
#line 417
      if (bytes < 0) {
        {
#line 418
        pi_log(4, 1, "SLP RX Read Error %d\n", bytes);
#line 421
        pi_buffer_free(slp_buf);
        }
#line 422
        return ((ssize_t )bytes);
      }
#line 424
      expect -= bytes;
#line 415
      if (! (expect > 0)) {
#line 415
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 440 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
static int slp_flush(pi_socket_t *ps , int flags ) 
{ 
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 446
  prot = pi_protocol(ps->sd, 1);
  }
#line 447
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 448
    tmp = pi_set_error(ps->sd, -201);
    }
#line 448
    return (tmp);
  }
  {
#line 450
  next = pi_protocol_next(ps->sd, 1);
  }
#line 451
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 452
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 452
    return (tmp___0);
  }
  {
#line 454
  tmp___1 = (*(next->flush))(ps, flags);
  }
#line 454
  return (tmp___1);
}
}
#line 468 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
static int slp_getsockopt(pi_socket_t *ps , int level , int option_name , void *option_value ,
                          size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  struct pi_slp_data *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 475
  prot = pi_protocol(ps->sd, 1);
  }
#line 476
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 477
    tmp = pi_set_error(ps->sd, -201);
    }
#line 477
    return (tmp);
  }
#line 479
  data = (struct pi_slp_data *)prot->data;
  {
#line 482
  if (option_name == 0) {
#line 482
    goto case_0;
  }
#line 488
  if (option_name == 1) {
#line 488
    goto case_1;
  }
#line 495
  if (option_name == 2) {
#line 495
    goto case_2;
  }
#line 502
  if (option_name == 3) {
#line 502
    goto case_3;
  }
#line 509
  if (option_name == 4) {
#line 509
    goto case_4;
  }
#line 516
  if (option_name == 5) {
#line 516
    goto case_5;
  }
#line 523
  if (option_name == 6) {
#line 523
    goto case_6;
  }
#line 530
  if (option_name == 7) {
#line 530
    goto case_7;
  }
#line 481
  goto switch_break;
  case_0: /* CIL Label */ 
#line 483
  if (*option_len < sizeof(data->dest)) {
#line 484
    goto error;
  }
  {
#line 485
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->dest),
         sizeof(data->dest));
#line 486
  *option_len = sizeof(data->dest);
  }
#line 487
  goto switch_break;
  case_1: /* CIL Label */ 
#line 489
  if (*option_len < sizeof(data->dest)) {
#line 490
    goto error;
  }
  {
#line 491
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->last_dest),
         sizeof(data->last_dest));
#line 493
  *option_len = sizeof(data->last_dest);
  }
#line 494
  goto switch_break;
  case_2: /* CIL Label */ 
#line 496
  if (*option_len < sizeof(data->src)) {
#line 497
    goto error;
  }
  {
#line 498
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->src),
         sizeof(data->src));
#line 500
  *option_len = sizeof(data->src);
  }
#line 501
  goto switch_break;
  case_3: /* CIL Label */ 
#line 503
  if (*option_len < sizeof(data->last_src)) {
#line 504
    goto error;
  }
  {
#line 505
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->last_src),
         sizeof(data->last_src));
#line 507
  *option_len = sizeof(data->last_src);
  }
#line 508
  goto switch_break;
  case_4: /* CIL Label */ 
#line 510
  if (*option_len < sizeof(data->type)) {
#line 511
    goto error;
  }
  {
#line 512
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->type),
         sizeof(data->type));
#line 514
  *option_len = sizeof(data->type);
  }
#line 515
  goto switch_break;
  case_5: /* CIL Label */ 
#line 517
  if (*option_len < sizeof(data->last_type)) {
#line 518
    goto error;
  }
  {
#line 519
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->last_type),
         sizeof(data->last_type));
#line 521
  *option_len = sizeof(data->last_type);
  }
#line 522
  goto switch_break;
  case_6: /* CIL Label */ 
#line 524
  if (*option_len < sizeof(data->txid)) {
#line 525
    goto error;
  }
  {
#line 526
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->txid),
         sizeof(data->txid));
#line 528
  *option_len = sizeof(data->txid);
  }
#line 529
  goto switch_break;
  case_7: /* CIL Label */ 
#line 531
  if (*option_len < sizeof(data->last_txid)) {
#line 532
    goto error;
  }
  {
#line 533
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->last_txid),
         sizeof(data->last_txid));
#line 535
  *option_len = sizeof(data->last_txid);
  }
#line 536
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 539
  return (0);
  error: 
  {
#line 542
  tmp___0 = __errno_location();
#line 542
  *tmp___0 = 22;
#line 543
  tmp___1 = pi_set_error(ps->sd, -501);
  }
#line 543
  return (tmp___1);
}
}
#line 558 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
static int slp_setsockopt(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                          size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  struct pi_slp_data *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 565
  prot = pi_protocol(ps->sd, 1);
  }
#line 566
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 567
    tmp = pi_set_error(ps->sd, -201);
    }
#line 567
    return (tmp);
  }
#line 568
  data = (struct pi_slp_data *)prot->data;
  {
#line 571
  if (option_name == 0) {
#line 571
    goto case_0;
  }
#line 578
  if (option_name == 2) {
#line 578
    goto case_2;
  }
#line 585
  if (option_name == 4) {
#line 585
    goto case_4;
  }
#line 592
  if (option_name == 6) {
#line 592
    goto case_6;
  }
#line 570
  goto switch_break;
  case_0: /* CIL Label */ 
#line 572
  if (*option_len != sizeof(data->dest)) {
#line 573
    goto error;
  }
  {
#line 574
  memcpy((void */* __restrict  */)(& data->dest), (void const   */* __restrict  */)option_value,
         sizeof(data->dest));
#line 576
  *option_len = sizeof(data->dest);
  }
#line 577
  goto switch_break;
  case_2: /* CIL Label */ 
#line 579
  if (*option_len != sizeof(data->src)) {
#line 580
    goto error;
  }
  {
#line 581
  memcpy((void */* __restrict  */)(& data->src), (void const   */* __restrict  */)option_value,
         sizeof(data->src));
#line 583
  *option_len = sizeof(data->src);
  }
#line 584
  goto switch_break;
  case_4: /* CIL Label */ 
#line 586
  if (*option_len != sizeof(data->type)) {
#line 587
    goto error;
  }
  {
#line 588
  memcpy((void */* __restrict  */)(& data->type), (void const   */* __restrict  */)option_value,
         sizeof(data->type));
#line 590
  *option_len = sizeof(data->type);
  }
#line 591
  goto switch_break;
  case_6: /* CIL Label */ 
#line 593
  if (*option_len != sizeof(data->txid)) {
#line 594
    goto error;
  }
  {
#line 595
  memcpy((void */* __restrict  */)(& data->txid), (void const   */* __restrict  */)option_value,
         sizeof(data->txid));
#line 597
  *option_len = sizeof(data->txid);
  }
#line 598
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 601
  return (0);
  error: 
  {
#line 604
  tmp___0 = __errno_location();
#line 604
  *tmp___0 = 22;
#line 605
  tmp___1 = pi_set_error(ps->sd, -501);
  }
#line 605
  return (tmp___1);
}
}
#line 620 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
void slp_dump_header(unsigned char const   *data , int rxtx ) 
{ 
  char const   *tmp ;

  {
#line 623
  if (rxtx) {
#line 623
    tmp = "TX";
  } else {
#line 623
    tmp = "RX";
  }
  {
#line 623
  pi_log(4, 0, "SLP %s %d->%d type=%d txid=0x%.2x len=0x%.4x checksum=0x%.2x\n", tmp,
         (int )*((unsigned char *)(data + 3) + 0), (int )*((unsigned char *)(data + 4) + 0),
         (int )*((unsigned char *)(data + 5) + 0), (int )*((unsigned char *)(data + 8) + 0),
         (int )((unsigned short )(((int )*((unsigned char *)(data + 6) + 0) << 8) | (int )*((unsigned char *)(data + 6) + 1))),
         (int )*((unsigned char *)(data + 9) + 0));
  }
#line 632
  return;
}
}
#line 646 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
void slp_dump(unsigned char const   *data ) 
{ 


  {
  {
#line 649
  pi_dumpdata((char const   *)((char *)(data + 10)), (size_t )((unsigned short )(((int )*((unsigned char *)(data + 6) + 0) << 8) | (int )*((unsigned char *)(data + 6) + 1))));
  }
#line 650
  return;
}
}
#line 34 "../include/pi-expense.h"
char *ExpenseSortNames[3] ;
#line 35
char *ExpenseDistanceNames[3] ;
#line 36
char *ExpensePaymentNames[8] ;
#line 37
char *ExpenseTypeNames[28] ;
#line 106
void free_Expense(struct Expense *expense ) ;
#line 108
int unpack_Expense(struct Expense *expense , unsigned char *buffer , int len ) ;
#line 110
int pack_Expense(struct Expense *expense , unsigned char *record , int len ) ;
#line 112
int unpack_ExpensePref(struct ExpensePref *pref , unsigned char *record , int len ) ;
#line 114
int pack_ExpensePref(struct ExpensePref *p , unsigned char *record , int len ) ;
#line 116
int unpack_ExpenseAppInfo(struct ExpenseAppInfo *appinfo , unsigned char *record ,
                          size_t len ) ;
#line 118
int pack_ExpenseAppInfo(struct ExpenseAppInfo *appinfo , unsigned char *record , size_t len ) ;
#line 41 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/expense.c"
char *ExpenseSortNames[3]  = {      (char *)"Date",      (char *)"Type",      (char *)((void *)0)};
#line 42 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/expense.c"
char *ExpenseDistanceNames[3]  = {      (char *)"Miles",      (char *)"Kilometers",      (char *)((void *)0)};
#line 43 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/expense.c"
char *ExpensePaymentNames[8]  = 
#line 43
  {      (char *)"AmEx",      (char *)"Cash",      (char *)"Check",      (char *)"CreditCard", 
        (char *)"MasterCard",      (char *)"Prepaid",      (char *)"VISA",      (char *)"Unfiled"};
#line 48 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/expense.c"
char *ExpenseTypeNames[28]  = 
#line 48
  {      (char *)"Airfare",      (char *)"Breakfast",      (char *)"Bus",      (char *)"Business Meals", 
        (char *)"Car Rental",      (char *)"Dinner",      (char *)"Entertainment",      (char *)"Fax", 
        (char *)"Gas",      (char *)"Gifts",      (char *)"Hotel",      (char *)"Incidentals", 
        (char *)"Laundry",      (char *)"Limo",      (char *)"Lodging",      (char *)"Lunch", 
        (char *)"Mileage",      (char *)"Other",      (char *)"Parking",      (char *)"Postage", 
        (char *)"Snack",      (char *)"Subway",      (char *)"Supplies",      (char *)"Taxi", 
        (char *)"Telephone",      (char *)"Tips",      (char *)"Tolls",      (char *)"Train"};
#line 68 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/expense.c"
void free_Expense(struct Expense *expense ) 
{ 


  {
#line 71
  if ((unsigned long )expense->note != (unsigned long )((void *)0)) {
    {
#line 72
    free((void *)expense->note);
#line 73
    expense->note = (char *)((void *)0);
    }
  }
#line 76
  if ((unsigned long )expense->amount != (unsigned long )((void *)0)) {
    {
#line 77
    free((void *)expense->amount);
#line 78
    expense->amount = (char *)((void *)0);
    }
  }
#line 81
  if ((unsigned long )expense->city != (unsigned long )((void *)0)) {
    {
#line 82
    free((void *)expense->city);
#line 83
    expense->city = (char *)((void *)0);
    }
  }
#line 86
  if ((unsigned long )expense->vendor != (unsigned long )((void *)0)) {
    {
#line 87
    free((void *)expense->vendor);
#line 88
    expense->vendor = (char *)((void *)0);
    }
  }
#line 91
  if ((unsigned long )expense->attendees != (unsigned long )((void *)0)) {
    {
#line 92
    free((void *)expense->attendees);
#line 93
    expense->attendees = (char *)((void *)0);
    }
  }
#line 95
  return;
}
}
#line 109 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/expense.c"
int unpack_Expense(struct Expense *expense , unsigned char *buffer , int len ) 
{ 
  unsigned long d ;
  unsigned char *start ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
#line 113
  start = buffer;
#line 115
  if (len < 6) {
#line 116
    return (0);
  }
  {
#line 118
  d = (unsigned long )((unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1)));
#line 119
  expense->date.tm_year = (int )((d >> 9) + 4UL);
#line 120
  expense->date.tm_mon = (int )(((d >> 5) & 15UL) - 1UL);
#line 121
  expense->date.tm_mday = (int )(d & 31UL);
#line 122
  expense->date.tm_hour = 0;
#line 123
  expense->date.tm_min = 0;
#line 124
  expense->date.tm_sec = 0;
#line 125
  expense->date.tm_isdst = -1;
#line 126
  mktime(& expense->date);
#line 128
  expense->type = (enum ExpenseType )*((buffer + 2) + 0);
#line 129
  expense->payment = (enum ExpensePayment )*((buffer + 3) + 0);
#line 130
  expense->currency = (int )*((buffer + 4) + 0);
#line 132
  buffer += 6;
#line 133
  len -= 6;
  }
#line 135
  if (len < 1) {
#line 136
    return (0);
  }
#line 138
  if (*buffer) {
    {
#line 139
    expense->amount = strdup((char const   *)((char *)buffer));
#line 140
    tmp = strlen((char const   *)expense->amount);
#line 140
    buffer += tmp;
#line 141
    tmp___0 = strlen((char const   *)expense->amount);
#line 141
    len = (int )((size_t )len - tmp___0);
    }
  } else {
#line 143
    expense->amount = (char *)0;
  }
#line 145
  buffer ++;
#line 146
  len --;
#line 148
  if (len < 1) {
#line 149
    return (0);
  }
#line 151
  if (*buffer) {
    {
#line 152
    expense->vendor = strdup((char const   *)((char *)buffer));
#line 153
    tmp___1 = strlen((char const   *)expense->vendor);
#line 153
    buffer += tmp___1;
#line 154
    tmp___2 = strlen((char const   *)expense->vendor);
#line 154
    len = (int )((size_t )len - tmp___2);
    }
  } else {
#line 156
    expense->vendor = (char *)0;
  }
#line 158
  buffer ++;
#line 159
  len --;
#line 161
  if (len < 1) {
#line 162
    return (0);
  }
#line 164
  if (*buffer) {
    {
#line 165
    expense->city = strdup((char const   *)((char *)buffer));
#line 166
    tmp___3 = strlen((char const   *)expense->city);
#line 166
    buffer += tmp___3;
#line 167
    tmp___4 = strlen((char const   *)expense->city);
#line 167
    len = (int )((size_t )len - tmp___4);
    }
  } else {
#line 169
    expense->city = (char *)0;
  }
#line 171
  buffer ++;
#line 172
  len --;
#line 174
  if (len < 1) {
#line 175
    return (0);
  }
#line 177
  if (*buffer) {
    {
#line 178
    expense->attendees = strdup((char const   *)((char *)buffer));
#line 179
    tmp___5 = strlen((char const   *)expense->attendees);
#line 179
    buffer += tmp___5;
#line 180
    tmp___6 = strlen((char const   *)expense->attendees);
#line 180
    len = (int )((size_t )len - tmp___6);
    }
  } else {
#line 182
    expense->attendees = (char *)0;
  }
#line 184
  buffer ++;
#line 185
  len --;
#line 187
  if (len < 1) {
#line 188
    return (0);
  }
#line 190
  if (*buffer) {
    {
#line 191
    expense->note = strdup((char const   *)((char *)buffer));
#line 192
    tmp___7 = strlen((char const   *)expense->note);
#line 192
    buffer += tmp___7;
#line 193
    tmp___8 = strlen((char const   *)expense->note);
#line 193
    len = (int )((size_t )len - tmp___8);
    }
  } else {
#line 195
    expense->note = (char *)0;
  }
#line 198
  buffer ++;
#line 199
  len --;
#line 201
  return ((int )(buffer - start));
}
}
#line 216 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/expense.c"
int pack_Expense(struct Expense *expense , unsigned char *record , int len ) 
{ 
  int destlen ;
  unsigned char *buf___3 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
#line 219
  destlen = 11;
#line 220
  buf___3 = record;
#line 222
  if (expense->amount) {
    {
#line 223
    tmp = strlen((char const   *)expense->amount);
#line 223
    destlen = (int )((size_t )destlen + tmp);
    }
  }
#line 224
  if (expense->vendor) {
    {
#line 225
    tmp___0 = strlen((char const   *)expense->vendor);
#line 225
    destlen = (int )((size_t )destlen + tmp___0);
    }
  }
#line 226
  if (expense->city) {
    {
#line 227
    tmp___1 = strlen((char const   *)expense->city);
#line 227
    destlen = (int )((size_t )destlen + tmp___1);
    }
  }
#line 228
  if (expense->attendees) {
    {
#line 229
    tmp___2 = strlen((char const   *)expense->attendees);
#line 229
    destlen = (int )((size_t )destlen + tmp___2);
    }
  }
#line 230
  if (expense->note) {
    {
#line 231
    tmp___3 = strlen((char const   *)expense->note);
#line 231
    destlen = (int )((size_t )destlen + tmp___3);
    }
  }
#line 233
  if (! record) {
#line 234
    return (destlen);
  }
#line 235
  if (len < destlen) {
#line 236
    return (0);
  }
#line 238
  *(buf___3 + 0) = (unsigned char )(((int )((unsigned short )((((expense->date.tm_year - 4) << 9) | ((expense->date.tm_mon + 1) << 5)) | expense->date.tm_mday)) >> 8) & 255);
#line 238
  *(buf___3 + 1) = (unsigned char )((int )((unsigned short )((((expense->date.tm_year - 4) << 9) | ((expense->date.tm_mon + 1) << 5)) | expense->date.tm_mday)) & 255);
#line 242
  buf___3 += 2;
#line 243
  *(buf___3 + 0) = (unsigned char )expense->type;
#line 244
  *((buf___3 + 1) + 0) = (unsigned char )expense->payment;
#line 245
  *((buf___3 + 2) + 0) = (unsigned char )expense->currency;
#line 246
  *((buf___3 + 3) + 0) = (unsigned char)0;
#line 247
  buf___3 += 4;
#line 249
  if (expense->amount) {
    {
#line 250
    strcpy((char */* __restrict  */)((char *)buf___3), (char const   */* __restrict  */)expense->amount);
#line 251
    tmp___4 = strlen((char const   *)((char *)buf___3));
#line 251
    buf___3 += tmp___4;
    }
  } else {
#line 253
    *(buf___3 + 0) = (unsigned char)0;
  }
#line 255
  buf___3 ++;
#line 257
  if (expense->vendor) {
    {
#line 258
    strcpy((char */* __restrict  */)((char *)buf___3), (char const   */* __restrict  */)expense->vendor);
#line 259
    tmp___5 = strlen((char const   *)((char *)buf___3));
#line 259
    buf___3 += tmp___5;
    }
  } else {
#line 261
    *(buf___3 + 0) = (unsigned char)0;
  }
#line 263
  buf___3 ++;
#line 265
  if (expense->city) {
    {
#line 266
    strcpy((char */* __restrict  */)((char *)buf___3), (char const   */* __restrict  */)expense->city);
#line 267
    tmp___6 = strlen((char const   *)((char *)buf___3));
#line 267
    buf___3 += tmp___6;
    }
  } else {
#line 269
    *(buf___3 + 0) = (unsigned char)0;
  }
#line 271
  buf___3 ++;
#line 273
  if (expense->attendees) {
    {
#line 274
    strcpy((char */* __restrict  */)((char *)buf___3), (char const   */* __restrict  */)expense->attendees);
#line 275
    tmp___7 = strlen((char const   *)((char *)buf___3));
#line 275
    buf___3 += tmp___7;
    }
  } else {
#line 277
    *(buf___3 + 0) = (unsigned char)0;
  }
#line 279
  buf___3 ++;
#line 281
  if (expense->note) {
    {
#line 282
    strcpy((char */* __restrict  */)((char *)buf___3), (char const   */* __restrict  */)expense->note);
#line 283
    tmp___8 = strlen((char const   *)((char *)buf___3));
#line 283
    buf___3 += tmp___8;
    }
  } else {
#line 285
    *(buf___3 + 0) = (unsigned char)0;
  }
#line 287
  buf___3 ++;
#line 289
  return ((int )(buf___3 - record));
}
}
#line 304 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/expense.c"
int unpack_ExpenseAppInfo(struct ExpenseAppInfo *appinfo , unsigned char *record ,
                          size_t len ) 
{ 
  int i ;
  unsigned char *start ;

  {
  {
#line 309
  start = record;
#line 311
  i = unpack_CategoryAppInfo(& appinfo->category, (unsigned char const   *)record,
                             len);
  }
#line 312
  if (! i) {
#line 313
    return (0);
  }
#line 314
  record += i;
#line 315
  len -= (size_t )i;
#line 317
  appinfo->sortOrder = (enum ExpenseSort )*(record + 0);
#line 318
  record += 2;
#line 319
  i = 0;
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (! (i < 4)) {
#line 319
      goto while_break;
    }
    {
#line 320
    memcpy((void */* __restrict  */)(appinfo->currencies[i].name), (void const   */* __restrict  */)record,
           (size_t )16);
#line 321
    record += 16;
#line 322
    memcpy((void */* __restrict  */)(appinfo->currencies[i].symbol), (void const   */* __restrict  */)record,
           (size_t )4);
#line 323
    record += 4;
#line 324
    memcpy((void */* __restrict  */)(appinfo->currencies[i].rate), (void const   */* __restrict  */)record,
           (size_t )8);
#line 325
    record += 8;
#line 319
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 327
  return ((int )(record - start));
}
}
#line 341 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/expense.c"
int pack_ExpenseAppInfo(struct ExpenseAppInfo *appinfo , unsigned char *record , size_t len ) 
{ 
  int i ;
  int destlen ;
  unsigned char *start ;

  {
  {
#line 345
  destlen = 114;
#line 347
  start = record;
#line 349
  i = pack_CategoryAppInfo((CategoryAppInfo_t const   *)(& appinfo->category), record,
                           len);
  }
#line 350
  if (! record) {
#line 351
    return (i + destlen);
  }
#line 352
  if (! i) {
#line 353
    return (i);
  }
#line 354
  record += i;
#line 355
  len -= (size_t )i;
#line 356
  if (len < (size_t )destlen) {
#line 357
    return (0);
  }
#line 358
  *(record + 0) = (unsigned char )appinfo->sortOrder;
#line 359
  *((record + 1) + 0) = (unsigned char)0;
#line 360
  record += 2;
#line 361
  i = 0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! (i < 4)) {
#line 361
      goto while_break;
    }
    {
#line 362
    memcpy((void */* __restrict  */)record, (void const   */* __restrict  */)(appinfo->currencies[i].name),
           (size_t )16);
#line 363
    record += 16;
#line 364
    memcpy((void */* __restrict  */)record, (void const   */* __restrict  */)(appinfo->currencies[i].symbol),
           (size_t )4);
#line 365
    record += 4;
#line 366
    memcpy((void */* __restrict  */)record, (void const   */* __restrict  */)(appinfo->currencies[i].rate),
           (size_t )8);
#line 367
    record += 8;
#line 361
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 370
  return ((int )(record - start));
}
}
#line 384 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/expense.c"
int unpack_ExpensePref(struct ExpensePref *pref , unsigned char *record , int len ) 
{ 
  int i ;
  unsigned char *start ;

  {
#line 388
  start = record;
#line 392
  pref->currentCategory = (int )((unsigned short )(((int )*(record + 0) << 8) | (int )*(record + 1)));
#line 393
  record += 2;
#line 394
  pref->defaultCurrency = (int )((unsigned short )(((int )*(record + 0) << 8) | (int )*(record + 1)));
#line 395
  record += 2;
#line 396
  pref->attendeeFont = (int )*(record + 0);
#line 397
  record ++;
#line 398
  pref->showAllCategories = (int )*(record + 0);
#line 399
  record ++;
#line 400
  pref->showCurrency = (int )*(record + 0);
#line 401
  record ++;
#line 402
  pref->saveBackup = (int )*(record + 0);
#line 403
  record ++;
#line 404
  pref->allowQuickFill = (int )*(record + 0);
#line 405
  record ++;
#line 406
  pref->unitOfDistance = (enum ExpenseDistance )*(record + 0);
#line 407
  record ++;
#line 409
  i = 0;
  {
#line 409
  while (1) {
    while_continue: /* CIL Label */ ;
#line 409
    if (! (i < 5)) {
#line 409
      goto while_break;
    }
#line 410
    pref->currencies[i] = (int )*(record + 0);
#line 411
    record ++;
#line 409
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 414
  i = 0;
  {
#line 414
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 414
    if (! (i < 2)) {
#line 414
      goto while_break___0;
    }
#line 415
    pref->unknown[i] = (int )*(record + 0);
#line 416
    record ++;
#line 414
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 419
  pref->noteFont = (int )*(record + 0);
#line 420
  record ++;
#line 422
  return ((int )(record - start));
}
}
#line 436 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/expense.c"
int pack_ExpensePref(struct ExpensePref *p , unsigned char *record , int len ) 
{ 
  int i ;
  unsigned char *start ;

  {
#line 439
  start = record;
#line 443
  *(record + 0) = (unsigned char )(((int )((unsigned short )p->currentCategory) >> 8) & 255);
#line 443
  *(record + 1) = (unsigned char )((int )((unsigned short )p->currentCategory) & 255);
#line 444
  record += 2;
#line 445
  *(record + 0) = (unsigned char )(((int )((unsigned short )p->defaultCurrency) >> 8) & 255);
#line 445
  *(record + 1) = (unsigned char )((int )((unsigned short )p->defaultCurrency) & 255);
#line 446
  record += 2;
#line 447
  *(record + 0) = (unsigned char )p->attendeeFont;
#line 448
  record ++;
#line 449
  *(record + 0) = (unsigned char )p->showAllCategories;
#line 450
  record ++;
#line 451
  *(record + 0) = (unsigned char )p->showCurrency;
#line 452
  record ++;
#line 453
  *(record + 0) = (unsigned char )p->saveBackup;
#line 454
  record ++;
#line 455
  *(record + 0) = (unsigned char )p->allowQuickFill;
#line 456
  record ++;
#line 457
  *(record + 0) = (unsigned char )p->unitOfDistance;
#line 458
  record ++;
#line 459
  i = 0;
  {
#line 459
  while (1) {
    while_continue: /* CIL Label */ ;
#line 459
    if (! (i < 5)) {
#line 459
      goto while_break;
    }
#line 460
    *(record + 0) = (unsigned char )p->currencies[i];
#line 461
    record ++;
#line 459
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 464
  *(record + 0) = (unsigned char)255;
#line 465
  record ++;
#line 466
  *(record + 0) = (unsigned char)255;
#line 467
  record ++;
#line 469
  *(record + 0) = (unsigned char )p->noteFont;
#line 470
  record ++;
#line 472
  return ((int )(record - start));
}
}
#line 28 "../include/pi-header.h"
void print_splash(char const   *progname )  __attribute__((__deprecated__)) ;
#line 31 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-header.c"
void print_splash(char const   *progname )  __attribute__((__deprecated__)) ;
#line 31 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-header.c"
void print_splash(char const   *progname ) 
{ 
  char *patchlevel ;

  {
  {
#line 33
  patchlevel = (char *)"";
#line 35
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   DEPRECATED: The application is calling print_splash()\n");
#line 37
  patchlevel = (char *)"";
#line 39
  printf((char const   */* __restrict  */)"   .--------------------------------------------.\n   | (c) Copyright 1996-2006, pilot-link team   |\n   |   Join the pilot-link lists to help out.   |\n   `--------------------------------------------\'\n   This is %s, from pilot-link version %d.%d.%d%s\n\n   Build target..: %s\n   Build date....: %s %s\n\n",
         progname, 0, 12, 5, patchlevel, "x86_64-unknown-linux-gnu", "Mar  4 2016",
         "18:18:16");
#line 49
  printf((char const   */* __restrict  */)"   pilot-link %d.%d.%d%s is covered under the GPL/LGPL\n",
         0, 12, 5, patchlevel);
#line 53
  printf((char const   */* __restrict  */)"   See the file COPYING under docs for more info.\n\n   Please use --help for more detailed options.\n");
  }
#line 56
  return;
}
}
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 519
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 204 "../include/pi-socket.h"
int pi_socket(int domain , int type , int protocol ) ;
#line 217
int pi_socket_setsd(pi_socket_t *ps , int pi_sd ) ;
#line 228
int pi_getsockname(int pi_sd , struct sockaddr *addr , size_t *namelen ) ;
#line 238
int pi_getsockpeer(int pi_sd , struct sockaddr *addr , size_t *namelen ) ;
#line 313
int pi_socket_connected(int pi_sd ) ;
#line 324
int pi_connect(int pi_sd , char const   *port ) ;
#line 338
int pi_bind(int pi_sd , char const   *port ) ;
#line 341
int pi_listen(int pi_sd , int backlog ) ;
#line 353
int pi_accept(int pi_sd , struct sockaddr *addr , size_t *addrlen ) ;
#line 369
int pi_accept_to(int pi_sd , struct sockaddr *addr , size_t *addrlen , int timeout ) ;
#line 382
int pi_close(int pi_sd ) ;
#line 402
int pi_send(int pi_sd , void const   *msg , size_t len , int flags ) ;
#line 421
ssize_t pi_recv(int pi_sd , pi_buffer_t *msg , size_t len , int flags ) ;
#line 433
ssize_t pi_read(int pi_sd , pi_buffer_t *msg , size_t len ) ;
#line 444
ssize_t pi_write(int pi_sd , void const   *msg , size_t len ) ;
#line 469
int pi_error(int pi_sd ) ;
#line 496
int pi_palmos_error(int pi_sd ) ;
#line 507
int pi_set_palmos_error(int pi_sd , int error_code ) ;
#line 516
void pi_reset_errors(int pi_sd ) ;
#line 531
int pi_version(int pi_sd ) ;
#line 547
unsigned long pi_maxrecsize(int pi_sd ) ;
#line 561
int pi_tickle(int pi_sd ) ;
#line 573
int pi_watchdog(int pi_sd , int newinterval ) ;
#line 138 "../include/pi-source.h"
pi_socket_list_t *pi_socket_recognize(pi_socket_t *ps ) ;
#line 139
pi_socket_t *find_pi_socket(int pi_sd ) ;
#line 90 "../include/pi-usb.h"
pi_device_t *pi_usb_device(int type ) ;
#line 44 "../include/pi-inet.h"
pi_device_t *pi_inet_device(int type ) ;
#line 38 "../include/pi-sys.h"
pi_protocol_t *sys_protocol(void) ;
#line 72 "../include/pi-cmp.h"
pi_protocol_t *cmp_protocol(void) ;
#line 783 "../include/pi-dlp.h"
int dlp_EndOfSync(int sd , int status ) ;
#line 50 "../include/pi-debug.h"
void pi_debug_set_types(int types ) ;
#line 53
void pi_debug_set_level(int level ) ;
#line 55
void pi_debug_set_file(char const   *path ) ;
#line 63 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_list_t *ps_list_append(pi_socket_list_t *list , pi_socket_t *ps ) ;
#line 65
static pi_socket_t *ps_list_find(pi_socket_list_t *list , int pi_sd ) ;
#line 67
static pi_socket_list_t *ps_list_remove(pi_socket_list_t *list , int pi_sd ) ;
#line 69
static pi_socket_list_t *ps_list_copy(pi_socket_list_t *list ) ;
#line 70
static void ps_list_free(pi_socket_list_t *list ) ;
#line 72
static void protocol_queue_add(pi_socket_t *ps , pi_protocol_t *prot ) ;
#line 73
static void protocol_cmd_queue_add(pi_socket_t *ps , pi_protocol_t *prot ) ;
#line 74
static pi_protocol_t *protocol_queue_find(pi_socket_t *ps , int level ) ;
#line 75
static pi_protocol_t *protocol_queue_find_next(pi_socket_t *ps , int level ) ;
#line 79
static int is_connected(pi_socket_t *ps ) ;
#line 80
static int is_listener(pi_socket_t *ps ) ;
#line 83 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static int psl_mutex  =    0;
#line 84 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_list_t *psl  =    (pi_socket_list_t *)((void *)0);
#line 86 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static int watch_list_mutex  =    0;
#line 87 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_list_t *watch_list  =    (pi_socket_list_t *)((void *)0);
#line 90 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static unsigned int interval  =    0U;
#line 94 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
int pi_sock_installedexit  =    0;
#line 133 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_list_t *ps_list_append(pi_socket_list_t *list , pi_socket_t *ps ) 
{ 
  pi_socket_list_t *elem ;
  pi_socket_list_t *new_elem ;
  void *tmp ;

  {
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! ((unsigned long )ps != (unsigned long )((void *)0))) {
      {
#line 138
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c",
             138, "ps != NULL");
      }
    }
#line 138
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 140
  tmp = malloc(sizeof(pi_socket_list_t ));
#line 140
  new_elem = (pi_socket_list_t *)tmp;
  }
#line 141
  if ((unsigned long )new_elem == (unsigned long )((void *)0)) {
#line 142
    return (list);
  }
#line 144
  new_elem->ps = ps;
#line 145
  new_elem->next = (struct pi_socket_list *)((void *)0);
#line 147
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 148
    return (new_elem);
  }
#line 150
  elem = list;
  {
#line 151
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 151
    if (! ((unsigned long )elem->next != (unsigned long )((void *)0))) {
#line 151
      goto while_break___0;
    }
#line 152
    elem = elem->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 153
  elem->next = new_elem;
#line 155
  return (list);
}
}
#line 177 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_t *ps_list_find(pi_socket_list_t *list , int pi_sd ) 
{ 
  pi_socket_list_t *elem ;

  {
#line 182
  elem = list;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! ((unsigned long )elem != (unsigned long )((void *)0))) {
#line 182
      goto while_break;
    }
#line 183
    if ((unsigned long )elem->ps != (unsigned long )((void *)0)) {
#line 183
      if ((elem->ps)->sd == pi_sd) {
#line 184
        return (elem->ps);
      }
    }
#line 182
    elem = elem->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return ((pi_socket_t *)((void *)0));
}
}
#line 207 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_list_t *ps_list_remove(pi_socket_list_t *list , int pi_sd ) 
{ 
  pi_socket_list_t *elem ;
  pi_socket_list_t *new_list ;
  pi_socket_list_t *prev_elem ;

  {
#line 210
  new_list = list;
#line 210
  prev_elem = (pi_socket_list_t *)((void *)0);
#line 214
  elem = list;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! ((unsigned long )elem != (unsigned long )((void *)0))) {
#line 214
      goto while_break;
    }
#line 215
    if ((unsigned long )elem->ps == (unsigned long )((void *)0)) {
#line 216
      goto __Cont;
    } else
#line 217
    if ((elem->ps)->sd == pi_sd) {
#line 218
      if ((unsigned long )prev_elem == (unsigned long )((void *)0)) {
#line 219
        new_list = elem->next;
      } else {
#line 221
        prev_elem->next = elem->next;
      }
      {
#line 222
      free((void *)elem);
      }
#line 223
      goto while_break;
    }
#line 225
    prev_elem = elem;
    __Cont: /* CIL Label */ 
#line 214
    elem = elem->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  return (new_list);
}
}
#line 246 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_list_t *ps_list_copy(pi_socket_list_t *list ) 
{ 
  pi_socket_list_t *l ;
  pi_socket_list_t *new_list ;

  {
#line 249
  new_list = (pi_socket_list_t *)((void *)0);
#line 251
  l = list;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 251
      goto while_break;
    }
    {
#line 252
    new_list = ps_list_append(new_list, l->ps);
#line 251
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  return (new_list);
}
}
#line 274 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void ps_list_free(pi_socket_list_t *list ) 
{ 
  pi_socket_list_t *l ;
  pi_socket_list_t *next ;

  {
#line 279
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 280
    return;
  }
#line 282
  l = list;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 284
    next = l->next;
#line 285
    free((void *)l);
#line 286
    l = next;
    }
#line 283
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 283
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return;
}
}
#line 302 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void protocol_queue_add(pi_socket_t *ps , pi_protocol_t *prot ) 
{ 
  void *tmp ;
  int *tmp___0 ;

  {
  {
#line 305
  tmp = realloc((void *)ps->protocol_queue, sizeof(pi_protocol_t *) * (unsigned long )(ps->queue_len + 1));
#line 305
  ps->protocol_queue = (struct pi_protocol **)tmp;
  }
#line 307
  if ((unsigned long )ps->protocol_queue != (unsigned long )((void *)0)) {
#line 308
    *(ps->protocol_queue + ps->queue_len) = prot;
#line 309
    (ps->queue_len) ++;
  } else {
    {
#line 311
    tmp___0 = __errno_location();
#line 311
    *tmp___0 = 12;
#line 312
    ps->queue_len = 0;
    }
  }
#line 314
  return;
}
}
#line 328 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void protocol_cmd_queue_add(pi_socket_t *ps , pi_protocol_t *prot ) 
{ 
  void *tmp ;
  int *tmp___0 ;

  {
  {
#line 331
  tmp = realloc((void *)ps->cmd_queue, sizeof(pi_protocol_t *) * (unsigned long )(ps->cmd_len + 1));
#line 331
  ps->cmd_queue = (struct pi_protocol **)tmp;
  }
#line 333
  if ((unsigned long )ps->cmd_queue != (unsigned long )((void *)0)) {
#line 334
    *(ps->cmd_queue + ps->cmd_len) = prot;
#line 335
    (ps->cmd_len) ++;
  } else {
    {
#line 337
    tmp___0 = __errno_location();
#line 337
    *tmp___0 = 12;
#line 338
    ps->cmd_len = 0;
    }
  }
#line 340
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_protocol_t *protocol_queue_find(pi_socket_t *ps , int level ) 
{ 
  int i ;

  {
#line 359
  if (ps->command) {
#line 360
    i = 0;
    {
#line 360
    while (1) {
      while_continue: /* CIL Label */ ;
#line 360
      if (! (i < ps->cmd_len)) {
#line 360
        goto while_break;
      }
#line 361
      if ((*(ps->cmd_queue + i))->level == level) {
#line 362
        return (*(ps->cmd_queue + i));
      }
#line 360
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 365
    i = 0;
    {
#line 365
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 365
      if (! (i < ps->queue_len)) {
#line 365
        goto while_break___0;
      }
#line 366
      if ((*(ps->protocol_queue + i))->level == level) {
#line 367
        return (*(ps->protocol_queue + i));
      }
#line 365
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 371
  return ((pi_protocol_t *)((void *)0));
}
}
#line 386 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_protocol_t *protocol_queue_find_next(pi_socket_t *ps , int level ) 
{ 
  int i ;

  {
#line 391
  if (ps->command) {
#line 391
    if (ps->cmd_len == 0) {
#line 392
      return ((pi_protocol_t *)((void *)0));
    }
  }
#line 394
  if (! ps->command) {
#line 394
    if (ps->queue_len == 0) {
#line 395
      return ((pi_protocol_t *)((void *)0));
    }
  }
#line 397
  if (ps->command) {
#line 397
    if (level == 0) {
#line 398
      return (*(ps->cmd_queue + 0));
    }
  }
#line 400
  if (! ps->command) {
#line 400
    if (level == 0) {
#line 401
      return (*(ps->protocol_queue + 0));
    }
  }
#line 403
  if (ps->command) {
#line 404
    i = 0;
    {
#line 404
    while (1) {
      while_continue: /* CIL Label */ ;
#line 404
      if (! (i < ps->cmd_len - 1)) {
#line 404
        goto while_break;
      }
#line 405
      if ((*(ps->cmd_queue + i))->level == level) {
#line 406
        return (*(ps->cmd_queue + (i + 1)));
      }
#line 404
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 409
    i = 0;
    {
#line 409
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 409
      if (! (i < ps->queue_len - 1)) {
#line 409
        goto while_break___0;
      }
#line 410
      if ((*(ps->protocol_queue + i))->level == level) {
#line 411
        return (*(ps->protocol_queue + (i + 1)));
      }
#line 409
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 415
  return ((pi_protocol_t *)((void *)0));
}
}
#line 430 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void protocol_queue_build(pi_socket_t *ps , int autodetect ) 
{ 
  int protocol ;
  int result ;
  pi_protocol_t *dev_prot ;
  pi_protocol_t *dev_cmd_prot ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int skipped_bytes ;
  int bytes_to_skip ;
  pi_buffer_t *detect_buf ;
  pi_buffer_t *tmp___5 ;
  ssize_t tmp___6 ;
  int i ;
  unsigned char header_checksum ;
  ssize_t tmp___7 ;
  pi_protocol_t *tmp___8 ;
  pi_protocol_t *tmp___9 ;
  pi_protocol_t *tmp___10 ;
  pi_protocol_t *tmp___11 ;
  pi_protocol_t *tmp___12 ;
  pi_protocol_t *tmp___13 ;
  pi_protocol_t *tmp___14 ;
  pi_protocol_t *tmp___15 ;
  pi_protocol_t *tmp___16 ;

  {
  {
#line 439
  pi_log(128, 8, "SOCK fd=%d auto=%d\n", ps->sd, autodetect);
#line 442
  dev_prot = (*((ps->device)->protocol))(ps->device);
#line 443
  dev_cmd_prot = (*((ps->device)->protocol))(ps->device);
  }
#line 446
  if (ps->type == 48) {
    {
#line 447
    pi_log(128, 8, "RAW mode, no protocol\n", ps->sd, autodetect);
#line 448
    protocol_queue_add(ps, dev_prot);
#line 449
    protocol_cmd_queue_add(ps, dev_cmd_prot);
    }
#line 450
    return;
  }
#line 453
  protocol = ps->protocol;
#line 455
  if (protocol == 1) {
#line 455
    tmp___4 = "DEV";
  } else {
#line 455
    if (protocol == 2) {
#line 455
      tmp___3 = "SLP";
    } else {
#line 455
      if (protocol == 3) {
#line 455
        tmp___2 = "SYS";
      } else {
#line 455
        if (protocol == 4) {
#line 455
          tmp___1 = "PADP";
        } else {
#line 455
          if (protocol == 5) {
#line 455
            tmp___0 = "NET";
          } else {
#line 455
            if (protocol == 6) {
#line 455
              tmp = "DLP";
            } else {
#line 455
              tmp = "unknown";
            }
#line 455
            tmp___0 = tmp;
          }
#line 455
          tmp___1 = tmp___0;
        }
#line 455
        tmp___2 = tmp___1;
      }
#line 455
      tmp___3 = tmp___2;
    }
#line 455
    tmp___4 = tmp___3;
  }
  {
#line 455
  pi_log(128, 8, "SOCK proto=%s (%d)\n", tmp___4, protocol);
  }
#line 464
  if (protocol == 6) {
#line 464
    if (autodetect) {
      {
#line 465
      skipped_bytes = 0;
#line 467
      tmp___5 = pi_buffer_new((size_t )64);
#line 467
      detect_buf = tmp___5;
      }
      {
#line 470
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 472
        tmp___6 = (*(dev_prot->read))(ps, detect_buf, (size_t )10, 1);
#line 472
        result = (int )tmp___6;
        }
#line 473
        if (result < 0) {
#line 474
          goto while_break;
        }
#line 475
        if (result != 10) {
          {
#line 476
          pi_buffer_clear(detect_buf);
          }
#line 477
          goto __Cont;
        }
#line 480
        bytes_to_skip = 1;
#line 483
        if ((int )*(detect_buf->data + 0) == 190) {
#line 483
          if ((int )*(detect_buf->data + 1) == 239) {
#line 483
            if ((int )*(detect_buf->data + 2) == 237) {
#line 490
              i = 0;
#line 490
              header_checksum = (unsigned char )i;
              {
#line 490
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 490
                if (! (i < 9)) {
#line 490
                  goto while_break___0;
                }
#line 491
                header_checksum = (unsigned char )((int )header_checksum + (int )*(detect_buf->data + i));
#line 490
                i ++;
              }
              while_break___0: /* CIL Label */ ;
              }
#line 493
              if ((int )header_checksum == (int )*(detect_buf->data + 9)) {
#line 494
                if ((int )*(detect_buf->data + 3) == 3) {
#line 494
                  if ((int )*(detect_buf->data + 4) == 3) {
#line 494
                    if ((int )*(detect_buf->data + 5) == 2) {
#line 494
                      if ((int )*(detect_buf->data + 8) == 255) {
                        {
#line 499
                        protocol = 4;
#line 500
                        pi_log(128, 4, "\nusing PADP/SLP protocol (skipped %d bytes)\n",
                               skipped_bytes);
                        }
#line 503
                        goto while_break;
                      } else {
#line 507
                        bytes_to_skip = 10;
                      }
                    } else {
#line 507
                      bytes_to_skip = 10;
                    }
                  } else {
#line 507
                    bytes_to_skip = 10;
                  }
                } else {
#line 507
                  bytes_to_skip = 10;
                }
              } else {
#line 511
                bytes_to_skip = 3;
              }
            } else {
#line 483
              goto _L___5;
            }
          } else {
#line 483
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 516
        if ((int )*(detect_buf->data + 0) == 1) {
#line 516
          if ((int )*(detect_buf->data + 2) == 0) {
#line 516
            if ((int )*(detect_buf->data + 3) == 0) {
#line 516
              if ((int )*(detect_buf->data + 4) == 0) {
#line 516
                if ((int )*(detect_buf->data + 5) > 0) {
#line 516
                  if ((int )*(detect_buf->data + 6) == 144) {
                    {
#line 523
                    protocol = 5;
#line 524
                    pi_log(128, 4, "\nusing NET protocol (skipped %d bytes)\n", skipped_bytes);
                    }
#line 527
                    goto while_break;
                  } else {
#line 516
                    goto _L___3;
                  }
                } else {
#line 516
                  goto _L___3;
                }
              } else {
#line 516
                goto _L___3;
              }
            } else {
#line 516
              goto _L___3;
            }
          } else {
#line 516
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 535
        if ((int )*(detect_buf->data + 0) == 144) {
#line 535
          if ((int )*(detect_buf->data + 1) == 1) {
#line 535
            if ((int )*(detect_buf->data + 2) == 0) {
#line 535
              if ((int )*(detect_buf->data + 3) == 0) {
#line 535
                if ((int )*(detect_buf->data + 4) == 0) {
#line 535
                  if ((int )*(detect_buf->data + 5) == 0) {
#line 535
                    if ((int )*(detect_buf->data + 6) == 0) {
#line 535
                      if ((int )*(detect_buf->data + 7) == 0) {
#line 535
                        if ((int )*(detect_buf->data + 8) == 0) {
#line 535
                          if ((int )*(detect_buf->data + 9) == 32) {
                            {
#line 546
                            protocol = 5;
#line 547
                            pi_log(128, 4, "\nusing NET protocol (skipped %d bytes)\n",
                                   skipped_bytes);
                            }
#line 550
                            goto while_break;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        {
#line 554
        tmp___7 = (*(dev_prot->read))(ps, detect_buf, (size_t )bytes_to_skip, 0);
#line 554
        result = (int )tmp___7;
        }
#line 555
        if (result < 0) {
#line 556
          goto while_break;
        }
        {
#line 557
        skipped_bytes += bytes_to_skip;
#line 558
        pi_buffer_clear(detect_buf);
        }
        __Cont: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 561
      pi_buffer_free(detect_buf);
      }
#line 563
      if (result < 0) {
        {
#line 568
        pi_log(128, 8, "Error: last read returned %d; switching to PADP by default\n",
               result);
#line 571
        protocol = 4;
        }
      }
    } else {
#line 464
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 574
  if (protocol == 6) {
#line 575
    protocol = 4;
  }
  {
#line 580
  if (protocol == 4) {
#line 580
    goto case_4;
  }
#line 582
  if (protocol == 2) {
#line 582
    goto case_2;
  }
#line 585
  if (protocol == 5) {
#line 585
    goto case_5;
  }
#line 588
  if (protocol == 3) {
#line 588
    goto case_3;
  }
#line 579
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 581
  tmp___8 = padp_protocol();
#line 581
  protocol_queue_add(ps, tmp___8);
  }
  case_2: /* CIL Label */ 
  {
#line 583
  tmp___9 = slp_protocol();
#line 583
  protocol_queue_add(ps, tmp___9);
  }
#line 584
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 586
  tmp___10 = net_protocol();
#line 586
  protocol_queue_add(ps, tmp___10);
  }
#line 587
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 589
  tmp___11 = sys_protocol();
#line 589
  protocol_queue_add(ps, tmp___11);
#line 590
  tmp___12 = slp_protocol();
#line 590
  protocol_queue_add(ps, tmp___12);
  }
#line 591
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 597
  if (protocol == 2) {
#line 597
    goto case_2___0;
  }
#line 597
  if (protocol == 4) {
#line 597
    goto case_2___0;
  }
#line 603
  if (protocol == 5) {
#line 603
    goto case_5___0;
  }
#line 607
  if (protocol == 3) {
#line 607
    goto case_3___0;
  }
#line 610
  goto switch_default;
  case_2___0: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  {
#line 598
  tmp___13 = cmp_protocol();
#line 598
  protocol_cmd_queue_add(ps, tmp___13);
#line 599
  tmp___14 = padp_protocol();
#line 599
  protocol_cmd_queue_add(ps, tmp___14);
#line 600
  tmp___15 = slp_protocol();
#line 600
  protocol_cmd_queue_add(ps, tmp___15);
#line 601
  ps->cmd = 1;
  }
#line 602
  goto switch_break___0;
  case_5___0: /* CIL Label */ 
  {
#line 604
  tmp___16 = net_protocol();
#line 604
  protocol_cmd_queue_add(ps, tmp___16);
#line 605
  ps->cmd = 2;
  }
#line 606
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 608
  ps->cmd = 3;
#line 609
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 611
  pi_log(128, 1, "invalid protocol (%d)", protocol);
  }
#line 612
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 615
  protocol_queue_add(ps, dev_prot);
#line 616
  protocol_cmd_queue_add(ps, dev_cmd_prot);
  }
#line 617
  return;
}
}
#line 631 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void protocol_queue_destroy(pi_socket_t *ps ) 
{ 
  int i ;

  {
#line 635
  i = 0;
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 635
    if (! (i < ps->queue_len)) {
#line 635
      goto while_break;
    }
    {
#line 636
    (*((*(ps->protocol_queue + i))->free))(*(ps->protocol_queue + i));
#line 635
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 637
  i = 0;
  {
#line 637
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 637
    if (! (i < ps->cmd_len)) {
#line 637
      goto while_break___0;
    }
    {
#line 638
    (*((*(ps->cmd_queue + i))->free))(*(ps->cmd_queue + i));
#line 637
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 640
  if (ps->queue_len > 0) {
    {
#line 641
    free((void *)ps->protocol_queue);
    }
  }
#line 642
  if (ps->cmd_len > 0) {
    {
#line 643
    free((void *)ps->cmd_queue);
    }
  }
#line 644
  return;
}
}
#line 658 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
struct pi_protocol *pi_protocol(int pi_sd , int level ) 
{ 
  pi_socket_t *ps ;
  int *tmp ;
  pi_protocol_t *tmp___0 ;

  {
  {
#line 663
  ps = find_pi_socket(pi_sd);
  }
#line 663
  if (! ps) {
    {
#line 664
    tmp = __errno_location();
#line 664
    *tmp = 3;
    }
#line 665
    return ((struct pi_protocol *)((void *)0));
  }
  {
#line 668
  tmp___0 = protocol_queue_find(ps, level);
  }
#line 668
  return (tmp___0);
}
}
#line 671 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
struct pi_protocol *pi_protocol_next(int pi_sd , int level ) 
{ 
  pi_socket_t *ps ;
  int *tmp ;
  pi_protocol_t *tmp___0 ;

  {
  {
#line 676
  ps = find_pi_socket(pi_sd);
  }
#line 676
  if (! ps) {
    {
#line 677
    tmp = __errno_location();
#line 677
    *tmp = 3;
    }
#line 678
    return ((struct pi_protocol *)((void *)0));
  }
  {
#line 681
  tmp___0 = protocol_queue_find_next(ps, level);
  }
#line 681
  return (tmp___0);
}
}
#line 697 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void env_dbgcheck(void) 
{ 
  int types ;
  int done ;
  char *debug ;
  char *b ;
  char *e ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int level ;
  char const   *debug___0 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  char const   *logfile ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;

  {
  {
#line 700
  tmp___11 = getenv("PILOT_DEBUG");
  }
#line 700
  if (tmp___11) {
    {
#line 701
    types = 0;
#line 707
    tmp = getenv("PILOT_DEBUG");
#line 707
    debug = strdup((char const   *)tmp);
#line 709
    b = debug;
#line 710
    done = 0;
    }
    {
#line 711
    while (1) {
      while_continue: /* CIL Label */ ;
#line 711
      if (! (! done)) {
#line 711
        goto while_break;
      }
      {
#line 712
      e = strchr((char const   *)b, ' ');
      }
#line 713
      if (e) {
#line 714
        *e = (char )'\000';
      } else {
#line 716
        done = 1;
      }
      {
#line 718
      tmp___10 = strcmp((char const   *)b, "SYS");
      }
#line 718
      if (tmp___10) {
        {
#line 720
        tmp___9 = strcmp((char const   *)b, "DEV");
        }
#line 720
        if (tmp___9) {
          {
#line 722
          tmp___8 = strcmp((char const   *)b, "SLP");
          }
#line 722
          if (tmp___8) {
            {
#line 724
            tmp___7 = strcmp((char const   *)b, "PADP");
            }
#line 724
            if (tmp___7) {
              {
#line 726
              tmp___6 = strcmp((char const   *)b, "DLP");
              }
#line 726
              if (tmp___6) {
                {
#line 728
                tmp___5 = strcmp((char const   *)b, "NET");
                }
#line 728
                if (tmp___5) {
                  {
#line 730
                  tmp___4 = strcmp((char const   *)b, "CMP");
                  }
#line 730
                  if (tmp___4) {
                    {
#line 732
                    tmp___3 = strcmp((char const   *)b, "SOCK");
                    }
#line 732
                    if (tmp___3) {
                      {
#line 734
                      tmp___2 = strcmp((char const   *)b, "API");
                      }
#line 734
                      if (tmp___2) {
                        {
#line 736
                        tmp___1 = strcmp((char const   *)b, "USER");
                        }
#line 736
                        if (tmp___1) {
                          {
#line 738
                          tmp___0 = strcmp((char const   *)b, "ALL");
                          }
#line 738
                          if (! tmp___0) {
#line 739
                            types |= 1024;
                          }
                        } else {
#line 737
                          types |= 512;
                        }
                      } else {
#line 735
                        types |= 256;
                      }
                    } else {
#line 733
                      types |= 128;
                    }
                  } else {
#line 731
                    types |= 64;
                  }
                } else {
#line 729
                  types |= 32;
                }
              } else {
#line 727
                types |= 16;
              }
            } else {
#line 725
              types |= 8;
            }
          } else {
#line 723
            types |= 4;
          }
        } else {
#line 721
          types |= 2;
        }
      } else {
#line 719
        types |= 1;
      }
#line 740
      e ++;
#line 741
      b = e;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 743
    pi_debug_set_types(types);
#line 745
    free((void *)debug);
    }
  }
  {
#line 749
  tmp___18 = getenv("PILOT_DEBUG_LEVEL");
  }
#line 749
  if (tmp___18) {
    {
#line 750
    level = 0;
#line 754
    tmp___12 = getenv("PILOT_DEBUG_LEVEL");
#line 754
    debug___0 = (char const   *)tmp___12;
#line 755
    tmp___17 = strcmp(debug___0, "NONE");
    }
#line 755
    if (tmp___17) {
      {
#line 757
      tmp___16 = strcmp(debug___0, "ERR");
      }
#line 757
      if (tmp___16) {
        {
#line 759
        tmp___15 = strcmp(debug___0, "WARN");
        }
#line 759
        if (tmp___15) {
          {
#line 761
          tmp___14 = strcmp(debug___0, "INFO");
          }
#line 761
          if (tmp___14) {
            {
#line 763
            tmp___13 = strcmp(debug___0, "DEBUG");
            }
#line 763
            if (! tmp___13) {
#line 764
              level |= 8;
            }
          } else {
#line 762
            level |= 4;
          }
        } else {
#line 760
          level |= 2;
        }
      } else {
#line 758
        level |= 1;
      }
    } else {
#line 756
      level = level;
    }
    {
#line 766
    pi_debug_set_level(level);
    }
  }
  {
#line 770
  tmp___20 = getenv("PILOT_LOG");
  }
#line 770
  if (tmp___20) {
    {
#line 770
    tmp___21 = getenv("PILOT_LOG");
#line 770
    tmp___22 = atoi((char const   *)tmp___21);
    }
#line 770
    if (tmp___22) {
      {
#line 773
      tmp___19 = getenv("PILOT_LOGFILE");
#line 773
      logfile = (char const   *)tmp___19;
      }
#line 774
      if ((unsigned long )logfile == (unsigned long )((void *)0)) {
        {
#line 775
        pi_debug_set_file("pilot-link.debug");
        }
      } else {
        {
#line 777
        pi_debug_set_file(logfile);
        }
      }
    }
  }
#line 779
  return;
}
}
#line 793 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static int is_connected(pi_socket_t *ps ) 
{ 
  int tmp ;

  {
#line 796
  if (ps->state == 4) {
#line 796
    tmp = 1;
  } else
#line 796
  if (ps->state == 2) {
#line 796
    tmp = 1;
  } else {
#line 796
    tmp = 0;
  }
#line 796
  return (tmp);
}
}
#line 810 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static int is_listener(pi_socket_t *ps ) 
{ 
  int tmp ;

  {
#line 813
  if (ps->state == 1) {
#line 813
    tmp = 1;
  } else {
#line 813
    tmp = 0;
  }
#line 813
  return (tmp);
}
}
#line 817 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void onalarm(int signo ) 
{ 
  pi_socket_list_t *l ;
  pi_socket_t *ps ;
  int tmp ;
  PI_ERR tmp___0 ;

  {
  {
#line 822
  signal(signo, & onalarm);
#line 824
  pi_mutex_lock(& watch_list_mutex);
#line 826
  l = watch_list;
  }
  {
#line 826
  while (1) {
    while_continue: /* CIL Label */ ;
#line 826
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 826
      goto while_break;
    }
    {
#line 827
    ps = l->ps;
#line 829
    tmp = is_connected(ps);
    }
#line 829
    if (! tmp) {
#line 830
      goto __Cont;
    }
    {
#line 832
    tmp___0 = pi_tickle(ps->sd);
    }
#line 832
    if (tmp___0 < 0) {
      {
#line 833
      pi_log(128, 4, "SOCKET Socket %d is busy during tickle\n", ps->sd);
#line 836
      alarm(1U);
      }
    } else {
      {
#line 838
      pi_log(128, 4, "SOCKET Tickling socket %d\n", ps->sd);
#line 840
      alarm(interval);
      }
    }
    __Cont: /* CIL Label */ 
#line 826
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 844
  pi_mutex_unlock(& watch_list_mutex);
  }
#line 845
  return;
}
}
#line 860 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void onexit(void) 
{ 
  pi_socket_list_t *l ;
  pi_socket_list_t *list ;

  {
  {
#line 866
  pi_mutex_lock(& psl_mutex);
#line 867
  list = ps_list_copy(psl);
#line 868
  pi_mutex_unlock(& psl_mutex);
#line 870
  l = list;
  }
  {
#line 870
  while (1) {
    while_continue: /* CIL Label */ ;
#line 870
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 870
      goto while_break;
    }
    {
#line 871
    pi_close((l->ps)->sd);
#line 870
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 873
  ps_list_free(list);
  }
#line 874
  return;
}
}
#line 888 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void installexit(void) 
{ 


  {
#line 891
  if (! pi_sock_installedexit) {
    {
#line 892
    atexit(& onexit);
#line 893
    pi_sock_installedexit = 1;
    }
  }
#line 895
  return;
}
}
#line 897 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
int pi_socket(int domain , int type , int protocol ) 
{ 
  pi_socket_t *ps ;
  pi_socket_list_t *list ;
  void *tmp ;
  int *tmp___0 ;
  int err ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 903
  env_dbgcheck();
  }
#line 905
  if (protocol == 0) {
#line 906
    if (type == 16) {
#line 907
      protocol = 6;
    } else
#line 908
    if (type == 48) {
#line 909
      protocol = 1;
    }
  }
  {
#line 912
  tmp = calloc((size_t )1, sizeof(pi_socket_t ));
#line 912
  ps = (pi_socket_t *)tmp;
  }
#line 913
  if ((unsigned long )ps == (unsigned long )((void *)0)) {
    {
#line 914
    tmp___0 = __errno_location();
#line 914
    *tmp___0 = 12;
    }
#line 915
    return (-1);
  }
  {
#line 919
  tmp___3 = open("/dev/null", 2);
#line 919
  ps->sd = tmp___3;
  }
#line 919
  if (tmp___3 == -1) {
    {
#line 920
    tmp___1 = __errno_location();
#line 920
    err = *tmp___1;
#line 922
    free((void *)ps);
#line 923
    tmp___2 = __errno_location();
#line 923
    *tmp___2 = err;
    }
#line 924
    return (-1);
  }
  {
#line 929
  ps->type = type;
#line 930
  ps->protocol = protocol;
#line 931
  ps->state = 32;
#line 932
  ps->honor_rx_to = 1;
#line 933
  ps->command = 1;
#line 936
  list = pi_socket_recognize(ps);
  }
#line 937
  if ((unsigned long )list == (unsigned long )((void *)0)) {
    {
#line 938
    close(ps->sd);
#line 939
    free((void *)ps);
#line 940
    tmp___4 = __errno_location();
#line 940
    *tmp___4 = 12;
    }
#line 941
    return (-1);
  }
  {
#line 944
  installexit();
  }
#line 945
  return (ps->sd);
}
}
#line 948 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
int pi_socket_setsd(pi_socket_t *ps , int pi_sd ) 
{ 
  int tmp ;

  {
  {
#line 952
  ps->sd = dup2(pi_sd, ps->sd);
  }
#line 961
  if (ps->sd == -1) {
    {
#line 962
    tmp = pi_set_error(ps->sd, -502);
    }
#line 962
    return (tmp);
  }
#line 963
  if (ps->sd != pi_sd) {
    {
#line 964
    close(pi_sd);
    }
  }
#line 965
  return (0);
}
}
#line 980 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
int pi_socket_init(pi_socket_t *ps ) 
{ 


  {
  {
#line 983
  protocol_queue_build(ps, 1);
  }
#line 984
  return (0);
}
}
#line 999 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
pi_socket_list_t *pi_socket_recognize(pi_socket_t *ps ) 
{ 


  {
  {
#line 1002
  pi_mutex_lock(& psl_mutex);
#line 1003
  psl = ps_list_append(psl, ps);
#line 1004
  pi_mutex_unlock(& psl_mutex);
  }
#line 1005
  return (psl);
}
}
#line 1020 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_t *pi_devsocket(int pi_sd , char const   *port , struct pi_sockaddr *addr ) 
{ 
  pi_socket_t *ps ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1025
  ps = find_pi_socket(pi_sd);
  }
#line 1025
  if (! ps) {
    {
#line 1026
    tmp = __errno_location();
#line 1026
    *tmp = 3;
    }
#line 1027
    return ((pi_socket_t *)((void *)0));
  }
#line 1030
  if ((unsigned long )port == (unsigned long )((void *)0)) {
    {
#line 1030
    tmp___1 = getenv("PILOTPORT");
#line 1030
    port = (char const   *)tmp___1;
    }
#line 1030
    if ((unsigned long )port == (unsigned long )((void *)0)) {
      {
#line 1031
      tmp___0 = __errno_location();
#line 1031
      *tmp___0 = 6;
      }
#line 1032
      return ((pi_socket_t *)((void *)0));
    }
  }
  {
#line 1036
  addr->pi_family = (unsigned short)0;
#line 1037
  tmp___4 = strncmp(port, "serial:", (size_t )7);
  }
#line 1037
  if (tmp___4) {
    {
#line 1041
    tmp___3 = strncmp(port, "usb:", (size_t )4);
    }
#line 1041
    if (tmp___3) {
      {
#line 1045
      tmp___2 = strncmp(port, "net:", (size_t )4);
      }
#line 1045
      if (tmp___2) {
        {
#line 1055
        strncpy((char */* __restrict  */)(addr->pi_device), (char const   */* __restrict  */)port,
                sizeof(addr->pi_device));
#line 1056
        ps->device = pi_serial_device(1);
        }
      } else {
        {
#line 1046
        strncpy((char */* __restrict  */)(addr->pi_device), (char const   */* __restrict  */)(port + 4),
                sizeof(addr->pi_device));
#line 1047
        ps->device = pi_inet_device(1);
        }
      }
    } else {
      {
#line 1042
      strncpy((char */* __restrict  */)(addr->pi_device), (char const   */* __restrict  */)(port + 4),
              sizeof(addr->pi_device));
#line 1043
      ps->device = pi_usb_device(1);
      }
    }
  } else {
    {
#line 1038
    strncpy((char */* __restrict  */)(addr->pi_device), (char const   */* __restrict  */)(port + 7),
            sizeof(addr->pi_device));
#line 1039
    ps->device = pi_serial_device(1);
    }
  }
#line 1059
  return (ps);
}
}
#line 1062 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
int pi_connect(int pi_sd , char const   *port ) 
{ 
  pi_socket_t *ps ;
  struct pi_sockaddr addr ;
  int result ;

  {
  {
#line 1069
  ps = pi_devsocket(pi_sd, port, & addr);
  }
#line 1070
  if (! ps) {
#line 1071
    return (-201);
  }
  {
#line 1074
  protocol_queue_build(ps, 0);
#line 1076
  result = (*((ps->device)->connect))(ps, (struct sockaddr *)(& addr), sizeof(addr));
  }
#line 1077
  if (result < 0) {
    {
#line 1078
    pi_close(pi_sd);
    }
  }
#line 1080
  return (result);
}
}
#line 1083 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
int pi_bind(int pi_sd , char const   *port ) 
{ 
  int bind_return ;
  pi_socket_t *ps ;
  struct pi_sockaddr addr ;

  {
  {
#line 1090
  ps = pi_devsocket(pi_sd, port, & addr);
  }
#line 1091
  if (! ps) {
#line 1092
    return (-201);
  }
  {
#line 1094
  bind_return = (*((ps->device)->bind))(ps, (struct sockaddr *)(& addr), sizeof(addr));
  }
#line 1096
  if (bind_return < 0) {
    {
#line 1097
    (*((ps->device)->free))(ps->device);
#line 1098
    ps->device = (struct pi_device *)((void *)0);
    }
  }
#line 1101
  return (bind_return);
}
}
#line 1104 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
int pi_listen(int pi_sd , int backlog ) 
{ 
  pi_socket_t *ps ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 1109
  ps = find_pi_socket(pi_sd);
  }
#line 1109
  if (! ps) {
    {
#line 1110
    tmp = __errno_location();
#line 1110
    *tmp = 3;
    }
#line 1111
    return (-201);
  }
  {
#line 1114
  tmp___0 = (*((ps->device)->listen))(ps, backlog);
  }
#line 1114
  return (tmp___0);
}
}
#line 1117 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
int pi_accept(int pi_sd , struct sockaddr *addr , size_t *addrlen ) 
{ 
  PI_ERR tmp ;

  {
  {
#line 1120
  tmp = pi_accept_to(pi_sd, addr, addrlen, 0);
  }
#line 1120
  return (tmp);
}
}
#line 1123 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
int pi_accept_to(int pi_sd , struct sockaddr *addr , size_t *addrlen , int timeout ) 
{ 
  pi_socket_t *ps ;
  int result ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 1129
  ps = find_pi_socket(pi_sd);
  }
#line 1129
  if (! ps) {
    {
#line 1130
    tmp = __errno_location();
#line 1130
    *tmp = 3;
    }
#line 1131
    return (-201);
  }
  {
#line 1134
  tmp___0 = is_listener(ps);
  }
#line 1134
  if (! tmp___0) {
#line 1135
    return (-205);
  }
  {
#line 1137
  ps->accept_to = timeout;
#line 1139
  result = (*((ps->device)->accept))(ps, addr, addrlen);
  }
#line 1140
  if (result < 0) {
    {
#line 1141
    pi_log(128, 8, "pi_accept_to: ps->device->accept returned %d, calling pi_close()\n",
           result);
#line 1144
    pi_close(pi_sd);
    }
  }
#line 1147
  return (result);
}
}
#line 1150 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
int pi_getsockopt(int pi_sd , int level , int option_name , void *option_value , size_t *option_len ) 
{ 
  pi_socket_t *ps ;
  pi_protocol_t *prot ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1157
  ps = find_pi_socket(pi_sd);
  }
#line 1157
  if (! ps) {
    {
#line 1158
    tmp = __errno_location();
#line 1158
    *tmp = 3;
    }
#line 1159
    return (-201);
  }
#line 1163
  if (level == 7) {
    {
#line 1165
    if (option_name == 0) {
#line 1165
      goto case_0;
    }
#line 1171
    if (option_name == 1) {
#line 1171
      goto case_1;
    }
#line 1177
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1166
    if (*option_len != sizeof(ps->state)) {
#line 1167
      goto argerr;
    }
    {
#line 1168
    memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& ps->state),
           sizeof(ps->state));
    }
#line 1169
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1172
    if (*option_len != sizeof(ps->honor_rx_to)) {
#line 1173
      goto argerr;
    }
    {
#line 1174
    memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& ps->honor_rx_to),
           sizeof(ps->honor_rx_to));
    }
#line 1175
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1178
    goto argerr;
    switch_break: /* CIL Label */ ;
    }
#line 1180
    return (0);
  }
  {
#line 1184
  prot = protocol_queue_find(ps, level);
  }
#line 1186
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 1187
    tmp___0 = __errno_location();
#line 1187
    *tmp___0 = 22;
#line 1188
    tmp___1 = pi_set_error(pi_sd, -201);
    }
#line 1188
    return (tmp___1);
  } else
#line 1186
  if (prot->level != level) {
    {
#line 1187
    tmp___0 = __errno_location();
#line 1187
    *tmp___0 = 22;
#line 1188
    tmp___1 = pi_set_error(pi_sd, -201);
    }
#line 1188
    return (tmp___1);
  }
  {
#line 1191
  tmp___2 = (*(prot->getsockopt))(ps, level, option_name, option_value, option_len);
  }
#line 1191
  return (tmp___2);
  argerr: 
  {
#line 1194
  tmp___3 = __errno_location();
#line 1194
  *tmp___3 = 22;
#line 1195
  tmp___4 = pi_set_error(pi_sd, -501);
  }
#line 1195
  return (tmp___4);
}
}
#line 1198 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
int pi_setsockopt(int pi_sd , int level , int option_name , void const   *option_value ,
                  size_t *option_len ) 
{ 
  pi_socket_t *ps ;
  pi_protocol_t *prot ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1205
  ps = find_pi_socket(pi_sd);
  }
#line 1205
  if (! ps) {
    {
#line 1206
    tmp = __errno_location();
#line 1206
    *tmp = 3;
    }
#line 1207
    return (-201);
  }
#line 1211
  if (level == 7) {
    {
#line 1213
    if (option_name == 0) {
#line 1213
      goto case_0;
    }
#line 1219
    if (option_name == 1) {
#line 1219
      goto case_1;
    }
#line 1225
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1214
    if (*option_len != sizeof(ps->state)) {
#line 1215
      goto argerr;
    }
    {
#line 1216
    memcpy((void */* __restrict  */)(& ps->state), (void const   */* __restrict  */)option_value,
           sizeof(ps->state));
    }
#line 1217
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1220
    if (*option_len != sizeof(ps->honor_rx_to)) {
#line 1221
      goto argerr;
    }
    {
#line 1222
    memcpy((void */* __restrict  */)(& ps->honor_rx_to), (void const   */* __restrict  */)option_value,
           sizeof(ps->honor_rx_to));
    }
#line 1223
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1226
    goto argerr;
    switch_break: /* CIL Label */ ;
    }
#line 1228
    return (0);
  }
  {
#line 1232
  prot = protocol_queue_find(ps, level);
  }
#line 1234
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 1235
    tmp___0 = __errno_location();
#line 1235
    *tmp___0 = 22;
    }
#line 1236
    return (-201);
  } else
#line 1234
  if (prot->level != level) {
    {
#line 1235
    tmp___0 = __errno_location();
#line 1235
    *tmp___0 = 22;
    }
#line 1236
    return (-201);
  }
  {
#line 1239
  tmp___1 = (*(prot->setsockopt))(ps, level, option_name, option_value, option_len);
  }
#line 1239
  return (tmp___1);
  argerr: 
  {
#line 1242
  tmp___2 = __errno_location();
#line 1242
  *tmp___2 = 22;
#line 1243
  tmp___3 = pi_set_error(pi_sd, -501);
  }
#line 1243
  return (tmp___3);
}
}
#line 1257 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
int pi_send(int pi_sd , void const   *msg , size_t len , int flags ) 
{ 
  pi_socket_t *ps ;
  int *tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 1262
  ps = find_pi_socket(pi_sd);
  }
#line 1262
  if (! ps) {
    {
#line 1263
    tmp = __errno_location();
#line 1263
    *tmp = 3;
    }
#line 1264
    return (-201);
  }
  {
#line 1267
  tmp___0 = is_connected(ps);
  }
#line 1267
  if (! tmp___0) {
#line 1268
    return (-200);
  }
#line 1270
  if (interval) {
    {
#line 1271
    alarm(interval);
    }
  }
  {
#line 1273
  tmp___1 = (*((*(ps->protocol_queue + 0))->write))(ps, (unsigned char const   *)((void *)msg),
                                                    len, flags);
  }
#line 1273
  return ((int )tmp___1);
}
}
#line 1287 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
ssize_t pi_recv(int pi_sd , pi_buffer_t *msg , size_t len , int flags ) 
{ 
  pi_socket_t *ps ;
  int *tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 1292
  ps = find_pi_socket(pi_sd);
  }
#line 1292
  if (! ps) {
    {
#line 1293
    tmp = __errno_location();
#line 1293
    *tmp = 3;
    }
#line 1294
    return ((ssize_t )-201);
  }
  {
#line 1297
  tmp___0 = is_connected(ps);
  }
#line 1297
  if (! tmp___0) {
#line 1298
    return ((ssize_t )-200);
  }
  {
#line 1300
  tmp___1 = (*((*(ps->protocol_queue + 0))->read))(ps, msg, len, flags);
  }
#line 1300
  return (tmp___1);
}
}
#line 1314 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
ssize_t pi_read(int pi_sd , pi_buffer_t *msg , size_t len ) 
{ 
  ssize_t tmp ;

  {
  {
#line 1317
  tmp = pi_recv(pi_sd, msg, len, 0);
  }
#line 1317
  return (tmp);
}
}
#line 1331 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
ssize_t pi_write(int pi_sd , void const   *msg , size_t len ) 
{ 
  int tmp ;

  {
  {
#line 1334
  tmp = pi_send(pi_sd, msg, len, 0);
  }
#line 1334
  return ((ssize_t )tmp);
}
}
#line 1337 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
void pi_flush(int pi_sd , int flags ) 
{ 
  pi_socket_t *ps ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 1342
  ps = find_pi_socket(pi_sd);
  }
#line 1342
  if (! ps) {
    {
#line 1343
    tmp = __errno_location();
#line 1343
    *tmp = 3;
    }
#line 1344
    return;
  }
  {
#line 1347
  tmp___0 = is_connected(ps);
  }
#line 1347
  if (! tmp___0) {
#line 1348
    return;
  }
  {
#line 1350
  (*((*(ps->protocol_queue + 0))->flush))(ps, flags);
  }
#line 1351
  return;
}
}
#line 1353 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
int pi_tickle(int pi_sd ) 
{ 
  int result ;
  int type ;
  int oldtype ;
  size_t len ;
  size_t size ;
  unsigned char msg[1] ;
  pi_socket_t *ps ;
  int *tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 1356
  result = 0;
#line 1359
  len = (size_t )0;
#line 1364
  ps = find_pi_socket(pi_sd);
  }
#line 1364
  if (! ps) {
    {
#line 1365
    tmp = __errno_location();
#line 1365
    *tmp = 3;
    }
#line 1366
    return (-201);
  }
  {
#line 1369
  tmp___0 = is_connected(ps);
  }
#line 1369
  if (! tmp___0) {
#line 1370
    return (-200);
  }
  {
#line 1372
  pi_log(128, 4, "SOCKET Tickling socket %d\n", pi_sd);
  }
  {
#line 1376
  if (ps->cmd == 1) {
#line 1376
    goto case_1;
  }
#line 1394
  if (ps->cmd == 2) {
#line 1394
    goto case_2;
  }
#line 1375
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1378
  size = sizeof(type);
#line 1379
  pi_getsockopt(ps->sd, 2, 0, (void *)(& oldtype), & size);
#line 1382
  type = 4;
#line 1383
  size = sizeof(type);
#line 1384
  pi_setsockopt(ps->sd, 2, 0, (void const   *)(& type), & size);
#line 1387
  tmp___1 = (*((*(ps->protocol_queue + 0))->write))(ps, (unsigned char const   *)(msg),
                                                    len, 0);
#line 1387
  result = (int )tmp___1;
#line 1390
  size = sizeof(type);
#line 1391
  pi_setsockopt(ps->sd, 2, 0, (void const   *)(& oldtype), & size);
  }
#line 1392
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1396
  ps->command = 1;
#line 1399
  type = 2;
#line 1400
  size = sizeof(type);
#line 1401
  pi_setsockopt(ps->sd, 3, 0, (void const   *)(& type), & size);
#line 1404
  tmp___2 = (*((*(ps->cmd_queue + 0))->write))(ps, (unsigned char const   *)(msg),
                                               len, 0);
#line 1404
  result = (int )tmp___2;
#line 1407
  ps->command = 0;
  }
#line 1408
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1411
  return (result);
}
}
#line 1414 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
int pi_close(int pi_sd ) 
{ 
  int result ;
  pi_socket_t *ps ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 1417
  result = 0;
#line 1420
  ps = find_pi_socket(pi_sd);
  }
#line 1420
  if (! ps) {
    {
#line 1421
    tmp = __errno_location();
#line 1421
    *tmp = 3;
    }
#line 1422
    return (-201);
  }
#line 1425
  if (ps->type == 16) {
#line 1425
    if (ps->cmd != 3) {
      {
#line 1426
      tmp___0 = is_connected(ps);
      }
#line 1426
      if (tmp___0) {
        {
#line 1427
        ps->command = 1;
#line 1430
        result = dlp_EndOfSync(ps->sd, 0);
#line 1432
        ps->command = 0;
        }
      }
    }
  }
#line 1436
  if (result == 0) {
    {
#line 1439
    pi_mutex_lock(& psl_mutex);
#line 1440
    psl = ps_list_remove(psl, pi_sd);
#line 1441
    pi_mutex_unlock(& psl_mutex);
#line 1443
    pi_mutex_lock(& watch_list_mutex);
#line 1444
    watch_list = ps_list_remove(watch_list, pi_sd);
#line 1445
    pi_mutex_unlock(& watch_list_mutex);
    }
#line 1447
    if ((unsigned long )ps->device != (unsigned long )((void *)0)) {
      {
#line 1448
      result = (*((ps->device)->close))(ps);
      }
    }
    {
#line 1450
    protocol_queue_destroy(ps);
    }
#line 1452
    if ((unsigned long )ps->device != (unsigned long )((void *)0)) {
      {
#line 1453
      (*((ps->device)->free))(ps->device);
      }
    }
#line 1455
    if (ps->sd > 0) {
      {
#line 1456
      close(ps->sd);
      }
    }
    {
#line 1457
    free((void *)ps);
    }
  }
#line 1460
  return (result);
}
}
#line 1475 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
int pi_getsockname(int pi_sd , struct sockaddr *addr , size_t *namelen ) 
{ 
  pi_socket_t *ps ;
  int *tmp ;

  {
  {
#line 1480
  ps = find_pi_socket(pi_sd);
  }
#line 1480
  if (! ps) {
    {
#line 1481
    tmp = __errno_location();
#line 1481
    *tmp = 3;
    }
#line 1482
    return (-201);
  }
#line 1485
  if (*namelen > ps->laddrlen) {
#line 1486
    *namelen = ps->laddrlen;
  }
  {
#line 1487
  memcpy((void */* __restrict  */)addr, (void const   */* __restrict  */)(& ps->laddr),
         *namelen);
  }
#line 1489
  return (0);
}
}
#line 1504 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
int pi_getsockpeer(int pi_sd , struct sockaddr *addr , size_t *namelen ) 
{ 
  pi_socket_t *ps ;
  int *tmp ;

  {
  {
#line 1509
  ps = find_pi_socket(pi_sd);
  }
#line 1509
  if (! ps) {
    {
#line 1510
    tmp = __errno_location();
#line 1510
    *tmp = 3;
    }
#line 1511
    return (-201);
  }
#line 1514
  if (*namelen > ps->raddrlen) {
#line 1515
    *namelen = ps->raddrlen;
  }
  {
#line 1516
  memcpy((void */* __restrict  */)addr, (void const   */* __restrict  */)(& ps->raddr),
         *namelen);
  }
#line 1518
  return (0);
}
}
#line 1521 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
int pi_version(int pi_sd ) 
{ 
  size_t size ;
  pi_socket_t *ps ;
  int *tmp ;

  {
  {
#line 1527
  ps = find_pi_socket(pi_sd);
  }
#line 1527
  if (! ps) {
    {
#line 1528
    tmp = __errno_location();
#line 1528
    *tmp = 3;
    }
#line 1529
    return (-201);
  }
#line 1532
  if (ps->dlpversion) {
#line 1533
    return (ps->dlpversion);
  }
#line 1535
  if (ps->cmd == 1) {
    {
#line 1537
    ps->command = 1;
#line 1540
    size = sizeof(ps->dlpversion);
#line 1541
    pi_getsockopt(ps->sd, 5, 2, (void *)(& ps->dlpversion), & size);
#line 1542
    ps->maxrecsize = 65535UL;
#line 1545
    ps->command = 0;
    }
  }
#line 1548
  return (ps->dlpversion);
}
}
#line 1551 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
unsigned long pi_maxrecsize(int pi_sd ) 
{ 
  pi_socket_t *ps ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 1556
  ps = find_pi_socket(pi_sd);
  }
#line 1556
  if (! ps) {
    {
#line 1557
    tmp = __errno_location();
#line 1557
    *tmp = 3;
    }
#line 1558
    return (0UL);
  }
  {
#line 1562
  tmp___0 = pi_version(pi_sd);
  }
#line 1562
  if (tmp___0 == 0) {
#line 1563
    return (65535UL);
  }
#line 1565
  return (ps->maxrecsize);
}
}
#line 1579 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
pi_socket_t *find_pi_socket(int pi_sd ) 
{ 
  pi_socket_t *result ;

  {
  {
#line 1584
  pi_mutex_lock(& psl_mutex);
#line 1585
  result = ps_list_find(psl, pi_sd);
#line 1586
  pi_mutex_unlock(& psl_mutex);
  }
#line 1588
  return (result);
}
}
#line 1591 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
int pi_watchdog(int pi_sd , int newinterval ) 
{ 
  pi_socket_t *ps ;
  int *tmp ;

  {
  {
#line 1596
  ps = find_pi_socket(pi_sd);
  }
#line 1596
  if (! ps) {
    {
#line 1597
    tmp = __errno_location();
#line 1597
    *tmp = 3;
    }
#line 1598
    return (-201);
  }
  {
#line 1601
  pi_mutex_lock(& watch_list_mutex);
#line 1602
  watch_list = ps_list_append(watch_list, ps);
#line 1603
  pi_mutex_unlock(& watch_list_mutex);
#line 1605
  signal(14, & onalarm);
#line 1606
  interval = (unsigned int )newinterval;
#line 1607
  alarm(interval);
  }
#line 1609
  return (0);
}
}
#line 1612 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
int pi_error(int pi_sd ) 
{ 
  pi_socket_t *ps ;
  int *tmp ;

  {
  {
#line 1617
  ps = find_pi_socket(pi_sd);
  }
#line 1617
  if ((unsigned long )ps == (unsigned long )((void *)0)) {
    {
#line 1618
    tmp = __errno_location();
#line 1618
    *tmp = 3;
    }
#line 1619
    return (-201);
  }
#line 1621
  return (ps->last_error);
}
}
#line 1624 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
int pi_set_error(int pi_sd , int error_code ) 
{ 
  pi_socket_t *ps ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 1629
  ps = find_pi_socket(pi_sd);
  }
#line 1629
  if (ps) {
#line 1630
    ps->last_error = error_code;
  } else {
    {
#line 1632
    tmp = __errno_location();
#line 1632
    *tmp = 3;
    }
  }
#line 1635
  if (error_code == -500) {
    {
#line 1636
    tmp___0 = __errno_location();
#line 1636
    *tmp___0 = 12;
    }
  }
#line 1638
  return (error_code);
}
}
#line 1641 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
int pi_palmos_error(int pi_sd ) 
{ 
  pi_socket_t *ps ;
  int *tmp ;

  {
  {
#line 1646
  ps = find_pi_socket(pi_sd);
  }
#line 1646
  if ((unsigned long )ps == (unsigned long )((void *)0)) {
    {
#line 1647
    tmp = __errno_location();
#line 1647
    *tmp = 3;
    }
#line 1648
    return (-201);
  }
#line 1650
  return (ps->palmos_error);
}
}
#line 1653 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
int pi_set_palmos_error(int pi_sd , int error_code ) 
{ 
  pi_socket_t *ps ;
  int *tmp ;

  {
  {
#line 1658
  ps = find_pi_socket(pi_sd);
  }
#line 1658
  if (ps) {
#line 1659
    ps->palmos_error = error_code;
  } else {
    {
#line 1661
    tmp = __errno_location();
#line 1661
    *tmp = 3;
    }
  }
#line 1662
  return (error_code);
}
}
#line 1665 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
void pi_reset_errors(int pi_sd ) 
{ 
  pi_socket_t *ps ;
  int *tmp ;

  {
  {
#line 1670
  ps = find_pi_socket(pi_sd);
  }
#line 1670
  if (ps) {
#line 1671
    ps->last_error = 0;
#line 1672
    ps->palmos_error = 0;
  } else {
    {
#line 1674
    tmp = __errno_location();
#line 1674
    *tmp = 3;
    }
  }
#line 1675
  return;
}
}
#line 1677 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
int pi_socket_connected(int pi_sd ) 
{ 
  pi_socket_t *ps ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 1682
  ps = find_pi_socket(pi_sd);
  }
#line 1682
  if (ps) {
    {
#line 1683
    tmp = is_connected(ps);
    }
#line 1683
    return (tmp);
  }
  {
#line 1684
  tmp___0 = __errno_location();
#line 1684
  *tmp___0 = 3;
  }
#line 1685
  return (0);
}
}
#line 76 "../include/pi-mail.h"
char *MailSyncTypeNames[4] ;
#line 77
char *MailSortTypeNames[3] ;
#line 101
void free_Mail(struct Mail *mail ) ;
#line 102
void free_MailAppInfo(struct MailAppInfo *appinfo ) ;
#line 103
void free_MailSyncPref(struct MailSyncPref *pref ) ;
#line 104
void free_MailSignaturePref(struct MailSignaturePref *pref ) ;
#line 107
int unpack_Mail(struct Mail *mail , unsigned char *buffer , size_t len ) ;
#line 110
int pack_Mail(struct Mail *mail , unsigned char *buffer , size_t len ) ;
#line 113
int unpack_MailAppInfo(struct MailAppInfo *appinfo , unsigned char *record , size_t len ) ;
#line 117
int pack_MailAppInfo(struct MailAppInfo *appinfo , unsigned char *record , size_t len ) ;
#line 121
int unpack_MailSyncPref(struct MailSyncPref *pref , unsigned char *record , size_t len ) ;
#line 125
int unpack_MailSignaturePref(struct MailSignaturePref *pref , unsigned char *record ,
                             size_t len ) ;
#line 129
int pack_MailSyncPref(struct MailSyncPref *pref , unsigned char *record , size_t len ) ;
#line 133
int pack_MailSignaturePref(struct MailSignaturePref *pref , unsigned char *record ,
                           size_t len ) ;
#line 41 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/mail.c"
char *MailSortTypeNames[3]  = {      (char *)"Date",      (char *)"Type",      (char *)((void *)0)};
#line 42 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/mail.c"
char *MailSyncTypeNames[4]  = {      (char *)"All",      (char *)"Send",      (char *)"Filter",      (char *)((void *)0)};
#line 55 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/mail.c"
void free_Mail(struct Mail *mail ) 
{ 


  {
#line 58
  if ((unsigned long )mail->from != (unsigned long )((void *)0)) {
    {
#line 59
    free((void *)mail->from);
#line 60
    mail->from = (char *)((void *)0);
    }
  }
#line 63
  if ((unsigned long )mail->to != (unsigned long )((void *)0)) {
    {
#line 64
    free((void *)mail->to);
#line 65
    mail->to = (char *)((void *)0);
    }
  }
#line 68
  if ((unsigned long )mail->subject != (unsigned long )((void *)0)) {
    {
#line 69
    free((void *)mail->subject);
#line 70
    mail->to = (char *)((void *)0);
    }
  }
#line 73
  if ((unsigned long )mail->cc != (unsigned long )((void *)0)) {
    {
#line 74
    free((void *)mail->cc);
#line 75
    mail->cc = (char *)((void *)0);
    }
  }
#line 78
  if ((unsigned long )mail->bcc != (unsigned long )((void *)0)) {
    {
#line 79
    free((void *)mail->bcc);
#line 80
    mail->bcc = (char *)((void *)0);
    }
  }
#line 83
  if (mail->replyTo) {
    {
#line 84
    free((void *)mail->replyTo);
#line 85
    mail->replyTo = (char *)((void *)0);
    }
  }
#line 88
  if (mail->sentTo) {
    {
#line 89
    free((void *)mail->sentTo);
#line 90
    mail->sentTo = (char *)((void *)0);
    }
  }
#line 93
  if ((unsigned long )mail->body != (unsigned long )((void *)0)) {
    {
#line 94
    free((void *)mail->body);
#line 95
    mail->body = (char *)((void *)0);
    }
  }
#line 97
  return;
}
}
#line 111 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/mail.c"
void free_MailAppInfo(struct MailAppInfo *appinfo ) 
{ 


  {
#line 116
  return;
}
}
#line 130 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/mail.c"
void free_MailSyncPref(struct MailSyncPref *pref ) 
{ 


  {
#line 133
  if ((unsigned long )pref->filterTo != (unsigned long )((void *)0)) {
    {
#line 134
    free((void *)pref->filterTo);
#line 135
    pref->filterTo = (char *)((void *)0);
    }
  }
#line 138
  if ((unsigned long )pref->filterFrom != (unsigned long )((void *)0)) {
    {
#line 139
    free((void *)pref->filterFrom);
#line 140
    pref->filterFrom = (char *)((void *)0);
    }
  }
#line 143
  if ((unsigned long )pref->filterSubject != (unsigned long )((void *)0)) {
    {
#line 144
    free((void *)pref->filterSubject);
#line 145
    pref->filterSubject = (char *)((void *)0);
    }
  }
#line 147
  return;
}
}
#line 161 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/mail.c"
void free_MailSignaturePref(struct MailSignaturePref *pref ) 
{ 


  {
#line 164
  if ((unsigned long )pref->signature != (unsigned long )((void *)0)) {
    {
#line 165
    free((void *)pref->signature);
#line 166
    pref->signature = (char *)((void *)0);
    }
  }
#line 168
  return;
}
}
#line 182 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/mail.c"
int unpack_Mail(struct Mail *mail , unsigned char *buffer , size_t len ) 
{ 
  int flags ;
  unsigned long d ;
  unsigned char *start ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;

  {
#line 187
  start = buffer;
#line 189
  if (len < 6UL) {
#line 190
    return (0);
  }
  {
#line 192
  d = (unsigned long )((unsigned short )(((int )*(buffer + 0) << 8) | (int )*(buffer + 1)));
#line 193
  mail->date.tm_year = (int )((d >> 9) + 4UL);
#line 194
  mail->date.tm_mon = (int )(((d >> 5) & 15UL) - 1UL);
#line 195
  mail->date.tm_mday = (int )(d & 31UL);
#line 196
  mail->date.tm_hour = (int )*((buffer + 2) + 0);
#line 197
  mail->date.tm_min = (int )*((buffer + 3) + 0);
#line 198
  mail->date.tm_sec = 0;
#line 199
  mail->date.tm_isdst = -1;
#line 200
  mktime(& mail->date);
  }
#line 202
  if (d) {
#line 203
    mail->dated = 1;
  } else {
#line 205
    mail->dated = 0;
  }
#line 207
  flags = (int )*((buffer + 4) + 0);
#line 209
  if (flags & (1 << 7)) {
#line 209
    mail->read = 1;
  } else {
#line 209
    mail->read = 0;
  }
#line 210
  if (flags & (1 << 6)) {
#line 210
    mail->signature = 1;
  } else {
#line 210
    mail->signature = 0;
  }
#line 211
  if (flags & (1 << 5)) {
#line 211
    mail->confirmRead = 1;
  } else {
#line 211
    mail->confirmRead = 0;
  }
#line 212
  if (flags & (1 << 4)) {
#line 212
    mail->confirmDelivery = 1;
  } else {
#line 212
    mail->confirmDelivery = 0;
  }
#line 213
  mail->priority = (flags & (3 << 2)) >> 2;
#line 214
  mail->addressing = flags & 3;
#line 216
  buffer += 6;
#line 217
  len -= 6UL;
#line 219
  if (len < 1UL) {
#line 220
    return (0);
  }
#line 221
  if (*(buffer + 0)) {
    {
#line 222
    mail->subject = strdup((char const   *)((char *)buffer));
#line 223
    tmp = strlen((char const   *)((char *)buffer));
#line 223
    buffer += tmp;
#line 224
    tmp___0 = strlen((char const   *)((char *)buffer));
#line 224
    len -= tmp___0;
    }
  } else {
#line 226
    mail->subject = (char *)0;
  }
#line 227
  buffer ++;
#line 228
  len --;
#line 229
  if (len < 1UL) {
#line 230
    return (0);
  }
#line 231
  if (*(buffer + 0)) {
    {
#line 232
    mail->from = strdup((char const   *)((char *)buffer));
#line 233
    tmp___1 = strlen((char const   *)((char *)buffer));
#line 233
    buffer += tmp___1;
#line 234
    tmp___2 = strlen((char const   *)((char *)buffer));
#line 234
    len -= tmp___2;
    }
  } else {
#line 236
    mail->from = (char *)0;
  }
#line 237
  buffer ++;
#line 238
  len --;
#line 239
  if (len < 1UL) {
#line 240
    return (0);
  }
#line 241
  if (*(buffer + 0)) {
    {
#line 242
    mail->to = strdup((char const   *)((char *)buffer));
#line 243
    tmp___3 = strlen((char const   *)((char *)buffer));
#line 243
    buffer += tmp___3;
#line 244
    tmp___4 = strlen((char const   *)((char *)buffer));
#line 244
    len -= tmp___4;
    }
  } else {
#line 246
    mail->to = (char *)0;
  }
#line 247
  buffer ++;
#line 248
  len --;
#line 249
  if (len < 1UL) {
#line 250
    return (0);
  }
#line 251
  if (*(buffer + 0)) {
    {
#line 252
    mail->cc = strdup((char const   *)((char *)buffer));
#line 253
    tmp___5 = strlen((char const   *)((char *)buffer));
#line 253
    buffer += tmp___5;
#line 254
    tmp___6 = strlen((char const   *)((char *)buffer));
#line 254
    len -= tmp___6;
    }
  } else {
#line 256
    mail->cc = (char *)0;
  }
#line 257
  buffer ++;
#line 258
  len --;
#line 259
  if (len < 1UL) {
#line 260
    return (0);
  }
#line 261
  if (*(buffer + 0)) {
    {
#line 262
    mail->bcc = strdup((char const   *)((char *)buffer));
#line 263
    tmp___7 = strlen((char const   *)((char *)buffer));
#line 263
    buffer += tmp___7;
#line 264
    tmp___8 = strlen((char const   *)((char *)buffer));
#line 264
    len -= tmp___8;
    }
  } else {
#line 266
    mail->bcc = (char *)0;
  }
#line 267
  buffer ++;
#line 268
  len --;
#line 269
  if (len < 1UL) {
#line 270
    return (0);
  }
#line 271
  if (*(buffer + 0)) {
    {
#line 272
    mail->replyTo = strdup((char const   *)((char *)buffer));
#line 273
    tmp___9 = strlen((char const   *)((char *)buffer));
#line 273
    buffer += tmp___9;
#line 274
    tmp___10 = strlen((char const   *)((char *)buffer));
#line 274
    len -= tmp___10;
    }
  } else {
#line 276
    mail->replyTo = (char *)0;
  }
#line 277
  buffer ++;
#line 278
  len --;
#line 279
  if (len < 1UL) {
#line 280
    return (0);
  }
#line 281
  if (*(buffer + 0)) {
    {
#line 282
    mail->sentTo = strdup((char const   *)((char *)buffer));
#line 283
    tmp___11 = strlen((char const   *)((char *)buffer));
#line 283
    buffer += tmp___11;
#line 284
    tmp___12 = strlen((char const   *)((char *)buffer));
#line 284
    len -= tmp___12;
    }
  } else {
#line 286
    mail->sentTo = (char *)0;
  }
#line 287
  buffer ++;
#line 288
  len --;
#line 289
  if (len < 1UL) {
#line 290
    return (0);
  }
#line 291
  if (*(buffer + 0)) {
    {
#line 292
    mail->body = strdup((char const   *)((char *)buffer));
#line 293
    tmp___13 = strlen((char const   *)((char *)buffer));
#line 293
    buffer += tmp___13;
#line 294
    tmp___14 = strlen((char const   *)((char *)buffer));
#line 294
    len -= tmp___14;
    }
  } else {
#line 296
    mail->body = (char *)0;
  }
#line 297
  buffer ++;
#line 298
  len --;
#line 300
  return ((int )(buffer - start));
}
}
#line 315 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/mail.c"
int pack_Mail(struct Mail *mail , unsigned char *buffer , size_t len ) 
{ 
  size_t destlen ;
  unsigned char *start ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;

  {
#line 318
  destlen = (size_t )14;
#line 319
  start = buffer;
#line 321
  if (mail->subject) {
    {
#line 322
    tmp = strlen((char const   *)mail->subject);
#line 322
    destlen += tmp;
    }
  }
#line 323
  if (mail->from) {
    {
#line 324
    tmp___0 = strlen((char const   *)mail->from);
#line 324
    destlen += tmp___0;
    }
  }
#line 325
  if (mail->to) {
    {
#line 326
    tmp___1 = strlen((char const   *)mail->to);
#line 326
    destlen += tmp___1;
    }
  }
#line 327
  if (mail->cc) {
    {
#line 328
    tmp___2 = strlen((char const   *)mail->cc);
#line 328
    destlen += tmp___2;
    }
  }
#line 329
  if (mail->bcc) {
    {
#line 330
    tmp___3 = strlen((char const   *)mail->bcc);
#line 330
    destlen += tmp___3;
    }
  }
#line 331
  if (mail->replyTo) {
    {
#line 332
    tmp___4 = strlen((char const   *)mail->replyTo);
#line 332
    destlen += tmp___4;
    }
  }
#line 333
  if (mail->sentTo) {
    {
#line 334
    tmp___5 = strlen((char const   *)mail->sentTo);
#line 334
    destlen += tmp___5;
    }
  }
#line 335
  if (mail->body) {
    {
#line 336
    tmp___6 = strlen((char const   *)mail->body);
#line 336
    destlen += tmp___6;
    }
  }
#line 338
  if (! buffer) {
#line 339
    return ((int )destlen);
  }
#line 340
  if (len < destlen) {
#line 341
    return (0);
  }
#line 343
  *(buffer + 0) = (unsigned char )(((int )((unsigned short )((((mail->date.tm_year - 4) << 9) | ((mail->date.tm_mon + 1) << 5)) | mail->date.tm_mday)) >> 8) & 255);
#line 343
  *(buffer + 1) = (unsigned char )((int )((unsigned short )((((mail->date.tm_year - 4) << 9) | ((mail->date.tm_mon + 1) << 5)) | mail->date.tm_mday)) & 255);
#line 347
  *((buffer + 2) + 0) = (unsigned char )mail->date.tm_hour;
#line 348
  *((buffer + 3) + 0) = (unsigned char )mail->date.tm_min;
#line 350
  if (! mail->dated) {
#line 351
    *(buffer + 0) = (unsigned char)0;
#line 351
    *(buffer + 1) = (unsigned char)0;
#line 351
    *(buffer + 2) = (unsigned char)0;
#line 351
    *(buffer + 3) = (unsigned char)0;
  }
#line 353
  if (mail->read) {
#line 353
    tmp___7 = 1 << 7;
  } else {
#line 353
    tmp___7 = 0;
  }
#line 353
  if (mail->signature) {
#line 353
    tmp___8 = 1 << 6;
  } else {
#line 353
    tmp___8 = 0;
  }
#line 353
  if (mail->confirmRead) {
#line 353
    tmp___9 = 1 << 5;
  } else {
#line 353
    tmp___9 = 0;
  }
#line 353
  if (mail->confirmDelivery) {
#line 353
    tmp___10 = 1 << 4;
  } else {
#line 353
    tmp___10 = 0;
  }
#line 353
  *((buffer + 4) + 0) = (unsigned char )(((((tmp___7 | tmp___8) | tmp___9) | tmp___10) | ((mail->priority & 3) << 2)) | (mail->addressing & 3));
#line 360
  *((buffer + 5) + 0) = (unsigned char)0;
#line 362
  buffer += 6;
#line 364
  if (mail->subject) {
    {
#line 365
    strcpy((char */* __restrict  */)((char *)buffer), (char const   */* __restrict  */)mail->subject);
#line 366
    tmp___11 = strlen((char const   *)((char *)buffer));
#line 366
    buffer += tmp___11;
    }
  } else {
#line 368
    *(buffer + 0) = (unsigned char)0;
  }
#line 369
  buffer ++;
#line 370
  if (mail->from) {
    {
#line 371
    strcpy((char */* __restrict  */)((char *)buffer), (char const   */* __restrict  */)mail->from);
#line 372
    tmp___12 = strlen((char const   *)((char *)buffer));
#line 372
    buffer += tmp___12;
    }
  } else {
#line 374
    *(buffer + 0) = (unsigned char)0;
  }
#line 375
  buffer ++;
#line 376
  if (mail->to) {
    {
#line 377
    strcpy((char */* __restrict  */)((char *)buffer), (char const   */* __restrict  */)mail->to);
#line 378
    tmp___13 = strlen((char const   *)((char *)buffer));
#line 378
    buffer += tmp___13;
    }
  } else {
#line 380
    *(buffer + 0) = (unsigned char)0;
  }
#line 381
  buffer ++;
#line 382
  if (mail->cc) {
    {
#line 383
    strcpy((char */* __restrict  */)((char *)buffer), (char const   */* __restrict  */)mail->cc);
#line 384
    tmp___14 = strlen((char const   *)((char *)buffer));
#line 384
    buffer += tmp___14;
    }
  } else {
#line 386
    *(buffer + 0) = (unsigned char)0;
  }
#line 387
  buffer ++;
#line 388
  if (mail->bcc) {
    {
#line 389
    strcpy((char */* __restrict  */)((char *)buffer), (char const   */* __restrict  */)mail->bcc);
#line 390
    tmp___15 = strlen((char const   *)((char *)buffer));
#line 390
    buffer += tmp___15;
    }
  } else {
#line 392
    *(buffer + 0) = (unsigned char)0;
  }
#line 393
  buffer ++;
#line 394
  if (mail->replyTo) {
    {
#line 395
    strcpy((char */* __restrict  */)((char *)buffer), (char const   */* __restrict  */)mail->replyTo);
#line 396
    tmp___16 = strlen((char const   *)((char *)buffer));
#line 396
    buffer += tmp___16;
    }
  } else {
#line 398
    *(buffer + 0) = (unsigned char)0;
  }
#line 399
  buffer ++;
#line 400
  if (mail->sentTo) {
    {
#line 401
    strcpy((char */* __restrict  */)((char *)buffer), (char const   */* __restrict  */)mail->sentTo);
#line 402
    tmp___17 = strlen((char const   *)((char *)buffer));
#line 402
    buffer += tmp___17;
    }
  } else {
#line 404
    *(buffer + 0) = (unsigned char)0;
  }
#line 405
  buffer ++;
#line 406
  if (mail->body) {
    {
#line 407
    strcpy((char */* __restrict  */)((char *)buffer), (char const   */* __restrict  */)mail->body);
#line 408
    tmp___18 = strlen((char const   *)((char *)buffer));
#line 408
    buffer += tmp___18;
    }
  } else {
#line 410
    *(buffer + 0) = (unsigned char)0;
  }
#line 411
  buffer ++;
#line 413
  return ((int )(buffer - start));
}
}
#line 428 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/mail.c"
int unpack_MailAppInfo(struct MailAppInfo *appinfo , unsigned char *record , size_t len ) 
{ 
  int i ;
  unsigned char *start ;

  {
  {
#line 432
  start = record;
#line 434
  i = unpack_CategoryAppInfo(& appinfo->category, (unsigned char const   *)record,
                             len);
  }
#line 435
  if (! i) {
#line 436
    return (i);
  }
#line 437
  record += i;
#line 438
  len -= (size_t )i;
#line 439
  if (len < 11UL) {
#line 440
    return (0);
  }
#line 441
  appinfo->dirty = (int )((unsigned short )(((int )*(record + 0) << 8) | (int )*(record + 1)));
#line 442
  record += 2;
#line 443
  appinfo->sortOrder = (int )*(record + 0);
#line 444
  record += 2;
#line 445
  appinfo->unsentMessage = ((((unsigned long )*(record + 0) << 24) | ((unsigned long )*(record + 1) << 16)) | ((unsigned long )*(record + 2) << 8)) | (unsigned long )*(record + 3);
#line 446
  record += 4;
#line 450
  record += 3;
#line 452
  return ((int )(record - start));
}
}
#line 467 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/mail.c"
int pack_MailAppInfo(struct MailAppInfo *appinfo , unsigned char *record , size_t len ) 
{ 
  int i ;
  unsigned char *start ;

  {
  {
#line 471
  start = record;
#line 473
  i = pack_CategoryAppInfo((CategoryAppInfo_t const   *)(& appinfo->category), record,
                           len);
  }
#line 474
  if (! record) {
#line 475
    return (i + 11);
  }
#line 476
  if (! i) {
#line 477
    return (i);
  }
#line 478
  record += i;
#line 479
  len -= (size_t )i;
#line 480
  if (len < 8UL) {
#line 481
    return (0);
  }
#line 482
  *(record + 0) = (unsigned char )(((int )((unsigned short )appinfo->dirty) >> 8) & 255);
#line 482
  *(record + 1) = (unsigned char )((int )((unsigned short )appinfo->dirty) & 255);
#line 483
  record += 2;
#line 484
  *(record + 0) = (unsigned char)0;
#line 484
  *(record + 1) = (unsigned char)0;
#line 485
  *(record + 0) = (unsigned char )appinfo->sortOrder;
#line 486
  record += 2;
#line 487
  *(record + 0) = (unsigned char )((int )((unsigned char )(appinfo->unsentMessage >> 24)) & 255);
#line 487
  *(record + 1) = (unsigned char )((appinfo->unsentMessage >> 16) & 255UL);
#line 487
  *(record + 2) = (unsigned char )((appinfo->unsentMessage >> 8) & 255UL);
#line 487
  *(record + 3) = (unsigned char )(appinfo->unsentMessage & 255UL);
#line 488
  record += 4;
#line 490
  *(record + 0) = (unsigned char )(((int )((unsigned short )((record - start) + 2L)) >> 8) & 255);
#line 490
  *(record + 1) = (unsigned char )((int )((unsigned short )((record - start) + 2L)) & 255);
#line 491
  record += 2;
#line 498
  *(record + 0) = (unsigned char)0;
#line 499
  record ++;
#line 501
  return ((int )(record - start));
}
}
#line 516 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/mail.c"
int unpack_MailSyncPref(struct MailSyncPref *pref , unsigned char *record , size_t len ) 
{ 
  unsigned char *start ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 519
  start = record;
#line 521
  pref->syncType = (int )*(record + 0);
#line 522
  record ++;
#line 523
  pref->getHigh = (int )*(record + 0);
#line 524
  record ++;
#line 525
  pref->getContaining = (int )*(record + 0);
#line 526
  record += 2;
#line 527
  pref->truncate = (int )((unsigned short )(((int )*(record + 0) << 8) | (int )*(record + 1)));
#line 528
  record += 2;
#line 530
  if (*(record + 0)) {
    {
#line 531
    pref->filterTo = strdup((char const   *)((char *)record));
#line 532
    tmp = strlen((char const   *)((char *)record));
#line 532
    record += tmp;
    }
  } else {
#line 534
    pref->filterTo = (char *)0;
  }
#line 535
  record ++;
#line 536
  if (*(record + 0)) {
    {
#line 537
    pref->filterFrom = strdup((char const   *)((char *)record));
#line 538
    tmp___0 = strlen((char const   *)((char *)record));
#line 538
    record += tmp___0;
    }
  } else {
#line 540
    pref->filterFrom = (char *)0;
  }
#line 541
  record ++;
#line 542
  if (*(record + 0)) {
    {
#line 543
    pref->filterSubject = strdup((char const   *)((char *)record));
#line 544
    tmp___1 = strlen((char const   *)((char *)record));
#line 544
    record += tmp___1;
    }
  } else {
#line 546
    pref->filterSubject = (char *)0;
  }
#line 547
  record ++;
#line 549
  return ((int )(record - start));
}
}
#line 564 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/mail.c"
int pack_MailSyncPref(struct MailSyncPref *pref , unsigned char *record , size_t len ) 
{ 
  size_t destlen ;
  unsigned char *start ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  unsigned char *tmp___3 ;
  size_t tmp___4 ;
  unsigned char *tmp___5 ;
  size_t tmp___6 ;
  unsigned char *tmp___7 ;

  {
#line 567
  destlen = (size_t )9;
#line 568
  start = record;
#line 570
  if (pref->filterTo) {
    {
#line 571
    tmp = strlen((char const   *)pref->filterTo);
#line 571
    destlen += tmp;
    }
  }
#line 572
  if (pref->filterSubject) {
    {
#line 573
    tmp___0 = strlen((char const   *)pref->filterSubject);
#line 573
    destlen += tmp___0;
    }
  }
#line 574
  if (pref->filterFrom) {
    {
#line 575
    tmp___1 = strlen((char const   *)pref->filterFrom);
#line 575
    destlen += tmp___1;
    }
  }
#line 577
  if (! record) {
#line 578
    return ((int )destlen);
  }
#line 579
  if (len < destlen) {
#line 580
    return (0);
  }
#line 582
  *(record + 0) = (unsigned char )pref->syncType;
#line 583
  record ++;
#line 584
  *(record + 0) = (unsigned char )pref->getHigh;
#line 585
  record ++;
#line 586
  *(record + 0) = (unsigned char )pref->getContaining;
#line 587
  record ++;
#line 588
  *(record + 0) = (unsigned char)0;
#line 589
  record ++;
#line 590
  *(record + 0) = (unsigned char )(((int )((unsigned short )pref->truncate) >> 8) & 255);
#line 590
  *(record + 1) = (unsigned char )((int )((unsigned short )pref->truncate) & 255);
#line 591
  record += 2;
#line 593
  if (pref->filterTo) {
    {
#line 594
    strcpy((char */* __restrict  */)((char *)record), (char const   */* __restrict  */)pref->filterTo);
#line 595
    tmp___2 = strlen((char const   *)pref->filterTo);
#line 595
    record += tmp___2;
    }
  }
#line 597
  tmp___3 = record;
#line 597
  record ++;
#line 597
  *tmp___3 = (unsigned char)0;
#line 599
  if (pref->filterFrom) {
    {
#line 600
    strcpy((char */* __restrict  */)((char *)record), (char const   */* __restrict  */)pref->filterFrom);
#line 601
    tmp___4 = strlen((char const   *)pref->filterFrom);
#line 601
    record += tmp___4;
    }
  }
#line 603
  tmp___5 = record;
#line 603
  record ++;
#line 603
  *tmp___5 = (unsigned char)0;
#line 605
  if (pref->filterSubject) {
    {
#line 606
    strcpy((char */* __restrict  */)((char *)record), (char const   */* __restrict  */)pref->filterSubject);
#line 607
    tmp___6 = strlen((char const   *)pref->filterSubject);
#line 607
    record += tmp___6;
    }
  }
#line 609
  tmp___7 = record;
#line 609
  record ++;
#line 609
  *tmp___7 = (unsigned char)0;
#line 611
  return ((int )(record - start));
}
}
#line 626 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/mail.c"
int unpack_MailSignaturePref(struct MailSignaturePref *pref , unsigned char *record ,
                             size_t len ) 
{ 
  unsigned char *start ;
  size_t tmp ;

  {
#line 630
  start = record;
#line 632
  if (len < 1UL) {
#line 633
    return (0);
  }
  {
#line 635
  pref->signature = strdup((char const   *)((char *)record));
#line 637
  tmp = strlen((char const   *)pref->signature);
#line 637
  record += tmp + 1UL;
  }
#line 639
  return ((int )(record - start));
}
}
#line 654 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/mail.c"
int pack_MailSignaturePref(struct MailSignaturePref *pref , unsigned char *record ,
                           size_t len ) 
{ 
  size_t destlen ;
  unsigned char *start ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 658
  destlen = (size_t )1;
#line 659
  start = record;
#line 661
  if (pref->signature) {
    {
#line 662
    tmp = strlen((char const   *)pref->signature);
#line 662
    destlen += tmp;
    }
  }
#line 664
  if (! record) {
#line 665
    return ((int )destlen);
  }
#line 666
  if (len < destlen) {
#line 667
    return (0);
  }
#line 668
  if (pref->signature) {
    {
#line 669
    strcpy((char */* __restrict  */)((char *)record), (char const   */* __restrict  */)pref->signature);
#line 670
    tmp___0 = strlen((char const   *)pref->signature);
#line 670
    record += tmp___0;
    }
  }
#line 672
  *record = (unsigned char)0;
#line 673
  record ++;
#line 675
  return ((int )(record - start));
}
}
#line 168 "../include/pi-contact.h"
void free_Contact(struct Contact *c ) ;
#line 170
int unpack_Contact(struct Contact *c , pi_buffer_t *buf___3 , contactsType type ) ;
#line 172
int pack_Contact(struct Contact *c , pi_buffer_t *buf___3 , contactsType type ) ;
#line 174
int unpack_ContactAppInfo(struct ContactAppInfo *ai , pi_buffer_t *buf___3 ) ;
#line 176
int pack_ContactAppInfo(struct ContactAppInfo *ai , pi_buffer_t *buf___3 ) ;
#line 179
void free_ContactAppInfo(struct ContactAppInfo *ai ) ;
#line 182
int Contact_add_blob(struct Contact *c , struct ContactBlob *blob ) ;
#line 184
int Contact_add_picture(struct Contact *c , struct ContactPicture *p ) ;
#line 44 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/contact.c"
void free_Contact(struct Contact *c ) 
{ 
  int i ;

  {
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i < 39)) {
#line 48
      goto while_break;
    }
#line 49
    if (c->entry[i]) {
      {
#line 50
      free((void *)c->entry[i]);
      }
    }
#line 48
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  i = 0;
  {
#line 51
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 51
    if (! (i < 10)) {
#line 51
      goto while_break___0;
    }
#line 52
    if (c->blob[i]) {
#line 53
      if ((c->blob[i])->data) {
        {
#line 54
        free((void *)(c->blob[i])->data);
        }
      }
      {
#line 56
      free((void *)c->blob[i]);
      }
    }
#line 51
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 60
  if (c->picture) {
    {
#line 60
    free((void *)c->picture);
    }
  }
#line 61
  return;
}
}
#line 80 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/contact.c"
int unpack_Contact(struct Contact *c , pi_buffer_t *buf___3 , contactsType type ) 
{ 
  unsigned long contents1 ;
  unsigned long contents2 ;
  unsigned char *Pbuf ;
  unsigned char *record ;
  int i ;
  int field_num ;
  int len ;
  unsigned int packed_date ;
  unsigned int blob_count ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;

  {
#line 89
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
#line 90
    return (-1);
  } else
#line 89
  if ((unsigned long )buf___3->data == (unsigned long )((void *)0)) {
#line 90
    return (-1);
  } else
#line 89
  if (buf___3->used < 17UL) {
#line 90
    return (-1);
  }
#line 92
  if ((unsigned int )type != 0U) {
#line 92
    if ((unsigned int )type != 1U) {
#line 94
      return (-1);
    }
  }
#line 97
  Pbuf = buf___3->data;
#line 97
  record = Pbuf;
#line 98
  len = (int )buf___3->used;
#line 100
  i = 0;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (i < 10)) {
#line 100
      goto while_break;
    }
#line 101
    c->blob[i] = (struct ContactBlob *)((void *)0);
#line 100
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  c->picture = (struct ContactPicture *)((void *)0);
#line 105
  c->showPhone = ((int )*(Pbuf + 0) >> 4) & 15;
#line 106
  c->phoneLabel[6] = (int )*(Pbuf + 0) & 15;
#line 107
  c->phoneLabel[5] = ((int )*((Pbuf + 1) + 0) >> 4) & 15;
#line 108
  c->phoneLabel[4] = (int )*((Pbuf + 1) + 0) & 15;
#line 109
  c->phoneLabel[3] = ((int )*((Pbuf + 2) + 0) >> 4) & 15;
#line 110
  c->phoneLabel[2] = (int )*((Pbuf + 2) + 0) & 15;
#line 111
  c->phoneLabel[1] = ((int )*((Pbuf + 3) + 0) >> 4) & 15;
#line 112
  c->phoneLabel[0] = (int )*((Pbuf + 3) + 0) & 15;
#line 114
  c->addressLabel[2] = (int )*((Pbuf + 4) + 0) & 15;
#line 115
  c->addressLabel[1] = ((int )*((Pbuf + 5) + 0) >> 4) & 15;
#line 116
  c->addressLabel[0] = (int )*((Pbuf + 5) + 0) & 15;
#line 118
  c->IMLabel[1] = ((int )*((Pbuf + 7) + 0) >> 4) & 15;
#line 119
  c->IMLabel[0] = (int )*((Pbuf + 7) + 0) & 15;
#line 121
  contents1 = ((((unsigned long )*((record + 8) + 0) << 24) | ((unsigned long )*((record + 8) + 1) << 16)) | ((unsigned long )*((record + 8) + 2) << 8)) | (unsigned long )*((record + 8) + 3);
#line 122
  contents2 = ((((unsigned long )*((record + 12) + 0) << 24) | ((unsigned long )*((record + 12) + 1) << 16)) | ((unsigned long )*((record + 12) + 2) << 8)) | (unsigned long )*((record + 12) + 3);
#line 126
  Pbuf += 17;
#line 127
  len -= 17;
#line 129
  field_num = 0;
#line 131
  i = 0;
  {
#line 131
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 131
    if (! (i < 28)) {
#line 131
      goto while_break___0;
    }
#line 132
    if (contents1 & (unsigned long )(1 << i)) {
#line 133
      if (len < 1) {
#line 134
        return (0);
      }
      {
#line 135
      c->entry[field_num] = strdup((char const   *)((char *)Pbuf));
#line 136
      tmp = strlen((char const   *)((char *)Pbuf));
#line 136
      Pbuf += tmp + 1UL;
#line 137
      tmp___0 = strlen((char const   *)c->entry[field_num]);
#line 137
      len = (int )((size_t )len - (tmp___0 + 1UL));
      }
    } else {
#line 139
      c->entry[field_num] = (char *)0;
    }
#line 131
    i ++;
#line 131
    field_num ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 142
  i = 0;
  {
#line 142
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 142
    if (! (i < 11)) {
#line 142
      goto while_break___1;
    }
#line 143
    if (contents2 & (unsigned long )(1 << i)) {
#line 144
      if (len < 1) {
#line 145
        return (0);
      }
      {
#line 146
      c->entry[field_num] = strdup((char const   *)((char *)Pbuf));
#line 147
      tmp___1 = strlen((char const   *)((char *)Pbuf));
#line 147
      Pbuf += tmp___1 + 1UL;
#line 148
      tmp___2 = strlen((char const   *)c->entry[field_num]);
#line 148
      len = (int )((size_t )len - (tmp___2 + 1UL));
      }
    } else {
#line 150
      c->entry[field_num] = (char *)0;
    }
#line 142
    i ++;
#line 142
    field_num ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 157
  if (contents2 & 2048UL) {
#line 157
    goto _L;
  } else
#line 157
  if (contents2 & 4096UL) {
    _L: /* CIL Label */ 
#line 158
    c->birthdayFlag = 1;
#line 159
    if (len < 1) {
#line 160
      return (0);
    }
    {
#line 161
    packed_date = (unsigned int )((unsigned short )(((int )*(Pbuf + 0) << 8) | (int )*(Pbuf + 1)));
#line 162
    c->birthday.tm_year = (int )(((packed_date & 65024U) >> 9) + 4U);
#line 163
    c->birthday.tm_mon = (int )(((packed_date & 480U) >> 5) - 1U);
#line 164
    c->birthday.tm_mday = (int )(packed_date & 31U);
#line 165
    c->birthday.tm_hour = 0;
#line 166
    c->birthday.tm_min = 0;
#line 167
    c->birthday.tm_sec = 0;
#line 168
    c->birthday.tm_isdst = -1;
#line 169
    mktime(& c->birthday);
#line 171
    len -= 3;
#line 172
    Pbuf += 3;
#line 173
    c->advanceUnits = (int )*(Pbuf + 0);
#line 174
    len --;
#line 175
    Pbuf ++;
    }
  } else {
#line 177
    c->birthdayFlag = 0;
  }
#line 180
  if (contents2 & 8192UL) {
#line 181
    c->reminder = 1;
#line 182
    if (len < 1) {
#line 183
      return (0);
    }
#line 184
    c->advance = (int )*(Pbuf + 0);
#line 185
    len --;
#line 186
    Pbuf ++;
  } else {
#line 188
    c->reminder = 0;
#line 189
    c->advance = 0;
  }
#line 193
  blob_count = 0U;
  {
#line 194
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 194
    if (! (len >= 6)) {
#line 194
      goto while_break___2;
    }
#line 195
    if (blob_count >= 10U) {
#line 197
      return ((int )(Pbuf - record));
    }
    {
#line 199
    tmp___3 = malloc(sizeof(struct ContactBlob ));
#line 199
    c->blob[blob_count] = (struct ContactBlob *)tmp___3;
#line 200
    strncpy((char */* __restrict  */)((c->blob[blob_count])->type), (char const   */* __restrict  */)((char *)Pbuf),
            (size_t )4);
#line 201
    (c->blob[blob_count])->length = (int )((unsigned short )(((int )*((Pbuf + 4) + 0) << 8) | (int )*((Pbuf + 4) + 1)));
#line 202
    tmp___4 = malloc((size_t )(c->blob[blob_count])->length);
#line 202
    (c->blob[blob_count])->data = (unsigned char *)tmp___4;
    }
#line 203
    if ((c->blob[blob_count])->data) {
      {
#line 204
      memcpy((void */* __restrict  */)(c->blob[blob_count])->data, (void const   */* __restrict  */)(Pbuf + 6),
             (size_t )(c->blob[blob_count])->length);
      }
    }
    {
#line 206
    tmp___6 = strncmp((char const   *)((c->blob[blob_count])->type), "Bd00", (size_t )4);
    }
#line 206
    if (! tmp___6) {
#line 207
      if (! c->picture) {
        {
#line 208
        tmp___5 = malloc(sizeof(struct ContactPicture ));
#line 208
        c->picture = (struct ContactPicture *)tmp___5;
        }
      }
#line 210
      (c->picture)->dirty = (unsigned int )((unsigned short )(((int )*((c->blob[blob_count])->data + 0) << 8) | (int )*((c->blob[blob_count])->data + 1)));
#line 211
      (c->picture)->length = (unsigned int )((c->blob[blob_count])->length - 2);
#line 212
      (c->picture)->data = (c->blob[blob_count])->data + 2;
    }
#line 215
    Pbuf += 6;
#line 216
    len -= 6;
#line 217
    Pbuf += (c->blob[blob_count])->length;
#line 218
    len -= (c->blob[blob_count])->length;
#line 219
    blob_count ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 222
  return ((int )(Pbuf - record));
}
}
#line 239 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/contact.c"
int pack_Contact(struct Contact *c , pi_buffer_t *buf___3 , contactsType type ) 
{ 
  int l ;
  int destlen ;
  unsigned char *Pbuf ;
  unsigned char *record ;
  unsigned long contents1 ;
  unsigned long contents2 ;
  int i ;
  unsigned int field_i ;
  unsigned long phoneflag ;
  unsigned long typesflag ;
  unsigned short packed_date ;
  int companyOffset ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 241
  destlen = 17;
#line 250
  companyOffset = 0;
#line 252
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 253
    return (-1);
  } else
#line 252
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
#line 253
    return (-1);
  }
#line 255
  if ((unsigned int )type != 0U) {
#line 255
    if ((unsigned int )type != 1U) {
#line 257
      return (-1);
    }
  }
#line 260
  i = 0;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (i < 39)) {
#line 260
      goto while_break;
    }
#line 261
    if (c->entry[i]) {
      {
#line 262
      tmp = strlen((char const   *)c->entry[i]);
#line 262
      destlen = (int )((size_t )destlen + (tmp + 1UL));
      }
    }
#line 260
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  if (c->birthdayFlag) {
#line 266
    destlen += 3;
#line 267
    if (c->reminder) {
#line 268
      destlen += 2;
    } else {
#line 270
      destlen ++;
    }
  }
#line 275
  i = 0;
  {
#line 275
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 275
    if (! (i < 10)) {
#line 275
      goto while_break___0;
    }
#line 276
    if (c->blob[i]) {
#line 277
      destlen += (c->blob[i])->length + 6;
    }
#line 275
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 281
  pi_buffer_expect(buf___3, (size_t )destlen);
#line 283
  record = buf___3->data;
#line 285
  Pbuf = record + 17;
#line 286
  phoneflag = 0UL;
#line 287
  typesflag = 0UL;
#line 288
  contents2 = 0UL;
#line 288
  contents1 = contents2;
#line 290
  field_i = 0U;
#line 291
  i = 0;
  }
  {
#line 291
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 291
    if (! (i < 28)) {
#line 291
      goto while_break___1;
    }
#line 292
    if (c->entry[field_i]) {
      {
#line 292
      tmp___1 = strlen((char const   *)c->entry[field_i]);
      }
#line 292
      if (tmp___1) {
        {
#line 293
        contents1 |= (unsigned long )(1 << i);
#line 294
        tmp___0 = strlen((char const   *)c->entry[field_i]);
#line 294
        l = (int )(tmp___0 + 1UL);
#line 295
        memcpy((void */* __restrict  */)Pbuf, (void const   */* __restrict  */)c->entry[field_i],
               (size_t )l);
#line 296
        Pbuf += l;
        }
      }
    }
#line 291
    i ++;
#line 291
    field_i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 299
  i = 0;
  {
#line 299
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 299
    if (! (i < 11)) {
#line 299
      goto while_break___2;
    }
#line 300
    if (c->entry[field_i]) {
      {
#line 300
      tmp___3 = strlen((char const   *)c->entry[field_i]);
      }
#line 300
      if (tmp___3) {
        {
#line 301
        contents2 |= (unsigned long )(1 << i);
#line 302
        tmp___2 = strlen((char const   *)c->entry[field_i]);
#line 302
        l = (int )(tmp___2 + 1UL);
#line 303
        memcpy((void */* __restrict  */)Pbuf, (void const   */* __restrict  */)c->entry[field_i],
               (size_t )l);
#line 304
        Pbuf += l;
        }
      }
    }
#line 299
    i ++;
#line 299
    field_i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 308
  phoneflag = (unsigned long )c->phoneLabel[0] & 15UL;
#line 309
  phoneflag |= ((unsigned long )c->phoneLabel[1] & 15UL) << 4;
#line 310
  phoneflag |= ((unsigned long )c->phoneLabel[2] & 15UL) << 8;
#line 311
  phoneflag |= ((unsigned long )c->phoneLabel[3] & 15UL) << 12;
#line 312
  phoneflag |= ((unsigned long )c->phoneLabel[4] & 15UL) << 16;
#line 313
  phoneflag |= ((unsigned long )c->phoneLabel[5] & 15UL) << 20;
#line 314
  phoneflag |= ((unsigned long )c->phoneLabel[6] & 15UL) << 24;
#line 315
  phoneflag |= ((unsigned long )c->showPhone & 15UL) << 28;
#line 317
  typesflag = (unsigned long )c->IMLabel[0] & 15UL;
#line 318
  typesflag |= ((unsigned long )c->IMLabel[1] & 15UL) << 4;
#line 319
  typesflag |= ((unsigned long )c->addressLabel[0] & 15UL) << 16;
#line 320
  typesflag |= ((unsigned long )c->addressLabel[1] & 15UL) << 20;
#line 321
  typesflag |= ((unsigned long )c->addressLabel[2] & 15UL) << 24;
#line 323
  if (c->birthdayFlag) {
#line 324
    contents2 |= 6144UL;
#line 325
    packed_date = (unsigned short )(((((c->birthday.tm_year - 4) << 9) & 65024) | (((c->birthday.tm_mon + 1) << 5) & 480)) | (c->birthday.tm_mday & 31));
#line 328
    *(Pbuf + 0) = (unsigned char )(((int )packed_date >> 8) & 255);
#line 328
    *(Pbuf + 1) = (unsigned char )((int )packed_date & 255);
#line 329
    Pbuf += 2;
#line 330
    *(Pbuf + 0) = (unsigned char)0;
#line 331
    Pbuf ++;
#line 332
    if (c->reminder) {
#line 333
      contents2 |= 8192UL;
#line 334
      *(Pbuf + 0) = (unsigned char )c->advanceUnits;
#line 335
      Pbuf ++;
#line 336
      *(Pbuf + 0) = (unsigned char )c->advance;
#line 337
      Pbuf ++;
    } else {
#line 339
      *(Pbuf + 0) = (unsigned char)0;
#line 340
      Pbuf ++;
    }
  }
#line 344
  *(record + 0) = (unsigned char )((int )((unsigned char )(phoneflag >> 24)) & 255);
#line 344
  *(record + 1) = (unsigned char )((phoneflag >> 16) & 255UL);
#line 344
  *(record + 2) = (unsigned char )((phoneflag >> 8) & 255UL);
#line 344
  *(record + 3) = (unsigned char )(phoneflag & 255UL);
#line 345
  *((record + 4) + 0) = (unsigned char )((int )((unsigned char )(typesflag >> 24)) & 255);
#line 345
  *((record + 4) + 1) = (unsigned char )((typesflag >> 16) & 255UL);
#line 345
  *((record + 4) + 2) = (unsigned char )((typesflag >> 8) & 255UL);
#line 345
  *((record + 4) + 3) = (unsigned char )(typesflag & 255UL);
#line 346
  *((record + 8) + 0) = (unsigned char )((int )((unsigned char )(contents1 >> 24)) & 255);
#line 346
  *((record + 8) + 1) = (unsigned char )((contents1 >> 16) & 255UL);
#line 346
  *((record + 8) + 2) = (unsigned char )((contents1 >> 8) & 255UL);
#line 346
  *((record + 8) + 3) = (unsigned char )(contents1 & 255UL);
#line 347
  *((record + 12) + 0) = (unsigned char )((int )((unsigned char )(contents2 >> 24)) & 255);
#line 347
  *((record + 12) + 1) = (unsigned char )((contents2 >> 16) & 255UL);
#line 347
  *((record + 12) + 2) = (unsigned char )((contents2 >> 8) & 255UL);
#line 347
  *((record + 12) + 3) = (unsigned char )(contents2 & 255UL);
#line 350
  if (c->entry[2]) {
#line 351
    companyOffset ++;
#line 352
    if (c->entry[0]) {
      {
#line 352
      tmp___4 = strlen((char const   *)c->entry[0]);
#line 352
      companyOffset = (int )((size_t )companyOffset + (tmp___4 + 1UL));
      }
    }
#line 353
    if (c->entry[1]) {
      {
#line 353
      tmp___5 = strlen((char const   *)c->entry[1]);
#line 353
      companyOffset = (int )((size_t )companyOffset + (tmp___5 + 1UL));
      }
    }
  }
#line 355
  *((record + 16) + 0) = (unsigned char )companyOffset;
#line 358
  i = 0;
  {
#line 358
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 358
    if (! (i < 10)) {
#line 358
      goto while_break___3;
    }
#line 359
    if (c->blob[i]) {
      {
#line 360
      memcpy((void */* __restrict  */)Pbuf, (void const   */* __restrict  */)((c->blob[i])->type),
             (size_t )4);
#line 361
      Pbuf += 4;
#line 362
      *(Pbuf + 0) = (unsigned char )(((int )((unsigned short )(c->blob[i])->length) >> 8) & 255);
#line 362
      *(Pbuf + 1) = (unsigned char )((int )((unsigned short )(c->blob[i])->length) & 255);
#line 363
      Pbuf += 2;
#line 364
      memcpy((void */* __restrict  */)Pbuf, (void const   */* __restrict  */)(c->blob[i])->data,
             (size_t )(c->blob[i])->length);
#line 365
      Pbuf += (c->blob[i])->length;
      }
    }
#line 358
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 368
  buf___3->used = (size_t )(Pbuf - record);
#line 370
  return ((int )buf___3->used);
}
}
#line 386 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/contact.c"
int Contact_add_blob(struct Contact *c , struct ContactBlob *blob ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 390
  i = 0;
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! (i < 10)) {
#line 390
      goto while_break;
    }
#line 391
    if (c->blob[i]) {
#line 392
      goto __Cont;
    }
    {
#line 395
    tmp = malloc(sizeof(struct ContactBlob ));
#line 395
    c->blob[i] = (struct ContactBlob *)tmp;
    }
#line 396
    if (! c->blob[i]) {
#line 396
      return (1);
    }
    {
#line 398
    tmp___0 = malloc((size_t )blob->length);
#line 398
    (c->blob[i])->data = (unsigned char *)tmp___0;
#line 399
    strncpy((char */* __restrict  */)((c->blob[i])->type), (char const   */* __restrict  */)(blob->type),
            (size_t )4);
#line 400
    (c->blob[i])->length = blob->length;
#line 401
    strncpy((char */* __restrict  */)((char *)(c->blob[i])->data), (char const   */* __restrict  */)((char *)blob->data),
            (size_t )blob->length);
    }
#line 402
    return (0);
    __Cont: /* CIL Label */ 
#line 390
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 405
  return (1);
}
}
#line 423 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/contact.c"
int Contact_add_picture(struct Contact *c , struct ContactPicture *p ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 427
  if (! p) {
#line 428
    return (1);
  } else
#line 427
  if (p->length < 1U) {
#line 428
    return (1);
  } else
#line 427
  if (! p->data) {
#line 428
    return (1);
  }
#line 430
  i = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! (i < 10)) {
#line 430
      goto while_break;
    }
#line 431
    if (c->blob[i]) {
#line 432
      goto __Cont;
    }
    {
#line 435
    tmp = malloc(sizeof(struct ContactBlob ));
#line 435
    c->blob[i] = (struct ContactBlob *)tmp;
    }
#line 436
    if (! c->blob[i]) {
#line 436
      return (1);
    }
    {
#line 438
    tmp___0 = malloc((size_t )(p->length + 2U));
#line 438
    (c->blob[i])->data = (unsigned char *)tmp___0;
#line 439
    strncpy((char */* __restrict  */)((c->blob[i])->type), (char const   */* __restrict  */)"Bd00",
            (size_t )4);
#line 440
    (c->blob[i])->length = (int )(p->length + 2U);
#line 441
    *((c->blob[i])->data + 0) = (unsigned char )(((int )((unsigned short )p->dirty) >> 8) & 255);
#line 441
    *((c->blob[i])->data + 1) = (unsigned char )((int )((unsigned short )p->dirty) & 255);
#line 442
    memcpy((void */* __restrict  */)((c->blob[i])->data + 2), (void const   */* __restrict  */)p->data,
           (size_t )p->length);
    }
#line 443
    return (0);
    __Cont: /* CIL Label */ 
#line 430
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 446
  return (1);
}
}
#line 463 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/contact.c"
int unpack_ContactAppInfo(struct ContactAppInfo *ai , pi_buffer_t *buf___3 ) 
{ 
  int i ;
  int j ;
  int destlen ;
  unsigned char *start ;
  unsigned char *Pbuf ;
  int len ;

  {
#line 469
  Pbuf = buf___3->data;
#line 469
  start = Pbuf;
#line 470
  len = (int )buf___3->used;
#line 471
  if (len == 1092) {
#line 472
    ai->type = (contactsType )0;
#line 473
    ai->num_labels = 49;
#line 474
    ai->numCustoms = 9;
  } else
#line 475
  if (len == 1156) {
#line 476
    ai->type = (contactsType )1;
#line 477
    ai->num_labels = 53;
#line 478
    ai->numCustoms = 9;
  } else {
    {
#line 480
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"contact.c: unpack_ContactAppInfo: ContactAppInfo size of %d incorrect\n",
            len);
    }
#line 481
    return (-1);
  }
#line 485
  destlen = ((304 + 16 * ai->num_labels) + 2) + 2;
#line 486
  if (buf___3->used < (size_t )destlen) {
#line 487
    return (-1);
  }
  {
#line 489
  i = unpack_CategoryAppInfo(& ai->category, (unsigned char const   *)start, (size_t )len);
  }
#line 490
  if (! i) {
#line 491
    return (i);
  }
  {
#line 492
  Pbuf += i;
#line 494
  memcpy((void */* __restrict  */)(ai->internal), (void const   */* __restrict  */)Pbuf,
         (size_t )26);
#line 495
  Pbuf += 26;
#line 496
  memcpy((void */* __restrict  */)(ai->labels), (void const   */* __restrict  */)Pbuf,
         (size_t )(16 * ai->num_labels));
#line 497
  Pbuf += 16 * ai->num_labels;
#line 498
  ai->country = (int )*(Pbuf + 0);
#line 499
  Pbuf += 2;
#line 500
  ai->sortByCompany = (int )*(Pbuf + 0);
#line 501
  Pbuf += 2;
#line 504
  i = 4;
#line 504
  j = 0;
  }
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 504
    if (! (i < 11)) {
#line 504
      goto while_break;
    }
    {
#line 505
    strcpy((char */* __restrict  */)(ai->phoneLabels[j]), (char const   */* __restrict  */)(ai->labels[i]));
#line 504
    i ++;
#line 504
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 507
  strcpy((char */* __restrict  */)(ai->phoneLabels[j]), (char const   */* __restrict  */)(ai->labels[40]));
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 509
    if (! (i < ai->numCustoms)) {
#line 509
      goto while_break___0;
    }
    {
#line 510
    strcpy((char */* __restrict  */)(ai->customLabels[i]), (char const   */* __restrict  */)(ai->labels[14 + i]));
#line 509
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 513
  strcpy((char */* __restrict  */)(ai->addrLabels[0]), (char const   */* __restrict  */)(ai->labels[23]));
#line 514
  strcpy((char */* __restrict  */)(ai->addrLabels[1]), (char const   */* __restrict  */)(ai->labels[28]));
#line 515
  strcpy((char */* __restrict  */)(ai->addrLabels[2]), (char const   */* __restrict  */)(ai->labels[33]));
#line 517
  strcpy((char */* __restrict  */)(ai->IMLabels[0]), (char const   */* __restrict  */)(ai->labels[41]));
#line 518
  strcpy((char */* __restrict  */)(ai->IMLabels[1]), (char const   */* __restrict  */)(ai->labels[42]));
#line 519
  strcpy((char */* __restrict  */)(ai->IMLabels[2]), (char const   */* __restrict  */)(ai->labels[43]));
#line 520
  strcpy((char */* __restrict  */)(ai->IMLabels[3]), (char const   */* __restrict  */)(ai->labels[44]));
#line 521
  strcpy((char */* __restrict  */)(ai->IMLabels[4]), (char const   */* __restrict  */)(ai->labels[45]));
  }
#line 523
  return ((int )(Pbuf - start));
}
}
#line 539 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/contact.c"
void free_ContactAppInfo(struct ContactAppInfo *ai ) 
{ 


  {
#line 541
  return;
}
}
#line 556 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/contact.c"
int pack_ContactAppInfo(struct ContactAppInfo *ai , pi_buffer_t *buf___3 ) 
{ 
  int destlen ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
#line 560
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
#line 561
    return (-1);
  } else
#line 560
  if ((unsigned long )buf___3->data == (unsigned long )((void *)0)) {
#line 561
    return (-1);
  }
  {
#line 564
  destlen = ((304 + 16 * ai->num_labels) + 2) + 2;
#line 566
  pi_buffer_expect(buf___3, (size_t )destlen);
#line 568
  tmp = pack_CategoryAppInfo((CategoryAppInfo_t const   *)(& ai->category), buf___3->data,
                             buf___3->allocated);
#line 568
  buf___3->used = (size_t )tmp;
  }
#line 569
  if (buf___3->used != 278UL) {
#line 570
    return (-1);
  }
  {
#line 572
  pi_buffer_append(buf___3, (void const   *)(ai->internal), (size_t )26);
#line 574
  pi_buffer_append(buf___3, (void const   *)(ai->labels), (size_t )(16 * ai->num_labels));
#line 576
  tmp___0 = buf___3->used;
#line 576
  (buf___3->used) ++;
#line 576
  *((buf___3->data + tmp___0) + 0) = (unsigned char )ai->country;
#line 578
  tmp___1 = buf___3->used;
#line 578
  (buf___3->used) ++;
#line 578
  *((buf___3->data + tmp___1) + 0) = (unsigned char)0;
#line 580
  tmp___2 = buf___3->used;
#line 580
  (buf___3->used) ++;
#line 580
  *((buf___3->data + tmp___2) + 0) = (unsigned char )ai->sortByCompany;
#line 582
  tmp___3 = buf___3->used;
#line 582
  (buf___3->used) ++;
#line 582
  *((buf___3->data + tmp___3) + 0) = (unsigned char)0;
  }
#line 584
  return ((int )buf___3->used);
}
}
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 703 "../include/pi-dlp.h"
int dlp_ReadSysInfo(int sd , struct SysInfo *s ) ;
#line 771
int dlp_OpenConduit(int sd ) ;
#line 31 "../include/pi-header.h"
int pilot_connect(char const   *port )  __attribute__((__deprecated__)) ;
#line 60 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/connect.c"
int pilot_connect(char const   *port )  __attribute__((__deprecated__)) ;
#line 60 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/connect.c"
int pilot_connect(char const   *port ) 
{ 
  int sd ;
  int result ;
  struct SysInfo sys_info ;
  int tmp ;
  int tmp___0 ;
  PI_ERR tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  PI_ERR tmp___4 ;

  {
  {
#line 63
  sd = -1;
#line 68
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 69
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   DEPRECATED: The application is calling pilot_connect()\n");
#line 70
  sd = pi_socket(0, 16, 6);
  }
#line 70
  if (sd < 0) {
    {
#line 72
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n   Unable to create socket \'%s\'\n",
            port);
    }
#line 73
    return (-1);
  }
  {
#line 76
  result = pi_bind(sd, port);
  }
#line 78
  if (result < 0) {
#line 79
    if ((unsigned long )port == (unsigned long )((void *)0)) {
      {
#line 80
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   No port specified\n");
      }
    } else {
      {
#line 82
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   Unable to bind to port: %s\n",
              port);
      }
    }
    {
#line 84
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   Please use --help for more information\n\n");
    }
#line 85
    return (result);
  }
  {
#line 88
  tmp = fileno(stdout);
#line 88
  tmp___0 = isatty(tmp);
  }
#line 88
  if (tmp___0) {
    {
#line 89
    printf((char const   */* __restrict  */)"\n   Listening for incoming connection on %s... ",
           port);
#line 91
    fflush(stdout);
    }
  }
  {
#line 94
  tmp___1 = pi_listen(sd, 1);
  }
#line 94
  if (tmp___1 < 0) {
    {
#line 95
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n   Error listening on %s\n",
            port);
#line 96
    pi_close(sd);
    }
#line 97
    return (-1);
  }
  {
#line 100
  sd = pi_accept(sd, (struct sockaddr *)0, (size_t *)0);
  }
#line 101
  if (sd < 0) {
    {
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n   Error accepting data on %s\n",
            port);
#line 103
    pi_close(sd);
    }
#line 104
    return (-1);
  }
  {
#line 107
  tmp___2 = fileno(stdout);
#line 107
  tmp___3 = isatty(tmp___2);
  }
#line 107
  if (tmp___3) {
    {
#line 108
    printf((char const   */* __restrict  */)"connected!\n\n");
    }
  }
  {
#line 111
  tmp___4 = dlp_ReadSysInfo(sd, & sys_info);
  }
#line 111
  if (tmp___4 < 0) {
    {
#line 112
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n   Error read system info on %s\n",
            port);
#line 113
    pi_close(sd);
    }
#line 114
    return (-1);
  }
  {
#line 117
  dlp_OpenConduit(sd);
  }
#line 118
  return (sd);
}
}
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 48 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static void pi_inet_device_free(pi_device_t *dev ) ;
#line 49
static pi_protocol_t *pi_inet_protocol(pi_device_t *dev ) ;
#line 50
static pi_protocol_t *pi_inet_protocol_dup(pi_protocol_t *prot ) ;
#line 51
static void pi_inet_protocol_free(pi_protocol_t *prot ) ;
#line 52
static int pi_inet_close(pi_socket_t *ps ) ;
#line 53
static int pi_inet_connect(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
#line 54
static int pi_inet_bind(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
#line 55
static int pi_inet_listen(pi_socket_t *ps , int backlog ) ;
#line 56
static int pi_inet_accept(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) ;
#line 57
static ssize_t pi_inet_read(pi_socket_t *ps , pi_buffer_t *msg , size_t len , int flags ) ;
#line 58
static ssize_t pi_inet_write(pi_socket_t *ps , unsigned char const   *msg , size_t len ,
                             int flags ) ;
#line 59
static int pi_inet_getsockopt(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) ;
#line 60
static int pi_inet_setsockopt(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) ;
#line 61
static int pi_inet_flush(pi_socket_t *ps , int flags ) ;
#line 65 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
pi_device_t *pi_inet_device(int type ) 
{ 
  pi_device_t *dev ;
  pi_inet_data_t *data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 68
  dev = (pi_device_t *)((void *)0);
#line 69
  data = (pi_inet_data_t *)((void *)0);
#line 71
  tmp = malloc(sizeof(pi_device_t ));
#line 71
  dev = (pi_device_t *)tmp;
  }
#line 72
  if ((unsigned long )dev != (unsigned long )((void *)0)) {
    {
#line 73
    tmp___0 = malloc(sizeof(pi_inet_data_t ));
#line 73
    data = (pi_inet_data_t *)tmp___0;
    }
#line 74
    if ((unsigned long )data == (unsigned long )((void *)0)) {
      {
#line 75
      free((void *)dev);
#line 76
      dev = (pi_device_t *)((void *)0);
      }
    }
  }
#line 80
  if ((unsigned long )dev != (unsigned long )((void *)0)) {
#line 80
    if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 81
      dev->free = & pi_inet_device_free;
#line 82
      dev->protocol = & pi_inet_protocol;
#line 83
      dev->bind = & pi_inet_bind;
#line 84
      dev->listen = & pi_inet_listen;
#line 85
      dev->accept = & pi_inet_accept;
#line 86
      dev->connect = & pi_inet_connect;
#line 87
      dev->close = & pi_inet_close;
#line 89
      data->timeout = 0;
#line 90
      data->rx_bytes = 0;
#line 91
      data->rx_errors = 0;
#line 92
      data->tx_bytes = 0;
#line 93
      data->tx_errors = 0;
#line 94
      dev->data = (void *)data;
    }
  }
#line 97
  return (dev);
}
}
#line 100 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static void pi_inet_device_free(pi_device_t *dev ) 
{ 


  {
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! ((unsigned long )dev != (unsigned long )((void *)0))) {
      {
#line 103
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c",
             103, "dev != NULL");
      }
    }
#line 103
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if ((unsigned long )dev != (unsigned long )((void *)0)) {
#line 105
    if ((unsigned long )dev->data != (unsigned long )((void *)0)) {
      {
#line 106
      free(dev->data);
      }
    }
    {
#line 107
    free((void *)dev);
    }
  }
#line 109
  return;
}
}
#line 111 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static pi_protocol_t *pi_inet_protocol(pi_device_t *dev ) 
{ 
  pi_protocol_t *prot ;
  pi_inet_data_t *data ;
  void *tmp ;

  {
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! ((unsigned long )dev != (unsigned long )((void *)0))) {
      {
#line 117
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c",
             117, "dev != NULL");
      }
    }
#line 117
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  data = (pi_inet_data_t *)dev->data;
#line 121
  tmp = malloc(sizeof(pi_protocol_t ));
#line 121
  prot = (pi_protocol_t *)tmp;
  }
#line 123
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 124
    prot->level = 0;
#line 125
    prot->dup = & pi_inet_protocol_dup;
#line 126
    prot->free = & pi_inet_protocol_free;
#line 127
    prot->read = & pi_inet_read;
#line 128
    prot->write = & pi_inet_write;
#line 129
    prot->flush = & pi_inet_flush;
#line 130
    prot->getsockopt = & pi_inet_getsockopt;
#line 131
    prot->setsockopt = & pi_inet_setsockopt;
#line 132
    prot->data = (void *)0;
  }
#line 135
  return (prot);
}
}
#line 138 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static pi_protocol_t *pi_inet_protocol_dup(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  void *tmp ;

  {
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 143
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c",
             143, "prot != NULL");
      }
    }
#line 143
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 145
  tmp = malloc(sizeof(pi_protocol_t ));
#line 145
  new_prot = (pi_protocol_t *)tmp;
  }
#line 147
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 148
    new_prot->level = prot->level;
#line 149
    new_prot->dup = prot->dup;
#line 150
    new_prot->free = prot->free;
#line 151
    new_prot->read = prot->read;
#line 152
    new_prot->write = prot->write;
#line 153
    new_prot->flush = prot->flush;
#line 154
    new_prot->getsockopt = prot->getsockopt;
#line 155
    new_prot->setsockopt = prot->setsockopt;
#line 156
    new_prot->data = (void *)0;
  }
#line 159
  return (new_prot);
}
}
#line 162 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static void pi_inet_protocol_free(pi_protocol_t *prot ) 
{ 


  {
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 165
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c",
             165, "prot != NULL");
      }
    }
#line 165
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
    {
#line 167
    free((void *)prot);
    }
  }
#line 168
  return;
}
}
#line 170 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_bind(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) 
{ 
  int opt ;
  int sd ;
  int err ;
  size_t optlen ;
  struct pi_sockaddr *paddr ;
  struct sockaddr_in serv_addr ;
  char *device ;
  char *port ;
  struct hostent *hostent ;
  struct hostent *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;

  {
  {
#line 177
  paddr = (struct pi_sockaddr *)addr;
#line 179
  device = paddr->pi_device;
#line 179
  port = (char *)((void *)0);
#line 183
  memset((void *)(& serv_addr), 0, sizeof(serv_addr));
#line 184
  serv_addr.sin_family = (sa_family_t )2;
#line 185
  tmp___1 = strlen((char const   *)device);
  }
#line 185
  if (tmp___1 > 1UL) {
    {
#line 185
    tmp___2 = strncmp((char const   *)device, "any", (size_t )3);
    }
#line 185
    if (tmp___2) {
      {
#line 186
      serv_addr.sin_addr.s_addr = inet_addr((char const   *)device);
      }
#line 187
      if (serv_addr.sin_addr.s_addr == 4294967295U) {
        {
#line 188
        tmp = gethostbyname((char const   *)device);
#line 188
        hostent = tmp;
        }
#line 190
        if (! hostent) {
          {
#line 191
          tmp___0 = pi_set_error(ps->sd, -502);
          }
#line 191
          return (tmp___0);
        }
        {
#line 193
        memcpy((void */* __restrict  */)((char *)(& serv_addr.sin_addr.s_addr)), (void const   */* __restrict  */)*(hostent->h_addr_list + 0),
               (size_t )hostent->h_length);
        }
      }
    } else {
      {
#line 197
      serv_addr.sin_addr.s_addr = htonl((in_addr_t )0);
      }
    }
  } else {
    {
#line 197
    serv_addr.sin_addr.s_addr = htonl((in_addr_t )0);
    }
  }
  {
#line 199
  port = strchr((char const   *)device, ':');
  }
#line 199
  if ((unsigned long )port != (unsigned long )((void *)0)) {
    {
#line 200
    port ++;
#line 200
    tmp___3 = atoi((char const   *)port);
#line 200
    serv_addr.sin_port = htons((uint16_t )tmp___3);
    }
  } else {
    {
#line 202
    serv_addr.sin_port = htons((uint16_t )14238);
    }
  }
  {
#line 205
  sd = socket(2, 1, 0);
  }
#line 206
  if (sd < 0) {
    {
#line 207
    pi_log(2, 1, "DEV BIND Inet: Unable to create socket\n");
#line 209
    tmp___4 = pi_set_error(ps->sd, -502);
    }
#line 209
    return (tmp___4);
  }
  {
#line 211
  err = pi_socket_setsd(ps, sd);
  }
#line 211
  if (err < 0) {
#line 212
    return (err);
  }
  {
#line 214
  opt = 1;
#line 215
  optlen = sizeof(opt);
#line 217
  tmp___6 = setsockopt(ps->sd, 1, 2, (void const   *)((void *)(& opt)), (socklen_t )((int )optlen));
  }
#line 217
  if (tmp___6 < 0) {
    {
#line 219
    tmp___5 = pi_set_error(ps->sd, -502);
    }
#line 219
    return (tmp___5);
  }
  {
#line 222
  tmp___8 = bind(ps->sd, (struct sockaddr  const  *)((struct sockaddr *)(& serv_addr)),
                 (socklen_t )sizeof(serv_addr));
  }
#line 222
  if (tmp___8 < 0) {
    {
#line 223
    tmp___7 = pi_set_error(ps->sd, -502);
    }
#line 223
    return (tmp___7);
  }
  {
#line 225
  pi_log(2, 4, "DEV BIND Inet Bound to %s\n", device);
#line 228
  tmp___9 = malloc(addrlen);
#line 228
  ps->raddr = (struct sockaddr *)tmp___9;
#line 229
  memcpy((void */* __restrict  */)ps->raddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 230
  ps->raddrlen = addrlen;
#line 231
  tmp___10 = malloc(addrlen);
#line 231
  ps->laddr = (struct sockaddr *)tmp___10;
#line 232
  memcpy((void */* __restrict  */)ps->laddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 233
  ps->laddrlen = addrlen;
  }
#line 235
  return (0);
}
}
#line 238 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_connect(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) 
{ 
  int sd ;
  int err ;
  struct pi_sockaddr *paddr ;
  struct sockaddr_in serv_addr ;
  char *device ;
  struct hostent *hostent ;
  struct hostent *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 244
  paddr = (struct pi_sockaddr *)addr;
#line 246
  device = paddr->pi_device;
#line 249
  memset((void *)(& serv_addr), 0, sizeof(serv_addr));
#line 250
  serv_addr.sin_family = (sa_family_t )2;
#line 251
  tmp___1 = strlen((char const   *)device);
  }
#line 251
  if (tmp___1 > 1UL) {
    {
#line 252
    serv_addr.sin_addr.s_addr = inet_addr((char const   *)device);
    }
#line 253
    if (serv_addr.sin_addr.s_addr == 4294967295U) {
      {
#line 254
      tmp = gethostbyname((char const   *)device);
#line 254
      hostent = tmp;
      }
#line 256
      if (! hostent) {
        {
#line 257
        pi_log(2, 1, "DEV CONNECT Inet: Unable to determine host\n");
#line 260
        tmp___0 = pi_set_error(ps->sd, -502);
        }
#line 260
        return (tmp___0);
      }
      {
#line 263
      memcpy((void */* __restrict  */)((char *)(& serv_addr.sin_addr.s_addr)), (void const   */* __restrict  */)*(hostent->h_addr_list + 0),
             (size_t )hostent->h_length);
      }
    }
  } else {
    {
#line 267
    serv_addr.sin_addr.s_addr = htonl((in_addr_t )0);
    }
  }
  {
#line 269
  serv_addr.sin_port = htons((uint16_t )14238);
#line 271
  sd = socket(2, 1, 0);
  }
#line 273
  if (sd < 0) {
    {
#line 274
    pi_log(2, 1, "DEV CONNECT Inet: Unable to create socket\n");
#line 276
    tmp___2 = pi_set_error(ps->sd, -502);
    }
#line 276
    return (tmp___2);
  }
  {
#line 279
  err = pi_socket_setsd(ps, sd);
  }
#line 279
  if (err < 0) {
#line 280
    return (err);
  }
  {
#line 282
  tmp___4 = connect(ps->sd, (struct sockaddr  const  *)((struct sockaddr *)(& serv_addr)),
                    (socklen_t )sizeof(serv_addr));
  }
#line 282
  if (tmp___4 < 0) {
    {
#line 284
    pi_log(2, 1, "DEV CONNECT Inet: Unable to connect\n");
#line 286
    tmp___3 = pi_set_error(ps->sd, -502);
    }
#line 286
    return (tmp___3);
  }
  {
#line 289
  tmp___5 = malloc(addrlen);
#line 289
  ps->raddr = (struct sockaddr *)tmp___5;
#line 290
  memcpy((void */* __restrict  */)ps->raddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 291
  ps->raddrlen = addrlen;
#line 292
  tmp___6 = malloc(addrlen);
#line 292
  ps->laddr = (struct sockaddr *)tmp___6;
#line 293
  memcpy((void */* __restrict  */)ps->laddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 294
  ps->laddrlen = addrlen;
  }
  {
#line 297
  if (ps->cmd == 1) {
#line 297
    goto case_1;
  }
#line 301
  if (ps->cmd == 2) {
#line 301
    goto case_2;
  }
#line 296
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 298
  err = cmp_tx_handshake(ps);
  }
#line 298
  if (err < 0) {
#line 299
    goto fail;
  }
#line 300
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 302
  err = net_tx_handshake(ps);
  }
#line 302
  if (err < 0) {
#line 303
    goto fail;
  }
#line 304
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 306
  ps->state = 4;
#line 307
  ps->command = 0;
#line 309
  pi_log(2, 4, "DEV CONNECT Inet: Connected\n");
  }
#line 310
  return (0);
  fail: 
#line 313
  return (err);
}
}
#line 316 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_listen(pi_socket_t *ps , int backlog ) 
{ 
  int result ;

  {
  {
#line 321
  result = listen(ps->sd, backlog);
  }
#line 322
  if (result == 0) {
#line 323
    ps->state = 1;
  }
#line 325
  return (result);
}
}
#line 328 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_accept(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) 
{ 
  int sd ;
  int err ;
  int split ;
  int chunksize ;
  size_t len ;
  size_t size ;
  socklen_t l ;
  unsigned char cmp_flags ;
  int use_long_format ;

  {
#line 331
  split = 0;
#line 331
  chunksize = 0;
#line 337
  l = (socklen_t )0;
#line 340
  if (addrlen) {
#line 341
    l = (socklen_t )*addrlen;
  }
  {
#line 342
  sd = accept(ps->sd, (struct sockaddr */* __restrict  */)addr, (socklen_t */* __restrict  */)(& l));
  }
#line 343
  if (addrlen) {
#line 344
    *addrlen = (size_t )l;
  }
#line 345
  if (sd < 0) {
    {
#line 346
    pi_set_error(ps->sd, sd);
#line 347
    err = -502;
    }
#line 348
    goto fail;
  }
  {
#line 351
  pi_socket_setsd(ps, sd);
#line 352
  pi_socket_init(ps);
  }
  {
#line 355
  if (ps->cmd == 1) {
#line 355
    goto case_1;
  }
#line 374
  if (ps->cmd == 2) {
#line 374
    goto case_2;
  }
#line 354
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 356
  err = cmp_rx_handshake(ps, 57600, 0);
  }
#line 356
  if (err < 0) {
#line 357
    goto fail;
  }
  {
#line 360
  size = sizeof(cmp_flags);
#line 361
  pi_getsockopt(ps->sd, 5, 1, (void *)(& cmp_flags), & size);
  }
#line 362
  if ((int )cmp_flags & 16) {
    {
#line 363
    use_long_format = 1;
#line 364
    size = sizeof(int );
#line 365
    pi_setsockopt(ps->sd, 2, 3, (void const   *)(& use_long_format), & size);
#line 367
    ps->command ^= 1;
#line 368
    pi_setsockopt(ps->sd, 2, 3, (void const   *)(& use_long_format), & size);
#line 370
    ps->command ^= 1;
    }
  }
#line 373
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 378
  len = sizeof(split);
#line 379
  pi_setsockopt(ps->sd, 3, 1, (void const   *)(& split), & len);
#line 381
  len = sizeof(chunksize);
#line 382
  pi_setsockopt(ps->sd, 3, 2, (void const   *)(& chunksize), & len);
#line 385
  ps->command ^= 1;
#line 386
  len = sizeof(split);
#line 387
  pi_setsockopt(ps->sd, 3, 1, (void const   *)(& split), & len);
#line 389
  len = sizeof(chunksize);
#line 390
  pi_setsockopt(ps->sd, 3, 2, (void const   *)(& chunksize), & len);
#line 392
  ps->command ^= 1;
#line 394
  err = net_rx_handshake(ps);
  }
#line 394
  if (err < 0) {
#line 395
    goto fail;
  }
#line 396
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 399
  ps->state = 2;
#line 400
  ps->command = 0;
#line 401
  ps->dlprecord = 0;
#line 403
  pi_log(2, 4, "DEV INET ACCEPT accepted\n");
  }
#line 405
  return (ps->sd);
  fail: 
#line 408
  return (err);
}
}
#line 411 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_close(pi_socket_t *ps ) 
{ 


  {
#line 414
  if (ps->sd) {
    {
#line 415
    close(ps->sd);
#line 416
    ps->sd = 0;
    }
  }
#line 418
  if (ps->laddr) {
    {
#line 419
    free((void *)ps->laddr);
#line 420
    ps->laddr = (struct sockaddr *)((void *)0);
    }
  }
#line 422
  if (ps->raddr) {
    {
#line 423
    free((void *)ps->raddr);
#line 424
    ps->raddr = (struct sockaddr *)((void *)0);
    }
  }
#line 426
  return (0);
}
}
#line 429 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_flush(pi_socket_t *ps , int flags ) 
{ 
  char buf___3[256] ;
  int fl ;
  ssize_t tmp ;

  {
#line 435
  if (flags & 1) {
    {
#line 436
    fl = fcntl(ps->sd, 3, 0);
    }
#line 436
    if (fl != -1) {
      {
#line 437
      fcntl(ps->sd, 4, fl | 2048);
      }
      {
#line 438
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 438
        tmp = recv(ps->sd, (void *)(buf___3), sizeof(buf___3), 0);
        }
#line 438
        if (! (tmp > 0L)) {
#line 438
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 440
      fcntl(ps->sd, 4, fl);
      }
    }
  }
#line 443
  return (0);
}
}
#line 446 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static ssize_t pi_inet_write(pi_socket_t *ps , unsigned char const   *msg , size_t len ,
                             int flags ) 
{ 
  int total ;
  int nwrote ;
  pi_inet_data_t *data ;
  struct timeval t ;
  fd_set ready ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;

  {
#line 451
  data = (pi_inet_data_t *)(ps->device)->data;
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 455
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 455
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 458
  total = (int )len;
  {
#line 459
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 459
    if (! (total > 0)) {
#line 459
      goto while_break___0;
    }
#line 460
    if (data->timeout == 0) {
      {
#line 461
      tmp = select(ps->sd + 1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)(& ready),
                   (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
      }
#line 461
      if (tmp < 0) {
        {
#line 461
        tmp___0 = __errno_location();
        }
#line 461
        if (*tmp___0 == 4) {
#line 463
          goto while_continue___0;
        }
      }
    } else {
      {
#line 465
      t.tv_sec = (__time_t )(data->timeout / 1000);
#line 466
      t.tv_usec = (__suseconds_t )((data->timeout % 1000) * 1000);
#line 467
      tmp___2 = select(ps->sd + 1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)(& ready),
                       (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
      }
#line 467
      if (tmp___2 == 0) {
        {
#line 468
        tmp___1 = pi_set_error(ps->sd, -202);
        }
#line 468
        return ((ssize_t )tmp___1);
      }
    }
#line 470
    if (! ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
      {
#line 471
      ps->state = 8;
#line 472
      tmp___3 = pi_set_error(ps->sd, -200);
      }
#line 472
      return ((ssize_t )tmp___3);
    }
    {
#line 475
    tmp___4 = write(ps->sd, (void const   *)msg, len);
#line 475
    nwrote = (int )tmp___4;
    }
#line 476
    if (nwrote < 0) {
      {
#line 478
      tmp___6 = __errno_location();
      }
#line 478
      if (*tmp___6 == 32) {
        {
#line 479
        ps->state = 8;
#line 480
        tmp___5 = pi_set_error(ps->sd, -200);
        }
#line 480
        return ((ssize_t )tmp___5);
      } else {
        {
#line 478
        tmp___7 = __errno_location();
        }
#line 478
        if (*tmp___7 == 9) {
          {
#line 479
          ps->state = 8;
#line 480
          tmp___5 = pi_set_error(ps->sd, -200);
          }
#line 480
          return ((ssize_t )tmp___5);
        }
      }
      {
#line 482
      tmp___8 = pi_set_error(ps->sd, -204);
      }
#line 482
      return ((ssize_t )tmp___8);
    }
#line 485
    total -= nwrote;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 487
  data->tx_bytes = (int )((size_t )data->tx_bytes + len);
#line 489
  pi_log(2, 4, "DEV TX Inet Bytes: %d\n", len);
  }
#line 491
  return ((ssize_t )len);
}
}
#line 494 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static ssize_t pi_inet_read(pi_socket_t *ps , pi_buffer_t *msg , size_t len , int flags ) 
{ 
  int r ;
  int fl ;
  pi_inet_data_t *data ;
  fd_set ready ;
  struct timeval t ;
  int *tmp ;
  int tmp___0 ;
  pi_buffer_t *tmp___1 ;
  int __d0 ;
  int __d1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 497
  fl = 0;
#line 499
  data = (pi_inet_data_t *)(ps->device)->data;
#line 503
  tmp___1 = pi_buffer_expect(msg, len);
  }
#line 503
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 504
    tmp = __errno_location();
#line 504
    *tmp = 12;
#line 505
    tmp___0 = pi_set_error(ps->sd, -500);
    }
#line 505
    return ((ssize_t )tmp___0);
  }
#line 508
  if (flags == 1) {
#line 509
    fl = 2;
  }
  {
#line 511
  while (1) {
    while_continue: /* CIL Label */ ;
#line 511
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 511
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 512
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 516
  if (data->timeout == 0) {
    {
#line 517
    select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
           (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
    }
  } else {
    {
#line 519
    t.tv_sec = (__time_t )(data->timeout / 1000);
#line 520
    t.tv_usec = (__suseconds_t )((data->timeout % 1000) * 1000);
#line 521
    tmp___3 = select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
                     (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
    }
#line 521
    if (tmp___3 == 0) {
      {
#line 522
      tmp___2 = pi_set_error(ps->sd, -202);
      }
#line 522
      return ((ssize_t )tmp___2);
    }
  }
#line 526
  if ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
    {
#line 527
    tmp___4 = recv(ps->sd, (void *)(msg->data + msg->used), len, fl);
#line 527
    r = (int )tmp___4;
    }
#line 528
    if (r < 0) {
      {
#line 529
      tmp___6 = __errno_location();
      }
#line 529
      if (*tmp___6 == 32) {
        {
#line 530
        ps->state = 8;
#line 531
        tmp___5 = pi_set_error(ps->sd, -200);
        }
#line 531
        return ((ssize_t )tmp___5);
      } else {
        {
#line 529
        tmp___7 = __errno_location();
        }
#line 529
        if (*tmp___7 == 9) {
          {
#line 530
          ps->state = 8;
#line 531
          tmp___5 = pi_set_error(ps->sd, -200);
          }
#line 531
          return ((ssize_t )tmp___5);
        }
      }
      {
#line 533
      tmp___8 = pi_set_error(ps->sd, -204);
      }
#line 533
      return ((ssize_t )tmp___8);
    }
    {
#line 536
    data->rx_bytes += r;
#line 537
    msg->used += (size_t )r;
#line 539
    pi_log(2, 4, "DEV RX Inet Bytes: %d\n", r);
    }
#line 540
    return ((ssize_t )r);
  }
  {
#line 544
  pi_log(2, 2, "DEV RX Inet timeout\n");
#line 545
  (data->rx_errors) ++;
  }
#line 546
  return ((ssize_t )0);
}
}
#line 549 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_getsockopt(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) 
{ 
  pi_inet_data_t *data ;
  int *tmp ;
  int tmp___0 ;

  {
#line 553
  data = (pi_inet_data_t *)(ps->device)->data;
  {
#line 556
  if (option_name == 3) {
#line 556
    goto case_3;
  }
#line 555
  goto switch_break;
  case_3: /* CIL Label */ 
#line 557
  if (*option_len != sizeof(data->timeout)) {
    {
#line 558
    tmp = __errno_location();
#line 558
    *tmp = 22;
#line 559
    tmp___0 = pi_set_error(ps->sd, -501);
    }
#line 559
    return (tmp___0);
  }
  {
#line 561
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->timeout),
         sizeof(data->timeout));
#line 563
  *option_len = sizeof(data->timeout);
  }
#line 564
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 567
  return (0);
}
}
#line 570 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_setsockopt(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) 
{ 
  pi_inet_data_t *data ;
  int *tmp ;
  int tmp___0 ;

  {
#line 574
  data = (pi_inet_data_t *)(ps->device)->data;
  {
#line 577
  if (option_name == 3) {
#line 577
    goto case_3;
  }
#line 576
  goto switch_break;
  case_3: /* CIL Label */ 
#line 578
  if (*option_len != sizeof(data->timeout)) {
    {
#line 579
    tmp = __errno_location();
#line 579
    *tmp = 22;
#line 580
    tmp___0 = pi_set_error(ps->sd, -501);
    }
#line 580
    return (tmp___0);
  }
  {
#line 582
  memcpy((void */* __restrict  */)(& data->timeout), (void const   */* __restrict  */)option_value,
         sizeof(data->timeout));
  }
#line 584
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 587
  return (0);
}
}
#line 91 "../include/pi-usb.h"
void pi_usb_impl_init(struct pi_usb_impl *impl ) ;
#line 92
int USB_check_device(pi_usb_data_t *dev , u_int16_t vendor , u_int16_t product ) ;
#line 93
int USB_configure_device(pi_usb_data_t *dev , u_int8_t *input_pipe , u_int8_t *output_pipe ) ;
#line 50 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
pi_protocol_t *pi_usb_protocol_dup(pi_protocol_t *prot ) ;
#line 52
static int pi_usb_connect(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
#line 54
static int pi_usb_bind(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
#line 56
static int pi_usb_listen(pi_socket_t *ps , int backlog ) ;
#line 57
static int pi_usb_accept(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) ;
#line 59
static int pi_usb_getsockopt(pi_socket_t *ps , int level , int option_name , void *option_value ,
                             size_t *option_len ) ;
#line 61
static int pi_usb_setsockopt(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                             size_t *option_len ) ;
#line 63
static int pi_usb_close(pi_socket_t *ps ) ;
#line 65
static int USB_configure_visor(pi_usb_data_t *dev , u_int8_t *input_pipe , u_int8_t *output_pipe ) ;
#line 66
static int USB_configure_generic(pi_usb_data_t *dev , u_int8_t *input_pipe , u_int8_t *output_pipe ) ;
#line 82 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
pi_protocol_t *pi_usb_protocol_dup(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  void *tmp ;

  {
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 87
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
             87, "prot != NULL");
      }
    }
#line 87
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  tmp = malloc(sizeof(pi_protocol_t ));
#line 89
  new_prot = (pi_protocol_t *)tmp;
  }
#line 91
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 92
    new_prot->level = prot->level;
#line 93
    new_prot->dup = prot->dup;
#line 94
    new_prot->free = prot->free;
#line 95
    new_prot->read = prot->read;
#line 96
    new_prot->write = prot->write;
#line 97
    new_prot->flush = prot->flush;
#line 98
    new_prot->getsockopt = prot->getsockopt;
#line 99
    new_prot->setsockopt = prot->setsockopt;
#line 100
    new_prot->data = (void *)0;
  }
#line 103
  return (new_prot);
}
}
#line 118 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static void pi_usb_protocol_free(pi_protocol_t *prot ) 
{ 


  {
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 121
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
             121, "prot != NULL");
      }
    }
#line 121
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
    {
#line 124
    free((void *)prot);
    }
  }
#line 125
  return;
}
}
#line 139 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static pi_protocol_t *pi_usb_protocol(pi_device_t *dev ) 
{ 
  pi_protocol_t *prot ;
  pi_usb_data_t *data ;
  void *tmp ;

  {
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! ((unsigned long )dev != (unsigned long )((void *)0))) {
      {
#line 145
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
             145, "dev != NULL");
      }
    }
#line 145
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 147
  data = (pi_usb_data_t *)dev->data;
#line 149
  tmp = malloc(sizeof(pi_protocol_t ));
#line 149
  prot = (pi_protocol_t *)tmp;
  }
#line 151
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 152
    prot->level = 0;
#line 153
    prot->dup = & pi_usb_protocol_dup;
#line 154
    prot->free = & pi_usb_protocol_free;
#line 155
    prot->read = data->impl.read;
#line 156
    prot->write = data->impl.write;
#line 157
    prot->flush = data->impl.flush;
#line 158
    prot->getsockopt = & pi_usb_getsockopt;
#line 159
    prot->setsockopt = & pi_usb_setsockopt;
#line 160
    prot->data = (void *)0;
  }
#line 163
  return (prot);
}
}
#line 177 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static void pi_usb_device_free(pi_device_t *dev ) 
{ 
  pi_usb_data_t *data ;

  {
#line 180
  data = (pi_usb_data_t *)dev->data;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! ((unsigned long )dev != (unsigned long )((void *)0))) {
      {
#line 182
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
             182, "dev != NULL");
      }
    }
#line 182
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  if ((unsigned long )data != (unsigned long )((void *)0)) {
    {
#line 185
    free((void *)data);
    }
  }
#line 186
  if ((unsigned long )dev != (unsigned long )((void *)0)) {
    {
#line 187
    free((void *)dev);
    }
  }
#line 188
  return;
}
}
#line 202 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
pi_device_t *pi_usb_device(int type ) 
{ 
  pi_device_t *dev ;
  pi_usb_data_t *data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 208
  tmp = malloc(sizeof(pi_device_t ));
#line 208
  dev = (pi_device_t *)tmp;
  }
#line 209
  if ((unsigned long )dev != (unsigned long )((void *)0)) {
    {
#line 210
    tmp___0 = malloc(sizeof(struct pi_usb_data ));
#line 210
    data = (pi_usb_data_t *)tmp___0;
    }
#line 211
    if ((unsigned long )data == (unsigned long )((void *)0)) {
      {
#line 212
      free((void *)dev);
#line 213
      dev = (pi_device_t *)((void *)0);
      }
    } else {
      {
#line 215
      dev->free = & pi_usb_device_free;
#line 216
      dev->protocol = & pi_usb_protocol;
#line 217
      dev->bind = & pi_usb_bind;
#line 218
      dev->listen = & pi_usb_listen;
#line 219
      dev->accept = & pi_usb_accept;
#line 220
      dev->connect = & pi_usb_connect;
#line 221
      dev->close = & pi_usb_close;
#line 223
      memset((void *)data, 0, sizeof(struct pi_usb_data ));
#line 224
      data->rate = -1;
#line 225
      data->establishrate = -1;
#line 226
      data->establishhighrate = 0;
#line 227
      pi_usb_impl_init(& data->impl);
#line 229
      dev->data = (void *)data;
      }
    }
  }
#line 233
  return (dev);
}
}
#line 247 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_connect(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) 
{ 
  struct pi_usb_data *data ;
  struct pi_sockaddr *pa ;
  int result ;
  int timeout ;
  size_t size ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 250
  data = (pi_usb_data_t *)(ps->device)->data;
#line 251
  pa = (struct pi_sockaddr *)addr;
#line 255
  if (ps->type == 16) {
#line 256
    if (ps->protocol == 3) {
#line 257
      tmp = 57600;
#line 257
      data->rate = tmp;
#line 257
      data->establishrate = tmp;
    } else {
#line 259
      if (data->establishrate == -1) {
        {
#line 260
        get_pilot_rate(& data->establishrate, & data->establishhighrate);
        }
      }
#line 263
      data->rate = 9600;
    }
  } else
#line 265
  if (ps->type == 48) {
#line 267
    tmp___0 = 57600;
#line 267
    data->rate = tmp___0;
#line 267
    data->establishrate = tmp___0;
  }
  {
#line 270
  result = (*(data->impl.open))(ps, pa, addrlen);
  }
#line 271
  if (result < 0) {
#line 272
    goto fail;
  }
#line 274
  timeout = ps->accept_to * 1000;
#line 274
  data->timeout = timeout;
#line 276
  if (data->impl.wait_for_device) {
    {
#line 277
    result = (*(data->impl.wait_for_device))(ps, & timeout);
    }
#line 278
    if (result <= 0) {
#line 279
      goto fail;
    }
  }
  {
#line 282
  tmp___1 = malloc(addrlen);
#line 282
  ps->raddr = (struct sockaddr *)tmp___1;
#line 283
  memcpy((void */* __restrict  */)ps->raddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 284
  ps->raddrlen = addrlen;
#line 285
  tmp___2 = malloc(addrlen);
#line 285
  ps->laddr = (struct sockaddr *)tmp___2;
#line 286
  memcpy((void */* __restrict  */)ps->laddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 287
  ps->laddrlen = addrlen;
  }
#line 289
  if (ps->type == 16) {
    {
#line 291
    if (ps->cmd == 1) {
#line 291
      goto case_1;
    }
#line 301
    if (ps->cmd == 2) {
#line 301
      goto case_2;
    }
#line 290
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 292
    result = cmp_tx_handshake(ps);
    }
#line 292
    if (result < 0) {
#line 293
      goto fail;
    }
    {
#line 294
    size = sizeof(data->rate);
#line 295
    pi_getsockopt(ps->sd, 5, 3, (void *)(& data->rate), & size);
#line 297
    result = (*(data->impl.changebaud))(ps);
    }
#line 297
    if (result < 0) {
#line 298
      goto fail;
    }
#line 299
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 302
    result = net_tx_handshake(ps);
    }
#line 302
    if (result < 0) {
#line 303
      goto fail;
    }
#line 304
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 307
  ps->state = 4;
#line 308
  ps->command = 0;
  fail: 
#line 311
  if (result < 0) {
#line 311
    tmp___3 = result;
  } else {
#line 311
    tmp___3 = 0;
  }
#line 311
  return (tmp___3);
}
}
#line 325 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_bind(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) 
{ 
  struct pi_usb_data *data ;
  struct pi_sockaddr *pa ;
  int result ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 328
  data = (pi_usb_data_t *)(ps->device)->data;
#line 329
  pa = (struct pi_sockaddr *)addr;
#line 335
  if (ps->type == 16) {
#line 336
    if (data->establishrate == -1) {
      {
#line 337
      get_pilot_rate(& data->establishrate, & data->establishhighrate);
      }
    }
#line 340
    data->rate = 9600;
  } else
#line 341
  if (ps->type == 48) {
#line 343
    tmp = 57600;
#line 343
    data->rate = tmp;
#line 343
    data->establishrate = tmp;
  }
  {
#line 346
  result = (*(data->impl.open))(ps, pa, addrlen);
  }
#line 347
  if (result < 0) {
#line 348
    return (result);
  }
  {
#line 350
  tmp___0 = malloc(addrlen);
#line 350
  ps->raddr = (struct sockaddr *)tmp___0;
#line 351
  memcpy((void */* __restrict  */)ps->raddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 352
  ps->raddrlen = addrlen;
#line 353
  tmp___1 = malloc(addrlen);
#line 353
  ps->laddr = (struct sockaddr *)tmp___1;
#line 354
  memcpy((void */* __restrict  */)ps->laddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 355
  ps->laddrlen = addrlen;
  }
#line 357
  return (0);
}
}
#line 371 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_listen(pi_socket_t *ps , int backlog ) 
{ 


  {
#line 374
  ps->state = 1;
#line 375
  return (0);
}
}
#line 389 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_accept(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) 
{ 
  struct pi_usb_data *data ;
  int result ;
  int timeout ;
  size_t size ;
  struct timeval tv ;
  unsigned char cmp_flags ;
  int use_long_format ;

  {
#line 392
  data = (pi_usb_data_t *)(ps->device)->data;
#line 397
  timeout = ps->accept_to * 1000;
#line 397
  data->timeout = timeout;
#line 399
  if (data->impl.wait_for_device) {
    {
#line 400
    result = (*(data->impl.wait_for_device))(ps, & timeout);
    }
#line 401
    if (result <= 0) {
#line 402
      return (result);
    }
  }
  {
#line 423
  result = (*(data->impl.poll))(ps, timeout);
  }
#line 424
  if (result <= 0) {
#line 425
    if (result == 0) {
#line 426
      return (-205);
    } else {
#line 428
      return (result);
    }
  }
  {
#line 432
  pi_socket_init(ps);
#line 434
  pi_log(2, 8, "%s: %d, prot: 0x%x, type: 0x%x, cmd: 0x%x.\n", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
         434, ps->protocol, ps->type, ps->cmd);
  }
#line 435
  if (ps->type == 16) {
    {
#line 440
    if (ps->cmd == 1) {
#line 440
      goto case_1;
    }
#line 476
    if (ps->cmd == 2) {
#line 476
      goto case_2;
    }
#line 485
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 441
    pi_log(2, 8, "%s: %d, cmp rx.\n", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
           441);
#line 442
    result = cmp_rx_handshake(ps, data->establishrate, data->establishhighrate);
    }
#line 442
    if (result < 0) {
      {
#line 444
      pi_log(2, 8, "usb.c: cmp_rx_handshake returned %d\n", result);
      }
#line 445
      return (result);
    }
    {
#line 449
    size = sizeof(cmp_flags);
#line 450
    pi_getsockopt(ps->sd, 5, 1, (void *)(& cmp_flags), & size);
    }
#line 451
    if ((int )cmp_flags & 16) {
      {
#line 452
      use_long_format = 1;
#line 453
      size = sizeof(int );
#line 454
      pi_setsockopt(ps->sd, 2, 3, (void const   *)(& use_long_format), & size);
#line 456
      ps->command ^= 1;
#line 457
      pi_setsockopt(ps->sd, 2, 3, (void const   *)(& use_long_format), & size);
#line 459
      ps->command ^= 1;
      }
    }
    {
#line 463
    size = sizeof(data->rate);
#line 464
    pi_getsockopt(ps->sd, 5, 3, (void *)(& data->rate), & size);
    }
#line 465
    if ((unsigned long )data->impl.changebaud != (unsigned long )((void *)0)) {
      {
#line 466
      result = (*(data->impl.changebaud))(ps);
      }
#line 466
      if (result < 0) {
#line 467
        return (result);
      }
      {
#line 470
      tv.tv_sec = (__time_t )0;
#line 471
      tv.tv_usec = (__suseconds_t )50000;
#line 472
      select(0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0,
             (struct timeval */* __restrict  */)(& tv));
      }
    }
#line 474
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 477
    pi_log(2, 8, "%s: %d, net rx.\n", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
           477);
#line 478
    result = net_rx_handshake(ps);
    }
#line 478
    if (result < 0) {
      {
#line 480
      pi_log(2, 8, "usb.c: cmp_rx_handshake returned %d\n", result);
      }
#line 481
      return (result);
    }
#line 483
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 486
    pi_log(2, 1, "%s: %d, unknown rx %x.\n", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
           486, ps->cmd);
    }
#line 487
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 489
    ps->dlprecord = 0;
  }
#line 492
  data->timeout = 0;
#line 493
  ps->command = 0;
#line 494
  ps->state = 2;
#line 495
  return (ps->sd);
}
}
#line 509 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_getsockopt(pi_socket_t *ps , int level , int option_name , void *option_value ,
                             size_t *option_len ) 
{ 
  pi_usb_data_t *data ;
  int *tmp ;
  int tmp___0 ;

  {
#line 513
  data = (pi_usb_data_t *)(ps->device)->data;
  {
#line 516
  if (option_name == 0) {
#line 516
    goto case_0;
  }
#line 522
  if (option_name == 1) {
#line 522
    goto case_1;
  }
#line 529
  if (option_name == 2) {
#line 529
    goto case_2;
  }
#line 536
  if (option_name == 3) {
#line 536
    goto case_3;
  }
#line 515
  goto switch_break;
  case_0: /* CIL Label */ 
#line 517
  if (*option_len != sizeof(data->rate)) {
#line 518
    goto fail;
  }
  {
#line 519
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->rate),
         sizeof(data->rate));
  }
#line 520
  goto switch_break;
  case_1: /* CIL Label */ 
#line 523
  if (*option_len != sizeof(data->establishrate)) {
#line 524
    goto fail;
  }
  {
#line 525
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->establishrate),
         sizeof(data->establishrate));
  }
#line 527
  goto switch_break;
  case_2: /* CIL Label */ 
#line 530
  if (*option_len != sizeof(data->establishhighrate)) {
#line 531
    goto fail;
  }
  {
#line 532
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->establishhighrate),
         sizeof(data->establishhighrate));
  }
#line 534
  goto switch_break;
  case_3: /* CIL Label */ 
#line 537
  if (*option_len != sizeof(data->timeout)) {
#line 538
    goto fail;
  }
  {
#line 539
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->timeout),
         sizeof(data->timeout));
  }
#line 541
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 544
  return (0);
  fail: 
  {
#line 547
  tmp = __errno_location();
#line 547
  *tmp = 22;
#line 548
  tmp___0 = pi_set_error(ps->sd, -501);
  }
#line 548
  return (tmp___0);
}
}
#line 562 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_setsockopt(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                             size_t *option_len ) 
{ 
  pi_usb_data_t *data ;
  int *tmp ;
  int tmp___0 ;

  {
#line 566
  data = (pi_usb_data_t *)(ps->device)->data;
  {
#line 569
  if (option_name == 1) {
#line 569
    goto case_1;
  }
#line 576
  if (option_name == 2) {
#line 576
    goto case_2;
  }
#line 583
  if (option_name == 3) {
#line 583
    goto case_3;
  }
#line 568
  goto switch_break;
  case_1: /* CIL Label */ 
#line 570
  if (*option_len != sizeof(data->establishrate)) {
#line 571
    goto fail;
  }
  {
#line 572
  memcpy((void */* __restrict  */)(& data->establishrate), (void const   */* __restrict  */)option_value,
         sizeof(data->establishrate));
  }
#line 574
  goto switch_break;
  case_2: /* CIL Label */ 
#line 577
  if (*option_len != sizeof(data->establishhighrate)) {
#line 578
    goto fail;
  }
  {
#line 579
  memcpy((void */* __restrict  */)(& data->establishhighrate), (void const   */* __restrict  */)option_value,
         sizeof(data->establishhighrate));
  }
#line 581
  goto switch_break;
  case_3: /* CIL Label */ 
#line 584
  if (*option_len != sizeof(data->timeout)) {
#line 585
    goto fail;
  }
  {
#line 586
  memcpy((void */* __restrict  */)(& data->timeout), (void const   */* __restrict  */)option_value,
         sizeof(data->timeout));
  }
#line 588
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 591
  return (0);
  fail: 
  {
#line 594
  tmp = __errno_location();
#line 594
  *tmp = 22;
#line 595
  tmp___0 = pi_set_error(ps->sd, -501);
  }
#line 595
  return (tmp___0);
}
}
#line 610 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_close(pi_socket_t *ps ) 
{ 
  pi_usb_data_t *data ;

  {
#line 613
  data = (pi_usb_data_t *)(ps->device)->data;
#line 615
  if (ps->sd != 0) {
    {
#line 616
    (*(data->impl.close))(ps);
#line 617
    ps->sd = 0;
    }
  }
#line 620
  if ((unsigned long )ps->laddr != (unsigned long )((void *)0)) {
    {
#line 621
    free((void *)ps->laddr);
#line 622
    ps->laddr = (struct sockaddr *)((void *)0);
    }
  }
#line 624
  if ((unsigned long )ps->raddr != (unsigned long )((void *)0)) {
    {
#line 625
    free((void *)ps->raddr);
#line 626
    ps->raddr = (struct sockaddr *)((void *)0);
    }
  }
#line 629
  return (0);
}
}
#line 645 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
pi_usb_dev_t known_devices[41]  = 
#line 645
  {      {(u_int16_t )1356, (u_int16_t )56, (u_int32_t )(1 << 3), (char *)"Sony S S320 and other Palm OS 3.5 devices"}, 
        {(u_int16_t )1356,
      (u_int16_t )102, (u_int32_t )(1 << 3), (char *)"Sony T, SJ series, and other Palm OS 4.0 devices"}, 
        {(u_int16_t )1356,
      (u_int16_t )149, 0U, (char *)"Sony S360"}, 
        {(u_int16_t )1356, (u_int16_t )10, 0U, (char *)"Sony NR and other Palm OS 4.1 devices"}, 
        {(u_int16_t )1356,
      (u_int16_t )154, (u_int32_t )(1 << 3), (char *)"Sony NR70V/U"}, 
        {(u_int16_t )1356, (u_int16_t )218, 0U, (char *)"Sony NX"}, 
        {(u_int16_t )1356, (u_int16_t )233, 0U, (char *)"Sony NZ"}, 
        {(u_int16_t )1356, (u_int16_t )324, 0U, (char *)"Sony UX"}, 
        {(u_int16_t )1356, (u_int16_t )361, (u_int32_t )(1 << 3), (char *)"Sony TJ"}, 
        {(u_int16_t )2078,
      (u_int16_t )57088, 0U, (char *)"Alphasmart Dana"}, 
        {(u_int16_t )2093, (u_int16_t )256, (u_int32_t )(1 << 2), (char *)"Visor, Treo 300"}, 
        {(u_int16_t )2093,
      (u_int16_t )512, 0U, (char *)"Treo"}, 
        {(u_int16_t )2093, (u_int16_t )768, 0U, (char *)"Treo 600"}, 
        {(u_int16_t )2096, (u_int16_t )1, 0U, (char *)"m500"}, 
        {(u_int16_t )2096, (u_int16_t )2, 0U, (char *)"m505"}, 
        {(u_int16_t )2096, (u_int16_t )3, 0U, (char *)"m515"}, 
        {(u_int16_t )2096, (u_int16_t )16, 0U, (char *)0}, 
        {(u_int16_t )2096, (u_int16_t )17, 0U, (char *)0}, 
        {(u_int16_t )2096, (u_int16_t )32, 0U, (char *)"i705"}, 
        {(u_int16_t )2096, (u_int16_t )48, 0U, (char *)"Tungsten|Z"}, 
        {(u_int16_t )2096, (u_int16_t )49, 0U, (char *)"Tungsten|W"}, 
        {(u_int16_t )2096, (u_int16_t )64, 0U, (char *)"m125"}, 
        {(u_int16_t )2096, (u_int16_t )80, 0U, (char *)"m130"}, 
        {(u_int16_t )2096, (u_int16_t )81, 0U, (char *)0}, 
        {(u_int16_t )2096, (u_int16_t )82, 0U, (char *)0}, 
        {(u_int16_t )2096, (u_int16_t )83, 0U, (char *)0}, 
        {(u_int16_t )2096, (u_int16_t )96, 0U, (char *)"Tungsten series, Zire 71"}, 
        {(u_int16_t )2096, (u_int16_t )97, (u_int32_t )(1 << 1), (char *)"Zire 31, 72, Z22"}, 
        {(u_int16_t )2096,
      (u_int16_t )98, 0U, (char *)0}, 
        {(u_int16_t )2096, (u_int16_t )99, 0U, (char *)0}, 
        {(u_int16_t )2096, (u_int16_t )112, 0U, (char *)"Zire"}, 
        {(u_int16_t )2096, (u_int16_t )113, 0U, (char *)0}, 
        {(u_int16_t )2096, (u_int16_t )128, (u_int32_t )1, (char *)"m100"}, 
        {(u_int16_t )2096, (u_int16_t )153, 0U, (char *)0}, 
        {(u_int16_t )2096, (u_int16_t )256, 0U, (char *)0}, 
        {(u_int16_t )2334, (u_int16_t )4, 0U, (char *)"IQUE 3600"}, 
        {(u_int16_t )3208, (u_int16_t )33, 0U, (char *)"7135 Smartphone"}, 
        {(u_int16_t )3208, (u_int16_t )41510, 0U, (char *)"6035 Smartphone"}, 
        {(u_int16_t )4847, (u_int16_t )256, (u_int32_t )(1 << 1), (char *)"Zodiac, Zodiac2"}, 
        {(u_int16_t )18278,
      (u_int16_t )1, 0U, (char *)"MEZ1000"}, 
        {(u_int16_t )1256, (u_int16_t )32769, 0U, (char *)"i330"}};
#line 900 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
int USB_check_device(pi_usb_data_t *dev , u_int16_t vendor , u_int16_t product ) 
{ 
  unsigned int i ;

  {
#line 905
  i = 0U;
  {
#line 905
  while (1) {
    while_continue: /* CIL Label */ ;
#line 905
    if (! ((unsigned long )i < sizeof(known_devices) / sizeof(known_devices[0]))) {
#line 905
      goto while_break;
    }
#line 906
    if ((int )known_devices[i].vendor == (int )vendor) {
#line 907
      if (! known_devices[i].product) {
#line 909
        dev->dev.flags |= known_devices[i].flags;
#line 910
        return (0);
      } else
#line 907
      if ((int )known_devices[i].product == (int )product) {
#line 909
        dev->dev.flags |= known_devices[i].flags;
#line 910
        return (0);
      }
    }
#line 905
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 915
  return (-1);
}
}
#line 923 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
int USB_configure_device(pi_usb_data_t *dev , u_int8_t *input_pipe , u_int8_t *output_pipe ) 
{ 
  int ret ;
  u_int32_t flags ;
  unsigned char ba[2] ;
  unsigned int tmp ;

  {
#line 927
  flags = dev->dev.flags;
#line 929
  *input_pipe = (u_int8_t )255;
#line 930
  *output_pipe = (u_int8_t )255;
#line 940
  if (flags & 1U) {
#line 941
    return (0);
  }
#line 942
  if (flags & (unsigned int )(1 << 2)) {
    {
#line 943
    ret = USB_configure_visor(dev, input_pipe, output_pipe);
    }
  } else
#line 944
  if (flags & (unsigned int )(1 << 3)) {
    {
#line 947
    ret = (*(dev->impl.control_request))(dev, 128, 8, 0, 0, (void *)0, 1, 0);
    }
#line 948
    if (ret < 0) {
      {
#line 949
      pi_log(2, 1, "usb: Sony USB_REQ_GET_CONFIGURATION failed (err=%08x)\n", ret);
      }
    }
    {
#line 952
    ret = (*(dev->impl.control_request))(dev, 128, 10, 0, 0, (void *)0, 1, 0);
    }
#line 953
    if (ret < 0) {
      {
#line 954
      pi_log(2, 1, "usb: Sony USB_REQ_GET_INTERFACE failed (err=%08x)\n", ret);
      }
    }
  } else {
    {
#line 958
    ret = USB_configure_generic(dev, input_pipe, output_pipe);
    }
#line 959
    if (ret < 0) {
#line 960
      return (-1);
    }
  }
#line 967
  if (! (flags & (unsigned int )(1 << 1))) {
#line 968
    ba[0] = (unsigned char)0;
#line 968
    tmp = 1U;
    {
#line 968
    while (1) {
      while_continue: /* CIL Label */ ;
#line 968
      if (tmp >= 2U) {
#line 968
        goto while_break;
      }
#line 968
      ba[tmp] = (unsigned char)0;
#line 968
      tmp ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 970
    ret = (*(dev->impl.control_request))(dev, 194, 1, 0, 0, (void *)(& ba[0]), 2,
                                         0);
    }
#line 971
    if (ret < 0) {
      {
#line 972
      pi_log(2, 1, "usb: GENERIC_REQUEST_BYTES_AVAILABLE failed (err=%08x)\n", ret);
      }
#line 974
      return (-1);
    }
    {
#line 976
    pi_log(2, 8, "GENERIC_REQUEST_BYTES_AVAILABLE returns 0x%02x%02x\n", (int )ba[0],
           (int )ba[1]);
    }
  }
#line 979
  return (0);
}
}
#line 982 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int USB_configure_visor(pi_usb_data_t *dev , u_int8_t *input_pipe , u_int8_t *output_pipe ) 
{ 
  int i ;
  int ret ;
  visor_connection_info_t ci ;
  char *function_str ;

  {
  {
#line 988
  ret = (*(dev->impl.control_request))(dev, 194, 3, 0, 0, (void *)(& ci), (int )sizeof(ci),
                                       0);
  }
#line 989
  if (ret < 0) {
    {
#line 990
    pi_log(2, 1, "usb: VISOR_GET_CONNECTION_INFORMATION failed (err=%08x)\n", ret);
    }
  } else {
    {
#line 992
    pi_log(2, 8, "usb: VISOR_GET_CONNECTION_INFORMATION, num_ports=%d\n", (int )ci.num_ports);
    }
#line 993
    if ((int )ci.num_ports > 2) {
#line 994
      ci.num_ports = (u_int16_t )2;
    }
#line 995
    i = 0;
    {
#line 995
    while (1) {
      while_continue: /* CIL Label */ ;
#line 995
      if (! (i < (int )ci.num_ports)) {
#line 995
        goto while_break;
      }
      {
#line 1000
      if ((int )ci.connections[i].port_function_id == 0) {
#line 1000
        goto case_0;
      }
#line 1003
      if ((int )ci.connections[i].port_function_id == 1) {
#line 1003
        goto case_1;
      }
#line 1006
      if ((int )ci.connections[i].port_function_id == 2) {
#line 1006
        goto case_2;
      }
#line 1009
      if ((int )ci.connections[i].port_function_id == 3) {
#line 1009
        goto case_3;
      }
#line 1012
      if ((int )ci.connections[i].port_function_id == 4) {
#line 1012
        goto case_4;
      }
#line 1015
      goto switch_default;
      case_0: /* CIL Label */ 
#line 1001
      function_str = (char *)"GENERIC";
#line 1002
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1004
      function_str = (char *)"DEBUGGER";
#line 1005
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1007
      function_str = (char *)"HOTSYNC";
#line 1008
      goto switch_break;
      case_3: /* CIL Label */ 
#line 1010
      function_str = (char *)"CONSOLE";
#line 1011
      goto switch_break;
      case_4: /* CIL Label */ 
#line 1013
      function_str = (char *)"REMOTE_FILE_SYSTEM";
#line 1014
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1016
      function_str = (char *)"UNKNOWN";
#line 1017
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 1019
      pi_log(2, 8, "\t[%d] port_function_id=0x%02x (%s)\n", i, (int )ci.connections[i].port_function_id,
             function_str);
#line 1023
      pi_log(2, 8, "\t[%d] port=%d\n", i, (int )ci.connections[i].port);
#line 995
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1027
  return (ret);
}
}
#line 1030 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int USB_configure_generic(pi_usb_data_t *dev , u_int8_t *input_pipe , u_int8_t *output_pipe ) 
{ 
  int i ;
  int ret ;
  int hotsync ;
  palm_ext_connection_info_t ci ;
  u_int32_t flags ;
  int tmp ;

  {
  {
#line 1034
  hotsync = 0;
#line 1036
  flags = dev->dev.flags;
#line 1038
  ret = (*(dev->impl.control_request))(dev, 194, 4, 0, 0, (void *)(& ci), (int )sizeof(ci),
                                       0);
  }
#line 1039
  if (ret < 0) {
    {
#line 1040
    pi_log(2, 1, "usb: PALM_GET_EXT_CONNECTION_INFORMATION failed (err=%08x)\n", ret);
    }
  } else {
    {
#line 1042
    pi_log(2, 8, "usb: PALM_GET_EXT_CONNECTION_INFORMATION, num_ports=%d, endpoint_numbers_different=%d\n",
           (int )ci.num_ports, (int )ci.endpoint_numbers_different);
#line 1045
    i = 0;
    }
    {
#line 1045
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1045
      if (! (i < (int )ci.num_ports)) {
#line 1045
        goto while_break;
      }
      {
#line 1046
      pi_log(2, 8, "\t[%d] port_function_id=\'%c%c%c%c\'\n", i, (int )ci.connections[i].port_function_id[0],
             (int )ci.connections[i].port_function_id[1], (int )ci.connections[i].port_function_id[2],
             (int )ci.connections[i].port_function_id[3]);
#line 1052
      pi_log(2, 8, "\t[%d] port=%d\n", i, (int )ci.connections[i].port);
#line 1055
      pi_log(2, 8, "\t[%d] endpoint_info=%d\n", i, (int )ci.connections[i].endpoint_info);
#line 1057
      tmp = memcmp((void const   *)(ci.connections[i].port_function_id), (void const   *)"cnys",
                   (size_t )4);
      }
#line 1057
      if (! tmp) {
#line 1060
        hotsync = 1;
#line 1064
        if (ci.endpoint_numbers_different) {
#line 1065
          if (input_pipe) {
#line 1066
            *input_pipe = (u_int8_t )((int )ci.connections[i].endpoint_info >> 4);
          }
#line 1067
          if (output_pipe) {
#line 1068
            *output_pipe = (u_int8_t )((int )ci.connections[i].endpoint_info & 15);
          }
        } else {
#line 1070
          if (input_pipe) {
#line 1071
            *input_pipe = ci.connections[i].port;
          }
#line 1072
          if (output_pipe) {
#line 1073
            *output_pipe = ci.connections[i].port;
          }
        }
      }
#line 1045
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1078
    if (! hotsync) {
      {
#line 1079
      pi_log(2, 1, "usb: PALM_GET_EXT_CONNECTION_INFORMATION - no hotsync port found.\n",
             ret);
      }
#line 1080
      return (-1);
    }
  }
#line 1084
  if (flags & (unsigned int )(1 << 1)) {
    {
#line 1089
    ret = (*(dev->impl.control_request))(dev, 194, 4, 0, 0, (void *)(& ci), (int )sizeof(ci),
                                         0);
#line 1090
    ret = (*(dev->impl.control_request))(dev, 194, 4, 0, 0, (void *)(& ci), (int )sizeof(ci),
                                         0);
    }
  }
#line 1092
  return (ret);
}
}
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 49 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_open(pi_socket_t *ps , struct pi_sockaddr *addr , size_t addrlen ) ;
#line 50
static int u_close(pi_socket_t *ps ) ;
#line 51
static int u_write(pi_socket_t *ps , unsigned char *buf___3 , size_t len , int flags ) ;
#line 52
static int u_read(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) ;
#line 53
static int u_poll(pi_socket_t *ps , int timeout ) ;
#line 54
static int u_flush(pi_socket_t *ps , int flags ) ;
#line 56 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
void pi_usb_impl_init(struct pi_usb_impl *impl ) 
{ 


  {
#line 58
  impl->open = & u_open;
#line 59
  impl->close = & u_close;
#line 60
  impl->write = (ssize_t (*)(pi_socket_t *ps , unsigned char const   *buf , size_t len ,
                             int flags ))(& u_write);
#line 61
  impl->read = (ssize_t (*)(pi_socket_t *ps , pi_buffer_t *buf , size_t expect , int flags ))(& u_read);
#line 62
  impl->flush = & u_flush;
#line 63
  impl->poll = & u_poll;
#line 64
  impl->wait_for_device = (int (*)(pi_socket_t *ps , int *timeout ))((void *)0);
#line 65
  impl->changebaud = (int (*)(pi_socket_t *ps ))((void *)0);
#line 68
  impl->control_request = (int (*)(struct pi_usb_data *usb_data , int request_type ,
                                   int request , int value , int reqindex , void *data ,
                                   int size , int timeout ))((void *)0);
#line 69
  return;
}
}
#line 83 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_open(pi_socket_t *ps , struct pi_sockaddr *addr , size_t addrlen ) 
{ 
  int fd ;
  int i ;
  char *tty ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 88
  tty = addr->pi_device;
#line 90
  fd = open((char const   *)tty, 2050);
  }
#line 90
  if (fd < 0) {
#line 91
    ps->last_error = -502;
#line 92
    return (-502);
  }
  {
#line 95
  tmp___0 = isatty(fd);
  }
#line 95
  if (! tmp___0) {
    {
#line 96
    close(fd);
#line 97
    tmp = __errno_location();
#line 97
    *tmp = 22;
#line 98
    ps->last_error = -502;
    }
#line 99
    return (-502);
  }
  {
#line 102
  i = fcntl(fd, 3, 0);
  }
#line 102
  if (i != -1) {
    {
#line 103
    i &= -2049;
#line 104
    fcntl(fd, 4, i);
    }
  }
  {
#line 107
  i = pi_socket_setsd(ps, fd);
  }
#line 107
  if (i < 0) {
#line 108
    return (i);
  }
#line 110
  return (fd);
}
}
#line 125 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_close(pi_socket_t *ps ) 
{ 
  int tmp ;

  {
  {
#line 128
  pi_log(2, 4, "DEV CLOSE linuxusb fd: %d\n", ps->sd);
#line 131
  tmp = close(ps->sd);
  }
#line 131
  return (tmp);
}
}
#line 146 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_poll(pi_socket_t *ps , int timeout ) 
{ 
  struct timeval t ;
  fd_set ready ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 152
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 157
  if (timeout == 0) {
    {
#line 158
    select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
           (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
    }
  } else {
    {
#line 160
    t.tv_sec = (__time_t )(timeout / 1000);
#line 161
    t.tv_usec = (__suseconds_t )((timeout % 1000) * 1000);
#line 162
    select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
           (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
    }
  }
#line 165
  if (! ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
    {
#line 167
    pi_log(2, 2, "DEV POLL linuxusb timeout\n");
#line 169
    tmp = __errno_location();
#line 169
    *tmp = 110;
#line 170
    tmp___0 = pi_set_error(ps->sd, -202);
    }
#line 170
    return (tmp___0);
  }
  {
#line 173
  pi_log(2, 8, "DEV POLL linuxusb found data on fd: %d\n", ps->sd);
  }
#line 176
  return (1);
}
}
#line 191 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_write(pi_socket_t *ps , unsigned char *buf___3 , size_t len , int flags ) 
{ 
  int total ;
  int nwrote ;
  struct pi_usb_data *data ;
  struct timeval t ;
  fd_set ready ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;

  {
#line 196
  data = (struct pi_usb_data *)(ps->device)->data;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 200
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 203
  total = (int )len;
  {
#line 204
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 204
    if (! (total > 0)) {
#line 204
      goto while_break___0;
    }
#line 205
    if (data->timeout == 0) {
      {
#line 206
      select(ps->sd + 1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)(& ready),
             (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
      }
    } else {
      {
#line 208
      t.tv_sec = (__time_t )(data->timeout / 1000);
#line 209
      t.tv_usec = (__suseconds_t )((data->timeout % 1000) * 1000);
#line 210
      tmp___0 = select(ps->sd + 1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)(& ready),
                       (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
      }
#line 210
      if (tmp___0) {
        {
#line 211
        tmp = pi_set_error(ps->sd, -202);
        }
#line 211
        return (tmp);
      }
    }
#line 214
    if (! ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
      {
#line 215
      ps->state = 8;
#line 216
      tmp___1 = pi_set_error(ps->sd, -200);
      }
#line 216
      return (tmp___1);
    }
    {
#line 219
    tmp___2 = write(ps->sd, (void const   *)buf___3, len);
#line 219
    nwrote = (int )tmp___2;
    }
#line 220
    if (nwrote < 0) {
      {
#line 221
      ps->state = 8;
#line 222
      tmp___3 = pi_set_error(ps->sd, -200);
      }
#line 222
      return (tmp___3);
    }
#line 225
    total -= nwrote;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 228
  pi_log(2, 8, "DEV TX linuxusb wrote %d bytes\n", len);
  }
#line 231
  return ((int )len);
}
}
#line 246 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_read_buf(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) 
{ 
  struct pi_usb_data *data ;
  size_t rbuf ;
  int *tmp ;
  int tmp___0 ;
  pi_buffer_t *tmp___1 ;

  {
#line 249
  data = (struct pi_usb_data *)(ps->device)->data;
#line 250
  rbuf = data->buf_size;
#line 252
  if (rbuf > len) {
#line 253
    rbuf = len;
  }
  {
#line 255
  tmp___1 = pi_buffer_append(buf___3, (void const   *)(data->buf), rbuf);
  }
#line 255
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 256
    tmp = __errno_location();
#line 256
    *tmp = 12;
#line 257
    tmp___0 = pi_set_error(ps->sd, -500);
    }
#line 257
    return (tmp___0);
  }
#line 260
  if (flags != 1) {
#line 261
    data->buf_size -= rbuf;
#line 262
    if (data->buf_size > 0UL) {
      {
#line 263
      memmove((void *)(data->buf), (void const   *)(& data->buf[rbuf]), data->buf_size);
      }
    }
  }
  {
#line 266
  pi_log(2, 8, "DEV RX linuxusb read %d bytes from read-ahead buffer\n", rbuf);
  }
#line 269
  return ((int )rbuf);
}
}
#line 284 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_read(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) 
{ 
  ssize_t rbuf ;
  ssize_t bytes ;
  struct pi_usb_data *data ;
  struct timeval t ;
  fd_set ready ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  pi_buffer_t *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
#line 287
  rbuf = (ssize_t )0;
#line 289
  data = (struct pi_usb_data *)(ps->device)->data;
#line 294
  if (data->buf_size) {
    {
#line 295
    tmp = u_read_buf(ps, buf___3, len, flags);
#line 295
    rbuf = (ssize_t )tmp;
    }
#line 296
    if (rbuf < 0L) {
#line 297
      return ((int )rbuf);
    }
#line 298
    len -= (size_t )rbuf;
#line 299
    if (len == 0UL) {
#line 300
      return ((int )rbuf);
    }
  }
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 305
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 307
  if (data->timeout == 0) {
    {
#line 308
    select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
           (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
    }
  } else {
    {
#line 310
    t.tv_sec = (__time_t )(data->timeout / 1000);
#line 311
    t.tv_usec = (__suseconds_t )((data->timeout % 1000) * 1000);
#line 312
    tmp___2 = select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
                     (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
    }
#line 312
    if (tmp___2 == 0) {
      {
#line 313
      pi_log(2, 2, "DEV RX linuxusb timeout\n");
#line 315
      tmp___0 = __errno_location();
#line 315
      *tmp___0 = 110;
#line 316
      tmp___1 = pi_set_error(ps->sd, -202);
      }
#line 316
      return (tmp___1);
    }
  }
#line 321
  if ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 322
    if (flags == 1) {
#line 322
      if (len > 256UL) {
#line 323
        len = (size_t )256;
      }
    }
    {
#line 325
    tmp___5 = pi_buffer_expect(buf___3, len);
    }
#line 325
    if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
      {
#line 326
      tmp___3 = __errno_location();
#line 326
      *tmp___3 = 12;
#line 327
      tmp___4 = pi_set_error(ps->sd, -500);
      }
#line 327
      return (tmp___4);
    }
    {
#line 330
    bytes = read(ps->sd, (void *)(buf___3->data + buf___3->used), len);
    }
#line 332
    if (bytes > 0L) {
#line 333
      if (flags == 1) {
        {
#line 334
        memcpy((void */* __restrict  */)(data->buf + data->buf_size), (void const   */* __restrict  */)(buf___3->data + buf___3->used),
               (size_t )bytes);
#line 335
        data->buf_size += (size_t )bytes;
        }
      }
      {
#line 337
      buf___3->used += (size_t )bytes;
#line 338
      rbuf += bytes;
#line 340
      pi_log(2, 8, "DEV RX linuxusb read %d bytes\n", bytes);
      }
    }
  } else {
    {
#line 344
    pi_log(2, 2, "DEV RX linuxusb timeout\n");
#line 346
    tmp___6 = __errno_location();
#line 346
    *tmp___6 = 110;
#line 347
    tmp___7 = pi_set_error(ps->sd, -202);
    }
#line 347
    return (tmp___7);
  }
#line 350
  return ((int )rbuf);
}
}
#line 370 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_flush(pi_socket_t *ps , int flags ) 
{ 
  char buf___3[256] ;
  int fl ;
  struct pi_usb_data *data ;
  int tmp ;

  {
#line 375
  data = (struct pi_usb_data *)(ps->device)->data;
#line 377
  if (flags & 1) {
    {
#line 379
    data->buf_size = (size_t )0;
#line 382
    fl = fcntl(ps->sd, 3, 0);
    }
#line 382
    if (fl != -1) {
      {
#line 383
      fcntl(ps->sd, 4, fl | 2048);
      }
      {
#line 384
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 384
        tmp = (int )recv(ps->sd, buf___3, sizeof(buf___3), 0);
        }
#line 384
        if (! (tmp > 0)) {
#line 384
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 386
      fcntl(ps->sd, 4, 0);
      }
    }
    {
#line 389
    pi_log(2, 8, "DEV FLUSH linuxusb flushed input buffer\n");
    }
  }
#line 392
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 74 "../include/pi-syspkt.h"
int sys_UnpackState(void *buffer , struct Pilot_state *s ) ;
#line 77
int sys_UnpackRegisters(void *data , struct Pilot_registers *r ) ;
#line 81
int sys_Continue(int sd , struct Pilot_registers *r , struct Pilot_watch *w ) ;
#line 84
int sys_Step(int sd ) ;
#line 86
int sys_QueryState(int sd ) ;
#line 87
int sys_ReadMemory(int sd , unsigned long addr , unsigned long len , void *dest ) ;
#line 90
int sys_WriteMemory(int sd , unsigned long addr , unsigned long len , void *src ) ;
#line 94
int sys_ToggleDbgBreaks(int sd ) ;
#line 96
int sys_SetTrapBreaks(int sd , int *traps ) ;
#line 97
int sys_GetTrapBreaks(int sd , int *traps ) ;
#line 99
int sys_SetBreakpoints(int sd , struct Pilot_breakpoint *b ) ;
#line 101
int sys_Find(int sd , unsigned long startaddr , unsigned long stopaddr , size_t len ,
             int caseinsensitive , void *data , unsigned long *found ) ;
#line 106
int sys_RemoteEvent(int sd , int penDown , int x , int y , int keypressed , int keymod ,
                    int keyasc , int keycode ) ;
#line 110
int sys_RPC(int sd , int sockaddr , int trap , long *D0 , long *A0 , int params ,
            struct RPC_param *param , int reply ) ;
#line 131
int RPC(int sd , int sockaddr , int trap , int reply  , ...) ;
#line 134
void InvertRPC(struct RPC_params *p ) ;
#line 135
void UninvertRPC(struct RPC_params *p ) ;
#line 137
int PackRPC(struct RPC_params *p , int trap , int reply  , ...) ;
#line 140
unsigned long DoRPC(int sd , int sockaddr , struct RPC_params *p , int *error ) ;
#line 147
int RPC_Int_Void(int sd , int trap ) ;
#line 148
int RPC_Ptr_Void(int sd , int trap ) ;
#line 44 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
static int sys_PackRegisters(void *data , struct Pilot_registers *r ) ;
#line 58 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
int sys_UnpackState(void *buffer , struct Pilot_state *s ) 
{ 
  int idx ;
  unsigned char *data ;

  {
  {
#line 62
  data = (unsigned char *)buffer;
#line 64
  s->reset = (int )((unsigned short )(((int )*(data + 0) << 8) | (int )*(data + 1)));
#line 65
  s->exception = (int )((unsigned short )(((int )*((data + 2) + 0) << 8) | (int )*((data + 2) + 1)));
#line 66
  memcpy((void */* __restrict  */)(s->func_name), (void const   */* __restrict  */)(data + 152),
         (size_t )32);
#line 67
  memcpy((void */* __restrict  */)(s->instructions), (void const   */* __restrict  */)(data + 78),
         (size_t )30);
#line 68
  s->func_name[31] = (char)0;
#line 69
  s->func_start = ((((unsigned long )*((data + 144) + 0) << 24) | ((unsigned long )*((data + 144) + 1) << 16)) | ((unsigned long )*((data + 144) + 2) << 8)) | (unsigned long )*((data + 144) + 3);
#line 70
  s->func_end = ((((unsigned long )*((data + 148) + 0) << 24) | ((unsigned long )*((data + 148) + 1) << 16)) | ((unsigned long )*((data + 148) + 2) << 8)) | (unsigned long )*((data + 148) + 3);
#line 71
  sys_UnpackRegisters((void *)(data + 4), & s->regs);
#line 73
  idx = 0;
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! (idx < 6)) {
#line 73
      goto while_break;
    }
#line 74
    s->breakpoint[idx].address = ((((unsigned long )*(((data + 108) + idx * 6) + 0) << 24) | ((unsigned long )*(((data + 108) + idx * 6) + 1) << 16)) | ((unsigned long )*(((data + 108) + idx * 6) + 2) << 8)) | (unsigned long )*(((data + 108) + idx * 6) + 3);
#line 75
    s->breakpoint[idx].enabled = (int )*(((data + 112) + idx * 6) + 0);
#line 73
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  s->trap_rev = (int )((unsigned short )(((int )*((data + 184) + 0) << 8) | (int )*((data + 184) + 1)));
#line 80
  return (0);
}
}
#line 95 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
int sys_UnpackRegisters(void *data , struct Pilot_registers *r ) 
{ 
  unsigned char *buffer ;

  {
#line 98
  buffer = (unsigned char *)data;
#line 100
  r->D[0] = ((((unsigned long )*((buffer + 0) + 0) << 24) | ((unsigned long )*((buffer + 0) + 1) << 16)) | ((unsigned long )*((buffer + 0) + 2) << 8)) | (unsigned long )*((buffer + 0) + 3);
#line 101
  r->D[1] = ((((unsigned long )*((buffer + 4) + 0) << 24) | ((unsigned long )*((buffer + 4) + 1) << 16)) | ((unsigned long )*((buffer + 4) + 2) << 8)) | (unsigned long )*((buffer + 4) + 3);
#line 102
  r->D[2] = ((((unsigned long )*((buffer + 8) + 0) << 24) | ((unsigned long )*((buffer + 8) + 1) << 16)) | ((unsigned long )*((buffer + 8) + 2) << 8)) | (unsigned long )*((buffer + 8) + 3);
#line 103
  r->D[3] = ((((unsigned long )*((buffer + 12) + 0) << 24) | ((unsigned long )*((buffer + 12) + 1) << 16)) | ((unsigned long )*((buffer + 12) + 2) << 8)) | (unsigned long )*((buffer + 12) + 3);
#line 104
  r->D[4] = ((((unsigned long )*((buffer + 16) + 0) << 24) | ((unsigned long )*((buffer + 16) + 1) << 16)) | ((unsigned long )*((buffer + 16) + 2) << 8)) | (unsigned long )*((buffer + 16) + 3);
#line 105
  r->D[5] = ((((unsigned long )*((buffer + 20) + 0) << 24) | ((unsigned long )*((buffer + 20) + 1) << 16)) | ((unsigned long )*((buffer + 20) + 2) << 8)) | (unsigned long )*((buffer + 20) + 3);
#line 106
  r->D[6] = ((((unsigned long )*((buffer + 24) + 0) << 24) | ((unsigned long )*((buffer + 24) + 1) << 16)) | ((unsigned long )*((buffer + 24) + 2) << 8)) | (unsigned long )*((buffer + 24) + 3);
#line 107
  r->D[7] = ((((unsigned long )*((buffer + 28) + 0) << 24) | ((unsigned long )*((buffer + 28) + 1) << 16)) | ((unsigned long )*((buffer + 28) + 2) << 8)) | (unsigned long )*((buffer + 28) + 3);
#line 108
  r->A[0] = ((((unsigned long )*((buffer + 32) + 0) << 24) | ((unsigned long )*((buffer + 32) + 1) << 16)) | ((unsigned long )*((buffer + 32) + 2) << 8)) | (unsigned long )*((buffer + 32) + 3);
#line 109
  r->A[1] = ((((unsigned long )*((buffer + 36) + 0) << 24) | ((unsigned long )*((buffer + 36) + 1) << 16)) | ((unsigned long )*((buffer + 36) + 2) << 8)) | (unsigned long )*((buffer + 36) + 3);
#line 110
  r->A[2] = ((((unsigned long )*((buffer + 40) + 0) << 24) | ((unsigned long )*((buffer + 40) + 1) << 16)) | ((unsigned long )*((buffer + 40) + 2) << 8)) | (unsigned long )*((buffer + 40) + 3);
#line 111
  r->A[3] = ((((unsigned long )*((buffer + 44) + 0) << 24) | ((unsigned long )*((buffer + 44) + 1) << 16)) | ((unsigned long )*((buffer + 44) + 2) << 8)) | (unsigned long )*((buffer + 44) + 3);
#line 112
  r->A[4] = ((((unsigned long )*((buffer + 48) + 0) << 24) | ((unsigned long )*((buffer + 48) + 1) << 16)) | ((unsigned long )*((buffer + 48) + 2) << 8)) | (unsigned long )*((buffer + 48) + 3);
#line 113
  r->A[5] = ((((unsigned long )*((buffer + 52) + 0) << 24) | ((unsigned long )*((buffer + 52) + 1) << 16)) | ((unsigned long )*((buffer + 52) + 2) << 8)) | (unsigned long )*((buffer + 52) + 3);
#line 114
  r->A[6] = ((((unsigned long )*((buffer + 56) + 0) << 24) | ((unsigned long )*((buffer + 56) + 1) << 16)) | ((unsigned long )*((buffer + 56) + 2) << 8)) | (unsigned long )*((buffer + 56) + 3);
#line 115
  r->USP = ((((unsigned long )*((buffer + 60) + 0) << 24) | ((unsigned long )*((buffer + 60) + 1) << 16)) | ((unsigned long )*((buffer + 60) + 2) << 8)) | (unsigned long )*((buffer + 60) + 3);
#line 116
  r->SSP = ((((unsigned long )*((buffer + 64) + 0) << 24) | ((unsigned long )*((buffer + 64) + 1) << 16)) | ((unsigned long )*((buffer + 64) + 2) << 8)) | (unsigned long )*((buffer + 64) + 3);
#line 117
  r->PC = ((((unsigned long )*((buffer + 68) + 0) << 24) | ((unsigned long )*((buffer + 68) + 1) << 16)) | ((unsigned long )*((buffer + 68) + 2) << 8)) | (unsigned long )*((buffer + 68) + 3);
#line 119
  r->SR = (unsigned long )((unsigned short )(((int )*((buffer + 72) + 0) << 8) | (int )*((buffer + 72) + 1)));
#line 121
  return (0);
}
}
#line 136 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
static int sys_PackRegisters(void *data , struct Pilot_registers *r ) 
{ 
  int idx ;
  unsigned char *buffer ;

  {
#line 140
  buffer = (unsigned char *)data;
#line 142
  idx = 0;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (idx < 8)) {
#line 142
      goto while_break;
    }
#line 143
    *((buffer + idx * 4) + 0) = (unsigned char )((int )((unsigned char )(r->D[idx] >> 24)) & 255);
#line 143
    *((buffer + idx * 4) + 1) = (unsigned char )((r->D[idx] >> 16) & 255UL);
#line 143
    *((buffer + idx * 4) + 2) = (unsigned char )((r->D[idx] >> 8) & 255UL);
#line 143
    *((buffer + idx * 4) + 3) = (unsigned char )(r->D[idx] & 255UL);
#line 142
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  idx = 0;
  {
#line 144
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 144
    if (! (idx < 7)) {
#line 144
      goto while_break___0;
    }
#line 145
    *(((buffer + 32) + idx * 4) + 0) = (unsigned char )((int )((unsigned char )(r->A[idx] >> 24)) & 255);
#line 145
    *(((buffer + 32) + idx * 4) + 1) = (unsigned char )((r->A[idx] >> 16) & 255UL);
#line 145
    *(((buffer + 32) + idx * 4) + 2) = (unsigned char )((r->A[idx] >> 8) & 255UL);
#line 145
    *(((buffer + 32) + idx * 4) + 3) = (unsigned char )(r->A[idx] & 255UL);
#line 144
    idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 146
  *((buffer + 60) + 0) = (unsigned char )((int )((unsigned char )(r->USP >> 24)) & 255);
#line 146
  *((buffer + 60) + 1) = (unsigned char )((r->USP >> 16) & 255UL);
#line 146
  *((buffer + 60) + 2) = (unsigned char )((r->USP >> 8) & 255UL);
#line 146
  *((buffer + 60) + 3) = (unsigned char )(r->USP & 255UL);
#line 147
  *((buffer + 64) + 0) = (unsigned char )((int )((unsigned char )(r->SSP >> 24)) & 255);
#line 147
  *((buffer + 64) + 1) = (unsigned char )((r->SSP >> 16) & 255UL);
#line 147
  *((buffer + 64) + 2) = (unsigned char )((r->SSP >> 8) & 255UL);
#line 147
  *((buffer + 64) + 3) = (unsigned char )(r->SSP & 255UL);
#line 148
  *((buffer + 68) + 0) = (unsigned char )((int )((unsigned char )(r->PC >> 24)) & 255);
#line 148
  *((buffer + 68) + 1) = (unsigned char )((r->PC >> 16) & 255UL);
#line 148
  *((buffer + 68) + 2) = (unsigned char )((r->PC >> 8) & 255UL);
#line 148
  *((buffer + 68) + 3) = (unsigned char )(r->PC & 255UL);
#line 150
  *((buffer + 72) + 0) = (unsigned char )(((int )((unsigned short )r->SR) >> 8) & 255);
#line 150
  *((buffer + 72) + 1) = (unsigned char )((int )((unsigned short )r->SR) & 255);
#line 152
  return (0);
}
}
#line 166 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
int sys_Continue(int sd , struct Pilot_registers *r , struct Pilot_watch *w ) 
{ 
  char buf___3[94] ;
  ssize_t tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  ssize_t tmp___12 ;

  {
#line 171
  buf___3[0] = (char)0;
#line 172
  buf___3[1] = (char)0;
#line 173
  buf___3[2] = (char)0;
#line 174
  buf___3[3] = (char)0;
#line 175
  buf___3[4] = (char)7;
#line 176
  buf___3[5] = (char)0;
#line 178
  if (! r) {
    {
#line 179
    tmp = pi_write(sd, (void const   *)(buf___3), (size_t )6);
    }
#line 179
    return ((int )tmp);
  }
  {
#line 181
  sys_PackRegisters((void *)(buf___3 + 6), r);
  }
#line 182
  if ((unsigned long )w != (unsigned long )((struct Pilot_watch *)0)) {
#line 182
    *((unsigned char *)(buf___3 + 80) + 0) = (unsigned char)1;
  } else {
#line 182
    *((unsigned char *)(buf___3 + 80) + 0) = (unsigned char)0;
  }
#line 183
  *((unsigned char *)(buf___3 + 81) + 0) = (unsigned char)0;
#line 184
  if (w) {
#line 184
    tmp___0 = w->address;
  } else {
#line 184
    tmp___0 = 0UL;
  }
#line 184
  *((unsigned char *)(buf___3 + 82) + 0) = (unsigned char )((int )((unsigned char )(tmp___0 >> 24)) & 255);
#line 184
  if (w) {
#line 184
    tmp___1 = w->address;
  } else {
#line 184
    tmp___1 = 0UL;
  }
#line 184
  *((unsigned char *)(buf___3 + 82) + 1) = (unsigned char )((tmp___1 >> 16) & 255UL);
#line 184
  if (w) {
#line 184
    tmp___2 = w->address;
  } else {
#line 184
    tmp___2 = 0UL;
  }
#line 184
  *((unsigned char *)(buf___3 + 82) + 2) = (unsigned char )((tmp___2 >> 8) & 255UL);
#line 184
  if (w) {
#line 184
    tmp___3 = w->address;
  } else {
#line 184
    tmp___3 = 0UL;
  }
#line 184
  *((unsigned char *)(buf___3 + 82) + 3) = (unsigned char )(tmp___3 & 255UL);
#line 185
  if (w) {
#line 185
    tmp___4 = w->length;
  } else {
#line 185
    tmp___4 = 0UL;
  }
#line 185
  *((unsigned char *)(buf___3 + 86) + 0) = (unsigned char )((int )((unsigned char )(tmp___4 >> 24)) & 255);
#line 185
  if (w) {
#line 185
    tmp___5 = w->length;
  } else {
#line 185
    tmp___5 = 0UL;
  }
#line 185
  *((unsigned char *)(buf___3 + 86) + 1) = (unsigned char )((tmp___5 >> 16) & 255UL);
#line 185
  if (w) {
#line 185
    tmp___6 = w->length;
  } else {
#line 185
    tmp___6 = 0UL;
  }
#line 185
  *((unsigned char *)(buf___3 + 86) + 2) = (unsigned char )((tmp___6 >> 8) & 255UL);
#line 185
  if (w) {
#line 185
    tmp___7 = w->length;
  } else {
#line 185
    tmp___7 = 0UL;
  }
#line 185
  *((unsigned char *)(buf___3 + 86) + 3) = (unsigned char )(tmp___7 & 255UL);
#line 186
  if (w) {
#line 186
    tmp___8 = w->checksum;
  } else {
#line 186
    tmp___8 = 0UL;
  }
#line 186
  *((unsigned char *)(buf___3 + 90) + 0) = (unsigned char )((int )((unsigned char )(tmp___8 >> 24)) & 255);
#line 186
  if (w) {
#line 186
    tmp___9 = w->checksum;
  } else {
#line 186
    tmp___9 = 0UL;
  }
#line 186
  *((unsigned char *)(buf___3 + 90) + 1) = (unsigned char )((tmp___9 >> 16) & 255UL);
#line 186
  if (w) {
#line 186
    tmp___10 = w->checksum;
  } else {
#line 186
    tmp___10 = 0UL;
  }
#line 186
  *((unsigned char *)(buf___3 + 90) + 2) = (unsigned char )((tmp___10 >> 8) & 255UL);
#line 186
  if (w) {
#line 186
    tmp___11 = w->checksum;
  } else {
#line 186
    tmp___11 = 0UL;
  }
  {
#line 186
  *((unsigned char *)(buf___3 + 90) + 3) = (unsigned char )(tmp___11 & 255UL);
#line 188
  tmp___12 = pi_write(sd, (void const   *)(buf___3), (size_t )94);
  }
#line 188
  return ((int )tmp___12);
}
}
#line 202 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
int sys_Step(int sd ) 
{ 
  char buf___3[94] ;
  ssize_t tmp ;

  {
  {
#line 207
  buf___3[0] = (char)0;
#line 208
  buf___3[1] = (char)0;
#line 209
  buf___3[2] = (char)0;
#line 210
  buf___3[3] = (char)0;
#line 211
  buf___3[4] = (char)3;
#line 212
  buf___3[5] = (char)0;
#line 214
  tmp = pi_write(sd, (void const   *)(buf___3), (size_t )6);
  }
#line 214
  return ((int )tmp);
}
}
#line 228 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
int sys_SetBreakpoints(int sd , struct Pilot_breakpoint *b ) 
{ 
  int idx ;
  pi_buffer_t *buf___3 ;
  int *tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 234
  buf___3 = pi_buffer_new((size_t )94);
  }
#line 235
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
    {
#line 236
    tmp = __errno_location();
#line 236
    *tmp = 12;
#line 237
    tmp___0 = pi_set_error(sd, -500);
    }
#line 237
    return (tmp___0);
  }
#line 240
  *(buf___3->data + 0) = (unsigned char)0;
#line 241
  *(buf___3->data + 1) = (unsigned char)0;
#line 242
  *(buf___3->data + 2) = (unsigned char)0;
#line 243
  *(buf___3->data + 3) = (unsigned char)0;
#line 244
  *(buf___3->data + 4) = (unsigned char)12;
#line 245
  *(buf___3->data + 5) = (unsigned char)0;
#line 247
  idx = 0;
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (idx < 6)) {
#line 247
      goto while_break;
    }
#line 248
    *(((buf___3->data + 6) + idx * 6) + 0) = (unsigned char )((int )((unsigned char )((b + idx)->address >> 24)) & 255);
#line 248
    *(((buf___3->data + 6) + idx * 6) + 1) = (unsigned char )(((b + idx)->address >> 16) & 255UL);
#line 248
    *(((buf___3->data + 6) + idx * 6) + 2) = (unsigned char )(((b + idx)->address >> 8) & 255UL);
#line 248
    *(((buf___3->data + 6) + idx * 6) + 3) = (unsigned char )((b + idx)->address & 255UL);
#line 249
    *(((buf___3->data + 10) + idx * 6) + 0) = (unsigned char )(b + idx)->enabled;
#line 250
    *(((buf___3->data + 11) + idx * 6) + 0) = (unsigned char)0;
#line 247
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 253
  pi_write(sd, (void const   *)buf___3->data, (size_t )42);
#line 255
  tmp___1 = pi_read(sd, buf___3, (size_t )6);
#line 255
  idx = (int )tmp___1;
  }
#line 257
  if (idx <= 0) {
    {
#line 258
    pi_buffer_free(buf___3);
    }
#line 259
    return (0);
  } else
#line 257
  if ((int )*(buf___3->data + 4) != 140) {
    {
#line 258
    pi_buffer_free(buf___3);
    }
#line 259
    return (0);
  }
  {
#line 262
  pi_buffer_free(buf___3);
  }
#line 263
  return (1);
}
}
#line 277 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
int sys_SetTrapBreaks(int sd , int *traps ) 
{ 
  int idx ;
  pi_buffer_t *buf___3 ;
  int *tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 283
  buf___3 = pi_buffer_new((size_t )32);
  }
#line 284
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
    {
#line 285
    tmp = __errno_location();
#line 285
    *tmp = 12;
#line 286
    tmp___0 = pi_set_error(sd, -500);
    }
#line 286
    return (tmp___0);
  }
#line 289
  *(buf___3->data + 0) = (unsigned char)0;
#line 290
  *(buf___3->data + 1) = (unsigned char)0;
#line 291
  *(buf___3->data + 2) = (unsigned char)0;
#line 292
  *(buf___3->data + 3) = (unsigned char)0;
#line 293
  *(buf___3->data + 4) = (unsigned char)17;
#line 294
  *(buf___3->data + 5) = (unsigned char)0;
#line 296
  idx = 0;
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! (idx < 5)) {
#line 296
      goto while_break;
    }
#line 297
    *(((buf___3->data + 6) + idx * 2) + 0) = (unsigned char )(((int )((unsigned short )*(traps + idx)) >> 8) & 255);
#line 297
    *(((buf___3->data + 6) + idx * 2) + 1) = (unsigned char )((int )((unsigned short )*(traps + idx)) & 255);
#line 296
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 300
  pi_write(sd, (void const   *)buf___3->data, (size_t )16);
#line 302
  tmp___1 = pi_read(sd, buf___3, (size_t )6);
#line 302
  idx = (int )tmp___1;
  }
#line 304
  if (idx <= 0) {
    {
#line 305
    pi_buffer_free(buf___3);
    }
#line 306
    return (0);
  } else
#line 304
  if ((int )*(buf___3->data + 4) != 145) {
    {
#line 305
    pi_buffer_free(buf___3);
    }
#line 306
    return (0);
  }
  {
#line 309
  pi_buffer_free(buf___3);
  }
#line 310
  return (1);
}
}
#line 324 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
int sys_GetTrapBreaks(int sd , int *traps ) 
{ 
  int idx ;
  pi_buffer_t *buf___3 ;
  int *tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 330
  buf___3 = pi_buffer_new((size_t )32);
  }
#line 331
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
    {
#line 332
    tmp = __errno_location();
#line 332
    *tmp = 12;
#line 333
    tmp___0 = pi_set_error(sd, -500);
    }
#line 333
    return (tmp___0);
  }
  {
#line 336
  *(buf___3->data + 0) = (unsigned char)0;
#line 337
  *(buf___3->data + 1) = (unsigned char)0;
#line 338
  *(buf___3->data + 2) = (unsigned char)0;
#line 339
  *(buf___3->data + 3) = (unsigned char)0;
#line 340
  *(buf___3->data + 4) = (unsigned char)16;
#line 341
  *(buf___3->data + 5) = (unsigned char)0;
#line 343
  pi_write(sd, (void const   *)buf___3->data, (size_t )6);
#line 345
  tmp___1 = pi_read(sd, buf___3, (size_t )16);
#line 345
  idx = (int )tmp___1;
  }
#line 347
  if (idx < 16) {
    {
#line 348
    pi_buffer_free(buf___3);
    }
#line 349
    return (0);
  } else
#line 347
  if ((int )*(buf___3->data + 4) != 144) {
    {
#line 348
    pi_buffer_free(buf___3);
    }
#line 349
    return (0);
  }
#line 352
  idx = 0;
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! (idx < 5)) {
#line 352
      goto while_break;
    }
#line 353
    *(traps + idx) = (int )((unsigned short )(((int )*(((buf___3->data + 6) + idx * 2) + 0) << 8) | (int )*(((buf___3->data + 6) + idx * 2) + 1)));
#line 352
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 356
  pi_buffer_free(buf___3);
  }
#line 357
  return (1);
}
}
#line 372 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
int sys_ToggleDbgBreaks(int sd ) 
{ 
  int idx ;
  pi_buffer_t *buf___3 ;
  unsigned char byte ;
  int *tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 379
  buf___3 = pi_buffer_new((size_t )32);
  }
#line 380
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
    {
#line 381
    tmp = __errno_location();
#line 381
    *tmp = 12;
#line 382
    tmp___0 = pi_set_error(sd, -500);
    }
#line 382
    return (tmp___0);
  }
  {
#line 385
  *(buf___3->data + 0) = (unsigned char)0;
#line 386
  *(buf___3->data + 1) = (unsigned char)0;
#line 387
  *(buf___3->data + 2) = (unsigned char)0;
#line 388
  *(buf___3->data + 3) = (unsigned char)0;
#line 389
  *(buf___3->data + 4) = (unsigned char)13;
#line 390
  *(buf___3->data + 5) = (unsigned char)0;
#line 392
  pi_write(sd, (void const   *)buf___3->data, (size_t )6);
#line 394
  tmp___1 = pi_read(sd, buf___3, (size_t )7);
#line 394
  idx = (int )tmp___1;
  }
#line 396
  if (idx < 7) {
    {
#line 397
    pi_buffer_free(buf___3);
    }
#line 398
    return (0);
  } else
#line 396
  if ((int )*(buf___3->data + 4) != 141) {
    {
#line 397
    pi_buffer_free(buf___3);
    }
#line 398
    return (0);
  }
  {
#line 401
  byte = *((buf___3->data + 6) + 0);
#line 403
  pi_buffer_free(buf___3);
  }
#line 405
  return ((int )byte);
}
}
#line 420 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
int sys_QueryState(int sd ) 
{ 
  char buf___3[6] ;
  ssize_t tmp ;

  {
  {
#line 425
  buf___3[0] = (char)0;
#line 426
  buf___3[1] = (char)0;
#line 427
  buf___3[2] = (char)0;
#line 428
  buf___3[3] = (char)0;
#line 429
  buf___3[4] = (char)0;
#line 430
  buf___3[5] = (char)0;
#line 432
  tmp = pi_write(sd, (void const   *)(buf___3), (size_t )2);
  }
#line 432
  return ((int )tmp);
}
}
#line 446 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
int sys_ReadMemory(int sd , unsigned long addr , unsigned long len , void *dest ) 
{ 
  int result ;
  unsigned long todo ;
  unsigned long done ;
  pi_buffer_t *buf___3 ;
  int *tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 453
  buf___3 = pi_buffer_new((size_t )65535);
  }
#line 454
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
    {
#line 455
    tmp = __errno_location();
#line 455
    *tmp = 12;
#line 456
    tmp___0 = pi_set_error(sd, -500);
    }
#line 456
    return (tmp___0);
  }
#line 459
  done = 0UL;
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    todo = len;
#line 462
    if (todo > 256UL) {
#line 463
      todo = 256UL;
    }
    {
#line 465
    *(buf___3->data + 0) = (unsigned char)0;
#line 466
    *(buf___3->data + 1) = (unsigned char)0;
#line 467
    *(buf___3->data + 2) = (unsigned char)0;
#line 468
    *(buf___3->data + 3) = (unsigned char)0;
#line 469
    *(buf___3->data + 4) = (unsigned char)1;
#line 470
    *(buf___3->data + 5) = (unsigned char)0;
#line 472
    *((buf___3->data + 6) + 0) = (unsigned char )((int )((unsigned char )((addr + done) >> 24)) & 255);
#line 472
    *((buf___3->data + 6) + 1) = (unsigned char )(((addr + done) >> 16) & 255UL);
#line 472
    *((buf___3->data + 6) + 2) = (unsigned char )(((addr + done) >> 8) & 255UL);
#line 472
    *((buf___3->data + 6) + 3) = (unsigned char )((addr + done) & 255UL);
#line 473
    *((buf___3->data + 10) + 0) = (unsigned char )(((int )((unsigned short )todo) >> 8) & 255);
#line 473
    *((buf___3->data + 10) + 1) = (unsigned char )((int )((unsigned short )todo) & 255);
#line 475
    pi_write(sd, (void const   *)buf___3->data, (size_t )12);
#line 477
    tmp___1 = pi_read(sd, buf___3, todo + 6UL);
#line 477
    result = (int )tmp___1;
    }
#line 479
    if (result < 0) {
      {
#line 480
      pi_buffer_free(buf___3);
      }
#line 481
      return ((int )done);
    }
#line 484
    if ((int )*(buf___3->data + 4) == 129) {
#line 484
      if ((unsigned long )((unsigned int )result) == todo + 6UL) {
        {
#line 486
        memcpy((void */* __restrict  */)((char *)dest + done), (void const   */* __restrict  */)(buf___3->data + 6),
               todo);
#line 487
        done += todo;
        }
      } else {
        {
#line 489
        pi_buffer_free(buf___3);
        }
#line 490
        return ((int )done);
      }
    } else {
      {
#line 489
      pi_buffer_free(buf___3);
      }
#line 490
      return ((int )done);
    }
#line 460
    if (! (done < len)) {
#line 460
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 494
  pi_buffer_free(buf___3);
  }
#line 495
  return ((int )done);
}
}
#line 510 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
int sys_WriteMemory(int sd , unsigned long addr , unsigned long len , void *src ) 
{ 
  int result ;
  unsigned long todo ;
  unsigned long done ;
  pi_buffer_t *buf___3 ;
  int *tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 517
  buf___3 = pi_buffer_new((size_t )65535);
  }
#line 518
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
    {
#line 519
    tmp = __errno_location();
#line 519
    *tmp = 12;
#line 520
    tmp___0 = pi_set_error(sd, -500);
    }
#line 520
    return (tmp___0);
  }
#line 523
  done = 0UL;
  {
#line 524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    todo = len;
#line 526
    if (todo > 256UL) {
#line 527
      todo = 256UL;
    }
    {
#line 529
    *(buf___3->data + 0) = (unsigned char)0;
#line 530
    *(buf___3->data + 1) = (unsigned char)0;
#line 531
    *(buf___3->data + 2) = (unsigned char)0;
#line 532
    *(buf___3->data + 3) = (unsigned char)0;
#line 533
    *(buf___3->data + 4) = (unsigned char)2;
#line 534
    *(buf___3->data + 5) = (unsigned char)0;
#line 536
    *((buf___3->data + 6) + 0) = (unsigned char )((int )((unsigned char )(addr >> 24)) & 255);
#line 536
    *((buf___3->data + 6) + 1) = (unsigned char )((addr >> 16) & 255UL);
#line 536
    *((buf___3->data + 6) + 2) = (unsigned char )((addr >> 8) & 255UL);
#line 536
    *((buf___3->data + 6) + 3) = (unsigned char )(addr & 255UL);
#line 537
    *((buf___3->data + 10) + 0) = (unsigned char )(((int )((unsigned short )len) >> 8) & 255);
#line 537
    *((buf___3->data + 10) + 1) = (unsigned char )((int )((unsigned short )len) & 255);
#line 538
    memcpy((void */* __restrict  */)(buf___3->data + 12), (void const   */* __restrict  */)((char *)src + done),
           todo);
#line 540
    pi_write(sd, (void const   *)buf___3->data, len + 12UL);
#line 542
    tmp___1 = pi_read(sd, buf___3, (size_t )6);
#line 542
    result = (int )tmp___1;
    }
#line 544
    if (result < 0) {
      {
#line 545
      pi_buffer_free(buf___3);
      }
#line 546
      return ((int )done);
    }
#line 549
    if ((int )*(buf___3->data + 4) == 130) {
#line 549
      if (! ((unsigned long )result == todo + 6UL)) {
        {
#line 553
        pi_buffer_free(buf___3);
        }
#line 554
        return ((int )done);
      }
    } else {
      {
#line 553
      pi_buffer_free(buf___3);
      }
#line 554
      return ((int )done);
    }
#line 524
    if (! (done < len)) {
#line 524
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 558
  pi_buffer_free(buf___3);
  }
#line 559
  return ((int )done);
}
}
#line 574 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
int sys_Find(int sd , unsigned long startaddr , unsigned long stopaddr , size_t len ,
             int caseinsensitive , void *data , unsigned long *found ) 
{ 
  int result ;
  unsigned char byte ;
  pi_buffer_t *buf___3 ;
  int *tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 582
  buf___3 = pi_buffer_new(len + 17UL);
  }
#line 583
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
    {
#line 584
    tmp = __errno_location();
#line 584
    *tmp = 12;
#line 585
    tmp___0 = pi_set_error(sd, -500);
    }
#line 585
    return (tmp___0);
  }
  {
#line 588
  *(buf___3->data + 0) = (unsigned char)0;
#line 589
  *(buf___3->data + 1) = (unsigned char)0;
#line 590
  *(buf___3->data + 2) = (unsigned char)0;
#line 591
  *(buf___3->data + 3) = (unsigned char)0;
#line 592
  *(buf___3->data + 4) = (unsigned char)17;
#line 593
  *(buf___3->data + 5) = (unsigned char)0;
#line 595
  *((buf___3->data + 6) + 0) = (unsigned char )((int )((unsigned char )(startaddr >> 24)) & 255);
#line 595
  *((buf___3->data + 6) + 1) = (unsigned char )((startaddr >> 16) & 255UL);
#line 595
  *((buf___3->data + 6) + 2) = (unsigned char )((startaddr >> 8) & 255UL);
#line 595
  *((buf___3->data + 6) + 3) = (unsigned char )(startaddr & 255UL);
#line 596
  *((buf___3->data + 10) + 0) = (unsigned char )((int )((unsigned char )(stopaddr >> 24)) & 255);
#line 596
  *((buf___3->data + 10) + 1) = (unsigned char )((stopaddr >> 16) & 255UL);
#line 596
  *((buf___3->data + 10) + 2) = (unsigned char )((stopaddr >> 8) & 255UL);
#line 596
  *((buf___3->data + 10) + 3) = (unsigned char )(stopaddr & 255UL);
#line 597
  *((buf___3->data + 14) + 0) = (unsigned char )(((int )((unsigned short )len) >> 8) & 255);
#line 597
  *((buf___3->data + 14) + 1) = (unsigned char )((int )((unsigned short )len) & 255);
#line 598
  *((buf___3->data + 16) + 0) = (unsigned char )caseinsensitive;
#line 599
  memcpy((void */* __restrict  */)(buf___3->data + 17), (void const   */* __restrict  */)data,
         len);
#line 601
  pi_write(sd, (void const   *)buf___3->data, len + 17UL);
#line 603
  tmp___1 = pi_read(sd, buf___3, (size_t )12);
#line 603
  result = (int )tmp___1;
  }
#line 605
  if (result < 0) {
    {
#line 606
    pi_buffer_free(buf___3);
    }
#line 607
    return (result);
  }
#line 610
  if (found) {
#line 611
    *found = ((((unsigned long )*((buf___3->data + 6) + 0) << 24) | ((unsigned long )*((buf___3->data + 6) + 1) << 16)) | ((unsigned long )*((buf___3->data + 6) + 2) << 8)) | (unsigned long )*((buf___3->data + 6) + 3);
  }
  {
#line 613
  byte = *((buf___3->data + 10) + 0);
#line 615
  pi_buffer_free(buf___3);
  }
#line 617
  return ((int )byte);
}
}
#line 633 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
int sys_RemoteEvent(int sd , int penDown , int x , int y , int keypressed , int keymod ,
                    int keyasc , int keycode ) 
{ 
  char buf___3[16] ;
  ssize_t tmp ;

  {
  {
#line 640
  *((unsigned char *)(& buf___3[0]) + 0) = (unsigned char)13;
#line 641
  *((unsigned char *)(& buf___3[1]) + 0) = (unsigned char)0;
#line 642
  *((unsigned char *)(& buf___3[2]) + 0) = (unsigned char )penDown;
#line 643
  *((unsigned char *)(& buf___3[3]) + 0) = (unsigned char)0;
#line 644
  *((unsigned char *)(& buf___3[4]) + 0) = (unsigned char )(((int )((unsigned short )x) >> 8) & 255);
#line 644
  *((unsigned char *)(& buf___3[4]) + 1) = (unsigned char )((int )((unsigned short )x) & 255);
#line 645
  *((unsigned char *)(& buf___3[6]) + 0) = (unsigned char )(((int )((unsigned short )y) >> 8) & 255);
#line 645
  *((unsigned char *)(& buf___3[6]) + 1) = (unsigned char )((int )((unsigned short )y) & 255);
#line 646
  *((unsigned char *)(& buf___3[8]) + 0) = (unsigned char )keypressed;
#line 647
  *((unsigned char *)(& buf___3[9]) + 0) = (unsigned char)0;
#line 648
  *((unsigned char *)(& buf___3[10]) + 0) = (unsigned char )(((int )((unsigned short )keymod) >> 8) & 255);
#line 648
  *((unsigned char *)(& buf___3[10]) + 1) = (unsigned char )((int )((unsigned short )keymod) & 255);
#line 649
  *((unsigned char *)(& buf___3[12]) + 0) = (unsigned char )(((int )((unsigned short )keyasc) >> 8) & 255);
#line 649
  *((unsigned char *)(& buf___3[12]) + 1) = (unsigned char )((int )((unsigned short )keyasc) & 255);
#line 650
  *((unsigned char *)(& buf___3[14]) + 0) = (unsigned char )(((int )((unsigned short )keycode) >> 8) & 255);
#line 650
  *((unsigned char *)(& buf___3[14]) + 1) = (unsigned char )((int )((unsigned short )keycode) & 255);
#line 652
  tmp = pi_write(sd, (void const   *)(buf___3), (size_t )16);
  }
#line 652
  return ((int )tmp);
}
}
#line 667 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
int sys_RPC(int sd , int sockaddr , int trap , long *D0 , long *A0 , int params ,
            struct RPC_param *param , int reply ) 
{ 
  int idx ;
  unsigned char *c ;
  pi_buffer_t *buf___3 ;
  int *tmp ;
  int tmp___0 ;
  unsigned char *tmp___1 ;
  int l ;
  ssize_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 675
  buf___3 = pi_buffer_new((size_t )4096);
  }
#line 676
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
    {
#line 677
    tmp = __errno_location();
#line 677
    *tmp = 12;
#line 678
    tmp___0 = pi_set_error(sd, -500);
    }
#line 678
    return (tmp___0);
  }
#line 681
  *(buf___3->data + 0) = (unsigned char )sockaddr;
#line 682
  *(buf___3->data + 1) = (unsigned char )sockaddr;
#line 683
  *(buf___3->data + 2) = (unsigned char)0;
#line 684
  *(buf___3->data + 4) = (unsigned char)10;
#line 685
  *(buf___3->data + 5) = (unsigned char)0;
#line 687
  *((buf___3->data + 6) + 0) = (unsigned char )(((int )((unsigned short )trap) >> 8) & 255);
#line 687
  *((buf___3->data + 6) + 1) = (unsigned char )((int )((unsigned short )trap) & 255);
#line 688
  *((buf___3->data + 8) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )*D0 >> 24)) & 255);
#line 688
  *((buf___3->data + 8) + 1) = (unsigned char )(((unsigned long )*D0 >> 16) & 255UL);
#line 688
  *((buf___3->data + 8) + 2) = (unsigned char )(((unsigned long )*D0 >> 8) & 255UL);
#line 688
  *((buf___3->data + 8) + 3) = (unsigned char )((unsigned long )*D0 & 255UL);
#line 689
  *((buf___3->data + 12) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )*A0 >> 24)) & 255);
#line 689
  *((buf___3->data + 12) + 1) = (unsigned char )(((unsigned long )*A0 >> 16) & 255UL);
#line 689
  *((buf___3->data + 12) + 2) = (unsigned char )(((unsigned long )*A0 >> 8) & 255UL);
#line 689
  *((buf___3->data + 12) + 3) = (unsigned char )((unsigned long )*A0 & 255UL);
#line 690
  *((buf___3->data + 16) + 0) = (unsigned char )(((int )((unsigned short )params) >> 8) & 255);
#line 690
  *((buf___3->data + 16) + 1) = (unsigned char )((int )((unsigned short )params) & 255);
#line 692
  c = buf___3->data + 18;
#line 693
  idx = params - 1;
  {
#line 693
  while (1) {
    while_continue: /* CIL Label */ ;
#line 693
    if (! (idx >= 0)) {
#line 693
      goto while_break;
    }
#line 694
    *(c + 0) = (unsigned char )(param + idx)->byRef;
#line 695
    c ++;
#line 696
    *(c + 0) = (unsigned char )(param + idx)->size;
#line 697
    c ++;
#line 698
    if ((param + idx)->data) {
      {
#line 699
      memcpy((void */* __restrict  */)c, (void const   */* __restrict  */)(param + idx)->data,
             (param + idx)->size);
      }
    }
#line 700
    c += (param + idx)->size;
#line 701
    if ((param + idx)->size & 1UL) {
#line 702
      tmp___1 = c;
#line 702
      c ++;
#line 702
      *tmp___1 = (unsigned char)0;
    }
#line 693
    idx --;
  }
  while_break: /* CIL Label */ ;
  }
#line 705
  if (sockaddr == 3) {
#line 706
    *((buf___3->data + 4) + 0) = (unsigned char )(((int )((unsigned short )((c - buf___3->data) - 6L)) >> 8) & 255);
#line 706
    *((buf___3->data + 4) + 1) = (unsigned char )((int )((unsigned short )((c - buf___3->data) - 6L)) & 255);
  }
  {
#line 708
  pi_write(sd, (void const   *)(buf___3->data + 4), (size_t )((c - buf___3->data) - 4L));
  }
#line 710
  if (reply) {
    {
#line 711
    tmp___2 = pi_read(sd, buf___3, (size_t )4096);
#line 711
    l = (int )tmp___2;
    }
#line 713
    if (l < 0) {
      {
#line 714
      pi_buffer_free(buf___3);
      }
#line 715
      return (l);
    }
#line 718
    if ((int )*(buf___3->data + 0) != 138) {
      {
#line 719
      pi_buffer_free(buf___3);
#line 720
      tmp___3 = pi_set_error(sd, -2);
      }
#line 720
      return (tmp___3);
    }
#line 723
    *D0 = (long )(((((unsigned long )*((buf___3->data + 4) + 0) << 24) | ((unsigned long )*((buf___3->data + 4) + 1) << 16)) | ((unsigned long )*((buf___3->data + 4) + 2) << 8)) | (unsigned long )*((buf___3->data + 4) + 3));
#line 724
    *A0 = (long )(((((unsigned long )*((buf___3->data + 8) + 0) << 24) | ((unsigned long )*((buf___3->data + 8) + 1) << 16)) | ((unsigned long )*((buf___3->data + 8) + 2) << 8)) | (unsigned long )*((buf___3->data + 8) + 3));
#line 725
    c = buf___3->data + 14;
#line 726
    idx = params - 1;
    {
#line 726
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 726
      if (! (idx >= 0)) {
#line 726
        goto while_break___0;
      }
#line 727
      if ((param + idx)->byRef) {
#line 727
        if ((param + idx)->data) {
          {
#line 728
          memcpy((void */* __restrict  */)(param + idx)->data, (void const   */* __restrict  */)(c + 2),
                 (param + idx)->size);
          }
        }
      }
#line 730
      c += 2 + (((int )*((c + 1) + 0) + 1) & -2);
#line 726
      idx --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 734
  pi_buffer_free(buf___3);
  }
#line 735
  return (0);
}
}
#line 750 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
int RPC(int sd , int sockaddr , int trap , int reply  , ...) 
{ 
  int idx ;
  int j ;
  int RPC_arg[20] ;
  va_list ap ;
  struct RPC_param p[20] ;
  long D0 ;
  long A0 ;
  int type ;
  int tmp___0 ;
  int tmp___1 ;
  void *c ;
  void *tmp___3 ;
  int tmp___4 ;
  int *s ;
  uint16_t tmp___5 ;
  int *l ;
  uint32_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *c___0 ;
  int *s___0 ;
  uint16_t tmp___9 ;
  int *l___0 ;
  uint32_t tmp___10 ;

  {
  {
#line 753
  idx = 0;
#line 758
  D0 = 0L;
#line 758
  A0 = 0L;
#line 761
  __builtin_va_start(ap, reply);
  }
  {
#line 762
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 763
    tmp___0 = __builtin_va_arg(ap, int );
#line 763
    type = tmp___0;
    }
#line 765
    if (type == 0) {
#line 766
      goto while_break;
    }
#line 767
    if (type < 0) {
      {
#line 768
      p[idx].byRef = 0;
#line 769
      p[idx].size = (size_t )(- type);
#line 770
      tmp___1 = __builtin_va_arg(ap, int );
#line 770
      RPC_arg[idx] = tmp___1;
#line 772
      p[idx].data = (void *)(& RPC_arg[idx]);
#line 773
      p[idx].invert = 0;
      }
    } else {
      {
#line 775
      tmp___3 = __builtin_va_arg(ap, void *);
#line 775
      c = tmp___3;
#line 777
      p[idx].byRef = 1;
#line 778
      p[idx].size = (size_t )type;
#line 779
      p[idx].data = c;
#line 780
      tmp___4 = __builtin_va_arg(ap, int );
#line 780
      p[idx].invert = tmp___4;
      }
#line 782
      if (p[idx].invert) {
#line 783
        if (p[idx].size == 2UL) {
          {
#line 784
          s = (int *)c;
#line 786
          tmp___5 = htons((uint16_t )*s);
#line 786
          *s = (int )tmp___5;
          }
        } else {
          {
#line 788
          l = (int *)c;
#line 790
          tmp___6 = htonl((uint32_t )*l);
#line 790
          *l = (int )tmp___6;
          }
        }
      }
    }
#line 794
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 796
  __builtin_va_end(ap);
#line 798
  tmp___8 = sys_RPC(sd, sockaddr, trap, & D0, & A0, idx, p, reply != 2);
  }
#line 798
  if (tmp___8 < 0) {
    {
#line 799
    tmp___7 = pi_error(sd);
    }
#line 799
    return (tmp___7);
  }
#line 801
  j = 0;
  {
#line 801
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 801
    if (! (j < idx)) {
#line 801
      goto while_break___0;
    }
#line 802
    if (p[j].invert) {
#line 803
      c___0 = p[j].data;
#line 805
      if (p[j].size == 2UL) {
        {
#line 806
        s___0 = (int *)c___0;
#line 808
        tmp___9 = htons((uint16_t )*s___0);
#line 808
        *s___0 = (int )tmp___9;
        }
      } else {
        {
#line 810
        l___0 = (int *)c___0;
#line 812
        tmp___10 = htonl((uint32_t )*l___0);
#line 812
        *l___0 = (int )tmp___10;
        }
      }
    }
#line 801
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 817
  if (reply) {
#line 818
    return ((int )A0);
  }
#line 819
  return ((int )D0);
}
}
#line 834 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
int PackRPC(struct RPC_params *p , int trap , int reply  , ...) 
{ 
  int idx ;
  va_list ap ;
  int type ;
  int tmp___0 ;
  int tmp___2 ;
  void *c ;
  void *tmp___4 ;
  int tmp___6 ;

  {
  {
#line 837
  idx = 0;
#line 840
  p->trap = trap;
#line 841
  p->reply = reply;
#line 843
  __builtin_va_start(ap, reply);
  }
  {
#line 844
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 845
    tmp___0 = __builtin_va_arg(ap, int );
#line 845
    type = tmp___0;
    }
#line 847
    if (type == 0) {
#line 848
      goto while_break;
    }
#line 849
    if (type < 0) {
      {
#line 850
      p->param[idx].byRef = 0;
#line 851
      p->param[idx].size = (size_t )(- type);
#line 852
      tmp___2 = __builtin_va_arg(ap, int );
#line 852
      p->param[idx].arg = tmp___2;
#line 854
      p->param[idx].data = (void *)(& p->param[idx].arg);
#line 855
      p->param[idx].invert = 0;
      }
    } else {
      {
#line 857
      tmp___4 = __builtin_va_arg(ap, void *);
#line 857
      c = tmp___4;
#line 859
      p->param[idx].byRef = 1;
#line 860
      p->param[idx].size = (size_t )type;
#line 861
      p->param[idx].data = c;
#line 862
      tmp___6 = __builtin_va_arg(ap, int );
#line 862
      p->param[idx].invert = tmp___6;
      }
    }
#line 864
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 866
  p->args = idx;
#line 867
  __builtin_va_end(ap);
  }
#line 869
  return (0);
}
}
#line 884 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
void UninvertRPC(struct RPC_params *p ) 
{ 
  int j ;
  void *c ;
  int *s ;
  uint16_t tmp ;
  int *s___0 ;
  uint16_t tmp___0 ;
  long *l ;
  uint32_t tmp___1 ;

  {
#line 889
  j = 0;
  {
#line 889
  while (1) {
    while_continue: /* CIL Label */ ;
#line 889
    if (! (j < p->args)) {
#line 889
      goto while_break;
    }
#line 890
    if (p->param[j].invert) {
#line 891
      c = p->param[j].data;
#line 893
      if (p->param[j].invert == 2) {
#line 893
        if (p->param[j].size == 2UL) {
          {
#line 895
          s = (int *)c;
#line 897
          tmp = htons((uint16_t )*s);
#line 897
          *s = (int )tmp >> 8;
          }
        } else {
#line 893
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 898
      if (p->param[j].size == 2UL) {
        {
#line 899
        s___0 = (int *)c;
#line 901
        tmp___0 = htons((uint16_t )*s___0);
#line 901
        *s___0 = (int )tmp___0;
        }
      } else {
        {
#line 903
        l = (long *)c;
#line 905
        tmp___1 = htonl((uint32_t )*l);
#line 905
        *l = (long )tmp___1;
        }
      }
    }
#line 889
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 909
  return;
}
}
#line 923 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
void InvertRPC(struct RPC_params *p ) 
{ 
  int j ;
  void *c ;
  int *s ;
  uint16_t tmp ;
  int *s___0 ;
  uint16_t tmp___0 ;
  long *l ;
  uint32_t tmp___1 ;

  {
#line 928
  j = 0;
  {
#line 928
  while (1) {
    while_continue: /* CIL Label */ ;
#line 928
    if (! (j < p->args)) {
#line 928
      goto while_break;
    }
#line 929
    if (p->param[j].invert) {
#line 930
      c = p->param[j].data;
#line 932
      if (p->param[j].invert == 2) {
#line 932
        if (p->param[j].size == 2UL) {
          {
#line 934
          s = (int *)c;
#line 936
          tmp = ntohs((uint16_t )*s);
#line 936
          *s = (int )tmp >> 8;
          }
        } else {
#line 932
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 937
      if (p->param[j].size == 2UL) {
        {
#line 938
        s___0 = (int *)c;
#line 940
        tmp___0 = ntohs((uint16_t )*s___0);
#line 940
        *s___0 = (int )tmp___0;
        }
      } else {
        {
#line 942
        l = (long *)c;
#line 944
        tmp___1 = ntohl((unsigned int )*l);
#line 944
        *l = (long )tmp___1;
        }
      }
    }
#line 928
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 948
  return;
}
}
#line 962 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
unsigned long DoRPC(int sd , int sockaddr , struct RPC_params *p , int *error ) 
{ 
  int err ;
  long D0 ;
  long A0 ;

  {
  {
#line 966
  D0 = 0L;
#line 966
  A0 = 0L;
#line 969
  InvertRPC(p);
#line 971
  err = sys_RPC(sd, sockaddr, p->trap, & D0, & A0, p->args, & p->param[0], p->reply);
#line 975
  UninvertRPC(p);
  }
#line 977
  if (error) {
#line 978
    *error = err;
  }
#line 980
  if (p->reply == 1) {
#line 981
    return ((unsigned long )A0);
  } else
#line 982
  if (p->reply == 2) {
#line 983
    return ((unsigned long )D0);
  } else {
#line 985
    return ((unsigned long )err);
  }
}
}
#line 1000 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
int RPC_Int_Void(int sd , int trap ) 
{ 
  int tmp ;

  {
  {
#line 1003
  tmp = RPC(sd, 1, trap, 0, 0);
  }
#line 1003
  return (tmp);
}
}
#line 1018 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
int RPC_Ptr_Void(int sd , int trap ) 
{ 
  int tmp ;

  {
  {
#line 1021
  tmp = RPC(sd, 1, trap, 1, 0);
  }
#line 1021
  return (tmp);
}
}
#line 81 "../include/pi-cmp.h"
ssize_t cmp_tx(pi_socket_t *ps , unsigned char const   *buf___3 , size_t len , int flags ) ;
#line 85
ssize_t cmp_rx(pi_socket_t *ps , pi_buffer_t *msg , size_t len , int flags ) ;
#line 89
int cmp_init(pi_socket_t *ps , int baudrate ) ;
#line 92
int cmp_abort(pi_socket_t *ps , int reason ) ;
#line 95
int cmp_wakeup(pi_socket_t *ps , int maxbaud ) ;
#line 98
void cmp_dump(unsigned char const   *cmp , int rxtx ) ;
#line 40 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
static int cmp_flush(pi_socket_t *ps , int flags ) ;
#line 41
static int cmp_getsockopt(pi_socket_t *ps , int level , int option_name , void *option_value ,
                          size_t *option_len ) ;
#line 43
static int cmp_setsockopt(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                          size_t *option_len ) ;
#line 46
static pi_protocol_t *cmp_protocol_dup(pi_protocol_t *prot ) ;
#line 47
static void cmp_protocol_free(pi_protocol_t *prot ) ;
#line 61 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
static pi_protocol_t *cmp_protocol_dup(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  struct pi_cmp_data *data ;
  struct pi_cmp_data *new_data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 69
  tmp = malloc(sizeof(pi_protocol_t ));
#line 69
  new_prot = (pi_protocol_t *)tmp;
#line 70
  tmp___0 = malloc(sizeof(struct pi_cmp_data ));
#line 70
  new_data = (struct pi_cmp_data *)tmp___0;
  }
#line 72
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 72
    if ((unsigned long )new_data != (unsigned long )((void *)0)) {
#line 73
      new_prot->level = prot->level;
#line 74
      new_prot->dup = prot->dup;
#line 75
      new_prot->free = prot->free;
#line 76
      new_prot->read = prot->read;
#line 77
      new_prot->write = prot->write;
#line 78
      new_prot->flush = prot->flush;
#line 79
      new_prot->getsockopt = prot->getsockopt;
#line 80
      new_prot->setsockopt = prot->setsockopt;
#line 82
      data = (struct pi_cmp_data *)prot->data;
#line 83
      new_data->type = data->type;
#line 84
      new_data->flags = data->flags;
#line 85
      new_data->version = data->version;
#line 86
      new_data->baudrate = data->baudrate;
#line 88
      new_prot->data = (void *)new_data;
    } else {
#line 72
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 90
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
    {
#line 91
    free((void *)new_prot);
#line 92
    new_prot = (pi_protocol_t *)((void *)0);
    }
  } else
#line 93
  if ((unsigned long )new_data != (unsigned long )((void *)0)) {
    {
#line 94
    free((void *)new_data);
#line 95
    new_data = (struct pi_cmp_data *)((void *)0);
    }
  }
#line 98
  return (new_prot);
}
}
#line 113 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
static void cmp_protocol_free(pi_protocol_t *prot ) 
{ 


  {
#line 116
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 117
    if ((unsigned long )prot->data != (unsigned long )((void *)0)) {
      {
#line 118
      free(prot->data);
      }
    }
    {
#line 119
    free((void *)prot);
    }
  }
#line 121
  return;
}
}
#line 135 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
pi_protocol_t *cmp_protocol(void) 
{ 
  pi_protocol_t *prot ;
  struct pi_cmp_data *data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 141
  tmp = malloc(sizeof(pi_protocol_t ));
#line 141
  prot = (pi_protocol_t *)tmp;
#line 142
  tmp___0 = malloc(sizeof(struct pi_cmp_data ));
#line 142
  data = (struct pi_cmp_data *)tmp___0;
  }
#line 144
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 144
    if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 145
      prot->level = 5;
#line 146
      prot->dup = & cmp_protocol_dup;
#line 147
      prot->free = & cmp_protocol_free;
#line 148
      prot->read = & cmp_rx;
#line 149
      prot->write = & cmp_tx;
#line 150
      prot->flush = & cmp_flush;
#line 151
      prot->getsockopt = & cmp_getsockopt;
#line 152
      prot->setsockopt = & cmp_setsockopt;
#line 154
      data->type = (unsigned char)0;
#line 155
      data->flags = (unsigned char)0;
#line 156
      data->version = 0U;
#line 157
      data->baudrate = 0;
#line 159
      prot->data = (void *)data;
    } else {
#line 144
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 161
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
    {
#line 162
    free((void *)prot);
#line 163
    prot = (pi_protocol_t *)((void *)0);
    }
  } else
#line 164
  if ((unsigned long )data != (unsigned long )((void *)0)) {
    {
#line 165
    free((void *)data);
#line 166
    data = (struct pi_cmp_data *)((void *)0);
    }
  }
#line 169
  return (prot);
}
}
#line 184 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
int cmp_rx_handshake(pi_socket_t *ps , int establishrate , int establishhighrate ) 
{ 
  pi_protocol_t *prot ;
  struct pi_cmp_data *data ;
  pi_buffer_t *buf___3 ;
  int bytes ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 193
  prot = pi_protocol(ps->sd, 5);
  }
#line 194
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 195
    tmp = pi_set_error(ps->sd, -201);
    }
#line 195
    return (tmp);
  }
  {
#line 197
  data = (struct pi_cmp_data *)prot->data;
#line 200
  buf___3 = pi_buffer_new((size_t )10);
  }
#line 201
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
    {
#line 202
    tmp___0 = __errno_location();
#line 202
    *tmp___0 = 12;
#line 203
    tmp___1 = pi_set_error(ps->sd, -500);
    }
#line 203
    return (tmp___1);
  }
  {
#line 206
  tmp___2 = cmp_rx(ps, buf___3, (size_t )10, 0);
#line 206
  bytes = (int )tmp___2;
#line 208
  pi_buffer_free(buf___3);
  }
#line 209
  if (bytes < 0) {
#line 210
    return (bytes);
  }
#line 212
  if ((data->version & 65280U) == 256U) {
#line 213
    if (establishrate != -1) {
#line 214
      if (establishrate > data->baudrate) {
#line 215
        if (establishhighrate) {
          {
#line 216
          pi_log(64, 4, "CMP Establishing higher rate %ul (%ul)\n", establishrate,
                 data->baudrate);
#line 219
          data->baudrate = establishrate;
          }
        }
      } else {
#line 222
        data->baudrate = establishrate;
      }
    }
    {
#line 226
    bytes = cmp_init(ps, data->baudrate);
    }
#line 226
    if (bytes < 0) {
#line 227
      return (bytes);
    }
  } else {
    {
#line 230
    pi_log(64, 1, "CMP Incompatible Version\n");
#line 231
    cmp_abort(ps, 128);
#line 232
    tmp___3 = __errno_location();
#line 232
    *tmp___3 = 111;
#line 233
    tmp___4 = pi_set_error(ps->sd, -101);
    }
#line 233
    return (tmp___4);
  }
#line 236
  return (0);
}
}
#line 251 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
int cmp_tx_handshake(pi_socket_t *ps ) 
{ 
  pi_protocol_t *prot ;
  struct pi_cmp_data *data ;
  int result ;
  int tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 258
  prot = pi_protocol(ps->sd, 5);
  }
#line 259
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 260
    tmp = pi_set_error(ps->sd, -201);
    }
#line 260
    return (tmp);
  }
  {
#line 262
  data = (struct pi_cmp_data *)prot->data;
#line 264
  result = cmp_wakeup(ps, 38400);
  }
#line 264
  if (result < 0) {
#line 265
    return (result);
  }
  {
#line 267
  tmp___0 = cmp_rx(ps, (pi_buffer_t *)((void *)0), (size_t )0, 0);
#line 267
  result = (int )tmp___0;
  }
#line 267
  if (result < 0) {
#line 268
    return (result);
  }
  {
#line 271
  if ((int )data->type == 2) {
#line 271
    goto case_2;
  }
#line 273
  if ((int )data->type == 3) {
#line 273
    goto case_3;
  }
#line 270
  goto switch_break;
  case_2: /* CIL Label */ 
#line 272
  return (0);
  case_3: /* CIL Label */ 
  {
#line 274
  pi_log(64, 0, "CMP Aborted by other end\n");
#line 276
  tmp___1 = __errno_location();
#line 276
  *tmp___1 = -5;
#line 277
  tmp___2 = pi_set_error(ps->sd, -100);
  }
#line 277
  return (tmp___2);
  switch_break: /* CIL Label */ ;
  }
#line 280
  return (-101);
}
}
#line 296 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
ssize_t cmp_tx(pi_socket_t *ps , unsigned char const   *buf___3 , size_t len , int flags ) 
{ 
  int bytes ;
  int type ;
  size_t size ;
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  struct pi_cmp_data *data ;
  unsigned char cmp_buf[10] ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 307
  prot = pi_protocol(ps->sd, 5);
  }
#line 308
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 309
    tmp = pi_set_error(ps->sd, -201);
    }
#line 309
    return ((ssize_t )tmp);
  }
  {
#line 311
  data = (struct pi_cmp_data *)prot->data;
#line 312
  next = pi_protocol_next(ps->sd, 5);
  }
#line 313
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 314
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 314
    return ((ssize_t )tmp___0);
  }
  {
#line 316
  type = 1;
#line 317
  size = sizeof(type);
#line 318
  pi_setsockopt(ps->sd, 2, 0, (void const   *)(& type), & size);
#line 320
  *(& cmp_buf[0] + 0) = data->type;
#line 321
  *(& cmp_buf[1] + 0) = data->flags;
  }
#line 322
  if ((long )data->version > 258L) {
#line 322
    tmp___1 = 258L;
  } else {
#line 322
    tmp___1 = (long )data->version;
  }
#line 322
  *(& cmp_buf[2] + 0) = (unsigned char )(((int )((unsigned short )tmp___1) >> 8) & 255);
#line 322
  if ((long )data->version > 258L) {
#line 322
    tmp___2 = 258L;
  } else {
#line 322
    tmp___2 = (long )data->version;
  }
#line 322
  *(& cmp_buf[2] + 1) = (unsigned char )((int )((unsigned short )tmp___2) & 255);
#line 323
  *(& cmp_buf[4] + 0) = (unsigned char)0;
#line 323
  *(& cmp_buf[4] + 1) = (unsigned char)0;
#line 324
  *(& cmp_buf[6] + 0) = (unsigned char )((int )((unsigned char )((unsigned long )data->baudrate >> 24)) & 255);
#line 324
  *(& cmp_buf[6] + 1) = (unsigned char )(((unsigned long )data->baudrate >> 16) & 255UL);
#line 324
  *(& cmp_buf[6] + 2) = (unsigned char )(((unsigned long )data->baudrate >> 8) & 255UL);
#line 324
  *(& cmp_buf[6] + 3) = (unsigned char )((unsigned long )data->baudrate & 255UL);
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 326
    tmp___3 = pi_debug_get_types();
    }
#line 326
    if (tmp___3 & 64) {
      {
#line 326
      tmp___4 = pi_debug_get_level();
      }
#line 326
      if (tmp___4 >= 4) {
        {
#line 326
        cmp_dump((unsigned char const   *)(cmp_buf), 1);
        }
      }
    }
#line 326
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 328
  tmp___5 = (*(next->write))(ps, (unsigned char const   *)(cmp_buf), (size_t )10,
                             flags);
#line 328
  bytes = (int )tmp___5;
  }
#line 329
  if (bytes < 10) {
#line 330
    if (bytes < 0) {
#line 330
      tmp___7 = bytes;
    } else {
      {
#line 330
      tmp___6 = pi_set_error(ps->sd, -100);
#line 330
      tmp___7 = tmp___6;
      }
    }
#line 330
    return ((ssize_t )tmp___7);
  }
#line 332
  return ((ssize_t )0);
}
}
#line 346 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
ssize_t cmp_rx(pi_socket_t *ps , pi_buffer_t *msg , size_t len , int flags ) 
{ 
  int bytes ;
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  struct pi_cmp_data *data ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 354
  pi_log(64, 8, "CMP RX len=%d flags=0x%02x\n", len, flags);
#line 357
  prot = pi_protocol(ps->sd, 5);
  }
#line 358
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 359
    tmp = pi_set_error(ps->sd, -201);
    }
#line 359
    return ((ssize_t )tmp);
  }
  {
#line 361
  data = (struct pi_cmp_data *)prot->data;
#line 362
  next = pi_protocol_next(ps->sd, 5);
  }
#line 363
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 364
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 364
    return ((ssize_t )tmp___0);
  }
  {
#line 366
  tmp___1 = (*(next->read))(ps, msg, len, flags);
#line 366
  bytes = (int )tmp___1;
  }
#line 367
  if (bytes < 10) {
#line 368
    if (bytes < 0) {
#line 368
      tmp___2 = bytes;
    } else {
#line 368
      tmp___2 = -100;
    }
    {
#line 368
    tmp___3 = pi_set_error(ps->sd, tmp___2);
    }
#line 368
    return ((ssize_t )tmp___3);
  }
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 370
    tmp___4 = pi_debug_get_types();
    }
#line 370
    if (tmp___4 & 64) {
      {
#line 370
      tmp___5 = pi_debug_get_level();
      }
#line 370
      if (tmp___5 >= 4) {
        {
#line 370
        cmp_dump((unsigned char const   *)msg->data, 0);
        }
      }
    }
#line 370
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  data->type = *((msg->data + 0) + 0);
#line 373
  data->flags = *((msg->data + 1) + 0);
#line 374
  data->version = (unsigned int )((unsigned short )(((int )*((msg->data + 2) + 0) << 8) | (int )*((msg->data + 2) + 1)));
#line 375
  data->baudrate = (int )(((((unsigned long )*((msg->data + 6) + 0) << 24) | ((unsigned long )*((msg->data + 6) + 1) << 16)) | ((unsigned long )*((msg->data + 6) + 2) << 8)) | (unsigned long )*((msg->data + 6) + 3));
#line 377
  return ((ssize_t )0);
}
}
#line 391 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
static int cmp_flush(pi_socket_t *ps , int flags ) 
{ 
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 397
  prot = pi_protocol(ps->sd, 5);
  }
#line 398
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 399
    tmp = pi_set_error(ps->sd, -201);
    }
#line 399
    return (tmp);
  }
  {
#line 401
  next = pi_protocol_next(ps->sd, 5);
  }
#line 402
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 403
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 403
    return (tmp___0);
  }
  {
#line 405
  tmp___1 = (*(next->flush))(ps, flags);
  }
#line 405
  return (tmp___1);
}
}
#line 419 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
int cmp_init(pi_socket_t *ps , int baudrate ) 
{ 
  pi_protocol_t *prot ;
  struct pi_cmp_data *data ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 425
  prot = pi_protocol(ps->sd, 5);
  }
#line 426
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 427
    tmp = pi_set_error(ps->sd, -201);
    }
#line 427
    return (tmp);
  }
#line 428
  data = (struct pi_cmp_data *)prot->data;
#line 430
  data->type = (unsigned char)2;
#line 431
  data->flags = (unsigned char)16;
#line 432
  if (baudrate != 9600) {
#line 433
    data->flags = (unsigned char)128;
  }
  {
#line 434
  data->baudrate = baudrate;
#line 436
  tmp___0 = cmp_tx(ps, (unsigned char const   *)((void *)0), (size_t )0, 0);
  }
#line 436
  return ((int )tmp___0);
}
}
#line 450 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
int cmp_abort(pi_socket_t *ps , int reason ) 
{ 
  pi_protocol_t *prot ;
  struct pi_cmp_data *data ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 456
  prot = pi_protocol(ps->sd, 5);
  }
#line 457
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 458
    tmp = pi_set_error(ps->sd, -201);
    }
#line 458
    return (tmp);
  }
  {
#line 460
  data = (struct pi_cmp_data *)prot->data;
#line 461
  data->type = (unsigned char)3;
#line 462
  data->flags = (unsigned char )reason;
#line 464
  pi_log(64, 0, "CMP ABORT\n");
#line 466
  tmp___0 = cmp_tx(ps, (unsigned char const   *)((void *)0), (size_t )0, 0);
  }
#line 466
  return ((int )tmp___0);
}
}
#line 480 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
int cmp_wakeup(pi_socket_t *ps , int maxbaud ) 
{ 
  pi_protocol_t *prot ;
  struct pi_cmp_data *data ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 486
  prot = pi_protocol(ps->sd, 5);
  }
#line 487
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 488
    tmp = pi_set_error(ps->sd, -201);
    }
#line 488
    return (tmp);
  }
  {
#line 490
  data = (struct pi_cmp_data *)prot->data;
#line 491
  data->type = (unsigned char)1;
#line 492
  data->flags = (unsigned char)0;
#line 493
  data->version = 258U;
#line 494
  data->baudrate = maxbaud;
#line 496
  tmp___0 = cmp_tx(ps, (unsigned char const   *)((void *)0), (size_t )0, 0);
  }
#line 496
  return ((int )tmp___0);
}
}
#line 511 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
static int cmp_getsockopt(pi_socket_t *ps , int level , int option_name , void *option_value ,
                          size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  struct pi_cmp_data *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 520
  prot = pi_protocol(ps->sd, 5);
  }
#line 521
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 522
    tmp = pi_set_error(ps->sd, -201);
    }
#line 522
    return (tmp);
  }
#line 523
  data = (struct pi_cmp_data *)prot->data;
  {
#line 526
  if (option_name == 0) {
#line 526
    goto case_0;
  }
#line 534
  if (option_name == 1) {
#line 534
    goto case_1;
  }
#line 542
  if (option_name == 2) {
#line 542
    goto case_2;
  }
#line 550
  if (option_name == 3) {
#line 550
    goto case_3;
  }
#line 525
  goto switch_break;
  case_0: /* CIL Label */ 
#line 527
  if (*option_len != sizeof(data->type)) {
#line 528
    goto error;
  }
  {
#line 529
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->type),
         sizeof(data->type));
#line 531
  *option_len = sizeof(data->type);
  }
#line 532
  goto switch_break;
  case_1: /* CIL Label */ 
#line 535
  if (*option_len != sizeof(data->flags)) {
#line 536
    goto error;
  }
  {
#line 537
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->flags),
         sizeof(data->flags));
#line 539
  *option_len = sizeof(data->flags);
  }
#line 540
  goto switch_break;
  case_2: /* CIL Label */ 
#line 543
  if (*option_len != sizeof(data->version)) {
#line 544
    goto error;
  }
  {
#line 545
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->version),
         sizeof(data->version));
#line 547
  *option_len = sizeof(data->version);
  }
#line 548
  goto switch_break;
  case_3: /* CIL Label */ 
#line 551
  if (*option_len != sizeof(data->baudrate)) {
#line 552
    goto error;
  }
  {
#line 553
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->baudrate),
         sizeof(data->baudrate));
#line 555
  *option_len = sizeof(data->baudrate);
  }
#line 556
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 559
  return (0);
  error: 
  {
#line 562
  tmp___0 = __errno_location();
#line 562
  *tmp___0 = 22;
#line 563
  tmp___1 = pi_set_error(ps->sd, -501);
  }
#line 563
  return (tmp___1);
}
}
#line 578 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
static int cmp_setsockopt(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                          size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  struct pi_padp_data *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 587
  prot = pi_protocol(ps->sd, 2);
  }
#line 588
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 589
    tmp = pi_set_error(ps->sd, -201);
    }
#line 589
    return (tmp);
  }
#line 590
  data = (struct pi_padp_data *)prot->data;
#line 592
  if (option_name == 0) {
#line 593
    if (*option_len != sizeof(data->type)) {
#line 594
      goto error;
    }
    {
#line 595
    memcpy((void */* __restrict  */)(& data->type), (void const   */* __restrict  */)option_value,
           sizeof(data->type));
#line 597
    *option_len = sizeof(data->type);
    }
  }
#line 600
  return (0);
  error: 
  {
#line 603
  tmp___0 = __errno_location();
#line 603
  *tmp___0 = 22;
#line 604
  tmp___1 = pi_set_error(ps->sd, -501);
  }
#line 604
  return (tmp___1);
}
}
#line 619 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
void cmp_dump(unsigned char const   *cmp , int rxtx ) 
{ 
  char *type ;
  char const   *tmp ;

  {
  {
#line 627
  if ((int )*((unsigned char *)(cmp + 0) + 0) == 1) {
#line 627
    goto case_1;
  }
#line 630
  if ((int )*((unsigned char *)(cmp + 0) + 0) == 2) {
#line 630
    goto case_2;
  }
#line 633
  if ((int )*((unsigned char *)(cmp + 0) + 0) == 3) {
#line 633
    goto case_3;
  }
#line 636
  goto switch_default;
  case_1: /* CIL Label */ 
#line 628
  type = (char *)"WAKE";
#line 629
  goto switch_break;
  case_2: /* CIL Label */ 
#line 631
  type = (char *)"INIT";
#line 632
  goto switch_break;
  case_3: /* CIL Label */ 
#line 634
  type = (char *)"ABRT";
#line 635
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 637
  type = (char *)"UNK";
#line 638
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 641
  if (rxtx) {
#line 641
    tmp = "TX";
  } else {
#line 641
    tmp = "RX";
  }
  {
#line 641
  pi_log(64, 0, "CMP %s %s Type: 0x%02x Flags: 0x%02x Version: 0x%04x Baud: %d\n",
         tmp, type, (int )*((unsigned char *)(cmp + 0) + 0), (int )*((unsigned char *)(cmp + 1) + 0),
         ((((unsigned long )*((unsigned char *)(cmp + 2) + 0) << 24) | ((unsigned long )*((unsigned char *)(cmp + 2) + 1) << 16)) | ((unsigned long )*((unsigned char *)(cmp + 2) + 2) << 8)) | (unsigned long )*((unsigned char *)(cmp + 2) + 3),
         ((((unsigned long )*((unsigned char *)(cmp + 6) + 0) << 24) | ((unsigned long )*((unsigned char *)(cmp + 6) + 1) << 16)) | ((unsigned long )*((unsigned char *)(cmp + 6) + 2) << 8)) | (unsigned long )*((unsigned char *)(cmp + 6) + 3));
  }
#line 648
  return;
}
}
#line 41 "../include/pi-hinote.h"
void free_HiNoteNote(struct HiNoteNote *hinote ) ;
#line 42
int unpack_HiNoteNote(struct HiNoteNote *hinote , unsigned char *buffer , int len ) ;
#line 44
int pack_HiNoteNote(struct HiNoteNote *hinote , unsigned char *buffer , int len ) ;
#line 46
int unpack_HiNoteAppInfo(struct HiNoteAppInfo *appinfo , unsigned char *record , size_t len ) ;
#line 49
int pack_HiNoteAppInfo(struct HiNoteAppInfo *appinfo , unsigned char *record , size_t len ) ;
#line 40 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/hinote.c"
void free_HiNoteNote(struct HiNoteNote *hinote ) 
{ 


  {
#line 43
  if ((unsigned long )hinote->text != (unsigned long )((void *)0)) {
    {
#line 44
    free((void *)hinote->text);
#line 45
    hinote->text = (char *)((void *)0);
    }
  }
#line 47
  return;
}
}
#line 60 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/hinote.c"
int unpack_HiNoteNote(struct HiNoteNote *hinote , unsigned char *buffer , int len ) 
{ 
  size_t tmp ;

  {
#line 63
  if (len < 3) {
#line 64
    return (0);
  }
  {
#line 66
  hinote->flags = (int )*(buffer + 0);
#line 67
  hinote->level = (int )*(buffer + 1);
#line 68
  hinote->text = strdup((char const   *)((char *)(buffer + 2)));
#line 70
  tmp = strlen((char const   *)((char *)(buffer + 2)));
  }
#line 70
  return ((int )(tmp + 3UL));
}
}
#line 84 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/hinote.c"
int pack_HiNoteNote(struct HiNoteNote *hinote , unsigned char *buffer , int len ) 
{ 
  int destlen ;
  size_t tmp ;

  {
#line 89
  destlen = 3;
#line 90
  if (hinote->text) {
    {
#line 91
    tmp = strlen((char const   *)hinote->text);
#line 91
    destlen = (int )((size_t )destlen + tmp);
    }
  }
#line 93
  if (! buffer) {
#line 94
    return (destlen);
  }
#line 95
  if (len < destlen) {
#line 96
    return (0);
  }
#line 98
  *(buffer + 0) = (unsigned char )hinote->flags;
#line 99
  *(buffer + 1) = (unsigned char )hinote->level;
#line 101
  if (hinote->text) {
    {
#line 102
    strcpy((char */* __restrict  */)((char *)(buffer + 2)), (char const   */* __restrict  */)hinote->text);
    }
  } else {
#line 104
    *(buffer + 2) = (unsigned char)0;
  }
#line 106
  return (destlen);
}
}
#line 121 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/hinote.c"
int unpack_HiNoteAppInfo(struct HiNoteAppInfo *appinfo , unsigned char *record , size_t len ) 
{ 
  int i ;
  int idx ;
  unsigned char *start ;
  unsigned char *tmp ;

  {
  {
#line 128
  start = record;
#line 129
  i = unpack_CategoryAppInfo(& appinfo->category, (unsigned char const   *)record,
                             len);
  }
#line 130
  if (! i) {
#line 131
    return (i);
  }
#line 132
  record += i;
#line 133
  len -= (size_t )i;
#line 134
  if (len < 48UL) {
#line 135
    return (0);
  }
#line 136
  idx = 0;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! (i < 48)) {
#line 136
      goto while_break;
    }
#line 137
    tmp = record;
#line 137
    record ++;
#line 137
    appinfo->reserved[i] = *tmp;
#line 136
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  return ((int )(record - start));
}
}
#line 153 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/hinote.c"
int pack_HiNoteAppInfo(struct HiNoteAppInfo *appinfo , unsigned char *record , size_t len ) 
{ 
  int i ;
  int idx ;
  unsigned char *start ;
  unsigned char *tmp ;

  {
  {
#line 158
  start = record;
#line 160
  i = pack_CategoryAppInfo((CategoryAppInfo_t const   *)(& appinfo->category), record,
                           len);
  }
#line 161
  if (i == 0) {
#line 162
    return (0);
  }
#line 163
  if (! record) {
#line 164
    return (i + 48);
  }
#line 165
  record += i;
#line 166
  len -= (size_t )i;
#line 167
  if (len < 48UL) {
#line 168
    return ((int )(record - start));
  }
#line 169
  idx = 0;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (i < 48)) {
#line 169
      goto while_break;
    }
#line 170
    tmp = record;
#line 170
    record ++;
#line 170
    *tmp = appinfo->reserved[i];
#line 169
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  return ((int )(record - start));
}
}
#line 40 "../include/pi-md5.h"
void MD5Init(struct MD5Context *ctx ) ;
#line 41
void MD5Update(struct MD5Context *ctx , uint8_t const   *buf___3 , unsigned int len ) ;
#line 42
void MD5Final(unsigned char *digest , struct MD5Context *ctx ) ;
#line 43
void MD5Transform(uint32_t *buf___3 , uint32_t const   *in ) ;
#line 45
void byteSwap(uint32_t *buf___3 , unsigned int words ) ;
#line 32 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/md5.c"
void byteSwap(uint32_t *buf___3 , unsigned int words ) 
{ 
  uint8_t *p ;
  uint32_t *tmp ;

  {
#line 34
  p = (uint8_t *)buf___3;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    tmp = buf___3;
#line 37
    buf___3 ++;
#line 37
    *tmp = ((((unsigned int )*(p + 3) << 8) | (unsigned int )*(p + 2)) << 16) | (((unsigned int )*(p + 1) << 8) | (unsigned int )*(p + 0));
#line 39
    p += 4;
#line 36
    words --;
#line 36
    if (! words) {
#line 36
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  return;
}
}
#line 47 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/md5.c"
void MD5Init(struct MD5Context *ctx ) 
{ 


  {
#line 49
  ctx->buf[0] = (uint32_t )1732584193;
#line 50
  ctx->buf[1] = 4023233417U;
#line 51
  ctx->buf[2] = 2562383102U;
#line 52
  ctx->buf[3] = (uint32_t )271733878;
#line 53
  ctx->bytes[0] = (uint32_t )0;
#line 54
  ctx->bytes[1] = (uint32_t )0;
#line 55
  return;
}
}
#line 61 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/md5.c"
void MD5Update(struct MD5Context *ctx , uint8_t const   *buf___3 , unsigned int len ) 
{ 
  uint32_t t ;
  uint32_t tmp ;

  {
#line 67
  t = ctx->bytes[0];
#line 68
  tmp = t + len;
#line 68
  ctx->bytes[0] = tmp;
#line 68
  if (tmp < t) {
#line 69
    (ctx->bytes[1]) ++;
  }
#line 71
  t = 64U - (t & 63U);
#line 72
  if (t > len) {
    {
#line 73
    memcpy((void */* __restrict  */)(((uint8_t *)(ctx->in) + 64) - t), (void const   */* __restrict  */)buf___3,
           (size_t )len);
    }
#line 74
    return;
  }
  {
#line 77
  memcpy((void */* __restrict  */)(((uint8_t *)(ctx->in) + 64) - t), (void const   */* __restrict  */)buf___3,
         (size_t )t);
#line 78
  byteSwap(ctx->in, 16U);
#line 79
  MD5Transform((uint32_t *)(ctx->buf), (uint32_t const   *)(ctx->in));
#line 80
  buf___3 += t;
#line 81
  len -= t;
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (len >= 64U)) {
#line 84
      goto while_break;
    }
    {
#line 85
    memcpy((void */* __restrict  */)(ctx->in), (void const   */* __restrict  */)buf___3,
           (size_t )64);
#line 86
    byteSwap(ctx->in, 16U);
#line 87
    MD5Transform((uint32_t *)(ctx->buf), (uint32_t const   *)(ctx->in));
#line 88
    buf___3 += 64;
#line 89
    len -= 64U;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 93
  memcpy((void */* __restrict  */)(ctx->in), (void const   */* __restrict  */)buf___3,
         (size_t )len);
  }
#line 94
  return;
}
}
#line 100 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/md5.c"
void MD5Final(unsigned char *digest , struct MD5Context *ctx ) 
{ 
  int count ;
  uint8_t *p ;
  uint8_t *tmp ;

  {
#line 102
  count = (int )(ctx->bytes[0] & 63U);
#line 103
  p = (uint8_t *)(ctx->in) + count;
#line 106
  tmp = p;
#line 106
  p ++;
#line 106
  *tmp = (uint8_t )128;
#line 109
  count = 55 - count;
#line 111
  if (count < 0) {
    {
#line 112
    memset((void *)p, 0, (size_t )(count + 8));
#line 113
    byteSwap(ctx->in, 16U);
#line 114
    MD5Transform((uint32_t *)(ctx->buf), (uint32_t const   *)(ctx->in));
#line 115
    p = (uint8_t *)(ctx->in);
#line 116
    count = 56;
    }
  }
  {
#line 118
  memset((void *)p, 0, (size_t )count);
#line 119
  byteSwap(ctx->in, 14U);
#line 122
  ctx->in[14] = ctx->bytes[0] << 3;
#line 123
  ctx->in[15] = (ctx->bytes[1] << 3) | (ctx->bytes[0] >> 29);
#line 124
  MD5Transform((uint32_t *)(ctx->buf), (uint32_t const   *)(ctx->in));
#line 126
  byteSwap(ctx->buf, 4U);
#line 127
  memcpy((void */* __restrict  */)digest, (void const   */* __restrict  */)(ctx->buf),
         (size_t )16);
#line 128
  memset((void *)ctx, 0, sizeof(ctx));
  }
#line 129
  return;
}
}
#line 150 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/md5.c"
void MD5Transform(uint32_t *buf___3 , uint32_t const   *in ) 
{ 
  register uint32_t a ;
  register uint32_t b ;
  register uint32_t c ;
  register uint32_t d ;

  {
#line 154
  a = *(buf___3 + 0);
#line 155
  b = *(buf___3 + 1);
#line 156
  c = *(buf___3 + 2);
#line 157
  d = *(buf___3 + 3);
#line 159
  a += ((d ^ (b & (c ^ d))) + (unsigned int )*(in + 0)) + 3614090360U;
#line 159
  a = ((a << 7) | (a >> 25)) + b;
#line 160
  d += ((c ^ (a & (b ^ c))) + (unsigned int )*(in + 1)) + 3905402710U;
#line 160
  d = ((d << 12) | (d >> 20)) + a;
#line 161
  c += ((b ^ (d & (a ^ b))) + (unsigned int )*(in + 2)) + 606105819U;
#line 161
  c = ((c << 17) | (c >> 15)) + d;
#line 162
  b += ((a ^ (c & (d ^ a))) + (unsigned int )*(in + 3)) + 3250441966U;
#line 162
  b = ((b << 22) | (b >> 10)) + c;
#line 163
  a += ((d ^ (b & (c ^ d))) + (unsigned int )*(in + 4)) + 4118548399U;
#line 163
  a = ((a << 7) | (a >> 25)) + b;
#line 164
  d += ((c ^ (a & (b ^ c))) + (unsigned int )*(in + 5)) + 1200080426U;
#line 164
  d = ((d << 12) | (d >> 20)) + a;
#line 165
  c += ((b ^ (d & (a ^ b))) + (unsigned int )*(in + 6)) + 2821735955U;
#line 165
  c = ((c << 17) | (c >> 15)) + d;
#line 166
  b += ((a ^ (c & (d ^ a))) + (unsigned int )*(in + 7)) + 4249261313U;
#line 166
  b = ((b << 22) | (b >> 10)) + c;
#line 167
  a += ((d ^ (b & (c ^ d))) + (unsigned int )*(in + 8)) + 1770035416U;
#line 167
  a = ((a << 7) | (a >> 25)) + b;
#line 168
  d += ((c ^ (a & (b ^ c))) + (unsigned int )*(in + 9)) + 2336552879U;
#line 168
  d = ((d << 12) | (d >> 20)) + a;
#line 169
  c += ((b ^ (d & (a ^ b))) + (unsigned int )*(in + 10)) + 4294925233U;
#line 169
  c = ((c << 17) | (c >> 15)) + d;
#line 170
  b += ((a ^ (c & (d ^ a))) + (unsigned int )*(in + 11)) + 2304563134U;
#line 170
  b = ((b << 22) | (b >> 10)) + c;
#line 171
  a += ((d ^ (b & (c ^ d))) + (unsigned int )*(in + 12)) + 1804603682U;
#line 171
  a = ((a << 7) | (a >> 25)) + b;
#line 172
  d += ((c ^ (a & (b ^ c))) + (unsigned int )*(in + 13)) + 4254626195U;
#line 172
  d = ((d << 12) | (d >> 20)) + a;
#line 173
  c += ((b ^ (d & (a ^ b))) + (unsigned int )*(in + 14)) + 2792965006U;
#line 173
  c = ((c << 17) | (c >> 15)) + d;
#line 174
  b += ((a ^ (c & (d ^ a))) + (unsigned int )*(in + 15)) + 1236535329U;
#line 174
  b = ((b << 22) | (b >> 10)) + c;
#line 176
  a += ((c ^ (d & (b ^ c))) + (unsigned int )*(in + 1)) + 4129170786U;
#line 176
  a = ((a << 5) | (a >> 27)) + b;
#line 177
  d += ((b ^ (c & (a ^ b))) + (unsigned int )*(in + 6)) + 3225465664U;
#line 177
  d = ((d << 9) | (d >> 23)) + a;
#line 178
  c += ((a ^ (b & (d ^ a))) + (unsigned int )*(in + 11)) + 643717713U;
#line 178
  c = ((c << 14) | (c >> 18)) + d;
#line 179
  b += ((d ^ (a & (c ^ d))) + (unsigned int )*(in + 0)) + 3921069994U;
#line 179
  b = ((b << 20) | (b >> 12)) + c;
#line 180
  a += ((c ^ (d & (b ^ c))) + (unsigned int )*(in + 5)) + 3593408605U;
#line 180
  a = ((a << 5) | (a >> 27)) + b;
#line 181
  d += ((b ^ (c & (a ^ b))) + (unsigned int )*(in + 10)) + 38016083U;
#line 181
  d = ((d << 9) | (d >> 23)) + a;
#line 182
  c += ((a ^ (b & (d ^ a))) + (unsigned int )*(in + 15)) + 3634488961U;
#line 182
  c = ((c << 14) | (c >> 18)) + d;
#line 183
  b += ((d ^ (a & (c ^ d))) + (unsigned int )*(in + 4)) + 3889429448U;
#line 183
  b = ((b << 20) | (b >> 12)) + c;
#line 184
  a += ((c ^ (d & (b ^ c))) + (unsigned int )*(in + 9)) + 568446438U;
#line 184
  a = ((a << 5) | (a >> 27)) + b;
#line 185
  d += ((b ^ (c & (a ^ b))) + (unsigned int )*(in + 14)) + 3275163606U;
#line 185
  d = ((d << 9) | (d >> 23)) + a;
#line 186
  c += ((a ^ (b & (d ^ a))) + (unsigned int )*(in + 3)) + 4107603335U;
#line 186
  c = ((c << 14) | (c >> 18)) + d;
#line 187
  b += ((d ^ (a & (c ^ d))) + (unsigned int )*(in + 8)) + 1163531501U;
#line 187
  b = ((b << 20) | (b >> 12)) + c;
#line 188
  a += ((c ^ (d & (b ^ c))) + (unsigned int )*(in + 13)) + 2850285829U;
#line 188
  a = ((a << 5) | (a >> 27)) + b;
#line 189
  d += ((b ^ (c & (a ^ b))) + (unsigned int )*(in + 2)) + 4243563512U;
#line 189
  d = ((d << 9) | (d >> 23)) + a;
#line 190
  c += ((a ^ (b & (d ^ a))) + (unsigned int )*(in + 7)) + 1735328473U;
#line 190
  c = ((c << 14) | (c >> 18)) + d;
#line 191
  b += ((d ^ (a & (c ^ d))) + (unsigned int )*(in + 12)) + 2368359562U;
#line 191
  b = ((b << 20) | (b >> 12)) + c;
#line 193
  a += (((b ^ c) ^ d) + (unsigned int )*(in + 5)) + 4294588738U;
#line 193
  a = ((a << 4) | (a >> 28)) + b;
#line 194
  d += (((a ^ b) ^ c) + (unsigned int )*(in + 8)) + 2272392833U;
#line 194
  d = ((d << 11) | (d >> 21)) + a;
#line 195
  c += (((d ^ a) ^ b) + (unsigned int )*(in + 11)) + 1839030562U;
#line 195
  c = ((c << 16) | (c >> 16)) + d;
#line 196
  b += (((c ^ d) ^ a) + (unsigned int )*(in + 14)) + 4259657740U;
#line 196
  b = ((b << 23) | (b >> 9)) + c;
#line 197
  a += (((b ^ c) ^ d) + (unsigned int )*(in + 1)) + 2763975236U;
#line 197
  a = ((a << 4) | (a >> 28)) + b;
#line 198
  d += (((a ^ b) ^ c) + (unsigned int )*(in + 4)) + 1272893353U;
#line 198
  d = ((d << 11) | (d >> 21)) + a;
#line 199
  c += (((d ^ a) ^ b) + (unsigned int )*(in + 7)) + 4139469664U;
#line 199
  c = ((c << 16) | (c >> 16)) + d;
#line 200
  b += (((c ^ d) ^ a) + (unsigned int )*(in + 10)) + 3200236656U;
#line 200
  b = ((b << 23) | (b >> 9)) + c;
#line 201
  a += (((b ^ c) ^ d) + (unsigned int )*(in + 13)) + 681279174U;
#line 201
  a = ((a << 4) | (a >> 28)) + b;
#line 202
  d += (((a ^ b) ^ c) + (unsigned int )*(in + 0)) + 3936430074U;
#line 202
  d = ((d << 11) | (d >> 21)) + a;
#line 203
  c += (((d ^ a) ^ b) + (unsigned int )*(in + 3)) + 3572445317U;
#line 203
  c = ((c << 16) | (c >> 16)) + d;
#line 204
  b += (((c ^ d) ^ a) + (unsigned int )*(in + 6)) + 76029189U;
#line 204
  b = ((b << 23) | (b >> 9)) + c;
#line 205
  a += (((b ^ c) ^ d) + (unsigned int )*(in + 9)) + 3654602809U;
#line 205
  a = ((a << 4) | (a >> 28)) + b;
#line 206
  d += (((a ^ b) ^ c) + (unsigned int )*(in + 12)) + 3873151461U;
#line 206
  d = ((d << 11) | (d >> 21)) + a;
#line 207
  c += (((d ^ a) ^ b) + (unsigned int )*(in + 15)) + 530742520U;
#line 207
  c = ((c << 16) | (c >> 16)) + d;
#line 208
  b += (((c ^ d) ^ a) + (unsigned int )*(in + 2)) + 3299628645U;
#line 208
  b = ((b << 23) | (b >> 9)) + c;
#line 210
  a += ((c ^ (b | ~ d)) + (unsigned int )*(in + 0)) + 4096336452U;
#line 210
  a = ((a << 6) | (a >> 26)) + b;
#line 211
  d += ((b ^ (a | ~ c)) + (unsigned int )*(in + 7)) + 1126891415U;
#line 211
  d = ((d << 10) | (d >> 22)) + a;
#line 212
  c += ((a ^ (d | ~ b)) + (unsigned int )*(in + 14)) + 2878612391U;
#line 212
  c = ((c << 15) | (c >> 17)) + d;
#line 213
  b += ((d ^ (c | ~ a)) + (unsigned int )*(in + 5)) + 4237533241U;
#line 213
  b = ((b << 21) | (b >> 11)) + c;
#line 214
  a += ((c ^ (b | ~ d)) + (unsigned int )*(in + 12)) + 1700485571U;
#line 214
  a = ((a << 6) | (a >> 26)) + b;
#line 215
  d += ((b ^ (a | ~ c)) + (unsigned int )*(in + 3)) + 2399980690U;
#line 215
  d = ((d << 10) | (d >> 22)) + a;
#line 216
  c += ((a ^ (d | ~ b)) + (unsigned int )*(in + 10)) + 4293915773U;
#line 216
  c = ((c << 15) | (c >> 17)) + d;
#line 217
  b += ((d ^ (c | ~ a)) + (unsigned int )*(in + 1)) + 2240044497U;
#line 217
  b = ((b << 21) | (b >> 11)) + c;
#line 218
  a += ((c ^ (b | ~ d)) + (unsigned int )*(in + 8)) + 1873313359U;
#line 218
  a = ((a << 6) | (a >> 26)) + b;
#line 219
  d += ((b ^ (a | ~ c)) + (unsigned int )*(in + 15)) + 4264355552U;
#line 219
  d = ((d << 10) | (d >> 22)) + a;
#line 220
  c += ((a ^ (d | ~ b)) + (unsigned int )*(in + 6)) + 2734768916U;
#line 220
  c = ((c << 15) | (c >> 17)) + d;
#line 221
  b += ((d ^ (c | ~ a)) + (unsigned int )*(in + 13)) + 1309151649U;
#line 221
  b = ((b << 21) | (b >> 11)) + c;
#line 222
  a += ((c ^ (b | ~ d)) + (unsigned int )*(in + 4)) + 4149444226U;
#line 222
  a = ((a << 6) | (a >> 26)) + b;
#line 223
  d += ((b ^ (a | ~ c)) + (unsigned int )*(in + 11)) + 3174756917U;
#line 223
  d = ((d << 10) | (d >> 22)) + a;
#line 224
  c += ((a ^ (d | ~ b)) + (unsigned int )*(in + 2)) + 718787259U;
#line 224
  c = ((c << 15) | (c >> 17)) + d;
#line 225
  b += ((d ^ (c | ~ a)) + (unsigned int )*(in + 9)) + 3951481745U;
#line 225
  b = ((b << 21) | (b >> 11)) + c;
#line 227
  *(buf___3 + 0) += a;
#line 228
  *(buf___3 + 1) += b;
#line 229
  *(buf___3 + 2) += c;
#line 230
  *(buf___3 + 3) += d;
#line 231
  return;
}
}
#line 80 "../include/pi-location.h"
void new_Timezone(Timezone_t *a ) ;
#line 82
void new_Location(Location_t *a ) ;
#line 87
void free_Location(Location_t *loc ) ;
#line 90
int unpack_DST(DST_t *dst , pi_buffer_t const   *buf___3 ) ;
#line 92
int unpack_DST_p(DST_t *dst , unsigned char const   *data , size_t const   position ) ;
#line 94
int unpack_Timezone(Timezone_t *tz , pi_buffer_t const   *buf___3 ) ;
#line 98
int unpack_Location(Location_t *loc , pi_buffer_t const   *buf___3 ) ;
#line 101
int pack_DST(DST_t const   *dst , pi_buffer_t *buf___3 ) ;
#line 103
int pack_Timezone(Timezone_t const   *tz , pi_buffer_t *buf___3 ) ;
#line 105
int pack_Location(Location_t const   *loc , pi_buffer_t *buf___3 ) ;
#line 111
int copy_Timezone(Timezone_t const   *source , Timezone_t *dest ) ;
#line 114
int copy_Location(Location_t const   *source , Location_t *dest ) ;
#line 43 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/location.c"
void new_Timezone(Timezone_t *a ) 
{ 


  {
#line 46
  a->offset = (int16_t )0;
#line 47
  a->t2 = (uint8_t )0;
#line 48
  a->dstStart.dayOfWeek = (enum DayOfWeek )0;
#line 49
  a->dstStart.weekOfMonth = (enum WeekOfMonth )0;
#line 50
  a->dstStart.month = (enum Month )0;
#line 51
  a->dstStart.unknown = (uint8_t )0;
#line 52
  a->dstEnd.dayOfWeek = (enum DayOfWeek )0;
#line 53
  a->dstEnd.weekOfMonth = (enum WeekOfMonth )0;
#line 54
  a->dstEnd.month = (enum Month )0;
#line 55
  a->dstEnd.unknown = (uint8_t )0;
#line 56
  a->dstObserved = (uint8_t )0;
#line 57
  a->t4 = (uint8_t )0;
#line 58
  a->unknown = (uint8_t )0;
#line 59
  a->name = (char *)((void *)0);
#line 60
  return;
}
}
#line 73 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/location.c"
void new_Location(Location_t *a ) 
{ 


  {
  {
#line 76
  new_Timezone(& a->tz);
#line 77
  a->unknownExists = (uint8_t )0;
#line 78
  a->unknown = (uint8_t )0;
#line 79
  a->latitude.degrees = (int16_t )0;
#line 80
  a->latitude.minutes = (int16_t )0;
#line 81
  a->latitude.direction = (enum CompassDirection )0;
#line 82
  a->longitude.degrees = (int16_t )0;
#line 83
  a->longitude.minutes = (int16_t )0;
#line 84
  a->longitude.direction = (enum CompassDirection )0;
#line 85
  a->note = (char *)((void *)0);
  }
#line 86
  return;
}
}
#line 101 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/location.c"
int copy_Timezone(Timezone_t const   *source , Timezone_t *dest ) 
{ 


  {
#line 105
  dest->offset = (int16_t )source->offset;
#line 106
  dest->t2 = (uint8_t )source->t2;
#line 107
  dest->dstStart.dayOfWeek = (enum DayOfWeek )source->dstStart.dayOfWeek;
#line 108
  dest->dstStart.weekOfMonth = (enum WeekOfMonth )source->dstStart.weekOfMonth;
#line 109
  dest->dstStart.month = (enum Month )source->dstStart.month;
#line 110
  dest->dstStart.unknown = (uint8_t )source->dstStart.unknown;
#line 111
  dest->dstEnd.dayOfWeek = (enum DayOfWeek )source->dstEnd.dayOfWeek;
#line 112
  dest->dstEnd.weekOfMonth = (enum WeekOfMonth )source->dstEnd.weekOfMonth;
#line 113
  dest->dstEnd.month = (enum Month )source->dstEnd.month;
#line 114
  dest->dstEnd.unknown = (uint8_t )source->dstEnd.unknown;
#line 115
  dest->dstObserved = (uint8_t )source->dstObserved;
#line 116
  dest->t4 = (uint8_t )source->t4;
#line 117
  dest->unknown = (uint8_t )source->unknown;
#line 118
  if ((unsigned long )((void *)0) != (unsigned long )source->name) {
    {
#line 119
    dest->name = strdup((char const   *)source->name);
    }
  } else {
#line 121
    dest->name = (char *)((void *)0);
  }
#line 124
  return (0);
}
}
#line 140 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/location.c"
int copy_Location(Location_t const   *source , Location_t *dest ) 
{ 
  int retval ;

  {
  {
#line 144
  retval = copy_Timezone(& source->tz, & dest->tz);
  }
#line 145
  if (0 != retval) {
#line 146
    return (retval);
  }
#line 148
  dest->unknownExists = (uint8_t )source->unknownExists;
#line 149
  dest->unknown = (uint8_t )source->unknown;
#line 150
  dest->latitude.degrees = (int16_t )source->latitude.degrees;
#line 151
  dest->latitude.minutes = (int16_t )source->latitude.minutes;
#line 152
  dest->latitude.direction = (enum CompassDirection )source->latitude.direction;
#line 153
  dest->longitude.degrees = (int16_t )source->longitude.degrees;
#line 154
  dest->longitude.minutes = (int16_t )source->longitude.minutes;
#line 155
  dest->longitude.direction = (enum CompassDirection )source->longitude.direction;
#line 156
  if ((unsigned long )((void *)0) != (unsigned long )source->note) {
    {
#line 157
    dest->note = strdup((char const   *)source->note);
    }
  } else {
#line 159
    dest->note = (char *)((void *)0);
  }
#line 162
  return (0);
}
}
#line 176 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/location.c"
void free_Location(Location_t *loc ) 
{ 


  {
  {
#line 179
  free_Timezone(& loc->tz);
  }
#line 181
  if ((unsigned long )loc->note != (unsigned long )((void *)0)) {
    {
#line 182
    free((void *)loc->note);
#line 183
    loc->note = (char *)((void *)0);
    }
  }
#line 186
  return;
}
}
#line 199 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/location.c"
Timezone_t *dup_Timezone(Timezone_t const   *tz ) 
{ 
  Timezone_t *retval ;
  void *tmp ;
  int *tmp___0 ;

  {
  {
#line 202
  tmp = malloc(sizeof(Timezone_t ));
#line 202
  retval = (Timezone_t *)tmp;
  }
#line 203
  if ((unsigned long )((void *)0) == (unsigned long )retval) {
    {
#line 204
    tmp___0 = __errno_location();
#line 204
    *tmp___0 = 12;
    }
#line 205
    return ((Timezone_t *)((void *)0));
  }
  {
#line 207
  retval->offset = (int16_t )tz->offset;
#line 208
  retval->t2 = (uint8_t )tz->t2;
#line 209
  memcpy((void */* __restrict  */)(& retval->dstStart), (void const   */* __restrict  */)(& tz->dstStart),
         sizeof(DST_t ));
#line 210
  memcpy((void */* __restrict  */)(& retval->dstEnd), (void const   */* __restrict  */)(& tz->dstEnd),
         sizeof(DST_t ));
#line 211
  retval->dstObserved = (uint8_t )tz->dstObserved;
#line 212
  retval->t4 = (uint8_t )tz->t4;
#line 213
  retval->unknown = (uint8_t )tz->unknown;
  }
#line 214
  if ((unsigned long )((void *)0) != (unsigned long )tz->name) {
    {
#line 215
    retval->name = strdup((char const   *)tz->name);
    }
  } else {
#line 217
    retval->name = (char *)((void *)0);
  }
#line 220
  return (retval);
}
}
#line 234 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/location.c"
void free_Timezone(Timezone_t *tz ) 
{ 


  {
#line 236
  if ((unsigned long )tz->name != (unsigned long )((void *)0)) {
    {
#line 237
    free((void *)tz->name);
#line 238
    tz->name = (char *)((void *)0);
    }
  }
#line 240
  return;
}
}
#line 254 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/location.c"
int unpack_DST(DST_t *dst , pi_buffer_t const   *buf___3 ) 
{ 
  int tmp ;

  {
  {
#line 256
  tmp = unpack_DST_p(dst, (unsigned char const   *)buf___3->data, (size_t const   )0);
  }
#line 256
  return (tmp);
}
}
#line 261 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/location.c"
int unpack_DST_p(DST_t *dst , unsigned char const   *data , size_t const   position ) 
{ 
  uint8_t byte ;

  {
#line 265
  byte = *((unsigned char *)(data + position) + 0);
  {
#line 267
  if ((int )byte == 0) {
#line 267
    goto case_0;
  }
#line 270
  if ((int )byte == 1) {
#line 270
    goto case_1;
  }
#line 273
  if ((int )byte == 2) {
#line 273
    goto case_2;
  }
#line 276
  if ((int )byte == 3) {
#line 276
    goto case_3;
  }
#line 279
  if ((int )byte == 4) {
#line 279
    goto case_4;
  }
#line 282
  if ((int )byte == 5) {
#line 282
    goto case_5;
  }
#line 285
  if ((int )byte == 6) {
#line 285
    goto case_6;
  }
#line 288
  goto switch_default;
  case_0: /* CIL Label */ 
#line 268
  dst->dayOfWeek = (enum DayOfWeek )0;
#line 269
  goto switch_break;
  case_1: /* CIL Label */ 
#line 271
  dst->dayOfWeek = (enum DayOfWeek )1;
#line 272
  goto switch_break;
  case_2: /* CIL Label */ 
#line 274
  dst->dayOfWeek = (enum DayOfWeek )2;
#line 275
  goto switch_break;
  case_3: /* CIL Label */ 
#line 277
  dst->dayOfWeek = (enum DayOfWeek )3;
#line 278
  goto switch_break;
  case_4: /* CIL Label */ 
#line 280
  dst->dayOfWeek = (enum DayOfWeek )4;
#line 281
  goto switch_break;
  case_5: /* CIL Label */ 
#line 283
  dst->dayOfWeek = (enum DayOfWeek )5;
#line 284
  goto switch_break;
  case_6: /* CIL Label */ 
#line 286
  dst->dayOfWeek = (enum DayOfWeek )6;
#line 287
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 289
  printf((char const   */* __restrict  */)"Illegal value found in day of week: 0x%02X\n",
         (int )byte);
  }
#line 290
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 293
  byte = *((unsigned char *)((data + position) + 1) + 0);
  {
#line 295
  if ((int )byte == 0) {
#line 295
    goto case_0___0;
  }
#line 298
  if ((int )byte == 1) {
#line 298
    goto case_1___0;
  }
#line 301
  if ((int )byte == 2) {
#line 301
    goto case_2___0;
  }
#line 304
  if ((int )byte == 3) {
#line 304
    goto case_3___0;
  }
#line 307
  if ((int )byte == 4) {
#line 307
    goto case_4___0;
  }
#line 310
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
#line 296
  dst->weekOfMonth = (enum WeekOfMonth )0;
#line 297
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 299
  dst->weekOfMonth = (enum WeekOfMonth )1;
#line 300
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 302
  dst->weekOfMonth = (enum WeekOfMonth )2;
#line 303
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 305
  dst->weekOfMonth = (enum WeekOfMonth )3;
#line 306
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
#line 308
  dst->weekOfMonth = (enum WeekOfMonth )4;
#line 309
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 311
  printf((char const   */* __restrict  */)"Illegal value found in week: 0x%02Xd\n",
         (int )byte);
  }
#line 312
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
#line 315
  byte = *((unsigned char *)((data + position) + 2) + 0);
  {
#line 317
  if ((int )byte == 0) {
#line 317
    goto case_0___1;
  }
#line 320
  if ((int )byte == 1) {
#line 320
    goto case_1___1;
  }
#line 323
  if ((int )byte == 2) {
#line 323
    goto case_2___1;
  }
#line 326
  if ((int )byte == 3) {
#line 326
    goto case_3___1;
  }
#line 329
  if ((int )byte == 4) {
#line 329
    goto case_4___1;
  }
#line 332
  if ((int )byte == 5) {
#line 332
    goto case_5___0;
  }
#line 335
  if ((int )byte == 6) {
#line 335
    goto case_6___0;
  }
#line 338
  if ((int )byte == 7) {
#line 338
    goto case_7;
  }
#line 341
  if ((int )byte == 8) {
#line 341
    goto case_8;
  }
#line 344
  if ((int )byte == 9) {
#line 344
    goto case_9;
  }
#line 347
  if ((int )byte == 10) {
#line 347
    goto case_10;
  }
#line 350
  if ((int )byte == 11) {
#line 350
    goto case_11;
  }
#line 353
  if ((int )byte == 12) {
#line 353
    goto case_12;
  }
#line 356
  goto switch_default___1;
  case_0___1: /* CIL Label */ 
#line 318
  dst->month = (enum Month )0;
#line 319
  goto switch_break___1;
  case_1___1: /* CIL Label */ 
#line 321
  dst->month = (enum Month )1;
#line 322
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
#line 324
  dst->month = (enum Month )2;
#line 325
  goto switch_break___1;
  case_3___1: /* CIL Label */ 
#line 327
  dst->month = (enum Month )3;
#line 328
  goto switch_break___1;
  case_4___1: /* CIL Label */ 
#line 330
  dst->month = (enum Month )4;
#line 331
  goto switch_break___1;
  case_5___0: /* CIL Label */ 
#line 333
  dst->month = (enum Month )5;
#line 334
  goto switch_break___1;
  case_6___0: /* CIL Label */ 
#line 336
  dst->month = (enum Month )6;
#line 337
  goto switch_break___1;
  case_7: /* CIL Label */ 
#line 339
  dst->month = (enum Month )7;
#line 340
  goto switch_break___1;
  case_8: /* CIL Label */ 
#line 342
  dst->month = (enum Month )8;
#line 343
  goto switch_break___1;
  case_9: /* CIL Label */ 
#line 345
  dst->month = (enum Month )9;
#line 346
  goto switch_break___1;
  case_10: /* CIL Label */ 
#line 348
  dst->month = (enum Month )10;
#line 349
  goto switch_break___1;
  case_11: /* CIL Label */ 
#line 351
  dst->month = (enum Month )11;
#line 352
  goto switch_break___1;
  case_12: /* CIL Label */ 
#line 354
  dst->month = (enum Month )12;
#line 355
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
  {
#line 357
  printf((char const   */* __restrict  */)"Illegal value found in month: 0x%02Xd\n",
         (int )byte);
  }
#line 358
  return (-1);
  switch_break___1: /* CIL Label */ ;
  }
#line 361
  dst->unknown = *((unsigned char *)((data + position) + 3) + 0);
  {
#line 366
  if ((int )dst->unknown == 3) {
#line 366
    goto case_3___2;
  }
#line 366
  if ((int )dst->unknown == 2) {
#line 366
    goto case_3___2;
  }
#line 366
  if ((int )dst->unknown == 1) {
#line 366
    goto case_3___2;
  }
#line 366
  if ((int )dst->unknown == 0) {
#line 366
    goto case_3___2;
  }
#line 369
  goto switch_default___2;
  case_3___2: /* CIL Label */ 
  case_2___2: /* CIL Label */ 
  case_1___2: /* CIL Label */ 
  case_0___2: /* CIL Label */ 
#line 368
  goto switch_break___2;
  switch_default___2: /* CIL Label */ 
  {
#line 370
  printf((char const   */* __restrict  */)"Bad value for DST.unknown: 0x%02x\n", (int )dst->unknown);
  }
#line 371
  return (-1);
  switch_break___2: /* CIL Label */ ;
  }
#line 374
  return (0);
}
}
#line 389 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/location.c"
int unpack_Timezone(Timezone_t *tz , pi_buffer_t const   *buf___3 ) 
{ 
  int tmp ;

  {
  {
#line 391
  tmp = unpack_Timezone_p(tz, (unsigned char const   *)buf___3->data, (size_t const   )0);
  }
#line 391
  return (tmp);
}
}
#line 398 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/location.c"
int unpack_Timezone_p(Timezone_t *tz , unsigned char const   *data , size_t const   position ) 
{ 
  uint8_t byte ;
  size_t localPosition ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 401
  localPosition = (size_t )position;
#line 403
  tz->offset = (int16_t )((unsigned short )(((int )*((unsigned char *)(data + localPosition) + 0) << 8) | (int )*((unsigned char *)(data + localPosition) + 1)));
#line 404
  localPosition += 2UL;
#line 407
  tz->t2 = *((unsigned char *)(data + localPosition) + 0);
#line 408
  localPosition ++;
  {
#line 410
  if ((int )tz->t2 == 0) {
#line 410
    goto case_0;
  }
#line 412
  if ((int )tz->t2 == 1) {
#line 412
    goto case_1;
  }
#line 414
  if ((int )tz->t2 == 2) {
#line 414
    goto case_2;
  }
#line 416
  if ((int )tz->t2 == 3) {
#line 416
    goto case_3;
  }
#line 418
  goto switch_default;
  case_0: /* CIL Label */ 
#line 411
  goto switch_break;
  case_1: /* CIL Label */ 
#line 413
  goto switch_break;
  case_2: /* CIL Label */ 
#line 415
  goto switch_break;
  case_3: /* CIL Label */ 
#line 417
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 420
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 423
  tmp = unpack_DST_p(& tz->dstStart, data, (size_t const   )localPosition);
  }
#line 423
  if (tmp != 0) {
#line 424
    return (-1);
  }
  {
#line 426
  localPosition += 4UL;
#line 428
  tmp___0 = unpack_DST_p(& tz->dstEnd, data, (size_t const   )localPosition);
  }
#line 428
  if (tmp___0 != 0) {
#line 429
    return (-1);
  }
#line 431
  localPosition += 4UL;
#line 433
  byte = *((unsigned char *)(data + localPosition) + 0);
#line 434
  localPosition ++;
  {
#line 436
  if ((int )byte == 60) {
#line 436
    goto case_60;
  }
#line 440
  if ((int )byte == 0) {
#line 440
    goto case_0___0;
  }
#line 444
  goto switch_default___0;
  case_60: /* CIL Label */ 
#line 438
  tz->dstObserved = (uint8_t )1;
#line 439
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
#line 442
  tz->dstObserved = (uint8_t )0;
#line 443
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 445
  printf((char const   */* __restrict  */)"Illegal value in dst_observed 0x%02X\n",
         (int )byte);
  }
#line 446
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
#line 449
  tz->t4 = *((unsigned char *)(data + localPosition) + 0);
#line 450
  localPosition ++;
#line 452
  tz->unknown = *((unsigned char *)(data + localPosition) + 0);
#line 453
  localPosition ++;
  {
#line 456
  if ((int )tz->unknown == 0) {
#line 456
    goto case_0___1;
  }
#line 456
  if ((int )tz->unknown == 128) {
#line 456
    goto case_0___1;
  }
#line 458
  goto switch_default___1;
  case_0___1: /* CIL Label */ 
  case_128: /* CIL Label */ 
#line 457
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
  {
#line 459
  printf((char const   */* __restrict  */)"Bad value for unknown 0x%02X\n", (int )tz->unknown);
  }
#line 460
  return (-1);
  switch_break___1: /* CIL Label */ ;
  }
#line 463
  if ((unsigned long )((unsigned char const   *)0) == (unsigned long )(data + localPosition)) {
#line 464
    tz->name = (char *)((void *)0);
#line 465
    localPosition ++;
  } else {
    {
#line 467
    tz->name = strdup((char const   *)((char *)(data + localPosition)));
#line 468
    tmp___1 = strlen((char const   *)tz->name);
#line 468
    localPosition += tmp___1 + 1UL;
    }
  }
#line 471
  return ((int )localPosition);
}
}
#line 486 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/location.c"
int unpack_Location(Location_t *loc , pi_buffer_t const   *buf___3 ) 
{ 
  size_t localPosition ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 489
  localPosition = (size_t )0;
#line 491
  tmp = unpack_Timezone_p(& loc->tz, (unsigned char const   *)buf___3->data, (size_t const   )localPosition);
#line 491
  localPosition = (size_t )tmp;
  }
#line 492
  if (localPosition < 0UL) {
#line 493
    return (-1);
  }
#line 496
  loc->unknownExists = (uint8_t )0;
#line 499
  loc->latitude.degrees = (int16_t )((unsigned short )(((int )*((unsigned char *)(buf___3->data + localPosition) + 0) << 8) | (int )*((unsigned char *)(buf___3->data + localPosition) + 1)));
#line 500
  loc->latitude.minutes = (int16_t )((unsigned short )(((int )*((unsigned char *)((buf___3->data + localPosition) + 2) + 0) << 8) | (int )*((unsigned char *)((buf___3->data + localPosition) + 2) + 1)));
#line 501
  if ((int )loc->latitude.degrees > 90) {
#line 501
    goto _L;
  } else
#line 501
  if ((int )loc->latitude.degrees < -90) {
#line 501
    goto _L;
  } else
#line 501
  if ((int )loc->latitude.minutes > 60) {
#line 501
    goto _L;
  } else
#line 501
  if ((int )loc->latitude.minutes < -60) {
    _L: /* CIL Label */ 
#line 508
    loc->unknownExists = (uint8_t )1;
#line 509
    loc->unknown = *((unsigned char *)(buf___3->data + localPosition) + 0);
#line 510
    localPosition ++;
#line 514
    loc->latitude.degrees = (int16_t )((unsigned short )(((int )*((unsigned char *)(buf___3->data + localPosition) + 0) << 8) | (int )*((unsigned char *)(buf___3->data + localPosition) + 1)));
#line 515
    localPosition += 2UL;
#line 516
    loc->latitude.minutes = (int16_t )((unsigned short )(((int )*((unsigned char *)(buf___3->data + localPosition) + 0) << 8) | (int )*((unsigned char *)(buf___3->data + localPosition) + 1)));
#line 517
    localPosition += 2UL;
  } else {
#line 519
    localPosition += 4UL;
  }
#line 522
  loc->longitude.degrees = (int16_t )((unsigned short )(((int )*((unsigned char *)(buf___3->data + localPosition) + 0) << 8) | (int )*((unsigned char *)(buf___3->data + localPosition) + 1)));
#line 523
  localPosition += 2UL;
#line 524
  loc->longitude.minutes = (int16_t )((unsigned short )(((int )*((unsigned char *)(buf___3->data + localPosition) + 0) << 8) | (int )*((unsigned char *)(buf___3->data + localPosition) + 1)));
#line 525
  localPosition += 2UL;
#line 528
  loc->latitude.direction = (enum CompassDirection )2;
#line 529
  loc->longitude.direction = (enum CompassDirection )3;
#line 530
  if ((int )loc->latitude.minutes < 0) {
#line 531
    loc->latitude.direction = (enum CompassDirection )0;
#line 532
    loc->latitude.minutes = (int16_t )(-1 * (int )loc->latitude.minutes);
  }
#line 534
  if ((int )loc->latitude.degrees < 0) {
#line 535
    loc->latitude.direction = (enum CompassDirection )0;
#line 536
    loc->latitude.degrees = (int16_t )(-1 * (int )loc->latitude.degrees);
  }
#line 538
  if ((int )loc->longitude.minutes < 0) {
#line 539
    loc->longitude.direction = (enum CompassDirection )1;
#line 540
    loc->longitude.minutes = (int16_t )(-1 * (int )loc->longitude.minutes);
  }
#line 542
  if ((int )loc->longitude.degrees < 0) {
#line 543
    loc->longitude.direction = (enum CompassDirection )1;
#line 544
    loc->longitude.degrees = (int16_t )(-1 * (int )loc->longitude.degrees);
  }
#line 548
  if (0 == (int )*(buf___3->data + localPosition)) {
#line 549
    loc->note = (char *)((void *)0);
#line 550
    localPosition ++;
  } else {
    {
#line 552
    loc->note = strdup((char const   *)((char *)(buf___3->data + localPosition)));
#line 553
    tmp___0 = strlen((char const   *)loc->note);
#line 553
    localPosition += tmp___0 + 1UL;
    }
  }
#line 556
  return (0);
}
}
#line 572 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/location.c"
int pack_DST(DST_t const   *dst , pi_buffer_t *buf___3 ) 
{ 
  size_t offset ;

  {
#line 577
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 578
    return (-1);
  } else
#line 577
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
#line 578
    return (-1);
  }
  {
#line 580
  offset = buf___3->used;
#line 582
  pi_buffer_expect(buf___3, buf___3->used + 4UL);
#line 583
  buf___3->used += 4UL;
  }
  {
#line 586
  if ((unsigned int const   )dst->dayOfWeek == 0U) {
#line 586
    goto case_0;
  }
#line 589
  if ((unsigned int const   )dst->dayOfWeek == 1U) {
#line 589
    goto case_1;
  }
#line 592
  if ((unsigned int const   )dst->dayOfWeek == 2U) {
#line 592
    goto case_2;
  }
#line 595
  if ((unsigned int const   )dst->dayOfWeek == 3U) {
#line 595
    goto case_3;
  }
#line 598
  if ((unsigned int const   )dst->dayOfWeek == 4U) {
#line 598
    goto case_4;
  }
#line 601
  if ((unsigned int const   )dst->dayOfWeek == 5U) {
#line 601
    goto case_5;
  }
#line 604
  if ((unsigned int const   )dst->dayOfWeek == 6U) {
#line 604
    goto case_6;
  }
#line 607
  goto switch_default;
  case_0: /* CIL Label */ 
#line 587
  *((buf___3->data + offset) + 0) = (unsigned char)0;
#line 588
  goto switch_break;
  case_1: /* CIL Label */ 
#line 590
  *((buf___3->data + offset) + 0) = (unsigned char)1;
#line 591
  goto switch_break;
  case_2: /* CIL Label */ 
#line 593
  *((buf___3->data + offset) + 0) = (unsigned char)2;
#line 594
  goto switch_break;
  case_3: /* CIL Label */ 
#line 596
  *((buf___3->data + offset) + 0) = (unsigned char)3;
#line 597
  goto switch_break;
  case_4: /* CIL Label */ 
#line 599
  *((buf___3->data + offset) + 0) = (unsigned char)4;
#line 600
  goto switch_break;
  case_5: /* CIL Label */ 
#line 602
  *((buf___3->data + offset) + 0) = (unsigned char)5;
#line 603
  goto switch_break;
  case_6: /* CIL Label */ 
#line 605
  *((buf___3->data + offset) + 0) = (unsigned char)6;
#line 606
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 608
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 613
  if ((unsigned int const   )dst->weekOfMonth == 0U) {
#line 613
    goto case_0___0;
  }
#line 616
  if ((unsigned int const   )dst->weekOfMonth == 1U) {
#line 616
    goto case_1___0;
  }
#line 619
  if ((unsigned int const   )dst->weekOfMonth == 2U) {
#line 619
    goto case_2___0;
  }
#line 622
  if ((unsigned int const   )dst->weekOfMonth == 3U) {
#line 622
    goto case_3___0;
  }
#line 625
  if ((unsigned int const   )dst->weekOfMonth == 4U) {
#line 625
    goto case_4___0;
  }
#line 628
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
#line 614
  *(((buf___3->data + offset) + 1) + 0) = (unsigned char)0;
#line 615
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 617
  *(((buf___3->data + offset) + 1) + 0) = (unsigned char)1;
#line 618
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 620
  *(((buf___3->data + offset) + 1) + 0) = (unsigned char)2;
#line 621
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 623
  *(((buf___3->data + offset) + 1) + 0) = (unsigned char)3;
#line 624
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
#line 626
  *(((buf___3->data + offset) + 1) + 0) = (unsigned char)4;
#line 627
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 629
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 634
  if ((unsigned int const   )dst->month == 0U) {
#line 634
    goto case_0___1;
  }
#line 637
  if ((unsigned int const   )dst->month == 1U) {
#line 637
    goto case_1___1;
  }
#line 640
  if ((unsigned int const   )dst->month == 2U) {
#line 640
    goto case_2___1;
  }
#line 643
  if ((unsigned int const   )dst->month == 3U) {
#line 643
    goto case_3___1;
  }
#line 646
  if ((unsigned int const   )dst->month == 4U) {
#line 646
    goto case_4___1;
  }
#line 649
  if ((unsigned int const   )dst->month == 5U) {
#line 649
    goto case_5___0;
  }
#line 652
  if ((unsigned int const   )dst->month == 6U) {
#line 652
    goto case_6___0;
  }
#line 655
  if ((unsigned int const   )dst->month == 7U) {
#line 655
    goto case_7;
  }
#line 658
  if ((unsigned int const   )dst->month == 8U) {
#line 658
    goto case_8;
  }
#line 661
  if ((unsigned int const   )dst->month == 9U) {
#line 661
    goto case_9;
  }
#line 664
  if ((unsigned int const   )dst->month == 10U) {
#line 664
    goto case_10;
  }
#line 667
  if ((unsigned int const   )dst->month == 11U) {
#line 667
    goto case_11;
  }
#line 670
  if ((unsigned int const   )dst->month == 12U) {
#line 670
    goto case_12;
  }
#line 673
  goto switch_default___1;
  case_0___1: /* CIL Label */ 
#line 635
  *(((buf___3->data + offset) + 2) + 0) = (unsigned char)0;
#line 636
  goto switch_break___1;
  case_1___1: /* CIL Label */ 
#line 638
  *(((buf___3->data + offset) + 2) + 0) = (unsigned char)1;
#line 639
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
#line 641
  *(((buf___3->data + offset) + 2) + 0) = (unsigned char)2;
#line 642
  goto switch_break___1;
  case_3___1: /* CIL Label */ 
#line 644
  *(((buf___3->data + offset) + 2) + 0) = (unsigned char)3;
#line 645
  goto switch_break___1;
  case_4___1: /* CIL Label */ 
#line 647
  *(((buf___3->data + offset) + 2) + 0) = (unsigned char)4;
#line 648
  goto switch_break___1;
  case_5___0: /* CIL Label */ 
#line 650
  *(((buf___3->data + offset) + 2) + 0) = (unsigned char)5;
#line 651
  goto switch_break___1;
  case_6___0: /* CIL Label */ 
#line 653
  *(((buf___3->data + offset) + 2) + 0) = (unsigned char)6;
#line 654
  goto switch_break___1;
  case_7: /* CIL Label */ 
#line 656
  *(((buf___3->data + offset) + 2) + 0) = (unsigned char)7;
#line 657
  goto switch_break___1;
  case_8: /* CIL Label */ 
#line 659
  *(((buf___3->data + offset) + 2) + 0) = (unsigned char)8;
#line 660
  goto switch_break___1;
  case_9: /* CIL Label */ 
#line 662
  *(((buf___3->data + offset) + 2) + 0) = (unsigned char)9;
#line 663
  goto switch_break___1;
  case_10: /* CIL Label */ 
#line 665
  *(((buf___3->data + offset) + 2) + 0) = (unsigned char)10;
#line 666
  goto switch_break___1;
  case_11: /* CIL Label */ 
#line 668
  *(((buf___3->data + offset) + 2) + 0) = (unsigned char)11;
#line 669
  goto switch_break___1;
  case_12: /* CIL Label */ 
#line 671
  *(((buf___3->data + offset) + 2) + 0) = (unsigned char)12;
#line 672
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 674
  return (-1);
  switch_break___1: /* CIL Label */ ;
  }
#line 677
  *(((buf___3->data + offset) + 3) + 0) = (unsigned char )dst->unknown;
#line 679
  return (0);
}
}
#line 694 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/location.c"
int pack_Timezone(Timezone_t const   *tz , pi_buffer_t *buf___3 ) 
{ 
  size_t offset ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 700
  if ((unsigned long )tz == (unsigned long )((void *)0)) {
#line 701
    return (-1);
  } else
#line 700
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
#line 701
    return (-1);
  }
  {
#line 703
  offset = buf___3->used;
#line 704
  pi_buffer_expect(buf___3, buf___3->used + 3UL);
#line 705
  buf___3->used += 3UL;
#line 707
  *((buf___3->data + offset) + 0) = (unsigned char )(((int )((unsigned short )tz->offset) >> 8) & 255);
#line 707
  *((buf___3->data + offset) + 1) = (unsigned char )((int )((unsigned short )tz->offset) & 255);
#line 708
  *(((buf___3->data + offset) + 2) + 0) = (unsigned char )tz->t2;
#line 710
  pack_DST(& tz->dstStart, buf___3);
#line 711
  pack_DST(& tz->dstEnd, buf___3);
#line 713
  offset = buf___3->used;
#line 714
  pi_buffer_expect(buf___3, buf___3->used + 3UL);
#line 715
  buf___3->used += 3UL;
  }
#line 717
  if (tz->dstObserved) {
#line 718
    *((buf___3->data + offset) + 0) = (unsigned char)60;
  } else {
#line 720
    *((buf___3->data + offset) + 0) = (unsigned char)0;
  }
#line 722
  *((buf___3->data + offset) + 0) = (unsigned char )tz->t4;
#line 724
  if ((unsigned long )((void *)0) != (unsigned long )tz->name) {
    {
#line 725
    offset = buf___3->used;
#line 726
    tmp = strlen((char const   *)tz->name);
#line 726
    pi_buffer_expect(buf___3, (buf___3->used + tmp) + 1UL);
#line 727
    tmp___0 = strlen((char const   *)tz->name);
#line 727
    buf___3->used = (buf___3->used + tmp___0) + 1UL;
#line 729
    strcpy((char */* __restrict  */)((char *)(buf___3->data + offset)), (char const   */* __restrict  */)tz->name);
    }
  }
#line 732
  return (0);
}
}
#line 747 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/location.c"
int pack_Location(Location_t const   *loc , pi_buffer_t *buf___3 ) 
{ 
  size_t offset ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 752
  if ((unsigned long )loc == (unsigned long )((void *)0)) {
#line 753
    return (-1);
  } else
#line 752
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
#line 753
    return (-1);
  }
  {
#line 755
  pack_Timezone(& loc->tz, buf___3);
  }
#line 757
  if (loc->unknownExists) {
    {
#line 758
    offset = buf___3->used;
#line 759
    pi_buffer_expect(buf___3, buf___3->used + 1UL);
#line 760
    (buf___3->used) ++;
#line 761
    *((buf___3->data + offset) + 0) = (unsigned char )loc->unknown;
    }
  }
  {
#line 764
  offset = buf___3->used;
#line 765
  pi_buffer_expect(buf___3, buf___3->used + 8UL);
#line 766
  buf___3->used += 8UL;
  }
#line 768
  if ((unsigned int const   )loc->latitude.direction == 0U) {
#line 769
    *((buf___3->data + offset) + 0) = (unsigned char )(((int )((unsigned short )(-1 * (int )loc->latitude.degrees)) >> 8) & 255);
#line 769
    *((buf___3->data + offset) + 1) = (unsigned char )((int )((unsigned short )(-1 * (int )loc->latitude.degrees)) & 255);
#line 770
    *(((buf___3->data + offset) + 2) + 0) = (unsigned char )(((int )((unsigned short )(-1 * (int )loc->latitude.minutes)) >> 8) & 255);
#line 770
    *(((buf___3->data + offset) + 2) + 1) = (unsigned char )((int )((unsigned short )(-1 * (int )loc->latitude.minutes)) & 255);
  } else {
#line 772
    *((buf___3->data + offset) + 0) = (unsigned char )(((int )((unsigned short )loc->latitude.degrees) >> 8) & 255);
#line 772
    *((buf___3->data + offset) + 1) = (unsigned char )((int )((unsigned short )loc->latitude.degrees) & 255);
#line 773
    *(((buf___3->data + offset) + 2) + 0) = (unsigned char )(((int )((unsigned short )loc->latitude.minutes) >> 8) & 255);
#line 773
    *(((buf___3->data + offset) + 2) + 1) = (unsigned char )((int )((unsigned short )loc->latitude.minutes) & 255);
  }
#line 775
  if ((unsigned int const   )loc->longitude.direction == 1U) {
#line 776
    *(((buf___3->data + offset) + 4) + 0) = (unsigned char )(((int )((unsigned short )(-1 * (int )loc->longitude.degrees)) >> 8) & 255);
#line 776
    *(((buf___3->data + offset) + 4) + 1) = (unsigned char )((int )((unsigned short )(-1 * (int )loc->longitude.degrees)) & 255);
#line 777
    *(((buf___3->data + offset) + 6) + 0) = (unsigned char )(((int )((unsigned short )(-1 * (int )loc->longitude.minutes)) >> 8) & 255);
#line 777
    *(((buf___3->data + offset) + 6) + 1) = (unsigned char )((int )((unsigned short )(-1 * (int )loc->longitude.minutes)) & 255);
  } else {
#line 779
    *(((buf___3->data + offset) + 4) + 0) = (unsigned char )(((int )((unsigned short )loc->longitude.degrees) >> 8) & 255);
#line 779
    *(((buf___3->data + offset) + 4) + 1) = (unsigned char )((int )((unsigned short )loc->longitude.degrees) & 255);
#line 780
    *(((buf___3->data + offset) + 6) + 0) = (unsigned char )(((int )((unsigned short )loc->longitude.minutes) >> 8) & 255);
#line 780
    *(((buf___3->data + offset) + 6) + 1) = (unsigned char )((int )((unsigned short )loc->longitude.minutes) & 255);
  }
#line 783
  if ((unsigned long )((void *)0) != (unsigned long )loc->note) {
    {
#line 784
    offset = buf___3->used;
#line 785
    tmp = strlen((char const   *)loc->note);
#line 785
    pi_buffer_expect(buf___3, (buf___3->used + tmp) + 1UL);
#line 786
    tmp___0 = strlen((char const   *)loc->note);
#line 786
    buf___3->used = (buf___3->used + tmp___0) + 1UL;
#line 788
    strcpy((char */* __restrict  */)((char *)(buf___3->data + offset)), (char const   */* __restrict  */)loc->note);
    }
  } else {
    {
#line 790
    offset = buf___3->used;
#line 791
    pi_buffer_expect(buf___3, buf___3->used + 1UL);
#line 792
    *((buf___3->data + offset) + 0) = (unsigned char)0;
#line 793
    (buf___3->used) ++;
    }
  }
#line 797
  return (0);
}
}
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 460 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 61 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) cfsetspeed)(struct termios *__termios_p ,
                                                                                 speed_t __speed ) ;
#line 66
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 76
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) cfmakeraw)(struct termios *__termios_p ) ;
#line 124 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static int s_open(pi_socket_t *ps , struct pi_sockaddr *addr , size_t addrlen ) ;
#line 126
static int s_close(pi_socket_t *ps ) ;
#line 127
static int s_changebaud(pi_socket_t *ps ) ;
#line 128
static ssize_t s_write(pi_socket_t *ps , unsigned char const   *buf___3 , size_t len ,
                       int flags ) ;
#line 130
static ssize_t s_read(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) ;
#line 132
static int s_poll(pi_socket_t *ps , int timeout ) ;
#line 134
static speed_t calcrate(int baudrate ) ;
#line 136
static int s_flush(pi_socket_t *ps , int flags ) ;
#line 155 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static int s_open(pi_socket_t *ps , struct pi_sockaddr *addr , size_t addrlen ) 
{ 
  int fd ;
  int i ;
  char *tty ;
  struct pi_serial_data *data ;
  struct termios tcn ;
  int *tmp ;
  int tmp___0 ;
  speed_t tmp___1 ;

  {
  {
#line 160
  tty = addr->pi_device;
#line 162
  data = (struct pi_serial_data *)(ps->device)->data;
#line 170
  fd = open((char const   *)tty, 2050);
  }
#line 170
  if (fd < 0) {
#line 171
    ps->last_error = -502;
#line 172
    return (-502);
  }
  {
#line 175
  tmp___0 = isatty(fd);
  }
#line 175
  if (! tmp___0) {
    {
#line 176
    close(fd);
#line 177
    tmp = __errno_location();
#line 177
    *tmp = 22;
#line 178
    ps->last_error = -502;
    }
#line 179
    return (-502);
  }
  {
#line 184
  tcgetattr(fd, & tcn);
#line 186
  data->tco = tcn;
#line 187
  tcn.c_oflag = (tcflag_t )0;
#line 188
  tcn.c_iflag = (tcflag_t )5;
#line 189
  tcn.c_cflag = (tcflag_t )2224;
#line 191
  tmp___1 = calcrate(data->rate);
#line 191
  cfsetspeed(& tcn, tmp___1);
#line 193
  tcn.c_lflag = (tcflag_t )128;
#line 195
  cfmakeraw(& tcn);
#line 197
  i = 0;
  }
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! (i < 16)) {
#line 197
      goto while_break;
    }
#line 198
    tcn.c_cc[i] = (cc_t )0;
#line 197
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 200
  tcn.c_cc[6] = (cc_t )1;
#line 201
  tcn.c_cc[5] = (cc_t )0;
#line 203
  tcsetattr(fd, 0, (struct termios  const  *)(& tcn));
#line 217
  i = fcntl(fd, 3, 0);
  }
#line 217
  if (i != -1) {
    {
#line 218
    i &= -2049;
#line 219
    fcntl(fd, 4, i);
    }
  }
  {
#line 222
  i = pi_socket_setsd(ps, fd);
  }
#line 222
  if (i < 0) {
#line 223
    return (i);
  }
#line 225
  return (fd);
}
}
#line 240 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static int s_close(pi_socket_t *ps ) 
{ 
  int tmp ;

  {
  {
#line 255
  pi_log(2, 4, "DEV CLOSE unixserial fd: %d\n", ps->sd);
#line 258
  tmp = close(ps->sd);
  }
#line 258
  return (tmp);
}
}
#line 273 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static int s_poll(pi_socket_t *ps , int timeout ) 
{ 
  struct pi_serial_data *data ;
  struct timeval t ;
  fd_set ready ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 276
  data = (struct pi_serial_data *)(ps->device)->data;
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 281
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 286
  if (timeout == 0) {
    {
#line 287
    select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
           (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
    }
  } else {
    {
#line 289
    t.tv_sec = (__time_t )(timeout / 1000);
#line 290
    t.tv_usec = (__suseconds_t )((timeout % 1000) * 1000);
#line 291
    tmp___0 = select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
                     (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
    }
#line 291
    if (tmp___0 == 0) {
      {
#line 292
      tmp = pi_set_error(ps->sd, -202);
      }
#line 292
      return (tmp);
    }
  }
#line 295
  if (! ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
    {
#line 297
    pi_log(2, 2, "DEV POLL unixserial timeout\n");
#line 299
    (data->rx_errors) ++;
#line 300
    tmp___1 = __errno_location();
#line 300
    *tmp___1 = 110;
#line 301
    tmp___2 = pi_set_error(ps->sd, -202);
    }
#line 301
    return (tmp___2);
  }
  {
#line 303
  pi_log(2, 8, "DEV POLL unixserial found data on fd: %d\n", ps->sd);
  }
#line 306
  return (0);
}
}
#line 321 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static ssize_t s_write(pi_socket_t *ps , unsigned char const   *buf___3 , size_t len ,
                       int flags ) 
{ 
  ssize_t total ;
  ssize_t nwrote ;
  struct pi_serial_data *data ;
  struct timeval t ;
  fd_set ready ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 327
  data = (struct pi_serial_data *)(ps->device)->data;
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 332
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 335
  total = (ssize_t )len;
  {
#line 336
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 336
    if (! (total > 0L)) {
#line 336
      goto while_break___0;
    }
#line 337
    if (data->timeout == 0) {
      {
#line 338
      select(ps->sd + 1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)(& ready),
             (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
      }
    } else {
      {
#line 340
      t.tv_sec = (__time_t )(data->timeout / 1000);
#line 341
      t.tv_usec = (__suseconds_t )((data->timeout % 1000) * 1000);
#line 342
      tmp___0 = select(ps->sd + 1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)(& ready),
                       (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
      }
#line 342
      if (tmp___0 == 0) {
        {
#line 343
        tmp = pi_set_error(ps->sd, -202);
        }
#line 343
        return ((ssize_t )tmp);
      }
    }
#line 346
    if (! ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
      {
#line 347
      tmp___1 = pi_set_error(ps->sd, -202);
      }
#line 347
      return ((ssize_t )tmp___1);
    }
    {
#line 349
    nwrote = write(ps->sd, (void const   *)buf___3, len);
    }
#line 350
    if (nwrote < 0L) {
      {
#line 351
      tmp___3 = __errno_location();
      }
#line 351
      if (*tmp___3 == 32) {
        {
#line 352
        ps->state = 8;
#line 353
        tmp___2 = pi_set_error(ps->sd, -200);
        }
#line 353
        return ((ssize_t )tmp___2);
      } else {
        {
#line 351
        tmp___4 = __errno_location();
        }
#line 351
        if (*tmp___4 == 9) {
          {
#line 352
          ps->state = 8;
#line 353
          tmp___2 = pi_set_error(ps->sd, -200);
          }
#line 353
          return ((ssize_t )tmp___2);
        }
      }
      {
#line 355
      tmp___5 = pi_set_error(ps->sd, -204);
      }
#line 355
      return ((ssize_t )tmp___5);
    }
#line 357
    total -= nwrote;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 359
  data->tx_bytes = (int )((size_t )data->tx_bytes + len);
#line 362
  usleep((__useconds_t )(10UL + len));
#line 364
  pi_log(2, 8, "DEV TX unixserial wrote %d bytes\n", len);
  }
#line 367
  return ((ssize_t )len);
}
}
#line 382 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static size_t s_read_buf(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) 
{ 
  struct pi_serial_data *data ;
  size_t rbuf ;
  int *tmp ;
  int tmp___0 ;
  pi_buffer_t *tmp___1 ;

  {
#line 385
  data = (struct pi_serial_data *)(ps->device)->data;
#line 387
  rbuf = data->buf_size;
#line 389
  if (rbuf > len) {
#line 390
    rbuf = len;
  }
  {
#line 392
  tmp___1 = pi_buffer_append(buf___3, (void const   *)(data->buf), rbuf);
  }
#line 392
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 393
    tmp = __errno_location();
#line 393
    *tmp = 12;
#line 394
    tmp___0 = pi_set_error(ps->sd, -500);
    }
#line 394
    return ((size_t )tmp___0);
  }
#line 397
  if (flags != 1) {
#line 398
    data->buf_size -= rbuf;
#line 399
    if (data->buf_size > 0UL) {
      {
#line 400
      memmove((void *)(data->buf), (void const   *)(& data->buf[rbuf]), data->buf_size);
      }
    }
  }
  {
#line 403
  pi_log(2, 8, "DEV RX unixserial read %d bytes from read-ahead buffer\n", rbuf);
  }
#line 406
  return (rbuf);
}
}
#line 420 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static ssize_t s_read(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) 
{ 
  ssize_t rbuf ;
  ssize_t bytes ;
  struct pi_serial_data *data ;
  struct timeval t ;
  fd_set ready ;
  size_t tmp ;
  int __d0 ;
  int __d1 ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  pi_buffer_t *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
#line 423
  rbuf = (ssize_t )0;
#line 425
  data = (struct pi_serial_data *)(ps->device)->data;
#line 431
  if (data->buf_size) {
    {
#line 432
    tmp = s_read_buf(ps, buf___3, len, flags);
#line 432
    rbuf = (ssize_t )tmp;
    }
#line 433
    if (rbuf < 0L) {
#line 434
      return (rbuf);
    }
#line 435
    len -= (size_t )rbuf;
#line 436
    if (len == 0UL) {
#line 437
      return (rbuf);
    }
  }
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 442
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 444
  if (data->timeout == 0) {
    {
#line 445
    select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
           (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
    }
  } else {
    {
#line 447
    t.tv_sec = (__time_t )(data->timeout / 1000);
#line 448
    t.tv_usec = (__suseconds_t )((data->timeout % 1000) * 1000);
#line 449
    tmp___1 = select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
                     (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
    }
#line 449
    if (tmp___1 == 0) {
      {
#line 450
      tmp___0 = pi_set_error(ps->sd, -202);
      }
#line 450
      return ((ssize_t )tmp___0);
    }
  }
#line 454
  if ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 455
    if (flags == 1) {
#line 455
      if (len > 256UL) {
#line 456
        len = (size_t )256;
      }
    }
    {
#line 458
    tmp___4 = pi_buffer_expect(buf___3, len);
    }
#line 458
    if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
      {
#line 459
      tmp___2 = __errno_location();
#line 459
      *tmp___2 = 12;
#line 460
      tmp___3 = pi_set_error(ps->sd, -500);
      }
#line 460
      return ((ssize_t )tmp___3);
    }
    {
#line 463
    bytes = read(ps->sd, (void *)(buf___3->data + buf___3->used), len);
    }
#line 465
    if (bytes > 0L) {
#line 466
      if (flags == 1) {
        {
#line 467
        memcpy((void */* __restrict  */)(data->buf + data->buf_size), (void const   */* __restrict  */)(buf___3->data + buf___3->used),
               (size_t )bytes);
#line 468
        data->buf_size += (size_t )bytes;
        }
      }
      {
#line 470
      buf___3->used += (size_t )bytes;
#line 471
      data->rx_bytes = (int )((ssize_t )data->rx_bytes + bytes);
#line 472
      rbuf += bytes;
#line 474
      pi_log(2, 8, "DEV RX unixserial read %d bytes\n", bytes);
      }
    } else
#line 476
    if (bytes < 0L) {
#line 477
      rbuf = bytes;
    }
  } else {
    {
#line 480
    pi_log(2, 2, "DEV RX unixserial timeout\n");
#line 482
    (data->rx_errors) ++;
#line 483
    tmp___5 = __errno_location();
#line 483
    *tmp___5 = 110;
#line 484
    tmp___6 = pi_set_error(ps->sd, -202);
    }
#line 484
    return ((ssize_t )tmp___6);
  }
#line 487
  return (rbuf);
}
}
#line 507 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static int s_flush(pi_socket_t *ps , int flags ) 
{ 
  int fl ;
  char buf___3[256] ;
  struct pi_serial_data *data ;
  ssize_t tmp ;

  {
#line 512
  data = (struct pi_serial_data *)(ps->device)->data;
#line 514
  if (flags & 1) {
    {
#line 516
    data->buf_size = (size_t )0;
#line 519
    fl = fcntl(ps->sd, 3, 0);
    }
#line 519
    if (fl != -1) {
      {
#line 521
      fcntl(ps->sd, 4, fl | 2048);
      }
      {
#line 522
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 522
        tmp = recv(ps->sd, (void *)(buf___3), sizeof(buf___3), 0);
        }
#line 522
        if (! (tmp > 0L)) {
#line 522
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 524
      fcntl(ps->sd, 4, fl);
      }
    }
    {
#line 527
    pi_log(2, 8, "DEV FLUSH unixserial flushed input buffer\n");
    }
  }
#line 530
  return (0);
}
}
#line 569 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static int s_changebaud(pi_socket_t *ps ) 
{ 
  struct pi_serial_data *data ;
  struct termios tcn ;
  int tmp ;
  int tmp___0 ;
  speed_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 572
  data = (struct pi_serial_data *)(ps->device)->data;
#line 577
  pi_log(2, 8, "DEV SPEED unixserial switch to %d bps\n", data->rate);
#line 584
  tmp___0 = tcgetattr(ps->sd, & tcn);
  }
#line 584
  if (tmp___0) {
    {
#line 585
    tmp = pi_set_error(ps->sd, -502);
    }
#line 585
    return (tmp);
  }
  {
#line 587
  tcn.c_cflag = (tcflag_t )2224;
#line 588
  tmp___1 = calcrate(data->rate);
#line 588
  cfsetspeed(& tcn, tmp___1);
#line 590
  tmp___3 = tcsetattr(ps->sd, 1, (struct termios  const  *)(& tcn));
  }
#line 590
  if (tmp___3) {
    {
#line 591
    tmp___2 = pi_set_error(ps->sd, -502);
    }
#line 591
    return (tmp___2);
  }
#line 609
  return (0);
}
}
#line 624 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
void pi_serial_impl_init(struct pi_serial_impl *impl ) 
{ 


  {
#line 627
  impl->open = & s_open;
#line 628
  impl->close = & s_close;
#line 629
  impl->changebaud = & s_changebaud;
#line 630
  impl->write = & s_write;
#line 631
  impl->read = & s_read;
#line 632
  impl->flush = & s_flush;
#line 633
  impl->poll = & s_poll;
#line 634
  return;
}
}
#line 649 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static speed_t calcrate(int baudrate ) 
{ 


  {
#line 653
  if (baudrate == 50) {
#line 654
    return ((speed_t )1);
  }
#line 657
  if (baudrate == 75) {
#line 658
    return ((speed_t )2);
  }
#line 661
  if (baudrate == 110) {
#line 662
    return ((speed_t )3);
  }
#line 665
  if (baudrate == 134) {
#line 666
    return ((speed_t )4);
  }
#line 669
  if (baudrate == 150) {
#line 670
    return ((speed_t )5);
  }
#line 673
  if (baudrate == 200) {
#line 674
    return ((speed_t )6);
  }
#line 677
  if (baudrate == 300) {
#line 678
    return ((speed_t )7);
  }
#line 681
  if (baudrate == 600) {
#line 682
    return ((speed_t )8);
  }
#line 685
  if (baudrate == 1200) {
#line 686
    return ((speed_t )9);
  }
#line 689
  if (baudrate == 1800) {
#line 690
    return ((speed_t )10);
  }
#line 693
  if (baudrate == 2400) {
#line 694
    return ((speed_t )11);
  }
#line 697
  if (baudrate == 4800) {
#line 698
    return ((speed_t )12);
  }
#line 701
  if (baudrate == 9600) {
#line 702
    return ((speed_t )13);
  } else
#line 705
  if (baudrate == 19200) {
#line 706
    return ((speed_t )14);
  } else
#line 709
  if (baudrate == 38400) {
#line 710
    return ((speed_t )15);
  } else
#line 713
  if (baudrate == 57600) {
#line 714
    return ((speed_t )4097);
  } else
#line 721
  if (baudrate == 115200) {
#line 722
    return ((speed_t )4098);
  } else
#line 725
  if (baudrate == 230400) {
#line 726
    return ((speed_t )4099);
  } else
#line 729
  if (baudrate == 460800) {
#line 730
    return ((speed_t )4100);
  }
  {
#line 733
  pi_log(2, 1, "DEV Serial CHANGEBAUD Unable to set baud rate %d\n", baudrate);
#line 736
  abort();
  }
#line 737
  return ((speed_t )0);
}
}
#line 41 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/appinfo.c"
int unpack_CategoryAppInfo(CategoryAppInfo_t *ai , unsigned char const   *record ,
                           size_t len ) 
{ 
  int i ;
  int rec ;

  {
#line 47
  if (len < 278UL) {
#line 48
    return (0);
  }
#line 49
  rec = (int )((unsigned short )(((int )*((unsigned char *)record + 0) << 8) | (int )*((unsigned char *)record + 1)));
#line 50
  i = 0;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! (i < 16)) {
#line 50
      goto while_break;
    }
#line 51
    if (rec & (1 << i)) {
#line 52
      ai->renamed[i] = 1U;
    } else {
#line 54
      ai->renamed[i] = 0U;
    }
#line 50
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  record += 2;
#line 57
  i = 0;
  {
#line 57
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 57
    if (! (i < 16)) {
#line 57
      goto while_break___0;
    }
    {
#line 58
    memcpy((void */* __restrict  */)(ai->name[i]), (void const   */* __restrict  */)record,
           (size_t )16);
#line 59
    record += 16;
#line 57
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 61
  memcpy((void */* __restrict  */)(ai->ID), (void const   */* __restrict  */)record,
         (size_t )16);
#line 62
  record += 16;
#line 63
  ai->lastUniqueID = *((unsigned char *)record + 0);
#line 64
  record += 4;
  }
#line 65
  return (278);
}
}
#line 79 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/appinfo.c"
int pack_CategoryAppInfo(CategoryAppInfo_t const   *ai , unsigned char *record , size_t len ) 
{ 
  int i ;
  int rec ;
  unsigned char *start ;

  {
#line 85
  start = record;
#line 87
  if (! record) {
#line 88
    return (278);
  }
#line 90
  if (len < 278UL) {
#line 91
    return (0);
  }
#line 92
  rec = 0;
#line 93
  i = 0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (i < 16)) {
#line 93
      goto while_break;
    }
#line 94
    if (ai->renamed[i]) {
#line 95
      rec |= 1 << i;
    }
#line 93
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  *(record + 0) = (unsigned char )(((int )((unsigned short )rec) >> 8) & 255);
#line 97
  *(record + 1) = (unsigned char )((int )((unsigned short )rec) & 255);
#line 98
  record += 2;
#line 99
  i = 0;
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 99
    if (! (i < 16)) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    memcpy((void */* __restrict  */)record, (void const   */* __restrict  */)(ai->name[i]),
           (size_t )16);
#line 101
    record += 16;
#line 99
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 103
  memcpy((void */* __restrict  */)record, (void const   */* __restrict  */)(ai->ID),
         (size_t )16);
#line 104
  record += 16;
#line 105
  *(record + 0) = (unsigned char )ai->lastUniqueID;
#line 106
  record ++;
#line 107
  *(record + 0) = (unsigned char)0;
#line 108
  *((record + 1) + 0) = (unsigned char)0;
#line 108
  *((record + 1) + 1) = (unsigned char)0;
#line 109
  record += 3;
  }
#line 111
  return ((int )(record - start));
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 59 "../include/pi-debug.h"
void pi_dumpline(char const   *buf___3 , size_t len , unsigned int addr ) ;
#line 31 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
static int debug_types  =    0;
#line 32 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
static int debug_level  =    0;
#line 33 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
static FILE *debug_file  =    (FILE *)((void *)0);
#line 34 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
static int logfile_mutex  =    0;
#line 47 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
int pi_debug_get_types(void) 
{ 


  {
#line 50
  return (debug_types);
}
}
#line 65 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
void pi_debug_set_types(int types ) 
{ 


  {
#line 68
  debug_types = types;
#line 69
  return;
}
}
#line 83 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
int pi_debug_get_level(void) 
{ 


  {
#line 86
  return (debug_level);
}
}
#line 101 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
void pi_debug_set_level(int level ) 
{ 


  {
  {
#line 104
  pi_mutex_lock(& logfile_mutex);
#line 105
  debug_level = level;
#line 106
  pi_mutex_unlock(& logfile_mutex);
  }
#line 107
  return;
}
}
#line 120 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
void pi_debug_set_file(char const   *path ) 
{ 


  {
  {
#line 123
  pi_mutex_lock(& logfile_mutex);
  }
#line 125
  if ((unsigned long )debug_file != (unsigned long )((void *)0)) {
#line 125
    if ((unsigned long )debug_file != (unsigned long )stderr) {
      {
#line 126
      fclose(debug_file);
      }
    }
  }
  {
#line 128
  debug_file = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"a");
  }
#line 129
  if ((unsigned long )debug_file == (unsigned long )((void *)0)) {
#line 130
    debug_file = stderr;
  }
  {
#line 132
  pi_mutex_unlock(& logfile_mutex);
  }
#line 133
  return;
}
}
#line 147 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
void pi_log(int type , int level , char const   *format  , ...) 
{ 
  va_list ap ;

  {
#line 152
  if (! (debug_types & type)) {
#line 152
    if (type != 1024) {
#line 153
      return;
    }
  }
#line 155
  if (debug_level < level) {
#line 156
    return;
  }
  {
#line 158
  pi_mutex_lock(& logfile_mutex);
  }
#line 160
  if ((unsigned long )debug_file == (unsigned long )((void *)0)) {
#line 161
    debug_file = stderr;
  }
  {
#line 166
  __builtin_va_start(ap, format);
#line 167
  vfprintf((FILE */* __restrict  */)debug_file, (char const   */* __restrict  */)format,
           ap);
#line 168
  __builtin_va_end(ap);
#line 170
  fflush(debug_file);
#line 172
  pi_mutex_unlock(& logfile_mutex);
  }
#line 173
  return;
}
}
#line 175 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
void pi_dumpline(char const   *buf___3 , size_t len , unsigned int addr ) 
{ 
  unsigned int i ;
  int offset ;
  char line[256] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 182
  offset = sprintf((char */* __restrict  */)(line), (char const   */* __restrict  */)"  %.4x  ",
                   addr);
#line 184
  i = 0U;
  }
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! (i < 16U)) {
#line 184
      goto while_break;
    }
#line 185
    if ((size_t )i < len) {
      {
#line 186
      tmp = sprintf((char */* __restrict  */)(line + offset), (char const   */* __restrict  */)"%.2x ",
                    255U & (unsigned int )*(buf___3 + i));
#line 186
      offset += tmp;
      }
    } else {
      {
#line 189
      strcpy((char */* __restrict  */)(line + offset), (char const   */* __restrict  */)"   ");
#line 190
      offset += 3;
      }
    }
#line 184
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 194
  strcpy((char */* __restrict  */)(line + offset), (char const   */* __restrict  */)"  ");
#line 195
  offset += 2;
#line 197
  i = 0U;
  }
  {
#line 197
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 197
    if (! ((size_t )i < len)) {
#line 197
      goto while_break___0;
    }
#line 198
    if ((int const   )*(buf___3 + i) == 37) {
#line 202
      tmp___0 = offset;
#line 202
      offset ++;
#line 202
      line[tmp___0] = (char )'%';
#line 203
      tmp___1 = offset;
#line 203
      offset ++;
#line 203
      line[tmp___1] = (char )'%';
    } else {
      {
#line 204
      tmp___4 = __ctype_b_loc();
      }
#line 204
      if ((int const   )*(*tmp___4 + (int )*(buf___3 + i)) & 16384) {
#line 204
        if ((int const   )*(buf___3 + i) >= 32) {
#line 204
          if ((int const   )*(buf___3 + i) <= 126) {
#line 205
            tmp___2 = offset;
#line 205
            offset ++;
#line 205
            line[tmp___2] = (char )*(buf___3 + i);
          } else {
#line 207
            tmp___3 = offset;
#line 207
            offset ++;
#line 207
            line[tmp___3] = (char )'.';
          }
        } else {
#line 207
          tmp___3 = offset;
#line 207
          offset ++;
#line 207
          line[tmp___3] = (char )'.';
        }
      } else {
#line 207
        tmp___3 = offset;
#line 207
        offset ++;
#line 207
        line[tmp___3] = (char )'.';
      }
    }
#line 197
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 210
  strcpy((char */* __restrict  */)(line + offset), (char const   */* __restrict  */)"\n");
  }
#line 212
  return;
}
}
#line 214 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
void dumpline(char const   *buf___3 , size_t len , unsigned int addr ) 
{ 


  {
  {
#line 218
  pi_dumpline(buf___3, len, addr);
  }
#line 219
  return;
}
}
#line 221 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
void pi_dumpdata(char const   *buf___3 , size_t len ) 
{ 
  unsigned int i ;
  size_t tmp ;

  {
#line 226
  i = 0U;
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (! ((size_t )i < len)) {
#line 226
      goto while_break;
    }
#line 227
    if (len - (size_t )i > 16UL) {
#line 227
      tmp = (size_t )16;
    } else {
#line 227
      tmp = len - (size_t )i;
    }
    {
#line 227
    pi_dumpline(buf___3 + i, tmp, i);
#line 226
    i += 16U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  return;
}
}
#line 230 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
void dumpdata(char const   *buf___3 , size_t len ) 
{ 


  {
  {
#line 234
  pi_dumpdata(buf___3, len);
  }
#line 235
  return;
}
}
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 904 "../include/pi-dlp.h"
int dlp_ResetSystem(int sd ) ;
#line 949
int dlp_FindDBByName(int sd , int cardno , char const   *name , unsigned long *localid ,
                     int *dbhandle , struct DBInfo *info , struct DBSizeInfo *size ) ;
#line 1023
int dlp_OpenDB(int sd , int cardno , int mode , char const   *name , int *dbhandle ) ;
#line 1033
int dlp_CloseDB(int sd , int dbhandle ) ;
#line 1049
int dlp_DeleteDB(int sd , int card , char const   *name ) ;
#line 1067
int dlp_CreateDB(int sd , unsigned long creator , unsigned long type , int cardno ,
                 int flags , unsigned int version , char const   *name , int *dbhandle ) ;
#line 1079
int dlp_ReadOpenDBInfo(int sd , int dbhandle , int *records ) ;
#line 1135
int dlp_ReadAppBlock(int sd , int dbhandle , int offset , int reqbytes , pi_buffer_t *retbuf ) ;
#line 1147
int dlp_WriteAppBlock(int sd , int dbhandle , void const   *data , size_t length ) ;
#line 1258
int dlp_ReadRecordByIndex(int sd , int dbhandle , int recindex , pi_buffer_t *buffer ,
                          recordid_t *recuid , int *attr , int *category ) ;
#line 1344
int dlp_WriteRecord(int sd , int dbhandle , int flags , recordid_t recID , int catID ,
                    void const   *data , size_t length , recordid_t *pNewRecID ) ;
#line 1389
int dlp_ReadResourceByIndex(int sd , int dbhandle , unsigned int resindex , pi_buffer_t *buffer ,
                            unsigned long *type , int *resID ) ;
#line 1406
int dlp_WriteResource(int sd , int dbhandle , unsigned long type , int resID , void const   *data ,
                      size_t length ) ;
#line 141 "../include/pi-file.h"
pi_file_t *pi_file_open(char const   *name ) ;
#line 152
pi_file_t *pi_file_create(char const   *name , struct DBInfo  const  *info ) ;
#line 163
int pi_file_close(pi_file_t *pf ) ;
#line 173
void pi_file_get_info(pi_file_t const   *pf , struct DBInfo *infop ) ;
#line 185
void pi_file_get_app_info(pi_file_t *pf , void **datap , size_t *sizep ) ;
#line 197
void pi_file_get_sort_info(pi_file_t *pf , void **datap , size_t *sizep ) ;
#line 213
int pi_file_read_resource(pi_file_t *pf , int i , void **bufp , size_t *sizep , unsigned long *type ,
                          int *idp ) ;
#line 230
int pi_file_read_resource_by_type_id(pi_file_t *pf , unsigned long restype , int resid ,
                                     void **bufp , size_t *sizep , int *resindex ) ;
#line 241
int pi_file_type_id_used(pi_file_t const   *pf , unsigned long restype , int resid ) ;
#line 250
int pi_file_id_used(pi_file_t const   *pf , recordid_t uid ) ;
#line 267
int pi_file_read_record(pi_file_t *pf , int recindex , void **bufp , size_t *sizep ,
                        int *recattrs , int *category , recordid_t *recuid ) ;
#line 285
int pi_file_read_record_by_id(pi_file_t *pf , recordid_t uid , void **bufp , size_t *sizep ,
                              int *idxp , int *attrp , int *catp ) ;
#line 290
void pi_file_get_entries(pi_file_t *pf , int *entries ) ;
#line 298
int pi_file_set_info(pi_file_t *pf , struct DBInfo  const  *ip ) ;
#line 310
int pi_file_set_app_info(pi_file_t *pf , void *data , size_t size ) ;
#line 322
int pi_file_set_sort_info(pi_file_t *pf , void *data , size_t size ) ;
#line 338
int pi_file_append_resource(pi_file_t *pf , void *data , size_t size , unsigned long restype ,
                            int resid ) ;
#line 356
int pi_file_append_record(pi_file_t *pf , void *data , size_t size , int recattrs ,
                          int category , recordid_t recuid ) ;
#line 373
int pi_file_retrieve(pi_file_t *pf , int socket___0 , int cardno , int (*report_progress)(int socket ,
                                                                                          pi_progress_t *progress ) ) ;
#line 387
int pi_file_install(pi_file_t *pf , int socket___0 , int cardno , int (*report_progress)(int socket ,
                                                                                         pi_progress_t *progress ) ) ;
#line 408
int pi_file_merge(pi_file_t *pf , int socket___0 , int cardno , int (*report_progress)(int socket ,
                                                                                       pi_progress_t *progress ) ) ;
#line 420
unsigned long unix_time_to_pilot_time(time_t t ) ;
#line 428
time_t pilot_time_to_unix_time(unsigned long raw_time ) ;
#line 99 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
static int pi_file_close_for_write(pi_file_t *pf ) ;
#line 100
static void pi_file_free(pi_file_t *pf ) ;
#line 101
static int pi_file_find_resource_by_type_id(pi_file_t const   *pf , unsigned long restype ,
                                            int resid , int *resindex ) ;
#line 102
static pi_file_entry_t *pi_file_append_entry(pi_file_t *pf ) ;
#line 103
static int pi_file_set_rbuf_size(pi_file_t *pf , size_t size ) ;
#line 130 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
time_t pilot_time_to_unix_time(unsigned long raw_time ) 
{ 


  {
#line 133
  return ((time_t )(raw_time - 2082844800UL));
}
}
#line 136 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
unsigned long unix_time_to_pilot_time(time_t t ) 
{ 


  {
#line 139
  return ((unsigned long )t + 2082844800UL);
}
}
#line 142 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
pi_file_t *pi_file_open(char const   *name ) 
{ 
  int i ;
  int file_size ;
  pi_file_t *pf ;
  struct DBInfo *ip ;
  pi_file_entry_t *entp ;
  unsigned char buf___3[78] ;
  unsigned char *p ;
  off_t offset ;
  off_t app_info_offset ;
  off_t sort_info_offset ;
  void *tmp ;
  FILE *tmp___0 ;
  long tmp___1 ;
  size_t tmp___2 ;
  struct pi_file_entry *tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;

  {
  {
#line 154
  app_info_offset = (off_t )0;
#line 154
  sort_info_offset = (off_t )0;
#line 156
  tmp = calloc((size_t )1, sizeof(pi_file_t ));
#line 156
  pf = (pi_file_t *)tmp;
  }
#line 156
  if ((unsigned long )pf == (unsigned long )((void *)0)) {
#line 157
    return ((pi_file_t *)((void *)0));
  }
  {
#line 159
  tmp___0 = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"rb");
#line 159
  pf->f = tmp___0;
  }
#line 159
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 160
    goto bad;
  }
  {
#line 162
  fseek(pf->f, 0L, 2);
#line 163
  tmp___1 = ftell(pf->f);
#line 163
  file_size = (int )tmp___1;
#line 164
  fseek(pf->f, 0L, 0);
#line 166
  tmp___2 = fread((void */* __restrict  */)(buf___3), (size_t )78, (size_t )1, (FILE */* __restrict  */)pf->f);
  }
#line 166
  if (tmp___2 != 1UL) {
#line 169
    goto bad;
  }
  {
#line 172
  p = buf___3;
#line 173
  ip = & pf->info;
#line 175
  memcpy((void */* __restrict  */)(ip->name), (void const   */* __restrict  */)p,
         (size_t )32);
#line 176
  ip->flags = (unsigned int )((unsigned short )(((int )*((p + 32) + 0) << 8) | (int )*((p + 32) + 1)));
#line 177
  ip->miscFlags = 64U;
#line 178
  ip->version = (unsigned int )((unsigned short )(((int )*((p + 34) + 0) << 8) | (int )*((p + 34) + 1)));
#line 179
  ip->createDate = pilot_time_to_unix_time(((((unsigned long )*((p + 36) + 0) << 24) | ((unsigned long )*((p + 36) + 1) << 16)) | ((unsigned long )*((p + 36) + 2) << 8)) | (unsigned long )*((p + 36) + 3));
#line 180
  ip->modifyDate = pilot_time_to_unix_time(((((unsigned long )*((p + 40) + 0) << 24) | ((unsigned long )*((p + 40) + 1) << 16)) | ((unsigned long )*((p + 40) + 2) << 8)) | (unsigned long )*((p + 40) + 3));
#line 181
  ip->backupDate = pilot_time_to_unix_time(((((unsigned long )*((p + 44) + 0) << 24) | ((unsigned long )*((p + 44) + 1) << 16)) | ((unsigned long )*((p + 44) + 2) << 8)) | (unsigned long )*((p + 44) + 3));
#line 182
  ip->modnum = ((((unsigned long )*((p + 48) + 0) << 24) | ((unsigned long )*((p + 48) + 1) << 16)) | ((unsigned long )*((p + 48) + 2) << 8)) | (unsigned long )*((p + 48) + 3);
#line 183
  app_info_offset = (off_t )(((((unsigned long )*((p + 52) + 0) << 24) | ((unsigned long )*((p + 52) + 1) << 16)) | ((unsigned long )*((p + 52) + 2) << 8)) | (unsigned long )*((p + 52) + 3));
#line 184
  sort_info_offset = (off_t )(((((unsigned long )*((p + 56) + 0) << 24) | ((unsigned long )*((p + 56) + 1) << 16)) | ((unsigned long )*((p + 56) + 2) << 8)) | (unsigned long )*((p + 56) + 3));
#line 185
  ip->type = ((((unsigned long )*((p + 60) + 0) << 24) | ((unsigned long )*((p + 60) + 1) << 16)) | ((unsigned long )*((p + 60) + 2) << 8)) | (unsigned long )*((p + 60) + 3);
#line 186
  ip->creator = ((((unsigned long )*((p + 64) + 0) << 24) | ((unsigned long )*((p + 64) + 1) << 16)) | ((unsigned long )*((p + 64) + 2) << 8)) | (unsigned long )*((p + 64) + 3);
#line 187
  pf->unique_id_seed = ((((unsigned long )*((p + 68) + 0) << 24) | ((unsigned long )*((p + 68) + 1) << 16)) | ((unsigned long )*((p + 68) + 2) << 8)) | (unsigned long )*((p + 68) + 3);
#line 190
  pf->next_record_list_id = (int )(((((unsigned long )*((p + 72) + 0) << 24) | ((unsigned long )*((p + 72) + 1) << 16)) | ((unsigned long )*((p + 72) + 2) << 8)) | (unsigned long )*((p + 72) + 3));
#line 191
  pf->num_entries = (int )((unsigned short )(((int )*((p + 76) + 0) << 8) | (int )*((p + 76) + 1)));
  }
#line 211
  if (pf->next_record_list_id != 0) {
#line 214
    goto bad;
  }
#line 217
  if (ip->flags & 1U) {
#line 218
    pf->resource_flag = 1;
#line 219
    pf->ent_hdr_size = 10;
  } else {
#line 221
    pf->resource_flag = 0;
#line 222
    pf->ent_hdr_size = 8;
  }
#line 225
  if (pf->num_entries < 0) {
#line 228
    goto bad;
  }
#line 231
  offset = (off_t )file_size;
#line 233
  if (pf->num_entries) {
    {
#line 234
    tmp___4 = calloc((size_t )pf->num_entries, sizeof(*(pf->entries)));
#line 234
    tmp___3 = (struct pi_file_entry *)tmp___4;
#line 234
    pf->entries = tmp___3;
    }
#line 234
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 237
      goto bad;
    }
#line 239
    i = 0;
#line 239
    entp = pf->entries;
    {
#line 239
    while (1) {
      while_continue: /* CIL Label */ ;
#line 239
      if (! (i < pf->num_entries)) {
#line 239
        goto while_break;
      }
      {
#line 241
      tmp___5 = fread((void */* __restrict  */)(buf___3), (size_t )pf->ent_hdr_size,
                      (size_t )1, (FILE */* __restrict  */)pf->f);
      }
#line 241
      if (tmp___5 != 1UL) {
#line 243
        goto bad;
      }
#line 245
      p = buf___3;
#line 246
      if (pf->resource_flag) {
#line 247
        entp->type = ((((unsigned long )*(p + 0) << 24) | ((unsigned long )*(p + 1) << 16)) | ((unsigned long )*(p + 2) << 8)) | (unsigned long )*(p + 3);
#line 248
        entp->resource_id = (int )((unsigned short )(((int )*((p + 4) + 0) << 8) | (int )*((p + 4) + 1)));
#line 249
        entp->offset = (int )(((((unsigned long )*((p + 6) + 0) << 24) | ((unsigned long )*((p + 6) + 1) << 16)) | ((unsigned long )*((p + 6) + 2) << 8)) | (unsigned long )*((p + 6) + 3));
      } else {
#line 256
        entp->offset = (int )(((((unsigned long )*(p + 0) << 24) | ((unsigned long )*(p + 1) << 16)) | ((unsigned long )*(p + 2) << 8)) | (unsigned long )*(p + 3));
#line 257
        entp->attrs = (int )*((p + 4) + 0);
#line 258
        entp->uid = (unsigned long )((((int )*((p + 5) + 0) << 16) | ((int )*((p + 5) + 1) << 8)) | (int )*((p + 5) + 2));
      }
#line 239
      i ++;
#line 239
      entp ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 268
    i = 0;
#line 268
    entp = (pf->entries + pf->num_entries) - 1;
    {
#line 268
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 268
      if (! (i < pf->num_entries)) {
#line 268
        goto while_break___0;
      }
#line 270
      entp->size = (int )(offset - (off_t )entp->offset);
#line 271
      offset = (off_t )entp->offset;
#line 277
      if (entp->size < 0) {
#line 283
        goto bad;
      } else
#line 277
      if (entp->offset + entp->size > file_size) {
#line 283
        goto bad;
      }
#line 268
      i ++;
#line 268
      entp --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 288
  if (sort_info_offset) {
#line 289
    pf->sort_info_size = (int )(offset - sort_info_offset);
#line 290
    offset = sort_info_offset;
  }
#line 293
  if (app_info_offset) {
#line 294
    pf->app_info_size = (int )(offset - app_info_offset);
#line 295
    offset = app_info_offset;
  }
#line 298
  if (pf->app_info_size < 0) {
#line 308
    goto bad;
  } else
#line 298
  if (sort_info_offset + (off_t )pf->sort_info_size > (off_t )file_size) {
#line 308
    goto bad;
  } else
#line 298
  if (pf->sort_info_size < 0) {
#line 308
    goto bad;
  } else
#line 298
  if (app_info_offset + (off_t )pf->app_info_size > (off_t )file_size) {
#line 308
    goto bad;
  }
#line 311
  if (pf->app_info_size == 0) {
#line 312
    pf->app_info = (void *)0;
  } else {
    {
#line 314
    tmp___6 = malloc((size_t )pf->app_info_size);
#line 314
    pf->app_info = tmp___6;
    }
#line 314
    if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
#line 316
      goto bad;
    }
    {
#line 317
    fseek(pf->f, app_info_offset, 0);
#line 318
    tmp___7 = fread((void */* __restrict  */)pf->app_info, (size_t )1, (size_t )pf->app_info_size,
                    (FILE */* __restrict  */)pf->f);
    }
#line 318
    if (tmp___7 != (size_t )pf->app_info_size) {
#line 320
      goto bad;
    }
  }
#line 323
  if (pf->sort_info_size == 0) {
#line 324
    pf->sort_info = (void *)0;
  } else {
    {
#line 326
    tmp___8 = malloc((size_t )pf->sort_info_size);
#line 326
    pf->sort_info = tmp___8;
    }
#line 326
    if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
#line 328
      goto bad;
    }
    {
#line 329
    fseek(pf->f, sort_info_offset, 0);
#line 330
    tmp___9 = fread((void */* __restrict  */)pf->sort_info, (size_t )1, (size_t )pf->sort_info_size,
                    (FILE */* __restrict  */)pf->f);
    }
#line 330
    if (tmp___9 != (size_t )pf->sort_info_size) {
#line 332
      goto bad;
    }
  }
#line 335
  return (pf);
  bad: 
  {
#line 338
  pi_file_close(pf);
  }
#line 339
  return ((pi_file_t *)((void *)0));
}
}
#line 342 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
int pi_file_close(pi_file_t *pf ) 
{ 
  int err ;

  {
#line 347
  if (! pf) {
#line 348
    return (-400);
  }
#line 350
  if (pf->for_writing) {
    {
#line 351
    pf->err = pi_file_close_for_write(pf);
    }
  }
  {
#line 353
  err = pf->err;
#line 355
  pi_file_free(pf);
  }
#line 357
  return (err);
}
}
#line 360 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
void pi_file_get_info(pi_file_t const   *pf , struct DBInfo *infop ) 
{ 


  {
#line 363
  *infop = (struct DBInfo )pf->info;
#line 364
  return;
}
}
#line 366 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
void pi_file_get_app_info(pi_file_t *pf , void **datap , size_t *sizep ) 
{ 


  {
#line 369
  *datap = pf->app_info;
#line 370
  *sizep = (size_t )pf->app_info_size;
#line 371
  return;
}
}
#line 373 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
void pi_file_get_sort_info(pi_file_t *pf , void **datap , size_t *sizep ) 
{ 


  {
#line 376
  *datap = pf->sort_info;
#line 377
  *sizep = (size_t )pf->sort_info_size;
#line 378
  return;
}
}
#line 380 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
int pi_file_read_resource_by_type_id(pi_file_t *pf , unsigned long restype , int resid ,
                                     void **bufp , size_t *sizep , int *resindex ) 
{ 
  int i ;
  int result ;
  int tmp ;

  {
  {
#line 388
  result = pi_file_find_resource_by_type_id((pi_file_t const   *)pf, restype, resid,
                                            & i);
  }
#line 389
  if (! result) {
#line 390
    return (-403);
  }
#line 391
  if (resindex) {
#line 392
    *resindex = i;
  }
  {
#line 393
  tmp = pi_file_read_resource(pf, i, bufp, sizep, (unsigned long *)((void *)0), (int *)((void *)0));
  }
#line 393
  return (tmp);
}
}
#line 396 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
int pi_file_type_id_used(pi_file_t const   *pf , unsigned long restype , int resid ) 
{ 
  int tmp ;

  {
  {
#line 399
  tmp = pi_file_find_resource_by_type_id(pf, restype, resid, (int *)((void *)0));
  }
#line 399
  return (tmp);
}
}
#line 402 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
int pi_file_read_resource(pi_file_t *pf , int i , void **bufp , size_t *sizep , unsigned long *type ,
                          int *idp ) 
{ 
  pi_file_entry_t *entp ;
  int result ;
  size_t tmp ;

  {
#line 410
  if (pf->for_writing) {
#line 411
    return (-400);
  } else
#line 410
  if (! pf->resource_flag) {
#line 411
    return (-400);
  }
#line 413
  if (i < 0) {
#line 414
    return (-501);
  } else
#line 413
  if (i >= pf->num_entries) {
#line 414
    return (-501);
  }
#line 416
  entp = pf->entries + i;
#line 418
  if (bufp) {
    {
#line 419
    result = pi_file_set_rbuf_size(pf, (size_t )entp->size);
    }
#line 419
    if (result < 0) {
#line 420
      return (result);
    }
    {
#line 421
    fseek(pf->f, (long )(pf->entries + i)->offset, 0);
#line 422
    tmp = fread((void */* __restrict  */)pf->rbuf, (size_t )1, (size_t )entp->size,
                (FILE */* __restrict  */)pf->f);
    }
#line 422
    if (tmp != (size_t )entp->size) {
#line 424
      return (-401);
    }
#line 425
    *bufp = pf->rbuf;
  }
#line 428
  if (sizep) {
#line 429
    *sizep = (size_t )entp->size;
  }
#line 430
  if (type) {
#line 431
    *type = entp->type;
  }
#line 432
  if (idp) {
#line 433
    *idp = entp->resource_id;
  }
#line 435
  return (0);
}
}
#line 438 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
int pi_file_read_record(pi_file_t *pf , int recindex , void **bufp , size_t *sizep ,
                        int *recattrs , int *category , recordid_t *recuid ) 
{ 
  int result ;
  pi_file_entry_t *entp ;
  size_t tmp ;

  {
#line 446
  if (pf->for_writing) {
#line 447
    return (-400);
  } else
#line 446
  if (pf->resource_flag) {
#line 447
    return (-400);
  }
#line 449
  if (recindex < 0) {
#line 450
    return (-501);
  } else
#line 449
  if (recindex >= pf->num_entries) {
#line 450
    return (-501);
  }
#line 452
  entp = pf->entries + recindex;
#line 454
  if (bufp) {
    {
#line 455
    result = pi_file_set_rbuf_size(pf, (size_t )entp->size);
    }
#line 455
    if (result < 0) {
#line 458
      return (result);
    }
    {
#line 461
    fseek(pf->f, (long )(pf->entries + recindex)->offset, 0);
#line 463
    tmp = fread((void */* __restrict  */)pf->rbuf, (size_t )1, (size_t )entp->size,
                (FILE */* __restrict  */)pf->f);
    }
#line 463
    if (tmp != (size_t )entp->size) {
#line 467
      return (-401);
    }
#line 470
    *bufp = pf->rbuf;
  }
#line 476
  if (sizep) {
#line 477
    *sizep = (size_t )entp->size;
  }
#line 478
  if (recattrs) {
#line 479
    *recattrs = entp->attrs & 240;
  }
#line 480
  if (category) {
#line 481
    *category = entp->attrs & 15;
  }
#line 482
  if (recuid) {
#line 483
    *recuid = entp->uid;
  }
#line 485
  return (0);
}
}
#line 488 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
int pi_file_read_record_by_id(pi_file_t *pf , recordid_t uid , void **bufp , size_t *sizep ,
                              int *idxp , int *attrp , int *catp ) 
{ 
  int i ;
  struct pi_file_entry *entp ;
  int tmp ;

  {
#line 496
  i = 0;
#line 496
  entp = pf->entries;
  {
#line 496
  while (1) {
    while_continue: /* CIL Label */ ;
#line 496
    if (! (i < pf->num_entries)) {
#line 496
      goto while_break;
    }
#line 498
    if (entp->uid == uid) {
#line 499
      if (idxp) {
#line 500
        *idxp = i;
      }
      {
#line 501
      tmp = pi_file_read_record(pf, i, bufp, sizep, attrp, catp, & uid);
      }
#line 501
      return (tmp);
    }
#line 496
    i ++;
#line 496
    entp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 506
  return (-403);
}
}
#line 509 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
int pi_file_id_used(pi_file_t const   *pf , recordid_t uid ) 
{ 
  int i ;
  struct pi_file_entry *entp ;

  {
#line 515
  i = 0;
#line 515
  entp = (struct pi_file_entry *)pf->entries;
  {
#line 515
  while (1) {
    while_continue: /* CIL Label */ ;
#line 515
    if (! (i < (int )pf->num_entries)) {
#line 515
      goto while_break;
    }
#line 516
    if (entp->uid == uid) {
#line 517
      return (1);
    }
#line 515
    i ++;
#line 515
    entp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 519
  return (0);
}
}
#line 522 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
pi_file_t *pi_file_create(char const   *name , struct DBInfo  const  *info ) 
{ 
  pi_file_t *pf ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 525
  tmp = calloc((size_t )1, sizeof(pi_file_t ));
#line 525
  pf = (pi_file_t *)tmp;
  }
#line 527
  if ((unsigned long )pf == (unsigned long )((void *)0)) {
#line 528
    return ((pi_file_t *)((void *)0));
  }
  {
#line 530
  tmp___0 = strdup(name);
#line 530
  pf->file_name = tmp___0;
  }
#line 530
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 531
    goto bad;
  }
#line 533
  pf->for_writing = 1;
#line 534
  pf->info = (struct DBInfo )*info;
#line 536
  if (info->flags & 1U) {
#line 537
    pf->resource_flag = 1;
#line 538
    pf->ent_hdr_size = 10;
  } else {
#line 540
    pf->resource_flag = 0;
#line 541
    pf->ent_hdr_size = 8;
  }
  {
#line 544
  pf->tmpbuf = pi_buffer_new((size_t )2048);
  }
#line 545
  if ((unsigned long )pf->tmpbuf == (unsigned long )((void *)0)) {
#line 546
    goto bad;
  }
#line 548
  return (pf);
  bad: 
  {
#line 551
  pi_file_free(pf);
  }
#line 552
  return ((pi_file_t *)((void *)0));
}
}
#line 555 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
int pi_file_set_info(pi_file_t *pf , struct DBInfo  const  *ip ) 
{ 


  {
#line 558
  if (! pf->for_writing) {
#line 559
    return (-400);
  }
#line 561
  if ((ip->flags & 1U) != (unsigned int const   )(pf->info.flags & 1U)) {
#line 563
    return (-400);
  }
#line 565
  pf->info = (struct DBInfo )*ip;
#line 567
  return (0);
}
}
#line 570 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
int pi_file_set_app_info(pi_file_t *pf , void *data , size_t size ) 
{ 
  void *p ;

  {
#line 575
  if (! size) {
#line 576
    if (pf->app_info) {
      {
#line 577
      free(pf->app_info);
      }
    }
#line 578
    pf->app_info_size = 0;
#line 579
    return (0);
  }
  {
#line 582
  p = malloc(size);
  }
#line 582
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 583
    return (-500);
  }
  {
#line 585
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)data, size);
  }
#line 587
  if (pf->app_info) {
    {
#line 588
    free(pf->app_info);
    }
  }
#line 590
  pf->app_info = p;
#line 591
  pf->app_info_size = (int )size;
#line 593
  return (0);
}
}
#line 596 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
int pi_file_set_sort_info(pi_file_t *pf , void *data , size_t size ) 
{ 
  void *p ;

  {
#line 601
  if (! size) {
#line 602
    if (pf->sort_info) {
      {
#line 603
      free(pf->sort_info);
      }
    }
#line 604
    pf->sort_info_size = 0;
#line 605
    return (0);
  }
  {
#line 608
  p = malloc(size);
  }
#line 608
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 609
    return (-500);
  }
  {
#line 611
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)data, size);
  }
#line 613
  if (pf->sort_info) {
    {
#line 614
    free(pf->sort_info);
    }
  }
#line 616
  pf->sort_info = p;
#line 617
  pf->sort_info_size = (int )size;
#line 619
  return (0);
}
}
#line 622 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
int pi_file_append_resource(pi_file_t *pf , void *data , size_t size , unsigned long restype ,
                            int resid ) 
{ 
  pi_file_entry_t *entp ;
  int tmp ;
  pi_buffer_t *tmp___0 ;

  {
#line 628
  if (! pf->for_writing) {
#line 629
    return (-400);
  } else
#line 628
  if (! pf->resource_flag) {
#line 629
    return (-400);
  }
  {
#line 630
  tmp = pi_file_type_id_used((pi_file_t const   *)pf, restype, resid);
  }
#line 630
  if (tmp) {
#line 631
    return (-404);
  }
  {
#line 633
  entp = pi_file_append_entry(pf);
  }
#line 634
  if ((unsigned long )entp == (unsigned long )((void *)0)) {
#line 635
    return (-500);
  }
#line 637
  if (size) {
    {
#line 637
    tmp___0 = pi_buffer_append(pf->tmpbuf, (void const   *)data, size);
    }
#line 637
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 638
      pf->err = 1;
#line 639
      return (-500);
    }
  }
#line 642
  entp->size = (int )size;
#line 643
  entp->type = restype;
#line 644
  entp->resource_id = resid;
#line 646
  return ((int )size);
}
}
#line 649 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
int pi_file_append_record(pi_file_t *pf , void *data , size_t size , int recattrs ,
                          int category , recordid_t recuid ) 
{ 
  pi_file_entry_t *entp ;
  int tmp ;
  pi_buffer_t *tmp___0 ;

  {
#line 655
  if (! pf->for_writing) {
#line 656
    return (-400);
  } else
#line 655
  if (pf->resource_flag) {
#line 656
    return (-400);
  }
#line 657
  if (recuid) {
    {
#line 657
    tmp = pi_file_id_used((pi_file_t const   *)pf, recuid);
    }
#line 657
    if (tmp) {
#line 658
      return (-404);
    }
  }
  {
#line 660
  entp = pi_file_append_entry(pf);
  }
#line 661
  if ((unsigned long )entp == (unsigned long )((void *)0)) {
#line 662
    return (-500);
  }
#line 664
  if (size) {
    {
#line 664
    tmp___0 = pi_buffer_append(pf->tmpbuf, (void const   *)data, size);
    }
#line 664
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 665
      pf->err = 1;
#line 666
      return (-500);
    }
  }
#line 669
  entp->size = (int )size;
#line 670
  entp->attrs = (recattrs & 240) | (category & 15);
#line 671
  entp->uid = recuid;
#line 673
  return ((int )size);
}
}
#line 676 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
void pi_file_get_entries(pi_file_t *pf , int *entries ) 
{ 


  {
#line 679
  *entries = pf->num_entries;
#line 680
  return;
}
}
#line 682 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
int pi_file_retrieve(pi_file_t *pf , int socket___0 , int cardno , int (*report_progress)(int socket ,
                                                                                          pi_progress_t *progress ) ) 
{ 
  int db ;
  int result ;
  int old_device ;
  unsigned int j ;
  struct DBInfo dbi ;
  struct DBSizeInfo size_info ;
  pi_buffer_t *buffer ;
  pi_progress_t progress ;
  int num_records ;
  int tmp ;
  int resource_id ;
  unsigned long type ;
  int tmp___0 ;
  int attr ;
  int category ;
  unsigned long resource_id___0 ;
  int tmp___1 ;
  PI_ERR tmp___2 ;
  int err ;
  int tmp___3 ;
  int palmoserr ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 686
  db = -1;
#line 686
  old_device = 0;
#line 695
  buffer = (pi_buffer_t *)((void *)0);
#line 698
  pi_reset_errors(socket___0);
#line 699
  memset((void *)(& size_info), 0, sizeof(size_info));
#line 700
  memset((void *)(& dbi), 0, sizeof(dbi));
#line 708
  result = dlp_FindDBByName(socket___0, cardno, (char const   *)(pf->info.name), (unsigned long *)((void *)0),
                            (int *)((void *)0), & dbi, & size_info);
  }
#line 708
  if (result < 0) {
#line 711
    if (result != -302) {
#line 712
      goto fail;
    }
#line 713
    old_device = 1;
  }
  {
#line 716
  result = dlp_OpenDB(socket___0, cardno, 144, (char const   *)(pf->info.name), & db);
  }
#line 716
  if (result < 0) {
#line 718
    goto fail;
  }
  {
#line 720
  buffer = pi_buffer_new((size_t )65535);
  }
#line 721
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 722
    result = pi_set_error(socket___0, -500);
    }
#line 723
    goto fail;
  }
#line 726
  if (old_device) {
    {
#line 728
    result = dlp_ReadOpenDBInfo(socket___0, db, & num_records);
    }
#line 728
    if (result < 0) {
#line 729
      goto fail;
    }
#line 730
    size_info.numRecords = (unsigned long )num_records;
  }
  {
#line 733
  memset((void *)(& progress), 0, sizeof(progress));
#line 734
  progress.type = 2;
#line 735
  progress.data.db.pf = pf;
#line 736
  progress.data.db.size = size_info;
  }
#line 738
  if (size_info.appBlockSize) {
#line 738
    goto _L;
  } else
#line 738
  if (dbi.miscFlags & 64U) {
#line 738
    goto _L;
  } else
#line 738
  if (old_device) {
    _L: /* CIL Label */ 
    {
#line 759
    result = dlp_ReadAppBlock(socket___0, db, 0, 65535, buffer);
    }
#line 760
    if (result > 0) {
      {
#line 761
      pi_file_set_app_info(pf, (void *)buffer->data, (size_t )result);
#line 762
      progress.transferred_bytes += result;
      }
#line 763
      if (report_progress) {
        {
#line 763
        tmp = (*report_progress)(socket___0, & progress);
        }
#line 763
        if (tmp == 0) {
#line 765
          result = -402;
#line 766
          goto fail;
        }
      }
    }
  }
#line 771
  if (pf->info.flags & 1U) {
#line 772
    j = 0U;
    {
#line 772
    while (1) {
      while_continue: /* CIL Label */ ;
#line 772
      if (! ((unsigned long )j < size_info.numRecords)) {
#line 772
        goto while_break;
      }
      {
#line 776
      result = dlp_ReadResourceByIndex(socket___0, db, j, buffer, & type, & resource_id);
      }
#line 776
      if (result < 0) {
#line 778
        goto fail;
      }
      {
#line 780
      result = pi_file_append_resource(pf, (void *)buffer->data, buffer->used, type,
                                       resource_id);
      }
#line 780
      if (result < 0) {
        {
#line 782
        pi_set_error(socket___0, result);
        }
#line 783
        goto fail;
      }
#line 786
      progress.transferred_bytes = (int )((size_t )progress.transferred_bytes + buffer->used);
#line 787
      (progress.data.db.transferred_records) ++;
#line 789
      if (report_progress) {
        {
#line 789
        tmp___0 = (*report_progress)(socket___0, & progress);
        }
#line 789
        if (tmp___0 == 0) {
          {
#line 791
          result = pi_set_error(socket___0, -402);
          }
#line 792
          goto fail;
        }
      }
#line 772
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 795
    j = 0U;
    {
#line 795
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 795
      if (! ((unsigned long )j < size_info.numRecords)) {
#line 795
        goto while_break___0;
      }
      {
#line 800
      result = dlp_ReadRecordByIndex(socket___0, db, (int )j, buffer, & resource_id___0,
                                     & attr, & category);
      }
#line 800
      if (result < 0) {
#line 802
        goto fail;
      }
#line 804
      progress.transferred_bytes = (int )((size_t )progress.transferred_bytes + buffer->used);
#line 805
      (progress.data.db.transferred_records) ++;
#line 807
      if (report_progress) {
        {
#line 807
        tmp___1 = (*report_progress)(socket___0, & progress);
        }
#line 807
        if (tmp___1 == 0) {
          {
#line 810
          result = pi_set_error(socket___0, -402);
          }
#line 811
          goto fail;
        }
      }
#line 817
      if (attr & 136) {
#line 819
        goto __Cont;
      }
      {
#line 820
      result = pi_file_append_record(pf, (void *)buffer->data, buffer->used, attr,
                                     category, resource_id___0);
      }
#line 820
      if (result < 0) {
        {
#line 822
        pi_set_error(socket___0, result);
        }
#line 823
        goto fail;
      }
      __Cont: /* CIL Label */ 
#line 795
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 827
  pi_buffer_free(buffer);
#line 829
  tmp___2 = dlp_CloseDB(socket___0, db);
  }
#line 829
  return (tmp___2);
  fail: 
#line 832
  if (db != -1) {
    {
#line 832
    tmp___5 = pi_socket_connected(socket___0);
    }
#line 832
    if (tmp___5) {
      {
#line 833
      tmp___3 = pi_error(socket___0);
#line 833
      err = tmp___3;
#line 834
      tmp___4 = pi_palmos_error(socket___0);
#line 834
      palmoserr = tmp___4;
#line 836
      dlp_CloseDB(socket___0, db);
#line 838
      pi_set_error(socket___0, err);
#line 839
      pi_set_palmos_error(socket___0, palmoserr);
      }
    }
  }
#line 842
  if ((unsigned long )buffer != (unsigned long )((void *)0)) {
    {
#line 843
    pi_buffer_free(buffer);
    }
  }
#line 845
  if (result >= 0) {
    {
#line 847
    result = pi_set_error(socket___0, -401);
    }
  }
#line 849
  return (result);
}
}
#line 852 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
int pi_file_install(pi_file_t *pf , int socket___0 , int cardno , int (*report_progress)(int socket ,
                                                                                         pi_progress_t *progress ) ) 
{ 
  int db ;
  int j ;
  int reset ;
  int flags ;
  int version ;
  int freeai ;
  int result ;
  int err1 ;
  int err2 ;
  size_t l ;
  size_t size ;
  void *buffer ;
  pi_progress_t progress ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int retry ;
  int tmp___2 ;
  int tmp___3 ;
  void *b2 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int resource_id ;
  unsigned long type ;
  int tmp___7 ;
  int attr ;
  int category ;
  unsigned long resource_id___0 ;
  int tmp___8 ;
  PI_ERR tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 856
  db = -1;
#line 856
  reset = 0;
#line 856
  freeai = 0;
#line 865
  size = (size_t )0;
#line 870
  version = pi_version(socket___0);
#line 872
  memset((void *)(& progress), 0, sizeof(progress));
#line 873
  progress.type = 1;
#line 874
  progress.data.db.pf = pf;
#line 875
  progress.data.db.size.numRecords = (unsigned long )pf->num_entries;
#line 876
  progress.data.db.size.dataBytes = (unsigned long )pf->app_info_size;
#line 877
  progress.data.db.size.appBlockSize = (unsigned long )pf->app_info_size;
#line 878
  progress.data.db.size.maxRecSize = pi_maxrecsize(socket___0);
#line 884
  j = 0;
  }
  {
#line 884
  while (1) {
    while_continue: /* CIL Label */ ;
#line 884
    if (! (j < pf->num_entries)) {
#line 884
      goto while_break;
    }
#line 885
    if (pf->info.flags & 1U) {
      {
#line 885
      tmp = pi_file_read_resource(pf, j, (void **)0, & size, (unsigned long *)0, (int *)0);
#line 885
      result = tmp;
      }
    } else {
      {
#line 885
      tmp___0 = pi_file_read_record(pf, j, (void **)0, & size, (int *)0, (int *)0,
                                    (recordid_t *)0);
#line 885
      result = tmp___0;
      }
    }
#line 888
    if (result < 0) {
#line 891
      goto fail;
    }
#line 893
    if (size > 65536UL) {
#line 893
      if (version < 260) {
#line 897
        goto fail;
      }
    }
#line 899
    progress.data.db.size.dataBytes += size;
#line 884
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 902
  progress.data.db.size.totalBytes = ((progress.data.db.size.dataBytes + (unsigned long )(pf->ent_hdr_size * pf->num_entries)) + 78UL) + 2UL;
#line 908
  dlp_DeleteDB(socket___0, cardno, (char const   *)(pf->info.name));
#line 911
  flags = (int )pf->info.flags;
  }
#line 915
  if (pf->info.creator == (unsigned long )((((103 << 24) | (114 << 16)) | (97 << 8)) | 102)) {
#line 916
    flags |= 16;
#line 917
    flags |= 32;
  }
  {
#line 920
  tmp___1 = strcmp((char const   *)(pf->info.name), "Graffiti ShortCuts ");
  }
#line 920
  if (tmp___1 == 0) {
#line 921
    flags |= 32768;
#line 922
    reset = 1;
  }
  {
#line 928
  result = dlp_CreateDB(socket___0, pf->info.creator, pf->info.type, cardno, flags,
                        pf->info.version, (char const   *)(pf->info.name), & db);
  }
#line 928
  if (result < 0) {
    {
#line 931
    retry = 0;
#line 941
    tmp___3 = strcmp((char const   *)(pf->info.name), "Graffiti ShortCuts ");
    }
#line 941
    if (tmp___3 == 0) {
      {
#line 942
      strcpy((char */* __restrict  */)(pf->info.name), (char const   */* __restrict  */)"Graffiti ShortCuts");
#line 943
      retry = 1;
      }
    } else {
      {
#line 944
      tmp___2 = strcmp((char const   *)(pf->info.name), "Graffiti ShortCuts");
      }
#line 944
      if (tmp___2 == 0) {
        {
#line 946
        strcpy((char */* __restrict  */)(pf->info.name), (char const   */* __restrict  */)"Graffiti ShortCuts ");
#line 947
        retry = 1;
        }
      } else
#line 948
      if (pf->info.creator == (unsigned long )((((103 << 24) | (114 << 16)) | (97 << 8)) | 102)) {
        {
#line 951
        strcpy((char */* __restrict  */)(pf->info.name), (char const   */* __restrict  */)"Graffiti ShortCuts");
#line 952
        retry = 1;
        }
      }
    }
#line 955
    if (retry) {
      {
#line 959
      result = dlp_CreateDB(socket___0, pf->info.creator, pf->info.type, cardno, flags,
                            pf->info.version, (char const   *)(pf->info.name), & db);
      }
#line 959
      if (result < 0) {
#line 963
        return (result);
      }
    } else {
#line 966
      return (result);
    }
  }
  {
#line 970
  pi_file_get_app_info(pf, & buffer, & l);
  }
#line 973
  if (version > 256) {
    {
#line 973
    tmp___5 = strcmp((char const   *)(pf->info.name), "MemoDB");
    }
#line 973
    if (tmp___5 == 0) {
#line 973
      if (l > 0UL) {
#line 973
        if (l < 282UL) {
          {
#line 985
          tmp___4 = calloc((size_t )1, (size_t )282);
#line 985
          b2 = tmp___4;
#line 986
          memcpy((void */* __restrict  */)b2, (void const   */* __restrict  */)buffer,
                 l);
#line 987
          buffer = b2;
#line 988
          progress.data.db.size.appBlockSize = 282UL;
#line 989
          l = (size_t )282;
#line 990
          freeai = 1;
          }
        }
      }
    }
  }
#line 995
  if (pf->info.creator == (unsigned long )((((112 << 24) | (116 << 16)) | (99 << 8)) | 104)) {
#line 996
    reset = 1;
  }
#line 998
  if (pf->info.flags & 32U) {
#line 999
    reset = 1;
  }
#line 1002
  if (l > 0UL) {
    {
#line 1003
    result = dlp_WriteAppBlock(socket___0, db, (void const   *)buffer, l);
    }
#line 1003
    if (result < 0) {
#line 1004
      if (freeai) {
        {
#line 1005
        free(buffer);
        }
      }
#line 1006
      goto fail;
    }
#line 1008
    if (freeai) {
      {
#line 1009
      free(buffer);
      }
    }
#line 1010
    progress.transferred_bytes = (int )l;
#line 1011
    if (report_progress) {
      {
#line 1011
      tmp___6 = (*report_progress)(socket___0, & progress);
      }
#line 1011
      if (tmp___6 == 0) {
        {
#line 1013
        result = pi_set_error(socket___0, -402);
        }
#line 1014
        goto fail;
      }
    }
  }
#line 1019
  if (pf->info.flags & 1U) {
#line 1020
    j = 0;
    {
#line 1020
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1020
      if (! (j < pf->num_entries)) {
#line 1020
        goto while_break___0;
      }
      {
#line 1024
      result = pi_file_read_resource(pf, j, & buffer, & size, & type, & resource_id);
      }
#line 1024
      if (result < 0) {
#line 1026
        goto fail;
      }
#line 1029
      if (size == 0UL) {
#line 1030
        goto __Cont;
      }
      {
#line 1032
      result = dlp_WriteResource(socket___0, db, type, resource_id, (void const   *)buffer,
                                 size);
      }
#line 1032
      if (result < 0) {
#line 1034
        goto fail;
      }
#line 1036
      progress.transferred_bytes = (int )((size_t )progress.transferred_bytes + size);
#line 1037
      (progress.data.db.transferred_records) ++;
#line 1039
      if (report_progress) {
        {
#line 1039
        tmp___7 = (*report_progress)(socket___0, & progress);
        }
#line 1039
        if (tmp___7 == 0) {
          {
#line 1041
          result = pi_set_error(socket___0, -402);
          }
#line 1042
          goto fail;
        }
      }
#line 1047
      if (type == (unsigned long )((((98 << 24) | (111 << 16)) | (111 << 8)) | 116)) {
#line 1048
        reset = 1;
      }
      __Cont: /* CIL Label */ 
#line 1020
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1051
    j = 0;
    {
#line 1051
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1051
      if (! (j < pf->num_entries)) {
#line 1051
        goto while_break___1;
      }
      {
#line 1056
      result = pi_file_read_record(pf, j, & buffer, & size, & attr, & category, & resource_id___0);
      }
#line 1056
      if (result < 0) {
#line 1058
        goto fail;
      }
#line 1062
      if (attr & 136) {
#line 1062
        if (version < 257) {
#line 1064
          goto __Cont___0;
        }
      }
      {
#line 1066
      result = dlp_WriteRecord(socket___0, db, attr, resource_id___0, category, (void const   *)buffer,
                               size, (recordid_t *)0);
      }
#line 1066
      if (result < 0) {
#line 1068
        goto fail;
      }
#line 1070
      progress.transferred_bytes = (int )((size_t )progress.transferred_bytes + size);
#line 1071
      (progress.data.db.transferred_records) ++;
#line 1073
      if (report_progress) {
        {
#line 1073
        tmp___8 = (*report_progress)(socket___0, & progress);
        }
#line 1073
        if (tmp___8 == 0) {
          {
#line 1076
          result = pi_set_error(socket___0, -402);
          }
#line 1077
          goto fail;
        }
      }
      __Cont___0: /* CIL Label */ 
#line 1051
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1082
  if (reset) {
    {
#line 1083
    dlp_ResetSystem(socket___0);
    }
  }
  {
#line 1085
  tmp___9 = dlp_CloseDB(socket___0, db);
  }
#line 1085
  return (tmp___9);
  fail: 
  {
#line 1090
  err1 = pi_error(socket___0);
#line 1091
  err2 = pi_palmos_error(socket___0);
  }
#line 1095
  if (db != -1) {
    {
#line 1095
    tmp___10 = pi_socket_connected(socket___0);
    }
#line 1095
    if (tmp___10) {
      {
#line 1096
      dlp_CloseDB(socket___0, db);
      }
    }
  }
  {
#line 1097
  tmp___11 = pi_socket_connected(socket___0);
  }
#line 1097
  if (tmp___11) {
    {
#line 1098
    dlp_DeleteDB(socket___0, cardno, (char const   *)(pf->info.name));
    }
  }
  {
#line 1100
  pi_set_error(socket___0, err1);
#line 1101
  pi_set_palmos_error(socket___0, err2);
  }
#line 1103
  if (result >= 0) {
    {
#line 1104
    result = pi_set_error(socket___0, -401);
    }
  }
#line 1105
  return (result);
}
}
#line 1108 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
int pi_file_merge(pi_file_t *pf , int socket___0 , int cardno , int (*report_progress)(int socket ,
                                                                                       pi_progress_t *progress ) ) 
{ 
  int db ;
  int j ;
  int reset ;
  int version ;
  int result ;
  void *buffer ;
  size_t size ;
  pi_progress_t progress ;
  int tmp ;
  PI_ERR tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int resource_id ;
  unsigned long type ;
  int tmp___3 ;
  int attr ;
  int category ;
  unsigned long resource_id___0 ;
  int tmp___4 ;
  PI_ERR tmp___5 ;
  int err1 ;
  int tmp___6 ;
  int err2 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 1112
  db = -1;
#line 1112
  reset = 0;
#line 1121
  version = pi_version(socket___0);
#line 1123
  memset((void *)(& progress), 0, sizeof(progress));
#line 1124
  progress.type = 1;
#line 1125
  progress.data.db.pf = pf;
#line 1126
  progress.data.db.size.numRecords = (unsigned long )pf->num_entries;
#line 1127
  progress.data.db.size.dataBytes = (unsigned long )pf->app_info_size;
#line 1128
  progress.data.db.size.appBlockSize = (unsigned long )pf->app_info_size;
#line 1129
  progress.data.db.size.maxRecSize = pi_maxrecsize(socket___0);
#line 1131
  tmp___0 = dlp_OpenDB(socket___0, cardno, 208, (char const   *)(pf->info.name), & db);
  }
#line 1131
  if (tmp___0 < 0) {
    {
#line 1133
    tmp = pi_file_install(pf, socket___0, cardno, report_progress);
    }
#line 1133
    return (tmp);
  }
#line 1139
  j = 0;
  {
#line 1139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1139
    if (! (j < pf->num_entries)) {
#line 1139
      goto while_break;
    }
#line 1140
    if (pf->info.flags & 1U) {
      {
#line 1140
      tmp___1 = pi_file_read_resource(pf, j, (void **)0, & size, (unsigned long *)0,
                                      (int *)0);
#line 1140
      result = tmp___1;
      }
    } else {
      {
#line 1140
      tmp___2 = pi_file_read_record(pf, j, (void **)0, & size, (int *)0, (int *)0,
                                    (recordid_t *)0);
#line 1140
      result = tmp___2;
      }
    }
#line 1143
    if (result < 0) {
#line 1146
      goto fail;
    }
#line 1148
    if (size > 65536UL) {
#line 1148
      if (version < 260) {
        {
#line 1152
        result = pi_set_error(socket___0, -304);
        }
#line 1153
        goto fail;
      }
    }
#line 1155
    progress.data.db.size.dataBytes += size;
#line 1139
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1158
  progress.data.db.size.totalBytes = ((progress.data.db.size.dataBytes + (unsigned long )(pf->ent_hdr_size * pf->num_entries)) + 78UL) + 2UL;
#line 1165
  if (pf->info.creator == (unsigned long )((((112 << 24) | (116 << 16)) | (99 << 8)) | 104)) {
#line 1166
    reset = 1;
  }
#line 1168
  if (pf->info.flags & 32U) {
#line 1169
    reset = 1;
  }
#line 1172
  if (pf->info.flags & 1U) {
#line 1173
    j = 0;
    {
#line 1173
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1173
      if (! (j < pf->num_entries)) {
#line 1173
        goto while_break___0;
      }
      {
#line 1177
      result = pi_file_read_resource(pf, j, & buffer, & size, & type, & resource_id);
      }
#line 1177
      if (result < 0) {
#line 1179
        goto fail;
      }
#line 1181
      if (size == 0UL) {
#line 1182
        goto __Cont;
      }
      {
#line 1184
      result = dlp_WriteResource(socket___0, db, type, resource_id, (void const   *)buffer,
                                 size);
      }
#line 1184
      if (result < 0) {
#line 1186
        goto fail;
      }
#line 1188
      progress.transferred_bytes = (int )((size_t )progress.transferred_bytes + size);
#line 1189
      (progress.data.db.transferred_records) ++;
#line 1191
      if (report_progress) {
        {
#line 1191
        tmp___3 = (*report_progress)(socket___0, & progress);
        }
#line 1191
        if (tmp___3 == 0) {
          {
#line 1193
          result = pi_set_error(socket___0, -402);
          }
#line 1194
          goto fail;
        }
      }
#line 1199
      if (type == (unsigned long )((((98 << 24) | (111 << 16)) | (111 << 8)) | 116)) {
#line 1200
        reset = 1;
      }
      __Cont: /* CIL Label */ 
#line 1173
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1203
    j = 0;
    {
#line 1203
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1203
      if (! (j < pf->num_entries)) {
#line 1203
        goto while_break___1;
      }
      {
#line 1208
      result = pi_file_read_record(pf, j, & buffer, & size, & attr, & category, & resource_id___0);
      }
#line 1208
      if (result < 0) {
#line 1210
        goto fail;
      }
#line 1214
      if (attr & 136) {
#line 1214
        if (version < 257) {
#line 1216
          goto __Cont___0;
        }
      }
      {
#line 1218
      result = dlp_WriteRecord(socket___0, db, attr, (recordid_t )0, category, (void const   *)buffer,
                               size, (recordid_t *)0);
      }
#line 1218
      if (result < 0) {
#line 1220
        goto fail;
      }
#line 1222
      progress.transferred_bytes = (int )((size_t )progress.transferred_bytes + size);
#line 1223
      (progress.data.db.transferred_records) ++;
#line 1225
      if (report_progress) {
        {
#line 1225
        tmp___4 = (*report_progress)(socket___0, & progress);
        }
#line 1225
        if (tmp___4 == 0) {
#line 1227
          result = -402;
#line 1228
          goto fail;
        }
      }
      __Cont___0: /* CIL Label */ 
#line 1203
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1233
  if (reset) {
    {
#line 1234
    dlp_ResetSystem(socket___0);
    }
  }
  {
#line 1236
  tmp___5 = dlp_CloseDB(socket___0, db);
  }
#line 1236
  return (tmp___5);
  fail: 
#line 1239
  if (db != -1) {
    {
#line 1239
    tmp___8 = pi_socket_connected(socket___0);
    }
#line 1239
    if (tmp___8) {
      {
#line 1240
      tmp___6 = pi_error(socket___0);
#line 1240
      err1 = tmp___6;
#line 1241
      tmp___7 = pi_palmos_error(socket___0);
#line 1241
      err2 = tmp___7;
#line 1243
      dlp_CloseDB(socket___0, db);
#line 1245
      pi_set_error(socket___0, err1);
#line 1246
      pi_set_palmos_error(socket___0, err2);
      }
    }
  }
#line 1248
  if (result >= 0) {
    {
#line 1249
    result = pi_set_error(socket___0, -401);
    }
  }
#line 1250
  return (result);
}
}
#line 1270 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
static int pi_file_close_for_write(pi_file_t *pf ) 
{ 
  int i ;
  int offset ;
  FILE *f ;
  struct DBInfo *ip ;
  struct pi_file_entry *entp ;
  struct stat sbuf ;
  unsigned char buf___3[512] ;
  unsigned char *p ;
  int tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
#line 1284
  ip = & pf->info;
#line 1285
  if (pf->num_entries >= 65536) {
#line 1290
    return (-400);
  }
  {
#line 1301
  tmp = stat((char const   */* __restrict  */)pf->file_name, (struct stat */* __restrict  */)(& sbuf));
  }
#line 1301
  if (! tmp) {
#line 1302
    if ((sbuf.st_mode & 61440U) == 32768U) {
      {
#line 1303
      unlink((char const   *)pf->file_name);
      }
    }
  }
  {
#line 1305
  f = fopen((char const   */* __restrict  */)pf->file_name, (char const   */* __restrict  */)"wb");
  }
#line 1305
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 1306
    return (-401);
  }
  {
#line 1308
  ip = & pf->info;
#line 1310
  offset = (78 + pf->num_entries * pf->ent_hdr_size) + 2;
#line 1312
  p = buf___3;
#line 1313
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(ip->name),
         (size_t )32);
#line 1314
  *((p + 32) + 0) = (unsigned char )(((int )((unsigned short )ip->flags) >> 8) & 255);
#line 1314
  *((p + 32) + 1) = (unsigned char )((int )((unsigned short )ip->flags) & 255);
#line 1315
  *((p + 34) + 0) = (unsigned char )(((int )((unsigned short )ip->version) >> 8) & 255);
#line 1315
  *((p + 34) + 1) = (unsigned char )((int )((unsigned short )ip->version) & 255);
#line 1316
  tmp___0 = unix_time_to_pilot_time(ip->createDate);
#line 1316
  *((p + 36) + 0) = (unsigned char )((int )((unsigned char )(tmp___0 >> 24)) & 255);
#line 1316
  tmp___1 = unix_time_to_pilot_time(ip->createDate);
#line 1316
  *((p + 36) + 1) = (unsigned char )((tmp___1 >> 16) & 255UL);
#line 1316
  tmp___2 = unix_time_to_pilot_time(ip->createDate);
#line 1316
  *((p + 36) + 2) = (unsigned char )((tmp___2 >> 8) & 255UL);
#line 1316
  tmp___3 = unix_time_to_pilot_time(ip->createDate);
#line 1316
  *((p + 36) + 3) = (unsigned char )(tmp___3 & 255UL);
#line 1317
  tmp___4 = unix_time_to_pilot_time(ip->modifyDate);
#line 1317
  *((p + 40) + 0) = (unsigned char )((int )((unsigned char )(tmp___4 >> 24)) & 255);
#line 1317
  tmp___5 = unix_time_to_pilot_time(ip->modifyDate);
#line 1317
  *((p + 40) + 1) = (unsigned char )((tmp___5 >> 16) & 255UL);
#line 1317
  tmp___6 = unix_time_to_pilot_time(ip->modifyDate);
#line 1317
  *((p + 40) + 2) = (unsigned char )((tmp___6 >> 8) & 255UL);
#line 1317
  tmp___7 = unix_time_to_pilot_time(ip->modifyDate);
#line 1317
  *((p + 40) + 3) = (unsigned char )(tmp___7 & 255UL);
#line 1318
  tmp___8 = unix_time_to_pilot_time(ip->backupDate);
#line 1318
  *((p + 44) + 0) = (unsigned char )((int )((unsigned char )(tmp___8 >> 24)) & 255);
#line 1318
  tmp___9 = unix_time_to_pilot_time(ip->backupDate);
#line 1318
  *((p + 44) + 1) = (unsigned char )((tmp___9 >> 16) & 255UL);
#line 1318
  tmp___10 = unix_time_to_pilot_time(ip->backupDate);
#line 1318
  *((p + 44) + 2) = (unsigned char )((tmp___10 >> 8) & 255UL);
#line 1318
  tmp___11 = unix_time_to_pilot_time(ip->backupDate);
#line 1318
  *((p + 44) + 3) = (unsigned char )(tmp___11 & 255UL);
#line 1319
  *((p + 48) + 0) = (unsigned char )((int )((unsigned char )(ip->modnum >> 24)) & 255);
#line 1319
  *((p + 48) + 1) = (unsigned char )((ip->modnum >> 16) & 255UL);
#line 1319
  *((p + 48) + 2) = (unsigned char )((ip->modnum >> 8) & 255UL);
#line 1319
  *((p + 48) + 3) = (unsigned char )(ip->modnum & 255UL);
  }
#line 1320
  if (pf->app_info_size) {
#line 1320
    tmp___12 = offset;
  } else {
#line 1320
    tmp___12 = 0;
  }
#line 1320
  *((p + 52) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )tmp___12 >> 24)) & 255);
#line 1320
  if (pf->app_info_size) {
#line 1320
    tmp___13 = offset;
  } else {
#line 1320
    tmp___13 = 0;
  }
#line 1320
  *((p + 52) + 1) = (unsigned char )(((unsigned long )tmp___13 >> 16) & 255UL);
#line 1320
  if (pf->app_info_size) {
#line 1320
    tmp___14 = offset;
  } else {
#line 1320
    tmp___14 = 0;
  }
#line 1320
  *((p + 52) + 2) = (unsigned char )(((unsigned long )tmp___14 >> 8) & 255UL);
#line 1320
  if (pf->app_info_size) {
#line 1320
    tmp___15 = offset;
  } else {
#line 1320
    tmp___15 = 0;
  }
#line 1320
  *((p + 52) + 3) = (unsigned char )((unsigned long )tmp___15 & 255UL);
#line 1321
  offset += pf->app_info_size;
#line 1322
  if (pf->sort_info_size) {
#line 1322
    tmp___16 = offset;
  } else {
#line 1322
    tmp___16 = 0;
  }
#line 1322
  *((p + 56) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )tmp___16 >> 24)) & 255);
#line 1322
  if (pf->sort_info_size) {
#line 1322
    tmp___17 = offset;
  } else {
#line 1322
    tmp___17 = 0;
  }
#line 1322
  *((p + 56) + 1) = (unsigned char )(((unsigned long )tmp___17 >> 16) & 255UL);
#line 1322
  if (pf->sort_info_size) {
#line 1322
    tmp___18 = offset;
  } else {
#line 1322
    tmp___18 = 0;
  }
#line 1322
  *((p + 56) + 2) = (unsigned char )(((unsigned long )tmp___18 >> 8) & 255UL);
#line 1322
  if (pf->sort_info_size) {
#line 1322
    tmp___19 = offset;
  } else {
#line 1322
    tmp___19 = 0;
  }
  {
#line 1322
  *((p + 56) + 3) = (unsigned char )((unsigned long )tmp___19 & 255UL);
#line 1323
  offset += pf->sort_info_size;
#line 1324
  *((p + 60) + 0) = (unsigned char )((int )((unsigned char )(ip->type >> 24)) & 255);
#line 1324
  *((p + 60) + 1) = (unsigned char )((ip->type >> 16) & 255UL);
#line 1324
  *((p + 60) + 2) = (unsigned char )((ip->type >> 8) & 255UL);
#line 1324
  *((p + 60) + 3) = (unsigned char )(ip->type & 255UL);
#line 1325
  *((p + 64) + 0) = (unsigned char )((int )((unsigned char )(ip->creator >> 24)) & 255);
#line 1325
  *((p + 64) + 1) = (unsigned char )((ip->creator >> 16) & 255UL);
#line 1325
  *((p + 64) + 2) = (unsigned char )((ip->creator >> 8) & 255UL);
#line 1325
  *((p + 64) + 3) = (unsigned char )(ip->creator & 255UL);
#line 1326
  *((p + 68) + 0) = (unsigned char )((int )((unsigned char )(pf->unique_id_seed >> 24)) & 255);
#line 1326
  *((p + 68) + 1) = (unsigned char )((pf->unique_id_seed >> 16) & 255UL);
#line 1326
  *((p + 68) + 2) = (unsigned char )((pf->unique_id_seed >> 8) & 255UL);
#line 1326
  *((p + 68) + 3) = (unsigned char )(pf->unique_id_seed & 255UL);
#line 1327
  *((p + 72) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )pf->next_record_list_id >> 24)) & 255);
#line 1327
  *((p + 72) + 1) = (unsigned char )(((unsigned long )pf->next_record_list_id >> 16) & 255UL);
#line 1327
  *((p + 72) + 2) = (unsigned char )(((unsigned long )pf->next_record_list_id >> 8) & 255UL);
#line 1327
  *((p + 72) + 3) = (unsigned char )((unsigned long )pf->next_record_list_id & 255UL);
#line 1328
  *((p + 76) + 0) = (unsigned char )(((int )((unsigned short )pf->num_entries) >> 8) & 255);
#line 1328
  *((p + 76) + 1) = (unsigned char )((int )((unsigned short )pf->num_entries) & 255);
#line 1330
  tmp___20 = fwrite((void const   */* __restrict  */)(buf___3), (size_t )78, (size_t )1,
                    (FILE */* __restrict  */)f);
  }
#line 1330
  if (tmp___20 != 1UL) {
#line 1331
    goto bad;
  }
#line 1333
  i = 0;
#line 1333
  entp = pf->entries;
  {
#line 1333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1333
    if (! (i < pf->num_entries)) {
#line 1333
      goto while_break;
    }
#line 1334
    entp->offset = offset;
#line 1336
    p = buf___3;
#line 1337
    if (pf->resource_flag) {
#line 1338
      *(p + 0) = (unsigned char )((int )((unsigned char )(entp->type >> 24)) & 255);
#line 1338
      *(p + 1) = (unsigned char )((entp->type >> 16) & 255UL);
#line 1338
      *(p + 2) = (unsigned char )((entp->type >> 8) & 255UL);
#line 1338
      *(p + 3) = (unsigned char )(entp->type & 255UL);
#line 1339
      *((p + 4) + 0) = (unsigned char )(((int )((unsigned short )entp->resource_id) >> 8) & 255);
#line 1339
      *((p + 4) + 1) = (unsigned char )((int )((unsigned short )entp->resource_id) & 255);
#line 1340
      *((p + 6) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )entp->offset >> 24)) & 255);
#line 1340
      *((p + 6) + 1) = (unsigned char )(((unsigned long )entp->offset >> 16) & 255UL);
#line 1340
      *((p + 6) + 2) = (unsigned char )(((unsigned long )entp->offset >> 8) & 255UL);
#line 1340
      *((p + 6) + 3) = (unsigned char )((unsigned long )entp->offset & 255UL);
    } else {
#line 1342
      *(p + 0) = (unsigned char )((int )((unsigned char )((unsigned long )entp->offset >> 24)) & 255);
#line 1342
      *(p + 1) = (unsigned char )(((unsigned long )entp->offset >> 16) & 255UL);
#line 1342
      *(p + 2) = (unsigned char )(((unsigned long )entp->offset >> 8) & 255UL);
#line 1342
      *(p + 3) = (unsigned char )((unsigned long )entp->offset & 255UL);
#line 1343
      *((p + 4) + 0) = (unsigned char )entp->attrs;
#line 1344
      *((p + 5) + 0) = (unsigned char )((int )((unsigned char )(entp->uid >> 16)) & 255);
#line 1344
      *((p + 5) + 1) = (unsigned char )((entp->uid >> 8) & 255UL);
#line 1344
      *((p + 5) + 2) = (unsigned char )(entp->uid & 255UL);
    }
    {
#line 1347
    tmp___21 = fwrite((void const   */* __restrict  */)(buf___3), (size_t )pf->ent_hdr_size,
                      (size_t )1, (FILE */* __restrict  */)f);
    }
#line 1347
    if (tmp___21 != 1UL) {
#line 1348
      goto bad;
    }
#line 1350
    offset += entp->size;
#line 1333
    i ++;
#line 1333
    entp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1354
  fwrite((void const   */* __restrict  */)"\000\000", (size_t )1, (size_t )2, (FILE */* __restrict  */)f);
  }
#line 1356
  if (pf->app_info) {
    {
#line 1356
    tmp___22 = fwrite((void const   */* __restrict  */)pf->app_info, (size_t )1, (size_t )pf->app_info_size,
                      (FILE */* __restrict  */)f);
    }
#line 1356
    if (tmp___22 != (size_t )pf->app_info_size) {
#line 1359
      goto bad;
    }
  }
#line 1361
  if (pf->sort_info) {
    {
#line 1361
    tmp___23 = fwrite((void const   */* __restrict  */)pf->sort_info, (size_t )1,
                      (size_t )pf->sort_info_size, (FILE */* __restrict  */)f);
    }
#line 1361
    if (tmp___23 != (size_t )pf->sort_info_size) {
#line 1364
      goto bad;
    }
  }
  {
#line 1367
  fwrite((void const   */* __restrict  */)(pf->tmpbuf)->data, (pf->tmpbuf)->used,
         (size_t )1, (FILE */* __restrict  */)f);
#line 1368
  fflush(f);
#line 1370
  tmp___24 = ferror(f);
  }
#line 1370
  if (tmp___24) {
#line 1371
    goto bad;
  } else {
    {
#line 1370
    tmp___25 = feof(f);
    }
#line 1370
    if (tmp___25) {
#line 1371
      goto bad;
    }
  }
  {
#line 1373
  fclose(f);
  }
#line 1374
  return (0);
  bad: 
  {
#line 1377
  fclose(f);
  }
#line 1378
  return (-401);
}
}
#line 1392 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
static void pi_file_free(pi_file_t *pf ) 
{ 


  {
#line 1397
  if ((unsigned long )pf->f != (unsigned long )((FILE *)0)) {
    {
#line 1398
    fclose(pf->f);
    }
  }
#line 1400
  if ((unsigned long )pf->app_info != (unsigned long )((void *)0)) {
    {
#line 1401
    free(pf->app_info);
    }
  }
#line 1403
  if ((unsigned long )pf->sort_info != (unsigned long )((void *)0)) {
    {
#line 1404
    free(pf->sort_info);
    }
  }
#line 1406
  if ((unsigned long )pf->entries != (unsigned long )((void *)0)) {
    {
#line 1407
    free((void *)pf->entries);
    }
  }
#line 1409
  if ((unsigned long )pf->file_name != (unsigned long )((void *)0)) {
    {
#line 1410
    free((void *)pf->file_name);
    }
  }
#line 1412
  if ((unsigned long )pf->rbuf != (unsigned long )((void *)0)) {
    {
#line 1413
    free(pf->rbuf);
    }
  }
#line 1415
  if ((unsigned long )pf->tmpbuf != (unsigned long )((void *)0)) {
    {
#line 1416
    pi_buffer_free(pf->tmpbuf);
    }
  }
  {
#line 1419
  memset((void *)pf, 0, sizeof(pi_file_t ));
#line 1421
  free((void *)pf);
  }
#line 1422
  return;
}
}
#line 1435 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
static int pi_file_set_rbuf_size(pi_file_t *pf , size_t size ) 
{ 
  size_t new_size ;
  void *rbuf ;

  {
#line 1441
  if (size > (size_t )pf->rbuf_size) {
#line 1442
    if (pf->rbuf_size == 0) {
      {
#line 1443
      new_size = size + 2048UL;
#line 1444
      rbuf = malloc(new_size);
      }
    } else {
      {
#line 1446
      new_size = size + 2048UL;
#line 1447
      rbuf = realloc(pf->rbuf, new_size);
      }
    }
#line 1450
    if ((unsigned long )rbuf == (unsigned long )((void *)0)) {
#line 1451
      return (-500);
    }
#line 1453
    pf->rbuf_size = (int )new_size;
#line 1454
    pf->rbuf = rbuf;
  }
#line 1457
  return (0);
}
}
#line 1472 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
static pi_file_entry_t *pi_file_append_entry(pi_file_t *pf ) 
{ 
  int new_count ;
  size_t new_size ;
  struct pi_file_entry *new_entries ;
  struct pi_file_entry *entp ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1480
  if (pf->num_entries >= pf->num_entries_allocated) {
#line 1481
    if (pf->num_entries_allocated == 0) {
#line 1482
      new_count = 100;
    } else {
#line 1484
      new_count = (pf->num_entries_allocated * 3) / 2;
    }
#line 1485
    new_size = (unsigned long )new_count * sizeof(*(pf->entries));
#line 1487
    if ((unsigned long )pf->entries == (unsigned long )((void *)0)) {
      {
#line 1488
      tmp = malloc(new_size);
#line 1488
      new_entries = (struct pi_file_entry *)tmp;
      }
    } else {
      {
#line 1490
      tmp___0 = realloc((void *)pf->entries, new_size);
#line 1490
      new_entries = (struct pi_file_entry *)tmp___0;
      }
    }
#line 1492
    if ((unsigned long )new_entries == (unsigned long )((void *)0)) {
#line 1493
      return ((pi_file_entry_t *)((void *)0));
    }
#line 1495
    pf->num_entries_allocated = new_count;
#line 1496
    pf->entries = new_entries;
  }
  {
#line 1499
  tmp___1 = pf->num_entries;
#line 1499
  (pf->num_entries) ++;
#line 1499
  entp = pf->entries + tmp___1;
#line 1500
  memset((void *)entp, 0, sizeof(*entp));
  }
#line 1501
  return (entp);
}
}
#line 1504 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
static int pi_file_find_resource_by_type_id(pi_file_t const   *pf , unsigned long restype ,
                                            int resid , int *resindex ) 
{ 
  int i ;
  struct pi_file_entry *entp ;

  {
#line 1511
  if (! pf->resource_flag) {
#line 1512
    return (-400);
  }
#line 1514
  i = 0;
#line 1514
  entp = (struct pi_file_entry *)pf->entries;
  {
#line 1514
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1514
    if (! (i < (int )pf->num_entries)) {
#line 1514
      goto while_break;
    }
#line 1515
    if (entp->type == restype) {
#line 1515
      if (entp->resource_id == resid) {
#line 1516
        if (resindex) {
#line 1517
          *resindex = i;
        }
#line 1518
        return (1);
      }
    }
#line 1514
    i ++;
#line 1514
    entp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1521
  return (0);
}
}
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 243 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 611 "../include/pi-dlp.h"
struct dlpArg *dlp_arg_new(int argID , size_t len ) ;
#line 612
void dlp_arg_free(struct dlpArg *arg ) ;
#line 613
int dlp_arg_len(int argc , struct dlpArg **argv ) ;
#line 615
struct dlpRequest *dlp_request_new(enum dlpFunctions cmd , int argc  , ...) ;
#line 617
struct dlpRequest *dlp_request_new_with_argid(enum dlpFunctions cmd , int argid ,
                                              int argc  , ...) ;
#line 619
void dlp_request_free(struct dlpRequest *req ) ;
#line 621
struct dlpResponse *dlp_response_new(enum dlpFunctions cmd , int argc ) ;
#line 623
ssize_t dlp_response_read(struct dlpResponse **res , int sd ) ;
#line 625
ssize_t dlp_request_write(struct dlpRequest *req , int sd ) ;
#line 627
void dlp_response_free(struct dlpResponse *res ) ;
#line 629
int dlp_exec(int sd , struct dlpRequest *req , struct dlpResponse **res ) ;
#line 632
char *dlp_errorlist[22] ;
#line 633
char *dlp_strerror(int error ) ;
#line 636
int dlp_RPC(int sd , struct RPC_params *p , unsigned long *result ) ;
#line 655
void dlp_set_protocol_version(int major , int minor ) ;
#line 666
time_t dlp_ptohdate(unsigned char const   *data ) ;
#line 676
void dlp_htopdate(time_t time_interval , unsigned char *data ) ;
#line 687
int dlp_GetSysDateTime(int sd , time_t *t ) ;
#line 695
int dlp_SetSysDateTime(int sd , time_t t ) ;
#line 712
int dlp_ReadStorageInfo(int sd , int cardno , struct CardInfo *c ) ;
#line 721
int dlp_ReadUserInfo(int sd , struct PilotUser *User ) ;
#line 730
int dlp_WriteUserInfo(int sd , struct PilotUser  const  *User ) ;
#line 738
int dlp_ResetLastSyncPC(int sd ) ;
#line 748
int dlp_ReadNetSyncInfo(int sd , struct NetSyncInfo *i ) ;
#line 759
int dlp_WriteNetSyncInfo(int sd , struct NetSyncInfo  const  *i ) ;
#line 795
int dlp_AbortSync(int sd ) ;
#line 805
int dlp_ReadFeature(int sd , unsigned long creator , int num , unsigned long *feature ) ;
#line 824
int dlp_GetROMToken(int sd , unsigned long token , void *buffer , size_t *size ) ;
#line 837
int dlp_AddSyncLogEntry(int sd , char *entry ) ;
#line 859
int dlp_CallApplication(int sd , unsigned long creator , unsigned long type , int action ,
                        size_t length , void const   *data , unsigned long *retcode ,
                        pi_buffer_t *retbuf ) ;
#line 878
int dlp_ReadAppPreference(int sd , unsigned long creator , int prefID , int backup ,
                          int maxsize , void *buffer , size_t *size , int *version ) ;
#line 895
int dlp_WriteAppPreference(int sd , unsigned long creator , int prefID , int backup ,
                           int version , void const   *buffer , size_t size ) ;
#line 932
int dlp_ReadDBList(int sd , int cardno , int flags , int start , pi_buffer_t *info ) ;
#line 965
int dlp_FindDBByOpenHandle(int sd , int dbhandle , int *cardno , unsigned long *localid ,
                           struct DBInfo *info , struct DBSizeInfo *size ) ;
#line 987
int dlp_FindDBByTypeCreator(int sd , unsigned long type , unsigned long creator ,
                            int start , int latest , int *cardno , unsigned long *localid ,
                            int *dbhandle , struct DBInfo *info , struct DBSizeInfo *size ) ;
#line 1009
int dlp_FindDBInfo(int sd , int cardno , int start , char const   *dbname , unsigned long type ,
                   unsigned long creator , struct DBInfo *info ) ;
#line 1040
int dlp_CloseDB_All(int sd ) ;
#line 1098
int dlp_SetDBInfo(int sd , int dbhandle , int flags , int clearFlags , unsigned int version ,
                  time_t createDate , time_t modifyDate , time_t backupDate , unsigned long type ,
                  unsigned long creator ) ;
#line 1112
int dlp_DeleteCategory(int sd , int dbhandle , int category ) ;
#line 1123
int dlp_MoveCategory(int sd , int handle , int fromcat , int tocat ) ;
#line 1159
int dlp_ReadSortBlock(int sd , int dbhandle , int offset , int reqbytes , pi_buffer_t *retbuf ) ;
#line 1171
int dlp_WriteSortBlock(int sd , int dbhandle , void const   *data , size_t length ) ;
#line 1184
int dlp_CleanUpDatabase(int sd , int dbhandle ) ;
#line 1195
int dlp_ResetSyncFlags(int sd , int dbhandle ) ;
#line 1205
int dlp_ResetDBIndex(int sd , int dbhandle ) ;
#line 1219
int dlp_ReadRecordIDList(int sd , int dbhandle , int sort , int start , int max ,
                         recordid_t *IDs , int *count ) ;
#line 1240
int dlp_ReadRecordById(int sd , int dbhandle , recordid_t recuid , pi_buffer_t *buffer ,
                       int *recindex , int *attr , int *category ) ;
#line 1278
int dlp_ReadNextModifiedRec(int sd , int dbhandle , pi_buffer_t *buffer , recordid_t *recID ,
                            int *recindex , int *attr , int *category ) ;
#line 1298
int dlp_ReadNextModifiedRecInCategory(int sd , int dbhandle , int category , pi_buffer_t *buffer ,
                                      recordid_t *recID , int *recindex , int *attr ) ;
#line 1318
int dlp_ReadNextRecInCategory(int sd , int dbhandle , int category , pi_buffer_t *buffer ,
                              recordid_t *recuid , int *recindex , int *attr ) ;
#line 1357
int dlp_DeleteRecord(int sd , int dbhandle , int all , recordid_t recID ) ;
#line 1372
int dlp_ReadResourceByType(int sd , int dbhandle , unsigned long type , int resID ,
                           pi_buffer_t *buffer , int *resindex ) ;
#line 1419
int dlp_DeleteResource(int sd , int dbhandle , int all , unsigned long restype , int resID ) ;
#line 1437
int dlp_ExpSlotEnumerate(int sd , int *numSlots , int *slotRefs ) ;
#line 1449
int dlp_ExpCardPresent(int sd , int slotRef ) ;
#line 1465
int dlp_ExpCardInfo(int sd , int slotRef , unsigned long *flags , int *numStrings ,
                    char **strings ) ;
#line 1478
int dlp_ExpSlotMediaType(int sd , int slotNum , unsigned long *mediaType ) ;
#line 1493
int dlp_VFSVolumeEnumerate(int sd , int *numVols , int *volRefs ) ;
#line 1505
int dlp_VFSVolumeInfo(int sd , int volRefNum , struct VFSInfo *volInfo ) ;
#line 1518
int dlp_VFSVolumeGetLabel(int sd , int volRefNum , int *len , char *name ) ;
#line 1530
int dlp_VFSVolumeSetLabel(int sd , int volRefNum , char const   *name ) ;
#line 1543
int dlp_VFSVolumeSize(int sd , int volRefNum , long *volSizeUsed , long *volSizeTotal ) ;
#line 1556
int dlp_VFSVolumeFormat(int sd , unsigned char flags , int fsLibRef , struct VFSSlotMountParam *param ) ;
#line 1573
int dlp_VFSGetDefaultDir(int sd , int volRefNum , char const   *type , char *dir ,
                         int *len ) ;
#line 1596
int dlp_VFSDirEntryEnumerate(int sd , FileRef dirRefNum , unsigned long *dirIterator ,
                             int *maxDirItems , struct VFSDirInfo *data ) ;
#line 1609
int dlp_VFSDirCreate(int sd , int volRefNum , char const   *path ) ;
#line 1624
int dlp_VFSImportDatabaseFromFile(int sd , int volRefNum , char const   *path , int *cardno ,
                                  unsigned long *localid ) ;
#line 1640
int dlp_VFSExportDatabaseToFile(int sd , int volRefNum , char const   *path , int cardno ,
                                unsigned int localid ) ;
#line 1653
int dlp_VFSFileCreate(int sd , int volRefNum , char const   *name ) ;
#line 1669
int dlp_VFSFileOpen(int sd , int volRefNum , char const   *path , int openMode , FileRef *fileRef ) ;
#line 1681
int dlp_VFSFileClose(int sd , FileRef fileRef ) ;
#line 1695
int dlp_VFSFileWrite(int sd , FileRef fileRef , void const   *data , size_t len ) ;
#line 1709
int dlp_VFSFileRead(int sd , FileRef fileRef , pi_buffer_t *data , size_t len ) ;
#line 1721
int dlp_VFSFileDelete(int sd , int volRefNum , char const   *path ) ;
#line 1738
int dlp_VFSFileRename(int sd , int volRefNum , char const   *path , char const   *newname ) ;
#line 1750
int dlp_VFSFileEOF(int sd , FileRef fileRef ) ;
#line 1762
int dlp_VFSFileTell(int sd , FileRef fileRef , int *position ) ;
#line 1774
int dlp_VFSFileGetAttributes(int sd , FileRef fileRef , unsigned long *attributes ) ;
#line 1786
int dlp_VFSFileSetAttributes(int sd , FileRef fileRef , unsigned long attributes ) ;
#line 1799
int dlp_VFSFileGetDate(int sd , FileRef fileRef , int which , time_t *date ) ;
#line 1812
int dlp_VFSFileSetDate(int sd , FileRef fileRef , int which , time_t date ) ;
#line 1825
int dlp_VFSFileSeek(int sd , FileRef fileRef , int origin , int offset ) ;
#line 1837
int dlp_VFSFileResize(int sd , FileRef fileRef , int newSize ) ;
#line 1849
int dlp_VFSFileSize(int sd , FileRef fileRef , int *size ) ;
#line 63 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
static void record_dump(unsigned long recID , unsigned int recIndex , int flags ,
                        int catID , char const   *data , int data_len ) ;
#line 67 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
char *dlp_errorlist[22]  = 
#line 67
  {      (char *)"No error",      (char *)"General System error",      (char *)"Illegal Function",      (char *)"Out of memory", 
        (char *)"Invalid parameter",      (char *)"Not found",      (char *)"None Open",      (char *)"Already Open", 
        (char *)"Too many Open",      (char *)"Already Exists",      (char *)"Cannot Open",      (char *)"Record deleted", 
        (char *)"Record busy",      (char *)"Operation not supported",      (char *)"-Unused-",      (char *)"Read only", 
        (char *)"Not enough space",      (char *)"Limit exceeded",      (char *)"Sync cancelled",      (char *)"Bad arg wrapper", 
        (char *)"Argument missing",      (char *)"Bad argument size"};
#line 94 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
char *vfs_errorlist[21]  = 
#line 94
  {      (char *)"No error",      (char *)"Buffer Overflow",      (char *)"Generic file error",      (char *)"File reference is invalid", 
        (char *)"File still open",      (char *)"Permission denied",      (char *)"File or folder already exists",      (char *)"FileEOF", 
        (char *)"File not found",      (char *)"volumereference is invalid",      (char *)"Volume still mounted",      (char *)"No filesystem", 
        (char *)"Bad data",      (char *)"Non-empty directory",      (char *)"Invalid path or filename",      (char *)"Volume full - not enough space", 
        (char *)"Unimplemented",      (char *)"Not a directory",      (char *)"Is a directory",      (char *)"Directory not found", 
        (char *)"Name truncated"};
#line 120 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
char *exp_errorlist[15]  = 
#line 120
  {      (char *)"No error",      (char *)"Unsupported Operation",      (char *)"Not enough Power",      (char *)"Card not present", 
        (char *)"Invalid slotreference number",      (char *)"Slot deallocated",      (char *)"Card no sector read/write",      (char *)"Card read only", 
        (char *)"Card bad sector",      (char *)"Protected sector",      (char *)"Not open (slot driver)",      (char *)"still open (slot driver)", 
        (char *)"Unimplemented",      (char *)"Enumeration empty",      (char *)"Incompatible API version"};
#line 141 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
static int dlp_version_major  =    1;
#line 142 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
static int dlp_version_minor  =    4;
#line 160 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
static void record_dump(unsigned long recID , unsigned int recIndex , int flags ,
                        int catID , char const   *data , int data_len ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 163
  if (! flags) {
#line 163
    tmp = " None";
  } else {
#line 163
    tmp = "";
  }
#line 163
  if (flags & 8) {
#line 163
    tmp___0 = " Archive";
  } else {
#line 163
    tmp___0 = "";
  }
#line 163
  if (flags & 16) {
#line 163
    tmp___1 = " Secret";
  } else {
#line 163
    tmp___1 = "";
  }
#line 163
  if (flags & 32) {
#line 163
    tmp___2 = " Busy";
  } else {
#line 163
    tmp___2 = "";
  }
#line 163
  if (flags & 64) {
#line 163
    tmp___3 = " Dirty";
  } else {
#line 163
    tmp___3 = "";
  }
#line 163
  if (flags & 128) {
#line 163
    tmp___4 = " Deleted";
  } else {
#line 163
    tmp___4 = "";
  }
  {
#line 163
  pi_log(16, 4, "  ID: 0x%8.8lX, Index: %u, Category: %d\n  Flags:%s%s%s%s%s%s (0x%2.2X), and %d bytes:\n",
         recID, recIndex, catID, tmp___4, tmp___3, tmp___2, tmp___1, tmp___0, tmp,
         flags, data_len);
#line 176
  pi_dumpdata(data, (size_t )data_len);
  }
#line 177
  return;
}
}
#line 180 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
void dlp_set_protocol_version(int major , int minor ) 
{ 


  {
#line 183
  dlp_version_major = major;
#line 184
  dlp_version_minor = minor;
#line 185
  return;
}
}
#line 198 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
char *dlp_strerror(int error ) 
{ 


  {
#line 201
  if (error < 0) {
#line 202
    error = - error;
  }
#line 204
  if ((unsigned long )((unsigned int )error) >= sizeof(dlp_errorlist) / sizeof(char *)) {
#line 205
    return ((char *)"Unknown error");
  }
#line 207
  return (dlp_errorlist[error]);
}
}
#line 222 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
struct dlpArg *dlp_arg_new(int argID , size_t len ) 
{ 
  struct dlpArg *arg ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 227
  tmp = malloc(sizeof(struct dlpArg ));
#line 227
  arg = (struct dlpArg *)tmp;
  }
#line 229
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
#line 230
    arg->id_ = argID;
#line 231
    arg->len = len;
#line 232
    arg->data = (char *)((void *)0);
#line 233
    if (len > 0UL) {
      {
#line 234
      tmp___0 = malloc(len);
#line 234
      arg->data = (char *)tmp___0;
      }
#line 235
      if ((unsigned long )arg->data == (unsigned long )((void *)0)) {
        {
#line 236
        free((void *)arg);
#line 237
        arg = (struct dlpArg *)((void *)0);
        }
      }
    }
  }
#line 242
  return (arg);
}
}
#line 257 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
void dlp_arg_free(struct dlpArg *arg ) 
{ 


  {
#line 260
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
#line 261
    if ((unsigned long )arg->data != (unsigned long )((void *)0)) {
      {
#line 262
      free((void *)arg->data);
      }
    }
    {
#line 263
    free((void *)arg);
    }
  }
#line 265
  return;
}
}
#line 280 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_arg_len(int argc , struct dlpArg **argv ) 
{ 
  int i ;
  int len ;
  struct dlpArg *arg ;

  {
#line 283
  len = 0;
#line 285
  i = 0;
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (! (i < argc)) {
#line 285
      goto while_break;
    }
#line 286
    arg = *(argv + i);
#line 289
    if (arg->len < 255UL) {
#line 289
      if ((arg->id_ & 192) == 0) {
#line 291
        len += 2;
      } else {
#line 289
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 292
    if (arg->len < 65535UL) {
#line 292
      if ((arg->id_ & 64) == 0) {
#line 294
        len += 4;
      } else {
#line 296
        len += 6;
      }
    } else {
#line 296
      len += 6;
    }
#line 298
    len = (int )((size_t )len + arg->len);
#line 285
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  return (len);
}
}
#line 317 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
struct dlpRequest *dlp_request_new(enum dlpFunctions cmd , int argc  , ...) 
{ 
  struct dlpRequest *req ;
  va_list ap ;
  int i ;
  int j ;
  void *tmp ;
  void *tmp___0 ;
  size_t len ;
  size_t tmp___1 ;

  {
  {
#line 325
  tmp = malloc(sizeof(struct dlpRequest ));
#line 325
  req = (struct dlpRequest *)tmp;
  }
#line 327
  if ((unsigned long )req != (unsigned long )((void *)0)) {
#line 328
    req->cmd = cmd;
#line 329
    req->argc = argc;
#line 330
    req->argv = (struct dlpArg **)((void *)0);
#line 332
    if (argc) {
      {
#line 333
      tmp___0 = malloc(sizeof(struct dlpArg *) * (unsigned long )argc);
#line 333
      req->argv = (struct dlpArg **)tmp___0;
      }
#line 334
      if ((unsigned long )req->argv == (unsigned long )((void *)0)) {
        {
#line 335
        free((void *)req);
        }
#line 336
        return ((struct dlpRequest *)((void *)0));
      }
    }
    {
#line 340
    __builtin_va_start(ap, argc);
#line 341
    i = 0;
    }
    {
#line 341
    while (1) {
      while_continue: /* CIL Label */ ;
#line 341
      if (! (i < argc)) {
#line 341
        goto while_break;
      }
      {
#line 344
      tmp___1 = __builtin_va_arg(ap, size_t );
#line 344
      len = tmp___1;
#line 345
      *(req->argv + i) = dlp_arg_new(32 + i, len);
      }
#line 347
      if ((unsigned long )*(req->argv + i) == (unsigned long )((void *)0)) {
#line 348
        j = 0;
        {
#line 348
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 348
          if (! (j < i)) {
#line 348
            goto while_break___0;
          }
          {
#line 349
          dlp_arg_free(*(req->argv + j));
#line 348
          j ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 350
        free((void *)req->argv);
#line 351
        free((void *)req);
#line 352
        req = (struct dlpRequest *)((void *)0);
        }
#line 353
        goto while_break;
      }
#line 341
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 356
    __builtin_va_end(ap);
    }
  }
#line 359
  return (req);
}
}
#line 375 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
struct dlpRequest *dlp_request_new_with_argid(enum dlpFunctions cmd , int argid ,
                                              int argc  , ...) 
{ 
  struct dlpRequest *req ;
  va_list ap ;
  int i ;
  int j ;
  void *tmp ;
  void *tmp___0 ;
  size_t len ;
  size_t tmp___1 ;

  {
  {
#line 383
  tmp = malloc(sizeof(struct dlpRequest ));
#line 383
  req = (struct dlpRequest *)tmp;
  }
#line 385
  if ((unsigned long )req != (unsigned long )((void *)0)) {
#line 386
    req->cmd = cmd;
#line 387
    req->argc = argc;
#line 388
    req->argv = (struct dlpArg **)((void *)0);
#line 390
    if (argc) {
      {
#line 391
      tmp___0 = malloc(sizeof(struct dlpArg *) * (unsigned long )argc);
#line 391
      req->argv = (struct dlpArg **)tmp___0;
      }
#line 392
      if ((unsigned long )req->argv == (unsigned long )((void *)0)) {
        {
#line 393
        free((void *)req);
        }
#line 394
        return ((struct dlpRequest *)((void *)0));
      }
    }
    {
#line 398
    __builtin_va_start(ap, argc);
#line 399
    i = 0;
    }
    {
#line 399
    while (1) {
      while_continue: /* CIL Label */ ;
#line 399
      if (! (i < argc)) {
#line 399
        goto while_break;
      }
      {
#line 402
      tmp___1 = __builtin_va_arg(ap, size_t );
#line 402
      len = tmp___1;
#line 403
      *(req->argv + i) = dlp_arg_new(argid + i, len);
      }
#line 404
      if ((unsigned long )*(req->argv + i) == (unsigned long )((void *)0)) {
#line 405
        j = 0;
        {
#line 405
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 405
          if (! (j < i)) {
#line 405
            goto while_break___0;
          }
          {
#line 406
          dlp_arg_free(*(req->argv + j));
#line 405
          j ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 407
        free((void *)req->argv);
#line 408
        free((void *)req);
#line 409
        req = (struct dlpRequest *)((void *)0);
        }
#line 410
        goto while_break;
      }
#line 399
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 413
    __builtin_va_end(ap);
    }
  }
#line 416
  return (req);
}
}
#line 431 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
struct dlpResponse *dlp_response_new(enum dlpFunctions cmd , int argc ) 
{ 
  struct dlpResponse *res ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 436
  tmp = malloc(sizeof(struct dlpResponse ));
#line 436
  res = (struct dlpResponse *)tmp;
  }
#line 438
  if ((unsigned long )res != (unsigned long )((void *)0)) {
#line 440
    res->cmd = cmd;
#line 441
    res->err = (enum dlpErrors )0;
#line 442
    res->argc = argc;
#line 443
    res->argv = (struct dlpArg **)((void *)0);
#line 445
    if (argc) {
      {
#line 446
      tmp___0 = malloc(sizeof(struct dlpArg *) * (unsigned long )argc);
#line 446
      res->argv = (struct dlpArg **)tmp___0;
      }
#line 447
      if ((unsigned long )res->argv == (unsigned long )((void *)0)) {
        {
#line 448
        free((void *)res);
        }
#line 449
        return ((struct dlpResponse *)((void *)0));
      }
      {
#line 454
      memset((void *)res->argv, 0, sizeof(struct dlpArg *) * (unsigned long )argc);
      }
    }
  }
#line 458
  return (res);
}
}
#line 473 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
ssize_t dlp_response_read(struct dlpResponse **res , int sd ) 
{ 
  struct dlpResponse *response ;
  unsigned char *buf___3 ;
  short argid ;
  int i ;
  ssize_t bytes ;
  size_t len ;
  pi_buffer_t *dlp_buf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  PI_ERR tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 484
  dlp_buf = pi_buffer_new((size_t )65535);
  }
#line 485
  if ((unsigned long )dlp_buf == (unsigned long )((void *)0)) {
    {
#line 486
    tmp = pi_set_error(sd, -500);
    }
#line 486
    return ((ssize_t )tmp);
  }
  {
#line 488
  bytes = pi_read(sd, dlp_buf, dlp_buf->allocated);
  }
#line 489
  if (bytes < 0L) {
    {
#line 490
    pi_buffer_free(dlp_buf);
    }
#line 491
    return (bytes);
  }
#line 493
  if (bytes < 4L) {
    {
#line 502
    tmp___0 = pi_set_error(sd, -305);
    }
#line 502
    return ((ssize_t )tmp___0);
  }
  {
#line 505
  response = dlp_response_new((enum dlpFunctions )((int )*(dlp_buf->data + 0) & 127),
                              (int )*(dlp_buf->data + 1));
#line 506
  *res = response;
  }
#line 510
  if ((unsigned long )response == (unsigned long )((void *)0)) {
    {
#line 511
    pi_buffer_free(dlp_buf);
#line 512
    tmp___1 = pi_set_error(sd, -500);
    }
#line 512
    return ((ssize_t )tmp___1);
  }
  {
#line 515
  response->err = (enum dlpErrors )((unsigned short )(((int )*((dlp_buf->data + 2) + 0) << 8) | (int )*((dlp_buf->data + 2) + 1)));
#line 516
  pi_set_palmos_error(sd, (int )response->err);
#line 520
  buf___3 = dlp_buf->data + 4;
#line 521
  i = 0;
  }
  {
#line 521
  while (1) {
    while_continue: /* CIL Label */ ;
#line 521
    if (! (i < response->argc)) {
#line 521
      goto while_break;
    }
#line 522
    argid = (short )((int )*(buf___3 + 0) & 63);
#line 523
    if ((int )*(buf___3 + 0) & 64) {
      {
#line 524
      tmp___3 = pi_version(sd);
      }
#line 524
      if (tmp___3 < 260) {
        {
#line 533
        pi_buffer_free(dlp_buf);
#line 534
        tmp___2 = pi_set_error(sd, -304);
        }
#line 534
        return ((ssize_t )tmp___2);
      }
#line 536
      len = ((((unsigned long )*((buf___3 + 2) + 0) << 24) | ((unsigned long )*((buf___3 + 2) + 1) << 16)) | ((unsigned long )*((buf___3 + 2) + 2) << 8)) | (unsigned long )*((buf___3 + 2) + 3);
#line 537
      buf___3 += 6;
    } else
#line 538
    if ((int )*(buf___3 + 0) & 128) {
#line 539
      len = (size_t )((unsigned short )(((int )*((buf___3 + 2) + 0) << 8) | (int )*((buf___3 + 2) + 1)));
#line 540
      buf___3 += 4;
    } else {
#line 542
      argid = (short )*(buf___3 + 0);
#line 543
      len = (size_t )*((buf___3 + 1) + 0);
#line 544
      buf___3 += 2;
    }
    {
#line 547
    *(response->argv + i) = dlp_arg_new((int )argid, len);
    }
#line 548
    if ((unsigned long )*(response->argv + i) == (unsigned long )((void *)0)) {
      {
#line 549
      pi_buffer_free(dlp_buf);
#line 550
      tmp___4 = pi_set_error(sd, -500);
      }
#line 550
      return ((ssize_t )tmp___4);
    }
    {
#line 552
    memcpy((void */* __restrict  */)(*(response->argv + i))->data, (void const   */* __restrict  */)buf___3,
           len);
#line 553
    buf___3 += len;
#line 521
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 556
  pi_buffer_free(dlp_buf);
  }
#line 558
  if (response->argc) {
#line 558
    tmp___5 = (*(response->argv + 0))->len;
  } else {
#line 558
    tmp___5 = (size_t )0;
  }
#line 558
  return ((ssize_t )tmp___5);
}
}
#line 573 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
ssize_t dlp_request_write(struct dlpRequest *req , int sd ) 
{ 
  unsigned char *exec_buf ;
  unsigned char *buf___3 ;
  int i ;
  size_t len ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  struct dlpArg *arg ;
  short argid ;
  int *tmp___2 ;
  ssize_t tmp___3 ;

  {
  {
#line 580
  tmp = dlp_arg_len(req->argc, req->argv);
#line 580
  len = (size_t )(tmp + 2);
#line 581
  tmp___0 = malloc(sizeof(unsigned char ) * len);
#line 581
  exec_buf = (unsigned char *)tmp___0;
  }
#line 582
  if ((unsigned long )exec_buf == (unsigned long )((void *)0)) {
    {
#line 583
    tmp___1 = pi_set_error(sd, -500);
    }
#line 583
    return ((ssize_t )tmp___1);
  }
#line 585
  *((exec_buf + 0) + 0) = (unsigned char )req->cmd;
#line 586
  *((exec_buf + 1) + 0) = (unsigned char )req->argc;
#line 588
  buf___3 = exec_buf + 2;
#line 589
  i = 0;
  {
#line 589
  while (1) {
    while_continue: /* CIL Label */ ;
#line 589
    if (! (i < req->argc)) {
#line 589
      goto while_break;
    }
#line 590
    arg = *(req->argv + i);
#line 591
    argid = (short )arg->id_;
#line 593
    if (arg->len < 255UL) {
#line 593
      if (((int )argid & 192) == 0) {
        {
#line 595
        *((buf___3 + 0) + 0) = (unsigned char )((int )argid);
#line 596
        *((buf___3 + 1) + 0) = (unsigned char )arg->len;
#line 598
        memcpy((void */* __restrict  */)(buf___3 + 2), (void const   */* __restrict  */)arg->data,
               arg->len);
#line 599
        buf___3 += arg->len + 2UL;
        }
      } else {
#line 593
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 600
    if (arg->len < 65535UL) {
#line 600
      if (((int )argid & 64) == 0) {
        {
#line 602
        *((buf___3 + 0) + 0) = (unsigned char )((int )argid | 128);
#line 603
        *((buf___3 + 1) + 0) = (unsigned char)0;
#line 604
        *((buf___3 + 2) + 0) = (unsigned char )(((int )((unsigned short )arg->len) >> 8) & 255);
#line 604
        *((buf___3 + 2) + 1) = (unsigned char )((int )((unsigned short )arg->len) & 255);
#line 606
        memcpy((void */* __restrict  */)(buf___3 + 4), (void const   */* __restrict  */)arg->data,
               arg->len);
#line 607
        buf___3 += arg->len + 4UL;
        }
      } else {
#line 600
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 609
      *((buf___3 + 0) + 0) = (unsigned char )((int )argid | 64);
#line 610
      *((buf___3 + 1) + 0) = (unsigned char)0;
#line 611
      *((buf___3 + 2) + 0) = (unsigned char )((int )((unsigned char )(arg->len >> 24)) & 255);
#line 611
      *((buf___3 + 2) + 1) = (unsigned char )((arg->len >> 16) & 255UL);
#line 611
      *((buf___3 + 2) + 2) = (unsigned char )((arg->len >> 8) & 255UL);
#line 611
      *((buf___3 + 2) + 3) = (unsigned char )(arg->len & 255UL);
#line 613
      memcpy((void */* __restrict  */)(buf___3 + 6), (void const   */* __restrict  */)arg->data,
             arg->len);
#line 614
      buf___3 += arg->len + 6UL;
      }
    }
#line 589
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 618
  pi_flush(sd, 1);
#line 620
  tmp___3 = pi_write(sd, (void const   *)exec_buf, len);
#line 620
  i = (int )tmp___3;
  }
#line 620
  if ((ssize_t )i < (ssize_t )len) {
    {
#line 621
    tmp___2 = __errno_location();
#line 621
    *tmp___2 = -5;
    }
#line 622
    if (i >= 0) {
#line 622
      if ((ssize_t )i < (ssize_t )len) {
#line 623
        i = -1;
      }
    }
  }
  {
#line 626
  free((void *)exec_buf);
  }
#line 628
  return ((ssize_t )i);
}
}
#line 643 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
void dlp_request_free(struct dlpRequest *req ) 
{ 
  int i ;

  {
#line 648
  if ((unsigned long )req == (unsigned long )((void *)0)) {
#line 649
    return;
  }
#line 651
  if ((unsigned long )req->argv != (unsigned long )((void *)0)) {
#line 652
    i = 0;
    {
#line 652
    while (1) {
      while_continue: /* CIL Label */ ;
#line 652
      if (! (i < req->argc)) {
#line 652
        goto while_break;
      }
#line 653
      if ((unsigned long )*(req->argv + i) != (unsigned long )((void *)0)) {
        {
#line 654
        dlp_arg_free(*(req->argv + i));
        }
      }
#line 652
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 656
    free((void *)req->argv);
    }
  }
  {
#line 659
  free((void *)req);
  }
#line 660
  return;
}
}
#line 674 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
void dlp_response_free(struct dlpResponse *res ) 
{ 
  int i ;

  {
#line 679
  if ((unsigned long )res == (unsigned long )((void *)0)) {
#line 680
    return;
  }
#line 682
  if ((unsigned long )res->argv != (unsigned long )((void *)0)) {
#line 683
    i = 0;
    {
#line 683
    while (1) {
      while_continue: /* CIL Label */ ;
#line 683
      if (! (i < res->argc)) {
#line 683
        goto while_break;
      }
#line 684
      if ((unsigned long )*(res->argv + i) != (unsigned long )((void *)0)) {
        {
#line 685
        dlp_arg_free(*(res->argv + i));
        }
      }
#line 683
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 687
    free((void *)res->argv);
    }
  }
  {
#line 690
  free((void *)res);
  }
#line 691
  return;
}
}
#line 705 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_exec(int sd , struct dlpRequest *req , struct dlpResponse **res ) 
{ 
  int bytes ;
  int result ;
  int *tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 709
  *res = (struct dlpResponse *)((void *)0);
#line 711
  tmp___0 = dlp_request_write(req, sd);
#line 711
  result = (int )tmp___0;
  }
#line 711
  if (result < req->argc) {
    {
#line 712
    pi_log(16, 1, "DLP sd:%i dlp_request_write returned %i\n", sd, result);
#line 715
    tmp = __errno_location();
#line 715
    *tmp = -5;
    }
#line 716
    return (result);
  }
  {
#line 719
  tmp___2 = dlp_response_read(res, sd);
#line 719
  bytes = (int )tmp___2;
  }
#line 719
  if (bytes < 0) {
    {
#line 720
    pi_log(16, 1, "DLP sd:%i dlp_response_read returned %i\n", sd, bytes);
#line 723
    tmp___1 = __errno_location();
#line 723
    *tmp___1 = -5;
    }
#line 724
    return (bytes);
  }
#line 728
  if ((unsigned int )(*res)->cmd != (unsigned int )req->cmd) {
#line 732
    if ((unsigned int )req->cmd != 86U) {
#line 732
      goto _L;
    } else
#line 732
    if ((unsigned int )(*res)->cmd != 89U) {
      _L: /* CIL Label */ 
#line 732
      if ((unsigned int )req->cmd != 36U) {
#line 732
        if ((unsigned int )req->cmd != 32U) {
#line 732
          if ((unsigned int )req->cmd != 96U) {
            {
#line 737
            tmp___3 = __errno_location();
#line 737
            *tmp___3 = -42;
#line 739
            pi_log(16, 8, "dlp_exec: result CMD 0x%02x doesn\'t match requested cmd 0x%02x\n",
                   (unsigned int )(*res)->cmd, (unsigned int )req->cmd);
#line 743
            tmp___4 = pi_set_error(sd, -305);
            }
#line 743
            return (tmp___4);
          }
        }
      }
    }
  }
#line 748
  if ((unsigned int )(*res)->err != 0U) {
    {
#line 749
    tmp___5 = __errno_location();
#line 749
    *tmp___5 = -42;
#line 750
    pi_set_palmos_error(sd, (int )(*res)->err);
#line 751
    tmp___6 = pi_set_error(sd, -301);
    }
#line 751
    return (tmp___6);
  }
#line 754
  return (bytes);
}
}
#line 770 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
time_t dlp_ptohdate(unsigned char const   *data ) 
{ 
  struct tm t ;
  time_t tmp ;

  {
#line 786
  if ((int const   )*(data + 0) == 0) {
#line 786
    if ((int const   )*(data + 1) == 0) {
#line 806
      return ((time_t )2212151296U);
    }
  }
  {
#line 809
  memset((void *)(& t), 0, sizeof(t));
#line 810
  t.tm_sec = (int )*(data + 6);
#line 811
  t.tm_min = (int )*(data + 5);
#line 812
  t.tm_hour = (int )*(data + 4);
#line 813
  t.tm_mday = (int )*(data + 3);
#line 814
  t.tm_mon = (int )*(data + 2) - 1;
#line 815
  t.tm_year = (((int )*(data + 0) << 8) | (int )*(data + 1)) - 1900;
#line 816
  t.tm_isdst = -1;
#line 818
  tmp = mktime(& t);
  }
#line 818
  return (tmp);
}
}
#line 821 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
void dlp_htopdate(time_t time_interval , unsigned char *data ) 
{ 
  int year ;
  struct tm  const  *t ;
  time_t palm_epoch ;
  struct tm *tmp ;

  {
#line 828
  palm_epoch = (time_t )2212151296U;
#line 830
  if (time_interval == palm_epoch) {
    {
#line 831
    memset((void *)data, 0, (size_t )8);
    }
#line 832
    return;
  }
  {
#line 835
  tmp = localtime((time_t const   *)(& time_interval));
#line 835
  t = (struct tm  const  *)tmp;
  }
  {
#line 836
  while (1) {
    while_continue: /* CIL Label */ ;
#line 836
    if (! ((unsigned long )t != (unsigned long )((void *)0))) {
      {
#line 836
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c",
             836, "t != NULL");
      }
    }
#line 836
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 838
  year = (int )(t->tm_year + 1900);
#line 840
  *(data + 7) = (unsigned char)0;
#line 841
  *(data + 6) = (unsigned char )t->tm_sec;
#line 842
  *(data + 5) = (unsigned char )t->tm_min;
#line 843
  *(data + 4) = (unsigned char )t->tm_hour;
#line 844
  *(data + 3) = (unsigned char )t->tm_mday;
#line 845
  *(data + 2) = (unsigned char )(t->tm_mon + 1);
#line 846
  *(data + 0) = (unsigned char )(year >> 8);
#line 847
  *(data + 1) = (unsigned char )year;
#line 848
  return;
}
}
#line 850 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_GetSysDateTime(int sd , time_t *t ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 857
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_GetSysDateTime");
#line 858
  pi_reset_errors(sd);
#line 860
  req = dlp_request_new((enum dlpFunctions )19, 0);
  }
#line 861
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 862
    tmp = pi_set_error(sd, -500);
    }
#line 862
    return (tmp);
  }
  {
#line 864
  result = dlp_exec(sd, req, & res);
#line 866
  dlp_request_free(req);
  }
#line 868
  if (result > 0) {
    {
#line 869
    *t = dlp_ptohdate((unsigned char const   *)((*(res->argv + 0))->data + 0));
#line 871
    tmp___0 = ctime((time_t const   *)t);
#line 871
    pi_log(16, 4, "DLP GetSysDateTime %s", tmp___0);
    }
  }
  {
#line 875
  dlp_response_free(res);
  }
#line 877
  return (result);
}
}
#line 880 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_SetSysDateTime(int sd , time_t t ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp ;

  {
  {
#line 887
  pi_log(16, 4, "DLP sd=%d %s \"time=0x%08lx\"\n", sd, "dlp_SetSysDateTime", t);
#line 888
  pi_reset_errors(sd);
#line 890
  req = dlp_request_new((enum dlpFunctions )20, 1, 8);
  }
#line 891
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 892
    tmp = pi_set_error(sd, -500);
    }
#line 892
    return (tmp);
  }
  {
#line 894
  dlp_htopdate(t, (unsigned char *)((*(req->argv + 0))->data + 0));
#line 896
  result = dlp_exec(sd, req, & res);
#line 898
  dlp_request_free(req);
#line 899
  dlp_response_free(res);
  }
#line 901
  return (result);
}
}
#line 904 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ReadStorageInfo(int sd , int cardno , struct CardInfo *c ) 
{ 
  int result ;
  size_t len1 ;
  size_t len2 ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 912
  pi_log(16, 4, "DLP sd=%d %s \"cardno=%d\"\n", sd, "dlp_ReadStorageInfo", cardno);
#line 913
  pi_reset_errors(sd);
#line 915
  req = dlp_request_new((enum dlpFunctions )21, 1, 2);
  }
#line 916
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 917
    tmp = pi_set_error(sd, -500);
    }
#line 917
    return (tmp);
  }
  {
#line 919
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )cardno;
#line 920
  *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char)0;
#line 922
  result = dlp_exec(sd, req, & res);
#line 924
  dlp_request_free(req);
  }
#line 926
  if (result > 0) {
#line 927
    if (*((unsigned char *)((*(res->argv + 0))->data + 0) + 0)) {
#line 927
      tmp___0 = 1;
    } else
#line 927
    if ((int )*((unsigned char *)((*(res->argv + 0))->data + 3) + 0) > 1) {
#line 927
      tmp___0 = 1;
    } else {
#line 927
      tmp___0 = 0;
    }
    {
#line 927
    c->more = tmp___0;
#line 929
    c->card = (int )*((unsigned char *)((*(res->argv + 0))->data + 5) + 0);
#line 930
    c->version = (int )*((unsigned char *)((*(res->argv + 0))->data + 6) + 0);
#line 931
    c->creation = dlp_ptohdate((unsigned char const   *)((*(res->argv + 0))->data + 8));
#line 932
    c->romSize = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 16) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 16) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 16) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 16) + 3);
#line 933
    c->ramSize = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 20) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 20) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 20) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 20) + 3);
#line 934
    c->ramFree = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 24) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 24) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 24) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 24) + 3);
#line 936
    len1 = (size_t )*((unsigned char *)((*(res->argv + 0))->data + 28) + 0);
#line 937
    memcpy((void */* __restrict  */)(c->name), (void const   */* __restrict  */)((*(res->argv + 0))->data + 30),
           len1);
#line 938
    c->name[len1] = (char )'\000';
#line 940
    len2 = (size_t )*((unsigned char *)((*(res->argv + 0))->data + 29) + 0);
#line 941
    memcpy((void */* __restrict  */)(c->manufacturer), (void const   */* __restrict  */)((*(res->argv + 0))->data + (30UL + len1)),
           len2);
#line 943
    c->manufacturer[len2] = (char )'\000';
#line 945
    tmp___1 = ctime((time_t const   *)(& c->creation));
#line 945
    pi_log(16, 4, "DLP Read Cardno: %d, Card Version: %d, Creation time: %s", c->card,
           c->version, tmp___1);
#line 948
    pi_log(16, 4, "  Total ROM: %lu, Total RAM: %lu, Free RAM: %lu\n", c->romSize,
           c->ramSize, c->ramFree);
#line 951
    pi_log(16, 4, "  Card name: \'%s\'\n", c->name);
#line 953
    pi_log(16, 4, "  Manufacturer name: \'%s\'\n", c->manufacturer);
    }
#line 955
    if (c->more) {
#line 955
      tmp___2 = "Yes";
    } else {
#line 955
      tmp___2 = "No";
    }
    {
#line 955
    pi_log(16, 4, "  More: %s\n", tmp___2);
    }
  }
  {
#line 959
  dlp_response_free(res);
  }
#line 961
  return (result);
}
}
#line 964 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ReadSysInfo(int sd , struct SysInfo *s ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp ;
  pi_socket_t *ps ;
  pi_socket_t *tmp___0 ;

  {
  {
#line 971
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_ReadSysInfo");
#line 972
  pi_reset_errors(sd);
#line 974
  req = dlp_request_new((enum dlpFunctions )18, 1, 4);
  }
#line 975
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 976
    tmp = pi_set_error(sd, -500);
    }
#line 976
    return (tmp);
  }
  {
#line 978
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )(((int )((unsigned short )dlp_version_major) >> 8) & 255);
#line 978
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((int )((unsigned short )dlp_version_major) & 255);
#line 979
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )(((int )((unsigned short )dlp_version_minor) >> 8) & 255);
#line 979
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((int )((unsigned short )dlp_version_minor) & 255);
#line 981
  result = dlp_exec(sd, req, & res);
#line 983
  dlp_request_free(req);
  }
#line 985
  if (result > 0) {
    {
#line 986
    s->romVersion = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3);
#line 987
    s->locale = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 4) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 4) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 4) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 4) + 3);
#line 989
    s->prodIDLength = *((unsigned char *)((*(res->argv + 0))->data + 9) + 0);
#line 990
    memcpy((void */* __restrict  */)(s->prodID), (void const   */* __restrict  */)((*(res->argv + 0))->data + 10),
           (size_t )s->prodIDLength);
    }
#line 993
    if (res->argc > 1) {
      {
#line 995
      tmp___0 = find_pi_socket(sd);
#line 995
      ps = tmp___0;
#line 997
      s->dlpMajorVersion = (unsigned short )(((int )*((unsigned char *)((*(res->argv + 1))->data + 0) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 1))->data + 0) + 1));
#line 999
      s->dlpMinorVersion = (unsigned short )(((int )*((unsigned char *)((*(res->argv + 1))->data + 2) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 1))->data + 2) + 1));
#line 1001
      s->compatMajorVersion = (unsigned short )(((int )*((unsigned char *)((*(res->argv + 1))->data + 4) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 1))->data + 4) + 1));
#line 1003
      s->compatMinorVersion = (unsigned short )(((int )*((unsigned char *)((*(res->argv + 1))->data + 6) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 1))->data + 6) + 1));
#line 1005
      s->maxRecSize = ((((unsigned long )*((unsigned char *)((*(res->argv + 1))->data + 8) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 1))->data + 8) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 1))->data + 8) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 1))->data + 8) + 3);
#line 1009
      ps->dlpversion = ((int )s->dlpMajorVersion << 8) | (int )s->dlpMinorVersion;
#line 1010
      ps->maxrecsize = s->maxRecSize;
      }
    } else {
#line 1012
      s->dlpMajorVersion = (unsigned short)0;
#line 1013
      s->dlpMinorVersion = (unsigned short)0;
#line 1014
      s->compatMajorVersion = (unsigned short)0;
#line 1015
      s->compatMinorVersion = (unsigned short)0;
#line 1016
      s->maxRecSize = 0UL;
    }
    {
#line 1019
    pi_log(16, 4, "DLP ReadSysInfo ROM Ver=0x%8.8lX Locale=0x%8.8lX\n", s->romVersion,
           s->locale);
#line 1022
    pi_log(16, 4, "  Product ID=0x%8.8lX\n", s->prodID);
#line 1024
    pi_log(16, 4, "  DLP Major Ver=0x%4.4lX DLP Minor Ver=0x%4.4lX\n", (int )s->dlpMajorVersion,
           (int )s->dlpMinorVersion);
#line 1027
    pi_log(16, 4, "  Compat Major Ver=0x%4.4lX Compat Minor Vers=0x%4.4lX\n", (int )s->compatMajorVersion,
           (int )s->compatMinorVersion);
#line 1030
    pi_log(16, 4, "  Max Rec Size=%ld\n", s->maxRecSize);
    }
  }
  {
#line 1034
  dlp_response_free(res);
  }
#line 1036
  return (result);
}
}
#line 1039 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ReadDBList(int sd , int cardno , int flags , int start , pi_buffer_t *info ) 
{ 
  int result ;
  int i ;
  int count ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  unsigned char *p ;
  struct DBInfo db ;
  int tmp ;
  PI_ERR tmp___0 ;
  PI_ERR tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  pi_buffer_t *tmp___18 ;

  {
  {
#line 1050
  pi_log(16, 4, "DLP sd=%d %s \"cardno=%d flags=0x%04x start=%d\"\n", sd, "dlp_ReadDBList",
         cardno, flags, start);
#line 1051
  pi_reset_errors(sd);
#line 1053
  req = dlp_request_new((enum dlpFunctions )22, 1, 4);
  }
#line 1054
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 1055
    tmp = pi_set_error(sd, -500);
    }
#line 1055
    return (tmp);
  }
  {
#line 1057
  pi_buffer_clear(info);
#line 1060
  tmp___0 = pi_version(sd);
  }
#line 1060
  if (tmp___0 < 258) {
#line 1061
    flags &= -33;
  }
  {
#line 1063
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )flags;
#line 1064
  *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char )cardno;
#line 1065
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )(((int )((unsigned short )start) >> 8) & 255);
#line 1065
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((int )((unsigned short )start) & 255);
#line 1067
  result = dlp_exec(sd, req, & res);
#line 1069
  dlp_request_free(req);
  }
#line 1071
  if (result > 0) {
#line 1072
    p = (unsigned char *)((*(res->argv + 0))->data + 0);
#line 1073
    db.more = (int )*((p + 2) + 0);
#line 1074
    count = (int )*((p + 3) + 0);
#line 1076
    i = 0;
    {
#line 1076
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1076
      if (! (i < count)) {
#line 1076
        goto while_break;
      }
      {
#line 1078
      tmp___1 = pi_version(sd);
      }
#line 1078
      if (tmp___1 > 256) {
#line 1079
        db.miscFlags = (unsigned int )*((p + 5) + 0);
      } else {
#line 1081
        db.miscFlags = 0U;
      }
      {
#line 1083
      db.flags = (unsigned int )((unsigned short )(((int )*((p + 6) + 0) << 8) | (int )*((p + 6) + 1)));
#line 1084
      db.type = ((((unsigned long )*((p + 8) + 0) << 24) | ((unsigned long )*((p + 8) + 1) << 16)) | ((unsigned long )*((p + 8) + 2) << 8)) | (unsigned long )*((p + 8) + 3);
#line 1085
      db.creator = ((((unsigned long )*((p + 12) + 0) << 24) | ((unsigned long )*((p + 12) + 1) << 16)) | ((unsigned long )*((p + 12) + 2) << 8)) | (unsigned long )*((p + 12) + 3);
#line 1086
      db.version = (unsigned int )((unsigned short )(((int )*((p + 16) + 0) << 8) | (int )*((p + 16) + 1)));
#line 1087
      db.modnum = ((((unsigned long )*((p + 18) + 0) << 24) | ((unsigned long )*((p + 18) + 1) << 16)) | ((unsigned long )*((p + 18) + 2) << 8)) | (unsigned long )*((p + 18) + 3);
#line 1088
      db.createDate = dlp_ptohdate((unsigned char const   *)(p + 22));
#line 1089
      db.modifyDate = dlp_ptohdate((unsigned char const   *)(p + 30));
#line 1090
      db.backupDate = dlp_ptohdate((unsigned char const   *)(p + 38));
#line 1091
      db.index = (unsigned int )((unsigned short )(((int )*((p + 46) + 0) << 8) | (int )*((p + 46) + 1)));
#line 1093
      memset((void *)(db.name), 0, sizeof(db.name));
#line 1094
      strncpy((char */* __restrict  */)(db.name), (char const   */* __restrict  */)((char *)(p + 48)),
              (size_t )32);
      }
#line 1096
      if (db.more) {
#line 1096
        tmp___2 = "Yes";
      } else {
#line 1096
        tmp___2 = "No";
      }
      {
#line 1096
      pi_log(16, 4, "DLP ReadDBList Name: \'%s\', Version: %d, More: %s\n", db.name,
             db.version, tmp___2);
#line 1099
      tmp___3 = printlong(db.creator);
#line 1099
      pi_log(16, 4, "  Creator: \'%s\'", tmp___3);
      }
#line 1101
      if (! db.flags) {
#line 1101
        tmp___4 = "None";
      } else {
#line 1101
        tmp___4 = "";
      }
#line 1101
      if (db.flags & 32768U) {
#line 1101
        tmp___5 = "Open ";
      } else {
#line 1101
        tmp___5 = "";
      }
#line 1101
      if (db.flags & 128U) {
#line 1101
        tmp___6 = "Stream ";
      } else {
#line 1101
        tmp___6 = "";
      }
#line 1101
      if (db.flags & 64U) {
#line 1101
        tmp___7 = "CopyPrevention ";
      } else {
#line 1101
        tmp___7 = "";
      }
#line 1101
      if (db.flags & 16U) {
#line 1101
        tmp___8 = "Newer ";
      } else {
#line 1101
        tmp___8 = "";
      }
#line 1101
      if (db.flags & 32U) {
#line 1101
        tmp___9 = "Reset ";
      } else {
#line 1101
        tmp___9 = "";
      }
#line 1101
      if (db.flags & 8U) {
#line 1101
        tmp___10 = "Backup ";
      } else {
#line 1101
        tmp___10 = "";
      }
#line 1101
      if (db.flags & 4U) {
#line 1101
        tmp___11 = "AppInfoDirty ";
      } else {
#line 1101
        tmp___11 = "";
      }
#line 1101
      if (db.flags & 2U) {
#line 1101
        tmp___12 = "ReadOnly ";
      } else {
#line 1101
        tmp___12 = "";
      }
#line 1101
      if (db.flags & 1U) {
#line 1101
        tmp___13 = "Resource ";
      } else {
#line 1101
        tmp___13 = "";
      }
      {
#line 1101
      tmp___14 = printlong(db.type);
#line 1101
      pi_log(16, 4, " Type: \'%s\' Flags: %s%s%s%s%s%s%s%s%s%s", tmp___14, tmp___13,
             tmp___12, tmp___11, tmp___10, tmp___9, tmp___8, tmp___7, tmp___6, tmp___5,
             tmp___4);
#line 1116
      pi_log(16, 4, " (0x%2.2X)\n", db.flags);
#line 1117
      tmp___15 = ctime((time_t const   *)(& db.createDate));
#line 1117
      pi_log(16, 4, "  Modnum: %ld, Index: %d, Creation date: 0x%08lx, %s", db.modnum,
             db.index, db.createDate, tmp___15);
#line 1120
      tmp___16 = ctime((time_t const   *)(& db.modifyDate));
#line 1120
      pi_log(16, 4, " Modification date: 0x%08lx, %s", db.modifyDate, tmp___16);
#line 1122
      tmp___17 = ctime((time_t const   *)(& db.backupDate));
#line 1122
      pi_log(16, 4, " Backup date: 0x%08lx, %s", db.backupDate, tmp___17);
#line 1125
      tmp___18 = pi_buffer_append(info, (void const   *)(& db), sizeof(db));
      }
#line 1125
      if ((unsigned long )tmp___18 == (unsigned long )((void *)0)) {
        {
#line 1126
        result = pi_set_error(sd, -500);
        }
#line 1127
        goto while_break;
      }
#line 1130
      p += (int )*((p + 4) + 0);
#line 1076
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1133
    pi_log(16, 4, "Error in dlp_ReadDBList: %d\n", result);
    }
  }
  {
#line 1137
  dlp_response_free(res);
  }
#line 1139
  return (result);
}
}
#line 1142 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_FindDBInfo(int sd , int cardno , int start , char const   *dbname , unsigned long type ,
                   unsigned long creator , struct DBInfo *info ) 
{ 
  int i ;
  int j ;
  pi_buffer_t *buf___3 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1151
  pi_log(16, 4, "DLP sd=%d %s \"cardno=%d start=%d\"\n", sd, "dlp_FindDBInfo", cardno,
         start);
#line 1152
  pi_reset_errors(sd);
#line 1154
  buf___3 = pi_buffer_new(sizeof(struct DBInfo ));
  }
#line 1155
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
    {
#line 1156
    tmp = pi_set_error(sd, -500);
    }
#line 1156
    return (tmp);
  }
#line 1158
  if (start < 4096) {
#line 1159
    i = start;
    {
#line 1160
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1160
      tmp___1 = dlp_ReadDBList(sd, cardno, 160, i, buf___3);
      }
#line 1160
      if (! (tmp___1 >= 0)) {
#line 1160
        goto while_break;
      }
#line 1161
      j = 0;
      {
#line 1161
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1161
        if (! (j < (int )(buf___3->used / sizeof(struct DBInfo )))) {
#line 1161
          goto while_break___0;
        }
        {
#line 1162
        memcpy((void */* __restrict  */)info, (void const   */* __restrict  */)(buf___3->data + (unsigned long )j * sizeof(struct DBInfo )),
               sizeof(struct DBInfo ));
        }
#line 1163
        if (! dbname) {
#line 1163
          goto _L___0;
        } else {
          {
#line 1163
          tmp___0 = strcmp((char const   *)(info->name), dbname);
          }
#line 1163
          if (tmp___0 == 0) {
            _L___0: /* CIL Label */ 
#line 1163
            if (! type) {
#line 1163
              goto _L;
            } else
#line 1163
            if (info->type == type) {
              _L: /* CIL Label */ 
#line 1163
              if (! creator) {
#line 1166
                goto found;
              } else
#line 1163
              if (info->creator == creator) {
#line 1166
                goto found;
              }
            }
          }
        }
#line 1167
        i = (int )(info->index + 1U);
#line 1161
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1170
    start = 4096;
  }
#line 1173
  i = start & 4095;
  {
#line 1174
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1174
    tmp___3 = dlp_ReadDBList(sd, cardno, 96, i, buf___3);
    }
#line 1174
    if (! (tmp___3 >= 0)) {
#line 1174
      goto while_break___1;
    }
#line 1175
    j = 0;
    {
#line 1175
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1175
      if (! (j < (int )(buf___3->used / sizeof(struct DBInfo )))) {
#line 1175
        goto while_break___2;
      }
      {
#line 1176
      memcpy((void */* __restrict  */)info, (void const   */* __restrict  */)(buf___3->data + (unsigned long )j * sizeof(struct DBInfo )),
             sizeof(struct DBInfo ));
      }
#line 1177
      if (! dbname) {
#line 1177
        goto _L___2;
      } else {
        {
#line 1177
        tmp___2 = strcmp((char const   *)(info->name), dbname);
        }
#line 1177
        if (tmp___2 == 0) {
          _L___2: /* CIL Label */ 
#line 1177
          if (! type) {
#line 1177
            goto _L___1;
          } else
#line 1177
          if (info->type == type) {
            _L___1: /* CIL Label */ 
#line 1177
            if (! creator) {
#line 1181
              info->index |= 4096U;
#line 1182
              goto found;
            } else
#line 1177
            if (info->creator == creator) {
#line 1181
              info->index |= 4096U;
#line 1182
              goto found;
            }
          }
        }
      }
#line 1184
      i = (int )(info->index + 1U);
#line 1175
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1188
  pi_buffer_free(buf___3);
  }
#line 1189
  return (-1);
  found: 
  {
#line 1192
  pi_buffer_free(buf___3);
  }
#line 1193
  return (0);
}
}
#line 1207 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
static void dlp_decode_finddb_response(struct dlpResponse *res , int *cardno , unsigned long *localid ,
                                       int *dbhandle , struct DBInfo *info , struct DBSizeInfo *size ) 
{ 
  int arg ;
  int argid ;
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
#line 1212
  arg = 0;
  {
#line 1212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1212
    if (! (arg < res->argc)) {
#line 1212
      goto while_break;
    }
#line 1213
    argid = ((*(res->argv + arg))->id_ & 127) - 32;
#line 1214
    if (argid == 0) {
#line 1215
      if (cardno) {
#line 1216
        *cardno = (int )*((unsigned char *)((*(res->argv + arg))->data + 0) + 0);
      }
#line 1217
      if (localid) {
#line 1218
        *localid = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 2) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 2) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 2) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 2) + 3);
      }
#line 1219
      if (dbhandle) {
#line 1220
        *dbhandle = (int )(((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 6) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 6) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 6) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 6) + 3));
      }
#line 1222
      if (info) {
        {
#line 1223
        info->more = 0;
#line 1224
        info->miscFlags = (unsigned int )*((unsigned char *)((*(res->argv + arg))->data + 11) + 0);
#line 1226
        info->flags = (unsigned int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + arg))->data + 12) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + arg))->data + 12) + 1)));
#line 1228
        info->type = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 14) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 14) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 14) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 14) + 3);
#line 1230
        info->creator = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 18) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 18) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 18) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 18) + 3);
#line 1232
        info->version = (unsigned int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + arg))->data + 22) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + arg))->data + 22) + 1)));
#line 1234
        info->modnum = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 24) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 24) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 24) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 24) + 3);
#line 1236
        info->createDate = dlp_ptohdate((unsigned char const   *)((*(res->argv + arg))->data + 28));
#line 1238
        info->modifyDate = dlp_ptohdate((unsigned char const   *)((*(res->argv + arg))->data + 36));
#line 1240
        info->backupDate = dlp_ptohdate((unsigned char const   *)((*(res->argv + arg))->data + 44));
#line 1242
        info->index = (unsigned int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + arg))->data + 52) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + arg))->data + 52) + 1)));
#line 1245
        strncpy((char */* __restrict  */)(info->name), (char const   */* __restrict  */)((*(res->argv + arg))->data + 54),
                (size_t )32);
#line 1246
        info->name[32] = (char )'\000';
        }
#line 1248
        if (info->more) {
#line 1248
          tmp = "Yes";
        } else {
#line 1248
          tmp = "No";
        }
        {
#line 1248
        pi_log(16, 4, "DLP FindDB Name: \'%s\', Version: %d, More: %s\n", info->name,
               info->version, tmp);
#line 1253
        tmp___0 = printlong(info->creator);
#line 1253
        pi_log(16, 4, "  Creator: \'%s\'", tmp___0);
        }
#line 1255
        if (! info->flags) {
#line 1255
          tmp___1 = "None";
        } else {
#line 1255
          tmp___1 = "";
        }
#line 1255
        if (info->flags & 32768U) {
#line 1255
          tmp___2 = "Open ";
        } else {
#line 1255
          tmp___2 = "";
        }
#line 1255
        if (info->flags & 128U) {
#line 1255
          tmp___3 = "Stream ";
        } else {
#line 1255
          tmp___3 = "";
        }
#line 1255
        if (info->flags & 64U) {
#line 1255
          tmp___4 = "CopyPrevention ";
        } else {
#line 1255
          tmp___4 = "";
        }
#line 1255
        if (info->flags & 16U) {
#line 1255
          tmp___5 = "Newer ";
        } else {
#line 1255
          tmp___5 = "";
        }
#line 1255
        if (info->flags & 32U) {
#line 1255
          tmp___6 = "Reset ";
        } else {
#line 1255
          tmp___6 = "";
        }
#line 1255
        if (info->flags & 8U) {
#line 1255
          tmp___7 = "Backup ";
        } else {
#line 1255
          tmp___7 = "";
        }
#line 1255
        if (info->flags & 4U) {
#line 1255
          tmp___8 = "AppInfoDirty ";
        } else {
#line 1255
          tmp___8 = "";
        }
#line 1255
        if (info->flags & 2U) {
#line 1255
          tmp___9 = "ReadOnly ";
        } else {
#line 1255
          tmp___9 = "";
        }
#line 1255
        if (info->flags & 1U) {
#line 1255
          tmp___10 = "Resource ";
        } else {
#line 1255
          tmp___10 = "";
        }
        {
#line 1255
        tmp___11 = printlong(info->type);
#line 1255
        pi_log(16, 4, " Type: \'%s\' Flags: %s%s%s%s%s%s%s%s%s%s", tmp___11, tmp___10,
               tmp___9, tmp___8, tmp___7, tmp___6, tmp___5, tmp___4, tmp___3, tmp___2,
               tmp___1);
#line 1277
        pi_log(16, 4, " (0x%2.2X)\n", info->flags);
#line 1279
        tmp___12 = ctime((time_t const   *)(& info->createDate));
#line 1279
        pi_log(16, 4, "  Modnum: %ld, Index: %d, Creation date: %s", info->modnum,
               info->index, tmp___12);
#line 1284
        tmp___13 = ctime((time_t const   *)(& info->modifyDate));
#line 1284
        pi_log(16, 4, " Modification date: %s", tmp___13);
#line 1287
        tmp___14 = ctime((time_t const   *)(& info->backupDate));
#line 1287
        pi_log(16, 4, " Backup date: %s", tmp___14);
        }
      }
    } else
#line 1292
    if (argid == 1) {
#line 1293
      if (size) {
#line 1294
        size->numRecords = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 0) + 3);
#line 1296
        size->totalBytes = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 4) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 4) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 4) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 4) + 3);
#line 1298
        size->dataBytes = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 8) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 8) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 8) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 8) + 3);
#line 1300
        size->appBlockSize = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 12) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 12) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 12) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 12) + 3);
#line 1302
        size->sortBlockSize = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 16) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 16) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 16) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 16) + 3);
#line 1304
        size->maxRecSize = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 20) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 20) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 20) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 20) + 3);
      }
    }
#line 1212
    arg ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1309
  return;
}
}
#line 1311 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_FindDBByName(int sd , int cardno , char const   *name , unsigned long *localid ,
                     int *dbhandle , struct DBInfo *info , struct DBSizeInfo *size ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int flags ;
  int tmp ;
  PI_ERR tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1318
  flags = 0;
#line 1320
  pi_log(16, 4, "DLP sd=%d %s \"cardno=%d name=\'%s\'\"\n", sd, "dlp_FindDBByName",
         cardno, name);
#line 1321
  pi_reset_errors(sd);
#line 1323
  tmp___0 = pi_version(sd);
  }
#line 1323
  if (tmp___0 < 258) {
    {
#line 1324
    tmp = pi_set_error(sd, -302);
    }
#line 1324
    return (tmp);
  }
  {
#line 1326
  tmp___1 = strlen(name);
#line 1326
  req = dlp_request_new((enum dlpFunctions )57, 1, 2UL + (tmp___1 + 1UL));
  }
#line 1327
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 1328
    tmp___2 = pi_set_error(sd, -500);
    }
#line 1328
    return (tmp___2);
  }
#line 1330
  if (localid) {
#line 1331
    flags |= 128;
  } else
#line 1330
  if (dbhandle) {
#line 1331
    flags |= 128;
  } else
#line 1330
  if (info) {
#line 1331
    flags |= 128;
  }
#line 1332
  if (size) {
#line 1333
    flags |= 64;
  }
  {
#line 1335
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )flags;
#line 1336
  *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char )cardno;
#line 1337
  strcpy((char */* __restrict  */)((*(req->argv + 0))->data + 2), (char const   */* __restrict  */)name);
#line 1339
  result = dlp_exec(sd, req, & res);
#line 1341
  dlp_request_free(req);
  }
#line 1343
  if (result > 0) {
    {
#line 1344
    dlp_decode_finddb_response(res, (int *)((void *)0), localid, dbhandle, info, size);
    }
  }
  {
#line 1346
  dlp_response_free(res);
  }
#line 1348
  return (result);
}
}
#line 1351 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_FindDBByOpenHandle(int sd , int dbhandle , int *cardno , unsigned long *localid ,
                           struct DBInfo *info , struct DBSizeInfo *size ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int flags ;
  int tmp ;
  PI_ERR tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1358
  flags = 0;
#line 1360
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_FindDBByOpenHandle");
#line 1361
  pi_reset_errors(sd);
#line 1363
  tmp___0 = pi_version(sd);
  }
#line 1363
  if (tmp___0 < 258) {
    {
#line 1364
    tmp = pi_set_error(sd, -302);
    }
#line 1364
    return (tmp);
  }
  {
#line 1366
  req = dlp_request_new_with_argid((enum dlpFunctions )57, 33, 1, 2);
  }
#line 1367
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 1368
    tmp___1 = pi_set_error(sd, -500);
    }
#line 1368
    return (tmp___1);
  }
#line 1374
  if (cardno) {
#line 1375
    flags |= 128;
  } else
#line 1374
  if (localid) {
#line 1375
    flags |= 128;
  } else
#line 1374
  if (info) {
#line 1375
    flags |= 128;
  }
#line 1376
  if (size) {
#line 1377
    flags |= 64;
  }
  {
#line 1379
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )flags;
#line 1380
  *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char )dbhandle;
#line 1382
  result = dlp_exec(sd, req, & res);
#line 1384
  dlp_request_free(req);
  }
#line 1386
  if (result > 0) {
    {
#line 1387
    dlp_decode_finddb_response(res, cardno, localid, (int *)((void *)0), info, size);
    }
  }
  {
#line 1389
  dlp_response_free(res);
  }
#line 1391
  return (result);
}
}
#line 1394 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_FindDBByTypeCreator(int sd , unsigned long type , unsigned long creator ,
                            int start , int latest , int *cardno , unsigned long *localid ,
                            int *dbhandle , struct DBInfo *info , struct DBSizeInfo *size ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int flags ;
  int search_flags ;
  int tmp ;
  PI_ERR tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1402
  flags = 0;
#line 1402
  search_flags = 0;
#line 1404
  pi_log(16, 4, "DLP sd=%d %s \"type=\'%4.4s\' creator=\'%4.4s\' start=%d latest=%d\"\n",
         sd, "dlp_FindDBByTypeCreator", (char const   *)(& type), (char const   *)(& creator),
         start, latest);
#line 1406
  pi_reset_errors(sd);
#line 1408
  tmp___0 = pi_version(sd);
  }
#line 1408
  if (tmp___0 < 258) {
    {
#line 1409
    tmp = pi_set_error(sd, -302);
    }
#line 1409
    return (tmp);
  }
  {
#line 1411
  req = dlp_request_new_with_argid((enum dlpFunctions )57, 34, 1, 10);
  }
#line 1412
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 1413
    tmp___1 = pi_set_error(sd, -500);
    }
#line 1413
    return (tmp___1);
  }
#line 1415
  if (cardno) {
#line 1416
    flags |= 128;
  } else
#line 1415
  if (localid) {
#line 1416
    flags |= 128;
  } else
#line 1415
  if (dbhandle) {
#line 1416
    flags |= 128;
  } else
#line 1415
  if (info) {
#line 1416
    flags |= 128;
  }
#line 1417
  if (size) {
#line 1418
    flags |= 96;
  }
#line 1421
  if (start) {
#line 1422
    search_flags |= 128;
  }
#line 1423
  if (latest) {
#line 1424
    search_flags |= 64;
  }
  {
#line 1427
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )flags;
#line 1428
  *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char )search_flags;
#line 1429
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )((int )((unsigned char )(type >> 24)) & 255);
#line 1429
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((type >> 16) & 255UL);
#line 1429
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 2) = (unsigned char )((type >> 8) & 255UL);
#line 1429
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 3) = (unsigned char )(type & 255UL);
#line 1430
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 0) = (unsigned char )((int )((unsigned char )(creator >> 24)) & 255);
#line 1430
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 1) = (unsigned char )((creator >> 16) & 255UL);
#line 1430
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 2) = (unsigned char )((creator >> 8) & 255UL);
#line 1430
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 3) = (unsigned char )(creator & 255UL);
#line 1432
  result = dlp_exec(sd, req, & res);
#line 1434
  dlp_request_free(req);
  }
#line 1436
  if (result > 0) {
    {
#line 1437
    dlp_decode_finddb_response(res, cardno, localid, dbhandle, info, size);
    }
  }
  {
#line 1439
  dlp_response_free(res);
  }
#line 1441
  return (result);
}
}
#line 1444 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_OpenDB(int sd , int cardno , int mode , char const   *name , int *dbhandle ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1451
  pi_log(16, 4, "DLP sd=%d %s \"\'%s\'\"\n", sd, "dlp_OpenDB", name);
#line 1452
  pi_reset_errors(sd);
#line 1454
  tmp = strlen(name);
#line 1454
  req = dlp_request_new((enum dlpFunctions )23, 1, (2UL + tmp) + 1UL);
  }
#line 1455
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 1456
    tmp___0 = pi_set_error(sd, -500);
    }
#line 1456
    return (tmp___0);
  }
  {
#line 1458
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )cardno;
#line 1459
  *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char )mode;
#line 1460
  strcpy((char */* __restrict  */)((*(req->argv + 0))->data + 2), (char const   */* __restrict  */)name);
#line 1462
  result = dlp_exec(sd, req, & res);
#line 1464
  dlp_request_free(req);
  }
#line 1466
  if (result > 0) {
    {
#line 1467
    *dbhandle = (int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0);
#line 1469
    pi_log(16, 4, "-> dlp_OpenDB dbhandle=%d\n", *dbhandle);
    }
  }
  {
#line 1473
  dlp_response_free(res);
  }
#line 1475
  return (result);
}
}
#line 1478 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_DeleteDB(int sd , int card , char const   *name ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1485
  pi_log(16, 4, "DLP sd=%d %s \"%s\"\n", sd, "dlp_DeleteDB", name);
#line 1486
  pi_reset_errors(sd);
#line 1488
  tmp = strlen(name);
#line 1488
  req = dlp_request_new((enum dlpFunctions )26, 1, 2UL + (tmp + 1UL));
  }
#line 1489
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 1490
    tmp___0 = pi_set_error(sd, -500);
    }
#line 1490
    return (tmp___0);
  }
  {
#line 1492
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )card;
#line 1493
  *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char)0;
#line 1494
  strcpy((char */* __restrict  */)((*(req->argv + 0))->data + 2), (char const   */* __restrict  */)name);
#line 1496
  result = dlp_exec(sd, req, & res);
#line 1498
  dlp_request_free(req);
#line 1499
  dlp_response_free(res);
  }
#line 1501
  return (result);
}
}
#line 1504 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_CreateDB(int sd , unsigned long creator , unsigned long type , int cardno ,
                 int flags , unsigned int version , char const   *name , int *dbhandle ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1512
  pi_log(16, 4, "DLP sd=%d %s \"\'%s\' type=\'%4.4s\' creator=\'%4.4s\' flags=0x%04x version=%d\"\n",
         sd, "dlp_CreateDB", name, (char const   *)(& type), (char const   *)(& creator),
         flags, version);
#line 1514
  pi_reset_errors(sd);
#line 1516
  tmp = strlen(name);
#line 1516
  req = dlp_request_new((enum dlpFunctions )24, 1, 14UL + (tmp + 1UL));
  }
#line 1517
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 1518
    tmp___0 = pi_set_error(sd, -500);
    }
#line 1518
    return (tmp___0);
  }
  {
#line 1520
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )((int )((unsigned char )(creator >> 24)) & 255);
#line 1520
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((creator >> 16) & 255UL);
#line 1520
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 2) = (unsigned char )((creator >> 8) & 255UL);
#line 1520
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 3) = (unsigned char )(creator & 255UL);
#line 1521
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char )((int )((unsigned char )(type >> 24)) & 255);
#line 1521
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char )((type >> 16) & 255UL);
#line 1521
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 2) = (unsigned char )((type >> 8) & 255UL);
#line 1521
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 3) = (unsigned char )(type & 255UL);
#line 1522
  *((unsigned char *)((*(req->argv + 0))->data + 8) + 0) = (unsigned char )cardno;
#line 1523
  *((unsigned char *)((*(req->argv + 0))->data + 9) + 0) = (unsigned char)0;
#line 1524
  *((unsigned char *)((*(req->argv + 0))->data + 10) + 0) = (unsigned char )(((int )((unsigned short )flags) >> 8) & 255);
#line 1524
  *((unsigned char *)((*(req->argv + 0))->data + 10) + 1) = (unsigned char )((int )((unsigned short )flags) & 255);
#line 1525
  *((unsigned char *)((*(req->argv + 0))->data + 12) + 0) = (unsigned char )(((int )((unsigned short )version) >> 8) & 255);
#line 1525
  *((unsigned char *)((*(req->argv + 0))->data + 12) + 1) = (unsigned char )((int )((unsigned short )version) & 255);
#line 1526
  strcpy((char */* __restrict  */)((*(req->argv + 0))->data + 14), (char const   */* __restrict  */)name);
#line 1528
  result = dlp_exec(sd, req, & res);
#line 1530
  dlp_request_free(req);
  }
#line 1532
  if (result > 0) {
#line 1532
    if (dbhandle) {
      {
#line 1533
      *dbhandle = (int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0);
#line 1535
      pi_log(16, 4, "DLP CreateDB Handle=%d\n", *dbhandle);
      }
    }
  }
  {
#line 1539
  dlp_response_free(res);
  }
#line 1541
  return (result);
}
}
#line 1544 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_CloseDB(int sd , int dbhandle ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp ;

  {
  {
#line 1551
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_CloseDB");
#line 1552
  pi_reset_errors(sd);
#line 1554
  req = dlp_request_new((enum dlpFunctions )25, 1, 1);
  }
#line 1555
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 1556
    tmp = pi_set_error(sd, -500);
    }
#line 1556
    return (tmp);
  }
  {
#line 1558
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 1560
  result = dlp_exec(sd, req, & res);
#line 1562
  dlp_request_free(req);
#line 1563
  dlp_response_free(res);
  }
#line 1565
  return (result);
}
}
#line 1568 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_CloseDB_All(int sd ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp ;

  {
  {
#line 1575
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_CloseDB_All");
#line 1576
  pi_reset_errors(sd);
#line 1578
  req = dlp_request_new_with_argid((enum dlpFunctions )25, 33, 0);
  }
#line 1579
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 1580
    tmp = pi_set_error(sd, -500);
    }
#line 1580
    return (tmp);
  }
  {
#line 1582
  result = dlp_exec(sd, req, & res);
#line 1584
  dlp_request_free(req);
#line 1585
  dlp_response_free(res);
  }
#line 1587
  return (result);
}
}
#line 1590 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_CallApplication(int sd , unsigned long creator , unsigned long type , int action ,
                        size_t length , void const   *data , unsigned long *retcode ,
                        pi_buffer_t *retbuf ) 
{ 
  int result ;
  int version ;
  PI_ERR tmp ;
  int previous_honor_rx_timeout ;
  int no_rx_timeout ;
  size_t data_len ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1595
  tmp = pi_version(sd);
#line 1595
  version = tmp;
#line 1595
  no_rx_timeout = 0;
#line 1603
  pi_log(16, 4, "DLP sd=%d %s \"type=\'%4.4s\' creator=\'%4.4s\' action=0x%04x dataLength=%d\"\n",
         sd, "dlp_CallApplication", (char const   *)(& type), (char const   *)(& creator),
         action, (int )length);
#line 1605
  pi_reset_errors(sd);
  }
#line 1606
  if (retbuf) {
    {
#line 1607
    pi_buffer_clear(retbuf);
    }
  }
  {
#line 1613
  data_len = sizeof(previous_honor_rx_timeout);
#line 1614
  pi_getsockopt(sd, 7, 1, (void *)(& previous_honor_rx_timeout), & data_len);
  }
#line 1617
  if (version >= 257) {
#line 1619
    if (length + 22UL > 65535UL) {
      {
#line 1620
      pi_log(16, 1, "DLP CallApplication: data too large (>64k)");
#line 1622
      pi_set_error(sd, -304);
      }
#line 1623
      return (-131);
    }
    {
#line 1626
    req = dlp_request_new_with_argid((enum dlpFunctions )40, 33, 1, 22UL + length);
    }
#line 1628
    if ((unsigned long )req == (unsigned long )((void *)0)) {
      {
#line 1629
      tmp___0 = pi_set_error(sd, -500);
      }
#line 1629
      return (tmp___0);
    }
#line 1631
    *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )((int )((unsigned char )(creator >> 24)) & 255);
#line 1631
    *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((creator >> 16) & 255UL);
#line 1631
    *((unsigned char *)((*(req->argv + 0))->data + 0) + 2) = (unsigned char )((creator >> 8) & 255UL);
#line 1631
    *((unsigned char *)((*(req->argv + 0))->data + 0) + 3) = (unsigned char )(creator & 255UL);
#line 1632
    *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char )((int )((unsigned char )(type >> 24)) & 255);
#line 1632
    *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char )((type >> 16) & 255UL);
#line 1632
    *((unsigned char *)((*(req->argv + 0))->data + 4) + 2) = (unsigned char )((type >> 8) & 255UL);
#line 1632
    *((unsigned char *)((*(req->argv + 0))->data + 4) + 3) = (unsigned char )(type & 255UL);
#line 1633
    *((unsigned char *)((*(req->argv + 0))->data + 8) + 0) = (unsigned char )(((int )((unsigned short )action) >> 8) & 255);
#line 1633
    *((unsigned char *)((*(req->argv + 0))->data + 8) + 1) = (unsigned char )((int )((unsigned short )action) & 255);
#line 1634
    *((unsigned char *)((*(req->argv + 0))->data + 10) + 0) = (unsigned char )((int )((unsigned char )(length >> 24)) & 255);
#line 1634
    *((unsigned char *)((*(req->argv + 0))->data + 10) + 1) = (unsigned char )((length >> 16) & 255UL);
#line 1634
    *((unsigned char *)((*(req->argv + 0))->data + 10) + 2) = (unsigned char )((length >> 8) & 255UL);
#line 1634
    *((unsigned char *)((*(req->argv + 0))->data + 10) + 3) = (unsigned char )(length & 255UL);
#line 1635
    *((unsigned char *)((*(req->argv + 0))->data + 14) + 0) = (unsigned char)0;
#line 1635
    *((unsigned char *)((*(req->argv + 0))->data + 14) + 1) = (unsigned char)0;
#line 1635
    *((unsigned char *)((*(req->argv + 0))->data + 14) + 2) = (unsigned char)0;
#line 1635
    *((unsigned char *)((*(req->argv + 0))->data + 14) + 3) = (unsigned char)0;
#line 1636
    *((unsigned char *)((*(req->argv + 0))->data + 18) + 0) = (unsigned char)0;
#line 1636
    *((unsigned char *)((*(req->argv + 0))->data + 18) + 1) = (unsigned char)0;
#line 1636
    *((unsigned char *)((*(req->argv + 0))->data + 18) + 2) = (unsigned char)0;
#line 1636
    *((unsigned char *)((*(req->argv + 0))->data + 18) + 3) = (unsigned char)0;
#line 1637
    if (length) {
      {
#line 1638
      memcpy((void */* __restrict  */)((*(req->argv + 0))->data + 22), (void const   */* __restrict  */)data,
             length);
      }
    }
    {
#line 1640
    data_len = sizeof(no_rx_timeout);
#line 1641
    pi_setsockopt(sd, 7, 1, (void const   *)(& no_rx_timeout), & data_len);
#line 1644
    result = dlp_exec(sd, req, & res);
#line 1646
    pi_setsockopt(sd, 7, 1, (void const   *)(& previous_honor_rx_timeout), & data_len);
#line 1649
    dlp_request_free(req);
    }
#line 1651
    if (result > 0) {
#line 1652
      data_len = (*(res->argv + 0))->len - 16UL;
#line 1654
      if (retcode) {
#line 1655
        *retcode = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3);
      }
#line 1656
      if (retbuf) {
        {
#line 1657
        pi_buffer_append(retbuf, (void const   *)((*(res->argv + 0))->data + 16),
                         data_len);
        }
      }
      {
#line 1659
      pi_log(16, 4, "DLP CallApplication Result: %lu (0x%08lx), and %d bytes:\n",
             ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3),
             ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3),
             data_len);
      }
      {
#line 1665
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1665
        tmp___1 = pi_debug_get_types();
        }
#line 1665
        if (tmp___1 & 16) {
          {
#line 1665
          tmp___2 = pi_debug_get_level();
          }
#line 1665
          if (tmp___2 >= 8) {
            {
#line 1665
            pi_dumpdata((char const   *)((*(res->argv + 0))->data + 16), data_len);
            }
          }
        }
#line 1665
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
#line 1672
    if (length + 8UL > 65535UL) {
      {
#line 1673
      pi_log(16, 1, "DLP CallApplication: data too large (>64k)");
#line 1675
      pi_set_error(sd, -304);
      }
#line 1676
      return (-131);
    }
    {
#line 1679
    req = dlp_request_new((enum dlpFunctions )40, 1, 8UL + length);
    }
#line 1680
    if ((unsigned long )req == (unsigned long )((void *)0)) {
      {
#line 1681
      tmp___3 = pi_set_error(sd, -500);
      }
#line 1681
      return (tmp___3);
    }
    {
#line 1683
    *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )((int )((unsigned char )(creator >> 24)) & 255);
#line 1683
    *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((creator >> 16) & 255UL);
#line 1683
    *((unsigned char *)((*(req->argv + 0))->data + 0) + 2) = (unsigned char )((creator >> 8) & 255UL);
#line 1683
    *((unsigned char *)((*(req->argv + 0))->data + 0) + 3) = (unsigned char )(creator & 255UL);
#line 1684
    *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char )(((int )((unsigned short )action) >> 8) & 255);
#line 1684
    *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char )((int )((unsigned short )action) & 255);
#line 1685
    *((unsigned char *)((*(req->argv + 0))->data + 6) + 0) = (unsigned char )(((int )((unsigned short )length) >> 8) & 255);
#line 1685
    *((unsigned char *)((*(req->argv + 0))->data + 6) + 1) = (unsigned char )((int )((unsigned short )length) & 255);
#line 1686
    memcpy((void */* __restrict  */)((*(req->argv + 0))->data + 8), (void const   */* __restrict  */)data,
           length);
#line 1688
    data_len = sizeof(no_rx_timeout);
#line 1689
    pi_setsockopt(sd, 7, 1, (void const   *)(& no_rx_timeout), & data_len);
#line 1692
    result = dlp_exec(sd, req, & res);
#line 1694
    pi_setsockopt(sd, 7, 1, (void const   *)(& previous_honor_rx_timeout), & data_len);
#line 1697
    dlp_request_free(req);
    }
#line 1699
    if (result > 0) {
#line 1700
      data_len = (*(res->argv + 0))->len - 6UL;
#line 1701
      if (retcode) {
#line 1702
        *retcode = (unsigned long )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 2) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 2) + 1)));
      }
#line 1703
      if (retbuf) {
        {
#line 1704
        pi_buffer_append(retbuf, (void const   *)((*(res->argv + 0))->data + 6), data_len);
        }
      }
      {
#line 1706
      pi_log(16, 4, "DLP CallApplication Action: %d Result: %u (0x%04x), and %d bytes:\n",
             (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1))),
             (unsigned int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 2) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 2) + 1))),
             (unsigned int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 2) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 2) + 1))),
             data_len);
      }
      {
#line 1713
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1713
        tmp___4 = pi_debug_get_types();
        }
#line 1713
        if (tmp___4 & 16) {
          {
#line 1713
          tmp___5 = pi_debug_get_level();
          }
#line 1713
          if (tmp___5 >= 8) {
            {
#line 1713
            pi_dumpdata((char const   *)((*(res->argv + 0))->data + 6), data_len);
            }
          }
        }
#line 1713
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 1719
  dlp_response_free(res);
  }
#line 1720
  return (result);
}
}
#line 1723 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ResetSystem(int sd ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp ;

  {
  {
#line 1730
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_ResetSystem");
#line 1731
  pi_reset_errors(sd);
#line 1733
  req = dlp_request_new((enum dlpFunctions )41, 0);
#line 1735
  result = dlp_exec(sd, req, & res);
  }
#line 1736
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 1737
    tmp = pi_set_error(sd, -500);
    }
#line 1737
    return (tmp);
  }
  {
#line 1739
  dlp_request_free(req);
#line 1740
  dlp_response_free(res);
  }
#line 1742
  return (result);
}
}
#line 1745 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_AddSyncLogEntry(int sd , char *entry ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1752
  pi_log(16, 4, "DLP sd=%d %s \"%s\"\n", sd, "dlp_AddSyncLogEntry", entry);
#line 1753
  pi_reset_errors(sd);
#line 1755
  tmp = strlen((char const   *)entry);
#line 1755
  req = dlp_request_new((enum dlpFunctions )42, 1, tmp + 1UL);
  }
#line 1756
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 1757
    tmp___0 = pi_set_error(sd, -500);
    }
#line 1757
    return (tmp___0);
  }
  {
#line 1759
  strcpy((char */* __restrict  */)((*(req->argv + 0))->data + 0), (char const   */* __restrict  */)entry);
#line 1761
  result = dlp_exec(sd, req, & res);
#line 1763
  dlp_request_free(req);
#line 1764
  dlp_response_free(res);
  }
#line 1766
  if (result > 0) {
    {
#line 1767
    pi_log(16, 4, "DLP AddSyncLogEntry Entry: \n  %s\n", entry);
    }
  }
#line 1771
  return (result);
}
}
#line 1774 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ReadOpenDBInfo(int sd , int dbhandle , int *records ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp ;

  {
  {
#line 1781
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_ReadOpenDBInfo");
#line 1782
  pi_reset_errors(sd);
#line 1784
  req = dlp_request_new((enum dlpFunctions )43, 1, 1);
  }
#line 1785
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 1786
    tmp = pi_set_error(sd, -500);
    }
#line 1786
    return (tmp);
  }
  {
#line 1788
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 1790
  result = dlp_exec(sd, req, & res);
#line 1792
  dlp_request_free(req);
  }
#line 1794
  if (result > 0) {
#line 1795
    if (records) {
#line 1796
      *records = (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1)));
    }
    {
#line 1798
    pi_log(16, 4, "DLP ReadOpenDBInfo %d records\n", (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1))));
    }
  }
  {
#line 1803
  dlp_response_free(res);
  }
#line 1805
  return (result);
}
}
#line 1808 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_SetDBInfo(int sd , int dbhandle , int flags , int clearFlags , unsigned int version ,
                  time_t createDate , time_t modifyDate , time_t backupDate , unsigned long type ,
                  unsigned long creator ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp ;
  PI_ERR tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1817
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_SetDBInfo");
#line 1818
  pi_reset_errors(sd);
#line 1820
  tmp___0 = pi_version(sd);
  }
#line 1820
  if (tmp___0 < 258) {
    {
#line 1821
    tmp = pi_set_error(sd, -302);
    }
#line 1821
    return (tmp);
  }
  {
#line 1823
  req = dlp_request_new((enum dlpFunctions )58, 1, 40);
  }
#line 1824
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 1825
    tmp___1 = pi_set_error(sd, -500);
    }
#line 1825
    return (tmp___1);
  }
  {
#line 1827
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 1828
  *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char)0;
#line 1829
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )(((int )((unsigned short )clearFlags) >> 8) & 255);
#line 1829
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((int )((unsigned short )clearFlags) & 255);
#line 1830
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char )(((int )((unsigned short )flags) >> 8) & 255);
#line 1830
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char )((int )((unsigned short )flags) & 255);
#line 1831
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 0) = (unsigned char )(((int )((unsigned short )version) >> 8) & 255);
#line 1831
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 1) = (unsigned char )((int )((unsigned short )version) & 255);
#line 1832
  dlp_htopdate(createDate, (unsigned char *)((*(req->argv + 0))->data + 8));
#line 1833
  dlp_htopdate(modifyDate, (unsigned char *)((*(req->argv + 0))->data + 16));
#line 1834
  dlp_htopdate(backupDate, (unsigned char *)((*(req->argv + 0))->data + 24));
#line 1835
  *((unsigned char *)((*(req->argv + 0))->data + 32) + 0) = (unsigned char )((int )((unsigned char )(type >> 24)) & 255);
#line 1835
  *((unsigned char *)((*(req->argv + 0))->data + 32) + 1) = (unsigned char )((type >> 16) & 255UL);
#line 1835
  *((unsigned char *)((*(req->argv + 0))->data + 32) + 2) = (unsigned char )((type >> 8) & 255UL);
#line 1835
  *((unsigned char *)((*(req->argv + 0))->data + 32) + 3) = (unsigned char )(type & 255UL);
#line 1836
  *((unsigned char *)((*(req->argv + 0))->data + 36) + 0) = (unsigned char )((int )((unsigned char )(creator >> 24)) & 255);
#line 1836
  *((unsigned char *)((*(req->argv + 0))->data + 36) + 1) = (unsigned char )((creator >> 16) & 255UL);
#line 1836
  *((unsigned char *)((*(req->argv + 0))->data + 36) + 2) = (unsigned char )((creator >> 8) & 255UL);
#line 1836
  *((unsigned char *)((*(req->argv + 0))->data + 36) + 3) = (unsigned char )(creator & 255UL);
#line 1838
  result = dlp_exec(sd, req, & res);
#line 1840
  dlp_request_free(req);
#line 1841
  dlp_response_free(res);
  }
#line 1843
  return (result);
}
}
#line 1846 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_MoveCategory(int sd , int handle , int fromcat , int tocat ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp ;

  {
  {
#line 1853
  pi_log(16, 4, "DLP sd=%d %s \"from %d to %d\"\n", sd, "dlp_MoveCategory", fromcat,
         tocat);
#line 1854
  pi_reset_errors(sd);
#line 1856
  req = dlp_request_new((enum dlpFunctions )44, 1, 4);
  }
#line 1857
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 1858
    tmp = pi_set_error(sd, -500);
    }
#line 1858
    return (tmp);
  }
  {
#line 1860
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )handle;
#line 1861
  *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char )fromcat;
#line 1862
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )tocat;
#line 1863
  *((unsigned char *)((*(req->argv + 0))->data + 3) + 0) = (unsigned char)0;
#line 1865
  result = dlp_exec(sd, req, & res);
#line 1867
  dlp_request_free(req);
#line 1868
  dlp_response_free(res);
  }
#line 1870
  if (result >= 0) {
    {
#line 1871
    pi_log(16, 4, "DLP MoveCategory Handle: %d, From: %d, To: %d\n", handle, fromcat,
           tocat);
    }
  }
#line 1876
  return (result);
}
}
#line 1879 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_OpenConduit(int sd ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp ;

  {
  {
#line 1886
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_OpenConduit");
#line 1887
  pi_reset_errors(sd);
#line 1889
  req = dlp_request_new((enum dlpFunctions )46, 0);
  }
#line 1890
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 1891
    tmp = pi_set_error(sd, -500);
    }
#line 1891
    return (tmp);
  }
  {
#line 1893
  result = dlp_exec(sd, req, & res);
#line 1895
  dlp_request_free(req);
#line 1896
  dlp_response_free(res);
  }
#line 1901
  if (result >= 0) {
    {
#line 1902
    pi_version(sd);
    }
  }
#line 1904
  return (result);
}
}
#line 1907 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_EndOfSync(int sd , int status ) 
{ 
  int result ;
  pi_socket_t *ps ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 1915
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_EndOfSync");
#line 1916
  pi_reset_errors(sd);
#line 1918
  ps = find_pi_socket(sd);
  }
#line 1919
  if ((unsigned long )ps == (unsigned long )((void *)0)) {
    {
#line 1920
    tmp = __errno_location();
#line 1920
    *tmp = 3;
    }
#line 1921
    return (-201);
  }
  {
#line 1924
  req = dlp_request_new((enum dlpFunctions )47, 1, 2);
  }
#line 1925
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 1926
    tmp___0 = pi_set_error(sd, -500);
    }
#line 1926
    return (tmp___0);
  }
  {
#line 1928
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )(((int )((unsigned short )status) >> 8) & 255);
#line 1928
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((int )((unsigned short )status) & 255);
#line 1930
  result = dlp_exec(sd, req, & res);
#line 1932
  dlp_request_free(req);
#line 1933
  dlp_response_free(res);
  }
#line 1937
  if (result == 0) {
#line 1938
    ps->state = 16;
  }
#line 1940
  return (result);
}
}
#line 1943 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_AbortSync(int sd ) 
{ 
  pi_socket_t *ps ;
  int *tmp ;

  {
  {
#line 1948
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_AbortSync");
#line 1949
  pi_reset_errors(sd);
#line 1952
  ps = find_pi_socket(sd);
  }
#line 1952
  if ((unsigned long )ps == (unsigned long )((void *)0)) {
    {
#line 1953
    tmp = __errno_location();
#line 1953
    *tmp = 3;
    }
#line 1954
    return (-201);
  }
#line 1957
  ps->state = 16;
#line 1959
  return (0);
}
}
#line 1962 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_WriteUserInfo(int sd , struct PilotUser  const  *User ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int len ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1970
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_WriteUserInfo");
#line 1971
  pi_reset_errors(sd);
#line 1973
  tmp = strlen((char const   *)(User->username));
#line 1973
  len = (int )(tmp + 1UL);
#line 1975
  req = dlp_request_new((enum dlpFunctions )17, 1, 22 + len);
  }
#line 1976
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 1977
    tmp___0 = pi_set_error(sd, -500);
    }
#line 1977
    return (tmp___0);
  }
  {
#line 1979
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )User->userID >> 24)) & 255);
#line 1979
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )(((unsigned long )User->userID >> 16) & 255UL);
#line 1979
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 2) = (unsigned char )(((unsigned long )User->userID >> 8) & 255UL);
#line 1979
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 3) = (unsigned char )((unsigned long )User->userID & 255UL);
#line 1980
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )User->viewerID >> 24)) & 255);
#line 1980
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char )(((unsigned long )User->viewerID >> 16) & 255UL);
#line 1980
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 2) = (unsigned char )(((unsigned long )User->viewerID >> 8) & 255UL);
#line 1980
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 3) = (unsigned char )((unsigned long )User->viewerID & 255UL);
#line 1981
  *((unsigned char *)((*(req->argv + 0))->data + 8) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )User->lastSyncPC >> 24)) & 255);
#line 1981
  *((unsigned char *)((*(req->argv + 0))->data + 8) + 1) = (unsigned char )(((unsigned long )User->lastSyncPC >> 16) & 255UL);
#line 1981
  *((unsigned char *)((*(req->argv + 0))->data + 8) + 2) = (unsigned char )(((unsigned long )User->lastSyncPC >> 8) & 255UL);
#line 1981
  *((unsigned char *)((*(req->argv + 0))->data + 8) + 3) = (unsigned char )((unsigned long )User->lastSyncPC & 255UL);
#line 1982
  dlp_htopdate((time_t )User->lastSyncDate, (unsigned char *)((*(req->argv + 0))->data + 12));
#line 1983
  *((unsigned char *)((*(req->argv + 0))->data + 20) + 0) = (unsigned char)255;
#line 1984
  *((unsigned char *)((*(req->argv + 0))->data + 21) + 0) = (unsigned char )len;
#line 1985
  strcpy((char */* __restrict  */)((*(req->argv + 0))->data + 22), (char const   */* __restrict  */)(User->username));
#line 1987
  result = dlp_exec(sd, req, & res);
#line 1989
  dlp_request_free(req);
#line 1990
  dlp_response_free(res);
  }
#line 1992
  return (result);
}
}
#line 1995 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ReadUserInfo(int sd , struct PilotUser *User ) 
{ 
  int result ;
  size_t userlen ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 2003
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_ReadUserInfo");
#line 2004
  pi_reset_errors(sd);
#line 2006
  req = dlp_request_new((enum dlpFunctions )16, 0);
  }
#line 2007
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 2008
    tmp = pi_set_error(sd, -500);
    }
#line 2008
    return (tmp);
  }
  {
#line 2010
  result = dlp_exec(sd, req, & res);
#line 2012
  dlp_request_free(req);
  }
#line 2014
  if (result > 0) {
    {
#line 2015
    User->userID = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3);
#line 2017
    User->viewerID = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 4) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 4) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 4) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 4) + 3);
#line 2019
    User->lastSyncPC = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 8) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 8) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 8) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 8) + 3);
#line 2021
    User->successfulSyncDate = dlp_ptohdate((unsigned char const   *)((*(res->argv + 0))->data + 12));
#line 2023
    User->lastSyncDate = dlp_ptohdate((unsigned char const   *)((*(res->argv + 0))->data + 20));
#line 2025
    userlen = (size_t )*((unsigned char *)((*(res->argv + 0))->data + 28) + 0);
#line 2027
    User->passwordLength = (size_t )*((unsigned char *)((*(res->argv + 0))->data + 29) + 0);
#line 2030
    memcpy((void */* __restrict  */)(User->username), (void const   */* __restrict  */)((*(res->argv + 0))->data + 30),
           userlen);
#line 2032
    memcpy((void */* __restrict  */)(User->password), (void const   */* __restrict  */)((*(res->argv + 0))->data + (30UL + userlen)),
           User->passwordLength);
    }
#line 2036
    if (userlen < sizeof(User->username)) {
#line 2037
      User->username[userlen] = (char )'\000';
    }
#line 2038
    if (User->passwordLength < sizeof(User->password)) {
#line 2039
      User->password[User->passwordLength] = (char )'\000';
    }
    {
#line 2041
    pi_log(16, 4, "DLP ReadUserInfo UID=0x%8.8lX VID=0x%8.8lX PCID=0x%8.8lX\n", User->userID,
           User->viewerID, User->lastSyncPC);
#line 2045
    tmp___0 = ctime((time_t const   *)(& User->successfulSyncDate));
#line 2045
    tmp___1 = ctime((time_t const   *)(& User->lastSyncDate));
#line 2045
    pi_log(16, 4, "  Last Sync=%s  Last Successful Sync=%s", tmp___1, tmp___0);
#line 2049
    pi_log(16, 4, "  Username=%s\n", User->username);
    }
  }
  {
#line 2053
  dlp_response_free(res);
  }
#line 2055
  return (result);
}
}
#line 2058 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ReadNetSyncInfo(int sd , struct NetSyncInfo *i ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp ;
  PI_ERR tmp___0 ;
  int tmp___1 ;
  size_t str_offset ;
  int tmp___2 ;

  {
  {
#line 2065
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_ReadNetSyncInfo");
#line 2066
  pi_reset_errors(sd);
#line 2068
  tmp___0 = pi_version(sd);
  }
#line 2068
  if (tmp___0 < 257) {
    {
#line 2069
    tmp = pi_set_error(sd, -302);
    }
#line 2069
    return (tmp);
  }
  {
#line 2071
  req = dlp_request_new((enum dlpFunctions )54, 0);
  }
#line 2072
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 2073
    tmp___1 = pi_set_error(sd, -500);
    }
#line 2073
    return (tmp___1);
  }
  {
#line 2075
  result = dlp_exec(sd, req, & res);
#line 2077
  dlp_request_free(req);
  }
#line 2079
  if (result >= 0) {
    {
#line 2080
    str_offset = (size_t )24;
#line 2082
    i->lanSync = (int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0);
#line 2084
    i->hostName[0] = (char )'\000';
#line 2085
    memcpy((void */* __restrict  */)(i->hostName), (void const   */* __restrict  */)((*(res->argv + 0))->data + str_offset),
           (size_t )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 18) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 18) + 1))));
#line 2087
    str_offset += (size_t )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 18) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 18) + 1)));
#line 2089
    i->hostAddress[0] = (char )'\000';
#line 2090
    memcpy((void */* __restrict  */)(i->hostAddress), (void const   */* __restrict  */)((*(res->argv + 0))->data + str_offset),
           (size_t )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 20) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 20) + 1))));
#line 2092
    str_offset += (size_t )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 20) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 20) + 1)));
#line 2094
    i->hostSubnetMask[0] = (char )'\000';
#line 2095
    memcpy((void */* __restrict  */)(i->hostSubnetMask), (void const   */* __restrict  */)((*(res->argv + 0))->data + str_offset),
           (size_t )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 22) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 22) + 1))));
    }
#line 2098
    if (i->lanSync) {
#line 2098
      tmp___2 = 1;
    } else {
#line 2098
      tmp___2 = 0;
    }
    {
#line 2098
    pi_log(16, 4, "DLP ReadNetSyncInfo Active: %d\n", tmp___2);
#line 2100
    pi_log(16, 4, "  PC hostname: \'%s\', address \'%s\', mask \'%s\'\n", i->hostName,
           i->hostAddress, i->hostSubnetMask);
    }
  }
  {
#line 2105
  dlp_response_free(res);
  }
#line 2107
  return (result);
}
}
#line 2110 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_WriteNetSyncInfo(int sd , struct NetSyncInfo  const  *i ) 
{ 
  int result ;
  int str_offset ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp ;
  PI_ERR tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;

  {
  {
#line 2113
  str_offset = 24;
#line 2118
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_WriteNetSyncInfo");
#line 2119
  pi_reset_errors(sd);
#line 2121
  tmp___0 = pi_version(sd);
  }
#line 2121
  if (tmp___0 < 257) {
    {
#line 2122
    tmp = pi_set_error(sd, -302);
    }
#line 2122
    return (tmp);
  }
#line 2124
  if (i->lanSync) {
#line 2124
    tmp___1 = 1;
  } else {
#line 2124
    tmp___1 = 0;
  }
  {
#line 2124
  pi_log(16, 4, "DLP ReadNetSyncInfo Active: %d\n", tmp___1);
#line 2126
  pi_log(16, 4, "  PC hostname: \'%s\', address \'%s\', mask \'%s\'\n", i->hostName,
         i->hostAddress, i->hostSubnetMask);
#line 2130
  tmp___2 = strlen((char const   *)(i->hostName));
#line 2130
  tmp___3 = strlen((char const   *)(i->hostAddress));
#line 2130
  tmp___4 = strlen((char const   *)(i->hostSubnetMask));
#line 2130
  req = dlp_request_new((enum dlpFunctions )55, 1, (((24UL + tmp___2) + tmp___3) + tmp___4) + 3UL);
  }
#line 2133
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 2134
    tmp___5 = pi_set_error(sd, -500);
    }
#line 2134
    return (tmp___5);
  }
  {
#line 2137
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char)240;
#line 2139
  *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char )i->lanSync;
#line 2140
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char)0;
#line 2140
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char)0;
#line 2140
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 2) = (unsigned char)0;
#line 2140
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 3) = (unsigned char)0;
#line 2141
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 0) = (unsigned char)0;
#line 2141
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 1) = (unsigned char)0;
#line 2141
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 2) = (unsigned char)0;
#line 2141
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 3) = (unsigned char)0;
#line 2142
  *((unsigned char *)((*(req->argv + 0))->data + 10) + 0) = (unsigned char)0;
#line 2142
  *((unsigned char *)((*(req->argv + 0))->data + 10) + 1) = (unsigned char)0;
#line 2142
  *((unsigned char *)((*(req->argv + 0))->data + 10) + 2) = (unsigned char)0;
#line 2142
  *((unsigned char *)((*(req->argv + 0))->data + 10) + 3) = (unsigned char)0;
#line 2143
  *((unsigned char *)((*(req->argv + 0))->data + 14) + 0) = (unsigned char)0;
#line 2143
  *((unsigned char *)((*(req->argv + 0))->data + 14) + 1) = (unsigned char)0;
#line 2143
  *((unsigned char *)((*(req->argv + 0))->data + 14) + 2) = (unsigned char)0;
#line 2143
  *((unsigned char *)((*(req->argv + 0))->data + 14) + 3) = (unsigned char)0;
#line 2144
  tmp___6 = strlen((char const   *)(i->hostName));
#line 2144
  *((unsigned char *)((*(req->argv + 0))->data + 18) + 0) = (unsigned char )(((int )((unsigned short )(tmp___6 + 1UL)) >> 8) & 255);
#line 2144
  tmp___7 = strlen((char const   *)(i->hostName));
#line 2144
  *((unsigned char *)((*(req->argv + 0))->data + 18) + 1) = (unsigned char )((int )((unsigned short )(tmp___7 + 1UL)) & 255);
#line 2145
  tmp___8 = strlen((char const   *)(i->hostAddress));
#line 2145
  *((unsigned char *)((*(req->argv + 0))->data + 20) + 0) = (unsigned char )(((int )((unsigned short )(tmp___8 + 1UL)) >> 8) & 255);
#line 2145
  tmp___9 = strlen((char const   *)(i->hostAddress));
#line 2145
  *((unsigned char *)((*(req->argv + 0))->data + 20) + 1) = (unsigned char )((int )((unsigned short )(tmp___9 + 1UL)) & 255);
#line 2146
  tmp___10 = strlen((char const   *)(i->hostSubnetMask));
#line 2146
  *((unsigned char *)((*(req->argv + 0))->data + 22) + 0) = (unsigned char )(((int )((unsigned short )(tmp___10 + 1UL)) >> 8) & 255);
#line 2146
  tmp___11 = strlen((char const   *)(i->hostSubnetMask));
#line 2146
  *((unsigned char *)((*(req->argv + 0))->data + 22) + 1) = (unsigned char )((int )((unsigned short )(tmp___11 + 1UL)) & 255);
#line 2148
  strcpy((char */* __restrict  */)((*(req->argv + 0))->data + str_offset), (char const   */* __restrict  */)(i->hostName));
#line 2149
  tmp___12 = strlen((char const   *)(i->hostName));
#line 2149
  str_offset = (int )((size_t )str_offset + (tmp___12 + 1UL));
#line 2150
  strcpy((char */* __restrict  */)((*(req->argv + 0))->data + str_offset), (char const   */* __restrict  */)(i->hostAddress));
#line 2151
  tmp___13 = strlen((char const   *)(i->hostAddress));
#line 2151
  str_offset = (int )((size_t )str_offset + (tmp___13 + 1UL));
#line 2152
  strcpy((char */* __restrict  */)((*(req->argv + 0))->data + str_offset), (char const   */* __restrict  */)(i->hostSubnetMask));
#line 2154
  result = dlp_exec(sd, req, & res);
#line 2156
  dlp_request_free(req);
#line 2157
  dlp_response_free(res);
  }
#line 2159
  return (result);
}
}
#line 2163 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_RPC(int sd , struct RPC_params *p , unsigned long *result ) 
{ 
  int i ;
  int err ;
  long D0 ;
  long A0 ;
  unsigned char *c ;
  pi_buffer_t *dlp_buf ;
  int tmp ;
  unsigned char *tmp___0 ;
  int l ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 2166
  err = 0;
#line 2168
  D0 = 0L;
#line 2168
  A0 = 0L;
#line 2173
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_RPC");
#line 2174
  pi_reset_errors(sd);
#line 2178
  dlp_buf = pi_buffer_new((size_t )65535);
  }
#line 2179
  if ((unsigned long )dlp_buf == (unsigned long )((void *)0)) {
    {
#line 2180
    tmp = pi_set_error(sd, -500);
    }
#line 2180
    return (tmp);
  }
  {
#line 2182
  *(dlp_buf->data + 0) = (unsigned char)45;
#line 2183
  *(dlp_buf->data + 1) = (unsigned char)1;
#line 2184
  *(dlp_buf->data + 2) = (unsigned char)0;
#line 2185
  *(dlp_buf->data + 3) = (unsigned char)0;
#line 2187
  InvertRPC(p);
#line 2189
  *((dlp_buf->data + 4) + 0) = (unsigned char )(((int )((unsigned short )p->trap) >> 8) & 255);
#line 2189
  *((dlp_buf->data + 4) + 1) = (unsigned char )((int )((unsigned short )p->trap) & 255);
#line 2190
  *((dlp_buf->data + 6) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )D0 >> 24)) & 255);
#line 2190
  *((dlp_buf->data + 6) + 1) = (unsigned char )(((unsigned long )D0 >> 16) & 255UL);
#line 2190
  *((dlp_buf->data + 6) + 2) = (unsigned char )(((unsigned long )D0 >> 8) & 255UL);
#line 2190
  *((dlp_buf->data + 6) + 3) = (unsigned char )((unsigned long )D0 & 255UL);
#line 2191
  *((dlp_buf->data + 10) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )A0 >> 24)) & 255);
#line 2191
  *((dlp_buf->data + 10) + 1) = (unsigned char )(((unsigned long )A0 >> 16) & 255UL);
#line 2191
  *((dlp_buf->data + 10) + 2) = (unsigned char )(((unsigned long )A0 >> 8) & 255UL);
#line 2191
  *((dlp_buf->data + 10) + 3) = (unsigned char )((unsigned long )A0 & 255UL);
#line 2192
  *((dlp_buf->data + 14) + 0) = (unsigned char )(((int )((unsigned short )p->args) >> 8) & 255);
#line 2192
  *((dlp_buf->data + 14) + 1) = (unsigned char )((int )((unsigned short )p->args) & 255);
#line 2194
  c = dlp_buf->data + 16;
#line 2195
  i = p->args - 1;
  }
  {
#line 2195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2195
    if (! (i >= 0)) {
#line 2195
      goto while_break;
    }
#line 2196
    *(c + 0) = (unsigned char )p->param[i].byRef;
#line 2197
    c ++;
#line 2198
    *(c + 0) = (unsigned char )p->param[i].size;
#line 2199
    c ++;
#line 2200
    if (p->param[i].data) {
      {
#line 2201
      memcpy((void */* __restrict  */)c, (void const   */* __restrict  */)p->param[i].data,
             p->param[i].size);
      }
    }
#line 2202
    c += p->param[i].size;
#line 2203
    if (p->param[i].size & 1UL) {
#line 2204
      tmp___0 = c;
#line 2204
      c ++;
#line 2204
      *tmp___0 = (unsigned char)0;
    }
#line 2195
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2207
  tmp___2 = pi_write(sd, (void const   *)dlp_buf->data, (size_t )(c - dlp_buf->data));
  }
#line 2207
  if (tmp___2 > 0L) {
#line 2208
    err = 0;
#line 2209
    if (p->reply) {
      {
#line 2210
      tmp___1 = pi_read(sd, dlp_buf, (size_t )((c - dlp_buf->data) + 2L));
#line 2210
      l = (int )tmp___1;
      }
#line 2212
      if (l < 0) {
#line 2213
        err = l;
      } else
#line 2214
      if (l < 6) {
#line 2215
        err = -1;
      } else
#line 2216
      if ((int )*(dlp_buf->data + 0) != 173) {
#line 2217
        err = -2;
      } else
#line 2218
      if ((unsigned short )(((int )*((dlp_buf->data + 2) + 0) << 8) | (int )*((dlp_buf->data + 2) + 1))) {
        {
#line 2219
        err = - ((int )((unsigned short )(((int )*((dlp_buf->data + 2) + 0) << 8) | (int )*((dlp_buf->data + 2) + 1))));
#line 2220
        pi_set_palmos_error(sd, - err);
        }
      } else {
#line 2222
        D0 = (long )(((((unsigned long )*((dlp_buf->data + 8) + 0) << 24) | ((unsigned long )*((dlp_buf->data + 8) + 1) << 16)) | ((unsigned long )*((dlp_buf->data + 8) + 2) << 8)) | (unsigned long )*((dlp_buf->data + 8) + 3));
#line 2223
        A0 = (long )(((((unsigned long )*((dlp_buf->data + 12) + 0) << 24) | ((unsigned long )*((dlp_buf->data + 12) + 1) << 16)) | ((unsigned long )*((dlp_buf->data + 12) + 2) << 8)) | (unsigned long )*((dlp_buf->data + 12) + 3));
#line 2224
        c = dlp_buf->data + 18;
#line 2225
        i = p->args - 1;
        {
#line 2225
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2225
          if (! (i >= 0)) {
#line 2225
            goto while_break___0;
          }
#line 2226
          if (p->param[i].byRef) {
#line 2226
            if (p->param[i].data) {
              {
#line 2227
              memcpy((void */* __restrict  */)p->param[i].data, (void const   */* __restrict  */)(c + 2),
                     p->param[i].size);
              }
            }
          }
#line 2229
          c += 2UL + ((p->param[i].size + 1UL) & 4294967294UL);
#line 2225
          i --;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 2236
  pi_buffer_free(dlp_buf);
#line 2238
  UninvertRPC(p);
  }
#line 2240
  if (result) {
#line 2241
    if (p->reply == 1) {
#line 2242
      *result = (unsigned long )A0;
    } else
#line 2243
    if (p->reply == 2) {
#line 2244
      *result = (unsigned long )D0;
    }
  }
#line 2248
  return (err);
}
}
#line 2252 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ReadFeature(int sd , unsigned long creator , int num , unsigned long *feature ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  struct RPC_params p ;
  int val ;
  unsigned long errCode ;
  uint16_t tmp ;
  uint32_t tmp___0 ;
  int tmp___1 ;
  PI_ERR tmp___2 ;
  int tmp___3 ;

  {
  {
#line 2260
  pi_log(16, 4, "DLP sd=%d %s \"creator=\'%4.4s\' num=%d\"\n", sd, "dlp_ReadFeature",
         (char const   *)(& creator), num);
#line 2261
  pi_reset_errors(sd);
#line 2263
  tmp___2 = pi_version(sd);
  }
#line 2263
  if (tmp___2 < 257) {
#line 2268
    if ((unsigned long )feature == (unsigned long )((void *)0)) {
#line 2269
      return (0);
    }
    {
#line 2271
    *feature = 305419896UL;
#line 2273
    tmp = htons((uint16_t )num);
#line 2273
    tmp___0 = htonl((uint32_t )creator);
#line 2273
    PackRPC(& p, 41595, 2, -4, tmp___0, -2, (unsigned int )tmp, 4, (void *)feature,
            1, 0);
#line 2275
    val = dlp_RPC(sd, & p, & errCode);
    }
#line 2277
    if (val < 0) {
      {
#line 2278
      pi_log(16, 4, "DLP ReadFeature Error: %s (%d)\n", dlp_errorlist[- val], val);
      }
#line 2282
      return (val);
    }
#line 2285
    if (errCode) {
      {
#line 2286
      pi_log(16, 4, "DLP ReadFeature FtrGet error 0x%8.8lX\n", res);
#line 2289
      pi_set_palmos_error(sd, (int )errCode);
#line 2290
      tmp___1 = pi_set_error(sd, -301);
      }
#line 2290
      return (tmp___1);
    }
    {
#line 2293
    pi_log(16, 4, " DLP ReadFeature Feature: 0x%8.8lX\n", *feature);
    }
#line 2297
    return (0);
  }
  {
#line 2300
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_ReadFeatureV2");
#line 2302
  req = dlp_request_new((enum dlpFunctions )56, 1, 6);
  }
#line 2303
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 2304
    tmp___3 = pi_set_error(sd, -500);
    }
#line 2304
    return (tmp___3);
  }
  {
#line 2306
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )((int )((unsigned char )(creator >> 24)) & 255);
#line 2306
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((creator >> 16) & 255UL);
#line 2306
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 2) = (unsigned char )((creator >> 8) & 255UL);
#line 2306
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 3) = (unsigned char )(creator & 255UL);
#line 2307
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char )(((int )((unsigned short )num) >> 8) & 255);
#line 2307
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char )((int )((unsigned short )num) & 255);
#line 2309
  result = dlp_exec(sd, req, & res);
#line 2311
  dlp_request_free(req);
  }
#line 2313
  if (result > 0) {
#line 2314
    if (feature) {
#line 2315
      *feature = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3);
    }
    {
#line 2318
    pi_log(16, 4, "DLP ReadFeature Feature: 0x%8.8lX\n", ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3));
    }
  }
  {
#line 2324
  dlp_response_free(res);
  }
#line 2326
  return (result);
}
}
#line 2330 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_GetROMToken(int sd , unsigned long token , void *buffer , size_t *size ) 
{ 
  unsigned long result ;
  struct RPC_params p ;
  int val ;
  unsigned long buffer_ptr ;
  uint32_t tmp ;
  uint16_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
  {
#line 2340
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_GetROMToken");
#line 2341
  pi_reset_errors(sd);
#line 2351
  tmp = htonl((uint32_t )token);
#line 2351
  tmp___0 = htons((uint16_t )0);
#line 2351
  PackRPC(& p, 41792, 2, -2, (unsigned int )tmp___0, -4, tmp, 4, (void *)(& buffer_ptr),
          1, 2, (void *)size, 1, 0);
#line 2357
  val = dlp_RPC(sd, & p, & result);
  }
#line 2376
  if (buffer) {
    {
#line 2377
    *((unsigned char *)buffer + *size) = (unsigned char)0;
#line 2379
    tmp___1 = htonl((uint32_t )*size);
#line 2379
    tmp___2 = htonl((uint32_t )buffer_ptr);
#line 2379
    PackRPC(& p, 40998, 2, *size, buffer, 0, -4, tmp___2, -4, tmp___1, 0);
#line 2385
    val = dlp_RPC(sd, & p, & result);
    }
  }
#line 2404
  if (val < 0) {
#line 2405
    return (val);
  }
#line 2407
  if (result) {
#line 2408
    return (- ((int )result));
  }
#line 2410
  return ((int )result);
}
}
#line 2413 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ResetLastSyncPC(int sd ) 
{ 
  int err ;
  struct PilotUser User ;
  int tmp ;

  {
  {
#line 2419
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_ResetLastSyncPC");
#line 2421
  err = dlp_ReadUserInfo(sd, & User);
  }
#line 2421
  if (err < 0) {
#line 2422
    return (err);
  }
  {
#line 2424
  User.lastSyncPC = 0UL;
#line 2426
  tmp = dlp_WriteUserInfo(sd, (struct PilotUser  const  *)(& User));
  }
#line 2426
  return (tmp);
}
}
#line 2429 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ResetDBIndex(int sd , int dbhandle ) 
{ 
  int result ;
  pi_socket_t *ps ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 2437
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_ResetDBIndex");
#line 2438
  pi_reset_errors(sd);
#line 2440
  ps = find_pi_socket(sd);
  }
#line 2440
  if ((unsigned long )ps == (unsigned long )((void *)0)) {
    {
#line 2441
    tmp = __errno_location();
#line 2441
    *tmp = 3;
    }
#line 2442
    return (-201);
  }
  {
#line 2445
  ps->dlprecord = 0;
#line 2447
  req = dlp_request_new((enum dlpFunctions )48, 1, 1);
  }
#line 2448
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 2449
    tmp___0 = pi_set_error(sd, -500);
    }
#line 2449
    return (tmp___0);
  }
  {
#line 2451
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 2453
  result = dlp_exec(sd, req, & res);
#line 2455
  dlp_request_free(req);
#line 2456
  dlp_response_free(res);
  }
#line 2458
  return (result);
}
}
#line 2461 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ReadRecordIDList(int sd , int dbhandle , int sort , int start , int max ,
                         recordid_t *IDs , int *count ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp ;
  int ret ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2469
  pi_log(16, 4, "DLP sd=%d %s \"sort=%d start=%d max=%d\"\n", sd, "dlp_ReadRecordIDList",
         sort, start, max);
#line 2471
  pi_reset_errors(sd);
#line 2473
  req = dlp_request_new((enum dlpFunctions )49, 1, 6);
  }
#line 2474
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 2475
    tmp = pi_set_error(sd, -500);
    }
#line 2475
    return (tmp);
  }
#line 2477
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 2478
  if (sort) {
#line 2478
    *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char)128;
  } else {
#line 2478
    *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char)0;
  }
  {
#line 2479
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )(((int )((unsigned short )start) >> 8) & 255);
#line 2479
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((int )((unsigned short )start) & 255);
#line 2480
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char )(((int )((unsigned short )max) >> 8) & 255);
#line 2480
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char )((int )((unsigned short )max) & 255);
#line 2482
  result = dlp_exec(sd, req, & res);
#line 2484
  dlp_request_free(req);
  }
#line 2486
  if (result > 0) {
#line 2489
    ret = (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1)));
#line 2490
    i = 0;
    {
#line 2490
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2490
      if (! (i < ret)) {
#line 2490
        goto while_break;
      }
#line 2491
      *(IDs + i) = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + (2 + i * 4)) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + (2 + i * 4)) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + (2 + i * 4)) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + (2 + i * 4)) + 3);
#line 2490
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2494
    if (count) {
#line 2495
      *count = ret;
    }
    {
#line 2497
    pi_log(16, 4, "DLP ReadRecordIDList %d IDs:\n", ret);
    }
    {
#line 2499
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2499
      tmp___0 = pi_debug_get_types();
      }
#line 2499
      if (tmp___0 & 16) {
        {
#line 2499
        tmp___1 = pi_debug_get_level();
        }
#line 2499
        if (tmp___1 >= 8) {
          {
#line 2499
          pi_dumpdata((char const   *)((*(res->argv + 0))->data + 2), (size_t )(ret * 4));
          }
        }
      }
#line 2499
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 2504
  dlp_response_free(res);
  }
#line 2506
  return (result);
}
}
#line 2509 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_WriteRecord(int sd , int dbhandle , int flags , recordid_t recID , int catID ,
                    void const   *data , size_t length , recordid_t *pNewRecID ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  PI_ERR tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 2517
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_WriteRecord");
#line 2518
  pi_reset_errors(sd);
  }
#line 2520
  if (length == 0xffffffffffffffffUL) {
    {
#line 2521
    tmp = strlen((char const   *)((char *)data));
#line 2521
    length = tmp + 1UL;
    }
  }
  {
#line 2523
  tmp___2 = pi_version(sd);
  }
#line 2523
  if (tmp___2 >= 260) {
    {
#line 2524
    req = dlp_request_new((enum dlpFunctions )94, 1, 12UL + length);
    }
#line 2525
    if ((unsigned long )req == (unsigned long )((void *)0)) {
      {
#line 2526
      tmp___0 = pi_set_error(sd, -500);
      }
#line 2526
      return (tmp___0);
    }
    {
#line 2528
    *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 2529
    *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char)128;
#line 2530
    *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )((int )((unsigned char )(recID >> 24)) & 255);
#line 2530
    *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((recID >> 16) & 255UL);
#line 2530
    *((unsigned char *)((*(req->argv + 0))->data + 2) + 2) = (unsigned char )((recID >> 8) & 255UL);
#line 2530
    *((unsigned char *)((*(req->argv + 0))->data + 2) + 3) = (unsigned char )(recID & 255UL);
#line 2531
    *((unsigned char *)((*(req->argv + 0))->data + 6) + 0) = (unsigned char )flags;
#line 2532
    *((unsigned char *)((*(req->argv + 0))->data + 7) + 0) = (unsigned char )catID;
#line 2533
    *((unsigned char *)((*(req->argv + 0))->data + 8) + 0) = (unsigned char)0;
#line 2533
    *((unsigned char *)((*(req->argv + 0))->data + 8) + 1) = (unsigned char)0;
#line 2533
    *((unsigned char *)((*(req->argv + 0))->data + 8) + 2) = (unsigned char)0;
#line 2533
    *((unsigned char *)((*(req->argv + 0))->data + 8) + 3) = (unsigned char)0;
#line 2535
    memcpy((void */* __restrict  */)((*(req->argv + 0))->data + 12), (void const   */* __restrict  */)data,
           length);
    }
  } else {
#line 2537
    if (length + 8UL > 65535UL) {
      {
#line 2538
      pi_log(16, 1, "DLP WriteRecord: data too large (>64k)");
      }
#line 2540
      return (-304);
    }
    {
#line 2543
    req = dlp_request_new((enum dlpFunctions )33, 1, 8UL + length);
    }
#line 2544
    if ((unsigned long )req == (unsigned long )((void *)0)) {
      {
#line 2545
      tmp___1 = pi_set_error(sd, -500);
      }
#line 2545
      return (tmp___1);
    }
    {
#line 2547
    *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 2548
    *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char)128;
#line 2549
    *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )((int )((unsigned char )(recID >> 24)) & 255);
#line 2549
    *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((recID >> 16) & 255UL);
#line 2549
    *((unsigned char *)((*(req->argv + 0))->data + 2) + 2) = (unsigned char )((recID >> 8) & 255UL);
#line 2549
    *((unsigned char *)((*(req->argv + 0))->data + 2) + 3) = (unsigned char )(recID & 255UL);
#line 2550
    *((unsigned char *)((*(req->argv + 0))->data + 6) + 0) = (unsigned char )flags;
#line 2551
    *((unsigned char *)((*(req->argv + 0))->data + 7) + 0) = (unsigned char )catID;
#line 2553
    memcpy((void */* __restrict  */)((*(req->argv + 0))->data + 8), (void const   */* __restrict  */)data,
           length);
    }
  }
  {
#line 2556
  result = dlp_exec(sd, req, & res);
#line 2558
  dlp_request_free(req);
  }
#line 2560
  if (result > 0) {
#line 2561
    if (pNewRecID) {
#line 2562
      *pNewRecID = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3);
    }
    {
#line 2564
    pi_log(16, 4, "DLP WriteRecord Record ID: 0x%8.8lX\n", ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3));
    }
    {
#line 2568
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2568
      tmp___3 = pi_debug_get_types();
      }
#line 2568
      if (tmp___3 & 16) {
        {
#line 2568
        tmp___4 = pi_debug_get_level();
        }
#line 2568
        if (tmp___4 >= 8) {
          {
#line 2568
          record_dump(((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3),
                      65535U, flags, catID, (char const   *)data, (int )length);
          }
        }
      }
#line 2568
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 2577
  dlp_response_free(res);
  }
#line 2579
  return (result);
}
}
#line 2582 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_DeleteRecord(int sd , int dbhandle , int all , recordid_t recID ) 
{ 
  int result ;
  int flags ;
  int tmp ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp___0 ;

  {
#line 2585
  if (all) {
#line 2585
    tmp = 128;
  } else {
#line 2585
    tmp = 0;
  }
  {
#line 2585
  flags = tmp;
#line 2590
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_DeleteRecord");
#line 2591
  pi_reset_errors(sd);
#line 2593
  req = dlp_request_new((enum dlpFunctions )34, 1, 6);
  }
#line 2594
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 2595
    tmp___0 = pi_set_error(sd, -500);
    }
#line 2595
    return (tmp___0);
  }
  {
#line 2597
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 2598
  *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char )flags;
#line 2599
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )((int )((unsigned char )(recID >> 24)) & 255);
#line 2599
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((recID >> 16) & 255UL);
#line 2599
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 2) = (unsigned char )((recID >> 8) & 255UL);
#line 2599
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 3) = (unsigned char )(recID & 255UL);
#line 2601
  result = dlp_exec(sd, req, & res);
#line 2603
  dlp_request_free(req);
#line 2604
  dlp_response_free(res);
  }
#line 2606
  return (result);
}
}
#line 2609 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_DeleteCategory(int sd , int dbhandle , int category ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int i ;
  int cat ;
  int attr ;
  recordid_t id_ ;
  int flags ;
  int tmp ;
  PI_ERR tmp___0 ;

  {
  {
#line 2616
  pi_log(16, 4, "DLP sd=%d %s \"category=%d\"\n", sd, "dlp_DeleteCategory", category);
#line 2617
  pi_reset_errors(sd);
#line 2619
  tmp___0 = pi_version(sd);
  }
#line 2619
  if (tmp___0 < 257) {
    {
#line 2624
    pi_log(16, 4, "DLP DeleteCategory Emulating with: Handle: %d, Category: %d\n",
           dbhandle, category & 255);
#line 2629
    i = 0;
    }
    {
#line 2629
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2629
      result = dlp_ReadRecordByIndex(sd, dbhandle, i, (pi_buffer_t *)((void *)0),
                                     & id_, & attr, & cat);
      }
#line 2629
      if (! (result >= 0)) {
#line 2629
        goto while_break;
      }
#line 2632
      if (cat != category) {
#line 2635
        goto __Cont;
      } else
#line 2632
      if (attr & 128) {
#line 2635
        goto __Cont;
      } else
#line 2632
      if (attr & 8) {
#line 2635
        goto __Cont;
      }
      {
#line 2636
      result = dlp_DeleteRecord(sd, dbhandle, 0, id_);
      }
#line 2637
      if (result < 0) {
#line 2638
        goto while_break;
      }
#line 2639
      i --;
      __Cont: /* CIL Label */ 
#line 2629
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2642
    return (result);
  } else {
    {
#line 2644
    flags = 64;
#line 2646
    req = dlp_request_new((enum dlpFunctions )34, 1, 6);
    }
#line 2647
    if ((unsigned long )req == (unsigned long )((void *)0)) {
      {
#line 2648
      tmp = pi_set_error(sd, -500);
      }
#line 2648
      return (tmp);
    }
    {
#line 2650
    *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 2651
    *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char )flags;
#line 2652
    *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )(category & 255) >> 24)) & 255);
#line 2652
    *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )(((unsigned long )(category & 255) >> 16) & 255UL);
#line 2652
    *((unsigned char *)((*(req->argv + 0))->data + 2) + 2) = (unsigned char )(((unsigned long )(category & 255) >> 8) & 255UL);
#line 2652
    *((unsigned char *)((*(req->argv + 0))->data + 2) + 3) = (unsigned char )((unsigned long )(category & 255) & 255UL);
#line 2654
    result = dlp_exec(sd, req, & res);
#line 2656
    dlp_request_free(req);
#line 2657
    dlp_response_free(res);
    }
#line 2659
    return (result);
  }
}
}
#line 2663 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ReadResourceByType(int sd , int dbhandle , unsigned long type , int resID ,
                           pi_buffer_t *buffer , int *resindex ) 
{ 
  int result ;
  int data_len ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int maxBufferSize ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 2671
  tmp = pi_maxrecsize(sd);
#line 2671
  maxBufferSize = (int )(tmp - 100UL);
#line 2673
  pi_log(16, 4, "DLP sd=%d %s \"type=\'%4.4s\' resID=%d\"\n", sd, "dlp_ReadResourceByType",
         (char const   *)(& type), resID);
#line 2674
  pi_reset_errors(sd);
#line 2676
  req = dlp_request_new_with_argid((enum dlpFunctions )35, 33, 1, 12);
  }
#line 2677
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 2678
    tmp___0 = pi_set_error(sd, -500);
    }
#line 2678
    return (tmp___0);
  }
#line 2680
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 2681
  *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char)0;
#line 2682
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )((int )((unsigned char )(type >> 24)) & 255);
#line 2682
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((type >> 16) & 255UL);
#line 2682
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 2) = (unsigned char )((type >> 8) & 255UL);
#line 2682
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 3) = (unsigned char )(type & 255UL);
#line 2683
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 0) = (unsigned char )(((int )((unsigned short )resID) >> 8) & 255);
#line 2683
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 1) = (unsigned char )((int )((unsigned short )resID) & 255);
#line 2684
  *((unsigned char *)((*(req->argv + 0))->data + 8) + 0) = (unsigned char)0;
#line 2684
  *((unsigned char *)((*(req->argv + 0))->data + 8) + 1) = (unsigned char)0;
#line 2685
  if (buffer) {
#line 2685
    tmp___1 = maxBufferSize;
  } else {
#line 2685
    tmp___1 = 0;
  }
#line 2685
  *((unsigned char *)((*(req->argv + 0))->data + 10) + 0) = (unsigned char )(((int )((unsigned short )tmp___1) >> 8) & 255);
#line 2685
  if (buffer) {
#line 2685
    tmp___2 = maxBufferSize;
  } else {
#line 2685
    tmp___2 = 0;
  }
  {
#line 2685
  *((unsigned char *)((*(req->argv + 0))->data + 10) + 1) = (unsigned char )((int )((unsigned short )tmp___2) & 255);
#line 2687
  result = dlp_exec(sd, req, & res);
#line 2689
  dlp_request_free(req);
  }
#line 2691
  if (result > 0) {
#line 2692
    data_len = (int )((*(res->argv + 0))->len - 10UL);
#line 2693
    if (resindex) {
#line 2694
      *resindex = (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 6) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 6) + 1)));
    }
#line 2695
    if (buffer) {
      {
#line 2696
      pi_buffer_clear(buffer);
#line 2697
      pi_buffer_append(buffer, (void const   *)((*(res->argv + 0))->data + 10), (size_t )data_len);
      }
#line 2704
      if (data_len == maxBufferSize) {
        {
#line 2705
        dlp_response_free(res);
#line 2706
        req = dlp_request_new_with_argid((enum dlpFunctions )35, 33, 1, 12);
        }
#line 2707
        if ((unsigned long )req != (unsigned long )((void *)0)) {
          {
#line 2708
          *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 2709
          *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char)0;
#line 2710
          *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )((int )((unsigned char )(type >> 24)) & 255);
#line 2710
          *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((type >> 16) & 255UL);
#line 2710
          *((unsigned char *)((*(req->argv + 0))->data + 2) + 2) = (unsigned char )((type >> 8) & 255UL);
#line 2710
          *((unsigned char *)((*(req->argv + 0))->data + 2) + 3) = (unsigned char )(type & 255UL);
#line 2711
          *((unsigned char *)((*(req->argv + 0))->data + 6) + 0) = (unsigned char )(((int )((unsigned short )resID) >> 8) & 255);
#line 2711
          *((unsigned char *)((*(req->argv + 0))->data + 6) + 1) = (unsigned char )((int )((unsigned short )resID) & 255);
#line 2712
          *((unsigned char *)((*(req->argv + 0))->data + 8) + 0) = (unsigned char )(((int )((unsigned short )maxBufferSize) >> 8) & 255);
#line 2712
          *((unsigned char *)((*(req->argv + 0))->data + 8) + 1) = (unsigned char )((int )((unsigned short )maxBufferSize) & 255);
#line 2713
          *((unsigned char *)((*(req->argv + 0))->data + 10) + 0) = (unsigned char )((100 >> 8) & 255);
#line 2713
          *((unsigned char *)((*(req->argv + 0))->data + 10) + 1) = (unsigned char)100;
#line 2715
          result = dlp_exec(sd, req, & res);
#line 2717
          dlp_request_free(req);
          }
#line 2719
          if (result > 0) {
            {
#line 2720
            data_len = (int )((*(res->argv + 0))->len - 10UL);
#line 2721
            pi_buffer_append(buffer, (void const   *)((*(res->argv + 0))->data + 10),
                             (size_t )data_len);
#line 2722
            data_len += maxBufferSize;
            }
          }
        }
      }
    }
    {
#line 2728
    tmp___3 = printlong(type);
#line 2728
    pi_log(16, 4, "DLP ReadResourceByType  Type: \'%s\', ID: %d, Index: %d, and %d bytes:\n",
           tmp___3, resID, (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 6) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 6) + 1))),
           (size_t )data_len);
    }
    {
#line 2733
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2733
      tmp___4 = pi_debug_get_types();
      }
#line 2733
      if (tmp___4 & 16) {
        {
#line 2733
        tmp___5 = pi_debug_get_level();
        }
#line 2733
        if (tmp___5 >= 8) {
          {
#line 2733
          pi_dumpdata((char const   *)((*(res->argv + 0))->data + 10), (size_t )data_len);
          }
        }
      }
#line 2733
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 2736
    data_len = result;
  }
  {
#line 2739
  dlp_response_free(res);
  }
#line 2741
  return (data_len);
}
}
#line 2744 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ReadResourceByIndex(int sd , int dbhandle , unsigned int resindex , pi_buffer_t *buffer ,
                            unsigned long *type , int *resID ) 
{ 
  int result ;
  int data_len ;
  int large ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int maxBufferSize ;
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  PI_ERR tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 2748
  large = 0;
#line 2753
  tmp = pi_maxrecsize(sd);
#line 2753
  maxBufferSize = (int )(tmp - 100UL);
#line 2755
  pi_log(16, 4, "DLP sd=%d %s \"resindex=%d\"\n", sd, "dlp_ReadResourceByIndex", resindex);
#line 2756
  pi_reset_errors(sd);
#line 2761
  tmp___6 = pi_version(sd);
  }
#line 2761
  if (tmp___6 >= 260) {
    {
#line 2762
    req = dlp_request_new((enum dlpFunctions )100, 1, 12);
    }
#line 2763
    if ((unsigned long )req == (unsigned long )((void *)0)) {
      {
#line 2764
      tmp___0 = pi_set_error(sd, -500);
      }
#line 2764
      return (tmp___0);
    }
    {
#line 2766
    *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 2767
    *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char)0;
#line 2768
    *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )(((int )((unsigned short )resindex) >> 8) & 255);
#line 2768
    *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((int )((unsigned short )resindex) & 255);
#line 2769
    *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char)0;
#line 2769
    *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char)0;
#line 2769
    *((unsigned char *)((*(req->argv + 0))->data + 4) + 2) = (unsigned char)0;
#line 2769
    *((unsigned char *)((*(req->argv + 0))->data + 4) + 3) = (unsigned char)0;
#line 2770
    tmp___1 = pi_maxrecsize(sd);
#line 2770
    *((unsigned char *)((*(req->argv + 0))->data + 8) + 0) = (unsigned char )((int )((unsigned char )(tmp___1 >> 24)) & 255);
#line 2770
    tmp___2 = pi_maxrecsize(sd);
#line 2770
    *((unsigned char *)((*(req->argv + 0))->data + 8) + 1) = (unsigned char )((tmp___2 >> 16) & 255UL);
#line 2770
    tmp___3 = pi_maxrecsize(sd);
#line 2770
    *((unsigned char *)((*(req->argv + 0))->data + 8) + 2) = (unsigned char )((tmp___3 >> 8) & 255UL);
#line 2770
    tmp___4 = pi_maxrecsize(sd);
#line 2770
    *((unsigned char *)((*(req->argv + 0))->data + 8) + 3) = (unsigned char )(tmp___4 & 255UL);
#line 2771
    large = 1;
    }
  } else {
    {
#line 2773
    req = dlp_request_new((enum dlpFunctions )35, 1, 8);
    }
#line 2774
    if ((unsigned long )req == (unsigned long )((void *)0)) {
      {
#line 2775
      tmp___5 = pi_set_error(sd, -500);
      }
#line 2775
      return (tmp___5);
    }
#line 2777
    *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 2778
    *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char)0;
#line 2779
    *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )(((int )((unsigned short )resindex) >> 8) & 255);
#line 2779
    *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((int )((unsigned short )resindex) & 255);
#line 2780
    *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )maxBufferSize >> 24)) & 255);
#line 2780
    *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char )(((unsigned long )maxBufferSize >> 16) & 255UL);
#line 2780
    *((unsigned char *)((*(req->argv + 0))->data + 4) + 2) = (unsigned char )(((unsigned long )maxBufferSize >> 8) & 255UL);
#line 2780
    *((unsigned char *)((*(req->argv + 0))->data + 4) + 3) = (unsigned char )((unsigned long )maxBufferSize & 255UL);
  }
  {
#line 2783
  result = dlp_exec(sd, req, & res);
#line 2785
  dlp_request_free(req);
  }
#line 2787
  if (result > 0) {
#line 2788
    if (large) {
#line 2788
      tmp___7 = 12;
    } else {
#line 2788
      tmp___7 = 10;
    }
#line 2788
    data_len = (int )((*(res->argv + 0))->len - (size_t )tmp___7);
#line 2789
    if (type) {
#line 2790
      *type = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3);
    }
#line 2791
    if (resID) {
#line 2792
      *resID = (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 1)));
    }
#line 2793
    if (buffer) {
      {
#line 2794
      pi_buffer_clear(buffer);
      }
#line 2795
      if (large) {
#line 2795
        tmp___8 = 12;
      } else {
#line 2795
        tmp___8 = 10;
      }
      {
#line 2795
      pi_buffer_append(buffer, (void const   *)((*(res->argv + 0))->data + tmp___8),
                       (size_t )data_len);
      }
#line 2802
      if (data_len == maxBufferSize) {
#line 2802
        if (! large) {
          {
#line 2803
          dlp_response_free(res);
#line 2804
          req = dlp_request_new((enum dlpFunctions )35, 1, 8);
          }
#line 2805
          if ((unsigned long )req != (unsigned long )((void *)0)) {
            {
#line 2806
            *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 2807
            *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char)0;
#line 2808
            *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )(((int )((unsigned short )resindex) >> 8) & 255);
#line 2808
            *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((int )((unsigned short )resindex) & 255);
#line 2809
            *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char )(((int )((unsigned short )maxBufferSize) >> 8) & 255);
#line 2809
            *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char )((int )((unsigned short )maxBufferSize) & 255);
#line 2810
            *((unsigned char *)((*(req->argv + 0))->data + 6) + 0) = (unsigned char )((100 >> 8) & 255);
#line 2810
            *((unsigned char *)((*(req->argv + 0))->data + 6) + 1) = (unsigned char)100;
#line 2812
            result = dlp_exec(sd, req, & res);
#line 2814
            dlp_request_free(req);
            }
#line 2816
            if (result > 0) {
#line 2817
              if (large) {
#line 2817
                tmp___9 = 12;
              } else {
#line 2817
                tmp___9 = 10;
              }
#line 2817
              data_len = (int )((*(res->argv + 0))->len - (size_t )tmp___9);
#line 2818
              if (large) {
#line 2818
                tmp___10 = 12;
              } else {
#line 2818
                tmp___10 = 10;
              }
              {
#line 2818
              pi_buffer_append(buffer, (void const   *)((*(res->argv + 0))->data + tmp___10),
                               (size_t )data_len);
#line 2820
              data_len += maxBufferSize;
              }
            }
          }
        }
      }
    }
    {
#line 2826
    tmp___11 = printlong(((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3));
#line 2826
    pi_log(16, 4, "DLP ReadResourceByIndex Type: \'%s\', ID: %d, Index: %d, and %d bytes:\n",
           tmp___11, (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 1))),
           resindex, data_len);
    }
    {
#line 2832
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2832
      tmp___13 = pi_debug_get_types();
      }
#line 2832
      if (tmp___13 & 16) {
        {
#line 2832
        tmp___14 = pi_debug_get_level();
        }
#line 2832
        if (tmp___14 >= 8) {
#line 2832
          if (large) {
#line 2832
            tmp___12 = 12;
          } else {
#line 2832
            tmp___12 = 10;
          }
          {
#line 2832
          pi_dumpdata((char const   *)((*(res->argv + 0))->data + tmp___12), (size_t )data_len);
          }
        }
      }
#line 2832
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 2836
    data_len = result;
  }
  {
#line 2839
  dlp_response_free(res);
  }
#line 2841
  return (data_len);
}
}
#line 2844 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_WriteResource(int sd , int dbhandle , unsigned long type , int resID , void const   *data ,
                      size_t length ) 
{ 
  int result ;
  int large ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2848
  large = 0;
#line 2853
  pi_log(16, 4, "DLP sd=%d %s \"\'%4.4s\' #%d\"\n", sd, "dlp_WriteResource", (char const   *)(& type),
         resID);
#line 2854
  pi_reset_errors(sd);
#line 2859
  tmp = pi_version(sd);
  }
#line 2859
  if (tmp >= 260) {
    {
#line 2860
    req = dlp_request_new_with_argid((enum dlpFunctions )95, 96, 1, 12UL + length);
#line 2862
    large = 1;
    }
  } else {
#line 2864
    if (length > 65535UL) {
#line 2865
      length = (size_t )65535;
    }
    {
#line 2866
    req = dlp_request_new((enum dlpFunctions )36, 1, 10UL + length);
    }
  }
#line 2868
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 2869
    pi_log(16, 1, "DLP sd:%i large:%i dlp_request_new failed\n", sd, large);
#line 2872
    tmp___0 = pi_set_error(sd, -500);
    }
#line 2872
    return (tmp___0);
  }
#line 2875
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 2876
  *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char)0;
#line 2877
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )((int )((unsigned char )(type >> 24)) & 255);
#line 2877
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((type >> 16) & 255UL);
#line 2877
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 2) = (unsigned char )((type >> 8) & 255UL);
#line 2877
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 3) = (unsigned char )(type & 255UL);
#line 2878
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 0) = (unsigned char )(((int )((unsigned short )resID) >> 8) & 255);
#line 2878
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 1) = (unsigned char )((int )((unsigned short )resID) & 255);
#line 2879
  if (large) {
#line 2880
    *((unsigned char *)((*(req->argv + 0))->data + 8) + 0) = (unsigned char)0;
#line 2880
    *((unsigned char *)((*(req->argv + 0))->data + 8) + 1) = (unsigned char)0;
#line 2880
    *((unsigned char *)((*(req->argv + 0))->data + 8) + 2) = (unsigned char)0;
#line 2880
    *((unsigned char *)((*(req->argv + 0))->data + 8) + 3) = (unsigned char)0;
  } else {
#line 2882
    *((unsigned char *)((*(req->argv + 0))->data + 8) + 0) = (unsigned char )(((int )((unsigned short )length) >> 8) & 255);
#line 2882
    *((unsigned char *)((*(req->argv + 0))->data + 8) + 1) = (unsigned char )((int )((unsigned short )length) & 255);
  }
#line 2884
  if (large) {
#line 2884
    tmp___1 = 12;
  } else {
#line 2884
    tmp___1 = 10;
  }
  {
#line 2884
  memcpy((void */* __restrict  */)((*(req->argv + 0))->data + tmp___1), (void const   */* __restrict  */)data,
         length);
#line 2886
  result = dlp_exec(sd, req, & res);
#line 2888
  dlp_request_free(req);
#line 2889
  dlp_response_free(res);
  }
#line 2891
  return (result);
}
}
#line 2895 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_DeleteResource(int sd , int dbhandle , int all , unsigned long restype , int resID ) 
{ 
  int result ;
  int flags ;
  int tmp ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp___0 ;

  {
#line 2899
  if (all) {
#line 2899
    tmp = 128;
  } else {
#line 2899
    tmp = 0;
  }
  {
#line 2899
  flags = tmp;
#line 2904
  pi_log(16, 4, "DLP sd=%d %s \"restype=\'%4.4s\' resID=%d all=%d\"\n", sd, "dlp_DeleteResource",
         (char const   *)(& restype), resID, all);
#line 2906
  pi_reset_errors(sd);
#line 2908
  req = dlp_request_new((enum dlpFunctions )37, 1, 8);
  }
#line 2909
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 2910
    tmp___0 = pi_set_error(sd, -500);
    }
#line 2910
    return (tmp___0);
  }
  {
#line 2912
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 2913
  *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char )flags;
#line 2914
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )((int )((unsigned char )(restype >> 24)) & 255);
#line 2914
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((restype >> 16) & 255UL);
#line 2914
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 2) = (unsigned char )((restype >> 8) & 255UL);
#line 2914
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 3) = (unsigned char )(restype & 255UL);
#line 2915
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 0) = (unsigned char )(((int )((unsigned short )resID) >> 8) & 255);
#line 2915
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 1) = (unsigned char )((int )((unsigned short )resID) & 255);
#line 2917
  result = dlp_exec(sd, req, & res);
#line 2919
  dlp_request_free(req);
#line 2920
  dlp_response_free(res);
  }
#line 2922
  return (result);
}
}
#line 2925 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ReadAppBlock(int sd , int dbhandle , int offset , int reqbytes , pi_buffer_t *retbuf ) 
{ 
  int result ;
  int data_len ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2933
  pi_log(16, 4, "DLP sd=%d %s \"offset=%d reqbytes=%ld\"\n", sd, "dlp_ReadAppBlock",
         offset, reqbytes);
#line 2934
  pi_reset_errors(sd);
  }
#line 2936
  if (retbuf) {
    {
#line 2937
    pi_buffer_clear(retbuf);
    }
  }
  {
#line 2939
  req = dlp_request_new((enum dlpFunctions )27, 1, 6);
  }
#line 2940
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 2941
    tmp = pi_set_error(sd, -500);
    }
#line 2941
    return (tmp);
  }
  {
#line 2943
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 2944
  *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char)0;
#line 2945
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )(((int )((unsigned short )offset) >> 8) & 255);
#line 2945
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((int )((unsigned short )offset) & 255);
#line 2946
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char )(((int )((unsigned short )reqbytes) >> 8) & 255);
#line 2946
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char )((int )((unsigned short )reqbytes) & 255);
#line 2948
  result = dlp_exec(sd, req, & res);
#line 2950
  dlp_request_free(req);
  }
#line 2952
  if (result >= 0) {
#line 2953
    if (result < 2) {
#line 2954
      data_len = -305;
    } else {
#line 2956
      data_len = (int )((*(res->argv + 0))->len - 2UL);
#line 2957
      if (retbuf) {
#line 2957
        if (data_len) {
          {
#line 2958
          pi_buffer_append(retbuf, (void const   *)((*(res->argv + 0))->data + 2),
                           (size_t )data_len);
          }
        }
      }
      {
#line 2961
      pi_log(16, 4, "DLP ReadAppBlock %d bytes\n", data_len);
      }
      {
#line 2963
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 2963
        tmp___0 = pi_debug_get_types();
        }
#line 2963
        if (tmp___0 & 16) {
          {
#line 2963
          tmp___1 = pi_debug_get_level();
          }
#line 2963
          if (tmp___1 >= 8) {
            {
#line 2963
            pi_dumpdata((char const   *)((*(res->argv + 0))->data + 2), (size_t )data_len);
            }
          }
        }
#line 2963
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
#line 2968
    data_len = result;
  }
  {
#line 2971
  dlp_response_free(res);
  }
#line 2973
  return (data_len);
}
}
#line 2976 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_WriteAppBlock(int sd , int dbhandle , void const   *data , size_t length ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp ;

  {
  {
#line 2984
  pi_log(16, 4, "DLP sd=%d %s \"length=%ld\"\n", sd, "dlp_WriteAppBlock", length);
#line 2985
  pi_reset_errors(sd);
#line 2987
  req = dlp_request_new((enum dlpFunctions )28, 1, 4UL + length);
  }
#line 2988
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 2989
    tmp = pi_set_error(sd, -500);
    }
#line 2989
    return (tmp);
  }
#line 2991
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 2992
  *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char)0;
#line 2993
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )(((int )((unsigned short )length) >> 8) & 255);
#line 2993
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((int )((unsigned short )length) & 255);
#line 2995
  if (length + 10UL > 65535UL) {
    {
#line 2996
    pi_log(16, 1, "DLP WriteAppBlock: data too large (>64k)");
#line 2998
    pi_set_error(sd, -304);
    }
#line 2999
    return (-131);
  }
#line 3001
  if (length) {
    {
#line 3002
    memcpy((void */* __restrict  */)((*(req->argv + 0))->data + 4), (void const   */* __restrict  */)data,
           length);
    }
  }
  {
#line 3004
  result = dlp_exec(sd, req, & res);
#line 3006
  dlp_request_free(req);
#line 3007
  dlp_response_free(res);
  }
#line 3009
  return (result);
}
}
#line 3012 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ReadSortBlock(int sd , int dbhandle , int offset , int reqbytes , pi_buffer_t *retbuf ) 
{ 
  int result ;
  int data_len ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 3020
  pi_log(16, 4, "DLP sd=%d %s \"offset=%d reqbytes=%d\"\n", sd, "dlp_ReadSortBlock",
         offset, reqbytes);
#line 3021
  pi_reset_errors(sd);
  }
#line 3023
  if (retbuf) {
    {
#line 3024
    pi_buffer_clear(retbuf);
    }
  }
  {
#line 3026
  req = dlp_request_new((enum dlpFunctions )29, 1, 6);
  }
#line 3027
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 3028
    tmp = pi_set_error(sd, -500);
    }
#line 3028
    return (tmp);
  }
  {
#line 3030
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 3031
  *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char)0;
#line 3032
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )(((int )((unsigned short )offset) >> 8) & 255);
#line 3032
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((int )((unsigned short )offset) & 255);
#line 3033
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char )(((int )((unsigned short )reqbytes) >> 8) & 255);
#line 3033
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char )((int )((unsigned short )reqbytes) & 255);
#line 3035
  result = dlp_exec(sd, req, & res);
#line 3037
  dlp_request_free(req);
  }
#line 3039
  if (result >= 0) {
#line 3040
    if (result < 2) {
#line 3041
      data_len = -305;
    } else {
#line 3043
      data_len = (int )((*(res->argv + 0))->len - 2UL);
#line 3044
      if (retbuf) {
        {
#line 3045
        pi_buffer_append(retbuf, (void const   *)((*(res->argv + 0))->data + 2), (size_t )data_len);
        }
      }
      {
#line 3048
      pi_log(16, 4, "DLP ReadSortBlock %d bytes\n", data_len);
      }
      {
#line 3050
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 3050
        tmp___0 = pi_debug_get_types();
        }
#line 3050
        if (tmp___0 & 16) {
          {
#line 3050
          tmp___1 = pi_debug_get_level();
          }
#line 3050
          if (tmp___1 >= 8) {
            {
#line 3050
            pi_dumpdata((char const   *)((*(res->argv + 0))->data + 2), (size_t )data_len);
            }
          }
        }
#line 3050
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
#line 3055
    data_len = result;
  }
  {
#line 3058
  dlp_response_free(res);
  }
#line 3060
  return (data_len);
}
}
#line 3063 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_WriteSortBlock(int sd , int dbhandle , void const   *data , size_t length ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp ;

  {
  {
#line 3071
  pi_log(16, 4, "DLP sd=%d %s \"length=%ld\"\n", sd, "dlp_WriteSortBlock", length);
#line 3072
  pi_reset_errors(sd);
#line 3074
  req = dlp_request_new((enum dlpFunctions )30, 1, 4UL + length);
  }
#line 3075
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 3076
    tmp = pi_set_error(sd, -500);
    }
#line 3076
    return (tmp);
  }
#line 3078
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 3079
  *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char)0;
#line 3080
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )(((int )((unsigned short )length) >> 8) & 255);
#line 3080
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((int )((unsigned short )length) & 255);
#line 3082
  if (length + 10UL > 65535UL) {
    {
#line 3083
    pi_log(16, 1, "DLP WriteSortBlock: data too large (>64k)");
#line 3085
    pi_set_error(sd, -304);
    }
#line 3086
    return (-131);
  }
  {
#line 3088
  memcpy((void */* __restrict  */)((*(req->argv + 0))->data + 4), (void const   */* __restrict  */)data,
         length);
#line 3090
  result = dlp_exec(sd, req, & res);
#line 3092
  dlp_request_free(req);
#line 3093
  dlp_response_free(res);
  }
#line 3095
  return (result);
}
}
#line 3098 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_CleanUpDatabase(int sd , int dbhandle ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp ;

  {
  {
#line 3105
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_CleanUpDatabase");
#line 3106
  pi_reset_errors(sd);
#line 3108
  req = dlp_request_new((enum dlpFunctions )38, 1, 1);
  }
#line 3109
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 3110
    tmp = pi_set_error(sd, -500);
    }
#line 3110
    return (tmp);
  }
  {
#line 3112
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 3114
  result = dlp_exec(sd, req, & res);
#line 3116
  dlp_request_free(req);
#line 3117
  dlp_response_free(res);
  }
#line 3119
  return (result);
}
}
#line 3122 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ResetSyncFlags(int sd , int dbhandle ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp ;

  {
  {
#line 3129
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dpl_ResetSyncFlags");
#line 3130
  pi_reset_errors(sd);
#line 3132
  req = dlp_request_new((enum dlpFunctions )39, 1, 1);
  }
#line 3133
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 3134
    tmp = pi_set_error(sd, -500);
    }
#line 3134
    return (tmp);
  }
  {
#line 3136
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 3138
  result = dlp_exec(sd, req, & res);
#line 3140
  dlp_request_free(req);
#line 3141
  dlp_response_free(res);
  }
#line 3143
  return (result);
}
}
#line 3146 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ReadNextRecInCategory(int sd , int dbhandle , int category , pi_buffer_t *buffer ,
                              recordid_t *recuid , int *recindex , int *attr ) 
{ 
  int result ;
  int data_len ;
  int flags ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int cat ;
  int rec ;
  pi_socket_t *ps ;
  int *tmp ;
  PI_ERR tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 3157
  pi_log(16, 4, "DLP sd=%d %s \"category=%d\"\n", sd, "dlp_ReadNextRecInCategory",
         category);
#line 3158
  pi_reset_errors(sd);
#line 3160
  tmp___0 = pi_version(sd);
  }
#line 3160
  if (tmp___0 < 257) {
    {
#line 3166
    pi_log(16, 4, "DLP ReadNextRecInCategory Emulating with: Handle: %d, Category: %d\n",
           dbhandle, category);
#line 3171
    ps = find_pi_socket(sd);
    }
#line 3171
    if ((unsigned long )ps == (unsigned long )((pi_socket_t *)0)) {
      {
#line 3172
      tmp = __errno_location();
#line 3172
      *tmp = 3;
      }
#line 3173
      return (-130);
    }
    {
#line 3176
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 3178
      rec = dlp_ReadRecordByIndex(sd, dbhandle, ps->dlprecord, (pi_buffer_t *)0, (recordid_t *)0,
                                  (int *)0, & cat);
      }
#line 3182
      if (rec < 0) {
#line 3183
        goto while_break;
      }
#line 3185
      if (cat != category) {
#line 3186
        (ps->dlprecord) ++;
#line 3187
        goto __Cont;
      }
      {
#line 3190
      rec = dlp_ReadRecordByIndex(sd, dbhandle, ps->dlprecord, buffer, recuid, attr,
                                  & cat);
      }
#line 3194
      if (rec >= 0) {
#line 3195
        if (recindex) {
#line 3196
          *recindex = ps->dlprecord;
        }
#line 3197
        (ps->dlprecord) ++;
      }
#line 3209
      goto while_break;
      __Cont: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 3212
    return (rec);
  }
  {
#line 3215
  req = dlp_request_new((enum dlpFunctions )50, 1, 2);
  }
#line 3216
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 3217
    tmp___1 = pi_set_error(sd, -500);
    }
#line 3217
    return (tmp___1);
  }
  {
#line 3219
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 3220
  *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char )category;
#line 3222
  result = dlp_exec(sd, req, & res);
#line 3224
  dlp_request_free(req);
  }
#line 3226
  if (result > 0) {
#line 3227
    data_len = (int )((*(res->argv + 0))->len - 10UL);
#line 3228
    if (recuid) {
#line 3229
      *recuid = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3);
    }
#line 3230
    if (recindex) {
#line 3231
      *recindex = (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 1)));
    }
#line 3232
    if (attr) {
#line 3233
      *attr = (int )*((unsigned char *)((*(res->argv + 0))->data + 8) + 0);
    }
#line 3234
    if (buffer) {
      {
#line 3235
      pi_buffer_clear(buffer);
#line 3236
      pi_buffer_append(buffer, (void const   *)((*(res->argv + 0))->data + 10), (size_t )data_len);
      }
    }
#line 3240
    flags = (int )*((unsigned char *)((*(res->argv + 0))->data + 8) + 0);
#line 3241
    if (! flags) {
#line 3241
      tmp___2 = " None";
    } else {
#line 3241
      tmp___2 = "";
    }
#line 3241
    if (flags & 8) {
#line 3241
      tmp___3 = " Archive";
    } else {
#line 3241
      tmp___3 = "";
    }
#line 3241
    if (flags & 16) {
#line 3241
      tmp___4 = " Secret";
    } else {
#line 3241
      tmp___4 = "";
    }
#line 3241
    if (flags & 32) {
#line 3241
      tmp___5 = " Busy";
    } else {
#line 3241
      tmp___5 = "";
    }
#line 3241
    if (flags & 64) {
#line 3241
      tmp___6 = " Dirty";
    } else {
#line 3241
      tmp___6 = "";
    }
#line 3241
    if (flags & 128) {
#line 3241
      tmp___7 = " Deleted";
    } else {
#line 3241
      tmp___7 = "";
    }
    {
#line 3241
    pi_log(16, 4, "DLP ReadNextRecInCategory ID: 0x%8.8lX, Index: %d, Category: %d\n  Flags: %s%s%s%s%s%s (0x%2.2X) and %d bytes:\n",
           ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3),
           (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 1))),
           (int )*((unsigned char *)((*(res->argv + 0))->data + 9) + 0), tmp___7,
           tmp___6, tmp___5, tmp___4, tmp___3, tmp___2, flags, data_len);
    }
    {
#line 3256
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 3256
      tmp___8 = pi_debug_get_types();
      }
#line 3256
      if (tmp___8 & 16) {
        {
#line 3256
        tmp___9 = pi_debug_get_level();
        }
#line 3256
        if (tmp___9 >= 8) {
          {
#line 3256
          pi_dumpdata((char const   *)((*(res->argv + 0))->data + 10), (size_t )data_len);
          }
        }
      }
#line 3256
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 3260
    data_len = result;
  }
  {
#line 3263
  dlp_response_free(res);
  }
#line 3265
  return (data_len);
}
}
#line 3268 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ReadAppPreference(int sd , unsigned long creator , int prefID , int backup ,
                          int maxsize , void *buffer , size_t *size , int *version ) 
{ 
  int result ;
  int data_len ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int db ;
  pi_buffer_t *buf___3 ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int err1 ;
  int tmp___2 ;
  int err2 ;
  int tmp___3 ;
  PI_ERR tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 3277
  pi_log(16, 4, "DLP sd=%d %s \"creator=\'%4.4s\' prefID=%d backup=%d maxsize=%d\"\n",
         sd, "dlp_ReadAppPreference", (char const   *)creator, prefID, backup, maxsize);
#line 3279
  pi_reset_errors(sd);
#line 3281
  tmp___4 = pi_version(sd);
  }
#line 3281
  if (tmp___4 < 257) {
#line 3286
    if (backup) {
#line 3286
      tmp = 128;
    } else {
#line 3286
      tmp = 0;
    }
#line 3286
    if (buffer) {
#line 3286
      tmp___0 = maxsize;
    } else {
#line 3286
      tmp___0 = 0;
    }
    {
#line 3286
    tmp___1 = printlong(creator);
#line 3286
    pi_log(16, 4, "DLP ReadAppPreference Emulating with: Creator: \'%s\', Id: %d, Size: %d, Backup: %d\n",
           tmp___1, prefID, tmp___0, tmp);
#line 3292
    result = dlp_OpenDB(sd, 0, 128, "System Preferences", & db);
    }
#line 3293
    if (result < 0) {
#line 3294
      return (result);
    }
    {
#line 3296
    buf___3 = pi_buffer_new((size_t )1024);
#line 3298
    result = dlp_ReadResourceByType(sd, db, creator, prefID, buf___3, (int *)((void *)0));
    }
#line 3300
    if (result < 0) {
      {
#line 3302
      tmp___2 = pi_error(sd);
#line 3302
      err1 = tmp___2;
#line 3303
      tmp___3 = pi_palmos_error(sd);
#line 3303
      err2 = tmp___3;
#line 3305
      pi_buffer_free(buf___3);
      }
#line 3306
      if (err1 != -200) {
        {
#line 3307
        dlp_CloseDB(sd, db);
        }
      }
      {
#line 3309
      pi_set_error(sd, err1);
#line 3310
      pi_set_palmos_error(sd, err2);
      }
#line 3311
      return (result);
    }
#line 3314
    if (size) {
#line 3315
      *size = buf___3->used - 2UL;
    }
#line 3317
    if (version) {
#line 3318
      *version = (int )((unsigned short )(((int )*(buf___3->data + 0) << 8) | (int )*(buf___3->data + 1)));
    }
#line 3320
    if (result > 2) {
      {
#line 3321
      result -= 2;
#line 3322
      memcpy((void */* __restrict  */)buffer, (void const   */* __restrict  */)(buf___3->data + 2),
             (size_t )result);
      }
    } else {
#line 3324
      result = 0;
    }
    {
#line 3327
    pi_buffer_free(buf___3);
#line 3328
    dlp_CloseDB(sd, db);
    }
#line 3329
    return (result);
  }
  {
#line 3332
  req = dlp_request_new((enum dlpFunctions )52, 1, 10);
  }
#line 3333
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 3334
    tmp___5 = pi_set_error(sd, -500);
    }
#line 3334
    return (tmp___5);
  }
#line 3336
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )((int )((unsigned char )(creator >> 24)) & 255);
#line 3336
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((creator >> 16) & 255UL);
#line 3336
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 2) = (unsigned char )((creator >> 8) & 255UL);
#line 3336
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 3) = (unsigned char )(creator & 255UL);
#line 3337
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char )(((int )((unsigned short )prefID) >> 8) & 255);
#line 3337
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char )((int )((unsigned short )prefID) & 255);
#line 3338
  if (buffer) {
#line 3338
    tmp___6 = maxsize;
  } else {
#line 3338
    tmp___6 = 0;
  }
#line 3338
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 0) = (unsigned char )(((int )((unsigned short )tmp___6) >> 8) & 255);
#line 3338
  if (buffer) {
#line 3338
    tmp___7 = maxsize;
  } else {
#line 3338
    tmp___7 = 0;
  }
#line 3338
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 1) = (unsigned char )((int )((unsigned short )tmp___7) & 255);
#line 3339
  if (backup) {
#line 3339
    *((unsigned char *)((*(req->argv + 0))->data + 8) + 0) = (unsigned char)128;
  } else {
#line 3339
    *((unsigned char *)((*(req->argv + 0))->data + 8) + 0) = (unsigned char)0;
  }
  {
#line 3340
  *((unsigned char *)((*(req->argv + 0))->data + 9) + 0) = (unsigned char)0;
#line 3342
  result = dlp_exec(sd, req, & res);
#line 3344
  dlp_request_free(req);
  }
#line 3346
  if (result > 0) {
#line 3347
    data_len = (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 1)));
#line 3348
    if (version) {
#line 3349
      *version = (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1)));
    }
#line 3350
    if (size) {
#line 3350
      if (! buffer) {
#line 3350
        *size = (size_t )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 2) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 2) + 1)));
      }
    }
#line 3352
    if (size) {
#line 3352
      if (buffer) {
#line 3353
        *size = (size_t )data_len;
      }
    }
#line 3354
    if (buffer) {
      {
#line 3355
      memcpy((void */* __restrict  */)buffer, (void const   */* __restrict  */)((*(res->argv + 0))->data + 6),
             (size_t )data_len);
      }
    }
    {
#line 3358
    pi_log(16, 4, "DLP ReadAppPref Version: %d, Total size: %d, Read %d bytes:\n",
           (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1))),
           (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 2) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 2) + 1))),
           (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 1))));
    }
    {
#line 3364
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 3364
      tmp___8 = pi_debug_get_types();
      }
#line 3364
      if (tmp___8 & 16) {
        {
#line 3364
        tmp___9 = pi_debug_get_level();
        }
#line 3364
        if (tmp___9 >= 8) {
          {
#line 3364
          pi_dumpdata((char const   *)((*(res->argv + 0))->data + 6), (size_t )data_len);
          }
        }
      }
#line 3364
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 3368
    data_len = result;
  }
  {
#line 3371
  dlp_response_free(res);
  }
#line 3373
  return (data_len);
}
}
#line 3376 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_WriteAppPreference(int sd , unsigned long creator , int prefID , int backup ,
                           int version , void const   *buffer , size_t size ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int db ;
  int err1 ;
  int err2 ;
  unsigned char dlp_buf[65535] ;
  PI_ERR tmp ;
  int tmp___0 ;

  {
  {
#line 3384
  pi_log(16, 4, "DLP sd=%d %s \"creator=\'%4.4s\' prefID=%d backup=%d version=%d size=%ld\"\n",
         sd, "dlp_WriteAppPreference", (char const   *)(& creator), prefID, backup,
         version, size);
#line 3386
  pi_reset_errors(sd);
#line 3388
  tmp = pi_version(sd);
  }
#line 3388
  if (tmp < 257) {
    {
#line 3394
    result = dlp_OpenDB(sd, 0, 64, "System Preferences", & db);
    }
#line 3394
    if (result < 0) {
#line 3396
      return (result);
    }
#line 3398
    if (buffer) {
#line 3398
      if (size) {
        {
#line 3400
        memcpy((void */* __restrict  */)(dlp_buf + 2), (void const   */* __restrict  */)buffer,
               size);
#line 3401
        dlp_buf[0] = (unsigned char )(((int )((unsigned short )version) >> 8) & 255);
#line 3401
        dlp_buf[1] = (unsigned char )((int )((unsigned short )version) & 255);
#line 3402
        result = dlp_WriteResource(sd, db, creator, prefID, (void const   *)(dlp_buf),
                                   size);
        }
      } else {
        {
#line 3405
        result = dlp_WriteResource(sd, db, creator, prefID, (void const   *)((void *)0),
                                   (size_t )0);
        }
      }
    } else {
      {
#line 3405
      result = dlp_WriteResource(sd, db, creator, prefID, (void const   *)((void *)0),
                                 (size_t )0);
      }
    }
    {
#line 3408
    err1 = pi_error(sd);
#line 3409
    err2 = pi_palmos_error(sd);
    }
#line 3411
    if (err1 != -200) {
      {
#line 3412
      dlp_CloseDB(sd, db);
      }
    }
#line 3414
    if (result < 0) {
      {
#line 3416
      pi_set_error(sd, err1);
#line 3417
      pi_set_palmos_error(sd, err2);
      }
    }
#line 3419
    return (result);
  }
  {
#line 3422
  req = dlp_request_new((enum dlpFunctions )53, 1, 12UL + size);
  }
#line 3423
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 3424
    tmp___0 = pi_set_error(sd, -500);
    }
#line 3424
    return (tmp___0);
  }
#line 3426
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )((int )((unsigned char )(creator >> 24)) & 255);
#line 3426
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((creator >> 16) & 255UL);
#line 3426
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 2) = (unsigned char )((creator >> 8) & 255UL);
#line 3426
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 3) = (unsigned char )(creator & 255UL);
#line 3427
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char )(((int )((unsigned short )prefID) >> 8) & 255);
#line 3427
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char )((int )((unsigned short )prefID) & 255);
#line 3428
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 0) = (unsigned char )(((int )((unsigned short )version) >> 8) & 255);
#line 3428
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 1) = (unsigned char )((int )((unsigned short )version) & 255);
#line 3429
  *((unsigned char *)((*(req->argv + 0))->data + 8) + 0) = (unsigned char )(((int )((unsigned short )size) >> 8) & 255);
#line 3429
  *((unsigned char *)((*(req->argv + 0))->data + 8) + 1) = (unsigned char )((int )((unsigned short )size) & 255);
#line 3430
  if (backup) {
#line 3430
    *((unsigned char *)((*(req->argv + 0))->data + 10) + 0) = (unsigned char)128;
  } else {
#line 3430
    *((unsigned char *)((*(req->argv + 0))->data + 10) + 0) = (unsigned char)0;
  }
#line 3431
  *((unsigned char *)((*(req->argv + 0))->data + 11) + 0) = (unsigned char)0;
#line 3433
  if (size + 12UL > 65535UL) {
    {
#line 3434
    pi_log(16, 1, "DLP WriteAppPreferenceV2: data too large (>64k)");
    }
#line 3436
    return (-304);
  }
  {
#line 3438
  memcpy((void */* __restrict  */)((*(req->argv + 0))->data + 12), (void const   */* __restrict  */)buffer,
         size);
#line 3440
  result = dlp_exec(sd, req, & res);
#line 3442
  dlp_request_free(req);
#line 3443
  dlp_response_free(res);
  }
#line 3445
  return (result);
}
}
#line 3448 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ReadNextModifiedRecInCategory(int sd , int dbhandle , int category , pi_buffer_t *buffer ,
                                      recordid_t *recID , int *recindex , int *attr ) 
{ 
  int result ;
  int data_len ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int cat ;
  PI_ERR tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 3458
  pi_log(16, 4, "DLP sd=%d %s \"category=%d\"\n", sd, "dlp_ReadNextModifiedRecInCategory",
         category);
#line 3459
  pi_reset_errors(sd);
#line 3461
  tmp = pi_version(sd);
  }
#line 3461
  if (tmp < 257) {
    {
#line 3465
    pi_log(16, 4, "DLP ReadNextModifiedRecInCategory Emulating with: Handle: %d, Category: %d\n",
           dbhandle, category);
    }
    {
#line 3470
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 3472
      result = dlp_ReadNextModifiedRec(sd, dbhandle, buffer, recID, recindex, attr,
                                       & cat);
      }
#line 3470
      if (result >= 0) {
#line 3470
        if (! (cat != category)) {
#line 3470
          goto while_break;
        }
      } else {
#line 3470
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3490
    return (result);
  }
  {
#line 3493
  req = dlp_request_new((enum dlpFunctions )51, 1, 2);
  }
#line 3494
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 3495
    tmp___0 = pi_set_error(sd, -500);
    }
#line 3495
    return (tmp___0);
  }
  {
#line 3497
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 3498
  *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char )category;
#line 3500
  result = dlp_exec(sd, req, & res);
#line 3502
  dlp_request_free(req);
  }
#line 3504
  if (result > 0) {
#line 3505
    data_len = (int )((*(res->argv + 0))->len - 10UL);
#line 3507
    if (recID) {
#line 3508
      *recID = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3);
    }
#line 3509
    if (recindex) {
#line 3510
      *recindex = (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 1)));
    }
#line 3511
    if (attr) {
#line 3512
      *attr = (int )*((unsigned char *)((*(res->argv + 0))->data + 8) + 0);
    }
#line 3514
    if (buffer) {
      {
#line 3515
      pi_buffer_clear(buffer);
#line 3516
      pi_buffer_append(buffer, (void const   *)((*(res->argv + 0))->data + 10), (size_t )data_len);
      }
    }
    {
#line 3520
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 3520
      tmp___1 = pi_debug_get_types();
      }
#line 3520
      if (tmp___1 & 16) {
        {
#line 3520
        tmp___2 = pi_debug_get_level();
        }
#line 3520
        if (tmp___2 >= 8) {
          {
#line 3520
          record_dump(((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3),
                      (unsigned int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 1))),
                      (int )*((unsigned char *)((*(res->argv + 0))->data + 8) + 0),
                      (int )*((unsigned char *)((*(res->argv + 0))->data + 9) + 0),
                      (char const   *)((*(res->argv + 0))->data + 10), data_len);
          }
        }
      }
#line 3520
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 3528
    data_len = result;
  }
  {
#line 3531
  dlp_response_free(res);
  }
#line 3533
  return (data_len);
}
}
#line 3536 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ReadNextModifiedRec(int sd , int dbhandle , pi_buffer_t *buffer , recordid_t *recID ,
                            int *recindex , int *attr , int *category ) 
{ 
  int result ;
  int data_len ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 3545
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_ReadNextModifiedRec");
#line 3546
  pi_reset_errors(sd);
#line 3548
  req = dlp_request_new((enum dlpFunctions )31, 1, 1);
  }
#line 3549
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 3550
    tmp = pi_set_error(sd, -500);
    }
#line 3550
    return (tmp);
  }
  {
#line 3552
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 3554
  result = dlp_exec(sd, req, & res);
#line 3556
  dlp_request_free(req);
  }
#line 3558
  if (result >= 0) {
#line 3559
    data_len = (int )((*(res->argv + 0))->len - 10UL);
#line 3560
    if (recID) {
#line 3561
      *recID = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3);
    }
#line 3562
    if (recindex) {
#line 3563
      *recindex = (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 1)));
    }
#line 3564
    if (attr) {
#line 3565
      *attr = (int )*((unsigned char *)((*(res->argv + 0))->data + 8) + 0);
    }
#line 3566
    if (category) {
#line 3567
      *category = (int )*((unsigned char *)((*(res->argv + 0))->data + 9) + 0);
    }
#line 3569
    if (buffer) {
      {
#line 3570
      pi_buffer_clear(buffer);
#line 3571
      pi_buffer_append(buffer, (void const   *)((*(res->argv + 0))->data + 10), (size_t )data_len);
      }
    }
    {
#line 3575
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 3575
      tmp___0 = pi_debug_get_types();
      }
#line 3575
      if (tmp___0 & 16) {
        {
#line 3575
        tmp___1 = pi_debug_get_level();
        }
#line 3575
        if (tmp___1 >= 8) {
          {
#line 3575
          record_dump(((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3),
                      (unsigned int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 1))),
                      (int )*((unsigned char *)((*(res->argv + 0))->data + 8) + 0),
                      (int )*((unsigned char *)((*(res->argv + 0))->data + 9) + 0),
                      (char const   *)((*(res->argv + 0))->data + 10), data_len);
          }
        }
      }
#line 3575
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 3583
    data_len = result;
  }
  {
#line 3586
  dlp_response_free(res);
  }
#line 3588
  return (data_len);
}
}
#line 3591 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ReadRecordById(int sd , int dbhandle , recordid_t recuid , pi_buffer_t *buffer ,
                       int *recindex , int *attr , int *category ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int maxBufferSize ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 3598
  tmp = pi_maxrecsize(sd);
#line 3598
  maxBufferSize = (int )(tmp - 100UL);
#line 3600
  pi_log(16, 4, "DLP sd=%d %s \"recuid=0x%08lx\"\n", sd, "dlp_ReadRecordById", recuid);
#line 3601
  pi_reset_errors(sd);
#line 3603
  req = dlp_request_new((enum dlpFunctions )32, 1, 10);
  }
#line 3604
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 3605
    tmp___0 = pi_set_error(sd, -500);
    }
#line 3605
    return (tmp___0);
  }
#line 3607
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 3608
  *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char)0;
#line 3609
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )((int )((unsigned char )(recuid >> 24)) & 255);
#line 3609
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((recuid >> 16) & 255UL);
#line 3609
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 2) = (unsigned char )((recuid >> 8) & 255UL);
#line 3609
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 3) = (unsigned char )(recuid & 255UL);
#line 3610
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 0) = (unsigned char)0;
#line 3610
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 1) = (unsigned char)0;
#line 3611
  if (buffer) {
#line 3611
    tmp___1 = maxBufferSize;
  } else {
#line 3611
    tmp___1 = 0;
  }
#line 3611
  *((unsigned char *)((*(req->argv + 0))->data + 8) + 0) = (unsigned char )(((int )((unsigned short )tmp___1) >> 8) & 255);
#line 3611
  if (buffer) {
#line 3611
    tmp___2 = maxBufferSize;
  } else {
#line 3611
    tmp___2 = 0;
  }
  {
#line 3611
  *((unsigned char *)((*(req->argv + 0))->data + 8) + 1) = (unsigned char )((int )((unsigned short )tmp___2) & 255);
#line 3613
  result = dlp_exec(sd, req, & res);
#line 3615
  dlp_request_free(req);
  }
#line 3617
  if (result > 0) {
#line 3618
    result = (int )((*(res->argv + 0))->len - 10UL);
#line 3619
    if (recindex) {
#line 3620
      *recindex = (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 1)));
    }
#line 3621
    if (attr) {
#line 3622
      *attr = (int )*((unsigned char *)((*(res->argv + 0))->data + 8) + 0);
    }
#line 3623
    if (category) {
#line 3624
      *category = (int )*((unsigned char *)((*(res->argv + 0))->data + 9) + 0);
    }
#line 3625
    if (buffer) {
      {
#line 3626
      pi_buffer_clear(buffer);
#line 3627
      pi_buffer_append(buffer, (void const   *)((*(res->argv + 0))->data + 10), (size_t )result);
      }
#line 3634
      if (result == maxBufferSize) {
        {
#line 3635
        dlp_response_free(res);
#line 3636
        req = dlp_request_new((enum dlpFunctions )32, 1, 10);
        }
#line 3637
        if ((unsigned long )req != (unsigned long )((void *)0)) {
#line 3638
          *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 3639
          *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char)0;
#line 3640
          *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )((int )((unsigned char )(recuid >> 24)) & 255);
#line 3640
          *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((recuid >> 16) & 255UL);
#line 3640
          *((unsigned char *)((*(req->argv + 0))->data + 2) + 2) = (unsigned char )((recuid >> 8) & 255UL);
#line 3640
          *((unsigned char *)((*(req->argv + 0))->data + 2) + 3) = (unsigned char )(recuid & 255UL);
#line 3641
          *((unsigned char *)((*(req->argv + 0))->data + 6) + 0) = (unsigned char )(((int )((unsigned short )maxBufferSize) >> 8) & 255);
#line 3641
          *((unsigned char *)((*(req->argv + 0))->data + 6) + 1) = (unsigned char )((int )((unsigned short )maxBufferSize) & 255);
#line 3642
          if (buffer) {
#line 3642
            tmp___3 = 100;
          } else {
#line 3642
            tmp___3 = 0;
          }
#line 3642
          *((unsigned char *)((*(req->argv + 0))->data + 8) + 0) = (unsigned char )(((int )((unsigned short )tmp___3) >> 8) & 255);
#line 3642
          if (buffer) {
#line 3642
            tmp___4 = 100;
          } else {
#line 3642
            tmp___4 = 0;
          }
          {
#line 3642
          *((unsigned char *)((*(req->argv + 0))->data + 8) + 1) = (unsigned char )((int )((unsigned short )tmp___4) & 255);
#line 3644
          result = dlp_exec(sd, req, & res);
#line 3645
          dlp_request_free(req);
          }
#line 3647
          if (result > 0) {
            {
#line 3648
            result = (int )((*(res->argv + 0))->len - 10UL);
#line 3649
            pi_buffer_append(buffer, (void const   *)((*(res->argv + 0))->data + 10),
                             (size_t )result);
#line 3651
            result += maxBufferSize;
            }
          }
        }
      }
    }
    {
#line 3657
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 3657
      tmp___5 = pi_debug_get_types();
      }
#line 3657
      if (tmp___5 & 16) {
        {
#line 3657
        tmp___6 = pi_debug_get_level();
        }
#line 3657
        if (tmp___6 >= 8) {
          {
#line 3657
          record_dump(((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3),
                      (unsigned int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 1))),
                      (int )*((unsigned char *)((*(res->argv + 0))->data + 8) + 0),
                      (int )*((unsigned char *)((*(res->argv + 0))->data + 9) + 0),
                      (char const   *)((*(res->argv + 0))->data + 10), result);
          }
        }
      }
#line 3657
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 3666
  dlp_response_free(res);
  }
#line 3668
  return (result);
}
}
#line 3671 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ReadRecordByIndex(int sd , int dbhandle , int recindex , pi_buffer_t *buffer ,
                          recordid_t *recuid , int *attr , int *category ) 
{ 
  int result ;
  int large ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  int maxBufferSize ;
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  PI_ERR tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
  {
#line 3675
  large = 0;
#line 3679
  tmp = pi_maxrecsize(sd);
#line 3679
  maxBufferSize = (int )(tmp - 100UL);
#line 3681
  pi_log(16, 4, "DLP sd=%d %s \"recindex=%d\"\n", sd, "dlp_ReadRecordByIndex", recindex);
#line 3682
  pi_reset_errors(sd);
#line 3687
  tmp___8 = pi_version(sd);
  }
#line 3687
  if (tmp___8 >= 260) {
    {
#line 3688
    req = dlp_request_new_with_argid((enum dlpFunctions )96, 33, 1, 12);
    }
#line 3689
    if ((unsigned long )req == (unsigned long )((void *)0)) {
      {
#line 3690
      tmp___0 = pi_set_error(sd, -500);
      }
#line 3690
      return (tmp___0);
    }
    {
#line 3692
    *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 3693
    *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char)0;
#line 3694
    *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )(((int )((unsigned short )recindex) >> 8) & 255);
#line 3694
    *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((int )((unsigned short )recindex) & 255);
#line 3695
    *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char)0;
#line 3695
    *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char)0;
#line 3695
    *((unsigned char *)((*(req->argv + 0))->data + 4) + 2) = (unsigned char)0;
#line 3695
    *((unsigned char *)((*(req->argv + 0))->data + 4) + 3) = (unsigned char)0;
#line 3696
    tmp___1 = pi_maxrecsize(sd);
#line 3696
    *((unsigned char *)((*(req->argv + 0))->data + 8) + 0) = (unsigned char )((int )((unsigned char )(tmp___1 >> 24)) & 255);
#line 3696
    tmp___2 = pi_maxrecsize(sd);
#line 3696
    *((unsigned char *)((*(req->argv + 0))->data + 8) + 1) = (unsigned char )((tmp___2 >> 16) & 255UL);
#line 3696
    tmp___3 = pi_maxrecsize(sd);
#line 3696
    *((unsigned char *)((*(req->argv + 0))->data + 8) + 2) = (unsigned char )((tmp___3 >> 8) & 255UL);
#line 3696
    tmp___4 = pi_maxrecsize(sd);
#line 3696
    *((unsigned char *)((*(req->argv + 0))->data + 8) + 3) = (unsigned char )(tmp___4 & 255UL);
#line 3697
    large = 1;
    }
  } else {
    {
#line 3699
    req = dlp_request_new_with_argid((enum dlpFunctions )32, 33, 1, 8);
    }
#line 3700
    if ((unsigned long )req == (unsigned long )((void *)0)) {
      {
#line 3701
      tmp___5 = pi_set_error(sd, -500);
      }
#line 3701
      return (tmp___5);
    }
#line 3703
    *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 3704
    *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char)0;
#line 3705
    *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )(((int )((unsigned short )recindex) >> 8) & 255);
#line 3705
    *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((int )((unsigned short )recindex) & 255);
#line 3706
    *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char)0;
#line 3706
    *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char)0;
#line 3707
    if (buffer) {
#line 3707
      tmp___6 = maxBufferSize;
    } else {
#line 3707
      tmp___6 = 0;
    }
#line 3707
    *((unsigned char *)((*(req->argv + 0))->data + 6) + 0) = (unsigned char )(((int )((unsigned short )tmp___6) >> 8) & 255);
#line 3707
    if (buffer) {
#line 3707
      tmp___7 = maxBufferSize;
    } else {
#line 3707
      tmp___7 = 0;
    }
#line 3707
    *((unsigned char *)((*(req->argv + 0))->data + 6) + 1) = (unsigned char )((int )((unsigned short )tmp___7) & 255);
  }
  {
#line 3709
  result = dlp_exec(sd, req, & res);
#line 3710
  dlp_request_free(req);
  }
#line 3712
  if (result > 0) {
#line 3713
    if (large) {
#line 3713
      tmp___9 = 14;
    } else {
#line 3713
      tmp___9 = 10;
    }
#line 3713
    result = (int )((*(res->argv + 0))->len - (size_t )tmp___9);
#line 3714
    if (recuid) {
#line 3715
      *recuid = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3);
    }
#line 3716
    if (attr) {
#line 3717
      if (large) {
#line 3717
        tmp___10 = 12;
      } else {
#line 3717
        tmp___10 = 8;
      }
#line 3717
      *attr = (int )*((unsigned char *)((*(res->argv + 0))->data + tmp___10) + 0);
    }
#line 3718
    if (category) {
#line 3719
      if (large) {
#line 3719
        tmp___11 = 13;
      } else {
#line 3719
        tmp___11 = 9;
      }
#line 3719
      *category = (int )*((unsigned char *)((*(res->argv + 0))->data + tmp___11) + 0);
    }
#line 3720
    if (buffer) {
      {
#line 3721
      pi_buffer_clear(buffer);
      }
#line 3722
      if (large) {
#line 3722
        tmp___12 = 14;
      } else {
#line 3722
        tmp___12 = 10;
      }
      {
#line 3722
      pi_buffer_append(buffer, (void const   *)((*(res->argv + 0))->data + tmp___12),
                       (size_t )result);
      }
#line 3729
      if (result == maxBufferSize) {
#line 3729
        if (! large) {
          {
#line 3730
          dlp_response_free(res);
#line 3731
          req = dlp_request_new_with_argid((enum dlpFunctions )32, 33, 1, 8);
          }
#line 3732
          if ((unsigned long )req != (unsigned long )((void *)0)) {
#line 3733
            *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )dbhandle;
#line 3734
            *((unsigned char *)((*(req->argv + 0))->data + 1) + 0) = (unsigned char)0;
#line 3735
            *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )(((int )((unsigned short )recindex) >> 8) & 255);
#line 3735
            *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((int )((unsigned short )recindex) & 255);
#line 3736
            *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char )(((int )((unsigned short )maxBufferSize) >> 8) & 255);
#line 3736
            *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char )((int )((unsigned short )maxBufferSize) & 255);
#line 3737
            if (buffer) {
#line 3737
              tmp___13 = 100;
            } else {
#line 3737
              tmp___13 = 0;
            }
#line 3737
            *((unsigned char *)((*(req->argv + 0))->data + 6) + 0) = (unsigned char )(((int )((unsigned short )tmp___13) >> 8) & 255);
#line 3737
            if (buffer) {
#line 3737
              tmp___14 = 100;
            } else {
#line 3737
              tmp___14 = 0;
            }
            {
#line 3737
            *((unsigned char *)((*(req->argv + 0))->data + 6) + 1) = (unsigned char )((int )((unsigned short )tmp___14) & 255);
#line 3739
            result = dlp_exec(sd, req, & res);
#line 3740
            dlp_request_free(req);
            }
#line 3742
            if (result > 0) {
#line 3743
              if (large) {
#line 3743
                tmp___15 = 14;
              } else {
#line 3743
                tmp___15 = 10;
              }
#line 3743
              result = (int )((*(res->argv + 0))->len - (size_t )tmp___15);
#line 3744
              if (large) {
#line 3744
                tmp___16 = 14;
              } else {
#line 3744
                tmp___16 = 10;
              }
              {
#line 3744
              pi_buffer_append(buffer, (void const   *)((*(res->argv + 0))->data + tmp___16),
                               (size_t )result);
#line 3747
              result += maxBufferSize;
              }
            }
          }
        }
      }
    }
    {
#line 3753
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 3753
      tmp___20 = pi_debug_get_types();
      }
#line 3753
      if (tmp___20 & 16) {
        {
#line 3753
        tmp___21 = pi_debug_get_level();
        }
#line 3753
        if (tmp___21 >= 8) {
#line 3753
          if (large) {
#line 3753
            tmp___17 = 14;
          } else {
#line 3753
            tmp___17 = 10;
          }
#line 3753
          if (large) {
#line 3753
            tmp___18 = 13;
          } else {
#line 3753
            tmp___18 = 9;
          }
#line 3753
          if (large) {
#line 3753
            tmp___19 = 12;
          } else {
#line 3753
            tmp___19 = 8;
          }
          {
#line 3753
          record_dump(((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3),
                      (unsigned int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 1))),
                      (int )*((unsigned char *)((*(res->argv + 0))->data + tmp___19) + 0),
                      (int )*((unsigned char *)((*(res->argv + 0))->data + tmp___18) + 0),
                      (char const   *)((*(res->argv + 0))->data + tmp___17), result);
          }
        }
      }
#line 3753
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 3762
  dlp_response_free(res);
  }
#line 3764
  return (result);
}
}
#line 3767 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ExpSlotEnumerate(int sd , int *numSlots , int *slotRefs ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  int tmp___0 ;
  int slots ;
  int i ;

  {
  {
#line 3774
  tmp = pi_version(sd);
  }
#line 3774
  if (tmp < ((1 << 8) | 2)) {
#line 3774
    return (13);
  }
  {
#line 3775
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_ExpSlotEnumerate");
#line 3776
  pi_reset_errors(sd);
#line 3778
  req = dlp_request_new((enum dlpFunctions )60, 0);
  }
#line 3779
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 3780
    tmp___0 = pi_set_error(sd, -500);
    }
#line 3780
    return (tmp___0);
  }
  {
#line 3782
  result = dlp_exec(sd, req, & res);
#line 3784
  dlp_request_free(req);
  }
#line 3786
  if (result > 0) {
    {
#line 3789
    slots = (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1)));
#line 3791
    pi_log(16, 4, "DLP ExpSlotEnumerate %d\n", slots);
    }
#line 3794
    if (slots) {
#line 3795
      i = 0;
      {
#line 3795
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3795
        if (i < slots) {
#line 3795
          if (! (i < *numSlots)) {
#line 3795
            goto while_break;
          }
        } else {
#line 3795
          goto while_break;
        }
        {
#line 3796
        *(slotRefs + i) = (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + (2 + 2 * i)) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + (2 + 2 * i)) + 1)));
#line 3800
        pi_log(16, 4, "  %d Slot-Refnum %d\n", i, *(slotRefs + i));
#line 3795
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 3805
    *numSlots = slots;
  }
  {
#line 3808
  dlp_response_free(res);
  }
#line 3810
  return (result);
}
}
#line 3813 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ExpCardPresent(int sd , int slotRef ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  int tmp___0 ;

  {
  {
#line 3820
  tmp = pi_version(sd);
  }
#line 3820
  if (tmp < ((1 << 8) | 2)) {
#line 3820
    return (13);
  }
  {
#line 3821
  pi_log(16, 4, "DLP sd=%d %s \"slotRef=%d\"\n", sd, "dlp_ExpCardPresent", slotRef);
#line 3822
  pi_reset_errors(sd);
#line 3824
  req = dlp_request_new((enum dlpFunctions )61, 1, 2);
  }
#line 3825
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 3826
    tmp___0 = pi_set_error(sd, -500);
    }
#line 3826
    return (tmp___0);
  }
  {
#line 3828
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )(((int )((unsigned short )slotRef) >> 8) & 255);
#line 3828
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((int )((unsigned short )slotRef) & 255);
#line 3830
  result = dlp_exec(sd, req, & res);
#line 3832
  dlp_request_free(req);
#line 3833
  dlp_response_free(res);
  }
#line 3835
  return (result);
}
}
#line 3838 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ExpCardInfo(int sd , int slotRef , unsigned long *flags , int *numStrings ,
                    char **strings ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  int tmp___0 ;
  int i ;
  int len ;
  int sz ;
  char *p ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 3846
  tmp = pi_version(sd);
  }
#line 3846
  if (tmp < ((1 << 8) | 2)) {
#line 3846
    return (13);
  }
  {
#line 3847
  pi_log(16, 4, "DLP sd=%d %s \"slotRef=%d\"\n", sd, "dlp_ExpCardInfo", slotRef);
#line 3848
  pi_reset_errors(sd);
#line 3850
  req = dlp_request_new((enum dlpFunctions )62, 1, 2);
  }
#line 3851
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 3852
    tmp___0 = pi_set_error(sd, -500);
    }
#line 3852
    return (tmp___0);
  }
  {
#line 3854
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )(((int )((unsigned short )slotRef) >> 8) & 255);
#line 3854
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((int )((unsigned short )slotRef) & 255);
#line 3856
  result = dlp_exec(sd, req, & res);
#line 3858
  dlp_request_free(req);
  }
#line 3860
  if (result > 0) {
#line 3861
    *flags = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3);
#line 3862
    *numStrings = (int )*((unsigned char *)((*(res->argv + 0))->data + 4) + 0);
#line 3864
    if (strings) {
#line 3864
      if (*numStrings) {
#line 3865
        sz = 0;
#line 3866
        p = (*(res->argv + 0))->data + 8;
#line 3868
        i = 0;
        {
#line 3868
        while (1) {
          while_continue: /* CIL Label */ ;
#line 3868
          if (! (i < *numStrings)) {
#line 3868
            goto while_break;
          }
          {
#line 3869
          tmp___1 = strlen((char const   *)p);
#line 3869
          len = (int )(tmp___1 + 1UL);
#line 3868
          i ++;
#line 3868
          sz += len;
#line 3868
          p += len;
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 3871
        tmp___2 = malloc((size_t )sz);
#line 3871
        *strings = (char *)tmp___2;
        }
#line 3872
        if (*strings) {
          {
#line 3873
          memcpy((void */* __restrict  */)*strings, (void const   */* __restrict  */)((*(res->argv + 0))->data + 8),
                 (size_t )sz);
          }
        } else {
          {
#line 3875
          result = pi_set_error(sd, -500);
          }
        }
      }
    }
    {
#line 3878
    pi_log(16, 4, "DLP ExpCardInfo flags: 0x%08lx numStrings: %d\n", *flags, *numStrings);
    }
  }
  {
#line 3883
  dlp_response_free(res);
  }
#line 3885
  return (result);
}
}
#line 3888 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSGetDefaultDir(int sd , int volRefNum , char const   *type , char *dir ,
                         int *len ) 
{ 
  int result ;
  int buflen ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 3896
  tmp = pi_version(sd);
  }
#line 3896
  if (tmp < ((1 << 8) | 2)) {
#line 3896
    return (13);
  }
  {
#line 3897
  pi_log(16, 4, "DLP sd=%d %s \"volRefNum=%d\"\n", sd, "dlp_VFSGetDefaultDir", volRefNum);
#line 3898
  pi_reset_errors(sd);
#line 3900
  tmp___0 = strlen(type);
#line 3900
  req = dlp_request_new((enum dlpFunctions )64, 1, 2UL + (tmp___0 + 1UL));
  }
#line 3902
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 3903
    tmp___1 = pi_set_error(sd, -500);
    }
#line 3903
    return (tmp___1);
  }
  {
#line 3905
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )(((int )((unsigned short )volRefNum) >> 8) & 255);
#line 3905
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((int )((unsigned short )volRefNum) & 255);
#line 3906
  strcpy((char */* __restrict  */)((*(req->argv + 0))->data + 2), (char const   */* __restrict  */)type);
#line 3908
  result = dlp_exec(sd, req, & res);
#line 3910
  dlp_request_free(req);
  }
#line 3912
  if (result > 0) {
#line 3913
    buflen = (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1)));
#line 3915
    if (*len < buflen + 1) {
      {
#line 3916
      result = pi_set_error(sd, -300);
      }
    } else {
#line 3918
      if (buflen) {
        {
#line 3919
        strncpy((char */* __restrict  */)dir, (char const   */* __restrict  */)((*(res->argv + 0))->data + 2),
                (size_t )buflen);
        }
      } else {
#line 3922
        *(dir + 0) = (char )'\000';
      }
      {
#line 3924
      *len = buflen;
#line 3926
      pi_log(16, 4, "Default dir is %s\n", dir);
      }
    }
  }
  {
#line 3931
  dlp_response_free(res);
  }
#line 3933
  return (result);
}
}
#line 3936 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSImportDatabaseFromFile(int sd , int volRefNum , char const   *path , int *cardno ,
                                  unsigned long *localid ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 3944
  tmp = pi_version(sd);
  }
#line 3944
  if (tmp < ((1 << 8) | 2)) {
#line 3944
    return (13);
  }
  {
#line 3945
  pi_log(16, 4, "DLP sd=%d %s \"volRefNum=%d path=\'%s\'\"\n", sd, "dlp_VFSImportDatabaseFromFile",
         volRefNum, path);
#line 3946
  pi_reset_errors(sd);
#line 3948
  pi_log(16, 4, "Import file <%s>%d\n", path);
#line 3951
  tmp___0 = strlen(path);
#line 3951
  req = dlp_request_new((enum dlpFunctions )65, 1, 2UL + (tmp___0 + 1UL));
  }
#line 3953
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 3954
    tmp___1 = pi_set_error(sd, -500);
    }
#line 3954
    return (tmp___1);
  }
  {
#line 3956
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )(((int )((unsigned short )volRefNum) >> 8) & 255);
#line 3956
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((int )((unsigned short )volRefNum) & 255);
#line 3957
  strcpy((char */* __restrict  */)((*(req->argv + 0))->data + 2), (char const   */* __restrict  */)path);
#line 3959
  result = dlp_exec(sd, req, & res);
#line 3961
  dlp_request_free(req);
  }
#line 3963
  if (result > 0) {
#line 3964
    if (cardno) {
#line 3965
      *cardno = (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1)));
    }
#line 3966
    if (localid) {
#line 3967
      *localid = (unsigned long )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 2) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 2) + 1)));
    }
    {
#line 3969
    pi_log(16, 4, "Database imported as: cardNo:%d dbID:%d\n", (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1))),
           (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 2) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 2) + 1))));
    }
  }
  {
#line 3975
  dlp_response_free(res);
  }
#line 3977
  return (result);
}
}
#line 3980 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSExportDatabaseToFile(int sd , int volRefNum , char const   *path , int cardno ,
                                unsigned int localid ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 3988
  tmp = pi_version(sd);
  }
#line 3988
  if (tmp < ((1 << 8) | 2)) {
#line 3988
    return (13);
  }
  {
#line 3989
  pi_log(16, 4, "DLP sd=%d %s \"cardno=%d localid=0x%08lx volRefNum=%d path=\'%s\'\"\n",
         sd, "dlp_VFSExportDatabaseToFile", cardno, (long )localid, volRefNum, path);
#line 3991
  pi_reset_errors(sd);
#line 3993
  tmp___0 = strlen(path);
#line 3993
  req = dlp_request_new((enum dlpFunctions )66, 1, 8UL + (tmp___0 + 1UL));
  }
#line 3995
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 3996
    tmp___1 = pi_set_error(sd, -500);
    }
#line 3996
    return (tmp___1);
  }
  {
#line 3998
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )(((int )((unsigned short )volRefNum) >> 8) & 255);
#line 3998
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((int )((unsigned short )volRefNum) & 255);
#line 3999
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )(((int )((unsigned short )cardno) >> 8) & 255);
#line 3999
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((int )((unsigned short )cardno) & 255);
#line 4000
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )localid >> 24)) & 255);
#line 4000
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char )(((unsigned long )localid >> 16) & 255UL);
#line 4000
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 2) = (unsigned char )(((unsigned long )localid >> 8) & 255UL);
#line 4000
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 3) = (unsigned char )((unsigned long )localid & 255UL);
#line 4001
  strcpy((char */* __restrict  */)((*(req->argv + 0))->data + 8), (char const   */* __restrict  */)path);
#line 4003
  result = dlp_exec(sd, req, & res);
#line 4005
  dlp_request_free(req);
#line 4006
  dlp_response_free(res);
  }
#line 4008
  return (result);
}
}
#line 4011 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSFileCreate(int sd , int volRefNum , char const   *name ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 4018
  tmp = pi_version(sd);
  }
#line 4018
  if (tmp < ((1 << 8) | 2)) {
#line 4018
    return (13);
  }
  {
#line 4019
  pi_log(16, 4, "DLP sd=%d %s \"volRefNum=%d name=\'%s\'\"\n", sd, "dlp_VFSFileCreate",
         volRefNum, name);
#line 4020
  pi_reset_errors(sd);
#line 4022
  tmp___0 = strlen(name);
#line 4022
  req = dlp_request_new((enum dlpFunctions )67, 1, 2UL + (tmp___0 + 1UL));
  }
#line 4023
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4024
    tmp___1 = pi_set_error(sd, -500);
    }
#line 4024
    return (tmp___1);
  }
  {
#line 4026
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )(((int )((unsigned short )volRefNum) >> 8) & 255);
#line 4026
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((int )((unsigned short )volRefNum) & 255);
#line 4027
  strcpy((char */* __restrict  */)((*(req->argv + 0))->data + 2), (char const   */* __restrict  */)name);
#line 4029
  result = dlp_exec(sd, req, & res);
#line 4031
  dlp_request_free(req);
#line 4032
  dlp_response_free(res);
  }
#line 4034
  return (result);
}
}
#line 4037 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSFileOpen(int sd , int volRefNum , char const   *path , int openMode , FileRef *fileRef ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 4045
  tmp = pi_version(sd);
  }
#line 4045
  if (tmp < ((1 << 8) | 2)) {
#line 4045
    return (13);
  }
  {
#line 4046
  pi_log(16, 4, "DLP sd=%d %s \"volRefNum=%d mode=0x%04x path=\'%s\'\"\n", sd, "dlp_VFSFileOpen",
         volRefNum, openMode, path);
#line 4048
  pi_reset_errors(sd);
#line 4050
  tmp___0 = strlen(path);
#line 4050
  req = dlp_request_new((enum dlpFunctions )68, 1, 4UL + (tmp___0 + 1UL));
  }
#line 4051
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4052
    tmp___1 = pi_set_error(sd, -500);
    }
#line 4052
    return (tmp___1);
  }
  {
#line 4054
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )(((int )((unsigned short )volRefNum) >> 8) & 255);
#line 4054
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((int )((unsigned short )volRefNum) & 255);
#line 4055
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )(((int )((unsigned short )openMode) >> 8) & 255);
#line 4055
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((int )((unsigned short )openMode) & 255);
#line 4056
  strcpy((char */* __restrict  */)((*(req->argv + 0))->data + 4), (char const   */* __restrict  */)path);
#line 4058
  result = dlp_exec(sd, req, & res);
#line 4060
  dlp_request_free(req);
  }
#line 4062
  if (result > 0) {
    {
#line 4063
    *fileRef = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3);
#line 4065
    pi_log(16, 4, "OpenFileRef: 0x%x\n", *fileRef);
    }
  }
  {
#line 4069
  dlp_response_free(res);
  }
#line 4071
  return (result);
}
}
#line 4074 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSFileClose(int sd , FileRef fileRef ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  int tmp___0 ;

  {
  {
#line 4081
  tmp = pi_version(sd);
  }
#line 4081
  if (tmp < ((1 << 8) | 2)) {
#line 4081
    return (13);
  }
  {
#line 4082
  pi_log(16, 4, "DLP sd=%d %s \"fileRef=%ld\"\n", sd, "dlp_VFSFileClose", fileRef);
#line 4083
  pi_reset_errors(sd);
#line 4085
  req = dlp_request_new((enum dlpFunctions )69, 1, 4);
  }
#line 4086
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4087
    tmp___0 = pi_set_error(sd, -500);
    }
#line 4087
    return (tmp___0);
  }
  {
#line 4089
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )((int )((unsigned char )(fileRef >> 24)) & 255);
#line 4089
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((fileRef >> 16) & 255UL);
#line 4089
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 2) = (unsigned char )((fileRef >> 8) & 255UL);
#line 4089
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 3) = (unsigned char )(fileRef & 255UL);
#line 4091
  result = dlp_exec(sd, req, & res);
#line 4093
  dlp_request_free(req);
#line 4094
  dlp_response_free(res);
#line 4096
  pi_log(16, 4, "Closed FileRef: %x\n", fileRef);
  }
#line 4099
  return (result);
}
}
#line 4102 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSFileWrite(int sd , FileRef fileRef , void const   *data , size_t len ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  int tmp___0 ;
  int bytes ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 4107
  res = (struct dlpResponse *)((void *)0);
#line 4109
  tmp = pi_version(sd);
  }
#line 4109
  if (tmp < ((1 << 8) | 2)) {
#line 4109
    return (13);
  }
  {
#line 4110
  pi_log(16, 4, "DLP sd=%d %s \"fileRef=%ld len=%ld\"\n", sd, "dlp_VFSFileWrite",
         (long )fileRef, (long )len);
#line 4111
  pi_reset_errors(sd);
#line 4113
  pi_log(16, 4, "Write to FileRef: %x bytes %d\n", fileRef, len);
#line 4116
  req = dlp_request_new((enum dlpFunctions )70, 1, 8);
  }
#line 4117
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4118
    tmp___0 = pi_set_error(sd, -500);
    }
#line 4118
    return (tmp___0);
  }
  {
#line 4120
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )((int )((unsigned char )(fileRef >> 24)) & 255);
#line 4120
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((fileRef >> 16) & 255UL);
#line 4120
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 2) = (unsigned char )((fileRef >> 8) & 255UL);
#line 4120
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 3) = (unsigned char )(fileRef & 255UL);
#line 4121
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char )((int )((unsigned char )(len >> 24)) & 255);
#line 4121
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char )((len >> 16) & 255UL);
#line 4121
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 2) = (unsigned char )((len >> 8) & 255UL);
#line 4121
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 3) = (unsigned char )(len & 255UL);
#line 4123
  result = dlp_exec(sd, req, & res);
#line 4125
  dlp_request_free(req);
  }
#line 4127
  if (result >= 0) {
    {
#line 4128
    tmp___1 = pi_write(sd, data, len);
#line 4128
    bytes = (int )tmp___1;
#line 4129
    result = bytes;
    }
#line 4130
    if (result < (int )len) {
      {
#line 4131
      pi_log(16, 4, "send failed %d\n", result);
      }
    } else {
      {
#line 4134
      dlp_response_free(res);
#line 4135
      res = (struct dlpResponse *)((void *)0);
#line 4137
      tmp___2 = dlp_response_read(& res, sd);
#line 4137
      result = (int )tmp___2;
      }
#line 4139
      if (result > 0) {
        {
#line 4140
        pi_set_palmos_error(sd, (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 2) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 2) + 1))));
#line 4141
        tmp___3 = pi_palmos_error(sd);
#line 4141
        pi_log(16, 4, "send success (%d) res 0x%04x!\n", len, tmp___3);
#line 4143
        result = bytes;
        }
      }
    }
  }
  {
#line 4148
  dlp_response_free(res);
  }
#line 4150
  return (result);
}
}
#line 4153 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSFileRead(int sd , FileRef fileRef , pi_buffer_t *data , size_t len ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  size_t bytes ;
  int freeze_txid ;
  size_t opt_size ;
  PI_ERR tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 4159
  bytes = (size_t )0;
#line 4160
  freeze_txid = 1;
#line 4161
  opt_size = sizeof(int );
#line 4163
  tmp = pi_version(sd);
  }
#line 4163
  if (tmp < ((1 << 8) | 2)) {
#line 4163
    return (13);
  }
  {
#line 4164
  pi_log(16, 4, "DLP sd=%d %s \"fileRef=%ld len=%ld\"\n", sd, "dlp_VFSFileRead", (long )fileRef,
         (long )len);
#line 4165
  pi_reset_errors(sd);
#line 4167
  req = dlp_request_new((enum dlpFunctions )71, 1, 8);
  }
#line 4168
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4169
    tmp___0 = pi_set_error(sd, -500);
    }
#line 4169
    return (tmp___0);
  }
  {
#line 4171
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )((int )((unsigned char )(fileRef >> 24)) & 255);
#line 4171
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((fileRef >> 16) & 255UL);
#line 4171
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 2) = (unsigned char )((fileRef >> 8) & 255UL);
#line 4171
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 3) = (unsigned char )(fileRef & 255UL);
#line 4172
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char )((int )((unsigned char )(len >> 24)) & 255);
#line 4172
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char )((len >> 16) & 255UL);
#line 4172
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 2) = (unsigned char )((len >> 8) & 255UL);
#line 4172
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 3) = (unsigned char )(len & 255UL);
#line 4177
  pi_setsockopt(sd, 2, 2, (void const   *)(& freeze_txid), & opt_size);
#line 4179
  result = dlp_exec(sd, req, & res);
#line 4181
  dlp_request_free(req);
#line 4183
  pi_buffer_clear(data);
  }
#line 4185
  if (result >= 0) {
    {
#line 4187
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 4188
      tmp___1 = pi_read(sd, data, len);
#line 4188
      result = (int )tmp___1;
      }
#line 4189
      if (result > 0) {
#line 4190
        len -= (size_t )result;
#line 4191
        bytes += (size_t )result;
      }
#line 4187
      if (result > 0) {
#line 4187
        if (! (len > 0UL)) {
#line 4187
          goto while_break;
        }
      } else {
#line 4187
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 4195
    pi_log(16, 4, "dlp_VFSFileRead: read %u bytes (last pi_read was %d)\n", (unsigned int )bytes,
           result);
    }
#line 4199
    if (result >= 0) {
#line 4200
      result = (int )bytes;
    }
  }
  {
#line 4203
  dlp_response_free(res);
#line 4205
  freeze_txid = 0;
#line 4206
  pi_setsockopt(sd, 2, 2, (void const   *)(& freeze_txid), & opt_size);
  }
#line 4208
  return (result);
}
}
#line 4211 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSFileDelete(int sd , int volRefNum , char const   *path ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 4218
  tmp = pi_version(sd);
  }
#line 4218
  if (tmp < ((1 << 8) | 2)) {
#line 4218
    return (13);
  }
  {
#line 4219
  pi_log(16, 4, "DLP sd=%d %s \"volRefNum=%d path=\'%s\'\"\n", sd, "dlp_VFSFileDelete",
         volRefNum, path);
#line 4220
  pi_reset_errors(sd);
#line 4222
  tmp___0 = strlen(path);
#line 4222
  req = dlp_request_new((enum dlpFunctions )72, 1, 2UL + (tmp___0 + 1UL));
  }
#line 4223
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4224
    tmp___1 = pi_set_error(sd, -500);
    }
#line 4224
    return (tmp___1);
  }
  {
#line 4226
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )(((int )((unsigned short )volRefNum) >> 8) & 255);
#line 4226
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((int )((unsigned short )volRefNum) & 255);
#line 4227
  strcpy((char */* __restrict  */)((*(req->argv + 0))->data + 2), (char const   */* __restrict  */)path);
#line 4229
  result = dlp_exec(sd, req, & res);
#line 4231
  dlp_request_free(req);
#line 4232
  dlp_response_free(res);
  }
#line 4234
  return (result);
}
}
#line 4237 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSFileRename(int sd , int volRefNum , char const   *path , char const   *newname ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 4245
  tmp = pi_version(sd);
  }
#line 4245
  if (tmp < ((1 << 8) | 2)) {
#line 4245
    return (13);
  }
  {
#line 4246
  pi_log(16, 4, "DLP sd=%d %s \"volRefNum=%d file \'%s\' renamed \'%s\'\"\n", sd,
         "dlp_VFSFileRename", volRefNum, path, & rename);
#line 4248
  pi_reset_errors(sd);
#line 4250
  tmp___0 = strlen(path);
#line 4250
  tmp___1 = strlen(newname);
#line 4250
  req = dlp_request_new((enum dlpFunctions )73, 1, (4UL + (tmp___0 + 1UL)) + (tmp___1 + 1UL));
  }
#line 4252
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4253
    tmp___2 = pi_set_error(sd, -500);
    }
#line 4253
    return (tmp___2);
  }
  {
#line 4255
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )(((int )((unsigned short )volRefNum) >> 8) & 255);
#line 4255
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((int )((unsigned short )volRefNum) & 255);
#line 4256
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )((2 >> 8) & 255);
#line 4256
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char)2;
#line 4257
  strcpy((char */* __restrict  */)((*(req->argv + 0))->data + 4), (char const   */* __restrict  */)path);
#line 4258
  tmp___3 = strlen(path);
#line 4258
  strcpy((char */* __restrict  */)((*(req->argv + 0))->data + (4UL + (tmp___3 + 1UL))),
         (char const   */* __restrict  */)newname);
#line 4260
  result = dlp_exec(sd, req, & res);
#line 4262
  dlp_request_free(req);
#line 4263
  dlp_response_free(res);
  }
#line 4265
  return (result);
}
}
#line 4268 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSFileEOF(int sd , FileRef fileRef ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  int tmp___0 ;

  {
  {
#line 4275
  tmp = pi_version(sd);
  }
#line 4275
  if (tmp < ((1 << 8) | 2)) {
#line 4275
    return (13);
  }
  {
#line 4276
  pi_log(16, 4, "DLP sd=%d %s \"fileRef=%ld\"\n", sd, "dlp_VFSFileEOF", fileRef);
#line 4277
  pi_reset_errors(sd);
#line 4279
  req = dlp_request_new((enum dlpFunctions )74, 1, 4);
  }
#line 4280
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4281
    tmp___0 = pi_set_error(sd, -500);
    }
#line 4281
    return (tmp___0);
  }
  {
#line 4283
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )((int )((unsigned char )(fileRef >> 24)) & 255);
#line 4283
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((fileRef >> 16) & 255UL);
#line 4283
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 2) = (unsigned char )((fileRef >> 8) & 255UL);
#line 4283
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 3) = (unsigned char )(fileRef & 255UL);
#line 4285
  result = dlp_exec(sd, req, & res);
#line 4287
  dlp_request_free(req);
#line 4288
  dlp_response_free(res);
  }
#line 4290
  return (result);
}
}
#line 4293 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSFileTell(int sd , FileRef fileRef , int *position ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  int tmp___0 ;

  {
  {
#line 4300
  tmp = pi_version(sd);
  }
#line 4300
  if (tmp < ((1 << 8) | 2)) {
#line 4300
    return (13);
  }
  {
#line 4301
  pi_log(16, 4, "DLP sd=%d %s \"fileRef=%ld\"\n", sd, "dlp_VFSFileTell", fileRef);
#line 4302
  pi_reset_errors(sd);
#line 4304
  req = dlp_request_new((enum dlpFunctions )75, 1, 4);
  }
#line 4305
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4306
    tmp___0 = pi_set_error(sd, -500);
    }
#line 4306
    return (tmp___0);
  }
  {
#line 4308
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )((int )((unsigned char )(fileRef >> 24)) & 255);
#line 4308
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((fileRef >> 16) & 255UL);
#line 4308
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 2) = (unsigned char )((fileRef >> 8) & 255UL);
#line 4308
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 3) = (unsigned char )(fileRef & 255UL);
#line 4310
  result = dlp_exec(sd, req, & res);
#line 4312
  dlp_request_free(req);
  }
#line 4314
  if (result > 0) {
#line 4315
    *position = (int )(((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3));
  }
  {
#line 4318
  dlp_response_free(res);
  }
#line 4320
  return (result);
}
}
#line 4323 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSFileGetAttributes(int sd , FileRef fileRef , unsigned long *attributes ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  int tmp___0 ;

  {
  {
#line 4330
  tmp = pi_version(sd);
  }
#line 4330
  if (tmp < ((1 << 8) | 2)) {
#line 4330
    return (13);
  }
  {
#line 4331
  pi_log(16, 4, "DLP sd=%d %s \"fileRef=%ld\"\n", sd, "dlp_VFSFileGetAttributes",
         fileRef);
#line 4332
  pi_reset_errors(sd);
#line 4334
  req = dlp_request_new((enum dlpFunctions )76, 1, 4);
  }
#line 4335
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4336
    tmp___0 = pi_set_error(sd, -500);
    }
#line 4336
    return (tmp___0);
  }
  {
#line 4338
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )((int )((unsigned char )(fileRef >> 24)) & 255);
#line 4338
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((fileRef >> 16) & 255UL);
#line 4338
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 2) = (unsigned char )((fileRef >> 8) & 255UL);
#line 4338
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 3) = (unsigned char )(fileRef & 255UL);
#line 4340
  result = dlp_exec(sd, req, & res);
#line 4342
  dlp_request_free(req);
  }
#line 4344
  if (result > 0) {
#line 4345
    *attributes = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3);
  }
  {
#line 4348
  dlp_response_free(res);
  }
#line 4350
  return (result);
}
}
#line 4353 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSFileSetAttributes(int sd , FileRef fileRef , unsigned long attributes ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  int tmp___0 ;

  {
  {
#line 4360
  tmp = pi_version(sd);
  }
#line 4360
  if (tmp < ((1 << 8) | 2)) {
#line 4360
    return (13);
  }
  {
#line 4361
  pi_log(16, 4, "DLP sd=%d %s \"fileRef=%ld attributes=0x%08lx\"\n", sd, "dlp_VFSFileSetAttributes",
         fileRef, attributes);
#line 4363
  pi_reset_errors(sd);
#line 4365
  req = dlp_request_new((enum dlpFunctions )77, 1, 8);
  }
#line 4366
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4367
    tmp___0 = pi_set_error(sd, -500);
    }
#line 4367
    return (tmp___0);
  }
  {
#line 4369
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )((int )((unsigned char )(fileRef >> 24)) & 255);
#line 4369
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((fileRef >> 16) & 255UL);
#line 4369
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 2) = (unsigned char )((fileRef >> 8) & 255UL);
#line 4369
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 3) = (unsigned char )(fileRef & 255UL);
#line 4370
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char )((int )((unsigned char )(attributes >> 24)) & 255);
#line 4370
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char )((attributes >> 16) & 255UL);
#line 4370
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 2) = (unsigned char )((attributes >> 8) & 255UL);
#line 4370
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 3) = (unsigned char )(attributes & 255UL);
#line 4372
  result = dlp_exec(sd, req, & res);
#line 4374
  dlp_request_free(req);
#line 4375
  dlp_response_free(res);
  }
#line 4377
  return (result);
}
}
#line 4380 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSFileGetDate(int sd , FileRef fileRef , int which , time_t *date ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  int tmp___0 ;

  {
  {
#line 4387
  tmp = pi_version(sd);
  }
#line 4387
  if (tmp < ((1 << 8) | 2)) {
#line 4387
    return (13);
  }
  {
#line 4388
  pi_log(16, 4, "DLP sd=%d %s \"fileRef=%ld which=%d\"\n", sd, "dlp_VFSFileGetDate",
         fileRef, which);
#line 4389
  pi_reset_errors(sd);
#line 4391
  req = dlp_request_new((enum dlpFunctions )78, 1, 6);
  }
#line 4392
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4393
    tmp___0 = pi_set_error(sd, -500);
    }
#line 4393
    return (tmp___0);
  }
  {
#line 4395
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )((int )((unsigned char )(fileRef >> 24)) & 255);
#line 4395
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((fileRef >> 16) & 255UL);
#line 4395
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 2) = (unsigned char )((fileRef >> 8) & 255UL);
#line 4395
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 3) = (unsigned char )(fileRef & 255UL);
#line 4396
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char )(((int )((unsigned short )which) >> 8) & 255);
#line 4396
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char )((int )((unsigned short )which) & 255);
#line 4398
  result = dlp_exec(sd, req, & res);
#line 4400
  dlp_request_free(req);
  }
#line 4402
  if (result > 0) {
    {
#line 4403
    *date = (time_t )((((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3)) - 2082852000UL);
#line 4405
    pi_log(16, 4, "Requested date(%d): %d / %x calc %d / %x\n", which, ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3),
           ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3),
           *date, *date);
    }
  }
  {
#line 4412
  dlp_response_free(res);
  }
#line 4414
  return (result);
}
}
#line 4417 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSFileSetDate(int sd , FileRef fileRef , int which , time_t date ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  int tmp___0 ;

  {
  {
#line 4424
  tmp = pi_version(sd);
  }
#line 4424
  if (tmp < ((1 << 8) | 2)) {
#line 4424
    return (13);
  }
  {
#line 4425
  pi_log(16, 4, "DLP sd=%d %s \"fileRef=%ld which=%d date=0x%08lx\"\n", sd, "dlp_VFSFileSetDate",
         (long )fileRef, which, date);
#line 4427
  pi_reset_errors(sd);
#line 4429
  req = dlp_request_new((enum dlpFunctions )79, 1, 10);
  }
#line 4430
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4431
    tmp___0 = pi_set_error(sd, -500);
    }
#line 4431
    return (tmp___0);
  }
  {
#line 4433
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )((int )((unsigned char )(fileRef >> 24)) & 255);
#line 4433
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((fileRef >> 16) & 255UL);
#line 4433
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 2) = (unsigned char )((fileRef >> 8) & 255UL);
#line 4433
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 3) = (unsigned char )(fileRef & 255UL);
#line 4434
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char )(((int )((unsigned short )which) >> 8) & 255);
#line 4434
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char )((int )((unsigned short )which) & 255);
#line 4435
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )(date + 2082852000L) >> 24)) & 255);
#line 4435
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 1) = (unsigned char )(((unsigned long )(date + 2082852000L) >> 16) & 255UL);
#line 4435
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 2) = (unsigned char )(((unsigned long )(date + 2082852000L) >> 8) & 255UL);
#line 4435
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 3) = (unsigned char )((unsigned long )(date + 2082852000L) & 255UL);
#line 4437
  result = dlp_exec(sd, req, & res);
#line 4439
  dlp_request_free(req);
#line 4440
  dlp_response_free(res);
  }
#line 4442
  return (result);
}
}
#line 4445 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSDirCreate(int sd , int volRefNum , char const   *path ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 4452
  tmp = pi_version(sd);
  }
#line 4452
  if (tmp < ((1 << 8) | 2)) {
#line 4452
    return (13);
  }
  {
#line 4453
  pi_log(16, 4, "DLP sd=%d %s \"volRefNum=%d path=\'%s\'\"\n", sd, "dlp_VFSDirCreate",
         volRefNum, path);
#line 4454
  pi_reset_errors(sd);
#line 4456
  tmp___0 = strlen(path);
#line 4456
  req = dlp_request_new((enum dlpFunctions )80, 1, 2UL + (tmp___0 + 1UL));
  }
#line 4457
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4458
    tmp___1 = pi_set_error(sd, -500);
    }
#line 4458
    return (tmp___1);
  }
  {
#line 4460
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )(((int )((unsigned short )volRefNum) >> 8) & 255);
#line 4460
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((int )((unsigned short )volRefNum) & 255);
#line 4461
  strcpy((char */* __restrict  */)((*(req->argv + 0))->data + 2), (char const   */* __restrict  */)path);
#line 4463
  result = dlp_exec(sd, req, & res);
#line 4465
  dlp_request_free(req);
#line 4466
  dlp_response_free(res);
  }
#line 4468
  return (result);
}
}
#line 4471 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSDirEntryEnumerate(int sd , FileRef dirRefNum , unsigned long *dirIterator ,
                             int *maxDirItems , struct VFSDirInfo *data ) 
{ 
  unsigned int result ;
  unsigned int entries ;
  unsigned int from ;
  unsigned int at ;
  unsigned int slen ;
  unsigned int count ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 4484
  tmp = pi_version(sd);
  }
#line 4484
  if (tmp < ((1 << 8) | 2)) {
#line 4484
    return (13);
  }
  {
#line 4485
  pi_log(16, 4, "DLP sd=%d %s \"dirRef=%ld\"\n", sd, "dlp_VFSDirEntryEnumerate", dirRefNum);
#line 4486
  pi_reset_errors(sd);
#line 4488
  req = dlp_request_new((enum dlpFunctions )81, 1, 12);
  }
#line 4489
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4490
    tmp___0 = pi_set_error(sd, -500);
    }
#line 4490
    return (tmp___0);
  }
  {
#line 4492
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )((int )((unsigned char )(dirRefNum >> 24)) & 255);
#line 4492
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((dirRefNum >> 16) & 255UL);
#line 4492
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 2) = (unsigned char )((dirRefNum >> 8) & 255UL);
#line 4492
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 3) = (unsigned char )(dirRefNum & 255UL);
#line 4493
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char )((int )((unsigned char )(*dirIterator >> 24)) & 255);
#line 4493
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char )((*dirIterator >> 16) & 255UL);
#line 4493
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 2) = (unsigned char )((*dirIterator >> 8) & 255UL);
#line 4493
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 3) = (unsigned char )(*dirIterator & 255UL);
#line 4494
  *((unsigned char *)((*(req->argv + 0))->data + 8) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )(8 + *maxDirItems * 260) >> 24)) & 255);
#line 4494
  *((unsigned char *)((*(req->argv + 0))->data + 8) + 1) = (unsigned char )(((unsigned long )(8 + *maxDirItems * 260) >> 16) & 255UL);
#line 4494
  *((unsigned char *)((*(req->argv + 0))->data + 8) + 2) = (unsigned char )(((unsigned long )(8 + *maxDirItems * 260) >> 8) & 255UL);
#line 4494
  *((unsigned char *)((*(req->argv + 0))->data + 8) + 3) = (unsigned char )((unsigned long )(8 + *maxDirItems * 260) & 255UL);
#line 4496
  tmp___1 = dlp_exec(sd, req, & res);
#line 4496
  result = (unsigned int )tmp___1;
#line 4498
  dlp_request_free(req);
  }
#line 4500
  if (result > 0U) {
#line 4501
    if (result) {
#line 4502
      *dirIterator = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3);
#line 4503
      entries = (unsigned int )(((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 4) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 4) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 4) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 4) + 3));
    } else {
#line 4505
      *dirIterator = 0xffffffffffffffffUL;
#line 4506
      entries = 0U;
    }
    {
#line 4509
    pi_log(16, 4, "%d results returnd (ilterator: %d)\n", entries, *dirIterator);
#line 4513
    from = 8U;
#line 4514
    count = 0U;
#line 4516
    at = 0U;
    }
    {
#line 4516
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4516
      if (! (at < entries)) {
#line 4516
        goto while_break;
      }
#line 4517
      if ((unsigned int )*maxDirItems > at) {
#line 4518
        (data + at)->attr = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + from) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + from) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + from) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + from) + 3);
#line 4525
        if (((data + at)->attr & 65535UL) == 0UL) {
#line 4525
          if (((data + at)->attr & 4294901760UL) != 0UL) {
#line 4527
            (data + at)->attr >>= 16;
          }
        }
        {
#line 4529
        strncpy((char */* __restrict  */)((data + at)->name), (char const   */* __restrict  */)((*(res->argv + 0))->data + (from + 4U)),
                (size_t )256);
#line 4532
        (data + at)->name[255] = (char)0;
#line 4533
        count ++;
        }
      }
      {
#line 4539
      tmp___2 = strlen((char const   *)((*(res->argv + 0))->data + (from + 4U)));
#line 4539
      slen = (unsigned int )(tmp___2 + 1UL);
      }
#line 4540
      if (slen & 1U) {
#line 4541
        slen ++;
      }
#line 4544
      from += slen + 4U;
#line 4516
      at ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 4546
    *maxDirItems = (int )count;
  }
  {
#line 4549
  dlp_response_free(res);
  }
#line 4551
  return ((int )result);
}
}
#line 4554 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSVolumeFormat(int sd , unsigned char flags , int fsLibRef , struct VFSSlotMountParam *param ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  int tmp___0 ;

  {
  {
#line 4562
  tmp = pi_version(sd);
  }
#line 4562
  if (tmp < ((1 << 8) | 2)) {
#line 4562
    return (13);
  }
  {
#line 4563
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_VFSVolumeFormat");
#line 4564
  pi_reset_errors(sd);
#line 4566
  req = dlp_request_new((enum dlpFunctions )84, 1, 4);
  }
#line 4567
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4568
    tmp___0 = pi_set_error(sd, -500);
    }
#line 4568
    return (tmp___0);
  }
  {
#line 4571
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )(((int )((unsigned short )fsLibRef) >> 8) & 255);
#line 4571
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((int )((unsigned short )fsLibRef) & 255);
#line 4572
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 0) = (unsigned char )(((int )((unsigned short )sizeof(struct VFSSlotMountParam )) >> 8) & 255);
#line 4572
  *((unsigned char *)((*(req->argv + 0))->data + 2) + 1) = (unsigned char )((int )((unsigned short )sizeof(struct VFSSlotMountParam )) & 255);
#line 4574
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = flags;
#line 4575
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char)0;
#line 4577
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 0) = (unsigned char )(((int )param->vfsMountParam.volRefNum >> 8) & 255);
#line 4577
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 1) = (unsigned char )((int )param->vfsMountParam.volRefNum & 255);
#line 4578
  *((unsigned char *)((*(req->argv + 0))->data + 8) + 0) = (unsigned char )(((int )param->vfsMountParam.reserved >> 8) & 255);
#line 4578
  *((unsigned char *)((*(req->argv + 0))->data + 8) + 1) = (unsigned char )((int )param->vfsMountParam.reserved & 255);
#line 4579
  *((unsigned char *)((*(req->argv + 0))->data + 10) + 0) = (unsigned char )((int )((unsigned char )(param->vfsMountParam.mountClass >> 24)) & 255);
#line 4579
  *((unsigned char *)((*(req->argv + 0))->data + 10) + 1) = (unsigned char )((param->vfsMountParam.mountClass >> 16) & 255UL);
#line 4579
  *((unsigned char *)((*(req->argv + 0))->data + 10) + 2) = (unsigned char )((param->vfsMountParam.mountClass >> 8) & 255UL);
#line 4579
  *((unsigned char *)((*(req->argv + 0))->data + 10) + 3) = (unsigned char )(param->vfsMountParam.mountClass & 255UL);
#line 4580
  *((unsigned char *)((*(req->argv + 0))->data + 14) + 0) = (unsigned char )(((int )param->slotLibRefNum >> 8) & 255);
#line 4580
  *((unsigned char *)((*(req->argv + 0))->data + 14) + 1) = (unsigned char )((int )param->slotLibRefNum & 255);
#line 4581
  *((unsigned char *)((*(req->argv + 0))->data + 16) + 0) = (unsigned char )(((int )param->slotRefNum >> 8) & 255);
#line 4581
  *((unsigned char *)((*(req->argv + 0))->data + 16) + 1) = (unsigned char )((int )param->slotRefNum & 255);
#line 4583
  result = dlp_exec(sd, req, & res);
#line 4585
  dlp_request_free(req);
#line 4586
  dlp_response_free(res);
  }
#line 4588
  return (result);
}
}
#line 4591 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSVolumeEnumerate(int sd , int *numVols , int *volRefs ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  int tmp___0 ;
  int vols ;
  int i ;

  {
  {
#line 4598
  tmp = pi_version(sd);
  }
#line 4598
  if (tmp < ((1 << 8) | 2)) {
#line 4598
    return (13);
  }
  {
#line 4599
  pi_log(16, 4, "DLP sd=%d %s\n", sd, "dlp_VFSVolumeEnumerate");
#line 4600
  pi_reset_errors(sd);
#line 4602
  req = dlp_request_new((enum dlpFunctions )85, 0);
  }
#line 4603
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4604
    tmp___0 = pi_set_error(sd, -500);
    }
#line 4604
    return (tmp___0);
  }
  {
#line 4606
  result = dlp_exec(sd, req, & res);
#line 4608
  dlp_request_free(req);
  }
#line 4610
  if (result > 0) {
    {
#line 4613
    vols = (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1)));
#line 4615
    pi_log(16, 4, "DLP VFSVolumeEnumerate %d\n", vols);
    }
#line 4618
    if (vols) {
#line 4619
      i = 0;
      {
#line 4619
      while (1) {
        while_continue: /* CIL Label */ ;
#line 4619
        if (i < vols) {
#line 4619
          if (! (i < *numVols)) {
#line 4619
            goto while_break;
          }
        } else {
#line 4619
          goto while_break;
        }
        {
#line 4620
        *(volRefs + i) = (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + (2 + 2 * i)) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + (2 + 2 * i)) + 1)));
#line 4624
        pi_log(16, 4, "  %d Volume-Refnum %d\n", i, *(volRefs + i));
#line 4619
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 4628
    *numVols = vols;
  } else {
#line 4631
    *numVols = 0;
  }
  {
#line 4633
  dlp_response_free(res);
  }
#line 4635
  return (result);
}
}
#line 4638 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSVolumeInfo(int sd , int volRefNum , struct VFSInfo *volInfo ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 4645
  tmp = pi_version(sd);
  }
#line 4645
  if (tmp < ((1 << 8) | 2)) {
#line 4645
    return (13);
  }
  {
#line 4646
  pi_log(16, 4, "DLP sd=%d %s \"volRefNum=%d\"\n", sd, "dlp_VFSVolumeInfo", volRefNum);
#line 4647
  pi_reset_errors(sd);
#line 4649
  req = dlp_request_new((enum dlpFunctions )86, 1, 2);
  }
#line 4650
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4651
    tmp___0 = pi_set_error(sd, -500);
    }
#line 4651
    return (tmp___0);
  }
  {
#line 4653
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )(((int )((unsigned short )volRefNum) >> 8) & 255);
#line 4653
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((int )((unsigned short )volRefNum) & 255);
#line 4655
  result = dlp_exec(sd, req, & res);
#line 4657
  dlp_request_free(req);
  }
#line 4659
  if (result > 0) {
    {
#line 4660
    volInfo->attributes = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3);
#line 4661
    volInfo->fsType = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 4) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 4) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 4) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 4) + 3);
#line 4662
    volInfo->fsCreator = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 8) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 8) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 8) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 8) + 3);
#line 4663
    volInfo->mountClass = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 12) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 12) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 12) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 12) + 3);
#line 4664
    volInfo->slotLibRefNum = (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 16) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 16) + 1)));
#line 4665
    volInfo->slotRefNum = (int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + 0))->data + 18) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + 0))->data + 18) + 1)));
#line 4666
    volInfo->mediaType = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 20) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 20) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 20) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 20) + 3);
#line 4667
    volInfo->reserved = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 24) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 24) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 24) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 24) + 3);
#line 4669
    tmp___1 = printlong(volInfo->fsType);
#line 4669
    pi_log(16, 4, "VFSVolumeInfo: fstype \'%s\' ", tmp___1);
#line 4672
    tmp___2 = printlong(volInfo->fsCreator);
#line 4672
    pi_log(16, 4, "fscreator: \'%s\'\nSlotlibref %d Slotref %d\n", tmp___2, volInfo->slotLibRefNum,
           volInfo->slotRefNum);
#line 4678
    tmp___3 = printlong(volInfo->mediaType);
#line 4678
    pi_log(16, 4, "Media: \'%s\'\n", tmp___3);
    }
  }
  {
#line 4682
  dlp_response_free(res);
  }
#line 4684
  return (result);
}
}
#line 4687 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSVolumeGetLabel(int sd , int volRefNum , int *len , char *name ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 4694
  tmp = pi_version(sd);
  }
#line 4694
  if (tmp < ((1 << 8) | 2)) {
#line 4694
    return (13);
  }
  {
#line 4695
  pi_log(16, 4, "DLP sd=%d %s \"volRefNum=%d\"\n", sd, "dlp_VFSVolumeGetLabel", volRefNum);
#line 4696
  pi_reset_errors(sd);
#line 4698
  req = dlp_request_new((enum dlpFunctions )87, 1, 2);
  }
#line 4699
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4700
    tmp___0 = pi_set_error(sd, -500);
    }
#line 4700
    return (tmp___0);
  }
  {
#line 4702
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )(((int )((unsigned short )volRefNum) >> 8) & 255);
#line 4702
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((int )((unsigned short )volRefNum) & 255);
#line 4704
  result = dlp_exec(sd, req, & res);
#line 4706
  dlp_request_free(req);
  }
#line 4708
  if (result > 0) {
    {
#line 4709
    strncpy((char */* __restrict  */)name, (char const   */* __restrict  */)((*(res->argv + 0))->data + 0),
            (size_t )(*len - 1));
#line 4711
    tmp___1 = strlen((char const   *)name);
#line 4711
    *len = (int )tmp___1;
#line 4713
    pi_log(16, 4, "DLP VFSVolumeGetLabel %s\n", name);
    }
  }
  {
#line 4717
  dlp_response_free(res);
  }
#line 4719
  return (result);
}
}
#line 4722 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSVolumeSetLabel(int sd , int volRefNum , char const   *name ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 4729
  tmp = pi_version(sd);
  }
#line 4729
  if (tmp < ((1 << 8) | 2)) {
#line 4729
    return (13);
  }
  {
#line 4730
  pi_log(16, 4, "DLP sd=%d %s \"volRefNum=%d name=\'%s\'\"\n", sd, "dlp_VFSVolumeSetLabel",
         volRefNum, name);
#line 4731
  pi_reset_errors(sd);
#line 4733
  tmp___0 = strlen(name);
#line 4733
  req = dlp_request_new((enum dlpFunctions )88, 1, 2UL + (tmp___0 + 1UL));
  }
#line 4735
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4736
    tmp___1 = pi_set_error(sd, -500);
    }
#line 4736
    return (tmp___1);
  }
  {
#line 4738
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )(((int )((unsigned short )volRefNum) >> 8) & 255);
#line 4738
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((int )((unsigned short )volRefNum) & 255);
#line 4739
  strcpy((char */* __restrict  */)((*(req->argv + 0))->data + 2), (char const   */* __restrict  */)name);
#line 4741
  result = dlp_exec(sd, req, & res);
#line 4743
  dlp_response_free(res);
#line 4744
  dlp_request_free(req);
  }
#line 4746
  return (result);
}
}
#line 4749 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSVolumeSize(int sd , int volRefNum , long *volSizeUsed , long *volSizeTotal ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  int tmp___0 ;

  {
  {
#line 4757
  tmp = pi_version(sd);
  }
#line 4757
  if (tmp < ((1 << 8) | 2)) {
#line 4757
    return (13);
  }
  {
#line 4758
  pi_log(16, 4, "DLP sd=%d %s \"volRefNum=%d\"\n", sd, "dlp_VFSVolumeSize", volRefNum);
#line 4759
  pi_reset_errors(sd);
#line 4761
  req = dlp_request_new((enum dlpFunctions )89, 1, 2);
  }
#line 4762
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4763
    tmp___0 = pi_set_error(sd, -500);
    }
#line 4763
    return (tmp___0);
  }
  {
#line 4765
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )(((int )((unsigned short )volRefNum) >> 8) & 255);
#line 4765
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((int )((unsigned short )volRefNum) & 255);
#line 4767
  result = dlp_exec(sd, req, & res);
#line 4769
  dlp_request_free(req);
  }
#line 4771
  if (result > 0) {
    {
#line 4772
    *volSizeUsed = (long )(((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3));
#line 4773
    *volSizeTotal = (long )(((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 4) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 4) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 4) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 4) + 3));
#line 4775
    pi_log(16, 4, "DLP VFS Volume Size total: %d used: %d\n", *volSizeTotal, *volSizeUsed);
    }
  }
  {
#line 4780
  dlp_response_free(res);
  }
#line 4782
  return (result);
}
}
#line 4785 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSFileSeek(int sd , FileRef fileRef , int origin , int offset ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  int tmp___0 ;

  {
  {
#line 4792
  tmp = pi_version(sd);
  }
#line 4792
  if (tmp < ((1 << 8) | 2)) {
#line 4792
    return (13);
  }
  {
#line 4793
  pi_log(16, 4, "DLP sd=%d %s \"fileRef=%ld origin=%d offset=%d\"\n", sd, "dlp_VFSFileSeek",
         fileRef, origin, offset);
#line 4795
  pi_reset_errors(sd);
#line 4797
  req = dlp_request_new((enum dlpFunctions )90, 1, 10);
  }
#line 4798
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4799
    tmp___0 = pi_set_error(sd, -500);
    }
#line 4799
    return (tmp___0);
  }
  {
#line 4801
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )((int )((unsigned char )(fileRef >> 24)) & 255);
#line 4801
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((fileRef >> 16) & 255UL);
#line 4801
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 2) = (unsigned char )((fileRef >> 8) & 255UL);
#line 4801
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 3) = (unsigned char )(fileRef & 255UL);
#line 4802
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char )(((int )((unsigned short )origin) >> 8) & 255);
#line 4802
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char )((int )((unsigned short )origin) & 255);
#line 4803
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )offset >> 24)) & 255);
#line 4803
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 1) = (unsigned char )(((unsigned long )offset >> 16) & 255UL);
#line 4803
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 2) = (unsigned char )(((unsigned long )offset >> 8) & 255UL);
#line 4803
  *((unsigned char *)((*(req->argv + 0))->data + 6) + 3) = (unsigned char )((unsigned long )offset & 255UL);
#line 4805
  result = dlp_exec(sd, req, & res);
#line 4807
  dlp_request_free(req);
#line 4808
  dlp_response_free(res);
  }
#line 4810
  return (result);
}
}
#line 4813 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSFileResize(int sd , FileRef fileRef , int newSize ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  int tmp___0 ;

  {
  {
#line 4820
  tmp = pi_version(sd);
  }
#line 4820
  if (tmp < ((1 << 8) | 2)) {
#line 4820
    return (13);
  }
  {
#line 4821
  pi_log(16, 4, "DLP sd=%d %s \"fileRef=%ld newSize=%d\"\n", sd, "dlp_VFSFileResize",
         fileRef, newSize);
#line 4822
  pi_reset_errors(sd);
#line 4824
  req = dlp_request_new((enum dlpFunctions )91, 1, 8);
  }
#line 4825
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4826
    tmp___0 = pi_set_error(sd, -500);
    }
#line 4826
    return (tmp___0);
  }
  {
#line 4828
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )((int )((unsigned char )(fileRef >> 24)) & 255);
#line 4828
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((fileRef >> 16) & 255UL);
#line 4828
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 2) = (unsigned char )((fileRef >> 8) & 255UL);
#line 4828
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 3) = (unsigned char )(fileRef & 255UL);
#line 4829
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )newSize >> 24)) & 255);
#line 4829
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 1) = (unsigned char )(((unsigned long )newSize >> 16) & 255UL);
#line 4829
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 2) = (unsigned char )(((unsigned long )newSize >> 8) & 255UL);
#line 4829
  *((unsigned char *)((*(req->argv + 0))->data + 4) + 3) = (unsigned char )((unsigned long )newSize & 255UL);
#line 4831
  result = dlp_exec(sd, req, & res);
#line 4833
  dlp_request_free(req);
#line 4834
  dlp_response_free(res);
  }
#line 4836
  return (result);
}
}
#line 4839 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_VFSFileSize(int sd , FileRef fileRef , int *size ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  int tmp___0 ;

  {
  {
#line 4846
  tmp = pi_version(sd);
  }
#line 4846
  if (tmp < ((1 << 8) | 2)) {
#line 4846
    return (13);
  }
  {
#line 4847
  pi_log(16, 4, "DLP sd=%d %s \"fileRef=%ld\"\n", sd, "dlp_VFSFileSize", fileRef);
#line 4848
  pi_reset_errors(sd);
#line 4850
  req = dlp_request_new((enum dlpFunctions )92, 1, 4);
  }
#line 4851
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4852
    tmp___0 = pi_set_error(sd, -500);
    }
#line 4852
    return (tmp___0);
  }
  {
#line 4854
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )((int )((unsigned char )(fileRef >> 24)) & 255);
#line 4854
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((fileRef >> 16) & 255UL);
#line 4854
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 2) = (unsigned char )((fileRef >> 8) & 255UL);
#line 4854
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 3) = (unsigned char )(fileRef & 255UL);
#line 4856
  result = dlp_exec(sd, req, & res);
#line 4858
  dlp_request_free(req);
  }
#line 4860
  if (result > 0) {
    {
#line 4861
    *size = (int )(((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3));
#line 4863
    pi_log(16, 4, "DLP VFS File Size: %d\n", *size);
    }
  }
  {
#line 4867
  dlp_response_free(res);
  }
#line 4869
  return (result);
}
}
#line 4872 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
int dlp_ExpSlotMediaType(int sd , int slotNum , unsigned long *mediaType ) 
{ 
  int result ;
  struct dlpRequest *req ;
  struct dlpResponse *res ;
  PI_ERR tmp ;
  int tmp___0 ;

  {
  {
#line 4879
  tmp = pi_version(sd);
  }
#line 4879
  if (tmp < ((1 << 8) | 4)) {
#line 4879
    return (13);
  }
  {
#line 4880
  pi_log(16, 4, "DLP sd=%d %s \"slotNum=%d\"\n", sd, "dlp_ExpSlotMediaType", slotNum);
#line 4881
  pi_reset_errors(sd);
#line 4883
  req = dlp_request_new((enum dlpFunctions )93, 1, 2);
  }
#line 4884
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    {
#line 4885
    tmp___0 = pi_set_error(sd, -500);
    }
#line 4885
    return (tmp___0);
  }
  {
#line 4887
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 0) = (unsigned char )(((int )((unsigned short )slotNum) >> 8) & 255);
#line 4887
  *((unsigned char *)((*(req->argv + 0))->data + 0) + 1) = (unsigned char )((int )((unsigned short )slotNum) & 255);
#line 4889
  result = dlp_exec(sd, req, & res);
#line 4891
  dlp_request_free(req);
  }
#line 4893
  if (result > 0) {
    {
#line 4894
    *mediaType = ((((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + 0))->data + 0) + 3);
#line 4896
    pi_log(16, 4, "DLP Media Type for slot %d: %4.4s\n", slotNum, mediaType);
    }
  }
  {
#line 4901
  dlp_response_free(res);
  }
#line 4903
  return (result);
}
}
#line 53 "../include/pi-todo.h"
void free_ToDo(ToDo_t *todo ) ;
#line 54
int unpack_ToDo(ToDo_t *todo , pi_buffer_t const   *buf___3 , todoType type ) ;
#line 56
int pack_ToDo(ToDo_t const   *todo , pi_buffer_t *buf___3 , todoType type ) ;
#line 58
int unpack_ToDoAppInfo(ToDoAppInfo_t *appinfo , unsigned char const   *record , size_t len ) ;
#line 60
int pack_ToDoAppInfo(ToDoAppInfo_t const   *appinfo , unsigned char *record , size_t len ) ;
#line 57 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/todo.c"
void free_ToDo(ToDo_t *todo ) 
{ 


  {
#line 61
  if ((unsigned long )todo->description != (unsigned long )((void *)0)) {
    {
#line 62
    free((void *)todo->description);
#line 63
    todo->description = (char *)((void *)0);
    }
  }
#line 66
  if ((unsigned long )todo->note != (unsigned long )((void *)0)) {
    {
#line 67
    free((void *)todo->note);
#line 68
    todo->note = (char *)((void *)0);
    }
  }
#line 70
  return;
}
}
#line 85 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/todo.c"
int unpack_ToDo(ToDo_t *todo , pi_buffer_t const   *buf___3 , todoType type ) 
{ 
  unsigned long d ;
  int ofs ;
  size_t tmp ;

  {
#line 105
  if ((unsigned int )type != 0U) {
#line 106
    return (-1);
  }
#line 108
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
#line 109
    return (-1);
  } else
#line 108
  if ((unsigned long )buf___3->data == (unsigned long )((void *)0)) {
#line 109
    return (-1);
  } else
#line 108
  if (buf___3->used < 3UL) {
#line 109
    return (-1);
  }
#line 111
  d = (unsigned long )((unsigned short )(((int )*((unsigned char *)buf___3->data + 0) << 8) | (int )*((unsigned char *)buf___3->data + 1)));
#line 112
  if (d != 65535UL) {
    {
#line 113
    todo->due.tm_year = (int )((d >> 9) + 4UL);
#line 114
    todo->due.tm_mon = (int )(((d >> 5) & 15UL) - 1UL);
#line 115
    todo->due.tm_mday = (int )(d & 31UL);
#line 116
    todo->due.tm_hour = 0;
#line 117
    todo->due.tm_min = 0;
#line 118
    todo->due.tm_sec = 0;
#line 119
    todo->due.tm_isdst = -1;
#line 120
    mktime(& todo->due);
#line 121
    todo->indefinite = 0;
    }
  } else {
#line 123
    todo->indefinite = 1;
  }
#line 126
  todo->priority = (int )*((unsigned char *)(buf___3->data + 2) + 0);
#line 127
  if (todo->priority & 128) {
#line 128
    todo->complete = 1;
#line 129
    todo->priority &= 127;
  } else {
#line 131
    todo->complete = 0;
  }
#line 134
  ofs = 3;
#line 136
  if (buf___3->used - (size_t const   )ofs < 1UL) {
#line 137
    return (-1);
  }
  {
#line 139
  todo->description = strdup((char const   *)((char *)buf___3->data + ofs));
#line 141
  tmp = strlen((char const   *)todo->description);
#line 141
  ofs = (int )((size_t )ofs + (tmp + 1UL));
  }
#line 143
  if (buf___3->used - (size_t const   )ofs < 1UL) {
    {
#line 144
    free((void *)todo->description);
#line 145
    todo->description = (char *)0;
    }
#line 146
    return (-1);
  }
  {
#line 148
  todo->note = strdup((char const   *)((char *)buf___3->data + ofs));
  }
#line 150
  return (0);
}
}
#line 165 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/todo.c"
int pack_ToDo(ToDo_t const   *todo , pi_buffer_t *buf___3 , todoType type ) 
{ 
  int pos ;
  size_t destlen ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
#line 169
  destlen = (size_t )3;
#line 171
  if ((unsigned long )todo == (unsigned long )((void *)0)) {
#line 172
    return (-1);
  } else
#line 171
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
#line 172
    return (-1);
  }
#line 174
  if ((unsigned int )type != 0U) {
#line 175
    return (-1);
  }
#line 177
  if (todo->description) {
    {
#line 178
    tmp = strlen((char const   *)todo->description);
#line 178
    destlen += tmp;
    }
  }
#line 179
  destlen ++;
#line 180
  if (todo->note) {
    {
#line 181
    tmp___0 = strlen((char const   *)todo->note);
#line 181
    destlen += tmp___0;
    }
  }
  {
#line 182
  destlen ++;
#line 184
  pi_buffer_expect(buf___3, destlen);
#line 185
  buf___3->used = destlen;
  }
#line 187
  if (todo->indefinite) {
#line 188
    *(buf___3->data + 0) = (unsigned char)255;
#line 189
    *(buf___3->data + 1) = (unsigned char)255;
  } else {
#line 191
    *(buf___3->data + 0) = (unsigned char )(((int )((unsigned short )((((todo->due.tm_year - 4) << 9) | ((todo->due.tm_mon + 1) << 5)) | todo->due.tm_mday)) >> 8) & 255);
#line 191
    *(buf___3->data + 1) = (unsigned char )((int )((unsigned short )((((todo->due.tm_year - 4) << 9) | ((todo->due.tm_mon + 1) << 5)) | todo->due.tm_mday)) & 255);
  }
#line 196
  *(buf___3->data + 2) = (unsigned char )todo->priority;
#line 197
  if (todo->complete) {
#line 198
    *(buf___3->data + 2) = (unsigned char )((int )*(buf___3->data + 2) | 128);
  }
#line 201
  pos = 3;
#line 202
  if (todo->description) {
    {
#line 203
    strcpy((char */* __restrict  */)((char *)buf___3->data + pos), (char const   */* __restrict  */)todo->description);
#line 204
    tmp___1 = strlen((char const   *)todo->description);
#line 204
    pos = (int )((size_t )pos + (tmp___1 + 1UL));
    }
  } else {
#line 206
    tmp___2 = pos;
#line 206
    pos ++;
#line 206
    *(buf___3->data + tmp___2) = (unsigned char)0;
  }
#line 209
  if (todo->note) {
    {
#line 210
    strcpy((char */* __restrict  */)((char *)buf___3->data + pos), (char const   */* __restrict  */)todo->note);
#line 211
    tmp___3 = strlen((char const   *)todo->note);
#line 211
    pos = (int )((size_t )pos + (tmp___3 + 1UL));
    }
  } else {
#line 213
    tmp___4 = pos;
#line 213
    pos ++;
#line 213
    *(buf___3->data + tmp___4) = (unsigned char)0;
  }
#line 216
  return (0);
}
}
#line 231 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/todo.c"
int unpack_ToDoAppInfo(ToDoAppInfo_t *appinfo , unsigned char const   *record , size_t len ) 
{ 
  int i ;
  unsigned char *start ;

  {
  {
#line 235
  start = (unsigned char *)record;
#line 237
  appinfo->type = (todoType )0;
#line 239
  i = unpack_CategoryAppInfo(& appinfo->category, record, len);
  }
#line 240
  if (! i) {
#line 241
    return (0);
  }
#line 242
  record += i;
#line 243
  len -= (size_t )i;
#line 244
  if (len < 4UL) {
#line 245
    return (0);
  }
#line 246
  appinfo->dirty = (int )((unsigned short )(((int )*((unsigned char *)record + 0) << 8) | (int )*((unsigned char *)record + 1)));
#line 247
  record += 2;
#line 248
  appinfo->sortByPriority = (int )*((unsigned char *)record + 0);
#line 249
  record += 2;
#line 250
  return ((int )(record - (unsigned char const   *)start));
}
}
#line 265 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/todo.c"
int pack_ToDoAppInfo(ToDoAppInfo_t const   *appinfo , unsigned char *record , size_t len ) 
{ 
  int i ;
  unsigned char *start ;

  {
  {
#line 269
  start = record;
#line 271
  i = pack_CategoryAppInfo(& appinfo->category, record, len);
  }
#line 272
  if (! record) {
#line 273
    return (i + 4);
  }
#line 274
  if (! i) {
#line 275
    return (0);
  }
#line 276
  record += i;
#line 277
  len -= (size_t )i;
#line 278
  if (len < 4UL) {
#line 279
    return (0);
  }
#line 280
  *(record + 0) = (unsigned char )(((int )((unsigned short )appinfo->dirty) >> 8) & 255);
#line 280
  *(record + 1) = (unsigned char )((int )((unsigned short )appinfo->dirty) & 255);
#line 281
  *((record + 2) + 0) = (unsigned char )appinfo->sortByPriority;
#line 282
  *((record + 3) + 0) = (unsigned char)0;
#line 283
  record += 4;
#line 285
  return ((int )(record - start));
}
}
#line 36 "../include/pi-datebook.h"
char *DatebookAlarmTypeNames[4] ;
#line 37
char *DatebookRepeatTypeNames[7] ;
#line 97
void free_Appointment(struct Appointment *a ) ;
#line 99
int unpack_Appointment(struct Appointment *a , pi_buffer_t const   *buf___3 , datebookType type ) ;
#line 101
int pack_Appointment(struct Appointment  const  *a , pi_buffer_t *buf___3 , datebookType type ) ;
#line 103
int unpack_AppointmentAppInfo(struct AppointmentAppInfo *ai , unsigned char const   *record ,
                              size_t len ) ;
#line 106
int pack_AppointmentAppInfo(struct AppointmentAppInfo  const  *ai , unsigned char *record ,
                            size_t len ) ;
#line 47 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/datebook.c"
char *DatebookAlarmTypeNames[4]  = {      (char *)"Minutes",      (char *)"Hours",      (char *)"Days",      (char *)((void *)0)};
#line 49 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/datebook.c"
char *DatebookRepeatTypeNames[7]  = {      (char *)"None",      (char *)"Daily",      (char *)"Weekly",      (char *)"MonthlyByDay", 
        (char *)"MonthlyByDate",      (char *)"Yearly",      (char *)((void *)0)};
#line 70 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/datebook.c"
void free_Appointment(struct Appointment *a ) 
{ 


  {
#line 73
  if ((unsigned long )a->exception != (unsigned long )((void *)0)) {
    {
#line 74
    free((void *)a->exception);
#line 75
    a->exception = (struct tm *)((void *)0);
    }
  }
#line 78
  if ((unsigned long )a->description != (unsigned long )((void *)0)) {
    {
#line 79
    free((void *)a->description);
#line 80
    a->description = (char *)((void *)0);
    }
  }
#line 83
  if ((unsigned long )a->note != (unsigned long )((void *)0)) {
    {
#line 84
    free((void *)a->note);
#line 85
    a->note = (char *)((void *)0);
    }
  }
#line 87
  return;
}
}
#line 101 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/datebook.c"
int unpack_Appointment(struct Appointment *a , pi_buffer_t const   *buf___3 , datebookType type ) 
{ 
  int iflags ;
  int j ;
  int destlen ;
  unsigned char *p2 ;
  unsigned long d ;
  int i ;
  int on ;
  int i___0 ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 126
  destlen = 8;
#line 128
  if ((unsigned int )type != 0U) {
#line 129
    return (-1);
  }
#line 131
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
#line 132
    return (-1);
  } else
#line 131
  if ((unsigned long )buf___3->data == (unsigned long )((void *)0)) {
#line 132
    return (-1);
  } else
#line 131
  if (buf___3->used < (size_t const   )destlen) {
#line 132
    return (-1);
  }
#line 134
  a->begin.tm_hour = (int )*((unsigned char *)buf___3->data + 0);
#line 135
  a->begin.tm_min = (int )*((unsigned char *)(buf___3->data + 1) + 0);
#line 136
  a->begin.tm_sec = 0;
#line 137
  d = (unsigned long )((unsigned short )(((int )*((unsigned char *)(buf___3->data + 4) + 0) << 8) | (int )*((unsigned char *)(buf___3->data + 4) + 1)));
#line 138
  a->begin.tm_year = (int )((d >> 9) + 4UL);
#line 139
  a->begin.tm_mon = (int )(((d >> 5) & 15UL) - 1UL);
#line 140
  a->begin.tm_mday = (int )(d & 31UL);
#line 141
  a->begin.tm_isdst = -1;
#line 142
  a->end = a->begin;
#line 144
  a->end.tm_hour = (int )*((unsigned char *)(buf___3->data + 2) + 0);
#line 145
  a->end.tm_min = (int )*((unsigned char *)(buf___3->data + 3) + 0);
#line 147
  if ((int )((unsigned short )(((int )*((unsigned char *)buf___3->data + 0) << 8) | (int )*((unsigned char *)buf___3->data + 1))) == 65535) {
#line 148
    a->event = 1;
#line 149
    a->begin.tm_hour = 0;
#line 150
    a->begin.tm_min = 0;
#line 151
    a->end.tm_hour = 0;
#line 152
    a->end.tm_min = 0;
  } else {
#line 154
    a->event = 0;
  }
  {
#line 157
  mktime(& a->begin);
#line 158
  mktime(& a->end);
#line 160
  iflags = (int )*((unsigned char *)(buf___3->data + 6) + 0);
#line 164
  p2 = (unsigned char *)buf___3->data + 8;
  }
#line 166
  if (iflags & 64) {
#line 167
    a->alarm = 1;
#line 168
    a->advance = (int )*(p2 + 0);
#line 169
    p2 ++;
#line 170
    a->advanceUnits = (int )*(p2 + 0);
#line 171
    p2 ++;
  } else {
#line 174
    a->alarm = 0;
#line 175
    a->advance = 0;
#line 176
    a->advanceUnits = 0;
  }
#line 179
  if (iflags & 32) {
#line 183
    a->repeatType = (enum repeatTypes )*(p2 + 0);
#line 184
    p2 += 2;
#line 185
    d = (unsigned long )((unsigned short )(((int )*(p2 + 0) << 8) | (int )*(p2 + 1)));
#line 186
    p2 += 2;
#line 187
    if (d == 65535UL) {
#line 188
      a->repeatForever = 1;
    } else {
      {
#line 190
      a->repeatEnd.tm_year = (int )((d >> 9) + 4UL);
#line 191
      a->repeatEnd.tm_mon = (int )(((d >> 5) & 15UL) - 1UL);
#line 192
      a->repeatEnd.tm_mday = (int )(d & 31UL);
#line 193
      a->repeatEnd.tm_min = 0;
#line 194
      a->repeatEnd.tm_hour = 0;
#line 195
      a->repeatEnd.tm_sec = 0;
#line 196
      a->repeatEnd.tm_isdst = -1;
#line 197
      mktime(& a->repeatEnd);
#line 198
      a->repeatForever = 0;
      }
    }
#line 200
    a->repeatFrequency = (int )*(p2 + 0);
#line 201
    p2 ++;
#line 202
    on = (int )*(p2 + 0);
#line 203
    p2 ++;
#line 204
    a->repeatDay = (enum DayOfMonthType )0;
#line 205
    i = 0;
    {
#line 205
    while (1) {
      while_continue: /* CIL Label */ ;
#line 205
      if (! (i < 7)) {
#line 205
        goto while_break;
      }
#line 206
      a->repeatDays[i] = 0;
#line 205
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 208
    if ((unsigned int )a->repeatType == 3U) {
#line 209
      a->repeatDay = (enum DayOfMonthType )on;
    } else
#line 210
    if ((unsigned int )a->repeatType == 2U) {
#line 211
      i = 0;
      {
#line 211
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 211
        if (! (i < 7)) {
#line 211
          goto while_break___0;
        }
#line 212
        a->repeatDays[i] = ! (! (on & (1 << i)));
#line 211
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 213
    a->repeatWeekstart = (int )*(p2 + 0);
#line 214
    p2 ++;
#line 215
    p2 ++;
  } else {
#line 219
    a->repeatType = (enum repeatTypes )0;
#line 220
    a->repeatForever = 1;
#line 221
    a->repeatFrequency = 0;
#line 222
    a->repeatDay = (enum DayOfMonthType )0;
#line 223
    i___0 = 0;
    {
#line 223
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 223
      if (! (i___0 < 7)) {
#line 223
        goto while_break___1;
      }
#line 224
      a->repeatDays[i___0] = 0;
#line 223
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 225
    a->repeatWeekstart = 0;
  }
#line 228
  if (iflags & 8) {
    {
#line 229
    a->exceptions = (int )((unsigned short )(((int )*(p2 + 0) << 8) | (int )*(p2 + 1)));
#line 230
    p2 += 2;
#line 231
    tmp = malloc(sizeof(struct tm ) * (unsigned long )a->exceptions);
#line 231
    a->exception = (struct tm *)tmp;
#line 233
    j = 0;
    }
    {
#line 233
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 233
      if (! (j < a->exceptions)) {
#line 233
        goto while_break___2;
      }
      {
#line 234
      d = (unsigned long )((unsigned short )(((int )*(p2 + 0) << 8) | (int )*(p2 + 1)));
#line 235
      (a->exception + j)->tm_year = (int )((d >> 9) + 4UL);
#line 236
      (a->exception + j)->tm_mon = (int )(((d >> 5) & 15UL) - 1UL);
#line 237
      (a->exception + j)->tm_mday = (int )(d & 31UL);
#line 238
      (a->exception + j)->tm_hour = 0;
#line 239
      (a->exception + j)->tm_min = 0;
#line 240
      (a->exception + j)->tm_sec = 0;
#line 241
      (a->exception + j)->tm_isdst = -1;
#line 242
      mktime(a->exception + j);
#line 233
      j ++;
#line 233
      p2 += 2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 246
    a->exceptions = 0;
#line 247
    a->exception = (struct tm *)0;
  }
#line 250
  if (iflags & 4) {
    {
#line 251
    a->description = strdup((char const   *)((char *)p2));
#line 252
    tmp___0 = strlen((char const   *)((char *)p2));
#line 252
    p2 += tmp___0 + 1UL;
    }
  } else {
#line 254
    a->description = (char *)0;
  }
#line 256
  if (iflags & 16) {
    {
#line 257
    a->note = strdup((char const   *)((char *)p2));
#line 258
    tmp___1 = strlen((char const   *)((char *)p2));
#line 258
    p2 += tmp___1 + 1UL;
    }
  } else {
#line 260
    a->note = (char *)0;
  }
#line 262
  return (0);
}
}
#line 280 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/datebook.c"
int pack_Appointment(struct Appointment  const  *a , pi_buffer_t *buf___3 , datebookType type ) 
{ 
  int iflags ;
  int destlen ;
  char *pos ;
  size_t tmp ;
  size_t tmp___0 ;
  int i ;
  int on ;
  int i___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 283
  destlen = 8;
#line 287
  if ((unsigned long )a == (unsigned long )((void *)0)) {
#line 288
    return (-1);
  } else
#line 287
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
#line 288
    return (-1);
  }
#line 290
  if ((unsigned int )type != 0U) {
#line 291
    return (-1);
  }
#line 293
  if (a->alarm) {
#line 294
    destlen += 2;
  }
#line 295
  if (a->repeatType) {
#line 296
    destlen += 8;
  }
#line 297
  if (a->exceptions) {
#line 298
    destlen += 2 + 2 * (int )a->exceptions;
  }
#line 299
  if (a->note) {
    {
#line 300
    tmp = strlen((char const   *)a->note);
#line 300
    destlen = (int )((size_t )destlen + (tmp + 1UL));
    }
  }
#line 301
  if (a->description) {
    {
#line 302
    tmp___0 = strlen((char const   *)a->description);
#line 302
    destlen = (int )((size_t )destlen + (tmp___0 + 1UL));
    }
  }
  {
#line 304
  pi_buffer_expect(buf___3, (size_t )destlen);
#line 305
  buf___3->used = (size_t )destlen;
#line 307
  *(buf___3->data + 0) = (unsigned char )a->begin.tm_hour;
#line 308
  *((buf___3->data + 1) + 0) = (unsigned char )a->begin.tm_min;
#line 309
  *((buf___3->data + 2) + 0) = (unsigned char )a->end.tm_hour;
#line 310
  *((buf___3->data + 3) + 0) = (unsigned char )a->end.tm_min;
#line 311
  *((buf___3->data + 4) + 0) = (unsigned char )(((int )((unsigned short )((((a->begin.tm_year - 4) << 9) | ((a->begin.tm_mon + 1) << 5)) | a->begin.tm_mday)) >> 8) & 255);
#line 311
  *((buf___3->data + 4) + 1) = (unsigned char )((int )((unsigned short )((((a->begin.tm_year - 4) << 9) | ((a->begin.tm_mon + 1) << 5)) | a->begin.tm_mday)) & 255);
  }
#line 317
  if (a->event) {
#line 318
    *(buf___3->data + 0) = (unsigned char )((int )((unsigned char )(4294967295UL >> 24)) & 255);
#line 318
    *(buf___3->data + 1) = (unsigned char )((4294967295UL >> 16) & 255UL);
#line 318
    *(buf___3->data + 2) = (unsigned char )((4294967295UL >> 8) & 255UL);
#line 318
    *(buf___3->data + 3) = (unsigned char)255;
  }
#line 321
  iflags = 0;
#line 323
  pos = (char *)buf___3->data + 8;
#line 325
  if (a->alarm) {
#line 326
    iflags |= 64;
#line 328
    *((unsigned char *)pos + 0) = (unsigned char )a->advance;
#line 329
    *((unsigned char *)(pos + 1) + 0) = (unsigned char )a->advanceUnits;
#line 330
    pos += 2;
  }
#line 333
  if (a->repeatType) {
#line 337
    iflags |= 32;
#line 339
    if ((unsigned int const   )a->repeatType == 3U) {
#line 340
      on = (int )a->repeatDay;
    } else
#line 341
    if ((unsigned int const   )a->repeatType == 2U) {
#line 342
      on = 0;
#line 343
      i = 0;
      {
#line 343
      while (1) {
        while_continue: /* CIL Label */ ;
#line 343
        if (! (i < 7)) {
#line 343
          goto while_break;
        }
#line 344
        if (a->repeatDays[i]) {
#line 345
          on |= 1 << i;
        }
#line 343
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 347
      on = 0;
    }
#line 349
    *((unsigned char *)pos + 0) = (unsigned char )a->repeatType;
#line 350
    *((unsigned char *)(pos + 1) + 0) = (unsigned char)0;
#line 351
    pos += 2;
#line 353
    if (a->repeatForever) {
#line 354
      *((unsigned char *)pos + 0) = (unsigned char )((65535 >> 8) & 255);
#line 354
      *((unsigned char *)pos + 1) = (unsigned char)255;
    } else {
#line 356
      *((unsigned char *)pos + 0) = (unsigned char )(((int )((unsigned short )((((a->repeatEnd.tm_year - 4) << 9) | ((a->repeatEnd.tm_mon + 1) << 5)) | a->repeatEnd.tm_mday)) >> 8) & 255);
#line 356
      *((unsigned char *)pos + 1) = (unsigned char )((int )((unsigned short )((((a->repeatEnd.tm_year - 4) << 9) | ((a->repeatEnd.tm_mon + 1) << 5)) | a->repeatEnd.tm_mday)) & 255);
    }
#line 363
    pos += 2;
#line 365
    *((unsigned char *)pos + 0) = (unsigned char )a->repeatFrequency;
#line 366
    pos ++;
#line 367
    *((unsigned char *)pos + 0) = (unsigned char )on;
#line 368
    pos ++;
#line 369
    *((unsigned char *)pos + 0) = (unsigned char )a->repeatWeekstart;
#line 370
    pos ++;
#line 371
    *((unsigned char *)pos + 0) = (unsigned char)0;
#line 372
    pos ++;
  }
#line 375
  if (a->exceptions) {
#line 378
    iflags |= 8;
#line 380
    *((unsigned char *)pos + 0) = (unsigned char )(((int )((unsigned short )a->exceptions) >> 8) & 255);
#line 380
    *((unsigned char *)pos + 1) = (unsigned char )((int )((unsigned short )a->exceptions) & 255);
#line 381
    pos += 2;
#line 383
    i___0 = 0;
    {
#line 383
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 383
      if (! (i___0 < (int )a->exceptions)) {
#line 383
        goto while_break___0;
      }
#line 384
      *((unsigned char *)pos + 0) = (unsigned char )(((int )((unsigned short )(((((a->exception + i___0)->tm_year - 4) << 9) | (((a->exception + i___0)->tm_mon + 1) << 5)) | (a->exception + i___0)->tm_mday)) >> 8) & 255);
#line 384
      *((unsigned char *)pos + 1) = (unsigned char )((int )((unsigned short )(((((a->exception + i___0)->tm_year - 4) << 9) | (((a->exception + i___0)->tm_mon + 1) << 5)) | (a->exception + i___0)->tm_mday)) & 255);
#line 383
      i___0 ++;
#line 383
      pos += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 392
  if ((unsigned long )a->description != (unsigned long )((void *)0)) {
    {
#line 393
    iflags |= 4;
#line 395
    strcpy((char */* __restrict  */)pos, (char const   */* __restrict  */)a->description);
#line 396
    tmp___1 = strlen((char const   *)pos);
#line 396
    pos += tmp___1 + 1UL;
    }
  }
#line 399
  if ((unsigned long )a->note != (unsigned long )((void *)0)) {
    {
#line 400
    iflags |= 16;
#line 402
    strcpy((char */* __restrict  */)pos, (char const   */* __restrict  */)a->note);
#line 403
    tmp___2 = strlen((char const   *)pos);
#line 403
    pos += tmp___2 + 1UL;
    }
  }
#line 406
  *((buf___3->data + 6) + 0) = (unsigned char )iflags;
#line 407
  *((buf___3->data + 7) + 0) = (unsigned char)0;
#line 409
  return (0);
}
}
#line 426 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/datebook.c"
int unpack_AppointmentAppInfo(struct AppointmentAppInfo *ai , unsigned char const   *record ,
                              size_t len ) 
{ 
  int i ;

  {
  {
#line 432
  i = unpack_CategoryAppInfo(& ai->category, record, len);
  }
#line 433
  if (! i) {
#line 434
    return (0);
  }
#line 435
  record += i;
#line 436
  len -= (size_t )i;
#line 437
  if (len < 2UL) {
#line 438
    return (0);
  }
#line 439
  ai->startOfWeek = (int )*((unsigned char *)record + 0);
#line 440
  return (i + 2);
}
}
#line 457 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/datebook.c"
int pack_AppointmentAppInfo(struct AppointmentAppInfo  const  *ai , unsigned char *record ,
                            size_t len ) 
{ 
  int i ;
  unsigned char *start ;

  {
  {
#line 462
  start = record;
#line 464
  i = pack_CategoryAppInfo(& ai->category, record, len);
  }
#line 465
  if (! record) {
#line 466
    return (i + 2);
  }
#line 467
  if (! i) {
#line 468
    return (i);
  }
#line 469
  record += i;
#line 470
  len -= (size_t )i;
#line 471
  if (len < 2UL) {
#line 472
    return (0);
  }
#line 473
  *(record + 0) = (unsigned char)0;
#line 473
  *(record + 1) = (unsigned char)0;
#line 474
  *(record + 0) = (unsigned char )ai->startOfWeek;
#line 475
  record += 2;
#line 477
  return ((int )(record - start));
}
}
#line 41 "../include/pi-sys.h"
ssize_t sys_tx(pi_socket_t *ps , unsigned char const   *buf___3 , size_t len , int flags ) ;
#line 44
ssize_t sys_rx(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) ;
#line 48
void sys_dump_header(unsigned char const   *data , int rxtx ) ;
#line 50
void sys_dump(unsigned char const   *data , size_t len ) ;
#line 41 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
static int sys_flush(pi_socket_t *ps , int flags ) ;
#line 42
static int sys_getsockopt(pi_socket_t *ps , int level , int option_name , void *option_value ,
                          size_t *option_len ) ;
#line 44
static int sys_setsockopt(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                          size_t *option_len ) ;
#line 59 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
static pi_protocol_t *sys_protocol_dup(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  pi_sys_data_t *data ;
  pi_sys_data_t *new_data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 62
  new_prot = (pi_protocol_t *)((void *)0);
#line 63
  data = (pi_sys_data_t *)((void *)0);
#line 63
  new_data = (pi_sys_data_t *)((void *)0);
#line 66
  tmp = malloc(sizeof(pi_protocol_t ));
#line 66
  new_prot = (pi_protocol_t *)tmp;
  }
#line 67
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
    {
#line 68
    tmp___0 = malloc(sizeof(pi_sys_data_t ));
#line 68
    new_data = (pi_sys_data_t *)tmp___0;
    }
#line 69
    if ((unsigned long )new_data == (unsigned long )((void *)0)) {
      {
#line 70
      free((void *)new_prot);
#line 71
      new_prot = (pi_protocol_t *)((void *)0);
      }
    }
  }
#line 75
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 75
    if ((unsigned long )new_data != (unsigned long )((void *)0)) {
#line 76
      new_prot->level = prot->level;
#line 77
      new_prot->dup = prot->dup;
#line 78
      new_prot->free = prot->free;
#line 79
      new_prot->read = prot->read;
#line 80
      new_prot->write = prot->write;
#line 81
      new_prot->flush = prot->flush;
#line 82
      new_prot->getsockopt = prot->getsockopt;
#line 83
      new_prot->setsockopt = prot->setsockopt;
#line 85
      data = (pi_sys_data_t *)prot->data;
#line 86
      new_data->txid = data->txid;
#line 87
      new_prot->data = (void *)new_data;
    }
  }
#line 90
  return (new_prot);
}
}
#line 105 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
static void sys_protocol_free(pi_protocol_t *prot ) 
{ 


  {
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 109
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c",
             109, "prot != NULL");
      }
    }
#line 109
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 111
    if ((unsigned long )prot->data != (unsigned long )((void *)0)) {
      {
#line 112
      free(prot->data);
      }
    }
    {
#line 113
    free((void *)prot);
    }
  }
#line 115
  return;
}
}
#line 129 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
pi_protocol_t *sys_protocol(void) 
{ 
  pi_protocol_t *prot ;
  pi_sys_data_t *data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 132
  prot = (pi_protocol_t *)((void *)0);
#line 133
  data = (pi_sys_data_t *)((void *)0);
#line 135
  tmp = malloc(sizeof(pi_protocol_t ));
#line 135
  prot = (pi_protocol_t *)tmp;
  }
#line 136
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
    {
#line 137
    tmp___0 = malloc(sizeof(pi_sys_data_t ));
#line 137
    data = (pi_sys_data_t *)tmp___0;
    }
#line 138
    if ((unsigned long )data == (unsigned long )((void *)0)) {
      {
#line 139
      free((void *)prot);
#line 140
      prot = (pi_protocol_t *)((void *)0);
      }
    }
  }
#line 144
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 144
    if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 145
      prot->level = 4;
#line 146
      prot->dup = & sys_protocol_dup;
#line 147
      prot->free = & sys_protocol_free;
#line 148
      prot->read = & sys_rx;
#line 149
      prot->write = & sys_tx;
#line 150
      prot->flush = & sys_flush;
#line 151
      prot->getsockopt = & sys_getsockopt;
#line 152
      prot->setsockopt = & sys_setsockopt;
#line 154
      data->txid = (unsigned char)0;
#line 155
      prot->data = (void *)data;
    }
  }
#line 158
  return (prot);
}
}
#line 173 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
ssize_t sys_tx(pi_socket_t *ps , unsigned char const   *buf___3 , size_t len , int flags ) 
{ 
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  pi_sys_data_t *data ;
  int type ;
  int socket___0 ;
  size_t size ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 186
  prot = pi_protocol(ps->sd, 4);
  }
#line 187
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 188
    tmp = pi_set_error(ps->sd, -201);
    }
#line 188
    return ((ssize_t )tmp);
  }
  {
#line 190
  data = (pi_sys_data_t *)prot->data;
#line 192
  next = pi_protocol_next(ps->sd, 4);
  }
#line 193
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 194
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 194
    return ((ssize_t )tmp___0);
  }
#line 196
  if (! data->txid) {
#line 197
    data->txid = (unsigned char)17;
  } else
#line 196
  if ((int )data->txid == 255) {
#line 197
    data->txid = (unsigned char)17;
  }
#line 198
  data->txid = (unsigned char )((int )data->txid + 1);
#line 199
  if (! data->txid) {
#line 200
    data->txid = (unsigned char)17;
  } else
#line 199
  if ((int )data->txid == 255) {
#line 200
    data->txid = (unsigned char)17;
  }
  {
#line 202
  type = 0;
#line 205
  socket___0 = 1;
#line 206
  size = sizeof(type);
#line 207
  pi_setsockopt(ps->sd, 1, 4, (void const   *)(& type), & size);
#line 209
  pi_setsockopt(ps->sd, 1, 0, (void const   *)(& socket___0), & size);
#line 211
  pi_setsockopt(ps->sd, 1, 2, (void const   *)(& socket___0), & size);
#line 213
  size = sizeof(data->txid);
#line 214
  pi_setsockopt(ps->sd, 1, 6, (void const   *)(& data->txid), & size);
#line 217
  tmp___1 = (*(next->write))(ps, buf___3, len, flags);
#line 217
  len = (size_t )tmp___1;
  }
#line 218
  if (len >= 0UL) {
    {
#line 219
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 219
      tmp___2 = pi_debug_get_types();
      }
#line 219
      if (tmp___2 & 1) {
        {
#line 219
        tmp___3 = pi_debug_get_level();
        }
#line 219
        if (tmp___3 >= 4) {
          {
#line 219
          sys_dump_header(buf___3, 1);
          }
        }
      }
#line 219
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 220
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 220
      tmp___4 = pi_debug_get_types();
      }
#line 220
      if (tmp___4 & 1) {
        {
#line 220
        tmp___5 = pi_debug_get_level();
        }
#line 220
        if (tmp___5 >= 8) {
          {
#line 220
          sys_dump(buf___3, len);
          }
        }
      }
#line 220
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 223
  return ((ssize_t )len);
}
}
#line 238 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
ssize_t sys_rx(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) 
{ 
  pi_protocol_t *next ;
  pi_protocol_t *prot ;
  pi_sys_data_t *data ;
  size_t data_len ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 247
  prot = pi_protocol(ps->sd, 4);
  }
#line 248
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 249
    tmp = pi_set_error(ps->sd, -201);
    }
#line 249
    return ((ssize_t )tmp);
  }
  {
#line 251
  data = (pi_sys_data_t *)prot->data;
#line 252
  next = pi_protocol_next(ps->sd, 4);
  }
#line 253
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 254
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 254
    return ((ssize_t )tmp___0);
  }
  {
#line 256
  tmp___1 = (*(next->read))(ps, buf___3, len, flags);
#line 256
  data_len = (size_t )tmp___1;
  }
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 258
    tmp___2 = pi_debug_get_types();
    }
#line 258
    if (tmp___2 & 1) {
      {
#line 258
      tmp___3 = pi_debug_get_level();
      }
#line 258
      if (tmp___3 >= 4) {
        {
#line 258
        sys_dump_header((unsigned char const   *)buf___3->data, 0);
        }
      }
    }
#line 258
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 259
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 259
    tmp___4 = pi_debug_get_types();
    }
#line 259
    if (tmp___4 & 1) {
      {
#line 259
      tmp___5 = pi_debug_get_level();
      }
#line 259
      if (tmp___5 >= 8) {
        {
#line 259
        sys_dump((unsigned char const   *)buf___3->data, data_len);
        }
      }
    }
#line 259
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 261
  return ((ssize_t )data_len);
}
}
#line 275 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
static int sys_flush(pi_socket_t *ps , int flags ) 
{ 
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 281
  prot = pi_protocol(ps->sd, 4);
  }
#line 282
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 283
    tmp = pi_set_error(ps->sd, -201);
    }
#line 283
    return (tmp);
  }
  {
#line 285
  next = pi_protocol_next(ps->sd, 4);
  }
#line 286
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 287
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 287
    return (tmp___0);
  }
  {
#line 289
  tmp___1 = (*(next->flush))(ps, flags);
  }
#line 289
  return (tmp___1);
}
}
#line 303 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
static int sys_getsockopt(pi_socket_t *ps , int level , int option_name , void *option_value ,
                          size_t *option_len ) 
{ 


  {
#line 307
  return (0);
}
}
#line 322 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
static int sys_setsockopt(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                          size_t *option_len ) 
{ 


  {
#line 326
  return (0);
}
}
#line 341 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
void sys_dump_header(unsigned char const   *data , int rxtx ) 
{ 
  char const   *tmp ;

  {
#line 344
  if (rxtx) {
#line 344
    tmp = "TX";
  } else {
#line 344
    tmp = "RX";
  }
  {
#line 344
  pi_log(1, 0, "SYS %s\n", tmp);
  }
#line 346
  return;
}
}
#line 360 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
void sys_dump(unsigned char const   *data , size_t len ) 
{ 


  {
  {
#line 363
  pi_dumpdata((char const   *)((char *)(data + 0)), len);
  }
#line 364
  return;
}
}
#line 66 "../include/pi-versamail.h"
int unpack_VersaMail(struct VersaMail *a , char *buffer , size_t len ) ;
#line 69
int pack_VersaMail(struct VersaMail *a , char *buffer , size_t len ) ;
#line 72
void free_VersaMail(struct VersaMail *a ) ;
#line 75
int unpack_VersaMailAppInfo(struct VersaMailAppInfo *ai , unsigned char *record ,
                            size_t len ) ;
#line 55 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/versamail.c"
void free_VersaMail(struct VersaMail *a ) 
{ 


  {
#line 57
  if (a->messageUID) {
    {
#line 58
    free((void *)a->messageUID);
    }
  }
#line 59
  if (a->to) {
    {
#line 60
    free((void *)a->to);
    }
  }
#line 61
  if (a->from) {
    {
#line 62
    free((void *)a->from);
    }
  }
#line 63
  if (a->cc) {
    {
#line 64
    free((void *)a->cc);
    }
  }
#line 65
  if (a->bcc) {
    {
#line 66
    free((void *)a->bcc);
    }
  }
#line 67
  if (a->subject) {
    {
#line 68
    free((void *)a->subject);
    }
  }
#line 69
  if (a->dateString) {
    {
#line 70
    free((void *)a->dateString);
    }
  }
#line 71
  if (a->body) {
    {
#line 72
    free((void *)a->body);
    }
  }
#line 73
  if (a->replyTo) {
    {
#line 74
    free((void *)a->replyTo);
    }
  }
#line 75
  if (a->unknown3) {
    {
#line 76
    free(a->unknown3);
    }
  }
#line 77
  return;
}
}
#line 129 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/versamail.c"
int unpack_VersaMail(struct VersaMail *a , char *buffer , size_t len ) 
{ 
  time_t date_t ;
  struct tm *date_tm ;
  char *start ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  void *tmp___18 ;

  {
  {
#line 133
  start = buffer;
#line 136
  a->imapuid = ((((unsigned long )*((unsigned char *)buffer + 0) << 24) | ((unsigned long )*((unsigned char *)buffer + 1) << 16)) | ((unsigned long )*((unsigned char *)buffer + 2) << 8)) | (unsigned long )*((unsigned char *)buffer + 3);
#line 137
  len -= 4UL;
#line 137
  buffer += 4;
#line 143
  date_t = (time_t )(((((unsigned long )*((unsigned char *)buffer + 0) << 24) | ((unsigned long )*((unsigned char *)buffer + 1) << 16)) | ((unsigned long )*((unsigned char *)buffer + 2) << 8)) | (unsigned long )*((unsigned char *)buffer + 3));
#line 144
  date_t -= 2082844800L;
#line 145
  date_tm = localtime((time_t const   *)(& date_t));
#line 146
  memcpy((void */* __restrict  */)(& a->date), (void const   */* __restrict  */)date_tm,
         sizeof(struct tm ));
#line 147
  len -= 4UL;
#line 147
  buffer += 4;
#line 150
  a->category = (unsigned int )((unsigned short )(((int )*((unsigned char *)buffer + 0) << 8) | (int )*((unsigned char *)buffer + 1)));
#line 150
  len -= 2UL;
#line 150
  buffer += 2;
#line 153
  a->accountNo = (unsigned int )((unsigned short )(((int )*((unsigned char *)buffer + 0) << 8) | (int )*((unsigned char *)buffer + 1)));
#line 153
  len -= 2UL;
#line 153
  buffer += 2;
#line 156
  a->unknown1 = (unsigned int )((unsigned short )(((int )*((unsigned char *)buffer + 0) << 8) | (int )*((unsigned char *)buffer + 1)));
#line 156
  len -= 2UL;
#line 156
  buffer += 2;
#line 158
  a->download = (unsigned int )*((unsigned char *)buffer + 0);
#line 158
  len --;
#line 158
  buffer ++;
#line 160
  a->mark = (unsigned int )*((unsigned char *)buffer + 0);
#line 160
  len --;
#line 160
  buffer ++;
#line 166
  a->unknown2 = (unsigned int )((unsigned short )(((int )*((unsigned char *)buffer + 0) << 8) | (int )*((unsigned char *)buffer + 1)));
#line 166
  len -= 2UL;
#line 166
  buffer += 2;
#line 169
  a->reserved1 = (unsigned int )*((unsigned char *)buffer + 0);
#line 170
  a->reserved2 = (unsigned int )((int )*((unsigned char *)(buffer + 1) + 0) >> 1);
  }
#line 171
  if (*((unsigned char *)(buffer + 1) + 0)) {
#line 171
    tmp = 1;
  } else {
#line 171
    tmp = 0;
  }
#line 171
  a->read = (unsigned int )tmp;
#line 172
  len -= 2UL;
#line 172
  buffer += 2;
#line 185
  a->msgSize = (unsigned int )(((((unsigned long )*((unsigned char *)buffer + 0) << 24) | ((unsigned long )*((unsigned char *)buffer + 1) << 16)) | ((unsigned long )*((unsigned char *)buffer + 2) << 8)) | (unsigned long )*((unsigned char *)buffer + 3));
#line 186
  len -= 4UL;
#line 186
  buffer += 4;
#line 188
  if (*((unsigned char *)buffer + 0)) {
    {
#line 188
    a->messageUID = strdup((char const   *)buffer);
#line 188
    tmp___0 = strlen((char const   *)buffer);
#line 188
    len -= tmp___0;
#line 188
    tmp___1 = strlen((char const   *)buffer);
#line 188
    buffer += tmp___1;
    }
  } else {
#line 188
    a->messageUID = (char *)((void *)0);
  }
#line 188
  buffer ++;
#line 188
  len --;
#line 189
  if (*((unsigned char *)buffer + 0)) {
    {
#line 189
    a->to = strdup((char const   *)buffer);
#line 189
    tmp___2 = strlen((char const   *)buffer);
#line 189
    len -= tmp___2;
#line 189
    tmp___3 = strlen((char const   *)buffer);
#line 189
    buffer += tmp___3;
    }
  } else {
#line 189
    a->to = (char *)((void *)0);
  }
#line 189
  buffer ++;
#line 189
  len --;
#line 190
  if (*((unsigned char *)buffer + 0)) {
    {
#line 190
    a->from = strdup((char const   *)buffer);
#line 190
    tmp___4 = strlen((char const   *)buffer);
#line 190
    len -= tmp___4;
#line 190
    tmp___5 = strlen((char const   *)buffer);
#line 190
    buffer += tmp___5;
    }
  } else {
#line 190
    a->from = (char *)((void *)0);
  }
#line 190
  buffer ++;
#line 190
  len --;
#line 191
  if (*((unsigned char *)buffer + 0)) {
    {
#line 191
    a->cc = strdup((char const   *)buffer);
#line 191
    tmp___6 = strlen((char const   *)buffer);
#line 191
    len -= tmp___6;
#line 191
    tmp___7 = strlen((char const   *)buffer);
#line 191
    buffer += tmp___7;
    }
  } else {
#line 191
    a->cc = (char *)((void *)0);
  }
#line 191
  buffer ++;
#line 191
  len --;
#line 192
  if (*((unsigned char *)buffer + 0)) {
    {
#line 192
    a->bcc = strdup((char const   *)buffer);
#line 192
    tmp___8 = strlen((char const   *)buffer);
#line 192
    len -= tmp___8;
#line 192
    tmp___9 = strlen((char const   *)buffer);
#line 192
    buffer += tmp___9;
    }
  } else {
#line 192
    a->bcc = (char *)((void *)0);
  }
#line 192
  buffer ++;
#line 192
  len --;
#line 193
  if (*((unsigned char *)buffer + 0)) {
    {
#line 193
    a->subject = strdup((char const   *)buffer);
#line 193
    tmp___10 = strlen((char const   *)buffer);
#line 193
    len -= tmp___10;
#line 193
    tmp___11 = strlen((char const   *)buffer);
#line 193
    buffer += tmp___11;
    }
  } else {
#line 193
    a->subject = (char *)((void *)0);
  }
#line 193
  buffer ++;
#line 193
  len --;
#line 194
  if (*((unsigned char *)buffer + 0)) {
    {
#line 194
    a->dateString = strdup((char const   *)buffer);
#line 194
    tmp___12 = strlen((char const   *)buffer);
#line 194
    len -= tmp___12;
#line 194
    tmp___13 = strlen((char const   *)buffer);
#line 194
    buffer += tmp___13;
    }
  } else {
#line 194
    a->dateString = (char *)((void *)0);
  }
#line 194
  buffer ++;
#line 194
  len --;
#line 195
  if (*((unsigned char *)buffer + 0)) {
    {
#line 195
    a->body = strdup((char const   *)buffer);
#line 195
    tmp___14 = strlen((char const   *)buffer);
#line 195
    len -= tmp___14;
#line 195
    tmp___15 = strlen((char const   *)buffer);
#line 195
    buffer += tmp___15;
    }
  } else {
#line 195
    a->body = (char *)((void *)0);
  }
#line 195
  buffer ++;
#line 195
  len --;
#line 196
  if (*((unsigned char *)buffer + 0)) {
    {
#line 196
    a->replyTo = strdup((char const   *)buffer);
#line 196
    tmp___16 = strlen((char const   *)buffer);
#line 196
    len -= tmp___16;
#line 196
    tmp___17 = strlen((char const   *)buffer);
#line 196
    buffer += tmp___17;
    }
  } else {
#line 196
    a->replyTo = (char *)((void *)0);
  }
#line 196
  buffer ++;
#line 196
  len --;
#line 198
  a->unknown3length = 0U;
#line 199
  a->unknown3 = (void *)0;
#line 200
  a->attachmentCount = 0U;
#line 201
  if (len > 0UL) {
    {
#line 202
    tmp___18 = malloc(len);
#line 202
    a->unknown3 = tmp___18;
#line 235
    a->attachmentCount = (unsigned int )(len / 4UL - 1UL);
    }
#line 236
    if (a->unknown3) {
      {
#line 237
      a->unknown3length = (unsigned int )len;
#line 238
      memcpy((void */* __restrict  */)a->unknown3, (void const   */* __restrict  */)buffer,
             len);
#line 239
      len -= len;
#line 239
      buffer += len;
      }
    }
  }
#line 243
  return ((int )(buffer - start));
}
}
#line 246 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/versamail.c"
int pack_VersaMail(struct VersaMail *a , char *buffer , size_t len ) 
{ 
  time_t date_t ;
  unsigned int destlen ;
  char *start ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;

  {
#line 250
  start = buffer;
#line 252
  destlen = 24U + a->unknown3length;
#line 254
  if (a->messageUID) {
    {
#line 254
    tmp = strlen((char const   *)a->messageUID);
#line 254
    destlen = (unsigned int )((size_t )destlen + (1UL + tmp));
    }
  } else {
#line 254
    destlen ++;
  }
#line 255
  if (a->to) {
    {
#line 255
    tmp___0 = strlen((char const   *)a->to);
#line 255
    destlen = (unsigned int )((size_t )destlen + (1UL + tmp___0));
    }
  } else {
#line 255
    destlen ++;
  }
#line 256
  if (a->from) {
    {
#line 256
    tmp___1 = strlen((char const   *)a->from);
#line 256
    destlen = (unsigned int )((size_t )destlen + (1UL + tmp___1));
    }
  } else {
#line 256
    destlen ++;
  }
#line 257
  if (a->cc) {
    {
#line 257
    tmp___2 = strlen((char const   *)a->cc);
#line 257
    destlen = (unsigned int )((size_t )destlen + (1UL + tmp___2));
    }
  } else {
#line 257
    destlen ++;
  }
#line 258
  if (a->bcc) {
    {
#line 258
    tmp___3 = strlen((char const   *)a->bcc);
#line 258
    destlen = (unsigned int )((size_t )destlen + (1UL + tmp___3));
    }
  } else {
#line 258
    destlen ++;
  }
#line 259
  if (a->subject) {
    {
#line 259
    tmp___4 = strlen((char const   *)a->subject);
#line 259
    destlen = (unsigned int )((size_t )destlen + (1UL + tmp___4));
    }
  } else {
#line 259
    destlen ++;
  }
#line 260
  if (a->dateString) {
    {
#line 260
    tmp___5 = strlen((char const   *)a->dateString);
#line 260
    destlen = (unsigned int )((size_t )destlen + (1UL + tmp___5));
    }
  } else {
#line 260
    destlen ++;
  }
#line 261
  if (a->body) {
    {
#line 261
    tmp___6 = strlen((char const   *)a->body);
#line 261
    destlen = (unsigned int )((size_t )destlen + (1UL + tmp___6));
    }
  } else {
#line 261
    destlen ++;
  }
#line 262
  if (a->replyTo) {
    {
#line 262
    tmp___7 = strlen((char const   *)a->replyTo);
#line 262
    destlen = (unsigned int )((size_t )destlen + (1UL + tmp___7));
    }
  } else {
#line 262
    destlen ++;
  }
#line 264
  if (! buffer) {
#line 265
    return ((int )destlen);
  }
#line 267
  if (len < (size_t )destlen) {
#line 268
    return (0);
  }
  {
#line 270
  *((unsigned char *)buffer + 0) = (unsigned char )((int )((unsigned char )(a->imapuid >> 24)) & 255);
#line 270
  *((unsigned char *)buffer + 1) = (unsigned char )((a->imapuid >> 16) & 255UL);
#line 270
  *((unsigned char *)buffer + 2) = (unsigned char )((a->imapuid >> 8) & 255UL);
#line 270
  *((unsigned char *)buffer + 3) = (unsigned char )(a->imapuid & 255UL);
#line 271
  len -= 4UL;
#line 271
  buffer += 4;
#line 273
  date_t = mktime(& a->date);
#line 274
  date_t += 2082844800L;
#line 275
  *((unsigned char *)buffer + 0) = (unsigned char )((int )((unsigned char )((unsigned long )date_t >> 24)) & 255);
#line 275
  *((unsigned char *)buffer + 1) = (unsigned char )(((unsigned long )date_t >> 16) & 255UL);
#line 275
  *((unsigned char *)buffer + 2) = (unsigned char )(((unsigned long )date_t >> 8) & 255UL);
#line 275
  *((unsigned char *)buffer + 3) = (unsigned char )((unsigned long )date_t & 255UL);
#line 276
  len -= 4UL;
#line 276
  buffer += 4;
#line 278
  *((unsigned char *)buffer + 0) = (unsigned char )(((int )((unsigned short )a->category) >> 8) & 255);
#line 278
  *((unsigned char *)buffer + 1) = (unsigned char )((int )((unsigned short )a->category) & 255);
#line 279
  len -= 2UL;
#line 279
  buffer += 2;
#line 280
  *((unsigned char *)buffer + 0) = (unsigned char )(((int )((unsigned short )a->accountNo) >> 8) & 255);
#line 280
  *((unsigned char *)buffer + 1) = (unsigned char )((int )((unsigned short )a->accountNo) & 255);
#line 281
  len -= 2UL;
#line 281
  buffer += 2;
#line 282
  *((unsigned char *)buffer + 0) = (unsigned char )(((int )((unsigned short )a->unknown1) >> 8) & 255);
#line 282
  *((unsigned char *)buffer + 1) = (unsigned char )((int )((unsigned short )a->unknown1) & 255);
#line 283
  len -= 2UL;
#line 283
  buffer += 2;
#line 284
  *((unsigned char *)buffer + 0) = (unsigned char )a->download;
#line 285
  len --;
#line 285
  buffer ++;
#line 286
  *((unsigned char *)buffer + 0) = (unsigned char )a->mark;
#line 287
  len --;
#line 287
  buffer ++;
#line 288
  *((unsigned char *)buffer + 0) = (unsigned char )(((int )((unsigned short )a->unknown2) >> 8) & 255);
#line 288
  *((unsigned char *)buffer + 1) = (unsigned char )((int )((unsigned short )a->unknown2) & 255);
#line 289
  len -= 2UL;
#line 289
  buffer += 2;
#line 291
  *((unsigned char *)buffer + 0) = (unsigned char )a->reserved1;
  }
#line 292
  if (a->reserved2 << 1) {
#line 292
    tmp___8 = 1;
  } else
#line 292
  if (a->read) {
#line 292
    tmp___8 = 1;
  } else {
#line 292
    tmp___8 = 0;
  }
#line 292
  *((unsigned char *)(buffer + 1) + 0) = (unsigned char )tmp___8;
#line 293
  len -= 2UL;
#line 293
  buffer += 2;
#line 295
  *((unsigned char *)buffer + 0) = (unsigned char )((int )((unsigned char )((unsigned long )a->msgSize >> 24)) & 255);
#line 295
  *((unsigned char *)buffer + 1) = (unsigned char )(((unsigned long )a->msgSize >> 16) & 255UL);
#line 295
  *((unsigned char *)buffer + 2) = (unsigned char )(((unsigned long )a->msgSize >> 8) & 255UL);
#line 295
  *((unsigned char *)buffer + 3) = (unsigned char )((unsigned long )a->msgSize & 255UL);
#line 296
  len -= 4UL;
#line 296
  buffer += 4;
#line 298
  if (a->messageUID) {
    {
#line 298
    strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)a->messageUID);
#line 298
    tmp___9 = strlen((char const   *)buffer);
#line 298
    len -= tmp___9;
#line 298
    tmp___10 = strlen((char const   *)buffer);
#line 298
    buffer += tmp___10;
    }
  } else {
#line 298
    *((unsigned char *)buffer + 0) = (unsigned char)0;
  }
#line 298
  buffer ++;
#line 298
  len --;
#line 299
  if (a->to) {
    {
#line 299
    strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)a->to);
#line 299
    tmp___11 = strlen((char const   *)buffer);
#line 299
    len -= tmp___11;
#line 299
    tmp___12 = strlen((char const   *)buffer);
#line 299
    buffer += tmp___12;
    }
  } else {
#line 299
    *((unsigned char *)buffer + 0) = (unsigned char)0;
  }
#line 299
  buffer ++;
#line 299
  len --;
#line 300
  if (a->from) {
    {
#line 300
    strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)a->from);
#line 300
    tmp___13 = strlen((char const   *)buffer);
#line 300
    len -= tmp___13;
#line 300
    tmp___14 = strlen((char const   *)buffer);
#line 300
    buffer += tmp___14;
    }
  } else {
#line 300
    *((unsigned char *)buffer + 0) = (unsigned char)0;
  }
#line 300
  buffer ++;
#line 300
  len --;
#line 301
  if (a->cc) {
    {
#line 301
    strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)a->cc);
#line 301
    tmp___15 = strlen((char const   *)buffer);
#line 301
    len -= tmp___15;
#line 301
    tmp___16 = strlen((char const   *)buffer);
#line 301
    buffer += tmp___16;
    }
  } else {
#line 301
    *((unsigned char *)buffer + 0) = (unsigned char)0;
  }
#line 301
  buffer ++;
#line 301
  len --;
#line 302
  if (a->bcc) {
    {
#line 302
    strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)a->bcc);
#line 302
    tmp___17 = strlen((char const   *)buffer);
#line 302
    len -= tmp___17;
#line 302
    tmp___18 = strlen((char const   *)buffer);
#line 302
    buffer += tmp___18;
    }
  } else {
#line 302
    *((unsigned char *)buffer + 0) = (unsigned char)0;
  }
#line 302
  buffer ++;
#line 302
  len --;
#line 303
  if (a->subject) {
    {
#line 303
    strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)a->subject);
#line 303
    tmp___19 = strlen((char const   *)buffer);
#line 303
    len -= tmp___19;
#line 303
    tmp___20 = strlen((char const   *)buffer);
#line 303
    buffer += tmp___20;
    }
  } else {
#line 303
    *((unsigned char *)buffer + 0) = (unsigned char)0;
  }
#line 303
  buffer ++;
#line 303
  len --;
#line 304
  if (a->dateString) {
    {
#line 304
    strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)a->dateString);
#line 304
    tmp___21 = strlen((char const   *)buffer);
#line 304
    len -= tmp___21;
#line 304
    tmp___22 = strlen((char const   *)buffer);
#line 304
    buffer += tmp___22;
    }
  } else {
#line 304
    *((unsigned char *)buffer + 0) = (unsigned char)0;
  }
#line 304
  buffer ++;
#line 304
  len --;
#line 305
  if (a->body) {
    {
#line 305
    strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)a->body);
#line 305
    tmp___23 = strlen((char const   *)buffer);
#line 305
    len -= tmp___23;
#line 305
    tmp___24 = strlen((char const   *)buffer);
#line 305
    buffer += tmp___24;
    }
  } else {
#line 305
    *((unsigned char *)buffer + 0) = (unsigned char)0;
  }
#line 305
  buffer ++;
#line 305
  len --;
#line 306
  if (a->replyTo) {
    {
#line 306
    strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)a->replyTo);
#line 306
    tmp___25 = strlen((char const   *)buffer);
#line 306
    len -= tmp___25;
#line 306
    tmp___26 = strlen((char const   *)buffer);
#line 306
    buffer += tmp___26;
    }
  } else {
#line 306
    *((unsigned char *)buffer + 0) = (unsigned char)0;
  }
#line 306
  buffer ++;
#line 306
  len --;
#line 308
  if (a->unknown3length > 0U) {
    {
#line 309
    memcpy((void */* __restrict  */)buffer, (void const   */* __restrict  */)a->unknown3,
           (size_t )a->unknown3length);
    }
  }
#line 312
  return ((int )(buffer - start));
}
}
#line 315 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/versamail.c"
int unpack_VersaMailAppInfo(struct VersaMailAppInfo *ai , unsigned char *record ,
                            size_t len ) 
{ 
  int i ;
  unsigned char *start ;

  {
  {
#line 319
  start = record;
#line 321
  i = unpack_CategoryAppInfo(& ai->category, (unsigned char const   *)record, len);
  }
#line 322
  if (! i) {
#line 323
    return (i);
  }
#line 324
  record += i;
#line 325
  len -= (size_t )i;
#line 327
  return ((int )(record - start));
}
}
#line 31 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
static int debug_types___0  =    0;
#line 32 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
static int debug_level___0  =    0;
#line 33 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
static FILE *debug_file___0  =    (FILE *)((void *)0);
#line 34 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
static int logfile_mutex___0  =    0;
#line 63 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_list_t *ps_list_append___0(pi_socket_list_t *list , pi_socket_t *ps ) ;
#line 65
static pi_socket_t *ps_list_find___0(pi_socket_list_t *list , int pi_sd ) ;
#line 67
static pi_socket_list_t *ps_list_remove___0(pi_socket_list_t *list , int pi_sd ) ;
#line 69
static pi_socket_list_t *ps_list_copy___0(pi_socket_list_t *list ) ;
#line 70
static void ps_list_free___0(pi_socket_list_t *list ) ;
#line 72
static void protocol_queue_add___0(pi_socket_t *ps , pi_protocol_t *prot ) ;
#line 73
static void protocol_cmd_queue_add___0(pi_socket_t *ps , pi_protocol_t *prot ) ;
#line 74
static pi_protocol_t *protocol_queue_find___0(pi_socket_t *ps , int level ) ;
#line 75
static pi_protocol_t *protocol_queue_find_next___0(pi_socket_t *ps , int level ) ;
#line 79
static int is_connected___0(pi_socket_t *ps ) ;
#line 80
static int is_listener___0(pi_socket_t *ps ) ;
#line 83 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static int psl_mutex___0  =    0;
#line 84 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_list_t *psl___0  =    (pi_socket_list_t *)((void *)0);
#line 86 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static int watch_list_mutex___0  =    0;
#line 87 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_list_t *watch_list___0  =    (pi_socket_list_t *)((void *)0);
#line 90 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static unsigned int interval___0  =    0U;
#line 133 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_list_t *ps_list_append___0(pi_socket_list_t *list , pi_socket_t *ps ) 
{ 
  pi_socket_list_t *elem ;
  pi_socket_list_t *new_elem ;
  void *tmp ;

  {
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! ((unsigned long )ps != (unsigned long )((void *)0))) {
      {
#line 138
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c",
             138, "ps != NULL");
      }
    }
#line 138
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 140
  tmp = malloc(sizeof(pi_socket_list_t ));
#line 140
  new_elem = (pi_socket_list_t *)tmp;
  }
#line 141
  if ((unsigned long )new_elem == (unsigned long )((void *)0)) {
#line 142
    return (list);
  }
#line 144
  new_elem->ps = ps;
#line 145
  new_elem->next = (struct pi_socket_list *)((void *)0);
#line 147
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 148
    return (new_elem);
  }
#line 150
  elem = list;
  {
#line 151
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 151
    if (! ((unsigned long )elem->next != (unsigned long )((void *)0))) {
#line 151
      goto while_break___0;
    }
#line 152
    elem = elem->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 153
  elem->next = new_elem;
#line 155
  return (list);
}
}
#line 177 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_t *ps_list_find___0(pi_socket_list_t *list , int pi_sd ) 
{ 
  pi_socket_list_t *elem ;

  {
#line 182
  elem = list;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! ((unsigned long )elem != (unsigned long )((void *)0))) {
#line 182
      goto while_break;
    }
#line 183
    if ((unsigned long )elem->ps != (unsigned long )((void *)0)) {
#line 183
      if ((elem->ps)->sd == pi_sd) {
#line 184
        return (elem->ps);
      }
    }
#line 182
    elem = elem->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return ((pi_socket_t *)((void *)0));
}
}
#line 207 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_list_t *ps_list_remove___0(pi_socket_list_t *list , int pi_sd ) 
{ 
  pi_socket_list_t *elem ;
  pi_socket_list_t *new_list ;
  pi_socket_list_t *prev_elem ;

  {
#line 210
  new_list = list;
#line 210
  prev_elem = (pi_socket_list_t *)((void *)0);
#line 214
  elem = list;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! ((unsigned long )elem != (unsigned long )((void *)0))) {
#line 214
      goto while_break;
    }
#line 215
    if ((unsigned long )elem->ps == (unsigned long )((void *)0)) {
#line 216
      goto __Cont;
    } else
#line 217
    if ((elem->ps)->sd == pi_sd) {
#line 218
      if ((unsigned long )prev_elem == (unsigned long )((void *)0)) {
#line 219
        new_list = elem->next;
      } else {
#line 221
        prev_elem->next = elem->next;
      }
      {
#line 222
      free((void *)elem);
      }
#line 223
      goto while_break;
    }
#line 225
    prev_elem = elem;
    __Cont: /* CIL Label */ 
#line 214
    elem = elem->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  return (new_list);
}
}
#line 246 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_list_t *ps_list_copy___0(pi_socket_list_t *list ) 
{ 
  pi_socket_list_t *l ;
  pi_socket_list_t *new_list ;

  {
#line 249
  new_list = (pi_socket_list_t *)((void *)0);
#line 251
  l = list;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 251
      goto while_break;
    }
    {
#line 252
    new_list = ps_list_append___0(new_list, l->ps);
#line 251
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  return (new_list);
}
}
#line 274 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void ps_list_free___0(pi_socket_list_t *list ) 
{ 
  pi_socket_list_t *l ;
  pi_socket_list_t *next ;

  {
#line 279
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 280
    return;
  }
#line 282
  l = list;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 284
    next = l->next;
#line 285
    free((void *)l);
#line 286
    l = next;
    }
#line 283
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 283
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return;
}
}
#line 302 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void protocol_queue_add___0(pi_socket_t *ps , pi_protocol_t *prot ) 
{ 
  void *tmp ;
  int *tmp___0 ;

  {
  {
#line 305
  tmp = realloc((void *)ps->protocol_queue, sizeof(pi_protocol_t *) * (unsigned long )(ps->queue_len + 1));
#line 305
  ps->protocol_queue = (struct pi_protocol **)tmp;
  }
#line 307
  if ((unsigned long )ps->protocol_queue != (unsigned long )((void *)0)) {
#line 308
    *(ps->protocol_queue + ps->queue_len) = prot;
#line 309
    (ps->queue_len) ++;
  } else {
    {
#line 311
    tmp___0 = __errno_location();
#line 311
    *tmp___0 = 12;
#line 312
    ps->queue_len = 0;
    }
  }
#line 314
  return;
}
}
#line 328 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void protocol_cmd_queue_add___0(pi_socket_t *ps , pi_protocol_t *prot ) 
{ 
  void *tmp ;
  int *tmp___0 ;

  {
  {
#line 331
  tmp = realloc((void *)ps->cmd_queue, sizeof(pi_protocol_t *) * (unsigned long )(ps->cmd_len + 1));
#line 331
  ps->cmd_queue = (struct pi_protocol **)tmp;
  }
#line 333
  if ((unsigned long )ps->cmd_queue != (unsigned long )((void *)0)) {
#line 334
    *(ps->cmd_queue + ps->cmd_len) = prot;
#line 335
    (ps->cmd_len) ++;
  } else {
    {
#line 337
    tmp___0 = __errno_location();
#line 337
    *tmp___0 = 12;
#line 338
    ps->cmd_len = 0;
    }
  }
#line 340
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_protocol_t *protocol_queue_find___0(pi_socket_t *ps , int level ) 
{ 
  int i ;

  {
#line 359
  if (ps->command) {
#line 360
    i = 0;
    {
#line 360
    while (1) {
      while_continue: /* CIL Label */ ;
#line 360
      if (! (i < ps->cmd_len)) {
#line 360
        goto while_break;
      }
#line 361
      if ((*(ps->cmd_queue + i))->level == level) {
#line 362
        return (*(ps->cmd_queue + i));
      }
#line 360
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 365
    i = 0;
    {
#line 365
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 365
      if (! (i < ps->queue_len)) {
#line 365
        goto while_break___0;
      }
#line 366
      if ((*(ps->protocol_queue + i))->level == level) {
#line 367
        return (*(ps->protocol_queue + i));
      }
#line 365
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 371
  return ((pi_protocol_t *)((void *)0));
}
}
#line 386 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_protocol_t *protocol_queue_find_next___0(pi_socket_t *ps , int level ) 
{ 
  int i ;

  {
#line 391
  if (ps->command) {
#line 391
    if (ps->cmd_len == 0) {
#line 392
      return ((pi_protocol_t *)((void *)0));
    }
  }
#line 394
  if (! ps->command) {
#line 394
    if (ps->queue_len == 0) {
#line 395
      return ((pi_protocol_t *)((void *)0));
    }
  }
#line 397
  if (ps->command) {
#line 397
    if (level == 0) {
#line 398
      return (*(ps->cmd_queue + 0));
    }
  }
#line 400
  if (! ps->command) {
#line 400
    if (level == 0) {
#line 401
      return (*(ps->protocol_queue + 0));
    }
  }
#line 403
  if (ps->command) {
#line 404
    i = 0;
    {
#line 404
    while (1) {
      while_continue: /* CIL Label */ ;
#line 404
      if (! (i < ps->cmd_len - 1)) {
#line 404
        goto while_break;
      }
#line 405
      if ((*(ps->cmd_queue + i))->level == level) {
#line 406
        return (*(ps->cmd_queue + (i + 1)));
      }
#line 404
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 409
    i = 0;
    {
#line 409
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 409
      if (! (i < ps->queue_len - 1)) {
#line 409
        goto while_break___0;
      }
#line 410
      if ((*(ps->protocol_queue + i))->level == level) {
#line 411
        return (*(ps->protocol_queue + (i + 1)));
      }
#line 409
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 415
  return ((pi_protocol_t *)((void *)0));
}
}
#line 430 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void protocol_queue_build___0(pi_socket_t *ps , int autodetect ) 
{ 
  int protocol ;
  int result ;
  pi_protocol_t *dev_prot ;
  pi_protocol_t *dev_cmd_prot ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int skipped_bytes ;
  int bytes_to_skip ;
  pi_buffer_t *detect_buf ;
  pi_buffer_t *tmp___5 ;
  ssize_t tmp___6 ;
  int i ;
  unsigned char header_checksum ;
  ssize_t tmp___7 ;
  pi_protocol_t *tmp___8 ;
  pi_protocol_t *tmp___9 ;
  pi_protocol_t *tmp___10 ;
  pi_protocol_t *tmp___11 ;
  pi_protocol_t *tmp___12 ;
  pi_protocol_t *tmp___13 ;
  pi_protocol_t *tmp___14 ;
  pi_protocol_t *tmp___15 ;
  pi_protocol_t *tmp___16 ;

  {
  {
#line 439
  pi_log(128, 8, "SOCK fd=%d auto=%d\n", ps->sd, autodetect);
#line 442
  dev_prot = (*((ps->device)->protocol))(ps->device);
#line 443
  dev_cmd_prot = (*((ps->device)->protocol))(ps->device);
  }
#line 446
  if (ps->type == 48) {
    {
#line 447
    pi_log(128, 8, "RAW mode, no protocol\n", ps->sd, autodetect);
#line 448
    protocol_queue_add___0(ps, dev_prot);
#line 449
    protocol_cmd_queue_add___0(ps, dev_cmd_prot);
    }
#line 450
    return;
  }
#line 453
  protocol = ps->protocol;
#line 455
  if (protocol == 1) {
#line 455
    tmp___4 = "DEV";
  } else {
#line 455
    if (protocol == 2) {
#line 455
      tmp___3 = "SLP";
    } else {
#line 455
      if (protocol == 3) {
#line 455
        tmp___2 = "SYS";
      } else {
#line 455
        if (protocol == 4) {
#line 455
          tmp___1 = "PADP";
        } else {
#line 455
          if (protocol == 5) {
#line 455
            tmp___0 = "NET";
          } else {
#line 455
            if (protocol == 6) {
#line 455
              tmp = "DLP";
            } else {
#line 455
              tmp = "unknown";
            }
#line 455
            tmp___0 = tmp;
          }
#line 455
          tmp___1 = tmp___0;
        }
#line 455
        tmp___2 = tmp___1;
      }
#line 455
      tmp___3 = tmp___2;
    }
#line 455
    tmp___4 = tmp___3;
  }
  {
#line 455
  pi_log(128, 8, "SOCK proto=%s (%d)\n", tmp___4, protocol);
  }
#line 464
  if (protocol == 6) {
#line 464
    if (autodetect) {
      {
#line 465
      skipped_bytes = 0;
#line 467
      tmp___5 = pi_buffer_new((size_t )64);
#line 467
      detect_buf = tmp___5;
      }
      {
#line 470
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 472
        tmp___6 = (*(dev_prot->read))(ps, detect_buf, (size_t )10, 1);
#line 472
        result = (int )tmp___6;
        }
#line 473
        if (result < 0) {
#line 474
          goto while_break;
        }
#line 475
        if (result != 10) {
          {
#line 476
          pi_buffer_clear(detect_buf);
          }
#line 477
          goto __Cont;
        }
#line 480
        bytes_to_skip = 1;
#line 483
        if ((int )*(detect_buf->data + 0) == 190) {
#line 483
          if ((int )*(detect_buf->data + 1) == 239) {
#line 483
            if ((int )*(detect_buf->data + 2) == 237) {
#line 490
              i = 0;
#line 490
              header_checksum = (unsigned char )i;
              {
#line 490
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 490
                if (! (i < 9)) {
#line 490
                  goto while_break___0;
                }
#line 491
                header_checksum = (unsigned char )((int )header_checksum + (int )*(detect_buf->data + i));
#line 490
                i ++;
              }
              while_break___0: /* CIL Label */ ;
              }
#line 493
              if ((int )header_checksum == (int )*(detect_buf->data + 9)) {
#line 494
                if ((int )*(detect_buf->data + 3) == 3) {
#line 494
                  if ((int )*(detect_buf->data + 4) == 3) {
#line 494
                    if ((int )*(detect_buf->data + 5) == 2) {
#line 494
                      if ((int )*(detect_buf->data + 8) == 255) {
                        {
#line 499
                        protocol = 4;
#line 500
                        pi_log(128, 4, "\nusing PADP/SLP protocol (skipped %d bytes)\n",
                               skipped_bytes);
                        }
#line 503
                        goto while_break;
                      } else {
#line 507
                        bytes_to_skip = 10;
                      }
                    } else {
#line 507
                      bytes_to_skip = 10;
                    }
                  } else {
#line 507
                    bytes_to_skip = 10;
                  }
                } else {
#line 507
                  bytes_to_skip = 10;
                }
              } else {
#line 511
                bytes_to_skip = 3;
              }
            } else {
#line 483
              goto _L___5;
            }
          } else {
#line 483
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 516
        if ((int )*(detect_buf->data + 0) == 1) {
#line 516
          if ((int )*(detect_buf->data + 2) == 0) {
#line 516
            if ((int )*(detect_buf->data + 3) == 0) {
#line 516
              if ((int )*(detect_buf->data + 4) == 0) {
#line 516
                if ((int )*(detect_buf->data + 5) > 0) {
#line 516
                  if ((int )*(detect_buf->data + 6) == 144) {
                    {
#line 523
                    protocol = 5;
#line 524
                    pi_log(128, 4, "\nusing NET protocol (skipped %d bytes)\n", skipped_bytes);
                    }
#line 527
                    goto while_break;
                  } else {
#line 516
                    goto _L___3;
                  }
                } else {
#line 516
                  goto _L___3;
                }
              } else {
#line 516
                goto _L___3;
              }
            } else {
#line 516
              goto _L___3;
            }
          } else {
#line 516
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 535
        if ((int )*(detect_buf->data + 0) == 144) {
#line 535
          if ((int )*(detect_buf->data + 1) == 1) {
#line 535
            if ((int )*(detect_buf->data + 2) == 0) {
#line 535
              if ((int )*(detect_buf->data + 3) == 0) {
#line 535
                if ((int )*(detect_buf->data + 4) == 0) {
#line 535
                  if ((int )*(detect_buf->data + 5) == 0) {
#line 535
                    if ((int )*(detect_buf->data + 6) == 0) {
#line 535
                      if ((int )*(detect_buf->data + 7) == 0) {
#line 535
                        if ((int )*(detect_buf->data + 8) == 0) {
#line 535
                          if ((int )*(detect_buf->data + 9) == 32) {
                            {
#line 546
                            protocol = 5;
#line 547
                            pi_log(128, 4, "\nusing NET protocol (skipped %d bytes)\n",
                                   skipped_bytes);
                            }
#line 550
                            goto while_break;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        {
#line 554
        tmp___7 = (*(dev_prot->read))(ps, detect_buf, (size_t )bytes_to_skip, 0);
#line 554
        result = (int )tmp___7;
        }
#line 555
        if (result < 0) {
#line 556
          goto while_break;
        }
        {
#line 557
        skipped_bytes += bytes_to_skip;
#line 558
        pi_buffer_clear(detect_buf);
        }
        __Cont: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 561
      pi_buffer_free(detect_buf);
      }
#line 563
      if (result < 0) {
        {
#line 568
        pi_log(128, 8, "Error: last read returned %d; switching to PADP by default\n",
               result);
#line 571
        protocol = 4;
        }
      }
    } else {
#line 464
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 574
  if (protocol == 6) {
#line 575
    protocol = 4;
  }
  {
#line 580
  if (protocol == 4) {
#line 580
    goto case_4;
  }
#line 582
  if (protocol == 2) {
#line 582
    goto case_2;
  }
#line 585
  if (protocol == 5) {
#line 585
    goto case_5;
  }
#line 588
  if (protocol == 3) {
#line 588
    goto case_3;
  }
#line 579
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 581
  tmp___8 = padp_protocol();
#line 581
  protocol_queue_add___0(ps, tmp___8);
  }
  case_2: /* CIL Label */ 
  {
#line 583
  tmp___9 = slp_protocol();
#line 583
  protocol_queue_add___0(ps, tmp___9);
  }
#line 584
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 586
  tmp___10 = net_protocol();
#line 586
  protocol_queue_add___0(ps, tmp___10);
  }
#line 587
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 589
  tmp___11 = sys_protocol();
#line 589
  protocol_queue_add___0(ps, tmp___11);
#line 590
  tmp___12 = slp_protocol();
#line 590
  protocol_queue_add___0(ps, tmp___12);
  }
#line 591
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 597
  if (protocol == 2) {
#line 597
    goto case_2___0;
  }
#line 597
  if (protocol == 4) {
#line 597
    goto case_2___0;
  }
#line 603
  if (protocol == 5) {
#line 603
    goto case_5___0;
  }
#line 607
  if (protocol == 3) {
#line 607
    goto case_3___0;
  }
#line 610
  goto switch_default;
  case_2___0: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  {
#line 598
  tmp___13 = cmp_protocol();
#line 598
  protocol_cmd_queue_add___0(ps, tmp___13);
#line 599
  tmp___14 = padp_protocol();
#line 599
  protocol_cmd_queue_add___0(ps, tmp___14);
#line 600
  tmp___15 = slp_protocol();
#line 600
  protocol_cmd_queue_add___0(ps, tmp___15);
#line 601
  ps->cmd = 1;
  }
#line 602
  goto switch_break___0;
  case_5___0: /* CIL Label */ 
  {
#line 604
  tmp___16 = net_protocol();
#line 604
  protocol_cmd_queue_add___0(ps, tmp___16);
#line 605
  ps->cmd = 2;
  }
#line 606
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 608
  ps->cmd = 3;
#line 609
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 611
  pi_log(128, 1, "invalid protocol (%d)", protocol);
  }
#line 612
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 615
  protocol_queue_add___0(ps, dev_prot);
#line 616
  protocol_cmd_queue_add___0(ps, dev_cmd_prot);
  }
#line 617
  return;
}
}
#line 631 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void protocol_queue_destroy___0(pi_socket_t *ps ) 
{ 
  int i ;

  {
#line 635
  i = 0;
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 635
    if (! (i < ps->queue_len)) {
#line 635
      goto while_break;
    }
    {
#line 636
    (*((*(ps->protocol_queue + i))->free))(*(ps->protocol_queue + i));
#line 635
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 637
  i = 0;
  {
#line 637
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 637
    if (! (i < ps->cmd_len)) {
#line 637
      goto while_break___0;
    }
    {
#line 638
    (*((*(ps->cmd_queue + i))->free))(*(ps->cmd_queue + i));
#line 637
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 640
  if (ps->queue_len > 0) {
    {
#line 641
    free((void *)ps->protocol_queue);
    }
  }
#line 642
  if (ps->cmd_len > 0) {
    {
#line 643
    free((void *)ps->cmd_queue);
    }
  }
#line 644
  return;
}
}
#line 697 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void env_dbgcheck___0(void) 
{ 
  int types ;
  int done ;
  char *debug ;
  char *b ;
  char *e ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int level ;
  char const   *debug___0 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  char const   *logfile ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;

  {
  {
#line 700
  tmp___11 = getenv("PILOT_DEBUG");
  }
#line 700
  if (tmp___11) {
    {
#line 701
    types = 0;
#line 707
    tmp = getenv("PILOT_DEBUG");
#line 707
    debug = strdup((char const   *)tmp);
#line 709
    b = debug;
#line 710
    done = 0;
    }
    {
#line 711
    while (1) {
      while_continue: /* CIL Label */ ;
#line 711
      if (! (! done)) {
#line 711
        goto while_break;
      }
      {
#line 712
      e = strchr((char const   *)b, ' ');
      }
#line 713
      if (e) {
#line 714
        *e = (char )'\000';
      } else {
#line 716
        done = 1;
      }
      {
#line 718
      tmp___10 = strcmp((char const   *)b, "SYS");
      }
#line 718
      if (tmp___10) {
        {
#line 720
        tmp___9 = strcmp((char const   *)b, "DEV");
        }
#line 720
        if (tmp___9) {
          {
#line 722
          tmp___8 = strcmp((char const   *)b, "SLP");
          }
#line 722
          if (tmp___8) {
            {
#line 724
            tmp___7 = strcmp((char const   *)b, "PADP");
            }
#line 724
            if (tmp___7) {
              {
#line 726
              tmp___6 = strcmp((char const   *)b, "DLP");
              }
#line 726
              if (tmp___6) {
                {
#line 728
                tmp___5 = strcmp((char const   *)b, "NET");
                }
#line 728
                if (tmp___5) {
                  {
#line 730
                  tmp___4 = strcmp((char const   *)b, "CMP");
                  }
#line 730
                  if (tmp___4) {
                    {
#line 732
                    tmp___3 = strcmp((char const   *)b, "SOCK");
                    }
#line 732
                    if (tmp___3) {
                      {
#line 734
                      tmp___2 = strcmp((char const   *)b, "API");
                      }
#line 734
                      if (tmp___2) {
                        {
#line 736
                        tmp___1 = strcmp((char const   *)b, "USER");
                        }
#line 736
                        if (tmp___1) {
                          {
#line 738
                          tmp___0 = strcmp((char const   *)b, "ALL");
                          }
#line 738
                          if (! tmp___0) {
#line 739
                            types |= 1024;
                          }
                        } else {
#line 737
                          types |= 512;
                        }
                      } else {
#line 735
                        types |= 256;
                      }
                    } else {
#line 733
                      types |= 128;
                    }
                  } else {
#line 731
                    types |= 64;
                  }
                } else {
#line 729
                  types |= 32;
                }
              } else {
#line 727
                types |= 16;
              }
            } else {
#line 725
              types |= 8;
            }
          } else {
#line 723
            types |= 4;
          }
        } else {
#line 721
          types |= 2;
        }
      } else {
#line 719
        types |= 1;
      }
#line 740
      e ++;
#line 741
      b = e;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 743
    pi_debug_set_types(types);
#line 745
    free((void *)debug);
    }
  }
  {
#line 749
  tmp___18 = getenv("PILOT_DEBUG_LEVEL");
  }
#line 749
  if (tmp___18) {
    {
#line 750
    level = 0;
#line 754
    tmp___12 = getenv("PILOT_DEBUG_LEVEL");
#line 754
    debug___0 = (char const   *)tmp___12;
#line 755
    tmp___17 = strcmp(debug___0, "NONE");
    }
#line 755
    if (tmp___17) {
      {
#line 757
      tmp___16 = strcmp(debug___0, "ERR");
      }
#line 757
      if (tmp___16) {
        {
#line 759
        tmp___15 = strcmp(debug___0, "WARN");
        }
#line 759
        if (tmp___15) {
          {
#line 761
          tmp___14 = strcmp(debug___0, "INFO");
          }
#line 761
          if (tmp___14) {
            {
#line 763
            tmp___13 = strcmp(debug___0, "DEBUG");
            }
#line 763
            if (! tmp___13) {
#line 764
              level |= 8;
            }
          } else {
#line 762
            level |= 4;
          }
        } else {
#line 760
          level |= 2;
        }
      } else {
#line 758
        level |= 1;
      }
    } else {
#line 756
      level = level;
    }
    {
#line 766
    pi_debug_set_level(level);
    }
  }
  {
#line 770
  tmp___20 = getenv("PILOT_LOG");
  }
#line 770
  if (tmp___20) {
    {
#line 770
    tmp___21 = getenv("PILOT_LOG");
#line 770
    tmp___22 = atoi((char const   *)tmp___21);
    }
#line 770
    if (tmp___22) {
      {
#line 773
      tmp___19 = getenv("PILOT_LOGFILE");
#line 773
      logfile = (char const   *)tmp___19;
      }
#line 774
      if ((unsigned long )logfile == (unsigned long )((void *)0)) {
        {
#line 775
        pi_debug_set_file("pilot-link.debug");
        }
      } else {
        {
#line 777
        pi_debug_set_file(logfile);
        }
      }
    }
  }
#line 779
  return;
}
}
#line 793 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static int is_connected___0(pi_socket_t *ps ) 
{ 
  int tmp ;

  {
#line 796
  if (ps->state == 4) {
#line 796
    tmp = 1;
  } else
#line 796
  if (ps->state == 2) {
#line 796
    tmp = 1;
  } else {
#line 796
    tmp = 0;
  }
#line 796
  return (tmp);
}
}
#line 810 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static int is_listener___0(pi_socket_t *ps ) 
{ 
  int tmp ;

  {
#line 813
  if (ps->state == 1) {
#line 813
    tmp = 1;
  } else {
#line 813
    tmp = 0;
  }
#line 813
  return (tmp);
}
}
#line 817 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void onalarm___0(int signo ) 
{ 
  pi_socket_list_t *l ;
  pi_socket_t *ps ;
  int tmp ;
  PI_ERR tmp___0 ;

  {
  {
#line 822
  signal(signo, & onalarm___0);
#line 824
  pi_mutex_lock(& watch_list_mutex___0);
#line 826
  l = watch_list___0;
  }
  {
#line 826
  while (1) {
    while_continue: /* CIL Label */ ;
#line 826
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 826
      goto while_break;
    }
    {
#line 827
    ps = l->ps;
#line 829
    tmp = is_connected___0(ps);
    }
#line 829
    if (! tmp) {
#line 830
      goto __Cont;
    }
    {
#line 832
    tmp___0 = pi_tickle(ps->sd);
    }
#line 832
    if (tmp___0 < 0) {
      {
#line 833
      pi_log(128, 4, "SOCKET Socket %d is busy during tickle\n", ps->sd);
#line 836
      alarm(1U);
      }
    } else {
      {
#line 838
      pi_log(128, 4, "SOCKET Tickling socket %d\n", ps->sd);
#line 840
      alarm(interval___0);
      }
    }
    __Cont: /* CIL Label */ 
#line 826
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 844
  pi_mutex_unlock(& watch_list_mutex___0);
  }
#line 845
  return;
}
}
#line 860 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void onexit___0(void) 
{ 
  pi_socket_list_t *l ;
  pi_socket_list_t *list ;

  {
  {
#line 866
  pi_mutex_lock(& psl_mutex___0);
#line 867
  list = ps_list_copy___0(psl___0);
#line 868
  pi_mutex_unlock(& psl_mutex___0);
#line 870
  l = list;
  }
  {
#line 870
  while (1) {
    while_continue: /* CIL Label */ ;
#line 870
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 870
      goto while_break;
    }
    {
#line 871
    pi_close((l->ps)->sd);
#line 870
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 873
  ps_list_free___0(list);
  }
#line 874
  return;
}
}
#line 888 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void installexit___0(void) 
{ 


  {
#line 891
  if (! pi_sock_installedexit) {
    {
#line 892
    atexit(& onexit___0);
#line 893
    pi_sock_installedexit = 1;
    }
  }
#line 895
  return;
}
}
#line 1020 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_t *pi_devsocket___0(int pi_sd , char const   *port , struct pi_sockaddr *addr ) 
{ 
  pi_socket_t *ps ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1025
  ps = find_pi_socket(pi_sd);
  }
#line 1025
  if (! ps) {
    {
#line 1026
    tmp = __errno_location();
#line 1026
    *tmp = 3;
    }
#line 1027
    return ((pi_socket_t *)((void *)0));
  }
#line 1030
  if ((unsigned long )port == (unsigned long )((void *)0)) {
    {
#line 1030
    tmp___1 = getenv("PILOTPORT");
#line 1030
    port = (char const   *)tmp___1;
    }
#line 1030
    if ((unsigned long )port == (unsigned long )((void *)0)) {
      {
#line 1031
      tmp___0 = __errno_location();
#line 1031
      *tmp___0 = 6;
      }
#line 1032
      return ((pi_socket_t *)((void *)0));
    }
  }
  {
#line 1036
  addr->pi_family = (unsigned short)0;
#line 1037
  tmp___4 = strncmp(port, "serial:", (size_t )7);
  }
#line 1037
  if (tmp___4) {
    {
#line 1041
    tmp___3 = strncmp(port, "usb:", (size_t )4);
    }
#line 1041
    if (tmp___3) {
      {
#line 1045
      tmp___2 = strncmp(port, "net:", (size_t )4);
      }
#line 1045
      if (tmp___2) {
        {
#line 1055
        strncpy((char */* __restrict  */)(addr->pi_device), (char const   */* __restrict  */)port,
                sizeof(addr->pi_device));
#line 1056
        ps->device = pi_serial_device(1);
        }
      } else {
        {
#line 1046
        strncpy((char */* __restrict  */)(addr->pi_device), (char const   */* __restrict  */)(port + 4),
                sizeof(addr->pi_device));
#line 1047
        ps->device = pi_inet_device(1);
        }
      }
    } else {
      {
#line 1042
      strncpy((char */* __restrict  */)(addr->pi_device), (char const   */* __restrict  */)(port + 4),
              sizeof(addr->pi_device));
#line 1043
      ps->device = pi_usb_device(1);
      }
    }
  } else {
    {
#line 1038
    strncpy((char */* __restrict  */)(addr->pi_device), (char const   */* __restrict  */)(port + 7),
            sizeof(addr->pi_device));
#line 1039
    ps->device = pi_serial_device(1);
    }
  }
#line 1059
  return (ps);
}
}
#line 41 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
static int sys_flush___0(pi_socket_t *ps , int flags ) ;
#line 42
static int sys_getsockopt___0(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) ;
#line 44
static int sys_setsockopt___0(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) ;
#line 59 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
static pi_protocol_t *sys_protocol_dup___0(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  pi_sys_data_t *data ;
  pi_sys_data_t *new_data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 62
  new_prot = (pi_protocol_t *)((void *)0);
#line 63
  data = (pi_sys_data_t *)((void *)0);
#line 63
  new_data = (pi_sys_data_t *)((void *)0);
#line 66
  tmp = malloc(sizeof(pi_protocol_t ));
#line 66
  new_prot = (pi_protocol_t *)tmp;
  }
#line 67
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
    {
#line 68
    tmp___0 = malloc(sizeof(pi_sys_data_t ));
#line 68
    new_data = (pi_sys_data_t *)tmp___0;
    }
#line 69
    if ((unsigned long )new_data == (unsigned long )((void *)0)) {
      {
#line 70
      free((void *)new_prot);
#line 71
      new_prot = (pi_protocol_t *)((void *)0);
      }
    }
  }
#line 75
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 75
    if ((unsigned long )new_data != (unsigned long )((void *)0)) {
#line 76
      new_prot->level = prot->level;
#line 77
      new_prot->dup = prot->dup;
#line 78
      new_prot->free = prot->free;
#line 79
      new_prot->read = prot->read;
#line 80
      new_prot->write = prot->write;
#line 81
      new_prot->flush = prot->flush;
#line 82
      new_prot->getsockopt = prot->getsockopt;
#line 83
      new_prot->setsockopt = prot->setsockopt;
#line 85
      data = (pi_sys_data_t *)prot->data;
#line 86
      new_data->txid = data->txid;
#line 87
      new_prot->data = (void *)new_data;
    }
  }
#line 90
  return (new_prot);
}
}
#line 105 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
static void sys_protocol_free___0(pi_protocol_t *prot ) 
{ 


  {
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 109
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c",
             109, "prot != NULL");
      }
    }
#line 109
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 111
    if ((unsigned long )prot->data != (unsigned long )((void *)0)) {
      {
#line 112
      free(prot->data);
      }
    }
    {
#line 113
    free((void *)prot);
    }
  }
#line 115
  return;
}
}
#line 275 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
static int sys_flush___0(pi_socket_t *ps , int flags ) 
{ 
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 281
  prot = pi_protocol(ps->sd, 4);
  }
#line 282
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 283
    tmp = pi_set_error(ps->sd, -201);
    }
#line 283
    return (tmp);
  }
  {
#line 285
  next = pi_protocol_next(ps->sd, 4);
  }
#line 286
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 287
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 287
    return (tmp___0);
  }
  {
#line 289
  tmp___1 = (*(next->flush))(ps, flags);
  }
#line 289
  return (tmp___1);
}
}
#line 303 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
static int sys_getsockopt___0(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) 
{ 


  {
#line 307
  return (0);
}
}
#line 322 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
static int sys_setsockopt___0(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) 
{ 


  {
#line 326
  return (0);
}
}
#line 52 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_connect___0(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
#line 54
static int pi_usb_bind___0(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
#line 56
static int pi_usb_listen___0(pi_socket_t *ps , int backlog ) ;
#line 57
static int pi_usb_accept___0(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) ;
#line 59
static int pi_usb_getsockopt___0(pi_socket_t *ps , int level , int option_name , void *option_value ,
                                 size_t *option_len ) ;
#line 61
static int pi_usb_setsockopt___0(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                                 size_t *option_len ) ;
#line 63
static int pi_usb_close___0(pi_socket_t *ps ) ;
#line 65
static int USB_configure_visor___0(pi_usb_data_t *dev , u_int8_t *input_pipe , u_int8_t *output_pipe ) ;
#line 66
static int USB_configure_generic___0(pi_usb_data_t *dev , u_int8_t *input_pipe , u_int8_t *output_pipe ) ;
#line 118 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static void pi_usb_protocol_free___0(pi_protocol_t *prot ) 
{ 


  {
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 121
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
             121, "prot != NULL");
      }
    }
#line 121
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
    {
#line 124
    free((void *)prot);
    }
  }
#line 125
  return;
}
}
#line 139 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static pi_protocol_t *pi_usb_protocol___0(pi_device_t *dev ) 
{ 
  pi_protocol_t *prot ;
  pi_usb_data_t *data ;
  void *tmp ;

  {
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! ((unsigned long )dev != (unsigned long )((void *)0))) {
      {
#line 145
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
             145, "dev != NULL");
      }
    }
#line 145
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 147
  data = (pi_usb_data_t *)dev->data;
#line 149
  tmp = malloc(sizeof(pi_protocol_t ));
#line 149
  prot = (pi_protocol_t *)tmp;
  }
#line 151
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 152
    prot->level = 0;
#line 153
    prot->dup = & pi_usb_protocol_dup;
#line 154
    prot->free = & pi_usb_protocol_free___0;
#line 155
    prot->read = data->impl.read;
#line 156
    prot->write = data->impl.write;
#line 157
    prot->flush = data->impl.flush;
#line 158
    prot->getsockopt = & pi_usb_getsockopt___0;
#line 159
    prot->setsockopt = & pi_usb_setsockopt___0;
#line 160
    prot->data = (void *)0;
  }
#line 163
  return (prot);
}
}
#line 177 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static void pi_usb_device_free___0(pi_device_t *dev ) 
{ 
  pi_usb_data_t *data ;

  {
#line 180
  data = (pi_usb_data_t *)dev->data;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! ((unsigned long )dev != (unsigned long )((void *)0))) {
      {
#line 182
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
             182, "dev != NULL");
      }
    }
#line 182
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  if ((unsigned long )data != (unsigned long )((void *)0)) {
    {
#line 185
    free((void *)data);
    }
  }
#line 186
  if ((unsigned long )dev != (unsigned long )((void *)0)) {
    {
#line 187
    free((void *)dev);
    }
  }
#line 188
  return;
}
}
#line 247 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_connect___0(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) 
{ 
  struct pi_usb_data *data ;
  struct pi_sockaddr *pa ;
  int result ;
  int timeout ;
  size_t size ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 250
  data = (pi_usb_data_t *)(ps->device)->data;
#line 251
  pa = (struct pi_sockaddr *)addr;
#line 255
  if (ps->type == 16) {
#line 256
    if (ps->protocol == 3) {
#line 257
      tmp = 57600;
#line 257
      data->rate = tmp;
#line 257
      data->establishrate = tmp;
    } else {
#line 259
      if (data->establishrate == -1) {
        {
#line 260
        get_pilot_rate(& data->establishrate, & data->establishhighrate);
        }
      }
#line 263
      data->rate = 9600;
    }
  } else
#line 265
  if (ps->type == 48) {
#line 267
    tmp___0 = 57600;
#line 267
    data->rate = tmp___0;
#line 267
    data->establishrate = tmp___0;
  }
  {
#line 270
  result = (*(data->impl.open))(ps, pa, addrlen);
  }
#line 271
  if (result < 0) {
#line 272
    goto fail;
  }
#line 274
  timeout = ps->accept_to * 1000;
#line 274
  data->timeout = timeout;
#line 276
  if (data->impl.wait_for_device) {
    {
#line 277
    result = (*(data->impl.wait_for_device))(ps, & timeout);
    }
#line 278
    if (result <= 0) {
#line 279
      goto fail;
    }
  }
  {
#line 282
  tmp___1 = malloc(addrlen);
#line 282
  ps->raddr = (struct sockaddr *)tmp___1;
#line 283
  memcpy((void */* __restrict  */)ps->raddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 284
  ps->raddrlen = addrlen;
#line 285
  tmp___2 = malloc(addrlen);
#line 285
  ps->laddr = (struct sockaddr *)tmp___2;
#line 286
  memcpy((void */* __restrict  */)ps->laddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 287
  ps->laddrlen = addrlen;
  }
#line 289
  if (ps->type == 16) {
    {
#line 291
    if (ps->cmd == 1) {
#line 291
      goto case_1;
    }
#line 301
    if (ps->cmd == 2) {
#line 301
      goto case_2;
    }
#line 290
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 292
    result = cmp_tx_handshake(ps);
    }
#line 292
    if (result < 0) {
#line 293
      goto fail;
    }
    {
#line 294
    size = sizeof(data->rate);
#line 295
    pi_getsockopt(ps->sd, 5, 3, (void *)(& data->rate), & size);
#line 297
    result = (*(data->impl.changebaud))(ps);
    }
#line 297
    if (result < 0) {
#line 298
      goto fail;
    }
#line 299
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 302
    result = net_tx_handshake(ps);
    }
#line 302
    if (result < 0) {
#line 303
      goto fail;
    }
#line 304
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 307
  ps->state = 4;
#line 308
  ps->command = 0;
  fail: 
#line 311
  if (result < 0) {
#line 311
    tmp___3 = result;
  } else {
#line 311
    tmp___3 = 0;
  }
#line 311
  return (tmp___3);
}
}
#line 325 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_bind___0(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) 
{ 
  struct pi_usb_data *data ;
  struct pi_sockaddr *pa ;
  int result ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 328
  data = (pi_usb_data_t *)(ps->device)->data;
#line 329
  pa = (struct pi_sockaddr *)addr;
#line 335
  if (ps->type == 16) {
#line 336
    if (data->establishrate == -1) {
      {
#line 337
      get_pilot_rate(& data->establishrate, & data->establishhighrate);
      }
    }
#line 340
    data->rate = 9600;
  } else
#line 341
  if (ps->type == 48) {
#line 343
    tmp = 57600;
#line 343
    data->rate = tmp;
#line 343
    data->establishrate = tmp;
  }
  {
#line 346
  result = (*(data->impl.open))(ps, pa, addrlen);
  }
#line 347
  if (result < 0) {
#line 348
    return (result);
  }
  {
#line 350
  tmp___0 = malloc(addrlen);
#line 350
  ps->raddr = (struct sockaddr *)tmp___0;
#line 351
  memcpy((void */* __restrict  */)ps->raddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 352
  ps->raddrlen = addrlen;
#line 353
  tmp___1 = malloc(addrlen);
#line 353
  ps->laddr = (struct sockaddr *)tmp___1;
#line 354
  memcpy((void */* __restrict  */)ps->laddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 355
  ps->laddrlen = addrlen;
  }
#line 357
  return (0);
}
}
#line 371 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_listen___0(pi_socket_t *ps , int backlog ) 
{ 


  {
#line 374
  ps->state = 1;
#line 375
  return (0);
}
}
#line 389 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_accept___0(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) 
{ 
  struct pi_usb_data *data ;
  int result ;
  int timeout ;
  size_t size ;
  struct timeval tv ;
  unsigned char cmp_flags ;
  int use_long_format ;

  {
#line 392
  data = (pi_usb_data_t *)(ps->device)->data;
#line 397
  timeout = ps->accept_to * 1000;
#line 397
  data->timeout = timeout;
#line 399
  if (data->impl.wait_for_device) {
    {
#line 400
    result = (*(data->impl.wait_for_device))(ps, & timeout);
    }
#line 401
    if (result <= 0) {
#line 402
      return (result);
    }
  }
  {
#line 423
  result = (*(data->impl.poll))(ps, timeout);
  }
#line 424
  if (result <= 0) {
#line 425
    if (result == 0) {
#line 426
      return (-205);
    } else {
#line 428
      return (result);
    }
  }
  {
#line 432
  pi_socket_init(ps);
#line 434
  pi_log(2, 8, "%s: %d, prot: 0x%x, type: 0x%x, cmd: 0x%x.\n", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
         434, ps->protocol, ps->type, ps->cmd);
  }
#line 435
  if (ps->type == 16) {
    {
#line 440
    if (ps->cmd == 1) {
#line 440
      goto case_1;
    }
#line 476
    if (ps->cmd == 2) {
#line 476
      goto case_2;
    }
#line 485
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 441
    pi_log(2, 8, "%s: %d, cmp rx.\n", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
           441);
#line 442
    result = cmp_rx_handshake(ps, data->establishrate, data->establishhighrate);
    }
#line 442
    if (result < 0) {
      {
#line 444
      pi_log(2, 8, "usb.c: cmp_rx_handshake returned %d\n", result);
      }
#line 445
      return (result);
    }
    {
#line 449
    size = sizeof(cmp_flags);
#line 450
    pi_getsockopt(ps->sd, 5, 1, (void *)(& cmp_flags), & size);
    }
#line 451
    if ((int )cmp_flags & 16) {
      {
#line 452
      use_long_format = 1;
#line 453
      size = sizeof(int );
#line 454
      pi_setsockopt(ps->sd, 2, 3, (void const   *)(& use_long_format), & size);
#line 456
      ps->command ^= 1;
#line 457
      pi_setsockopt(ps->sd, 2, 3, (void const   *)(& use_long_format), & size);
#line 459
      ps->command ^= 1;
      }
    }
    {
#line 463
    size = sizeof(data->rate);
#line 464
    pi_getsockopt(ps->sd, 5, 3, (void *)(& data->rate), & size);
    }
#line 465
    if ((unsigned long )data->impl.changebaud != (unsigned long )((void *)0)) {
      {
#line 466
      result = (*(data->impl.changebaud))(ps);
      }
#line 466
      if (result < 0) {
#line 467
        return (result);
      }
      {
#line 470
      tv.tv_sec = (__time_t )0;
#line 471
      tv.tv_usec = (__suseconds_t )50000;
#line 472
      select(0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0,
             (struct timeval */* __restrict  */)(& tv));
      }
    }
#line 474
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 477
    pi_log(2, 8, "%s: %d, net rx.\n", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
           477);
#line 478
    result = net_rx_handshake(ps);
    }
#line 478
    if (result < 0) {
      {
#line 480
      pi_log(2, 8, "usb.c: cmp_rx_handshake returned %d\n", result);
      }
#line 481
      return (result);
    }
#line 483
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 486
    pi_log(2, 1, "%s: %d, unknown rx %x.\n", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
           486, ps->cmd);
    }
#line 487
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 489
    ps->dlprecord = 0;
  }
#line 492
  data->timeout = 0;
#line 493
  ps->command = 0;
#line 494
  ps->state = 2;
#line 495
  return (ps->sd);
}
}
#line 509 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_getsockopt___0(pi_socket_t *ps , int level , int option_name , void *option_value ,
                                 size_t *option_len ) 
{ 
  pi_usb_data_t *data ;
  int *tmp ;
  int tmp___0 ;

  {
#line 513
  data = (pi_usb_data_t *)(ps->device)->data;
  {
#line 516
  if (option_name == 0) {
#line 516
    goto case_0;
  }
#line 522
  if (option_name == 1) {
#line 522
    goto case_1;
  }
#line 529
  if (option_name == 2) {
#line 529
    goto case_2;
  }
#line 536
  if (option_name == 3) {
#line 536
    goto case_3;
  }
#line 515
  goto switch_break;
  case_0: /* CIL Label */ 
#line 517
  if (*option_len != sizeof(data->rate)) {
#line 518
    goto fail;
  }
  {
#line 519
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->rate),
         sizeof(data->rate));
  }
#line 520
  goto switch_break;
  case_1: /* CIL Label */ 
#line 523
  if (*option_len != sizeof(data->establishrate)) {
#line 524
    goto fail;
  }
  {
#line 525
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->establishrate),
         sizeof(data->establishrate));
  }
#line 527
  goto switch_break;
  case_2: /* CIL Label */ 
#line 530
  if (*option_len != sizeof(data->establishhighrate)) {
#line 531
    goto fail;
  }
  {
#line 532
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->establishhighrate),
         sizeof(data->establishhighrate));
  }
#line 534
  goto switch_break;
  case_3: /* CIL Label */ 
#line 537
  if (*option_len != sizeof(data->timeout)) {
#line 538
    goto fail;
  }
  {
#line 539
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->timeout),
         sizeof(data->timeout));
  }
#line 541
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 544
  return (0);
  fail: 
  {
#line 547
  tmp = __errno_location();
#line 547
  *tmp = 22;
#line 548
  tmp___0 = pi_set_error(ps->sd, -501);
  }
#line 548
  return (tmp___0);
}
}
#line 562 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_setsockopt___0(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                                 size_t *option_len ) 
{ 
  pi_usb_data_t *data ;
  int *tmp ;
  int tmp___0 ;

  {
#line 566
  data = (pi_usb_data_t *)(ps->device)->data;
  {
#line 569
  if (option_name == 1) {
#line 569
    goto case_1;
  }
#line 576
  if (option_name == 2) {
#line 576
    goto case_2;
  }
#line 583
  if (option_name == 3) {
#line 583
    goto case_3;
  }
#line 568
  goto switch_break;
  case_1: /* CIL Label */ 
#line 570
  if (*option_len != sizeof(data->establishrate)) {
#line 571
    goto fail;
  }
  {
#line 572
  memcpy((void */* __restrict  */)(& data->establishrate), (void const   */* __restrict  */)option_value,
         sizeof(data->establishrate));
  }
#line 574
  goto switch_break;
  case_2: /* CIL Label */ 
#line 577
  if (*option_len != sizeof(data->establishhighrate)) {
#line 578
    goto fail;
  }
  {
#line 579
  memcpy((void */* __restrict  */)(& data->establishhighrate), (void const   */* __restrict  */)option_value,
         sizeof(data->establishhighrate));
  }
#line 581
  goto switch_break;
  case_3: /* CIL Label */ 
#line 584
  if (*option_len != sizeof(data->timeout)) {
#line 585
    goto fail;
  }
  {
#line 586
  memcpy((void */* __restrict  */)(& data->timeout), (void const   */* __restrict  */)option_value,
         sizeof(data->timeout));
  }
#line 588
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 591
  return (0);
  fail: 
  {
#line 594
  tmp = __errno_location();
#line 594
  *tmp = 22;
#line 595
  tmp___0 = pi_set_error(ps->sd, -501);
  }
#line 595
  return (tmp___0);
}
}
#line 610 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_close___0(pi_socket_t *ps ) 
{ 
  pi_usb_data_t *data ;

  {
#line 613
  data = (pi_usb_data_t *)(ps->device)->data;
#line 615
  if (ps->sd != 0) {
    {
#line 616
    (*(data->impl.close))(ps);
#line 617
    ps->sd = 0;
    }
  }
#line 620
  if ((unsigned long )ps->laddr != (unsigned long )((void *)0)) {
    {
#line 621
    free((void *)ps->laddr);
#line 622
    ps->laddr = (struct sockaddr *)((void *)0);
    }
  }
#line 624
  if ((unsigned long )ps->raddr != (unsigned long )((void *)0)) {
    {
#line 625
    free((void *)ps->raddr);
#line 626
    ps->raddr = (struct sockaddr *)((void *)0);
    }
  }
#line 629
  return (0);
}
}
#line 982 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int USB_configure_visor___0(pi_usb_data_t *dev , u_int8_t *input_pipe , u_int8_t *output_pipe ) 
{ 
  int i ;
  int ret ;
  visor_connection_info_t ci ;
  char *function_str ;

  {
  {
#line 988
  ret = (*(dev->impl.control_request))(dev, 194, 3, 0, 0, (void *)(& ci), (int )sizeof(ci),
                                       0);
  }
#line 989
  if (ret < 0) {
    {
#line 990
    pi_log(2, 1, "usb: VISOR_GET_CONNECTION_INFORMATION failed (err=%08x)\n", ret);
    }
  } else {
    {
#line 992
    pi_log(2, 8, "usb: VISOR_GET_CONNECTION_INFORMATION, num_ports=%d\n", (int )ci.num_ports);
    }
#line 993
    if ((int )ci.num_ports > 2) {
#line 994
      ci.num_ports = (u_int16_t )2;
    }
#line 995
    i = 0;
    {
#line 995
    while (1) {
      while_continue: /* CIL Label */ ;
#line 995
      if (! (i < (int )ci.num_ports)) {
#line 995
        goto while_break;
      }
      {
#line 1000
      if ((int )ci.connections[i].port_function_id == 0) {
#line 1000
        goto case_0;
      }
#line 1003
      if ((int )ci.connections[i].port_function_id == 1) {
#line 1003
        goto case_1;
      }
#line 1006
      if ((int )ci.connections[i].port_function_id == 2) {
#line 1006
        goto case_2;
      }
#line 1009
      if ((int )ci.connections[i].port_function_id == 3) {
#line 1009
        goto case_3;
      }
#line 1012
      if ((int )ci.connections[i].port_function_id == 4) {
#line 1012
        goto case_4;
      }
#line 1015
      goto switch_default;
      case_0: /* CIL Label */ 
#line 1001
      function_str = (char *)"GENERIC";
#line 1002
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1004
      function_str = (char *)"DEBUGGER";
#line 1005
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1007
      function_str = (char *)"HOTSYNC";
#line 1008
      goto switch_break;
      case_3: /* CIL Label */ 
#line 1010
      function_str = (char *)"CONSOLE";
#line 1011
      goto switch_break;
      case_4: /* CIL Label */ 
#line 1013
      function_str = (char *)"REMOTE_FILE_SYSTEM";
#line 1014
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1016
      function_str = (char *)"UNKNOWN";
#line 1017
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 1019
      pi_log(2, 8, "\t[%d] port_function_id=0x%02x (%s)\n", i, (int )ci.connections[i].port_function_id,
             function_str);
#line 1023
      pi_log(2, 8, "\t[%d] port=%d\n", i, (int )ci.connections[i].port);
#line 995
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1027
  return (ret);
}
}
#line 1030 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int USB_configure_generic___0(pi_usb_data_t *dev , u_int8_t *input_pipe , u_int8_t *output_pipe ) 
{ 
  int i ;
  int ret ;
  int hotsync ;
  palm_ext_connection_info_t ci ;
  u_int32_t flags ;
  int tmp ;

  {
  {
#line 1034
  hotsync = 0;
#line 1036
  flags = dev->dev.flags;
#line 1038
  ret = (*(dev->impl.control_request))(dev, 194, 4, 0, 0, (void *)(& ci), (int )sizeof(ci),
                                       0);
  }
#line 1039
  if (ret < 0) {
    {
#line 1040
    pi_log(2, 1, "usb: PALM_GET_EXT_CONNECTION_INFORMATION failed (err=%08x)\n", ret);
    }
  } else {
    {
#line 1042
    pi_log(2, 8, "usb: PALM_GET_EXT_CONNECTION_INFORMATION, num_ports=%d, endpoint_numbers_different=%d\n",
           (int )ci.num_ports, (int )ci.endpoint_numbers_different);
#line 1045
    i = 0;
    }
    {
#line 1045
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1045
      if (! (i < (int )ci.num_ports)) {
#line 1045
        goto while_break;
      }
      {
#line 1046
      pi_log(2, 8, "\t[%d] port_function_id=\'%c%c%c%c\'\n", i, (int )ci.connections[i].port_function_id[0],
             (int )ci.connections[i].port_function_id[1], (int )ci.connections[i].port_function_id[2],
             (int )ci.connections[i].port_function_id[3]);
#line 1052
      pi_log(2, 8, "\t[%d] port=%d\n", i, (int )ci.connections[i].port);
#line 1055
      pi_log(2, 8, "\t[%d] endpoint_info=%d\n", i, (int )ci.connections[i].endpoint_info);
#line 1057
      tmp = memcmp((void const   *)(ci.connections[i].port_function_id), (void const   *)"cnys",
                   (size_t )4);
      }
#line 1057
      if (! tmp) {
#line 1060
        hotsync = 1;
#line 1064
        if (ci.endpoint_numbers_different) {
#line 1065
          if (input_pipe) {
#line 1066
            *input_pipe = (u_int8_t )((int )ci.connections[i].endpoint_info >> 4);
          }
#line 1067
          if (output_pipe) {
#line 1068
            *output_pipe = (u_int8_t )((int )ci.connections[i].endpoint_info & 15);
          }
        } else {
#line 1070
          if (input_pipe) {
#line 1071
            *input_pipe = ci.connections[i].port;
          }
#line 1072
          if (output_pipe) {
#line 1073
            *output_pipe = ci.connections[i].port;
          }
        }
      }
#line 1045
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1078
    if (! hotsync) {
      {
#line 1079
      pi_log(2, 1, "usb: PALM_GET_EXT_CONNECTION_INFORMATION - no hotsync port found.\n",
             ret);
      }
#line 1080
      return (-1);
    }
  }
#line 1084
  if (flags & (unsigned int )(1 << 1)) {
    {
#line 1089
    ret = (*(dev->impl.control_request))(dev, 194, 4, 0, 0, (void *)(& ci), (int )sizeof(ci),
                                         0);
#line 1090
    ret = (*(dev->impl.control_request))(dev, 194, 4, 0, 0, (void *)(& ci), (int )sizeof(ci),
                                         0);
    }
  }
#line 1092
  return (ret);
}
}
#line 47 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
static int slp_flush___0(pi_socket_t *ps , int flags ) ;
#line 48
static int slp_getsockopt___0(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) ;
#line 50
static int slp_setsockopt___0(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) ;
#line 65 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
static pi_protocol_t *slp_protocol_dup___0(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  struct pi_slp_data *data ;
  struct pi_slp_data *new_data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 73
  tmp = malloc(sizeof(pi_protocol_t ));
#line 73
  new_prot = (pi_protocol_t *)tmp;
#line 74
  tmp___0 = malloc(sizeof(struct pi_slp_data ));
#line 74
  new_data = (struct pi_slp_data *)tmp___0;
  }
#line 76
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 76
    if ((unsigned long )new_data != (unsigned long )((void *)0)) {
#line 77
      new_prot->level = prot->level;
#line 78
      new_prot->dup = prot->dup;
#line 79
      new_prot->free = prot->free;
#line 80
      new_prot->read = prot->read;
#line 81
      new_prot->write = prot->write;
#line 82
      new_prot->flush = prot->flush;
#line 83
      new_prot->getsockopt = prot->getsockopt;
#line 84
      new_prot->setsockopt = prot->setsockopt;
#line 86
      data = (struct pi_slp_data *)prot->data;
#line 88
      new_data->dest = data->dest;
#line 89
      new_data->last_dest = data->last_dest;
#line 90
      new_data->src = data->src;
#line 91
      new_data->last_src = data->last_src;
#line 92
      new_data->type = data->type;
#line 93
      new_data->last_type = data->last_type;
#line 94
      new_data->txid = data->txid;
#line 95
      new_data->last_txid = data->last_txid;
#line 97
      new_prot->data = (void *)new_data;
    } else {
#line 76
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 99
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
    {
#line 100
    free((void *)new_prot);
#line 101
    new_prot = (pi_protocol_t *)((void *)0);
    }
  } else
#line 102
  if ((unsigned long )new_data != (unsigned long )((void *)0)) {
    {
#line 103
    free((void *)new_data);
#line 104
    new_data = (struct pi_slp_data *)((void *)0);
    }
  }
#line 107
  return (new_prot);
}
}
#line 122 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
static void slp_protocol_free___0(pi_protocol_t *prot ) 
{ 


  {
#line 125
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 126
    if ((unsigned long )prot->data != (unsigned long )((void *)0)) {
      {
#line 127
      free(prot->data);
      }
    }
    {
#line 128
    free((void *)prot);
    }
  }
#line 130
  return;
}
}
#line 440 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
static int slp_flush___0(pi_socket_t *ps , int flags ) 
{ 
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 446
  prot = pi_protocol(ps->sd, 1);
  }
#line 447
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 448
    tmp = pi_set_error(ps->sd, -201);
    }
#line 448
    return (tmp);
  }
  {
#line 450
  next = pi_protocol_next(ps->sd, 1);
  }
#line 451
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 452
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 452
    return (tmp___0);
  }
  {
#line 454
  tmp___1 = (*(next->flush))(ps, flags);
  }
#line 454
  return (tmp___1);
}
}
#line 468 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
static int slp_getsockopt___0(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  struct pi_slp_data *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 475
  prot = pi_protocol(ps->sd, 1);
  }
#line 476
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 477
    tmp = pi_set_error(ps->sd, -201);
    }
#line 477
    return (tmp);
  }
#line 479
  data = (struct pi_slp_data *)prot->data;
  {
#line 482
  if (option_name == 0) {
#line 482
    goto case_0;
  }
#line 488
  if (option_name == 1) {
#line 488
    goto case_1;
  }
#line 495
  if (option_name == 2) {
#line 495
    goto case_2;
  }
#line 502
  if (option_name == 3) {
#line 502
    goto case_3;
  }
#line 509
  if (option_name == 4) {
#line 509
    goto case_4;
  }
#line 516
  if (option_name == 5) {
#line 516
    goto case_5;
  }
#line 523
  if (option_name == 6) {
#line 523
    goto case_6;
  }
#line 530
  if (option_name == 7) {
#line 530
    goto case_7;
  }
#line 481
  goto switch_break;
  case_0: /* CIL Label */ 
#line 483
  if (*option_len < sizeof(data->dest)) {
#line 484
    goto error;
  }
  {
#line 485
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->dest),
         sizeof(data->dest));
#line 486
  *option_len = sizeof(data->dest);
  }
#line 487
  goto switch_break;
  case_1: /* CIL Label */ 
#line 489
  if (*option_len < sizeof(data->dest)) {
#line 490
    goto error;
  }
  {
#line 491
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->last_dest),
         sizeof(data->last_dest));
#line 493
  *option_len = sizeof(data->last_dest);
  }
#line 494
  goto switch_break;
  case_2: /* CIL Label */ 
#line 496
  if (*option_len < sizeof(data->src)) {
#line 497
    goto error;
  }
  {
#line 498
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->src),
         sizeof(data->src));
#line 500
  *option_len = sizeof(data->src);
  }
#line 501
  goto switch_break;
  case_3: /* CIL Label */ 
#line 503
  if (*option_len < sizeof(data->last_src)) {
#line 504
    goto error;
  }
  {
#line 505
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->last_src),
         sizeof(data->last_src));
#line 507
  *option_len = sizeof(data->last_src);
  }
#line 508
  goto switch_break;
  case_4: /* CIL Label */ 
#line 510
  if (*option_len < sizeof(data->type)) {
#line 511
    goto error;
  }
  {
#line 512
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->type),
         sizeof(data->type));
#line 514
  *option_len = sizeof(data->type);
  }
#line 515
  goto switch_break;
  case_5: /* CIL Label */ 
#line 517
  if (*option_len < sizeof(data->last_type)) {
#line 518
    goto error;
  }
  {
#line 519
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->last_type),
         sizeof(data->last_type));
#line 521
  *option_len = sizeof(data->last_type);
  }
#line 522
  goto switch_break;
  case_6: /* CIL Label */ 
#line 524
  if (*option_len < sizeof(data->txid)) {
#line 525
    goto error;
  }
  {
#line 526
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->txid),
         sizeof(data->txid));
#line 528
  *option_len = sizeof(data->txid);
  }
#line 529
  goto switch_break;
  case_7: /* CIL Label */ 
#line 531
  if (*option_len < sizeof(data->last_txid)) {
#line 532
    goto error;
  }
  {
#line 533
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->last_txid),
         sizeof(data->last_txid));
#line 535
  *option_len = sizeof(data->last_txid);
  }
#line 536
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 539
  return (0);
  error: 
  {
#line 542
  tmp___0 = __errno_location();
#line 542
  *tmp___0 = 22;
#line 543
  tmp___1 = pi_set_error(ps->sd, -501);
  }
#line 543
  return (tmp___1);
}
}
#line 558 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
static int slp_setsockopt___0(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  struct pi_slp_data *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 565
  prot = pi_protocol(ps->sd, 1);
  }
#line 566
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 567
    tmp = pi_set_error(ps->sd, -201);
    }
#line 567
    return (tmp);
  }
#line 568
  data = (struct pi_slp_data *)prot->data;
  {
#line 571
  if (option_name == 0) {
#line 571
    goto case_0;
  }
#line 578
  if (option_name == 2) {
#line 578
    goto case_2;
  }
#line 585
  if (option_name == 4) {
#line 585
    goto case_4;
  }
#line 592
  if (option_name == 6) {
#line 592
    goto case_6;
  }
#line 570
  goto switch_break;
  case_0: /* CIL Label */ 
#line 572
  if (*option_len != sizeof(data->dest)) {
#line 573
    goto error;
  }
  {
#line 574
  memcpy((void */* __restrict  */)(& data->dest), (void const   */* __restrict  */)option_value,
         sizeof(data->dest));
#line 576
  *option_len = sizeof(data->dest);
  }
#line 577
  goto switch_break;
  case_2: /* CIL Label */ 
#line 579
  if (*option_len != sizeof(data->src)) {
#line 580
    goto error;
  }
  {
#line 581
  memcpy((void */* __restrict  */)(& data->src), (void const   */* __restrict  */)option_value,
         sizeof(data->src));
#line 583
  *option_len = sizeof(data->src);
  }
#line 584
  goto switch_break;
  case_4: /* CIL Label */ 
#line 586
  if (*option_len != sizeof(data->type)) {
#line 587
    goto error;
  }
  {
#line 588
  memcpy((void */* __restrict  */)(& data->type), (void const   */* __restrict  */)option_value,
         sizeof(data->type));
#line 590
  *option_len = sizeof(data->type);
  }
#line 591
  goto switch_break;
  case_6: /* CIL Label */ 
#line 593
  if (*option_len != sizeof(data->txid)) {
#line 594
    goto error;
  }
  {
#line 595
  memcpy((void */* __restrict  */)(& data->txid), (void const   */* __restrict  */)option_value,
         sizeof(data->txid));
#line 597
  *option_len = sizeof(data->txid);
  }
#line 598
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 601
  return (0);
  error: 
  {
#line 604
  tmp___0 = __errno_location();
#line 604
  *tmp___0 = 22;
#line 605
  tmp___1 = pi_set_error(ps->sd, -501);
  }
#line 605
  return (tmp___1);
}
}
#line 57 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_connect___0(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
#line 59
static int pi_serial_bind___0(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
#line 61
static int pi_serial_listen___0(pi_socket_t *ps , int backlog ) ;
#line 62
static int pi_serial_accept___0(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) ;
#line 64
static int pi_serial_getsockopt___0(pi_socket_t *ps , int level , int option_name ,
                                    void *option_value , size_t *option_len ) ;
#line 67
static int pi_serial_setsockopt___0(pi_socket_t *ps , int level , int option_name ,
                                    void const   *option_value , size_t *option_len ) ;
#line 70
static int pi_serial_close___0(pi_socket_t *ps ) ;
#line 87 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static pi_protocol_t *pi_serial_protocol_dup___0(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  void *tmp ;

  {
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 92
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c",
             92, "prot != NULL");
      }
    }
#line 92
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 94
  tmp = malloc(sizeof(pi_protocol_t ));
#line 94
  new_prot = (pi_protocol_t *)tmp;
  }
#line 96
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 97
    new_prot->level = prot->level;
#line 98
    new_prot->dup = prot->dup;
#line 99
    new_prot->free = prot->free;
#line 100
    new_prot->read = prot->read;
#line 101
    new_prot->write = prot->write;
#line 102
    new_prot->flush = prot->flush;
#line 103
    new_prot->getsockopt = prot->getsockopt;
#line 104
    new_prot->setsockopt = prot->setsockopt;
#line 105
    new_prot->data = (void *)0;
  }
#line 108
  return (new_prot);
}
}
#line 123 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static void pi_serial_protocol_free___0(pi_protocol_t *prot ) 
{ 


  {
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 126
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c",
             126, "prot != NULL");
      }
    }
#line 126
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
    {
#line 129
    free((void *)prot);
    }
  }
#line 130
  return;
}
}
#line 144 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static pi_protocol_t *pi_serial_protocol___0(pi_device_t *dev ) 
{ 
  pi_protocol_t *prot ;
  struct pi_serial_data *data ;
  void *tmp ;

  {
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! ((unsigned long )dev != (unsigned long )((void *)0))) {
      {
#line 150
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c",
             150, "dev != NULL");
      }
    }
#line 150
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 152
  tmp = malloc(sizeof(pi_protocol_t ));
#line 152
  prot = (pi_protocol_t *)tmp;
#line 154
  data = (struct pi_serial_data *)dev->data;
  }
#line 156
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 157
    prot->level = 0;
#line 158
    prot->dup = & pi_serial_protocol_dup___0;
#line 159
    prot->free = & pi_serial_protocol_free___0;
#line 160
    prot->read = data->impl.read;
#line 161
    prot->write = data->impl.write;
#line 162
    prot->flush = data->impl.flush;
#line 163
    prot->getsockopt = & pi_serial_getsockopt___0;
#line 164
    prot->setsockopt = & pi_serial_setsockopt___0;
#line 165
    prot->data = (void *)0;
  }
#line 168
  return (prot);
}
}
#line 184 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static void pi_serial_device_free___0(pi_device_t *dev ) 
{ 


  {
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )dev != (unsigned long )((void *)0))) {
      {
#line 187
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c",
             187, "dev != NULL");
      }
    }
#line 187
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 189
  free(dev->data);
#line 190
  free((void *)dev);
  }
#line 191
  return;
}
}
#line 265 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_connect___0(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) 
{ 
  struct pi_serial_data *data ;
  struct pi_sockaddr *pa ;
  int err ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  int tmp___3 ;

  {
#line 269
  data = (struct pi_serial_data *)(ps->device)->data;
#line 271
  pa = (struct pi_sockaddr *)addr;
#line 274
  if (ps->type == 16) {
#line 275
    if (ps->protocol == 3) {
#line 276
      tmp = 57600;
#line 276
      data->rate = tmp;
#line 276
      data->establishrate = tmp;
    } else {
#line 278
      if (data->establishrate == -1) {
        {
#line 279
        get_pilot_rate(& data->establishrate, & data->establishhighrate);
        }
      }
#line 282
      data->rate = 9600;
    }
  } else
#line 284
  if (ps->type == 48) {
#line 286
    tmp___0 = 57600;
#line 286
    data->rate = tmp___0;
#line 286
    data->establishrate = tmp___0;
  }
  {
#line 289
  err = (*(data->impl.open))(ps, pa, addrlen);
  }
#line 289
  if (err < 0) {
#line 290
    return (err);
  }
  {
#line 292
  tmp___1 = malloc(addrlen);
#line 292
  ps->raddr = (struct sockaddr *)tmp___1;
#line 293
  memcpy((void */* __restrict  */)ps->raddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 294
  ps->raddrlen = addrlen;
#line 295
  tmp___2 = malloc(addrlen);
#line 295
  ps->laddr = (struct sockaddr *)tmp___2;
#line 296
  memcpy((void */* __restrict  */)ps->laddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 297
  ps->laddrlen = addrlen;
  }
#line 299
  if (ps->type == 16) {
    {
#line 302
    if (ps->cmd == 1) {
#line 302
      goto case_1;
    }
#line 314
    if (ps->cmd == 2) {
#line 314
      goto case_2;
    }
#line 319
    if (ps->cmd == 3) {
#line 319
      goto case_3;
    }
#line 301
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 303
    tmp___3 = cmp_tx_handshake(ps);
    }
#line 303
    if (tmp___3 < 0) {
#line 304
      goto fail;
    }
    {
#line 306
    size = sizeof(data->rate);
#line 307
    pi_getsockopt(ps->sd, 5, 3, (void *)(& data->rate), & size);
#line 310
    err = (*(data->impl.changebaud))(ps);
    }
#line 310
    if (err < 0) {
#line 311
      goto fail;
    }
#line 312
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 315
    err = (*(data->impl.changebaud))(ps);
    }
#line 315
    if (err < 0) {
#line 316
      goto fail;
    }
#line 317
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 320
    err = (*(data->impl.changebaud))(ps);
    }
#line 320
    if (err < 0) {
#line 321
      goto fail;
    }
#line 322
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 325
  ps->state = 4;
#line 326
  ps->command = 0;
#line 327
  return (0);
  fail: 
#line 330
  return (err);
}
}
#line 345 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_bind___0(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) 
{ 
  struct pi_serial_data *data ;
  struct pi_sockaddr *pa ;
  int err ;
  int count ;
  int tmp ;
  int save_errno ;
  int *tmp___0 ;
  char realport[4096] ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
#line 348
  data = (struct pi_serial_data *)(ps->device)->data;
#line 350
  pa = (struct pi_sockaddr *)addr;
#line 351
  count = 0;
#line 353
  if (ps->type == 16) {
#line 354
    if (data->establishrate == -1) {
      {
#line 355
      get_pilot_rate(& data->establishrate, & data->establishhighrate);
      }
    }
#line 358
    data->rate = 9600;
  } else
#line 359
  if (ps->type == 48) {
#line 361
    tmp = 57600;
#line 361
    data->rate = tmp;
#line 361
    data->establishrate = tmp;
  }
  begin: 
  {
#line 365
  err = (*(data->impl.open))(ps, pa, addrlen);
  }
#line 365
  if (err < 0) {
    {
#line 366
    tmp___0 = __errno_location();
#line 366
    save_errno = *tmp___0;
#line 377
    realpath((char const   */* __restrict  */)(pa->pi_device), (char */* __restrict  */)(realport));
#line 378
    tmp___1 = __errno_location();
#line 378
    *tmp___1 = save_errno;
#line 380
    tmp___7 = __errno_location();
    }
#line 380
    if (*tmp___7 == 2) {
      {
#line 381
      pi_log(2, 1, " The device %s does not exist..\n", pa->pi_device);
#line 384
      pi_log(2, 1, " Possible solution:\n\n\tmknod %s c <major> <minor>\n\n", pa->pi_device);
      }
    } else {
      {
#line 387
      tmp___6 = __errno_location();
      }
#line 387
      if (*tmp___6 == 13) {
        {
#line 388
        pi_log(2, 1, "   Please check the permissions on %s..\n", realport);
#line 391
        pi_log(2, 1, " Possible solution:\n\n\tchmod 0666 %s\n\n", realport);
        }
      } else {
        {
#line 394
        tmp___5 = __errno_location();
        }
#line 394
        if (*tmp___5 == 19) {
          {
#line 395
          while (1) {
            while_continue: /* CIL Label */ ;
#line 395
            if (! (count <= 5)) {
#line 395
              goto while_break;
            }
            {
#line 396
            tmp___2 = fileno(stdout);
#line 396
            tmp___3 = isatty(tmp___2);
            }
#line 396
            if (tmp___3) {
              {
#line 397
              pi_log(2, 1, "\r   Port not connected, sleeping for 2 seconds, ");
#line 400
              pi_log(2, 1, "%d retries..", 5 - count);
              }
            }
            {
#line 404
            sleep(2U);
#line 405
            count ++;
            }
#line 406
            goto begin;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 408
          pi_log(2, 1, "\n\n   Device not found on %s, \t\t\t\t\tDid you hit HotSync?\n\n",
                 realport);
          }
        } else {
          {
#line 411
          tmp___4 = __errno_location();
          }
#line 411
          if (*tmp___4 == 21) {
            {
#line 412
            pi_log(2, 1, " The port specified must contain a device name, and %s was a directory.\n   Please change that to reference a real device, and try again\n\n",
                   pa->pi_device);
            }
          }
        }
      }
    }
#line 420
    return (err);
  }
  {
#line 422
  tmp___8 = malloc(addrlen);
#line 422
  ps->raddr = (struct sockaddr *)tmp___8;
#line 423
  memcpy((void */* __restrict  */)ps->raddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 424
  ps->raddrlen = addrlen;
#line 425
  tmp___9 = malloc(addrlen);
#line 425
  ps->laddr = (struct sockaddr *)tmp___9;
#line 426
  memcpy((void */* __restrict  */)ps->laddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 427
  ps->laddrlen = addrlen;
  }
#line 429
  return (0);
}
}
#line 443 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_listen___0(pi_socket_t *ps , int backlog ) 
{ 
  int result ;
  struct pi_serial_data *data ;

  {
  {
#line 446
  data = (struct pi_serial_data *)(ps->device)->data;
#line 450
  result = (*(data->impl.changebaud))(ps);
  }
#line 451
  if (result == 0) {
#line 452
    ps->state = 1;
  }
#line 454
  return (result);
}
}
#line 468 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_accept___0(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) 
{ 
  struct pi_serial_data *data ;
  size_t size ;
  int err ;
  int result ;
  int tmp ;
  char buf___3[6] ;
  struct timeval tv ;
  unsigned char cmp_flags ;
  int use_long_format ;

  {
#line 472
  data = (struct pi_serial_data *)(ps->device)->data;
#line 479
  if (ps->accept_to) {
    {
#line 481
    tmp = (*(data->impl.poll))(ps, 1000);
#line 481
    result = tmp;
#line 482
    pi_log(2, 8, "%s: %d, poll result: %d.\n", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c",
           482, result);
    }
#line 484
    if (result < 0) {
      {
#line 485
      buf___3[0] = (char)1;
#line 485
      buf___3[1] = (char)0;
#line 485
      buf___3[2] = (char)0;
#line 485
      buf___3[3] = (char)0;
#line 485
      buf___3[4] = (char)0;
#line 485
      buf___3[5] = (char)0;
#line 486
      (*(data->impl.write))(ps, (unsigned char const   *)(buf___3), sizeof(buf___3),
                            1000);
      }
    }
  }
  {
#line 490
  err = (*(data->impl.poll))(ps, ps->accept_to * 1000);
  }
#line 490
  if (err < 0) {
#line 491
    goto fail;
  }
  {
#line 493
  data->timeout = ps->accept_to * 1000;
#line 495
  pi_socket_init(ps);
  }
#line 496
  if (ps->type == 16) {
    {
#line 501
    if (ps->cmd == 1) {
#line 501
      goto case_1;
    }
#line 531
    if (ps->cmd == 2) {
#line 531
      goto case_2;
    }
#line 500
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 502
    err = cmp_rx_handshake(ps, data->establishrate, data->establishhighrate);
    }
#line 502
    if (err < 0) {
#line 503
      goto fail;
    }
    {
#line 506
    size = sizeof(cmp_flags);
#line 507
    pi_getsockopt(ps->sd, 5, 1, (void *)(& cmp_flags), & size);
    }
#line 508
    if ((int )cmp_flags & 16) {
      {
#line 509
      use_long_format = 1;
#line 510
      size = sizeof(int );
#line 511
      pi_setsockopt(ps->sd, 2, 3, (void const   *)(& use_long_format), & size);
#line 513
      ps->command ^= 1;
#line 514
      pi_setsockopt(ps->sd, 2, 3, (void const   *)(& use_long_format), & size);
#line 516
      ps->command ^= 1;
      }
    }
    {
#line 520
    size = sizeof(data->rate);
#line 521
    pi_getsockopt(ps->sd, 5, 3, (void *)(& data->rate), & size);
#line 522
    err = (*(data->impl.changebaud))(ps);
    }
#line 522
    if (err < 0) {
#line 523
      goto fail;
    }
    {
#line 526
    tv.tv_sec = (__time_t )0;
#line 527
    tv.tv_usec = (__suseconds_t )50000;
#line 528
    select(0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0,
           (struct timeval */* __restrict  */)(& tv));
    }
#line 529
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 561
    err = net_rx_handshake(ps);
    }
#line 561
    if (err < 0) {
#line 562
      goto fail;
    }
#line 563
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 565
    ps->dlprecord = 0;
  }
#line 568
  data->timeout = 0;
#line 569
  ps->command = 0;
#line 570
  ps->state = 2;
#line 572
  return (ps->sd);
  fail: 
#line 575
  return (err);
}
}
#line 590 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_getsockopt___0(pi_socket_t *ps , int level , int option_name ,
                                    void *option_value , size_t *option_len ) 
{ 
  struct pi_serial_data *data ;
  int *tmp ;
  int tmp___0 ;

  {
#line 594
  data = (struct pi_serial_data *)(ps->device)->data;
  {
#line 598
  if (option_name == 0) {
#line 598
    goto case_0;
  }
#line 604
  if (option_name == 1) {
#line 604
    goto case_1;
  }
#line 610
  if (option_name == 2) {
#line 610
    goto case_2;
  }
#line 616
  if (option_name == 3) {
#line 616
    goto case_3;
  }
#line 597
  goto switch_break;
  case_0: /* CIL Label */ 
#line 599
  if (*option_len != sizeof(data->rate)) {
#line 600
    goto error;
  }
  {
#line 601
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->rate),
         sizeof(data->rate));
  }
#line 602
  goto switch_break;
  case_1: /* CIL Label */ 
#line 605
  if (*option_len != sizeof(data->establishrate)) {
#line 606
    goto error;
  }
  {
#line 607
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->establishrate),
         sizeof(data->establishrate));
  }
#line 608
  goto switch_break;
  case_2: /* CIL Label */ 
#line 611
  if (*option_len != sizeof(data->establishhighrate)) {
#line 612
    goto error;
  }
  {
#line 613
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->establishhighrate),
         sizeof(data->establishhighrate));
  }
#line 614
  goto switch_break;
  case_3: /* CIL Label */ 
#line 617
  if (*option_len != sizeof(data->timeout)) {
#line 618
    goto error;
  }
  {
#line 619
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->timeout),
         sizeof(data->timeout));
  }
#line 620
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 623
  return (0);
  error: 
  {
#line 626
  tmp = __errno_location();
#line 626
  *tmp = 22;
#line 627
  tmp___0 = pi_set_error(ps->sd, -501);
  }
#line 627
  return (tmp___0);
}
}
#line 642 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_setsockopt___0(pi_socket_t *ps , int level , int option_name ,
                                    void const   *option_value , size_t *option_len ) 
{ 
  struct pi_serial_data *data ;
  int *tmp ;
  int tmp___0 ;

  {
#line 646
  data = (struct pi_serial_data *)(ps->device)->data;
  {
#line 651
  if (option_name == 1) {
#line 651
    goto case_1;
  }
#line 657
  if (option_name == 2) {
#line 657
    goto case_2;
  }
#line 663
  if (option_name == 3) {
#line 663
    goto case_3;
  }
#line 650
  goto switch_break;
  case_1: /* CIL Label */ 
#line 652
  if (*option_len != sizeof(data->establishrate)) {
#line 653
    goto error;
  }
  {
#line 654
  memcpy((void */* __restrict  */)(& data->establishrate), (void const   */* __restrict  */)option_value,
         sizeof(data->establishrate));
  }
#line 655
  goto switch_break;
  case_2: /* CIL Label */ 
#line 658
  if (*option_len != sizeof(data->establishhighrate)) {
#line 659
    goto error;
  }
  {
#line 660
  memcpy((void */* __restrict  */)(& data->establishhighrate), (void const   */* __restrict  */)option_value,
         sizeof(data->establishhighrate));
  }
#line 661
  goto switch_break;
  case_3: /* CIL Label */ 
#line 664
  if (*option_len != sizeof(data->timeout)) {
#line 665
    goto error;
  }
  {
#line 666
  memcpy((void */* __restrict  */)(& data->timeout), (void const   */* __restrict  */)option_value,
         sizeof(data->timeout));
  }
#line 667
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 670
  return (0);
  error: 
  {
#line 673
  tmp = __errno_location();
#line 673
  *tmp = 22;
#line 674
  tmp___0 = pi_set_error(ps->sd, -501);
  }
#line 674
  return (tmp___0);
}
}
#line 689 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_close___0(pi_socket_t *ps ) 
{ 
  struct pi_serial_data *data ;

  {
#line 691
  data = (struct pi_serial_data *)(ps->device)->data;
#line 694
  if (ps->sd) {
    {
#line 695
    (*(data->impl.close))(ps);
#line 696
    ps->sd = 0;
    }
  }
#line 699
  if (ps->laddr) {
    {
#line 700
    free((void *)ps->laddr);
#line 701
    ps->laddr = (struct sockaddr *)((void *)0);
    }
  }
#line 704
  if (ps->raddr) {
    {
#line 705
    free((void *)ps->raddr);
#line 706
    ps->raddr = (struct sockaddr *)((void *)0);
    }
  }
#line 709
  return (0);
}
}
#line 291 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/utils.c"
static char buf___0[5]  ;
#line 124 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static int s_open___0(pi_socket_t *ps , struct pi_sockaddr *addr , size_t addrlen ) ;
#line 126
static int s_close___0(pi_socket_t *ps ) ;
#line 127
static int s_changebaud___0(pi_socket_t *ps ) ;
#line 128
static ssize_t s_write___0(pi_socket_t *ps , unsigned char const   *buf___3 , size_t len ,
                           int flags ) ;
#line 130
static ssize_t s_read___0(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) ;
#line 132
static int s_poll___0(pi_socket_t *ps , int timeout ) ;
#line 134
static speed_t calcrate___0(int baudrate ) ;
#line 136
static int s_flush___0(pi_socket_t *ps , int flags ) ;
#line 155 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static int s_open___0(pi_socket_t *ps , struct pi_sockaddr *addr , size_t addrlen ) 
{ 
  int fd ;
  int i ;
  char *tty ;
  struct pi_serial_data *data ;
  struct termios tcn ;
  int *tmp ;
  int tmp___0 ;
  speed_t tmp___1 ;

  {
  {
#line 160
  tty = addr->pi_device;
#line 162
  data = (struct pi_serial_data *)(ps->device)->data;
#line 170
  fd = open((char const   *)tty, 2050);
  }
#line 170
  if (fd < 0) {
#line 171
    ps->last_error = -502;
#line 172
    return (-502);
  }
  {
#line 175
  tmp___0 = isatty(fd);
  }
#line 175
  if (! tmp___0) {
    {
#line 176
    close(fd);
#line 177
    tmp = __errno_location();
#line 177
    *tmp = 22;
#line 178
    ps->last_error = -502;
    }
#line 179
    return (-502);
  }
  {
#line 184
  tcgetattr(fd, & tcn);
#line 186
  data->tco = tcn;
#line 187
  tcn.c_oflag = (tcflag_t )0;
#line 188
  tcn.c_iflag = (tcflag_t )5;
#line 189
  tcn.c_cflag = (tcflag_t )2224;
#line 191
  tmp___1 = calcrate___0(data->rate);
#line 191
  cfsetspeed(& tcn, tmp___1);
#line 193
  tcn.c_lflag = (tcflag_t )128;
#line 195
  cfmakeraw(& tcn);
#line 197
  i = 0;
  }
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! (i < 16)) {
#line 197
      goto while_break;
    }
#line 198
    tcn.c_cc[i] = (cc_t )0;
#line 197
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 200
  tcn.c_cc[6] = (cc_t )1;
#line 201
  tcn.c_cc[5] = (cc_t )0;
#line 203
  tcsetattr(fd, 0, (struct termios  const  *)(& tcn));
#line 217
  i = fcntl(fd, 3, 0);
  }
#line 217
  if (i != -1) {
    {
#line 218
    i &= -2049;
#line 219
    fcntl(fd, 4, i);
    }
  }
  {
#line 222
  i = pi_socket_setsd(ps, fd);
  }
#line 222
  if (i < 0) {
#line 223
    return (i);
  }
#line 225
  return (fd);
}
}
#line 240 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static int s_close___0(pi_socket_t *ps ) 
{ 
  int tmp ;

  {
  {
#line 255
  pi_log(2, 4, "DEV CLOSE unixserial fd: %d\n", ps->sd);
#line 258
  tmp = close(ps->sd);
  }
#line 258
  return (tmp);
}
}
#line 273 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static int s_poll___0(pi_socket_t *ps , int timeout ) 
{ 
  struct pi_serial_data *data ;
  struct timeval t ;
  fd_set ready ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 276
  data = (struct pi_serial_data *)(ps->device)->data;
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 281
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 286
  if (timeout == 0) {
    {
#line 287
    select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
           (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
    }
  } else {
    {
#line 289
    t.tv_sec = (__time_t )(timeout / 1000);
#line 290
    t.tv_usec = (__suseconds_t )((timeout % 1000) * 1000);
#line 291
    tmp___0 = select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
                     (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
    }
#line 291
    if (tmp___0 == 0) {
      {
#line 292
      tmp = pi_set_error(ps->sd, -202);
      }
#line 292
      return (tmp);
    }
  }
#line 295
  if (! ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
    {
#line 297
    pi_log(2, 2, "DEV POLL unixserial timeout\n");
#line 299
    (data->rx_errors) ++;
#line 300
    tmp___1 = __errno_location();
#line 300
    *tmp___1 = 110;
#line 301
    tmp___2 = pi_set_error(ps->sd, -202);
    }
#line 301
    return (tmp___2);
  }
  {
#line 303
  pi_log(2, 8, "DEV POLL unixserial found data on fd: %d\n", ps->sd);
  }
#line 306
  return (0);
}
}
#line 321 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static ssize_t s_write___0(pi_socket_t *ps , unsigned char const   *buf___3 , size_t len ,
                           int flags ) 
{ 
  ssize_t total ;
  ssize_t nwrote ;
  struct pi_serial_data *data ;
  struct timeval t ;
  fd_set ready ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 327
  data = (struct pi_serial_data *)(ps->device)->data;
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 332
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 335
  total = (ssize_t )len;
  {
#line 336
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 336
    if (! (total > 0L)) {
#line 336
      goto while_break___0;
    }
#line 337
    if (data->timeout == 0) {
      {
#line 338
      select(ps->sd + 1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)(& ready),
             (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
      }
    } else {
      {
#line 340
      t.tv_sec = (__time_t )(data->timeout / 1000);
#line 341
      t.tv_usec = (__suseconds_t )((data->timeout % 1000) * 1000);
#line 342
      tmp___0 = select(ps->sd + 1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)(& ready),
                       (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
      }
#line 342
      if (tmp___0 == 0) {
        {
#line 343
        tmp = pi_set_error(ps->sd, -202);
        }
#line 343
        return ((ssize_t )tmp);
      }
    }
#line 346
    if (! ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
      {
#line 347
      tmp___1 = pi_set_error(ps->sd, -202);
      }
#line 347
      return ((ssize_t )tmp___1);
    }
    {
#line 349
    nwrote = write(ps->sd, (void const   *)buf___3, len);
    }
#line 350
    if (nwrote < 0L) {
      {
#line 351
      tmp___3 = __errno_location();
      }
#line 351
      if (*tmp___3 == 32) {
        {
#line 352
        ps->state = 8;
#line 353
        tmp___2 = pi_set_error(ps->sd, -200);
        }
#line 353
        return ((ssize_t )tmp___2);
      } else {
        {
#line 351
        tmp___4 = __errno_location();
        }
#line 351
        if (*tmp___4 == 9) {
          {
#line 352
          ps->state = 8;
#line 353
          tmp___2 = pi_set_error(ps->sd, -200);
          }
#line 353
          return ((ssize_t )tmp___2);
        }
      }
      {
#line 355
      tmp___5 = pi_set_error(ps->sd, -204);
      }
#line 355
      return ((ssize_t )tmp___5);
    }
#line 357
    total -= nwrote;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 359
  data->tx_bytes = (int )((size_t )data->tx_bytes + len);
#line 362
  usleep((__useconds_t )(10UL + len));
#line 364
  pi_log(2, 8, "DEV TX unixserial wrote %d bytes\n", len);
  }
#line 367
  return ((ssize_t )len);
}
}
#line 382 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static size_t s_read_buf___0(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len ,
                             int flags ) 
{ 
  struct pi_serial_data *data ;
  size_t rbuf ;
  int *tmp ;
  int tmp___0 ;
  pi_buffer_t *tmp___1 ;

  {
#line 385
  data = (struct pi_serial_data *)(ps->device)->data;
#line 387
  rbuf = data->buf_size;
#line 389
  if (rbuf > len) {
#line 390
    rbuf = len;
  }
  {
#line 392
  tmp___1 = pi_buffer_append(buf___3, (void const   *)(data->buf), rbuf);
  }
#line 392
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 393
    tmp = __errno_location();
#line 393
    *tmp = 12;
#line 394
    tmp___0 = pi_set_error(ps->sd, -500);
    }
#line 394
    return ((size_t )tmp___0);
  }
#line 397
  if (flags != 1) {
#line 398
    data->buf_size -= rbuf;
#line 399
    if (data->buf_size > 0UL) {
      {
#line 400
      memmove((void *)(data->buf), (void const   *)(& data->buf[rbuf]), data->buf_size);
      }
    }
  }
  {
#line 403
  pi_log(2, 8, "DEV RX unixserial read %d bytes from read-ahead buffer\n", rbuf);
  }
#line 406
  return (rbuf);
}
}
#line 420 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static ssize_t s_read___0(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) 
{ 
  ssize_t rbuf ;
  ssize_t bytes ;
  struct pi_serial_data *data ;
  struct timeval t ;
  fd_set ready ;
  size_t tmp ;
  int __d0 ;
  int __d1 ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  pi_buffer_t *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
#line 423
  rbuf = (ssize_t )0;
#line 425
  data = (struct pi_serial_data *)(ps->device)->data;
#line 431
  if (data->buf_size) {
    {
#line 432
    tmp = s_read_buf___0(ps, buf___3, len, flags);
#line 432
    rbuf = (ssize_t )tmp;
    }
#line 433
    if (rbuf < 0L) {
#line 434
      return (rbuf);
    }
#line 435
    len -= (size_t )rbuf;
#line 436
    if (len == 0UL) {
#line 437
      return (rbuf);
    }
  }
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 442
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 444
  if (data->timeout == 0) {
    {
#line 445
    select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
           (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
    }
  } else {
    {
#line 447
    t.tv_sec = (__time_t )(data->timeout / 1000);
#line 448
    t.tv_usec = (__suseconds_t )((data->timeout % 1000) * 1000);
#line 449
    tmp___1 = select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
                     (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
    }
#line 449
    if (tmp___1 == 0) {
      {
#line 450
      tmp___0 = pi_set_error(ps->sd, -202);
      }
#line 450
      return ((ssize_t )tmp___0);
    }
  }
#line 454
  if ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 455
    if (flags == 1) {
#line 455
      if (len > 256UL) {
#line 456
        len = (size_t )256;
      }
    }
    {
#line 458
    tmp___4 = pi_buffer_expect(buf___3, len);
    }
#line 458
    if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
      {
#line 459
      tmp___2 = __errno_location();
#line 459
      *tmp___2 = 12;
#line 460
      tmp___3 = pi_set_error(ps->sd, -500);
      }
#line 460
      return ((ssize_t )tmp___3);
    }
    {
#line 463
    bytes = read(ps->sd, (void *)(buf___3->data + buf___3->used), len);
    }
#line 465
    if (bytes > 0L) {
#line 466
      if (flags == 1) {
        {
#line 467
        memcpy((void */* __restrict  */)(data->buf + data->buf_size), (void const   */* __restrict  */)(buf___3->data + buf___3->used),
               (size_t )bytes);
#line 468
        data->buf_size += (size_t )bytes;
        }
      }
      {
#line 470
      buf___3->used += (size_t )bytes;
#line 471
      data->rx_bytes = (int )((ssize_t )data->rx_bytes + bytes);
#line 472
      rbuf += bytes;
#line 474
      pi_log(2, 8, "DEV RX unixserial read %d bytes\n", bytes);
      }
    } else
#line 476
    if (bytes < 0L) {
#line 477
      rbuf = bytes;
    }
  } else {
    {
#line 480
    pi_log(2, 2, "DEV RX unixserial timeout\n");
#line 482
    (data->rx_errors) ++;
#line 483
    tmp___5 = __errno_location();
#line 483
    *tmp___5 = 110;
#line 484
    tmp___6 = pi_set_error(ps->sd, -202);
    }
#line 484
    return ((ssize_t )tmp___6);
  }
#line 487
  return (rbuf);
}
}
#line 507 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static int s_flush___0(pi_socket_t *ps , int flags ) 
{ 
  int fl ;
  char buf___3[256] ;
  struct pi_serial_data *data ;
  ssize_t tmp ;

  {
#line 512
  data = (struct pi_serial_data *)(ps->device)->data;
#line 514
  if (flags & 1) {
    {
#line 516
    data->buf_size = (size_t )0;
#line 519
    fl = fcntl(ps->sd, 3, 0);
    }
#line 519
    if (fl != -1) {
      {
#line 521
      fcntl(ps->sd, 4, fl | 2048);
      }
      {
#line 522
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 522
        tmp = recv(ps->sd, (void *)(buf___3), sizeof(buf___3), 0);
        }
#line 522
        if (! (tmp > 0L)) {
#line 522
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 524
      fcntl(ps->sd, 4, fl);
      }
    }
    {
#line 527
    pi_log(2, 8, "DEV FLUSH unixserial flushed input buffer\n");
    }
  }
#line 530
  return (0);
}
}
#line 569 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static int s_changebaud___0(pi_socket_t *ps ) 
{ 
  struct pi_serial_data *data ;
  struct termios tcn ;
  int tmp ;
  int tmp___0 ;
  speed_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 572
  data = (struct pi_serial_data *)(ps->device)->data;
#line 577
  pi_log(2, 8, "DEV SPEED unixserial switch to %d bps\n", data->rate);
#line 584
  tmp___0 = tcgetattr(ps->sd, & tcn);
  }
#line 584
  if (tmp___0) {
    {
#line 585
    tmp = pi_set_error(ps->sd, -502);
    }
#line 585
    return (tmp);
  }
  {
#line 587
  tcn.c_cflag = (tcflag_t )2224;
#line 588
  tmp___1 = calcrate___0(data->rate);
#line 588
  cfsetspeed(& tcn, tmp___1);
#line 590
  tmp___3 = tcsetattr(ps->sd, 1, (struct termios  const  *)(& tcn));
  }
#line 590
  if (tmp___3) {
    {
#line 591
    tmp___2 = pi_set_error(ps->sd, -502);
    }
#line 591
    return (tmp___2);
  }
#line 609
  return (0);
}
}
#line 649 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static speed_t calcrate___0(int baudrate ) 
{ 


  {
#line 653
  if (baudrate == 50) {
#line 654
    return ((speed_t )1);
  }
#line 657
  if (baudrate == 75) {
#line 658
    return ((speed_t )2);
  }
#line 661
  if (baudrate == 110) {
#line 662
    return ((speed_t )3);
  }
#line 665
  if (baudrate == 134) {
#line 666
    return ((speed_t )4);
  }
#line 669
  if (baudrate == 150) {
#line 670
    return ((speed_t )5);
  }
#line 673
  if (baudrate == 200) {
#line 674
    return ((speed_t )6);
  }
#line 677
  if (baudrate == 300) {
#line 678
    return ((speed_t )7);
  }
#line 681
  if (baudrate == 600) {
#line 682
    return ((speed_t )8);
  }
#line 685
  if (baudrate == 1200) {
#line 686
    return ((speed_t )9);
  }
#line 689
  if (baudrate == 1800) {
#line 690
    return ((speed_t )10);
  }
#line 693
  if (baudrate == 2400) {
#line 694
    return ((speed_t )11);
  }
#line 697
  if (baudrate == 4800) {
#line 698
    return ((speed_t )12);
  }
#line 701
  if (baudrate == 9600) {
#line 702
    return ((speed_t )13);
  } else
#line 705
  if (baudrate == 19200) {
#line 706
    return ((speed_t )14);
  } else
#line 709
  if (baudrate == 38400) {
#line 710
    return ((speed_t )15);
  } else
#line 713
  if (baudrate == 57600) {
#line 714
    return ((speed_t )4097);
  } else
#line 721
  if (baudrate == 115200) {
#line 722
    return ((speed_t )4098);
  } else
#line 725
  if (baudrate == 230400) {
#line 726
    return ((speed_t )4099);
  } else
#line 729
  if (baudrate == 460800) {
#line 730
    return ((speed_t )4100);
  }
  {
#line 733
  pi_log(2, 1, "DEV Serial CHANGEBAUD Unable to set baud rate %d\n", baudrate);
#line 736
  abort();
  }
#line 737
  return ((speed_t )0);
}
}
#line 1121 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/palmpix.c"
static void Bias___0(double bias , int width , int height , uint8_t *data ) 
{ 
  int i ;
  double num ;
  double denom ;
  double t ;

  {
  {
#line 1126
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bias factor : %lf\n",
          bias);
#line 1128
  i = 0;
  }
  {
#line 1128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1128
    if (! (i < width * height)) {
#line 1128
      goto while_break;
    }
#line 1130
    t = (double )*(data + i) / 256.0;
#line 1131
    num = t;
#line 1132
    denom = (1.0 / bias - (double )2) * (1.0 - t) + (double )1;
#line 1133
    *(data + i) = (uint8_t )((num / denom) * 256.0);
#line 1128
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1135
  return;
}
}
#line 1429 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/palmpix.c"
static void Interpolate___0(struct PalmPixHeader  const  *pixHdr , uint8_t *red ,
                            uint8_t *greenR , uint8_t *greenB , uint8_t *blue , uint8_t *pp ,
                            int offset_r , int offset_g , int offset_b ) 
{ 
  int idx ;
  int offset ;
  int ppOff ;
  int x ;
  int y ;
  int rowOff ;
  uint8_t r ;
  uint8_t g ;
  uint8_t b ;
  int rawWidth ;

  {
#line 1434
  rawWidth = (int )(pixHdr->w / 2);
#line 1436
  y = 1;
  {
#line 1436
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1436
    if (! (y < (int )(pixHdr->h - 1))) {
#line 1436
      goto while_break;
    }
#line 1439
    idx = y / 2;
#line 1440
    offset = idx * rawWidth;
#line 1441
    ppOff = y * (int )pixHdr->w;
#line 1443
    if (y % 2 == 1) {
#line 1445
      x = 1;
      {
#line 1445
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1445
        if (! (x < rawWidth - 1)) {
#line 1445
          goto while_break___0;
        }
#line 1448
        rowOff = x * 2;
#line 1450
        r = (uint8_t )(((((int )*(red + ((offset + x) - 1)) + (int )*(red + (offset + x))) + (int )*(red + (((offset + rawWidth) + x) - 1))) + (int )*(red + ((offset + rawWidth) + x))) >> 2);
#line 1451
        g = (uint8_t )(((((int )*(greenR + (offset + x)) + (int )*(greenR + ((offset + x) + rawWidth))) + (int )*(greenB + ((offset + x) - 1))) + (int )*(greenB + (offset + x))) >> 2);
#line 1452
        b = *(blue + (offset + x));
#line 1453
        *(pp + (3 * (ppOff + rowOff) + offset_r)) = r;
#line 1454
        *(pp + (3 * (ppOff + rowOff) + offset_g)) = g;
#line 1455
        *(pp + (3 * (ppOff + rowOff) + offset_b)) = b;
#line 1457
        r = (uint8_t )(((int )*(red + (offset + x)) + (int )*(red + ((offset + rawWidth) + x))) >> 1);
#line 1458
        g = (uint8_t )(((((((int )*(greenB + (offset + x)) << 2) + (int )*(greenR + (offset + x))) + (int )*(greenR + ((offset + x) + 1))) + (int )*(greenR + ((offset + x) + rawWidth))) + (int )*(greenR + (((offset + x) + rawWidth) + 1))) >> 3);
#line 1459
        b = (uint8_t )(((int )*(blue + (offset + x)) + (int )*(blue + ((offset + x) + 1))) >> 1);
#line 1460
        *(pp + (3 * ((ppOff + rowOff) + 1) + offset_r)) = r;
#line 1461
        *(pp + (3 * ((ppOff + rowOff) + 1) + offset_g)) = g;
#line 1462
        *(pp + (3 * ((ppOff + rowOff) + 1) + offset_b)) = b;
#line 1445
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 1468
      x = 1;
      {
#line 1468
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1468
        if (! (x < rawWidth - 1)) {
#line 1468
          goto while_break___1;
        }
#line 1470
        rowOff = x * 2;
#line 1472
        r = (uint8_t )(((int )*(red + ((offset + x) - 1)) + (int )*(red + (offset + x))) >> 1);
#line 1473
        g = (uint8_t )(((((((int )*(greenR + (offset + x)) << 2) + (int )*(greenB + (((offset - rawWidth) + x) - 1))) + (int )*(greenB + ((offset - rawWidth) + x))) + (int )*(greenB + ((offset + x) - 1))) + (int )*(greenB + (offset + x))) >> 3);
#line 1474
        b = (uint8_t )(((int )*(blue + ((offset - rawWidth) + x)) + (int )*(blue + (offset + x))) >> 1);
#line 1475
        *(pp + (3 * (ppOff + rowOff) + offset_r)) = r;
#line 1476
        *(pp + (3 * (ppOff + rowOff) + offset_g)) = g;
#line 1477
        *(pp + (3 * (ppOff + rowOff) + offset_b)) = b;
#line 1479
        r = *(red + (offset + x));
#line 1480
        g = (uint8_t )(((((int )*(greenR + (offset + x)) + (int )*(greenR + ((offset + x) + 1))) + (int )*(greenB + ((offset - rawWidth) + x))) + (int )*(greenB + (offset + x))) >> 2);
#line 1481
        b = (uint8_t )(((((int )*(blue + ((offset + x) - rawWidth)) + (int )*(blue + (((offset + x) - rawWidth) - 1))) + (int )*(blue + (offset + x))) + (int )*(blue + ((offset + x) + 1))) >> 2);
#line 1482
        *(pp + (3 * ((ppOff + rowOff) + 1) + offset_r)) = r;
#line 1483
        *(pp + (3 * ((ppOff + rowOff) + 1) + offset_g)) = g;
#line 1484
        *(pp + (3 * ((ppOff + rowOff) + 1) + offset_b)) = b;
#line 1468
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 1436
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1490
  return;
}
}
#line 1601 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/palmpix.c"
static int get_le_short___0(unsigned char const   *p ) 
{ 


  {
#line 1605
  return ((int )((int const   )*(p + 0) | ((int const   )*(p + 1) << 8)));
}
}
#line 44 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
static int sys_PackRegisters___0(void *data , struct Pilot_registers *r ) ;
#line 136 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
static int sys_PackRegisters___0(void *data , struct Pilot_registers *r ) 
{ 
  int idx ;
  unsigned char *buffer ;

  {
#line 140
  buffer = (unsigned char *)data;
#line 142
  idx = 0;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (idx < 8)) {
#line 142
      goto while_break;
    }
#line 143
    *((buffer + idx * 4) + 0) = (unsigned char )((int )((unsigned char )(r->D[idx] >> 24)) & 255);
#line 143
    *((buffer + idx * 4) + 1) = (unsigned char )((r->D[idx] >> 16) & 255UL);
#line 143
    *((buffer + idx * 4) + 2) = (unsigned char )((r->D[idx] >> 8) & 255UL);
#line 143
    *((buffer + idx * 4) + 3) = (unsigned char )(r->D[idx] & 255UL);
#line 142
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  idx = 0;
  {
#line 144
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 144
    if (! (idx < 7)) {
#line 144
      goto while_break___0;
    }
#line 145
    *(((buffer + 32) + idx * 4) + 0) = (unsigned char )((int )((unsigned char )(r->A[idx] >> 24)) & 255);
#line 145
    *(((buffer + 32) + idx * 4) + 1) = (unsigned char )((r->A[idx] >> 16) & 255UL);
#line 145
    *(((buffer + 32) + idx * 4) + 2) = (unsigned char )((r->A[idx] >> 8) & 255UL);
#line 145
    *(((buffer + 32) + idx * 4) + 3) = (unsigned char )(r->A[idx] & 255UL);
#line 144
    idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 146
  *((buffer + 60) + 0) = (unsigned char )((int )((unsigned char )(r->USP >> 24)) & 255);
#line 146
  *((buffer + 60) + 1) = (unsigned char )((r->USP >> 16) & 255UL);
#line 146
  *((buffer + 60) + 2) = (unsigned char )((r->USP >> 8) & 255UL);
#line 146
  *((buffer + 60) + 3) = (unsigned char )(r->USP & 255UL);
#line 147
  *((buffer + 64) + 0) = (unsigned char )((int )((unsigned char )(r->SSP >> 24)) & 255);
#line 147
  *((buffer + 64) + 1) = (unsigned char )((r->SSP >> 16) & 255UL);
#line 147
  *((buffer + 64) + 2) = (unsigned char )((r->SSP >> 8) & 255UL);
#line 147
  *((buffer + 64) + 3) = (unsigned char )(r->SSP & 255UL);
#line 148
  *((buffer + 68) + 0) = (unsigned char )((int )((unsigned char )(r->PC >> 24)) & 255);
#line 148
  *((buffer + 68) + 1) = (unsigned char )((r->PC >> 16) & 255UL);
#line 148
  *((buffer + 68) + 2) = (unsigned char )((r->PC >> 8) & 255UL);
#line 148
  *((buffer + 68) + 3) = (unsigned char )(r->PC & 255UL);
#line 150
  *((buffer + 72) + 0) = (unsigned char )(((int )((unsigned short )r->SR) >> 8) & 255);
#line 150
  *((buffer + 72) + 1) = (unsigned char )((int )((unsigned short )r->SR) & 255);
#line 152
  return (0);
}
}
#line 66 "../include/pi-util.h"
int convert_ToPilotChar_WithCharset(char const   *charset , char const   *text , int bytes ,
                                    char **ptext , char const   *pi_charset ) ;
#line 70
int convert_ToPilotChar(char const   *charset , char const   *text , int bytes , char **ptext ) ;
#line 74
int convert_FromPilotChar_WithCharset(char const   *charset , char const   *ptext ,
                                      int bytes , char **text , char const   *pi_charset ) ;
#line 78
int convert_FromPilotChar(char const   *charset , char const   *ptext , int bytes ,
                          char **text ) ;
#line 37 "/usr/include/iconv.h"
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
#line 42
extern size_t iconv(iconv_t __cd , char ** __restrict  __inbuf , size_t * __restrict  __inbytesleft ,
                    char ** __restrict  __outbuf , size_t * __restrict  __outbytesleft ) ;
#line 51
extern int iconv_close(iconv_t __cd ) ;
#line 62 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/util.c"
int convert_ToPilotChar(char const   *charset , char const   *text , int bytes , char **ptext ) 
{ 
  char *pcharset ;
  int tmp ;

  {
  {
#line 69
  pcharset = getenv("PILOT_CHARSET");
  }
#line 69
  if ((unsigned long )pcharset == (unsigned long )((void *)0)) {
#line 70
    pcharset = (char *)"CP1252";
  }
  {
#line 71
  tmp = convert_ToPilotChar_WithCharset(charset, text, bytes, ptext, (char const   *)pcharset);
  }
#line 71
  return (tmp);
}
}
#line 102 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/util.c"
int convert_ToPilotChar_WithCharset(char const   *charset , char const   *text , int bytes ,
                                    char **ptext , char const   *pi_charset ) 
{ 
  char *ob ;
  iconv_t cd ;
  size_t ibl ;
  size_t obl ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 111
  if ((unsigned long )((void *)0) == (unsigned long )pi_charset) {
#line 112
    pi_charset = "CP1252";
  }
  {
#line 115
  cd = iconv_open(pi_charset, charset);
  }
#line 116
  if ((unsigned long )cd == (unsigned long )((iconv_t )-1)) {
#line 117
    return (-1);
  }
  {
#line 119
  ibl = (size_t )bytes;
#line 120
  obl = (size_t )(bytes * 4 + 1);
#line 121
  tmp = malloc(obl);
#line 121
  ob = (char *)tmp;
#line 121
  *ptext = ob;
#line 123
  tmp___0 = iconv(cd, (char **/* __restrict  */)(& text), (size_t */* __restrict  */)(& ibl),
                  (char **/* __restrict  */)(& ob), (size_t */* __restrict  */)(& obl));
  }
#line 123
  if (tmp___0 == 0xffffffffffffffffUL) {
#line 124
    return (-1);
  }
  {
#line 125
  *ob = (char )'\000';
#line 127
  iconv_close(cd);
  }
#line 129
  return (0);
}
}
#line 157 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/util.c"
int convert_FromPilotChar(char const   *charset , char const   *ptext , int bytes ,
                          char **text ) 
{ 
  char *pcharset ;
  int tmp ;

  {
  {
#line 164
  pcharset = getenv("PILOT_CHARSET");
  }
#line 164
  if ((unsigned long )pcharset == (unsigned long )((void *)0)) {
#line 165
    pcharset = (char *)"CP1252";
  }
  {
#line 166
  tmp = convert_FromPilotChar_WithCharset(charset, ptext, bytes, text, (char const   *)pcharset);
  }
#line 166
  return (tmp);
}
}
#line 193 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/util.c"
int convert_FromPilotChar_WithCharset(char const   *charset , char const   *ptext ,
                                      int bytes , char **text , char const   *pi_charset ) 
{ 
  char *ob ;
  iconv_t cd ;
  size_t ibl ;
  size_t obl ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 202
  if ((unsigned long )((void *)0) == (unsigned long )pi_charset) {
#line 203
    pi_charset = "CP1252";
  }
  {
#line 206
  cd = iconv_open(charset, pi_charset);
  }
#line 207
  if ((unsigned long )cd == (unsigned long )((iconv_t )-1)) {
#line 208
    return (-1);
  }
  {
#line 210
  ibl = (size_t )bytes;
#line 211
  obl = (size_t )(bytes * 4 + 1);
#line 212
  tmp = malloc(obl);
#line 212
  ob = (char *)tmp;
#line 212
  *text = ob;
#line 214
  tmp___0 = iconv(cd, (char **/* __restrict  */)(& ptext), (size_t */* __restrict  */)(& ibl),
                  (char **/* __restrict  */)(& ob), (size_t */* __restrict  */)(& obl));
  }
#line 214
  if (tmp___0 == 0xffffffffffffffffUL) {
#line 215
    return (-1);
  }
  {
#line 216
  *ob = (char )'\000';
#line 218
  iconv_close(cd);
  }
#line 220
  return (0);
}
}
#line 49 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_open___0(pi_socket_t *ps , struct pi_sockaddr *addr , size_t addrlen ) ;
#line 50
static int u_close___0(pi_socket_t *ps ) ;
#line 51
static int u_write___0(pi_socket_t *ps , unsigned char *buf___3 , size_t len , int flags ) ;
#line 52
static int u_read___0(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) ;
#line 53
static int u_poll___0(pi_socket_t *ps , int timeout ) ;
#line 54
static int u_flush___0(pi_socket_t *ps , int flags ) ;
#line 83 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_open___0(pi_socket_t *ps , struct pi_sockaddr *addr , size_t addrlen ) 
{ 
  int fd ;
  int i ;
  char *tty ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 88
  tty = addr->pi_device;
#line 90
  fd = open((char const   *)tty, 2050);
  }
#line 90
  if (fd < 0) {
#line 91
    ps->last_error = -502;
#line 92
    return (-502);
  }
  {
#line 95
  tmp___0 = isatty(fd);
  }
#line 95
  if (! tmp___0) {
    {
#line 96
    close(fd);
#line 97
    tmp = __errno_location();
#line 97
    *tmp = 22;
#line 98
    ps->last_error = -502;
    }
#line 99
    return (-502);
  }
  {
#line 102
  i = fcntl(fd, 3, 0);
  }
#line 102
  if (i != -1) {
    {
#line 103
    i &= -2049;
#line 104
    fcntl(fd, 4, i);
    }
  }
  {
#line 107
  i = pi_socket_setsd(ps, fd);
  }
#line 107
  if (i < 0) {
#line 108
    return (i);
  }
#line 110
  return (fd);
}
}
#line 125 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_close___0(pi_socket_t *ps ) 
{ 
  int tmp ;

  {
  {
#line 128
  pi_log(2, 4, "DEV CLOSE linuxusb fd: %d\n", ps->sd);
#line 131
  tmp = close(ps->sd);
  }
#line 131
  return (tmp);
}
}
#line 146 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_poll___0(pi_socket_t *ps , int timeout ) 
{ 
  struct timeval t ;
  fd_set ready ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 152
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 157
  if (timeout == 0) {
    {
#line 158
    select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
           (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
    }
  } else {
    {
#line 160
    t.tv_sec = (__time_t )(timeout / 1000);
#line 161
    t.tv_usec = (__suseconds_t )((timeout % 1000) * 1000);
#line 162
    select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
           (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
    }
  }
#line 165
  if (! ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
    {
#line 167
    pi_log(2, 2, "DEV POLL linuxusb timeout\n");
#line 169
    tmp = __errno_location();
#line 169
    *tmp = 110;
#line 170
    tmp___0 = pi_set_error(ps->sd, -202);
    }
#line 170
    return (tmp___0);
  }
  {
#line 173
  pi_log(2, 8, "DEV POLL linuxusb found data on fd: %d\n", ps->sd);
  }
#line 176
  return (1);
}
}
#line 191 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_write___0(pi_socket_t *ps , unsigned char *buf___3 , size_t len , int flags ) 
{ 
  int total ;
  int nwrote ;
  struct pi_usb_data *data ;
  struct timeval t ;
  fd_set ready ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;

  {
#line 196
  data = (struct pi_usb_data *)(ps->device)->data;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 200
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 203
  total = (int )len;
  {
#line 204
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 204
    if (! (total > 0)) {
#line 204
      goto while_break___0;
    }
#line 205
    if (data->timeout == 0) {
      {
#line 206
      select(ps->sd + 1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)(& ready),
             (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
      }
    } else {
      {
#line 208
      t.tv_sec = (__time_t )(data->timeout / 1000);
#line 209
      t.tv_usec = (__suseconds_t )((data->timeout % 1000) * 1000);
#line 210
      tmp___0 = select(ps->sd + 1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)(& ready),
                       (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
      }
#line 210
      if (tmp___0) {
        {
#line 211
        tmp = pi_set_error(ps->sd, -202);
        }
#line 211
        return (tmp);
      }
    }
#line 214
    if (! ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
      {
#line 215
      ps->state = 8;
#line 216
      tmp___1 = pi_set_error(ps->sd, -200);
      }
#line 216
      return (tmp___1);
    }
    {
#line 219
    tmp___2 = write(ps->sd, (void const   *)buf___3, len);
#line 219
    nwrote = (int )tmp___2;
    }
#line 220
    if (nwrote < 0) {
      {
#line 221
      ps->state = 8;
#line 222
      tmp___3 = pi_set_error(ps->sd, -200);
      }
#line 222
      return (tmp___3);
    }
#line 225
    total -= nwrote;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 228
  pi_log(2, 8, "DEV TX linuxusb wrote %d bytes\n", len);
  }
#line 231
  return ((int )len);
}
}
#line 246 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_read_buf___0(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) 
{ 
  struct pi_usb_data *data ;
  size_t rbuf ;
  int *tmp ;
  int tmp___0 ;
  pi_buffer_t *tmp___1 ;

  {
#line 249
  data = (struct pi_usb_data *)(ps->device)->data;
#line 250
  rbuf = data->buf_size;
#line 252
  if (rbuf > len) {
#line 253
    rbuf = len;
  }
  {
#line 255
  tmp___1 = pi_buffer_append(buf___3, (void const   *)(data->buf), rbuf);
  }
#line 255
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 256
    tmp = __errno_location();
#line 256
    *tmp = 12;
#line 257
    tmp___0 = pi_set_error(ps->sd, -500);
    }
#line 257
    return (tmp___0);
  }
#line 260
  if (flags != 1) {
#line 261
    data->buf_size -= rbuf;
#line 262
    if (data->buf_size > 0UL) {
      {
#line 263
      memmove((void *)(data->buf), (void const   *)(& data->buf[rbuf]), data->buf_size);
      }
    }
  }
  {
#line 266
  pi_log(2, 8, "DEV RX linuxusb read %d bytes from read-ahead buffer\n", rbuf);
  }
#line 269
  return ((int )rbuf);
}
}
#line 284 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_read___0(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) 
{ 
  ssize_t rbuf ;
  ssize_t bytes ;
  struct pi_usb_data *data ;
  struct timeval t ;
  fd_set ready ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  pi_buffer_t *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
#line 287
  rbuf = (ssize_t )0;
#line 289
  data = (struct pi_usb_data *)(ps->device)->data;
#line 294
  if (data->buf_size) {
    {
#line 295
    tmp = u_read_buf___0(ps, buf___3, len, flags);
#line 295
    rbuf = (ssize_t )tmp;
    }
#line 296
    if (rbuf < 0L) {
#line 297
      return ((int )rbuf);
    }
#line 298
    len -= (size_t )rbuf;
#line 299
    if (len == 0UL) {
#line 300
      return ((int )rbuf);
    }
  }
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 305
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 307
  if (data->timeout == 0) {
    {
#line 308
    select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
           (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
    }
  } else {
    {
#line 310
    t.tv_sec = (__time_t )(data->timeout / 1000);
#line 311
    t.tv_usec = (__suseconds_t )((data->timeout % 1000) * 1000);
#line 312
    tmp___2 = select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
                     (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
    }
#line 312
    if (tmp___2 == 0) {
      {
#line 313
      pi_log(2, 2, "DEV RX linuxusb timeout\n");
#line 315
      tmp___0 = __errno_location();
#line 315
      *tmp___0 = 110;
#line 316
      tmp___1 = pi_set_error(ps->sd, -202);
      }
#line 316
      return (tmp___1);
    }
  }
#line 321
  if ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 322
    if (flags == 1) {
#line 322
      if (len > 256UL) {
#line 323
        len = (size_t )256;
      }
    }
    {
#line 325
    tmp___5 = pi_buffer_expect(buf___3, len);
    }
#line 325
    if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
      {
#line 326
      tmp___3 = __errno_location();
#line 326
      *tmp___3 = 12;
#line 327
      tmp___4 = pi_set_error(ps->sd, -500);
      }
#line 327
      return (tmp___4);
    }
    {
#line 330
    bytes = read(ps->sd, (void *)(buf___3->data + buf___3->used), len);
    }
#line 332
    if (bytes > 0L) {
#line 333
      if (flags == 1) {
        {
#line 334
        memcpy((void */* __restrict  */)(data->buf + data->buf_size), (void const   */* __restrict  */)(buf___3->data + buf___3->used),
               (size_t )bytes);
#line 335
        data->buf_size += (size_t )bytes;
        }
      }
      {
#line 337
      buf___3->used += (size_t )bytes;
#line 338
      rbuf += bytes;
#line 340
      pi_log(2, 8, "DEV RX linuxusb read %d bytes\n", bytes);
      }
    }
  } else {
    {
#line 344
    pi_log(2, 2, "DEV RX linuxusb timeout\n");
#line 346
    tmp___6 = __errno_location();
#line 346
    *tmp___6 = 110;
#line 347
    tmp___7 = pi_set_error(ps->sd, -202);
    }
#line 347
    return (tmp___7);
  }
#line 350
  return ((int )rbuf);
}
}
#line 370 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_flush___0(pi_socket_t *ps , int flags ) 
{ 
  char buf___3[256] ;
  int fl ;
  struct pi_usb_data *data ;
  int tmp ;

  {
#line 375
  data = (struct pi_usb_data *)(ps->device)->data;
#line 377
  if (flags & 1) {
    {
#line 379
    data->buf_size = (size_t )0;
#line 382
    fl = fcntl(ps->sd, 3, 0);
    }
#line 382
    if (fl != -1) {
      {
#line 383
      fcntl(ps->sd, 4, fl | 2048);
      }
      {
#line 384
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 384
        tmp = (int )recv(ps->sd, buf___3, sizeof(buf___3), 0);
        }
#line 384
        if (! (tmp > 0)) {
#line 384
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 386
      fcntl(ps->sd, 4, 0);
      }
    }
    {
#line 389
    pi_log(2, 8, "DEV FLUSH linuxusb flushed input buffer\n");
    }
  }
#line 392
  return (0);
}
}
#line 40 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
static int cmp_flush___0(pi_socket_t *ps , int flags ) ;
#line 41
static int cmp_getsockopt___0(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) ;
#line 43
static int cmp_setsockopt___0(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) ;
#line 46
static pi_protocol_t *cmp_protocol_dup___0(pi_protocol_t *prot ) ;
#line 47
static void cmp_protocol_free___0(pi_protocol_t *prot ) ;
#line 61 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
static pi_protocol_t *cmp_protocol_dup___0(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  struct pi_cmp_data *data ;
  struct pi_cmp_data *new_data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 69
  tmp = malloc(sizeof(pi_protocol_t ));
#line 69
  new_prot = (pi_protocol_t *)tmp;
#line 70
  tmp___0 = malloc(sizeof(struct pi_cmp_data ));
#line 70
  new_data = (struct pi_cmp_data *)tmp___0;
  }
#line 72
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 72
    if ((unsigned long )new_data != (unsigned long )((void *)0)) {
#line 73
      new_prot->level = prot->level;
#line 74
      new_prot->dup = prot->dup;
#line 75
      new_prot->free = prot->free;
#line 76
      new_prot->read = prot->read;
#line 77
      new_prot->write = prot->write;
#line 78
      new_prot->flush = prot->flush;
#line 79
      new_prot->getsockopt = prot->getsockopt;
#line 80
      new_prot->setsockopt = prot->setsockopt;
#line 82
      data = (struct pi_cmp_data *)prot->data;
#line 83
      new_data->type = data->type;
#line 84
      new_data->flags = data->flags;
#line 85
      new_data->version = data->version;
#line 86
      new_data->baudrate = data->baudrate;
#line 88
      new_prot->data = (void *)new_data;
    } else {
#line 72
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 90
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
    {
#line 91
    free((void *)new_prot);
#line 92
    new_prot = (pi_protocol_t *)((void *)0);
    }
  } else
#line 93
  if ((unsigned long )new_data != (unsigned long )((void *)0)) {
    {
#line 94
    free((void *)new_data);
#line 95
    new_data = (struct pi_cmp_data *)((void *)0);
    }
  }
#line 98
  return (new_prot);
}
}
#line 113 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
static void cmp_protocol_free___0(pi_protocol_t *prot ) 
{ 


  {
#line 116
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 117
    if ((unsigned long )prot->data != (unsigned long )((void *)0)) {
      {
#line 118
      free(prot->data);
      }
    }
    {
#line 119
    free((void *)prot);
    }
  }
#line 121
  return;
}
}
#line 391 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
static int cmp_flush___0(pi_socket_t *ps , int flags ) 
{ 
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 397
  prot = pi_protocol(ps->sd, 5);
  }
#line 398
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 399
    tmp = pi_set_error(ps->sd, -201);
    }
#line 399
    return (tmp);
  }
  {
#line 401
  next = pi_protocol_next(ps->sd, 5);
  }
#line 402
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 403
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 403
    return (tmp___0);
  }
  {
#line 405
  tmp___1 = (*(next->flush))(ps, flags);
  }
#line 405
  return (tmp___1);
}
}
#line 511 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
static int cmp_getsockopt___0(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  struct pi_cmp_data *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 520
  prot = pi_protocol(ps->sd, 5);
  }
#line 521
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 522
    tmp = pi_set_error(ps->sd, -201);
    }
#line 522
    return (tmp);
  }
#line 523
  data = (struct pi_cmp_data *)prot->data;
  {
#line 526
  if (option_name == 0) {
#line 526
    goto case_0;
  }
#line 534
  if (option_name == 1) {
#line 534
    goto case_1;
  }
#line 542
  if (option_name == 2) {
#line 542
    goto case_2;
  }
#line 550
  if (option_name == 3) {
#line 550
    goto case_3;
  }
#line 525
  goto switch_break;
  case_0: /* CIL Label */ 
#line 527
  if (*option_len != sizeof(data->type)) {
#line 528
    goto error;
  }
  {
#line 529
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->type),
         sizeof(data->type));
#line 531
  *option_len = sizeof(data->type);
  }
#line 532
  goto switch_break;
  case_1: /* CIL Label */ 
#line 535
  if (*option_len != sizeof(data->flags)) {
#line 536
    goto error;
  }
  {
#line 537
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->flags),
         sizeof(data->flags));
#line 539
  *option_len = sizeof(data->flags);
  }
#line 540
  goto switch_break;
  case_2: /* CIL Label */ 
#line 543
  if (*option_len != sizeof(data->version)) {
#line 544
    goto error;
  }
  {
#line 545
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->version),
         sizeof(data->version));
#line 547
  *option_len = sizeof(data->version);
  }
#line 548
  goto switch_break;
  case_3: /* CIL Label */ 
#line 551
  if (*option_len != sizeof(data->baudrate)) {
#line 552
    goto error;
  }
  {
#line 553
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->baudrate),
         sizeof(data->baudrate));
#line 555
  *option_len = sizeof(data->baudrate);
  }
#line 556
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 559
  return (0);
  error: 
  {
#line 562
  tmp___0 = __errno_location();
#line 562
  *tmp___0 = 22;
#line 563
  tmp___1 = pi_set_error(ps->sd, -501);
  }
#line 563
  return (tmp___1);
}
}
#line 578 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
static int cmp_setsockopt___0(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  struct pi_padp_data *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 587
  prot = pi_protocol(ps->sd, 2);
  }
#line 588
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 589
    tmp = pi_set_error(ps->sd, -201);
    }
#line 589
    return (tmp);
  }
#line 590
  data = (struct pi_padp_data *)prot->data;
#line 592
  if (option_name == 0) {
#line 593
    if (*option_len != sizeof(data->type)) {
#line 594
      goto error;
    }
    {
#line 595
    memcpy((void */* __restrict  */)(& data->type), (void const   */* __restrict  */)option_value,
           sizeof(data->type));
#line 597
    *option_len = sizeof(data->type);
    }
  }
#line 600
  return (0);
  error: 
  {
#line 603
  tmp___0 = __errno_location();
#line 603
  *tmp___0 = 22;
#line 604
  tmp___1 = pi_set_error(ps->sd, -501);
  }
#line 604
  return (tmp___1);
}
}
#line 45 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static int padp_flush___0(pi_socket_t *ps , int flags ) ;
#line 46
static int padp_getsockopt___0(pi_socket_t *ps , int level , int option_name , void *option_value ,
                               size_t *option_len ) ;
#line 48
static int padp_setsockopt___0(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                               size_t *option_len ) ;
#line 50
static int padp_sendack___0(struct pi_socket *ps , struct pi_padp_data *data , unsigned char txid ,
                            struct padp *padp , int flags ) ;
#line 65 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static pi_protocol_t *padp_protocol_dup___0(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  pi_padp_data_t *data ;
  pi_padp_data_t *new_data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 68
  new_prot = (pi_protocol_t *)((void *)0);
#line 69
  data = (pi_padp_data_t *)((void *)0);
#line 69
  new_data = (pi_padp_data_t *)((void *)0);
#line 72
  tmp = malloc(sizeof(pi_protocol_t ));
#line 72
  new_prot = (pi_protocol_t *)tmp;
  }
#line 73
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
    {
#line 74
    tmp___0 = malloc(sizeof(pi_padp_data_t ));
#line 74
    new_data = (pi_padp_data_t *)tmp___0;
    }
#line 75
    if ((unsigned long )new_data == (unsigned long )((void *)0)) {
      {
#line 76
      free((void *)new_prot);
#line 77
      new_prot = (pi_protocol_t *)((void *)0);
      }
    } else {
      {
#line 79
      new_prot->level = prot->level;
#line 80
      new_prot->dup = prot->dup;
#line 81
      new_prot->free = prot->free;
#line 82
      new_prot->read = prot->read;
#line 83
      new_prot->write = prot->write;
#line 84
      new_prot->flush = prot->flush;
#line 85
      new_prot->getsockopt = prot->getsockopt;
#line 86
      new_prot->setsockopt = prot->setsockopt;
#line 88
      data = (pi_padp_data_t *)prot->data;
#line 89
      memcpy((void */* __restrict  */)new_data, (void const   */* __restrict  */)data,
             sizeof(pi_padp_data_t ));
#line 90
      new_prot->data = (void *)new_data;
      }
    }
  }
#line 94
  return (new_prot);
}
}
#line 109 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static void padp_protocol_free___0(pi_protocol_t *prot ) 
{ 


  {
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 112
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c",
             112, "prot != NULL");
      }
    }
#line 112
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 115
    if ((unsigned long )prot->data != (unsigned long )((void *)0)) {
      {
#line 116
      free(prot->data);
      }
    }
    {
#line 117
    free((void *)prot);
    }
  }
#line 119
  return;
}
}
#line 681 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static int padp_flush___0(pi_socket_t *ps , int flags ) 
{ 
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 687
  prot = pi_protocol(ps->sd, 2);
  }
#line 688
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 689
    tmp = pi_set_error(ps->sd, -201);
    }
#line 689
    return (tmp);
  }
  {
#line 691
  next = pi_protocol_next(ps->sd, 2);
  }
#line 692
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 693
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 693
    return (tmp___0);
  }
  {
#line 695
  tmp___1 = (*(next->flush))(ps, flags);
  }
#line 695
  return (tmp___1);
}
}
#line 709 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static int padp_getsockopt___0(pi_socket_t *ps , int level , int option_name , void *option_value ,
                               size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  pi_padp_data_t *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 716
  prot = pi_protocol(ps->sd, 2);
  }
#line 717
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 718
    tmp = pi_set_error(ps->sd, -201);
    }
#line 718
    return (tmp);
  }
#line 719
  data = (pi_padp_data_t *)prot->data;
  {
#line 722
  if (option_name == 0) {
#line 722
    goto case_0;
  }
#line 728
  if (option_name == 1) {
#line 728
    goto case_1;
  }
#line 734
  if (option_name == 2) {
#line 734
    goto case_2;
  }
#line 740
  if (option_name == 3) {
#line 740
    goto case_3;
  }
#line 721
  goto switch_break;
  case_0: /* CIL Label */ 
#line 723
  if (*option_len != sizeof(data->type)) {
#line 724
    goto error;
  }
  {
#line 725
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->type),
         sizeof(data->type));
  }
#line 726
  goto switch_break;
  case_1: /* CIL Label */ 
#line 729
  if (*option_len != sizeof(data->last_type)) {
#line 730
    goto error;
  }
  {
#line 731
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->last_type),
         sizeof(data->last_type));
  }
#line 732
  goto switch_break;
  case_2: /* CIL Label */ 
#line 735
  if (*option_len != sizeof(data->freeze_txid)) {
#line 736
    goto error;
  }
  {
#line 737
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->freeze_txid),
         sizeof(data->freeze_txid));
  }
#line 738
  goto switch_break;
  case_3: /* CIL Label */ 
#line 741
  if (*option_len != sizeof(data->use_long_format)) {
#line 742
    goto error;
  }
  {
#line 743
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->use_long_format),
         sizeof(data->use_long_format));
  }
#line 744
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 747
  return (0);
  error: 
  {
#line 750
  tmp___0 = __errno_location();
#line 750
  *tmp___0 = 22;
#line 751
  tmp___1 = pi_set_error(ps->sd, -501);
  }
#line 751
  return (tmp___1);
}
}
#line 766 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static int padp_setsockopt___0(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                               size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  pi_padp_data_t *data ;
  int was_frozen ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 774
  prot = pi_protocol(ps->sd, 2);
  }
#line 775
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 776
    tmp = pi_set_error(ps->sd, -201);
    }
#line 776
    return (tmp);
  }
#line 777
  data = (pi_padp_data_t *)prot->data;
  {
#line 780
  if (option_name == 0) {
#line 780
    goto case_0;
  }
#line 786
  if (option_name == 2) {
#line 786
    goto case_2;
  }
#line 798
  if (option_name == 3) {
#line 798
    goto case_3;
  }
#line 779
  goto switch_break;
  case_0: /* CIL Label */ 
#line 781
  if (*option_len != sizeof(data->type)) {
#line 782
    goto error;
  }
  {
#line 783
  memcpy((void */* __restrict  */)(& data->type), (void const   */* __restrict  */)option_value,
         sizeof(data->type));
  }
#line 784
  goto switch_break;
  case_2: /* CIL Label */ 
#line 787
  if (*option_len != sizeof(data->freeze_txid)) {
#line 788
    goto error;
  }
  {
#line 789
  was_frozen = data->freeze_txid;
#line 790
  memcpy((void */* __restrict  */)(& data->freeze_txid), (void const   */* __restrict  */)option_value,
         sizeof(data->freeze_txid));
  }
#line 791
  if (was_frozen) {
#line 791
    if (! data->freeze_txid) {
#line 792
      (data->next_txid) ++;
#line 793
      if (data->next_txid >= 254U) {
#line 794
        data->next_txid = 1U;
      }
    }
  }
#line 796
  goto switch_break;
  case_3: /* CIL Label */ 
#line 799
  if (*option_len != sizeof(data->use_long_format)) {
#line 800
    goto error;
  }
  {
#line 801
  memcpy((void */* __restrict  */)(& data->use_long_format), (void const   */* __restrict  */)option_value,
         sizeof(data->use_long_format));
  }
#line 802
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 805
  return (0);
  error: 
  {
#line 808
  tmp___0 = __errno_location();
#line 808
  *tmp___0 = 22;
#line 809
  tmp___1 = pi_set_error(ps->sd, -501);
  }
#line 809
  return (tmp___1);
}
}
#line 823 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static int padp_sendack___0(struct pi_socket *ps , struct pi_padp_data *data , unsigned char txid ,
                            struct padp *padp , int flags ) 
{ 
  int type ;
  int socket___0 ;
  int result ;
  int header_size ;
  size_t size ;
  unsigned char npadp_buf[6] ;
  struct pi_protocol *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;

  {
  {
#line 840
  next = pi_protocol_next(ps->sd, 2);
  }
#line 841
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 842
    tmp = pi_set_error(ps->sd, -201);
    }
#line 842
    return (tmp);
  }
  {
#line 844
  type = 2;
#line 845
  socket___0 = 3;
#line 846
  size = sizeof(type);
#line 847
  pi_setsockopt(ps->sd, 1, 4, (void const   *)(& type), & size);
#line 848
  pi_setsockopt(ps->sd, 1, 0, (void const   *)(& socket___0), & size);
#line 849
  pi_setsockopt(ps->sd, 1, 2, (void const   *)(& socket___0), & size);
#line 850
  size = sizeof(txid);
#line 851
  pi_setsockopt(ps->sd, 1, 6, (void const   *)(& txid), & size);
#line 853
  header_size = 4;
#line 854
  *(& npadp_buf[0] + 0) = (unsigned char)2;
#line 855
  *(& npadp_buf[1] + 0) = padp->flags;
  }
#line 856
  if ((int )padp->flags & 16) {
#line 857
    header_size += 2;
#line 858
    *(& npadp_buf[2] + 0) = (unsigned char )((int )((unsigned char )((unsigned long )padp->size >> 24)) & 255);
#line 858
    *(& npadp_buf[2] + 1) = (unsigned char )(((unsigned long )padp->size >> 16) & 255UL);
#line 858
    *(& npadp_buf[2] + 2) = (unsigned char )(((unsigned long )padp->size >> 8) & 255UL);
#line 858
    *(& npadp_buf[2] + 3) = (unsigned char )((unsigned long )padp->size & 255UL);
  } else {
#line 860
    *(& npadp_buf[2] + 0) = (unsigned char )(((int )((unsigned short )padp->size) >> 8) & 255);
#line 860
    *(& npadp_buf[2] + 1) = (unsigned char )((int )((unsigned short )padp->size) & 255);
  }
  {
#line 863
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 863
    tmp___0 = pi_debug_get_types();
    }
#line 863
    if (tmp___0 & 8) {
      {
#line 863
      tmp___1 = pi_debug_get_level();
      }
#line 863
      if (tmp___1 >= 4) {
        {
#line 863
        padp_dump_header((unsigned char const   *)(npadp_buf), 1);
        }
      }
    }
#line 863
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 864
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 864
    tmp___2 = pi_debug_get_types();
    }
#line 864
    if (tmp___2 & 8) {
      {
#line 864
      tmp___3 = pi_debug_get_level();
      }
#line 864
      if (tmp___3 >= 8) {
        {
#line 864
        padp_dump((unsigned char const   *)(npadp_buf));
        }
      }
    }
#line 864
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 866
  tmp___4 = (*(next->write))(ps, (unsigned char const   *)(npadp_buf), (size_t )header_size,
                             flags);
#line 866
  result = (int )tmp___4;
  }
#line 868
  if (result >= 0) {
#line 869
    data->last_ack_txid = txid;
#line 870
    data->last_ack_padp.type = padp->type;
#line 871
    data->last_ack_padp.flags = padp->flags;
#line 872
    data->last_ack_padp.size = padp->size;
  }
#line 875
  return (result);
}
}
#line 48 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static void pi_inet_device_free___0(pi_device_t *dev ) ;
#line 49
static pi_protocol_t *pi_inet_protocol___0(pi_device_t *dev ) ;
#line 50
static pi_protocol_t *pi_inet_protocol_dup___0(pi_protocol_t *prot ) ;
#line 51
static void pi_inet_protocol_free___0(pi_protocol_t *prot ) ;
#line 52
static int pi_inet_close___0(pi_socket_t *ps ) ;
#line 53
static int pi_inet_connect___0(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
#line 54
static int pi_inet_bind___0(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
#line 55
static int pi_inet_listen___0(pi_socket_t *ps , int backlog ) ;
#line 56
static int pi_inet_accept___0(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) ;
#line 57
static ssize_t pi_inet_read___0(pi_socket_t *ps , pi_buffer_t *msg , size_t len ,
                                int flags ) ;
#line 58
static ssize_t pi_inet_write___0(pi_socket_t *ps , unsigned char const   *msg , size_t len ,
                                 int flags ) ;
#line 59
static int pi_inet_getsockopt___0(pi_socket_t *ps , int level , int option_name ,
                                  void *option_value , size_t *option_len ) ;
#line 60
static int pi_inet_setsockopt___0(pi_socket_t *ps , int level , int option_name ,
                                  void const   *option_value , size_t *option_len ) ;
#line 61
static int pi_inet_flush___0(pi_socket_t *ps , int flags ) ;
#line 100 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static void pi_inet_device_free___0(pi_device_t *dev ) 
{ 


  {
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! ((unsigned long )dev != (unsigned long )((void *)0))) {
      {
#line 103
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c",
             103, "dev != NULL");
      }
    }
#line 103
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if ((unsigned long )dev != (unsigned long )((void *)0)) {
#line 105
    if ((unsigned long )dev->data != (unsigned long )((void *)0)) {
      {
#line 106
      free(dev->data);
      }
    }
    {
#line 107
    free((void *)dev);
    }
  }
#line 109
  return;
}
}
#line 111 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static pi_protocol_t *pi_inet_protocol___0(pi_device_t *dev ) 
{ 
  pi_protocol_t *prot ;
  pi_inet_data_t *data ;
  void *tmp ;

  {
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! ((unsigned long )dev != (unsigned long )((void *)0))) {
      {
#line 117
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c",
             117, "dev != NULL");
      }
    }
#line 117
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  data = (pi_inet_data_t *)dev->data;
#line 121
  tmp = malloc(sizeof(pi_protocol_t ));
#line 121
  prot = (pi_protocol_t *)tmp;
  }
#line 123
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 124
    prot->level = 0;
#line 125
    prot->dup = & pi_inet_protocol_dup___0;
#line 126
    prot->free = & pi_inet_protocol_free___0;
#line 127
    prot->read = & pi_inet_read___0;
#line 128
    prot->write = & pi_inet_write___0;
#line 129
    prot->flush = & pi_inet_flush___0;
#line 130
    prot->getsockopt = & pi_inet_getsockopt___0;
#line 131
    prot->setsockopt = & pi_inet_setsockopt___0;
#line 132
    prot->data = (void *)0;
  }
#line 135
  return (prot);
}
}
#line 138 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static pi_protocol_t *pi_inet_protocol_dup___0(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  void *tmp ;

  {
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 143
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c",
             143, "prot != NULL");
      }
    }
#line 143
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 145
  tmp = malloc(sizeof(pi_protocol_t ));
#line 145
  new_prot = (pi_protocol_t *)tmp;
  }
#line 147
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 148
    new_prot->level = prot->level;
#line 149
    new_prot->dup = prot->dup;
#line 150
    new_prot->free = prot->free;
#line 151
    new_prot->read = prot->read;
#line 152
    new_prot->write = prot->write;
#line 153
    new_prot->flush = prot->flush;
#line 154
    new_prot->getsockopt = prot->getsockopt;
#line 155
    new_prot->setsockopt = prot->setsockopt;
#line 156
    new_prot->data = (void *)0;
  }
#line 159
  return (new_prot);
}
}
#line 162 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static void pi_inet_protocol_free___0(pi_protocol_t *prot ) 
{ 


  {
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 165
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c",
             165, "prot != NULL");
      }
    }
#line 165
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
    {
#line 167
    free((void *)prot);
    }
  }
#line 168
  return;
}
}
#line 170 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_bind___0(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) 
{ 
  int opt ;
  int sd ;
  int err ;
  size_t optlen ;
  struct pi_sockaddr *paddr ;
  struct sockaddr_in serv_addr ;
  char *device ;
  char *port ;
  struct hostent *hostent ;
  struct hostent *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;

  {
  {
#line 177
  paddr = (struct pi_sockaddr *)addr;
#line 179
  device = paddr->pi_device;
#line 179
  port = (char *)((void *)0);
#line 183
  memset((void *)(& serv_addr), 0, sizeof(serv_addr));
#line 184
  serv_addr.sin_family = (sa_family_t )2;
#line 185
  tmp___1 = strlen((char const   *)device);
  }
#line 185
  if (tmp___1 > 1UL) {
    {
#line 185
    tmp___2 = strncmp((char const   *)device, "any", (size_t )3);
    }
#line 185
    if (tmp___2) {
      {
#line 186
      serv_addr.sin_addr.s_addr = inet_addr((char const   *)device);
      }
#line 187
      if (serv_addr.sin_addr.s_addr == 4294967295U) {
        {
#line 188
        tmp = gethostbyname((char const   *)device);
#line 188
        hostent = tmp;
        }
#line 190
        if (! hostent) {
          {
#line 191
          tmp___0 = pi_set_error(ps->sd, -502);
          }
#line 191
          return (tmp___0);
        }
        {
#line 193
        memcpy((void */* __restrict  */)((char *)(& serv_addr.sin_addr.s_addr)), (void const   */* __restrict  */)*(hostent->h_addr_list + 0),
               (size_t )hostent->h_length);
        }
      }
    } else {
      {
#line 197
      serv_addr.sin_addr.s_addr = htonl((in_addr_t )0);
      }
    }
  } else {
    {
#line 197
    serv_addr.sin_addr.s_addr = htonl((in_addr_t )0);
    }
  }
  {
#line 199
  port = strchr((char const   *)device, ':');
  }
#line 199
  if ((unsigned long )port != (unsigned long )((void *)0)) {
    {
#line 200
    port ++;
#line 200
    tmp___3 = atoi((char const   *)port);
#line 200
    serv_addr.sin_port = htons((uint16_t )tmp___3);
    }
  } else {
    {
#line 202
    serv_addr.sin_port = htons((uint16_t )14238);
    }
  }
  {
#line 205
  sd = socket(2, 1, 0);
  }
#line 206
  if (sd < 0) {
    {
#line 207
    pi_log(2, 1, "DEV BIND Inet: Unable to create socket\n");
#line 209
    tmp___4 = pi_set_error(ps->sd, -502);
    }
#line 209
    return (tmp___4);
  }
  {
#line 211
  err = pi_socket_setsd(ps, sd);
  }
#line 211
  if (err < 0) {
#line 212
    return (err);
  }
  {
#line 214
  opt = 1;
#line 215
  optlen = sizeof(opt);
#line 217
  tmp___6 = setsockopt(ps->sd, 1, 2, (void const   *)((void *)(& opt)), (socklen_t )((int )optlen));
  }
#line 217
  if (tmp___6 < 0) {
    {
#line 219
    tmp___5 = pi_set_error(ps->sd, -502);
    }
#line 219
    return (tmp___5);
  }
  {
#line 222
  tmp___8 = bind(ps->sd, (struct sockaddr  const  *)((struct sockaddr *)(& serv_addr)),
                 (socklen_t )sizeof(serv_addr));
  }
#line 222
  if (tmp___8 < 0) {
    {
#line 223
    tmp___7 = pi_set_error(ps->sd, -502);
    }
#line 223
    return (tmp___7);
  }
  {
#line 225
  pi_log(2, 4, "DEV BIND Inet Bound to %s\n", device);
#line 228
  tmp___9 = malloc(addrlen);
#line 228
  ps->raddr = (struct sockaddr *)tmp___9;
#line 229
  memcpy((void */* __restrict  */)ps->raddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 230
  ps->raddrlen = addrlen;
#line 231
  tmp___10 = malloc(addrlen);
#line 231
  ps->laddr = (struct sockaddr *)tmp___10;
#line 232
  memcpy((void */* __restrict  */)ps->laddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 233
  ps->laddrlen = addrlen;
  }
#line 235
  return (0);
}
}
#line 238 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_connect___0(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) 
{ 
  int sd ;
  int err ;
  struct pi_sockaddr *paddr ;
  struct sockaddr_in serv_addr ;
  char *device ;
  struct hostent *hostent ;
  struct hostent *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 244
  paddr = (struct pi_sockaddr *)addr;
#line 246
  device = paddr->pi_device;
#line 249
  memset((void *)(& serv_addr), 0, sizeof(serv_addr));
#line 250
  serv_addr.sin_family = (sa_family_t )2;
#line 251
  tmp___1 = strlen((char const   *)device);
  }
#line 251
  if (tmp___1 > 1UL) {
    {
#line 252
    serv_addr.sin_addr.s_addr = inet_addr((char const   *)device);
    }
#line 253
    if (serv_addr.sin_addr.s_addr == 4294967295U) {
      {
#line 254
      tmp = gethostbyname((char const   *)device);
#line 254
      hostent = tmp;
      }
#line 256
      if (! hostent) {
        {
#line 257
        pi_log(2, 1, "DEV CONNECT Inet: Unable to determine host\n");
#line 260
        tmp___0 = pi_set_error(ps->sd, -502);
        }
#line 260
        return (tmp___0);
      }
      {
#line 263
      memcpy((void */* __restrict  */)((char *)(& serv_addr.sin_addr.s_addr)), (void const   */* __restrict  */)*(hostent->h_addr_list + 0),
             (size_t )hostent->h_length);
      }
    }
  } else {
    {
#line 267
    serv_addr.sin_addr.s_addr = htonl((in_addr_t )0);
    }
  }
  {
#line 269
  serv_addr.sin_port = htons((uint16_t )14238);
#line 271
  sd = socket(2, 1, 0);
  }
#line 273
  if (sd < 0) {
    {
#line 274
    pi_log(2, 1, "DEV CONNECT Inet: Unable to create socket\n");
#line 276
    tmp___2 = pi_set_error(ps->sd, -502);
    }
#line 276
    return (tmp___2);
  }
  {
#line 279
  err = pi_socket_setsd(ps, sd);
  }
#line 279
  if (err < 0) {
#line 280
    return (err);
  }
  {
#line 282
  tmp___4 = connect(ps->sd, (struct sockaddr  const  *)((struct sockaddr *)(& serv_addr)),
                    (socklen_t )sizeof(serv_addr));
  }
#line 282
  if (tmp___4 < 0) {
    {
#line 284
    pi_log(2, 1, "DEV CONNECT Inet: Unable to connect\n");
#line 286
    tmp___3 = pi_set_error(ps->sd, -502);
    }
#line 286
    return (tmp___3);
  }
  {
#line 289
  tmp___5 = malloc(addrlen);
#line 289
  ps->raddr = (struct sockaddr *)tmp___5;
#line 290
  memcpy((void */* __restrict  */)ps->raddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 291
  ps->raddrlen = addrlen;
#line 292
  tmp___6 = malloc(addrlen);
#line 292
  ps->laddr = (struct sockaddr *)tmp___6;
#line 293
  memcpy((void */* __restrict  */)ps->laddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 294
  ps->laddrlen = addrlen;
  }
  {
#line 297
  if (ps->cmd == 1) {
#line 297
    goto case_1;
  }
#line 301
  if (ps->cmd == 2) {
#line 301
    goto case_2;
  }
#line 296
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 298
  err = cmp_tx_handshake(ps);
  }
#line 298
  if (err < 0) {
#line 299
    goto fail;
  }
#line 300
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 302
  err = net_tx_handshake(ps);
  }
#line 302
  if (err < 0) {
#line 303
    goto fail;
  }
#line 304
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 306
  ps->state = 4;
#line 307
  ps->command = 0;
#line 309
  pi_log(2, 4, "DEV CONNECT Inet: Connected\n");
  }
#line 310
  return (0);
  fail: 
#line 313
  return (err);
}
}
#line 316 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_listen___0(pi_socket_t *ps , int backlog ) 
{ 
  int result ;

  {
  {
#line 321
  result = listen(ps->sd, backlog);
  }
#line 322
  if (result == 0) {
#line 323
    ps->state = 1;
  }
#line 325
  return (result);
}
}
#line 328 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_accept___0(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) 
{ 
  int sd ;
  int err ;
  int split ;
  int chunksize ;
  size_t len ;
  size_t size ;
  socklen_t l ;
  unsigned char cmp_flags ;
  int use_long_format ;

  {
#line 331
  split = 0;
#line 331
  chunksize = 0;
#line 337
  l = (socklen_t )0;
#line 340
  if (addrlen) {
#line 341
    l = (socklen_t )*addrlen;
  }
  {
#line 342
  sd = accept(ps->sd, (struct sockaddr */* __restrict  */)addr, (socklen_t */* __restrict  */)(& l));
  }
#line 343
  if (addrlen) {
#line 344
    *addrlen = (size_t )l;
  }
#line 345
  if (sd < 0) {
    {
#line 346
    pi_set_error(ps->sd, sd);
#line 347
    err = -502;
    }
#line 348
    goto fail;
  }
  {
#line 351
  pi_socket_setsd(ps, sd);
#line 352
  pi_socket_init(ps);
  }
  {
#line 355
  if (ps->cmd == 1) {
#line 355
    goto case_1;
  }
#line 374
  if (ps->cmd == 2) {
#line 374
    goto case_2;
  }
#line 354
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 356
  err = cmp_rx_handshake(ps, 57600, 0);
  }
#line 356
  if (err < 0) {
#line 357
    goto fail;
  }
  {
#line 360
  size = sizeof(cmp_flags);
#line 361
  pi_getsockopt(ps->sd, 5, 1, (void *)(& cmp_flags), & size);
  }
#line 362
  if ((int )cmp_flags & 16) {
    {
#line 363
    use_long_format = 1;
#line 364
    size = sizeof(int );
#line 365
    pi_setsockopt(ps->sd, 2, 3, (void const   *)(& use_long_format), & size);
#line 367
    ps->command ^= 1;
#line 368
    pi_setsockopt(ps->sd, 2, 3, (void const   *)(& use_long_format), & size);
#line 370
    ps->command ^= 1;
    }
  }
#line 373
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 378
  len = sizeof(split);
#line 379
  pi_setsockopt(ps->sd, 3, 1, (void const   *)(& split), & len);
#line 381
  len = sizeof(chunksize);
#line 382
  pi_setsockopt(ps->sd, 3, 2, (void const   *)(& chunksize), & len);
#line 385
  ps->command ^= 1;
#line 386
  len = sizeof(split);
#line 387
  pi_setsockopt(ps->sd, 3, 1, (void const   *)(& split), & len);
#line 389
  len = sizeof(chunksize);
#line 390
  pi_setsockopt(ps->sd, 3, 2, (void const   *)(& chunksize), & len);
#line 392
  ps->command ^= 1;
#line 394
  err = net_rx_handshake(ps);
  }
#line 394
  if (err < 0) {
#line 395
    goto fail;
  }
#line 396
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 399
  ps->state = 2;
#line 400
  ps->command = 0;
#line 401
  ps->dlprecord = 0;
#line 403
  pi_log(2, 4, "DEV INET ACCEPT accepted\n");
  }
#line 405
  return (ps->sd);
  fail: 
#line 408
  return (err);
}
}
#line 411 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_close___0(pi_socket_t *ps ) 
{ 


  {
#line 414
  if (ps->sd) {
    {
#line 415
    close(ps->sd);
#line 416
    ps->sd = 0;
    }
  }
#line 418
  if (ps->laddr) {
    {
#line 419
    free((void *)ps->laddr);
#line 420
    ps->laddr = (struct sockaddr *)((void *)0);
    }
  }
#line 422
  if (ps->raddr) {
    {
#line 423
    free((void *)ps->raddr);
#line 424
    ps->raddr = (struct sockaddr *)((void *)0);
    }
  }
#line 426
  return (0);
}
}
#line 429 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_flush___0(pi_socket_t *ps , int flags ) 
{ 
  char buf___3[256] ;
  int fl ;
  ssize_t tmp ;

  {
#line 435
  if (flags & 1) {
    {
#line 436
    fl = fcntl(ps->sd, 3, 0);
    }
#line 436
    if (fl != -1) {
      {
#line 437
      fcntl(ps->sd, 4, fl | 2048);
      }
      {
#line 438
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 438
        tmp = recv(ps->sd, (void *)(buf___3), sizeof(buf___3), 0);
        }
#line 438
        if (! (tmp > 0L)) {
#line 438
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 440
      fcntl(ps->sd, 4, fl);
      }
    }
  }
#line 443
  return (0);
}
}
#line 446 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static ssize_t pi_inet_write___0(pi_socket_t *ps , unsigned char const   *msg , size_t len ,
                                 int flags ) 
{ 
  int total ;
  int nwrote ;
  pi_inet_data_t *data ;
  struct timeval t ;
  fd_set ready ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;

  {
#line 451
  data = (pi_inet_data_t *)(ps->device)->data;
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 455
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 455
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 458
  total = (int )len;
  {
#line 459
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 459
    if (! (total > 0)) {
#line 459
      goto while_break___0;
    }
#line 460
    if (data->timeout == 0) {
      {
#line 461
      tmp = select(ps->sd + 1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)(& ready),
                   (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
      }
#line 461
      if (tmp < 0) {
        {
#line 461
        tmp___0 = __errno_location();
        }
#line 461
        if (*tmp___0 == 4) {
#line 463
          goto while_continue___0;
        }
      }
    } else {
      {
#line 465
      t.tv_sec = (__time_t )(data->timeout / 1000);
#line 466
      t.tv_usec = (__suseconds_t )((data->timeout % 1000) * 1000);
#line 467
      tmp___2 = select(ps->sd + 1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)(& ready),
                       (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
      }
#line 467
      if (tmp___2 == 0) {
        {
#line 468
        tmp___1 = pi_set_error(ps->sd, -202);
        }
#line 468
        return ((ssize_t )tmp___1);
      }
    }
#line 470
    if (! ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
      {
#line 471
      ps->state = 8;
#line 472
      tmp___3 = pi_set_error(ps->sd, -200);
      }
#line 472
      return ((ssize_t )tmp___3);
    }
    {
#line 475
    tmp___4 = write(ps->sd, (void const   *)msg, len);
#line 475
    nwrote = (int )tmp___4;
    }
#line 476
    if (nwrote < 0) {
      {
#line 478
      tmp___6 = __errno_location();
      }
#line 478
      if (*tmp___6 == 32) {
        {
#line 479
        ps->state = 8;
#line 480
        tmp___5 = pi_set_error(ps->sd, -200);
        }
#line 480
        return ((ssize_t )tmp___5);
      } else {
        {
#line 478
        tmp___7 = __errno_location();
        }
#line 478
        if (*tmp___7 == 9) {
          {
#line 479
          ps->state = 8;
#line 480
          tmp___5 = pi_set_error(ps->sd, -200);
          }
#line 480
          return ((ssize_t )tmp___5);
        }
      }
      {
#line 482
      tmp___8 = pi_set_error(ps->sd, -204);
      }
#line 482
      return ((ssize_t )tmp___8);
    }
#line 485
    total -= nwrote;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 487
  data->tx_bytes = (int )((size_t )data->tx_bytes + len);
#line 489
  pi_log(2, 4, "DEV TX Inet Bytes: %d\n", len);
  }
#line 491
  return ((ssize_t )len);
}
}
#line 494 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static ssize_t pi_inet_read___0(pi_socket_t *ps , pi_buffer_t *msg , size_t len ,
                                int flags ) 
{ 
  int r ;
  int fl ;
  pi_inet_data_t *data ;
  fd_set ready ;
  struct timeval t ;
  int *tmp ;
  int tmp___0 ;
  pi_buffer_t *tmp___1 ;
  int __d0 ;
  int __d1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 497
  fl = 0;
#line 499
  data = (pi_inet_data_t *)(ps->device)->data;
#line 503
  tmp___1 = pi_buffer_expect(msg, len);
  }
#line 503
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 504
    tmp = __errno_location();
#line 504
    *tmp = 12;
#line 505
    tmp___0 = pi_set_error(ps->sd, -500);
    }
#line 505
    return ((ssize_t )tmp___0);
  }
#line 508
  if (flags == 1) {
#line 509
    fl = 2;
  }
  {
#line 511
  while (1) {
    while_continue: /* CIL Label */ ;
#line 511
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 511
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 512
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 516
  if (data->timeout == 0) {
    {
#line 517
    select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
           (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
    }
  } else {
    {
#line 519
    t.tv_sec = (__time_t )(data->timeout / 1000);
#line 520
    t.tv_usec = (__suseconds_t )((data->timeout % 1000) * 1000);
#line 521
    tmp___3 = select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
                     (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
    }
#line 521
    if (tmp___3 == 0) {
      {
#line 522
      tmp___2 = pi_set_error(ps->sd, -202);
      }
#line 522
      return ((ssize_t )tmp___2);
    }
  }
#line 526
  if ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
    {
#line 527
    tmp___4 = recv(ps->sd, (void *)(msg->data + msg->used), len, fl);
#line 527
    r = (int )tmp___4;
    }
#line 528
    if (r < 0) {
      {
#line 529
      tmp___6 = __errno_location();
      }
#line 529
      if (*tmp___6 == 32) {
        {
#line 530
        ps->state = 8;
#line 531
        tmp___5 = pi_set_error(ps->sd, -200);
        }
#line 531
        return ((ssize_t )tmp___5);
      } else {
        {
#line 529
        tmp___7 = __errno_location();
        }
#line 529
        if (*tmp___7 == 9) {
          {
#line 530
          ps->state = 8;
#line 531
          tmp___5 = pi_set_error(ps->sd, -200);
          }
#line 531
          return ((ssize_t )tmp___5);
        }
      }
      {
#line 533
      tmp___8 = pi_set_error(ps->sd, -204);
      }
#line 533
      return ((ssize_t )tmp___8);
    }
    {
#line 536
    data->rx_bytes += r;
#line 537
    msg->used += (size_t )r;
#line 539
    pi_log(2, 4, "DEV RX Inet Bytes: %d\n", r);
    }
#line 540
    return ((ssize_t )r);
  }
  {
#line 544
  pi_log(2, 2, "DEV RX Inet timeout\n");
#line 545
  (data->rx_errors) ++;
  }
#line 546
  return ((ssize_t )0);
}
}
#line 549 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_getsockopt___0(pi_socket_t *ps , int level , int option_name ,
                                  void *option_value , size_t *option_len ) 
{ 
  pi_inet_data_t *data ;
  int *tmp ;
  int tmp___0 ;

  {
#line 553
  data = (pi_inet_data_t *)(ps->device)->data;
  {
#line 556
  if (option_name == 3) {
#line 556
    goto case_3;
  }
#line 555
  goto switch_break;
  case_3: /* CIL Label */ 
#line 557
  if (*option_len != sizeof(data->timeout)) {
    {
#line 558
    tmp = __errno_location();
#line 558
    *tmp = 22;
#line 559
    tmp___0 = pi_set_error(ps->sd, -501);
    }
#line 559
    return (tmp___0);
  }
  {
#line 561
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->timeout),
         sizeof(data->timeout));
#line 563
  *option_len = sizeof(data->timeout);
  }
#line 564
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 567
  return (0);
}
}
#line 570 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_setsockopt___0(pi_socket_t *ps , int level , int option_name ,
                                  void const   *option_value , size_t *option_len ) 
{ 
  pi_inet_data_t *data ;
  int *tmp ;
  int tmp___0 ;

  {
#line 574
  data = (pi_inet_data_t *)(ps->device)->data;
  {
#line 577
  if (option_name == 3) {
#line 577
    goto case_3;
  }
#line 576
  goto switch_break;
  case_3: /* CIL Label */ 
#line 578
  if (*option_len != sizeof(data->timeout)) {
    {
#line 579
    tmp = __errno_location();
#line 579
    *tmp = 22;
#line 580
    tmp___0 = pi_set_error(ps->sd, -501);
    }
#line 580
    return (tmp___0);
  }
  {
#line 582
  memcpy((void */* __restrict  */)(& data->timeout), (void const   */* __restrict  */)option_value,
         sizeof(data->timeout));
  }
#line 584
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 587
  return (0);
}
}
#line 42 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static int net_flush___0(pi_socket_t *ps , int flags ) ;
#line 43
static int net_getsockopt___0(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) ;
#line 45
static int net_setsockopt___0(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) ;
#line 59 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static pi_protocol_t *net_protocol_dup___0(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  pi_net_data_t *data ;
  pi_net_data_t *new_data ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 62
  new_prot = (pi_protocol_t *)((void *)0);
#line 63
  data = (pi_net_data_t *)((void *)0);
#line 63
  new_data = (pi_net_data_t *)((void *)0);
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 66
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c",
             66, "prot != NULL");
      }
    }
#line 66
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 68
  tmp = malloc(sizeof(pi_protocol_t ));
#line 68
  new_prot = (pi_protocol_t *)tmp;
  }
#line 69
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
    {
#line 70
    tmp___0 = malloc(sizeof(pi_net_data_t ));
#line 70
    new_data = (pi_net_data_t *)tmp___0;
    }
#line 71
    if ((unsigned long )new_data == (unsigned long )((void *)0)) {
      {
#line 72
      free((void *)new_prot);
#line 73
      new_prot = (pi_protocol_t *)((void *)0);
      }
    }
  }
#line 77
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 77
    if ((unsigned long )new_data != (unsigned long )((void *)0)) {
#line 78
      new_prot->level = prot->level;
#line 79
      new_prot->dup = prot->dup;
#line 80
      new_prot->free = prot->free;
#line 81
      new_prot->read = prot->read;
#line 82
      new_prot->write = prot->write;
#line 83
      new_prot->flush = prot->flush;
#line 84
      new_prot->getsockopt = prot->getsockopt;
#line 85
      new_prot->setsockopt = prot->setsockopt;
#line 87
      data = (pi_net_data_t *)prot->data;
#line 88
      new_data->type = data->type;
#line 89
      new_data->split_writes = data->split_writes;
#line 90
      new_data->write_chunksize = data->write_chunksize;
#line 91
      new_data->txid = data->txid;
#line 92
      new_prot->data = (void *)new_data;
    }
  }
#line 95
  return (new_prot);
}
}
#line 110 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static void net_protocol_free___0(pi_protocol_t *prot ) 
{ 


  {
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 113
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c",
             113, "prot != NULL");
      }
    }
#line 113
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 116
    if ((unsigned long )prot->data != (unsigned long )((void *)0)) {
      {
#line 117
      free(prot->data);
      }
    }
    {
#line 118
    free((void *)prot);
    }
  }
#line 120
  return;
}
}
#line 184 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static unsigned char const   msg1___1[51]  = 
#line 184
  {      (unsigned char const   )'\022',      (unsigned char const   )'\001',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )' ',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'$',      (unsigned char const   )'\377',      (unsigned char const   )'\377', 
        (unsigned char const   )'\377',      (unsigned char const   )'\377',      (unsigned char const   )'<',      (unsigned char const   )'\000', 
        (unsigned char const   )'<',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\300',      (unsigned char const   )'\250', 
        (unsigned char const   )'\245',      (unsigned char const   )'\037',      (unsigned char const   )'\004',      (unsigned char const   )'\'', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000'};
#line 189 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static unsigned char const   msg2___1[47]  = 
#line 189
  {      (unsigned char const   )'\023',      (unsigned char const   )'\001',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )' ',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )' ',      (unsigned char const   )'\377',      (unsigned char const   )'\377', 
        (unsigned char const   )'\377',      (unsigned char const   )'\377',      (unsigned char const   )'\000',      (unsigned char const   )'<', 
        (unsigned char const   )'\000',      (unsigned char const   )'<',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\001',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000'};
#line 232 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static unsigned char const   msg1___2[23]  = 
#line 232
  {      (unsigned char const   )'\220',      (unsigned char const   )'\001',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )' ',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\b',      (unsigned char const   )'\001',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000'};
#line 235 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static unsigned char const   msg2___2[51]  = 
#line 235
  {      (unsigned char const   )'\222',      (unsigned char const   )'\001',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )' ',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'$',      (unsigned char const   )'\377',      (unsigned char const   )'\377', 
        (unsigned char const   )'\377',      (unsigned char const   )'\377',      (unsigned char const   )'\000',      (unsigned char const   )'<', 
        (unsigned char const   )'\000',      (unsigned char const   )'<',      (unsigned char const   )'@',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\001',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\300',      (unsigned char const   )'\250', 
        (unsigned char const   )'\245',      (unsigned char const   )'\036',      (unsigned char const   )'\004',      (unsigned char const   )'\001', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000'};
#line 240 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static unsigned char const   msg3___0[9]  = 
#line 240
  {      (unsigned char const   )'\223',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000'};
#line 276 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static int net_flush___0(pi_socket_t *ps , int flags ) 
{ 
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 282
  prot = pi_protocol(ps->sd, 3);
  }
#line 283
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 284
    tmp = pi_set_error(ps->sd, -201);
    }
#line 284
    return (tmp);
  }
  {
#line 286
  next = pi_protocol_next(ps->sd, 3);
  }
#line 287
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 288
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 288
    return (tmp___0);
  }
  {
#line 290
  tmp___1 = (*(next->flush))(ps, flags);
  }
#line 290
  return (tmp___1);
}
}
#line 572 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static int net_getsockopt___0(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  pi_net_data_t *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 579
  prot = pi_protocol(ps->sd, 3);
  }
#line 580
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 581
    tmp = pi_set_error(ps->sd, -201);
    }
#line 581
    return (tmp);
  }
#line 583
  data = (pi_net_data_t *)prot->data;
  {
#line 586
  if (option_name == 0) {
#line 586
    goto case_0;
  }
#line 585
  goto switch_break;
  case_0: /* CIL Label */ 
#line 587
  if (*option_len != sizeof(data->type)) {
    {
#line 588
    tmp___0 = __errno_location();
#line 588
    *tmp___0 = 22;
#line 589
    tmp___1 = pi_set_error(ps->sd, -501);
    }
#line 589
    return (tmp___1);
  }
  {
#line 591
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->type),
         sizeof(data->type));
#line 593
  *option_len = sizeof(data->type);
  }
#line 594
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 597
  return (0);
}
}
#line 612 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static int net_setsockopt___0(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  pi_net_data_t *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 619
  prot = pi_protocol(ps->sd, 3);
  }
#line 620
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 621
    tmp = pi_set_error(ps->sd, -201);
    }
#line 621
    return (tmp);
  }
#line 623
  data = (pi_net_data_t *)prot->data;
  {
#line 626
  if (option_name == 0) {
#line 626
    goto case_0;
  }
#line 639
  if (option_name == 1) {
#line 639
    goto case_1;
  }
#line 653
  if (option_name == 2) {
#line 653
    goto case_2;
  }
#line 625
  goto switch_break;
  case_0: /* CIL Label */ 
#line 627
  if (*option_len != sizeof(data->type)) {
    {
#line 628
    tmp___0 = __errno_location();
#line 628
    *tmp___0 = 22;
#line 629
    tmp___1 = pi_set_error(ps->sd, -501);
    }
#line 629
    return (tmp___1);
  }
  {
#line 631
  memcpy((void */* __restrict  */)(& data->type), (void const   */* __restrict  */)option_value,
         sizeof(data->type));
  }
#line 633
  goto switch_break;
  case_1: /* CIL Label */ 
#line 640
  if (*option_len != sizeof(data->split_writes)) {
    {
#line 641
    tmp___2 = __errno_location();
#line 641
    *tmp___2 = 22;
#line 642
    tmp___3 = pi_set_error(ps->sd, -501);
    }
#line 642
    return (tmp___3);
  }
  {
#line 644
  memcpy((void */* __restrict  */)(& data->split_writes), (void const   */* __restrict  */)option_value,
         sizeof(data->split_writes));
  }
#line 646
  goto switch_break;
  case_2: /* CIL Label */ 
#line 654
  if (*option_len != sizeof(data->write_chunksize)) {
    {
#line 655
    tmp___4 = __errno_location();
#line 655
    *tmp___4 = 22;
#line 656
    tmp___5 = pi_set_error(ps->sd, -501);
    }
#line 656
    return (tmp___5);
  }
  {
#line 658
  memcpy((void */* __restrict  */)(& data->write_chunksize), (void const   */* __restrict  */)option_value,
         sizeof(data->write_chunksize));
  }
#line 660
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 663
  return (0);
}
}
#line 87 "../include/pi-sync.h"
PilotRecord *sync_NewPilotRecord(int buf_size ) ;
#line 88
PilotRecord *sync_CopyPilotRecord(PilotRecord const   *precord ) ;
#line 89
void sync_FreePilotRecord(PilotRecord *precord ) ;
#line 91
DesktopRecord *sync_NewDesktopRecord(void) ;
#line 92
DesktopRecord *sync_CopyDesktopRecord(DesktopRecord const   *drecord ) ;
#line 94
void sync_FreeDesktopRecord(DesktopRecord *drecord ) ;
#line 96
int sync_CopyToPilot(SyncHandler *sh ) ;
#line 97
int sync_CopyFromPilot(SyncHandler *sh ) ;
#line 99
int sync_MergeToPilot(SyncHandler *sh ) ;
#line 100
int sync_MergeFromPilot(SyncHandler *sh ) ;
#line 102
int sync_Synchronize(SyncHandler *sh ) ;
#line 71 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
PilotRecord *sync_NewPilotRecord(int buf_size ) 
{ 
  PilotRecord *precord ;
  void *tmp ;

  {
  {
#line 75
  tmp = malloc(sizeof(PilotRecord ));
#line 75
  precord = (PilotRecord *)tmp;
#line 76
  memset((void *)precord, 0, sizeof(PilotRecord ));
#line 78
  precord->buffer = malloc((size_t )buf_size);
  }
#line 80
  return (precord);
}
}
#line 94 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
PilotRecord *sync_CopyPilotRecord(PilotRecord const   *precord ) 
{ 
  PilotRecord *new_record ;

  {
  {
#line 98
  new_record = sync_NewPilotRecord((int )sizeof(precord->buffer));
#line 100
  new_record->recID = (recordid_t )precord->recID;
#line 101
  new_record->catID = (int )precord->catID;
#line 102
  new_record->flags = (int )precord->flags;
#line 103
  memcpy((void */* __restrict  */)new_record->buffer, (void const   */* __restrict  */)precord->buffer,
         (size_t )precord->len);
#line 104
  new_record->len = (size_t )precord->len;
  }
#line 106
  return (new_record);
}
}
#line 121 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
void sync_FreePilotRecord(PilotRecord *precord ) 
{ 


  {
#line 123
  if (precord->buffer) {
    {
#line 124
    free(precord->buffer);
    }
  }
  {
#line 126
  free((void *)precord);
  }
#line 127
  return;
}
}
#line 140 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
DesktopRecord *sync_NewDesktopRecord(void) 
{ 
  DesktopRecord *drecord ;
  void *tmp ;

  {
  {
#line 144
  tmp = malloc(sizeof(DesktopRecord ));
#line 144
  drecord = (DesktopRecord *)tmp;
#line 145
  memset((void *)drecord, 0, sizeof(DesktopRecord ));
  }
#line 147
  return (drecord);
}
}
#line 161 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
DesktopRecord *sync_CopyDesktopRecord(DesktopRecord const   *drecord ) 
{ 
  DesktopRecord *new_record ;

  {
  {
#line 165
  new_record = sync_NewDesktopRecord();
#line 166
  *new_record = (DesktopRecord )*drecord;
  }
#line 168
  return (new_record);
}
}
#line 182 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
void sync_FreeDesktopRecord(DesktopRecord *drecord ) 
{ 


  {
  {
#line 184
  free((void *)drecord);
  }
#line 185
  return;
}
}
#line 199 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
static void add_record_queue(RecordQueue *rq , PilotRecord *precord , DesktopRecord *drecord ) 
{ 
  RecordQueueList *item ;
  void *tmp ;

  {
  {
#line 205
  tmp = malloc(sizeof(RecordQueueList ));
#line 205
  item = (RecordQueueList *)tmp;
  }
#line 207
  if ((unsigned long )drecord != (unsigned long )((void *)0)) {
#line 208
    item->drecord = drecord;
#line 209
    item->precord = (PilotRecord *)((void *)0);
  } else {
    {
#line 211
    item->drecord = (DesktopRecord *)((void *)0);
#line 212
    item->precord = sync_CopyPilotRecord((PilotRecord const   *)precord);
    }
  }
#line 215
  if (rq) {
#line 216
    item->next = rq->rql;
#line 217
    rq->rql = item;
  } else {
#line 219
    item->next = (RecordQueueList *)((void *)0);
  }
#line 222
  (rq->count) ++;
#line 223
  return;
}
}
#line 236 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
static int free_record_queue_list(SyncHandler *sh , RecordQueueList *rql ) 
{ 
  int result ;
  RecordQueueList *item ;

  {
#line 238
  result = 0;
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! ((unsigned long )rql != (unsigned long )((void *)0))) {
#line 241
      goto while_break;
    }
#line 242
    item = rql;
#line 243
    rql = rql->next;
#line 245
    if (item->drecord) {
      {
#line 246
      result = (*(sh->FreeMatch))(sh, item->drecord);
      }
#line 246
      if (result < 0) {
#line 246
        return (result);
      }
    }
#line 247
    if (item->precord) {
      {
#line 248
      sync_FreePilotRecord(item->precord);
      }
    }
    {
#line 250
    free((void *)item);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  return (0);
}
}
#line 268 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
static int delete_both(SyncHandler *sh , int dbhandle , DesktopRecord *drecord , PilotRecord *precord ,
                       RecordModifier rec_mod ) 
{ 
  int result ;

  {
#line 272
  result = 0;
#line 274
  if ((unsigned long )drecord != (unsigned long )((void *)0)) {
#line 275
    if ((unsigned int )rec_mod == 1U) {
#line 275
      goto _L;
    } else
#line 275
    if ((unsigned int )rec_mod == 2U) {
      _L: /* CIL Label */ 
      {
#line 275
      result = (*(sh->DeleteRecord))(sh, drecord);
      }
#line 275
      if (result < 0) {
#line 275
        return (result);
      }
    }
  }
#line 277
  if ((unsigned long )precord != (unsigned long )((void *)0)) {
#line 278
    if ((unsigned int )rec_mod == 0U) {
#line 278
      goto _L___0;
    } else
#line 278
    if ((unsigned int )rec_mod == 2U) {
      _L___0: /* CIL Label */ 
      {
#line 278
      result = dlp_DeleteRecord(sh->sd, dbhandle, 0, precord->recID);
      }
#line 278
      if (result < 0) {
#line 278
        return (result);
      }
    }
  }
#line 281
  return (result);
}
}
#line 295 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
static int store_record_on_pilot(SyncHandler *sh , int dbhandle , DesktopRecord *drecord ,
                                 RecordModifier rec_mod ) 
{ 
  int result ;
  PilotRecord precord ;
  recordid_t id_ ;

  {
  {
#line 299
  result = 0;
#line 303
  memset((void *)(& precord), 0, sizeof(PilotRecord ));
#line 305
  result = (*(sh->Prepare))(sh, drecord, & precord);
  }
#line 306
  if (result != 0) {
#line 307
    return (result);
  }
#line 309
  if ((unsigned int )rec_mod == 0U) {
#line 309
    goto _L;
  } else
#line 309
  if ((unsigned int )rec_mod == 2U) {
    _L: /* CIL Label */ 
    {
#line 309
    result = dlp_WriteRecord(sh->sd, dbhandle, precord.flags & 16, precord.recID,
                             precord.catID, (void const   *)precord.buffer, precord.len,
                             & id_);
    }
#line 309
    if (result < 0) {
#line 309
      return (result);
    }
  }
#line 313
  if ((unsigned int )rec_mod == 1U) {
#line 313
    goto _L___0;
  } else
#line 313
  if ((unsigned int )rec_mod == 2U) {
    _L___0: /* CIL Label */ 
    {
#line 313
    result = (*(sh->SetPilotID))(sh, drecord, id_);
    }
#line 313
    if (result < 0) {
#line 313
      return (result);
    }
  }
#line 315
  return (result);
}
}
#line 329 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
static int open_db(SyncHandler *sh , int *dbhandle ) 
{ 
  PI_ERR tmp ;
  PI_ERR tmp___0 ;

  {
#line 331
  if (sh->secret) {
    {
#line 332
    tmp = dlp_OpenDB(sh->sd, 0, 1, (char const   *)sh->name, dbhandle);
    }
#line 332
    return (tmp);
  } else {
    {
#line 335
    tmp___0 = dlp_OpenDB(sh->sd, 0, 192, (char const   *)sh->name, dbhandle);
    }
#line 335
    return (tmp___0);
  }
}
}
#line 350 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
static int close_db(SyncHandler *sh , int dbhandle ) 
{ 


  {
  {
#line 352
  dlp_CleanUpDatabase(sh->sd, dbhandle);
#line 354
  dlp_ResetSyncFlags(sh->sd, dbhandle);
#line 355
  dlp_CloseDB(sh->sd, dbhandle);
  }
#line 357
  return (0);
}
}
#line 371 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
static int sync_record(SyncHandler *sh , int dbhandle , DesktopRecord *drecord , PilotRecord *precord ,
                       RecordQueue *rq , RecordModifier rec_mod ) 
{ 
  int parch ;
  int pdel ;
  int pchange ;
  int darch ;
  int ddel ;
  int dchange ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int comp ;
  int comp___0 ;
  int comp___1 ;

  {
#line 376
  parch = 0;
#line 376
  pdel = 0;
#line 376
  pchange = 0;
#line 376
  darch = 0;
#line 376
  ddel = 0;
#line 376
  dchange = 0;
#line 376
  result = 0;
#line 386
  if (precord) {
#line 387
    parch = precord->flags & 8;
#line 388
    pdel = precord->flags & 128;
#line 389
    if (precord->flags & 64) {
#line 389
      if (! pdel) {
#line 389
        tmp = 1;
      } else {
#line 389
        tmp = 0;
      }
    } else {
#line 389
      tmp = 0;
    }
#line 389
    pchange = tmp;
  }
#line 392
  if (drecord) {
#line 393
    darch = drecord->flags & 8;
#line 394
    ddel = drecord->flags & 128;
#line 395
    if (drecord->flags & 64) {
#line 395
      if (! ddel) {
#line 395
        tmp___0 = 1;
      } else {
#line 395
        tmp___0 = 0;
      }
    } else {
#line 395
      tmp___0 = 0;
    }
#line 395
    dchange = tmp___0;
  }
#line 399
  if ((unsigned long )drecord == (unsigned long )((void *)0)) {
#line 399
    if (! parch) {
#line 399
      if (pdel) {
#line 400
        return (0);
      }
    }
  }
#line 403
  if ((unsigned long )precord != (unsigned long )((void *)0)) {
#line 403
    if (! parch) {
#line 403
      if (! pdel) {
#line 403
        if ((unsigned long )drecord == (unsigned long )((void *)0)) {
#line 404
          if ((unsigned int )rec_mod == 1U) {
#line 404
            goto _L;
          } else
#line 404
          if ((unsigned int )rec_mod == 2U) {
            _L: /* CIL Label */ 
            {
#line 404
            result = (*(sh->AddRecord))(sh, precord);
            }
#line 404
            if (result < 0) {
#line 404
              return (result);
            }
          }
        } else {
#line 403
          goto _L___61;
        }
      } else {
#line 403
        goto _L___61;
      }
    } else {
#line 403
      goto _L___61;
    }
  } else
  _L___61: /* CIL Label */ 
#line 406
  if ((unsigned long )precord == (unsigned long )((void *)0)) {
#line 406
    if ((unsigned long )drecord != (unsigned long )((void *)0)) {
      {
#line 407
      add_record_queue(rq, (PilotRecord *)((void *)0), drecord);
      }
    } else {
#line 406
      goto _L___58;
    }
  } else
  _L___58: /* CIL Label */ 
#line 409
  if (parch) {
#line 409
    if (ddel) {
#line 410
      if ((unsigned int )rec_mod == 1U) {
#line 410
        goto _L___0;
      } else
#line 410
      if ((unsigned int )rec_mod == 2U) {
        _L___0: /* CIL Label */ 
        {
#line 410
        result = (*(sh->ReplaceRecord))(sh, drecord, precord);
        }
#line 410
        if (result < 0) {
#line 410
          return (result);
        }
      }
#line 411
      if ((unsigned int )rec_mod == 1U) {
#line 411
        goto _L___1;
      } else
#line 411
      if ((unsigned int )rec_mod == 2U) {
        _L___1: /* CIL Label */ 
        {
#line 411
        result = (*(sh->ArchiveRecord))(sh, drecord, 1);
        }
#line 411
        if (result < 0) {
#line 411
          return (result);
        }
      }
#line 412
      if ((unsigned int )rec_mod == 1U) {
#line 412
        goto _L___2;
      } else
#line 412
      if ((unsigned int )rec_mod == 2U) {
        _L___2: /* CIL Label */ 
        {
#line 412
        result = (*(sh->SetStatusCleared))(sh, drecord);
        }
#line 412
        if (result < 0) {
#line 412
          return (result);
        }
      }
    } else {
#line 409
      goto _L___57;
    }
  } else
  _L___57: /* CIL Label */ 
#line 414
  if (parch) {
#line 414
    if (! darch) {
#line 414
      if (! dchange) {
#line 414
        if ((unsigned long )drecord != (unsigned long )((void *)0)) {
#line 415
          if ((unsigned int )rec_mod == 1U) {
#line 415
            goto _L___3;
          } else
#line 415
          if ((unsigned int )rec_mod == 2U) {
            _L___3: /* CIL Label */ 
            {
#line 415
            result = (*(sh->ArchiveRecord))(sh, drecord, 1);
            }
#line 415
            if (result < 0) {
#line 415
              return (result);
            }
          }
        } else {
#line 414
          goto _L___56;
        }
      } else {
#line 414
        goto _L___56;
      }
    } else {
#line 414
      goto _L___56;
    }
  } else
  _L___56: /* CIL Label */ 
#line 417
  if (parch) {
#line 417
    if ((unsigned long )drecord == (unsigned long )((void *)0)) {
#line 418
      if ((unsigned int )rec_mod == 1U) {
#line 418
        goto _L___4;
      } else
#line 418
      if ((unsigned int )rec_mod == 2U) {
        _L___4: /* CIL Label */ 
        {
#line 418
        result = (*(sh->AddRecord))(sh, precord);
        }
#line 418
        if (result < 0) {
#line 418
          return (result);
        }
      }
      {
#line 419
      result = (*(sh->Match))(sh, precord, & drecord);
      }
#line 419
      if (result < 0) {
#line 419
        return (result);
      }
#line 420
      if ((unsigned long )drecord == (unsigned long )((void *)0)) {
#line 421
        return (-1);
      }
#line 422
      if ((unsigned int )rec_mod == 1U) {
#line 422
        goto _L___5;
      } else
#line 422
      if ((unsigned int )rec_mod == 2U) {
        _L___5: /* CIL Label */ 
        {
#line 422
        result = (*(sh->ArchiveRecord))(sh, drecord, 1);
        }
#line 422
        if (result < 0) {
#line 422
          return (result);
        }
      }
      {
#line 423
      result = (*(sh->FreeMatch))(sh, drecord);
      }
#line 423
      if (result < 0) {
#line 423
        return (result);
      }
    } else {
#line 417
      goto _L___53;
    }
  } else
  _L___53: /* CIL Label */ 
#line 425
  if (parch) {
#line 425
    if (pchange) {
#line 425
      if (! darch) {
#line 425
        if (dchange) {
          {
#line 428
          comp = (*(sh->Compare))(sh, precord, drecord);
          }
#line 429
          if (comp == 0) {
#line 430
            if ((unsigned int )rec_mod == 1U) {
#line 430
              goto _L___6;
            } else
#line 430
            if ((unsigned int )rec_mod == 2U) {
              _L___6: /* CIL Label */ 
              {
#line 430
              result = (*(sh->ArchiveRecord))(sh, drecord, 1);
              }
#line 430
              if (result < 0) {
#line 430
                return (result);
              }
            }
#line 431
            if ((unsigned int )rec_mod == 0U) {
#line 431
              goto _L___7;
            } else
#line 431
            if ((unsigned int )rec_mod == 2U) {
              _L___7: /* CIL Label */ 
              {
#line 431
              result = dlp_DeleteRecord(sh->sd, dbhandle, 0, precord->recID);
              }
#line 431
              if (result < 0) {
#line 431
                return (result);
              }
            }
#line 433
            if ((unsigned int )rec_mod == 1U) {
#line 433
              goto _L___8;
            } else
#line 433
            if ((unsigned int )rec_mod == 2U) {
              _L___8: /* CIL Label */ 
              {
#line 433
              result = (*(sh->SetStatusCleared))(sh, drecord);
              }
#line 433
              if (result < 0) {
#line 433
                return (result);
              }
            }
          } else {
#line 435
            if ((unsigned int )rec_mod == 0U) {
#line 435
              goto _L___9;
            } else
#line 435
            if ((unsigned int )rec_mod == 2U) {
              _L___9: /* CIL Label */ 
              {
#line 435
              result = dlp_WriteRecord(sh->sd, dbhandle, 0, (recordid_t )0, precord->catID,
                                       (void const   *)precord->buffer, precord->len,
                                       & precord->recID);
              }
#line 435
              if (result < 0) {
#line 435
                return (result);
              }
            }
#line 440
            if ((unsigned int )rec_mod == 1U) {
#line 440
              goto _L___10;
            } else
#line 440
            if ((unsigned int )rec_mod == 2U) {
              _L___10: /* CIL Label */ 
              {
#line 440
              result = (*(sh->AddRecord))(sh, precord);
              }
#line 440
              if (result < 0) {
#line 440
                return (result);
              }
            }
            {
#line 441
            add_record_queue(rq, (PilotRecord *)((void *)0), drecord);
            }
#line 442
            if ((unsigned int )rec_mod == 1U) {
#line 442
              goto _L___11;
            } else
#line 442
            if ((unsigned int )rec_mod == 2U) {
              _L___11: /* CIL Label */ 
              {
#line 442
              result = (*(sh->SetStatusCleared))(sh, drecord);
              }
#line 442
              if (result < 0) {
#line 442
                return (result);
              }
            }
          }
        } else {
#line 425
          goto _L___52;
        }
      } else {
#line 425
        goto _L___52;
      }
    } else {
#line 425
      goto _L___52;
    }
  } else
  _L___52: /* CIL Label */ 
#line 445
  if (parch) {
#line 445
    if (! pchange) {
#line 445
      if (! darch) {
#line 445
        if (dchange) {
#line 446
          if ((unsigned int )rec_mod == 0U) {
#line 446
            goto _L___12;
          } else
#line 446
          if ((unsigned int )rec_mod == 2U) {
            _L___12: /* CIL Label */ 
            {
#line 446
            result = dlp_DeleteRecord(sh->sd, dbhandle, 0, precord->recID);
            }
#line 446
            if (result < 0) {
#line 446
              return (result);
            }
          }
          {
#line 448
          add_record_queue(rq, (PilotRecord *)((void *)0), drecord);
          }
#line 449
          if ((unsigned int )rec_mod == 1U) {
#line 449
            goto _L___13;
          } else
#line 449
          if ((unsigned int )rec_mod == 2U) {
            _L___13: /* CIL Label */ 
            {
#line 449
            result = (*(sh->SetStatusCleared))(sh, drecord);
            }
#line 449
            if (result < 0) {
#line 449
              return (result);
            }
          }
        } else {
#line 445
          goto _L___49;
        }
      } else {
#line 445
        goto _L___49;
      }
    } else {
#line 445
      goto _L___49;
    }
  } else
  _L___49: /* CIL Label */ 
#line 451
  if (pchange) {
#line 451
    if (darch) {
#line 451
      if (dchange) {
        {
#line 454
        comp___0 = (*(sh->Compare))(sh, precord, drecord);
        }
#line 455
        if (comp___0 == 0) {
#line 456
          if ((unsigned int )rec_mod == 0U) {
#line 456
            goto _L___14;
          } else
#line 456
          if ((unsigned int )rec_mod == 2U) {
            _L___14: /* CIL Label */ 
            {
#line 456
            result = dlp_DeleteRecord(sh->sd, dbhandle, 0, precord->recID);
            }
#line 456
            if (result < 0) {
#line 456
              return (result);
            }
          }
        } else {
#line 459
          if ((unsigned int )rec_mod == 1U) {
#line 459
            goto _L___15;
          } else
#line 459
          if ((unsigned int )rec_mod == 2U) {
            _L___15: /* CIL Label */ 
            {
#line 459
            result = (*(sh->ArchiveRecord))(sh, drecord, 0);
            }
#line 459
            if (result < 0) {
#line 459
              return (result);
            }
          }
#line 460
          if ((unsigned int )rec_mod == 1U) {
#line 460
            goto _L___16;
          } else
#line 460
          if ((unsigned int )rec_mod == 2U) {
            _L___16: /* CIL Label */ 
            {
#line 460
            result = (*(sh->ReplaceRecord))(sh, drecord, precord);
            }
#line 460
            if (result < 0) {
#line 460
              return (result);
            }
          }
        }
#line 463
        if ((unsigned int )rec_mod == 1U) {
#line 463
          goto _L___17;
        } else
#line 463
        if ((unsigned int )rec_mod == 2U) {
          _L___17: /* CIL Label */ 
          {
#line 463
          result = (*(sh->SetStatusCleared))(sh, drecord);
          }
#line 463
          if (result < 0) {
#line 463
            return (result);
          }
        }
      } else {
#line 451
        goto _L___46;
      }
    } else {
#line 451
      goto _L___46;
    }
  } else
  _L___46: /* CIL Label */ 
#line 465
  if (pchange) {
#line 465
    if (darch) {
#line 465
      if (! dchange) {
#line 466
        if ((unsigned int )rec_mod == 1U) {
#line 466
          goto _L___18;
        } else
#line 466
        if ((unsigned int )rec_mod == 2U) {
          _L___18: /* CIL Label */ 
          {
#line 466
          result = (*(sh->ArchiveRecord))(sh, drecord, 0);
          }
#line 466
          if (result < 0) {
#line 466
            return (result);
          }
        }
#line 467
        if ((unsigned int )rec_mod == 1U) {
#line 467
          goto _L___19;
        } else
#line 467
        if ((unsigned int )rec_mod == 2U) {
          _L___19: /* CIL Label */ 
          {
#line 467
          result = (*(sh->ReplaceRecord))(sh, drecord, precord);
          }
#line 467
          if (result < 0) {
#line 467
            return (result);
          }
        }
#line 468
        if ((unsigned int )rec_mod == 1U) {
#line 468
          goto _L___20;
        } else
#line 468
        if ((unsigned int )rec_mod == 2U) {
          _L___20: /* CIL Label */ 
          {
#line 468
          result = (*(sh->SetStatusCleared))(sh, drecord);
          }
#line 468
          if (result < 0) {
#line 468
            return (result);
          }
        }
      } else {
#line 465
        goto _L___44;
      }
    } else {
#line 465
      goto _L___44;
    }
  } else
  _L___44: /* CIL Label */ 
#line 470
  if (pchange) {
#line 470
    if (dchange) {
      {
#line 473
      comp___1 = (*(sh->Compare))(sh, precord, drecord);
      }
#line 474
      if (comp___1 != 0) {
#line 475
        if ((unsigned int )rec_mod == 1U) {
#line 475
          goto _L___21;
        } else
#line 475
        if ((unsigned int )rec_mod == 2U) {
          _L___21: /* CIL Label */ 
          {
#line 475
          result = (*(sh->AddRecord))(sh, precord);
          }
#line 475
          if (result < 0) {
#line 475
            return (result);
          }
        }
        {
#line 476
        drecord->recID = 0;
#line 477
        add_record_queue(rq, (PilotRecord *)((void *)0), drecord);
        }
      }
#line 479
      if ((unsigned int )rec_mod == 1U) {
#line 479
        goto _L___22;
      } else
#line 479
      if ((unsigned int )rec_mod == 2U) {
        _L___22: /* CIL Label */ 
        {
#line 479
        result = (*(sh->SetStatusCleared))(sh, drecord);
        }
#line 479
        if (result < 0) {
#line 479
          return (result);
        }
      }
    } else {
#line 470
      goto _L___42;
    }
  } else
  _L___42: /* CIL Label */ 
#line 481
  if (pchange) {
#line 481
    if (ddel) {
#line 482
      if ((unsigned int )rec_mod == 1U) {
#line 482
        goto _L___23;
      } else
#line 482
      if ((unsigned int )rec_mod == 2U) {
        _L___23: /* CIL Label */ 
        {
#line 482
        result = (*(sh->ReplaceRecord))(sh, drecord, precord);
        }
#line 482
        if (result < 0) {
#line 482
          return (result);
        }
      }
#line 483
      if ((unsigned int )rec_mod == 1U) {
#line 483
        goto _L___24;
      } else
#line 483
      if ((unsigned int )rec_mod == 2U) {
        _L___24: /* CIL Label */ 
        {
#line 483
        result = (*(sh->SetStatusCleared))(sh, drecord);
        }
#line 483
        if (result < 0) {
#line 483
          return (result);
        }
      }
    } else {
#line 481
      goto _L___41;
    }
  } else
  _L___41: /* CIL Label */ 
#line 485
  if (pchange) {
#line 485
    if (! dchange) {
#line 486
      if ((unsigned int )rec_mod == 1U) {
#line 486
        goto _L___25;
      } else
#line 486
      if ((unsigned int )rec_mod == 2U) {
        _L___25: /* CIL Label */ 
        {
#line 486
        result = (*(sh->ReplaceRecord))(sh, drecord, precord);
        }
#line 486
        if (result < 0) {
#line 486
          return (result);
        }
      }
#line 487
      if ((unsigned int )rec_mod == 1U) {
#line 487
        goto _L___26;
      } else
#line 487
      if ((unsigned int )rec_mod == 2U) {
        _L___26: /* CIL Label */ 
        {
#line 487
        result = (*(sh->SetStatusCleared))(sh, drecord);
        }
#line 487
        if (result < 0) {
#line 487
          return (result);
        }
      }
    } else {
#line 485
      goto _L___40;
    }
  } else
  _L___40: /* CIL Label */ 
#line 489
  if (pdel) {
#line 489
    if (dchange) {
      {
#line 490
      add_record_queue(rq, (PilotRecord *)((void *)0), drecord);
      }
#line 491
      if ((unsigned int )rec_mod == 1U) {
#line 491
        goto _L___27;
      } else
#line 491
      if ((unsigned int )rec_mod == 2U) {
        _L___27: /* CIL Label */ 
        {
#line 491
        result = (*(sh->SetStatusCleared))(sh, drecord);
        }
#line 491
        if (result < 0) {
#line 491
          return (result);
        }
      }
    } else {
#line 489
      goto _L___39;
    }
  } else
  _L___39: /* CIL Label */ 
#line 493
  if (pdel) {
#line 493
    if (! dchange) {
#line 494
      if ((unsigned int )rec_mod == 1U) {
#line 494
        goto _L___28;
      } else
#line 494
      if ((unsigned int )rec_mod == 2U) {
        _L___28: /* CIL Label */ 
        {
#line 494
        result = delete_both(sh, dbhandle, drecord, precord, rec_mod);
        }
#line 494
        if (result < 0) {
#line 494
          return (result);
        }
      }
#line 496
      if ((unsigned int )rec_mod == 1U) {
#line 496
        goto _L___29;
      } else
#line 496
      if ((unsigned int )rec_mod == 2U) {
        _L___29: /* CIL Label */ 
        {
#line 496
        result = (*(sh->SetStatusCleared))(sh, drecord);
        }
#line 496
        if (result < 0) {
#line 496
          return (result);
        }
      }
    } else {
#line 493
      goto _L___38;
    }
  } else
  _L___38: /* CIL Label */ 
#line 498
  if (! pchange) {
#line 498
    if (darch) {
#line 499
      if ((unsigned int )rec_mod == 0U) {
#line 499
        goto _L___30;
      } else
#line 499
      if ((unsigned int )rec_mod == 2U) {
        _L___30: /* CIL Label */ 
        {
#line 499
        result = dlp_DeleteRecord(sh->sd, dbhandle, 0, precord->recID);
        }
#line 499
        if (result < 0) {
#line 499
          return (result);
        }
      }
#line 501
      if ((unsigned int )rec_mod == 1U) {
#line 501
        goto _L___31;
      } else
#line 501
      if ((unsigned int )rec_mod == 2U) {
        _L___31: /* CIL Label */ 
        {
#line 501
        result = (*(sh->SetStatusCleared))(sh, drecord);
        }
#line 501
        if (result < 0) {
#line 501
          return (result);
        }
      }
    } else {
#line 498
      goto _L___37;
    }
  } else
  _L___37: /* CIL Label */ 
#line 503
  if (! pchange) {
#line 503
    if (dchange) {
#line 504
      if ((unsigned int )rec_mod == 0U) {
#line 504
        goto _L___32;
      } else
#line 504
      if ((unsigned int )rec_mod == 2U) {
        _L___32: /* CIL Label */ 
        {
#line 504
        result = dlp_DeleteRecord(sh->sd, dbhandle, 0, precord->recID);
        }
#line 504
        if (result < 0) {
#line 504
          return (result);
        }
      }
      {
#line 506
      add_record_queue(rq, (PilotRecord *)((void *)0), drecord);
      }
#line 507
      if ((unsigned int )rec_mod == 1U) {
#line 507
        goto _L___33;
      } else
#line 507
      if ((unsigned int )rec_mod == 2U) {
        _L___33: /* CIL Label */ 
        {
#line 507
        result = (*(sh->SetStatusCleared))(sh, drecord);
        }
#line 507
        if (result < 0) {
#line 507
          return (result);
        }
      }
    } else {
#line 503
      goto _L___36;
    }
  } else
  _L___36: /* CIL Label */ 
#line 509
  if (! pchange) {
#line 509
    if (ddel) {
#line 510
      if ((unsigned int )rec_mod == 1U) {
#line 510
        goto _L___34;
      } else
#line 510
      if ((unsigned int )rec_mod == 2U) {
        _L___34: /* CIL Label */ 
        {
#line 510
        result = delete_both(sh, dbhandle, drecord, precord, rec_mod);
        }
#line 510
        if (result < 0) {
#line 510
          return (result);
        }
      }
#line 512
      if ((unsigned int )rec_mod == 1U) {
#line 512
        goto _L___35;
      } else
#line 512
      if ((unsigned int )rec_mod == 2U) {
        _L___35: /* CIL Label */ 
        {
#line 512
        result = (*(sh->SetStatusCleared))(sh, drecord);
        }
#line 512
        if (result < 0) {
#line 512
          return (result);
        }
      }
    }
  }
#line 516
  return (result);
}
}
#line 530 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
int sync_CopyToPilot(SyncHandler *sh ) 
{ 
  int dbhandle ;
  int slow ;
  int result ;
  DesktopRecord *drecord ;
  int tmp ;

  {
  {
#line 532
  slow = 0;
#line 532
  result = 0;
#line 535
  drecord = (DesktopRecord *)((void *)0);
#line 537
  result = open_db(sh, & dbhandle);
  }
#line 538
  if (result < 0) {
#line 539
    goto cleanup;
  }
  {
#line 541
  result = (*(sh->Pre))(sh, dbhandle, & slow);
  }
#line 542
  if (result < 0) {
#line 543
    goto cleanup;
  }
  {
#line 545
  result = dlp_DeleteRecord(sh->sd, dbhandle, 1, (recordid_t )0);
  }
#line 546
  if (result < 0) {
#line 547
    goto cleanup;
  }
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 550
    tmp = (*(sh->ForEach))(sh, & drecord);
    }
#line 550
    if (tmp == 0) {
#line 550
      if (! drecord) {
#line 550
        goto while_break;
      }
    } else {
#line 550
      goto while_break;
    }
    {
#line 551
    result = store_record_on_pilot(sh, dbhandle, drecord, (RecordModifier )2);
    }
#line 553
    if (result < 0) {
#line 554
      goto cleanup;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 557
  result = (*(sh->Post))(sh, dbhandle);
  }
  cleanup: 
  {
#line 560
  close_db(sh, dbhandle);
  }
#line 562
  return (result);
}
}
#line 576 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
int sync_CopyFromPilot(SyncHandler *sh ) 
{ 
  int dbhandle ;
  int i ;
  int slow ;
  int result ;
  pi_buffer_t *recbuf ;
  DesktopRecord *drecord ;
  PilotRecord *precord ;
  PilotRecord *tmp ;
  int tmp___0 ;
  PI_ERR tmp___1 ;

  {
  {
#line 578
  slow = 0;
#line 578
  result = 0;
#line 584
  drecord = (DesktopRecord *)((void *)0);
#line 585
  tmp = sync_NewPilotRecord(65535);
#line 585
  precord = tmp;
#line 587
  result = open_db(sh, & dbhandle);
  }
#line 588
  if (result < 0) {
#line 589
    goto cleanup;
  }
  {
#line 591
  result = (*(sh->Pre))(sh, dbhandle, & slow);
  }
#line 592
  if (result < 0) {
#line 593
    goto cleanup;
  }
  {
#line 595
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 595
    tmp___0 = (*(sh->ForEach))(sh, & drecord);
    }
#line 595
    if (tmp___0 == 0) {
#line 595
      if (! drecord) {
#line 595
        goto while_break;
      }
    } else {
#line 595
      goto while_break;
    }
    {
#line 596
    result = (*(sh->DeleteRecord))(sh, drecord);
    }
#line 597
    if (result < 0) {
#line 598
      goto cleanup;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 601
  i = 0;
#line 602
  recbuf = pi_buffer_new((size_t )65535);
  }
  {
#line 603
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 603
    tmp___1 = dlp_ReadRecordByIndex(sh->sd, dbhandle, i, recbuf, & precord->recID,
                                    & precord->flags, & precord->catID);
    }
#line 603
    if (! (tmp___1 > 0)) {
#line 603
      goto while_break___0;
    }
#line 605
    precord->len = recbuf->used;
#line 606
    if (precord->len > 65535UL) {
#line 607
      precord->len = (size_t )65535;
    }
    {
#line 608
    memcpy((void */* __restrict  */)precord->buffer, (void const   */* __restrict  */)recbuf->data,
           precord->len);
#line 609
    result = (*(sh->AddRecord))(sh, precord);
    }
#line 610
    if (result < 0) {
      {
#line 611
      pi_buffer_free(recbuf);
      }
#line 612
      goto cleanup;
    }
#line 615
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 617
  pi_buffer_free(recbuf);
#line 619
  result = (*(sh->Post))(sh, dbhandle);
  }
  cleanup: 
  {
#line 622
  close_db(sh, dbhandle);
#line 623
  sync_FreePilotRecord(precord);
  }
#line 624
  return (result);
}
}
#line 638 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
static int sync_MergeFromPilot_process(SyncHandler *sh , int dbhandle , RecordQueue *rq ,
                                       RecordModifier rec_mod ) 
{ 
  int result ;
  RecordQueueList *item ;

  {
#line 642
  result = 0;
#line 645
  item = rq->rql;
  {
#line 645
  while (1) {
    while_continue: /* CIL Label */ ;
#line 645
    if (! ((unsigned long )item != (unsigned long )((void *)0))) {
#line 645
      goto while_break;
    }
#line 646
    if ((unsigned long )item->drecord != (unsigned long )((void *)0)) {
      {
#line 647
      store_record_on_pilot(sh, dbhandle, item->drecord, rec_mod);
      }
    } else
#line 650
    if ((unsigned int )rec_mod == 0U) {
#line 650
      goto _L;
    } else
#line 650
    if ((unsigned int )rec_mod == 2U) {
      _L: /* CIL Label */ 
      {
#line 650
      result = dlp_WriteRecord(sh->sd, dbhandle, 0, (recordid_t )0, (item->precord)->catID,
                               (void const   *)(item->precord)->buffer, (item->precord)->len,
                               & (item->precord)->recID);
      }
#line 650
      if (result < 0) {
#line 650
        return (result);
      }
    }
#line 645
    item = item->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 657
  free_record_queue_list(sh, rq->rql);
  }
#line 659
  return (result);
}
}
#line 673 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
static int sync_MergeFromPilot_fast(SyncHandler *sh , int dbhandle , RecordModifier rec_mod ) 
{ 
  int result ;
  PilotRecord *precord ;
  PilotRecord *tmp ;
  DesktopRecord *drecord ;
  RecordQueue rq ;
  pi_buffer_t *recbuf ;
  pi_buffer_t *tmp___0 ;
  int count ;
  PI_ERR tmp___1 ;

  {
  {
#line 677
  result = 0;
#line 678
  tmp = sync_NewPilotRecord(65535);
#line 678
  precord = tmp;
#line 679
  drecord = (DesktopRecord *)((void *)0);
#line 680
  rq.count = 0;
#line 680
  rq.rql = (RecordQueueList *)((void *)0);
#line 681
  tmp___0 = pi_buffer_new((size_t )65535);
#line 681
  recbuf = tmp___0;
  }
  {
#line 683
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 683
    tmp___1 = dlp_ReadNextModifiedRec(sh->sd, dbhandle, recbuf, & precord->recID,
                                      (int *)((void *)0), & precord->flags, & precord->catID);
    }
#line 683
    if (! (tmp___1 >= 0)) {
#line 683
      goto while_break;
    }
#line 687
    count = rq.count;
#line 688
    precord->len = recbuf->used;
#line 689
    if (precord->len > 65535UL) {
#line 690
      precord->len = (size_t )65535;
    }
    {
#line 691
    memcpy((void */* __restrict  */)precord->buffer, (void const   */* __restrict  */)recbuf->data,
           precord->len);
#line 692
    result = (*(sh->Match))(sh, precord, & drecord);
    }
#line 692
    if (result < 0) {
#line 692
      return (result);
    }
    {
#line 693
    result = sync_record(sh, dbhandle, drecord, precord, & rq, rec_mod);
    }
#line 693
    if (result < 0) {
#line 693
      return (result);
    }
#line 696
    if (drecord) {
#line 696
      if (rq.count == count) {
        {
#line 697
        result = (*(sh->FreeMatch))(sh, drecord);
        }
#line 697
        if (result < 0) {
#line 697
          return (result);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 699
  pi_buffer_free(recbuf);
#line 700
  sync_FreePilotRecord(precord);
#line 702
  result = sync_MergeFromPilot_process(sh, dbhandle, & rq, rec_mod);
  }
#line 704
  return (result);
}
}
#line 718 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
static int sync_MergeFromPilot_slow(SyncHandler *sh , int dbhandle , RecordModifier rec_mod ) 
{ 
  int i ;
  int parch ;
  int psecret ;
  int result ;
  pi_buffer_t *recbuf ;
  PilotRecord *precord ;
  PilotRecord *tmp ;
  DesktopRecord *drecord ;
  RecordQueue rq ;
  int count ;
  int comp ;
  PI_ERR tmp___0 ;

  {
  {
#line 722
  result = 0;
#line 728
  tmp = sync_NewPilotRecord(65535);
#line 728
  precord = tmp;
#line 729
  drecord = (DesktopRecord *)((void *)0);
#line 730
  rq.count = 0;
#line 730
  rq.rql = (RecordQueueList *)((void *)0);
#line 732
  i = 0;
#line 733
  recbuf = pi_buffer_new((size_t )65535);
  }
  {
#line 734
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 734
    tmp___0 = dlp_ReadRecordByIndex(sh->sd, dbhandle, i, recbuf, & precord->recID,
                                    & precord->flags, & precord->catID);
    }
#line 734
    if (! (tmp___0 > 0)) {
#line 734
      goto while_break;
    }
#line 737
    count = rq.count;
#line 739
    precord->len = recbuf->used;
#line 740
    if (precord->len > 65535UL) {
#line 741
      precord->len = (size_t )65535;
    }
    {
#line 742
    memcpy((void */* __restrict  */)precord->buffer, (void const   */* __restrict  */)recbuf->data,
           precord->len);
#line 744
    result = (*(sh->Match))(sh, precord, & drecord);
    }
#line 744
    if (result < 0) {
#line 744
      return (result);
    }
#line 747
    parch = precord->flags & 8;
#line 748
    psecret = precord->flags & 16;
#line 750
    precord->flags = 0;
#line 751
    if ((unsigned long )drecord == (unsigned long )((void *)0)) {
#line 752
      precord->flags |= 64;
    } else {
      {
#line 756
      comp = (*(sh->Compare))(sh, precord, drecord);
      }
#line 757
      if (comp != 0) {
#line 758
        precord->flags |= 64;
      }
    }
#line 762
    if (parch) {
#line 763
      precord->flags |= 8;
    }
#line 765
    if (psecret) {
#line 766
      precord->flags |= 16;
    }
    {
#line 768
    result = sync_record(sh, dbhandle, drecord, precord, & rq, rec_mod);
    }
#line 768
    if (result < 0) {
#line 768
      return (result);
    }
#line 771
    if (drecord) {
#line 771
      if (rq.count == count) {
        {
#line 772
        result = (*(sh->FreeMatch))(sh, drecord);
        }
#line 772
        if (result < 0) {
#line 772
          return (result);
        }
      }
    }
#line 774
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 776
  pi_buffer_free(recbuf);
#line 778
  sync_FreePilotRecord(precord);
#line 780
  result = sync_MergeFromPilot_process(sh, dbhandle, & rq, rec_mod);
  }
#line 782
  return (result);
}
}
#line 797 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
int sync_MergeFromPilot(SyncHandler *sh ) 
{ 
  int dbhandle ;
  int slow ;
  int result ;

  {
  {
#line 799
  slow = 0;
#line 799
  result = 0;
#line 803
  result = open_db(sh, & dbhandle);
  }
#line 804
  if (result < 0) {
#line 805
    goto cleanup;
  }
  {
#line 807
  result = (*(sh->Pre))(sh, dbhandle, & slow);
  }
#line 808
  if (result < 0) {
#line 809
    goto cleanup;
  }
#line 811
  if (! slow) {
    {
#line 812
    result = sync_MergeFromPilot_fast(sh, dbhandle, (RecordModifier )1);
    }
#line 813
    if (result < 0) {
#line 814
      goto cleanup;
    }
  } else {
    {
#line 816
    result = sync_MergeFromPilot_slow(sh, dbhandle, (RecordModifier )1);
    }
#line 817
    if (result < 0) {
#line 818
      goto cleanup;
    }
  }
  {
#line 821
  result = (*(sh->Post))(sh, dbhandle);
  }
  cleanup: 
  {
#line 824
  close_db(sh, dbhandle);
  }
#line 826
  return (result);
}
}
#line 840 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
static int sync_MergeToPilot_fast(SyncHandler *sh , int dbhandle , RecordModifier rec_mod ) 
{ 
  int result ;
  PilotRecord *precord ;
  DesktopRecord *drecord ;
  RecordQueue rq ;
  pi_buffer_t *recbuf ;
  pi_buffer_t *tmp ;
  int tmp___0 ;

  {
  {
#line 844
  result = 0;
#line 845
  precord = (PilotRecord *)((void *)0);
#line 846
  drecord = (DesktopRecord *)((void *)0);
#line 847
  rq.count = 0;
#line 847
  rq.rql = (RecordQueueList *)((void *)0);
#line 848
  tmp = pi_buffer_new((size_t )65535);
#line 848
  recbuf = tmp;
  }
  {
#line 850
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 850
    tmp___0 = (*(sh->ForEachModified))(sh, & drecord);
    }
#line 850
    if (tmp___0 == 0) {
#line 850
      if (! drecord) {
#line 850
        goto while_break;
      }
    } else {
#line 850
      goto while_break;
    }
#line 851
    if (drecord->recID != 0) {
      {
#line 852
      precord = sync_NewPilotRecord(65535);
#line 853
      precord->recID = (recordid_t )drecord->recID;
      }
#line 854
      if ((unsigned int )rec_mod == 0U) {
#line 854
        goto _L;
      } else
#line 854
      if ((unsigned int )rec_mod == 2U) {
        _L: /* CIL Label */ 
        {
#line 854
        result = dlp_ReadRecordById(sh->sd, dbhandle, precord->recID, recbuf, (int *)((void *)0),
                                    & precord->flags, & precord->catID);
        }
#line 854
        if (result < 0) {
#line 854
          return (result);
        }
      }
#line 860
      precord->len = recbuf->used;
#line 861
      if (precord->len > 65535UL) {
#line 862
        precord->len = (size_t )65535;
      }
      {
#line 863
      memcpy((void */* __restrict  */)precord->buffer, (void const   */* __restrict  */)recbuf->data,
             precord->len);
      }
    }
    {
#line 866
    result = sync_record(sh, dbhandle, drecord, precord, & rq, rec_mod);
    }
#line 866
    if (result < 0) {
#line 866
      return (result);
    }
#line 869
    if (precord) {
      {
#line 870
      sync_FreePilotRecord(precord);
      }
    }
#line 871
    precord = (PilotRecord *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 873
  pi_buffer_free(recbuf);
#line 875
  result = sync_MergeFromPilot_process(sh, dbhandle, & rq, rec_mod);
  }
#line 877
  return (result);
}
}
#line 891 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
static int sync_MergeToPilot_slow(SyncHandler *sh , int dbhandle , RecordModifier rec_mod ) 
{ 
  int darch ;
  int dsecret ;
  int result ;
  PilotRecord *precord ;
  DesktopRecord *drecord ;
  RecordQueue rq ;
  pi_buffer_t *recbuf ;
  pi_buffer_t *tmp ;
  int comp ;
  int tmp___0 ;

  {
  {
#line 895
  result = 0;
#line 898
  precord = (PilotRecord *)((void *)0);
#line 899
  drecord = (DesktopRecord *)((void *)0);
#line 900
  rq.count = 0;
#line 900
  rq.rql = (RecordQueueList *)((void *)0);
#line 901
  tmp = pi_buffer_new((size_t )65535);
#line 901
  recbuf = tmp;
  }
  {
#line 903
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 903
    tmp___0 = (*(sh->ForEach))(sh, & drecord);
    }
#line 903
    if (tmp___0 == 0) {
#line 903
      if (! drecord) {
#line 903
        goto while_break;
      }
    } else {
#line 903
      goto while_break;
    }
#line 904
    if (drecord->recID != 0) {
      {
#line 905
      precord = sync_NewPilotRecord(65535);
#line 906
      precord->recID = (recordid_t )drecord->recID;
      }
#line 907
      if ((unsigned int )rec_mod == 0U) {
#line 907
        goto _L;
      } else
#line 907
      if ((unsigned int )rec_mod == 2U) {
        _L: /* CIL Label */ 
        {
#line 907
        result = dlp_ReadRecordById(sh->sd, dbhandle, precord->recID, recbuf, (int *)((void *)0),
                                    & precord->flags, & precord->catID);
        }
#line 907
        if (result < 0) {
#line 907
          return (result);
        }
      }
#line 913
      precord->len = recbuf->used;
#line 914
      if (precord->len > 65535UL) {
#line 915
        precord->len = (size_t )65535;
      }
      {
#line 916
      memcpy((void */* __restrict  */)precord->buffer, (void const   */* __restrict  */)recbuf->data,
             precord->len);
      }
    }
#line 920
    darch = drecord->flags & 8;
#line 921
    dsecret = drecord->flags & 16;
#line 923
    drecord->flags = 0;
#line 924
    if ((unsigned long )precord == (unsigned long )((void *)0)) {
#line 925
      drecord->flags |= 64;
    } else {
      {
#line 929
      comp = (*(sh->Compare))(sh, precord, drecord);
      }
#line 930
      if (comp != 0) {
#line 931
        drecord->flags |= 64;
      }
    }
#line 935
    if (darch) {
#line 936
      drecord->flags |= 8;
    }
#line 938
    if (dsecret) {
#line 939
      drecord->flags |= 16;
    }
    {
#line 941
    result = sync_record(sh, dbhandle, drecord, precord, & rq, rec_mod);
    }
#line 941
    if (result < 0) {
#line 941
      return (result);
    }
#line 944
    if (precord) {
      {
#line 945
      sync_FreePilotRecord(precord);
      }
    }
#line 946
    precord = (PilotRecord *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 948
  pi_buffer_free(recbuf);
#line 950
  result = sync_MergeFromPilot_process(sh, dbhandle, & rq, rec_mod);
  }
#line 952
  return (result);
}
}
#line 967 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
int sync_MergeToPilot(SyncHandler *sh ) 
{ 
  int dbhandle ;
  int slow ;
  int result ;

  {
  {
#line 969
  slow = 0;
#line 969
  result = 0;
#line 973
  result = open_db(sh, & dbhandle);
  }
#line 974
  if (result < 0) {
#line 975
    goto cleanup;
  }
  {
#line 977
  result = (*(sh->Pre))(sh, dbhandle, & slow);
  }
#line 978
  if (result < 0) {
#line 979
    goto cleanup;
  }
#line 981
  if (! slow) {
    {
#line 982
    sync_MergeToPilot_fast(sh, dbhandle, (RecordModifier )0);
    }
#line 983
    if (result < 0) {
#line 984
      goto cleanup;
    }
  } else {
    {
#line 986
    sync_MergeToPilot_slow(sh, dbhandle, (RecordModifier )0);
    }
#line 987
    if (result < 0) {
#line 988
      goto cleanup;
    }
  }
  {
#line 991
  result = (*(sh->Post))(sh, dbhandle);
  }
  cleanup: 
  {
#line 994
  close_db(sh, dbhandle);
  }
#line 996
  return (result);
}
}
#line 1010 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisync/sync.c"
int sync_Synchronize(SyncHandler *sh ) 
{ 
  int dbhandle ;
  int slow ;
  int result ;

  {
  {
#line 1012
  slow = 0;
#line 1012
  result = 0;
#line 1016
  result = open_db(sh, & dbhandle);
  }
#line 1017
  if (result < 0) {
#line 1018
    goto cleanup;
  }
  {
#line 1020
  result = (*(sh->Pre))(sh, dbhandle, & slow);
  }
#line 1021
  if (result != 0) {
#line 1022
    goto cleanup;
  }
#line 1024
  if (! slow) {
    {
#line 1025
    result = sync_MergeFromPilot_fast(sh, dbhandle, (RecordModifier )2);
    }
#line 1026
    if (result < 0) {
#line 1027
      goto cleanup;
    }
    {
#line 1029
    result = sync_MergeToPilot_fast(sh, dbhandle, (RecordModifier )2);
    }
#line 1030
    if (result < 0) {
#line 1031
      goto cleanup;
    }
  } else {
    {
#line 1033
    result = sync_MergeFromPilot_slow(sh, dbhandle, (RecordModifier )2);
    }
#line 1034
    if (result < 0) {
#line 1035
      goto cleanup;
    }
    {
#line 1037
    result = sync_MergeToPilot_slow(sh, dbhandle, (RecordModifier )2);
    }
#line 1038
    if (result < 0) {
#line 1039
      goto cleanup;
    }
  }
  {
#line 1042
  result = (*(sh->Post))(sh, dbhandle);
  }
  cleanup: 
  {
#line 1045
  close_db(sh, dbhandle);
  }
#line 1047
  return (result);
}
}
#line 63 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
static void record_dump___0(unsigned long recID , unsigned int recIndex , int flags ,
                            int catID , char const   *data , int data_len ) ;
#line 141 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
static int dlp_version_major___0  =    1;
#line 142 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
static int dlp_version_minor___0  =    4;
#line 160 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
static void record_dump___0(unsigned long recID , unsigned int recIndex , int flags ,
                            int catID , char const   *data , int data_len ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 163
  if (! flags) {
#line 163
    tmp = " None";
  } else {
#line 163
    tmp = "";
  }
#line 163
  if (flags & 8) {
#line 163
    tmp___0 = " Archive";
  } else {
#line 163
    tmp___0 = "";
  }
#line 163
  if (flags & 16) {
#line 163
    tmp___1 = " Secret";
  } else {
#line 163
    tmp___1 = "";
  }
#line 163
  if (flags & 32) {
#line 163
    tmp___2 = " Busy";
  } else {
#line 163
    tmp___2 = "";
  }
#line 163
  if (flags & 64) {
#line 163
    tmp___3 = " Dirty";
  } else {
#line 163
    tmp___3 = "";
  }
#line 163
  if (flags & 128) {
#line 163
    tmp___4 = " Deleted";
  } else {
#line 163
    tmp___4 = "";
  }
  {
#line 163
  pi_log(16, 4, "  ID: 0x%8.8lX, Index: %u, Category: %d\n  Flags:%s%s%s%s%s%s (0x%2.2X), and %d bytes:\n",
         recID, recIndex, catID, tmp___4, tmp___3, tmp___2, tmp___1, tmp___0, tmp,
         flags, data_len);
#line 176
  pi_dumpdata(data, (size_t )data_len);
  }
#line 177
  return;
}
}
#line 1207 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
static void dlp_decode_finddb_response___0(struct dlpResponse *res , int *cardno ,
                                           unsigned long *localid , int *dbhandle ,
                                           struct DBInfo *info , struct DBSizeInfo *size ) 
{ 
  int arg ;
  int argid ;
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
#line 1212
  arg = 0;
  {
#line 1212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1212
    if (! (arg < res->argc)) {
#line 1212
      goto while_break;
    }
#line 1213
    argid = ((*(res->argv + arg))->id_ & 127) - 32;
#line 1214
    if (argid == 0) {
#line 1215
      if (cardno) {
#line 1216
        *cardno = (int )*((unsigned char *)((*(res->argv + arg))->data + 0) + 0);
      }
#line 1217
      if (localid) {
#line 1218
        *localid = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 2) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 2) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 2) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 2) + 3);
      }
#line 1219
      if (dbhandle) {
#line 1220
        *dbhandle = (int )(((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 6) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 6) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 6) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 6) + 3));
      }
#line 1222
      if (info) {
        {
#line 1223
        info->more = 0;
#line 1224
        info->miscFlags = (unsigned int )*((unsigned char *)((*(res->argv + arg))->data + 11) + 0);
#line 1226
        info->flags = (unsigned int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + arg))->data + 12) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + arg))->data + 12) + 1)));
#line 1228
        info->type = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 14) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 14) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 14) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 14) + 3);
#line 1230
        info->creator = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 18) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 18) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 18) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 18) + 3);
#line 1232
        info->version = (unsigned int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + arg))->data + 22) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + arg))->data + 22) + 1)));
#line 1234
        info->modnum = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 24) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 24) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 24) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 24) + 3);
#line 1236
        info->createDate = dlp_ptohdate((unsigned char const   *)((*(res->argv + arg))->data + 28));
#line 1238
        info->modifyDate = dlp_ptohdate((unsigned char const   *)((*(res->argv + arg))->data + 36));
#line 1240
        info->backupDate = dlp_ptohdate((unsigned char const   *)((*(res->argv + arg))->data + 44));
#line 1242
        info->index = (unsigned int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + arg))->data + 52) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + arg))->data + 52) + 1)));
#line 1245
        strncpy((char */* __restrict  */)(info->name), (char const   */* __restrict  */)((*(res->argv + arg))->data + 54),
                (size_t )32);
#line 1246
        info->name[32] = (char )'\000';
        }
#line 1248
        if (info->more) {
#line 1248
          tmp = "Yes";
        } else {
#line 1248
          tmp = "No";
        }
        {
#line 1248
        pi_log(16, 4, "DLP FindDB Name: \'%s\', Version: %d, More: %s\n", info->name,
               info->version, tmp);
#line 1253
        tmp___0 = printlong(info->creator);
#line 1253
        pi_log(16, 4, "  Creator: \'%s\'", tmp___0);
        }
#line 1255
        if (! info->flags) {
#line 1255
          tmp___1 = "None";
        } else {
#line 1255
          tmp___1 = "";
        }
#line 1255
        if (info->flags & 32768U) {
#line 1255
          tmp___2 = "Open ";
        } else {
#line 1255
          tmp___2 = "";
        }
#line 1255
        if (info->flags & 128U) {
#line 1255
          tmp___3 = "Stream ";
        } else {
#line 1255
          tmp___3 = "";
        }
#line 1255
        if (info->flags & 64U) {
#line 1255
          tmp___4 = "CopyPrevention ";
        } else {
#line 1255
          tmp___4 = "";
        }
#line 1255
        if (info->flags & 16U) {
#line 1255
          tmp___5 = "Newer ";
        } else {
#line 1255
          tmp___5 = "";
        }
#line 1255
        if (info->flags & 32U) {
#line 1255
          tmp___6 = "Reset ";
        } else {
#line 1255
          tmp___6 = "";
        }
#line 1255
        if (info->flags & 8U) {
#line 1255
          tmp___7 = "Backup ";
        } else {
#line 1255
          tmp___7 = "";
        }
#line 1255
        if (info->flags & 4U) {
#line 1255
          tmp___8 = "AppInfoDirty ";
        } else {
#line 1255
          tmp___8 = "";
        }
#line 1255
        if (info->flags & 2U) {
#line 1255
          tmp___9 = "ReadOnly ";
        } else {
#line 1255
          tmp___9 = "";
        }
#line 1255
        if (info->flags & 1U) {
#line 1255
          tmp___10 = "Resource ";
        } else {
#line 1255
          tmp___10 = "";
        }
        {
#line 1255
        tmp___11 = printlong(info->type);
#line 1255
        pi_log(16, 4, " Type: \'%s\' Flags: %s%s%s%s%s%s%s%s%s%s", tmp___11, tmp___10,
               tmp___9, tmp___8, tmp___7, tmp___6, tmp___5, tmp___4, tmp___3, tmp___2,
               tmp___1);
#line 1277
        pi_log(16, 4, " (0x%2.2X)\n", info->flags);
#line 1279
        tmp___12 = ctime((time_t const   *)(& info->createDate));
#line 1279
        pi_log(16, 4, "  Modnum: %ld, Index: %d, Creation date: %s", info->modnum,
               info->index, tmp___12);
#line 1284
        tmp___13 = ctime((time_t const   *)(& info->modifyDate));
#line 1284
        pi_log(16, 4, " Modification date: %s", tmp___13);
#line 1287
        tmp___14 = ctime((time_t const   *)(& info->backupDate));
#line 1287
        pi_log(16, 4, " Backup date: %s", tmp___14);
        }
      }
    } else
#line 1292
    if (argid == 1) {
#line 1293
      if (size) {
#line 1294
        size->numRecords = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 0) + 3);
#line 1296
        size->totalBytes = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 4) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 4) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 4) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 4) + 3);
#line 1298
        size->dataBytes = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 8) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 8) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 8) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 8) + 3);
#line 1300
        size->appBlockSize = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 12) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 12) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 12) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 12) + 3);
#line 1302
        size->sortBlockSize = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 16) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 16) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 16) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 16) + 3);
#line 1304
        size->maxRecSize = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 20) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 20) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 20) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 20) + 3);
      }
    }
#line 1212
    arg ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1309
  return;
}
}
#line 99 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
static int pi_file_close_for_write___0(pi_file_t *pf ) ;
#line 100
static void pi_file_free___0(pi_file_t *pf ) ;
#line 101
static int pi_file_find_resource_by_type_id___0(pi_file_t const   *pf , unsigned long restype ,
                                                int resid , int *resindex ) ;
#line 102
static pi_file_entry_t *pi_file_append_entry___0(pi_file_t *pf ) ;
#line 103
static int pi_file_set_rbuf_size___0(pi_file_t *pf , size_t size ) ;
#line 1270 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
static int pi_file_close_for_write___0(pi_file_t *pf ) 
{ 
  int i ;
  int offset ;
  FILE *f ;
  struct DBInfo *ip ;
  struct pi_file_entry *entp ;
  struct stat sbuf ;
  unsigned char buf___3[512] ;
  unsigned char *p ;
  int tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
#line 1284
  ip = & pf->info;
#line 1285
  if (pf->num_entries >= 65536) {
#line 1290
    return (-400);
  }
  {
#line 1301
  tmp = stat((char const   */* __restrict  */)pf->file_name, (struct stat */* __restrict  */)(& sbuf));
  }
#line 1301
  if (! tmp) {
#line 1302
    if ((sbuf.st_mode & 61440U) == 32768U) {
      {
#line 1303
      unlink((char const   *)pf->file_name);
      }
    }
  }
  {
#line 1305
  f = fopen((char const   */* __restrict  */)pf->file_name, (char const   */* __restrict  */)"wb");
  }
#line 1305
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 1306
    return (-401);
  }
  {
#line 1308
  ip = & pf->info;
#line 1310
  offset = (78 + pf->num_entries * pf->ent_hdr_size) + 2;
#line 1312
  p = buf___3;
#line 1313
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(ip->name),
         (size_t )32);
#line 1314
  *((p + 32) + 0) = (unsigned char )(((int )((unsigned short )ip->flags) >> 8) & 255);
#line 1314
  *((p + 32) + 1) = (unsigned char )((int )((unsigned short )ip->flags) & 255);
#line 1315
  *((p + 34) + 0) = (unsigned char )(((int )((unsigned short )ip->version) >> 8) & 255);
#line 1315
  *((p + 34) + 1) = (unsigned char )((int )((unsigned short )ip->version) & 255);
#line 1316
  tmp___0 = unix_time_to_pilot_time(ip->createDate);
#line 1316
  *((p + 36) + 0) = (unsigned char )((int )((unsigned char )(tmp___0 >> 24)) & 255);
#line 1316
  tmp___1 = unix_time_to_pilot_time(ip->createDate);
#line 1316
  *((p + 36) + 1) = (unsigned char )((tmp___1 >> 16) & 255UL);
#line 1316
  tmp___2 = unix_time_to_pilot_time(ip->createDate);
#line 1316
  *((p + 36) + 2) = (unsigned char )((tmp___2 >> 8) & 255UL);
#line 1316
  tmp___3 = unix_time_to_pilot_time(ip->createDate);
#line 1316
  *((p + 36) + 3) = (unsigned char )(tmp___3 & 255UL);
#line 1317
  tmp___4 = unix_time_to_pilot_time(ip->modifyDate);
#line 1317
  *((p + 40) + 0) = (unsigned char )((int )((unsigned char )(tmp___4 >> 24)) & 255);
#line 1317
  tmp___5 = unix_time_to_pilot_time(ip->modifyDate);
#line 1317
  *((p + 40) + 1) = (unsigned char )((tmp___5 >> 16) & 255UL);
#line 1317
  tmp___6 = unix_time_to_pilot_time(ip->modifyDate);
#line 1317
  *((p + 40) + 2) = (unsigned char )((tmp___6 >> 8) & 255UL);
#line 1317
  tmp___7 = unix_time_to_pilot_time(ip->modifyDate);
#line 1317
  *((p + 40) + 3) = (unsigned char )(tmp___7 & 255UL);
#line 1318
  tmp___8 = unix_time_to_pilot_time(ip->backupDate);
#line 1318
  *((p + 44) + 0) = (unsigned char )((int )((unsigned char )(tmp___8 >> 24)) & 255);
#line 1318
  tmp___9 = unix_time_to_pilot_time(ip->backupDate);
#line 1318
  *((p + 44) + 1) = (unsigned char )((tmp___9 >> 16) & 255UL);
#line 1318
  tmp___10 = unix_time_to_pilot_time(ip->backupDate);
#line 1318
  *((p + 44) + 2) = (unsigned char )((tmp___10 >> 8) & 255UL);
#line 1318
  tmp___11 = unix_time_to_pilot_time(ip->backupDate);
#line 1318
  *((p + 44) + 3) = (unsigned char )(tmp___11 & 255UL);
#line 1319
  *((p + 48) + 0) = (unsigned char )((int )((unsigned char )(ip->modnum >> 24)) & 255);
#line 1319
  *((p + 48) + 1) = (unsigned char )((ip->modnum >> 16) & 255UL);
#line 1319
  *((p + 48) + 2) = (unsigned char )((ip->modnum >> 8) & 255UL);
#line 1319
  *((p + 48) + 3) = (unsigned char )(ip->modnum & 255UL);
  }
#line 1320
  if (pf->app_info_size) {
#line 1320
    tmp___12 = offset;
  } else {
#line 1320
    tmp___12 = 0;
  }
#line 1320
  *((p + 52) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )tmp___12 >> 24)) & 255);
#line 1320
  if (pf->app_info_size) {
#line 1320
    tmp___13 = offset;
  } else {
#line 1320
    tmp___13 = 0;
  }
#line 1320
  *((p + 52) + 1) = (unsigned char )(((unsigned long )tmp___13 >> 16) & 255UL);
#line 1320
  if (pf->app_info_size) {
#line 1320
    tmp___14 = offset;
  } else {
#line 1320
    tmp___14 = 0;
  }
#line 1320
  *((p + 52) + 2) = (unsigned char )(((unsigned long )tmp___14 >> 8) & 255UL);
#line 1320
  if (pf->app_info_size) {
#line 1320
    tmp___15 = offset;
  } else {
#line 1320
    tmp___15 = 0;
  }
#line 1320
  *((p + 52) + 3) = (unsigned char )((unsigned long )tmp___15 & 255UL);
#line 1321
  offset += pf->app_info_size;
#line 1322
  if (pf->sort_info_size) {
#line 1322
    tmp___16 = offset;
  } else {
#line 1322
    tmp___16 = 0;
  }
#line 1322
  *((p + 56) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )tmp___16 >> 24)) & 255);
#line 1322
  if (pf->sort_info_size) {
#line 1322
    tmp___17 = offset;
  } else {
#line 1322
    tmp___17 = 0;
  }
#line 1322
  *((p + 56) + 1) = (unsigned char )(((unsigned long )tmp___17 >> 16) & 255UL);
#line 1322
  if (pf->sort_info_size) {
#line 1322
    tmp___18 = offset;
  } else {
#line 1322
    tmp___18 = 0;
  }
#line 1322
  *((p + 56) + 2) = (unsigned char )(((unsigned long )tmp___18 >> 8) & 255UL);
#line 1322
  if (pf->sort_info_size) {
#line 1322
    tmp___19 = offset;
  } else {
#line 1322
    tmp___19 = 0;
  }
  {
#line 1322
  *((p + 56) + 3) = (unsigned char )((unsigned long )tmp___19 & 255UL);
#line 1323
  offset += pf->sort_info_size;
#line 1324
  *((p + 60) + 0) = (unsigned char )((int )((unsigned char )(ip->type >> 24)) & 255);
#line 1324
  *((p + 60) + 1) = (unsigned char )((ip->type >> 16) & 255UL);
#line 1324
  *((p + 60) + 2) = (unsigned char )((ip->type >> 8) & 255UL);
#line 1324
  *((p + 60) + 3) = (unsigned char )(ip->type & 255UL);
#line 1325
  *((p + 64) + 0) = (unsigned char )((int )((unsigned char )(ip->creator >> 24)) & 255);
#line 1325
  *((p + 64) + 1) = (unsigned char )((ip->creator >> 16) & 255UL);
#line 1325
  *((p + 64) + 2) = (unsigned char )((ip->creator >> 8) & 255UL);
#line 1325
  *((p + 64) + 3) = (unsigned char )(ip->creator & 255UL);
#line 1326
  *((p + 68) + 0) = (unsigned char )((int )((unsigned char )(pf->unique_id_seed >> 24)) & 255);
#line 1326
  *((p + 68) + 1) = (unsigned char )((pf->unique_id_seed >> 16) & 255UL);
#line 1326
  *((p + 68) + 2) = (unsigned char )((pf->unique_id_seed >> 8) & 255UL);
#line 1326
  *((p + 68) + 3) = (unsigned char )(pf->unique_id_seed & 255UL);
#line 1327
  *((p + 72) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )pf->next_record_list_id >> 24)) & 255);
#line 1327
  *((p + 72) + 1) = (unsigned char )(((unsigned long )pf->next_record_list_id >> 16) & 255UL);
#line 1327
  *((p + 72) + 2) = (unsigned char )(((unsigned long )pf->next_record_list_id >> 8) & 255UL);
#line 1327
  *((p + 72) + 3) = (unsigned char )((unsigned long )pf->next_record_list_id & 255UL);
#line 1328
  *((p + 76) + 0) = (unsigned char )(((int )((unsigned short )pf->num_entries) >> 8) & 255);
#line 1328
  *((p + 76) + 1) = (unsigned char )((int )((unsigned short )pf->num_entries) & 255);
#line 1330
  tmp___20 = fwrite((void const   */* __restrict  */)(buf___3), (size_t )78, (size_t )1,
                    (FILE */* __restrict  */)f);
  }
#line 1330
  if (tmp___20 != 1UL) {
#line 1331
    goto bad;
  }
#line 1333
  i = 0;
#line 1333
  entp = pf->entries;
  {
#line 1333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1333
    if (! (i < pf->num_entries)) {
#line 1333
      goto while_break;
    }
#line 1334
    entp->offset = offset;
#line 1336
    p = buf___3;
#line 1337
    if (pf->resource_flag) {
#line 1338
      *(p + 0) = (unsigned char )((int )((unsigned char )(entp->type >> 24)) & 255);
#line 1338
      *(p + 1) = (unsigned char )((entp->type >> 16) & 255UL);
#line 1338
      *(p + 2) = (unsigned char )((entp->type >> 8) & 255UL);
#line 1338
      *(p + 3) = (unsigned char )(entp->type & 255UL);
#line 1339
      *((p + 4) + 0) = (unsigned char )(((int )((unsigned short )entp->resource_id) >> 8) & 255);
#line 1339
      *((p + 4) + 1) = (unsigned char )((int )((unsigned short )entp->resource_id) & 255);
#line 1340
      *((p + 6) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )entp->offset >> 24)) & 255);
#line 1340
      *((p + 6) + 1) = (unsigned char )(((unsigned long )entp->offset >> 16) & 255UL);
#line 1340
      *((p + 6) + 2) = (unsigned char )(((unsigned long )entp->offset >> 8) & 255UL);
#line 1340
      *((p + 6) + 3) = (unsigned char )((unsigned long )entp->offset & 255UL);
    } else {
#line 1342
      *(p + 0) = (unsigned char )((int )((unsigned char )((unsigned long )entp->offset >> 24)) & 255);
#line 1342
      *(p + 1) = (unsigned char )(((unsigned long )entp->offset >> 16) & 255UL);
#line 1342
      *(p + 2) = (unsigned char )(((unsigned long )entp->offset >> 8) & 255UL);
#line 1342
      *(p + 3) = (unsigned char )((unsigned long )entp->offset & 255UL);
#line 1343
      *((p + 4) + 0) = (unsigned char )entp->attrs;
#line 1344
      *((p + 5) + 0) = (unsigned char )((int )((unsigned char )(entp->uid >> 16)) & 255);
#line 1344
      *((p + 5) + 1) = (unsigned char )((entp->uid >> 8) & 255UL);
#line 1344
      *((p + 5) + 2) = (unsigned char )(entp->uid & 255UL);
    }
    {
#line 1347
    tmp___21 = fwrite((void const   */* __restrict  */)(buf___3), (size_t )pf->ent_hdr_size,
                      (size_t )1, (FILE */* __restrict  */)f);
    }
#line 1347
    if (tmp___21 != 1UL) {
#line 1348
      goto bad;
    }
#line 1350
    offset += entp->size;
#line 1333
    i ++;
#line 1333
    entp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1354
  fwrite((void const   */* __restrict  */)"\000\000", (size_t )1, (size_t )2, (FILE */* __restrict  */)f);
  }
#line 1356
  if (pf->app_info) {
    {
#line 1356
    tmp___22 = fwrite((void const   */* __restrict  */)pf->app_info, (size_t )1, (size_t )pf->app_info_size,
                      (FILE */* __restrict  */)f);
    }
#line 1356
    if (tmp___22 != (size_t )pf->app_info_size) {
#line 1359
      goto bad;
    }
  }
#line 1361
  if (pf->sort_info) {
    {
#line 1361
    tmp___23 = fwrite((void const   */* __restrict  */)pf->sort_info, (size_t )1,
                      (size_t )pf->sort_info_size, (FILE */* __restrict  */)f);
    }
#line 1361
    if (tmp___23 != (size_t )pf->sort_info_size) {
#line 1364
      goto bad;
    }
  }
  {
#line 1367
  fwrite((void const   */* __restrict  */)(pf->tmpbuf)->data, (pf->tmpbuf)->used,
         (size_t )1, (FILE */* __restrict  */)f);
#line 1368
  fflush(f);
#line 1370
  tmp___24 = ferror(f);
  }
#line 1370
  if (tmp___24) {
#line 1371
    goto bad;
  } else {
    {
#line 1370
    tmp___25 = feof(f);
    }
#line 1370
    if (tmp___25) {
#line 1371
      goto bad;
    }
  }
  {
#line 1373
  fclose(f);
  }
#line 1374
  return (0);
  bad: 
  {
#line 1377
  fclose(f);
  }
#line 1378
  return (-401);
}
}
#line 1392 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
static void pi_file_free___0(pi_file_t *pf ) 
{ 


  {
#line 1397
  if ((unsigned long )pf->f != (unsigned long )((FILE *)0)) {
    {
#line 1398
    fclose(pf->f);
    }
  }
#line 1400
  if ((unsigned long )pf->app_info != (unsigned long )((void *)0)) {
    {
#line 1401
    free(pf->app_info);
    }
  }
#line 1403
  if ((unsigned long )pf->sort_info != (unsigned long )((void *)0)) {
    {
#line 1404
    free(pf->sort_info);
    }
  }
#line 1406
  if ((unsigned long )pf->entries != (unsigned long )((void *)0)) {
    {
#line 1407
    free((void *)pf->entries);
    }
  }
#line 1409
  if ((unsigned long )pf->file_name != (unsigned long )((void *)0)) {
    {
#line 1410
    free((void *)pf->file_name);
    }
  }
#line 1412
  if ((unsigned long )pf->rbuf != (unsigned long )((void *)0)) {
    {
#line 1413
    free(pf->rbuf);
    }
  }
#line 1415
  if ((unsigned long )pf->tmpbuf != (unsigned long )((void *)0)) {
    {
#line 1416
    pi_buffer_free(pf->tmpbuf);
    }
  }
  {
#line 1419
  memset((void *)pf, 0, sizeof(pi_file_t ));
#line 1421
  free((void *)pf);
  }
#line 1422
  return;
}
}
#line 1435 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
static int pi_file_set_rbuf_size___0(pi_file_t *pf , size_t size ) 
{ 
  size_t new_size ;
  void *rbuf ;

  {
#line 1441
  if (size > (size_t )pf->rbuf_size) {
#line 1442
    if (pf->rbuf_size == 0) {
      {
#line 1443
      new_size = size + 2048UL;
#line 1444
      rbuf = malloc(new_size);
      }
    } else {
      {
#line 1446
      new_size = size + 2048UL;
#line 1447
      rbuf = realloc(pf->rbuf, new_size);
      }
    }
#line 1450
    if ((unsigned long )rbuf == (unsigned long )((void *)0)) {
#line 1451
      return (-500);
    }
#line 1453
    pf->rbuf_size = (int )new_size;
#line 1454
    pf->rbuf = rbuf;
  }
#line 1457
  return (0);
}
}
#line 1472 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
static pi_file_entry_t *pi_file_append_entry___0(pi_file_t *pf ) 
{ 
  int new_count ;
  size_t new_size ;
  struct pi_file_entry *new_entries ;
  struct pi_file_entry *entp ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1480
  if (pf->num_entries >= pf->num_entries_allocated) {
#line 1481
    if (pf->num_entries_allocated == 0) {
#line 1482
      new_count = 100;
    } else {
#line 1484
      new_count = (pf->num_entries_allocated * 3) / 2;
    }
#line 1485
    new_size = (unsigned long )new_count * sizeof(*(pf->entries));
#line 1487
    if ((unsigned long )pf->entries == (unsigned long )((void *)0)) {
      {
#line 1488
      tmp = malloc(new_size);
#line 1488
      new_entries = (struct pi_file_entry *)tmp;
      }
    } else {
      {
#line 1490
      tmp___0 = realloc((void *)pf->entries, new_size);
#line 1490
      new_entries = (struct pi_file_entry *)tmp___0;
      }
    }
#line 1492
    if ((unsigned long )new_entries == (unsigned long )((void *)0)) {
#line 1493
      return ((pi_file_entry_t *)((void *)0));
    }
#line 1495
    pf->num_entries_allocated = new_count;
#line 1496
    pf->entries = new_entries;
  }
  {
#line 1499
  tmp___1 = pf->num_entries;
#line 1499
  (pf->num_entries) ++;
#line 1499
  entp = pf->entries + tmp___1;
#line 1500
  memset((void *)entp, 0, sizeof(*entp));
  }
#line 1501
  return (entp);
}
}
#line 1504 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
static int pi_file_find_resource_by_type_id___0(pi_file_t const   *pf , unsigned long restype ,
                                                int resid , int *resindex ) 
{ 
  int i ;
  struct pi_file_entry *entp ;

  {
#line 1511
  if (! pf->resource_flag) {
#line 1512
    return (-400);
  }
#line 1514
  i = 0;
#line 1514
  entp = (struct pi_file_entry *)pf->entries;
  {
#line 1514
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1514
    if (! (i < (int )pf->num_entries)) {
#line 1514
      goto while_break;
    }
#line 1515
    if (entp->type == restype) {
#line 1515
      if (entp->resource_id == resid) {
#line 1516
        if (resindex) {
#line 1517
          *resindex = i;
        }
#line 1518
        return (1);
      }
    }
#line 1514
    i ++;
#line 1514
    entp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1521
  return (0);
}
}
#line 31 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
static int debug_types___1  =    0;
#line 32 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
static int debug_level___1  =    0;
#line 33 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
static FILE *debug_file___1  =    (FILE *)((void *)0);
#line 34 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
static int logfile_mutex___1  =    0;
#line 41 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
static int sys_flush___1(pi_socket_t *ps , int flags ) ;
#line 42
static int sys_getsockopt___1(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) ;
#line 44
static int sys_setsockopt___1(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) ;
#line 59 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
static pi_protocol_t *sys_protocol_dup___1(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  pi_sys_data_t *data ;
  pi_sys_data_t *new_data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 62
  new_prot = (pi_protocol_t *)((void *)0);
#line 63
  data = (pi_sys_data_t *)((void *)0);
#line 63
  new_data = (pi_sys_data_t *)((void *)0);
#line 66
  tmp = malloc(sizeof(pi_protocol_t ));
#line 66
  new_prot = (pi_protocol_t *)tmp;
  }
#line 67
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
    {
#line 68
    tmp___0 = malloc(sizeof(pi_sys_data_t ));
#line 68
    new_data = (pi_sys_data_t *)tmp___0;
    }
#line 69
    if ((unsigned long )new_data == (unsigned long )((void *)0)) {
      {
#line 70
      free((void *)new_prot);
#line 71
      new_prot = (pi_protocol_t *)((void *)0);
      }
    }
  }
#line 75
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 75
    if ((unsigned long )new_data != (unsigned long )((void *)0)) {
#line 76
      new_prot->level = prot->level;
#line 77
      new_prot->dup = prot->dup;
#line 78
      new_prot->free = prot->free;
#line 79
      new_prot->read = prot->read;
#line 80
      new_prot->write = prot->write;
#line 81
      new_prot->flush = prot->flush;
#line 82
      new_prot->getsockopt = prot->getsockopt;
#line 83
      new_prot->setsockopt = prot->setsockopt;
#line 85
      data = (pi_sys_data_t *)prot->data;
#line 86
      new_data->txid = data->txid;
#line 87
      new_prot->data = (void *)new_data;
    }
  }
#line 90
  return (new_prot);
}
}
#line 105 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
static void sys_protocol_free___1(pi_protocol_t *prot ) 
{ 


  {
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 109
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c",
             109, "prot != NULL");
      }
    }
#line 109
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 111
    if ((unsigned long )prot->data != (unsigned long )((void *)0)) {
      {
#line 112
      free(prot->data);
      }
    }
    {
#line 113
    free((void *)prot);
    }
  }
#line 115
  return;
}
}
#line 275 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
static int sys_flush___1(pi_socket_t *ps , int flags ) 
{ 
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 281
  prot = pi_protocol(ps->sd, 4);
  }
#line 282
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 283
    tmp = pi_set_error(ps->sd, -201);
    }
#line 283
    return (tmp);
  }
  {
#line 285
  next = pi_protocol_next(ps->sd, 4);
  }
#line 286
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 287
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 287
    return (tmp___0);
  }
  {
#line 289
  tmp___1 = (*(next->flush))(ps, flags);
  }
#line 289
  return (tmp___1);
}
}
#line 303 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
static int sys_getsockopt___1(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) 
{ 


  {
#line 307
  return (0);
}
}
#line 322 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
static int sys_setsockopt___1(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) 
{ 


  {
#line 326
  return (0);
}
}
#line 42 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static int net_flush___1(pi_socket_t *ps , int flags ) ;
#line 43
static int net_getsockopt___1(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) ;
#line 45
static int net_setsockopt___1(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) ;
#line 59 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static pi_protocol_t *net_protocol_dup___1(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  pi_net_data_t *data ;
  pi_net_data_t *new_data ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 62
  new_prot = (pi_protocol_t *)((void *)0);
#line 63
  data = (pi_net_data_t *)((void *)0);
#line 63
  new_data = (pi_net_data_t *)((void *)0);
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 66
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c",
             66, "prot != NULL");
      }
    }
#line 66
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 68
  tmp = malloc(sizeof(pi_protocol_t ));
#line 68
  new_prot = (pi_protocol_t *)tmp;
  }
#line 69
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
    {
#line 70
    tmp___0 = malloc(sizeof(pi_net_data_t ));
#line 70
    new_data = (pi_net_data_t *)tmp___0;
    }
#line 71
    if ((unsigned long )new_data == (unsigned long )((void *)0)) {
      {
#line 72
      free((void *)new_prot);
#line 73
      new_prot = (pi_protocol_t *)((void *)0);
      }
    }
  }
#line 77
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 77
    if ((unsigned long )new_data != (unsigned long )((void *)0)) {
#line 78
      new_prot->level = prot->level;
#line 79
      new_prot->dup = prot->dup;
#line 80
      new_prot->free = prot->free;
#line 81
      new_prot->read = prot->read;
#line 82
      new_prot->write = prot->write;
#line 83
      new_prot->flush = prot->flush;
#line 84
      new_prot->getsockopt = prot->getsockopt;
#line 85
      new_prot->setsockopt = prot->setsockopt;
#line 87
      data = (pi_net_data_t *)prot->data;
#line 88
      new_data->type = data->type;
#line 89
      new_data->split_writes = data->split_writes;
#line 90
      new_data->write_chunksize = data->write_chunksize;
#line 91
      new_data->txid = data->txid;
#line 92
      new_prot->data = (void *)new_data;
    }
  }
#line 95
  return (new_prot);
}
}
#line 110 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static void net_protocol_free___1(pi_protocol_t *prot ) 
{ 


  {
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 113
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c",
             113, "prot != NULL");
      }
    }
#line 113
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 116
    if ((unsigned long )prot->data != (unsigned long )((void *)0)) {
      {
#line 117
      free(prot->data);
      }
    }
    {
#line 118
    free((void *)prot);
    }
  }
#line 120
  return;
}
}
#line 184 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static unsigned char const   msg1___3[51]  = 
#line 184
  {      (unsigned char const   )'\022',      (unsigned char const   )'\001',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )' ',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'$',      (unsigned char const   )'\377',      (unsigned char const   )'\377', 
        (unsigned char const   )'\377',      (unsigned char const   )'\377',      (unsigned char const   )'<',      (unsigned char const   )'\000', 
        (unsigned char const   )'<',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\300',      (unsigned char const   )'\250', 
        (unsigned char const   )'\245',      (unsigned char const   )'\037',      (unsigned char const   )'\004',      (unsigned char const   )'\'', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000'};
#line 189 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static unsigned char const   msg2___3[47]  = 
#line 189
  {      (unsigned char const   )'\023',      (unsigned char const   )'\001',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )' ',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )' ',      (unsigned char const   )'\377',      (unsigned char const   )'\377', 
        (unsigned char const   )'\377',      (unsigned char const   )'\377',      (unsigned char const   )'\000',      (unsigned char const   )'<', 
        (unsigned char const   )'\000',      (unsigned char const   )'<',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\001',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000'};
#line 232 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static unsigned char const   msg1___4[23]  = 
#line 232
  {      (unsigned char const   )'\220',      (unsigned char const   )'\001',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )' ',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\b',      (unsigned char const   )'\001',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000'};
#line 235 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static unsigned char const   msg2___4[51]  = 
#line 235
  {      (unsigned char const   )'\222',      (unsigned char const   )'\001',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )' ',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'$',      (unsigned char const   )'\377',      (unsigned char const   )'\377', 
        (unsigned char const   )'\377',      (unsigned char const   )'\377',      (unsigned char const   )'\000',      (unsigned char const   )'<', 
        (unsigned char const   )'\000',      (unsigned char const   )'<',      (unsigned char const   )'@',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\001',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\300',      (unsigned char const   )'\250', 
        (unsigned char const   )'\245',      (unsigned char const   )'\036',      (unsigned char const   )'\004',      (unsigned char const   )'\001', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000'};
#line 240 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static unsigned char const   msg3___1[9]  = 
#line 240
  {      (unsigned char const   )'\223',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000'};
#line 276 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static int net_flush___1(pi_socket_t *ps , int flags ) 
{ 
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 282
  prot = pi_protocol(ps->sd, 3);
  }
#line 283
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 284
    tmp = pi_set_error(ps->sd, -201);
    }
#line 284
    return (tmp);
  }
  {
#line 286
  next = pi_protocol_next(ps->sd, 3);
  }
#line 287
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 288
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 288
    return (tmp___0);
  }
  {
#line 290
  tmp___1 = (*(next->flush))(ps, flags);
  }
#line 290
  return (tmp___1);
}
}
#line 572 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static int net_getsockopt___1(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  pi_net_data_t *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 579
  prot = pi_protocol(ps->sd, 3);
  }
#line 580
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 581
    tmp = pi_set_error(ps->sd, -201);
    }
#line 581
    return (tmp);
  }
#line 583
  data = (pi_net_data_t *)prot->data;
  {
#line 586
  if (option_name == 0) {
#line 586
    goto case_0;
  }
#line 585
  goto switch_break;
  case_0: /* CIL Label */ 
#line 587
  if (*option_len != sizeof(data->type)) {
    {
#line 588
    tmp___0 = __errno_location();
#line 588
    *tmp___0 = 22;
#line 589
    tmp___1 = pi_set_error(ps->sd, -501);
    }
#line 589
    return (tmp___1);
  }
  {
#line 591
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->type),
         sizeof(data->type));
#line 593
  *option_len = sizeof(data->type);
  }
#line 594
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 597
  return (0);
}
}
#line 612 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static int net_setsockopt___1(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  pi_net_data_t *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 619
  prot = pi_protocol(ps->sd, 3);
  }
#line 620
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 621
    tmp = pi_set_error(ps->sd, -201);
    }
#line 621
    return (tmp);
  }
#line 623
  data = (pi_net_data_t *)prot->data;
  {
#line 626
  if (option_name == 0) {
#line 626
    goto case_0;
  }
#line 639
  if (option_name == 1) {
#line 639
    goto case_1;
  }
#line 653
  if (option_name == 2) {
#line 653
    goto case_2;
  }
#line 625
  goto switch_break;
  case_0: /* CIL Label */ 
#line 627
  if (*option_len != sizeof(data->type)) {
    {
#line 628
    tmp___0 = __errno_location();
#line 628
    *tmp___0 = 22;
#line 629
    tmp___1 = pi_set_error(ps->sd, -501);
    }
#line 629
    return (tmp___1);
  }
  {
#line 631
  memcpy((void */* __restrict  */)(& data->type), (void const   */* __restrict  */)option_value,
         sizeof(data->type));
  }
#line 633
  goto switch_break;
  case_1: /* CIL Label */ 
#line 640
  if (*option_len != sizeof(data->split_writes)) {
    {
#line 641
    tmp___2 = __errno_location();
#line 641
    *tmp___2 = 22;
#line 642
    tmp___3 = pi_set_error(ps->sd, -501);
    }
#line 642
    return (tmp___3);
  }
  {
#line 644
  memcpy((void */* __restrict  */)(& data->split_writes), (void const   */* __restrict  */)option_value,
         sizeof(data->split_writes));
  }
#line 646
  goto switch_break;
  case_2: /* CIL Label */ 
#line 654
  if (*option_len != sizeof(data->write_chunksize)) {
    {
#line 655
    tmp___4 = __errno_location();
#line 655
    *tmp___4 = 22;
#line 656
    tmp___5 = pi_set_error(ps->sd, -501);
    }
#line 656
    return (tmp___5);
  }
  {
#line 658
  memcpy((void */* __restrict  */)(& data->write_chunksize), (void const   */* __restrict  */)option_value,
         sizeof(data->write_chunksize));
  }
#line 660
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 663
  return (0);
}
}
#line 45 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static int padp_flush___1(pi_socket_t *ps , int flags ) ;
#line 46
static int padp_getsockopt___1(pi_socket_t *ps , int level , int option_name , void *option_value ,
                               size_t *option_len ) ;
#line 48
static int padp_setsockopt___1(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                               size_t *option_len ) ;
#line 50
static int padp_sendack___1(struct pi_socket *ps , struct pi_padp_data *data , unsigned char txid ,
                            struct padp *padp , int flags ) ;
#line 65 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static pi_protocol_t *padp_protocol_dup___1(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  pi_padp_data_t *data ;
  pi_padp_data_t *new_data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 68
  new_prot = (pi_protocol_t *)((void *)0);
#line 69
  data = (pi_padp_data_t *)((void *)0);
#line 69
  new_data = (pi_padp_data_t *)((void *)0);
#line 72
  tmp = malloc(sizeof(pi_protocol_t ));
#line 72
  new_prot = (pi_protocol_t *)tmp;
  }
#line 73
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
    {
#line 74
    tmp___0 = malloc(sizeof(pi_padp_data_t ));
#line 74
    new_data = (pi_padp_data_t *)tmp___0;
    }
#line 75
    if ((unsigned long )new_data == (unsigned long )((void *)0)) {
      {
#line 76
      free((void *)new_prot);
#line 77
      new_prot = (pi_protocol_t *)((void *)0);
      }
    } else {
      {
#line 79
      new_prot->level = prot->level;
#line 80
      new_prot->dup = prot->dup;
#line 81
      new_prot->free = prot->free;
#line 82
      new_prot->read = prot->read;
#line 83
      new_prot->write = prot->write;
#line 84
      new_prot->flush = prot->flush;
#line 85
      new_prot->getsockopt = prot->getsockopt;
#line 86
      new_prot->setsockopt = prot->setsockopt;
#line 88
      data = (pi_padp_data_t *)prot->data;
#line 89
      memcpy((void */* __restrict  */)new_data, (void const   */* __restrict  */)data,
             sizeof(pi_padp_data_t ));
#line 90
      new_prot->data = (void *)new_data;
      }
    }
  }
#line 94
  return (new_prot);
}
}
#line 109 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static void padp_protocol_free___1(pi_protocol_t *prot ) 
{ 


  {
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 112
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c",
             112, "prot != NULL");
      }
    }
#line 112
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 115
    if ((unsigned long )prot->data != (unsigned long )((void *)0)) {
      {
#line 116
      free(prot->data);
      }
    }
    {
#line 117
    free((void *)prot);
    }
  }
#line 119
  return;
}
}
#line 681 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static int padp_flush___1(pi_socket_t *ps , int flags ) 
{ 
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 687
  prot = pi_protocol(ps->sd, 2);
  }
#line 688
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 689
    tmp = pi_set_error(ps->sd, -201);
    }
#line 689
    return (tmp);
  }
  {
#line 691
  next = pi_protocol_next(ps->sd, 2);
  }
#line 692
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 693
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 693
    return (tmp___0);
  }
  {
#line 695
  tmp___1 = (*(next->flush))(ps, flags);
  }
#line 695
  return (tmp___1);
}
}
#line 709 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static int padp_getsockopt___1(pi_socket_t *ps , int level , int option_name , void *option_value ,
                               size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  pi_padp_data_t *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 716
  prot = pi_protocol(ps->sd, 2);
  }
#line 717
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 718
    tmp = pi_set_error(ps->sd, -201);
    }
#line 718
    return (tmp);
  }
#line 719
  data = (pi_padp_data_t *)prot->data;
  {
#line 722
  if (option_name == 0) {
#line 722
    goto case_0;
  }
#line 728
  if (option_name == 1) {
#line 728
    goto case_1;
  }
#line 734
  if (option_name == 2) {
#line 734
    goto case_2;
  }
#line 740
  if (option_name == 3) {
#line 740
    goto case_3;
  }
#line 721
  goto switch_break;
  case_0: /* CIL Label */ 
#line 723
  if (*option_len != sizeof(data->type)) {
#line 724
    goto error;
  }
  {
#line 725
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->type),
         sizeof(data->type));
  }
#line 726
  goto switch_break;
  case_1: /* CIL Label */ 
#line 729
  if (*option_len != sizeof(data->last_type)) {
#line 730
    goto error;
  }
  {
#line 731
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->last_type),
         sizeof(data->last_type));
  }
#line 732
  goto switch_break;
  case_2: /* CIL Label */ 
#line 735
  if (*option_len != sizeof(data->freeze_txid)) {
#line 736
    goto error;
  }
  {
#line 737
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->freeze_txid),
         sizeof(data->freeze_txid));
  }
#line 738
  goto switch_break;
  case_3: /* CIL Label */ 
#line 741
  if (*option_len != sizeof(data->use_long_format)) {
#line 742
    goto error;
  }
  {
#line 743
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->use_long_format),
         sizeof(data->use_long_format));
  }
#line 744
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 747
  return (0);
  error: 
  {
#line 750
  tmp___0 = __errno_location();
#line 750
  *tmp___0 = 22;
#line 751
  tmp___1 = pi_set_error(ps->sd, -501);
  }
#line 751
  return (tmp___1);
}
}
#line 766 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static int padp_setsockopt___1(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                               size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  pi_padp_data_t *data ;
  int was_frozen ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 774
  prot = pi_protocol(ps->sd, 2);
  }
#line 775
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 776
    tmp = pi_set_error(ps->sd, -201);
    }
#line 776
    return (tmp);
  }
#line 777
  data = (pi_padp_data_t *)prot->data;
  {
#line 780
  if (option_name == 0) {
#line 780
    goto case_0;
  }
#line 786
  if (option_name == 2) {
#line 786
    goto case_2;
  }
#line 798
  if (option_name == 3) {
#line 798
    goto case_3;
  }
#line 779
  goto switch_break;
  case_0: /* CIL Label */ 
#line 781
  if (*option_len != sizeof(data->type)) {
#line 782
    goto error;
  }
  {
#line 783
  memcpy((void */* __restrict  */)(& data->type), (void const   */* __restrict  */)option_value,
         sizeof(data->type));
  }
#line 784
  goto switch_break;
  case_2: /* CIL Label */ 
#line 787
  if (*option_len != sizeof(data->freeze_txid)) {
#line 788
    goto error;
  }
  {
#line 789
  was_frozen = data->freeze_txid;
#line 790
  memcpy((void */* __restrict  */)(& data->freeze_txid), (void const   */* __restrict  */)option_value,
         sizeof(data->freeze_txid));
  }
#line 791
  if (was_frozen) {
#line 791
    if (! data->freeze_txid) {
#line 792
      (data->next_txid) ++;
#line 793
      if (data->next_txid >= 254U) {
#line 794
        data->next_txid = 1U;
      }
    }
  }
#line 796
  goto switch_break;
  case_3: /* CIL Label */ 
#line 799
  if (*option_len != sizeof(data->use_long_format)) {
#line 800
    goto error;
  }
  {
#line 801
  memcpy((void */* __restrict  */)(& data->use_long_format), (void const   */* __restrict  */)option_value,
         sizeof(data->use_long_format));
  }
#line 802
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 805
  return (0);
  error: 
  {
#line 808
  tmp___0 = __errno_location();
#line 808
  *tmp___0 = 22;
#line 809
  tmp___1 = pi_set_error(ps->sd, -501);
  }
#line 809
  return (tmp___1);
}
}
#line 823 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static int padp_sendack___1(struct pi_socket *ps , struct pi_padp_data *data , unsigned char txid ,
                            struct padp *padp , int flags ) 
{ 
  int type ;
  int socket___0 ;
  int result ;
  int header_size ;
  size_t size ;
  unsigned char npadp_buf[6] ;
  struct pi_protocol *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;

  {
  {
#line 840
  next = pi_protocol_next(ps->sd, 2);
  }
#line 841
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 842
    tmp = pi_set_error(ps->sd, -201);
    }
#line 842
    return (tmp);
  }
  {
#line 844
  type = 2;
#line 845
  socket___0 = 3;
#line 846
  size = sizeof(type);
#line 847
  pi_setsockopt(ps->sd, 1, 4, (void const   *)(& type), & size);
#line 848
  pi_setsockopt(ps->sd, 1, 0, (void const   *)(& socket___0), & size);
#line 849
  pi_setsockopt(ps->sd, 1, 2, (void const   *)(& socket___0), & size);
#line 850
  size = sizeof(txid);
#line 851
  pi_setsockopt(ps->sd, 1, 6, (void const   *)(& txid), & size);
#line 853
  header_size = 4;
#line 854
  *(& npadp_buf[0] + 0) = (unsigned char)2;
#line 855
  *(& npadp_buf[1] + 0) = padp->flags;
  }
#line 856
  if ((int )padp->flags & 16) {
#line 857
    header_size += 2;
#line 858
    *(& npadp_buf[2] + 0) = (unsigned char )((int )((unsigned char )((unsigned long )padp->size >> 24)) & 255);
#line 858
    *(& npadp_buf[2] + 1) = (unsigned char )(((unsigned long )padp->size >> 16) & 255UL);
#line 858
    *(& npadp_buf[2] + 2) = (unsigned char )(((unsigned long )padp->size >> 8) & 255UL);
#line 858
    *(& npadp_buf[2] + 3) = (unsigned char )((unsigned long )padp->size & 255UL);
  } else {
#line 860
    *(& npadp_buf[2] + 0) = (unsigned char )(((int )((unsigned short )padp->size) >> 8) & 255);
#line 860
    *(& npadp_buf[2] + 1) = (unsigned char )((int )((unsigned short )padp->size) & 255);
  }
  {
#line 863
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 863
    tmp___0 = pi_debug_get_types();
    }
#line 863
    if (tmp___0 & 8) {
      {
#line 863
      tmp___1 = pi_debug_get_level();
      }
#line 863
      if (tmp___1 >= 4) {
        {
#line 863
        padp_dump_header((unsigned char const   *)(npadp_buf), 1);
        }
      }
    }
#line 863
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 864
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 864
    tmp___2 = pi_debug_get_types();
    }
#line 864
    if (tmp___2 & 8) {
      {
#line 864
      tmp___3 = pi_debug_get_level();
      }
#line 864
      if (tmp___3 >= 8) {
        {
#line 864
        padp_dump((unsigned char const   *)(npadp_buf));
        }
      }
    }
#line 864
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 866
  tmp___4 = (*(next->write))(ps, (unsigned char const   *)(npadp_buf), (size_t )header_size,
                             flags);
#line 866
  result = (int )tmp___4;
  }
#line 868
  if (result >= 0) {
#line 869
    data->last_ack_txid = txid;
#line 870
    data->last_ack_padp.type = padp->type;
#line 871
    data->last_ack_padp.flags = padp->flags;
#line 872
    data->last_ack_padp.size = padp->size;
  }
#line 875
  return (result);
}
}
#line 580 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 61 "/home/wheatley/newnew/temp/pilot-link-0.12.5/tests/locationdb-test.c"
static void dump(void *buf___3 , int n ) 
{ 
  int ch ;
  int i ;
  int j ;

  {
#line 67
  i = 0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (i < n)) {
#line 67
      goto while_break;
    }
    {
#line 68
    printf((char const   */* __restrict  */)"%04x: ", i);
#line 69
    j = 0;
    }
    {
#line 69
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 69
      if (! (j < 16)) {
#line 69
        goto while_break___0;
      }
#line 70
      if (i + j < n) {
        {
#line 71
        printf((char const   */* __restrict  */)"%02x ", (int )*((unsigned char *)buf___3 + (i + j)));
        }
      } else {
        {
#line 74
        printf((char const   */* __restrict  */)"   ");
        }
      }
#line 69
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 76
    printf((char const   */* __restrict  */)"  ");
#line 77
    j = 0;
    }
    {
#line 77
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 77
      if (j < 16) {
#line 77
        if (! (i + j < n)) {
#line 77
          goto while_break___1;
        }
      } else {
#line 77
        goto while_break___1;
      }
#line 78
      ch = (int )*((unsigned char *)buf___3 + (i + j)) & 127;
#line 79
      if (ch < 32) {
        {
#line 80
        putchar('.');
        }
      } else
#line 79
      if (ch >= 127) {
        {
#line 80
        putchar('.');
        }
      } else {
        {
#line 82
        putchar(ch);
        }
      }
#line 77
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 84
    printf((char const   */* __restrict  */)"\n");
#line 67
    i += 16;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return;
}
}
#line 91 "/home/wheatley/newnew/temp/pilot-link-0.12.5/tests/locationdb-test.c"
void parse(pi_file_t *pf ) 
{ 
  int result ;
  int nentries ;
  char *buf___3 ;
  int attrs ;
  int cat ;
  size_t size ;
  recordid_t uid ;
  Location_t loc ;
  int entnum ;
  pi_buffer_t *pi_buf ;
  pi_buffer_t *test ;
  int tmp ;
  int i ;

  {
  {
#line 104
  pi_file_get_entries(pf, & nentries);
#line 105
  printf((char const   */* __restrict  */)"Number of entries: %d\n", nentries);
#line 107
  entnum = 0;
  }
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (entnum < nentries)) {
#line 107
      goto while_break;
    }
    {
#line 108
    tmp = pi_file_read_record(pf, entnum, (void **)(& buf___3), & size, & attrs, & cat,
                              & uid);
    }
#line 108
    if (tmp < 0) {
      {
#line 110
      printf((char const   */* __restrict  */)"Error reading record number %d\n",
             entnum);
      }
#line 111
      return;
    }
#line 115
    if (attrs & 128) {
#line 117
      goto __Cont;
    } else
#line 115
    if (attrs & 8) {
#line 117
      goto __Cont;
    }
    {
#line 120
    printf((char const   */* __restrict  */)"original record %d\n", entnum);
#line 121
    dump((void *)buf___3, (int )size);
#line 123
    pi_buf = pi_buffer_new(size);
#line 124
    pi_buffer_append(pi_buf, (void const   *)buf___3, size);
#line 126
    result = unpack_Location(& loc, (pi_buffer_t const   *)pi_buf);
    }
#line 127
    if (result == -1) {
      {
#line 128
      printf((char const   */* __restrict  */)"Error unpacking record %d!\n", entnum);
      }
    } else {
      {
#line 130
      printf((char const   */* __restrict  */)"Timezone name: %s\n", loc.tz.name);
#line 131
      printf((char const   */* __restrict  */)"\tOffset from GMT: %d minutes\n", (int )loc.tz.offset);
#line 132
      printf((char const   */* __restrict  */)"\tDST observed: %d\n", (int )loc.tz.dstObserved);
#line 133
      printf((char const   */* __restrict  */)"\tNote is: %s\n", loc.note);
#line 135
      printf((char const   */* __restrict  */)"\tlat: %d degrees %d minutes\n", (int )loc.latitude.degrees,
             (int )loc.latitude.minutes);
#line 136
      printf((char const   */* __restrict  */)"\tlon: %d degrees %d minutes\n", (int )loc.longitude.degrees,
             (int )loc.longitude.minutes);
      }
    }
    {
#line 142
    test = pi_buffer_new((size_t )0);
#line 143
    result = pack_Location((Location_t const   *)(& loc), test);
    }
#line 144
    if (result == -1) {
      {
#line 145
      printf((char const   */* __restrict  */)"Error packing record %d!\n", entnum);
      }
    } else {
      {
#line 147
      printf((char const   */* __restrict  */)"packed record\n");
#line 148
      dump((void *)test->data, (int )test->used);
      }
#line 150
      if (pi_buf->used != test->used) {
        {
#line 152
        printf((char const   */* __restrict  */)"Error: Different record sizes unpack: %d pack: %d last byte unpack: 0x%02X pack: 0x%02X\n",
               pi_buf->used, test->used, (int )*(pi_buf->data + (pi_buf->used - 1UL)),
               (int )*(test->data + (test->used - 1UL)));
#line 153
        i = 0;
        }
        {
#line 153
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 153
          if (! ((size_t )i < pi_buf->used)) {
#line 153
            goto while_break___0;
          }
#line 154
          if ((int )*(pi_buf->data + i) != (int )*(test->data + i)) {
            {
#line 155
            printf((char const   */* __restrict  */)"Error: Byte %d is different unpack: 0x%02X pack: 0x%02X\n",
                   i, (int )*(pi_buf->data + i), (int )*(test->data + i));
            }
          }
#line 153
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
    {
#line 162
    pi_buffer_free(test);
#line 164
    pi_buffer_free(pi_buf);
#line 165
    free_Location(& loc);
    }
    __Cont: /* CIL Label */ 
#line 107
    entnum ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  return;
}
}
#line 169 "/home/wheatley/newnew/temp/pilot-link-0.12.5/tests/locationdb-test.c"
int main(int argc , char **argv ) 
{ 
  pi_file_t *pf ;
  struct DBInfo info ;

  {
#line 174
  if (argc != 2) {
    {
#line 175
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [.pdb file]\n",
            *argv);
    }
#line 176
    return (1);
  }
  {
#line 180
  pf = pi_file_open((char const   *)*(argv + 1));
  }
#line 180
  if ((unsigned long )pf == (unsigned long )((void *)0)) {
    {
#line 181
    perror("pi_file_open");
    }
#line 182
    return (1);
  }
  {
#line 185
  pi_file_get_info((pi_file_t const   *)pf, & info);
#line 187
  parse(pf);
#line 189
  pi_file_close(pf);
  }
#line 191
  return (0);
}
}
#line 52 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_connect___1(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
#line 54
static int pi_usb_bind___1(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
#line 56
static int pi_usb_listen___1(pi_socket_t *ps , int backlog ) ;
#line 57
static int pi_usb_accept___1(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) ;
#line 59
static int pi_usb_getsockopt___1(pi_socket_t *ps , int level , int option_name , void *option_value ,
                                 size_t *option_len ) ;
#line 61
static int pi_usb_setsockopt___1(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                                 size_t *option_len ) ;
#line 63
static int pi_usb_close___1(pi_socket_t *ps ) ;
#line 65
static int USB_configure_visor___1(pi_usb_data_t *dev , u_int8_t *input_pipe , u_int8_t *output_pipe ) ;
#line 66
static int USB_configure_generic___1(pi_usb_data_t *dev , u_int8_t *input_pipe , u_int8_t *output_pipe ) ;
#line 118 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static void pi_usb_protocol_free___1(pi_protocol_t *prot ) 
{ 


  {
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 121
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
             121, "prot != NULL");
      }
    }
#line 121
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
    {
#line 124
    free((void *)prot);
    }
  }
#line 125
  return;
}
}
#line 139 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static pi_protocol_t *pi_usb_protocol___1(pi_device_t *dev ) 
{ 
  pi_protocol_t *prot ;
  pi_usb_data_t *data ;
  void *tmp ;

  {
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! ((unsigned long )dev != (unsigned long )((void *)0))) {
      {
#line 145
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
             145, "dev != NULL");
      }
    }
#line 145
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 147
  data = (pi_usb_data_t *)dev->data;
#line 149
  tmp = malloc(sizeof(pi_protocol_t ));
#line 149
  prot = (pi_protocol_t *)tmp;
  }
#line 151
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 152
    prot->level = 0;
#line 153
    prot->dup = & pi_usb_protocol_dup;
#line 154
    prot->free = & pi_usb_protocol_free___1;
#line 155
    prot->read = data->impl.read;
#line 156
    prot->write = data->impl.write;
#line 157
    prot->flush = data->impl.flush;
#line 158
    prot->getsockopt = & pi_usb_getsockopt___1;
#line 159
    prot->setsockopt = & pi_usb_setsockopt___1;
#line 160
    prot->data = (void *)0;
  }
#line 163
  return (prot);
}
}
#line 177 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static void pi_usb_device_free___1(pi_device_t *dev ) 
{ 
  pi_usb_data_t *data ;

  {
#line 180
  data = (pi_usb_data_t *)dev->data;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! ((unsigned long )dev != (unsigned long )((void *)0))) {
      {
#line 182
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
             182, "dev != NULL");
      }
    }
#line 182
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  if ((unsigned long )data != (unsigned long )((void *)0)) {
    {
#line 185
    free((void *)data);
    }
  }
#line 186
  if ((unsigned long )dev != (unsigned long )((void *)0)) {
    {
#line 187
    free((void *)dev);
    }
  }
#line 188
  return;
}
}
#line 247 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_connect___1(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) 
{ 
  struct pi_usb_data *data ;
  struct pi_sockaddr *pa ;
  int result ;
  int timeout ;
  size_t size ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 250
  data = (pi_usb_data_t *)(ps->device)->data;
#line 251
  pa = (struct pi_sockaddr *)addr;
#line 255
  if (ps->type == 16) {
#line 256
    if (ps->protocol == 3) {
#line 257
      tmp = 57600;
#line 257
      data->rate = tmp;
#line 257
      data->establishrate = tmp;
    } else {
#line 259
      if (data->establishrate == -1) {
        {
#line 260
        get_pilot_rate(& data->establishrate, & data->establishhighrate);
        }
      }
#line 263
      data->rate = 9600;
    }
  } else
#line 265
  if (ps->type == 48) {
#line 267
    tmp___0 = 57600;
#line 267
    data->rate = tmp___0;
#line 267
    data->establishrate = tmp___0;
  }
  {
#line 270
  result = (*(data->impl.open))(ps, pa, addrlen);
  }
#line 271
  if (result < 0) {
#line 272
    goto fail;
  }
#line 274
  timeout = ps->accept_to * 1000;
#line 274
  data->timeout = timeout;
#line 276
  if (data->impl.wait_for_device) {
    {
#line 277
    result = (*(data->impl.wait_for_device))(ps, & timeout);
    }
#line 278
    if (result <= 0) {
#line 279
      goto fail;
    }
  }
  {
#line 282
  tmp___1 = malloc(addrlen);
#line 282
  ps->raddr = (struct sockaddr *)tmp___1;
#line 283
  memcpy((void */* __restrict  */)ps->raddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 284
  ps->raddrlen = addrlen;
#line 285
  tmp___2 = malloc(addrlen);
#line 285
  ps->laddr = (struct sockaddr *)tmp___2;
#line 286
  memcpy((void */* __restrict  */)ps->laddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 287
  ps->laddrlen = addrlen;
  }
#line 289
  if (ps->type == 16) {
    {
#line 291
    if (ps->cmd == 1) {
#line 291
      goto case_1;
    }
#line 301
    if (ps->cmd == 2) {
#line 301
      goto case_2;
    }
#line 290
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 292
    result = cmp_tx_handshake(ps);
    }
#line 292
    if (result < 0) {
#line 293
      goto fail;
    }
    {
#line 294
    size = sizeof(data->rate);
#line 295
    pi_getsockopt(ps->sd, 5, 3, (void *)(& data->rate), & size);
#line 297
    result = (*(data->impl.changebaud))(ps);
    }
#line 297
    if (result < 0) {
#line 298
      goto fail;
    }
#line 299
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 302
    result = net_tx_handshake(ps);
    }
#line 302
    if (result < 0) {
#line 303
      goto fail;
    }
#line 304
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 307
  ps->state = 4;
#line 308
  ps->command = 0;
  fail: 
#line 311
  if (result < 0) {
#line 311
    tmp___3 = result;
  } else {
#line 311
    tmp___3 = 0;
  }
#line 311
  return (tmp___3);
}
}
#line 325 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_bind___1(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) 
{ 
  struct pi_usb_data *data ;
  struct pi_sockaddr *pa ;
  int result ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 328
  data = (pi_usb_data_t *)(ps->device)->data;
#line 329
  pa = (struct pi_sockaddr *)addr;
#line 335
  if (ps->type == 16) {
#line 336
    if (data->establishrate == -1) {
      {
#line 337
      get_pilot_rate(& data->establishrate, & data->establishhighrate);
      }
    }
#line 340
    data->rate = 9600;
  } else
#line 341
  if (ps->type == 48) {
#line 343
    tmp = 57600;
#line 343
    data->rate = tmp;
#line 343
    data->establishrate = tmp;
  }
  {
#line 346
  result = (*(data->impl.open))(ps, pa, addrlen);
  }
#line 347
  if (result < 0) {
#line 348
    return (result);
  }
  {
#line 350
  tmp___0 = malloc(addrlen);
#line 350
  ps->raddr = (struct sockaddr *)tmp___0;
#line 351
  memcpy((void */* __restrict  */)ps->raddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 352
  ps->raddrlen = addrlen;
#line 353
  tmp___1 = malloc(addrlen);
#line 353
  ps->laddr = (struct sockaddr *)tmp___1;
#line 354
  memcpy((void */* __restrict  */)ps->laddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 355
  ps->laddrlen = addrlen;
  }
#line 357
  return (0);
}
}
#line 371 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_listen___1(pi_socket_t *ps , int backlog ) 
{ 


  {
#line 374
  ps->state = 1;
#line 375
  return (0);
}
}
#line 389 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_accept___1(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) 
{ 
  struct pi_usb_data *data ;
  int result ;
  int timeout ;
  size_t size ;
  struct timeval tv ;
  unsigned char cmp_flags ;
  int use_long_format ;

  {
#line 392
  data = (pi_usb_data_t *)(ps->device)->data;
#line 397
  timeout = ps->accept_to * 1000;
#line 397
  data->timeout = timeout;
#line 399
  if (data->impl.wait_for_device) {
    {
#line 400
    result = (*(data->impl.wait_for_device))(ps, & timeout);
    }
#line 401
    if (result <= 0) {
#line 402
      return (result);
    }
  }
  {
#line 423
  result = (*(data->impl.poll))(ps, timeout);
  }
#line 424
  if (result <= 0) {
#line 425
    if (result == 0) {
#line 426
      return (-205);
    } else {
#line 428
      return (result);
    }
  }
  {
#line 432
  pi_socket_init(ps);
#line 434
  pi_log(2, 8, "%s: %d, prot: 0x%x, type: 0x%x, cmd: 0x%x.\n", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
         434, ps->protocol, ps->type, ps->cmd);
  }
#line 435
  if (ps->type == 16) {
    {
#line 440
    if (ps->cmd == 1) {
#line 440
      goto case_1;
    }
#line 476
    if (ps->cmd == 2) {
#line 476
      goto case_2;
    }
#line 485
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 441
    pi_log(2, 8, "%s: %d, cmp rx.\n", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
           441);
#line 442
    result = cmp_rx_handshake(ps, data->establishrate, data->establishhighrate);
    }
#line 442
    if (result < 0) {
      {
#line 444
      pi_log(2, 8, "usb.c: cmp_rx_handshake returned %d\n", result);
      }
#line 445
      return (result);
    }
    {
#line 449
    size = sizeof(cmp_flags);
#line 450
    pi_getsockopt(ps->sd, 5, 1, (void *)(& cmp_flags), & size);
    }
#line 451
    if ((int )cmp_flags & 16) {
      {
#line 452
      use_long_format = 1;
#line 453
      size = sizeof(int );
#line 454
      pi_setsockopt(ps->sd, 2, 3, (void const   *)(& use_long_format), & size);
#line 456
      ps->command ^= 1;
#line 457
      pi_setsockopt(ps->sd, 2, 3, (void const   *)(& use_long_format), & size);
#line 459
      ps->command ^= 1;
      }
    }
    {
#line 463
    size = sizeof(data->rate);
#line 464
    pi_getsockopt(ps->sd, 5, 3, (void *)(& data->rate), & size);
    }
#line 465
    if ((unsigned long )data->impl.changebaud != (unsigned long )((void *)0)) {
      {
#line 466
      result = (*(data->impl.changebaud))(ps);
      }
#line 466
      if (result < 0) {
#line 467
        return (result);
      }
      {
#line 470
      tv.tv_sec = (__time_t )0;
#line 471
      tv.tv_usec = (__suseconds_t )50000;
#line 472
      select(0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0,
             (struct timeval */* __restrict  */)(& tv));
      }
    }
#line 474
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 477
    pi_log(2, 8, "%s: %d, net rx.\n", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
           477);
#line 478
    result = net_rx_handshake(ps);
    }
#line 478
    if (result < 0) {
      {
#line 480
      pi_log(2, 8, "usb.c: cmp_rx_handshake returned %d\n", result);
      }
#line 481
      return (result);
    }
#line 483
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 486
    pi_log(2, 1, "%s: %d, unknown rx %x.\n", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
           486, ps->cmd);
    }
#line 487
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 489
    ps->dlprecord = 0;
  }
#line 492
  data->timeout = 0;
#line 493
  ps->command = 0;
#line 494
  ps->state = 2;
#line 495
  return (ps->sd);
}
}
#line 509 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_getsockopt___1(pi_socket_t *ps , int level , int option_name , void *option_value ,
                                 size_t *option_len ) 
{ 
  pi_usb_data_t *data ;
  int *tmp ;
  int tmp___0 ;

  {
#line 513
  data = (pi_usb_data_t *)(ps->device)->data;
  {
#line 516
  if (option_name == 0) {
#line 516
    goto case_0;
  }
#line 522
  if (option_name == 1) {
#line 522
    goto case_1;
  }
#line 529
  if (option_name == 2) {
#line 529
    goto case_2;
  }
#line 536
  if (option_name == 3) {
#line 536
    goto case_3;
  }
#line 515
  goto switch_break;
  case_0: /* CIL Label */ 
#line 517
  if (*option_len != sizeof(data->rate)) {
#line 518
    goto fail;
  }
  {
#line 519
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->rate),
         sizeof(data->rate));
  }
#line 520
  goto switch_break;
  case_1: /* CIL Label */ 
#line 523
  if (*option_len != sizeof(data->establishrate)) {
#line 524
    goto fail;
  }
  {
#line 525
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->establishrate),
         sizeof(data->establishrate));
  }
#line 527
  goto switch_break;
  case_2: /* CIL Label */ 
#line 530
  if (*option_len != sizeof(data->establishhighrate)) {
#line 531
    goto fail;
  }
  {
#line 532
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->establishhighrate),
         sizeof(data->establishhighrate));
  }
#line 534
  goto switch_break;
  case_3: /* CIL Label */ 
#line 537
  if (*option_len != sizeof(data->timeout)) {
#line 538
    goto fail;
  }
  {
#line 539
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->timeout),
         sizeof(data->timeout));
  }
#line 541
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 544
  return (0);
  fail: 
  {
#line 547
  tmp = __errno_location();
#line 547
  *tmp = 22;
#line 548
  tmp___0 = pi_set_error(ps->sd, -501);
  }
#line 548
  return (tmp___0);
}
}
#line 562 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_setsockopt___1(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                                 size_t *option_len ) 
{ 
  pi_usb_data_t *data ;
  int *tmp ;
  int tmp___0 ;

  {
#line 566
  data = (pi_usb_data_t *)(ps->device)->data;
  {
#line 569
  if (option_name == 1) {
#line 569
    goto case_1;
  }
#line 576
  if (option_name == 2) {
#line 576
    goto case_2;
  }
#line 583
  if (option_name == 3) {
#line 583
    goto case_3;
  }
#line 568
  goto switch_break;
  case_1: /* CIL Label */ 
#line 570
  if (*option_len != sizeof(data->establishrate)) {
#line 571
    goto fail;
  }
  {
#line 572
  memcpy((void */* __restrict  */)(& data->establishrate), (void const   */* __restrict  */)option_value,
         sizeof(data->establishrate));
  }
#line 574
  goto switch_break;
  case_2: /* CIL Label */ 
#line 577
  if (*option_len != sizeof(data->establishhighrate)) {
#line 578
    goto fail;
  }
  {
#line 579
  memcpy((void */* __restrict  */)(& data->establishhighrate), (void const   */* __restrict  */)option_value,
         sizeof(data->establishhighrate));
  }
#line 581
  goto switch_break;
  case_3: /* CIL Label */ 
#line 584
  if (*option_len != sizeof(data->timeout)) {
#line 585
    goto fail;
  }
  {
#line 586
  memcpy((void */* __restrict  */)(& data->timeout), (void const   */* __restrict  */)option_value,
         sizeof(data->timeout));
  }
#line 588
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 591
  return (0);
  fail: 
  {
#line 594
  tmp = __errno_location();
#line 594
  *tmp = 22;
#line 595
  tmp___0 = pi_set_error(ps->sd, -501);
  }
#line 595
  return (tmp___0);
}
}
#line 610 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_close___1(pi_socket_t *ps ) 
{ 
  pi_usb_data_t *data ;

  {
#line 613
  data = (pi_usb_data_t *)(ps->device)->data;
#line 615
  if (ps->sd != 0) {
    {
#line 616
    (*(data->impl.close))(ps);
#line 617
    ps->sd = 0;
    }
  }
#line 620
  if ((unsigned long )ps->laddr != (unsigned long )((void *)0)) {
    {
#line 621
    free((void *)ps->laddr);
#line 622
    ps->laddr = (struct sockaddr *)((void *)0);
    }
  }
#line 624
  if ((unsigned long )ps->raddr != (unsigned long )((void *)0)) {
    {
#line 625
    free((void *)ps->raddr);
#line 626
    ps->raddr = (struct sockaddr *)((void *)0);
    }
  }
#line 629
  return (0);
}
}
#line 982 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int USB_configure_visor___1(pi_usb_data_t *dev , u_int8_t *input_pipe , u_int8_t *output_pipe ) 
{ 
  int i ;
  int ret ;
  visor_connection_info_t ci ;
  char *function_str ;

  {
  {
#line 988
  ret = (*(dev->impl.control_request))(dev, 194, 3, 0, 0, (void *)(& ci), (int )sizeof(ci),
                                       0);
  }
#line 989
  if (ret < 0) {
    {
#line 990
    pi_log(2, 1, "usb: VISOR_GET_CONNECTION_INFORMATION failed (err=%08x)\n", ret);
    }
  } else {
    {
#line 992
    pi_log(2, 8, "usb: VISOR_GET_CONNECTION_INFORMATION, num_ports=%d\n", (int )ci.num_ports);
    }
#line 993
    if ((int )ci.num_ports > 2) {
#line 994
      ci.num_ports = (u_int16_t )2;
    }
#line 995
    i = 0;
    {
#line 995
    while (1) {
      while_continue: /* CIL Label */ ;
#line 995
      if (! (i < (int )ci.num_ports)) {
#line 995
        goto while_break;
      }
      {
#line 1000
      if ((int )ci.connections[i].port_function_id == 0) {
#line 1000
        goto case_0;
      }
#line 1003
      if ((int )ci.connections[i].port_function_id == 1) {
#line 1003
        goto case_1;
      }
#line 1006
      if ((int )ci.connections[i].port_function_id == 2) {
#line 1006
        goto case_2;
      }
#line 1009
      if ((int )ci.connections[i].port_function_id == 3) {
#line 1009
        goto case_3;
      }
#line 1012
      if ((int )ci.connections[i].port_function_id == 4) {
#line 1012
        goto case_4;
      }
#line 1015
      goto switch_default;
      case_0: /* CIL Label */ 
#line 1001
      function_str = (char *)"GENERIC";
#line 1002
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1004
      function_str = (char *)"DEBUGGER";
#line 1005
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1007
      function_str = (char *)"HOTSYNC";
#line 1008
      goto switch_break;
      case_3: /* CIL Label */ 
#line 1010
      function_str = (char *)"CONSOLE";
#line 1011
      goto switch_break;
      case_4: /* CIL Label */ 
#line 1013
      function_str = (char *)"REMOTE_FILE_SYSTEM";
#line 1014
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1016
      function_str = (char *)"UNKNOWN";
#line 1017
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 1019
      pi_log(2, 8, "\t[%d] port_function_id=0x%02x (%s)\n", i, (int )ci.connections[i].port_function_id,
             function_str);
#line 1023
      pi_log(2, 8, "\t[%d] port=%d\n", i, (int )ci.connections[i].port);
#line 995
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1027
  return (ret);
}
}
#line 1030 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int USB_configure_generic___1(pi_usb_data_t *dev , u_int8_t *input_pipe , u_int8_t *output_pipe ) 
{ 
  int i ;
  int ret ;
  int hotsync ;
  palm_ext_connection_info_t ci ;
  u_int32_t flags ;
  int tmp ;

  {
  {
#line 1034
  hotsync = 0;
#line 1036
  flags = dev->dev.flags;
#line 1038
  ret = (*(dev->impl.control_request))(dev, 194, 4, 0, 0, (void *)(& ci), (int )sizeof(ci),
                                       0);
  }
#line 1039
  if (ret < 0) {
    {
#line 1040
    pi_log(2, 1, "usb: PALM_GET_EXT_CONNECTION_INFORMATION failed (err=%08x)\n", ret);
    }
  } else {
    {
#line 1042
    pi_log(2, 8, "usb: PALM_GET_EXT_CONNECTION_INFORMATION, num_ports=%d, endpoint_numbers_different=%d\n",
           (int )ci.num_ports, (int )ci.endpoint_numbers_different);
#line 1045
    i = 0;
    }
    {
#line 1045
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1045
      if (! (i < (int )ci.num_ports)) {
#line 1045
        goto while_break;
      }
      {
#line 1046
      pi_log(2, 8, "\t[%d] port_function_id=\'%c%c%c%c\'\n", i, (int )ci.connections[i].port_function_id[0],
             (int )ci.connections[i].port_function_id[1], (int )ci.connections[i].port_function_id[2],
             (int )ci.connections[i].port_function_id[3]);
#line 1052
      pi_log(2, 8, "\t[%d] port=%d\n", i, (int )ci.connections[i].port);
#line 1055
      pi_log(2, 8, "\t[%d] endpoint_info=%d\n", i, (int )ci.connections[i].endpoint_info);
#line 1057
      tmp = memcmp((void const   *)(ci.connections[i].port_function_id), (void const   *)"cnys",
                   (size_t )4);
      }
#line 1057
      if (! tmp) {
#line 1060
        hotsync = 1;
#line 1064
        if (ci.endpoint_numbers_different) {
#line 1065
          if (input_pipe) {
#line 1066
            *input_pipe = (u_int8_t )((int )ci.connections[i].endpoint_info >> 4);
          }
#line 1067
          if (output_pipe) {
#line 1068
            *output_pipe = (u_int8_t )((int )ci.connections[i].endpoint_info & 15);
          }
        } else {
#line 1070
          if (input_pipe) {
#line 1071
            *input_pipe = ci.connections[i].port;
          }
#line 1072
          if (output_pipe) {
#line 1073
            *output_pipe = ci.connections[i].port;
          }
        }
      }
#line 1045
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1078
    if (! hotsync) {
      {
#line 1079
      pi_log(2, 1, "usb: PALM_GET_EXT_CONNECTION_INFORMATION - no hotsync port found.\n",
             ret);
      }
#line 1080
      return (-1);
    }
  }
#line 1084
  if (flags & (unsigned int )(1 << 1)) {
    {
#line 1089
    ret = (*(dev->impl.control_request))(dev, 194, 4, 0, 0, (void *)(& ci), (int )sizeof(ci),
                                         0);
#line 1090
    ret = (*(dev->impl.control_request))(dev, 194, 4, 0, 0, (void *)(& ci), (int )sizeof(ci),
                                         0);
    }
  }
#line 1092
  return (ret);
}
}
#line 291 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/utils.c"
static char buf___1[5]  ;
#line 63 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_list_t *ps_list_append___1(pi_socket_list_t *list , pi_socket_t *ps ) ;
#line 65
static pi_socket_t *ps_list_find___1(pi_socket_list_t *list , int pi_sd ) ;
#line 67
static pi_socket_list_t *ps_list_remove___1(pi_socket_list_t *list , int pi_sd ) ;
#line 69
static pi_socket_list_t *ps_list_copy___1(pi_socket_list_t *list ) ;
#line 70
static void ps_list_free___1(pi_socket_list_t *list ) ;
#line 72
static void protocol_queue_add___1(pi_socket_t *ps , pi_protocol_t *prot ) ;
#line 73
static void protocol_cmd_queue_add___1(pi_socket_t *ps , pi_protocol_t *prot ) ;
#line 74
static pi_protocol_t *protocol_queue_find___1(pi_socket_t *ps , int level ) ;
#line 75
static pi_protocol_t *protocol_queue_find_next___1(pi_socket_t *ps , int level ) ;
#line 79
static int is_connected___1(pi_socket_t *ps ) ;
#line 80
static int is_listener___1(pi_socket_t *ps ) ;
#line 83 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static int psl_mutex___1  =    0;
#line 84 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_list_t *psl___1  =    (pi_socket_list_t *)((void *)0);
#line 86 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static int watch_list_mutex___1  =    0;
#line 87 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_list_t *watch_list___1  =    (pi_socket_list_t *)((void *)0);
#line 90 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static unsigned int interval___1  =    0U;
#line 133 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_list_t *ps_list_append___1(pi_socket_list_t *list , pi_socket_t *ps ) 
{ 
  pi_socket_list_t *elem ;
  pi_socket_list_t *new_elem ;
  void *tmp ;

  {
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! ((unsigned long )ps != (unsigned long )((void *)0))) {
      {
#line 138
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c",
             138, "ps != NULL");
      }
    }
#line 138
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 140
  tmp = malloc(sizeof(pi_socket_list_t ));
#line 140
  new_elem = (pi_socket_list_t *)tmp;
  }
#line 141
  if ((unsigned long )new_elem == (unsigned long )((void *)0)) {
#line 142
    return (list);
  }
#line 144
  new_elem->ps = ps;
#line 145
  new_elem->next = (struct pi_socket_list *)((void *)0);
#line 147
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 148
    return (new_elem);
  }
#line 150
  elem = list;
  {
#line 151
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 151
    if (! ((unsigned long )elem->next != (unsigned long )((void *)0))) {
#line 151
      goto while_break___0;
    }
#line 152
    elem = elem->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 153
  elem->next = new_elem;
#line 155
  return (list);
}
}
#line 177 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_t *ps_list_find___1(pi_socket_list_t *list , int pi_sd ) 
{ 
  pi_socket_list_t *elem ;

  {
#line 182
  elem = list;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! ((unsigned long )elem != (unsigned long )((void *)0))) {
#line 182
      goto while_break;
    }
#line 183
    if ((unsigned long )elem->ps != (unsigned long )((void *)0)) {
#line 183
      if ((elem->ps)->sd == pi_sd) {
#line 184
        return (elem->ps);
      }
    }
#line 182
    elem = elem->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return ((pi_socket_t *)((void *)0));
}
}
#line 207 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_list_t *ps_list_remove___1(pi_socket_list_t *list , int pi_sd ) 
{ 
  pi_socket_list_t *elem ;
  pi_socket_list_t *new_list ;
  pi_socket_list_t *prev_elem ;

  {
#line 210
  new_list = list;
#line 210
  prev_elem = (pi_socket_list_t *)((void *)0);
#line 214
  elem = list;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! ((unsigned long )elem != (unsigned long )((void *)0))) {
#line 214
      goto while_break;
    }
#line 215
    if ((unsigned long )elem->ps == (unsigned long )((void *)0)) {
#line 216
      goto __Cont;
    } else
#line 217
    if ((elem->ps)->sd == pi_sd) {
#line 218
      if ((unsigned long )prev_elem == (unsigned long )((void *)0)) {
#line 219
        new_list = elem->next;
      } else {
#line 221
        prev_elem->next = elem->next;
      }
      {
#line 222
      free((void *)elem);
      }
#line 223
      goto while_break;
    }
#line 225
    prev_elem = elem;
    __Cont: /* CIL Label */ 
#line 214
    elem = elem->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  return (new_list);
}
}
#line 246 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_list_t *ps_list_copy___1(pi_socket_list_t *list ) 
{ 
  pi_socket_list_t *l ;
  pi_socket_list_t *new_list ;

  {
#line 249
  new_list = (pi_socket_list_t *)((void *)0);
#line 251
  l = list;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 251
      goto while_break;
    }
    {
#line 252
    new_list = ps_list_append___1(new_list, l->ps);
#line 251
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  return (new_list);
}
}
#line 274 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void ps_list_free___1(pi_socket_list_t *list ) 
{ 
  pi_socket_list_t *l ;
  pi_socket_list_t *next ;

  {
#line 279
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 280
    return;
  }
#line 282
  l = list;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 284
    next = l->next;
#line 285
    free((void *)l);
#line 286
    l = next;
    }
#line 283
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 283
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return;
}
}
#line 302 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void protocol_queue_add___1(pi_socket_t *ps , pi_protocol_t *prot ) 
{ 
  void *tmp ;
  int *tmp___0 ;

  {
  {
#line 305
  tmp = realloc((void *)ps->protocol_queue, sizeof(pi_protocol_t *) * (unsigned long )(ps->queue_len + 1));
#line 305
  ps->protocol_queue = (struct pi_protocol **)tmp;
  }
#line 307
  if ((unsigned long )ps->protocol_queue != (unsigned long )((void *)0)) {
#line 308
    *(ps->protocol_queue + ps->queue_len) = prot;
#line 309
    (ps->queue_len) ++;
  } else {
    {
#line 311
    tmp___0 = __errno_location();
#line 311
    *tmp___0 = 12;
#line 312
    ps->queue_len = 0;
    }
  }
#line 314
  return;
}
}
#line 328 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void protocol_cmd_queue_add___1(pi_socket_t *ps , pi_protocol_t *prot ) 
{ 
  void *tmp ;
  int *tmp___0 ;

  {
  {
#line 331
  tmp = realloc((void *)ps->cmd_queue, sizeof(pi_protocol_t *) * (unsigned long )(ps->cmd_len + 1));
#line 331
  ps->cmd_queue = (struct pi_protocol **)tmp;
  }
#line 333
  if ((unsigned long )ps->cmd_queue != (unsigned long )((void *)0)) {
#line 334
    *(ps->cmd_queue + ps->cmd_len) = prot;
#line 335
    (ps->cmd_len) ++;
  } else {
    {
#line 337
    tmp___0 = __errno_location();
#line 337
    *tmp___0 = 12;
#line 338
    ps->cmd_len = 0;
    }
  }
#line 340
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_protocol_t *protocol_queue_find___1(pi_socket_t *ps , int level ) 
{ 
  int i ;

  {
#line 359
  if (ps->command) {
#line 360
    i = 0;
    {
#line 360
    while (1) {
      while_continue: /* CIL Label */ ;
#line 360
      if (! (i < ps->cmd_len)) {
#line 360
        goto while_break;
      }
#line 361
      if ((*(ps->cmd_queue + i))->level == level) {
#line 362
        return (*(ps->cmd_queue + i));
      }
#line 360
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 365
    i = 0;
    {
#line 365
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 365
      if (! (i < ps->queue_len)) {
#line 365
        goto while_break___0;
      }
#line 366
      if ((*(ps->protocol_queue + i))->level == level) {
#line 367
        return (*(ps->protocol_queue + i));
      }
#line 365
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 371
  return ((pi_protocol_t *)((void *)0));
}
}
#line 386 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_protocol_t *protocol_queue_find_next___1(pi_socket_t *ps , int level ) 
{ 
  int i ;

  {
#line 391
  if (ps->command) {
#line 391
    if (ps->cmd_len == 0) {
#line 392
      return ((pi_protocol_t *)((void *)0));
    }
  }
#line 394
  if (! ps->command) {
#line 394
    if (ps->queue_len == 0) {
#line 395
      return ((pi_protocol_t *)((void *)0));
    }
  }
#line 397
  if (ps->command) {
#line 397
    if (level == 0) {
#line 398
      return (*(ps->cmd_queue + 0));
    }
  }
#line 400
  if (! ps->command) {
#line 400
    if (level == 0) {
#line 401
      return (*(ps->protocol_queue + 0));
    }
  }
#line 403
  if (ps->command) {
#line 404
    i = 0;
    {
#line 404
    while (1) {
      while_continue: /* CIL Label */ ;
#line 404
      if (! (i < ps->cmd_len - 1)) {
#line 404
        goto while_break;
      }
#line 405
      if ((*(ps->cmd_queue + i))->level == level) {
#line 406
        return (*(ps->cmd_queue + (i + 1)));
      }
#line 404
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 409
    i = 0;
    {
#line 409
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 409
      if (! (i < ps->queue_len - 1)) {
#line 409
        goto while_break___0;
      }
#line 410
      if ((*(ps->protocol_queue + i))->level == level) {
#line 411
        return (*(ps->protocol_queue + (i + 1)));
      }
#line 409
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 415
  return ((pi_protocol_t *)((void *)0));
}
}
#line 430 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void protocol_queue_build___1(pi_socket_t *ps , int autodetect ) 
{ 
  int protocol ;
  int result ;
  pi_protocol_t *dev_prot ;
  pi_protocol_t *dev_cmd_prot ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int skipped_bytes ;
  int bytes_to_skip ;
  pi_buffer_t *detect_buf ;
  pi_buffer_t *tmp___5 ;
  ssize_t tmp___6 ;
  int i ;
  unsigned char header_checksum ;
  ssize_t tmp___7 ;
  pi_protocol_t *tmp___8 ;
  pi_protocol_t *tmp___9 ;
  pi_protocol_t *tmp___10 ;
  pi_protocol_t *tmp___11 ;
  pi_protocol_t *tmp___12 ;
  pi_protocol_t *tmp___13 ;
  pi_protocol_t *tmp___14 ;
  pi_protocol_t *tmp___15 ;
  pi_protocol_t *tmp___16 ;

  {
  {
#line 439
  pi_log(128, 8, "SOCK fd=%d auto=%d\n", ps->sd, autodetect);
#line 442
  dev_prot = (*((ps->device)->protocol))(ps->device);
#line 443
  dev_cmd_prot = (*((ps->device)->protocol))(ps->device);
  }
#line 446
  if (ps->type == 48) {
    {
#line 447
    pi_log(128, 8, "RAW mode, no protocol\n", ps->sd, autodetect);
#line 448
    protocol_queue_add___1(ps, dev_prot);
#line 449
    protocol_cmd_queue_add___1(ps, dev_cmd_prot);
    }
#line 450
    return;
  }
#line 453
  protocol = ps->protocol;
#line 455
  if (protocol == 1) {
#line 455
    tmp___4 = "DEV";
  } else {
#line 455
    if (protocol == 2) {
#line 455
      tmp___3 = "SLP";
    } else {
#line 455
      if (protocol == 3) {
#line 455
        tmp___2 = "SYS";
      } else {
#line 455
        if (protocol == 4) {
#line 455
          tmp___1 = "PADP";
        } else {
#line 455
          if (protocol == 5) {
#line 455
            tmp___0 = "NET";
          } else {
#line 455
            if (protocol == 6) {
#line 455
              tmp = "DLP";
            } else {
#line 455
              tmp = "unknown";
            }
#line 455
            tmp___0 = tmp;
          }
#line 455
          tmp___1 = tmp___0;
        }
#line 455
        tmp___2 = tmp___1;
      }
#line 455
      tmp___3 = tmp___2;
    }
#line 455
    tmp___4 = tmp___3;
  }
  {
#line 455
  pi_log(128, 8, "SOCK proto=%s (%d)\n", tmp___4, protocol);
  }
#line 464
  if (protocol == 6) {
#line 464
    if (autodetect) {
      {
#line 465
      skipped_bytes = 0;
#line 467
      tmp___5 = pi_buffer_new((size_t )64);
#line 467
      detect_buf = tmp___5;
      }
      {
#line 470
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 472
        tmp___6 = (*(dev_prot->read))(ps, detect_buf, (size_t )10, 1);
#line 472
        result = (int )tmp___6;
        }
#line 473
        if (result < 0) {
#line 474
          goto while_break;
        }
#line 475
        if (result != 10) {
          {
#line 476
          pi_buffer_clear(detect_buf);
          }
#line 477
          goto __Cont;
        }
#line 480
        bytes_to_skip = 1;
#line 483
        if ((int )*(detect_buf->data + 0) == 190) {
#line 483
          if ((int )*(detect_buf->data + 1) == 239) {
#line 483
            if ((int )*(detect_buf->data + 2) == 237) {
#line 490
              i = 0;
#line 490
              header_checksum = (unsigned char )i;
              {
#line 490
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 490
                if (! (i < 9)) {
#line 490
                  goto while_break___0;
                }
#line 491
                header_checksum = (unsigned char )((int )header_checksum + (int )*(detect_buf->data + i));
#line 490
                i ++;
              }
              while_break___0: /* CIL Label */ ;
              }
#line 493
              if ((int )header_checksum == (int )*(detect_buf->data + 9)) {
#line 494
                if ((int )*(detect_buf->data + 3) == 3) {
#line 494
                  if ((int )*(detect_buf->data + 4) == 3) {
#line 494
                    if ((int )*(detect_buf->data + 5) == 2) {
#line 494
                      if ((int )*(detect_buf->data + 8) == 255) {
                        {
#line 499
                        protocol = 4;
#line 500
                        pi_log(128, 4, "\nusing PADP/SLP protocol (skipped %d bytes)\n",
                               skipped_bytes);
                        }
#line 503
                        goto while_break;
                      } else {
#line 507
                        bytes_to_skip = 10;
                      }
                    } else {
#line 507
                      bytes_to_skip = 10;
                    }
                  } else {
#line 507
                    bytes_to_skip = 10;
                  }
                } else {
#line 507
                  bytes_to_skip = 10;
                }
              } else {
#line 511
                bytes_to_skip = 3;
              }
            } else {
#line 483
              goto _L___5;
            }
          } else {
#line 483
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 516
        if ((int )*(detect_buf->data + 0) == 1) {
#line 516
          if ((int )*(detect_buf->data + 2) == 0) {
#line 516
            if ((int )*(detect_buf->data + 3) == 0) {
#line 516
              if ((int )*(detect_buf->data + 4) == 0) {
#line 516
                if ((int )*(detect_buf->data + 5) > 0) {
#line 516
                  if ((int )*(detect_buf->data + 6) == 144) {
                    {
#line 523
                    protocol = 5;
#line 524
                    pi_log(128, 4, "\nusing NET protocol (skipped %d bytes)\n", skipped_bytes);
                    }
#line 527
                    goto while_break;
                  } else {
#line 516
                    goto _L___3;
                  }
                } else {
#line 516
                  goto _L___3;
                }
              } else {
#line 516
                goto _L___3;
              }
            } else {
#line 516
              goto _L___3;
            }
          } else {
#line 516
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 535
        if ((int )*(detect_buf->data + 0) == 144) {
#line 535
          if ((int )*(detect_buf->data + 1) == 1) {
#line 535
            if ((int )*(detect_buf->data + 2) == 0) {
#line 535
              if ((int )*(detect_buf->data + 3) == 0) {
#line 535
                if ((int )*(detect_buf->data + 4) == 0) {
#line 535
                  if ((int )*(detect_buf->data + 5) == 0) {
#line 535
                    if ((int )*(detect_buf->data + 6) == 0) {
#line 535
                      if ((int )*(detect_buf->data + 7) == 0) {
#line 535
                        if ((int )*(detect_buf->data + 8) == 0) {
#line 535
                          if ((int )*(detect_buf->data + 9) == 32) {
                            {
#line 546
                            protocol = 5;
#line 547
                            pi_log(128, 4, "\nusing NET protocol (skipped %d bytes)\n",
                                   skipped_bytes);
                            }
#line 550
                            goto while_break;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        {
#line 554
        tmp___7 = (*(dev_prot->read))(ps, detect_buf, (size_t )bytes_to_skip, 0);
#line 554
        result = (int )tmp___7;
        }
#line 555
        if (result < 0) {
#line 556
          goto while_break;
        }
        {
#line 557
        skipped_bytes += bytes_to_skip;
#line 558
        pi_buffer_clear(detect_buf);
        }
        __Cont: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 561
      pi_buffer_free(detect_buf);
      }
#line 563
      if (result < 0) {
        {
#line 568
        pi_log(128, 8, "Error: last read returned %d; switching to PADP by default\n",
               result);
#line 571
        protocol = 4;
        }
      }
    } else {
#line 464
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 574
  if (protocol == 6) {
#line 575
    protocol = 4;
  }
  {
#line 580
  if (protocol == 4) {
#line 580
    goto case_4;
  }
#line 582
  if (protocol == 2) {
#line 582
    goto case_2;
  }
#line 585
  if (protocol == 5) {
#line 585
    goto case_5;
  }
#line 588
  if (protocol == 3) {
#line 588
    goto case_3;
  }
#line 579
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 581
  tmp___8 = padp_protocol();
#line 581
  protocol_queue_add___1(ps, tmp___8);
  }
  case_2: /* CIL Label */ 
  {
#line 583
  tmp___9 = slp_protocol();
#line 583
  protocol_queue_add___1(ps, tmp___9);
  }
#line 584
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 586
  tmp___10 = net_protocol();
#line 586
  protocol_queue_add___1(ps, tmp___10);
  }
#line 587
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 589
  tmp___11 = sys_protocol();
#line 589
  protocol_queue_add___1(ps, tmp___11);
#line 590
  tmp___12 = slp_protocol();
#line 590
  protocol_queue_add___1(ps, tmp___12);
  }
#line 591
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 597
  if (protocol == 2) {
#line 597
    goto case_2___0;
  }
#line 597
  if (protocol == 4) {
#line 597
    goto case_2___0;
  }
#line 603
  if (protocol == 5) {
#line 603
    goto case_5___0;
  }
#line 607
  if (protocol == 3) {
#line 607
    goto case_3___0;
  }
#line 610
  goto switch_default;
  case_2___0: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  {
#line 598
  tmp___13 = cmp_protocol();
#line 598
  protocol_cmd_queue_add___1(ps, tmp___13);
#line 599
  tmp___14 = padp_protocol();
#line 599
  protocol_cmd_queue_add___1(ps, tmp___14);
#line 600
  tmp___15 = slp_protocol();
#line 600
  protocol_cmd_queue_add___1(ps, tmp___15);
#line 601
  ps->cmd = 1;
  }
#line 602
  goto switch_break___0;
  case_5___0: /* CIL Label */ 
  {
#line 604
  tmp___16 = net_protocol();
#line 604
  protocol_cmd_queue_add___1(ps, tmp___16);
#line 605
  ps->cmd = 2;
  }
#line 606
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 608
  ps->cmd = 3;
#line 609
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 611
  pi_log(128, 1, "invalid protocol (%d)", protocol);
  }
#line 612
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 615
  protocol_queue_add___1(ps, dev_prot);
#line 616
  protocol_cmd_queue_add___1(ps, dev_cmd_prot);
  }
#line 617
  return;
}
}
#line 631 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void protocol_queue_destroy___1(pi_socket_t *ps ) 
{ 
  int i ;

  {
#line 635
  i = 0;
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 635
    if (! (i < ps->queue_len)) {
#line 635
      goto while_break;
    }
    {
#line 636
    (*((*(ps->protocol_queue + i))->free))(*(ps->protocol_queue + i));
#line 635
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 637
  i = 0;
  {
#line 637
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 637
    if (! (i < ps->cmd_len)) {
#line 637
      goto while_break___0;
    }
    {
#line 638
    (*((*(ps->cmd_queue + i))->free))(*(ps->cmd_queue + i));
#line 637
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 640
  if (ps->queue_len > 0) {
    {
#line 641
    free((void *)ps->protocol_queue);
    }
  }
#line 642
  if (ps->cmd_len > 0) {
    {
#line 643
    free((void *)ps->cmd_queue);
    }
  }
#line 644
  return;
}
}
#line 697 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void env_dbgcheck___1(void) 
{ 
  int types ;
  int done ;
  char *debug ;
  char *b ;
  char *e ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int level ;
  char const   *debug___0 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  char const   *logfile ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;

  {
  {
#line 700
  tmp___11 = getenv("PILOT_DEBUG");
  }
#line 700
  if (tmp___11) {
    {
#line 701
    types = 0;
#line 707
    tmp = getenv("PILOT_DEBUG");
#line 707
    debug = strdup((char const   *)tmp);
#line 709
    b = debug;
#line 710
    done = 0;
    }
    {
#line 711
    while (1) {
      while_continue: /* CIL Label */ ;
#line 711
      if (! (! done)) {
#line 711
        goto while_break;
      }
      {
#line 712
      e = strchr((char const   *)b, ' ');
      }
#line 713
      if (e) {
#line 714
        *e = (char )'\000';
      } else {
#line 716
        done = 1;
      }
      {
#line 718
      tmp___10 = strcmp((char const   *)b, "SYS");
      }
#line 718
      if (tmp___10) {
        {
#line 720
        tmp___9 = strcmp((char const   *)b, "DEV");
        }
#line 720
        if (tmp___9) {
          {
#line 722
          tmp___8 = strcmp((char const   *)b, "SLP");
          }
#line 722
          if (tmp___8) {
            {
#line 724
            tmp___7 = strcmp((char const   *)b, "PADP");
            }
#line 724
            if (tmp___7) {
              {
#line 726
              tmp___6 = strcmp((char const   *)b, "DLP");
              }
#line 726
              if (tmp___6) {
                {
#line 728
                tmp___5 = strcmp((char const   *)b, "NET");
                }
#line 728
                if (tmp___5) {
                  {
#line 730
                  tmp___4 = strcmp((char const   *)b, "CMP");
                  }
#line 730
                  if (tmp___4) {
                    {
#line 732
                    tmp___3 = strcmp((char const   *)b, "SOCK");
                    }
#line 732
                    if (tmp___3) {
                      {
#line 734
                      tmp___2 = strcmp((char const   *)b, "API");
                      }
#line 734
                      if (tmp___2) {
                        {
#line 736
                        tmp___1 = strcmp((char const   *)b, "USER");
                        }
#line 736
                        if (tmp___1) {
                          {
#line 738
                          tmp___0 = strcmp((char const   *)b, "ALL");
                          }
#line 738
                          if (! tmp___0) {
#line 739
                            types |= 1024;
                          }
                        } else {
#line 737
                          types |= 512;
                        }
                      } else {
#line 735
                        types |= 256;
                      }
                    } else {
#line 733
                      types |= 128;
                    }
                  } else {
#line 731
                    types |= 64;
                  }
                } else {
#line 729
                  types |= 32;
                }
              } else {
#line 727
                types |= 16;
              }
            } else {
#line 725
              types |= 8;
            }
          } else {
#line 723
            types |= 4;
          }
        } else {
#line 721
          types |= 2;
        }
      } else {
#line 719
        types |= 1;
      }
#line 740
      e ++;
#line 741
      b = e;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 743
    pi_debug_set_types(types);
#line 745
    free((void *)debug);
    }
  }
  {
#line 749
  tmp___18 = getenv("PILOT_DEBUG_LEVEL");
  }
#line 749
  if (tmp___18) {
    {
#line 750
    level = 0;
#line 754
    tmp___12 = getenv("PILOT_DEBUG_LEVEL");
#line 754
    debug___0 = (char const   *)tmp___12;
#line 755
    tmp___17 = strcmp(debug___0, "NONE");
    }
#line 755
    if (tmp___17) {
      {
#line 757
      tmp___16 = strcmp(debug___0, "ERR");
      }
#line 757
      if (tmp___16) {
        {
#line 759
        tmp___15 = strcmp(debug___0, "WARN");
        }
#line 759
        if (tmp___15) {
          {
#line 761
          tmp___14 = strcmp(debug___0, "INFO");
          }
#line 761
          if (tmp___14) {
            {
#line 763
            tmp___13 = strcmp(debug___0, "DEBUG");
            }
#line 763
            if (! tmp___13) {
#line 764
              level |= 8;
            }
          } else {
#line 762
            level |= 4;
          }
        } else {
#line 760
          level |= 2;
        }
      } else {
#line 758
        level |= 1;
      }
    } else {
#line 756
      level = level;
    }
    {
#line 766
    pi_debug_set_level(level);
    }
  }
  {
#line 770
  tmp___20 = getenv("PILOT_LOG");
  }
#line 770
  if (tmp___20) {
    {
#line 770
    tmp___21 = getenv("PILOT_LOG");
#line 770
    tmp___22 = atoi((char const   *)tmp___21);
    }
#line 770
    if (tmp___22) {
      {
#line 773
      tmp___19 = getenv("PILOT_LOGFILE");
#line 773
      logfile = (char const   *)tmp___19;
      }
#line 774
      if ((unsigned long )logfile == (unsigned long )((void *)0)) {
        {
#line 775
        pi_debug_set_file("pilot-link.debug");
        }
      } else {
        {
#line 777
        pi_debug_set_file(logfile);
        }
      }
    }
  }
#line 779
  return;
}
}
#line 793 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static int is_connected___1(pi_socket_t *ps ) 
{ 
  int tmp ;

  {
#line 796
  if (ps->state == 4) {
#line 796
    tmp = 1;
  } else
#line 796
  if (ps->state == 2) {
#line 796
    tmp = 1;
  } else {
#line 796
    tmp = 0;
  }
#line 796
  return (tmp);
}
}
#line 810 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static int is_listener___1(pi_socket_t *ps ) 
{ 
  int tmp ;

  {
#line 813
  if (ps->state == 1) {
#line 813
    tmp = 1;
  } else {
#line 813
    tmp = 0;
  }
#line 813
  return (tmp);
}
}
#line 817 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void onalarm___1(int signo ) 
{ 
  pi_socket_list_t *l ;
  pi_socket_t *ps ;
  int tmp ;
  PI_ERR tmp___0 ;

  {
  {
#line 822
  signal(signo, & onalarm___1);
#line 824
  pi_mutex_lock(& watch_list_mutex___1);
#line 826
  l = watch_list___1;
  }
  {
#line 826
  while (1) {
    while_continue: /* CIL Label */ ;
#line 826
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 826
      goto while_break;
    }
    {
#line 827
    ps = l->ps;
#line 829
    tmp = is_connected___1(ps);
    }
#line 829
    if (! tmp) {
#line 830
      goto __Cont;
    }
    {
#line 832
    tmp___0 = pi_tickle(ps->sd);
    }
#line 832
    if (tmp___0 < 0) {
      {
#line 833
      pi_log(128, 4, "SOCKET Socket %d is busy during tickle\n", ps->sd);
#line 836
      alarm(1U);
      }
    } else {
      {
#line 838
      pi_log(128, 4, "SOCKET Tickling socket %d\n", ps->sd);
#line 840
      alarm(interval___1);
      }
    }
    __Cont: /* CIL Label */ 
#line 826
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 844
  pi_mutex_unlock(& watch_list_mutex___1);
  }
#line 845
  return;
}
}
#line 860 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void onexit___1(void) 
{ 
  pi_socket_list_t *l ;
  pi_socket_list_t *list ;

  {
  {
#line 866
  pi_mutex_lock(& psl_mutex___1);
#line 867
  list = ps_list_copy___1(psl___1);
#line 868
  pi_mutex_unlock(& psl_mutex___1);
#line 870
  l = list;
  }
  {
#line 870
  while (1) {
    while_continue: /* CIL Label */ ;
#line 870
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 870
      goto while_break;
    }
    {
#line 871
    pi_close((l->ps)->sd);
#line 870
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 873
  ps_list_free___1(list);
  }
#line 874
  return;
}
}
#line 888 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void installexit___1(void) 
{ 


  {
#line 891
  if (! pi_sock_installedexit) {
    {
#line 892
    atexit(& onexit___1);
#line 893
    pi_sock_installedexit = 1;
    }
  }
#line 895
  return;
}
}
#line 1020 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_t *pi_devsocket___1(int pi_sd , char const   *port , struct pi_sockaddr *addr ) 
{ 
  pi_socket_t *ps ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1025
  ps = find_pi_socket(pi_sd);
  }
#line 1025
  if (! ps) {
    {
#line 1026
    tmp = __errno_location();
#line 1026
    *tmp = 3;
    }
#line 1027
    return ((pi_socket_t *)((void *)0));
  }
#line 1030
  if ((unsigned long )port == (unsigned long )((void *)0)) {
    {
#line 1030
    tmp___1 = getenv("PILOTPORT");
#line 1030
    port = (char const   *)tmp___1;
    }
#line 1030
    if ((unsigned long )port == (unsigned long )((void *)0)) {
      {
#line 1031
      tmp___0 = __errno_location();
#line 1031
      *tmp___0 = 6;
      }
#line 1032
      return ((pi_socket_t *)((void *)0));
    }
  }
  {
#line 1036
  addr->pi_family = (unsigned short)0;
#line 1037
  tmp___4 = strncmp(port, "serial:", (size_t )7);
  }
#line 1037
  if (tmp___4) {
    {
#line 1041
    tmp___3 = strncmp(port, "usb:", (size_t )4);
    }
#line 1041
    if (tmp___3) {
      {
#line 1045
      tmp___2 = strncmp(port, "net:", (size_t )4);
      }
#line 1045
      if (tmp___2) {
        {
#line 1055
        strncpy((char */* __restrict  */)(addr->pi_device), (char const   */* __restrict  */)port,
                sizeof(addr->pi_device));
#line 1056
        ps->device = pi_serial_device(1);
        }
      } else {
        {
#line 1046
        strncpy((char */* __restrict  */)(addr->pi_device), (char const   */* __restrict  */)(port + 4),
                sizeof(addr->pi_device));
#line 1047
        ps->device = pi_inet_device(1);
        }
      }
    } else {
      {
#line 1042
      strncpy((char */* __restrict  */)(addr->pi_device), (char const   */* __restrict  */)(port + 4),
              sizeof(addr->pi_device));
#line 1043
      ps->device = pi_usb_device(1);
      }
    }
  } else {
    {
#line 1038
    strncpy((char */* __restrict  */)(addr->pi_device), (char const   */* __restrict  */)(port + 7),
            sizeof(addr->pi_device));
#line 1039
    ps->device = pi_serial_device(1);
    }
  }
#line 1059
  return (ps);
}
}
#line 40 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
static int cmp_flush___1(pi_socket_t *ps , int flags ) ;
#line 41
static int cmp_getsockopt___1(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) ;
#line 43
static int cmp_setsockopt___1(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) ;
#line 46
static pi_protocol_t *cmp_protocol_dup___1(pi_protocol_t *prot ) ;
#line 47
static void cmp_protocol_free___1(pi_protocol_t *prot ) ;
#line 61 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
static pi_protocol_t *cmp_protocol_dup___1(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  struct pi_cmp_data *data ;
  struct pi_cmp_data *new_data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 69
  tmp = malloc(sizeof(pi_protocol_t ));
#line 69
  new_prot = (pi_protocol_t *)tmp;
#line 70
  tmp___0 = malloc(sizeof(struct pi_cmp_data ));
#line 70
  new_data = (struct pi_cmp_data *)tmp___0;
  }
#line 72
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 72
    if ((unsigned long )new_data != (unsigned long )((void *)0)) {
#line 73
      new_prot->level = prot->level;
#line 74
      new_prot->dup = prot->dup;
#line 75
      new_prot->free = prot->free;
#line 76
      new_prot->read = prot->read;
#line 77
      new_prot->write = prot->write;
#line 78
      new_prot->flush = prot->flush;
#line 79
      new_prot->getsockopt = prot->getsockopt;
#line 80
      new_prot->setsockopt = prot->setsockopt;
#line 82
      data = (struct pi_cmp_data *)prot->data;
#line 83
      new_data->type = data->type;
#line 84
      new_data->flags = data->flags;
#line 85
      new_data->version = data->version;
#line 86
      new_data->baudrate = data->baudrate;
#line 88
      new_prot->data = (void *)new_data;
    } else {
#line 72
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 90
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
    {
#line 91
    free((void *)new_prot);
#line 92
    new_prot = (pi_protocol_t *)((void *)0);
    }
  } else
#line 93
  if ((unsigned long )new_data != (unsigned long )((void *)0)) {
    {
#line 94
    free((void *)new_data);
#line 95
    new_data = (struct pi_cmp_data *)((void *)0);
    }
  }
#line 98
  return (new_prot);
}
}
#line 113 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
static void cmp_protocol_free___1(pi_protocol_t *prot ) 
{ 


  {
#line 116
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 117
    if ((unsigned long )prot->data != (unsigned long )((void *)0)) {
      {
#line 118
      free(prot->data);
      }
    }
    {
#line 119
    free((void *)prot);
    }
  }
#line 121
  return;
}
}
#line 391 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
static int cmp_flush___1(pi_socket_t *ps , int flags ) 
{ 
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 397
  prot = pi_protocol(ps->sd, 5);
  }
#line 398
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 399
    tmp = pi_set_error(ps->sd, -201);
    }
#line 399
    return (tmp);
  }
  {
#line 401
  next = pi_protocol_next(ps->sd, 5);
  }
#line 402
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 403
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 403
    return (tmp___0);
  }
  {
#line 405
  tmp___1 = (*(next->flush))(ps, flags);
  }
#line 405
  return (tmp___1);
}
}
#line 511 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
static int cmp_getsockopt___1(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  struct pi_cmp_data *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 520
  prot = pi_protocol(ps->sd, 5);
  }
#line 521
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 522
    tmp = pi_set_error(ps->sd, -201);
    }
#line 522
    return (tmp);
  }
#line 523
  data = (struct pi_cmp_data *)prot->data;
  {
#line 526
  if (option_name == 0) {
#line 526
    goto case_0;
  }
#line 534
  if (option_name == 1) {
#line 534
    goto case_1;
  }
#line 542
  if (option_name == 2) {
#line 542
    goto case_2;
  }
#line 550
  if (option_name == 3) {
#line 550
    goto case_3;
  }
#line 525
  goto switch_break;
  case_0: /* CIL Label */ 
#line 527
  if (*option_len != sizeof(data->type)) {
#line 528
    goto error;
  }
  {
#line 529
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->type),
         sizeof(data->type));
#line 531
  *option_len = sizeof(data->type);
  }
#line 532
  goto switch_break;
  case_1: /* CIL Label */ 
#line 535
  if (*option_len != sizeof(data->flags)) {
#line 536
    goto error;
  }
  {
#line 537
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->flags),
         sizeof(data->flags));
#line 539
  *option_len = sizeof(data->flags);
  }
#line 540
  goto switch_break;
  case_2: /* CIL Label */ 
#line 543
  if (*option_len != sizeof(data->version)) {
#line 544
    goto error;
  }
  {
#line 545
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->version),
         sizeof(data->version));
#line 547
  *option_len = sizeof(data->version);
  }
#line 548
  goto switch_break;
  case_3: /* CIL Label */ 
#line 551
  if (*option_len != sizeof(data->baudrate)) {
#line 552
    goto error;
  }
  {
#line 553
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->baudrate),
         sizeof(data->baudrate));
#line 555
  *option_len = sizeof(data->baudrate);
  }
#line 556
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 559
  return (0);
  error: 
  {
#line 562
  tmp___0 = __errno_location();
#line 562
  *tmp___0 = 22;
#line 563
  tmp___1 = pi_set_error(ps->sd, -501);
  }
#line 563
  return (tmp___1);
}
}
#line 578 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
static int cmp_setsockopt___1(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  struct pi_padp_data *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 587
  prot = pi_protocol(ps->sd, 2);
  }
#line 588
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 589
    tmp = pi_set_error(ps->sd, -201);
    }
#line 589
    return (tmp);
  }
#line 590
  data = (struct pi_padp_data *)prot->data;
#line 592
  if (option_name == 0) {
#line 593
    if (*option_len != sizeof(data->type)) {
#line 594
      goto error;
    }
    {
#line 595
    memcpy((void */* __restrict  */)(& data->type), (void const   */* __restrict  */)option_value,
           sizeof(data->type));
#line 597
    *option_len = sizeof(data->type);
    }
  }
#line 600
  return (0);
  error: 
  {
#line 603
  tmp___0 = __errno_location();
#line 603
  *tmp___0 = 22;
#line 604
  tmp___1 = pi_set_error(ps->sd, -501);
  }
#line 604
  return (tmp___1);
}
}
#line 49 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_open___1(pi_socket_t *ps , struct pi_sockaddr *addr , size_t addrlen ) ;
#line 50
static int u_close___1(pi_socket_t *ps ) ;
#line 51
static int u_write___1(pi_socket_t *ps , unsigned char *buf___3 , size_t len , int flags ) ;
#line 52
static int u_read___1(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) ;
#line 53
static int u_poll___1(pi_socket_t *ps , int timeout ) ;
#line 54
static int u_flush___1(pi_socket_t *ps , int flags ) ;
#line 83 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_open___1(pi_socket_t *ps , struct pi_sockaddr *addr , size_t addrlen ) 
{ 
  int fd ;
  int i ;
  char *tty ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 88
  tty = addr->pi_device;
#line 90
  fd = open((char const   *)tty, 2050);
  }
#line 90
  if (fd < 0) {
#line 91
    ps->last_error = -502;
#line 92
    return (-502);
  }
  {
#line 95
  tmp___0 = isatty(fd);
  }
#line 95
  if (! tmp___0) {
    {
#line 96
    close(fd);
#line 97
    tmp = __errno_location();
#line 97
    *tmp = 22;
#line 98
    ps->last_error = -502;
    }
#line 99
    return (-502);
  }
  {
#line 102
  i = fcntl(fd, 3, 0);
  }
#line 102
  if (i != -1) {
    {
#line 103
    i &= -2049;
#line 104
    fcntl(fd, 4, i);
    }
  }
  {
#line 107
  i = pi_socket_setsd(ps, fd);
  }
#line 107
  if (i < 0) {
#line 108
    return (i);
  }
#line 110
  return (fd);
}
}
#line 125 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_close___1(pi_socket_t *ps ) 
{ 
  int tmp ;

  {
  {
#line 128
  pi_log(2, 4, "DEV CLOSE linuxusb fd: %d\n", ps->sd);
#line 131
  tmp = close(ps->sd);
  }
#line 131
  return (tmp);
}
}
#line 146 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_poll___1(pi_socket_t *ps , int timeout ) 
{ 
  struct timeval t ;
  fd_set ready ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 152
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 157
  if (timeout == 0) {
    {
#line 158
    select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
           (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
    }
  } else {
    {
#line 160
    t.tv_sec = (__time_t )(timeout / 1000);
#line 161
    t.tv_usec = (__suseconds_t )((timeout % 1000) * 1000);
#line 162
    select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
           (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
    }
  }
#line 165
  if (! ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
    {
#line 167
    pi_log(2, 2, "DEV POLL linuxusb timeout\n");
#line 169
    tmp = __errno_location();
#line 169
    *tmp = 110;
#line 170
    tmp___0 = pi_set_error(ps->sd, -202);
    }
#line 170
    return (tmp___0);
  }
  {
#line 173
  pi_log(2, 8, "DEV POLL linuxusb found data on fd: %d\n", ps->sd);
  }
#line 176
  return (1);
}
}
#line 191 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_write___1(pi_socket_t *ps , unsigned char *buf___3 , size_t len , int flags ) 
{ 
  int total ;
  int nwrote ;
  struct pi_usb_data *data ;
  struct timeval t ;
  fd_set ready ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;

  {
#line 196
  data = (struct pi_usb_data *)(ps->device)->data;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 200
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 203
  total = (int )len;
  {
#line 204
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 204
    if (! (total > 0)) {
#line 204
      goto while_break___0;
    }
#line 205
    if (data->timeout == 0) {
      {
#line 206
      select(ps->sd + 1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)(& ready),
             (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
      }
    } else {
      {
#line 208
      t.tv_sec = (__time_t )(data->timeout / 1000);
#line 209
      t.tv_usec = (__suseconds_t )((data->timeout % 1000) * 1000);
#line 210
      tmp___0 = select(ps->sd + 1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)(& ready),
                       (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
      }
#line 210
      if (tmp___0) {
        {
#line 211
        tmp = pi_set_error(ps->sd, -202);
        }
#line 211
        return (tmp);
      }
    }
#line 214
    if (! ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
      {
#line 215
      ps->state = 8;
#line 216
      tmp___1 = pi_set_error(ps->sd, -200);
      }
#line 216
      return (tmp___1);
    }
    {
#line 219
    tmp___2 = write(ps->sd, (void const   *)buf___3, len);
#line 219
    nwrote = (int )tmp___2;
    }
#line 220
    if (nwrote < 0) {
      {
#line 221
      ps->state = 8;
#line 222
      tmp___3 = pi_set_error(ps->sd, -200);
      }
#line 222
      return (tmp___3);
    }
#line 225
    total -= nwrote;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 228
  pi_log(2, 8, "DEV TX linuxusb wrote %d bytes\n", len);
  }
#line 231
  return ((int )len);
}
}
#line 246 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_read_buf___1(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) 
{ 
  struct pi_usb_data *data ;
  size_t rbuf ;
  int *tmp ;
  int tmp___0 ;
  pi_buffer_t *tmp___1 ;

  {
#line 249
  data = (struct pi_usb_data *)(ps->device)->data;
#line 250
  rbuf = data->buf_size;
#line 252
  if (rbuf > len) {
#line 253
    rbuf = len;
  }
  {
#line 255
  tmp___1 = pi_buffer_append(buf___3, (void const   *)(data->buf), rbuf);
  }
#line 255
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 256
    tmp = __errno_location();
#line 256
    *tmp = 12;
#line 257
    tmp___0 = pi_set_error(ps->sd, -500);
    }
#line 257
    return (tmp___0);
  }
#line 260
  if (flags != 1) {
#line 261
    data->buf_size -= rbuf;
#line 262
    if (data->buf_size > 0UL) {
      {
#line 263
      memmove((void *)(data->buf), (void const   *)(& data->buf[rbuf]), data->buf_size);
      }
    }
  }
  {
#line 266
  pi_log(2, 8, "DEV RX linuxusb read %d bytes from read-ahead buffer\n", rbuf);
  }
#line 269
  return ((int )rbuf);
}
}
#line 284 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_read___1(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) 
{ 
  ssize_t rbuf ;
  ssize_t bytes ;
  struct pi_usb_data *data ;
  struct timeval t ;
  fd_set ready ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  pi_buffer_t *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
#line 287
  rbuf = (ssize_t )0;
#line 289
  data = (struct pi_usb_data *)(ps->device)->data;
#line 294
  if (data->buf_size) {
    {
#line 295
    tmp = u_read_buf___1(ps, buf___3, len, flags);
#line 295
    rbuf = (ssize_t )tmp;
    }
#line 296
    if (rbuf < 0L) {
#line 297
      return ((int )rbuf);
    }
#line 298
    len -= (size_t )rbuf;
#line 299
    if (len == 0UL) {
#line 300
      return ((int )rbuf);
    }
  }
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 305
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 307
  if (data->timeout == 0) {
    {
#line 308
    select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
           (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
    }
  } else {
    {
#line 310
    t.tv_sec = (__time_t )(data->timeout / 1000);
#line 311
    t.tv_usec = (__suseconds_t )((data->timeout % 1000) * 1000);
#line 312
    tmp___2 = select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
                     (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
    }
#line 312
    if (tmp___2 == 0) {
      {
#line 313
      pi_log(2, 2, "DEV RX linuxusb timeout\n");
#line 315
      tmp___0 = __errno_location();
#line 315
      *tmp___0 = 110;
#line 316
      tmp___1 = pi_set_error(ps->sd, -202);
      }
#line 316
      return (tmp___1);
    }
  }
#line 321
  if ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 322
    if (flags == 1) {
#line 322
      if (len > 256UL) {
#line 323
        len = (size_t )256;
      }
    }
    {
#line 325
    tmp___5 = pi_buffer_expect(buf___3, len);
    }
#line 325
    if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
      {
#line 326
      tmp___3 = __errno_location();
#line 326
      *tmp___3 = 12;
#line 327
      tmp___4 = pi_set_error(ps->sd, -500);
      }
#line 327
      return (tmp___4);
    }
    {
#line 330
    bytes = read(ps->sd, (void *)(buf___3->data + buf___3->used), len);
    }
#line 332
    if (bytes > 0L) {
#line 333
      if (flags == 1) {
        {
#line 334
        memcpy((void */* __restrict  */)(data->buf + data->buf_size), (void const   */* __restrict  */)(buf___3->data + buf___3->used),
               (size_t )bytes);
#line 335
        data->buf_size += (size_t )bytes;
        }
      }
      {
#line 337
      buf___3->used += (size_t )bytes;
#line 338
      rbuf += bytes;
#line 340
      pi_log(2, 8, "DEV RX linuxusb read %d bytes\n", bytes);
      }
    }
  } else {
    {
#line 344
    pi_log(2, 2, "DEV RX linuxusb timeout\n");
#line 346
    tmp___6 = __errno_location();
#line 346
    *tmp___6 = 110;
#line 347
    tmp___7 = pi_set_error(ps->sd, -202);
    }
#line 347
    return (tmp___7);
  }
#line 350
  return ((int )rbuf);
}
}
#line 370 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_flush___1(pi_socket_t *ps , int flags ) 
{ 
  char buf___3[256] ;
  int fl ;
  struct pi_usb_data *data ;
  int tmp ;

  {
#line 375
  data = (struct pi_usb_data *)(ps->device)->data;
#line 377
  if (flags & 1) {
    {
#line 379
    data->buf_size = (size_t )0;
#line 382
    fl = fcntl(ps->sd, 3, 0);
    }
#line 382
    if (fl != -1) {
      {
#line 383
      fcntl(ps->sd, 4, fl | 2048);
      }
      {
#line 384
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 384
        tmp = (int )recv(ps->sd, buf___3, sizeof(buf___3), 0);
        }
#line 384
        if (! (tmp > 0)) {
#line 384
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 386
      fcntl(ps->sd, 4, 0);
      }
    }
    {
#line 389
    pi_log(2, 8, "DEV FLUSH linuxusb flushed input buffer\n");
    }
  }
#line 392
  return (0);
}
}
#line 99 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
static int pi_file_close_for_write___1(pi_file_t *pf ) ;
#line 100
static void pi_file_free___1(pi_file_t *pf ) ;
#line 101
static int pi_file_find_resource_by_type_id___1(pi_file_t const   *pf , unsigned long restype ,
                                                int resid , int *resindex ) ;
#line 102
static pi_file_entry_t *pi_file_append_entry___1(pi_file_t *pf ) ;
#line 103
static int pi_file_set_rbuf_size___1(pi_file_t *pf , size_t size ) ;
#line 1270 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
static int pi_file_close_for_write___1(pi_file_t *pf ) 
{ 
  int i ;
  int offset ;
  FILE *f ;
  struct DBInfo *ip ;
  struct pi_file_entry *entp ;
  struct stat sbuf ;
  unsigned char buf___3[512] ;
  unsigned char *p ;
  int tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
#line 1284
  ip = & pf->info;
#line 1285
  if (pf->num_entries >= 65536) {
#line 1290
    return (-400);
  }
  {
#line 1301
  tmp = stat((char const   */* __restrict  */)pf->file_name, (struct stat */* __restrict  */)(& sbuf));
  }
#line 1301
  if (! tmp) {
#line 1302
    if ((sbuf.st_mode & 61440U) == 32768U) {
      {
#line 1303
      unlink((char const   *)pf->file_name);
      }
    }
  }
  {
#line 1305
  f = fopen((char const   */* __restrict  */)pf->file_name, (char const   */* __restrict  */)"wb");
  }
#line 1305
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 1306
    return (-401);
  }
  {
#line 1308
  ip = & pf->info;
#line 1310
  offset = (78 + pf->num_entries * pf->ent_hdr_size) + 2;
#line 1312
  p = buf___3;
#line 1313
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(ip->name),
         (size_t )32);
#line 1314
  *((p + 32) + 0) = (unsigned char )(((int )((unsigned short )ip->flags) >> 8) & 255);
#line 1314
  *((p + 32) + 1) = (unsigned char )((int )((unsigned short )ip->flags) & 255);
#line 1315
  *((p + 34) + 0) = (unsigned char )(((int )((unsigned short )ip->version) >> 8) & 255);
#line 1315
  *((p + 34) + 1) = (unsigned char )((int )((unsigned short )ip->version) & 255);
#line 1316
  tmp___0 = unix_time_to_pilot_time(ip->createDate);
#line 1316
  *((p + 36) + 0) = (unsigned char )((int )((unsigned char )(tmp___0 >> 24)) & 255);
#line 1316
  tmp___1 = unix_time_to_pilot_time(ip->createDate);
#line 1316
  *((p + 36) + 1) = (unsigned char )((tmp___1 >> 16) & 255UL);
#line 1316
  tmp___2 = unix_time_to_pilot_time(ip->createDate);
#line 1316
  *((p + 36) + 2) = (unsigned char )((tmp___2 >> 8) & 255UL);
#line 1316
  tmp___3 = unix_time_to_pilot_time(ip->createDate);
#line 1316
  *((p + 36) + 3) = (unsigned char )(tmp___3 & 255UL);
#line 1317
  tmp___4 = unix_time_to_pilot_time(ip->modifyDate);
#line 1317
  *((p + 40) + 0) = (unsigned char )((int )((unsigned char )(tmp___4 >> 24)) & 255);
#line 1317
  tmp___5 = unix_time_to_pilot_time(ip->modifyDate);
#line 1317
  *((p + 40) + 1) = (unsigned char )((tmp___5 >> 16) & 255UL);
#line 1317
  tmp___6 = unix_time_to_pilot_time(ip->modifyDate);
#line 1317
  *((p + 40) + 2) = (unsigned char )((tmp___6 >> 8) & 255UL);
#line 1317
  tmp___7 = unix_time_to_pilot_time(ip->modifyDate);
#line 1317
  *((p + 40) + 3) = (unsigned char )(tmp___7 & 255UL);
#line 1318
  tmp___8 = unix_time_to_pilot_time(ip->backupDate);
#line 1318
  *((p + 44) + 0) = (unsigned char )((int )((unsigned char )(tmp___8 >> 24)) & 255);
#line 1318
  tmp___9 = unix_time_to_pilot_time(ip->backupDate);
#line 1318
  *((p + 44) + 1) = (unsigned char )((tmp___9 >> 16) & 255UL);
#line 1318
  tmp___10 = unix_time_to_pilot_time(ip->backupDate);
#line 1318
  *((p + 44) + 2) = (unsigned char )((tmp___10 >> 8) & 255UL);
#line 1318
  tmp___11 = unix_time_to_pilot_time(ip->backupDate);
#line 1318
  *((p + 44) + 3) = (unsigned char )(tmp___11 & 255UL);
#line 1319
  *((p + 48) + 0) = (unsigned char )((int )((unsigned char )(ip->modnum >> 24)) & 255);
#line 1319
  *((p + 48) + 1) = (unsigned char )((ip->modnum >> 16) & 255UL);
#line 1319
  *((p + 48) + 2) = (unsigned char )((ip->modnum >> 8) & 255UL);
#line 1319
  *((p + 48) + 3) = (unsigned char )(ip->modnum & 255UL);
  }
#line 1320
  if (pf->app_info_size) {
#line 1320
    tmp___12 = offset;
  } else {
#line 1320
    tmp___12 = 0;
  }
#line 1320
  *((p + 52) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )tmp___12 >> 24)) & 255);
#line 1320
  if (pf->app_info_size) {
#line 1320
    tmp___13 = offset;
  } else {
#line 1320
    tmp___13 = 0;
  }
#line 1320
  *((p + 52) + 1) = (unsigned char )(((unsigned long )tmp___13 >> 16) & 255UL);
#line 1320
  if (pf->app_info_size) {
#line 1320
    tmp___14 = offset;
  } else {
#line 1320
    tmp___14 = 0;
  }
#line 1320
  *((p + 52) + 2) = (unsigned char )(((unsigned long )tmp___14 >> 8) & 255UL);
#line 1320
  if (pf->app_info_size) {
#line 1320
    tmp___15 = offset;
  } else {
#line 1320
    tmp___15 = 0;
  }
#line 1320
  *((p + 52) + 3) = (unsigned char )((unsigned long )tmp___15 & 255UL);
#line 1321
  offset += pf->app_info_size;
#line 1322
  if (pf->sort_info_size) {
#line 1322
    tmp___16 = offset;
  } else {
#line 1322
    tmp___16 = 0;
  }
#line 1322
  *((p + 56) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )tmp___16 >> 24)) & 255);
#line 1322
  if (pf->sort_info_size) {
#line 1322
    tmp___17 = offset;
  } else {
#line 1322
    tmp___17 = 0;
  }
#line 1322
  *((p + 56) + 1) = (unsigned char )(((unsigned long )tmp___17 >> 16) & 255UL);
#line 1322
  if (pf->sort_info_size) {
#line 1322
    tmp___18 = offset;
  } else {
#line 1322
    tmp___18 = 0;
  }
#line 1322
  *((p + 56) + 2) = (unsigned char )(((unsigned long )tmp___18 >> 8) & 255UL);
#line 1322
  if (pf->sort_info_size) {
#line 1322
    tmp___19 = offset;
  } else {
#line 1322
    tmp___19 = 0;
  }
  {
#line 1322
  *((p + 56) + 3) = (unsigned char )((unsigned long )tmp___19 & 255UL);
#line 1323
  offset += pf->sort_info_size;
#line 1324
  *((p + 60) + 0) = (unsigned char )((int )((unsigned char )(ip->type >> 24)) & 255);
#line 1324
  *((p + 60) + 1) = (unsigned char )((ip->type >> 16) & 255UL);
#line 1324
  *((p + 60) + 2) = (unsigned char )((ip->type >> 8) & 255UL);
#line 1324
  *((p + 60) + 3) = (unsigned char )(ip->type & 255UL);
#line 1325
  *((p + 64) + 0) = (unsigned char )((int )((unsigned char )(ip->creator >> 24)) & 255);
#line 1325
  *((p + 64) + 1) = (unsigned char )((ip->creator >> 16) & 255UL);
#line 1325
  *((p + 64) + 2) = (unsigned char )((ip->creator >> 8) & 255UL);
#line 1325
  *((p + 64) + 3) = (unsigned char )(ip->creator & 255UL);
#line 1326
  *((p + 68) + 0) = (unsigned char )((int )((unsigned char )(pf->unique_id_seed >> 24)) & 255);
#line 1326
  *((p + 68) + 1) = (unsigned char )((pf->unique_id_seed >> 16) & 255UL);
#line 1326
  *((p + 68) + 2) = (unsigned char )((pf->unique_id_seed >> 8) & 255UL);
#line 1326
  *((p + 68) + 3) = (unsigned char )(pf->unique_id_seed & 255UL);
#line 1327
  *((p + 72) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )pf->next_record_list_id >> 24)) & 255);
#line 1327
  *((p + 72) + 1) = (unsigned char )(((unsigned long )pf->next_record_list_id >> 16) & 255UL);
#line 1327
  *((p + 72) + 2) = (unsigned char )(((unsigned long )pf->next_record_list_id >> 8) & 255UL);
#line 1327
  *((p + 72) + 3) = (unsigned char )((unsigned long )pf->next_record_list_id & 255UL);
#line 1328
  *((p + 76) + 0) = (unsigned char )(((int )((unsigned short )pf->num_entries) >> 8) & 255);
#line 1328
  *((p + 76) + 1) = (unsigned char )((int )((unsigned short )pf->num_entries) & 255);
#line 1330
  tmp___20 = fwrite((void const   */* __restrict  */)(buf___3), (size_t )78, (size_t )1,
                    (FILE */* __restrict  */)f);
  }
#line 1330
  if (tmp___20 != 1UL) {
#line 1331
    goto bad;
  }
#line 1333
  i = 0;
#line 1333
  entp = pf->entries;
  {
#line 1333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1333
    if (! (i < pf->num_entries)) {
#line 1333
      goto while_break;
    }
#line 1334
    entp->offset = offset;
#line 1336
    p = buf___3;
#line 1337
    if (pf->resource_flag) {
#line 1338
      *(p + 0) = (unsigned char )((int )((unsigned char )(entp->type >> 24)) & 255);
#line 1338
      *(p + 1) = (unsigned char )((entp->type >> 16) & 255UL);
#line 1338
      *(p + 2) = (unsigned char )((entp->type >> 8) & 255UL);
#line 1338
      *(p + 3) = (unsigned char )(entp->type & 255UL);
#line 1339
      *((p + 4) + 0) = (unsigned char )(((int )((unsigned short )entp->resource_id) >> 8) & 255);
#line 1339
      *((p + 4) + 1) = (unsigned char )((int )((unsigned short )entp->resource_id) & 255);
#line 1340
      *((p + 6) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )entp->offset >> 24)) & 255);
#line 1340
      *((p + 6) + 1) = (unsigned char )(((unsigned long )entp->offset >> 16) & 255UL);
#line 1340
      *((p + 6) + 2) = (unsigned char )(((unsigned long )entp->offset >> 8) & 255UL);
#line 1340
      *((p + 6) + 3) = (unsigned char )((unsigned long )entp->offset & 255UL);
    } else {
#line 1342
      *(p + 0) = (unsigned char )((int )((unsigned char )((unsigned long )entp->offset >> 24)) & 255);
#line 1342
      *(p + 1) = (unsigned char )(((unsigned long )entp->offset >> 16) & 255UL);
#line 1342
      *(p + 2) = (unsigned char )(((unsigned long )entp->offset >> 8) & 255UL);
#line 1342
      *(p + 3) = (unsigned char )((unsigned long )entp->offset & 255UL);
#line 1343
      *((p + 4) + 0) = (unsigned char )entp->attrs;
#line 1344
      *((p + 5) + 0) = (unsigned char )((int )((unsigned char )(entp->uid >> 16)) & 255);
#line 1344
      *((p + 5) + 1) = (unsigned char )((entp->uid >> 8) & 255UL);
#line 1344
      *((p + 5) + 2) = (unsigned char )(entp->uid & 255UL);
    }
    {
#line 1347
    tmp___21 = fwrite((void const   */* __restrict  */)(buf___3), (size_t )pf->ent_hdr_size,
                      (size_t )1, (FILE */* __restrict  */)f);
    }
#line 1347
    if (tmp___21 != 1UL) {
#line 1348
      goto bad;
    }
#line 1350
    offset += entp->size;
#line 1333
    i ++;
#line 1333
    entp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1354
  fwrite((void const   */* __restrict  */)"\000\000", (size_t )1, (size_t )2, (FILE */* __restrict  */)f);
  }
#line 1356
  if (pf->app_info) {
    {
#line 1356
    tmp___22 = fwrite((void const   */* __restrict  */)pf->app_info, (size_t )1, (size_t )pf->app_info_size,
                      (FILE */* __restrict  */)f);
    }
#line 1356
    if (tmp___22 != (size_t )pf->app_info_size) {
#line 1359
      goto bad;
    }
  }
#line 1361
  if (pf->sort_info) {
    {
#line 1361
    tmp___23 = fwrite((void const   */* __restrict  */)pf->sort_info, (size_t )1,
                      (size_t )pf->sort_info_size, (FILE */* __restrict  */)f);
    }
#line 1361
    if (tmp___23 != (size_t )pf->sort_info_size) {
#line 1364
      goto bad;
    }
  }
  {
#line 1367
  fwrite((void const   */* __restrict  */)(pf->tmpbuf)->data, (pf->tmpbuf)->used,
         (size_t )1, (FILE */* __restrict  */)f);
#line 1368
  fflush(f);
#line 1370
  tmp___24 = ferror(f);
  }
#line 1370
  if (tmp___24) {
#line 1371
    goto bad;
  } else {
    {
#line 1370
    tmp___25 = feof(f);
    }
#line 1370
    if (tmp___25) {
#line 1371
      goto bad;
    }
  }
  {
#line 1373
  fclose(f);
  }
#line 1374
  return (0);
  bad: 
  {
#line 1377
  fclose(f);
  }
#line 1378
  return (-401);
}
}
#line 1392 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
static void pi_file_free___1(pi_file_t *pf ) 
{ 


  {
#line 1397
  if ((unsigned long )pf->f != (unsigned long )((FILE *)0)) {
    {
#line 1398
    fclose(pf->f);
    }
  }
#line 1400
  if ((unsigned long )pf->app_info != (unsigned long )((void *)0)) {
    {
#line 1401
    free(pf->app_info);
    }
  }
#line 1403
  if ((unsigned long )pf->sort_info != (unsigned long )((void *)0)) {
    {
#line 1404
    free(pf->sort_info);
    }
  }
#line 1406
  if ((unsigned long )pf->entries != (unsigned long )((void *)0)) {
    {
#line 1407
    free((void *)pf->entries);
    }
  }
#line 1409
  if ((unsigned long )pf->file_name != (unsigned long )((void *)0)) {
    {
#line 1410
    free((void *)pf->file_name);
    }
  }
#line 1412
  if ((unsigned long )pf->rbuf != (unsigned long )((void *)0)) {
    {
#line 1413
    free(pf->rbuf);
    }
  }
#line 1415
  if ((unsigned long )pf->tmpbuf != (unsigned long )((void *)0)) {
    {
#line 1416
    pi_buffer_free(pf->tmpbuf);
    }
  }
  {
#line 1419
  memset((void *)pf, 0, sizeof(pi_file_t ));
#line 1421
  free((void *)pf);
  }
#line 1422
  return;
}
}
#line 1435 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
static int pi_file_set_rbuf_size___1(pi_file_t *pf , size_t size ) 
{ 
  size_t new_size ;
  void *rbuf ;

  {
#line 1441
  if (size > (size_t )pf->rbuf_size) {
#line 1442
    if (pf->rbuf_size == 0) {
      {
#line 1443
      new_size = size + 2048UL;
#line 1444
      rbuf = malloc(new_size);
      }
    } else {
      {
#line 1446
      new_size = size + 2048UL;
#line 1447
      rbuf = realloc(pf->rbuf, new_size);
      }
    }
#line 1450
    if ((unsigned long )rbuf == (unsigned long )((void *)0)) {
#line 1451
      return (-500);
    }
#line 1453
    pf->rbuf_size = (int )new_size;
#line 1454
    pf->rbuf = rbuf;
  }
#line 1457
  return (0);
}
}
#line 1472 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
static pi_file_entry_t *pi_file_append_entry___1(pi_file_t *pf ) 
{ 
  int new_count ;
  size_t new_size ;
  struct pi_file_entry *new_entries ;
  struct pi_file_entry *entp ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1480
  if (pf->num_entries >= pf->num_entries_allocated) {
#line 1481
    if (pf->num_entries_allocated == 0) {
#line 1482
      new_count = 100;
    } else {
#line 1484
      new_count = (pf->num_entries_allocated * 3) / 2;
    }
#line 1485
    new_size = (unsigned long )new_count * sizeof(*(pf->entries));
#line 1487
    if ((unsigned long )pf->entries == (unsigned long )((void *)0)) {
      {
#line 1488
      tmp = malloc(new_size);
#line 1488
      new_entries = (struct pi_file_entry *)tmp;
      }
    } else {
      {
#line 1490
      tmp___0 = realloc((void *)pf->entries, new_size);
#line 1490
      new_entries = (struct pi_file_entry *)tmp___0;
      }
    }
#line 1492
    if ((unsigned long )new_entries == (unsigned long )((void *)0)) {
#line 1493
      return ((pi_file_entry_t *)((void *)0));
    }
#line 1495
    pf->num_entries_allocated = new_count;
#line 1496
    pf->entries = new_entries;
  }
  {
#line 1499
  tmp___1 = pf->num_entries;
#line 1499
  (pf->num_entries) ++;
#line 1499
  entp = pf->entries + tmp___1;
#line 1500
  memset((void *)entp, 0, sizeof(*entp));
  }
#line 1501
  return (entp);
}
}
#line 1504 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
static int pi_file_find_resource_by_type_id___1(pi_file_t const   *pf , unsigned long restype ,
                                                int resid , int *resindex ) 
{ 
  int i ;
  struct pi_file_entry *entp ;

  {
#line 1511
  if (! pf->resource_flag) {
#line 1512
    return (-400);
  }
#line 1514
  i = 0;
#line 1514
  entp = (struct pi_file_entry *)pf->entries;
  {
#line 1514
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1514
    if (! (i < (int )pf->num_entries)) {
#line 1514
      goto while_break;
    }
#line 1515
    if (entp->type == restype) {
#line 1515
      if (entp->resource_id == resid) {
#line 1516
        if (resindex) {
#line 1517
          *resindex = i;
        }
#line 1518
        return (1);
      }
    }
#line 1514
    i ++;
#line 1514
    entp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1521
  return (0);
}
}
#line 47 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
static int slp_flush___1(pi_socket_t *ps , int flags ) ;
#line 48
static int slp_getsockopt___1(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) ;
#line 50
static int slp_setsockopt___1(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) ;
#line 65 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
static pi_protocol_t *slp_protocol_dup___1(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  struct pi_slp_data *data ;
  struct pi_slp_data *new_data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 73
  tmp = malloc(sizeof(pi_protocol_t ));
#line 73
  new_prot = (pi_protocol_t *)tmp;
#line 74
  tmp___0 = malloc(sizeof(struct pi_slp_data ));
#line 74
  new_data = (struct pi_slp_data *)tmp___0;
  }
#line 76
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 76
    if ((unsigned long )new_data != (unsigned long )((void *)0)) {
#line 77
      new_prot->level = prot->level;
#line 78
      new_prot->dup = prot->dup;
#line 79
      new_prot->free = prot->free;
#line 80
      new_prot->read = prot->read;
#line 81
      new_prot->write = prot->write;
#line 82
      new_prot->flush = prot->flush;
#line 83
      new_prot->getsockopt = prot->getsockopt;
#line 84
      new_prot->setsockopt = prot->setsockopt;
#line 86
      data = (struct pi_slp_data *)prot->data;
#line 88
      new_data->dest = data->dest;
#line 89
      new_data->last_dest = data->last_dest;
#line 90
      new_data->src = data->src;
#line 91
      new_data->last_src = data->last_src;
#line 92
      new_data->type = data->type;
#line 93
      new_data->last_type = data->last_type;
#line 94
      new_data->txid = data->txid;
#line 95
      new_data->last_txid = data->last_txid;
#line 97
      new_prot->data = (void *)new_data;
    } else {
#line 76
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 99
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
    {
#line 100
    free((void *)new_prot);
#line 101
    new_prot = (pi_protocol_t *)((void *)0);
    }
  } else
#line 102
  if ((unsigned long )new_data != (unsigned long )((void *)0)) {
    {
#line 103
    free((void *)new_data);
#line 104
    new_data = (struct pi_slp_data *)((void *)0);
    }
  }
#line 107
  return (new_prot);
}
}
#line 122 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
static void slp_protocol_free___1(pi_protocol_t *prot ) 
{ 


  {
#line 125
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 126
    if ((unsigned long )prot->data != (unsigned long )((void *)0)) {
      {
#line 127
      free(prot->data);
      }
    }
    {
#line 128
    free((void *)prot);
    }
  }
#line 130
  return;
}
}
#line 440 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
static int slp_flush___1(pi_socket_t *ps , int flags ) 
{ 
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 446
  prot = pi_protocol(ps->sd, 1);
  }
#line 447
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 448
    tmp = pi_set_error(ps->sd, -201);
    }
#line 448
    return (tmp);
  }
  {
#line 450
  next = pi_protocol_next(ps->sd, 1);
  }
#line 451
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 452
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 452
    return (tmp___0);
  }
  {
#line 454
  tmp___1 = (*(next->flush))(ps, flags);
  }
#line 454
  return (tmp___1);
}
}
#line 468 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
static int slp_getsockopt___1(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  struct pi_slp_data *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 475
  prot = pi_protocol(ps->sd, 1);
  }
#line 476
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 477
    tmp = pi_set_error(ps->sd, -201);
    }
#line 477
    return (tmp);
  }
#line 479
  data = (struct pi_slp_data *)prot->data;
  {
#line 482
  if (option_name == 0) {
#line 482
    goto case_0;
  }
#line 488
  if (option_name == 1) {
#line 488
    goto case_1;
  }
#line 495
  if (option_name == 2) {
#line 495
    goto case_2;
  }
#line 502
  if (option_name == 3) {
#line 502
    goto case_3;
  }
#line 509
  if (option_name == 4) {
#line 509
    goto case_4;
  }
#line 516
  if (option_name == 5) {
#line 516
    goto case_5;
  }
#line 523
  if (option_name == 6) {
#line 523
    goto case_6;
  }
#line 530
  if (option_name == 7) {
#line 530
    goto case_7;
  }
#line 481
  goto switch_break;
  case_0: /* CIL Label */ 
#line 483
  if (*option_len < sizeof(data->dest)) {
#line 484
    goto error;
  }
  {
#line 485
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->dest),
         sizeof(data->dest));
#line 486
  *option_len = sizeof(data->dest);
  }
#line 487
  goto switch_break;
  case_1: /* CIL Label */ 
#line 489
  if (*option_len < sizeof(data->dest)) {
#line 490
    goto error;
  }
  {
#line 491
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->last_dest),
         sizeof(data->last_dest));
#line 493
  *option_len = sizeof(data->last_dest);
  }
#line 494
  goto switch_break;
  case_2: /* CIL Label */ 
#line 496
  if (*option_len < sizeof(data->src)) {
#line 497
    goto error;
  }
  {
#line 498
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->src),
         sizeof(data->src));
#line 500
  *option_len = sizeof(data->src);
  }
#line 501
  goto switch_break;
  case_3: /* CIL Label */ 
#line 503
  if (*option_len < sizeof(data->last_src)) {
#line 504
    goto error;
  }
  {
#line 505
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->last_src),
         sizeof(data->last_src));
#line 507
  *option_len = sizeof(data->last_src);
  }
#line 508
  goto switch_break;
  case_4: /* CIL Label */ 
#line 510
  if (*option_len < sizeof(data->type)) {
#line 511
    goto error;
  }
  {
#line 512
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->type),
         sizeof(data->type));
#line 514
  *option_len = sizeof(data->type);
  }
#line 515
  goto switch_break;
  case_5: /* CIL Label */ 
#line 517
  if (*option_len < sizeof(data->last_type)) {
#line 518
    goto error;
  }
  {
#line 519
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->last_type),
         sizeof(data->last_type));
#line 521
  *option_len = sizeof(data->last_type);
  }
#line 522
  goto switch_break;
  case_6: /* CIL Label */ 
#line 524
  if (*option_len < sizeof(data->txid)) {
#line 525
    goto error;
  }
  {
#line 526
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->txid),
         sizeof(data->txid));
#line 528
  *option_len = sizeof(data->txid);
  }
#line 529
  goto switch_break;
  case_7: /* CIL Label */ 
#line 531
  if (*option_len < sizeof(data->last_txid)) {
#line 532
    goto error;
  }
  {
#line 533
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->last_txid),
         sizeof(data->last_txid));
#line 535
  *option_len = sizeof(data->last_txid);
  }
#line 536
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 539
  return (0);
  error: 
  {
#line 542
  tmp___0 = __errno_location();
#line 542
  *tmp___0 = 22;
#line 543
  tmp___1 = pi_set_error(ps->sd, -501);
  }
#line 543
  return (tmp___1);
}
}
#line 558 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
static int slp_setsockopt___1(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  struct pi_slp_data *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 565
  prot = pi_protocol(ps->sd, 1);
  }
#line 566
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 567
    tmp = pi_set_error(ps->sd, -201);
    }
#line 567
    return (tmp);
  }
#line 568
  data = (struct pi_slp_data *)prot->data;
  {
#line 571
  if (option_name == 0) {
#line 571
    goto case_0;
  }
#line 578
  if (option_name == 2) {
#line 578
    goto case_2;
  }
#line 585
  if (option_name == 4) {
#line 585
    goto case_4;
  }
#line 592
  if (option_name == 6) {
#line 592
    goto case_6;
  }
#line 570
  goto switch_break;
  case_0: /* CIL Label */ 
#line 572
  if (*option_len != sizeof(data->dest)) {
#line 573
    goto error;
  }
  {
#line 574
  memcpy((void */* __restrict  */)(& data->dest), (void const   */* __restrict  */)option_value,
         sizeof(data->dest));
#line 576
  *option_len = sizeof(data->dest);
  }
#line 577
  goto switch_break;
  case_2: /* CIL Label */ 
#line 579
  if (*option_len != sizeof(data->src)) {
#line 580
    goto error;
  }
  {
#line 581
  memcpy((void */* __restrict  */)(& data->src), (void const   */* __restrict  */)option_value,
         sizeof(data->src));
#line 583
  *option_len = sizeof(data->src);
  }
#line 584
  goto switch_break;
  case_4: /* CIL Label */ 
#line 586
  if (*option_len != sizeof(data->type)) {
#line 587
    goto error;
  }
  {
#line 588
  memcpy((void */* __restrict  */)(& data->type), (void const   */* __restrict  */)option_value,
         sizeof(data->type));
#line 590
  *option_len = sizeof(data->type);
  }
#line 591
  goto switch_break;
  case_6: /* CIL Label */ 
#line 593
  if (*option_len != sizeof(data->txid)) {
#line 594
    goto error;
  }
  {
#line 595
  memcpy((void */* __restrict  */)(& data->txid), (void const   */* __restrict  */)option_value,
         sizeof(data->txid));
#line 597
  *option_len = sizeof(data->txid);
  }
#line 598
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 601
  return (0);
  error: 
  {
#line 604
  tmp___0 = __errno_location();
#line 604
  *tmp___0 = 22;
#line 605
  tmp___1 = pi_set_error(ps->sd, -501);
  }
#line 605
  return (tmp___1);
}
}
#line 1121 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/palmpix.c"
static void Bias___1(double bias , int width , int height , uint8_t *data ) 
{ 
  int i ;
  double num ;
  double denom ;
  double t ;

  {
  {
#line 1126
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bias factor : %lf\n",
          bias);
#line 1128
  i = 0;
  }
  {
#line 1128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1128
    if (! (i < width * height)) {
#line 1128
      goto while_break;
    }
#line 1130
    t = (double )*(data + i) / 256.0;
#line 1131
    num = t;
#line 1132
    denom = (1.0 / bias - (double )2) * (1.0 - t) + (double )1;
#line 1133
    *(data + i) = (uint8_t )((num / denom) * 256.0);
#line 1128
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1135
  return;
}
}
#line 1429 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/palmpix.c"
static void Interpolate___1(struct PalmPixHeader  const  *pixHdr , uint8_t *red ,
                            uint8_t *greenR , uint8_t *greenB , uint8_t *blue , uint8_t *pp ,
                            int offset_r , int offset_g , int offset_b ) 
{ 
  int idx ;
  int offset ;
  int ppOff ;
  int x ;
  int y ;
  int rowOff ;
  uint8_t r ;
  uint8_t g ;
  uint8_t b ;
  int rawWidth ;

  {
#line 1434
  rawWidth = (int )(pixHdr->w / 2);
#line 1436
  y = 1;
  {
#line 1436
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1436
    if (! (y < (int )(pixHdr->h - 1))) {
#line 1436
      goto while_break;
    }
#line 1439
    idx = y / 2;
#line 1440
    offset = idx * rawWidth;
#line 1441
    ppOff = y * (int )pixHdr->w;
#line 1443
    if (y % 2 == 1) {
#line 1445
      x = 1;
      {
#line 1445
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1445
        if (! (x < rawWidth - 1)) {
#line 1445
          goto while_break___0;
        }
#line 1448
        rowOff = x * 2;
#line 1450
        r = (uint8_t )(((((int )*(red + ((offset + x) - 1)) + (int )*(red + (offset + x))) + (int )*(red + (((offset + rawWidth) + x) - 1))) + (int )*(red + ((offset + rawWidth) + x))) >> 2);
#line 1451
        g = (uint8_t )(((((int )*(greenR + (offset + x)) + (int )*(greenR + ((offset + x) + rawWidth))) + (int )*(greenB + ((offset + x) - 1))) + (int )*(greenB + (offset + x))) >> 2);
#line 1452
        b = *(blue + (offset + x));
#line 1453
        *(pp + (3 * (ppOff + rowOff) + offset_r)) = r;
#line 1454
        *(pp + (3 * (ppOff + rowOff) + offset_g)) = g;
#line 1455
        *(pp + (3 * (ppOff + rowOff) + offset_b)) = b;
#line 1457
        r = (uint8_t )(((int )*(red + (offset + x)) + (int )*(red + ((offset + rawWidth) + x))) >> 1);
#line 1458
        g = (uint8_t )(((((((int )*(greenB + (offset + x)) << 2) + (int )*(greenR + (offset + x))) + (int )*(greenR + ((offset + x) + 1))) + (int )*(greenR + ((offset + x) + rawWidth))) + (int )*(greenR + (((offset + x) + rawWidth) + 1))) >> 3);
#line 1459
        b = (uint8_t )(((int )*(blue + (offset + x)) + (int )*(blue + ((offset + x) + 1))) >> 1);
#line 1460
        *(pp + (3 * ((ppOff + rowOff) + 1) + offset_r)) = r;
#line 1461
        *(pp + (3 * ((ppOff + rowOff) + 1) + offset_g)) = g;
#line 1462
        *(pp + (3 * ((ppOff + rowOff) + 1) + offset_b)) = b;
#line 1445
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 1468
      x = 1;
      {
#line 1468
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1468
        if (! (x < rawWidth - 1)) {
#line 1468
          goto while_break___1;
        }
#line 1470
        rowOff = x * 2;
#line 1472
        r = (uint8_t )(((int )*(red + ((offset + x) - 1)) + (int )*(red + (offset + x))) >> 1);
#line 1473
        g = (uint8_t )(((((((int )*(greenR + (offset + x)) << 2) + (int )*(greenB + (((offset - rawWidth) + x) - 1))) + (int )*(greenB + ((offset - rawWidth) + x))) + (int )*(greenB + ((offset + x) - 1))) + (int )*(greenB + (offset + x))) >> 3);
#line 1474
        b = (uint8_t )(((int )*(blue + ((offset - rawWidth) + x)) + (int )*(blue + (offset + x))) >> 1);
#line 1475
        *(pp + (3 * (ppOff + rowOff) + offset_r)) = r;
#line 1476
        *(pp + (3 * (ppOff + rowOff) + offset_g)) = g;
#line 1477
        *(pp + (3 * (ppOff + rowOff) + offset_b)) = b;
#line 1479
        r = *(red + (offset + x));
#line 1480
        g = (uint8_t )(((((int )*(greenR + (offset + x)) + (int )*(greenR + ((offset + x) + 1))) + (int )*(greenB + ((offset - rawWidth) + x))) + (int )*(greenB + (offset + x))) >> 2);
#line 1481
        b = (uint8_t )(((((int )*(blue + ((offset + x) - rawWidth)) + (int )*(blue + (((offset + x) - rawWidth) - 1))) + (int )*(blue + (offset + x))) + (int )*(blue + ((offset + x) + 1))) >> 2);
#line 1482
        *(pp + (3 * ((ppOff + rowOff) + 1) + offset_r)) = r;
#line 1483
        *(pp + (3 * ((ppOff + rowOff) + 1) + offset_g)) = g;
#line 1484
        *(pp + (3 * ((ppOff + rowOff) + 1) + offset_b)) = b;
#line 1468
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 1436
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1490
  return;
}
}
#line 1601 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/palmpix.c"
static int get_le_short___1(unsigned char const   *p ) 
{ 


  {
#line 1605
  return ((int )((int const   )*(p + 0) | ((int const   )*(p + 1) << 8)));
}
}
#line 44 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
static int sys_PackRegisters___1(void *data , struct Pilot_registers *r ) ;
#line 136 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
static int sys_PackRegisters___1(void *data , struct Pilot_registers *r ) 
{ 
  int idx ;
  unsigned char *buffer ;

  {
#line 140
  buffer = (unsigned char *)data;
#line 142
  idx = 0;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (idx < 8)) {
#line 142
      goto while_break;
    }
#line 143
    *((buffer + idx * 4) + 0) = (unsigned char )((int )((unsigned char )(r->D[idx] >> 24)) & 255);
#line 143
    *((buffer + idx * 4) + 1) = (unsigned char )((r->D[idx] >> 16) & 255UL);
#line 143
    *((buffer + idx * 4) + 2) = (unsigned char )((r->D[idx] >> 8) & 255UL);
#line 143
    *((buffer + idx * 4) + 3) = (unsigned char )(r->D[idx] & 255UL);
#line 142
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  idx = 0;
  {
#line 144
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 144
    if (! (idx < 7)) {
#line 144
      goto while_break___0;
    }
#line 145
    *(((buffer + 32) + idx * 4) + 0) = (unsigned char )((int )((unsigned char )(r->A[idx] >> 24)) & 255);
#line 145
    *(((buffer + 32) + idx * 4) + 1) = (unsigned char )((r->A[idx] >> 16) & 255UL);
#line 145
    *(((buffer + 32) + idx * 4) + 2) = (unsigned char )((r->A[idx] >> 8) & 255UL);
#line 145
    *(((buffer + 32) + idx * 4) + 3) = (unsigned char )(r->A[idx] & 255UL);
#line 144
    idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 146
  *((buffer + 60) + 0) = (unsigned char )((int )((unsigned char )(r->USP >> 24)) & 255);
#line 146
  *((buffer + 60) + 1) = (unsigned char )((r->USP >> 16) & 255UL);
#line 146
  *((buffer + 60) + 2) = (unsigned char )((r->USP >> 8) & 255UL);
#line 146
  *((buffer + 60) + 3) = (unsigned char )(r->USP & 255UL);
#line 147
  *((buffer + 64) + 0) = (unsigned char )((int )((unsigned char )(r->SSP >> 24)) & 255);
#line 147
  *((buffer + 64) + 1) = (unsigned char )((r->SSP >> 16) & 255UL);
#line 147
  *((buffer + 64) + 2) = (unsigned char )((r->SSP >> 8) & 255UL);
#line 147
  *((buffer + 64) + 3) = (unsigned char )(r->SSP & 255UL);
#line 148
  *((buffer + 68) + 0) = (unsigned char )((int )((unsigned char )(r->PC >> 24)) & 255);
#line 148
  *((buffer + 68) + 1) = (unsigned char )((r->PC >> 16) & 255UL);
#line 148
  *((buffer + 68) + 2) = (unsigned char )((r->PC >> 8) & 255UL);
#line 148
  *((buffer + 68) + 3) = (unsigned char )(r->PC & 255UL);
#line 150
  *((buffer + 72) + 0) = (unsigned char )(((int )((unsigned short )r->SR) >> 8) & 255);
#line 150
  *((buffer + 72) + 1) = (unsigned char )((int )((unsigned short )r->SR) & 255);
#line 152
  return (0);
}
}
#line 48 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static void pi_inet_device_free___1(pi_device_t *dev ) ;
#line 49
static pi_protocol_t *pi_inet_protocol___1(pi_device_t *dev ) ;
#line 50
static pi_protocol_t *pi_inet_protocol_dup___1(pi_protocol_t *prot ) ;
#line 51
static void pi_inet_protocol_free___1(pi_protocol_t *prot ) ;
#line 52
static int pi_inet_close___1(pi_socket_t *ps ) ;
#line 53
static int pi_inet_connect___1(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
#line 54
static int pi_inet_bind___1(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
#line 55
static int pi_inet_listen___1(pi_socket_t *ps , int backlog ) ;
#line 56
static int pi_inet_accept___1(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) ;
#line 57
static ssize_t pi_inet_read___1(pi_socket_t *ps , pi_buffer_t *msg , size_t len ,
                                int flags ) ;
#line 58
static ssize_t pi_inet_write___1(pi_socket_t *ps , unsigned char const   *msg , size_t len ,
                                 int flags ) ;
#line 59
static int pi_inet_getsockopt___1(pi_socket_t *ps , int level , int option_name ,
                                  void *option_value , size_t *option_len ) ;
#line 60
static int pi_inet_setsockopt___1(pi_socket_t *ps , int level , int option_name ,
                                  void const   *option_value , size_t *option_len ) ;
#line 61
static int pi_inet_flush___1(pi_socket_t *ps , int flags ) ;
#line 100 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static void pi_inet_device_free___1(pi_device_t *dev ) 
{ 


  {
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! ((unsigned long )dev != (unsigned long )((void *)0))) {
      {
#line 103
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c",
             103, "dev != NULL");
      }
    }
#line 103
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if ((unsigned long )dev != (unsigned long )((void *)0)) {
#line 105
    if ((unsigned long )dev->data != (unsigned long )((void *)0)) {
      {
#line 106
      free(dev->data);
      }
    }
    {
#line 107
    free((void *)dev);
    }
  }
#line 109
  return;
}
}
#line 111 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static pi_protocol_t *pi_inet_protocol___1(pi_device_t *dev ) 
{ 
  pi_protocol_t *prot ;
  pi_inet_data_t *data ;
  void *tmp ;

  {
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! ((unsigned long )dev != (unsigned long )((void *)0))) {
      {
#line 117
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c",
             117, "dev != NULL");
      }
    }
#line 117
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  data = (pi_inet_data_t *)dev->data;
#line 121
  tmp = malloc(sizeof(pi_protocol_t ));
#line 121
  prot = (pi_protocol_t *)tmp;
  }
#line 123
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 124
    prot->level = 0;
#line 125
    prot->dup = & pi_inet_protocol_dup___1;
#line 126
    prot->free = & pi_inet_protocol_free___1;
#line 127
    prot->read = & pi_inet_read___1;
#line 128
    prot->write = & pi_inet_write___1;
#line 129
    prot->flush = & pi_inet_flush___1;
#line 130
    prot->getsockopt = & pi_inet_getsockopt___1;
#line 131
    prot->setsockopt = & pi_inet_setsockopt___1;
#line 132
    prot->data = (void *)0;
  }
#line 135
  return (prot);
}
}
#line 138 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static pi_protocol_t *pi_inet_protocol_dup___1(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  void *tmp ;

  {
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 143
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c",
             143, "prot != NULL");
      }
    }
#line 143
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 145
  tmp = malloc(sizeof(pi_protocol_t ));
#line 145
  new_prot = (pi_protocol_t *)tmp;
  }
#line 147
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 148
    new_prot->level = prot->level;
#line 149
    new_prot->dup = prot->dup;
#line 150
    new_prot->free = prot->free;
#line 151
    new_prot->read = prot->read;
#line 152
    new_prot->write = prot->write;
#line 153
    new_prot->flush = prot->flush;
#line 154
    new_prot->getsockopt = prot->getsockopt;
#line 155
    new_prot->setsockopt = prot->setsockopt;
#line 156
    new_prot->data = (void *)0;
  }
#line 159
  return (new_prot);
}
}
#line 162 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static void pi_inet_protocol_free___1(pi_protocol_t *prot ) 
{ 


  {
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 165
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c",
             165, "prot != NULL");
      }
    }
#line 165
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
    {
#line 167
    free((void *)prot);
    }
  }
#line 168
  return;
}
}
#line 170 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_bind___1(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) 
{ 
  int opt ;
  int sd ;
  int err ;
  size_t optlen ;
  struct pi_sockaddr *paddr ;
  struct sockaddr_in serv_addr ;
  char *device ;
  char *port ;
  struct hostent *hostent ;
  struct hostent *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;

  {
  {
#line 177
  paddr = (struct pi_sockaddr *)addr;
#line 179
  device = paddr->pi_device;
#line 179
  port = (char *)((void *)0);
#line 183
  memset((void *)(& serv_addr), 0, sizeof(serv_addr));
#line 184
  serv_addr.sin_family = (sa_family_t )2;
#line 185
  tmp___1 = strlen((char const   *)device);
  }
#line 185
  if (tmp___1 > 1UL) {
    {
#line 185
    tmp___2 = strncmp((char const   *)device, "any", (size_t )3);
    }
#line 185
    if (tmp___2) {
      {
#line 186
      serv_addr.sin_addr.s_addr = inet_addr((char const   *)device);
      }
#line 187
      if (serv_addr.sin_addr.s_addr == 4294967295U) {
        {
#line 188
        tmp = gethostbyname((char const   *)device);
#line 188
        hostent = tmp;
        }
#line 190
        if (! hostent) {
          {
#line 191
          tmp___0 = pi_set_error(ps->sd, -502);
          }
#line 191
          return (tmp___0);
        }
        {
#line 193
        memcpy((void */* __restrict  */)((char *)(& serv_addr.sin_addr.s_addr)), (void const   */* __restrict  */)*(hostent->h_addr_list + 0),
               (size_t )hostent->h_length);
        }
      }
    } else {
      {
#line 197
      serv_addr.sin_addr.s_addr = htonl((in_addr_t )0);
      }
    }
  } else {
    {
#line 197
    serv_addr.sin_addr.s_addr = htonl((in_addr_t )0);
    }
  }
  {
#line 199
  port = strchr((char const   *)device, ':');
  }
#line 199
  if ((unsigned long )port != (unsigned long )((void *)0)) {
    {
#line 200
    port ++;
#line 200
    tmp___3 = atoi((char const   *)port);
#line 200
    serv_addr.sin_port = htons((uint16_t )tmp___3);
    }
  } else {
    {
#line 202
    serv_addr.sin_port = htons((uint16_t )14238);
    }
  }
  {
#line 205
  sd = socket(2, 1, 0);
  }
#line 206
  if (sd < 0) {
    {
#line 207
    pi_log(2, 1, "DEV BIND Inet: Unable to create socket\n");
#line 209
    tmp___4 = pi_set_error(ps->sd, -502);
    }
#line 209
    return (tmp___4);
  }
  {
#line 211
  err = pi_socket_setsd(ps, sd);
  }
#line 211
  if (err < 0) {
#line 212
    return (err);
  }
  {
#line 214
  opt = 1;
#line 215
  optlen = sizeof(opt);
#line 217
  tmp___6 = setsockopt(ps->sd, 1, 2, (void const   *)((void *)(& opt)), (socklen_t )((int )optlen));
  }
#line 217
  if (tmp___6 < 0) {
    {
#line 219
    tmp___5 = pi_set_error(ps->sd, -502);
    }
#line 219
    return (tmp___5);
  }
  {
#line 222
  tmp___8 = bind(ps->sd, (struct sockaddr  const  *)((struct sockaddr *)(& serv_addr)),
                 (socklen_t )sizeof(serv_addr));
  }
#line 222
  if (tmp___8 < 0) {
    {
#line 223
    tmp___7 = pi_set_error(ps->sd, -502);
    }
#line 223
    return (tmp___7);
  }
  {
#line 225
  pi_log(2, 4, "DEV BIND Inet Bound to %s\n", device);
#line 228
  tmp___9 = malloc(addrlen);
#line 228
  ps->raddr = (struct sockaddr *)tmp___9;
#line 229
  memcpy((void */* __restrict  */)ps->raddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 230
  ps->raddrlen = addrlen;
#line 231
  tmp___10 = malloc(addrlen);
#line 231
  ps->laddr = (struct sockaddr *)tmp___10;
#line 232
  memcpy((void */* __restrict  */)ps->laddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 233
  ps->laddrlen = addrlen;
  }
#line 235
  return (0);
}
}
#line 238 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_connect___1(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) 
{ 
  int sd ;
  int err ;
  struct pi_sockaddr *paddr ;
  struct sockaddr_in serv_addr ;
  char *device ;
  struct hostent *hostent ;
  struct hostent *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 244
  paddr = (struct pi_sockaddr *)addr;
#line 246
  device = paddr->pi_device;
#line 249
  memset((void *)(& serv_addr), 0, sizeof(serv_addr));
#line 250
  serv_addr.sin_family = (sa_family_t )2;
#line 251
  tmp___1 = strlen((char const   *)device);
  }
#line 251
  if (tmp___1 > 1UL) {
    {
#line 252
    serv_addr.sin_addr.s_addr = inet_addr((char const   *)device);
    }
#line 253
    if (serv_addr.sin_addr.s_addr == 4294967295U) {
      {
#line 254
      tmp = gethostbyname((char const   *)device);
#line 254
      hostent = tmp;
      }
#line 256
      if (! hostent) {
        {
#line 257
        pi_log(2, 1, "DEV CONNECT Inet: Unable to determine host\n");
#line 260
        tmp___0 = pi_set_error(ps->sd, -502);
        }
#line 260
        return (tmp___0);
      }
      {
#line 263
      memcpy((void */* __restrict  */)((char *)(& serv_addr.sin_addr.s_addr)), (void const   */* __restrict  */)*(hostent->h_addr_list + 0),
             (size_t )hostent->h_length);
      }
    }
  } else {
    {
#line 267
    serv_addr.sin_addr.s_addr = htonl((in_addr_t )0);
    }
  }
  {
#line 269
  serv_addr.sin_port = htons((uint16_t )14238);
#line 271
  sd = socket(2, 1, 0);
  }
#line 273
  if (sd < 0) {
    {
#line 274
    pi_log(2, 1, "DEV CONNECT Inet: Unable to create socket\n");
#line 276
    tmp___2 = pi_set_error(ps->sd, -502);
    }
#line 276
    return (tmp___2);
  }
  {
#line 279
  err = pi_socket_setsd(ps, sd);
  }
#line 279
  if (err < 0) {
#line 280
    return (err);
  }
  {
#line 282
  tmp___4 = connect(ps->sd, (struct sockaddr  const  *)((struct sockaddr *)(& serv_addr)),
                    (socklen_t )sizeof(serv_addr));
  }
#line 282
  if (tmp___4 < 0) {
    {
#line 284
    pi_log(2, 1, "DEV CONNECT Inet: Unable to connect\n");
#line 286
    tmp___3 = pi_set_error(ps->sd, -502);
    }
#line 286
    return (tmp___3);
  }
  {
#line 289
  tmp___5 = malloc(addrlen);
#line 289
  ps->raddr = (struct sockaddr *)tmp___5;
#line 290
  memcpy((void */* __restrict  */)ps->raddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 291
  ps->raddrlen = addrlen;
#line 292
  tmp___6 = malloc(addrlen);
#line 292
  ps->laddr = (struct sockaddr *)tmp___6;
#line 293
  memcpy((void */* __restrict  */)ps->laddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 294
  ps->laddrlen = addrlen;
  }
  {
#line 297
  if (ps->cmd == 1) {
#line 297
    goto case_1;
  }
#line 301
  if (ps->cmd == 2) {
#line 301
    goto case_2;
  }
#line 296
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 298
  err = cmp_tx_handshake(ps);
  }
#line 298
  if (err < 0) {
#line 299
    goto fail;
  }
#line 300
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 302
  err = net_tx_handshake(ps);
  }
#line 302
  if (err < 0) {
#line 303
    goto fail;
  }
#line 304
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 306
  ps->state = 4;
#line 307
  ps->command = 0;
#line 309
  pi_log(2, 4, "DEV CONNECT Inet: Connected\n");
  }
#line 310
  return (0);
  fail: 
#line 313
  return (err);
}
}
#line 316 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_listen___1(pi_socket_t *ps , int backlog ) 
{ 
  int result ;

  {
  {
#line 321
  result = listen(ps->sd, backlog);
  }
#line 322
  if (result == 0) {
#line 323
    ps->state = 1;
  }
#line 325
  return (result);
}
}
#line 328 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_accept___1(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) 
{ 
  int sd ;
  int err ;
  int split ;
  int chunksize ;
  size_t len ;
  size_t size ;
  socklen_t l ;
  unsigned char cmp_flags ;
  int use_long_format ;

  {
#line 331
  split = 0;
#line 331
  chunksize = 0;
#line 337
  l = (socklen_t )0;
#line 340
  if (addrlen) {
#line 341
    l = (socklen_t )*addrlen;
  }
  {
#line 342
  sd = accept(ps->sd, (struct sockaddr */* __restrict  */)addr, (socklen_t */* __restrict  */)(& l));
  }
#line 343
  if (addrlen) {
#line 344
    *addrlen = (size_t )l;
  }
#line 345
  if (sd < 0) {
    {
#line 346
    pi_set_error(ps->sd, sd);
#line 347
    err = -502;
    }
#line 348
    goto fail;
  }
  {
#line 351
  pi_socket_setsd(ps, sd);
#line 352
  pi_socket_init(ps);
  }
  {
#line 355
  if (ps->cmd == 1) {
#line 355
    goto case_1;
  }
#line 374
  if (ps->cmd == 2) {
#line 374
    goto case_2;
  }
#line 354
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 356
  err = cmp_rx_handshake(ps, 57600, 0);
  }
#line 356
  if (err < 0) {
#line 357
    goto fail;
  }
  {
#line 360
  size = sizeof(cmp_flags);
#line 361
  pi_getsockopt(ps->sd, 5, 1, (void *)(& cmp_flags), & size);
  }
#line 362
  if ((int )cmp_flags & 16) {
    {
#line 363
    use_long_format = 1;
#line 364
    size = sizeof(int );
#line 365
    pi_setsockopt(ps->sd, 2, 3, (void const   *)(& use_long_format), & size);
#line 367
    ps->command ^= 1;
#line 368
    pi_setsockopt(ps->sd, 2, 3, (void const   *)(& use_long_format), & size);
#line 370
    ps->command ^= 1;
    }
  }
#line 373
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 378
  len = sizeof(split);
#line 379
  pi_setsockopt(ps->sd, 3, 1, (void const   *)(& split), & len);
#line 381
  len = sizeof(chunksize);
#line 382
  pi_setsockopt(ps->sd, 3, 2, (void const   *)(& chunksize), & len);
#line 385
  ps->command ^= 1;
#line 386
  len = sizeof(split);
#line 387
  pi_setsockopt(ps->sd, 3, 1, (void const   *)(& split), & len);
#line 389
  len = sizeof(chunksize);
#line 390
  pi_setsockopt(ps->sd, 3, 2, (void const   *)(& chunksize), & len);
#line 392
  ps->command ^= 1;
#line 394
  err = net_rx_handshake(ps);
  }
#line 394
  if (err < 0) {
#line 395
    goto fail;
  }
#line 396
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 399
  ps->state = 2;
#line 400
  ps->command = 0;
#line 401
  ps->dlprecord = 0;
#line 403
  pi_log(2, 4, "DEV INET ACCEPT accepted\n");
  }
#line 405
  return (ps->sd);
  fail: 
#line 408
  return (err);
}
}
#line 411 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_close___1(pi_socket_t *ps ) 
{ 


  {
#line 414
  if (ps->sd) {
    {
#line 415
    close(ps->sd);
#line 416
    ps->sd = 0;
    }
  }
#line 418
  if (ps->laddr) {
    {
#line 419
    free((void *)ps->laddr);
#line 420
    ps->laddr = (struct sockaddr *)((void *)0);
    }
  }
#line 422
  if (ps->raddr) {
    {
#line 423
    free((void *)ps->raddr);
#line 424
    ps->raddr = (struct sockaddr *)((void *)0);
    }
  }
#line 426
  return (0);
}
}
#line 429 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_flush___1(pi_socket_t *ps , int flags ) 
{ 
  char buf___3[256] ;
  int fl ;
  ssize_t tmp ;

  {
#line 435
  if (flags & 1) {
    {
#line 436
    fl = fcntl(ps->sd, 3, 0);
    }
#line 436
    if (fl != -1) {
      {
#line 437
      fcntl(ps->sd, 4, fl | 2048);
      }
      {
#line 438
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 438
        tmp = recv(ps->sd, (void *)(buf___3), sizeof(buf___3), 0);
        }
#line 438
        if (! (tmp > 0L)) {
#line 438
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 440
      fcntl(ps->sd, 4, fl);
      }
    }
  }
#line 443
  return (0);
}
}
#line 446 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static ssize_t pi_inet_write___1(pi_socket_t *ps , unsigned char const   *msg , size_t len ,
                                 int flags ) 
{ 
  int total ;
  int nwrote ;
  pi_inet_data_t *data ;
  struct timeval t ;
  fd_set ready ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;

  {
#line 451
  data = (pi_inet_data_t *)(ps->device)->data;
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 455
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 455
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 458
  total = (int )len;
  {
#line 459
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 459
    if (! (total > 0)) {
#line 459
      goto while_break___0;
    }
#line 460
    if (data->timeout == 0) {
      {
#line 461
      tmp = select(ps->sd + 1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)(& ready),
                   (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
      }
#line 461
      if (tmp < 0) {
        {
#line 461
        tmp___0 = __errno_location();
        }
#line 461
        if (*tmp___0 == 4) {
#line 463
          goto while_continue___0;
        }
      }
    } else {
      {
#line 465
      t.tv_sec = (__time_t )(data->timeout / 1000);
#line 466
      t.tv_usec = (__suseconds_t )((data->timeout % 1000) * 1000);
#line 467
      tmp___2 = select(ps->sd + 1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)(& ready),
                       (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
      }
#line 467
      if (tmp___2 == 0) {
        {
#line 468
        tmp___1 = pi_set_error(ps->sd, -202);
        }
#line 468
        return ((ssize_t )tmp___1);
      }
    }
#line 470
    if (! ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
      {
#line 471
      ps->state = 8;
#line 472
      tmp___3 = pi_set_error(ps->sd, -200);
      }
#line 472
      return ((ssize_t )tmp___3);
    }
    {
#line 475
    tmp___4 = write(ps->sd, (void const   *)msg, len);
#line 475
    nwrote = (int )tmp___4;
    }
#line 476
    if (nwrote < 0) {
      {
#line 478
      tmp___6 = __errno_location();
      }
#line 478
      if (*tmp___6 == 32) {
        {
#line 479
        ps->state = 8;
#line 480
        tmp___5 = pi_set_error(ps->sd, -200);
        }
#line 480
        return ((ssize_t )tmp___5);
      } else {
        {
#line 478
        tmp___7 = __errno_location();
        }
#line 478
        if (*tmp___7 == 9) {
          {
#line 479
          ps->state = 8;
#line 480
          tmp___5 = pi_set_error(ps->sd, -200);
          }
#line 480
          return ((ssize_t )tmp___5);
        }
      }
      {
#line 482
      tmp___8 = pi_set_error(ps->sd, -204);
      }
#line 482
      return ((ssize_t )tmp___8);
    }
#line 485
    total -= nwrote;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 487
  data->tx_bytes = (int )((size_t )data->tx_bytes + len);
#line 489
  pi_log(2, 4, "DEV TX Inet Bytes: %d\n", len);
  }
#line 491
  return ((ssize_t )len);
}
}
#line 494 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static ssize_t pi_inet_read___1(pi_socket_t *ps , pi_buffer_t *msg , size_t len ,
                                int flags ) 
{ 
  int r ;
  int fl ;
  pi_inet_data_t *data ;
  fd_set ready ;
  struct timeval t ;
  int *tmp ;
  int tmp___0 ;
  pi_buffer_t *tmp___1 ;
  int __d0 ;
  int __d1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 497
  fl = 0;
#line 499
  data = (pi_inet_data_t *)(ps->device)->data;
#line 503
  tmp___1 = pi_buffer_expect(msg, len);
  }
#line 503
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 504
    tmp = __errno_location();
#line 504
    *tmp = 12;
#line 505
    tmp___0 = pi_set_error(ps->sd, -500);
    }
#line 505
    return ((ssize_t )tmp___0);
  }
#line 508
  if (flags == 1) {
#line 509
    fl = 2;
  }
  {
#line 511
  while (1) {
    while_continue: /* CIL Label */ ;
#line 511
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 511
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 512
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 516
  if (data->timeout == 0) {
    {
#line 517
    select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
           (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
    }
  } else {
    {
#line 519
    t.tv_sec = (__time_t )(data->timeout / 1000);
#line 520
    t.tv_usec = (__suseconds_t )((data->timeout % 1000) * 1000);
#line 521
    tmp___3 = select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
                     (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
    }
#line 521
    if (tmp___3 == 0) {
      {
#line 522
      tmp___2 = pi_set_error(ps->sd, -202);
      }
#line 522
      return ((ssize_t )tmp___2);
    }
  }
#line 526
  if ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
    {
#line 527
    tmp___4 = recv(ps->sd, (void *)(msg->data + msg->used), len, fl);
#line 527
    r = (int )tmp___4;
    }
#line 528
    if (r < 0) {
      {
#line 529
      tmp___6 = __errno_location();
      }
#line 529
      if (*tmp___6 == 32) {
        {
#line 530
        ps->state = 8;
#line 531
        tmp___5 = pi_set_error(ps->sd, -200);
        }
#line 531
        return ((ssize_t )tmp___5);
      } else {
        {
#line 529
        tmp___7 = __errno_location();
        }
#line 529
        if (*tmp___7 == 9) {
          {
#line 530
          ps->state = 8;
#line 531
          tmp___5 = pi_set_error(ps->sd, -200);
          }
#line 531
          return ((ssize_t )tmp___5);
        }
      }
      {
#line 533
      tmp___8 = pi_set_error(ps->sd, -204);
      }
#line 533
      return ((ssize_t )tmp___8);
    }
    {
#line 536
    data->rx_bytes += r;
#line 537
    msg->used += (size_t )r;
#line 539
    pi_log(2, 4, "DEV RX Inet Bytes: %d\n", r);
    }
#line 540
    return ((ssize_t )r);
  }
  {
#line 544
  pi_log(2, 2, "DEV RX Inet timeout\n");
#line 545
  (data->rx_errors) ++;
  }
#line 546
  return ((ssize_t )0);
}
}
#line 549 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_getsockopt___1(pi_socket_t *ps , int level , int option_name ,
                                  void *option_value , size_t *option_len ) 
{ 
  pi_inet_data_t *data ;
  int *tmp ;
  int tmp___0 ;

  {
#line 553
  data = (pi_inet_data_t *)(ps->device)->data;
  {
#line 556
  if (option_name == 3) {
#line 556
    goto case_3;
  }
#line 555
  goto switch_break;
  case_3: /* CIL Label */ 
#line 557
  if (*option_len != sizeof(data->timeout)) {
    {
#line 558
    tmp = __errno_location();
#line 558
    *tmp = 22;
#line 559
    tmp___0 = pi_set_error(ps->sd, -501);
    }
#line 559
    return (tmp___0);
  }
  {
#line 561
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->timeout),
         sizeof(data->timeout));
#line 563
  *option_len = sizeof(data->timeout);
  }
#line 564
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 567
  return (0);
}
}
#line 570 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_setsockopt___1(pi_socket_t *ps , int level , int option_name ,
                                  void const   *option_value , size_t *option_len ) 
{ 
  pi_inet_data_t *data ;
  int *tmp ;
  int tmp___0 ;

  {
#line 574
  data = (pi_inet_data_t *)(ps->device)->data;
  {
#line 577
  if (option_name == 3) {
#line 577
    goto case_3;
  }
#line 576
  goto switch_break;
  case_3: /* CIL Label */ 
#line 578
  if (*option_len != sizeof(data->timeout)) {
    {
#line 579
    tmp = __errno_location();
#line 579
    *tmp = 22;
#line 580
    tmp___0 = pi_set_error(ps->sd, -501);
    }
#line 580
    return (tmp___0);
  }
  {
#line 582
  memcpy((void */* __restrict  */)(& data->timeout), (void const   */* __restrict  */)option_value,
         sizeof(data->timeout));
  }
#line 584
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 587
  return (0);
}
}
#line 63 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
static void record_dump___1(unsigned long recID , unsigned int recIndex , int flags ,
                            int catID , char const   *data , int data_len ) ;
#line 141 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
static int dlp_version_major___1  =    1;
#line 142 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
static int dlp_version_minor___1  =    4;
#line 160 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
static void record_dump___1(unsigned long recID , unsigned int recIndex , int flags ,
                            int catID , char const   *data , int data_len ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 163
  if (! flags) {
#line 163
    tmp = " None";
  } else {
#line 163
    tmp = "";
  }
#line 163
  if (flags & 8) {
#line 163
    tmp___0 = " Archive";
  } else {
#line 163
    tmp___0 = "";
  }
#line 163
  if (flags & 16) {
#line 163
    tmp___1 = " Secret";
  } else {
#line 163
    tmp___1 = "";
  }
#line 163
  if (flags & 32) {
#line 163
    tmp___2 = " Busy";
  } else {
#line 163
    tmp___2 = "";
  }
#line 163
  if (flags & 64) {
#line 163
    tmp___3 = " Dirty";
  } else {
#line 163
    tmp___3 = "";
  }
#line 163
  if (flags & 128) {
#line 163
    tmp___4 = " Deleted";
  } else {
#line 163
    tmp___4 = "";
  }
  {
#line 163
  pi_log(16, 4, "  ID: 0x%8.8lX, Index: %u, Category: %d\n  Flags:%s%s%s%s%s%s (0x%2.2X), and %d bytes:\n",
         recID, recIndex, catID, tmp___4, tmp___3, tmp___2, tmp___1, tmp___0, tmp,
         flags, data_len);
#line 176
  pi_dumpdata(data, (size_t )data_len);
  }
#line 177
  return;
}
}
#line 1207 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
static void dlp_decode_finddb_response___1(struct dlpResponse *res , int *cardno ,
                                           unsigned long *localid , int *dbhandle ,
                                           struct DBInfo *info , struct DBSizeInfo *size ) 
{ 
  int arg ;
  int argid ;
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
#line 1212
  arg = 0;
  {
#line 1212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1212
    if (! (arg < res->argc)) {
#line 1212
      goto while_break;
    }
#line 1213
    argid = ((*(res->argv + arg))->id_ & 127) - 32;
#line 1214
    if (argid == 0) {
#line 1215
      if (cardno) {
#line 1216
        *cardno = (int )*((unsigned char *)((*(res->argv + arg))->data + 0) + 0);
      }
#line 1217
      if (localid) {
#line 1218
        *localid = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 2) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 2) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 2) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 2) + 3);
      }
#line 1219
      if (dbhandle) {
#line 1220
        *dbhandle = (int )(((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 6) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 6) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 6) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 6) + 3));
      }
#line 1222
      if (info) {
        {
#line 1223
        info->more = 0;
#line 1224
        info->miscFlags = (unsigned int )*((unsigned char *)((*(res->argv + arg))->data + 11) + 0);
#line 1226
        info->flags = (unsigned int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + arg))->data + 12) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + arg))->data + 12) + 1)));
#line 1228
        info->type = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 14) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 14) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 14) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 14) + 3);
#line 1230
        info->creator = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 18) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 18) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 18) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 18) + 3);
#line 1232
        info->version = (unsigned int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + arg))->data + 22) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + arg))->data + 22) + 1)));
#line 1234
        info->modnum = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 24) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 24) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 24) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 24) + 3);
#line 1236
        info->createDate = dlp_ptohdate((unsigned char const   *)((*(res->argv + arg))->data + 28));
#line 1238
        info->modifyDate = dlp_ptohdate((unsigned char const   *)((*(res->argv + arg))->data + 36));
#line 1240
        info->backupDate = dlp_ptohdate((unsigned char const   *)((*(res->argv + arg))->data + 44));
#line 1242
        info->index = (unsigned int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + arg))->data + 52) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + arg))->data + 52) + 1)));
#line 1245
        strncpy((char */* __restrict  */)(info->name), (char const   */* __restrict  */)((*(res->argv + arg))->data + 54),
                (size_t )32);
#line 1246
        info->name[32] = (char )'\000';
        }
#line 1248
        if (info->more) {
#line 1248
          tmp = "Yes";
        } else {
#line 1248
          tmp = "No";
        }
        {
#line 1248
        pi_log(16, 4, "DLP FindDB Name: \'%s\', Version: %d, More: %s\n", info->name,
               info->version, tmp);
#line 1253
        tmp___0 = printlong(info->creator);
#line 1253
        pi_log(16, 4, "  Creator: \'%s\'", tmp___0);
        }
#line 1255
        if (! info->flags) {
#line 1255
          tmp___1 = "None";
        } else {
#line 1255
          tmp___1 = "";
        }
#line 1255
        if (info->flags & 32768U) {
#line 1255
          tmp___2 = "Open ";
        } else {
#line 1255
          tmp___2 = "";
        }
#line 1255
        if (info->flags & 128U) {
#line 1255
          tmp___3 = "Stream ";
        } else {
#line 1255
          tmp___3 = "";
        }
#line 1255
        if (info->flags & 64U) {
#line 1255
          tmp___4 = "CopyPrevention ";
        } else {
#line 1255
          tmp___4 = "";
        }
#line 1255
        if (info->flags & 16U) {
#line 1255
          tmp___5 = "Newer ";
        } else {
#line 1255
          tmp___5 = "";
        }
#line 1255
        if (info->flags & 32U) {
#line 1255
          tmp___6 = "Reset ";
        } else {
#line 1255
          tmp___6 = "";
        }
#line 1255
        if (info->flags & 8U) {
#line 1255
          tmp___7 = "Backup ";
        } else {
#line 1255
          tmp___7 = "";
        }
#line 1255
        if (info->flags & 4U) {
#line 1255
          tmp___8 = "AppInfoDirty ";
        } else {
#line 1255
          tmp___8 = "";
        }
#line 1255
        if (info->flags & 2U) {
#line 1255
          tmp___9 = "ReadOnly ";
        } else {
#line 1255
          tmp___9 = "";
        }
#line 1255
        if (info->flags & 1U) {
#line 1255
          tmp___10 = "Resource ";
        } else {
#line 1255
          tmp___10 = "";
        }
        {
#line 1255
        tmp___11 = printlong(info->type);
#line 1255
        pi_log(16, 4, " Type: \'%s\' Flags: %s%s%s%s%s%s%s%s%s%s", tmp___11, tmp___10,
               tmp___9, tmp___8, tmp___7, tmp___6, tmp___5, tmp___4, tmp___3, tmp___2,
               tmp___1);
#line 1277
        pi_log(16, 4, " (0x%2.2X)\n", info->flags);
#line 1279
        tmp___12 = ctime((time_t const   *)(& info->createDate));
#line 1279
        pi_log(16, 4, "  Modnum: %ld, Index: %d, Creation date: %s", info->modnum,
               info->index, tmp___12);
#line 1284
        tmp___13 = ctime((time_t const   *)(& info->modifyDate));
#line 1284
        pi_log(16, 4, " Modification date: %s", tmp___13);
#line 1287
        tmp___14 = ctime((time_t const   *)(& info->backupDate));
#line 1287
        pi_log(16, 4, " Backup date: %s", tmp___14);
        }
      }
    } else
#line 1292
    if (argid == 1) {
#line 1293
      if (size) {
#line 1294
        size->numRecords = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 0) + 3);
#line 1296
        size->totalBytes = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 4) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 4) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 4) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 4) + 3);
#line 1298
        size->dataBytes = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 8) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 8) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 8) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 8) + 3);
#line 1300
        size->appBlockSize = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 12) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 12) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 12) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 12) + 3);
#line 1302
        size->sortBlockSize = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 16) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 16) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 16) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 16) + 3);
#line 1304
        size->maxRecSize = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 20) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 20) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 20) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 20) + 3);
      }
    }
#line 1212
    arg ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1309
  return;
}
}
#line 57 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_connect___1(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
#line 59
static int pi_serial_bind___1(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
#line 61
static int pi_serial_listen___1(pi_socket_t *ps , int backlog ) ;
#line 62
static int pi_serial_accept___1(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) ;
#line 64
static int pi_serial_getsockopt___1(pi_socket_t *ps , int level , int option_name ,
                                    void *option_value , size_t *option_len ) ;
#line 67
static int pi_serial_setsockopt___1(pi_socket_t *ps , int level , int option_name ,
                                    void const   *option_value , size_t *option_len ) ;
#line 70
static int pi_serial_close___1(pi_socket_t *ps ) ;
#line 87 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static pi_protocol_t *pi_serial_protocol_dup___1(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  void *tmp ;

  {
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 92
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c",
             92, "prot != NULL");
      }
    }
#line 92
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 94
  tmp = malloc(sizeof(pi_protocol_t ));
#line 94
  new_prot = (pi_protocol_t *)tmp;
  }
#line 96
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 97
    new_prot->level = prot->level;
#line 98
    new_prot->dup = prot->dup;
#line 99
    new_prot->free = prot->free;
#line 100
    new_prot->read = prot->read;
#line 101
    new_prot->write = prot->write;
#line 102
    new_prot->flush = prot->flush;
#line 103
    new_prot->getsockopt = prot->getsockopt;
#line 104
    new_prot->setsockopt = prot->setsockopt;
#line 105
    new_prot->data = (void *)0;
  }
#line 108
  return (new_prot);
}
}
#line 123 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static void pi_serial_protocol_free___1(pi_protocol_t *prot ) 
{ 


  {
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 126
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c",
             126, "prot != NULL");
      }
    }
#line 126
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
    {
#line 129
    free((void *)prot);
    }
  }
#line 130
  return;
}
}
#line 144 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static pi_protocol_t *pi_serial_protocol___1(pi_device_t *dev ) 
{ 
  pi_protocol_t *prot ;
  struct pi_serial_data *data ;
  void *tmp ;

  {
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! ((unsigned long )dev != (unsigned long )((void *)0))) {
      {
#line 150
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c",
             150, "dev != NULL");
      }
    }
#line 150
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 152
  tmp = malloc(sizeof(pi_protocol_t ));
#line 152
  prot = (pi_protocol_t *)tmp;
#line 154
  data = (struct pi_serial_data *)dev->data;
  }
#line 156
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 157
    prot->level = 0;
#line 158
    prot->dup = & pi_serial_protocol_dup___1;
#line 159
    prot->free = & pi_serial_protocol_free___1;
#line 160
    prot->read = data->impl.read;
#line 161
    prot->write = data->impl.write;
#line 162
    prot->flush = data->impl.flush;
#line 163
    prot->getsockopt = & pi_serial_getsockopt___1;
#line 164
    prot->setsockopt = & pi_serial_setsockopt___1;
#line 165
    prot->data = (void *)0;
  }
#line 168
  return (prot);
}
}
#line 184 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static void pi_serial_device_free___1(pi_device_t *dev ) 
{ 


  {
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )dev != (unsigned long )((void *)0))) {
      {
#line 187
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c",
             187, "dev != NULL");
      }
    }
#line 187
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 189
  free(dev->data);
#line 190
  free((void *)dev);
  }
#line 191
  return;
}
}
#line 265 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_connect___1(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) 
{ 
  struct pi_serial_data *data ;
  struct pi_sockaddr *pa ;
  int err ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  int tmp___3 ;

  {
#line 269
  data = (struct pi_serial_data *)(ps->device)->data;
#line 271
  pa = (struct pi_sockaddr *)addr;
#line 274
  if (ps->type == 16) {
#line 275
    if (ps->protocol == 3) {
#line 276
      tmp = 57600;
#line 276
      data->rate = tmp;
#line 276
      data->establishrate = tmp;
    } else {
#line 278
      if (data->establishrate == -1) {
        {
#line 279
        get_pilot_rate(& data->establishrate, & data->establishhighrate);
        }
      }
#line 282
      data->rate = 9600;
    }
  } else
#line 284
  if (ps->type == 48) {
#line 286
    tmp___0 = 57600;
#line 286
    data->rate = tmp___0;
#line 286
    data->establishrate = tmp___0;
  }
  {
#line 289
  err = (*(data->impl.open))(ps, pa, addrlen);
  }
#line 289
  if (err < 0) {
#line 290
    return (err);
  }
  {
#line 292
  tmp___1 = malloc(addrlen);
#line 292
  ps->raddr = (struct sockaddr *)tmp___1;
#line 293
  memcpy((void */* __restrict  */)ps->raddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 294
  ps->raddrlen = addrlen;
#line 295
  tmp___2 = malloc(addrlen);
#line 295
  ps->laddr = (struct sockaddr *)tmp___2;
#line 296
  memcpy((void */* __restrict  */)ps->laddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 297
  ps->laddrlen = addrlen;
  }
#line 299
  if (ps->type == 16) {
    {
#line 302
    if (ps->cmd == 1) {
#line 302
      goto case_1;
    }
#line 314
    if (ps->cmd == 2) {
#line 314
      goto case_2;
    }
#line 319
    if (ps->cmd == 3) {
#line 319
      goto case_3;
    }
#line 301
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 303
    tmp___3 = cmp_tx_handshake(ps);
    }
#line 303
    if (tmp___3 < 0) {
#line 304
      goto fail;
    }
    {
#line 306
    size = sizeof(data->rate);
#line 307
    pi_getsockopt(ps->sd, 5, 3, (void *)(& data->rate), & size);
#line 310
    err = (*(data->impl.changebaud))(ps);
    }
#line 310
    if (err < 0) {
#line 311
      goto fail;
    }
#line 312
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 315
    err = (*(data->impl.changebaud))(ps);
    }
#line 315
    if (err < 0) {
#line 316
      goto fail;
    }
#line 317
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 320
    err = (*(data->impl.changebaud))(ps);
    }
#line 320
    if (err < 0) {
#line 321
      goto fail;
    }
#line 322
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 325
  ps->state = 4;
#line 326
  ps->command = 0;
#line 327
  return (0);
  fail: 
#line 330
  return (err);
}
}
#line 345 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_bind___1(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) 
{ 
  struct pi_serial_data *data ;
  struct pi_sockaddr *pa ;
  int err ;
  int count ;
  int tmp ;
  int save_errno ;
  int *tmp___0 ;
  char realport[4096] ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
#line 348
  data = (struct pi_serial_data *)(ps->device)->data;
#line 350
  pa = (struct pi_sockaddr *)addr;
#line 351
  count = 0;
#line 353
  if (ps->type == 16) {
#line 354
    if (data->establishrate == -1) {
      {
#line 355
      get_pilot_rate(& data->establishrate, & data->establishhighrate);
      }
    }
#line 358
    data->rate = 9600;
  } else
#line 359
  if (ps->type == 48) {
#line 361
    tmp = 57600;
#line 361
    data->rate = tmp;
#line 361
    data->establishrate = tmp;
  }
  begin: 
  {
#line 365
  err = (*(data->impl.open))(ps, pa, addrlen);
  }
#line 365
  if (err < 0) {
    {
#line 366
    tmp___0 = __errno_location();
#line 366
    save_errno = *tmp___0;
#line 377
    realpath((char const   */* __restrict  */)(pa->pi_device), (char */* __restrict  */)(realport));
#line 378
    tmp___1 = __errno_location();
#line 378
    *tmp___1 = save_errno;
#line 380
    tmp___7 = __errno_location();
    }
#line 380
    if (*tmp___7 == 2) {
      {
#line 381
      pi_log(2, 1, " The device %s does not exist..\n", pa->pi_device);
#line 384
      pi_log(2, 1, " Possible solution:\n\n\tmknod %s c <major> <minor>\n\n", pa->pi_device);
      }
    } else {
      {
#line 387
      tmp___6 = __errno_location();
      }
#line 387
      if (*tmp___6 == 13) {
        {
#line 388
        pi_log(2, 1, "   Please check the permissions on %s..\n", realport);
#line 391
        pi_log(2, 1, " Possible solution:\n\n\tchmod 0666 %s\n\n", realport);
        }
      } else {
        {
#line 394
        tmp___5 = __errno_location();
        }
#line 394
        if (*tmp___5 == 19) {
          {
#line 395
          while (1) {
            while_continue: /* CIL Label */ ;
#line 395
            if (! (count <= 5)) {
#line 395
              goto while_break;
            }
            {
#line 396
            tmp___2 = fileno(stdout);
#line 396
            tmp___3 = isatty(tmp___2);
            }
#line 396
            if (tmp___3) {
              {
#line 397
              pi_log(2, 1, "\r   Port not connected, sleeping for 2 seconds, ");
#line 400
              pi_log(2, 1, "%d retries..", 5 - count);
              }
            }
            {
#line 404
            sleep(2U);
#line 405
            count ++;
            }
#line 406
            goto begin;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 408
          pi_log(2, 1, "\n\n   Device not found on %s, \t\t\t\t\tDid you hit HotSync?\n\n",
                 realport);
          }
        } else {
          {
#line 411
          tmp___4 = __errno_location();
          }
#line 411
          if (*tmp___4 == 21) {
            {
#line 412
            pi_log(2, 1, " The port specified must contain a device name, and %s was a directory.\n   Please change that to reference a real device, and try again\n\n",
                   pa->pi_device);
            }
          }
        }
      }
    }
#line 420
    return (err);
  }
  {
#line 422
  tmp___8 = malloc(addrlen);
#line 422
  ps->raddr = (struct sockaddr *)tmp___8;
#line 423
  memcpy((void */* __restrict  */)ps->raddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 424
  ps->raddrlen = addrlen;
#line 425
  tmp___9 = malloc(addrlen);
#line 425
  ps->laddr = (struct sockaddr *)tmp___9;
#line 426
  memcpy((void */* __restrict  */)ps->laddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 427
  ps->laddrlen = addrlen;
  }
#line 429
  return (0);
}
}
#line 443 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_listen___1(pi_socket_t *ps , int backlog ) 
{ 
  int result ;
  struct pi_serial_data *data ;

  {
  {
#line 446
  data = (struct pi_serial_data *)(ps->device)->data;
#line 450
  result = (*(data->impl.changebaud))(ps);
  }
#line 451
  if (result == 0) {
#line 452
    ps->state = 1;
  }
#line 454
  return (result);
}
}
#line 468 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_accept___1(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) 
{ 
  struct pi_serial_data *data ;
  size_t size ;
  int err ;
  int result ;
  int tmp ;
  char buf___3[6] ;
  struct timeval tv ;
  unsigned char cmp_flags ;
  int use_long_format ;

  {
#line 472
  data = (struct pi_serial_data *)(ps->device)->data;
#line 479
  if (ps->accept_to) {
    {
#line 481
    tmp = (*(data->impl.poll))(ps, 1000);
#line 481
    result = tmp;
#line 482
    pi_log(2, 8, "%s: %d, poll result: %d.\n", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c",
           482, result);
    }
#line 484
    if (result < 0) {
      {
#line 485
      buf___3[0] = (char)1;
#line 485
      buf___3[1] = (char)0;
#line 485
      buf___3[2] = (char)0;
#line 485
      buf___3[3] = (char)0;
#line 485
      buf___3[4] = (char)0;
#line 485
      buf___3[5] = (char)0;
#line 486
      (*(data->impl.write))(ps, (unsigned char const   *)(buf___3), sizeof(buf___3),
                            1000);
      }
    }
  }
  {
#line 490
  err = (*(data->impl.poll))(ps, ps->accept_to * 1000);
  }
#line 490
  if (err < 0) {
#line 491
    goto fail;
  }
  {
#line 493
  data->timeout = ps->accept_to * 1000;
#line 495
  pi_socket_init(ps);
  }
#line 496
  if (ps->type == 16) {
    {
#line 501
    if (ps->cmd == 1) {
#line 501
      goto case_1;
    }
#line 531
    if (ps->cmd == 2) {
#line 531
      goto case_2;
    }
#line 500
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 502
    err = cmp_rx_handshake(ps, data->establishrate, data->establishhighrate);
    }
#line 502
    if (err < 0) {
#line 503
      goto fail;
    }
    {
#line 506
    size = sizeof(cmp_flags);
#line 507
    pi_getsockopt(ps->sd, 5, 1, (void *)(& cmp_flags), & size);
    }
#line 508
    if ((int )cmp_flags & 16) {
      {
#line 509
      use_long_format = 1;
#line 510
      size = sizeof(int );
#line 511
      pi_setsockopt(ps->sd, 2, 3, (void const   *)(& use_long_format), & size);
#line 513
      ps->command ^= 1;
#line 514
      pi_setsockopt(ps->sd, 2, 3, (void const   *)(& use_long_format), & size);
#line 516
      ps->command ^= 1;
      }
    }
    {
#line 520
    size = sizeof(data->rate);
#line 521
    pi_getsockopt(ps->sd, 5, 3, (void *)(& data->rate), & size);
#line 522
    err = (*(data->impl.changebaud))(ps);
    }
#line 522
    if (err < 0) {
#line 523
      goto fail;
    }
    {
#line 526
    tv.tv_sec = (__time_t )0;
#line 527
    tv.tv_usec = (__suseconds_t )50000;
#line 528
    select(0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0,
           (struct timeval */* __restrict  */)(& tv));
    }
#line 529
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 561
    err = net_rx_handshake(ps);
    }
#line 561
    if (err < 0) {
#line 562
      goto fail;
    }
#line 563
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 565
    ps->dlprecord = 0;
  }
#line 568
  data->timeout = 0;
#line 569
  ps->command = 0;
#line 570
  ps->state = 2;
#line 572
  return (ps->sd);
  fail: 
#line 575
  return (err);
}
}
#line 590 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_getsockopt___1(pi_socket_t *ps , int level , int option_name ,
                                    void *option_value , size_t *option_len ) 
{ 
  struct pi_serial_data *data ;
  int *tmp ;
  int tmp___0 ;

  {
#line 594
  data = (struct pi_serial_data *)(ps->device)->data;
  {
#line 598
  if (option_name == 0) {
#line 598
    goto case_0;
  }
#line 604
  if (option_name == 1) {
#line 604
    goto case_1;
  }
#line 610
  if (option_name == 2) {
#line 610
    goto case_2;
  }
#line 616
  if (option_name == 3) {
#line 616
    goto case_3;
  }
#line 597
  goto switch_break;
  case_0: /* CIL Label */ 
#line 599
  if (*option_len != sizeof(data->rate)) {
#line 600
    goto error;
  }
  {
#line 601
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->rate),
         sizeof(data->rate));
  }
#line 602
  goto switch_break;
  case_1: /* CIL Label */ 
#line 605
  if (*option_len != sizeof(data->establishrate)) {
#line 606
    goto error;
  }
  {
#line 607
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->establishrate),
         sizeof(data->establishrate));
  }
#line 608
  goto switch_break;
  case_2: /* CIL Label */ 
#line 611
  if (*option_len != sizeof(data->establishhighrate)) {
#line 612
    goto error;
  }
  {
#line 613
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->establishhighrate),
         sizeof(data->establishhighrate));
  }
#line 614
  goto switch_break;
  case_3: /* CIL Label */ 
#line 617
  if (*option_len != sizeof(data->timeout)) {
#line 618
    goto error;
  }
  {
#line 619
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->timeout),
         sizeof(data->timeout));
  }
#line 620
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 623
  return (0);
  error: 
  {
#line 626
  tmp = __errno_location();
#line 626
  *tmp = 22;
#line 627
  tmp___0 = pi_set_error(ps->sd, -501);
  }
#line 627
  return (tmp___0);
}
}
#line 642 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_setsockopt___1(pi_socket_t *ps , int level , int option_name ,
                                    void const   *option_value , size_t *option_len ) 
{ 
  struct pi_serial_data *data ;
  int *tmp ;
  int tmp___0 ;

  {
#line 646
  data = (struct pi_serial_data *)(ps->device)->data;
  {
#line 651
  if (option_name == 1) {
#line 651
    goto case_1;
  }
#line 657
  if (option_name == 2) {
#line 657
    goto case_2;
  }
#line 663
  if (option_name == 3) {
#line 663
    goto case_3;
  }
#line 650
  goto switch_break;
  case_1: /* CIL Label */ 
#line 652
  if (*option_len != sizeof(data->establishrate)) {
#line 653
    goto error;
  }
  {
#line 654
  memcpy((void */* __restrict  */)(& data->establishrate), (void const   */* __restrict  */)option_value,
         sizeof(data->establishrate));
  }
#line 655
  goto switch_break;
  case_2: /* CIL Label */ 
#line 658
  if (*option_len != sizeof(data->establishhighrate)) {
#line 659
    goto error;
  }
  {
#line 660
  memcpy((void */* __restrict  */)(& data->establishhighrate), (void const   */* __restrict  */)option_value,
         sizeof(data->establishhighrate));
  }
#line 661
  goto switch_break;
  case_3: /* CIL Label */ 
#line 664
  if (*option_len != sizeof(data->timeout)) {
#line 665
    goto error;
  }
  {
#line 666
  memcpy((void */* __restrict  */)(& data->timeout), (void const   */* __restrict  */)option_value,
         sizeof(data->timeout));
  }
#line 667
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 670
  return (0);
  error: 
  {
#line 673
  tmp = __errno_location();
#line 673
  *tmp = 22;
#line 674
  tmp___0 = pi_set_error(ps->sd, -501);
  }
#line 674
  return (tmp___0);
}
}
#line 689 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_close___1(pi_socket_t *ps ) 
{ 
  struct pi_serial_data *data ;

  {
#line 691
  data = (struct pi_serial_data *)(ps->device)->data;
#line 694
  if (ps->sd) {
    {
#line 695
    (*(data->impl.close))(ps);
#line 696
    ps->sd = 0;
    }
  }
#line 699
  if (ps->laddr) {
    {
#line 700
    free((void *)ps->laddr);
#line 701
    ps->laddr = (struct sockaddr *)((void *)0);
    }
  }
#line 704
  if (ps->raddr) {
    {
#line 705
    free((void *)ps->raddr);
#line 706
    ps->raddr = (struct sockaddr *)((void *)0);
    }
  }
#line 709
  return (0);
}
}
#line 124 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static int s_open___1(pi_socket_t *ps , struct pi_sockaddr *addr , size_t addrlen ) ;
#line 126
static int s_close___1(pi_socket_t *ps ) ;
#line 127
static int s_changebaud___1(pi_socket_t *ps ) ;
#line 128
static ssize_t s_write___1(pi_socket_t *ps , unsigned char const   *buf___3 , size_t len ,
                           int flags ) ;
#line 130
static ssize_t s_read___1(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) ;
#line 132
static int s_poll___1(pi_socket_t *ps , int timeout ) ;
#line 134
static speed_t calcrate___1(int baudrate ) ;
#line 136
static int s_flush___1(pi_socket_t *ps , int flags ) ;
#line 155 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static int s_open___1(pi_socket_t *ps , struct pi_sockaddr *addr , size_t addrlen ) 
{ 
  int fd ;
  int i ;
  char *tty ;
  struct pi_serial_data *data ;
  struct termios tcn ;
  int *tmp ;
  int tmp___0 ;
  speed_t tmp___1 ;

  {
  {
#line 160
  tty = addr->pi_device;
#line 162
  data = (struct pi_serial_data *)(ps->device)->data;
#line 170
  fd = open((char const   *)tty, 2050);
  }
#line 170
  if (fd < 0) {
#line 171
    ps->last_error = -502;
#line 172
    return (-502);
  }
  {
#line 175
  tmp___0 = isatty(fd);
  }
#line 175
  if (! tmp___0) {
    {
#line 176
    close(fd);
#line 177
    tmp = __errno_location();
#line 177
    *tmp = 22;
#line 178
    ps->last_error = -502;
    }
#line 179
    return (-502);
  }
  {
#line 184
  tcgetattr(fd, & tcn);
#line 186
  data->tco = tcn;
#line 187
  tcn.c_oflag = (tcflag_t )0;
#line 188
  tcn.c_iflag = (tcflag_t )5;
#line 189
  tcn.c_cflag = (tcflag_t )2224;
#line 191
  tmp___1 = calcrate___1(data->rate);
#line 191
  cfsetspeed(& tcn, tmp___1);
#line 193
  tcn.c_lflag = (tcflag_t )128;
#line 195
  cfmakeraw(& tcn);
#line 197
  i = 0;
  }
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! (i < 16)) {
#line 197
      goto while_break;
    }
#line 198
    tcn.c_cc[i] = (cc_t )0;
#line 197
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 200
  tcn.c_cc[6] = (cc_t )1;
#line 201
  tcn.c_cc[5] = (cc_t )0;
#line 203
  tcsetattr(fd, 0, (struct termios  const  *)(& tcn));
#line 217
  i = fcntl(fd, 3, 0);
  }
#line 217
  if (i != -1) {
    {
#line 218
    i &= -2049;
#line 219
    fcntl(fd, 4, i);
    }
  }
  {
#line 222
  i = pi_socket_setsd(ps, fd);
  }
#line 222
  if (i < 0) {
#line 223
    return (i);
  }
#line 225
  return (fd);
}
}
#line 240 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static int s_close___1(pi_socket_t *ps ) 
{ 
  int tmp ;

  {
  {
#line 255
  pi_log(2, 4, "DEV CLOSE unixserial fd: %d\n", ps->sd);
#line 258
  tmp = close(ps->sd);
  }
#line 258
  return (tmp);
}
}
#line 273 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static int s_poll___1(pi_socket_t *ps , int timeout ) 
{ 
  struct pi_serial_data *data ;
  struct timeval t ;
  fd_set ready ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 276
  data = (struct pi_serial_data *)(ps->device)->data;
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 281
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 286
  if (timeout == 0) {
    {
#line 287
    select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
           (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
    }
  } else {
    {
#line 289
    t.tv_sec = (__time_t )(timeout / 1000);
#line 290
    t.tv_usec = (__suseconds_t )((timeout % 1000) * 1000);
#line 291
    tmp___0 = select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
                     (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
    }
#line 291
    if (tmp___0 == 0) {
      {
#line 292
      tmp = pi_set_error(ps->sd, -202);
      }
#line 292
      return (tmp);
    }
  }
#line 295
  if (! ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
    {
#line 297
    pi_log(2, 2, "DEV POLL unixserial timeout\n");
#line 299
    (data->rx_errors) ++;
#line 300
    tmp___1 = __errno_location();
#line 300
    *tmp___1 = 110;
#line 301
    tmp___2 = pi_set_error(ps->sd, -202);
    }
#line 301
    return (tmp___2);
  }
  {
#line 303
  pi_log(2, 8, "DEV POLL unixserial found data on fd: %d\n", ps->sd);
  }
#line 306
  return (0);
}
}
#line 321 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static ssize_t s_write___1(pi_socket_t *ps , unsigned char const   *buf___3 , size_t len ,
                           int flags ) 
{ 
  ssize_t total ;
  ssize_t nwrote ;
  struct pi_serial_data *data ;
  struct timeval t ;
  fd_set ready ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 327
  data = (struct pi_serial_data *)(ps->device)->data;
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 332
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 335
  total = (ssize_t )len;
  {
#line 336
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 336
    if (! (total > 0L)) {
#line 336
      goto while_break___0;
    }
#line 337
    if (data->timeout == 0) {
      {
#line 338
      select(ps->sd + 1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)(& ready),
             (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
      }
    } else {
      {
#line 340
      t.tv_sec = (__time_t )(data->timeout / 1000);
#line 341
      t.tv_usec = (__suseconds_t )((data->timeout % 1000) * 1000);
#line 342
      tmp___0 = select(ps->sd + 1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)(& ready),
                       (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
      }
#line 342
      if (tmp___0 == 0) {
        {
#line 343
        tmp = pi_set_error(ps->sd, -202);
        }
#line 343
        return ((ssize_t )tmp);
      }
    }
#line 346
    if (! ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
      {
#line 347
      tmp___1 = pi_set_error(ps->sd, -202);
      }
#line 347
      return ((ssize_t )tmp___1);
    }
    {
#line 349
    nwrote = write(ps->sd, (void const   *)buf___3, len);
    }
#line 350
    if (nwrote < 0L) {
      {
#line 351
      tmp___3 = __errno_location();
      }
#line 351
      if (*tmp___3 == 32) {
        {
#line 352
        ps->state = 8;
#line 353
        tmp___2 = pi_set_error(ps->sd, -200);
        }
#line 353
        return ((ssize_t )tmp___2);
      } else {
        {
#line 351
        tmp___4 = __errno_location();
        }
#line 351
        if (*tmp___4 == 9) {
          {
#line 352
          ps->state = 8;
#line 353
          tmp___2 = pi_set_error(ps->sd, -200);
          }
#line 353
          return ((ssize_t )tmp___2);
        }
      }
      {
#line 355
      tmp___5 = pi_set_error(ps->sd, -204);
      }
#line 355
      return ((ssize_t )tmp___5);
    }
#line 357
    total -= nwrote;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 359
  data->tx_bytes = (int )((size_t )data->tx_bytes + len);
#line 362
  usleep((__useconds_t )(10UL + len));
#line 364
  pi_log(2, 8, "DEV TX unixserial wrote %d bytes\n", len);
  }
#line 367
  return ((ssize_t )len);
}
}
#line 382 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static size_t s_read_buf___1(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len ,
                             int flags ) 
{ 
  struct pi_serial_data *data ;
  size_t rbuf ;
  int *tmp ;
  int tmp___0 ;
  pi_buffer_t *tmp___1 ;

  {
#line 385
  data = (struct pi_serial_data *)(ps->device)->data;
#line 387
  rbuf = data->buf_size;
#line 389
  if (rbuf > len) {
#line 390
    rbuf = len;
  }
  {
#line 392
  tmp___1 = pi_buffer_append(buf___3, (void const   *)(data->buf), rbuf);
  }
#line 392
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 393
    tmp = __errno_location();
#line 393
    *tmp = 12;
#line 394
    tmp___0 = pi_set_error(ps->sd, -500);
    }
#line 394
    return ((size_t )tmp___0);
  }
#line 397
  if (flags != 1) {
#line 398
    data->buf_size -= rbuf;
#line 399
    if (data->buf_size > 0UL) {
      {
#line 400
      memmove((void *)(data->buf), (void const   *)(& data->buf[rbuf]), data->buf_size);
      }
    }
  }
  {
#line 403
  pi_log(2, 8, "DEV RX unixserial read %d bytes from read-ahead buffer\n", rbuf);
  }
#line 406
  return (rbuf);
}
}
#line 420 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static ssize_t s_read___1(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) 
{ 
  ssize_t rbuf ;
  ssize_t bytes ;
  struct pi_serial_data *data ;
  struct timeval t ;
  fd_set ready ;
  size_t tmp ;
  int __d0 ;
  int __d1 ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  pi_buffer_t *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
#line 423
  rbuf = (ssize_t )0;
#line 425
  data = (struct pi_serial_data *)(ps->device)->data;
#line 431
  if (data->buf_size) {
    {
#line 432
    tmp = s_read_buf___1(ps, buf___3, len, flags);
#line 432
    rbuf = (ssize_t )tmp;
    }
#line 433
    if (rbuf < 0L) {
#line 434
      return (rbuf);
    }
#line 435
    len -= (size_t )rbuf;
#line 436
    if (len == 0UL) {
#line 437
      return (rbuf);
    }
  }
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 442
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 444
  if (data->timeout == 0) {
    {
#line 445
    select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
           (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
    }
  } else {
    {
#line 447
    t.tv_sec = (__time_t )(data->timeout / 1000);
#line 448
    t.tv_usec = (__suseconds_t )((data->timeout % 1000) * 1000);
#line 449
    tmp___1 = select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
                     (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
    }
#line 449
    if (tmp___1 == 0) {
      {
#line 450
      tmp___0 = pi_set_error(ps->sd, -202);
      }
#line 450
      return ((ssize_t )tmp___0);
    }
  }
#line 454
  if ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 455
    if (flags == 1) {
#line 455
      if (len > 256UL) {
#line 456
        len = (size_t )256;
      }
    }
    {
#line 458
    tmp___4 = pi_buffer_expect(buf___3, len);
    }
#line 458
    if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
      {
#line 459
      tmp___2 = __errno_location();
#line 459
      *tmp___2 = 12;
#line 460
      tmp___3 = pi_set_error(ps->sd, -500);
      }
#line 460
      return ((ssize_t )tmp___3);
    }
    {
#line 463
    bytes = read(ps->sd, (void *)(buf___3->data + buf___3->used), len);
    }
#line 465
    if (bytes > 0L) {
#line 466
      if (flags == 1) {
        {
#line 467
        memcpy((void */* __restrict  */)(data->buf + data->buf_size), (void const   */* __restrict  */)(buf___3->data + buf___3->used),
               (size_t )bytes);
#line 468
        data->buf_size += (size_t )bytes;
        }
      }
      {
#line 470
      buf___3->used += (size_t )bytes;
#line 471
      data->rx_bytes = (int )((ssize_t )data->rx_bytes + bytes);
#line 472
      rbuf += bytes;
#line 474
      pi_log(2, 8, "DEV RX unixserial read %d bytes\n", bytes);
      }
    } else
#line 476
    if (bytes < 0L) {
#line 477
      rbuf = bytes;
    }
  } else {
    {
#line 480
    pi_log(2, 2, "DEV RX unixserial timeout\n");
#line 482
    (data->rx_errors) ++;
#line 483
    tmp___5 = __errno_location();
#line 483
    *tmp___5 = 110;
#line 484
    tmp___6 = pi_set_error(ps->sd, -202);
    }
#line 484
    return ((ssize_t )tmp___6);
  }
#line 487
  return (rbuf);
}
}
#line 507 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static int s_flush___1(pi_socket_t *ps , int flags ) 
{ 
  int fl ;
  char buf___3[256] ;
  struct pi_serial_data *data ;
  ssize_t tmp ;

  {
#line 512
  data = (struct pi_serial_data *)(ps->device)->data;
#line 514
  if (flags & 1) {
    {
#line 516
    data->buf_size = (size_t )0;
#line 519
    fl = fcntl(ps->sd, 3, 0);
    }
#line 519
    if (fl != -1) {
      {
#line 521
      fcntl(ps->sd, 4, fl | 2048);
      }
      {
#line 522
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 522
        tmp = recv(ps->sd, (void *)(buf___3), sizeof(buf___3), 0);
        }
#line 522
        if (! (tmp > 0L)) {
#line 522
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 524
      fcntl(ps->sd, 4, fl);
      }
    }
    {
#line 527
    pi_log(2, 8, "DEV FLUSH unixserial flushed input buffer\n");
    }
  }
#line 530
  return (0);
}
}
#line 569 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static int s_changebaud___1(pi_socket_t *ps ) 
{ 
  struct pi_serial_data *data ;
  struct termios tcn ;
  int tmp ;
  int tmp___0 ;
  speed_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 572
  data = (struct pi_serial_data *)(ps->device)->data;
#line 577
  pi_log(2, 8, "DEV SPEED unixserial switch to %d bps\n", data->rate);
#line 584
  tmp___0 = tcgetattr(ps->sd, & tcn);
  }
#line 584
  if (tmp___0) {
    {
#line 585
    tmp = pi_set_error(ps->sd, -502);
    }
#line 585
    return (tmp);
  }
  {
#line 587
  tcn.c_cflag = (tcflag_t )2224;
#line 588
  tmp___1 = calcrate___1(data->rate);
#line 588
  cfsetspeed(& tcn, tmp___1);
#line 590
  tmp___3 = tcsetattr(ps->sd, 1, (struct termios  const  *)(& tcn));
  }
#line 590
  if (tmp___3) {
    {
#line 591
    tmp___2 = pi_set_error(ps->sd, -502);
    }
#line 591
    return (tmp___2);
  }
#line 609
  return (0);
}
}
#line 649 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static speed_t calcrate___1(int baudrate ) 
{ 


  {
#line 653
  if (baudrate == 50) {
#line 654
    return ((speed_t )1);
  }
#line 657
  if (baudrate == 75) {
#line 658
    return ((speed_t )2);
  }
#line 661
  if (baudrate == 110) {
#line 662
    return ((speed_t )3);
  }
#line 665
  if (baudrate == 134) {
#line 666
    return ((speed_t )4);
  }
#line 669
  if (baudrate == 150) {
#line 670
    return ((speed_t )5);
  }
#line 673
  if (baudrate == 200) {
#line 674
    return ((speed_t )6);
  }
#line 677
  if (baudrate == 300) {
#line 678
    return ((speed_t )7);
  }
#line 681
  if (baudrate == 600) {
#line 682
    return ((speed_t )8);
  }
#line 685
  if (baudrate == 1200) {
#line 686
    return ((speed_t )9);
  }
#line 689
  if (baudrate == 1800) {
#line 690
    return ((speed_t )10);
  }
#line 693
  if (baudrate == 2400) {
#line 694
    return ((speed_t )11);
  }
#line 697
  if (baudrate == 4800) {
#line 698
    return ((speed_t )12);
  }
#line 701
  if (baudrate == 9600) {
#line 702
    return ((speed_t )13);
  } else
#line 705
  if (baudrate == 19200) {
#line 706
    return ((speed_t )14);
  } else
#line 709
  if (baudrate == 38400) {
#line 710
    return ((speed_t )15);
  } else
#line 713
  if (baudrate == 57600) {
#line 714
    return ((speed_t )4097);
  } else
#line 721
  if (baudrate == 115200) {
#line 722
    return ((speed_t )4098);
  } else
#line 725
  if (baudrate == 230400) {
#line 726
    return ((speed_t )4099);
  } else
#line 729
  if (baudrate == 460800) {
#line 730
    return ((speed_t )4100);
  }
  {
#line 733
  pi_log(2, 1, "DEV Serial CHANGEBAUD Unable to set baud rate %d\n", baudrate);
#line 736
  abort();
  }
#line 737
  return ((speed_t )0);
}
}
#line 31 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
static int debug_types___2  =    0;
#line 32 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
static int debug_level___2  =    0;
#line 33 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
static FILE *debug_file___2  =    (FILE *)((void *)0);
#line 34 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/debug.c"
static int logfile_mutex___2  =    0;
#line 41 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
static int sys_flush___2(pi_socket_t *ps , int flags ) ;
#line 42
static int sys_getsockopt___2(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) ;
#line 44
static int sys_setsockopt___2(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) ;
#line 59 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
static pi_protocol_t *sys_protocol_dup___2(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  pi_sys_data_t *data ;
  pi_sys_data_t *new_data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 62
  new_prot = (pi_protocol_t *)((void *)0);
#line 63
  data = (pi_sys_data_t *)((void *)0);
#line 63
  new_data = (pi_sys_data_t *)((void *)0);
#line 66
  tmp = malloc(sizeof(pi_protocol_t ));
#line 66
  new_prot = (pi_protocol_t *)tmp;
  }
#line 67
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
    {
#line 68
    tmp___0 = malloc(sizeof(pi_sys_data_t ));
#line 68
    new_data = (pi_sys_data_t *)tmp___0;
    }
#line 69
    if ((unsigned long )new_data == (unsigned long )((void *)0)) {
      {
#line 70
      free((void *)new_prot);
#line 71
      new_prot = (pi_protocol_t *)((void *)0);
      }
    }
  }
#line 75
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 75
    if ((unsigned long )new_data != (unsigned long )((void *)0)) {
#line 76
      new_prot->level = prot->level;
#line 77
      new_prot->dup = prot->dup;
#line 78
      new_prot->free = prot->free;
#line 79
      new_prot->read = prot->read;
#line 80
      new_prot->write = prot->write;
#line 81
      new_prot->flush = prot->flush;
#line 82
      new_prot->getsockopt = prot->getsockopt;
#line 83
      new_prot->setsockopt = prot->setsockopt;
#line 85
      data = (pi_sys_data_t *)prot->data;
#line 86
      new_data->txid = data->txid;
#line 87
      new_prot->data = (void *)new_data;
    }
  }
#line 90
  return (new_prot);
}
}
#line 105 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
static void sys_protocol_free___2(pi_protocol_t *prot ) 
{ 


  {
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 109
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c",
             109, "prot != NULL");
      }
    }
#line 109
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 111
    if ((unsigned long )prot->data != (unsigned long )((void *)0)) {
      {
#line 112
      free(prot->data);
      }
    }
    {
#line 113
    free((void *)prot);
    }
  }
#line 115
  return;
}
}
#line 275 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
static int sys_flush___2(pi_socket_t *ps , int flags ) 
{ 
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 281
  prot = pi_protocol(ps->sd, 4);
  }
#line 282
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 283
    tmp = pi_set_error(ps->sd, -201);
    }
#line 283
    return (tmp);
  }
  {
#line 285
  next = pi_protocol_next(ps->sd, 4);
  }
#line 286
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 287
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 287
    return (tmp___0);
  }
  {
#line 289
  tmp___1 = (*(next->flush))(ps, flags);
  }
#line 289
  return (tmp___1);
}
}
#line 303 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
static int sys_getsockopt___2(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) 
{ 


  {
#line 307
  return (0);
}
}
#line 322 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/sys.c"
static int sys_setsockopt___2(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) 
{ 


  {
#line 326
  return (0);
}
}
#line 42 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static int net_flush___2(pi_socket_t *ps , int flags ) ;
#line 43
static int net_getsockopt___2(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) ;
#line 45
static int net_setsockopt___2(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) ;
#line 59 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static pi_protocol_t *net_protocol_dup___2(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  pi_net_data_t *data ;
  pi_net_data_t *new_data ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 62
  new_prot = (pi_protocol_t *)((void *)0);
#line 63
  data = (pi_net_data_t *)((void *)0);
#line 63
  new_data = (pi_net_data_t *)((void *)0);
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 66
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c",
             66, "prot != NULL");
      }
    }
#line 66
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 68
  tmp = malloc(sizeof(pi_protocol_t ));
#line 68
  new_prot = (pi_protocol_t *)tmp;
  }
#line 69
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
    {
#line 70
    tmp___0 = malloc(sizeof(pi_net_data_t ));
#line 70
    new_data = (pi_net_data_t *)tmp___0;
    }
#line 71
    if ((unsigned long )new_data == (unsigned long )((void *)0)) {
      {
#line 72
      free((void *)new_prot);
#line 73
      new_prot = (pi_protocol_t *)((void *)0);
      }
    }
  }
#line 77
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 77
    if ((unsigned long )new_data != (unsigned long )((void *)0)) {
#line 78
      new_prot->level = prot->level;
#line 79
      new_prot->dup = prot->dup;
#line 80
      new_prot->free = prot->free;
#line 81
      new_prot->read = prot->read;
#line 82
      new_prot->write = prot->write;
#line 83
      new_prot->flush = prot->flush;
#line 84
      new_prot->getsockopt = prot->getsockopt;
#line 85
      new_prot->setsockopt = prot->setsockopt;
#line 87
      data = (pi_net_data_t *)prot->data;
#line 88
      new_data->type = data->type;
#line 89
      new_data->split_writes = data->split_writes;
#line 90
      new_data->write_chunksize = data->write_chunksize;
#line 91
      new_data->txid = data->txid;
#line 92
      new_prot->data = (void *)new_data;
    }
  }
#line 95
  return (new_prot);
}
}
#line 110 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static void net_protocol_free___2(pi_protocol_t *prot ) 
{ 


  {
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 113
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c",
             113, "prot != NULL");
      }
    }
#line 113
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 116
    if ((unsigned long )prot->data != (unsigned long )((void *)0)) {
      {
#line 117
      free(prot->data);
      }
    }
    {
#line 118
    free((void *)prot);
    }
  }
#line 120
  return;
}
}
#line 184 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static unsigned char const   msg1___5[51]  = 
#line 184
  {      (unsigned char const   )'\022',      (unsigned char const   )'\001',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )' ',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'$',      (unsigned char const   )'\377',      (unsigned char const   )'\377', 
        (unsigned char const   )'\377',      (unsigned char const   )'\377',      (unsigned char const   )'<',      (unsigned char const   )'\000', 
        (unsigned char const   )'<',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\300',      (unsigned char const   )'\250', 
        (unsigned char const   )'\245',      (unsigned char const   )'\037',      (unsigned char const   )'\004',      (unsigned char const   )'\'', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000'};
#line 189 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static unsigned char const   msg2___5[47]  = 
#line 189
  {      (unsigned char const   )'\023',      (unsigned char const   )'\001',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )' ',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )' ',      (unsigned char const   )'\377',      (unsigned char const   )'\377', 
        (unsigned char const   )'\377',      (unsigned char const   )'\377',      (unsigned char const   )'\000',      (unsigned char const   )'<', 
        (unsigned char const   )'\000',      (unsigned char const   )'<',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\001',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000'};
#line 232 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static unsigned char const   msg1___6[23]  = 
#line 232
  {      (unsigned char const   )'\220',      (unsigned char const   )'\001',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )' ',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\b',      (unsigned char const   )'\001',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000'};
#line 235 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static unsigned char const   msg2___6[51]  = 
#line 235
  {      (unsigned char const   )'\222',      (unsigned char const   )'\001',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )' ',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'$',      (unsigned char const   )'\377',      (unsigned char const   )'\377', 
        (unsigned char const   )'\377',      (unsigned char const   )'\377',      (unsigned char const   )'\000',      (unsigned char const   )'<', 
        (unsigned char const   )'\000',      (unsigned char const   )'<',      (unsigned char const   )'@',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\001',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\300',      (unsigned char const   )'\250', 
        (unsigned char const   )'\245',      (unsigned char const   )'\036',      (unsigned char const   )'\004',      (unsigned char const   )'\001', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000'};
#line 240 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static unsigned char const   msg3___2[9]  = 
#line 240
  {      (unsigned char const   )'\223',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000',      (unsigned char const   )'\000', 
        (unsigned char const   )'\000'};
#line 276 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static int net_flush___2(pi_socket_t *ps , int flags ) 
{ 
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 282
  prot = pi_protocol(ps->sd, 3);
  }
#line 283
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 284
    tmp = pi_set_error(ps->sd, -201);
    }
#line 284
    return (tmp);
  }
  {
#line 286
  next = pi_protocol_next(ps->sd, 3);
  }
#line 287
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 288
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 288
    return (tmp___0);
  }
  {
#line 290
  tmp___1 = (*(next->flush))(ps, flags);
  }
#line 290
  return (tmp___1);
}
}
#line 572 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static int net_getsockopt___2(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  pi_net_data_t *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 579
  prot = pi_protocol(ps->sd, 3);
  }
#line 580
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 581
    tmp = pi_set_error(ps->sd, -201);
    }
#line 581
    return (tmp);
  }
#line 583
  data = (pi_net_data_t *)prot->data;
  {
#line 586
  if (option_name == 0) {
#line 586
    goto case_0;
  }
#line 585
  goto switch_break;
  case_0: /* CIL Label */ 
#line 587
  if (*option_len != sizeof(data->type)) {
    {
#line 588
    tmp___0 = __errno_location();
#line 588
    *tmp___0 = 22;
#line 589
    tmp___1 = pi_set_error(ps->sd, -501);
    }
#line 589
    return (tmp___1);
  }
  {
#line 591
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->type),
         sizeof(data->type));
#line 593
  *option_len = sizeof(data->type);
  }
#line 594
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 597
  return (0);
}
}
#line 612 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/net.c"
static int net_setsockopt___2(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  pi_net_data_t *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 619
  prot = pi_protocol(ps->sd, 3);
  }
#line 620
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 621
    tmp = pi_set_error(ps->sd, -201);
    }
#line 621
    return (tmp);
  }
#line 623
  data = (pi_net_data_t *)prot->data;
  {
#line 626
  if (option_name == 0) {
#line 626
    goto case_0;
  }
#line 639
  if (option_name == 1) {
#line 639
    goto case_1;
  }
#line 653
  if (option_name == 2) {
#line 653
    goto case_2;
  }
#line 625
  goto switch_break;
  case_0: /* CIL Label */ 
#line 627
  if (*option_len != sizeof(data->type)) {
    {
#line 628
    tmp___0 = __errno_location();
#line 628
    *tmp___0 = 22;
#line 629
    tmp___1 = pi_set_error(ps->sd, -501);
    }
#line 629
    return (tmp___1);
  }
  {
#line 631
  memcpy((void */* __restrict  */)(& data->type), (void const   */* __restrict  */)option_value,
         sizeof(data->type));
  }
#line 633
  goto switch_break;
  case_1: /* CIL Label */ 
#line 640
  if (*option_len != sizeof(data->split_writes)) {
    {
#line 641
    tmp___2 = __errno_location();
#line 641
    *tmp___2 = 22;
#line 642
    tmp___3 = pi_set_error(ps->sd, -501);
    }
#line 642
    return (tmp___3);
  }
  {
#line 644
  memcpy((void */* __restrict  */)(& data->split_writes), (void const   */* __restrict  */)option_value,
         sizeof(data->split_writes));
  }
#line 646
  goto switch_break;
  case_2: /* CIL Label */ 
#line 654
  if (*option_len != sizeof(data->write_chunksize)) {
    {
#line 655
    tmp___4 = __errno_location();
#line 655
    *tmp___4 = 22;
#line 656
    tmp___5 = pi_set_error(ps->sd, -501);
    }
#line 656
    return (tmp___5);
  }
  {
#line 658
  memcpy((void */* __restrict  */)(& data->write_chunksize), (void const   */* __restrict  */)option_value,
         sizeof(data->write_chunksize));
  }
#line 660
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 663
  return (0);
}
}
#line 45 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static int padp_flush___2(pi_socket_t *ps , int flags ) ;
#line 46
static int padp_getsockopt___2(pi_socket_t *ps , int level , int option_name , void *option_value ,
                               size_t *option_len ) ;
#line 48
static int padp_setsockopt___2(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                               size_t *option_len ) ;
#line 50
static int padp_sendack___2(struct pi_socket *ps , struct pi_padp_data *data , unsigned char txid ,
                            struct padp *padp , int flags ) ;
#line 65 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static pi_protocol_t *padp_protocol_dup___2(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  pi_padp_data_t *data ;
  pi_padp_data_t *new_data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 68
  new_prot = (pi_protocol_t *)((void *)0);
#line 69
  data = (pi_padp_data_t *)((void *)0);
#line 69
  new_data = (pi_padp_data_t *)((void *)0);
#line 72
  tmp = malloc(sizeof(pi_protocol_t ));
#line 72
  new_prot = (pi_protocol_t *)tmp;
  }
#line 73
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
    {
#line 74
    tmp___0 = malloc(sizeof(pi_padp_data_t ));
#line 74
    new_data = (pi_padp_data_t *)tmp___0;
    }
#line 75
    if ((unsigned long )new_data == (unsigned long )((void *)0)) {
      {
#line 76
      free((void *)new_prot);
#line 77
      new_prot = (pi_protocol_t *)((void *)0);
      }
    } else {
      {
#line 79
      new_prot->level = prot->level;
#line 80
      new_prot->dup = prot->dup;
#line 81
      new_prot->free = prot->free;
#line 82
      new_prot->read = prot->read;
#line 83
      new_prot->write = prot->write;
#line 84
      new_prot->flush = prot->flush;
#line 85
      new_prot->getsockopt = prot->getsockopt;
#line 86
      new_prot->setsockopt = prot->setsockopt;
#line 88
      data = (pi_padp_data_t *)prot->data;
#line 89
      memcpy((void */* __restrict  */)new_data, (void const   */* __restrict  */)data,
             sizeof(pi_padp_data_t ));
#line 90
      new_prot->data = (void *)new_data;
      }
    }
  }
#line 94
  return (new_prot);
}
}
#line 109 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static void padp_protocol_free___2(pi_protocol_t *prot ) 
{ 


  {
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 112
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c",
             112, "prot != NULL");
      }
    }
#line 112
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 115
    if ((unsigned long )prot->data != (unsigned long )((void *)0)) {
      {
#line 116
      free(prot->data);
      }
    }
    {
#line 117
    free((void *)prot);
    }
  }
#line 119
  return;
}
}
#line 681 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static int padp_flush___2(pi_socket_t *ps , int flags ) 
{ 
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 687
  prot = pi_protocol(ps->sd, 2);
  }
#line 688
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 689
    tmp = pi_set_error(ps->sd, -201);
    }
#line 689
    return (tmp);
  }
  {
#line 691
  next = pi_protocol_next(ps->sd, 2);
  }
#line 692
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 693
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 693
    return (tmp___0);
  }
  {
#line 695
  tmp___1 = (*(next->flush))(ps, flags);
  }
#line 695
  return (tmp___1);
}
}
#line 709 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static int padp_getsockopt___2(pi_socket_t *ps , int level , int option_name , void *option_value ,
                               size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  pi_padp_data_t *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 716
  prot = pi_protocol(ps->sd, 2);
  }
#line 717
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 718
    tmp = pi_set_error(ps->sd, -201);
    }
#line 718
    return (tmp);
  }
#line 719
  data = (pi_padp_data_t *)prot->data;
  {
#line 722
  if (option_name == 0) {
#line 722
    goto case_0;
  }
#line 728
  if (option_name == 1) {
#line 728
    goto case_1;
  }
#line 734
  if (option_name == 2) {
#line 734
    goto case_2;
  }
#line 740
  if (option_name == 3) {
#line 740
    goto case_3;
  }
#line 721
  goto switch_break;
  case_0: /* CIL Label */ 
#line 723
  if (*option_len != sizeof(data->type)) {
#line 724
    goto error;
  }
  {
#line 725
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->type),
         sizeof(data->type));
  }
#line 726
  goto switch_break;
  case_1: /* CIL Label */ 
#line 729
  if (*option_len != sizeof(data->last_type)) {
#line 730
    goto error;
  }
  {
#line 731
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->last_type),
         sizeof(data->last_type));
  }
#line 732
  goto switch_break;
  case_2: /* CIL Label */ 
#line 735
  if (*option_len != sizeof(data->freeze_txid)) {
#line 736
    goto error;
  }
  {
#line 737
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->freeze_txid),
         sizeof(data->freeze_txid));
  }
#line 738
  goto switch_break;
  case_3: /* CIL Label */ 
#line 741
  if (*option_len != sizeof(data->use_long_format)) {
#line 742
    goto error;
  }
  {
#line 743
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->use_long_format),
         sizeof(data->use_long_format));
  }
#line 744
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 747
  return (0);
  error: 
  {
#line 750
  tmp___0 = __errno_location();
#line 750
  *tmp___0 = 22;
#line 751
  tmp___1 = pi_set_error(ps->sd, -501);
  }
#line 751
  return (tmp___1);
}
}
#line 766 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static int padp_setsockopt___2(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                               size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  pi_padp_data_t *data ;
  int was_frozen ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 774
  prot = pi_protocol(ps->sd, 2);
  }
#line 775
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 776
    tmp = pi_set_error(ps->sd, -201);
    }
#line 776
    return (tmp);
  }
#line 777
  data = (pi_padp_data_t *)prot->data;
  {
#line 780
  if (option_name == 0) {
#line 780
    goto case_0;
  }
#line 786
  if (option_name == 2) {
#line 786
    goto case_2;
  }
#line 798
  if (option_name == 3) {
#line 798
    goto case_3;
  }
#line 779
  goto switch_break;
  case_0: /* CIL Label */ 
#line 781
  if (*option_len != sizeof(data->type)) {
#line 782
    goto error;
  }
  {
#line 783
  memcpy((void */* __restrict  */)(& data->type), (void const   */* __restrict  */)option_value,
         sizeof(data->type));
  }
#line 784
  goto switch_break;
  case_2: /* CIL Label */ 
#line 787
  if (*option_len != sizeof(data->freeze_txid)) {
#line 788
    goto error;
  }
  {
#line 789
  was_frozen = data->freeze_txid;
#line 790
  memcpy((void */* __restrict  */)(& data->freeze_txid), (void const   */* __restrict  */)option_value,
         sizeof(data->freeze_txid));
  }
#line 791
  if (was_frozen) {
#line 791
    if (! data->freeze_txid) {
#line 792
      (data->next_txid) ++;
#line 793
      if (data->next_txid >= 254U) {
#line 794
        data->next_txid = 1U;
      }
    }
  }
#line 796
  goto switch_break;
  case_3: /* CIL Label */ 
#line 799
  if (*option_len != sizeof(data->use_long_format)) {
#line 800
    goto error;
  }
  {
#line 801
  memcpy((void */* __restrict  */)(& data->use_long_format), (void const   */* __restrict  */)option_value,
         sizeof(data->use_long_format));
  }
#line 802
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 805
  return (0);
  error: 
  {
#line 808
  tmp___0 = __errno_location();
#line 808
  *tmp___0 = 22;
#line 809
  tmp___1 = pi_set_error(ps->sd, -501);
  }
#line 809
  return (tmp___1);
}
}
#line 823 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/padp.c"
static int padp_sendack___2(struct pi_socket *ps , struct pi_padp_data *data , unsigned char txid ,
                            struct padp *padp , int flags ) 
{ 
  int type ;
  int socket___0 ;
  int result ;
  int header_size ;
  size_t size ;
  unsigned char npadp_buf[6] ;
  struct pi_protocol *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;

  {
  {
#line 840
  next = pi_protocol_next(ps->sd, 2);
  }
#line 841
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 842
    tmp = pi_set_error(ps->sd, -201);
    }
#line 842
    return (tmp);
  }
  {
#line 844
  type = 2;
#line 845
  socket___0 = 3;
#line 846
  size = sizeof(type);
#line 847
  pi_setsockopt(ps->sd, 1, 4, (void const   *)(& type), & size);
#line 848
  pi_setsockopt(ps->sd, 1, 0, (void const   *)(& socket___0), & size);
#line 849
  pi_setsockopt(ps->sd, 1, 2, (void const   *)(& socket___0), & size);
#line 850
  size = sizeof(txid);
#line 851
  pi_setsockopt(ps->sd, 1, 6, (void const   *)(& txid), & size);
#line 853
  header_size = 4;
#line 854
  *(& npadp_buf[0] + 0) = (unsigned char)2;
#line 855
  *(& npadp_buf[1] + 0) = padp->flags;
  }
#line 856
  if ((int )padp->flags & 16) {
#line 857
    header_size += 2;
#line 858
    *(& npadp_buf[2] + 0) = (unsigned char )((int )((unsigned char )((unsigned long )padp->size >> 24)) & 255);
#line 858
    *(& npadp_buf[2] + 1) = (unsigned char )(((unsigned long )padp->size >> 16) & 255UL);
#line 858
    *(& npadp_buf[2] + 2) = (unsigned char )(((unsigned long )padp->size >> 8) & 255UL);
#line 858
    *(& npadp_buf[2] + 3) = (unsigned char )((unsigned long )padp->size & 255UL);
  } else {
#line 860
    *(& npadp_buf[2] + 0) = (unsigned char )(((int )((unsigned short )padp->size) >> 8) & 255);
#line 860
    *(& npadp_buf[2] + 1) = (unsigned char )((int )((unsigned short )padp->size) & 255);
  }
  {
#line 863
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 863
    tmp___0 = pi_debug_get_types();
    }
#line 863
    if (tmp___0 & 8) {
      {
#line 863
      tmp___1 = pi_debug_get_level();
      }
#line 863
      if (tmp___1 >= 4) {
        {
#line 863
        padp_dump_header((unsigned char const   *)(npadp_buf), 1);
        }
      }
    }
#line 863
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 864
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 864
    tmp___2 = pi_debug_get_types();
    }
#line 864
    if (tmp___2 & 8) {
      {
#line 864
      tmp___3 = pi_debug_get_level();
      }
#line 864
      if (tmp___3 >= 8) {
        {
#line 864
        padp_dump((unsigned char const   *)(npadp_buf));
        }
      }
    }
#line 864
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 866
  tmp___4 = (*(next->write))(ps, (unsigned char const   *)(npadp_buf), (size_t )header_size,
                             flags);
#line 866
  result = (int )tmp___4;
  }
#line 868
  if (result >= 0) {
#line 869
    data->last_ack_txid = txid;
#line 870
    data->last_ack_padp.type = padp->type;
#line 871
    data->last_ack_padp.flags = padp->flags;
#line 872
    data->last_ack_padp.size = padp->size;
  }
#line 875
  return (result);
}
}
#line 52 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_connect___2(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
#line 54
static int pi_usb_bind___2(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
#line 56
static int pi_usb_listen___2(pi_socket_t *ps , int backlog ) ;
#line 57
static int pi_usb_accept___2(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) ;
#line 59
static int pi_usb_getsockopt___2(pi_socket_t *ps , int level , int option_name , void *option_value ,
                                 size_t *option_len ) ;
#line 61
static int pi_usb_setsockopt___2(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                                 size_t *option_len ) ;
#line 63
static int pi_usb_close___2(pi_socket_t *ps ) ;
#line 65
static int USB_configure_visor___2(pi_usb_data_t *dev , u_int8_t *input_pipe , u_int8_t *output_pipe ) ;
#line 66
static int USB_configure_generic___2(pi_usb_data_t *dev , u_int8_t *input_pipe , u_int8_t *output_pipe ) ;
#line 118 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static void pi_usb_protocol_free___2(pi_protocol_t *prot ) 
{ 


  {
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 121
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
             121, "prot != NULL");
      }
    }
#line 121
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
    {
#line 124
    free((void *)prot);
    }
  }
#line 125
  return;
}
}
#line 139 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static pi_protocol_t *pi_usb_protocol___2(pi_device_t *dev ) 
{ 
  pi_protocol_t *prot ;
  pi_usb_data_t *data ;
  void *tmp ;

  {
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! ((unsigned long )dev != (unsigned long )((void *)0))) {
      {
#line 145
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
             145, "dev != NULL");
      }
    }
#line 145
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 147
  data = (pi_usb_data_t *)dev->data;
#line 149
  tmp = malloc(sizeof(pi_protocol_t ));
#line 149
  prot = (pi_protocol_t *)tmp;
  }
#line 151
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 152
    prot->level = 0;
#line 153
    prot->dup = & pi_usb_protocol_dup;
#line 154
    prot->free = & pi_usb_protocol_free___2;
#line 155
    prot->read = data->impl.read;
#line 156
    prot->write = data->impl.write;
#line 157
    prot->flush = data->impl.flush;
#line 158
    prot->getsockopt = & pi_usb_getsockopt___2;
#line 159
    prot->setsockopt = & pi_usb_setsockopt___2;
#line 160
    prot->data = (void *)0;
  }
#line 163
  return (prot);
}
}
#line 177 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static void pi_usb_device_free___2(pi_device_t *dev ) 
{ 
  pi_usb_data_t *data ;

  {
#line 180
  data = (pi_usb_data_t *)dev->data;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! ((unsigned long )dev != (unsigned long )((void *)0))) {
      {
#line 182
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
             182, "dev != NULL");
      }
    }
#line 182
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  if ((unsigned long )data != (unsigned long )((void *)0)) {
    {
#line 185
    free((void *)data);
    }
  }
#line 186
  if ((unsigned long )dev != (unsigned long )((void *)0)) {
    {
#line 187
    free((void *)dev);
    }
  }
#line 188
  return;
}
}
#line 247 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_connect___2(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) 
{ 
  struct pi_usb_data *data ;
  struct pi_sockaddr *pa ;
  int result ;
  int timeout ;
  size_t size ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 250
  data = (pi_usb_data_t *)(ps->device)->data;
#line 251
  pa = (struct pi_sockaddr *)addr;
#line 255
  if (ps->type == 16) {
#line 256
    if (ps->protocol == 3) {
#line 257
      tmp = 57600;
#line 257
      data->rate = tmp;
#line 257
      data->establishrate = tmp;
    } else {
#line 259
      if (data->establishrate == -1) {
        {
#line 260
        get_pilot_rate(& data->establishrate, & data->establishhighrate);
        }
      }
#line 263
      data->rate = 9600;
    }
  } else
#line 265
  if (ps->type == 48) {
#line 267
    tmp___0 = 57600;
#line 267
    data->rate = tmp___0;
#line 267
    data->establishrate = tmp___0;
  }
  {
#line 270
  result = (*(data->impl.open))(ps, pa, addrlen);
  }
#line 271
  if (result < 0) {
#line 272
    goto fail;
  }
#line 274
  timeout = ps->accept_to * 1000;
#line 274
  data->timeout = timeout;
#line 276
  if (data->impl.wait_for_device) {
    {
#line 277
    result = (*(data->impl.wait_for_device))(ps, & timeout);
    }
#line 278
    if (result <= 0) {
#line 279
      goto fail;
    }
  }
  {
#line 282
  tmp___1 = malloc(addrlen);
#line 282
  ps->raddr = (struct sockaddr *)tmp___1;
#line 283
  memcpy((void */* __restrict  */)ps->raddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 284
  ps->raddrlen = addrlen;
#line 285
  tmp___2 = malloc(addrlen);
#line 285
  ps->laddr = (struct sockaddr *)tmp___2;
#line 286
  memcpy((void */* __restrict  */)ps->laddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 287
  ps->laddrlen = addrlen;
  }
#line 289
  if (ps->type == 16) {
    {
#line 291
    if (ps->cmd == 1) {
#line 291
      goto case_1;
    }
#line 301
    if (ps->cmd == 2) {
#line 301
      goto case_2;
    }
#line 290
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 292
    result = cmp_tx_handshake(ps);
    }
#line 292
    if (result < 0) {
#line 293
      goto fail;
    }
    {
#line 294
    size = sizeof(data->rate);
#line 295
    pi_getsockopt(ps->sd, 5, 3, (void *)(& data->rate), & size);
#line 297
    result = (*(data->impl.changebaud))(ps);
    }
#line 297
    if (result < 0) {
#line 298
      goto fail;
    }
#line 299
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 302
    result = net_tx_handshake(ps);
    }
#line 302
    if (result < 0) {
#line 303
      goto fail;
    }
#line 304
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 307
  ps->state = 4;
#line 308
  ps->command = 0;
  fail: 
#line 311
  if (result < 0) {
#line 311
    tmp___3 = result;
  } else {
#line 311
    tmp___3 = 0;
  }
#line 311
  return (tmp___3);
}
}
#line 325 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_bind___2(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) 
{ 
  struct pi_usb_data *data ;
  struct pi_sockaddr *pa ;
  int result ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 328
  data = (pi_usb_data_t *)(ps->device)->data;
#line 329
  pa = (struct pi_sockaddr *)addr;
#line 335
  if (ps->type == 16) {
#line 336
    if (data->establishrate == -1) {
      {
#line 337
      get_pilot_rate(& data->establishrate, & data->establishhighrate);
      }
    }
#line 340
    data->rate = 9600;
  } else
#line 341
  if (ps->type == 48) {
#line 343
    tmp = 57600;
#line 343
    data->rate = tmp;
#line 343
    data->establishrate = tmp;
  }
  {
#line 346
  result = (*(data->impl.open))(ps, pa, addrlen);
  }
#line 347
  if (result < 0) {
#line 348
    return (result);
  }
  {
#line 350
  tmp___0 = malloc(addrlen);
#line 350
  ps->raddr = (struct sockaddr *)tmp___0;
#line 351
  memcpy((void */* __restrict  */)ps->raddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 352
  ps->raddrlen = addrlen;
#line 353
  tmp___1 = malloc(addrlen);
#line 353
  ps->laddr = (struct sockaddr *)tmp___1;
#line 354
  memcpy((void */* __restrict  */)ps->laddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 355
  ps->laddrlen = addrlen;
  }
#line 357
  return (0);
}
}
#line 371 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_listen___2(pi_socket_t *ps , int backlog ) 
{ 


  {
#line 374
  ps->state = 1;
#line 375
  return (0);
}
}
#line 389 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_accept___2(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) 
{ 
  struct pi_usb_data *data ;
  int result ;
  int timeout ;
  size_t size ;
  struct timeval tv ;
  unsigned char cmp_flags ;
  int use_long_format ;

  {
#line 392
  data = (pi_usb_data_t *)(ps->device)->data;
#line 397
  timeout = ps->accept_to * 1000;
#line 397
  data->timeout = timeout;
#line 399
  if (data->impl.wait_for_device) {
    {
#line 400
    result = (*(data->impl.wait_for_device))(ps, & timeout);
    }
#line 401
    if (result <= 0) {
#line 402
      return (result);
    }
  }
  {
#line 423
  result = (*(data->impl.poll))(ps, timeout);
  }
#line 424
  if (result <= 0) {
#line 425
    if (result == 0) {
#line 426
      return (-205);
    } else {
#line 428
      return (result);
    }
  }
  {
#line 432
  pi_socket_init(ps);
#line 434
  pi_log(2, 8, "%s: %d, prot: 0x%x, type: 0x%x, cmd: 0x%x.\n", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
         434, ps->protocol, ps->type, ps->cmd);
  }
#line 435
  if (ps->type == 16) {
    {
#line 440
    if (ps->cmd == 1) {
#line 440
      goto case_1;
    }
#line 476
    if (ps->cmd == 2) {
#line 476
      goto case_2;
    }
#line 485
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 441
    pi_log(2, 8, "%s: %d, cmp rx.\n", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
           441);
#line 442
    result = cmp_rx_handshake(ps, data->establishrate, data->establishhighrate);
    }
#line 442
    if (result < 0) {
      {
#line 444
      pi_log(2, 8, "usb.c: cmp_rx_handshake returned %d\n", result);
      }
#line 445
      return (result);
    }
    {
#line 449
    size = sizeof(cmp_flags);
#line 450
    pi_getsockopt(ps->sd, 5, 1, (void *)(& cmp_flags), & size);
    }
#line 451
    if ((int )cmp_flags & 16) {
      {
#line 452
      use_long_format = 1;
#line 453
      size = sizeof(int );
#line 454
      pi_setsockopt(ps->sd, 2, 3, (void const   *)(& use_long_format), & size);
#line 456
      ps->command ^= 1;
#line 457
      pi_setsockopt(ps->sd, 2, 3, (void const   *)(& use_long_format), & size);
#line 459
      ps->command ^= 1;
      }
    }
    {
#line 463
    size = sizeof(data->rate);
#line 464
    pi_getsockopt(ps->sd, 5, 3, (void *)(& data->rate), & size);
    }
#line 465
    if ((unsigned long )data->impl.changebaud != (unsigned long )((void *)0)) {
      {
#line 466
      result = (*(data->impl.changebaud))(ps);
      }
#line 466
      if (result < 0) {
#line 467
        return (result);
      }
      {
#line 470
      tv.tv_sec = (__time_t )0;
#line 471
      tv.tv_usec = (__suseconds_t )50000;
#line 472
      select(0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0,
             (struct timeval */* __restrict  */)(& tv));
      }
    }
#line 474
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 477
    pi_log(2, 8, "%s: %d, net rx.\n", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
           477);
#line 478
    result = net_rx_handshake(ps);
    }
#line 478
    if (result < 0) {
      {
#line 480
      pi_log(2, 8, "usb.c: cmp_rx_handshake returned %d\n", result);
      }
#line 481
      return (result);
    }
#line 483
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 486
    pi_log(2, 1, "%s: %d, unknown rx %x.\n", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c",
           486, ps->cmd);
    }
#line 487
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 489
    ps->dlprecord = 0;
  }
#line 492
  data->timeout = 0;
#line 493
  ps->command = 0;
#line 494
  ps->state = 2;
#line 495
  return (ps->sd);
}
}
#line 509 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_getsockopt___2(pi_socket_t *ps , int level , int option_name , void *option_value ,
                                 size_t *option_len ) 
{ 
  pi_usb_data_t *data ;
  int *tmp ;
  int tmp___0 ;

  {
#line 513
  data = (pi_usb_data_t *)(ps->device)->data;
  {
#line 516
  if (option_name == 0) {
#line 516
    goto case_0;
  }
#line 522
  if (option_name == 1) {
#line 522
    goto case_1;
  }
#line 529
  if (option_name == 2) {
#line 529
    goto case_2;
  }
#line 536
  if (option_name == 3) {
#line 536
    goto case_3;
  }
#line 515
  goto switch_break;
  case_0: /* CIL Label */ 
#line 517
  if (*option_len != sizeof(data->rate)) {
#line 518
    goto fail;
  }
  {
#line 519
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->rate),
         sizeof(data->rate));
  }
#line 520
  goto switch_break;
  case_1: /* CIL Label */ 
#line 523
  if (*option_len != sizeof(data->establishrate)) {
#line 524
    goto fail;
  }
  {
#line 525
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->establishrate),
         sizeof(data->establishrate));
  }
#line 527
  goto switch_break;
  case_2: /* CIL Label */ 
#line 530
  if (*option_len != sizeof(data->establishhighrate)) {
#line 531
    goto fail;
  }
  {
#line 532
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->establishhighrate),
         sizeof(data->establishhighrate));
  }
#line 534
  goto switch_break;
  case_3: /* CIL Label */ 
#line 537
  if (*option_len != sizeof(data->timeout)) {
#line 538
    goto fail;
  }
  {
#line 539
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->timeout),
         sizeof(data->timeout));
  }
#line 541
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 544
  return (0);
  fail: 
  {
#line 547
  tmp = __errno_location();
#line 547
  *tmp = 22;
#line 548
  tmp___0 = pi_set_error(ps->sd, -501);
  }
#line 548
  return (tmp___0);
}
}
#line 562 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_setsockopt___2(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                                 size_t *option_len ) 
{ 
  pi_usb_data_t *data ;
  int *tmp ;
  int tmp___0 ;

  {
#line 566
  data = (pi_usb_data_t *)(ps->device)->data;
  {
#line 569
  if (option_name == 1) {
#line 569
    goto case_1;
  }
#line 576
  if (option_name == 2) {
#line 576
    goto case_2;
  }
#line 583
  if (option_name == 3) {
#line 583
    goto case_3;
  }
#line 568
  goto switch_break;
  case_1: /* CIL Label */ 
#line 570
  if (*option_len != sizeof(data->establishrate)) {
#line 571
    goto fail;
  }
  {
#line 572
  memcpy((void */* __restrict  */)(& data->establishrate), (void const   */* __restrict  */)option_value,
         sizeof(data->establishrate));
  }
#line 574
  goto switch_break;
  case_2: /* CIL Label */ 
#line 577
  if (*option_len != sizeof(data->establishhighrate)) {
#line 578
    goto fail;
  }
  {
#line 579
  memcpy((void */* __restrict  */)(& data->establishhighrate), (void const   */* __restrict  */)option_value,
         sizeof(data->establishhighrate));
  }
#line 581
  goto switch_break;
  case_3: /* CIL Label */ 
#line 584
  if (*option_len != sizeof(data->timeout)) {
#line 585
    goto fail;
  }
  {
#line 586
  memcpy((void */* __restrict  */)(& data->timeout), (void const   */* __restrict  */)option_value,
         sizeof(data->timeout));
  }
#line 588
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 591
  return (0);
  fail: 
  {
#line 594
  tmp = __errno_location();
#line 594
  *tmp = 22;
#line 595
  tmp___0 = pi_set_error(ps->sd, -501);
  }
#line 595
  return (tmp___0);
}
}
#line 610 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int pi_usb_close___2(pi_socket_t *ps ) 
{ 
  pi_usb_data_t *data ;

  {
#line 613
  data = (pi_usb_data_t *)(ps->device)->data;
#line 615
  if (ps->sd != 0) {
    {
#line 616
    (*(data->impl.close))(ps);
#line 617
    ps->sd = 0;
    }
  }
#line 620
  if ((unsigned long )ps->laddr != (unsigned long )((void *)0)) {
    {
#line 621
    free((void *)ps->laddr);
#line 622
    ps->laddr = (struct sockaddr *)((void *)0);
    }
  }
#line 624
  if ((unsigned long )ps->raddr != (unsigned long )((void *)0)) {
    {
#line 625
    free((void *)ps->raddr);
#line 626
    ps->raddr = (struct sockaddr *)((void *)0);
    }
  }
#line 629
  return (0);
}
}
#line 982 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int USB_configure_visor___2(pi_usb_data_t *dev , u_int8_t *input_pipe , u_int8_t *output_pipe ) 
{ 
  int i ;
  int ret ;
  visor_connection_info_t ci ;
  char *function_str ;

  {
  {
#line 988
  ret = (*(dev->impl.control_request))(dev, 194, 3, 0, 0, (void *)(& ci), (int )sizeof(ci),
                                       0);
  }
#line 989
  if (ret < 0) {
    {
#line 990
    pi_log(2, 1, "usb: VISOR_GET_CONNECTION_INFORMATION failed (err=%08x)\n", ret);
    }
  } else {
    {
#line 992
    pi_log(2, 8, "usb: VISOR_GET_CONNECTION_INFORMATION, num_ports=%d\n", (int )ci.num_ports);
    }
#line 993
    if ((int )ci.num_ports > 2) {
#line 994
      ci.num_ports = (u_int16_t )2;
    }
#line 995
    i = 0;
    {
#line 995
    while (1) {
      while_continue: /* CIL Label */ ;
#line 995
      if (! (i < (int )ci.num_ports)) {
#line 995
        goto while_break;
      }
      {
#line 1000
      if ((int )ci.connections[i].port_function_id == 0) {
#line 1000
        goto case_0;
      }
#line 1003
      if ((int )ci.connections[i].port_function_id == 1) {
#line 1003
        goto case_1;
      }
#line 1006
      if ((int )ci.connections[i].port_function_id == 2) {
#line 1006
        goto case_2;
      }
#line 1009
      if ((int )ci.connections[i].port_function_id == 3) {
#line 1009
        goto case_3;
      }
#line 1012
      if ((int )ci.connections[i].port_function_id == 4) {
#line 1012
        goto case_4;
      }
#line 1015
      goto switch_default;
      case_0: /* CIL Label */ 
#line 1001
      function_str = (char *)"GENERIC";
#line 1002
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1004
      function_str = (char *)"DEBUGGER";
#line 1005
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1007
      function_str = (char *)"HOTSYNC";
#line 1008
      goto switch_break;
      case_3: /* CIL Label */ 
#line 1010
      function_str = (char *)"CONSOLE";
#line 1011
      goto switch_break;
      case_4: /* CIL Label */ 
#line 1013
      function_str = (char *)"REMOTE_FILE_SYSTEM";
#line 1014
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1016
      function_str = (char *)"UNKNOWN";
#line 1017
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 1019
      pi_log(2, 8, "\t[%d] port_function_id=0x%02x (%s)\n", i, (int )ci.connections[i].port_function_id,
             function_str);
#line 1023
      pi_log(2, 8, "\t[%d] port=%d\n", i, (int )ci.connections[i].port);
#line 995
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1027
  return (ret);
}
}
#line 1030 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/usb.c"
static int USB_configure_generic___2(pi_usb_data_t *dev , u_int8_t *input_pipe , u_int8_t *output_pipe ) 
{ 
  int i ;
  int ret ;
  int hotsync ;
  palm_ext_connection_info_t ci ;
  u_int32_t flags ;
  int tmp ;

  {
  {
#line 1034
  hotsync = 0;
#line 1036
  flags = dev->dev.flags;
#line 1038
  ret = (*(dev->impl.control_request))(dev, 194, 4, 0, 0, (void *)(& ci), (int )sizeof(ci),
                                       0);
  }
#line 1039
  if (ret < 0) {
    {
#line 1040
    pi_log(2, 1, "usb: PALM_GET_EXT_CONNECTION_INFORMATION failed (err=%08x)\n", ret);
    }
  } else {
    {
#line 1042
    pi_log(2, 8, "usb: PALM_GET_EXT_CONNECTION_INFORMATION, num_ports=%d, endpoint_numbers_different=%d\n",
           (int )ci.num_ports, (int )ci.endpoint_numbers_different);
#line 1045
    i = 0;
    }
    {
#line 1045
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1045
      if (! (i < (int )ci.num_ports)) {
#line 1045
        goto while_break;
      }
      {
#line 1046
      pi_log(2, 8, "\t[%d] port_function_id=\'%c%c%c%c\'\n", i, (int )ci.connections[i].port_function_id[0],
             (int )ci.connections[i].port_function_id[1], (int )ci.connections[i].port_function_id[2],
             (int )ci.connections[i].port_function_id[3]);
#line 1052
      pi_log(2, 8, "\t[%d] port=%d\n", i, (int )ci.connections[i].port);
#line 1055
      pi_log(2, 8, "\t[%d] endpoint_info=%d\n", i, (int )ci.connections[i].endpoint_info);
#line 1057
      tmp = memcmp((void const   *)(ci.connections[i].port_function_id), (void const   *)"cnys",
                   (size_t )4);
      }
#line 1057
      if (! tmp) {
#line 1060
        hotsync = 1;
#line 1064
        if (ci.endpoint_numbers_different) {
#line 1065
          if (input_pipe) {
#line 1066
            *input_pipe = (u_int8_t )((int )ci.connections[i].endpoint_info >> 4);
          }
#line 1067
          if (output_pipe) {
#line 1068
            *output_pipe = (u_int8_t )((int )ci.connections[i].endpoint_info & 15);
          }
        } else {
#line 1070
          if (input_pipe) {
#line 1071
            *input_pipe = ci.connections[i].port;
          }
#line 1072
          if (output_pipe) {
#line 1073
            *output_pipe = ci.connections[i].port;
          }
        }
      }
#line 1045
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1078
    if (! hotsync) {
      {
#line 1079
      pi_log(2, 1, "usb: PALM_GET_EXT_CONNECTION_INFORMATION - no hotsync port found.\n",
             ret);
      }
#line 1080
      return (-1);
    }
  }
#line 1084
  if (flags & (unsigned int )(1 << 1)) {
    {
#line 1089
    ret = (*(dev->impl.control_request))(dev, 194, 4, 0, 0, (void *)(& ci), (int )sizeof(ci),
                                         0);
#line 1090
    ret = (*(dev->impl.control_request))(dev, 194, 4, 0, 0, (void *)(& ci), (int )sizeof(ci),
                                         0);
    }
  }
#line 1092
  return (ret);
}
}
#line 291 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/utils.c"
static char buf___2[5]  ;
#line 63 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_list_t *ps_list_append___2(pi_socket_list_t *list , pi_socket_t *ps ) ;
#line 65
static pi_socket_t *ps_list_find___2(pi_socket_list_t *list , int pi_sd ) ;
#line 67
static pi_socket_list_t *ps_list_remove___2(pi_socket_list_t *list , int pi_sd ) ;
#line 69
static pi_socket_list_t *ps_list_copy___2(pi_socket_list_t *list ) ;
#line 70
static void ps_list_free___2(pi_socket_list_t *list ) ;
#line 72
static void protocol_queue_add___2(pi_socket_t *ps , pi_protocol_t *prot ) ;
#line 73
static void protocol_cmd_queue_add___2(pi_socket_t *ps , pi_protocol_t *prot ) ;
#line 74
static pi_protocol_t *protocol_queue_find___2(pi_socket_t *ps , int level ) ;
#line 75
static pi_protocol_t *protocol_queue_find_next___2(pi_socket_t *ps , int level ) ;
#line 79
static int is_connected___2(pi_socket_t *ps ) ;
#line 80
static int is_listener___2(pi_socket_t *ps ) ;
#line 83 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static int psl_mutex___2  =    0;
#line 84 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_list_t *psl___2  =    (pi_socket_list_t *)((void *)0);
#line 86 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static int watch_list_mutex___2  =    0;
#line 87 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_list_t *watch_list___2  =    (pi_socket_list_t *)((void *)0);
#line 90 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static unsigned int interval___2  =    0U;
#line 133 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_list_t *ps_list_append___2(pi_socket_list_t *list , pi_socket_t *ps ) 
{ 
  pi_socket_list_t *elem ;
  pi_socket_list_t *new_elem ;
  void *tmp ;

  {
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! ((unsigned long )ps != (unsigned long )((void *)0))) {
      {
#line 138
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c",
             138, "ps != NULL");
      }
    }
#line 138
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 140
  tmp = malloc(sizeof(pi_socket_list_t ));
#line 140
  new_elem = (pi_socket_list_t *)tmp;
  }
#line 141
  if ((unsigned long )new_elem == (unsigned long )((void *)0)) {
#line 142
    return (list);
  }
#line 144
  new_elem->ps = ps;
#line 145
  new_elem->next = (struct pi_socket_list *)((void *)0);
#line 147
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 148
    return (new_elem);
  }
#line 150
  elem = list;
  {
#line 151
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 151
    if (! ((unsigned long )elem->next != (unsigned long )((void *)0))) {
#line 151
      goto while_break___0;
    }
#line 152
    elem = elem->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 153
  elem->next = new_elem;
#line 155
  return (list);
}
}
#line 177 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_t *ps_list_find___2(pi_socket_list_t *list , int pi_sd ) 
{ 
  pi_socket_list_t *elem ;

  {
#line 182
  elem = list;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! ((unsigned long )elem != (unsigned long )((void *)0))) {
#line 182
      goto while_break;
    }
#line 183
    if ((unsigned long )elem->ps != (unsigned long )((void *)0)) {
#line 183
      if ((elem->ps)->sd == pi_sd) {
#line 184
        return (elem->ps);
      }
    }
#line 182
    elem = elem->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return ((pi_socket_t *)((void *)0));
}
}
#line 207 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_list_t *ps_list_remove___2(pi_socket_list_t *list , int pi_sd ) 
{ 
  pi_socket_list_t *elem ;
  pi_socket_list_t *new_list ;
  pi_socket_list_t *prev_elem ;

  {
#line 210
  new_list = list;
#line 210
  prev_elem = (pi_socket_list_t *)((void *)0);
#line 214
  elem = list;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! ((unsigned long )elem != (unsigned long )((void *)0))) {
#line 214
      goto while_break;
    }
#line 215
    if ((unsigned long )elem->ps == (unsigned long )((void *)0)) {
#line 216
      goto __Cont;
    } else
#line 217
    if ((elem->ps)->sd == pi_sd) {
#line 218
      if ((unsigned long )prev_elem == (unsigned long )((void *)0)) {
#line 219
        new_list = elem->next;
      } else {
#line 221
        prev_elem->next = elem->next;
      }
      {
#line 222
      free((void *)elem);
      }
#line 223
      goto while_break;
    }
#line 225
    prev_elem = elem;
    __Cont: /* CIL Label */ 
#line 214
    elem = elem->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  return (new_list);
}
}
#line 246 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_list_t *ps_list_copy___2(pi_socket_list_t *list ) 
{ 
  pi_socket_list_t *l ;
  pi_socket_list_t *new_list ;

  {
#line 249
  new_list = (pi_socket_list_t *)((void *)0);
#line 251
  l = list;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 251
      goto while_break;
    }
    {
#line 252
    new_list = ps_list_append___2(new_list, l->ps);
#line 251
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  return (new_list);
}
}
#line 274 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void ps_list_free___2(pi_socket_list_t *list ) 
{ 
  pi_socket_list_t *l ;
  pi_socket_list_t *next ;

  {
#line 279
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 280
    return;
  }
#line 282
  l = list;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 284
    next = l->next;
#line 285
    free((void *)l);
#line 286
    l = next;
    }
#line 283
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 283
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return;
}
}
#line 302 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void protocol_queue_add___2(pi_socket_t *ps , pi_protocol_t *prot ) 
{ 
  void *tmp ;
  int *tmp___0 ;

  {
  {
#line 305
  tmp = realloc((void *)ps->protocol_queue, sizeof(pi_protocol_t *) * (unsigned long )(ps->queue_len + 1));
#line 305
  ps->protocol_queue = (struct pi_protocol **)tmp;
  }
#line 307
  if ((unsigned long )ps->protocol_queue != (unsigned long )((void *)0)) {
#line 308
    *(ps->protocol_queue + ps->queue_len) = prot;
#line 309
    (ps->queue_len) ++;
  } else {
    {
#line 311
    tmp___0 = __errno_location();
#line 311
    *tmp___0 = 12;
#line 312
    ps->queue_len = 0;
    }
  }
#line 314
  return;
}
}
#line 328 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void protocol_cmd_queue_add___2(pi_socket_t *ps , pi_protocol_t *prot ) 
{ 
  void *tmp ;
  int *tmp___0 ;

  {
  {
#line 331
  tmp = realloc((void *)ps->cmd_queue, sizeof(pi_protocol_t *) * (unsigned long )(ps->cmd_len + 1));
#line 331
  ps->cmd_queue = (struct pi_protocol **)tmp;
  }
#line 333
  if ((unsigned long )ps->cmd_queue != (unsigned long )((void *)0)) {
#line 334
    *(ps->cmd_queue + ps->cmd_len) = prot;
#line 335
    (ps->cmd_len) ++;
  } else {
    {
#line 337
    tmp___0 = __errno_location();
#line 337
    *tmp___0 = 12;
#line 338
    ps->cmd_len = 0;
    }
  }
#line 340
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_protocol_t *protocol_queue_find___2(pi_socket_t *ps , int level ) 
{ 
  int i ;

  {
#line 359
  if (ps->command) {
#line 360
    i = 0;
    {
#line 360
    while (1) {
      while_continue: /* CIL Label */ ;
#line 360
      if (! (i < ps->cmd_len)) {
#line 360
        goto while_break;
      }
#line 361
      if ((*(ps->cmd_queue + i))->level == level) {
#line 362
        return (*(ps->cmd_queue + i));
      }
#line 360
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 365
    i = 0;
    {
#line 365
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 365
      if (! (i < ps->queue_len)) {
#line 365
        goto while_break___0;
      }
#line 366
      if ((*(ps->protocol_queue + i))->level == level) {
#line 367
        return (*(ps->protocol_queue + i));
      }
#line 365
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 371
  return ((pi_protocol_t *)((void *)0));
}
}
#line 386 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_protocol_t *protocol_queue_find_next___2(pi_socket_t *ps , int level ) 
{ 
  int i ;

  {
#line 391
  if (ps->command) {
#line 391
    if (ps->cmd_len == 0) {
#line 392
      return ((pi_protocol_t *)((void *)0));
    }
  }
#line 394
  if (! ps->command) {
#line 394
    if (ps->queue_len == 0) {
#line 395
      return ((pi_protocol_t *)((void *)0));
    }
  }
#line 397
  if (ps->command) {
#line 397
    if (level == 0) {
#line 398
      return (*(ps->cmd_queue + 0));
    }
  }
#line 400
  if (! ps->command) {
#line 400
    if (level == 0) {
#line 401
      return (*(ps->protocol_queue + 0));
    }
  }
#line 403
  if (ps->command) {
#line 404
    i = 0;
    {
#line 404
    while (1) {
      while_continue: /* CIL Label */ ;
#line 404
      if (! (i < ps->cmd_len - 1)) {
#line 404
        goto while_break;
      }
#line 405
      if ((*(ps->cmd_queue + i))->level == level) {
#line 406
        return (*(ps->cmd_queue + (i + 1)));
      }
#line 404
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 409
    i = 0;
    {
#line 409
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 409
      if (! (i < ps->queue_len - 1)) {
#line 409
        goto while_break___0;
      }
#line 410
      if ((*(ps->protocol_queue + i))->level == level) {
#line 411
        return (*(ps->protocol_queue + (i + 1)));
      }
#line 409
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 415
  return ((pi_protocol_t *)((void *)0));
}
}
#line 430 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void protocol_queue_build___2(pi_socket_t *ps , int autodetect ) 
{ 
  int protocol ;
  int result ;
  pi_protocol_t *dev_prot ;
  pi_protocol_t *dev_cmd_prot ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int skipped_bytes ;
  int bytes_to_skip ;
  pi_buffer_t *detect_buf ;
  pi_buffer_t *tmp___5 ;
  ssize_t tmp___6 ;
  int i ;
  unsigned char header_checksum ;
  ssize_t tmp___7 ;
  pi_protocol_t *tmp___8 ;
  pi_protocol_t *tmp___9 ;
  pi_protocol_t *tmp___10 ;
  pi_protocol_t *tmp___11 ;
  pi_protocol_t *tmp___12 ;
  pi_protocol_t *tmp___13 ;
  pi_protocol_t *tmp___14 ;
  pi_protocol_t *tmp___15 ;
  pi_protocol_t *tmp___16 ;

  {
  {
#line 439
  pi_log(128, 8, "SOCK fd=%d auto=%d\n", ps->sd, autodetect);
#line 442
  dev_prot = (*((ps->device)->protocol))(ps->device);
#line 443
  dev_cmd_prot = (*((ps->device)->protocol))(ps->device);
  }
#line 446
  if (ps->type == 48) {
    {
#line 447
    pi_log(128, 8, "RAW mode, no protocol\n", ps->sd, autodetect);
#line 448
    protocol_queue_add___2(ps, dev_prot);
#line 449
    protocol_cmd_queue_add___2(ps, dev_cmd_prot);
    }
#line 450
    return;
  }
#line 453
  protocol = ps->protocol;
#line 455
  if (protocol == 1) {
#line 455
    tmp___4 = "DEV";
  } else {
#line 455
    if (protocol == 2) {
#line 455
      tmp___3 = "SLP";
    } else {
#line 455
      if (protocol == 3) {
#line 455
        tmp___2 = "SYS";
      } else {
#line 455
        if (protocol == 4) {
#line 455
          tmp___1 = "PADP";
        } else {
#line 455
          if (protocol == 5) {
#line 455
            tmp___0 = "NET";
          } else {
#line 455
            if (protocol == 6) {
#line 455
              tmp = "DLP";
            } else {
#line 455
              tmp = "unknown";
            }
#line 455
            tmp___0 = tmp;
          }
#line 455
          tmp___1 = tmp___0;
        }
#line 455
        tmp___2 = tmp___1;
      }
#line 455
      tmp___3 = tmp___2;
    }
#line 455
    tmp___4 = tmp___3;
  }
  {
#line 455
  pi_log(128, 8, "SOCK proto=%s (%d)\n", tmp___4, protocol);
  }
#line 464
  if (protocol == 6) {
#line 464
    if (autodetect) {
      {
#line 465
      skipped_bytes = 0;
#line 467
      tmp___5 = pi_buffer_new((size_t )64);
#line 467
      detect_buf = tmp___5;
      }
      {
#line 470
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 472
        tmp___6 = (*(dev_prot->read))(ps, detect_buf, (size_t )10, 1);
#line 472
        result = (int )tmp___6;
        }
#line 473
        if (result < 0) {
#line 474
          goto while_break;
        }
#line 475
        if (result != 10) {
          {
#line 476
          pi_buffer_clear(detect_buf);
          }
#line 477
          goto __Cont;
        }
#line 480
        bytes_to_skip = 1;
#line 483
        if ((int )*(detect_buf->data + 0) == 190) {
#line 483
          if ((int )*(detect_buf->data + 1) == 239) {
#line 483
            if ((int )*(detect_buf->data + 2) == 237) {
#line 490
              i = 0;
#line 490
              header_checksum = (unsigned char )i;
              {
#line 490
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 490
                if (! (i < 9)) {
#line 490
                  goto while_break___0;
                }
#line 491
                header_checksum = (unsigned char )((int )header_checksum + (int )*(detect_buf->data + i));
#line 490
                i ++;
              }
              while_break___0: /* CIL Label */ ;
              }
#line 493
              if ((int )header_checksum == (int )*(detect_buf->data + 9)) {
#line 494
                if ((int )*(detect_buf->data + 3) == 3) {
#line 494
                  if ((int )*(detect_buf->data + 4) == 3) {
#line 494
                    if ((int )*(detect_buf->data + 5) == 2) {
#line 494
                      if ((int )*(detect_buf->data + 8) == 255) {
                        {
#line 499
                        protocol = 4;
#line 500
                        pi_log(128, 4, "\nusing PADP/SLP protocol (skipped %d bytes)\n",
                               skipped_bytes);
                        }
#line 503
                        goto while_break;
                      } else {
#line 507
                        bytes_to_skip = 10;
                      }
                    } else {
#line 507
                      bytes_to_skip = 10;
                    }
                  } else {
#line 507
                    bytes_to_skip = 10;
                  }
                } else {
#line 507
                  bytes_to_skip = 10;
                }
              } else {
#line 511
                bytes_to_skip = 3;
              }
            } else {
#line 483
              goto _L___5;
            }
          } else {
#line 483
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 516
        if ((int )*(detect_buf->data + 0) == 1) {
#line 516
          if ((int )*(detect_buf->data + 2) == 0) {
#line 516
            if ((int )*(detect_buf->data + 3) == 0) {
#line 516
              if ((int )*(detect_buf->data + 4) == 0) {
#line 516
                if ((int )*(detect_buf->data + 5) > 0) {
#line 516
                  if ((int )*(detect_buf->data + 6) == 144) {
                    {
#line 523
                    protocol = 5;
#line 524
                    pi_log(128, 4, "\nusing NET protocol (skipped %d bytes)\n", skipped_bytes);
                    }
#line 527
                    goto while_break;
                  } else {
#line 516
                    goto _L___3;
                  }
                } else {
#line 516
                  goto _L___3;
                }
              } else {
#line 516
                goto _L___3;
              }
            } else {
#line 516
              goto _L___3;
            }
          } else {
#line 516
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 535
        if ((int )*(detect_buf->data + 0) == 144) {
#line 535
          if ((int )*(detect_buf->data + 1) == 1) {
#line 535
            if ((int )*(detect_buf->data + 2) == 0) {
#line 535
              if ((int )*(detect_buf->data + 3) == 0) {
#line 535
                if ((int )*(detect_buf->data + 4) == 0) {
#line 535
                  if ((int )*(detect_buf->data + 5) == 0) {
#line 535
                    if ((int )*(detect_buf->data + 6) == 0) {
#line 535
                      if ((int )*(detect_buf->data + 7) == 0) {
#line 535
                        if ((int )*(detect_buf->data + 8) == 0) {
#line 535
                          if ((int )*(detect_buf->data + 9) == 32) {
                            {
#line 546
                            protocol = 5;
#line 547
                            pi_log(128, 4, "\nusing NET protocol (skipped %d bytes)\n",
                                   skipped_bytes);
                            }
#line 550
                            goto while_break;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        {
#line 554
        tmp___7 = (*(dev_prot->read))(ps, detect_buf, (size_t )bytes_to_skip, 0);
#line 554
        result = (int )tmp___7;
        }
#line 555
        if (result < 0) {
#line 556
          goto while_break;
        }
        {
#line 557
        skipped_bytes += bytes_to_skip;
#line 558
        pi_buffer_clear(detect_buf);
        }
        __Cont: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 561
      pi_buffer_free(detect_buf);
      }
#line 563
      if (result < 0) {
        {
#line 568
        pi_log(128, 8, "Error: last read returned %d; switching to PADP by default\n",
               result);
#line 571
        protocol = 4;
        }
      }
    } else {
#line 464
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 574
  if (protocol == 6) {
#line 575
    protocol = 4;
  }
  {
#line 580
  if (protocol == 4) {
#line 580
    goto case_4;
  }
#line 582
  if (protocol == 2) {
#line 582
    goto case_2;
  }
#line 585
  if (protocol == 5) {
#line 585
    goto case_5;
  }
#line 588
  if (protocol == 3) {
#line 588
    goto case_3;
  }
#line 579
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 581
  tmp___8 = padp_protocol();
#line 581
  protocol_queue_add___2(ps, tmp___8);
  }
  case_2: /* CIL Label */ 
  {
#line 583
  tmp___9 = slp_protocol();
#line 583
  protocol_queue_add___2(ps, tmp___9);
  }
#line 584
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 586
  tmp___10 = net_protocol();
#line 586
  protocol_queue_add___2(ps, tmp___10);
  }
#line 587
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 589
  tmp___11 = sys_protocol();
#line 589
  protocol_queue_add___2(ps, tmp___11);
#line 590
  tmp___12 = slp_protocol();
#line 590
  protocol_queue_add___2(ps, tmp___12);
  }
#line 591
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 597
  if (protocol == 2) {
#line 597
    goto case_2___0;
  }
#line 597
  if (protocol == 4) {
#line 597
    goto case_2___0;
  }
#line 603
  if (protocol == 5) {
#line 603
    goto case_5___0;
  }
#line 607
  if (protocol == 3) {
#line 607
    goto case_3___0;
  }
#line 610
  goto switch_default;
  case_2___0: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  {
#line 598
  tmp___13 = cmp_protocol();
#line 598
  protocol_cmd_queue_add___2(ps, tmp___13);
#line 599
  tmp___14 = padp_protocol();
#line 599
  protocol_cmd_queue_add___2(ps, tmp___14);
#line 600
  tmp___15 = slp_protocol();
#line 600
  protocol_cmd_queue_add___2(ps, tmp___15);
#line 601
  ps->cmd = 1;
  }
#line 602
  goto switch_break___0;
  case_5___0: /* CIL Label */ 
  {
#line 604
  tmp___16 = net_protocol();
#line 604
  protocol_cmd_queue_add___2(ps, tmp___16);
#line 605
  ps->cmd = 2;
  }
#line 606
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 608
  ps->cmd = 3;
#line 609
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 611
  pi_log(128, 1, "invalid protocol (%d)", protocol);
  }
#line 612
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 615
  protocol_queue_add___2(ps, dev_prot);
#line 616
  protocol_cmd_queue_add___2(ps, dev_cmd_prot);
  }
#line 617
  return;
}
}
#line 631 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void protocol_queue_destroy___2(pi_socket_t *ps ) 
{ 
  int i ;

  {
#line 635
  i = 0;
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 635
    if (! (i < ps->queue_len)) {
#line 635
      goto while_break;
    }
    {
#line 636
    (*((*(ps->protocol_queue + i))->free))(*(ps->protocol_queue + i));
#line 635
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 637
  i = 0;
  {
#line 637
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 637
    if (! (i < ps->cmd_len)) {
#line 637
      goto while_break___0;
    }
    {
#line 638
    (*((*(ps->cmd_queue + i))->free))(*(ps->cmd_queue + i));
#line 637
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 640
  if (ps->queue_len > 0) {
    {
#line 641
    free((void *)ps->protocol_queue);
    }
  }
#line 642
  if (ps->cmd_len > 0) {
    {
#line 643
    free((void *)ps->cmd_queue);
    }
  }
#line 644
  return;
}
}
#line 697 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void env_dbgcheck___2(void) 
{ 
  int types ;
  int done ;
  char *debug ;
  char *b ;
  char *e ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int level ;
  char const   *debug___0 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  char const   *logfile ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;

  {
  {
#line 700
  tmp___11 = getenv("PILOT_DEBUG");
  }
#line 700
  if (tmp___11) {
    {
#line 701
    types = 0;
#line 707
    tmp = getenv("PILOT_DEBUG");
#line 707
    debug = strdup((char const   *)tmp);
#line 709
    b = debug;
#line 710
    done = 0;
    }
    {
#line 711
    while (1) {
      while_continue: /* CIL Label */ ;
#line 711
      if (! (! done)) {
#line 711
        goto while_break;
      }
      {
#line 712
      e = strchr((char const   *)b, ' ');
      }
#line 713
      if (e) {
#line 714
        *e = (char )'\000';
      } else {
#line 716
        done = 1;
      }
      {
#line 718
      tmp___10 = strcmp((char const   *)b, "SYS");
      }
#line 718
      if (tmp___10) {
        {
#line 720
        tmp___9 = strcmp((char const   *)b, "DEV");
        }
#line 720
        if (tmp___9) {
          {
#line 722
          tmp___8 = strcmp((char const   *)b, "SLP");
          }
#line 722
          if (tmp___8) {
            {
#line 724
            tmp___7 = strcmp((char const   *)b, "PADP");
            }
#line 724
            if (tmp___7) {
              {
#line 726
              tmp___6 = strcmp((char const   *)b, "DLP");
              }
#line 726
              if (tmp___6) {
                {
#line 728
                tmp___5 = strcmp((char const   *)b, "NET");
                }
#line 728
                if (tmp___5) {
                  {
#line 730
                  tmp___4 = strcmp((char const   *)b, "CMP");
                  }
#line 730
                  if (tmp___4) {
                    {
#line 732
                    tmp___3 = strcmp((char const   *)b, "SOCK");
                    }
#line 732
                    if (tmp___3) {
                      {
#line 734
                      tmp___2 = strcmp((char const   *)b, "API");
                      }
#line 734
                      if (tmp___2) {
                        {
#line 736
                        tmp___1 = strcmp((char const   *)b, "USER");
                        }
#line 736
                        if (tmp___1) {
                          {
#line 738
                          tmp___0 = strcmp((char const   *)b, "ALL");
                          }
#line 738
                          if (! tmp___0) {
#line 739
                            types |= 1024;
                          }
                        } else {
#line 737
                          types |= 512;
                        }
                      } else {
#line 735
                        types |= 256;
                      }
                    } else {
#line 733
                      types |= 128;
                    }
                  } else {
#line 731
                    types |= 64;
                  }
                } else {
#line 729
                  types |= 32;
                }
              } else {
#line 727
                types |= 16;
              }
            } else {
#line 725
              types |= 8;
            }
          } else {
#line 723
            types |= 4;
          }
        } else {
#line 721
          types |= 2;
        }
      } else {
#line 719
        types |= 1;
      }
#line 740
      e ++;
#line 741
      b = e;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 743
    pi_debug_set_types(types);
#line 745
    free((void *)debug);
    }
  }
  {
#line 749
  tmp___18 = getenv("PILOT_DEBUG_LEVEL");
  }
#line 749
  if (tmp___18) {
    {
#line 750
    level = 0;
#line 754
    tmp___12 = getenv("PILOT_DEBUG_LEVEL");
#line 754
    debug___0 = (char const   *)tmp___12;
#line 755
    tmp___17 = strcmp(debug___0, "NONE");
    }
#line 755
    if (tmp___17) {
      {
#line 757
      tmp___16 = strcmp(debug___0, "ERR");
      }
#line 757
      if (tmp___16) {
        {
#line 759
        tmp___15 = strcmp(debug___0, "WARN");
        }
#line 759
        if (tmp___15) {
          {
#line 761
          tmp___14 = strcmp(debug___0, "INFO");
          }
#line 761
          if (tmp___14) {
            {
#line 763
            tmp___13 = strcmp(debug___0, "DEBUG");
            }
#line 763
            if (! tmp___13) {
#line 764
              level |= 8;
            }
          } else {
#line 762
            level |= 4;
          }
        } else {
#line 760
          level |= 2;
        }
      } else {
#line 758
        level |= 1;
      }
    } else {
#line 756
      level = level;
    }
    {
#line 766
    pi_debug_set_level(level);
    }
  }
  {
#line 770
  tmp___20 = getenv("PILOT_LOG");
  }
#line 770
  if (tmp___20) {
    {
#line 770
    tmp___21 = getenv("PILOT_LOG");
#line 770
    tmp___22 = atoi((char const   *)tmp___21);
    }
#line 770
    if (tmp___22) {
      {
#line 773
      tmp___19 = getenv("PILOT_LOGFILE");
#line 773
      logfile = (char const   *)tmp___19;
      }
#line 774
      if ((unsigned long )logfile == (unsigned long )((void *)0)) {
        {
#line 775
        pi_debug_set_file("pilot-link.debug");
        }
      } else {
        {
#line 777
        pi_debug_set_file(logfile);
        }
      }
    }
  }
#line 779
  return;
}
}
#line 793 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static int is_connected___2(pi_socket_t *ps ) 
{ 
  int tmp ;

  {
#line 796
  if (ps->state == 4) {
#line 796
    tmp = 1;
  } else
#line 796
  if (ps->state == 2) {
#line 796
    tmp = 1;
  } else {
#line 796
    tmp = 0;
  }
#line 796
  return (tmp);
}
}
#line 810 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static int is_listener___2(pi_socket_t *ps ) 
{ 
  int tmp ;

  {
#line 813
  if (ps->state == 1) {
#line 813
    tmp = 1;
  } else {
#line 813
    tmp = 0;
  }
#line 813
  return (tmp);
}
}
#line 817 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void onalarm___2(int signo ) 
{ 
  pi_socket_list_t *l ;
  pi_socket_t *ps ;
  int tmp ;
  PI_ERR tmp___0 ;

  {
  {
#line 822
  signal(signo, & onalarm___2);
#line 824
  pi_mutex_lock(& watch_list_mutex___2);
#line 826
  l = watch_list___2;
  }
  {
#line 826
  while (1) {
    while_continue: /* CIL Label */ ;
#line 826
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 826
      goto while_break;
    }
    {
#line 827
    ps = l->ps;
#line 829
    tmp = is_connected___2(ps);
    }
#line 829
    if (! tmp) {
#line 830
      goto __Cont;
    }
    {
#line 832
    tmp___0 = pi_tickle(ps->sd);
    }
#line 832
    if (tmp___0 < 0) {
      {
#line 833
      pi_log(128, 4, "SOCKET Socket %d is busy during tickle\n", ps->sd);
#line 836
      alarm(1U);
      }
    } else {
      {
#line 838
      pi_log(128, 4, "SOCKET Tickling socket %d\n", ps->sd);
#line 840
      alarm(interval___2);
      }
    }
    __Cont: /* CIL Label */ 
#line 826
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 844
  pi_mutex_unlock(& watch_list_mutex___2);
  }
#line 845
  return;
}
}
#line 860 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void onexit___2(void) 
{ 
  pi_socket_list_t *l ;
  pi_socket_list_t *list ;

  {
  {
#line 866
  pi_mutex_lock(& psl_mutex___2);
#line 867
  list = ps_list_copy___2(psl___2);
#line 868
  pi_mutex_unlock(& psl_mutex___2);
#line 870
  l = list;
  }
  {
#line 870
  while (1) {
    while_continue: /* CIL Label */ ;
#line 870
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 870
      goto while_break;
    }
    {
#line 871
    pi_close((l->ps)->sd);
#line 870
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 873
  ps_list_free___2(list);
  }
#line 874
  return;
}
}
#line 888 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static void installexit___2(void) 
{ 


  {
#line 891
  if (! pi_sock_installedexit) {
    {
#line 892
    atexit(& onexit___2);
#line 893
    pi_sock_installedexit = 1;
    }
  }
#line 895
  return;
}
}
#line 1020 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/socket.c"
static pi_socket_t *pi_devsocket___2(int pi_sd , char const   *port , struct pi_sockaddr *addr ) 
{ 
  pi_socket_t *ps ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1025
  ps = find_pi_socket(pi_sd);
  }
#line 1025
  if (! ps) {
    {
#line 1026
    tmp = __errno_location();
#line 1026
    *tmp = 3;
    }
#line 1027
    return ((pi_socket_t *)((void *)0));
  }
#line 1030
  if ((unsigned long )port == (unsigned long )((void *)0)) {
    {
#line 1030
    tmp___1 = getenv("PILOTPORT");
#line 1030
    port = (char const   *)tmp___1;
    }
#line 1030
    if ((unsigned long )port == (unsigned long )((void *)0)) {
      {
#line 1031
      tmp___0 = __errno_location();
#line 1031
      *tmp___0 = 6;
      }
#line 1032
      return ((pi_socket_t *)((void *)0));
    }
  }
  {
#line 1036
  addr->pi_family = (unsigned short)0;
#line 1037
  tmp___4 = strncmp(port, "serial:", (size_t )7);
  }
#line 1037
  if (tmp___4) {
    {
#line 1041
    tmp___3 = strncmp(port, "usb:", (size_t )4);
    }
#line 1041
    if (tmp___3) {
      {
#line 1045
      tmp___2 = strncmp(port, "net:", (size_t )4);
      }
#line 1045
      if (tmp___2) {
        {
#line 1055
        strncpy((char */* __restrict  */)(addr->pi_device), (char const   */* __restrict  */)port,
                sizeof(addr->pi_device));
#line 1056
        ps->device = pi_serial_device(1);
        }
      } else {
        {
#line 1046
        strncpy((char */* __restrict  */)(addr->pi_device), (char const   */* __restrict  */)(port + 4),
                sizeof(addr->pi_device));
#line 1047
        ps->device = pi_inet_device(1);
        }
      }
    } else {
      {
#line 1042
      strncpy((char */* __restrict  */)(addr->pi_device), (char const   */* __restrict  */)(port + 4),
              sizeof(addr->pi_device));
#line 1043
      ps->device = pi_usb_device(1);
      }
    }
  } else {
    {
#line 1038
    strncpy((char */* __restrict  */)(addr->pi_device), (char const   */* __restrict  */)(port + 7),
            sizeof(addr->pi_device));
#line 1039
    ps->device = pi_serial_device(1);
    }
  }
#line 1059
  return (ps);
}
}
#line 40 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
static int cmp_flush___2(pi_socket_t *ps , int flags ) ;
#line 41
static int cmp_getsockopt___2(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) ;
#line 43
static int cmp_setsockopt___2(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) ;
#line 46
static pi_protocol_t *cmp_protocol_dup___2(pi_protocol_t *prot ) ;
#line 47
static void cmp_protocol_free___2(pi_protocol_t *prot ) ;
#line 61 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
static pi_protocol_t *cmp_protocol_dup___2(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  struct pi_cmp_data *data ;
  struct pi_cmp_data *new_data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 69
  tmp = malloc(sizeof(pi_protocol_t ));
#line 69
  new_prot = (pi_protocol_t *)tmp;
#line 70
  tmp___0 = malloc(sizeof(struct pi_cmp_data ));
#line 70
  new_data = (struct pi_cmp_data *)tmp___0;
  }
#line 72
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 72
    if ((unsigned long )new_data != (unsigned long )((void *)0)) {
#line 73
      new_prot->level = prot->level;
#line 74
      new_prot->dup = prot->dup;
#line 75
      new_prot->free = prot->free;
#line 76
      new_prot->read = prot->read;
#line 77
      new_prot->write = prot->write;
#line 78
      new_prot->flush = prot->flush;
#line 79
      new_prot->getsockopt = prot->getsockopt;
#line 80
      new_prot->setsockopt = prot->setsockopt;
#line 82
      data = (struct pi_cmp_data *)prot->data;
#line 83
      new_data->type = data->type;
#line 84
      new_data->flags = data->flags;
#line 85
      new_data->version = data->version;
#line 86
      new_data->baudrate = data->baudrate;
#line 88
      new_prot->data = (void *)new_data;
    } else {
#line 72
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 90
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
    {
#line 91
    free((void *)new_prot);
#line 92
    new_prot = (pi_protocol_t *)((void *)0);
    }
  } else
#line 93
  if ((unsigned long )new_data != (unsigned long )((void *)0)) {
    {
#line 94
    free((void *)new_data);
#line 95
    new_data = (struct pi_cmp_data *)((void *)0);
    }
  }
#line 98
  return (new_prot);
}
}
#line 113 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
static void cmp_protocol_free___2(pi_protocol_t *prot ) 
{ 


  {
#line 116
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 117
    if ((unsigned long )prot->data != (unsigned long )((void *)0)) {
      {
#line 118
      free(prot->data);
      }
    }
    {
#line 119
    free((void *)prot);
    }
  }
#line 121
  return;
}
}
#line 391 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
static int cmp_flush___2(pi_socket_t *ps , int flags ) 
{ 
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 397
  prot = pi_protocol(ps->sd, 5);
  }
#line 398
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 399
    tmp = pi_set_error(ps->sd, -201);
    }
#line 399
    return (tmp);
  }
  {
#line 401
  next = pi_protocol_next(ps->sd, 5);
  }
#line 402
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 403
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 403
    return (tmp___0);
  }
  {
#line 405
  tmp___1 = (*(next->flush))(ps, flags);
  }
#line 405
  return (tmp___1);
}
}
#line 511 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
static int cmp_getsockopt___2(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  struct pi_cmp_data *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 520
  prot = pi_protocol(ps->sd, 5);
  }
#line 521
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 522
    tmp = pi_set_error(ps->sd, -201);
    }
#line 522
    return (tmp);
  }
#line 523
  data = (struct pi_cmp_data *)prot->data;
  {
#line 526
  if (option_name == 0) {
#line 526
    goto case_0;
  }
#line 534
  if (option_name == 1) {
#line 534
    goto case_1;
  }
#line 542
  if (option_name == 2) {
#line 542
    goto case_2;
  }
#line 550
  if (option_name == 3) {
#line 550
    goto case_3;
  }
#line 525
  goto switch_break;
  case_0: /* CIL Label */ 
#line 527
  if (*option_len != sizeof(data->type)) {
#line 528
    goto error;
  }
  {
#line 529
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->type),
         sizeof(data->type));
#line 531
  *option_len = sizeof(data->type);
  }
#line 532
  goto switch_break;
  case_1: /* CIL Label */ 
#line 535
  if (*option_len != sizeof(data->flags)) {
#line 536
    goto error;
  }
  {
#line 537
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->flags),
         sizeof(data->flags));
#line 539
  *option_len = sizeof(data->flags);
  }
#line 540
  goto switch_break;
  case_2: /* CIL Label */ 
#line 543
  if (*option_len != sizeof(data->version)) {
#line 544
    goto error;
  }
  {
#line 545
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->version),
         sizeof(data->version));
#line 547
  *option_len = sizeof(data->version);
  }
#line 548
  goto switch_break;
  case_3: /* CIL Label */ 
#line 551
  if (*option_len != sizeof(data->baudrate)) {
#line 552
    goto error;
  }
  {
#line 553
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->baudrate),
         sizeof(data->baudrate));
#line 555
  *option_len = sizeof(data->baudrate);
  }
#line 556
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 559
  return (0);
  error: 
  {
#line 562
  tmp___0 = __errno_location();
#line 562
  *tmp___0 = 22;
#line 563
  tmp___1 = pi_set_error(ps->sd, -501);
  }
#line 563
  return (tmp___1);
}
}
#line 578 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/cmp.c"
static int cmp_setsockopt___2(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  struct pi_padp_data *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 587
  prot = pi_protocol(ps->sd, 2);
  }
#line 588
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 589
    tmp = pi_set_error(ps->sd, -201);
    }
#line 589
    return (tmp);
  }
#line 590
  data = (struct pi_padp_data *)prot->data;
#line 592
  if (option_name == 0) {
#line 593
    if (*option_len != sizeof(data->type)) {
#line 594
      goto error;
    }
    {
#line 595
    memcpy((void */* __restrict  */)(& data->type), (void const   */* __restrict  */)option_value,
           sizeof(data->type));
#line 597
    *option_len = sizeof(data->type);
    }
  }
#line 600
  return (0);
  error: 
  {
#line 603
  tmp___0 = __errno_location();
#line 603
  *tmp___0 = 22;
#line 604
  tmp___1 = pi_set_error(ps->sd, -501);
  }
#line 604
  return (tmp___1);
}
}
#line 49 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_open___2(pi_socket_t *ps , struct pi_sockaddr *addr , size_t addrlen ) ;
#line 50
static int u_close___2(pi_socket_t *ps ) ;
#line 51
static int u_write___2(pi_socket_t *ps , unsigned char *buf___3 , size_t len , int flags ) ;
#line 52
static int u_read___2(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) ;
#line 53
static int u_poll___2(pi_socket_t *ps , int timeout ) ;
#line 54
static int u_flush___2(pi_socket_t *ps , int flags ) ;
#line 83 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_open___2(pi_socket_t *ps , struct pi_sockaddr *addr , size_t addrlen ) 
{ 
  int fd ;
  int i ;
  char *tty ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 88
  tty = addr->pi_device;
#line 90
  fd = open((char const   *)tty, 2050);
  }
#line 90
  if (fd < 0) {
#line 91
    ps->last_error = -502;
#line 92
    return (-502);
  }
  {
#line 95
  tmp___0 = isatty(fd);
  }
#line 95
  if (! tmp___0) {
    {
#line 96
    close(fd);
#line 97
    tmp = __errno_location();
#line 97
    *tmp = 22;
#line 98
    ps->last_error = -502;
    }
#line 99
    return (-502);
  }
  {
#line 102
  i = fcntl(fd, 3, 0);
  }
#line 102
  if (i != -1) {
    {
#line 103
    i &= -2049;
#line 104
    fcntl(fd, 4, i);
    }
  }
  {
#line 107
  i = pi_socket_setsd(ps, fd);
  }
#line 107
  if (i < 0) {
#line 108
    return (i);
  }
#line 110
  return (fd);
}
}
#line 125 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_close___2(pi_socket_t *ps ) 
{ 
  int tmp ;

  {
  {
#line 128
  pi_log(2, 4, "DEV CLOSE linuxusb fd: %d\n", ps->sd);
#line 131
  tmp = close(ps->sd);
  }
#line 131
  return (tmp);
}
}
#line 146 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_poll___2(pi_socket_t *ps , int timeout ) 
{ 
  struct timeval t ;
  fd_set ready ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 152
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 157
  if (timeout == 0) {
    {
#line 158
    select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
           (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
    }
  } else {
    {
#line 160
    t.tv_sec = (__time_t )(timeout / 1000);
#line 161
    t.tv_usec = (__suseconds_t )((timeout % 1000) * 1000);
#line 162
    select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
           (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
    }
  }
#line 165
  if (! ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
    {
#line 167
    pi_log(2, 2, "DEV POLL linuxusb timeout\n");
#line 169
    tmp = __errno_location();
#line 169
    *tmp = 110;
#line 170
    tmp___0 = pi_set_error(ps->sd, -202);
    }
#line 170
    return (tmp___0);
  }
  {
#line 173
  pi_log(2, 8, "DEV POLL linuxusb found data on fd: %d\n", ps->sd);
  }
#line 176
  return (1);
}
}
#line 191 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_write___2(pi_socket_t *ps , unsigned char *buf___3 , size_t len , int flags ) 
{ 
  int total ;
  int nwrote ;
  struct pi_usb_data *data ;
  struct timeval t ;
  fd_set ready ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;

  {
#line 196
  data = (struct pi_usb_data *)(ps->device)->data;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 200
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 203
  total = (int )len;
  {
#line 204
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 204
    if (! (total > 0)) {
#line 204
      goto while_break___0;
    }
#line 205
    if (data->timeout == 0) {
      {
#line 206
      select(ps->sd + 1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)(& ready),
             (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
      }
    } else {
      {
#line 208
      t.tv_sec = (__time_t )(data->timeout / 1000);
#line 209
      t.tv_usec = (__suseconds_t )((data->timeout % 1000) * 1000);
#line 210
      tmp___0 = select(ps->sd + 1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)(& ready),
                       (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
      }
#line 210
      if (tmp___0) {
        {
#line 211
        tmp = pi_set_error(ps->sd, -202);
        }
#line 211
        return (tmp);
      }
    }
#line 214
    if (! ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
      {
#line 215
      ps->state = 8;
#line 216
      tmp___1 = pi_set_error(ps->sd, -200);
      }
#line 216
      return (tmp___1);
    }
    {
#line 219
    tmp___2 = write(ps->sd, (void const   *)buf___3, len);
#line 219
    nwrote = (int )tmp___2;
    }
#line 220
    if (nwrote < 0) {
      {
#line 221
      ps->state = 8;
#line 222
      tmp___3 = pi_set_error(ps->sd, -200);
      }
#line 222
      return (tmp___3);
    }
#line 225
    total -= nwrote;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 228
  pi_log(2, 8, "DEV TX linuxusb wrote %d bytes\n", len);
  }
#line 231
  return ((int )len);
}
}
#line 246 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_read_buf___2(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) 
{ 
  struct pi_usb_data *data ;
  size_t rbuf ;
  int *tmp ;
  int tmp___0 ;
  pi_buffer_t *tmp___1 ;

  {
#line 249
  data = (struct pi_usb_data *)(ps->device)->data;
#line 250
  rbuf = data->buf_size;
#line 252
  if (rbuf > len) {
#line 253
    rbuf = len;
  }
  {
#line 255
  tmp___1 = pi_buffer_append(buf___3, (void const   *)(data->buf), rbuf);
  }
#line 255
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 256
    tmp = __errno_location();
#line 256
    *tmp = 12;
#line 257
    tmp___0 = pi_set_error(ps->sd, -500);
    }
#line 257
    return (tmp___0);
  }
#line 260
  if (flags != 1) {
#line 261
    data->buf_size -= rbuf;
#line 262
    if (data->buf_size > 0UL) {
      {
#line 263
      memmove((void *)(data->buf), (void const   *)(& data->buf[rbuf]), data->buf_size);
      }
    }
  }
  {
#line 266
  pi_log(2, 8, "DEV RX linuxusb read %d bytes from read-ahead buffer\n", rbuf);
  }
#line 269
  return ((int )rbuf);
}
}
#line 284 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_read___2(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) 
{ 
  ssize_t rbuf ;
  ssize_t bytes ;
  struct pi_usb_data *data ;
  struct timeval t ;
  fd_set ready ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  pi_buffer_t *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
#line 287
  rbuf = (ssize_t )0;
#line 289
  data = (struct pi_usb_data *)(ps->device)->data;
#line 294
  if (data->buf_size) {
    {
#line 295
    tmp = u_read_buf___2(ps, buf___3, len, flags);
#line 295
    rbuf = (ssize_t )tmp;
    }
#line 296
    if (rbuf < 0L) {
#line 297
      return ((int )rbuf);
    }
#line 298
    len -= (size_t )rbuf;
#line 299
    if (len == 0UL) {
#line 300
      return ((int )rbuf);
    }
  }
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 305
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 307
  if (data->timeout == 0) {
    {
#line 308
    select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
           (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
    }
  } else {
    {
#line 310
    t.tv_sec = (__time_t )(data->timeout / 1000);
#line 311
    t.tv_usec = (__suseconds_t )((data->timeout % 1000) * 1000);
#line 312
    tmp___2 = select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
                     (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
    }
#line 312
    if (tmp___2 == 0) {
      {
#line 313
      pi_log(2, 2, "DEV RX linuxusb timeout\n");
#line 315
      tmp___0 = __errno_location();
#line 315
      *tmp___0 = 110;
#line 316
      tmp___1 = pi_set_error(ps->sd, -202);
      }
#line 316
      return (tmp___1);
    }
  }
#line 321
  if ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 322
    if (flags == 1) {
#line 322
      if (len > 256UL) {
#line 323
        len = (size_t )256;
      }
    }
    {
#line 325
    tmp___5 = pi_buffer_expect(buf___3, len);
    }
#line 325
    if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
      {
#line 326
      tmp___3 = __errno_location();
#line 326
      *tmp___3 = 12;
#line 327
      tmp___4 = pi_set_error(ps->sd, -500);
      }
#line 327
      return (tmp___4);
    }
    {
#line 330
    bytes = read(ps->sd, (void *)(buf___3->data + buf___3->used), len);
    }
#line 332
    if (bytes > 0L) {
#line 333
      if (flags == 1) {
        {
#line 334
        memcpy((void */* __restrict  */)(data->buf + data->buf_size), (void const   */* __restrict  */)(buf___3->data + buf___3->used),
               (size_t )bytes);
#line 335
        data->buf_size += (size_t )bytes;
        }
      }
      {
#line 337
      buf___3->used += (size_t )bytes;
#line 338
      rbuf += bytes;
#line 340
      pi_log(2, 8, "DEV RX linuxusb read %d bytes\n", bytes);
      }
    }
  } else {
    {
#line 344
    pi_log(2, 2, "DEV RX linuxusb timeout\n");
#line 346
    tmp___6 = __errno_location();
#line 346
    *tmp___6 = 110;
#line 347
    tmp___7 = pi_set_error(ps->sd, -202);
    }
#line 347
    return (tmp___7);
  }
#line 350
  return ((int )rbuf);
}
}
#line 370 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/linuxusb.c"
static int u_flush___2(pi_socket_t *ps , int flags ) 
{ 
  char buf___3[256] ;
  int fl ;
  struct pi_usb_data *data ;
  int tmp ;

  {
#line 375
  data = (struct pi_usb_data *)(ps->device)->data;
#line 377
  if (flags & 1) {
    {
#line 379
    data->buf_size = (size_t )0;
#line 382
    fl = fcntl(ps->sd, 3, 0);
    }
#line 382
    if (fl != -1) {
      {
#line 383
      fcntl(ps->sd, 4, fl | 2048);
      }
      {
#line 384
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 384
        tmp = (int )recv(ps->sd, buf___3, sizeof(buf___3), 0);
        }
#line 384
        if (! (tmp > 0)) {
#line 384
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 386
      fcntl(ps->sd, 4, 0);
      }
    }
    {
#line 389
    pi_log(2, 8, "DEV FLUSH linuxusb flushed input buffer\n");
    }
  }
#line 392
  return (0);
}
}
#line 99 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
static int pi_file_close_for_write___2(pi_file_t *pf ) ;
#line 100
static void pi_file_free___2(pi_file_t *pf ) ;
#line 101
static int pi_file_find_resource_by_type_id___2(pi_file_t const   *pf , unsigned long restype ,
                                                int resid , int *resindex ) ;
#line 102
static pi_file_entry_t *pi_file_append_entry___2(pi_file_t *pf ) ;
#line 103
static int pi_file_set_rbuf_size___2(pi_file_t *pf , size_t size ) ;
#line 1270 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
static int pi_file_close_for_write___2(pi_file_t *pf ) 
{ 
  int i ;
  int offset ;
  FILE *f ;
  struct DBInfo *ip ;
  struct pi_file_entry *entp ;
  struct stat sbuf ;
  unsigned char buf___3[512] ;
  unsigned char *p ;
  int tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
#line 1284
  ip = & pf->info;
#line 1285
  if (pf->num_entries >= 65536) {
#line 1290
    return (-400);
  }
  {
#line 1301
  tmp = stat((char const   */* __restrict  */)pf->file_name, (struct stat */* __restrict  */)(& sbuf));
  }
#line 1301
  if (! tmp) {
#line 1302
    if ((sbuf.st_mode & 61440U) == 32768U) {
      {
#line 1303
      unlink((char const   *)pf->file_name);
      }
    }
  }
  {
#line 1305
  f = fopen((char const   */* __restrict  */)pf->file_name, (char const   */* __restrict  */)"wb");
  }
#line 1305
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 1306
    return (-401);
  }
  {
#line 1308
  ip = & pf->info;
#line 1310
  offset = (78 + pf->num_entries * pf->ent_hdr_size) + 2;
#line 1312
  p = buf___3;
#line 1313
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(ip->name),
         (size_t )32);
#line 1314
  *((p + 32) + 0) = (unsigned char )(((int )((unsigned short )ip->flags) >> 8) & 255);
#line 1314
  *((p + 32) + 1) = (unsigned char )((int )((unsigned short )ip->flags) & 255);
#line 1315
  *((p + 34) + 0) = (unsigned char )(((int )((unsigned short )ip->version) >> 8) & 255);
#line 1315
  *((p + 34) + 1) = (unsigned char )((int )((unsigned short )ip->version) & 255);
#line 1316
  tmp___0 = unix_time_to_pilot_time(ip->createDate);
#line 1316
  *((p + 36) + 0) = (unsigned char )((int )((unsigned char )(tmp___0 >> 24)) & 255);
#line 1316
  tmp___1 = unix_time_to_pilot_time(ip->createDate);
#line 1316
  *((p + 36) + 1) = (unsigned char )((tmp___1 >> 16) & 255UL);
#line 1316
  tmp___2 = unix_time_to_pilot_time(ip->createDate);
#line 1316
  *((p + 36) + 2) = (unsigned char )((tmp___2 >> 8) & 255UL);
#line 1316
  tmp___3 = unix_time_to_pilot_time(ip->createDate);
#line 1316
  *((p + 36) + 3) = (unsigned char )(tmp___3 & 255UL);
#line 1317
  tmp___4 = unix_time_to_pilot_time(ip->modifyDate);
#line 1317
  *((p + 40) + 0) = (unsigned char )((int )((unsigned char )(tmp___4 >> 24)) & 255);
#line 1317
  tmp___5 = unix_time_to_pilot_time(ip->modifyDate);
#line 1317
  *((p + 40) + 1) = (unsigned char )((tmp___5 >> 16) & 255UL);
#line 1317
  tmp___6 = unix_time_to_pilot_time(ip->modifyDate);
#line 1317
  *((p + 40) + 2) = (unsigned char )((tmp___6 >> 8) & 255UL);
#line 1317
  tmp___7 = unix_time_to_pilot_time(ip->modifyDate);
#line 1317
  *((p + 40) + 3) = (unsigned char )(tmp___7 & 255UL);
#line 1318
  tmp___8 = unix_time_to_pilot_time(ip->backupDate);
#line 1318
  *((p + 44) + 0) = (unsigned char )((int )((unsigned char )(tmp___8 >> 24)) & 255);
#line 1318
  tmp___9 = unix_time_to_pilot_time(ip->backupDate);
#line 1318
  *((p + 44) + 1) = (unsigned char )((tmp___9 >> 16) & 255UL);
#line 1318
  tmp___10 = unix_time_to_pilot_time(ip->backupDate);
#line 1318
  *((p + 44) + 2) = (unsigned char )((tmp___10 >> 8) & 255UL);
#line 1318
  tmp___11 = unix_time_to_pilot_time(ip->backupDate);
#line 1318
  *((p + 44) + 3) = (unsigned char )(tmp___11 & 255UL);
#line 1319
  *((p + 48) + 0) = (unsigned char )((int )((unsigned char )(ip->modnum >> 24)) & 255);
#line 1319
  *((p + 48) + 1) = (unsigned char )((ip->modnum >> 16) & 255UL);
#line 1319
  *((p + 48) + 2) = (unsigned char )((ip->modnum >> 8) & 255UL);
#line 1319
  *((p + 48) + 3) = (unsigned char )(ip->modnum & 255UL);
  }
#line 1320
  if (pf->app_info_size) {
#line 1320
    tmp___12 = offset;
  } else {
#line 1320
    tmp___12 = 0;
  }
#line 1320
  *((p + 52) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )tmp___12 >> 24)) & 255);
#line 1320
  if (pf->app_info_size) {
#line 1320
    tmp___13 = offset;
  } else {
#line 1320
    tmp___13 = 0;
  }
#line 1320
  *((p + 52) + 1) = (unsigned char )(((unsigned long )tmp___13 >> 16) & 255UL);
#line 1320
  if (pf->app_info_size) {
#line 1320
    tmp___14 = offset;
  } else {
#line 1320
    tmp___14 = 0;
  }
#line 1320
  *((p + 52) + 2) = (unsigned char )(((unsigned long )tmp___14 >> 8) & 255UL);
#line 1320
  if (pf->app_info_size) {
#line 1320
    tmp___15 = offset;
  } else {
#line 1320
    tmp___15 = 0;
  }
#line 1320
  *((p + 52) + 3) = (unsigned char )((unsigned long )tmp___15 & 255UL);
#line 1321
  offset += pf->app_info_size;
#line 1322
  if (pf->sort_info_size) {
#line 1322
    tmp___16 = offset;
  } else {
#line 1322
    tmp___16 = 0;
  }
#line 1322
  *((p + 56) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )tmp___16 >> 24)) & 255);
#line 1322
  if (pf->sort_info_size) {
#line 1322
    tmp___17 = offset;
  } else {
#line 1322
    tmp___17 = 0;
  }
#line 1322
  *((p + 56) + 1) = (unsigned char )(((unsigned long )tmp___17 >> 16) & 255UL);
#line 1322
  if (pf->sort_info_size) {
#line 1322
    tmp___18 = offset;
  } else {
#line 1322
    tmp___18 = 0;
  }
#line 1322
  *((p + 56) + 2) = (unsigned char )(((unsigned long )tmp___18 >> 8) & 255UL);
#line 1322
  if (pf->sort_info_size) {
#line 1322
    tmp___19 = offset;
  } else {
#line 1322
    tmp___19 = 0;
  }
  {
#line 1322
  *((p + 56) + 3) = (unsigned char )((unsigned long )tmp___19 & 255UL);
#line 1323
  offset += pf->sort_info_size;
#line 1324
  *((p + 60) + 0) = (unsigned char )((int )((unsigned char )(ip->type >> 24)) & 255);
#line 1324
  *((p + 60) + 1) = (unsigned char )((ip->type >> 16) & 255UL);
#line 1324
  *((p + 60) + 2) = (unsigned char )((ip->type >> 8) & 255UL);
#line 1324
  *((p + 60) + 3) = (unsigned char )(ip->type & 255UL);
#line 1325
  *((p + 64) + 0) = (unsigned char )((int )((unsigned char )(ip->creator >> 24)) & 255);
#line 1325
  *((p + 64) + 1) = (unsigned char )((ip->creator >> 16) & 255UL);
#line 1325
  *((p + 64) + 2) = (unsigned char )((ip->creator >> 8) & 255UL);
#line 1325
  *((p + 64) + 3) = (unsigned char )(ip->creator & 255UL);
#line 1326
  *((p + 68) + 0) = (unsigned char )((int )((unsigned char )(pf->unique_id_seed >> 24)) & 255);
#line 1326
  *((p + 68) + 1) = (unsigned char )((pf->unique_id_seed >> 16) & 255UL);
#line 1326
  *((p + 68) + 2) = (unsigned char )((pf->unique_id_seed >> 8) & 255UL);
#line 1326
  *((p + 68) + 3) = (unsigned char )(pf->unique_id_seed & 255UL);
#line 1327
  *((p + 72) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )pf->next_record_list_id >> 24)) & 255);
#line 1327
  *((p + 72) + 1) = (unsigned char )(((unsigned long )pf->next_record_list_id >> 16) & 255UL);
#line 1327
  *((p + 72) + 2) = (unsigned char )(((unsigned long )pf->next_record_list_id >> 8) & 255UL);
#line 1327
  *((p + 72) + 3) = (unsigned char )((unsigned long )pf->next_record_list_id & 255UL);
#line 1328
  *((p + 76) + 0) = (unsigned char )(((int )((unsigned short )pf->num_entries) >> 8) & 255);
#line 1328
  *((p + 76) + 1) = (unsigned char )((int )((unsigned short )pf->num_entries) & 255);
#line 1330
  tmp___20 = fwrite((void const   */* __restrict  */)(buf___3), (size_t )78, (size_t )1,
                    (FILE */* __restrict  */)f);
  }
#line 1330
  if (tmp___20 != 1UL) {
#line 1331
    goto bad;
  }
#line 1333
  i = 0;
#line 1333
  entp = pf->entries;
  {
#line 1333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1333
    if (! (i < pf->num_entries)) {
#line 1333
      goto while_break;
    }
#line 1334
    entp->offset = offset;
#line 1336
    p = buf___3;
#line 1337
    if (pf->resource_flag) {
#line 1338
      *(p + 0) = (unsigned char )((int )((unsigned char )(entp->type >> 24)) & 255);
#line 1338
      *(p + 1) = (unsigned char )((entp->type >> 16) & 255UL);
#line 1338
      *(p + 2) = (unsigned char )((entp->type >> 8) & 255UL);
#line 1338
      *(p + 3) = (unsigned char )(entp->type & 255UL);
#line 1339
      *((p + 4) + 0) = (unsigned char )(((int )((unsigned short )entp->resource_id) >> 8) & 255);
#line 1339
      *((p + 4) + 1) = (unsigned char )((int )((unsigned short )entp->resource_id) & 255);
#line 1340
      *((p + 6) + 0) = (unsigned char )((int )((unsigned char )((unsigned long )entp->offset >> 24)) & 255);
#line 1340
      *((p + 6) + 1) = (unsigned char )(((unsigned long )entp->offset >> 16) & 255UL);
#line 1340
      *((p + 6) + 2) = (unsigned char )(((unsigned long )entp->offset >> 8) & 255UL);
#line 1340
      *((p + 6) + 3) = (unsigned char )((unsigned long )entp->offset & 255UL);
    } else {
#line 1342
      *(p + 0) = (unsigned char )((int )((unsigned char )((unsigned long )entp->offset >> 24)) & 255);
#line 1342
      *(p + 1) = (unsigned char )(((unsigned long )entp->offset >> 16) & 255UL);
#line 1342
      *(p + 2) = (unsigned char )(((unsigned long )entp->offset >> 8) & 255UL);
#line 1342
      *(p + 3) = (unsigned char )((unsigned long )entp->offset & 255UL);
#line 1343
      *((p + 4) + 0) = (unsigned char )entp->attrs;
#line 1344
      *((p + 5) + 0) = (unsigned char )((int )((unsigned char )(entp->uid >> 16)) & 255);
#line 1344
      *((p + 5) + 1) = (unsigned char )((entp->uid >> 8) & 255UL);
#line 1344
      *((p + 5) + 2) = (unsigned char )(entp->uid & 255UL);
    }
    {
#line 1347
    tmp___21 = fwrite((void const   */* __restrict  */)(buf___3), (size_t )pf->ent_hdr_size,
                      (size_t )1, (FILE */* __restrict  */)f);
    }
#line 1347
    if (tmp___21 != 1UL) {
#line 1348
      goto bad;
    }
#line 1350
    offset += entp->size;
#line 1333
    i ++;
#line 1333
    entp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1354
  fwrite((void const   */* __restrict  */)"\000\000", (size_t )1, (size_t )2, (FILE */* __restrict  */)f);
  }
#line 1356
  if (pf->app_info) {
    {
#line 1356
    tmp___22 = fwrite((void const   */* __restrict  */)pf->app_info, (size_t )1, (size_t )pf->app_info_size,
                      (FILE */* __restrict  */)f);
    }
#line 1356
    if (tmp___22 != (size_t )pf->app_info_size) {
#line 1359
      goto bad;
    }
  }
#line 1361
  if (pf->sort_info) {
    {
#line 1361
    tmp___23 = fwrite((void const   */* __restrict  */)pf->sort_info, (size_t )1,
                      (size_t )pf->sort_info_size, (FILE */* __restrict  */)f);
    }
#line 1361
    if (tmp___23 != (size_t )pf->sort_info_size) {
#line 1364
      goto bad;
    }
  }
  {
#line 1367
  fwrite((void const   */* __restrict  */)(pf->tmpbuf)->data, (pf->tmpbuf)->used,
         (size_t )1, (FILE */* __restrict  */)f);
#line 1368
  fflush(f);
#line 1370
  tmp___24 = ferror(f);
  }
#line 1370
  if (tmp___24) {
#line 1371
    goto bad;
  } else {
    {
#line 1370
    tmp___25 = feof(f);
    }
#line 1370
    if (tmp___25) {
#line 1371
      goto bad;
    }
  }
  {
#line 1373
  fclose(f);
  }
#line 1374
  return (0);
  bad: 
  {
#line 1377
  fclose(f);
  }
#line 1378
  return (-401);
}
}
#line 1392 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
static void pi_file_free___2(pi_file_t *pf ) 
{ 


  {
#line 1397
  if ((unsigned long )pf->f != (unsigned long )((FILE *)0)) {
    {
#line 1398
    fclose(pf->f);
    }
  }
#line 1400
  if ((unsigned long )pf->app_info != (unsigned long )((void *)0)) {
    {
#line 1401
    free(pf->app_info);
    }
  }
#line 1403
  if ((unsigned long )pf->sort_info != (unsigned long )((void *)0)) {
    {
#line 1404
    free(pf->sort_info);
    }
  }
#line 1406
  if ((unsigned long )pf->entries != (unsigned long )((void *)0)) {
    {
#line 1407
    free((void *)pf->entries);
    }
  }
#line 1409
  if ((unsigned long )pf->file_name != (unsigned long )((void *)0)) {
    {
#line 1410
    free((void *)pf->file_name);
    }
  }
#line 1412
  if ((unsigned long )pf->rbuf != (unsigned long )((void *)0)) {
    {
#line 1413
    free(pf->rbuf);
    }
  }
#line 1415
  if ((unsigned long )pf->tmpbuf != (unsigned long )((void *)0)) {
    {
#line 1416
    pi_buffer_free(pf->tmpbuf);
    }
  }
  {
#line 1419
  memset((void *)pf, 0, sizeof(pi_file_t ));
#line 1421
  free((void *)pf);
  }
#line 1422
  return;
}
}
#line 1435 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
static int pi_file_set_rbuf_size___2(pi_file_t *pf , size_t size ) 
{ 
  size_t new_size ;
  void *rbuf ;

  {
#line 1441
  if (size > (size_t )pf->rbuf_size) {
#line 1442
    if (pf->rbuf_size == 0) {
      {
#line 1443
      new_size = size + 2048UL;
#line 1444
      rbuf = malloc(new_size);
      }
    } else {
      {
#line 1446
      new_size = size + 2048UL;
#line 1447
      rbuf = realloc(pf->rbuf, new_size);
      }
    }
#line 1450
    if ((unsigned long )rbuf == (unsigned long )((void *)0)) {
#line 1451
      return (-500);
    }
#line 1453
    pf->rbuf_size = (int )new_size;
#line 1454
    pf->rbuf = rbuf;
  }
#line 1457
  return (0);
}
}
#line 1472 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
static pi_file_entry_t *pi_file_append_entry___2(pi_file_t *pf ) 
{ 
  int new_count ;
  size_t new_size ;
  struct pi_file_entry *new_entries ;
  struct pi_file_entry *entp ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1480
  if (pf->num_entries >= pf->num_entries_allocated) {
#line 1481
    if (pf->num_entries_allocated == 0) {
#line 1482
      new_count = 100;
    } else {
#line 1484
      new_count = (pf->num_entries_allocated * 3) / 2;
    }
#line 1485
    new_size = (unsigned long )new_count * sizeof(*(pf->entries));
#line 1487
    if ((unsigned long )pf->entries == (unsigned long )((void *)0)) {
      {
#line 1488
      tmp = malloc(new_size);
#line 1488
      new_entries = (struct pi_file_entry *)tmp;
      }
    } else {
      {
#line 1490
      tmp___0 = realloc((void *)pf->entries, new_size);
#line 1490
      new_entries = (struct pi_file_entry *)tmp___0;
      }
    }
#line 1492
    if ((unsigned long )new_entries == (unsigned long )((void *)0)) {
#line 1493
      return ((pi_file_entry_t *)((void *)0));
    }
#line 1495
    pf->num_entries_allocated = new_count;
#line 1496
    pf->entries = new_entries;
  }
  {
#line 1499
  tmp___1 = pf->num_entries;
#line 1499
  (pf->num_entries) ++;
#line 1499
  entp = pf->entries + tmp___1;
#line 1500
  memset((void *)entp, 0, sizeof(*entp));
  }
#line 1501
  return (entp);
}
}
#line 1504 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/pi-file.c"
static int pi_file_find_resource_by_type_id___2(pi_file_t const   *pf , unsigned long restype ,
                                                int resid , int *resindex ) 
{ 
  int i ;
  struct pi_file_entry *entp ;

  {
#line 1511
  if (! pf->resource_flag) {
#line 1512
    return (-400);
  }
#line 1514
  i = 0;
#line 1514
  entp = (struct pi_file_entry *)pf->entries;
  {
#line 1514
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1514
    if (! (i < (int )pf->num_entries)) {
#line 1514
      goto while_break;
    }
#line 1515
    if (entp->type == restype) {
#line 1515
      if (entp->resource_id == resid) {
#line 1516
        if (resindex) {
#line 1517
          *resindex = i;
        }
#line 1518
        return (1);
      }
    }
#line 1514
    i ++;
#line 1514
    entp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1521
  return (0);
}
}
#line 47 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
static int slp_flush___2(pi_socket_t *ps , int flags ) ;
#line 48
static int slp_getsockopt___2(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) ;
#line 50
static int slp_setsockopt___2(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) ;
#line 65 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
static pi_protocol_t *slp_protocol_dup___2(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  struct pi_slp_data *data ;
  struct pi_slp_data *new_data ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 73
  tmp = malloc(sizeof(pi_protocol_t ));
#line 73
  new_prot = (pi_protocol_t *)tmp;
#line 74
  tmp___0 = malloc(sizeof(struct pi_slp_data ));
#line 74
  new_data = (struct pi_slp_data *)tmp___0;
  }
#line 76
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 76
    if ((unsigned long )new_data != (unsigned long )((void *)0)) {
#line 77
      new_prot->level = prot->level;
#line 78
      new_prot->dup = prot->dup;
#line 79
      new_prot->free = prot->free;
#line 80
      new_prot->read = prot->read;
#line 81
      new_prot->write = prot->write;
#line 82
      new_prot->flush = prot->flush;
#line 83
      new_prot->getsockopt = prot->getsockopt;
#line 84
      new_prot->setsockopt = prot->setsockopt;
#line 86
      data = (struct pi_slp_data *)prot->data;
#line 88
      new_data->dest = data->dest;
#line 89
      new_data->last_dest = data->last_dest;
#line 90
      new_data->src = data->src;
#line 91
      new_data->last_src = data->last_src;
#line 92
      new_data->type = data->type;
#line 93
      new_data->last_type = data->last_type;
#line 94
      new_data->txid = data->txid;
#line 95
      new_data->last_txid = data->last_txid;
#line 97
      new_prot->data = (void *)new_data;
    } else {
#line 76
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 99
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
    {
#line 100
    free((void *)new_prot);
#line 101
    new_prot = (pi_protocol_t *)((void *)0);
    }
  } else
#line 102
  if ((unsigned long )new_data != (unsigned long )((void *)0)) {
    {
#line 103
    free((void *)new_data);
#line 104
    new_data = (struct pi_slp_data *)((void *)0);
    }
  }
#line 107
  return (new_prot);
}
}
#line 122 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
static void slp_protocol_free___2(pi_protocol_t *prot ) 
{ 


  {
#line 125
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 126
    if ((unsigned long )prot->data != (unsigned long )((void *)0)) {
      {
#line 127
      free(prot->data);
      }
    }
    {
#line 128
    free((void *)prot);
    }
  }
#line 130
  return;
}
}
#line 440 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
static int slp_flush___2(pi_socket_t *ps , int flags ) 
{ 
  pi_protocol_t *prot ;
  pi_protocol_t *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 446
  prot = pi_protocol(ps->sd, 1);
  }
#line 447
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 448
    tmp = pi_set_error(ps->sd, -201);
    }
#line 448
    return (tmp);
  }
  {
#line 450
  next = pi_protocol_next(ps->sd, 1);
  }
#line 451
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    {
#line 452
    tmp___0 = pi_set_error(ps->sd, -201);
    }
#line 452
    return (tmp___0);
  }
  {
#line 454
  tmp___1 = (*(next->flush))(ps, flags);
  }
#line 454
  return (tmp___1);
}
}
#line 468 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
static int slp_getsockopt___2(pi_socket_t *ps , int level , int option_name , void *option_value ,
                              size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  struct pi_slp_data *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 475
  prot = pi_protocol(ps->sd, 1);
  }
#line 476
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 477
    tmp = pi_set_error(ps->sd, -201);
    }
#line 477
    return (tmp);
  }
#line 479
  data = (struct pi_slp_data *)prot->data;
  {
#line 482
  if (option_name == 0) {
#line 482
    goto case_0;
  }
#line 488
  if (option_name == 1) {
#line 488
    goto case_1;
  }
#line 495
  if (option_name == 2) {
#line 495
    goto case_2;
  }
#line 502
  if (option_name == 3) {
#line 502
    goto case_3;
  }
#line 509
  if (option_name == 4) {
#line 509
    goto case_4;
  }
#line 516
  if (option_name == 5) {
#line 516
    goto case_5;
  }
#line 523
  if (option_name == 6) {
#line 523
    goto case_6;
  }
#line 530
  if (option_name == 7) {
#line 530
    goto case_7;
  }
#line 481
  goto switch_break;
  case_0: /* CIL Label */ 
#line 483
  if (*option_len < sizeof(data->dest)) {
#line 484
    goto error;
  }
  {
#line 485
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->dest),
         sizeof(data->dest));
#line 486
  *option_len = sizeof(data->dest);
  }
#line 487
  goto switch_break;
  case_1: /* CIL Label */ 
#line 489
  if (*option_len < sizeof(data->dest)) {
#line 490
    goto error;
  }
  {
#line 491
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->last_dest),
         sizeof(data->last_dest));
#line 493
  *option_len = sizeof(data->last_dest);
  }
#line 494
  goto switch_break;
  case_2: /* CIL Label */ 
#line 496
  if (*option_len < sizeof(data->src)) {
#line 497
    goto error;
  }
  {
#line 498
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->src),
         sizeof(data->src));
#line 500
  *option_len = sizeof(data->src);
  }
#line 501
  goto switch_break;
  case_3: /* CIL Label */ 
#line 503
  if (*option_len < sizeof(data->last_src)) {
#line 504
    goto error;
  }
  {
#line 505
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->last_src),
         sizeof(data->last_src));
#line 507
  *option_len = sizeof(data->last_src);
  }
#line 508
  goto switch_break;
  case_4: /* CIL Label */ 
#line 510
  if (*option_len < sizeof(data->type)) {
#line 511
    goto error;
  }
  {
#line 512
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->type),
         sizeof(data->type));
#line 514
  *option_len = sizeof(data->type);
  }
#line 515
  goto switch_break;
  case_5: /* CIL Label */ 
#line 517
  if (*option_len < sizeof(data->last_type)) {
#line 518
    goto error;
  }
  {
#line 519
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->last_type),
         sizeof(data->last_type));
#line 521
  *option_len = sizeof(data->last_type);
  }
#line 522
  goto switch_break;
  case_6: /* CIL Label */ 
#line 524
  if (*option_len < sizeof(data->txid)) {
#line 525
    goto error;
  }
  {
#line 526
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->txid),
         sizeof(data->txid));
#line 528
  *option_len = sizeof(data->txid);
  }
#line 529
  goto switch_break;
  case_7: /* CIL Label */ 
#line 531
  if (*option_len < sizeof(data->last_txid)) {
#line 532
    goto error;
  }
  {
#line 533
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->last_txid),
         sizeof(data->last_txid));
#line 535
  *option_len = sizeof(data->last_txid);
  }
#line 536
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 539
  return (0);
  error: 
  {
#line 542
  tmp___0 = __errno_location();
#line 542
  *tmp___0 = 22;
#line 543
  tmp___1 = pi_set_error(ps->sd, -501);
  }
#line 543
  return (tmp___1);
}
}
#line 558 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/slp.c"
static int slp_setsockopt___2(pi_socket_t *ps , int level , int option_name , void const   *option_value ,
                              size_t *option_len ) 
{ 
  pi_protocol_t *prot ;
  struct pi_slp_data *data ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 565
  prot = pi_protocol(ps->sd, 1);
  }
#line 566
  if ((unsigned long )prot == (unsigned long )((void *)0)) {
    {
#line 567
    tmp = pi_set_error(ps->sd, -201);
    }
#line 567
    return (tmp);
  }
#line 568
  data = (struct pi_slp_data *)prot->data;
  {
#line 571
  if (option_name == 0) {
#line 571
    goto case_0;
  }
#line 578
  if (option_name == 2) {
#line 578
    goto case_2;
  }
#line 585
  if (option_name == 4) {
#line 585
    goto case_4;
  }
#line 592
  if (option_name == 6) {
#line 592
    goto case_6;
  }
#line 570
  goto switch_break;
  case_0: /* CIL Label */ 
#line 572
  if (*option_len != sizeof(data->dest)) {
#line 573
    goto error;
  }
  {
#line 574
  memcpy((void */* __restrict  */)(& data->dest), (void const   */* __restrict  */)option_value,
         sizeof(data->dest));
#line 576
  *option_len = sizeof(data->dest);
  }
#line 577
  goto switch_break;
  case_2: /* CIL Label */ 
#line 579
  if (*option_len != sizeof(data->src)) {
#line 580
    goto error;
  }
  {
#line 581
  memcpy((void */* __restrict  */)(& data->src), (void const   */* __restrict  */)option_value,
         sizeof(data->src));
#line 583
  *option_len = sizeof(data->src);
  }
#line 584
  goto switch_break;
  case_4: /* CIL Label */ 
#line 586
  if (*option_len != sizeof(data->type)) {
#line 587
    goto error;
  }
  {
#line 588
  memcpy((void */* __restrict  */)(& data->type), (void const   */* __restrict  */)option_value,
         sizeof(data->type));
#line 590
  *option_len = sizeof(data->type);
  }
#line 591
  goto switch_break;
  case_6: /* CIL Label */ 
#line 593
  if (*option_len != sizeof(data->txid)) {
#line 594
    goto error;
  }
  {
#line 595
  memcpy((void */* __restrict  */)(& data->txid), (void const   */* __restrict  */)option_value,
         sizeof(data->txid));
#line 597
  *option_len = sizeof(data->txid);
  }
#line 598
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 601
  return (0);
  error: 
  {
#line 604
  tmp___0 = __errno_location();
#line 604
  *tmp___0 = 22;
#line 605
  tmp___1 = pi_set_error(ps->sd, -501);
  }
#line 605
  return (tmp___1);
}
}
#line 1121 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/palmpix.c"
static void Bias___2(double bias , int width , int height , uint8_t *data ) 
{ 
  int i ;
  double num ;
  double denom ;
  double t ;

  {
  {
#line 1126
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bias factor : %lf\n",
          bias);
#line 1128
  i = 0;
  }
  {
#line 1128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1128
    if (! (i < width * height)) {
#line 1128
      goto while_break;
    }
#line 1130
    t = (double )*(data + i) / 256.0;
#line 1131
    num = t;
#line 1132
    denom = (1.0 / bias - (double )2) * (1.0 - t) + (double )1;
#line 1133
    *(data + i) = (uint8_t )((num / denom) * 256.0);
#line 1128
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1135
  return;
}
}
#line 1429 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/palmpix.c"
static void Interpolate___2(struct PalmPixHeader  const  *pixHdr , uint8_t *red ,
                            uint8_t *greenR , uint8_t *greenB , uint8_t *blue , uint8_t *pp ,
                            int offset_r , int offset_g , int offset_b ) 
{ 
  int idx ;
  int offset ;
  int ppOff ;
  int x ;
  int y ;
  int rowOff ;
  uint8_t r ;
  uint8_t g ;
  uint8_t b ;
  int rawWidth ;

  {
#line 1434
  rawWidth = (int )(pixHdr->w / 2);
#line 1436
  y = 1;
  {
#line 1436
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1436
    if (! (y < (int )(pixHdr->h - 1))) {
#line 1436
      goto while_break;
    }
#line 1439
    idx = y / 2;
#line 1440
    offset = idx * rawWidth;
#line 1441
    ppOff = y * (int )pixHdr->w;
#line 1443
    if (y % 2 == 1) {
#line 1445
      x = 1;
      {
#line 1445
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1445
        if (! (x < rawWidth - 1)) {
#line 1445
          goto while_break___0;
        }
#line 1448
        rowOff = x * 2;
#line 1450
        r = (uint8_t )(((((int )*(red + ((offset + x) - 1)) + (int )*(red + (offset + x))) + (int )*(red + (((offset + rawWidth) + x) - 1))) + (int )*(red + ((offset + rawWidth) + x))) >> 2);
#line 1451
        g = (uint8_t )(((((int )*(greenR + (offset + x)) + (int )*(greenR + ((offset + x) + rawWidth))) + (int )*(greenB + ((offset + x) - 1))) + (int )*(greenB + (offset + x))) >> 2);
#line 1452
        b = *(blue + (offset + x));
#line 1453
        *(pp + (3 * (ppOff + rowOff) + offset_r)) = r;
#line 1454
        *(pp + (3 * (ppOff + rowOff) + offset_g)) = g;
#line 1455
        *(pp + (3 * (ppOff + rowOff) + offset_b)) = b;
#line 1457
        r = (uint8_t )(((int )*(red + (offset + x)) + (int )*(red + ((offset + rawWidth) + x))) >> 1);
#line 1458
        g = (uint8_t )(((((((int )*(greenB + (offset + x)) << 2) + (int )*(greenR + (offset + x))) + (int )*(greenR + ((offset + x) + 1))) + (int )*(greenR + ((offset + x) + rawWidth))) + (int )*(greenR + (((offset + x) + rawWidth) + 1))) >> 3);
#line 1459
        b = (uint8_t )(((int )*(blue + (offset + x)) + (int )*(blue + ((offset + x) + 1))) >> 1);
#line 1460
        *(pp + (3 * ((ppOff + rowOff) + 1) + offset_r)) = r;
#line 1461
        *(pp + (3 * ((ppOff + rowOff) + 1) + offset_g)) = g;
#line 1462
        *(pp + (3 * ((ppOff + rowOff) + 1) + offset_b)) = b;
#line 1445
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 1468
      x = 1;
      {
#line 1468
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1468
        if (! (x < rawWidth - 1)) {
#line 1468
          goto while_break___1;
        }
#line 1470
        rowOff = x * 2;
#line 1472
        r = (uint8_t )(((int )*(red + ((offset + x) - 1)) + (int )*(red + (offset + x))) >> 1);
#line 1473
        g = (uint8_t )(((((((int )*(greenR + (offset + x)) << 2) + (int )*(greenB + (((offset - rawWidth) + x) - 1))) + (int )*(greenB + ((offset - rawWidth) + x))) + (int )*(greenB + ((offset + x) - 1))) + (int )*(greenB + (offset + x))) >> 3);
#line 1474
        b = (uint8_t )(((int )*(blue + ((offset - rawWidth) + x)) + (int )*(blue + (offset + x))) >> 1);
#line 1475
        *(pp + (3 * (ppOff + rowOff) + offset_r)) = r;
#line 1476
        *(pp + (3 * (ppOff + rowOff) + offset_g)) = g;
#line 1477
        *(pp + (3 * (ppOff + rowOff) + offset_b)) = b;
#line 1479
        r = *(red + (offset + x));
#line 1480
        g = (uint8_t )(((((int )*(greenR + (offset + x)) + (int )*(greenR + ((offset + x) + 1))) + (int )*(greenB + ((offset - rawWidth) + x))) + (int )*(greenB + (offset + x))) >> 2);
#line 1481
        b = (uint8_t )(((((int )*(blue + ((offset + x) - rawWidth)) + (int )*(blue + (((offset + x) - rawWidth) - 1))) + (int )*(blue + (offset + x))) + (int )*(blue + ((offset + x) + 1))) >> 2);
#line 1482
        *(pp + (3 * ((ppOff + rowOff) + 1) + offset_r)) = r;
#line 1483
        *(pp + (3 * ((ppOff + rowOff) + 1) + offset_g)) = g;
#line 1484
        *(pp + (3 * ((ppOff + rowOff) + 1) + offset_b)) = b;
#line 1468
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 1436
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1490
  return;
}
}
#line 1601 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/palmpix.c"
static int get_le_short___2(unsigned char const   *p ) 
{ 


  {
#line 1605
  return ((int )((int const   )*(p + 0) | ((int const   )*(p + 1) << 8)));
}
}
#line 44 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
static int sys_PackRegisters___2(void *data , struct Pilot_registers *r ) ;
#line 136 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/syspkt.c"
static int sys_PackRegisters___2(void *data , struct Pilot_registers *r ) 
{ 
  int idx ;
  unsigned char *buffer ;

  {
#line 140
  buffer = (unsigned char *)data;
#line 142
  idx = 0;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (idx < 8)) {
#line 142
      goto while_break;
    }
#line 143
    *((buffer + idx * 4) + 0) = (unsigned char )((int )((unsigned char )(r->D[idx] >> 24)) & 255);
#line 143
    *((buffer + idx * 4) + 1) = (unsigned char )((r->D[idx] >> 16) & 255UL);
#line 143
    *((buffer + idx * 4) + 2) = (unsigned char )((r->D[idx] >> 8) & 255UL);
#line 143
    *((buffer + idx * 4) + 3) = (unsigned char )(r->D[idx] & 255UL);
#line 142
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  idx = 0;
  {
#line 144
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 144
    if (! (idx < 7)) {
#line 144
      goto while_break___0;
    }
#line 145
    *(((buffer + 32) + idx * 4) + 0) = (unsigned char )((int )((unsigned char )(r->A[idx] >> 24)) & 255);
#line 145
    *(((buffer + 32) + idx * 4) + 1) = (unsigned char )((r->A[idx] >> 16) & 255UL);
#line 145
    *(((buffer + 32) + idx * 4) + 2) = (unsigned char )((r->A[idx] >> 8) & 255UL);
#line 145
    *(((buffer + 32) + idx * 4) + 3) = (unsigned char )(r->A[idx] & 255UL);
#line 144
    idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 146
  *((buffer + 60) + 0) = (unsigned char )((int )((unsigned char )(r->USP >> 24)) & 255);
#line 146
  *((buffer + 60) + 1) = (unsigned char )((r->USP >> 16) & 255UL);
#line 146
  *((buffer + 60) + 2) = (unsigned char )((r->USP >> 8) & 255UL);
#line 146
  *((buffer + 60) + 3) = (unsigned char )(r->USP & 255UL);
#line 147
  *((buffer + 64) + 0) = (unsigned char )((int )((unsigned char )(r->SSP >> 24)) & 255);
#line 147
  *((buffer + 64) + 1) = (unsigned char )((r->SSP >> 16) & 255UL);
#line 147
  *((buffer + 64) + 2) = (unsigned char )((r->SSP >> 8) & 255UL);
#line 147
  *((buffer + 64) + 3) = (unsigned char )(r->SSP & 255UL);
#line 148
  *((buffer + 68) + 0) = (unsigned char )((int )((unsigned char )(r->PC >> 24)) & 255);
#line 148
  *((buffer + 68) + 1) = (unsigned char )((r->PC >> 16) & 255UL);
#line 148
  *((buffer + 68) + 2) = (unsigned char )((r->PC >> 8) & 255UL);
#line 148
  *((buffer + 68) + 3) = (unsigned char )(r->PC & 255UL);
#line 150
  *((buffer + 72) + 0) = (unsigned char )(((int )((unsigned short )r->SR) >> 8) & 255);
#line 150
  *((buffer + 72) + 1) = (unsigned char )((int )((unsigned short )r->SR) & 255);
#line 152
  return (0);
}
}
#line 55 "/home/wheatley/newnew/temp/pilot-link-0.12.5/tests/calendardb-test.c"
static void dump___0(void *buf___3 , int n ) 
{ 
  int ch ;
  int i ;
  int j ;

  {
#line 61
  if ((unsigned long )((void *)0) == (unsigned long )buf___3) {
    {
#line 62
    printf((char const   */* __restrict  */)"Null buf\n");
    }
#line 63
    return;
  }
#line 66
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! (i < n)) {
#line 66
      goto while_break;
    }
    {
#line 67
    printf((char const   */* __restrict  */)"%04x: ", i);
#line 68
    j = 0;
    }
    {
#line 68
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 68
      if (! (j < 16)) {
#line 68
        goto while_break___0;
      }
#line 69
      if (i + j < n) {
        {
#line 70
        printf((char const   */* __restrict  */)"%02x ", (int )*((unsigned char *)buf___3 + (i + j)));
        }
      } else {
        {
#line 73
        printf((char const   */* __restrict  */)"   ");
        }
      }
#line 68
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 75
    printf((char const   */* __restrict  */)"  ");
#line 76
    j = 0;
    }
    {
#line 76
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 76
      if (j < 16) {
#line 76
        if (! (i + j < n)) {
#line 76
          goto while_break___1;
        }
      } else {
#line 76
        goto while_break___1;
      }
#line 77
      ch = (int )*((unsigned char *)buf___3 + (i + j)) & 127;
#line 78
      if (ch < 32) {
        {
#line 79
        putchar('.');
        }
      } else
#line 78
      if (ch >= 127) {
        {
#line 79
        putchar('.');
        }
      } else {
        {
#line 81
        putchar(ch);
        }
      }
#line 76
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 83
    printf((char const   */* __restrict  */)"\n");
#line 66
    i += 16;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 48 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static void pi_inet_device_free___2(pi_device_t *dev ) ;
#line 49
static pi_protocol_t *pi_inet_protocol___2(pi_device_t *dev ) ;
#line 50
static pi_protocol_t *pi_inet_protocol_dup___2(pi_protocol_t *prot ) ;
#line 51
static void pi_inet_protocol_free___2(pi_protocol_t *prot ) ;
#line 52
static int pi_inet_close___2(pi_socket_t *ps ) ;
#line 53
static int pi_inet_connect___2(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
#line 54
static int pi_inet_bind___2(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
#line 55
static int pi_inet_listen___2(pi_socket_t *ps , int backlog ) ;
#line 56
static int pi_inet_accept___2(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) ;
#line 57
static ssize_t pi_inet_read___2(pi_socket_t *ps , pi_buffer_t *msg , size_t len ,
                                int flags ) ;
#line 58
static ssize_t pi_inet_write___2(pi_socket_t *ps , unsigned char const   *msg , size_t len ,
                                 int flags ) ;
#line 59
static int pi_inet_getsockopt___2(pi_socket_t *ps , int level , int option_name ,
                                  void *option_value , size_t *option_len ) ;
#line 60
static int pi_inet_setsockopt___2(pi_socket_t *ps , int level , int option_name ,
                                  void const   *option_value , size_t *option_len ) ;
#line 61
static int pi_inet_flush___2(pi_socket_t *ps , int flags ) ;
#line 100 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static void pi_inet_device_free___2(pi_device_t *dev ) 
{ 


  {
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! ((unsigned long )dev != (unsigned long )((void *)0))) {
      {
#line 103
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c",
             103, "dev != NULL");
      }
    }
#line 103
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if ((unsigned long )dev != (unsigned long )((void *)0)) {
#line 105
    if ((unsigned long )dev->data != (unsigned long )((void *)0)) {
      {
#line 106
      free(dev->data);
      }
    }
    {
#line 107
    free((void *)dev);
    }
  }
#line 109
  return;
}
}
#line 111 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static pi_protocol_t *pi_inet_protocol___2(pi_device_t *dev ) 
{ 
  pi_protocol_t *prot ;
  pi_inet_data_t *data ;
  void *tmp ;

  {
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! ((unsigned long )dev != (unsigned long )((void *)0))) {
      {
#line 117
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c",
             117, "dev != NULL");
      }
    }
#line 117
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  data = (pi_inet_data_t *)dev->data;
#line 121
  tmp = malloc(sizeof(pi_protocol_t ));
#line 121
  prot = (pi_protocol_t *)tmp;
  }
#line 123
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 124
    prot->level = 0;
#line 125
    prot->dup = & pi_inet_protocol_dup___2;
#line 126
    prot->free = & pi_inet_protocol_free___2;
#line 127
    prot->read = & pi_inet_read___2;
#line 128
    prot->write = & pi_inet_write___2;
#line 129
    prot->flush = & pi_inet_flush___2;
#line 130
    prot->getsockopt = & pi_inet_getsockopt___2;
#line 131
    prot->setsockopt = & pi_inet_setsockopt___2;
#line 132
    prot->data = (void *)0;
  }
#line 135
  return (prot);
}
}
#line 138 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static pi_protocol_t *pi_inet_protocol_dup___2(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  void *tmp ;

  {
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 143
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c",
             143, "prot != NULL");
      }
    }
#line 143
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 145
  tmp = malloc(sizeof(pi_protocol_t ));
#line 145
  new_prot = (pi_protocol_t *)tmp;
  }
#line 147
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 148
    new_prot->level = prot->level;
#line 149
    new_prot->dup = prot->dup;
#line 150
    new_prot->free = prot->free;
#line 151
    new_prot->read = prot->read;
#line 152
    new_prot->write = prot->write;
#line 153
    new_prot->flush = prot->flush;
#line 154
    new_prot->getsockopt = prot->getsockopt;
#line 155
    new_prot->setsockopt = prot->setsockopt;
#line 156
    new_prot->data = (void *)0;
  }
#line 159
  return (new_prot);
}
}
#line 162 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static void pi_inet_protocol_free___2(pi_protocol_t *prot ) 
{ 


  {
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 165
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c",
             165, "prot != NULL");
      }
    }
#line 165
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
    {
#line 167
    free((void *)prot);
    }
  }
#line 168
  return;
}
}
#line 170 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_bind___2(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) 
{ 
  int opt ;
  int sd ;
  int err ;
  size_t optlen ;
  struct pi_sockaddr *paddr ;
  struct sockaddr_in serv_addr ;
  char *device ;
  char *port ;
  struct hostent *hostent ;
  struct hostent *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;

  {
  {
#line 177
  paddr = (struct pi_sockaddr *)addr;
#line 179
  device = paddr->pi_device;
#line 179
  port = (char *)((void *)0);
#line 183
  memset((void *)(& serv_addr), 0, sizeof(serv_addr));
#line 184
  serv_addr.sin_family = (sa_family_t )2;
#line 185
  tmp___1 = strlen((char const   *)device);
  }
#line 185
  if (tmp___1 > 1UL) {
    {
#line 185
    tmp___2 = strncmp((char const   *)device, "any", (size_t )3);
    }
#line 185
    if (tmp___2) {
      {
#line 186
      serv_addr.sin_addr.s_addr = inet_addr((char const   *)device);
      }
#line 187
      if (serv_addr.sin_addr.s_addr == 4294967295U) {
        {
#line 188
        tmp = gethostbyname((char const   *)device);
#line 188
        hostent = tmp;
        }
#line 190
        if (! hostent) {
          {
#line 191
          tmp___0 = pi_set_error(ps->sd, -502);
          }
#line 191
          return (tmp___0);
        }
        {
#line 193
        memcpy((void */* __restrict  */)((char *)(& serv_addr.sin_addr.s_addr)), (void const   */* __restrict  */)*(hostent->h_addr_list + 0),
               (size_t )hostent->h_length);
        }
      }
    } else {
      {
#line 197
      serv_addr.sin_addr.s_addr = htonl((in_addr_t )0);
      }
    }
  } else {
    {
#line 197
    serv_addr.sin_addr.s_addr = htonl((in_addr_t )0);
    }
  }
  {
#line 199
  port = strchr((char const   *)device, ':');
  }
#line 199
  if ((unsigned long )port != (unsigned long )((void *)0)) {
    {
#line 200
    port ++;
#line 200
    tmp___3 = atoi((char const   *)port);
#line 200
    serv_addr.sin_port = htons((uint16_t )tmp___3);
    }
  } else {
    {
#line 202
    serv_addr.sin_port = htons((uint16_t )14238);
    }
  }
  {
#line 205
  sd = socket(2, 1, 0);
  }
#line 206
  if (sd < 0) {
    {
#line 207
    pi_log(2, 1, "DEV BIND Inet: Unable to create socket\n");
#line 209
    tmp___4 = pi_set_error(ps->sd, -502);
    }
#line 209
    return (tmp___4);
  }
  {
#line 211
  err = pi_socket_setsd(ps, sd);
  }
#line 211
  if (err < 0) {
#line 212
    return (err);
  }
  {
#line 214
  opt = 1;
#line 215
  optlen = sizeof(opt);
#line 217
  tmp___6 = setsockopt(ps->sd, 1, 2, (void const   *)((void *)(& opt)), (socklen_t )((int )optlen));
  }
#line 217
  if (tmp___6 < 0) {
    {
#line 219
    tmp___5 = pi_set_error(ps->sd, -502);
    }
#line 219
    return (tmp___5);
  }
  {
#line 222
  tmp___8 = bind(ps->sd, (struct sockaddr  const  *)((struct sockaddr *)(& serv_addr)),
                 (socklen_t )sizeof(serv_addr));
  }
#line 222
  if (tmp___8 < 0) {
    {
#line 223
    tmp___7 = pi_set_error(ps->sd, -502);
    }
#line 223
    return (tmp___7);
  }
  {
#line 225
  pi_log(2, 4, "DEV BIND Inet Bound to %s\n", device);
#line 228
  tmp___9 = malloc(addrlen);
#line 228
  ps->raddr = (struct sockaddr *)tmp___9;
#line 229
  memcpy((void */* __restrict  */)ps->raddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 230
  ps->raddrlen = addrlen;
#line 231
  tmp___10 = malloc(addrlen);
#line 231
  ps->laddr = (struct sockaddr *)tmp___10;
#line 232
  memcpy((void */* __restrict  */)ps->laddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 233
  ps->laddrlen = addrlen;
  }
#line 235
  return (0);
}
}
#line 238 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_connect___2(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) 
{ 
  int sd ;
  int err ;
  struct pi_sockaddr *paddr ;
  struct sockaddr_in serv_addr ;
  char *device ;
  struct hostent *hostent ;
  struct hostent *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 244
  paddr = (struct pi_sockaddr *)addr;
#line 246
  device = paddr->pi_device;
#line 249
  memset((void *)(& serv_addr), 0, sizeof(serv_addr));
#line 250
  serv_addr.sin_family = (sa_family_t )2;
#line 251
  tmp___1 = strlen((char const   *)device);
  }
#line 251
  if (tmp___1 > 1UL) {
    {
#line 252
    serv_addr.sin_addr.s_addr = inet_addr((char const   *)device);
    }
#line 253
    if (serv_addr.sin_addr.s_addr == 4294967295U) {
      {
#line 254
      tmp = gethostbyname((char const   *)device);
#line 254
      hostent = tmp;
      }
#line 256
      if (! hostent) {
        {
#line 257
        pi_log(2, 1, "DEV CONNECT Inet: Unable to determine host\n");
#line 260
        tmp___0 = pi_set_error(ps->sd, -502);
        }
#line 260
        return (tmp___0);
      }
      {
#line 263
      memcpy((void */* __restrict  */)((char *)(& serv_addr.sin_addr.s_addr)), (void const   */* __restrict  */)*(hostent->h_addr_list + 0),
             (size_t )hostent->h_length);
      }
    }
  } else {
    {
#line 267
    serv_addr.sin_addr.s_addr = htonl((in_addr_t )0);
    }
  }
  {
#line 269
  serv_addr.sin_port = htons((uint16_t )14238);
#line 271
  sd = socket(2, 1, 0);
  }
#line 273
  if (sd < 0) {
    {
#line 274
    pi_log(2, 1, "DEV CONNECT Inet: Unable to create socket\n");
#line 276
    tmp___2 = pi_set_error(ps->sd, -502);
    }
#line 276
    return (tmp___2);
  }
  {
#line 279
  err = pi_socket_setsd(ps, sd);
  }
#line 279
  if (err < 0) {
#line 280
    return (err);
  }
  {
#line 282
  tmp___4 = connect(ps->sd, (struct sockaddr  const  *)((struct sockaddr *)(& serv_addr)),
                    (socklen_t )sizeof(serv_addr));
  }
#line 282
  if (tmp___4 < 0) {
    {
#line 284
    pi_log(2, 1, "DEV CONNECT Inet: Unable to connect\n");
#line 286
    tmp___3 = pi_set_error(ps->sd, -502);
    }
#line 286
    return (tmp___3);
  }
  {
#line 289
  tmp___5 = malloc(addrlen);
#line 289
  ps->raddr = (struct sockaddr *)tmp___5;
#line 290
  memcpy((void */* __restrict  */)ps->raddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 291
  ps->raddrlen = addrlen;
#line 292
  tmp___6 = malloc(addrlen);
#line 292
  ps->laddr = (struct sockaddr *)tmp___6;
#line 293
  memcpy((void */* __restrict  */)ps->laddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 294
  ps->laddrlen = addrlen;
  }
  {
#line 297
  if (ps->cmd == 1) {
#line 297
    goto case_1;
  }
#line 301
  if (ps->cmd == 2) {
#line 301
    goto case_2;
  }
#line 296
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 298
  err = cmp_tx_handshake(ps);
  }
#line 298
  if (err < 0) {
#line 299
    goto fail;
  }
#line 300
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 302
  err = net_tx_handshake(ps);
  }
#line 302
  if (err < 0) {
#line 303
    goto fail;
  }
#line 304
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 306
  ps->state = 4;
#line 307
  ps->command = 0;
#line 309
  pi_log(2, 4, "DEV CONNECT Inet: Connected\n");
  }
#line 310
  return (0);
  fail: 
#line 313
  return (err);
}
}
#line 316 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_listen___2(pi_socket_t *ps , int backlog ) 
{ 
  int result ;

  {
  {
#line 321
  result = listen(ps->sd, backlog);
  }
#line 322
  if (result == 0) {
#line 323
    ps->state = 1;
  }
#line 325
  return (result);
}
}
#line 328 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_accept___2(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) 
{ 
  int sd ;
  int err ;
  int split ;
  int chunksize ;
  size_t len ;
  size_t size ;
  socklen_t l ;
  unsigned char cmp_flags ;
  int use_long_format ;

  {
#line 331
  split = 0;
#line 331
  chunksize = 0;
#line 337
  l = (socklen_t )0;
#line 340
  if (addrlen) {
#line 341
    l = (socklen_t )*addrlen;
  }
  {
#line 342
  sd = accept(ps->sd, (struct sockaddr */* __restrict  */)addr, (socklen_t */* __restrict  */)(& l));
  }
#line 343
  if (addrlen) {
#line 344
    *addrlen = (size_t )l;
  }
#line 345
  if (sd < 0) {
    {
#line 346
    pi_set_error(ps->sd, sd);
#line 347
    err = -502;
    }
#line 348
    goto fail;
  }
  {
#line 351
  pi_socket_setsd(ps, sd);
#line 352
  pi_socket_init(ps);
  }
  {
#line 355
  if (ps->cmd == 1) {
#line 355
    goto case_1;
  }
#line 374
  if (ps->cmd == 2) {
#line 374
    goto case_2;
  }
#line 354
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 356
  err = cmp_rx_handshake(ps, 57600, 0);
  }
#line 356
  if (err < 0) {
#line 357
    goto fail;
  }
  {
#line 360
  size = sizeof(cmp_flags);
#line 361
  pi_getsockopt(ps->sd, 5, 1, (void *)(& cmp_flags), & size);
  }
#line 362
  if ((int )cmp_flags & 16) {
    {
#line 363
    use_long_format = 1;
#line 364
    size = sizeof(int );
#line 365
    pi_setsockopt(ps->sd, 2, 3, (void const   *)(& use_long_format), & size);
#line 367
    ps->command ^= 1;
#line 368
    pi_setsockopt(ps->sd, 2, 3, (void const   *)(& use_long_format), & size);
#line 370
    ps->command ^= 1;
    }
  }
#line 373
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 378
  len = sizeof(split);
#line 379
  pi_setsockopt(ps->sd, 3, 1, (void const   *)(& split), & len);
#line 381
  len = sizeof(chunksize);
#line 382
  pi_setsockopt(ps->sd, 3, 2, (void const   *)(& chunksize), & len);
#line 385
  ps->command ^= 1;
#line 386
  len = sizeof(split);
#line 387
  pi_setsockopt(ps->sd, 3, 1, (void const   *)(& split), & len);
#line 389
  len = sizeof(chunksize);
#line 390
  pi_setsockopt(ps->sd, 3, 2, (void const   *)(& chunksize), & len);
#line 392
  ps->command ^= 1;
#line 394
  err = net_rx_handshake(ps);
  }
#line 394
  if (err < 0) {
#line 395
    goto fail;
  }
#line 396
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 399
  ps->state = 2;
#line 400
  ps->command = 0;
#line 401
  ps->dlprecord = 0;
#line 403
  pi_log(2, 4, "DEV INET ACCEPT accepted\n");
  }
#line 405
  return (ps->sd);
  fail: 
#line 408
  return (err);
}
}
#line 411 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_close___2(pi_socket_t *ps ) 
{ 


  {
#line 414
  if (ps->sd) {
    {
#line 415
    close(ps->sd);
#line 416
    ps->sd = 0;
    }
  }
#line 418
  if (ps->laddr) {
    {
#line 419
    free((void *)ps->laddr);
#line 420
    ps->laddr = (struct sockaddr *)((void *)0);
    }
  }
#line 422
  if (ps->raddr) {
    {
#line 423
    free((void *)ps->raddr);
#line 424
    ps->raddr = (struct sockaddr *)((void *)0);
    }
  }
#line 426
  return (0);
}
}
#line 429 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_flush___2(pi_socket_t *ps , int flags ) 
{ 
  char buf___3[256] ;
  int fl ;
  ssize_t tmp ;

  {
#line 435
  if (flags & 1) {
    {
#line 436
    fl = fcntl(ps->sd, 3, 0);
    }
#line 436
    if (fl != -1) {
      {
#line 437
      fcntl(ps->sd, 4, fl | 2048);
      }
      {
#line 438
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 438
        tmp = recv(ps->sd, (void *)(buf___3), sizeof(buf___3), 0);
        }
#line 438
        if (! (tmp > 0L)) {
#line 438
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 440
      fcntl(ps->sd, 4, fl);
      }
    }
  }
#line 443
  return (0);
}
}
#line 446 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static ssize_t pi_inet_write___2(pi_socket_t *ps , unsigned char const   *msg , size_t len ,
                                 int flags ) 
{ 
  int total ;
  int nwrote ;
  pi_inet_data_t *data ;
  struct timeval t ;
  fd_set ready ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;

  {
#line 451
  data = (pi_inet_data_t *)(ps->device)->data;
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 455
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 455
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 458
  total = (int )len;
  {
#line 459
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 459
    if (! (total > 0)) {
#line 459
      goto while_break___0;
    }
#line 460
    if (data->timeout == 0) {
      {
#line 461
      tmp = select(ps->sd + 1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)(& ready),
                   (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
      }
#line 461
      if (tmp < 0) {
        {
#line 461
        tmp___0 = __errno_location();
        }
#line 461
        if (*tmp___0 == 4) {
#line 463
          goto while_continue___0;
        }
      }
    } else {
      {
#line 465
      t.tv_sec = (__time_t )(data->timeout / 1000);
#line 466
      t.tv_usec = (__suseconds_t )((data->timeout % 1000) * 1000);
#line 467
      tmp___2 = select(ps->sd + 1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)(& ready),
                       (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
      }
#line 467
      if (tmp___2 == 0) {
        {
#line 468
        tmp___1 = pi_set_error(ps->sd, -202);
        }
#line 468
        return ((ssize_t )tmp___1);
      }
    }
#line 470
    if (! ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
      {
#line 471
      ps->state = 8;
#line 472
      tmp___3 = pi_set_error(ps->sd, -200);
      }
#line 472
      return ((ssize_t )tmp___3);
    }
    {
#line 475
    tmp___4 = write(ps->sd, (void const   *)msg, len);
#line 475
    nwrote = (int )tmp___4;
    }
#line 476
    if (nwrote < 0) {
      {
#line 478
      tmp___6 = __errno_location();
      }
#line 478
      if (*tmp___6 == 32) {
        {
#line 479
        ps->state = 8;
#line 480
        tmp___5 = pi_set_error(ps->sd, -200);
        }
#line 480
        return ((ssize_t )tmp___5);
      } else {
        {
#line 478
        tmp___7 = __errno_location();
        }
#line 478
        if (*tmp___7 == 9) {
          {
#line 479
          ps->state = 8;
#line 480
          tmp___5 = pi_set_error(ps->sd, -200);
          }
#line 480
          return ((ssize_t )tmp___5);
        }
      }
      {
#line 482
      tmp___8 = pi_set_error(ps->sd, -204);
      }
#line 482
      return ((ssize_t )tmp___8);
    }
#line 485
    total -= nwrote;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 487
  data->tx_bytes = (int )((size_t )data->tx_bytes + len);
#line 489
  pi_log(2, 4, "DEV TX Inet Bytes: %d\n", len);
  }
#line 491
  return ((ssize_t )len);
}
}
#line 494 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static ssize_t pi_inet_read___2(pi_socket_t *ps , pi_buffer_t *msg , size_t len ,
                                int flags ) 
{ 
  int r ;
  int fl ;
  pi_inet_data_t *data ;
  fd_set ready ;
  struct timeval t ;
  int *tmp ;
  int tmp___0 ;
  pi_buffer_t *tmp___1 ;
  int __d0 ;
  int __d1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 497
  fl = 0;
#line 499
  data = (pi_inet_data_t *)(ps->device)->data;
#line 503
  tmp___1 = pi_buffer_expect(msg, len);
  }
#line 503
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 504
    tmp = __errno_location();
#line 504
    *tmp = 12;
#line 505
    tmp___0 = pi_set_error(ps->sd, -500);
    }
#line 505
    return ((ssize_t )tmp___0);
  }
#line 508
  if (flags == 1) {
#line 509
    fl = 2;
  }
  {
#line 511
  while (1) {
    while_continue: /* CIL Label */ ;
#line 511
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 511
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 512
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 516
  if (data->timeout == 0) {
    {
#line 517
    select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
           (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
    }
  } else {
    {
#line 519
    t.tv_sec = (__time_t )(data->timeout / 1000);
#line 520
    t.tv_usec = (__suseconds_t )((data->timeout % 1000) * 1000);
#line 521
    tmp___3 = select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
                     (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
    }
#line 521
    if (tmp___3 == 0) {
      {
#line 522
      tmp___2 = pi_set_error(ps->sd, -202);
      }
#line 522
      return ((ssize_t )tmp___2);
    }
  }
#line 526
  if ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
    {
#line 527
    tmp___4 = recv(ps->sd, (void *)(msg->data + msg->used), len, fl);
#line 527
    r = (int )tmp___4;
    }
#line 528
    if (r < 0) {
      {
#line 529
      tmp___6 = __errno_location();
      }
#line 529
      if (*tmp___6 == 32) {
        {
#line 530
        ps->state = 8;
#line 531
        tmp___5 = pi_set_error(ps->sd, -200);
        }
#line 531
        return ((ssize_t )tmp___5);
      } else {
        {
#line 529
        tmp___7 = __errno_location();
        }
#line 529
        if (*tmp___7 == 9) {
          {
#line 530
          ps->state = 8;
#line 531
          tmp___5 = pi_set_error(ps->sd, -200);
          }
#line 531
          return ((ssize_t )tmp___5);
        }
      }
      {
#line 533
      tmp___8 = pi_set_error(ps->sd, -204);
      }
#line 533
      return ((ssize_t )tmp___8);
    }
    {
#line 536
    data->rx_bytes += r;
#line 537
    msg->used += (size_t )r;
#line 539
    pi_log(2, 4, "DEV RX Inet Bytes: %d\n", r);
    }
#line 540
    return ((ssize_t )r);
  }
  {
#line 544
  pi_log(2, 2, "DEV RX Inet timeout\n");
#line 545
  (data->rx_errors) ++;
  }
#line 546
  return ((ssize_t )0);
}
}
#line 549 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_getsockopt___2(pi_socket_t *ps , int level , int option_name ,
                                  void *option_value , size_t *option_len ) 
{ 
  pi_inet_data_t *data ;
  int *tmp ;
  int tmp___0 ;

  {
#line 553
  data = (pi_inet_data_t *)(ps->device)->data;
  {
#line 556
  if (option_name == 3) {
#line 556
    goto case_3;
  }
#line 555
  goto switch_break;
  case_3: /* CIL Label */ 
#line 557
  if (*option_len != sizeof(data->timeout)) {
    {
#line 558
    tmp = __errno_location();
#line 558
    *tmp = 22;
#line 559
    tmp___0 = pi_set_error(ps->sd, -501);
    }
#line 559
    return (tmp___0);
  }
  {
#line 561
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->timeout),
         sizeof(data->timeout));
#line 563
  *option_len = sizeof(data->timeout);
  }
#line 564
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 567
  return (0);
}
}
#line 570 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/inet.c"
static int pi_inet_setsockopt___2(pi_socket_t *ps , int level , int option_name ,
                                  void const   *option_value , size_t *option_len ) 
{ 
  pi_inet_data_t *data ;
  int *tmp ;
  int tmp___0 ;

  {
#line 574
  data = (pi_inet_data_t *)(ps->device)->data;
  {
#line 577
  if (option_name == 3) {
#line 577
    goto case_3;
  }
#line 576
  goto switch_break;
  case_3: /* CIL Label */ 
#line 578
  if (*option_len != sizeof(data->timeout)) {
    {
#line 579
    tmp = __errno_location();
#line 579
    *tmp = 22;
#line 580
    tmp___0 = pi_set_error(ps->sd, -501);
    }
#line 580
    return (tmp___0);
  }
  {
#line 582
  memcpy((void */* __restrict  */)(& data->timeout), (void const   */* __restrict  */)option_value,
         sizeof(data->timeout));
  }
#line 584
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 587
  return (0);
}
}
#line 63 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
static void record_dump___2(unsigned long recID , unsigned int recIndex , int flags ,
                            int catID , char const   *data , int data_len ) ;
#line 141 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
static int dlp_version_major___2  =    1;
#line 142 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
static int dlp_version_minor___2  =    4;
#line 160 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
static void record_dump___2(unsigned long recID , unsigned int recIndex , int flags ,
                            int catID , char const   *data , int data_len ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 163
  if (! flags) {
#line 163
    tmp = " None";
  } else {
#line 163
    tmp = "";
  }
#line 163
  if (flags & 8) {
#line 163
    tmp___0 = " Archive";
  } else {
#line 163
    tmp___0 = "";
  }
#line 163
  if (flags & 16) {
#line 163
    tmp___1 = " Secret";
  } else {
#line 163
    tmp___1 = "";
  }
#line 163
  if (flags & 32) {
#line 163
    tmp___2 = " Busy";
  } else {
#line 163
    tmp___2 = "";
  }
#line 163
  if (flags & 64) {
#line 163
    tmp___3 = " Dirty";
  } else {
#line 163
    tmp___3 = "";
  }
#line 163
  if (flags & 128) {
#line 163
    tmp___4 = " Deleted";
  } else {
#line 163
    tmp___4 = "";
  }
  {
#line 163
  pi_log(16, 4, "  ID: 0x%8.8lX, Index: %u, Category: %d\n  Flags:%s%s%s%s%s%s (0x%2.2X), and %d bytes:\n",
         recID, recIndex, catID, tmp___4, tmp___3, tmp___2, tmp___1, tmp___0, tmp,
         flags, data_len);
#line 176
  pi_dumpdata(data, (size_t )data_len);
  }
#line 177
  return;
}
}
#line 1207 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/dlp.c"
static void dlp_decode_finddb_response___2(struct dlpResponse *res , int *cardno ,
                                           unsigned long *localid , int *dbhandle ,
                                           struct DBInfo *info , struct DBSizeInfo *size ) 
{ 
  int arg ;
  int argid ;
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
#line 1212
  arg = 0;
  {
#line 1212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1212
    if (! (arg < res->argc)) {
#line 1212
      goto while_break;
    }
#line 1213
    argid = ((*(res->argv + arg))->id_ & 127) - 32;
#line 1214
    if (argid == 0) {
#line 1215
      if (cardno) {
#line 1216
        *cardno = (int )*((unsigned char *)((*(res->argv + arg))->data + 0) + 0);
      }
#line 1217
      if (localid) {
#line 1218
        *localid = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 2) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 2) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 2) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 2) + 3);
      }
#line 1219
      if (dbhandle) {
#line 1220
        *dbhandle = (int )(((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 6) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 6) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 6) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 6) + 3));
      }
#line 1222
      if (info) {
        {
#line 1223
        info->more = 0;
#line 1224
        info->miscFlags = (unsigned int )*((unsigned char *)((*(res->argv + arg))->data + 11) + 0);
#line 1226
        info->flags = (unsigned int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + arg))->data + 12) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + arg))->data + 12) + 1)));
#line 1228
        info->type = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 14) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 14) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 14) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 14) + 3);
#line 1230
        info->creator = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 18) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 18) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 18) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 18) + 3);
#line 1232
        info->version = (unsigned int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + arg))->data + 22) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + arg))->data + 22) + 1)));
#line 1234
        info->modnum = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 24) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 24) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 24) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 24) + 3);
#line 1236
        info->createDate = dlp_ptohdate((unsigned char const   *)((*(res->argv + arg))->data + 28));
#line 1238
        info->modifyDate = dlp_ptohdate((unsigned char const   *)((*(res->argv + arg))->data + 36));
#line 1240
        info->backupDate = dlp_ptohdate((unsigned char const   *)((*(res->argv + arg))->data + 44));
#line 1242
        info->index = (unsigned int )((unsigned short )(((int )*((unsigned char *)((*(res->argv + arg))->data + 52) + 0) << 8) | (int )*((unsigned char *)((*(res->argv + arg))->data + 52) + 1)));
#line 1245
        strncpy((char */* __restrict  */)(info->name), (char const   */* __restrict  */)((*(res->argv + arg))->data + 54),
                (size_t )32);
#line 1246
        info->name[32] = (char )'\000';
        }
#line 1248
        if (info->more) {
#line 1248
          tmp = "Yes";
        } else {
#line 1248
          tmp = "No";
        }
        {
#line 1248
        pi_log(16, 4, "DLP FindDB Name: \'%s\', Version: %d, More: %s\n", info->name,
               info->version, tmp);
#line 1253
        tmp___0 = printlong(info->creator);
#line 1253
        pi_log(16, 4, "  Creator: \'%s\'", tmp___0);
        }
#line 1255
        if (! info->flags) {
#line 1255
          tmp___1 = "None";
        } else {
#line 1255
          tmp___1 = "";
        }
#line 1255
        if (info->flags & 32768U) {
#line 1255
          tmp___2 = "Open ";
        } else {
#line 1255
          tmp___2 = "";
        }
#line 1255
        if (info->flags & 128U) {
#line 1255
          tmp___3 = "Stream ";
        } else {
#line 1255
          tmp___3 = "";
        }
#line 1255
        if (info->flags & 64U) {
#line 1255
          tmp___4 = "CopyPrevention ";
        } else {
#line 1255
          tmp___4 = "";
        }
#line 1255
        if (info->flags & 16U) {
#line 1255
          tmp___5 = "Newer ";
        } else {
#line 1255
          tmp___5 = "";
        }
#line 1255
        if (info->flags & 32U) {
#line 1255
          tmp___6 = "Reset ";
        } else {
#line 1255
          tmp___6 = "";
        }
#line 1255
        if (info->flags & 8U) {
#line 1255
          tmp___7 = "Backup ";
        } else {
#line 1255
          tmp___7 = "";
        }
#line 1255
        if (info->flags & 4U) {
#line 1255
          tmp___8 = "AppInfoDirty ";
        } else {
#line 1255
          tmp___8 = "";
        }
#line 1255
        if (info->flags & 2U) {
#line 1255
          tmp___9 = "ReadOnly ";
        } else {
#line 1255
          tmp___9 = "";
        }
#line 1255
        if (info->flags & 1U) {
#line 1255
          tmp___10 = "Resource ";
        } else {
#line 1255
          tmp___10 = "";
        }
        {
#line 1255
        tmp___11 = printlong(info->type);
#line 1255
        pi_log(16, 4, " Type: \'%s\' Flags: %s%s%s%s%s%s%s%s%s%s", tmp___11, tmp___10,
               tmp___9, tmp___8, tmp___7, tmp___6, tmp___5, tmp___4, tmp___3, tmp___2,
               tmp___1);
#line 1277
        pi_log(16, 4, " (0x%2.2X)\n", info->flags);
#line 1279
        tmp___12 = ctime((time_t const   *)(& info->createDate));
#line 1279
        pi_log(16, 4, "  Modnum: %ld, Index: %d, Creation date: %s", info->modnum,
               info->index, tmp___12);
#line 1284
        tmp___13 = ctime((time_t const   *)(& info->modifyDate));
#line 1284
        pi_log(16, 4, " Modification date: %s", tmp___13);
#line 1287
        tmp___14 = ctime((time_t const   *)(& info->backupDate));
#line 1287
        pi_log(16, 4, " Backup date: %s", tmp___14);
        }
      }
    } else
#line 1292
    if (argid == 1) {
#line 1293
      if (size) {
#line 1294
        size->numRecords = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 0) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 0) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 0) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 0) + 3);
#line 1296
        size->totalBytes = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 4) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 4) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 4) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 4) + 3);
#line 1298
        size->dataBytes = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 8) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 8) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 8) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 8) + 3);
#line 1300
        size->appBlockSize = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 12) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 12) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 12) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 12) + 3);
#line 1302
        size->sortBlockSize = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 16) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 16) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 16) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 16) + 3);
#line 1304
        size->maxRecSize = ((((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 20) + 0) << 24) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 20) + 1) << 16)) | ((unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 20) + 2) << 8)) | (unsigned long )*((unsigned char *)((*(res->argv + arg))->data + 20) + 3);
      }
    }
#line 1212
    arg ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1309
  return;
}
}
#line 57 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_connect___2(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
#line 59
static int pi_serial_bind___2(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) ;
#line 61
static int pi_serial_listen___2(pi_socket_t *ps , int backlog ) ;
#line 62
static int pi_serial_accept___2(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) ;
#line 64
static int pi_serial_getsockopt___2(pi_socket_t *ps , int level , int option_name ,
                                    void *option_value , size_t *option_len ) ;
#line 67
static int pi_serial_setsockopt___2(pi_socket_t *ps , int level , int option_name ,
                                    void const   *option_value , size_t *option_len ) ;
#line 70
static int pi_serial_close___2(pi_socket_t *ps ) ;
#line 87 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static pi_protocol_t *pi_serial_protocol_dup___2(pi_protocol_t *prot ) 
{ 
  pi_protocol_t *new_prot ;
  void *tmp ;

  {
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 92
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c",
             92, "prot != NULL");
      }
    }
#line 92
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 94
  tmp = malloc(sizeof(pi_protocol_t ));
#line 94
  new_prot = (pi_protocol_t *)tmp;
  }
#line 96
  if ((unsigned long )new_prot != (unsigned long )((void *)0)) {
#line 97
    new_prot->level = prot->level;
#line 98
    new_prot->dup = prot->dup;
#line 99
    new_prot->free = prot->free;
#line 100
    new_prot->read = prot->read;
#line 101
    new_prot->write = prot->write;
#line 102
    new_prot->flush = prot->flush;
#line 103
    new_prot->getsockopt = prot->getsockopt;
#line 104
    new_prot->setsockopt = prot->setsockopt;
#line 105
    new_prot->data = (void *)0;
  }
#line 108
  return (new_prot);
}
}
#line 123 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static void pi_serial_protocol_free___2(pi_protocol_t *prot ) 
{ 


  {
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! ((unsigned long )prot != (unsigned long )((void *)0))) {
      {
#line 126
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c",
             126, "prot != NULL");
      }
    }
#line 126
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
    {
#line 129
    free((void *)prot);
    }
  }
#line 130
  return;
}
}
#line 144 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static pi_protocol_t *pi_serial_protocol___2(pi_device_t *dev ) 
{ 
  pi_protocol_t *prot ;
  struct pi_serial_data *data ;
  void *tmp ;

  {
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! ((unsigned long )dev != (unsigned long )((void *)0))) {
      {
#line 150
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c",
             150, "dev != NULL");
      }
    }
#line 150
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 152
  tmp = malloc(sizeof(pi_protocol_t ));
#line 152
  prot = (pi_protocol_t *)tmp;
#line 154
  data = (struct pi_serial_data *)dev->data;
  }
#line 156
  if ((unsigned long )prot != (unsigned long )((void *)0)) {
#line 157
    prot->level = 0;
#line 158
    prot->dup = & pi_serial_protocol_dup___2;
#line 159
    prot->free = & pi_serial_protocol_free___2;
#line 160
    prot->read = data->impl.read;
#line 161
    prot->write = data->impl.write;
#line 162
    prot->flush = data->impl.flush;
#line 163
    prot->getsockopt = & pi_serial_getsockopt___2;
#line 164
    prot->setsockopt = & pi_serial_setsockopt___2;
#line 165
    prot->data = (void *)0;
  }
#line 168
  return (prot);
}
}
#line 184 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static void pi_serial_device_free___2(pi_device_t *dev ) 
{ 


  {
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )dev != (unsigned long )((void *)0))) {
      {
#line 187
      pi_log(1024, 0, "file %s: line %d: assertion failed: (%s)", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c",
             187, "dev != NULL");
      }
    }
#line 187
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 189
  free(dev->data);
#line 190
  free((void *)dev);
  }
#line 191
  return;
}
}
#line 265 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_connect___2(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) 
{ 
  struct pi_serial_data *data ;
  struct pi_sockaddr *pa ;
  int err ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  int tmp___3 ;

  {
#line 269
  data = (struct pi_serial_data *)(ps->device)->data;
#line 271
  pa = (struct pi_sockaddr *)addr;
#line 274
  if (ps->type == 16) {
#line 275
    if (ps->protocol == 3) {
#line 276
      tmp = 57600;
#line 276
      data->rate = tmp;
#line 276
      data->establishrate = tmp;
    } else {
#line 278
      if (data->establishrate == -1) {
        {
#line 279
        get_pilot_rate(& data->establishrate, & data->establishhighrate);
        }
      }
#line 282
      data->rate = 9600;
    }
  } else
#line 284
  if (ps->type == 48) {
#line 286
    tmp___0 = 57600;
#line 286
    data->rate = tmp___0;
#line 286
    data->establishrate = tmp___0;
  }
  {
#line 289
  err = (*(data->impl.open))(ps, pa, addrlen);
  }
#line 289
  if (err < 0) {
#line 290
    return (err);
  }
  {
#line 292
  tmp___1 = malloc(addrlen);
#line 292
  ps->raddr = (struct sockaddr *)tmp___1;
#line 293
  memcpy((void */* __restrict  */)ps->raddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 294
  ps->raddrlen = addrlen;
#line 295
  tmp___2 = malloc(addrlen);
#line 295
  ps->laddr = (struct sockaddr *)tmp___2;
#line 296
  memcpy((void */* __restrict  */)ps->laddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 297
  ps->laddrlen = addrlen;
  }
#line 299
  if (ps->type == 16) {
    {
#line 302
    if (ps->cmd == 1) {
#line 302
      goto case_1;
    }
#line 314
    if (ps->cmd == 2) {
#line 314
      goto case_2;
    }
#line 319
    if (ps->cmd == 3) {
#line 319
      goto case_3;
    }
#line 301
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 303
    tmp___3 = cmp_tx_handshake(ps);
    }
#line 303
    if (tmp___3 < 0) {
#line 304
      goto fail;
    }
    {
#line 306
    size = sizeof(data->rate);
#line 307
    pi_getsockopt(ps->sd, 5, 3, (void *)(& data->rate), & size);
#line 310
    err = (*(data->impl.changebaud))(ps);
    }
#line 310
    if (err < 0) {
#line 311
      goto fail;
    }
#line 312
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 315
    err = (*(data->impl.changebaud))(ps);
    }
#line 315
    if (err < 0) {
#line 316
      goto fail;
    }
#line 317
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 320
    err = (*(data->impl.changebaud))(ps);
    }
#line 320
    if (err < 0) {
#line 321
      goto fail;
    }
#line 322
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 325
  ps->state = 4;
#line 326
  ps->command = 0;
#line 327
  return (0);
  fail: 
#line 330
  return (err);
}
}
#line 345 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_bind___2(pi_socket_t *ps , struct sockaddr *addr , size_t addrlen ) 
{ 
  struct pi_serial_data *data ;
  struct pi_sockaddr *pa ;
  int err ;
  int count ;
  int tmp ;
  int save_errno ;
  int *tmp___0 ;
  char realport[4096] ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
#line 348
  data = (struct pi_serial_data *)(ps->device)->data;
#line 350
  pa = (struct pi_sockaddr *)addr;
#line 351
  count = 0;
#line 353
  if (ps->type == 16) {
#line 354
    if (data->establishrate == -1) {
      {
#line 355
      get_pilot_rate(& data->establishrate, & data->establishhighrate);
      }
    }
#line 358
    data->rate = 9600;
  } else
#line 359
  if (ps->type == 48) {
#line 361
    tmp = 57600;
#line 361
    data->rate = tmp;
#line 361
    data->establishrate = tmp;
  }
  begin: 
  {
#line 365
  err = (*(data->impl.open))(ps, pa, addrlen);
  }
#line 365
  if (err < 0) {
    {
#line 366
    tmp___0 = __errno_location();
#line 366
    save_errno = *tmp___0;
#line 377
    realpath((char const   */* __restrict  */)(pa->pi_device), (char */* __restrict  */)(realport));
#line 378
    tmp___1 = __errno_location();
#line 378
    *tmp___1 = save_errno;
#line 380
    tmp___7 = __errno_location();
    }
#line 380
    if (*tmp___7 == 2) {
      {
#line 381
      pi_log(2, 1, " The device %s does not exist..\n", pa->pi_device);
#line 384
      pi_log(2, 1, " Possible solution:\n\n\tmknod %s c <major> <minor>\n\n", pa->pi_device);
      }
    } else {
      {
#line 387
      tmp___6 = __errno_location();
      }
#line 387
      if (*tmp___6 == 13) {
        {
#line 388
        pi_log(2, 1, "   Please check the permissions on %s..\n", realport);
#line 391
        pi_log(2, 1, " Possible solution:\n\n\tchmod 0666 %s\n\n", realport);
        }
      } else {
        {
#line 394
        tmp___5 = __errno_location();
        }
#line 394
        if (*tmp___5 == 19) {
          {
#line 395
          while (1) {
            while_continue: /* CIL Label */ ;
#line 395
            if (! (count <= 5)) {
#line 395
              goto while_break;
            }
            {
#line 396
            tmp___2 = fileno(stdout);
#line 396
            tmp___3 = isatty(tmp___2);
            }
#line 396
            if (tmp___3) {
              {
#line 397
              pi_log(2, 1, "\r   Port not connected, sleeping for 2 seconds, ");
#line 400
              pi_log(2, 1, "%d retries..", 5 - count);
              }
            }
            {
#line 404
            sleep(2U);
#line 405
            count ++;
            }
#line 406
            goto begin;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 408
          pi_log(2, 1, "\n\n   Device not found on %s, \t\t\t\t\tDid you hit HotSync?\n\n",
                 realport);
          }
        } else {
          {
#line 411
          tmp___4 = __errno_location();
          }
#line 411
          if (*tmp___4 == 21) {
            {
#line 412
            pi_log(2, 1, " The port specified must contain a device name, and %s was a directory.\n   Please change that to reference a real device, and try again\n\n",
                   pa->pi_device);
            }
          }
        }
      }
    }
#line 420
    return (err);
  }
  {
#line 422
  tmp___8 = malloc(addrlen);
#line 422
  ps->raddr = (struct sockaddr *)tmp___8;
#line 423
  memcpy((void */* __restrict  */)ps->raddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 424
  ps->raddrlen = addrlen;
#line 425
  tmp___9 = malloc(addrlen);
#line 425
  ps->laddr = (struct sockaddr *)tmp___9;
#line 426
  memcpy((void */* __restrict  */)ps->laddr, (void const   */* __restrict  */)addr,
         addrlen);
#line 427
  ps->laddrlen = addrlen;
  }
#line 429
  return (0);
}
}
#line 443 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_listen___2(pi_socket_t *ps , int backlog ) 
{ 
  int result ;
  struct pi_serial_data *data ;

  {
  {
#line 446
  data = (struct pi_serial_data *)(ps->device)->data;
#line 450
  result = (*(data->impl.changebaud))(ps);
  }
#line 451
  if (result == 0) {
#line 452
    ps->state = 1;
  }
#line 454
  return (result);
}
}
#line 468 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_accept___2(pi_socket_t *ps , struct sockaddr *addr , size_t *addrlen ) 
{ 
  struct pi_serial_data *data ;
  size_t size ;
  int err ;
  int result ;
  int tmp ;
  char buf___3[6] ;
  struct timeval tv ;
  unsigned char cmp_flags ;
  int use_long_format ;

  {
#line 472
  data = (struct pi_serial_data *)(ps->device)->data;
#line 479
  if (ps->accept_to) {
    {
#line 481
    tmp = (*(data->impl.poll))(ps, 1000);
#line 481
    result = tmp;
#line 482
    pi_log(2, 8, "%s: %d, poll result: %d.\n", "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c",
           482, result);
    }
#line 484
    if (result < 0) {
      {
#line 485
      buf___3[0] = (char)1;
#line 485
      buf___3[1] = (char)0;
#line 485
      buf___3[2] = (char)0;
#line 485
      buf___3[3] = (char)0;
#line 485
      buf___3[4] = (char)0;
#line 485
      buf___3[5] = (char)0;
#line 486
      (*(data->impl.write))(ps, (unsigned char const   *)(buf___3), sizeof(buf___3),
                            1000);
      }
    }
  }
  {
#line 490
  err = (*(data->impl.poll))(ps, ps->accept_to * 1000);
  }
#line 490
  if (err < 0) {
#line 491
    goto fail;
  }
  {
#line 493
  data->timeout = ps->accept_to * 1000;
#line 495
  pi_socket_init(ps);
  }
#line 496
  if (ps->type == 16) {
    {
#line 501
    if (ps->cmd == 1) {
#line 501
      goto case_1;
    }
#line 531
    if (ps->cmd == 2) {
#line 531
      goto case_2;
    }
#line 500
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 502
    err = cmp_rx_handshake(ps, data->establishrate, data->establishhighrate);
    }
#line 502
    if (err < 0) {
#line 503
      goto fail;
    }
    {
#line 506
    size = sizeof(cmp_flags);
#line 507
    pi_getsockopt(ps->sd, 5, 1, (void *)(& cmp_flags), & size);
    }
#line 508
    if ((int )cmp_flags & 16) {
      {
#line 509
      use_long_format = 1;
#line 510
      size = sizeof(int );
#line 511
      pi_setsockopt(ps->sd, 2, 3, (void const   *)(& use_long_format), & size);
#line 513
      ps->command ^= 1;
#line 514
      pi_setsockopt(ps->sd, 2, 3, (void const   *)(& use_long_format), & size);
#line 516
      ps->command ^= 1;
      }
    }
    {
#line 520
    size = sizeof(data->rate);
#line 521
    pi_getsockopt(ps->sd, 5, 3, (void *)(& data->rate), & size);
#line 522
    err = (*(data->impl.changebaud))(ps);
    }
#line 522
    if (err < 0) {
#line 523
      goto fail;
    }
    {
#line 526
    tv.tv_sec = (__time_t )0;
#line 527
    tv.tv_usec = (__suseconds_t )50000;
#line 528
    select(0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0,
           (struct timeval */* __restrict  */)(& tv));
    }
#line 529
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 561
    err = net_rx_handshake(ps);
    }
#line 561
    if (err < 0) {
#line 562
      goto fail;
    }
#line 563
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 565
    ps->dlprecord = 0;
  }
#line 568
  data->timeout = 0;
#line 569
  ps->command = 0;
#line 570
  ps->state = 2;
#line 572
  return (ps->sd);
  fail: 
#line 575
  return (err);
}
}
#line 590 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_getsockopt___2(pi_socket_t *ps , int level , int option_name ,
                                    void *option_value , size_t *option_len ) 
{ 
  struct pi_serial_data *data ;
  int *tmp ;
  int tmp___0 ;

  {
#line 594
  data = (struct pi_serial_data *)(ps->device)->data;
  {
#line 598
  if (option_name == 0) {
#line 598
    goto case_0;
  }
#line 604
  if (option_name == 1) {
#line 604
    goto case_1;
  }
#line 610
  if (option_name == 2) {
#line 610
    goto case_2;
  }
#line 616
  if (option_name == 3) {
#line 616
    goto case_3;
  }
#line 597
  goto switch_break;
  case_0: /* CIL Label */ 
#line 599
  if (*option_len != sizeof(data->rate)) {
#line 600
    goto error;
  }
  {
#line 601
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->rate),
         sizeof(data->rate));
  }
#line 602
  goto switch_break;
  case_1: /* CIL Label */ 
#line 605
  if (*option_len != sizeof(data->establishrate)) {
#line 606
    goto error;
  }
  {
#line 607
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->establishrate),
         sizeof(data->establishrate));
  }
#line 608
  goto switch_break;
  case_2: /* CIL Label */ 
#line 611
  if (*option_len != sizeof(data->establishhighrate)) {
#line 612
    goto error;
  }
  {
#line 613
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->establishhighrate),
         sizeof(data->establishhighrate));
  }
#line 614
  goto switch_break;
  case_3: /* CIL Label */ 
#line 617
  if (*option_len != sizeof(data->timeout)) {
#line 618
    goto error;
  }
  {
#line 619
  memcpy((void */* __restrict  */)option_value, (void const   */* __restrict  */)(& data->timeout),
         sizeof(data->timeout));
  }
#line 620
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 623
  return (0);
  error: 
  {
#line 626
  tmp = __errno_location();
#line 626
  *tmp = 22;
#line 627
  tmp___0 = pi_set_error(ps->sd, -501);
  }
#line 627
  return (tmp___0);
}
}
#line 642 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_setsockopt___2(pi_socket_t *ps , int level , int option_name ,
                                    void const   *option_value , size_t *option_len ) 
{ 
  struct pi_serial_data *data ;
  int *tmp ;
  int tmp___0 ;

  {
#line 646
  data = (struct pi_serial_data *)(ps->device)->data;
  {
#line 651
  if (option_name == 1) {
#line 651
    goto case_1;
  }
#line 657
  if (option_name == 2) {
#line 657
    goto case_2;
  }
#line 663
  if (option_name == 3) {
#line 663
    goto case_3;
  }
#line 650
  goto switch_break;
  case_1: /* CIL Label */ 
#line 652
  if (*option_len != sizeof(data->establishrate)) {
#line 653
    goto error;
  }
  {
#line 654
  memcpy((void */* __restrict  */)(& data->establishrate), (void const   */* __restrict  */)option_value,
         sizeof(data->establishrate));
  }
#line 655
  goto switch_break;
  case_2: /* CIL Label */ 
#line 658
  if (*option_len != sizeof(data->establishhighrate)) {
#line 659
    goto error;
  }
  {
#line 660
  memcpy((void */* __restrict  */)(& data->establishhighrate), (void const   */* __restrict  */)option_value,
         sizeof(data->establishhighrate));
  }
#line 661
  goto switch_break;
  case_3: /* CIL Label */ 
#line 664
  if (*option_len != sizeof(data->timeout)) {
#line 665
    goto error;
  }
  {
#line 666
  memcpy((void */* __restrict  */)(& data->timeout), (void const   */* __restrict  */)option_value,
         sizeof(data->timeout));
  }
#line 667
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 670
  return (0);
  error: 
  {
#line 673
  tmp = __errno_location();
#line 673
  *tmp = 22;
#line 674
  tmp___0 = pi_set_error(ps->sd, -501);
  }
#line 674
  return (tmp___0);
}
}
#line 689 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/serial.c"
static int pi_serial_close___2(pi_socket_t *ps ) 
{ 
  struct pi_serial_data *data ;

  {
#line 691
  data = (struct pi_serial_data *)(ps->device)->data;
#line 694
  if (ps->sd) {
    {
#line 695
    (*(data->impl.close))(ps);
#line 696
    ps->sd = 0;
    }
  }
#line 699
  if (ps->laddr) {
    {
#line 700
    free((void *)ps->laddr);
#line 701
    ps->laddr = (struct sockaddr *)((void *)0);
    }
  }
#line 704
  if (ps->raddr) {
    {
#line 705
    free((void *)ps->raddr);
#line 706
    ps->raddr = (struct sockaddr *)((void *)0);
    }
  }
#line 709
  return (0);
}
}
#line 124 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static int s_open___2(pi_socket_t *ps , struct pi_sockaddr *addr , size_t addrlen ) ;
#line 126
static int s_close___2(pi_socket_t *ps ) ;
#line 127
static int s_changebaud___2(pi_socket_t *ps ) ;
#line 128
static ssize_t s_write___2(pi_socket_t *ps , unsigned char const   *buf___3 , size_t len ,
                           int flags ) ;
#line 130
static ssize_t s_read___2(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) ;
#line 132
static int s_poll___2(pi_socket_t *ps , int timeout ) ;
#line 134
static speed_t calcrate___2(int baudrate ) ;
#line 136
static int s_flush___2(pi_socket_t *ps , int flags ) ;
#line 155 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static int s_open___2(pi_socket_t *ps , struct pi_sockaddr *addr , size_t addrlen ) 
{ 
  int fd ;
  int i ;
  char *tty ;
  struct pi_serial_data *data ;
  struct termios tcn ;
  int *tmp ;
  int tmp___0 ;
  speed_t tmp___1 ;

  {
  {
#line 160
  tty = addr->pi_device;
#line 162
  data = (struct pi_serial_data *)(ps->device)->data;
#line 170
  fd = open((char const   *)tty, 2050);
  }
#line 170
  if (fd < 0) {
#line 171
    ps->last_error = -502;
#line 172
    return (-502);
  }
  {
#line 175
  tmp___0 = isatty(fd);
  }
#line 175
  if (! tmp___0) {
    {
#line 176
    close(fd);
#line 177
    tmp = __errno_location();
#line 177
    *tmp = 22;
#line 178
    ps->last_error = -502;
    }
#line 179
    return (-502);
  }
  {
#line 184
  tcgetattr(fd, & tcn);
#line 186
  data->tco = tcn;
#line 187
  tcn.c_oflag = (tcflag_t )0;
#line 188
  tcn.c_iflag = (tcflag_t )5;
#line 189
  tcn.c_cflag = (tcflag_t )2224;
#line 191
  tmp___1 = calcrate___2(data->rate);
#line 191
  cfsetspeed(& tcn, tmp___1);
#line 193
  tcn.c_lflag = (tcflag_t )128;
#line 195
  cfmakeraw(& tcn);
#line 197
  i = 0;
  }
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! (i < 16)) {
#line 197
      goto while_break;
    }
#line 198
    tcn.c_cc[i] = (cc_t )0;
#line 197
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 200
  tcn.c_cc[6] = (cc_t )1;
#line 201
  tcn.c_cc[5] = (cc_t )0;
#line 203
  tcsetattr(fd, 0, (struct termios  const  *)(& tcn));
#line 217
  i = fcntl(fd, 3, 0);
  }
#line 217
  if (i != -1) {
    {
#line 218
    i &= -2049;
#line 219
    fcntl(fd, 4, i);
    }
  }
  {
#line 222
  i = pi_socket_setsd(ps, fd);
  }
#line 222
  if (i < 0) {
#line 223
    return (i);
  }
#line 225
  return (fd);
}
}
#line 240 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static int s_close___2(pi_socket_t *ps ) 
{ 
  int tmp ;

  {
  {
#line 255
  pi_log(2, 4, "DEV CLOSE unixserial fd: %d\n", ps->sd);
#line 258
  tmp = close(ps->sd);
  }
#line 258
  return (tmp);
}
}
#line 273 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static int s_poll___2(pi_socket_t *ps , int timeout ) 
{ 
  struct pi_serial_data *data ;
  struct timeval t ;
  fd_set ready ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 276
  data = (struct pi_serial_data *)(ps->device)->data;
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 281
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 286
  if (timeout == 0) {
    {
#line 287
    select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
           (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
    }
  } else {
    {
#line 289
    t.tv_sec = (__time_t )(timeout / 1000);
#line 290
    t.tv_usec = (__suseconds_t )((timeout % 1000) * 1000);
#line 291
    tmp___0 = select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
                     (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
    }
#line 291
    if (tmp___0 == 0) {
      {
#line 292
      tmp = pi_set_error(ps->sd, -202);
      }
#line 292
      return (tmp);
    }
  }
#line 295
  if (! ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
    {
#line 297
    pi_log(2, 2, "DEV POLL unixserial timeout\n");
#line 299
    (data->rx_errors) ++;
#line 300
    tmp___1 = __errno_location();
#line 300
    *tmp___1 = 110;
#line 301
    tmp___2 = pi_set_error(ps->sd, -202);
    }
#line 301
    return (tmp___2);
  }
  {
#line 303
  pi_log(2, 8, "DEV POLL unixserial found data on fd: %d\n", ps->sd);
  }
#line 306
  return (0);
}
}
#line 321 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static ssize_t s_write___2(pi_socket_t *ps , unsigned char const   *buf___3 , size_t len ,
                           int flags ) 
{ 
  ssize_t total ;
  ssize_t nwrote ;
  struct pi_serial_data *data ;
  struct timeval t ;
  fd_set ready ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 327
  data = (struct pi_serial_data *)(ps->device)->data;
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 332
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 335
  total = (ssize_t )len;
  {
#line 336
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 336
    if (! (total > 0L)) {
#line 336
      goto while_break___0;
    }
#line 337
    if (data->timeout == 0) {
      {
#line 338
      select(ps->sd + 1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)(& ready),
             (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
      }
    } else {
      {
#line 340
      t.tv_sec = (__time_t )(data->timeout / 1000);
#line 341
      t.tv_usec = (__suseconds_t )((data->timeout % 1000) * 1000);
#line 342
      tmp___0 = select(ps->sd + 1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)(& ready),
                       (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
      }
#line 342
      if (tmp___0 == 0) {
        {
#line 343
        tmp = pi_set_error(ps->sd, -202);
        }
#line 343
        return ((ssize_t )tmp);
      }
    }
#line 346
    if (! ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
      {
#line 347
      tmp___1 = pi_set_error(ps->sd, -202);
      }
#line 347
      return ((ssize_t )tmp___1);
    }
    {
#line 349
    nwrote = write(ps->sd, (void const   *)buf___3, len);
    }
#line 350
    if (nwrote < 0L) {
      {
#line 351
      tmp___3 = __errno_location();
      }
#line 351
      if (*tmp___3 == 32) {
        {
#line 352
        ps->state = 8;
#line 353
        tmp___2 = pi_set_error(ps->sd, -200);
        }
#line 353
        return ((ssize_t )tmp___2);
      } else {
        {
#line 351
        tmp___4 = __errno_location();
        }
#line 351
        if (*tmp___4 == 9) {
          {
#line 352
          ps->state = 8;
#line 353
          tmp___2 = pi_set_error(ps->sd, -200);
          }
#line 353
          return ((ssize_t )tmp___2);
        }
      }
      {
#line 355
      tmp___5 = pi_set_error(ps->sd, -204);
      }
#line 355
      return ((ssize_t )tmp___5);
    }
#line 357
    total -= nwrote;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 359
  data->tx_bytes = (int )((size_t )data->tx_bytes + len);
#line 362
  usleep((__useconds_t )(10UL + len));
#line 364
  pi_log(2, 8, "DEV TX unixserial wrote %d bytes\n", len);
  }
#line 367
  return ((ssize_t )len);
}
}
#line 382 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static size_t s_read_buf___2(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len ,
                             int flags ) 
{ 
  struct pi_serial_data *data ;
  size_t rbuf ;
  int *tmp ;
  int tmp___0 ;
  pi_buffer_t *tmp___1 ;

  {
#line 385
  data = (struct pi_serial_data *)(ps->device)->data;
#line 387
  rbuf = data->buf_size;
#line 389
  if (rbuf > len) {
#line 390
    rbuf = len;
  }
  {
#line 392
  tmp___1 = pi_buffer_append(buf___3, (void const   *)(data->buf), rbuf);
  }
#line 392
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 393
    tmp = __errno_location();
#line 393
    *tmp = 12;
#line 394
    tmp___0 = pi_set_error(ps->sd, -500);
    }
#line 394
    return ((size_t )tmp___0);
  }
#line 397
  if (flags != 1) {
#line 398
    data->buf_size -= rbuf;
#line 399
    if (data->buf_size > 0UL) {
      {
#line 400
      memmove((void *)(data->buf), (void const   *)(& data->buf[rbuf]), data->buf_size);
      }
    }
  }
  {
#line 403
  pi_log(2, 8, "DEV RX unixserial read %d bytes from read-ahead buffer\n", rbuf);
  }
#line 406
  return (rbuf);
}
}
#line 420 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static ssize_t s_read___2(pi_socket_t *ps , pi_buffer_t *buf___3 , size_t len , int flags ) 
{ 
  ssize_t rbuf ;
  ssize_t bytes ;
  struct pi_serial_data *data ;
  struct timeval t ;
  fd_set ready ;
  size_t tmp ;
  int __d0 ;
  int __d1 ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  pi_buffer_t *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
#line 423
  rbuf = (ssize_t )0;
#line 425
  data = (struct pi_serial_data *)(ps->device)->data;
#line 431
  if (data->buf_size) {
    {
#line 432
    tmp = s_read_buf___2(ps, buf___3, len, flags);
#line 432
    rbuf = (ssize_t )tmp;
    }
#line 433
    if (rbuf < 0L) {
#line 434
      return (rbuf);
    }
#line 435
    len -= (size_t )rbuf;
#line 436
    if (len == 0UL) {
#line 437
      return (rbuf);
    }
  }
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ready.__fds_bits[0]): "memory");
#line 442
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ps->sd % (8 * (int )sizeof(__fd_mask ));
#line 444
  if (data->timeout == 0) {
    {
#line 445
    select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
           (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
    }
  } else {
    {
#line 447
    t.tv_sec = (__time_t )(data->timeout / 1000);
#line 448
    t.tv_usec = (__suseconds_t )((data->timeout % 1000) * 1000);
#line 449
    tmp___1 = select(ps->sd + 1, (fd_set */* __restrict  */)(& ready), (fd_set */* __restrict  */)0,
                     (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& t));
    }
#line 449
    if (tmp___1 == 0) {
      {
#line 450
      tmp___0 = pi_set_error(ps->sd, -202);
      }
#line 450
      return ((ssize_t )tmp___0);
    }
  }
#line 454
  if ((ready.__fds_bits[ps->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << ps->sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 455
    if (flags == 1) {
#line 455
      if (len > 256UL) {
#line 456
        len = (size_t )256;
      }
    }
    {
#line 458
    tmp___4 = pi_buffer_expect(buf___3, len);
    }
#line 458
    if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
      {
#line 459
      tmp___2 = __errno_location();
#line 459
      *tmp___2 = 12;
#line 460
      tmp___3 = pi_set_error(ps->sd, -500);
      }
#line 460
      return ((ssize_t )tmp___3);
    }
    {
#line 463
    bytes = read(ps->sd, (void *)(buf___3->data + buf___3->used), len);
    }
#line 465
    if (bytes > 0L) {
#line 466
      if (flags == 1) {
        {
#line 467
        memcpy((void */* __restrict  */)(data->buf + data->buf_size), (void const   */* __restrict  */)(buf___3->data + buf___3->used),
               (size_t )bytes);
#line 468
        data->buf_size += (size_t )bytes;
        }
      }
      {
#line 470
      buf___3->used += (size_t )bytes;
#line 471
      data->rx_bytes = (int )((ssize_t )data->rx_bytes + bytes);
#line 472
      rbuf += bytes;
#line 474
      pi_log(2, 8, "DEV RX unixserial read %d bytes\n", bytes);
      }
    } else
#line 476
    if (bytes < 0L) {
#line 477
      rbuf = bytes;
    }
  } else {
    {
#line 480
    pi_log(2, 2, "DEV RX unixserial timeout\n");
#line 482
    (data->rx_errors) ++;
#line 483
    tmp___5 = __errno_location();
#line 483
    *tmp___5 = 110;
#line 484
    tmp___6 = pi_set_error(ps->sd, -202);
    }
#line 484
    return ((ssize_t )tmp___6);
  }
#line 487
  return (rbuf);
}
}
#line 507 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static int s_flush___2(pi_socket_t *ps , int flags ) 
{ 
  int fl ;
  char buf___3[256] ;
  struct pi_serial_data *data ;
  ssize_t tmp ;

  {
#line 512
  data = (struct pi_serial_data *)(ps->device)->data;
#line 514
  if (flags & 1) {
    {
#line 516
    data->buf_size = (size_t )0;
#line 519
    fl = fcntl(ps->sd, 3, 0);
    }
#line 519
    if (fl != -1) {
      {
#line 521
      fcntl(ps->sd, 4, fl | 2048);
      }
      {
#line 522
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 522
        tmp = recv(ps->sd, (void *)(buf___3), sizeof(buf___3), 0);
        }
#line 522
        if (! (tmp > 0L)) {
#line 522
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 524
      fcntl(ps->sd, 4, fl);
      }
    }
    {
#line 527
    pi_log(2, 8, "DEV FLUSH unixserial flushed input buffer\n");
    }
  }
#line 530
  return (0);
}
}
#line 569 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static int s_changebaud___2(pi_socket_t *ps ) 
{ 
  struct pi_serial_data *data ;
  struct termios tcn ;
  int tmp ;
  int tmp___0 ;
  speed_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 572
  data = (struct pi_serial_data *)(ps->device)->data;
#line 577
  pi_log(2, 8, "DEV SPEED unixserial switch to %d bps\n", data->rate);
#line 584
  tmp___0 = tcgetattr(ps->sd, & tcn);
  }
#line 584
  if (tmp___0) {
    {
#line 585
    tmp = pi_set_error(ps->sd, -502);
    }
#line 585
    return (tmp);
  }
  {
#line 587
  tcn.c_cflag = (tcflag_t )2224;
#line 588
  tmp___1 = calcrate___2(data->rate);
#line 588
  cfsetspeed(& tcn, tmp___1);
#line 590
  tmp___3 = tcsetattr(ps->sd, 1, (struct termios  const  *)(& tcn));
  }
#line 590
  if (tmp___3) {
    {
#line 591
    tmp___2 = pi_set_error(ps->sd, -502);
    }
#line 591
    return (tmp___2);
  }
#line 609
  return (0);
}
}
#line 649 "/home/wheatley/newnew/temp/pilot-link-0.12.5/libpisock/unixserial.c"
static speed_t calcrate___2(int baudrate ) 
{ 


  {
#line 653
  if (baudrate == 50) {
#line 654
    return ((speed_t )1);
  }
#line 657
  if (baudrate == 75) {
#line 658
    return ((speed_t )2);
  }
#line 661
  if (baudrate == 110) {
#line 662
    return ((speed_t )3);
  }
#line 665
  if (baudrate == 134) {
#line 666
    return ((speed_t )4);
  }
#line 669
  if (baudrate == 150) {
#line 670
    return ((speed_t )5);
  }
#line 673
  if (baudrate == 200) {
#line 674
    return ((speed_t )6);
  }
#line 677
  if (baudrate == 300) {
#line 678
    return ((speed_t )7);
  }
#line 681
  if (baudrate == 600) {
#line 682
    return ((speed_t )8);
  }
#line 685
  if (baudrate == 1200) {
#line 686
    return ((speed_t )9);
  }
#line 689
  if (baudrate == 1800) {
#line 690
    return ((speed_t )10);
  }
#line 693
  if (baudrate == 2400) {
#line 694
    return ((speed_t )11);
  }
#line 697
  if (baudrate == 4800) {
#line 698
    return ((speed_t )12);
  }
#line 701
  if (baudrate == 9600) {
#line 702
    return ((speed_t )13);
  } else
#line 705
  if (baudrate == 19200) {
#line 706
    return ((speed_t )14);
  } else
#line 709
  if (baudrate == 38400) {
#line 710
    return ((speed_t )15);
  } else
#line 713
  if (baudrate == 57600) {
#line 714
    return ((speed_t )4097);
  } else
#line 721
  if (baudrate == 115200) {
#line 722
    return ((speed_t )4098);
  } else
#line 725
  if (baudrate == 230400) {
#line 726
    return ((speed_t )4099);
  } else
#line 729
  if (baudrate == 460800) {
#line 730
    return ((speed_t )4100);
  }
  {
#line 733
  pi_log(2, 1, "DEV Serial CHANGEBAUD Unable to set baud rate %d\n", baudrate);
#line 736
  abort();
  }
#line 737
  return ((speed_t )0);
}
}
