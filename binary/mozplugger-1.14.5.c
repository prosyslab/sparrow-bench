/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 260 "/usr/include/unistd.h"
typedef __pid_t pid_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 195 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef short int16_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_17 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_17 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 66 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 76 "/usr/include/X11/X.h"
typedef unsigned long VisualID;
#line 96 "/usr/include/X11/X.h"
typedef XID Window;
#line 102 "/usr/include/X11/X.h"
typedef XID Pixmap;
#line 103 "/usr/include/X11/X.h"
typedef XID Cursor;
#line 104 "/usr/include/X11/X.h"
typedef XID Colormap;
#line 92 "/usr/include/X11/Xlib.h"
typedef char *XPointer;
#line 160 "/usr/include/X11/Xlib.h"
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
#line 160 "/usr/include/X11/Xlib.h"
typedef struct _XExtData XExtData;
#line 226
struct _XGC;
#line 226 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 239 "/usr/include/X11/Xlib.h"
struct __anonstruct_Visual_59 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
#line 239 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Visual_59 Visual;
#line 255 "/usr/include/X11/Xlib.h"
struct __anonstruct_Depth_60 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
#line 255 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Depth_60 Depth;
#line 267
struct _XDisplay;
#line 269 "/usr/include/X11/Xlib.h"
struct __anonstruct_Screen_61 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
#line 269 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Screen_61 Screen;
#line 292 "/usr/include/X11/Xlib.h"
struct __anonstruct_ScreenFormat_62 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
#line 292 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_ScreenFormat_62 ScreenFormat;
#line 302 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSetWindowAttributes_63 {
   Pixmap background_pixmap ;
   unsigned long background_pixel ;
   Pixmap border_pixmap ;
   unsigned long border_pixel ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   long event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Colormap colormap ;
   Cursor cursor ;
};
#line 302 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSetWindowAttributes_63 XSetWindowAttributes;
#line 499 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 502
struct _XPrivate;
#line 503
struct _XrmHashBucketRec;
#line 505 "/usr/include/X11/Xlib.h"
struct __anonstruct__XPrivDisplay_77 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
#line 505 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct__XPrivDisplay_77 *_XPrivDisplay;
#line 67 "./npapi/include/npapi.h"
typedef unsigned char NPBool;
#line 68 "./npapi/include/npapi.h"
typedef int16_t NPError;
#line 69 "./npapi/include/npapi.h"
typedef int16_t NPReason;
#line 70 "./npapi/include/npapi.h"
typedef char *NPMIMEType;
#line 79 "./npapi/include/npapi.h"
struct _NPP {
   void *pdata ;
   void *ndata ;
};
#line 79 "./npapi/include/npapi.h"
typedef struct _NPP NPP_t;
#line 85 "./npapi/include/npapi.h"
typedef NPP_t *NPP;
#line 87 "./npapi/include/npapi.h"
struct _NPStream {
   void *pdata ;
   void *ndata ;
   char const   *url ;
   uint32_t end ;
   uint32_t lastmodified ;
   void *notifyData ;
   char const   *headers ;
};
#line 87 "./npapi/include/npapi.h"
typedef struct _NPStream NPStream;
#line 114 "./npapi/include/npapi.h"
struct _NPSavedData {
   int32_t len ;
   void *buf ;
};
#line 114 "./npapi/include/npapi.h"
typedef struct _NPSavedData NPSavedData;
#line 120 "./npapi/include/npapi.h"
struct _NPRect {
   uint16_t top ;
   uint16_t left ;
   uint16_t bottom ;
   uint16_t right ;
};
#line 120 "./npapi/include/npapi.h"
typedef struct _NPRect NPRect;
#line 134
enum __anonenum_NPFocusDirection_145 {
    NPFocusNext = 0,
    NPFocusPrevious = 1
} ;
#line 134 "./npapi/include/npapi.h"
typedef enum __anonenum_NPFocusDirection_145 NPFocusDirection;
#line 165 "./npapi/include/npapi.h"
struct __anonstruct_NPSetWindowCallbackStruct_148 {
   int32_t type ;
   Display *display ;
   Visual *visual ;
   Colormap colormap ;
   unsigned int depth ;
};
#line 165 "./npapi/include/npapi.h"
typedef struct __anonstruct_NPSetWindowCallbackStruct_148 NPSetWindowCallbackStruct;
#line 214
enum __anonenum_NPPVariable_150 {
    NPPVpluginNameString = 1,
    NPPVpluginDescriptionString = 2,
    NPPVpluginWindowBool = 3,
    NPPVpluginTransparentBool = 4,
    NPPVjavaClass = 5,
    NPPVpluginWindowSize = 6,
    NPPVpluginTimerInterval = 7,
    NPPVpluginScriptableInstance = 268435466,
    NPPVpluginScriptableIID = 11,
    NPPVjavascriptPushCallerBool = 12,
    NPPVpluginKeepLibraryInMemory = 13,
    NPPVpluginNeedsXEmbed = 14,
    NPPVpluginScriptableNPObject = 15,
    NPPVformValue = 16,
    NPPVpluginUrlRequestsDisplayedBool = 17,
    NPPVpluginWantsAllNetworkStreams = 18,
    NPPVpluginNativeAccessibleAtkPlugId = 19,
    NPPVpluginCancelSrcStream = 20,
    NPPVsupportsAdvancedKeyHandling = 21,
    NPPVpluginUsesDOMForCursorBool = 22
} ;
#line 214 "./npapi/include/npapi.h"
typedef enum __anonenum_NPPVariable_150 NPPVariable;
#line 271 "./npapi/include/npapi.h"
typedef int NPNVariable;
#line 321
enum __anonenum_NPWindowType_154 {
    NPWindowTypeWindow = 1,
    NPWindowTypeDrawable = 2
} ;
#line 321 "./npapi/include/npapi.h"
typedef enum __anonenum_NPWindowType_154 NPWindowType;
#line 326 "./npapi/include/npapi.h"
struct _NPWindow {
   void *window ;
   int32_t x ;
   int32_t y ;
   uint32_t width ;
   uint32_t height ;
   NPRect clipRect ;
   void *ws_info ;
   NPWindowType type ;
};
#line 326 "./npapi/include/npapi.h"
typedef struct _NPWindow NPWindow;
#line 358 "./npapi/include/npapi.h"
struct _NPFullPrint {
   NPBool pluginPrinted ;
   NPBool printOne ;
   void *platformPrint ;
};
#line 358 "./npapi/include/npapi.h"
typedef struct _NPFullPrint NPFullPrint;
#line 366 "./npapi/include/npapi.h"
struct _NPEmbedPrint {
   NPWindow window ;
   void *platformPrint ;
};
#line 366 "./npapi/include/npapi.h"
typedef struct _NPEmbedPrint NPEmbedPrint;
#line 372 "./npapi/include/npapi.h"
union __anonunion_print_155 {
   NPFullPrint fullPrint ;
   NPEmbedPrint embedPrint ;
};
#line 372 "./npapi/include/npapi.h"
struct _NPPrint {
   uint16_t mode ;
   union __anonunion_print_155 print ;
};
#line 372 "./npapi/include/npapi.h"
typedef struct _NPPrint NPPrint;
#line 81 "./npapi/include/npruntime.h"
struct NPObject;
#line 81 "./npapi/include/npruntime.h"
typedef struct NPObject NPObject;
#line 82
struct NPClass;
#line 82 "./npapi/include/npruntime.h"
typedef struct NPClass NPClass;
#line 84 "./npapi/include/npruntime.h"
typedef char NPUTF8;
#line 85 "./npapi/include/npruntime.h"
struct _NPString {
   NPUTF8 const   *UTF8Characters ;
   uint32_t UTF8Length ;
};
#line 85 "./npapi/include/npruntime.h"
typedef struct _NPString NPString;
#line 90
enum __anonenum_NPVariantType_157 {
    NPVariantType_Void = 0,
    NPVariantType_Null = 1,
    NPVariantType_Bool = 2,
    NPVariantType_Int32 = 3,
    NPVariantType_Double = 4,
    NPVariantType_String = 5,
    NPVariantType_Object = 6
} ;
#line 90 "./npapi/include/npruntime.h"
typedef enum __anonenum_NPVariantType_157 NPVariantType;
#line 100 "./npapi/include/npruntime.h"
union __anonunion_value_158 {
   _Bool boolValue ;
   int32_t intValue ;
   double doubleValue ;
   NPString stringValue ;
   NPObject *objectValue ;
};
#line 100 "./npapi/include/npruntime.h"
struct _NPVariant {
   NPVariantType type ;
   union __anonunion_value_158 value ;
};
#line 100 "./npapi/include/npruntime.h"
typedef struct _NPVariant NPVariant;
#line 210 "./npapi/include/npruntime.h"
typedef void *NPIdentifier;
#line 295 "./npapi/include/npruntime.h"
struct NPClass {
   uint32_t structVersion ;
   NPObject *(*allocate)(NPP npp , NPClass *aClass ) ;
   void (*deallocate)(NPObject *npobj ) ;
   void (*invalidate)(NPObject *npobj ) ;
   _Bool (*hasMethod)(NPObject *npobj , NPIdentifier name ) ;
   _Bool (*invoke)(NPObject *npobj , NPIdentifier name , NPVariant const   *args ,
                   uint32_t argCount , NPVariant *result ) ;
   _Bool (*invokeDefault)(NPObject *npobj , NPVariant const   *args , uint32_t argCount ,
                          NPVariant *result ) ;
   _Bool (*hasProperty)(NPObject *npobj , NPIdentifier name ) ;
   _Bool (*getProperty)(NPObject *npobj , NPIdentifier name , NPVariant *result ) ;
   _Bool (*setProperty)(NPObject *npobj , NPIdentifier name , NPVariant const   *value ) ;
   _Bool (*removeProperty)(NPObject *npobj , NPIdentifier name ) ;
   _Bool (*enumerate)(NPObject *npobj , NPIdentifier **value , uint32_t *count ) ;
   _Bool (*construct)(NPObject *npobj , NPVariant const   *args , uint32_t argCount ,
                      NPVariant *result ) ;
};
#line 323 "./npapi/include/npruntime.h"
struct NPObject {
   NPClass *_class ;
   uint32_t referenceCount ;
};
#line 60 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
struct argument {
   char *name ;
   char *value ;
};
#line 60 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
typedef struct argument argument_t;
#line 68 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
struct data {
   Display *display ;
   char *displayname ;
   NPWindow windata ;
   pid_t pid ;
   int commsPipeFd ;
   int repeats ;
   unsigned int cmd_flags ;
   char const   *command ;
   char const   *winname ;
   unsigned int mode_flags ;
   char *mimetype ;
   char *href ;
   char *url ;
   char browserCantHandleIt ;
   char *urlFragment ;
   int tmpFileFd ;
   char const   *tmpFileName ;
   int tmpFileSize ;
   char autostart ;
   char autostartNotSeen ;
   int num_arguments ;
   struct argument *args ;
};
#line 68 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
typedef struct data data_t;
#line 97 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
struct mimetype {
   char const   *type ;
   struct mimetype *pNext ;
};
#line 97 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
typedef struct mimetype mimetype_t;
#line 105 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
struct command {
   int flags ;
   char const   *cmd ;
   char const   *winname ;
   char const   *fmatchStr ;
   struct command *pNext ;
};
#line 105 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
typedef struct command command_t;
#line 116 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
struct handle {
   mimetype_t *types ;
   command_t *cmds ;
   struct handle *pNext ;
};
#line 116 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
typedef struct handle handler_t;
#line 124 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
struct __anonstruct_cacheEntry_t_159 {
   char name[128] ;
   short exists ;
};
#line 124 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
typedef struct __anonstruct_cacheEntry_t_159 cacheEntry_t;
#line 130 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
struct __anonstruct_our_NPObject_t_160 {
   struct NPObject objHead ;
   NPP assocInstance ;
};
#line 130 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
typedef struct __anonstruct_our_NPObject_t_160 our_NPObject_t;
#line 630 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
struct __anonstruct_flag_t_161 {
   char const   *name ;
   unsigned int value ;
};
#line 630 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
typedef struct __anonstruct_flag_t_161 flag_t;
#line 1130 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
union __anonunion_162 {
   int __in ;
   int __i ;
};
#line 1132 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
union __anonunion_163 {
   int __in ;
   int __i ;
};
#line 273 "/usr/include/X11/Xutil.h"
struct _XRegion;
#line 273 "/usr/include/X11/Xutil.h"
typedef struct _XRegion *Region;
#line 107 "./npapi/include/npapi.h"
struct _NPByteRange {
   int32_t offset ;
   uint32_t length ;
   struct _NPByteRange *next ;
};
#line 107 "./npapi/include/npapi.h"
typedef struct _NPByteRange NPByteRange;
#line 305
enum __anonenum_NPNURLVariable_114 {
    NPNURLVCookie = 501,
    NPNURLVProxy = 502
} ;
#line 305 "./npapi/include/npapi.h"
typedef enum __anonenum_NPNURLVariable_114 NPNURLVariable;
#line 389 "./npapi/include/npapi.h"
typedef Region NPRegion;
#line 398 "./npapi/include/npapi.h"
typedef void *NPMenu;
#line 400
enum __anonenum_NPCoordinateSpace_118 {
    NPCoordinateSpacePlugin = 1,
    NPCoordinateSpaceWindow = 2,
    NPCoordinateSpaceFlippedWindow = 3,
    NPCoordinateSpaceScreen = 4,
    NPCoordinateSpaceFlippedScreen = 5
} ;
#line 400 "./npapi/include/npapi.h"
typedef enum __anonenum_NPCoordinateSpace_118 NPCoordinateSpace;
#line 131 "./npapi/include/npupp.h"
struct _NPPluginFuncs {
   uint16_t size ;
   uint16_t version ;
   NPError (*newp)(NPMIMEType pluginType , NPP instance , uint16_t mode , int16_t argc ,
                   char **argn , char **argv , NPSavedData *saved ) ;
   NPError (*destroy)(NPP instance , NPSavedData **save ) ;
   NPError (*setwindow)(NPP instance , NPWindow *window ) ;
   NPError (*newstream)(NPP instance , NPMIMEType type , NPStream *stream , NPBool seekable ,
                        uint16_t *stype ) ;
   NPError (*destroystream)(NPP instance , NPStream *stream , NPReason reason ) ;
   void (*asfile)(NPP instance , NPStream *stream , char const   *fname ) ;
   int32_t (*writeready)(NPP instance , NPStream *stream ) ;
   int32_t (*write)(NPP instance , NPStream *stream , int32_t offset , int32_t len ,
                    void *buffer ) ;
   void (*print)(NPP instance , NPPrint *platformPrint ) ;
   int16_t (*event)(NPP instance , void *event ) ;
   void (*urlnotify)(NPP instance , char const   *url , NPReason reason , void *notifyData ) ;
   void *javaClass ;
   NPError (*getvalue)(NPP instance , NPPVariable variable , void *ret_value ) ;
   NPError (*setvalue)(NPP instance , NPNVariable variable , void *value ) ;
   NPBool (*gotfocus)(NPP instance , NPFocusDirection direction ) ;
   void (*lostfocus)(NPP instance ) ;
   void (*urlredirectnotify)(NPP instance , char const   *url , int32_t status , void *notifyData ) ;
   NPError (*clearsitedata)(char const   *site , uint64_t flags , uint64_t maxAge ) ;
   char **(*getsiteswithdata)(void) ;
};
#line 131 "./npapi/include/npupp.h"
typedef struct _NPPluginFuncs NPPluginFuncs;
#line 155 "./npapi/include/npupp.h"
struct _NPNetscapeFuncs {
   uint16_t size ;
   uint16_t version ;
   NPError (*geturl)(NPP instance , char const   *url , char const   *window ) ;
   NPError (*posturl)(NPP instance , char const   *url , char const   *window , uint32_t len ,
                      char const   *buf , NPBool file ) ;
   NPError (*requestread)(NPStream *stream , NPByteRange *rangeList ) ;
   NPError (*newstream)(NPP instance , NPMIMEType type , char const   *window , NPStream **stream ) ;
   int32_t (*write)(NPP instance , NPStream *stream , int32_t len , void *buffer ) ;
   NPError (*destroystream)(NPP instance , NPStream *stream , NPReason reason ) ;
   void (*status)(NPP instance , char const   *message ) ;
   char const   *(*uagent)(NPP instance ) ;
   void *(*memalloc)(uint32_t size ) ;
   void (*memfree)(void *ptr ) ;
   uint32_t (*memflush)(uint32_t size ) ;
   void (*reloadplugins)(NPBool reloadPages ) ;
   void *(*getJavaEnv)(void) ;
   void *(*getJavaPeer)(NPP instance ) ;
   NPError (*geturlnotify)(NPP instance , char const   *url , char const   *window ,
                           void *notifyData ) ;
   NPError (*posturlnotify)(NPP instance , char const   *url , char const   *window ,
                            uint32_t len , char const   *buf , NPBool file , void *notifyData ) ;
   NPError (*getvalue)(NPP instance , NPNVariable variable , void *ret_value ) ;
   NPError (*setvalue)(NPP instance , NPPVariable variable , void *value ) ;
   void (*invalidaterect)(NPP instance , NPRect *rect ) ;
   void (*invalidateregion)(NPP instance , NPRegion region ) ;
   void (*forceredraw)(NPP instance ) ;
   NPIdentifier (*getstringidentifier)(NPUTF8 const   *name ) ;
   void (*getstringidentifiers)(NPUTF8 const   **names , int32_t nameCount , NPIdentifier *identifiers ) ;
   NPIdentifier (*getintidentifier)(int32_t intid ) ;
   _Bool (*identifierisstring)(NPIdentifier identifier ) ;
   NPUTF8 *(*utf8fromidentifier)(NPIdentifier identifier ) ;
   int32_t (*intfromidentifier)(NPIdentifier identifier ) ;
   NPObject *(*createobject)(NPP npp , NPClass *aClass ) ;
   NPObject *(*retainobject)(NPObject *obj ) ;
   void (*releaseobject)(NPObject *obj ) ;
   _Bool (*invoke)(NPP npp , NPObject *obj , NPIdentifier methodName , NPVariant const   *args ,
                   uint32_t argCount , NPVariant *result ) ;
   _Bool (*invokeDefault)(NPP npp , NPObject *obj , NPVariant const   *args , uint32_t argCount ,
                          NPVariant *result ) ;
   _Bool (*evaluate)(NPP npp , NPObject *obj , NPString *script , NPVariant *result ) ;
   _Bool (*getproperty)(NPP npp , NPObject *obj , NPIdentifier propertyName , NPVariant *result ) ;
   _Bool (*setproperty)(NPP npp , NPObject *obj , NPIdentifier propertyName , NPVariant const   *value ) ;
   _Bool (*removeproperty)(NPP npp , NPObject *obj , NPIdentifier propertyName ) ;
   _Bool (*hasproperty)(NPP npp , NPObject *obj , NPIdentifier propertyName ) ;
   _Bool (*hasmethod)(NPP npp , NPObject *obj , NPIdentifier propertyName ) ;
   void (*releasevariantvalue)(NPVariant *variant ) ;
   void (*setexception)(NPObject *obj , NPUTF8 const   *message ) ;
   void (*pushpopupsenabledstate)(NPP npp , NPBool enabled ) ;
   void (*poppopupsenabledstate)(NPP npp ) ;
   _Bool (*enumerate)(NPP npp , NPObject *obj , NPIdentifier **identifier , uint32_t *count ) ;
   void (*pluginthreadasynccall)(NPP instance , void (*func)(void * ) , void *userData ) ;
   _Bool (*construct)(NPP npp , NPObject *obj , NPVariant const   *args , uint32_t argCount ,
                      NPVariant *result ) ;
   NPError (*getvalueforurl)(NPP npp , NPNURLVariable variable , char const   *url ,
                             char **value , uint32_t *len ) ;
   NPError (*setvalueforurl)(NPP npp , NPNURLVariable variable , char const   *url ,
                             char const   *value , uint32_t len ) ;
   NPError (*getauthenticationinfo)(NPP npp , char const   *protocol , char const   *host ,
                                    int32_t port , char const   *scheme , char const   *realm ,
                                    char **username , uint32_t *ulen , char **password ,
                                    uint32_t *plen ) ;
   uint32_t (*scheduletimer)(NPP instance , uint32_t interval , NPBool repeat , void (*timerFunc)(NPP npp ,
                                                                                                  uint32_t timerID ) ) ;
   void (*unscheduletimer)(NPP instance , uint32_t timerID ) ;
   NPError (*popupcontextmenu)(NPP instance , NPMenu *menu ) ;
   NPBool (*convertpoint)(NPP instance , double sourceX , double sourceY , NPCoordinateSpace sourceSpace ,
                          double *destX , double *destY , NPCoordinateSpace destSpace ) ;
   NPBool (*handleevent)(NPP instance , void *event , NPBool handled ) ;
   NPBool (*unfocusinstance)(NPP instance , NPFocusDirection direction ) ;
   void (*urlredirectresponse)(NPP instance , void *notifyData , NPBool allow ) ;
};
#line 155 "./npapi/include/npupp.h"
typedef struct _NPNetscapeFuncs NPNetscapeFuncs;
#line 312 "./npapi/include/npapi.h"
enum __anonenum_NPNToolkitType_5 {
    NPNVGtk12 = 1,
    NPNVGtk2 = 2
} ;
#line 312 "./npapi/include/npapi.h"
typedef enum __anonenum_NPNToolkitType_5 NPNToolkitType;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_10 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_10 fd_set;
#line 74 "/usr/include/X11/X.h"
typedef unsigned long Atom;
#line 77 "/usr/include/X11/X.h"
typedef unsigned long Time;
#line 97 "/usr/include/X11/X.h"
typedef XID Drawable;
#line 100 "/usr/include/X11/X.h"
typedef XID Font;
#line 193 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGCValues_54 {
   int function ;
   unsigned long plane_mask ;
   unsigned long foreground ;
   unsigned long background ;
   int line_width ;
   int line_style ;
   int cap_style ;
   int join_style ;
   int fill_style ;
   int fill_rule ;
   int arc_mode ;
   Pixmap tile ;
   Pixmap stipple ;
   int ts_x_origin ;
   int ts_y_origin ;
   Font font ;
   int subwindow_mode ;
   int graphics_exposures ;
   int clip_x_origin ;
   int clip_y_origin ;
   Pixmap clip_mask ;
   int dash_offset ;
   char dashes ;
};
#line 193 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGCValues_54 XGCValues;
#line 320 "/usr/include/X11/Xlib.h"
struct __anonstruct_XWindowAttributes_60 {
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int depth ;
   Visual *visual ;
   Window root ;
   int class ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   Colormap colormap ;
   int map_installed ;
   int map_state ;
   long all_event_masks ;
   long your_event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Screen *screen ;
};
#line 320 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XWindowAttributes_60 XWindowAttributes;
#line 422 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColor_64 {
   unsigned long pixel ;
   unsigned short red ;
   unsigned short green ;
   unsigned short blue ;
   char flags ;
   char pad ;
};
#line 422 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColor_64 XColor;
#line 438 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPoint_66 {
   short x ;
   short y ;
};
#line 438 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPoint_66 XPoint;
#line 569 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyEvent_74 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
#line 569 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyEvent_74 XKeyEvent;
#line 587 "/usr/include/X11/Xlib.h"
struct __anonstruct_XButtonEvent_75 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
#line 587 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XButtonEvent_75 XButtonEvent;
#line 605 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMotionEvent_76 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
#line 605 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMotionEvent_76 XMotionEvent;
#line 622 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCrossingEvent_77 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
#line 622 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCrossingEvent_77 XCrossingEvent;
#line 646 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFocusChangeEvent_78 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
#line 646 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFocusChangeEvent_78 XFocusChangeEvent;
#line 665 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeymapEvent_79 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
#line 665 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeymapEvent_79 XKeymapEvent;
#line 674 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExposeEvent_80 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
#line 674 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExposeEvent_80 XExposeEvent;
#line 685 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGraphicsExposeEvent_81 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
#line 685 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGraphicsExposeEvent_81 XGraphicsExposeEvent;
#line 698 "/usr/include/X11/Xlib.h"
struct __anonstruct_XNoExposeEvent_82 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
#line 698 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XNoExposeEvent_82 XNoExposeEvent;
#line 708 "/usr/include/X11/Xlib.h"
struct __anonstruct_XVisibilityEvent_83 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
#line 708 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XVisibilityEvent_83 XVisibilityEvent;
#line 717 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCreateWindowEvent_84 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
#line 717 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCreateWindowEvent_84 XCreateWindowEvent;
#line 730 "/usr/include/X11/Xlib.h"
struct __anonstruct_XDestroyWindowEvent_85 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
#line 730 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XDestroyWindowEvent_85 XDestroyWindowEvent;
#line 739 "/usr/include/X11/Xlib.h"
struct __anonstruct_XUnmapEvent_86 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
#line 739 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XUnmapEvent_86 XUnmapEvent;
#line 749 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapEvent_87 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
#line 749 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapEvent_87 XMapEvent;
#line 759 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapRequestEvent_88 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
#line 759 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapRequestEvent_88 XMapRequestEvent;
#line 768 "/usr/include/X11/Xlib.h"
struct __anonstruct_XReparentEvent_89 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
#line 768 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XReparentEvent_89 XReparentEvent;
#line 780 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureEvent_90 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
#line 780 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureEvent_90 XConfigureEvent;
#line 794 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGravityEvent_91 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
#line 794 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGravityEvent_91 XGravityEvent;
#line 804 "/usr/include/X11/Xlib.h"
struct __anonstruct_XResizeRequestEvent_92 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
#line 804 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XResizeRequestEvent_92 XResizeRequestEvent;
#line 813 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureRequestEvent_93 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
#line 813 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureRequestEvent_93 XConfigureRequestEvent;
#line 828 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateEvent_94 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
#line 828 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateEvent_94 XCirculateEvent;
#line 838 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateRequestEvent_95 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
#line 838 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateRequestEvent_95 XCirculateRequestEvent;
#line 848 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPropertyEvent_96 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
#line 848 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPropertyEvent_96 XPropertyEvent;
#line 859 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionClearEvent_97 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
#line 859 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionClearEvent_97 XSelectionClearEvent;
#line 869 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionRequestEvent_98 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 869 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionRequestEvent_98 XSelectionRequestEvent;
#line 882 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionEvent_99 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 882 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionEvent_99 XSelectionEvent;
#line 894 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColormapEvent_100 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
#line 894 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColormapEvent_100 XColormapEvent;
#line 909 "/usr/include/X11/Xlib.h"
union __anonunion_data_102 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
#line 909 "/usr/include/X11/Xlib.h"
struct __anonstruct_XClientMessageEvent_101 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_102 data ;
};
#line 909 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XClientMessageEvent_101 XClientMessageEvent;
#line 924 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMappingEvent_103 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
#line 924 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMappingEvent_103 XMappingEvent;
#line 936 "/usr/include/X11/Xlib.h"
struct __anonstruct_XErrorEvent_104 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
#line 936 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XErrorEvent_104 XErrorEvent;
#line 946 "/usr/include/X11/Xlib.h"
struct __anonstruct_XAnyEvent_105 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
#line 946 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XAnyEvent_105 XAnyEvent;
#line 960 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEvent_106 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
#line 960 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEvent_106 XGenericEvent;
#line 970 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEventCookie_107 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
#line 970 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEventCookie_107 XGenericEventCookie;
#line 985 "/usr/include/X11/Xlib.h"
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
#line 985 "/usr/include/X11/Xlib.h"
typedef union _XEvent XEvent;
#line 1855 "/usr/include/X11/Xlib.h"
typedef int (*XErrorHandler)(Display * , XErrorEvent * );
#line 1865 "/usr/include/X11/Xlib.h"
typedef int (*XIOErrorHandler)(Display * );
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_min_aspect_133 {
   int x ;
   int y ;
};
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_XSizeHints_132 {
   long flags ;
   int x ;
   int y ;
   int width ;
   int height ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   int width_inc ;
   int height_inc ;
   struct __anonstruct_min_aspect_133 min_aspect ;
   struct __anonstruct_min_aspect_133 max_aspect ;
   int base_width ;
   int base_height ;
   int win_gravity ;
};
#line 81 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XSizeHints_132 XSizeHints;
#line 189 "/usr/include/X11/Xutil.h"
struct __anonstruct_XClassHint_138 {
   char *res_name ;
   char *res_class ;
};
#line 189 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XClassHint_138 XClassHint;
#line 70 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
struct __anonstruct_parentDetails_153 {
   Window window ;
   int x ;
   int y ;
   unsigned int width ;
   unsigned int height ;
};
#line 119 "/usr/include/X11/Xutil.h"
struct __anonstruct_XWMHints_136 {
   long flags ;
   int input ;
   int initial_state ;
   Pixmap icon_pixmap ;
   Window icon_window ;
   int icon_x ;
   int icon_y ;
   Pixmap icon_mask ;
   XID window_group ;
};
#line 119 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XWMHints_136 XWMHints;
#line 55 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
struct __anonstruct_victimDetails_160 {
   int noWmRunning ;
   int mapped ;
   int reparented ;
   int reparentedAttemptCount ;
   Window window ;
   int borderWidth ;
   int x ;
   int y ;
   int width ;
   int height ;
   pid_t pid ;
};
#line 70 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
struct __anonstruct_parentDetails_161 {
   Window window ;
   int width ;
   int height ;
};
#line 1515 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
union __anonunion_162___0 {
   int __in ;
   int __i ;
};
#line 1523 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
union __anonunion_163___0 {
   int __in ;
   int __i ;
};
#line 1524 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
union __anonunion_164 {
   int __in ;
   int __i ;
};
#line 1521 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
union __anonunion_165 {
   int __in ;
   int __i ;
};
#line 460 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 84 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.h"
void my_kill(pid_t pid___1 ) ;
#line 39 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./debug.h"
void ( /* format attribute */  D)(char *fmt  , ...) ;
#line 52 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-common.c"
void my_kill(pid_t pid___1 ) 
{ 
  int status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __pid_t tmp___2 ;

  {
  {
#line 56
  D((char *)"Killing PID %d with SIGTERM\n", pid___1);
#line 57
  tmp___1 = kill(pid___1, 15);
  }
#line 57
  if (! tmp___1) {
    {
#line 59
    usleep((__useconds_t )100000);
#line 60
    D((char *)"Killing PID %d with SIGTERM\n", pid___1);
#line 61
    tmp___0 = kill(pid___1, 15);
    }
#line 61
    if (! tmp___0) {
      {
#line 63
      usleep((__useconds_t )100000);
#line 64
      D((char *)"Killing PID %d with SIGTERM\n", pid___1);
#line 65
      tmp = kill(pid___1, 15);
      }
#line 65
      if (! tmp) {
        {
#line 67
        D((char *)"Killing PID %d with SIGKILL\n", pid___1);
#line 68
        kill(pid___1, 9);
        }
      }
    }
  }
  {
#line 73
  D((char *)"Waiting for sons\n");
  }
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 74
    tmp___2 = waitpid(-1, & status, 1);
    }
#line 74
    if (! (tmp___2 > 0)) {
#line 74
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  return;
}
}
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const   *__file ,
                                                                                               char const   *__arg 
                                                                                               , ...) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 619
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 835
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *__path ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 620
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 218
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigfillset)(sigset_t *__set ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 119 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socketpair)(int __domain ,
                                                                                 int __type ,
                                                                                 int __protocol ,
                                                                                 int *__fds ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 1527 "/usr/include/X11/Xlib.h"
extern char *XDisplayName(char const   * ) ;
#line 2097
extern int XChangeWindowAttributes(Display * , Window  , unsigned long  , XSetWindowAttributes * ) ;
#line 3111
extern int XResizeWindow(Display * , Window  , unsigned int  , unsigned int  ) ;
#line 501 "./npapi/include/npapi.h"
char const   *NPP_GetMIMEDescription(void) ;
#line 504
NPError NPP_Initialize(void) ;
#line 505
void NPP_Shutdown(void) ;
#line 506
NPError NPP_New(NPMIMEType pluginType , NPP instance , uint16_t mode , int16_t argc ,
                char **argn , char **argv , NPSavedData *saved ) ;
#line 509
NPError NPP_Destroy(NPP instance , NPSavedData **save ) ;
#line 510
NPError NPP_SetWindow(NPP instance , NPWindow *window ) ;
#line 511
NPError NPP_NewStream(NPP instance , NPMIMEType type , NPStream *stream , NPBool seekable ,
                      uint16_t *stype ) ;
#line 514
NPError NPP_DestroyStream(NPP instance , NPStream *stream , short reason ) ;
#line 516
int32_t NPP_WriteReady(NPP instance , NPStream *stream ) ;
#line 517
int32_t NPP_Write(NPP instance , NPStream *stream , int32_t offset , int32_t len ,
                  void *buf ) ;
#line 519
void NPP_StreamAsFile(NPP instance , NPStream *stream , char const   *fname ) ;
#line 521
void NPP_Print(NPP instance , NPPrint *printInfo ) ;
#line 523
void NPP_URLNotify(NPP instance , char const   *url , NPReason reason , void *notifyData ) ;
#line 525
NPError NPP_GetValue(void *instance , NPPVariable variable , void *value ) ;
#line 526
NPError NPP_SetValue(NPP instance , NPNVariable variable , void *value ) ;
#line 527
NPBool NPP_GotFocus(NPP instance , NPFocusDirection direction ) ;
#line 528
void NPP_LostFocus(NPP instance ) ;
#line 529
void NPP_URLRedirectNotify(NPP instance , char const   *url , int32_t status , void *noifyData ) ;
#line 530
NPError NPP_ClearSiteData(char const   *site , uint64_t flags___3 , uint64_t maxAge ) ;
#line 531
char **NPP_GetSitesWithData(void) ;
#line 538
NPError NPN_GetURL(NPP instance , char const   *url , char const   *window ) ;
#line 552
NPError NPN_DestroyStream(NPP instance , NPStream *stream , short reason ) ;
#line 554
void NPN_Status(NPP instance , char const   *message ) ;
#line 556
void *NPN_MemAlloc(uint32_t size ) ;
#line 557
void NPN_MemFree(void *ptr ) ;
#line 227 "./npapi/include/npruntime.h"
_Bool NPN_IdentifierIsString(NPIdentifier identifier ) ;
#line 232
NPUTF8 *NPN_UTF8FromIdentifier(NPIdentifier identifier ) ;
#line 238
int32_t NPN_IntFromIdentifier(NPIdentifier identifier ) ;
#line 337
NPObject *NPN_CreateObject(NPP npp , NPClass *aClass ) ;
#line 35 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./debug.h"
void close_debug(void) ;
#line 36
char *get_debug_path(void) ;
#line 24 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npn-get-helpers.h"
void get_api_version(void) ;
#line 26
NPBool does_browser_have_resize_bug(void) ;
#line 28
NPBool does_browser_support_xembed(void) ;
#line 139 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static char const   *errMsg  =    (char const   *)((void *)0);
#line 140 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static char const   *config_fname  ;
#line 141 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static char const   *helper_fname  ;
#line 142 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static char const   *controller_fname  ;
#line 143 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static char const   *linker_fname  ;
#line 144 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static handler_t *handlers  =    (handler_t *)0;
#line 146 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static NPBool browserSupportsXEmbed  ;
#line 148 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static char staticPool[65536]  ;
#line 149 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static int staticPoolIdx  =    0;
#line 151 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static NPClass pluginClass  ;
#line 166 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static void my_putenv(char *buffer , int *offset , char const   *var , char const   *value ) 
{ 
  int l ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 169
  if (value) {
    {
#line 171
    tmp = strlen(var);
#line 171
    tmp___0 = strlen(value);
#line 171
    l = (int )((tmp + tmp___0) + 2UL);
    }
#line 172
    if (*offset + l >= 16348) {
      {
#line 174
      D((char *)"Buffer overflow in putenv(%s=%s)\n", var, value);
      }
#line 175
      return;
    }
    {
#line 178
    snprintf((char */* __restrict  */)(buffer + *offset), (size_t )l, (char const   */* __restrict  */)"%s=%s",
             var, value);
#line 179
    putenv(buffer + *offset);
#line 180
    *offset += l;
    }
  } else {
    {
#line 184
    D((char *)"putenv did nothing, no value for %s\n", var);
    }
  }
#line 186
  return;
}
}
#line 206 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static void run(data_t * const  THIS , char const   *file___0 , int pipeFd ) 
{ 
  char buffer[16348] ;
  char foo[128] ;
  int offset ;
  int i ;
  unsigned int flags___3 ;
  int autostart ;
  char const   *launcher ;
  char const   *nextHelper___0 ;
  size_t tmp ;
  char const   *tmp___0 ;

  {
#line 210
  offset = 0;
#line 212
  flags___3 = THIS->cmd_flags;
#line 213
  autostart = (int )THIS->autostart;
#line 214
  launcher = (char const   *)((void *)0);
#line 215
  nextHelper___0 = (char const   *)((void *)0);
#line 219
  if ((unsigned long )THIS->windata.window == (unsigned long )((void *)0)) {
#line 221
    if (flags___3 & 12288U) {
      {
#line 223
      D((char *)"Cannot use controls or link button as no window to draw controls in\n");
#line 225
      flags___3 &= 4294955007U;
      }
    }
  }
#line 230
  if (flags___3 & 12288U) {
#line 230
    if (THIS->autostartNotSeen) {
#line 232
      autostart = 0;
    }
  }
  {
#line 235
  snprintf((char */* __restrict  */)(buffer), sizeof(buffer), (char const   */* __restrict  */)"%d,%d,%d,%lu,%d,%d,%d,%d",
           flags___3, THIS->repeats, pipeFd, (unsigned long )THIS->windata.window,
           THIS->windata.x, THIS->windata.y, (int )THIS->windata.width, (int )THIS->windata.height);
#line 245
  tmp = strlen((char const   *)(buffer));
#line 245
  offset = (int )(tmp + 1UL);
#line 247
  snprintf((char */* __restrict  */)(foo), sizeof(foo), (char const   */* __restrict  */)"%lu",
           (unsigned long )THIS->windata.window);
#line 248
  my_putenv(buffer, & offset, "window", (char const   *)(foo));
#line 250
  snprintf((char */* __restrict  */)(foo), sizeof(foo), (char const   */* __restrict  */)"0x%lx",
           (unsigned long )THIS->windata.window);
#line 251
  my_putenv(buffer, & offset, "hexwindow", (char const   *)(foo));
#line 253
  snprintf((char */* __restrict  */)(foo), sizeof(foo), (char const   */* __restrict  */)"%ld",
           (long )THIS->repeats);
#line 254
  my_putenv(buffer, & offset, "repeats", (char const   *)(foo));
#line 256
  snprintf((char */* __restrict  */)(foo), sizeof(foo), (char const   */* __restrict  */)"%ld",
           (long )THIS->windata.width);
#line 257
  my_putenv(buffer, & offset, "width", (char const   *)(foo));
#line 259
  snprintf((char */* __restrict  */)(foo), sizeof(foo), (char const   */* __restrict  */)"%ld",
           (long )THIS->windata.height);
#line 260
  my_putenv(buffer, & offset, "height", (char const   *)(foo));
#line 262
  my_putenv(buffer, & offset, "mimetype", (char const   *)THIS->mimetype);
#line 264
  my_putenv(buffer, & offset, "file", file___0);
#line 266
  my_putenv(buffer, & offset, "fragment", (char const   *)THIS->urlFragment);
  }
#line 268
  if (autostart) {
#line 268
    tmp___0 = "1";
  } else {
#line 268
    tmp___0 = "0";
  }
  {
#line 268
  my_putenv(buffer, & offset, "autostart", tmp___0);
#line 270
  my_putenv(buffer, & offset, "winname", THIS->winname);
#line 272
  my_putenv(buffer, & offset, "DISPLAY", (char const   *)THIS->displayname);
#line 274
  i = 0;
  }
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! (i < THIS->num_arguments)) {
#line 274
      goto while_break;
    }
    {
#line 276
    my_putenv(buffer, & offset, (char const   *)(THIS->args + i)->name, (char const   *)(THIS->args + i)->value);
#line 274
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  if (flags___3 & 4096U) {
#line 281
    launcher = controller_fname;
  } else
#line 283
  if (flags___3 & 8192U) {
#line 285
    launcher = linker_fname;
  } else
#line 287
  if (! autostart) {
#line 287
    if (! (flags___3 & 32768U)) {
#line 287
      if ((unsigned long )THIS->windata.window != (unsigned long )((void *)0)) {
#line 292
        nextHelper___0 = helper_fname;
#line 293
        launcher = linker_fname;
      } else {
#line 297
        launcher = helper_fname;
      }
    } else {
#line 297
      launcher = helper_fname;
    }
  } else {
#line 297
    launcher = helper_fname;
  }
#line 300
  if ((unsigned long )launcher == (unsigned long )((char const   *)0)) {
    {
#line 302
    D((char *)"No launcher defined");
#line 303
    _exit(69);
    }
  }
  {
#line 306
  D((char *)"Executing helper: %s %s %s %s %s %s\n", launcher, buffer, file___0, THIS->displayname,
    THIS->command, THIS->mimetype);
  }
#line 314
  if (nextHelper___0) {
    {
#line 316
    execlp(launcher, launcher, buffer, THIS->command, nextHelper___0, (void *)0);
    }
  } else {
    {
#line 320
    execlp(launcher, launcher, buffer, THIS->command, (void *)0);
    }
  }
  {
#line 323
  D((char *)"EXECLP FAILED!\n");
#line 325
  _exit(69);
  }
}
}
#line 340 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static int inpath(char const   *path , char const   *file___0 ) 
{ 
  int start ;
  int i ;
  int fileLen ;
  size_t tmp ;
  int pathLen ;
  char buf[1024] ;
  struct stat filestat ;
  int tmp___0 ;

  {
  {
#line 343
  tmp = strlen(file___0);
#line 343
  fileLen = (int )tmp;
#line 345
  i = 0;
#line 345
  start = i;
  }
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 349
    if ((int const   )*(path + i) == 58) {
#line 349
      goto _L;
    } else
#line 349
    if ((int const   )*(path + i) == 0) {
      _L: /* CIL Label */ 
#line 352
      pathLen = i - start;
#line 353
      if (pathLen > 0) {
#line 353
        if ((pathLen + fileLen) + 2 < 1024) {
          {
#line 358
          strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)(path + start),
                  (size_t )pathLen);
          }
#line 361
          if ((int )buf[pathLen - 1] != 47) {
            {
#line 363
            buf[pathLen] = (char )'/';
#line 364
            strcpy((char */* __restrict  */)(& buf[pathLen + 1]), (char const   */* __restrict  */)file___0);
            }
          } else {
            {
#line 368
            strcpy((char */* __restrict  */)(& buf[pathLen]), (char const   */* __restrict  */)file___0);
            }
          }
          {
#line 372
          tmp___0 = stat((char const   */* __restrict  */)(buf), (struct stat */* __restrict  */)(& filestat));
          }
#line 372
          if (tmp___0 == 0) {
            {
#line 374
            D((char *)"stat(%s) = yes\n", buf);
            }
#line 375
            return (1);
          }
          {
#line 377
          D((char *)"stat(%s) = no\n", buf);
          }
        }
      }
#line 379
      if ((int const   )*(path + i) == 0) {
#line 381
        return (0);
      }
#line 383
      start = i + 1;
    }
#line 385
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 402 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static char *NP_strdup(char const   *str ) 
{ 
  int len ;
  size_t tmp ;
  char *dupStr ;
  void *tmp___0 ;

  {
  {
#line 404
  tmp = strlen(str);
#line 404
  len = (int )tmp;
#line 405
  tmp___0 = NPN_MemAlloc((uint32_t )(len + 1));
#line 405
  dupStr = (char *)tmp___0;
  }
#line 406
  if ((unsigned long )dupStr != (unsigned long )((void *)0)) {
    {
#line 408
    strcpy((char */* __restrict  */)dupStr, (char const   */* __restrict  */)str);
    }
  } else {
    {
#line 412
    D((char *)"NPN_MemAlloc failed, size=%i\n", len + 1);
    }
  }
#line 414
  return (dupStr);
}
}
#line 429 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static cacheEntry_t cache[10]  ;
#line 430
static int find(char const   *file___0 ) ;
#line 430 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static int cacheSize  =    0;
#line 431 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static int cacheHead  =    0;
#line 427 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static int find(char const   *file___0 ) 
{ 
  struct stat filestat ;
  int i ;
  int exists ;
  int exists___0 ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *env_path ;
  char *tmp___2 ;

  {
  {
#line 435
  exists = 0;
#line 437
  D((char *)"find(%s)\n", file___0);
#line 439
  i = 0;
  }
  {
#line 439
  while (1) {
    while_continue: /* CIL Label */ ;
#line 439
    if (! (i < cacheSize)) {
#line 439
      goto while_break;
    }
    {
#line 441
    tmp___0 = strcmp((char const   *)(cache[i].name), file___0);
    }
#line 441
    if (tmp___0 == 0) {
#line 443
      exists___0 = (int )cache[i].exists;
#line 444
      if (exists___0) {
#line 444
        tmp = "yes";
      } else {
#line 444
        tmp = "no";
      }
      {
#line 444
      D((char *)"find cache hit exists = %s\n", tmp);
      }
#line 445
      return (exists___0);
    }
#line 439
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 449
  if ((int const   )*(file___0 + 0) == 47) {
    {
#line 451
    tmp___1 = stat((char const   */* __restrict  */)file___0, (struct stat */* __restrict  */)(& filestat));
#line 451
    exists = tmp___1 == 0;
    }
  } else {
    {
#line 456
    tmp___2 = getenv("PATH");
#line 456
    env_path = (char const   *)tmp___2;
    }
#line 458
    if ((unsigned long )env_path == (unsigned long )((void *)0)) {
      {
#line 460
      D((char *)"No $PATH\n");
#line 461
      exists = 0;
      }
    } else {
      {
#line 465
      exists = inpath(env_path, file___0);
      }
    }
  }
  {
#line 469
  strncpy((char */* __restrict  */)(cache[cacheHead].name), (char const   */* __restrict  */)file___0,
          (size_t )128);
#line 470
  cache[cacheHead].name[127] = (char )'\000';
#line 471
  cache[cacheHead].exists = (short )exists;
#line 473
  cacheHead ++;
  }
#line 474
  if (cacheHead > cacheSize) {
#line 476
    cacheSize = cacheHead;
  }
#line 478
  if (cacheHead >= 10) {
#line 480
    cacheHead = 0;
  }
#line 482
  return (exists);
}
}
#line 496 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static void *allocStaticMem(int size ) 
{ 
  void *retVal ;
  int newIdx ;

  {
#line 499
  newIdx = staticPoolIdx + size;
#line 501
  if (newIdx > 65536) {
    {
#line 503
    D((char *)"Out of static memory");
#line 505
    errMsg = "MozPlugger: config file mozpluggerrc is too big - deletesome handlers/commands or mimetypes";
#line 507
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            errMsg);
    }
#line 508
    return ((void *)0);
  }
#line 511
  retVal = (void *)(& staticPool[staticPoolIdx]);
#line 512
  staticPoolIdx = newIdx;
#line 513
  return (retVal);
}
}
#line 529 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static char const   *makeStrStatic(char const   *str , int len ) 
{ 
  char *buf ;
  void *tmp ;

  {
  {
#line 532
  tmp = allocStaticMem(len + 1);
#line 532
  buf = (char *)tmp;
  }
#line 534
  if (buf) {
    {
#line 536
    strncpy((char */* __restrict  */)buf, (char const   */* __restrict  */)str, (size_t )len);
#line 537
    *(buf + len) = (char )'\000';
    }
  }
#line 539
  return ((char const   *)buf);
}
}
#line 555 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static char *get_parameter(char *x , char const   *flag , char const   **c ) 
{ 
  char *end ;
  int len ;

  {
  {
#line 561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 561
    if (! ((int )*x == 32)) {
#line 561
      if (! ((int )*x == 9)) {
#line 561
        goto while_break;
      }
    }
#line 563
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 566
  if ((int )*x != 40) {
    {
#line 568
    D((char *)"Config error - expected \'(\' after \'%s\'\n", flag);
#line 570
    errMsg = "MozPlugger: syntax error in mozpluggerrc config file";
#line 571
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s - expected \'(\' after \'%s\'\n",
            errMsg, flag);
    }
#line 572
    return ((char *)((void *)0));
  }
  {
#line 574
  x ++;
#line 575
  end = strchr((char const   *)x, ')');
  }
#line 576
  if (end) {
    {
#line 578
    len = (int )(end - x);
#line 582
    *c = makeStrStatic((char const   *)x, len);
#line 584
    x = end + 1;
    }
  } else {
    {
#line 588
    D((char *)"Config error - expected \')\'\n");
#line 590
    errMsg = "MozPlugger: syntax error in mozpluggerrc config file";
#line 591
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s - expected \')\' found nothing\n",
            errMsg);
    }
#line 592
    return ((char *)((void *)0));
  }
#line 594
  return (x);
}
}
#line 609 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
__inline static int match_word(char const   *line , char const   *kw ) 
{ 
  unsigned int kwLen ;
  size_t tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;

  {
  {
#line 612
  tmp = strlen(kw);
#line 612
  kwLen = (unsigned int )tmp;
#line 614
  tmp___0 = strncasecmp(line, kw, (size_t )kwLen);
  }
#line 614
  if (tmp___0 == 0) {
    {
#line 614
    tmp___1 = __ctype_b_loc();
    }
#line 614
    if ((int const   )*(*tmp___1 + (int )*(line + kwLen)) & 8) {
#line 614
      tmp___2 = 0;
    } else {
#line 614
      tmp___2 = 1;
    }
  } else {
#line 614
    tmp___2 = 0;
  }
#line 614
  return (tmp___2);
}
}
#line 636
static int parse_flags(char **x , command_t *commandp ) ;
#line 636 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static flag_t const   flags[19]  = 
#line 636
  {      {"repeat", 16U}, 
        {"loop", 1U}, 
        {"stream", 4U}, 
        {"ignore_errors", 128U}, 
        {"exits", 2U}, 
        {"nokill", 2U}, 
        {"maxaspect", 512U}, 
        {"fill", 1024U}, 
        {"noisy", 8U}, 
        {"embed", 32U}, 
        {"noembed", 64U}, 
        {"links", 8192U}, 
        {"controls", 4096U}, 
        {"swallow", 256U}, 
        {"fmatch", 16384U}, 
        {"autostart", 32768U}, 
        {"needs_xembed", 2048U}, 
        {"hidden", 0U}, 
        {(char const   *)((void *)0), 0U}};
#line 628 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static int parse_flags(char **x , command_t *commandp ) 
{ 
  flag_t const   *f ;
  size_t tmp ;
  char *p ;
  char *tmp___0 ;
  char *p___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 661
  f = flags;
  {
#line 661
  while (1) {
    while_continue: /* CIL Label */ ;
#line 661
    if (! f->name) {
#line 661
      goto while_break;
    }
    {
#line 663
    tmp___2 = match_word((char const   *)*x, (char const   *)f->name);
    }
#line 663
    if (tmp___2) {
      {
#line 665
      tmp = strlen((char const   *)f->name);
#line 665
      *x += tmp;
#line 666
      commandp->flags = (int )((unsigned int const   )commandp->flags | f->value);
      }
#line 669
      if (f->value & 256U) {
        {
#line 671
        tmp___0 = get_parameter(*x, (char const   *)f->name, & commandp->winname);
#line 671
        p = tmp___0;
        }
#line 672
        if (p) {
#line 674
          *x = p;
#line 675
          return (1);
        }
      } else
#line 678
      if (f->value & 16384U) {
        {
#line 680
        tmp___1 = get_parameter(*x, (char const   *)f->name, & commandp->fmatchStr);
#line 680
        p___0 = tmp___1;
        }
#line 681
        if (p___0) {
#line 683
          *x = p___0;
#line 684
          return (1);
        }
      } else {
#line 689
        return (1);
      }
    }
#line 661
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 693
  return (0);
}
}
#line 703 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static void read_config(FILE *f ) 
{ 
  int num_handlers ;
  handler_t *prev_handler ;
  handler_t *handler ;
  command_t *cmd ;
  command_t *prev_cmd ;
  mimetype_t *type ;
  mimetype_t *prev_type ;
  char buffer[16384] ;
  char file___0[128] ;
  int seen_commands ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  char *x ;
  unsigned short const   **tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  unsigned short const   **tmp___14 ;
  char *tmp___15 ;

  {
  {
#line 705
  num_handlers = 0;
#line 707
  prev_handler = (handler_t *)((void *)0);
#line 708
  handler = (handler_t *)((void *)0);
#line 710
  cmd = (command_t *)((void *)0);
#line 711
  prev_cmd = (command_t *)((void *)0);
#line 713
  type = (mimetype_t *)((void *)0);
#line 714
  prev_type = (mimetype_t *)((void *)0);
#line 718
  seen_commands = 0;
#line 720
  D((char *)"read_config\n");
#line 722
  tmp = allocStaticMem((int )sizeof(handler_t ));
#line 722
  handler = (handler_t *)tmp;
  }
#line 723
  if ((unsigned long )handler == (unsigned long )((void *)0)) {
#line 725
    return;
  }
  {
#line 727
  memset((void *)handler, 0, sizeof(handler_t ));
  }
  {
#line 729
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 729
    tmp___15 = fgets((char */* __restrict  */)(buffer), (int )sizeof(buffer), (FILE */* __restrict  */)f);
    }
#line 729
    if (! tmp___15) {
#line 729
      goto while_break;
    }
#line 731
    if ((int )buffer[0] == 10) {
#line 733
      goto while_continue;
    } else
#line 731
    if ((int )buffer[0] == 0) {
#line 733
      goto while_continue;
    }
    {
#line 736
    D((char *)"::: %s", buffer);
    }
#line 738
    if ((int )buffer[0] == 35) {
#line 740
      goto while_continue;
    }
    {
#line 743
    tmp___1 = strlen((char const   *)(buffer));
    }
#line 743
    if ((int )buffer[tmp___1 - 1UL] == 10) {
      {
#line 745
      tmp___0 = strlen((char const   *)(buffer));
#line 745
      buffer[tmp___0 - 1UL] = (char)0;
      }
    }
    {
#line 748
    tmp___14 = __ctype_b_loc();
    }
#line 748
    if ((int const   )*(*tmp___14 + (int )buffer[0]) & 8192) {
#line 835
      x = buffer + 1;
      {
#line 836
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 836
        tmp___5 = __ctype_b_loc();
        }
#line 836
        if (! ((int const   )*(*tmp___5 + (int )*x) & 8192)) {
#line 836
          goto while_break___0;
        }
#line 838
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 841
      if (! *x) {
        {
#line 843
        D((char *)"Empty command.\n");
#line 844
        seen_commands = 1;
        }
#line 845
        goto while_continue;
      }
      {
#line 848
      D((char *)"New command\n");
#line 850
      seen_commands = 1;
#line 852
      tmp___6 = allocStaticMem((int )sizeof(command_t ));
#line 852
      cmd = (command_t *)tmp___6;
      }
#line 853
      if ((unsigned long )cmd == (unsigned long )((void *)0)) {
#line 855
        goto while_continue;
      }
      {
#line 857
      memset((void *)cmd, 0, sizeof(command_t ));
#line 860
      D((char *)"Parsing %s\n", x);
      }
      {
#line 862
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 862
        if ((int )*x != 58) {
#line 862
          if (! *x) {
#line 862
            goto while_break___1;
          }
        } else {
#line 862
          goto while_break___1;
        }
#line 864
        if ((int )*x == 44) {
#line 866
          x ++;
        } else
#line 864
        if ((int )*x == 32) {
#line 866
          x ++;
        } else
#line 864
        if ((int )*x == 9) {
#line 866
          x ++;
        } else {
          {
#line 868
          tmp___8 = parse_flags(& x, cmd);
          }
#line 868
          if (! tmp___8) {
            {
#line 870
            D((char *)"Config error - unknown directive %s\n", x);
#line 872
            errMsg = "MozPlugger: syntax error in mozpluggerrc config file";
#line 873
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s - unknown directive: %s\n",
                    errMsg, x);
#line 874
            tmp___7 = strlen((char const   *)x);
#line 874
            x += tmp___7;
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 877
      if ((int )*x == 58) {
#line 879
        x ++;
        {
#line 880
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 880
          tmp___9 = __ctype_b_loc();
          }
#line 880
          if (! ((int const   )*(*tmp___9 + (int )*x) & 8192)) {
#line 880
            goto while_break___2;
          }
#line 882
          x ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 885
        tmp___10 = sscanf((char const   */* __restrict  */)x, (char const   */* __restrict  */)"if %128s",
                          file___0);
        }
#line 885
        if (tmp___10 != 1) {
          {
#line 885
          tmp___11 = sscanf((char const   */* __restrict  */)x, (char const   */* __restrict  */)"%128s",
                            file___0);
          }
#line 885
          if (tmp___11 != 1) {
#line 888
            goto while_continue;
          }
        }
        {
#line 891
        tmp___12 = find((char const   *)(file___0));
        }
#line 891
        if (! tmp___12) {
#line 893
          goto while_continue;
        }
        {
#line 898
        tmp___13 = strlen((char const   *)x);
#line 898
        cmd->cmd = makeStrStatic((char const   *)x, (int )tmp___13);
        }
#line 900
        if ((unsigned long )cmd->cmd == (unsigned long )((char const   *)0)) {
#line 902
          goto while_continue;
        }
      } else {
        {
#line 907
        D((char *)"No column? (%s)\n", x);
        }
#line 908
        goto while_continue;
      }
#line 911
      if (prev_cmd) {
#line 914
        prev_cmd->pNext = cmd;
      } else {
#line 919
        handler->cmds = cmd;
      }
#line 922
      prev_cmd = cmd;
    } else {
#line 752
      if (seen_commands) {
#line 757
        if (handler->cmds) {
#line 757
          if (handler->types) {
#line 761
            if (prev_handler) {
#line 764
              prev_handler->pNext = handler;
            } else {
#line 769
              handlers = handler;
            }
#line 772
            prev_handler = handler;
#line 774
            num_handlers ++;
          } else {
            {
#line 781
            D((char *)"previous handler has no commands, so dropped\n");
            }
          }
        } else {
          {
#line 781
          D((char *)"previous handler has no commands, so dropped\n");
          }
        }
        {
#line 784
        D((char *)"------------ Starting new handler ---------\n");
#line 786
        tmp___2 = allocStaticMem((int )sizeof(handler_t ));
#line 786
        handler = (handler_t *)tmp___2;
        }
#line 787
        if ((unsigned long )handler == (unsigned long )((handler_t *)0)) {
#line 789
          return;
        }
        {
#line 791
        memset((void *)handler, 0, sizeof(handler_t ));
#line 793
        prev_type = (mimetype_t *)((void *)0);
#line 794
        prev_cmd = (command_t *)((void *)0);
#line 796
        seen_commands = 0;
        }
      }
      {
#line 799
      D((char *)"New mime type\n");
#line 801
      tmp___3 = allocStaticMem((int )sizeof(mimetype_t ));
#line 801
      type = (mimetype_t *)tmp___3;
      }
#line 802
      if ((unsigned long )type == (unsigned long )((mimetype_t *)0)) {
#line 804
        goto while_continue;
      }
      {
#line 806
      memset((void *)type, 0, sizeof(mimetype_t ));
#line 811
      tmp___4 = strlen((char const   *)(buffer));
#line 811
      type->type = makeStrStatic((char const   *)(buffer), (int )tmp___4);
      }
#line 813
      if ((unsigned long )type->type == (unsigned long )((char const   *)0)) {
#line 815
        goto while_continue;
      }
#line 818
      if (prev_type) {
#line 821
        prev_type->pNext = type;
      } else {
#line 826
        handler->types = type;
      }
#line 829
      prev_type = type;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 926
  if (handler->cmds) {
#line 926
    if (handler->types) {
#line 928
      if (prev_handler) {
#line 930
        prev_handler->pNext = handler;
      } else {
#line 934
        handlers = handler;
      }
#line 936
      num_handlers ++;
    } else {
      {
#line 943
      D((char *)"previous handler has no commands, so dropped\n");
      }
    }
  } else {
    {
#line 943
    D((char *)"previous handler has no commands, so dropped\n");
    }
  }
  {
#line 946
  D((char *)"Num handlers: %d\n", num_handlers);
  }
#line 947
  return;
}
}
#line 959 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static int find_helper_file(char const   *basename , int (*cb)(char const   * ) ) 
{ 
  char fname[16384] ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 964
  D((char *)"find_helper_file \'%s\'\n", basename);
#line 966
  tmp = getenv("MOZPLUGGER_HOME");
  }
#line 966
  if (tmp) {
    {
#line 968
    snprintf((char */* __restrict  */)(fname), sizeof(fname), (char const   */* __restrict  */)"%s/%s",
             tmp, basename);
#line 969
    tmp___0 = (*cb)((char const   *)(fname));
    }
#line 969
    if (tmp___0) {
#line 971
      return (1);
    }
  }
  {
#line 975
  tmp = getenv("HOME");
  }
#line 975
  if (tmp) {
    {
#line 977
    snprintf((char */* __restrict  */)(fname), sizeof(fname), (char const   */* __restrict  */)"%s/.mozplugger/%s",
             tmp, basename);
#line 978
    tmp___1 = (*cb)((char const   *)(fname));
    }
#line 978
    if (tmp___1) {
#line 980
      return (1);
    }
    {
#line 983
    snprintf((char */* __restrict  */)(fname), sizeof(fname), (char const   */* __restrict  */)"%s/.netscape/%s",
             tmp, basename);
#line 984
    tmp___2 = (*cb)((char const   *)(fname));
    }
#line 984
    if (tmp___2) {
#line 986
      return (1);
    }
    {
#line 989
    snprintf((char */* __restrict  */)(fname), sizeof(fname), (char const   */* __restrict  */)"%s/.mozilla/%s",
             tmp, basename);
#line 990
    tmp___3 = (*cb)((char const   *)(fname));
    }
#line 990
    if (tmp___3) {
#line 992
      return (1);
    }
    {
#line 995
    snprintf((char */* __restrict  */)(fname), sizeof(fname), (char const   */* __restrict  */)"%s/.opera/%s",
             tmp, basename);
#line 996
    tmp___4 = (*cb)((char const   *)(fname));
    }
#line 996
    if (tmp___4) {
#line 998
      return (1);
    }
  }
  {
#line 1002
  tmp = getenv("MOZILLA_HOME");
  }
#line 1002
  if (tmp) {
    {
#line 1004
    snprintf((char */* __restrict  */)(fname), sizeof(fname), (char const   */* __restrict  */)"%s/%s",
             tmp, basename);
#line 1005
    tmp___5 = (*cb)((char const   *)(fname));
    }
#line 1005
    if (tmp___5) {
#line 1007
      return (1);
    }
  }
  {
#line 1011
  tmp = getenv("OPERA_DIR");
  }
#line 1011
  if (tmp) {
    {
#line 1013
    snprintf((char */* __restrict  */)(fname), sizeof(fname), (char const   */* __restrict  */)"%s/%s",
             tmp, basename);
#line 1014
    tmp___6 = (*cb)((char const   *)(fname));
    }
#line 1014
    if (tmp___6) {
#line 1016
      return (1);
    }
  }
  {
#line 1021
  snprintf((char */* __restrict  */)(fname), sizeof(fname), (char const   */* __restrict  */)"/usr/local/etc/%s",
           basename);
#line 1022
  tmp___7 = (*cb)((char const   *)(fname));
  }
#line 1022
  if (tmp___7) {
#line 1024
    return (1);
  }
  {
#line 1040
  snprintf((char */* __restrict  */)(fname), sizeof(fname), (char const   */* __restrict  */)"/usr/local/mozilla/%s",
           basename);
#line 1041
  tmp___8 = (*cb)((char const   *)(fname));
  }
#line 1041
  if (tmp___8) {
#line 1043
    return (1);
  }
  {
#line 1046
  snprintf((char */* __restrict  */)(fname), sizeof(fname), (char const   */* __restrict  */)"/usr/local/netscape/%s",
           basename);
#line 1047
  tmp___9 = (*cb)((char const   *)(fname));
  }
#line 1047
  if (tmp___9) {
#line 1049
    return (1);
  }
  {
#line 1052
  tmp___10 = (*cb)(basename);
  }
#line 1052
  if (tmp___10) {
#line 1054
    return (1);
  }
#line 1057
  return (0);
}
}
#line 1070 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static int read_config_cb(char const   *fname ) 
{ 
  int m4out[2] ;
  pid_t pid___1 ;
  int fd ;
  FILE *fp ;
  int tmp ;
  int status ;
  union __anonunion_162 __constr_expr_0 ;
  union __anonunion_163 __constr_expr_1 ;
  size_t tmp___0 ;

  {
  {
#line 1077
  fd = open(fname, 0);
  }
#line 1078
  if (fd < 0) {
    {
#line 1081
    D((char *)"READ_CONFIG(%s) - could not open\n", fname);
    }
#line 1082
    return (0);
  }
  {
#line 1084
  D((char *)"READ_CONFIG(%s) - file opened\n", fname);
#line 1086
  tmp = pipe((int *)(m4out));
  }
#line 1086
  if (tmp < 0) {
    {
#line 1088
    D((char *)"Failed to create pipe\n");
#line 1089
    perror("pipe");
    }
#line 1090
    return (0);
  }
  {
#line 1093
  pid___1 = fork();
  }
#line 1093
  if (pid___1 == -1) {
    {
#line 1095
    D((char *)"Failed to fork\n");
    }
#line 1096
    return (0);
  }
#line 1099
  if (! pid___1) {
    {
#line 1101
    close(m4out[0]);
#line 1103
    dup2(m4out[1], 1);
#line 1104
    close(m4out[1]);
#line 1106
    dup2(fd, 0);
#line 1107
    close(fd);
#line 1109
    execlp("m4", "m4", (void *)0);
#line 1110
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MozPlugger: Error: Failed to execute m4.\n");
#line 1111
    exit(1);
    }
  } else {
    {
#line 1116
    close(m4out[1]);
#line 1117
    close(fd);
#line 1119
    fp = fdopen(m4out[0], "r");
    }
#line 1120
    if (! fp) {
      {
#line 1122
      D((char *)"Failed to open pipe\n");
      }
#line 1123
      return (0);
    }
    {
#line 1125
    read_config(fp);
#line 1126
    fclose(fp);
#line 1129
    waitpid(pid___1, & status, 0);
#line 1130
    __constr_expr_0.__in = status;
#line 1130
    D((char *)"M4 exit status was %i\n", (__constr_expr_0.__i & 65280) >> 8);
#line 1132
    __constr_expr_1.__in = status;
    }
#line 1132
    if ((__constr_expr_1.__i & 65280) >> 8 != 0) {
      {
#line 1134
      errMsg = "Mozplugger: M4 parsing of config generated error";
#line 1135
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              errMsg);
#line 1136
      D((char *)"%s\n", errMsg);
      }
    }
    {
#line 1141
    tmp___0 = strlen(fname);
#line 1141
    config_fname = makeStrStatic(fname, (int )tmp___0);
    }
  }
#line 1144
  return (1);
}
}
#line 1158 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static int find_plugger_helper_cb(char const   *fname ) 
{ 
  struct stat buf ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 1160
  D((char *)"FIND_HELPER(%s)\n", fname);
#line 1163
  tmp = stat((char const   */* __restrict  */)fname, (struct stat */* __restrict  */)(& buf));
  }
#line 1163
  if (tmp != 0) {
#line 1165
    return (0);
  }
  {
#line 1169
  tmp___0 = strlen(fname);
#line 1169
  helper_fname = makeStrStatic(fname, (int )tmp___0);
  }
#line 1171
  return (1);
}
}
#line 1185 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static int find_plugger_controller_cb(char const   *fname ) 
{ 
  struct stat buf ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 1188
  tmp = stat((char const   */* __restrict  */)fname, (struct stat */* __restrict  */)(& buf));
  }
#line 1188
  if (tmp != 0) {
#line 1190
    return (0);
  }
  {
#line 1195
  tmp___0 = strlen(fname);
#line 1195
  controller_fname = makeStrStatic(fname, (int )tmp___0);
  }
#line 1197
  return (1);
}
}
#line 1211 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static int find_plugger_linker_cb(char const   *fname ) 
{ 
  struct stat buf ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 1214
  tmp = stat((char const   */* __restrict  */)fname, (struct stat */* __restrict  */)(& buf));
  }
#line 1214
  if (tmp != 0) {
#line 1216
    return (0);
  }
  {
#line 1220
  tmp___0 = strlen(fname);
#line 1220
  linker_fname = makeStrStatic(fname, (int )tmp___0);
  }
#line 1222
  return (1);
}
}
#line 1234 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static void do_read_config(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1236
  if (handlers) {
#line 1238
    return;
  }
  {
#line 1241
  D((char *)"do_read_config\n");
#line 1243
  tmp = find_helper_file("mozpluggerrc", & read_config_cb);
  }
#line 1243
  if (! tmp) {
    {
#line 1245
    errMsg = "Mozplugger: Installation error - failed to locate mozpluggerrc";
#line 1246
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            errMsg);
#line 1247
    D((char *)"%s\n", errMsg);
    }
#line 1248
    return;
  }
  {
#line 1251
  tmp___1 = find_helper_file("mozplugger-helper", & find_plugger_helper_cb);
  }
#line 1251
  if (! tmp___1) {
    {
#line 1253
    tmp___0 = find("mozplugger-helper");
    }
#line 1253
    if (tmp___0) {
#line 1255
      helper_fname = "mozplugger-helper";
    } else {
      {
#line 1259
      errMsg = "Mozplugger: Installation error - failed to locate mozplugger-helper";
#line 1260
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              errMsg);
#line 1261
      D((char *)"%s\n", errMsg);
      }
#line 1262
      return;
    }
  }
  {
#line 1266
  tmp___3 = find_helper_file("mozplugger-controller", & find_plugger_controller_cb);
  }
#line 1266
  if (! tmp___3) {
    {
#line 1268
    tmp___2 = find("mozplugger-controller");
    }
#line 1268
    if (tmp___2) {
#line 1270
      controller_fname = "mozplugger-controller";
    } else {
      {
#line 1274
      errMsg = "Mozplugger: Installation error - failed to locate mozplugger-controller";
#line 1275
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              errMsg);
#line 1276
      D((char *)"%s\n", errMsg);
      }
#line 1277
      return;
    }
  }
  {
#line 1281
  tmp___5 = find_helper_file("mozplugger-linker", & find_plugger_linker_cb);
  }
#line 1281
  if (! tmp___5) {
    {
#line 1283
    tmp___4 = find("mozplugger-linker");
    }
#line 1283
    if (tmp___4) {
#line 1285
      linker_fname = "mozplugger-linker";
    } else {
      {
#line 1289
      errMsg = "Mozplugger: Installation error - failed to locate mozplugger-linker";
#line 1290
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              errMsg);
#line 1291
      D((char *)"%s\n", errMsg);
      }
#line 1292
      return;
    }
  }
  {
#line 1296
  D((char *)"do_read_config done\n");
  }
#line 1297
  return;
}
}
#line 1310 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static int safeName(char const   *name , int isURL ) 
{ 
  int i ;
  int len ;
  size_t tmp ;

  {
  {
#line 1312
  i = 0;
#line 1313
  tmp = strlen(name);
#line 1313
  len = (int )tmp;
  }
#line 1315
  if ((int const   )*(name + 0) == 47) {
#line 1315
    if (isURL) {
      {
#line 1317
      D((char *)"safeName() - reject URL \'%s\' as starts with \'/\'\n", name);
      }
#line 1318
      return (0);
    }
  }
#line 1321
  i = 0;
  {
#line 1321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1321
    if (! (i < len)) {
#line 1321
      goto while_break;
    }
#line 1323
    if ((int const   )*(name + i) == 96) {
      {
#line 1325
      D((char *)"safeName() - reject \'%s\' as contains either \';\' or \'`\'\n",
        name);
      }
#line 1327
      return (0);
    } else
#line 1323
    if ((int const   )*(name + i) == 59) {
      {
#line 1325
      D((char *)"safeName() - reject \'%s\' as contains either \';\' or \'`\'\n",
        name);
      }
#line 1327
      return (0);
    }
#line 1321
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1330
  return (1);
}
}
#line 1347 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static void parseHeaders(data_t * const  THIS , char const   *headers , char *fileName ,
                         int maxFileNameLen ) 
{ 
  char const   *p ;
  size_t len ;
  size_t tmp ;
  char const   *start ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
#line 1350
  p = headers;
#line 1352
  if (! headers) {
#line 1354
    return;
  }
  {
#line 1357
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1357
    tmp___2 = strstr(p, "Content-Disposition:");
#line 1357
    p = (char const   *)tmp___2;
    }
#line 1357
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 1357
      goto while_break;
    }
    {
#line 1359
    tmp = strcspn(p, "\n\r");
#line 1359
    len = tmp;
#line 1360
    tmp___0 = strstr(p, "filename=\"");
#line 1360
    start = (char const   *)tmp___0;
    }
#line 1362
    if (len == 0UL) {
#line 1364
      goto while_break;
    }
#line 1367
    if ((unsigned long )start == (unsigned long )((char const   *)0)) {
#line 1369
      p += len;
#line 1370
      goto while_continue;
    } else
#line 1367
    if ((size_t )(start - p) > len) {
#line 1369
      p += len;
#line 1370
      goto while_continue;
    }
    {
#line 1372
    tmp___1 = strlen("filename=\"");
#line 1372
    start += tmp___1;
#line 1373
    len = (len - (size_t )(start - p)) - 1UL;
    }
#line 1375
    if (len > 0UL) {
      {
#line 1377
      strncpy((char */* __restrict  */)fileName, (char const   */* __restrict  */)start,
              len);
#line 1378
      *(fileName + len) = (char )'\000';
      }
    }
#line 1380
    p += len;
  }
  while_break: /* CIL Label */ ;
  }
#line 1382
  return;
}
}
#line 1398 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static void parseURL(data_t * const  THIS , char const   *url , char *fileName , int maxFileNameLen ) 
{ 
  char const   *frag ;
  char *tmp ;
  char const   *end ;
  char *tmp___0 ;
  char const   *start ;
  int len ;
  size_t tmp___1 ;

  {
  {
#line 1401
  tmp = strchr(url, '#');
#line 1401
  frag = (char const   *)tmp;
  }
#line 1403
  if (frag) {
#line 1405
    if (THIS->urlFragment) {
      {
#line 1407
      D((char *)"parseURL - replacing previous fragment\n");
#line 1408
      NPN_MemFree((void *)THIS->urlFragment);
      }
    }
    {
#line 1411
    D((char *)"parseURL - fragment \'%s\' found at end of URL\n", frag + 1);
#line 1412
    THIS->urlFragment = NP_strdup(frag + 1);
    }
  }
#line 1415
  if (fileName) {
    {
#line 1417
    tmp___0 = strrchr(url, '?');
#line 1417
    end = (char const   *)tmp___0;
    }
#line 1422
    if (! end) {
#line 1424
      if (frag) {
#line 1426
        end = frag;
      } else {
        {
#line 1430
        tmp___1 = strlen(url);
#line 1430
        end = url + tmp___1;
        }
      }
    }
#line 1434
    start = end + -1;
    {
#line 1435
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1435
      if ((unsigned long )start > (unsigned long )url) {
#line 1435
        if (! ((int const   )*start != 47)) {
#line 1435
          goto while_break;
        }
      } else {
#line 1435
        goto while_break;
      }
#line 1437
      start --;
    }
    while_break: /* CIL Label */ ;
    }
#line 1439
    if ((int const   )*start == 47) {
#line 1441
      start ++;
    }
#line 1443
    len = (int )(end - start);
#line 1444
    if (len > maxFileNameLen) {
#line 1446
      start = end - maxFileNameLen;
#line 1447
      len = maxFileNameLen;
    }
    {
#line 1449
    strncpy((char */* __restrict  */)fileName, (char const   */* __restrict  */)start,
            (size_t )len);
#line 1450
    *(fileName + len) = (char )'\000';
    }
  }
#line 1452
  return;
}
}
#line 1464 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
__inline static int match_url(char const   *matchStr , char const   *url ) 
{ 
  int matchStrLen ;
  char const   *end ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 1472
  if ((int const   )*(matchStr + 0) == 42) {
#line 1472
    goto case_42;
  }
#line 1477
  if ((int const   )*(matchStr + 0) == 37) {
#line 1477
    goto case_37;
  }
#line 1499
  goto switch_default;
  case_42: /* CIL Label */ 
  {
#line 1474
  matchStr ++;
#line 1475
  tmp = strlen(matchStr);
#line 1475
  tmp___0 = strncasecmp(matchStr, url, tmp);
  }
#line 1475
  return (tmp___0 == 0);
  case_37: /* CIL Label */ 
  {
#line 1479
  matchStr ++;
#line 1483
  tmp___1 = strchr(url, '?');
#line 1483
  end = (char const   *)tmp___1;
  }
#line 1484
  if ((unsigned long )end == (unsigned long )((void *)0)) {
    {
#line 1486
    tmp___2 = strchr(url, '#');
#line 1486
    end = (char const   *)tmp___2;
    }
#line 1487
    if ((unsigned long )end == (unsigned long )((void *)0)) {
      {
#line 1489
      tmp___3 = strlen(url);
#line 1489
      end = url + tmp___3;
      }
    }
  }
  {
#line 1492
  tmp___4 = strlen(matchStr);
#line 1492
  matchStrLen = (int )tmp___4;
  }
#line 1493
  if ((unsigned long )(end - matchStrLen) < (unsigned long )url) {
#line 1495
    return (0);
  }
  {
#line 1497
  tmp___5 = strncasecmp(matchStr, end - matchStrLen, (size_t )matchStrLen);
  }
#line 1497
  return (tmp___5 == 0);
  switch_default: /* CIL Label */ 
  {
#line 1501
  tmp___6 = strstr(url, matchStr);
  }
#line 1501
  return ((unsigned long )tmp___6 != (unsigned long )((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1517 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
__inline static int match_command(data_t * const  THIS , int streamOnly , command_t *c ) 
{ 
  int tmp ;

  {
  {
#line 1522
  D((char *)"Checking command: %s\n", c->cmd);
  }
#line 1525
  if ((unsigned int )c->flags & 8288U) {
#line 1528
    if ((THIS->mode_flags & 8288U) != ((unsigned int )c->flags & 8288U)) {
      {
#line 1530
      D((char *)"Flag mismatch: mode different %x != %x\n", THIS->mode_flags & 8288U,
        (unsigned int )c->flags & 8288U);
      }
#line 1532
      return (0);
    }
  }
#line 1536
  if ((unsigned int )c->flags & 1U) {
#line 1536
    if (THIS->repeats != 2147483647) {
      {
#line 1538
      D((char *)"Flag mismatch: loop\n");
      }
#line 1539
      return (0);
    }
  }
#line 1541
  if (streamOnly) {
#line 1541
    if (! ((unsigned int )c->flags & 4U)) {
      {
#line 1543
      D((char *)"Flag mismatch: stream only required\n");
      }
#line 1544
      return (0);
    }
  }
#line 1547
  if (c->fmatchStr) {
    {
#line 1549
    tmp = match_url(c->fmatchStr, (char const   *)THIS->url);
    }
#line 1549
    if (! tmp) {
      {
#line 1551
      D((char *)"fmatch mismatch: url \'%s\' doesnt have \'%s\'\n", THIS->url, c->fmatchStr);
      }
#line 1553
      return (0);
    }
  }
  {
#line 1556
  D((char *)"Match found!\n");
  }
#line 1557
  return (1);
}
}
#line 1571 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
__inline static int match_mime_type(data_t * const  THIS , mimetype_t *m ) 
{ 
  char mimetype[128] ;
  int retVal ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 1575
  sscanf((char const   */* __restrict  */)m->type, (char const   */* __restrict  */)"%128[^:]",
         mimetype);
#line 1576
  sscanf((char const   */* __restrict  */)(mimetype), (char const   */* __restrict  */)"%s",
         mimetype);
#line 1579
  tmp = strcasecmp((char const   *)(mimetype), (char const   *)THIS->mimetype);
  }
#line 1579
  if (tmp != 0) {
    {
#line 1579
    tmp___0 = strcmp((char const   *)(mimetype), "*");
    }
#line 1579
    if (tmp___0 != 0) {
#line 1582
      retVal = 0;
    } else {
#line 1586
      retVal = 1;
    }
  } else {
#line 1586
    retVal = 1;
  }
#line 1588
  if (retVal == 1) {
#line 1588
    tmp___1 = "same";
  } else {
#line 1588
    tmp___1 = "different";
  }
  {
#line 1588
  D((char *)"Checking \'%s\' ?= \'%s\', %s\n", mimetype, THIS->mimetype, tmp___1);
  }
#line 1590
  return (retVal);
}
}
#line 1604 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
__inline static int match_handler(handler_t *h , data_t * const  THIS , int streamOnly ) 
{ 
  mimetype_t *m ;
  command_t *c ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1610
  D((char *)"-------------------------------------------\n");
#line 1611
  D((char *)"Commands for this handle at (%p):\n", h->cmds);
#line 1613
  m = h->types;
  }
  {
#line 1614
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1614
    if (! m) {
#line 1614
      goto while_break;
    }
    {
#line 1616
    tmp___0 = match_mime_type(THIS, m);
    }
#line 1616
    if (tmp___0) {
#line 1618
      c = h->cmds;
      {
#line 1619
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1619
        if (! c) {
#line 1619
          goto while_break___0;
        }
        {
#line 1621
        tmp = match_command(THIS, streamOnly, c);
        }
#line 1621
        if (tmp) {
#line 1623
          THIS->cmd_flags = (unsigned int )c->flags;
#line 1624
          THIS->command = c->cmd;
#line 1625
          THIS->winname = c->winname;
#line 1626
          return (1);
        }
#line 1628
        c = c->pNext;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1631
    m = m->pNext;
  }
  while_break: /* CIL Label */ ;
  }
#line 1633
  return (0);
}
}
#line 1646 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static int find_command(data_t * const  THIS , int streamOnly ) 
{ 
  handler_t *h ;
  int tmp ;

  {
  {
#line 1650
  D((char *)"find_command...\n");
#line 1653
  THIS->command = (char const   *)0;
#line 1654
  THIS->cmd_flags = 0U;
#line 1655
  THIS->winname = (char const   *)0;
#line 1657
  do_read_config();
#line 1659
  h = handlers;
  }
  {
#line 1660
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1660
    if (! h) {
#line 1660
      goto while_break;
    }
    {
#line 1662
    tmp = match_handler(h, THIS, streamOnly);
    }
#line 1662
    if (tmp) {
      {
#line 1664
      D((char *)"Command found.\n");
      }
#line 1665
      return (1);
    }
#line 1667
    h = h->pNext;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1670
  D((char *)"No command found.\n");
  }
#line 1671
  return (0);
}
}
#line 1683 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
char const   *NPP_GetMIMEDescription(void) 
{ 
  char *x ;
  char *y ;
  handler_t *h ;
  mimetype_t *m ;
  int size_required ;
  int free___0 ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 1690
  D((char *)"NPP_GetMIMEDescription()\n");
#line 1692
  do_read_config();
#line 1695
  free___0 = 65536 - staticPoolIdx;
#line 1696
  D((char *)"Static Pool used=%i, free=%i\n", staticPoolIdx, free___0);
#line 1699
  size_required = 0;
#line 1701
  h = handlers;
  }
  {
#line 1702
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1702
    if (! h) {
#line 1702
      goto while_break;
    }
#line 1704
    m = h->types;
    {
#line 1705
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1705
      if (! m) {
#line 1705
        goto while_break___0;
      }
      {
#line 1707
      tmp = strlen(m->type);
#line 1707
      size_required = (int )((size_t )size_required + (tmp + 1UL));
#line 1708
      m = m->pNext;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1710
    h = h->pNext;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1713
  D((char *)"Size required=%d\n", size_required);
#line 1715
  tmp___0 = malloc((size_t )(size_required + 1));
#line 1715
  x = (char *)tmp___0;
  }
#line 1715
  if (! x) {
#line 1717
    return ((char const   *)0);
  }
  {
#line 1720
  D((char *)"Malloc did not fail\n");
#line 1722
  y = x;
#line 1724
  h = handlers;
  }
  {
#line 1725
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1725
    if (! h) {
#line 1725
      goto while_break___1;
    }
#line 1727
    m = h->types;
    {
#line 1728
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1728
      if (! m) {
#line 1728
        goto while_break___2;
      }
      {
#line 1730
      tmp___1 = strlen(m->type);
#line 1730
      memcpy((void */* __restrict  */)y, (void const   */* __restrict  */)m->type,
             tmp___1);
#line 1731
      tmp___2 = strlen(m->type);
#line 1731
      y += tmp___2;
#line 1732
      tmp___3 = y;
#line 1732
      y ++;
#line 1732
      *tmp___3 = (char )';';
#line 1733
      m = m->pNext;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1735
    h = h->pNext;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1737
  if ((unsigned long )x != (unsigned long )y) {
#line 1739
    y --;
  }
  {
#line 1741
  tmp___4 = y;
#line 1741
  y ++;
#line 1741
  *tmp___4 = (char)0;
#line 1743
  D((char *)"Getmimedescription done: %s\n", x);
  }
#line 1745
  return ((char const   *)x);
}
}
#line 1755 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static void debugLogIdentifier(NPIdentifier name ) 
{ 
  char *str ;
  NPUTF8 *tmp ;
  char const   *tmp___0 ;
  int32_t tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 1757
  tmp___2 = NPN_IdentifierIsString(name);
  }
#line 1757
  if (tmp___2) {
    {
#line 1759
    tmp = NPN_UTF8FromIdentifier(name);
#line 1759
    str = tmp;
    }
#line 1760
    if (str) {
#line 1760
      tmp___0 = (char const   *)str;
    } else {
#line 1760
      tmp___0 = "NULL";
    }
    {
#line 1760
    D((char *)"NPIdentifier = %s\n", tmp___0);
#line 1761
    NPN_MemFree((void *)str);
    }
  } else {
    {
#line 1765
    tmp___1 = NPN_IntFromIdentifier(name);
#line 1765
    D((char *)"NPIdentifier = %i\n", tmp___1);
    }
  }
#line 1767
  return;
}
}
#line 1776 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
_Bool NPP_HasMethod(NPObject *npobj , NPIdentifier name ) 
{ 


  {
  {
#line 1778
  D((char *)"NPP_HasMethod called\n");
#line 1779
  debugLogIdentifier(name);
  }
#line 1781
  return ((_Bool)0);
}
}
#line 1791 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
_Bool NPP_Invoke(NPObject *npobj , NPIdentifier name , NPVariant const   *args , uint32_t argCount ,
                 NPVariant *result ) 
{ 


  {
  {
#line 1794
  D((char *)"NPP_Invoke called\n");
#line 1795
  debugLogIdentifier(name);
  }
#line 1797
  return ((_Bool)0);
}
}
#line 1807 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
_Bool NPP_HasProperty(NPObject *npobj , NPIdentifier name ) 
{ 
  _Bool retVal ;
  char *str ;
  NPUTF8 *tmp ;
  int tmp___0 ;

  {
  {
#line 1809
  retVal = (_Bool)0;
#line 1811
  D((char *)"NPP_HasProperty called\n");
#line 1812
  debugLogIdentifier(name);
#line 1814
  tmp = NPN_UTF8FromIdentifier(name);
#line 1814
  str = tmp;
  }
#line 1815
  if (str) {
    {
#line 1817
    tmp___0 = strcasecmp("isplaying", (char const   *)str);
    }
#line 1817
    if (tmp___0 == 0) {
#line 1819
      retVal = (_Bool)1;
    }
    {
#line 1821
    NPN_MemFree((void *)str);
    }
  }
#line 1823
  return (retVal);
}
}
#line 1833 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
_Bool NPP_GetProperty(NPObject *npobj , NPIdentifier name , NPVariant *result ) 
{ 
  _Bool retVal ;
  char *str ;
  NPUTF8 *tmp ;
  NPP instance ;
  data_t *THIS ;
  int status ;
  __pid_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1835
  retVal = (_Bool)0;
#line 1837
  D((char *)"NPP_GetProperty called\n");
#line 1838
  debugLogIdentifier(name);
#line 1840
  tmp = NPN_UTF8FromIdentifier(name);
#line 1840
  str = tmp;
  }
#line 1841
  if (str) {
    {
#line 1843
    tmp___1 = strcasecmp("isplaying", (char const   *)str);
    }
#line 1843
    if (tmp___1 == 0) {
#line 1845
      result->type = (NPVariantType )2;
#line 1846
      result->value.boolValue = (_Bool)0;
#line 1847
      retVal = (_Bool)1;
#line 1849
      instance = ((our_NPObject_t *)npobj)->assocInstance;
#line 1850
      if (instance) {
#line 1852
        THIS = (data_t *)instance->pdata;
#line 1853
        if (THIS) {
#line 1855
          if (THIS->commsPipeFd >= 0) {
#line 1855
            goto _L;
          } else
#line 1855
          if (THIS->pid > -1) {
            _L: /* CIL Label */ 
            {
#line 1858
            tmp___0 = waitpid(THIS->pid, & status, 1);
            }
#line 1858
            if (tmp___0 == 0) {
#line 1862
              result->value.boolValue = (_Bool)1;
            }
          }
        }
      }
    }
    {
#line 1868
    NPN_MemFree((void *)str);
    }
  }
#line 1870
  return (retVal);
}
}
#line 1880 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
_Bool NPP_SetProperty(NPObject *npobj , NPIdentifier name , NPVariant const   *value ) 
{ 


  {
  {
#line 1883
  D((char *)"NPP_SetProperty called\n");
#line 1884
  debugLogIdentifier(name);
  }
#line 1886
  return ((_Bool)0);
}
}
#line 1896 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static char const   *getPluginName(void) 
{ 


  {
#line 1898
  return ("MozPlugger 1.14.5 handles QuickTime and Windows Media Player Plugin");
}
}
#line 1912 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static char desc_buffer[8192]  ;
#line 1910 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static char const   *getPluginDescription(void) 
{ 
  char const   *dbgPath ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;

  {
  {
#line 1913
  tmp = get_debug_path();
#line 1913
  dbgPath = (char const   *)tmp;
  }
#line 1915
  if (errMsg) {
#line 1915
    tmp___0 = errMsg;
  } else {
#line 1915
    tmp___0 = "";
  }
#line 1915
  if (dbgPath) {
#line 1915
    tmp___1 = "/mozdebug</td></tr> ";
  } else {
#line 1915
    tmp___1 = "";
  }
#line 1915
  if (dbgPath) {
#line 1915
    tmp___2 = dbgPath;
  } else {
#line 1915
    tmp___2 = "";
  }
#line 1915
  if (dbgPath) {
#line 1915
    tmp___3 = " <tr><td>Debug file:</td><td>";
  } else {
#line 1915
    tmp___3 = "";
  }
#line 1915
  if (linker_fname) {
#line 1915
    tmp___4 = linker_fname;
  } else {
#line 1915
    tmp___4 = "Not found!";
  }
#line 1915
  if (controller_fname) {
#line 1915
    tmp___5 = controller_fname;
  } else {
#line 1915
    tmp___5 = "Not found!";
  }
#line 1915
  if (helper_fname) {
#line 1915
    tmp___6 = helper_fname;
  } else {
#line 1915
    tmp___6 = "Not found!";
  }
#line 1915
  if (config_fname) {
#line 1915
    tmp___7 = config_fname;
  } else {
#line 1915
    tmp___7 = "Not found!";
  }
  {
#line 1915
  snprintf((char */* __restrict  */)(desc_buffer), sizeof(desc_buffer), (char const   */* __restrict  */)"MozPlugger version 1.14.5, maintained by Louis Bavoil and Peter Leese, a fork of plugger written by Fredrik H&uuml;binette.<br>For documentation on how to configure mozplugger, check the man page. (type <tt>man&nbsp;mozplugger</tt>) <table>  <tr><td>Configuration file:</td><td>%s</td></tr>  <tr><td>Helper binary:</td><td>%s</td></tr>  <tr><td>Controller binary:</td><td>%s</td></tr>  <tr><td>Link launcher binary:</td><td>%s</td></tr> %s%s%s </table> %s<br clear=all>",
           tmp___7, tmp___6, tmp___5, tmp___4, tmp___3, tmp___2, tmp___1, tmp___0);
#line 1942
  errMsg = (char const   *)((void *)0);
  }
#line 1943
  return ((char const   *)(desc_buffer));
}
}
#line 1953 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static NPBool getPluginNeedsXembed(NPP instance , NPError *pErr ) 
{ 
  data_t *this ;

  {
#line 1957
  if ((unsigned long )instance == (unsigned long )((void *)0)) {
#line 1959
    *pErr = (NPError )1;
#line 1960
    return ((NPBool )0);
  }
#line 1963
  this = (data_t *)instance->pdata;
#line 1964
  if ((unsigned long )this == (unsigned long )((void *)0)) {
#line 1966
    *pErr = (NPError )1;
#line 1967
    return ((NPBool )0);
  }
#line 1970
  if ((this->cmd_flags & 2048U) != 0U) {
#line 1970
    if (browserSupportsXEmbed) {
      {
#line 1972
      D((char *)"Plugin needs XEmbed\n");
      }
#line 1973
      return ((NPBool )1);
    } else {
      {
#line 1977
      D((char *)"Plugin does not need XEmbed\n");
      }
#line 1978
      return ((NPBool )0);
    }
  } else {
    {
#line 1977
    D((char *)"Plugin does not need XEmbed\n");
    }
#line 1978
    return ((NPBool )0);
  }
}
}
#line 1989 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static NPObject *NPP_AllocateObj(NPP instance , NPClass *aClass ) 
{ 
  our_NPObject_t *pObj ;
  void *tmp ;

  {
  {
#line 1991
  tmp = NPN_MemAlloc((uint32_t )sizeof(our_NPObject_t ));
#line 1991
  pObj = (our_NPObject_t *)tmp;
#line 1992
  pObj->assocInstance = instance;
  }
#line 1993
  return ((NPObject *)pObj);
}
}
#line 2003 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static NPObject *getPluginScritableObject(NPP instance , NPError *pErr ) 
{ 
  NPObject *tmp ;

  {
#line 2005
  if ((unsigned long )instance == (unsigned long )((NPP )0)) {
#line 2007
    *pErr = (NPError )1;
#line 2008
    return ((NPObject *)0);
  }
  {
#line 2011
  D((char *)"Scritable object created..\n");
#line 2012
  memset((void *)(& pluginClass), 0, sizeof(NPClass ));
#line 2014
  pluginClass.structVersion = (uint32_t )3;
#line 2016
  pluginClass.allocate = & NPP_AllocateObj;
#line 2017
  pluginClass.hasMethod = & NPP_HasMethod;
#line 2018
  pluginClass.invoke = & NPP_Invoke;
#line 2019
  pluginClass.hasProperty = & NPP_HasProperty;
#line 2020
  pluginClass.getProperty = & NPP_GetProperty;
#line 2021
  pluginClass.setProperty = & NPP_SetProperty;
#line 2023
  tmp = NPN_CreateObject(instance, & pluginClass);
  }
#line 2023
  return (tmp);
}
}
#line 2044 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
NPError NPP_GetValue(void *instance , NPPVariable variable , void *value ) 
{ 
  NPError err ;
  char const   *varName ;

  {
#line 2046
  err = (NPError )0;
  {
#line 2050
  if ((unsigned int )variable == 1U) {
#line 2050
    goto case_1;
  }
#line 2055
  if ((unsigned int )variable == 2U) {
#line 2055
    goto case_2;
  }
#line 2060
  if ((unsigned int )variable == 14U) {
#line 2060
    goto case_14;
  }
#line 2070
  if ((unsigned int )variable == 15U) {
#line 2070
    goto case_15;
  }
#line 2075
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2051
  D((char *)"NP_GetValue(NPPVpluginNameString)\n");
#line 2052
  *((char const   **)value) = getPluginName();
  }
#line 2053
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2056
  D((char *)"NP_GetValue(NPPVpluginDescriptionString)\n");
#line 2057
  *((char const   **)value) = getPluginDescription();
  }
#line 2058
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 2061
  D((char *)"NPP_GetValue(NPPVpluginNeedsXEmbed)\n");
#line 2066
  *((NPBool *)value) = getPluginNeedsXembed((NPP )instance, & err);
  }
#line 2068
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 2071
  D((char *)"NP_GetValue(NPPVpluginScriptableNPObject\n");
#line 2072
  *((NPObject **)value) = getPluginScritableObject((NPP )instance, & err);
  }
#line 2073
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2081
  if ((unsigned int )variable == 3U) {
#line 2081
    goto case_3;
  }
#line 2083
  if ((unsigned int )variable == 4U) {
#line 2083
    goto case_4;
  }
#line 2085
  if ((unsigned int )variable == 5U) {
#line 2085
    goto case_5;
  }
#line 2087
  if ((unsigned int )variable == 6U) {
#line 2087
    goto case_6;
  }
#line 2089
  if ((unsigned int )variable == 7U) {
#line 2089
    goto case_7;
  }
#line 2091
  if ((unsigned int )variable == 268435466U) {
#line 2091
    goto case_268435466;
  }
#line 2093
  if ((unsigned int )variable == 11U) {
#line 2093
    goto case_11;
  }
#line 2095
  if ((unsigned int )variable == 12U) {
#line 2095
    goto case_12;
  }
#line 2097
  if ((unsigned int )variable == 13U) {
#line 2097
    goto case_13;
  }
#line 2099
  if ((unsigned int )variable == 16U) {
#line 2099
    goto case_16;
  }
#line 2101
  if ((unsigned int )variable == 17U) {
#line 2101
    goto case_17;
  }
#line 2103
  if ((unsigned int )variable == 18U) {
#line 2103
    goto case_18;
  }
#line 2105
  if ((unsigned int )variable == 19U) {
#line 2105
    goto case_19;
  }
#line 2107
  if ((unsigned int )variable == 20U) {
#line 2107
    goto case_20;
  }
#line 2109
  if ((unsigned int )variable == 21U) {
#line 2109
    goto case_21;
  }
#line 2111
  if ((unsigned int )variable == 22U) {
#line 2111
    goto case_22;
  }
#line 2113
  goto switch_default___0;
  case_3: /* CIL Label */ 
#line 2082
  varName = "NPPVpluginWindowBool";
#line 2082
  goto switch_break___0;
  case_4: /* CIL Label */ 
#line 2084
  varName = "NPPVpluginTransparentBool";
#line 2084
  goto switch_break___0;
  case_5: /* CIL Label */ 
#line 2086
  varName = "NPPVjavaClass";
#line 2086
  goto switch_break___0;
  case_6: /* CIL Label */ 
#line 2088
  varName = "NPPVpluginWindowSize";
#line 2088
  goto switch_break___0;
  case_7: /* CIL Label */ 
#line 2090
  varName = "NPPVpluginTimerInterval";
#line 2090
  goto switch_break___0;
  case_268435466: /* CIL Label */ 
#line 2092
  varName = "NPPVpluginScriptableInstance";
#line 2092
  goto switch_break___0;
  case_11: /* CIL Label */ 
#line 2094
  varName = "NPPVpluginScriptableIID";
#line 2094
  goto switch_break___0;
  case_12: /* CIL Label */ 
#line 2096
  varName = "NPPVjavascriptPushCallerBool";
#line 2096
  goto switch_break___0;
  case_13: /* CIL Label */ 
#line 2098
  varName = "NPPVpluginKeepLibraryInMemory";
#line 2098
  goto switch_break___0;
  case_16: /* CIL Label */ 
#line 2100
  varName = "NPPVformValue";
#line 2100
  goto switch_break___0;
  case_17: /* CIL Label */ 
#line 2102
  varName = "NPPVpluginUrlRequestsDisplayedBool";
#line 2102
  goto switch_break___0;
  case_18: /* CIL Label */ 
#line 2104
  varName = "NPPVpluginWantsNetworkStreams";
#line 2104
  goto switch_break___0;
  case_19: /* CIL Label */ 
#line 2106
  varName = "NPPVpluginNativeAccessibleAtkPlugId";
#line 2106
  goto switch_break___0;
  case_20: /* CIL Label */ 
#line 2108
  varName = "NPPVpluginCancelSrcStream";
#line 2108
  goto switch_break___0;
  case_21: /* CIL Label */ 
#line 2110
  varName = "NPPVsupportsAdvancedKeyHandling";
#line 2110
  goto switch_break___0;
  case_22: /* CIL Label */ 
#line 2112
  varName = "NPPVpluginUsesDOMForCursorBool";
#line 2112
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 2114
  varName = "";
#line 2114
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 2116
  D((char *)"NPP_GetValue(\'%s\' - %d) not implemented\n", varName, (unsigned int )variable);
#line 2118
  err = (NPError )1;
  }
#line 2119
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2121
  return (err);
}
}
#line 2136 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
NPError NPP_SetValue(NPP instance , NPNVariable variable , void *value ) 
{ 
  NPError err ;

  {
#line 2138
  err = (NPError )0;
  {
#line 2142
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 2143
  D((char *)"NPP_SetValue( %d)  not implemented\n", (unsigned int )variable);
#line 2144
  err = (NPError )1;
  }
#line 2145
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2147
  return (err);
}
}
#line 2163 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static int my_atoi(char const   *s , int my_true , int my_false ) 
{ 
  int tmp ;

  {
  {
#line 2167
  if ((int const   )*(s + 0) == 89) {
#line 2167
    goto case_89;
  }
#line 2167
  if ((int const   )*(s + 0) == 121) {
#line 2167
    goto case_89;
  }
#line 2167
  if ((int const   )*(s + 0) == 84) {
#line 2167
    goto case_89;
  }
#line 2167
  if ((int const   )*(s + 0) == 116) {
#line 2167
    goto case_89;
  }
#line 2169
  if ((int const   )*(s + 0) == 78) {
#line 2169
    goto case_78;
  }
#line 2169
  if ((int const   )*(s + 0) == 110) {
#line 2169
    goto case_78;
  }
#line 2169
  if ((int const   )*(s + 0) == 70) {
#line 2169
    goto case_78;
  }
#line 2169
  if ((int const   )*(s + 0) == 102) {
#line 2169
    goto case_78;
  }
#line 2172
  if ((int const   )*(s + 0) == 57) {
#line 2172
    goto case_57;
  }
#line 2172
  if ((int const   )*(s + 0) == 56) {
#line 2172
    goto case_57;
  }
#line 2172
  if ((int const   )*(s + 0) == 55) {
#line 2172
    goto case_57;
  }
#line 2172
  if ((int const   )*(s + 0) == 54) {
#line 2172
    goto case_57;
  }
#line 2172
  if ((int const   )*(s + 0) == 53) {
#line 2172
    goto case_57;
  }
#line 2172
  if ((int const   )*(s + 0) == 52) {
#line 2172
    goto case_57;
  }
#line 2172
  if ((int const   )*(s + 0) == 51) {
#line 2172
    goto case_57;
  }
#line 2172
  if ((int const   )*(s + 0) == 50) {
#line 2172
    goto case_57;
  }
#line 2172
  if ((int const   )*(s + 0) == 49) {
#line 2172
    goto case_57;
  }
#line 2172
  if ((int const   )*(s + 0) == 48) {
#line 2172
    goto case_57;
  }
#line 2165
  goto switch_break;
  case_89: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_116: /* CIL Label */ 
#line 2168
  return (my_true);
  case_78: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_102: /* CIL Label */ 
#line 2170
  return (my_false);
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
  {
#line 2173
  tmp = atoi(s);
  }
#line 2173
  return (tmp);
  switch_break: /* CIL Label */ ;
  }
#line 2175
  return (-1);
}
}
#line 2195 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
NPError NPP_New(NPMIMEType pluginType , NPP instance , uint16_t mode , int16_t argc ,
                char **argn , char **argv , NPSavedData *saved ) 
{ 
  int e ;
  int src_idx ;
  int href_idx ;
  int data_idx ;
  int alt_idx ;
  int autostart_idx ;
  int autohref_idx ;
  int target_idx ;
  data_t *THIS ;
  char *url ;
  void *tmp ;
  char *tmp___0 ;
  struct argument *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int len ;
  size_t tmp___17 ;
  char *tmp___18 ;
  void *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  NPError retVal ;
  NPError tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;

  {
  {
#line 2205
  src_idx = -1;
#line 2206
  href_idx = -1;
#line 2207
  data_idx = -1;
#line 2208
  alt_idx = -1;
#line 2209
  autostart_idx = -1;
#line 2210
  autohref_idx = -1;
#line 2211
  target_idx = -1;
#line 2214
  url = (char *)((void *)0);
#line 2216
  D((char *)"NPP_New(%s) - instance=%p\n", pluginType, instance);
  }
#line 2218
  if (! instance) {
#line 2220
    return ((NPError )2);
  }
#line 2223
  if (! pluginType) {
#line 2225
    return ((NPError )2);
  }
  {
#line 2228
  tmp = NPN_MemAlloc((uint32_t )sizeof(data_t ));
#line 2228
  THIS = (data_t *)tmp;
  }
#line 2229
  if ((unsigned long )THIS == (unsigned long )((void *)0)) {
#line 2231
    return ((NPError )5);
  }
  {
#line 2233
  instance->pdata = (void *)THIS;
#line 2235
  memset((void *)THIS, 0, sizeof(data_t ));
#line 2238
  THIS->pid = -1;
#line 2239
  THIS->commsPipeFd = -1;
#line 2240
  THIS->repeats = 1;
#line 2241
  THIS->autostart = (char)1;
#line 2242
  THIS->autostartNotSeen = (char)1;
#line 2243
  THIS->tmpFileFd = -1;
  }
#line 2245
  if ((int )mode == 1) {
#line 2247
    THIS->mode_flags = 32U;
  } else {
#line 2251
    THIS->mode_flags = 64U;
  }
  {
#line 2254
  tmp___0 = NP_strdup((char const   *)pluginType);
#line 2254
  THIS->mimetype = tmp___0;
  }
#line 2254
  if (! tmp___0) {
#line 2256
    return ((NPError )5);
  }
  {
#line 2259
  THIS->num_arguments = (int )argc;
#line 2260
  tmp___2 = NPN_MemAlloc((uint32_t )(sizeof(argument_t ) * (unsigned long )argc));
#line 2260
  tmp___1 = (argument_t *)tmp___2;
#line 2260
  THIS->args = tmp___1;
  }
#line 2260
  if (! tmp___1) {
#line 2263
    return ((NPError )5);
  }
#line 2266
  e = 0;
  {
#line 2266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2266
    if (! (e < (int )argc)) {
#line 2266
      goto while_break;
    }
    {
#line 2268
    tmp___16 = strcasecmp("loop", (char const   *)*(argn + e));
    }
#line 2268
    if (tmp___16 == 0) {
      {
#line 2270
      THIS->repeats = my_atoi((char const   *)*(argv + e), 2147483647, 1);
      }
    } else {
      {
#line 2274
      tmp___14 = strcasecmp("numloop", (char const   *)*(argn + e));
      }
#line 2274
      if (tmp___14 == 0) {
        {
#line 2277
        THIS->repeats = atoi((char const   *)*(argv + e));
        }
      } else {
        {
#line 2274
        tmp___15 = strcasecmp("playcount", (char const   *)*(argn + e));
        }
#line 2274
        if (tmp___15 == 0) {
          {
#line 2277
          THIS->repeats = atoi((char const   *)*(argv + e));
          }
        } else {
          {
#line 2279
          tmp___12 = strcasecmp("autostart", (char const   *)*(argn + e));
          }
#line 2279
          if (tmp___12 == 0) {
#line 2282
            autostart_idx = e;
          } else {
            {
#line 2279
            tmp___13 = strcasecmp("autoplay", (char const   *)*(argn + e));
            }
#line 2279
            if (tmp___13 == 0) {
#line 2282
              autostart_idx = e;
            } else {
              {
#line 2285
              tmp___11 = strcasecmp("src", (char const   *)*(argn + e));
              }
#line 2285
              if (tmp___11 == 0) {
#line 2287
                src_idx = e;
              } else {
                {
#line 2290
                tmp___10 = strcasecmp("data", (char const   *)*(argn + e));
                }
#line 2290
                if (tmp___10 == 0) {
#line 2292
                  data_idx = e;
                } else {
                  {
#line 2296
                  tmp___8 = strcasecmp("href", (char const   *)*(argn + e));
                  }
#line 2296
                  if (tmp___8 == 0) {
#line 2296
                    goto _L___2;
                  } else {
                    {
#line 2296
                    tmp___9 = strcasecmp("qtsrc", (char const   *)*(argn + e));
                    }
#line 2296
                    if (tmp___9 == 0) {
                      _L___2: /* CIL Label */ 
#line 2296
                      if (href_idx == -1) {
#line 2300
                        href_idx = e;
                      } else {
#line 2296
                        goto _L___1;
                      }
                    } else {
                      _L___1: /* CIL Label */ 
                      {
#line 2302
                      tmp___5 = strcasecmp("filename", (char const   *)*(argn + e));
                      }
#line 2302
                      if (tmp___5 == 0) {
#line 2302
                        goto _L___0;
                      } else {
                        {
#line 2302
                        tmp___6 = strcasecmp("url", (char const   *)*(argn + e));
                        }
#line 2302
                        if (tmp___6 == 0) {
#line 2302
                          goto _L___0;
                        } else {
                          {
#line 2302
                          tmp___7 = strcasecmp("location", (char const   *)*(argn + e));
                          }
#line 2302
                          if (tmp___7 == 0) {
                            _L___0: /* CIL Label */ 
#line 2302
                            if (alt_idx == -1) {
#line 2307
                              alt_idx = e;
                            } else {
#line 2302
                              goto _L;
                            }
                          } else {
                            _L: /* CIL Label */ 
                            {
#line 2311
                            tmp___4 = strcasecmp("target", (char const   *)*(argn + e));
                            }
#line 2311
                            if (tmp___4 == 0) {
#line 2313
                              target_idx = e;
                            } else {
                              {
#line 2315
                              tmp___3 = strcasecmp("autohref", (char const   *)*(argn + e));
                              }
#line 2315
                              if (tmp___3 == 0) {
#line 2317
                                autohref_idx = e;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 2321
    D((char *)"VAR_%s=%s\n", *(argn + e), *(argv + e));
#line 2323
    tmp___17 = strlen((char const   *)*(argn + e));
#line 2323
    len = (int )(tmp___17 + 5UL);
#line 2325
    tmp___19 = NPN_MemAlloc((uint32_t )len);
#line 2325
    tmp___18 = (char *)tmp___19;
#line 2325
    (THIS->args + e)->name = tmp___18;
    }
#line 2325
    if (! tmp___18) {
#line 2327
      return ((NPError )5);
    }
    {
#line 2329
    snprintf((char */* __restrict  */)(THIS->args + e)->name, (size_t )len, (char const   */* __restrict  */)"VAR_%s",
             *(argn + e));
    }
#line 2330
    if (*(argv + e)) {
      {
#line 2330
      tmp___20 = NP_strdup((char const   *)*(argv + e));
#line 2330
      (THIS->args + e)->value = tmp___20;
      }
    } else {
#line 2330
      (THIS->args + e)->value = (char *)((void *)0);
    }
#line 2266
    e ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2334
  if (src_idx >= 0) {
#line 2336
    url = (THIS->args + src_idx)->value;
#line 2340
    if (href_idx >= 0) {
      {
#line 2342
      D((char *)"Special case QT detected\n");
#line 2343
      THIS->href = (THIS->args + href_idx)->value;
#line 2345
      autostart_idx = autohref_idx;
      }
#line 2347
      if (target_idx >= 0) {
#line 2350
        THIS->mode_flags &= 4294967199U;
#line 2351
        THIS->mode_flags |= 8192U;
      }
    }
  } else
#line 2355
  if (data_idx >= 0) {
    {
#line 2357
    D((char *)"Looks like an object tag with data attribute\n");
#line 2358
    url = (THIS->args + data_idx)->value;
    }
  } else
#line 2360
  if (alt_idx >= 0) {
    {
#line 2362
    D((char *)"Fall-back use alternative tags\n");
#line 2363
    url = (THIS->args + alt_idx)->value;
    }
  }
#line 2368
  if (autostart_idx > 0) {
    {
#line 2370
    tmp___21 = my_atoi((char const   *)*(argv + autostart_idx), 1, 0);
    }
#line 2370
    if (tmp___21) {
#line 2370
      tmp___22 = 1;
    } else {
#line 2370
      tmp___22 = 0;
    }
#line 2370
    THIS->autostart = (char )tmp___22;
#line 2371
    THIS->autostartNotSeen = (char)0;
  }
#line 2374
  if (url) {
    {
#line 2376
    THIS->url = url;
#line 2380
    tmp___24 = strncmp((char const   *)url, "mms://", (size_t )6);
    }
#line 2380
    if (tmp___24 == 0) {
      {
#line 2387
      D((char *)"Detected MMS -> url=%s\n", url);
#line 2389
      THIS->browserCantHandleIt = (char)1;
#line 2390
      find_command((data_t */* const  */)THIS, 1);
      }
    } else {
      {
#line 2380
      tmp___25 = strncmp((char const   *)url, "mmsu://", (size_t )7);
      }
#line 2380
      if (tmp___25 == 0) {
        {
#line 2387
        D((char *)"Detected MMS -> url=%s\n", url);
#line 2389
        THIS->browserCantHandleIt = (char)1;
#line 2390
        find_command((data_t */* const  */)THIS, 1);
        }
      } else {
        {
#line 2380
        tmp___26 = strncmp((char const   *)url, "mmst://", (size_t )7);
        }
#line 2380
        if (tmp___26 == 0) {
          {
#line 2387
          D((char *)"Detected MMS -> url=%s\n", url);
#line 2389
          THIS->browserCantHandleIt = (char)1;
#line 2390
          find_command((data_t */* const  */)THIS, 1);
          }
        } else {
          {
#line 2380
          tmp___27 = strncmp((char const   *)url, "rtsp://", (size_t )7);
          }
#line 2380
          if (tmp___27 == 0) {
            {
#line 2387
            D((char *)"Detected MMS -> url=%s\n", url);
#line 2389
            THIS->browserCantHandleIt = (char)1;
#line 2390
            find_command((data_t */* const  */)THIS, 1);
            }
          } else {
            {
#line 2380
            tmp___28 = strncmp((char const   *)url, "rtspu://", (size_t )8);
            }
#line 2380
            if (tmp___28 == 0) {
              {
#line 2387
              D((char *)"Detected MMS -> url=%s\n", url);
#line 2389
              THIS->browserCantHandleIt = (char)1;
#line 2390
              find_command((data_t */* const  */)THIS, 1);
              }
            } else {
              {
#line 2380
              tmp___29 = strncmp((char const   *)url, "rtspt://", (size_t )8);
              }
#line 2380
              if (tmp___29 == 0) {
                {
#line 2387
                D((char *)"Detected MMS -> url=%s\n", url);
#line 2389
                THIS->browserCantHandleIt = (char)1;
#line 2390
                find_command((data_t */* const  */)THIS, 1);
                }
              } else {
                {
#line 2399
                find_command((data_t */* const  */)THIS, 0);
                }
#line 2409
                if ((int )mode == 1) {
                  {
#line 2411
                  tmp___23 = NPN_GetURL(instance, (char const   *)url, (char const   *)0);
#line 2411
                  retVal = tmp___23;
                  }
#line 2412
                  if ((int )retVal != 0) {
                    {
#line 2414
                    D((char *)"NPN_GetURL(%s) failed with %i\n", url, (int )retVal);
#line 2416
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MozPlugger: Warning: Couldn\'t get%s\n",
                            url);
                    }
#line 2418
                    return ((NPError )1);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 2424
  D((char *)"New finished\n");
  }
#line 2426
  return ((NPError )0);
}
}
#line 2440 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
NPError NPP_Destroy(NPP instance , NPSavedData **save ) 
{ 
  int e ;
  data_t *THIS ;
  char *p ;

  {
  {
#line 2445
  D((char *)"NPP_Destroy() - instance=%p\n", instance);
  }
#line 2447
  if (! instance) {
#line 2449
    return ((NPError )2);
  }
#line 2452
  THIS = (data_t *)instance->pdata;
#line 2453
  if (THIS) {
#line 2456
    if (THIS->pid > 0) {
      {
#line 2458
      my_kill(- THIS->pid);
#line 2459
      THIS->pid = 0;
      }
    }
#line 2461
    if (THIS->commsPipeFd >= 0) {
      {
#line 2463
      close(THIS->commsPipeFd);
#line 2464
      THIS->commsPipeFd = -1;
      }
    }
#line 2466
    if (THIS->tmpFileFd >= 0) {
      {
#line 2468
      close(THIS->tmpFileFd);
#line 2469
      THIS->tmpFileFd = -1;
      }
    }
#line 2471
    if ((unsigned long )THIS->tmpFileName != (unsigned long )((char const   *)0)) {
      {
#line 2474
      D((char *)"Deleting temp file \'%s\'\n", THIS->tmpFileName);
#line 2476
      unlink(THIS->tmpFileName);
#line 2477
      p = strrchr(THIS->tmpFileName, '/');
      }
#line 2478
      if (p) {
        {
#line 2480
        *p = (char )'\000';
#line 2481
        D((char *)"Deleting temp dir \'%s\'\n", THIS->tmpFileName);
#line 2482
        rmdir(THIS->tmpFileName);
        }
      }
      {
#line 2484
      NPN_MemFree((void *)((char *)THIS->tmpFileName));
      }
    }
#line 2486
    e = 0;
    {
#line 2486
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2486
      if (! (e < THIS->num_arguments)) {
#line 2486
        goto while_break;
      }
      {
#line 2488
      NPN_MemFree((void *)(THIS->args + e)->name);
#line 2489
      NPN_MemFree((void *)(THIS->args + e)->value);
#line 2486
      e ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2492
    NPN_MemFree((void *)((char *)THIS->args));
#line 2494
    NPN_MemFree((void *)THIS->mimetype);
#line 2495
    THIS->href = (char *)((void *)0);
#line 2496
    THIS->url = (char *)((void *)0);
#line 2498
    NPN_MemFree((void *)THIS->urlFragment);
#line 2499
    THIS->urlFragment = (char *)((void *)0);
#line 2501
    NPN_MemFree(instance->pdata);
#line 2502
    instance->pdata = (void *)0;
    }
  }
  {
#line 2505
  D((char *)"Destroy finished\n");
  }
#line 2507
  return ((NPError )0);
}
}
#line 2521 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static void new_child(NPP instance , char const   *fname , int isURL ) 
{ 
  int commsPipe[2] ;
  data_t *THIS ;
  sigset_t set ;
  sigset_t oset ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int signum ;
  int i ;
  int maxFds ;
  int commsFd ;
  long tmp___3 ;

  {
#line 2528
  if (fname) {
#line 2528
    tmp = fname;
  } else {
#line 2528
    tmp = "NULL";
  }
  {
#line 2528
  D((char *)"NEW_CHILD(%s)\n", tmp);
  }
#line 2530
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
#line 2532
    return;
  }
#line 2536
  THIS = (data_t *)instance->pdata;
#line 2538
  if (THIS->pid != -1) {
    {
#line 2540
    D((char *)"Child already running\n");
    }
#line 2541
    return;
  }
#line 2545
  if ((unsigned long )THIS->command == (unsigned long )((char const   *)0)) {
    {
#line 2547
    D((char *)"Child has no command\n");
    }
#line 2548
    return;
  }
  {
#line 2551
  tmp___0 = safeName(fname, isURL);
  }
#line 2551
  if (tmp___0) {
#line 2551
    if (THIS->urlFragment) {
      {
#line 2551
      tmp___1 = safeName((char const   *)THIS->urlFragment, 0);
      }
#line 2551
      if (! tmp___1) {
        {
#line 2554
        NPN_Status(instance, "MozPlugger: Detected unsafe URL aborting!");
        }
#line 2555
        return;
      }
    }
  } else {
    {
#line 2554
    NPN_Status(instance, "MozPlugger: Detected unsafe URL aborting!");
    }
#line 2555
    return;
  }
  {
#line 2558
  tmp___2 = socketpair(1, 1, 0, (int *)(commsPipe));
  }
#line 2558
  if (tmp___2 < 0) {
    {
#line 2560
    NPN_Status(instance, "MozPlugger: Failed to create a pipe!");
    }
#line 2561
    return;
  }
  {
#line 2565
  sigfillset(& set);
#line 2566
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& set), (sigset_t */* __restrict  */)(& oset));
#line 2568
  D((char *)">>>>>>>>Forking<<<<<<<<\n");
#line 2570
  THIS->pid = fork();
  }
#line 2571
  if (THIS->pid == 0) {
    {
#line 2576
    commsFd = commsPipe[1];
#line 2578
    alarm(0U);
    }
#line 2580
    if (! (THIS->cmd_flags & 2U)) {
      {
#line 2582
      setsid();
      }
    }
#line 2585
    signum = 0;
    {
#line 2585
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2585
      if (! (signum < 65)) {
#line 2585
        goto while_break;
      }
      {
#line 2587
      signal(signum, (void (*)(int  ))0);
#line 2585
      signum ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2590
    close_debug();
#line 2595
    tmp___3 = sysconf(4);
#line 2595
    maxFds = (int )tmp___3;
#line 2596
    i = 3;
    }
    {
#line 2596
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2596
      if (! (i < maxFds)) {
#line 2596
        goto while_break___0;
      }
#line 2598
      if (i != commsFd) {
        {
#line 2600
        close(i);
        }
      }
#line 2596
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2603
    D((char *)"Closed up to %i Fds, except %i\n", maxFds, commsFd);
#line 2606
    sigprocmask(2, (sigset_t const   */* __restrict  */)(& oset), (sigset_t */* __restrict  */)(& set));
#line 2608
    run((data_t */* const  */)THIS, fname, commsFd);
#line 2610
    _exit(69);
    }
  }
  {
#line 2614
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& oset), (sigset_t */* __restrict  */)(& set));
  }
#line 2616
  if (THIS->pid == -1) {
    {
#line 2618
    NPN_Status(instance, "MozPlugger: Failed to fork helper!");
    }
  }
  {
#line 2621
  D((char *)"Child running with pid=%d\n", THIS->pid);
#line 2623
  THIS->commsPipeFd = commsPipe[0];
#line 2624
  close(commsPipe[1]);
  }
#line 2625
  return;
}
}
#line 2637 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static int guessTmpFile(char const   *fileName , int soFar , char *tmpFilePath , int maxTmpFilePathLen ) 
{ 
  int i ;
  int fd ;
  int spaceLeft ;
  char *dst ;
  char const   *src ;
  int left ;
  char ch ;
  char const   *tmp ;
  char *tmp___0 ;

  {
#line 2641
  fd = -1;
#line 2642
  spaceLeft = maxTmpFilePathLen - soFar;
#line 2644
  i = 0;
  {
#line 2644
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2644
    if (! (i <= 100)) {
#line 2644
      goto while_break;
    }
#line 2646
    if (i == 0) {
#line 2651
      dst = tmpFilePath + soFar;
#line 2652
      src = fileName;
#line 2653
      left = spaceLeft;
      {
#line 2654
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2654
        if (! (left > 0)) {
#line 2654
          goto while_break___0;
        }
#line 2656
        tmp = src;
#line 2656
        src ++;
#line 2656
        ch = (char )*tmp;
#line 2657
        if ((int )ch == 59) {
#line 2660
          ch = (char )'_';
        } else
#line 2657
        if ((int )ch == 96) {
#line 2660
          ch = (char )'_';
        } else
#line 2657
        if ((int )ch == 38) {
#line 2660
          ch = (char )'_';
        } else
#line 2657
        if ((int )ch == 32) {
#line 2660
          ch = (char )'_';
        } else
#line 2657
        if ((int )ch == 9) {
#line 2660
          ch = (char )'_';
        } else
#line 2662
        if ((int )ch == 0) {
#line 2664
          goto while_break___0;
        }
#line 2666
        tmp___0 = dst;
#line 2666
        dst ++;
#line 2666
        *tmp___0 = ch;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 2668
      strncpy((char */* __restrict  */)(tmpFilePath + soFar), (char const   */* __restrict  */)fileName,
              (size_t )spaceLeft);
      }
    } else
#line 2670
    if (i == 100) {
      {
#line 2672
      strncpy((char */* __restrict  */)(tmpFilePath + soFar), (char const   */* __restrict  */)"XXXXXX",
              (size_t )spaceLeft);
#line 2673
      fd = mkstemp(tmpFilePath);
      }
#line 2674
      goto while_break;
    } else {
      {
#line 2678
      snprintf((char */* __restrict  */)(tmpFilePath + soFar), (size_t )spaceLeft,
               (char const   */* __restrict  */)"%03i-%s", i, fileName);
      }
    }
    {
#line 2681
    *(tmpFilePath + (maxTmpFilePathLen - 1)) = (char )'\000';
#line 2683
    fd = open((char const   *)tmpFilePath, 193, 384);
    }
#line 2685
    if (fd >= 0) {
#line 2687
      goto while_break;
    }
#line 2644
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2691
  return (fd);
}
}
#line 2705 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static int createTmpFile(char const   *fileName , char *tmpFilePath , int maxTmpFilePathLen ) 
{ 
  int fd ;
  char const   *root ;
  pid_t pid___1 ;
  __pid_t tmp ;
  char *tmp___0 ;
  int soFar ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int soFar___0 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;

  {
  {
#line 2708
  fd = -1;
#line 2710
  tmp = getpid();
#line 2710
  pid___1 = tmp;
#line 2712
  D((char *)"Creating temp file for \'%s\'\n", fileName);
#line 2714
  tmp___0 = getenv("MOZPLUGGER_TMP");
#line 2714
  root = (char const   *)tmp___0;
  }
#line 2715
  if (root) {
    {
#line 2719
    strncpy((char */* __restrict  */)tmpFilePath, (char const   */* __restrict  */)root,
            (size_t )maxTmpFilePathLen);
#line 2720
    tmp___1 = strlen((char const   *)tmpFilePath);
#line 2720
    soFar = (int )tmp___1;
#line 2722
    tmp___2 = snprintf((char */* __restrict  */)(tmpFilePath + soFar), (size_t )(maxTmpFilePathLen - soFar),
                       (char const   */* __restrict  */)"/tmp-%i", pid___1);
#line 2722
    soFar += tmp___2;
#line 2724
    tmp___4 = mkdir((char const   *)tmpFilePath, (__mode_t )448);
    }
#line 2724
    if (tmp___4 == 0) {
      {
#line 2726
      D((char *)"Creating temp file in \'%s\'\n", tmpFilePath);
#line 2728
      tmp___3 = soFar;
#line 2728
      soFar ++;
#line 2728
      *(tmpFilePath + tmp___3) = (char )'/';
#line 2730
      fd = guessTmpFile(fileName, soFar, tmpFilePath, maxTmpFilePathLen);
      }
    } else {
      {
#line 2724
      tmp___5 = __errno_location();
      }
#line 2724
      if (*tmp___5 == 17) {
        {
#line 2726
        D((char *)"Creating temp file in \'%s\'\n", tmpFilePath);
#line 2728
        tmp___3 = soFar;
#line 2728
        soFar ++;
#line 2728
        *(tmpFilePath + tmp___3) = (char )'/';
#line 2730
        fd = guessTmpFile(fileName, soFar, tmpFilePath, maxTmpFilePathLen);
        }
      }
    }
  }
#line 2734
  if (fd < 0) {
    {
#line 2736
    tmp___6 = getenv("TMPDIR");
#line 2736
    root = (char const   *)tmp___6;
    }
#line 2737
    if (! root) {
#line 2739
      root = "/tmp";
    }
    {
#line 2742
    snprintf((char */* __restrict  */)tmpFilePath, (size_t )maxTmpFilePathLen, (char const   */* __restrict  */)"%s/mozplugger-%i",
             root, pid___1);
#line 2744
    tmp___9 = mkdir((char const   *)tmpFilePath, (__mode_t )448);
    }
#line 2744
    if (tmp___9 == 0) {
#line 2744
      goto _L;
    } else {
      {
#line 2744
      tmp___10 = __errno_location();
      }
#line 2744
      if (*tmp___10 == 17) {
        _L: /* CIL Label */ 
        {
#line 2746
        tmp___7 = strlen((char const   *)tmpFilePath);
#line 2746
        soFar___0 = (int )tmp___7;
#line 2748
        D((char *)"Creating temp file in \'%s\'\n", tmpFilePath);
#line 2750
        tmp___8 = soFar___0;
#line 2750
        soFar___0 ++;
#line 2750
        *(tmpFilePath + tmp___8) = (char )'/';
#line 2752
        fd = guessTmpFile(fileName, soFar___0, tmpFilePath, maxTmpFilePathLen);
        }
      }
    }
  }
#line 2756
  if (fd >= 0) {
    {
#line 2758
    D((char *)"Opened temporary file \'%s\'\n", tmpFilePath);
    }
  }
#line 2760
  return (fd);
}
}
#line 2778 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
NPError NPP_NewStream(NPP instance , NPMIMEType type , NPStream *stream , NPBool seekable ,
                      uint16_t *stype ) 
{ 
  char fileName[128] ;
  char *savedMimetype ;
  data_t *THIS ;
  char refind_command ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char tmpfile___0[16384] ;
  char *tmp___3 ;

  {
  {
#line 2785
  savedMimetype = (char *)((void *)0);
#line 2787
  refind_command = (char)0;
#line 2789
  D((char *)"NPP_NewStream() - instance=%p\n", instance);
  }
#line 2791
  if ((unsigned long )instance == (unsigned long )((void *)0)) {
#line 2793
    return ((NPError )2);
  }
#line 2796
  THIS = (data_t *)instance->pdata;
#line 2799
  THIS->browserCantHandleIt = (char)0;
#line 2801
  if (THIS->pid != -1) {
    {
#line 2803
    D((char *)"NewStream() exiting process already running\n");
    }
#line 2804
    return ((NPError )1);
  } else
#line 2801
  if (THIS->tmpFileFd >= 0) {
    {
#line 2803
    D((char *)"NewStream() exiting process already running\n");
    }
#line 2804
    return ((NPError )1);
  }
#line 2809
  if ((unsigned long )THIS->href != (unsigned long )((void *)0)) {
    {
#line 2811
    D((char *)"Replacing SRC with HREF... \n");
    }
#line 2813
    if ((unsigned long )THIS->url == (unsigned long )((char *)0)) {
      {
#line 2816
      D((char *)"URL has changed to %s\n", THIS->href);
#line 2817
      THIS->url = THIS->href;
#line 2818
      refind_command = (char)1;
      }
    } else {
      {
#line 2813
      tmp = strcmp((char const   *)THIS->href, (char const   *)THIS->url);
      }
#line 2813
      if (tmp != 0) {
        {
#line 2816
        D((char *)"URL has changed to %s\n", THIS->href);
#line 2817
        THIS->url = THIS->href;
#line 2818
        refind_command = (char)1;
        }
      }
    }
  } else
#line 2821
  if ((unsigned long )THIS->url == (unsigned long )((char *)0)) {
    {
#line 2824
    D((char *)"URL has changed to %s\n", stream->url);
#line 2825
    THIS->url = (char *)stream->url;
#line 2826
    refind_command = (char)1;
    }
  } else {
    {
#line 2821
    tmp___0 = strcmp(stream->url, (char const   *)THIS->url);
    }
#line 2821
    if (tmp___0 != 0) {
      {
#line 2824
      D((char *)"URL has changed to %s\n", stream->url);
#line 2825
      THIS->url = (char *)stream->url;
#line 2826
      refind_command = (char)1;
      }
    }
  }
  {
#line 2829
  D((char *)"Url is %s (seekable=%d)\n", THIS->url, (int )seekable);
#line 2838
  tmp___2 = strcmp((char const   *)type, (char const   *)THIS->mimetype);
  }
#line 2838
  if (tmp___2 != 0) {
    {
#line 2840
    D((char *)"Mismatching mimetype reported, originally was \'%s\' now \'%s\' for url %s\n",
      THIS->mimetype, type, THIS->url);
#line 2842
    savedMimetype = THIS->mimetype;
#line 2843
    THIS->mimetype = NP_strdup((char const   *)type);
#line 2845
    tmp___1 = find_command((data_t */* const  */)THIS, 0);
    }
#line 2845
    if (tmp___1) {
      {
#line 2853
      NPN_MemFree((void *)savedMimetype);
      }
    } else {
      {
#line 2847
      NPN_MemFree((void *)THIS->mimetype);
#line 2848
      THIS->mimetype = savedMimetype;
#line 2849
      find_command((data_t */* const  */)THIS, 0);
      }
    }
  } else
#line 2856
  if (refind_command) {
    {
#line 2858
    find_command((data_t */* const  */)THIS, 0);
#line 2859
    D((char *)"Mime type %s\n", type);
    }
  }
  {
#line 2863
  parseURL((data_t */* const  */)THIS, (char const   *)THIS->url, fileName, (int )(sizeof(fileName) / sizeof(char ) - 1UL));
#line 2866
  parseHeaders((data_t */* const  */)THIS, stream->headers, fileName, (int )(sizeof(fileName) / sizeof(char ) - 1UL));
  }
#line 2868
  if ((unsigned long )THIS->command == (unsigned long )((char const   *)0)) {
    {
#line 2870
    NPN_Status(instance, "MozPlugger: No appropriate application found.");
    }
#line 2872
    return ((NPError )1);
  }
#line 2875
  if ((THIS->cmd_flags & 4U) == 0U) {
    {
#line 2879
    THIS->tmpFileFd = createTmpFile((char const   *)(fileName), tmpfile___0, (int )sizeof(tmpfile___0));
    }
#line 2881
    if (THIS->tmpFileFd < 0) {
      {
#line 2883
      NPN_Status(instance, "MozPlugger: Failed to create tmp file");
      }
#line 2884
      return ((NPError )1);
    } else {
      {
#line 2888
      tmp___3 = NP_strdup((char const   *)(tmpfile___0));
#line 2888
      THIS->tmpFileName = (char const   *)tmp___3;
#line 2889
      THIS->tmpFileSize = 0;
      }
    }
  } else {
    {
#line 2894
    new_child(instance, (char const   *)THIS->url, 1);
    }
  }
#line 2897
  *stype = (uint16_t )1;
#line 2898
  return ((NPError )0);
}
}
#line 2913 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
void NPP_StreamAsFile(NPP instance , NPStream *stream , char const   *fname ) 
{ 


  {
  {
#line 2917
  D((char *)"NPP_StreamAsFile() - instance=%p\n", instance);
  }
#line 2919
  if ((unsigned long )instance != (unsigned long )((void *)0)) {
    {
#line 2921
    new_child(instance, fname, 0);
    }
  }
#line 2923
  return;
}
}
#line 2940 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
static void resize_window(NPP instance ) 
{ 
  XSetWindowAttributes attrib ;
  data_t *THIS ;
  NPBool tmp ;

  {
  {
#line 2945
  tmp = does_browser_have_resize_bug();
  }
#line 2945
  if (! tmp) {
#line 2947
    return;
  }
  {
#line 2949
  THIS = (data_t *)instance->pdata;
#line 2951
  attrib.override_redirect = 1;
#line 2952
  XChangeWindowAttributes(THIS->display, (Window )THIS->windata.window, (unsigned long )(1L << 9),
                          & attrib);
#line 2955
  D((char *)"Bug #7734 work around - resizing WIN 0x%x to %ux%u!?\n", (unsigned int )THIS->windata.window,
    THIS->windata.width, THIS->windata.height);
#line 2959
  XResizeWindow(THIS->display, (Window )THIS->windata.window, THIS->windata.width,
                THIS->windata.height);
  }
#line 2962
  return;
}
}
#line 2979 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
NPError NPP_SetWindow(NPP instance , NPWindow *window ) 
{ 
  data_t *THIS ;
  int tmp ;
  ssize_t ret ;

  {
  {
#line 2982
  D((char *)"NPP_SetWindow() - instance=%p\n", instance);
  }
#line 2984
  if (! instance) {
#line 2986
    return ((NPError )2);
  }
#line 2989
  if (! window) {
#line 2991
    return ((NPError )0);
  }
#line 2997
  if (! window->window) {
    {
#line 2999
    D((char *)"SetWindow() - NULL window passed in so exit\n");
    }
#line 3000
    return ((NPError )0);
  }
#line 3003
  if (! window->ws_info) {
#line 3005
    return ((NPError )0);
  }
  {
#line 3008
  THIS = (data_t *)instance->pdata;
#line 3010
  THIS->display = ((NPSetWindowCallbackStruct *)window->ws_info)->display;
#line 3011
  THIS->displayname = XDisplayName((char const   *)((_XPrivDisplay )THIS->display)->display_name);
#line 3012
  THIS->windata = *window;
  }
#line 3014
  if (THIS->url) {
#line 3014
    if (THIS->browserCantHandleIt) {
#line 3016
      if ((unsigned long )THIS->command == (unsigned long )((char const   *)0)) {
        {
#line 3020
        tmp = find_command((data_t */* const  */)THIS, 1);
        }
#line 3020
        if (! tmp) {
#line 3022
          if (errMsg) {
            {
#line 3024
            NPN_Status(instance, errMsg);
#line 3025
            errMsg = (char const   *)((void *)0);
            }
          } else {
            {
#line 3029
            NPN_Status(instance, "MozPlugger: No appropriate application found.");
            }
          }
#line 3032
          return ((NPError )1);
        }
      }
      {
#line 3037
      parseURL((data_t */* const  */)THIS, (char const   *)THIS->url, (char *)0, 0);
#line 3039
      new_child(instance, (char const   *)THIS->url, 1);
#line 3040
      THIS->url = (char *)((void *)0);
      }
#line 3041
      return ((NPError )0);
    }
  }
#line 3044
  if (THIS->commsPipeFd >= 0) {
    {
#line 3047
    D((char *)"Writing WIN 0x%x to fd %d\n", (unsigned int )window->window, THIS->commsPipeFd);
#line 3049
    ret = write(THIS->commsPipeFd, (void const   *)((char *)window), sizeof(*window));
    }
#line 3050
    if ((unsigned long )ret < sizeof(*window)) {
      {
#line 3052
      D((char *)"Writing to comms pipe failed\n");
#line 3053
      close(THIS->commsPipeFd);
#line 3054
      THIS->commsPipeFd = -1;
      }
    }
  }
  {
#line 3058
  resize_window(instance);
#line 3061
  usleep((__useconds_t )4000);
  }
#line 3066
  return ((NPError )0);
}
}
#line 3083 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
NPError NPP_DestroyStream(NPP instance , NPStream *stream , short reason ) 
{ 
  data_t *THIS ;

  {
  {
#line 3085
  D((char *)"NPP_DestroyStream() - instance=%p\n", instance);
  }
#line 3087
  if (! instance) {
#line 3089
    return ((NPError )2);
  }
#line 3092
  THIS = (data_t *)instance->pdata;
#line 3094
  if (THIS->tmpFileFd >= 0) {
    {
#line 3096
    close(THIS->tmpFileFd);
#line 3097
    THIS->tmpFileFd = -1;
    }
#line 3099
    if ((unsigned long )THIS->tmpFileName != (unsigned long )((void *)0)) {
      {
#line 3101
      D((char *)"Closing Temporary file \'%s\'\n", THIS->tmpFileName);
      }
#line 3102
      if (THIS->commsPipeFd < 0) {
        {
#line 3104
        new_child(instance, THIS->tmpFileName, 0);
        }
      }
    } else {
      {
#line 3109
      D((char *)"Closing stdin pipe\n");
      }
    }
  }
#line 3112
  return ((NPError )0);
}
}
#line 3125 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
NPError NPP_Initialize(void) 
{ 
  int free___0 ;

  {
  {
#line 3127
  D((char *)"NPP_Initialize(void)\n");
#line 3129
  get_api_version();
#line 3131
  browserSupportsXEmbed = does_browser_support_xembed();
#line 3133
  do_read_config();
#line 3136
  free___0 = 65536 - staticPoolIdx;
#line 3137
  D((char *)"Static Pool used=%i, free=%i\n", staticPoolIdx, free___0);
  }
#line 3140
  return ((NPError )0);
}
}
#line 3153 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
void NPP_Shutdown(void) 
{ 


  {
  {
#line 3155
  D((char *)"NPP_Shutdown()\n");
  }
#line 3156
  return;
}
}
#line 3170 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
void NPP_Print(NPP instance , NPPrint *printInfo ) 
{ 


  {
  {
#line 3172
  D((char *)"NPP_Print() - instance=%p\n", instance);
  }
#line 3173
  return;
}
}
#line 3194 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
int32_t NPP_Write(NPP instance , NPStream *stream , int32_t offset , int32_t len ,
                  void *buf ) 
{ 
  data_t *THIS ;
  ssize_t tmp ;

  {
  {
#line 3197
  D((char *)"NPP_Write(%d,%d) - instance=%p\n", offset, len, instance);
  }
#line 3198
  if (instance) {
#line 3200
    THIS = (data_t *)instance->pdata;
#line 3202
    if (THIS->tmpFileFd >= 0) {
#line 3204
      if (offset != THIS->tmpFileSize) {
        {
#line 3206
        D((char *)"Strange, there\'s a gap?\n");
        }
      }
      {
#line 3208
      tmp = write(THIS->tmpFileFd, (void const   *)buf, (size_t )len);
#line 3208
      len = (int32_t )tmp;
#line 3209
      THIS->tmpFileSize += len;
#line 3210
      D((char *)"Temporary file size now=%i\n", THIS->tmpFileSize);
      }
    }
  }
#line 3213
  return (len);
}
}
#line 3231 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
int32_t NPP_WriteReady(NPP instance , NPStream *stream ) 
{ 
  int32_t size ;
  data_t *THIS ;

  {
  {
#line 3233
  size = 0;
#line 3235
  D((char *)"NPP_WriteReady() - instance=%p\n", instance);
  }
#line 3236
  if ((unsigned long )instance != (unsigned long )((NPP )0)) {
#line 3238
    THIS = (data_t *)instance->pdata;
#line 3240
    if (THIS->tmpFileFd >= 0) {
#line 3242
      size = 8196;
    } else {
      {
#line 3246
      D((char *)"Nothing to do - Application will handle stream\n");
      }
    }
#line 3250
    if (size == 0) {
      {
#line 3255
      NPN_DestroyStream(instance, stream, (NPReason )0);
      }
    }
  }
#line 3258
  return (size);
}
}
#line 3275 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
void NPP_URLNotify(NPP instance , char const   *url , NPReason reason , void *notifyData ) 
{ 


  {
  {
#line 3277
  D((char *)"NPP_URLNotify() - instance=%p url=%s reason=%i\n", instance, url, (int )reason);
  }
#line 3278
  return;
}
}
#line 3295 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
NPBool NPP_GotFocus(NPP instance , NPFocusDirection direction ) 
{ 


  {
  {
#line 3297
  D((char *)"NPP_GotFocus() - instance=%p, direction=%i\n", instance, (unsigned int )direction);
  }
#line 3298
  return ((NPBool )0);
}
}
#line 3314 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
void NPP_LostFocus(NPP instance ) 
{ 


  {
  {
#line 3316
  D((char *)"NPP_LostFocus() - instance=%p\n", instance);
  }
#line 3317
  return;
}
}
#line 3332 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
void NPP_URLRedirectNotify(NPP instance , char const   *url , int32_t status , void *noifyData ) 
{ 


  {
  {
#line 3334
  D((char *)"NPP_URLRedirectNotify() - instance=%p, url=%s, status=%i\n", instance,
    url, status);
  }
#line 3335
  return;
}
}
#line 3350 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
NPError NPP_ClearSiteData(char const   *site , uint64_t flags___3 , uint64_t maxAge ) 
{ 


  {
  {
#line 3352
  D((char *)"NPP_ClearSiteData() - site=%s\n", site);
  }
#line 3353
  return ((NPError )0);
}
}
#line 3369 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger.c"
char **NPP_GetSitesWithData(void) 
{ 


  {
  {
#line 3371
  D((char *)"NPP_GetSitesWithData()\n");
  }
#line 3372
  return ((char **)0);
}
}
#line 175 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./debug.c"
void ( /* format attribute */  D)(char *fmt  , ...) 
{ 


  {
#line 177
  return;
}
}
#line 179 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./debug.c"
void close_debug(void) 
{ 


  {
#line 181
  return;
}
}
#line 183 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./debug.c"
char *get_debug_path(void) 
{ 


  {
#line 185
  return ((char *)((void *)0));
}
}
#line 534 "./npapi/include/npapi.h"
void NPN_Version(int *plugin_major , int *plugin_minor , int *netscape_major , int *netscape_minor ) ;
#line 536
NPError NPN_GetURLNotify(NPP instance , char const   *url , char const   *window ,
                         void *notifyData ) ;
#line 540
NPError NPN_PostURLNotify(NPP instance , char const   *url , char const   *window ,
                          uint32_t len , char const   *buf , NPBool file___0 , void *notifyData ) ;
#line 544
NPError NPN_PostURL(NPP instance , char const   *url , char const   *window , uint32_t len ,
                    char const   *buf , NPBool file___0 ) ;
#line 547
NPError NPN_RequestRead(NPStream *stream , NPByteRange *rangeList ) ;
#line 548
NPError NPN_NewStream(NPP instance , NPMIMEType type , char const   *window , NPStream **stream_ptr ) ;
#line 550
int32_t NPN_Write(NPP instance , NPStream *stream , int32_t len , void *buffer ) ;
#line 555
char const   *NPN_UserAgent(NPP instance ) ;
#line 558
uint32_t NPN_MemFlush(uint32_t size ) ;
#line 559
void NPN_ReloadPlugins(NPBool reloadPages ) ;
#line 560
NPError NPN_GetValue(NPP instance , NPNVariable variable , void *r_value ) ;
#line 562
NPError NPN_SetValue(NPP instance , NPPVariable variable , void *value ) ;
#line 564
void NPN_InvalidateRect(NPP instance , NPRect *invalidRect ) ;
#line 565
void NPN_InvalidateRegion(NPP instance , NPRegion invalidRegion ) ;
#line 567
void NPN_ForceRedraw(NPP instance ) ;
#line 568
void NPN_PushPopupsEnabledState(NPP instance , NPBool enabled ) ;
#line 569
void NPN_PopPopupsEnabledState(NPP instance ) ;
#line 570
void NPN_PluginThreadAsyncCall(NPP instance , void (*func)(void * ) , void *userData ) ;
#line 573
NPError NPN_GetValueForURL(NPP npp , NPNURLVariable variable , char const   *url ,
                           char **value , uint32_t *len ) ;
#line 576
NPError NPN_SetValueForURL(NPP npp , NPNURLVariable variable , char const   *url ,
                           char const   *value , uint32_t len ) ;
#line 579
NPError NPN_GetAuthenticationInfo(NPP npp , char const   *protocol , char const   *host ,
                                  int32_t port , char const   *scheme , char const   *realm ,
                                  char **username , uint32_t *ulen , char **password ,
                                  uint32_t *plen ) ;
#line 587
uint32_t NPN_ScheduleTimer(NPP instance , uint32_t interval , NPBool repeat , void (*timerFunc)(NPP npp ,
                                                                                                uint32_t timerID ) ) ;
#line 588
void NPN_UnscheduleTimer(NPP instance , uint32_t timerID ) ;
#line 589
NPError NPN_PopUpContextMenu(NPP instance , NPMenu *menu ) ;
#line 590
NPBool NPN_ConvertPoint(NPP instance , double sourceX , double sourceY , NPCoordinateSpace sourceSpace ,
                        double *destX , double *destY , NPCoordinateSpace destSpace ) ;
#line 591
NPBool NPN_HandleEvent(NPP instance , void *event , NPBool handled ) ;
#line 592
NPBool NPN_UnfocusInstance(NPP instance , NPFocusDirection direction ) ;
#line 593
void NPN_URLRedirectResponse(NPP instance , void *notifyData , NPBool allow ) ;
#line 121 "./npapi/include/npruntime.h"
void NPN_ReleaseVariantValue(NPVariant *variant ) ;
#line 223
NPIdentifier NPN_GetStringIdentifier(NPUTF8 const   *name ) ;
#line 224
void NPN_GetStringIdentifiers(NPUTF8 const   **names , int32_t nameCount , NPIdentifier *identifiers ) ;
#line 226
NPIdentifier NPN_GetIntIdentifier(int32_t intid ) ;
#line 342
NPObject *NPN_RetainObject(NPObject *obj ) ;
#line 349
void NPN_ReleaseObject(NPObject *obj ) ;
#line 363
_Bool NPN_Invoke(NPP npp , NPObject *obj , NPIdentifier methodName , NPVariant const   *args ,
                 uint32_t argCount , NPVariant *result ) ;
#line 365
_Bool NPN_InvokeDefault(NPP npp , NPObject *obj , NPVariant const   *args , uint32_t argCount ,
                        NPVariant *result ) ;
#line 367
_Bool NPN_Evaluate(NPP npp , NPObject *obj , NPString *script , NPVariant *result ) ;
#line 369
_Bool NPN_GetProperty(NPP npp , NPObject *obj , NPIdentifier propertyName , NPVariant *result ) ;
#line 371
_Bool NPN_SetProperty(NPP npp , NPObject *obj , NPIdentifier propertyName , NPVariant const   *value ) ;
#line 373
_Bool NPN_RemoveProperty(NPP npp , NPObject *obj , NPIdentifier propertyName ) ;
#line 374
_Bool NPN_HasProperty(NPP npp , NPObject *obj , NPIdentifier propertyName ) ;
#line 375
_Bool NPN_HasMethod(NPP npp , NPObject *obj , NPIdentifier methodName ) ;
#line 376
_Bool NPN_Enumerate(NPP npp , NPObject *obj , NPIdentifier **identifier , uint32_t *count ) ;
#line 378
_Bool NPN_Construct(NPP npp , NPObject *obj , NPVariant const   *args , uint32_t argCount ,
                    NPVariant *result ) ;
#line 387
void NPN_SetException(NPObject *obj , NPUTF8 const   *message ) ;
#line 233 "./npapi/include/npupp.h"
char __attribute__((__visibility__("default")))  *NP_GetPluginVersion(void) ;
#line 235
char const __attribute__((__visibility__("default")))  *NP_GetMIMEDescription(void) ;
#line 239
NPError __attribute__((__visibility__("default")))  NP_Initialize(NPNetscapeFuncs *nsTable ,
                                                                  NPPluginFuncs *pluginFuncs ) ;
#line 243
NPError __attribute__((__visibility__("default")))  NP_Shutdown(void) ;
#line 245
NPError __attribute__((__visibility__("default")))  NP_GetValue(void *future , NPPVariable variable ,
                                                                void *value ) ;
#line 68 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
static NPNetscapeFuncs gNetscapeFuncs  ;
#line 81 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
void NPN_Version(int *plugin_major , int *plugin_minor , int *netscape_major , int *netscape_minor ) 
{ 


  {
#line 84
  *plugin_major = 0;
#line 85
  *plugin_minor = 27;
#line 88
  *netscape_major = (int )gNetscapeFuncs.version >> 8;
#line 90
  *netscape_minor = (int )gNetscapeFuncs.version & 255;
#line 91
  return;
}
}
#line 94 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
NPError NPN_GetValue(NPP instance , NPNVariable variable , void *r_value ) 
{ 
  NPError retVal ;
  NPError (*func)(NPP instance , NPNVariable variable , void *ret_value ) ;

  {
#line 96
  retVal = (NPError )3;
#line 97
  func = gNetscapeFuncs.getvalue;
#line 98
  if (func) {
    {
#line 100
    retVal = (*func)(instance, variable, r_value);
    }
  }
#line 102
  return (retVal);
}
}
#line 106 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
NPError NPN_SetValue(NPP instance , NPPVariable variable , void *value ) 
{ 
  NPError retVal ;
  NPError (*func)(NPP instance , NPPVariable variable , void *value ) ;

  {
#line 108
  retVal = (NPError )3;
#line 109
  func = gNetscapeFuncs.setvalue;
#line 110
  if (func) {
    {
#line 112
    retVal = (*func)(instance, variable, value);
    }
  }
#line 114
  return (retVal);
}
}
#line 118 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
NPError NPN_GetURL(NPP instance , char const   *url , char const   *window ) 
{ 
  NPError retVal ;
  NPError (*func)(NPP instance , char const   *url , char const   *window ) ;

  {
#line 120
  retVal = (NPError )3;
#line 121
  func = gNetscapeFuncs.geturl;
#line 122
  if (func) {
    {
#line 124
    retVal = (*func)(instance, url, window);
    }
  }
#line 126
  return (retVal);
}
}
#line 130 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
NPError NPN_GetURLNotify(NPP instance , char const   *url , char const   *window ,
                         void *notifyData ) 
{ 
  NPError retVal ;
  NPError (*func)(NPP instance , char const   *url , char const   *window , void *notifyData ) ;

  {
#line 133
  retVal = (NPError )3;
#line 134
  func = gNetscapeFuncs.geturlnotify;
#line 135
  if (func) {
    {
#line 137
    retVal = (*func)(instance, url, window, notifyData);
    }
  }
#line 139
  return (retVal);
}
}
#line 143 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
NPError NPN_PostURL(NPP instance , char const   *url , char const   *window , uint32_t len ,
                    char const   *buf , NPBool file___0 ) 
{ 
  NPError retVal ;
  NPError (*func)(NPP instance , char const   *url , char const   *window , uint32_t len ,
                  char const   *buf , NPBool file ) ;

  {
#line 146
  retVal = (NPError )3;
#line 147
  func = gNetscapeFuncs.posturl;
#line 148
  if (func) {
    {
#line 150
    retVal = (*func)(instance, url, window, len, buf, file___0);
    }
  }
#line 152
  return (retVal);
}
}
#line 156 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
NPError NPN_PostURLNotify(NPP instance , char const   *url , char const   *window ,
                          uint32_t len , char const   *buf , NPBool file___0 , void *notifyData ) 
{ 
  NPError retVal ;
  NPError (*func)(NPP instance , char const   *url , char const   *window , uint32_t len ,
                  char const   *buf , NPBool file , void *notifyData ) ;

  {
#line 159
  retVal = (NPError )3;
#line 160
  func = gNetscapeFuncs.posturlnotify;
#line 161
  if (func) {
    {
#line 163
    retVal = (*func)(instance, url, window, len, buf, file___0, notifyData);
    }
  }
#line 165
  return (retVal);
}
}
#line 169 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
NPError NPN_RequestRead(NPStream *stream , NPByteRange *rangeList ) 
{ 
  NPError retVal ;
  NPError (*func)(NPStream *stream , NPByteRange *rangeList ) ;

  {
#line 171
  retVal = (NPError )3;
#line 172
  func = gNetscapeFuncs.requestread;
#line 173
  if (func) {
    {
#line 175
    retVal = (*func)(stream, rangeList);
    }
  }
#line 177
  return (retVal);
}
}
#line 181 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
NPError NPN_NewStream(NPP instance , NPMIMEType type , char const   *window , NPStream **stream_ptr ) 
{ 
  NPError retVal ;
  NPError (*func)(NPP instance , NPMIMEType type , char const   *window , NPStream **stream ) ;

  {
#line 184
  retVal = (NPError )3;
#line 185
  func = gNetscapeFuncs.newstream;
#line 186
  if (func) {
    {
#line 188
    retVal = (*func)(instance, type, window, stream_ptr);
    }
  }
#line 190
  return (retVal);
}
}
#line 194 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
int32_t NPN_Write(NPP instance , NPStream *stream , int32_t len , void *buffer ) 
{ 
  int32_t retVal ;
  int32_t (*func)(NPP instance , NPStream *stream , int32_t len , void *buffer ) ;

  {
#line 196
  retVal = 0;
#line 197
  func = gNetscapeFuncs.write;
#line 198
  if (func) {
    {
#line 200
    retVal = (*func)(instance, stream, len, buffer);
    }
  }
#line 202
  return (retVal);
}
}
#line 206 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
NPError NPN_DestroyStream(NPP instance , NPStream *stream , short reason ) 
{ 
  NPError retVal ;
  NPError (*func)(NPP instance , NPStream *stream , NPReason reason ) ;

  {
#line 208
  retVal = (NPError )3;
#line 209
  func = gNetscapeFuncs.destroystream;
#line 210
  if (func) {
    {
#line 212
    retVal = (*func)(instance, stream, reason);
    }
  }
#line 214
  return (retVal);
}
}
#line 218 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
void NPN_Status(NPP instance , char const   *message ) 
{ 
  void (*func)(NPP instance , char const   *message ) ;

  {
#line 220
  func = gNetscapeFuncs.status;
#line 221
  if (func) {
    {
#line 223
    (*func)(instance, message);
    }
  }
#line 225
  return;
}
}
#line 228 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
char const   *NPN_UserAgent(NPP instance ) 
{ 
  char const   *retVal ;
  char const   *(*func)(NPP instance ) ;

  {
#line 230
  retVal = (char const   *)0;
#line 231
  func = gNetscapeFuncs.uagent;
#line 232
  if (func) {
    {
#line 234
    retVal = (*func)(instance);
    }
  }
#line 236
  return (retVal);
}
}
#line 240 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
void *NPN_MemAlloc(uint32_t size ) 
{ 
  void *retVal ;
  void *(*func)(uint32_t size ) ;

  {
#line 242
  retVal = (void *)0;
#line 243
  func = gNetscapeFuncs.memalloc;
#line 244
  if (func) {
    {
#line 246
    retVal = (*func)(size);
    }
  }
#line 248
  return (retVal);
}
}
#line 252 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
void NPN_MemFree(void *ptr ) 
{ 
  void (*func)(void *ptr ) ;

  {
#line 254
  func = gNetscapeFuncs.memfree;
#line 255
  if (func) {
    {
#line 257
    (*func)(ptr);
    }
  }
#line 259
  return;
}
}
#line 262 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
uint32_t NPN_MemFlush(uint32_t size ) 
{ 
  uint32_t retVal ;
  uint32_t (*func)(uint32_t size ) ;

  {
#line 264
  retVal = (uint32_t )0;
#line 265
  func = gNetscapeFuncs.memflush;
#line 266
  if (func) {
    {
#line 268
    retVal = (*func)(size);
    }
  }
#line 270
  return (retVal);
}
}
#line 274 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
void NPN_ReloadPlugins(NPBool reloadPages ) 
{ 
  void (*func)(NPBool reloadPages ) ;

  {
#line 276
  func = gNetscapeFuncs.reloadplugins;
#line 277
  if (func) {
    {
#line 279
    (*func)(reloadPages);
    }
  }
#line 281
  return;
}
}
#line 284 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
void NPN_InvalidateRect(NPP instance , NPRect *invalidRect ) 
{ 
  void (*func)(NPP instance , NPRect *rect ) ;

  {
#line 286
  func = gNetscapeFuncs.invalidaterect;
#line 287
  if (func) {
    {
#line 289
    (*func)(instance, invalidRect);
    }
  }
#line 291
  return;
}
}
#line 294 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
void NPN_InvalidateRegion(NPP instance , NPRegion invalidRegion ) 
{ 
  void (*func)(NPP instance , NPRegion region ) ;

  {
#line 296
  func = gNetscapeFuncs.invalidateregion;
#line 297
  if (func) {
    {
#line 299
    (*func)(instance, invalidRegion);
    }
  }
#line 301
  return;
}
}
#line 304 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
void NPN_ForceRedraw(NPP instance ) 
{ 
  void (*func)(NPP instance ) ;

  {
#line 306
  func = gNetscapeFuncs.forceredraw;
#line 307
  if (func) {
    {
#line 309
    (*func)(instance);
    }
  }
#line 311
  return;
}
}
#line 314 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
void NPN_PushPopupsEnabledState(NPP instance , NPBool enabled ) 
{ 
  void (*func)(NPP npp , NPBool enabled ) ;

  {
#line 316
  func = gNetscapeFuncs.pushpopupsenabledstate;
#line 318
  if (func) {
    {
#line 320
    (*func)(instance, enabled);
    }
  }
#line 322
  return;
}
}
#line 325 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
void NPN_PopPopupsEnabledState(NPP instance ) 
{ 
  void (*func)(NPP npp ) ;

  {
#line 327
  func = gNetscapeFuncs.poppopupsenabledstate;
#line 329
  if (func) {
    {
#line 331
    (*func)(instance);
    }
  }
#line 333
  return;
}
}
#line 336 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
NPIdentifier NPN_GetStringIdentifier(NPUTF8 const   *name ) 
{ 
  NPIdentifier retVal ;
  NPIdentifier (*func)(NPUTF8 const   *name ) ;

  {
#line 338
  retVal = (NPIdentifier )0;
#line 339
  func = gNetscapeFuncs.getstringidentifier;
#line 340
  if (func) {
    {
#line 342
    retVal = (*func)(name);
    }
  }
#line 344
  return (retVal);
}
}
#line 348 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
void NPN_GetStringIdentifiers(NPUTF8 const   **names , int32_t nameCount , NPIdentifier *identifiers ) 
{ 
  void (*func)(NPUTF8 const   **names , int32_t nameCount , NPIdentifier *identifiers ) ;

  {
#line 351
  func = gNetscapeFuncs.getstringidentifiers;
#line 352
  if (func) {
    {
#line 354
    (*func)(names, nameCount, identifiers);
    }
  }
#line 356
  return;
}
}
#line 359 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
NPIdentifier NPN_GetIntIdentifier(int32_t intid ) 
{ 
  NPIdentifier retVal ;
  NPIdentifier (*func)(int32_t intid ) ;

  {
#line 361
  retVal = (NPIdentifier )0;
#line 362
  func = gNetscapeFuncs.getintidentifier;
#line 363
  if (func) {
    {
#line 365
    retVal = (*func)(intid);
    }
  }
#line 367
  return (retVal);
}
}
#line 371 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
_Bool NPN_IdentifierIsString(NPIdentifier identifier ) 
{ 
  _Bool retVal ;
  _Bool (*func)(NPIdentifier identifier ) ;

  {
#line 373
  retVal = (_Bool)0;
#line 374
  func = gNetscapeFuncs.identifierisstring;
#line 375
  if (func) {
    {
#line 377
    retVal = (*func)(identifier);
    }
  }
#line 379
  return (retVal);
}
}
#line 383 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
NPUTF8 *NPN_UTF8FromIdentifier(NPIdentifier identifier ) 
{ 
  NPUTF8 *retVal ;
  NPUTF8 *(*func)(NPIdentifier identifier ) ;

  {
#line 385
  retVal = (NPUTF8 *)0;
#line 386
  func = gNetscapeFuncs.utf8fromidentifier;
#line 387
  if (func) {
    {
#line 389
    retVal = (*func)(identifier);
    }
  }
#line 391
  return (retVal);
}
}
#line 395 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
int32_t NPN_IntFromIdentifier(NPIdentifier identifier ) 
{ 
  int32_t retVal ;
  int32_t (*func)(NPIdentifier identifier ) ;

  {
#line 397
  retVal = 0;
#line 398
  func = gNetscapeFuncs.intfromidentifier;
#line 399
  if (func) {
    {
#line 401
    retVal = (*func)(identifier);
    }
  }
#line 403
  return (retVal);
}
}
#line 407 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
NPObject *NPN_CreateObject(NPP npp , NPClass *aClass ) 
{ 
  NPObject *retVal ;
  NPObject *(*func)(NPP npp , NPClass *aClass ) ;

  {
#line 409
  retVal = (NPObject *)0;
#line 410
  func = gNetscapeFuncs.createobject;
#line 411
  if (func) {
    {
#line 413
    retVal = (*func)(npp, aClass);
    }
  }
#line 415
  return (retVal);
}
}
#line 419 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
NPObject *NPN_RetainObject(NPObject *obj ) 
{ 
  NPObject *retVal ;
  NPObject *(*func)(NPObject *obj ) ;

  {
#line 421
  retVal = (NPObject *)0;
#line 422
  func = gNetscapeFuncs.retainobject;
#line 423
  if (func) {
    {
#line 425
    retVal = (*func)(obj);
    }
  }
#line 427
  return (retVal);
}
}
#line 431 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
void NPN_ReleaseObject(NPObject *obj ) 
{ 
  void (*func)(NPObject *obj ) ;

  {
#line 433
  func = gNetscapeFuncs.releaseobject;
#line 434
  if (func) {
    {
#line 436
    (*func)(obj);
    }
  }
#line 438
  return;
}
}
#line 441 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
_Bool NPN_Invoke(NPP npp , NPObject *obj , NPIdentifier methodName , NPVariant const   *args ,
                 uint32_t argCount , NPVariant *result ) 
{ 
  _Bool retVal ;
  _Bool (*func)(NPP npp , NPObject *obj , NPIdentifier methodName , NPVariant const   *args ,
                uint32_t argCount , NPVariant *result ) ;

  {
#line 444
  retVal = (_Bool)0;
#line 445
  func = gNetscapeFuncs.invoke;
#line 446
  if (func) {
    {
#line 448
    retVal = (*func)(npp, obj, methodName, args, argCount, result);
    }
  }
#line 450
  return (retVal);
}
}
#line 454 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
_Bool NPN_InvokeDefault(NPP npp , NPObject *obj , NPVariant const   *args , uint32_t argCount ,
                        NPVariant *result ) 
{ 
  _Bool retVal ;
  _Bool (*func)(NPP npp , NPObject *obj , NPVariant const   *args , uint32_t argCount ,
                NPVariant *result ) ;

  {
#line 457
  retVal = (_Bool)0;
#line 458
  func = gNetscapeFuncs.invokeDefault;
#line 459
  if (func) {
    {
#line 461
    retVal = (*func)(npp, obj, args, argCount, result);
    }
  }
#line 463
  return (retVal);
}
}
#line 467 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
_Bool NPN_Evaluate(NPP npp , NPObject *obj , NPString *script , NPVariant *result ) 
{ 
  _Bool retVal ;
  _Bool (*func)(NPP npp , NPObject *obj , NPString *script , NPVariant *result ) ;

  {
#line 469
  retVal = (_Bool)0;
#line 470
  func = gNetscapeFuncs.evaluate;
#line 471
  if (func) {
    {
#line 473
    retVal = (*func)(npp, obj, script, result);
    }
  }
#line 475
  return (retVal);
}
}
#line 479 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
_Bool NPN_GetProperty(NPP npp , NPObject *obj , NPIdentifier propertyName , NPVariant *result ) 
{ 
  _Bool retVal ;
  _Bool (*func)(NPP npp , NPObject *obj , NPIdentifier propertyName , NPVariant *result ) ;

  {
#line 482
  retVal = (_Bool)0;
#line 483
  func = gNetscapeFuncs.getproperty;
#line 484
  if (func) {
    {
#line 486
    retVal = (*func)(npp, obj, propertyName, result);
    }
  }
#line 488
  return (retVal);
}
}
#line 492 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
_Bool NPN_SetProperty(NPP npp , NPObject *obj , NPIdentifier propertyName , NPVariant const   *value ) 
{ 
  _Bool retVal ;
  _Bool (*func)(NPP npp , NPObject *obj , NPIdentifier propertyName , NPVariant const   *value ) ;

  {
#line 495
  retVal = (_Bool)0;
#line 496
  func = gNetscapeFuncs.setproperty;
#line 497
  if (func) {
    {
#line 499
    retVal = (*func)(npp, obj, propertyName, value);
    }
  }
#line 501
  return (retVal);
}
}
#line 505 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
_Bool NPN_RemoveProperty(NPP npp , NPObject *obj , NPIdentifier propertyName ) 
{ 
  _Bool retVal ;
  _Bool (*func)(NPP npp , NPObject *obj , NPIdentifier propertyName ) ;

  {
#line 507
  retVal = (_Bool)0;
#line 508
  func = gNetscapeFuncs.removeproperty;
#line 509
  if (func) {
    {
#line 511
    retVal = (*func)(npp, obj, propertyName);
    }
  }
#line 513
  return (retVal);
}
}
#line 517 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
_Bool NPN_HasProperty(NPP npp , NPObject *obj , NPIdentifier propertyName ) 
{ 
  _Bool retVal ;
  _Bool (*func)(NPP npp , NPObject *obj , NPIdentifier propertyName ) ;

  {
#line 519
  retVal = (_Bool)0;
#line 520
  func = gNetscapeFuncs.hasproperty;
#line 521
  if (func) {
    {
#line 523
    retVal = (*func)(npp, obj, propertyName);
    }
  }
#line 525
  return (retVal);
}
}
#line 529 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
_Bool NPN_HasMethod(NPP npp , NPObject *obj , NPIdentifier methodName ) 
{ 
  _Bool retVal ;
  _Bool (*func)(NPP npp , NPObject *obj , NPIdentifier propertyName ) ;

  {
#line 531
  retVal = (_Bool)0;
#line 532
  func = gNetscapeFuncs.hasmethod;
#line 533
  if (func) {
    {
#line 535
    retVal = (*func)(npp, obj, methodName);
    }
  }
#line 537
  return (retVal);
}
}
#line 541 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
void NPN_ReleaseVariantValue(NPVariant *variant ) 
{ 
  void (*func)(NPVariant *variant ) ;

  {
#line 543
  func = gNetscapeFuncs.releasevariantvalue;
#line 544
  if (func) {
    {
#line 546
    (*func)(variant);
    }
  }
#line 548
  return;
}
}
#line 551 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
void NPN_SetException(NPObject *obj , NPUTF8 const   *message ) 
{ 
  void (*func)(NPObject *obj , NPUTF8 const   *message ) ;

  {
#line 553
  func = gNetscapeFuncs.setexception;
#line 554
  if (func) {
    {
#line 556
    (*func)(obj, message);
    }
  }
#line 558
  return;
}
}
#line 561 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
_Bool NPN_Enumerate(NPP npp , NPObject *obj , NPIdentifier **identifier , uint32_t *count ) 
{ 
  _Bool (*func)(NPP npp , NPObject *obj , NPIdentifier **identifier , uint32_t *count ) ;
  _Bool retVal ;

  {
#line 564
  func = gNetscapeFuncs.enumerate;
#line 565
  retVal = (_Bool)0;
#line 566
  if (func) {
    {
#line 568
    retVal = (*func)(npp, obj, identifier, count);
    }
  }
#line 570
  return (retVal);
}
}
#line 574 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
void NPN_PluginThreadAsyncCall(NPP instance , void (*func)(void * ) , void *userData ) 
{ 
  void (*func2)(NPP instance , void (*func)(void * ) , void *userData ) ;

  {
#line 577
  func2 = gNetscapeFuncs.pluginthreadasynccall;
#line 579
  if (func2) {
    {
#line 581
    (*func2)(instance, func, userData);
    }
  }
#line 583
  return;
}
}
#line 586 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
_Bool NPN_Construct(NPP npp , NPObject *obj , NPVariant const   *args , uint32_t argCount ,
                    NPVariant *result ) 
{ 
  _Bool (*func)(NPP npp , NPObject *obj , NPVariant const   *args , uint32_t argCount ,
                NPVariant *result ) ;
  _Bool retVal ;

  {
#line 589
  func = gNetscapeFuncs.construct;
#line 590
  retVal = (_Bool)0;
#line 591
  if (func) {
    {
#line 593
    retVal = (*func)(npp, obj, args, argCount, result);
    }
  }
#line 595
  return (retVal);
}
}
#line 599 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
NPError NPN_GetValueForURL(NPP npp , NPNURLVariable variable , char const   *url ,
                           char **value , uint32_t *len ) 
{ 
  NPError (*func)(NPP npp , NPNURLVariable variable , char const   *url , char **value ,
                  uint32_t *len ) ;
  NPError retVal ;

  {
#line 602
  func = gNetscapeFuncs.getvalueforurl;
#line 603
  retVal = (NPError )3;
#line 604
  if (func) {
    {
#line 606
    retVal = (*func)(npp, variable, url, value, len);
    }
  }
#line 608
  return (retVal);
}
}
#line 612 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
NPError NPN_SetValueForURL(NPP npp , NPNURLVariable variable , char const   *url ,
                           char const   *value , uint32_t len ) 
{ 
  NPError (*func)(NPP npp , NPNURLVariable variable , char const   *url , char const   *value ,
                  uint32_t len ) ;
  NPError retVal ;

  {
#line 615
  func = gNetscapeFuncs.setvalueforurl;
#line 616
  retVal = (NPError )3;
#line 617
  if (func) {
    {
#line 619
    retVal = (*func)(npp, variable, url, value, len);
    }
  }
#line 621
  return (retVal);
}
}
#line 625 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
NPError NPN_GetAuthenticationInfo(NPP npp , char const   *protocol , char const   *host ,
                                  int32_t port , char const   *scheme , char const   *realm ,
                                  char **username , uint32_t *ulen , char **password ,
                                  uint32_t *plen ) 
{ 
  NPError (*func)(NPP npp , char const   *protocol , char const   *host , int32_t port ,
                  char const   *scheme , char const   *realm , char **username , uint32_t *ulen ,
                  char **password , uint32_t *plen ) ;
  NPError retVal ;

  {
#line 631
  func = gNetscapeFuncs.getauthenticationinfo;
#line 632
  retVal = (NPError )3;
#line 633
  if (func) {
    {
#line 635
    retVal = (*func)(npp, protocol, host, port, scheme, realm, username, ulen, password,
                     plen);
    }
  }
#line 638
  return (retVal);
}
}
#line 642 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
uint32_t NPN_ScheduleTimer(NPP instance , uint32_t interval , NPBool repeat , void (*timerFunc)(NPP npp ,
                                                                                                uint32_t timerID ) ) 
{ 
  uint32_t (*func)(NPP instance , uint32_t interval , NPBool repeat , void (*timerFunc)(NPP npp ,
                                                                                        uint32_t timerID ) ) ;
  uint32_t retVal ;

  {
#line 645
  func = gNetscapeFuncs.scheduletimer;
#line 646
  retVal = (uint32_t )0;
#line 647
  if (func) {
    {
#line 649
    retVal = (*func)(instance, interval, repeat, timerFunc);
    }
  }
#line 651
  return (retVal);
}
}
#line 655 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
void NPN_UnscheduleTimer(NPP instance , uint32_t timerID ) 
{ 
  void (*func)(NPP instance , uint32_t timerID ) ;

  {
#line 657
  func = gNetscapeFuncs.unscheduletimer;
#line 658
  if (func) {
    {
#line 660
    (*func)(instance, timerID);
    }
  }
#line 662
  return;
}
}
#line 665 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
NPError NPN_PopUpContextMenu(NPP instance , NPMenu *menu ) 
{ 
  NPError (*func)(NPP instance , NPMenu *menu ) ;
  NPError retVal ;

  {
#line 667
  func = gNetscapeFuncs.popupcontextmenu;
#line 668
  retVal = (NPError )3;
#line 669
  if (func) {
    {
#line 671
    retVal = (*func)(instance, menu);
    }
  }
#line 673
  return (retVal);
}
}
#line 677 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
NPBool NPN_ConvertPoint(NPP instance , double sourceX , double sourceY , NPCoordinateSpace sourceSpace ,
                        double *destX , double *destY , NPCoordinateSpace destSpace ) 
{ 
  NPBool (*func)(NPP instance , double sourceX , double sourceY , NPCoordinateSpace sourceSpace ,
                 double *destX , double *destY , NPCoordinateSpace destSpace ) ;
  NPBool retVal ;

  {
#line 681
  func = gNetscapeFuncs.convertpoint;
#line 682
  retVal = (NPBool )0;
#line 683
  if (func) {
    {
#line 685
    retVal = (*func)(instance, sourceX, sourceY, sourceSpace, destX, destY, destSpace);
    }
  }
#line 688
  return (retVal);
}
}
#line 692 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
NPBool NPN_HandleEvent(NPP instance , void *event , NPBool handled ) 
{ 
  NPBool (*func)(NPP instance , void *event , NPBool handled ) ;
  NPBool retVal ;

  {
#line 694
  func = gNetscapeFuncs.handleevent;
#line 695
  retVal = (NPBool )0;
#line 696
  if (func) {
    {
#line 698
    retVal = (*func)(instance, event, handled);
    }
  }
#line 700
  return (retVal);
}
}
#line 704 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
NPBool NPN_UnfocusInstance(NPP instance , NPFocusDirection direction ) 
{ 
  NPBool (*func)(NPP instance , NPFocusDirection direction ) ;
  NPBool retVal ;

  {
#line 706
  func = gNetscapeFuncs.unfocusinstance;
#line 707
  retVal = (NPBool )0;
#line 708
  if (func) {
    {
#line 710
    retVal = (*func)(instance, direction);
    }
  }
#line 712
  return (retVal);
}
}
#line 717 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
void NPN_URLRedirectResponse(NPP instance , void *notifyData , NPBool allow ) 
{ 
  void (*func)(NPP instance , void *notifyData , NPBool allow ) ;

  {
#line 719
  func = gNetscapeFuncs.urlredirectresponse;
#line 720
  if (func) {
    {
#line 722
    (*func)(instance, notifyData, allow);
    }
  }
#line 724
  return;
}
}
#line 737 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
char __attribute__((__visibility__("default")))  *NP_GetPluginVersion(void) 
{ 


  {
#line 739
  return ((char __attribute__((__visibility__("default")))  *)"1.14.5");
}
}
#line 749 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
char const __attribute__((__visibility__("default")))  *NP_GetMIMEDescription(void) 
{ 
  char const   *tmp ;

  {
  {
#line 751
  tmp = NPP_GetMIMEDescription();
  }
#line 751
  return ((char const __attribute__((__visibility__("default")))  *)tmp);
}
}
#line 760 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
NPError __attribute__((__visibility__("default")))  NP_GetValue(void *future , NPPVariable variable ,
                                                                void *value ) 
{ 
  NPError tmp ;

  {
  {
#line 762
  tmp = NPP_GetValue(future, variable, value);
  }
#line 762
  return ((NPError __attribute__((__visibility__("default")))  )tmp);
}
}
#line 782 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
NPError __attribute__((__visibility__("default")))  NP_Initialize(NPNetscapeFuncs *nsTable ,
                                                                  NPPluginFuncs *pluginFuncs ) 
{ 
  NPError err ;
  uint32_t size ;
  NPPluginFuncs funcs ;

  {
  {
#line 784
  err = (NPError )0;
#line 787
  memset((void *)(& gNetscapeFuncs), 0, sizeof(gNetscapeFuncs));
  }
#line 790
  if ((unsigned long )nsTable != (unsigned long )((void *)0)) {
#line 798
    if ((int )nsTable->version >> 8 > 0) {
#line 800
      err = (NPError )8;
    }
#line 803
    if ((unsigned long )nsTable->size > sizeof(NPNetscapeFuncs )) {
#line 806
      size = (uint32_t )sizeof(NPNetscapeFuncs );
    } else {
#line 811
      size = (uint32_t )nsTable->size;
    }
    {
#line 814
    memcpy((void */* __restrict  */)(& gNetscapeFuncs), (void const   */* __restrict  */)nsTable,
           (size_t )size);
#line 815
    gNetscapeFuncs.size = (uint16_t )size;
    }
  } else {
#line 819
    err = (NPError )3;
  }
#line 822
  if ((unsigned long )pluginFuncs != (unsigned long )((void *)0)) {
    {
#line 828
    memset((void *)(& funcs), 0, sizeof(NPPluginFuncs ));
#line 831
    funcs.version = (uint16_t )27;
#line 832
    funcs.newp = & NPP_New;
#line 833
    funcs.destroy = & NPP_Destroy;
#line 834
    funcs.setwindow = & NPP_SetWindow;
#line 835
    funcs.newstream = & NPP_NewStream;
#line 836
    funcs.destroystream = & NPP_DestroyStream;
#line 837
    funcs.asfile = & NPP_StreamAsFile;
#line 838
    funcs.writeready = & NPP_WriteReady;
#line 839
    funcs.write = & NPP_Write;
#line 840
    funcs.print = & NPP_Print;
#line 841
    funcs.urlnotify = & NPP_URLNotify;
#line 842
    funcs.getvalue = (NPError (*)(NPP instance , NPPVariable variable , void *ret_value ))(& NPP_GetValue);
#line 843
    funcs.setvalue = & NPP_SetValue;
#line 844
    funcs.gotfocus = & NPP_GotFocus;
#line 845
    funcs.lostfocus = & NPP_LostFocus;
#line 846
    funcs.urlredirectnotify = & NPP_URLRedirectNotify;
#line 847
    funcs.clearsitedata = & NPP_ClearSiteData;
#line 848
    funcs.getsiteswithdata = & NPP_GetSitesWithData;
    }
#line 850
    if ((unsigned long )pluginFuncs->size > sizeof(NPPluginFuncs )) {
      {
#line 853
      memset((void *)(pluginFuncs + sizeof(NPPluginFuncs )), 0, (unsigned long )pluginFuncs->size - sizeof(NPPluginFuncs ));
#line 855
      funcs.size = (uint16_t )sizeof(NPPluginFuncs );
      }
    } else {
#line 859
      funcs.size = pluginFuncs->size;
    }
    {
#line 863
    memcpy((void */* __restrict  */)pluginFuncs, (void const   */* __restrict  */)(& funcs),
           (size_t )funcs.size);
    }
  } else {
#line 867
    err = (NPError )3;
  }
#line 870
  if ((int )err == 0) {
    {
#line 872
    err = NPP_Initialize();
    }
  }
#line 875
  return ((NPError __attribute__((__visibility__("default")))  )err);
}
}
#line 885 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npapi/common/npunix.c"
NPError __attribute__((__visibility__("default")))  NP_Shutdown(void) 
{ 


  {
  {
#line 887
  NPP_Shutdown();
  }
#line 888
  return ((NPError __attribute__((__visibility__("default")))  )0);
}
}
#line 25 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npn-get-helpers.c"
static int browserApiMajorVer  =    0;
#line 26 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npn-get-helpers.c"
static int browserApiMinorVer  =    0;
#line 33 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npn-get-helpers.c"
void get_api_version(void) 
{ 
  int pluginApiMajorVer ;
  int pluginApiMinorVer ;

  {
  {
#line 38
  NPN_Version(& pluginApiMajorVer, & pluginApiMinorVer, & browserApiMajorVer, & browserApiMinorVer);
#line 41
  D((char *)"NPN_Version() - API versions plugin=%d.%d Browser=%d.%d\n", pluginApiMajorVer,
    pluginApiMinorVer, browserApiMajorVer, browserApiMinorVer);
  }
#line 44
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npn-get-helpers.c"
NPBool does_browser_have_resize_bug(void) 
{ 


  {
#line 55
  if (browserApiMajorVer > 0) {
#line 57
    return ((NPBool )0);
  } else
#line 55
  if (browserApiMinorVer > 13) {
#line 57
    return ((NPBool )0);
  }
#line 59
  return ((NPBool )1);
}
}
#line 67 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npn-get-helpers.c"
NPBool does_browser_support_xembed(void) 
{ 
  NPBool value ;
  NPError err ;
  NPError tmp ;

  {
  {
#line 72
  tmp = NPN_GetValue((NPP )((void *)0), (NPNVariable )14, (void *)(& value));
#line 72
  err = tmp;
  }
#line 73
  if ((int )err != 0) {
    {
#line 75
    D((char *)"NPN_GetValue(NPNVSupportsXEmbedBool) - Browser returned err=%i\n",
      (int )err);
    }
#line 77
    return ((NPBool )0);
  }
  {
#line 81
  D((char *)"NPN_GetValue(NPNSupportsXEmbedBool) - Browser returned %i\n", (int )value);
  }
#line 82
  return (value);
}
}
#line 90 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npn-get-helpers.c"
NPNToolkitType get_browser_toolkit(NPP instance ) 
{ 
  NPNToolkitType value ;
  NPError err ;
  NPError tmp ;

  {
  {
#line 94
  tmp = NPN_GetValue(instance, (NPNVariable )13, (void *)(& value));
#line 94
  err = tmp;
  }
#line 95
  if ((int )err != 0) {
    {
#line 97
    D((char *)"NPN_GetValue(NPNVToolkit) - Browser returned err=%i\n", (int )err);
    }
#line 98
    return ((NPNToolkitType )0);
  }
  {
#line 103
  if ((unsigned int )value == 1U) {
#line 103
    goto case_1;
  }
#line 107
  if ((unsigned int )value == 2U) {
#line 107
    goto case_2;
  }
#line 101
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 104
  D((char *)"NPN_GetValue(NPNVToolkit) - Browser supports GTK1.2\n");
  }
#line 105
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 108
  D((char *)"NPN_GetValue(NPNToolkit) - Browser supports GTK2\n");
  }
#line 109
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 111
  return (value);
}
}
#line 121 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./npn-get-helpers.c"
NPBool does_browser_support_key_handling(NPP instance ) 
{ 
  NPBool value ;
  NPError err ;
  NPError tmp ;

  {
  {
#line 125
  tmp = NPN_GetValue(instance, (NPNVariable )21, (void *)(& value));
#line 125
  err = tmp;
  }
#line 127
  if ((int )err != 0) {
    {
#line 129
    D((char *)"NPN_GetValue(NPNVSupportsAdvancedKeyHandling) - Browser returned err=%i\n",
      (int )err);
    }
#line 131
    return ((NPBool )0);
  }
  {
#line 135
  D((char *)"NPN_GetValue(NPNVSupportsAdvancedKeyHandling) - Browser returned %i\n",
    (int )value);
  }
#line 137
  return (value);
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 1495 "/usr/include/X11/Xlib.h"
extern Display *XOpenDisplay(char const   * ) ;
#line 1596
extern GC XCreateGC(Display * , Drawable  , unsigned long  , XGCValues * ) ;
#line 1648
extern Window XCreateWindow(Display * , Window  , int  , int  , unsigned int  , unsigned int  ,
                            unsigned int  , int  , unsigned int  , Visual * , unsigned long  ,
                            XSetWindowAttributes * ) ;
#line 1860
extern XErrorHandler XSetErrorHandler(int (*)(Display * , XErrorEvent * ) ) ;
#line 1869
extern XIOErrorHandler XSetIOErrorHandler(int (*)(Display * ) ) ;
#line 1970
extern int XAllocColor(Display * , Colormap  , XColor * ) ;
#line 2255
extern int XDestroyWindow(Display * , Window  ) ;
#line 2354
extern int XDrawLine(Display * , Drawable  , GC  , int  , int  , int  , int  ) ;
#line 2364
extern int XDrawLines(Display * , Drawable  , GC  , XPoint * , int  , int  ) ;
#line 2491
extern int XFillPolygon(Display * , Drawable  , GC  , XPoint * , int  , int  , int  ) ;
#line 2501
extern int XFillRectangle(Display * , Drawable  , GC  , int  , int  , unsigned int  ,
                          unsigned int  ) ;
#line 2703
extern int XGetWindowAttributes(Display * , Window  , XWindowAttributes * ) ;
#line 2818
extern int XMapWindow(Display * , Window  ) ;
#line 2837
extern int XMoveResizeWindow(Display * , Window  , int  , int  , unsigned int  , unsigned int  ) ;
#line 2853
extern int XNextEvent(Display * , XEvent * ) ;
#line 2893
extern int XPending(Display * ) ;
#line 3239
extern int XSetForeground(Display * , GC  , unsigned long  ) ;
#line 3407
extern int XStoreName(Display * , Window  , char const   * ) ;
#line 3421
extern int XSync(Display * , int  ) ;
#line 583 "/usr/include/X11/Xutil.h"
extern int XSetClassHint(Display * , Window  , XClassHint * ) ;
#line 659
extern void XSetWMNormalHints(Display * , Window  , XSizeHints * ) ;
#line 24 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./child.h"
void restore_SIGCHLD_to_default(void) ;
#line 28
void redirect_SIGCHLD_to_fd(void) ;
#line 30
int get_SIGCHLD_fd(void) ;
#line 32
void handle_SIGCHLD_event(void) ;
#line 34
pid_t spawn_app(char *command___0 , int const   flags___3 , int maxFd ) ;
#line 56 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static Display *dpy  =    (Display *)0;
#line 57 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static Window topLevel  ;
#line 58 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static int buttonsize  =    10;
#line 60 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static int buttonDown  =    0;
#line 62 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static pid_t pid  =    -1;
#line 64 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static int repeats  =    0;
#line 65 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static int repeatsResetVal  ;
#line 67 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static int pipe_fd  ;
#line 68 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static int flags___0  ;
#line 70 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static struct __anonstruct_parentDetails_153 parentDetails  ;
#line 79 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static GC gc_white  ;
#line 80 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static GC gc_black  ;
#line 81 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static GC gc_onColor  ;
#line 82 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static GC gc_offColor  ;
#line 84 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static char const   *nextHelper  =    (char const   *)((void *)0);
#line 98 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static int scale(int v ) 
{ 


  {
#line 100
  return ((v * buttonsize + 8) / 16);
}
}
#line 116 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static XPoint coordAdd(XPoint const   * const  origin , int x , int y ) 
{ 
  XPoint ret ;

  {
#line 119
  ret.x = (short )((int const   )origin->x + (int const   )x);
#line 120
  ret.y = (short )((int const   )origin->y + (int const   )y);
#line 121
  return (ret);
}
}
#line 133
static void redraw(void) ;
#line 133 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static int old_buttonsize  =    -1;
#line 131 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static void redraw(void) 
{ 
  XWindowAttributes attr ;
  XPoint points[6] ;
  XPoint base ;
  int d ;
  GC c ;
  GC tmp ;
  int s ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int i ;
  int x ;
  int y ;
  unsigned int w ;
  unsigned int h ;

  {
#line 137
  d = 2;
#line 138
  if (pid > 0) {
#line 138
    tmp = gc_onColor;
  } else {
#line 138
    tmp = gc_offColor;
  }
#line 138
  c = tmp;
#line 139
  if (! buttonDown) {
#line 139
    tmp___0 = d;
  } else {
#line 139
    tmp___0 = 0;
  }
  {
#line 139
  s = tmp___0;
#line 141
  XGetWindowAttributes(dpy, topLevel, & attr);
#line 142
  buttonsize = attr.width;
  }
#line 143
  if (attr.height < buttonsize) {
#line 145
    buttonsize = attr.height;
  }
#line 148
  if (old_buttonsize != buttonsize) {
    {
#line 150
    old_buttonsize = buttonsize;
#line 151
    XFillRectangle(dpy, topLevel, gc_white, 0, 0, (unsigned int )attr.width, (unsigned int )attr.height);
    }
  }
  {
#line 156
  base.x = (short )((attr.width - buttonsize) / 2);
#line 157
  base.y = (short )((attr.height - buttonsize) / 2);
#line 159
  tmp___1 = scale(2);
#line 159
  tmp___2 = scale(5);
#line 159
  points[0] = coordAdd((XPoint const   */* const  */)(& base), tmp___2 - s, tmp___1 - s);
#line 160
  tmp___3 = scale(2);
#line 160
  points[1] = coordAdd((XPoint const   */* const  */)(& points[0]), tmp___3, 0);
#line 161
  tmp___4 = scale(5);
#line 161
  tmp___5 = scale(5);
#line 161
  points[2] = coordAdd((XPoint const   */* const  */)(& points[1]), tmp___5, tmp___4);
#line 163
  tmp___6 = scale(13);
#line 163
  tmp___7 = scale(5);
#line 163
  points[5] = coordAdd((XPoint const   */* const  */)(& base), tmp___7 - s, tmp___6 - s);
#line 164
  tmp___8 = scale(2);
#line 164
  points[4] = coordAdd((XPoint const   */* const  */)(& points[5]), tmp___8, 0);
#line 165
  tmp___9 = scale(5);
#line 165
  tmp___10 = scale(5);
#line 165
  points[3] = coordAdd((XPoint const   */* const  */)(& points[4]), tmp___10, - tmp___9);
  }
#line 167
  if (! buttonDown) {
    {
#line 171
    XFillPolygon(dpy, topLevel, c, points, 6, 2, 0);
#line 174
    points[2].y = (short )((int )points[2].y + 1);
#line 175
    points[5].x = (short )((int )points[5].x + 1);
#line 178
    i = 2;
    }
    {
#line 178
    while (1) {
      while_continue: /* CIL Label */ ;
#line 178
      if (! (i > 0)) {
#line 178
        goto while_break;
      }
      {
#line 180
      XDrawLines(dpy, topLevel, gc_black, & points[2], 4, 0);
#line 182
      XDrawLine(dpy, topLevel, gc_black, (int )points[3].x - 1, (int )points[3].y,
                (int )points[4].x - 1, (int )points[4].y);
#line 185
      points[2].x = (short )((int )points[2].x + 1);
#line 185
      points[2].y = (short )((int )points[2].y + 1);
#line 186
      points[3].x = (short )((int )points[3].x + 1);
#line 186
      points[3].y = (short )((int )points[3].y + 1);
#line 187
      points[4].x = (short )((int )points[4].x + 1);
#line 187
      points[4].y = (short )((int )points[4].y + 1);
#line 188
      points[5].x = (short )((int )points[5].x + 1);
#line 188
      points[5].y = (short )((int )points[5].y + 1);
#line 178
      i --;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 193
    x = (int )points[0].x;
#line 194
    y = (int )points[0].y;
#line 195
    w = (unsigned int )((int )points[2].x - (int )points[0].x);
#line 196
    h = (unsigned int )((int )points[4].y - (int )points[0].y);
#line 198
    XFillPolygon(dpy, topLevel, c, points, 6, 2, 0);
#line 202
    XFillRectangle(dpy, topLevel, gc_white, x - d, y - d, (unsigned int )d, h + (unsigned int )d);
#line 204
    XFillRectangle(dpy, topLevel, gc_white, x, y - d, w, (unsigned int )d);
    }
  }
#line 206
  return;
}
}
#line 217 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static void my_start(char *command___0 ) 
{ 
  int maxFd ;
  char buffer[16348] ;
  char *cmd[4] ;

  {
#line 220
  if (pid > 0) {
#line 222
    return;
  }
#line 226
  if (nextHelper) {
    {
#line 231
    XDestroyWindow(dpy, topLevel);
#line 232
    close(((_XPrivDisplay )dpy)->fd);
#line 234
    restore_SIGCHLD_to_default();
#line 236
    cmd[0] = (char *)nextHelper;
#line 238
    snprintf((char */* __restrict  */)(buffer), sizeof(buffer), (char const   */* __restrict  */)"%d,%d,%d,%lu,%d,%d,%d,%d",
             flags___0, repeats, pipe_fd, parentDetails.window, parentDetails.x, parentDetails.y,
             (int )parentDetails.width, (int )parentDetails.height);
#line 249
    cmd[1] = buffer;
#line 250
    cmd[2] = command___0;
#line 251
    cmd[3] = (char *)0;
#line 253
    D((char *)"Switching to helper\n");
#line 254
    execvp(nextHelper, (char * const  *)(cmd));
#line 255
    exit(69);
    }
  }
#line 259
  maxFd = pipe_fd;
#line 260
  if (dpy) {
#line 260
    if (((_XPrivDisplay )dpy)->fd > maxFd) {
#line 262
      maxFd = ((_XPrivDisplay )dpy)->fd;
    }
  }
  {
#line 265
  pid = spawn_app(command___0, (int const   )flags___0, (int const   )maxFd);
  }
#line 266
  if (pid == -1) {
#line 268
    return;
  }
#line 271
  if (! repeats) {
#line 273
    repeats = repeatsResetVal;
  }
#line 275
  if (repeats > 0) {
#line 275
    if (repeats != 2147483647) {
#line 277
      repeats --;
    }
  }
#line 279
  return;
}
}
#line 288 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static void low_die(void) 
{ 


  {
#line 290
  if (pid > 0) {
    {
#line 292
    my_kill(- pid);
    }
  }
  {
#line 294
  _exit(0);
  }
}
}
#line 310 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static int die(Display *dpy___1 , XErrorEvent *ev ) 
{ 


  {
  {
#line 312
  low_die();
  }
#line 313
  return (0);
}
}
#line 328 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static int die2(Display *dpy___1 ) 
{ 


  {
  {
#line 330
  low_die();
  }
#line 331
  return (0);
}
}
#line 344 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static void sigdie(int sig ) 
{ 


  {
  {
#line 346
  low_die();
  }
#line 347
  return;
}
}
#line 359 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static void check_x_events(char *command___0 ) 
{ 
  int numEvents ;
  int tmp ;
  XEvent ev ;

  {
  {
#line 361
  tmp = XPending(dpy);
#line 361
  numEvents = tmp;
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 363
    if (! (numEvents > 0)) {
#line 363
      goto while_break;
    }
    {
#line 367
    XNextEvent(dpy, & ev);
    }
    {
#line 371
    if (ev.type == 4) {
#line 371
      goto case_4;
    }
#line 382
    if (ev.type == 5) {
#line 382
      goto case_5;
    }
#line 390
    if (ev.type == 12) {
#line 390
      goto case_12;
    }
#line 396
    if (ev.type == 19) {
#line 396
      goto case_19;
    }
#line 396
    if (ev.type == 25) {
#line 396
      goto case_19;
    }
#line 400
    goto switch_default;
    case_4: /* CIL Label */ 
#line 372
    if (ev.xbutton.button == 1U) {
      {
#line 374
      buttonDown = 1;
#line 375
      redraw();
#line 376
      XSync(dpy, 0);
#line 378
      my_start(command___0);
      }
    }
#line 380
    goto switch_break;
    case_5: /* CIL Label */ 
#line 383
    if (buttonDown) {
      {
#line 385
      buttonDown = 0;
#line 386
      redraw();
      }
    }
#line 388
    goto switch_break;
    case_12: /* CIL Label */ 
#line 391
    if (ev.xexpose.count) {
#line 393
      goto switch_break;
    }
    case_19: /* CIL Label */ 
    case_25: /* CIL Label */ 
    {
#line 397
    redraw();
    }
#line 398
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 401
    D((char *)"Unknown event %d\n", ev.type);
    }
#line 402
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 407
    numEvents --;
#line 408
    if (numEvents == 0) {
      {
#line 410
      numEvents = XPending(dpy);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 413
  return;
}
}
#line 429 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static void normalise_window_coords(unsigned int *width , unsigned int *height , int *x ,
                                    int *y ) 
{ 
  unsigned int w ;
  unsigned int h ;
  int tmp ;

  {
#line 432
  w = *width;
#line 433
  h = *height;
#line 435
  if ((unsigned int )flags___0 & 1024U) {
#line 437
    tmp = 0;
#line 437
    *y = tmp;
#line 437
    *x = tmp;
#line 438
    return;
  }
#line 441
  if ((w > 100U) & ! ((unsigned int )flags___0 & 512U)) {
#line 443
    w = 100U;
  }
#line 447
  if (h < w) {
#line 449
    w = h;
  } else
#line 451
  if (h > w) {
#line 453
    h = w;
  }
#line 456
  *x = (int )(*width - w) / 2;
#line 457
  *y = (int )(*height - h) / 2;
#line 459
  *height = h;
#line 460
  *width = w;
#line 461
  return;
}
}
#line 471 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static void check_pipe_fd_events(void) 
{ 
  NPWindow wintmp___0 ;
  int n ;
  int x ;
  int y ;
  unsigned int w ;
  unsigned int h ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  {
#line 478
  D((char *)"Got pipe_fd data, pipe_fd=%d\n", pipe_fd);
#line 480
  tmp = read(pipe_fd, (void *)((char *)(& wintmp___0)), sizeof(wintmp___0));
#line 480
  n = (int )tmp;
  }
#line 481
  if (n < 0) {
    {
#line 483
    tmp___0 = __errno_location();
    }
#line 483
    if (*tmp___0 == 4) {
#line 485
      return;
    }
    {
#line 487
    exit(69);
    }
  }
#line 490
  if (n == 0) {
    {
#line 492
    exit(69);
    }
  }
#line 495
  if ((unsigned long )n != sizeof(wintmp___0)) {
#line 497
    return;
  }
  {
#line 500
  parentDetails.window = (Window )wintmp___0.window;
#line 501
  parentDetails.x = wintmp___0.x;
#line 502
  parentDetails.y = wintmp___0.y;
#line 503
  parentDetails.width = wintmp___0.width;
#line 504
  parentDetails.height = wintmp___0.height;
#line 507
  w = wintmp___0.width - 2U;
#line 508
  h = wintmp___0.height - 2U;
#line 510
  normalise_window_coords(& w, & h, & x, & y);
#line 512
  D((char *)"Linker window: x=%i, y=%i, w=%u, h=%u\n", x, y, w, h);
#line 514
  XMoveResizeWindow(dpy, topLevel, x, y, w, h);
  }
#line 515
  return;
}
}
#line 526 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
static void exitEarly(void) 
{ 


  {
  {
#line 528
  D((char *)"Invalid parameters passed to Linker - linker exiting\n");
#line 530
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MozPlugger version 1.14.5 linker application.\nPlease see \'man mozplugger\' for details.\n");
#line 533
  exit(1);
  }
}
}
#line 551 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-linker.c"
int main(int argc , char **argv ) 
{ 
  int old_pid ;
  unsigned long temp ;
  int x ;
  int y ;
  unsigned int width ;
  unsigned int height ;
  char *command___0 ;
  int i ;
  XColor colour ;
  XClassHint classhint ;
  XSetWindowAttributes attr ;
  XSizeHints wmHints ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  fd_set fds ;
  int maxFd ;
  int sig_chld_fd ;
  int __d0 ;
  int __d1 ;
  int tmp___3 ;
  int status ;
  __pid_t tmp___4 ;

  {
  {
#line 555
  temp = 0UL;
#line 566
  D((char *)"Linker started.....\n");
  }
#line 568
  if (argc < 3) {
    {
#line 570
    exitEarly();
    }
  }
  {
#line 573
  i = sscanf((char const   */* __restrict  */)*(argv + 1), (char const   */* __restrict  */)"%d,%d,%d,%lu,%d,%d,%d,%d",
             & flags___0, & repeatsResetVal, & pipe_fd, & temp, & parentDetails.x,
             & parentDetails.y, & parentDetails.width, & parentDetails.height);
  }
#line 583
  if (i < 8) {
    {
#line 585
    exitEarly();
    }
  }
  {
#line 588
  parentDetails.window = temp;
#line 589
  command___0 = *(argv + 2);
#line 591
  tmp = getenv("file");
#line 591
  D((char *)"LINKER: %s %s %s %s\n", *(argv + 0), *(argv + 1), tmp, command___0);
  }
#line 597
  if (argc > 3) {
#line 599
    nextHelper = (char const   *)*(argv + 3);
  } else {
#line 603
    nextHelper = (char const   *)((void *)0);
  }
#line 607
  if ((unsigned int )flags___0 & 16U) {
#line 609
    repeatsResetVal = 1;
  }
  {
#line 612
  tmp___2 = getenv("DISPLAY");
#line 612
  dpy = XOpenDisplay((char const   *)tmp___2);
  }
#line 612
  if (! dpy) {
    {
#line 614
    tmp___0 = getenv("DISPLAY");
#line 614
    tmp___1 = XDisplayName((char const   *)tmp___0);
#line 614
    D((char *)"%s: unable to open display %s\n", *(argv + 0), tmp___1);
#line 616
    exitEarly();
    }
  }
  {
#line 622
  width = parentDetails.width - 2U;
#line 623
  height = parentDetails.height - 2U;
#line 627
  normalise_window_coords(& width, & height, & x, & y);
#line 629
  D((char *)"Linker window: x=%i, y=%i, w=%u, h=%u\n", x, y, width, height);
#line 631
  wmHints.x = 0;
#line 632
  wmHints.y = 0;
#line 633
  wmHints.min_width = 16;
#line 634
  wmHints.min_height = 16;
#line 635
  wmHints.base_width = 20;
#line 636
  wmHints.base_height = 20;
#line 637
  wmHints.flags = ((1L << 2) | 1L) | (1L << 4);
#line 639
  attr.border_pixel = 0UL;
#line 640
  attr.background_pixel = (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->white_pixel;
#line 641
  attr.event_mask = ((1L << 15) | (1L << 2)) | (1L << 3);
#line 642
  attr.override_redirect = 0;
#line 644
  topLevel = XCreateWindow(dpy, parentDetails.window, x, y, width, height, 1U, 0,
                           1U, (Visual *)0L, (unsigned long )((((1L << 3) | (1L << 11)) | (1L << 9)) | (1L << 1)),
                           & attr);
#line 657
  classhint.res_name = (char *)"mozplugger-linker";
#line 658
  classhint.res_class = (char *)"mozplugger-linker";
#line 659
  XSetClassHint(dpy, topLevel, & classhint);
#line 660
  XStoreName(dpy, topLevel, "mozplugger-linker");
#line 662
  gc_black = XCreateGC(dpy, topLevel, 0UL, (XGCValues *)0);
#line 663
  XSetForeground(dpy, gc_black, (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->black_pixel);
#line 665
  gc_white = XCreateGC(dpy, topLevel, 0UL, (XGCValues *)0);
#line 666
  XSetForeground(dpy, gc_white, (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->white_pixel);
#line 668
  gc_onColor = XCreateGC(dpy, topLevel, 0UL, (XGCValues *)0);
#line 669
  colour.red = (unsigned short)0;
#line 670
  colour.green = (unsigned short)40960;
#line 671
  colour.blue = (unsigned short)0;
#line 672
  colour.pixel = 0UL;
#line 673
  colour.flags = (char)0;
#line 675
  XAllocColor(dpy, (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->cmap,
              & colour);
#line 676
  XSetForeground(dpy, gc_onColor, colour.pixel);
#line 678
  gc_offColor = XCreateGC(dpy, topLevel, 0UL, (XGCValues *)0);
#line 679
  colour.red = (unsigned short)32768;
#line 680
  colour.green = (unsigned short)32768;
#line 681
  colour.blue = (unsigned short)32768;
#line 682
  colour.pixel = 0UL;
#line 683
  colour.flags = (char)0;
#line 685
  XAllocColor(dpy, (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->cmap,
              & colour);
#line 686
  XSetForeground(dpy, gc_offColor, colour.pixel);
#line 688
  XSetWMNormalHints(dpy, topLevel, & wmHints);
#line 692
  XMapWindow(dpy, topLevel);
#line 694
  XSetIOErrorHandler(& die2);
#line 695
  XSetErrorHandler(& die);
#line 697
  old_pid = pid;
#line 699
  redirect_SIGCHLD_to_fd();
#line 701
  signal(1, & sigdie);
#line 702
  signal(2, & sigdie);
#line 703
  signal(15, & sigdie);
  }
  {
#line 705
  while (1) {
    while_continue: /* CIL Label */ ;
#line 711
    if (pid != old_pid) {
      {
#line 713
      redraw();
#line 714
      old_pid = pid;
      }
    }
    {
#line 717
    check_x_events(command___0);
    }
    {
#line 719
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 719
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.__fds_bits[0]): "memory");
#line 719
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 720
    fds.__fds_bits[((_XPrivDisplay )dpy)->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ((_XPrivDisplay )dpy)->fd % (8 * (int )sizeof(__fd_mask ));
#line 721
    fds.__fds_bits[pipe_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << pipe_fd % (8 * (int )sizeof(__fd_mask ));
#line 723
    if (((_XPrivDisplay )dpy)->fd > pipe_fd) {
#line 723
      maxFd = ((_XPrivDisplay )dpy)->fd;
    } else {
#line 723
      maxFd = pipe_fd;
    }
    {
#line 725
    sig_chld_fd = get_SIGCHLD_fd();
    }
#line 726
    if (sig_chld_fd >= 0) {
#line 728
      fds.__fds_bits[sig_chld_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sig_chld_fd % (8 * (int )sizeof(__fd_mask ));
#line 729
      if (maxFd > sig_chld_fd) {
#line 729
        maxFd = maxFd;
      } else {
#line 729
        maxFd = sig_chld_fd;
      }
    }
    {
#line 732
    D((char *)"SELECT IN maxFd = %i\n", maxFd);
#line 733
    tmp___3 = select(maxFd + 1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)0);
    }
#line 733
    if (tmp___3 > 0) {
#line 735
      if ((fds.__fds_bits[pipe_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << pipe_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 737
        check_pipe_fd_events();
        }
      }
#line 739
      if ((fds.__fds_bits[sig_chld_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << sig_chld_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 741
        handle_SIGCHLD_event();
        }
      }
    }
    {
#line 744
    D((char *)"SELECT OUT\n");
    }
#line 746
    if (pid != -1) {
      {
#line 749
      tmp___4 = waitpid(pid, & status, 1);
      }
#line 749
      if (tmp___4 > 0) {
#line 751
        if (pid > 0) {
#line 753
          pid = -1;
#line 754
          if (repeats > 0) {
            {
#line 756
            my_start(command___0);
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 646 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpgid)(__pid_t __pid ,
                                                                              __pid_t __pgid ) ;
#line 34 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./child.c"
static int sig_fds[2]  ;
#line 46 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./child.c"
void restore_SIGCHLD_to_default(void) 
{ 


  {
#line 48
  if (sig_fds[1] >= 0) {
    {
#line 50
    signal(17, (void (*)(int  ))0);
#line 51
    close(sig_fds[1]);
    }
  }
#line 54
  if (sig_fds[0] >= 0) {
    {
#line 56
    close(sig_fds[0]);
    }
  }
#line 58
  sig_fds[0] = -1;
#line 58
  sig_fds[1] = sig_fds[0];
#line 59
  return;
}
}
#line 73 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./child.c"
static void sig_to_fd(int sig ) 
{ 
  ssize_t tmp ;

  {
  {
#line 75
  D((char *)"Signal %i routed to pipe\n", sig);
#line 76
  tmp = write(sig_fds[1], (void const   *)(& sig), sizeof(int ));
  }
#line 76
  if ((unsigned long )tmp != sizeof(int )) {
    {
#line 78
    D((char *)"Signal write to pipe failed\n");
    }
  }
#line 80
  return;
}
}
#line 91 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./child.c"
void redirect_SIGCHLD_to_fd(void) 
{ 
  int tmp ;

  {
  {
#line 93
  tmp = pipe((int *)(sig_fds));
  }
#line 93
  if (tmp != 0) {
    {
#line 95
    D((char *)"Failed to create pipe to handle signals");
#line 96
    sig_fds[1] = -1;
#line 96
    sig_fds[0] = sig_fds[1];
    }
  }
#line 99
  if (sig_fds[1] >= 0) {
    {
#line 102
    signal(17, & sig_to_fd);
    }
  }
#line 104
  return;
}
}
#line 114 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./child.c"
int get_SIGCHLD_fd(void) 
{ 


  {
#line 116
  return (sig_fds[0]);
}
}
#line 127 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./child.c"
void handle_SIGCHLD_event(void) 
{ 
  int sig ;

  {
  {
#line 130
  read(sig_fds[0], (void *)(& sig), sizeof(int ));
  }
#line 131
  return;
}
}
#line 149 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./child.c"
pid_t spawn_app(char *command___0 , int const   flags___3 , int maxFd ) 
{ 
  pid_t pid___1 ;
  __pid_t tmp ;
  int i ;
  char *app_argv[4] ;
  int ofd ;
  int tmp___0 ;
  int ifd ;
  int tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 151
  tmp = fork();
#line 151
  pid___1 = tmp;
  }
#line 153
  if (pid___1 == 0) {
#line 158
    if (((unsigned int )flags___3 & 12288U) != 0U) {
      {
#line 160
      setpgid(pid___1, 0);
      }
    }
#line 163
    app_argv[0] = (char *)"/bin/sh";
#line 164
    app_argv[1] = (char *)"-c";
#line 165
    app_argv[2] = command___0;
#line 166
    app_argv[3] = (char *)0;
#line 169
    if (((unsigned int )flags___3 & 10U) != 0U) {
      {
#line 171
      tmp___0 = open("/dev/null", 0);
#line 171
      ofd = tmp___0;
#line 173
      D((char *)"Redirecting stdout and stderr\n");
      }
#line 175
      if (ofd == -1) {
        {
#line 177
        exit(69);
        }
      }
      {
#line 180
      dup2(ofd, 1);
#line 181
      dup2(ofd, 2);
#line 182
      close(ofd);
      }
    }
#line 188
    if (((unsigned int )flags___3 & 2U) != 0U) {
      {
#line 190
      tmp___1 = open("/dev/null", 1);
#line 190
      ifd = tmp___1;
#line 192
      D((char *)"Redirecting stdin also\n");
      }
#line 194
      if (ifd == -1) {
        {
#line 196
        exit(69);
        }
      }
      {
#line 198
      dup2(ifd, 0);
#line 199
      close(ifd);
      }
    }
    {
#line 202
    D((char *)"Running %s\n", command___0);
#line 204
    close_debug();
#line 206
    i = 0;
    }
    {
#line 206
    while (1) {
      while_continue: /* CIL Label */ ;
#line 206
      if (! (i < 2)) {
#line 206
        goto while_break;
      }
      {
#line 208
      close(sig_fds[i]);
#line 206
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 210
    i = 3;
    {
#line 210
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 210
      if (! (i <= maxFd)) {
#line 210
        goto while_break___0;
      }
      {
#line 212
      close(i);
#line 210
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 215
    execvp((char const   *)app_argv[0], (char * const  *)(app_argv));
#line 216
    tmp___2 = __errno_location();
#line 216
    D((char *)"Execvp failed. (errno=%d)\n", *tmp___2);
#line 217
    exit(69);
    }
  }
#line 219
  return (pid___1);
}
}
#line 671 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getsid)(__pid_t __pid ) ;
#line 879
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 1548 "/usr/include/X11/Xlib.h"
extern Atom XInternAtom(Display * , char const   * , int  ) ;
#line 1911
extern int XWithdrawWindow(Display * , Window  , int  ) ;
#line 2080
extern int XChangeProperty(Display * , Window  , Atom  , Atom  , int  , int  , unsigned char const   * ,
                           int  ) ;
#line 2172
extern int XCloseDisplay(Display * ) ;
#line 2249
extern int XDeleteProperty(Display * , Window  , Atom  ) ;
#line 2465
extern int XFetchName(Display * , Window  , char ** ) ;
#line 2528
extern int XFree(void * ) ;
#line 2612
extern int XGetErrorText(Display * , int  , char * , int  ) ;
#line 2688
extern int XGetWindowProperty(Display * , Window  , Atom  , long  , long  , int  ,
                              Atom  , Atom * , int * , unsigned long * , unsigned long * ,
                              unsigned char ** ) ;
#line 3099
extern int XReparentWindow(Display * , Window  , Window  , int  , int  ) ;
#line 3141
extern int XSelectInput(Display * , Window  , long  ) ;
#line 3147
extern int XSendEvent(Display * , Window  , int  , long  , XEvent * ) ;
#line 3369
extern int XSetWindowBorderWidth(Display * , Window  , unsigned int  ) ;
#line 423 "/usr/include/X11/Xutil.h"
extern int XGetClassHint(Display * , Window  , XClassHint * ) ;
#line 484
extern XWMHints *XGetWMHints(Display * , Window  ) ;
#line 641
extern int XSetWMHints(Display * , Window  , XWMHints * ) ;
#line 55 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static struct __anonstruct_victimDetails_160 victimDetails  ;
#line 70 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static struct __anonstruct_parentDetails_161 parentDetails___0  ;
#line 81 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static Display *display  =    (Display *)0;
#line 82 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static int pipe_fd___0  ;
#line 83 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static int flags___1  ;
#line 84 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static int repeats___0  ;
#line 85 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static char *winname  ;
#line 86 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static char *command  ;
#line 87 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static char *file  ;
#line 89 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static XWindowAttributes wattr  ;
#line 92 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static Atom swallowMutex  ;
#line 93 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static int swallowMutexTaken  ;
#line 96 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static Atom windowOwnerMark  ;
#line 98 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static int xaspect  ;
#line 99 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static int yaspect  ;
#line 102 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static unsigned int possible_victim_count  =    0U;
#line 103 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static Window possible_victim_windows[100]  ;
#line 119 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static int error_handler(Display *dpy___1 , XErrorEvent *err ) 
{ 
  char buffer[1024] ;

  {
  {
#line 122
  XGetErrorText(dpy___1, (int )err->error_code, buffer, (int )sizeof(buffer));
#line 123
  D((char *)"!!!ERROR_HANDLER!!!: %s\n", buffer);
  }
#line 124
  return (0);
}
}
#line 135 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static void initSwallowMutex(void) 
{ 


  {
  {
#line 137
  D((char *)"Initialising Swallow Mutex\n");
  }
#line 138
  if ((unsigned long )display == (unsigned long )((Display *)0)) {
    {
#line 140
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Display not set so cannot initialise semaphore!\n");
    }
  } else {
    {
#line 144
    swallowMutex = XInternAtom(display, "MOZPLUGGER_SWALLOW_MUTEX", 0);
#line 145
    swallowMutexTaken = 0;
    }
  }
#line 147
  return;
}
}
#line 157 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static void initWindowOwnerMarker(void) 
{ 


  {
  {
#line 159
  windowOwnerMark = XInternAtom(display, "MOZPLUGGER_OWNER", 0);
  }
#line 160
  return;
}
}
#line 169 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static uint32_t getHostId(void) 
{ 
  char hostName[128] ;
  uint32_t id ;
  int i ;

  {
  {
#line 175
  memset((void *)(hostName), 0, sizeof(hostName));
#line 176
  gethostname(hostName, sizeof(hostName) - 1UL);
#line 178
  D((char *)"Host Name = \"%s\"\n", hostName);
#line 184
  id = (uint32_t )0;
#line 185
  i = 0;
  }
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! (i < (int )(sizeof(hostName) / sizeof(uint32_t )))) {
#line 185
      goto while_break;
    }
#line 187
    id = ((id << 5) ^ (id >> 27)) ^ *((uint32_t *)(hostName) + i);
#line 185
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  return (id);
}
}
#line 206 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static int getOwnerFromProperty(Window w , Atom name , uint32_t *hostId , uint32_t *pid___1 ) 
{ 
  unsigned long nitems ;
  unsigned long bytes ;
  int fmt ;
  Atom type ;
  unsigned char *property ;
  int success ;

  {
  {
#line 212
  property = (unsigned char *)((void *)0);
#line 213
  success = 0;
#line 219
  XGetWindowProperty(display, w, name, 0L, 2L, 0, (Atom )19, & type, & fmt, & nitems,
                     & bytes, & property);
  }
#line 224
  if (property) {
    {
#line 226
    D((char *)"XGetWindowProperty() passed\n");
    }
#line 229
    if (type != 19UL) {
      {
#line 231
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"XGetWindowProperty returned bad values %ld,%d,%lu,%lu\n",
              (long )type, fmt, nitems, bytes);
      }
    } else
#line 229
    if (fmt != 32) {
      {
#line 231
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"XGetWindowProperty returned bad values %ld,%d,%lu,%lu\n",
              (long )type, fmt, nitems, bytes);
      }
    } else
#line 229
    if (nitems != 2UL) {
      {
#line 231
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"XGetWindowProperty returned bad values %ld,%d,%lu,%lu\n",
              (long )type, fmt, nitems, bytes);
      }
    } else {
#line 237
      *hostId = (uint32_t )*((unsigned long *)property + 0);
#line 238
      *pid___1 = (uint32_t )*((unsigned long *)property + 1);
#line 239
      success = 1;
    }
    {
#line 241
    XFree((void *)property);
    }
  } else {
    {
#line 245
    D((char *)"XGetWindowProperty() failed\n");
    }
  }
#line 247
  return (success);
}
}
#line 261 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static int getSwallowMutexOwner(uint32_t *hostId , uint32_t *pid___1 ) 
{ 
  int tmp ;

  {
  {
#line 263
  tmp = getOwnerFromProperty(wattr.root, swallowMutex, hostId, pid___1);
  }
#line 263
  return (tmp);
}
}
#line 276 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static void setSwallowMutexOwner(uint32_t hostId , uint32_t pid___1 ) 
{ 
  unsigned long temp[2] ;

  {
  {
#line 278
  temp[0] = (unsigned long )hostId;
#line 278
  temp[1] = (unsigned long )pid___1;
#line 280
  D((char *)"Setting swallow mutex owner, hostId = 0x%08X, pid=%u\n", hostId, pid___1);
#line 282
  XChangeProperty(display, wattr.root, swallowMutex, (Atom )19, 32, 2, (unsigned char const   *)((unsigned char *)(& temp)),
                  2);
  }
#line 285
  return;
}
}
#line 294 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static void takeSwallowMutex(void) 
{ 
  int countDown ;
  uint32_t ourPid ;
  __pid_t tmp ;
  uint32_t ourHostId ;
  uint32_t tmp___0 ;
  uint32_t otherPid ;
  uint32_t otherHostId ;
  uint32_t prevOtherPid ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 297
  tmp = getpid();
#line 297
  ourPid = (uint32_t )tmp;
#line 298
  tmp___0 = getHostId();
#line 298
  ourHostId = tmp___0;
#line 301
  prevOtherPid = (uint32_t )0;
  }
#line 303
  if ((unsigned long )display == (unsigned long )((Display *)0)) {
#line 305
    return;
  } else
#line 303
  if (swallowMutex == 0UL) {
#line 305
    return;
  }
  {
#line 308
  D((char *)"Attempting to take Swallow Mutex\n");
#line 312
  countDown = 40;
  }
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 317
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 317
      tmp___3 = getSwallowMutexOwner(& otherHostId, & otherPid);
      }
#line 317
      if (! tmp___3) {
#line 317
        goto while_break___0;
      }
#line 319
      if (otherHostId == ourHostId) {
#line 321
        if (otherPid == ourPid) {
          {
#line 326
          swallowMutexTaken = 1;
#line 327
          D((char *)"Taken Swallow Mutex\n");
          }
#line 328
          return;
        }
        {
#line 331
        D((char *)"Semaphore currently taken by pid=%ld\n", (long )otherPid);
#line 335
        tmp___1 = getsid((__pid_t )otherPid);
        }
#line 335
        if (tmp___1 < 0) {
          {
#line 335
          tmp___2 = __errno_location();
          }
#line 335
          if (*tmp___2 == 3) {
            {
#line 337
            D((char *)"Strange other Pid(%lu) cannot be found\n", (unsigned long )otherPid);
#line 338
            XDeleteProperty(display, wattr.root, swallowMutex);
            }
#line 339
            goto while_break___0;
          }
        }
      }
#line 345
      if (prevOtherPid != otherPid) {
        {
#line 347
        D((char *)"Looks like semaphore\'s owner has changed pid=%ld\n", (long )otherPid);
#line 349
        countDown = 40;
#line 350
        prevOtherPid = otherPid;
        }
      }
#line 354
      countDown --;
#line 355
      if (countDown <= 0) {
        {
#line 357
        D((char *)"Waited long enough for Pid(%lu)\n", (unsigned long )otherPid);
#line 358
        XDeleteProperty(display, wattr.root, swallowMutex);
        }
#line 359
        goto while_break___0;
      }
      {
#line 362
      usleep((__useconds_t )250000);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 373
    setSwallowMutexOwner(ourHostId, ourPid);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 384 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static int stillHaveMutex(void) 
{ 
  uint32_t otherPid ;
  uint32_t otherHostId ;
  uint32_t ourHostId ;
  uint32_t tmp ;
  uint32_t ourPid ;
  __pid_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 389
  tmp___1 = getSwallowMutexOwner(& otherHostId, & otherPid);
  }
#line 389
  if (tmp___1) {
    {
#line 391
    tmp = getHostId();
#line 391
    ourHostId = tmp;
    }
#line 392
    if (otherHostId == ourHostId) {
      {
#line 394
      tmp___0 = getpid();
#line 394
      ourPid = (uint32_t )tmp___0;
      }
#line 395
      if (otherPid == ourPid) {
#line 397
        return (1);
      }
    }
  }
  {
#line 401
  D((char *)"Race condition detected, semaphore pinched by Pid(%lu)\n", (unsigned long )otherPid);
  }
#line 403
  return (0);
}
}
#line 413 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static void giveSwallowMutex(void) 
{ 


  {
#line 415
  if ((unsigned long )display == (unsigned long )((Display *)0)) {
#line 417
    return;
  } else
#line 415
  if (swallowMutex == 0UL) {
#line 417
    return;
  } else
#line 415
  if (swallowMutexTaken == 0) {
#line 417
    return;
  }
  {
#line 419
  D((char *)"Giving Swallow Mutex\n");
#line 420
  XDeleteProperty(display, wattr.root, swallowMutex);
#line 421
  swallowMutexTaken = 0;
  }
#line 422
  return;
}
}
#line 436 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static int chkAndMarkVictimWindow(Window w ) 
{ 
  unsigned long temp[2] ;
  uint32_t ourPid ;
  uint32_t ourHostId ;
  uint32_t pid___1 ;
  uint32_t hostId ;
  int gotIt ;
  int tmp ;
  __pid_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 444
  gotIt = 0;
#line 448
  tmp = getOwnerFromProperty(w, windowOwnerMark, & hostId, & pid___1);
  }
#line 448
  if (tmp) {
#line 450
    return (0);
  }
  {
#line 454
  tmp___0 = getpid();
#line 454
  ourPid = (uint32_t )tmp___0;
#line 455
  ourHostId = getHostId();
#line 457
  temp[0] = (unsigned long )ourHostId;
#line 458
  temp[1] = (unsigned long )ourPid;
#line 460
  XChangeProperty(display, w, windowOwnerMark, (Atom )19, 32, 2, (unsigned char const   *)((unsigned char *)(& temp)),
                  2);
#line 465
  tmp___1 = getOwnerFromProperty(w, windowOwnerMark, & hostId, & pid___1);
  }
#line 465
  if (tmp___1) {
#line 467
    if (pid___1 == ourPid) {
#line 467
      if (hostId == ourHostId) {
#line 469
        gotIt = 1;
      }
    }
  } else {
    {
#line 474
    D((char *)"Strange, couldn\'t set windowOwnerMark\n");
#line 475
    gotIt = 1;
    }
  }
#line 478
  return (gotIt);
}
}
#line 492 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static int gcd(int a , int b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 494
  if (a < b) {
    {
#line 496
    tmp = gcd(b, a);
    }
#line 496
    return (tmp);
  }
#line 498
  if (b == 0) {
#line 500
    return (a);
  }
  {
#line 502
  tmp___0 = gcd(b, a % b);
  }
#line 502
  return (tmp___0);
}
}
#line 515 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static int set_aspect(int x , int y ) 
{ 
  int ox ;
  int oy ;
  int d ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 517
  ox = xaspect;
#line 518
  oy = yaspect;
#line 519
  tmp = gcd(x, y);
#line 519
  d = tmp;
#line 520
  xaspect = x / d;
#line 521
  yaspect = y / d;
#line 522
  D((char *)"xaspect=%d yaspect=%d\n", xaspect, yaspect);
  }
#line 523
  if (ox != xaspect) {
#line 523
    tmp___0 = 1;
  } else
#line 523
  if (oy != yaspect) {
#line 523
    tmp___0 = 1;
  } else {
#line 523
    tmp___0 = 0;
  }
#line 523
  return (tmp___0);
}
}
#line 533 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static void adjust_window_size(void) 
{ 
  int x ;
  int y ;
  int w ;
  int h ;
  int tmpw ;
  int tmph ;
  XEvent event ;

  {
#line 535
  x = 0;
#line 536
  y = 0;
#line 537
  w = parentDetails___0.width;
#line 538
  h = parentDetails___0.height;
#line 541
  if ((unsigned int )flags___1 & 1024U) {
    {
#line 543
    D((char *)"Resizing window 0x%x with FILL\n", (unsigned int )victimDetails.window);
    }
  } else
#line 545
  if ((unsigned int )flags___1 & 512U) {
#line 547
    if (xaspect) {
#line 547
      if (yaspect) {
        {
#line 551
        D((char *)"Resizing window 0x%x with MAXASPECT\n", (unsigned int )victimDetails.window);
#line 553
        tmph = h / yaspect;
#line 554
        tmpw = w / xaspect;
        }
#line 555
        if (tmpw < tmph) {
#line 557
          tmph = tmpw;
        }
#line 559
        tmpw = tmph * xaspect;
#line 560
        tmph *= yaspect;
#line 562
        x = (w - tmpw) / 2;
#line 563
        y = (h - tmph) / 2;
#line 565
        w = tmpw;
#line 566
        h = tmph;
      } else {
        {
#line 570
        D((char *)"Not resizing window\n");
        }
#line 571
        return;
      }
    } else {
      {
#line 570
      D((char *)"Not resizing window\n");
      }
#line 571
      return;
    }
  }
  {
#line 576
  w -= 2 * victimDetails.borderWidth;
#line 577
  h -= 2 * victimDetails.borderWidth;
#line 579
  D((char *)"New size: %dx%d+%d+%d\n", w, h, x, y);
  }
#line 581
  if (victimDetails.x == x) {
#line 581
    if (victimDetails.y == y) {
#line 581
      if (victimDetails.width == w) {
#line 581
        if (victimDetails.height == h) {
          {
#line 585
          D((char *)"No change in window size so sending ConfigureNotify instead\n");
#line 591
          event.type = 22;
#line 592
          event.xconfigure.display = display;
#line 593
          event.xconfigure.event = victimDetails.window;
#line 594
          event.xconfigure.window = victimDetails.window;
#line 595
          event.xconfigure.x = x;
#line 596
          event.xconfigure.y = y;
#line 597
          event.xconfigure.width = w;
#line 598
          event.xconfigure.height = h;
#line 599
          event.xconfigure.border_width = victimDetails.borderWidth;
#line 600
          event.xconfigure.above = (Window )0;
#line 601
          event.xconfigure.override_redirect = 0;
#line 603
          XSendEvent(display, victimDetails.window, 0, 1L << 17, & event);
          }
        }
      }
    }
  }
  {
#line 609
  XMoveResizeWindow(display, victimDetails.window, x, y, (unsigned int )w, (unsigned int )h);
#line 611
  victimDetails.x = x;
#line 612
  victimDetails.y = y;
#line 613
  victimDetails.width = w;
#line 614
  victimDetails.height = h;
  }
#line 615
  return;
}
}
#line 627 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static void change_leader(void) 
{ 
  XWMHints *leader_change ;

  {
  {
#line 629
  D((char *)"Changing leader of window 0x%x\n", (unsigned int )victimDetails.window);
#line 632
  leader_change = XGetWMHints(display, victimDetails.window);
  }
#line 632
  if (leader_change) {
#line 634
    if ((leader_change->flags & (1L << 6)) != 0L) {
      {
#line 636
      D((char *)"Old window leader was 0x%x\n", (unsigned int )leader_change->window_group);
      }
    }
#line 639
    if ((leader_change->flags & 1L) != 0L) {
      {
#line 641
      D((char *)"Input hint = %i\n", leader_change->input);
      }
    }
#line 643
    if ((leader_change->flags & (1L << 1)) != 0L) {
      {
#line 645
      D((char *)"InitialState hint = %i\n", (unsigned int )leader_change->initial_state);
      }
    }
    {
#line 649
    leader_change->flags |= 1L << 6;
#line 650
    leader_change->window_group = wattr.root;
#line 652
    D((char *)"New window leader is 0x%x\n", (unsigned int )leader_change->window_group);
#line 654
    XSetWMHints(display, victimDetails.window, leader_change);
#line 655
    XFree((void *)leader_change);
    }
  } else {
    {
#line 659
    D((char *)"XGetWMHints returned NULL\n");
    }
  }
#line 661
  return;
}
}
#line 675 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static void reparent_window(void) 
{ 


  {
#line 677
  if (! victimDetails.window) {
    {
#line 679
    D((char *)"reparent_window: No victim to reparent\n");
    }
#line 680
    return;
  }
#line 682
  if (! parentDetails___0.window) {
    {
#line 684
    D((char *)"reparent_window: No parent to reparent to\n");
    }
#line 685
    return;
  }
#line 688
  if (victimDetails.reparentedAttemptCount > 10) {
    {
#line 690
    D((char *)"Giving up reparenting to avoid - tried 10 times\n");
    }
#line 691
    return;
  }
  {
#line 694
  (victimDetails.reparentedAttemptCount) ++;
#line 697
  D((char *)"Reparenting window 0x%x into 0x%x\n", (unsigned int )victimDetails.window,
    (unsigned int )parentDetails___0.window);
#line 700
  XReparentWindow(display, victimDetails.window, parentDetails___0.window, 0, 0);
  }
#line 701
  return;
}
}
#line 714 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static int my_strcmp(char const   *windowname , char const   *name ) 
{ 
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 716
  if (! name) {
#line 718
    return (1);
  }
#line 720
  if (! windowname) {
#line 722
    return (1);
  }
  {
#line 727
  if ((int const   )*(name + 0) == 61) {
#line 727
    goto case_61;
  }
#line 729
  if ((int const   )*(name + 0) == 126) {
#line 729
    goto case_126;
  }
#line 731
  if ((int const   )*(name + 0) == 42) {
#line 731
    goto case_42;
  }
#line 733
  goto switch_default;
  case_61: /* CIL Label */ 
  {
#line 728
  tmp = strcmp(name + 1, windowname);
  }
#line 728
  return (tmp);
  case_126: /* CIL Label */ 
  {
#line 730
  tmp___0 = strcasecmp(name + 1, windowname);
  }
#line 730
  return (tmp___0);
  case_42: /* CIL Label */ 
  {
#line 732
  tmp___1 = strlen(name);
#line 732
  tmp___2 = strncasecmp(name + 1, windowname, tmp___1 - 1UL);
  }
#line 732
  return (tmp___2);
  switch_default: /* CIL Label */ 
  {
#line 736
  tmp___3 = strstr(windowname, name);
  }
#line 736
  if (tmp___3) {
#line 736
    tmp___4 = 0;
  } else {
#line 736
    tmp___4 = 1;
  }
#line 736
  return (tmp___4);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 750 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static char check_window_name(Window w , char const   *name ) 
{ 
  char *windowname ;
  XClassHint windowclass ;
  char match ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char match___0 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 755
  tmp___1 = XFetchName(display, w, & windowname);
  }
#line 755
  if (tmp___1) {
    {
#line 757
    tmp = my_strcmp((char const   *)windowname, name);
#line 757
    match = (char )(tmp == 0);
    }
#line 759
    if (match) {
#line 759
      tmp___0 = "==";
    } else {
#line 759
      tmp___0 = "!=";
    }
    {
#line 759
    D((char *)"XFetchName, checking window NAME 0x%x (%s %s %s)\n", (unsigned int )w,
      windowname, tmp___0, name);
#line 761
    XFree((void *)windowname);
    }
#line 762
    if (match) {
#line 764
      return ((char)1);
    }
  } else {
    {
#line 769
    D((char *)"XFetchName, window has no NAME\n");
    }
  }
  {
#line 772
  tmp___4 = XGetClassHint(display, w, & windowclass);
  }
#line 772
  if (tmp___4) {
    {
#line 774
    tmp___2 = my_strcmp((char const   *)windowclass.res_name, name);
#line 774
    match___0 = (char )(tmp___2 == 0);
    }
#line 776
    if (match___0) {
#line 776
      tmp___3 = "==";
    } else {
#line 776
      tmp___3 = "!=";
    }
    {
#line 776
    D((char *)"XGetClassHint, checking window CLASS 0x%x (%s %s %s)\n", (unsigned int )w,
      windowclass.res_name, tmp___3, name);
#line 778
    XFree((void *)windowclass.res_class);
#line 779
    XFree((void *)windowclass.res_name);
    }
#line 781
    return (match___0);
  } else {
    {
#line 785
    D((char *)"XGetClassHint, window has no CLASS\n");
    }
  }
#line 787
  return ((char)0);
}
}
#line 800 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static int setup_display(void) 
{ 
  char *displayname ;
  int tmp ;

  {
#line 804
  if (parentDetails___0.window == 0UL) {
    {
#line 806
    D((char *)"setup_display() WINDOW is Null - so nothing setup\n");
    }
#line 807
    return (0);
  }
  {
#line 810
  displayname = getenv("DISPLAY");
#line 811
  D((char *)"setup_display(%s)\n", displayname);
#line 813
  XSetErrorHandler(& error_handler);
#line 815
  display = XOpenDisplay((char const   *)displayname);
  }
#line 816
  if ((unsigned long )display == (unsigned long )((Display *)0)) {
    {
#line 818
    D((char *)"setup_display() failed cannot open display!!\n");
    }
#line 819
    return (0);
  }
  {
#line 822
  tmp = XGetWindowAttributes(display, parentDetails___0.window, & wattr);
  }
#line 822
  if (! tmp) {
    {
#line 824
    D((char *)"setup_display() failed cannot get window attributes!!\n");
#line 825
    XCloseDisplay(display);
#line 826
    display = (Display *)0;
    }
#line 827
    return (0);
  }
  {
#line 829
  D((char *)"display=0x%x\n", (unsigned int )display);
#line 830
  D((char *)"WINDOW =0x%x\n", (unsigned int )parentDetails___0.window);
#line 831
  D((char *)"rootwin=0x%x\n", (unsigned int )wattr.root);
#line 833
  D((char *)"setup_display() done\n");
  }
#line 835
  return (1);
}
}
#line 848 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static void add_possible_victim(Window window ) 
{ 


  {
#line 850
  possible_victim_windows[possible_victim_count] = window;
#line 851
  if (possible_victim_count < 100U) {
#line 853
    possible_victim_count ++;
  }
#line 855
  return;
}
}
#line 866 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static int find_victim(Window window ) 
{ 
  Window found ;
  int i ;
  char tmp ;
  XWindowAttributes ca ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 868
  if (! victimDetails.window) {
    {
#line 870
    found = (Window )0;
#line 872
    D((char *)"Looking for victim... (%s)\n", winname);
#line 876
    i = 0;
    }
    {
#line 876
    while (1) {
      while_continue: /* CIL Label */ ;
#line 876
      if (! ((unsigned int )i < possible_victim_count)) {
#line 876
        goto while_break;
      }
#line 878
      if (window == possible_victim_windows[i]) {
        {
#line 880
        tmp = check_window_name(window, (char const   *)winname);
        }
#line 880
        if (tmp) {
#line 882
          found = (Window )1;
#line 883
          goto while_break;
        }
      }
#line 876
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 888
    if (found) {
      {
#line 891
      tmp___1 = XGetWindowAttributes(display, window, & ca);
      }
#line 891
      if (tmp___1) {
        {
#line 895
        tmp___0 = chkAndMarkVictimWindow(window);
        }
#line 895
        if (tmp___0) {
          {
#line 897
          victimDetails.window = window;
#line 898
          victimDetails.borderWidth = ca.border_width;
#line 899
          victimDetails.x = ca.x;
#line 900
          victimDetails.y = ca.y;
#line 901
          victimDetails.width = ca.width;
#line 902
          victimDetails.height = ca.height;
#line 904
          D((char *)"Found victim=0x%x, x=%i, y=%i, width=%i, height=%i, border=%i\n",
            (unsigned int )victimDetails.window, victimDetails.x, victimDetails.y,
            victimDetails.width, victimDetails.height, victimDetails.borderWidth);
#line 916
          XSelectInput(display, victimDetails.window, 1L << 17);
#line 918
          XSync(display, 0);
#line 920
          XSelectInput(display, wattr.root, 0L);
#line 923
          giveSwallowMutex();
          }
#line 925
          if ((unsigned int )flags___1 & 512U) {
            {
#line 927
            set_aspect(ca.width, ca.height);
            }
          }
#line 929
          return (1);
        } else {
          {
#line 933
          D((char *)"Window 0x%x already claimed by another instance of mozplugger\n",
            (unsigned int )window);
          }
        }
      } else {
        {
#line 939
        D((char *)"XGetWindowAttributes failed for 0x%x\n", (unsigned int )window);
        }
      }
    }
  }
#line 944
  return (0);
}
}
#line 973 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static void handle_rootWindow_event(XEvent const   * const  ev ) 
{ 
  Window wnd ;
  int tmp ;
  Window wnd___0 ;
  int tmp___0 ;

  {
  {
#line 977
  if (ev->type == 16) {
#line 977
    goto case_16;
  }
#line 987
  if (ev->type == 19) {
#line 987
    goto case_19;
  }
#line 1014
  if (ev->type == 21) {
#line 1014
    goto case_21;
  }
#line 1045
  if (ev->type == 22) {
#line 1045
    goto case_22;
  }
#line 1057
  if (ev->type == 18) {
#line 1057
    goto case_18;
  }
#line 1065
  if (ev->type == 17) {
#line 1065
    goto case_17;
  }
#line 1070
  if (ev->type == 33) {
#line 1070
    goto case_33;
  }
#line 1074
  goto switch_default;
  case_16: /* CIL Label */ 
  {
#line 978
  D((char *)"***CreateNotify for root, window=0x%x, override_redirect=%i\n", (unsigned int )ev->xcreatewindow.window,
    ev->xcreatewindow.override_redirect);
#line 984
  add_possible_victim((Window )ev->xcreatewindow.window);
  }
#line 985
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 988
  D((char *)"***MapNotify for root, window=0x%x, override_redirect=%i\n", (unsigned int )ev->xmap.window,
    ev->xmap.override_redirect);
  }
#line 993
  if (! ev->xmap.override_redirect) {
    {
#line 995
    wnd = (Window )ev->xmap.window;
#line 996
    tmp = find_victim(wnd);
    }
#line 996
    if (tmp) {
      {
#line 1005
      D((char *)"Looks like no reparenting WM running\n");
#line 1006
      change_leader();
#line 1007
      victimDetails.noWmRunning = 1;
#line 1008
      reparent_window();
      }
    }
  }
#line 1011
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 1015
  D((char *)"***ReparentNotify for root, parent=0x%x, window=0x%x, x=%i, y=%i, override_redirect=%i\n",
    (unsigned int )ev->xreparent.parent, (unsigned int )ev->xreparent.window, ev->xreparent.x,
    ev->xreparent.y, ev->xreparent.override_redirect);
  }
#line 1024
  if (! ev->xreparent.override_redirect) {
    {
#line 1026
    wnd___0 = (Window )ev->xreparent.window;
#line 1028
    tmp___0 = find_victim(wnd___0);
    }
#line 1028
    if (tmp___0) {
      {
#line 1033
      D((char *)"Withdraw window 0x%x\n", (unsigned int )wnd___0);
#line 1035
      XWithdrawWindow(display, wnd___0, ((_XPrivDisplay )display)->default_screen);
      }
    }
  }
#line 1042
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 1046
  D((char *)"***ConfigureNotify for root, window=0x%x, x=%i, y=%i, width=%i, height=%i, override_redirect=%i\n",
    (unsigned int )ev->xconfigure.window, ev->xconfigure.x, ev->xconfigure.y, ev->xconfigure.width,
    ev->xconfigure.height, ev->xconfigure.override_redirect);
  }
#line 1053
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 1058
  D((char *)"***UnmapNotify for root, window=0x%x, from_configure=%i, send_event=%i\n",
    (unsigned int )ev->xunmap.window, ev->xunmap.from_configure, ev->xunmap.send_event);
  }
#line 1062
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 1066
  D((char *)"***DestroyNotify for root, window=0x%x\n", (unsigned int )ev->xdestroywindow.window);
  }
#line 1068
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 1071
  D((char *)"***ClientMessage for root\n");
  }
#line 1072
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1075
  D((char *)"!!Got unhandled event for root->%d\n", ev->type);
  }
#line 1076
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1078
  return;
}
}
#line 1089 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static void handle_victimWindow_event(XEvent const   * const  ev ) 
{ 


  {
  {
#line 1093
  if (ev->type == 18) {
#line 1093
    goto case_18;
  }
#line 1101
  if (ev->type == 19) {
#line 1101
    goto case_19;
  }
#line 1112
  if (ev->type == 21) {
#line 1112
    goto case_21;
  }
#line 1148
  if (ev->type == 22) {
#line 1148
    goto case_22;
  }
#line 1160
  if (ev->type == 33) {
#line 1160
    goto case_33;
  }
#line 1165
  if (ev->type == 17) {
#line 1165
    goto case_17;
  }
#line 1175
  goto switch_default;
  case_18: /* CIL Label */ 
  {
#line 1094
  D((char *)"UNMAPNOTIFY for victim, window=0x%x, from_configure=%i, send_event=%i\n",
    (unsigned int )ev->xunmap.window, ev->xunmap.from_configure, ev->xunmap.send_event);
#line 1098
  victimDetails.mapped = 0;
  }
#line 1099
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 1102
  D((char *)"MAPNOTIFY for victim, window=0x%x, override_redirect=%i\n", (unsigned int )ev->xmap.window,
    ev->xmap.override_redirect);
#line 1105
  victimDetails.mapped = 1;
  }
#line 1106
  if (victimDetails.reparented) {
    {
#line 1108
    adjust_window_size();
    }
  }
#line 1110
  goto switch_break;
  case_21: /* CIL Label */ 
#line 1113
  if (ev->xreparent.parent == (Window const   )parentDetails___0.window) {
    {
#line 1115
    D((char *)"REPARENT NOTIFY on victim to the right window, parent=0x%x, window=0x%x, x=%i, y=%i, override_redirect=%i\n",
      (unsigned int )ev->xreparent.parent, (unsigned int )ev->xreparent.window, ev->xreparent.x,
      ev->xreparent.y, ev->xreparent.override_redirect);
#line 1122
    victimDetails.reparented = 1;
    }
#line 1123
    if (! victimDetails.mapped) {
      {
#line 1125
      D((char *)"XMapWindow(0x%x)\n", (unsigned int )victimDetails.window);
#line 1126
      XMapWindow(display, victimDetails.window);
      }
    } else {
      {
#line 1130
      adjust_window_size();
      }
    }
  } else {
    {
#line 1135
    D((char *)"REPARENT NOTIFY on victim to some other window! parent=0x%x, window=0x%x, x=%i, y=%i, override_redirect=%i\n",
      (unsigned int )ev->xreparent.parent, (unsigned int )ev->xreparent.window, ev->xreparent.x,
      ev->xreparent.y, ev->xreparent.override_redirect);
#line 1142
    victimDetails.noWmRunning = 0;
#line 1143
    victimDetails.reparented = 0;
#line 1144
    reparent_window();
    }
  }
#line 1146
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 1149
  D((char *)"CONFIGURE NOTIFY for victim, window=0x%x, x=%d, y=%d, w=%d, h=%d, border_width=%d, override_redirect=%i\n",
    (unsigned int )ev->xconfigure.window, ev->xconfigure.x, ev->xconfigure.y, ev->xconfigure.width,
    ev->xconfigure.height, ev->xconfigure.border_width, ev->xconfigure.override_redirect);
  }
#line 1158
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 1161
  D((char *)"CLIENT MESSAGE for victim\n");
  }
#line 1163
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 1166
  D((char *)"DESTROY NOTIFY for victim, window=0x%x\n", (unsigned int )ev->xdestroywindow.window);
  }
#line 1168
  if (ev->xdestroywindow.window == (Window const   )victimDetails.window) {
    {
#line 1170
    XSelectInput(display, victimDetails.window, 0L);
#line 1171
    victimDetails.window = (Window )0;
    }
  }
#line 1173
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1176
  D((char *)"!!Got unhandled event for victim->%d\n", ev->type);
  }
#line 1177
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1179
  return;
}
}
#line 1190 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static void handle_parentWindow_event(XEvent const   * const  ev ) 
{ 
  unsigned long mask ;
  int adjustWindow ;
  int w ;

  {
  {
#line 1195
  if (ev->type == 23) {
#line 1195
    goto case_23;
  }
#line 1234
  goto switch_default;
  case_23: /* CIL Label */ 
  {
#line 1196
  mask = (unsigned long )ev->xconfigurerequest.value_mask;
#line 1197
  D((char *)"ConfigureRequest to WINDOW mask=0x%lx\n", mask);
  }
#line 1198
  if (ev->xconfigurerequest.window != (Window const   )victimDetails.window) {
    {
#line 1200
    D((char *)"- Strange Configure Request not for victim\n");
    }
  } else {
#line 1204
    adjustWindow = 0;
#line 1206
    if (mask & (unsigned long )((1 << 3) | (1 << 2))) {
      {
#line 1208
      D((char *)" - request to set width & height\n");
#line 1209
      set_aspect((int )ev->xconfigurerequest.width, (int )ev->xconfigurerequest.height);
#line 1211
      adjustWindow = 1;
      }
    }
#line 1213
    if (mask & (unsigned long )(1 << 4)) {
      {
#line 1215
      w = (int )ev->xconfigurerequest.border_width;
#line 1216
      D((char *)"- request to set border width=%d\n", w);
      }
#line 1217
      if (victimDetails.borderWidth != w) {
#line 1219
        victimDetails.borderWidth = w;
#line 1220
        adjustWindow = 1;
      }
      {
#line 1222
      XSetWindowBorderWidth(display, victimDetails.window, (unsigned int )w);
      }
    }
#line 1226
    if (adjustWindow) {
#line 1226
      if (victimDetails.mapped) {
#line 1226
        if (victimDetails.reparented) {
          {
#line 1229
          adjust_window_size();
          }
        }
      }
    }
  }
#line 1232
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1235
  D((char *)"!!Got unhandled event for PARENT->%d\n", ev->type);
  }
#line 1236
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1238
  return;
}
}
#line 1250 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static void check_x_events___0(void) 
{ 
  int numEvents ;
  int tmp ;
  XEvent ev ;

  {
  {
#line 1252
  tmp = XPending(display);
#line 1252
  numEvents = tmp;
  }
  {
#line 1255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1255
    if (! (numEvents > 0)) {
#line 1255
      goto while_break;
    }
    {
#line 1259
    XNextEvent(display, & ev);
    }
#line 1261
    if (ev.xany.window == wattr.root) {
      {
#line 1263
      handle_rootWindow_event((XEvent const   */* const  */)(& ev));
      }
    } else
#line 1265
    if (victimDetails.window) {
#line 1265
      if (ev.xany.window == victimDetails.window) {
        {
#line 1268
        handle_victimWindow_event((XEvent const   */* const  */)(& ev));
        }
      } else {
#line 1265
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1270
    if (parentDetails___0.window) {
#line 1270
      if (ev.xany.window == parentDetails___0.window) {
        {
#line 1273
        handle_parentWindow_event((XEvent const   */* const  */)(& ev));
        }
      } else {
        {
#line 1277
        D((char *)"!!Got unhandled event for unknown->%d\n", ev.type);
        }
      }
    } else {
      {
#line 1277
      D((char *)"!!Got unhandled event for unknown->%d\n", ev.type);
      }
    }
#line 1282
    numEvents --;
#line 1283
    if (numEvents == 0) {
      {
#line 1285
      numEvents = XPending(display);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1288
  return;
}
}
#line 1300 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static NPWindow wintmp  ;
#line 1298 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static void check_pipe_fd_events___0(void) 
{ 
  int n ;
  Window oldwindow ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  {
#line 1303
  oldwindow = parentDetails___0.window;
#line 1304
  D((char *)"Got pipe_fd data, old parent=0x%x pipe_fd=%d\n", (unsigned int )oldwindow,
    pipe_fd___0);
#line 1307
  tmp = read(pipe_fd___0, (void *)((char *)(& wintmp)), sizeof(wintmp));
#line 1307
  n = (int )tmp;
  }
#line 1308
  if (n < 0) {
    {
#line 1310
    tmp___0 = __errno_location();
    }
#line 1310
    if (*tmp___0 == 4) {
#line 1312
      return;
    }
    {
#line 1314
    D((char *)"Winddata read error, exiting\n");
#line 1316
    giveSwallowMutex();
#line 1318
    exit(69);
    }
  }
#line 1321
  if (n == 0) {
    {
#line 1323
    D((char *)"Winddata EOF, exiting\n");
#line 1325
    giveSwallowMutex();
#line 1327
    exit(69);
    }
  }
#line 1330
  if ((unsigned long )n != sizeof(wintmp)) {
#line 1332
    return;
  }
  {
#line 1335
  parentDetails___0.window = (Window )wintmp.window;
#line 1336
  parentDetails___0.width = (int )wintmp.width;
#line 1337
  parentDetails___0.height = (int )wintmp.height;
#line 1339
  D((char *)"Got pipe_fd data, new parent=0x%x\n", (unsigned int )parentDetails___0.window);
  }
#line 1341
  if (parentDetails___0.window) {
#line 1341
    if (display) {
#line 1343
      if (parentDetails___0.window != oldwindow) {
        {
#line 1345
        victimDetails.reparented = 0;
#line 1350
        XSelectInput(display, parentDetails___0.window, 1L << 20);
#line 1352
        XSync(display, 0);
#line 1353
        XSelectInput(display, oldwindow, 0L);
        }
#line 1355
        if (victimDetails.window) {
          {
#line 1357
          reparent_window();
          }
        } else {
          {
#line 1361
          D((char *)"Victim window not ready to be reparented\n");
          }
        }
      }
#line 1365
      if (victimDetails.window) {
#line 1365
        if (victimDetails.mapped) {
#line 1365
          if (victimDetails.reparented) {
            {
#line 1369
            adjust_window_size();
            }
          } else {
            {
#line 1373
            D((char *)"Victim window not ready to be adjusted\n");
            }
          }
        } else {
          {
#line 1373
          D((char *)"Victim window not ready to be adjusted\n");
          }
        }
      } else {
        {
#line 1373
        D((char *)"Victim window not ready to be adjusted\n");
        }
      }
    }
  }
#line 1376
  return;
}
}
#line 1386 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static void check_all_events(pid_t pid___1 ) 
{ 
  int maxfd ;
  fd_set fds ;
  int status ;
  int selectRetVal ;
  int sig_chld_fd ;
  struct timeval timeout ;
  struct timeval *pTimeout ;
  int __d0 ;
  int __d1 ;
  char const   *tmp ;
  int *tmp___0 ;
  __pid_t tmp___1 ;

  {
  {
#line 1392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1398
    pTimeout = (struct timeval *)0;
#line 1399
    if (display) {
      {
#line 1401
      check_x_events___0();
      }
    }
    {
#line 1404
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1404
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.__fds_bits[0]): "memory");
#line 1404
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1405
    fds.__fds_bits[((_XPrivDisplay )display)->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ((_XPrivDisplay )display)->fd % (8 * (int )sizeof(__fd_mask ));
#line 1406
    fds.__fds_bits[pipe_fd___0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << pipe_fd___0 % (8 * (int )sizeof(__fd_mask ));
#line 1408
    if (((_XPrivDisplay )display)->fd > pipe_fd___0) {
#line 1408
      maxfd = ((_XPrivDisplay )display)->fd;
    } else {
#line 1408
      maxfd = pipe_fd___0;
    }
    {
#line 1410
    sig_chld_fd = get_SIGCHLD_fd();
    }
#line 1411
    if (sig_chld_fd >= 0) {
#line 1413
      fds.__fds_bits[sig_chld_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sig_chld_fd % (8 * (int )sizeof(__fd_mask ));
#line 1414
      if (maxfd > sig_chld_fd) {
#line 1414
        maxfd = maxfd;
      } else {
#line 1414
        maxfd = sig_chld_fd;
      }
    }
#line 1422
    if (victimDetails.noWmRunning) {
#line 1422
      if (victimDetails.reparentedAttemptCount < 4) {
#line 1425
        pTimeout = & timeout;
#line 1426
        pTimeout->tv_usec = (__suseconds_t )50000;
#line 1427
        pTimeout->tv_sec = (__time_t )0;
      }
    }
#line 1430
    if (pTimeout) {
#line 1430
      tmp = "with timeout";
    } else {
#line 1430
      tmp = "";
    }
    {
#line 1430
    D((char *)"SELECT IN %s\n", tmp);
#line 1432
    selectRetVal = select(maxfd + 1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
                          (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)pTimeout);
    }
#line 1433
    if (selectRetVal > 0) {
#line 1435
      if ((fds.__fds_bits[pipe_fd___0 / (8 * (int )sizeof(__fd_mask ))] & (1L << pipe_fd___0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 1437
        check_pipe_fd_events___0();
        }
      }
#line 1439
      if ((fds.__fds_bits[sig_chld_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << sig_chld_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 1441
        handle_SIGCHLD_event();
        }
      }
    } else
#line 1444
    if (selectRetVal == 0) {
#line 1444
      if (pTimeout) {
        {
#line 1446
        D((char *)"Select timeout and suspect invisible WM\n");
#line 1447
        reparent_window();
        }
      } else {
        {
#line 1451
        tmp___0 = __errno_location();
#line 1451
        D((char *)"Select exited unexpected, errno = %i\n", *tmp___0);
        }
      }
    } else {
      {
#line 1451
      tmp___0 = __errno_location();
#line 1451
      D((char *)"Select exited unexpected, errno = %i\n", *tmp___0);
      }
    }
    {
#line 1453
    D((char *)"SELECT OUT\n");
    }
#line 1455
    if (pid___1 >= 0) {
      {
#line 1457
      tmp___1 = waitpid(pid___1, & status, 1);
      }
#line 1457
      if (tmp___1) {
#line 1459
        pid___1 = -1;
#line 1460
        if (((unsigned int )flags___1 & 2U) == 0U) {
          {
#line 1462
          D((char *)"Child process has died status=%i\n", status);
          }
#line 1463
          return;
        } else {
          {
#line 1467
          D((char *)"Child process has detached, keep going\n");
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1484 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static void handle_app(pid_t pid___1 ) 
{ 
  int status ;
  union __anonunion_162___0 __constr_expr_2 ;
  union __anonunion_163___0 __constr_expr_3 ;
  union __anonunion_164 __constr_expr_4 ;
  union __anonunion_165 __constr_expr_5 ;

  {
#line 1488
  victimDetails.pid = pid___1;
#line 1490
  if ((unsigned int )flags___1 & 256U) {
    {
#line 1493
    check_all_events(pid___1);
#line 1497
    giveSwallowMutex();
    }
  } else
#line 1500
  if ((unsigned int )flags___1 & 2U) {
    {
#line 1502
    victimDetails.pid = -1;
#line 1504
    exit(0);
    }
  } else {
    {
#line 1509
    waitpid(pid___1, & status, 0);
    }
  }
#line 1512
  victimDetails.pid = -1;
#line 1515
  __constr_expr_2.__in = status;
#line 1515
  if (! ((__constr_expr_2.__i & 127) == 0)) {
    {
#line 1517
    D((char *)"Process dumped core or something...\n");
#line 1518
    exit(69);
    }
  }
#line 1521
  __constr_expr_5.__in = status;
#line 1521
  if ((__constr_expr_5.__i & 65280) >> 8) {
#line 1521
    if (! ((unsigned int )flags___1 & 128U)) {
      {
#line 1523
      __constr_expr_3.__in = status;
#line 1523
      D((char *)"Process exited with error code: %d\n", (__constr_expr_3.__i & 65280) >> 8);
#line 1524
      __constr_expr_4.__in = status;
#line 1524
      exit((__constr_expr_4.__i & 65280) >> 8);
      }
    }
  }
  {
#line 1527
  D((char *)"Exited OK!\n");
  }
#line 1528
  return;
}
}
#line 1538 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static void exitEarly___0(void) 
{ 


  {
  {
#line 1540
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MozPlugger version 1.14.5 helper application.\nPlease see \'man mozplugger\' for details.\n");
#line 1542
  exit(1);
  }
}
}
#line 1553 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static void expand_winname(char *buffer , int bufferLen , char const   *winame , char const   *file___0 ) 
{ 
  char const   *p ;
  char *q ;
  char *end ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *r ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 1555
  p = winame;
#line 1556
  q = buffer;
#line 1557
  end = buffer + (bufferLen - 1);
#line 1559
  D((char *)"winame before expansion is \'%s\'\n", winname);
  }
  {
#line 1561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1561
    if ((int const   )*p != 0) {
#line 1561
      if (! ((unsigned long )q < (unsigned long )end)) {
#line 1561
        goto while_break;
      }
    } else {
#line 1561
      goto while_break;
    }
#line 1563
    if ((int const   )*p != 37) {
#line 1565
      tmp = q;
#line 1565
      q ++;
#line 1565
      tmp___0 = p;
#line 1565
      p ++;
#line 1565
      *tmp = (char )*tmp___0;
    } else {
      {
#line 1572
      if ((int const   )*(p + 1) == 37) {
#line 1572
        goto case_37;
      }
#line 1577
      if ((int const   )*(p + 1) == 102) {
#line 1577
        goto case_102;
      }
#line 1594
      if ((int const   )*(p + 1) == 112) {
#line 1594
        goto case_112;
      }
#line 1603
      goto switch_default;
      case_37: /* CIL Label */ 
#line 1573
      tmp___1 = q;
#line 1573
      q ++;
#line 1573
      *tmp___1 = (char )'%';
#line 1574
      p += 2;
#line 1575
      goto switch_break;
      case_102: /* CIL Label */ 
      {
#line 1578
      tmp___2 = strrchr(file___0, '/');
#line 1578
      r = (char const   *)tmp___2;
      }
#line 1579
      if ((unsigned long )r == (unsigned long )((char const   *)0)) {
#line 1581
        r = file___0;
      } else {
#line 1585
        r ++;
      }
      {
#line 1587
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1587
        if ((int const   )*r != 0) {
#line 1587
          if (! ((unsigned long )q < (unsigned long )end)) {
#line 1587
            goto while_break___0;
          }
        } else {
#line 1587
          goto while_break___0;
        }
#line 1589
        tmp___3 = q;
#line 1589
        q ++;
#line 1589
        tmp___4 = r;
#line 1589
        r ++;
#line 1589
        *tmp___3 = (char )*tmp___4;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1591
      p += 2;
#line 1592
      goto switch_break;
      case_112: /* CIL Label */ 
#line 1595
      r = file___0;
      {
#line 1596
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1596
        if ((int const   )*r != 0) {
#line 1596
          if (! ((unsigned long )q < (unsigned long )end)) {
#line 1596
            goto while_break___1;
          }
        } else {
#line 1596
          goto while_break___1;
        }
#line 1598
        tmp___5 = q;
#line 1598
        q ++;
#line 1598
        tmp___6 = r;
#line 1598
        r ++;
#line 1598
        *tmp___5 = (char )*tmp___6;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1600
      p += 2;
#line 1601
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1604
      tmp___7 = q;
#line 1604
      q ++;
#line 1604
      tmp___8 = p;
#line 1604
      p ++;
#line 1604
      *tmp___7 = (char )*tmp___8;
#line 1605
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1609
  *q = (char )'\000';
#line 1611
  D((char *)"winame after expansion is \'%s\'\n", buffer);
  }
#line 1612
  return;
}
}
#line 1621 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-helper.c"
static void sigTerm(void) 
{ 


  {
  {
#line 1623
  D((char *)"SIGTERM received\n");
#line 1625
  giveSwallowMutex();
  }
#line 1627
  if (display) {
    {
#line 1629
    XCloseDisplay(display);
#line 1630
    display = (Display *)0;
    }
  }
#line 1633
  if (victimDetails.pid >= 0) {
    {
#line 1635
    my_kill(- victimDetails.pid);
#line 1636
    victimDetails.pid = -1;
    }
  }
  {
#line 1639
  _exit(0);
  }
}
}
#line 34 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./child.c"
static int sig_fds___0[2]  ;
#line 73 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./child.c"
static void sig_to_fd___0(int sig ) 
{ 
  ssize_t tmp ;

  {
  {
#line 75
  D((char *)"Signal %i routed to pipe\n", sig);
#line 76
  tmp = write(sig_fds___0[1], (void const   *)(& sig), sizeof(int ));
  }
#line 76
  if ((unsigned long )tmp != sizeof(int )) {
    {
#line 78
    D((char *)"Signal write to pipe failed\n");
    }
  }
#line 80
  return;
}
}
#line 61 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static Display *dpy___0  =    (Display *)0;
#line 62 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static Window topLevel___0  ;
#line 63 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static int buttonsize___0  =    10;
#line 69 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static int state  =    3;
#line 70 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static int buttonDown___0  =    -1;
#line 72 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static pid_t pid___0  =    -1;
#line 74 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static int repeats___1  =    0;
#line 75 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static int repeatsResetVal___0  ;
#line 77 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static int pipe_fd___1  ;
#line 78 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static int flags___2  ;
#line 80 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static GC gc_white___0  ;
#line 81 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static GC gc_black___0  ;
#line 82 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static GC gc_onColor___0  ;
#line 83 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static GC gc_offColor___0  ;
#line 85 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static int bx  ;
#line 87 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static int smallControls  =    0;
#line 101 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static int scale___0(int v ) 
{ 


  {
#line 103
  return ((v * buttonsize___0 + 8) / 16);
}
}
#line 119 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static XPoint coordAdd___0(XPoint const   * const  origin , int x , int y ) 
{ 
  XPoint ret ;

  {
#line 122
  ret.x = (short )((int const   )origin->x + (int const   )x);
#line 123
  ret.y = (short )((int const   )origin->y + (int const   )y);
#line 124
  return (ret);
}
}
#line 143 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static void draw3dRectangle(int const   x , int const   y , unsigned int const   w ,
                            unsigned int const   h , GC const   c , int const   d ,
                            int const   pressed ) 
{ 
  int i ;

  {
#line 147
  if (pressed) {
    {
#line 149
    XFillRectangle(dpy___0, topLevel___0, (GC )c, (int )x, (int )y, (unsigned int )w,
                   (unsigned int )h);
#line 151
    XFillRectangle(dpy___0, topLevel___0, gc_white___0, (int )(x - d), (int )(y - d),
                   (unsigned int )d, (unsigned int )(h + (unsigned int const   )d));
#line 153
    XFillRectangle(dpy___0, topLevel___0, gc_white___0, (int )x, (int )(y - d), (unsigned int )w,
                   (unsigned int )d);
    }
  } else {
    {
#line 159
    XFillRectangle(dpy___0, topLevel___0, (GC )c, (int )(x - d), (int )(y - d), (unsigned int )w,
                   (unsigned int )h);
#line 162
    i = 2;
    }
    {
#line 162
    while (1) {
      while_continue: /* CIL Label */ ;
#line 162
      if (! (i > 0)) {
#line 162
        goto while_break;
      }
      {
#line 164
      XDrawLine(dpy___0, topLevel___0, gc_black___0, (int )(((unsigned int const   )x + w) - (unsigned int const   )i),
                (int )((y + 1) - (int const   )i), (int )(((unsigned int const   )x + w) - (unsigned int const   )i),
                (int )(((unsigned int const   )y + h) - (unsigned int const   )i));
#line 165
      XDrawLine(dpy___0, topLevel___0, gc_black___0, (int )((x + 1) - (int const   )i),
                (int )(((unsigned int const   )y + h) - (unsigned int const   )i),
                (int )(((unsigned int const   )x + w) - (unsigned int const   )i),
                (int )(((unsigned int const   )y + h) - (unsigned int const   )i));
#line 162
      i --;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 168
  return;
}
}
#line 179
static void redraw___0(void) ;
#line 179 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static int old_buttonsize___0  =    -1;
#line 177 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static void redraw___0(void) 
{ 
  XWindowAttributes attr ;
  XPoint points[6] ;
  XPoint base ;
  int x ;
  int y ;
  int d ;
  unsigned int w ;
  unsigned int h ;
  GC c ;
  int s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int i ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  GC tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  {
#line 184
  d = 2;
#line 188
  XGetWindowAttributes(dpy___0, topLevel___0, & attr);
#line 189
  buttonsize___0 = attr.width / 3;
  }
#line 190
  if (attr.height < buttonsize___0) {
#line 192
    buttonsize___0 = attr.height;
  }
#line 195
  if (old_buttonsize___0 != buttonsize___0) {
    {
#line 197
    old_buttonsize___0 = buttonsize___0;
#line 198
    XFillRectangle(dpy___0, topLevel___0, gc_white___0, 0, 0, (unsigned int )attr.width,
                   (unsigned int )attr.height);
    }
  }
#line 203
  base.x = (short )((attr.width - buttonsize___0 * 3) / 2);
#line 204
  base.y = (short )((attr.height - buttonsize___0) / 2);
#line 207
  bx = (int )base.x;
#line 212
  if (buttonDown___0 != 0) {
#line 212
    tmp = d;
  } else {
#line 212
    tmp = 0;
  }
  {
#line 212
  s = tmp;
#line 214
  tmp___0 = scale___0(2);
#line 214
  tmp___1 = scale___0(5);
#line 214
  points[0] = coordAdd___0((XPoint const   */* const  */)(& base), tmp___1 - s, tmp___0 - s);
#line 215
  tmp___2 = scale___0(2);
#line 215
  points[1] = coordAdd___0((XPoint const   */* const  */)(& points[0]), tmp___2, 0);
#line 216
  tmp___3 = scale___0(5);
#line 216
  tmp___4 = scale___0(5);
#line 216
  points[2] = coordAdd___0((XPoint const   */* const  */)(& points[1]), tmp___4, tmp___3);
#line 218
  tmp___5 = scale___0(13);
#line 218
  tmp___6 = scale___0(5);
#line 218
  points[5] = coordAdd___0((XPoint const   */* const  */)(& base), tmp___6 - s, tmp___5 - s);
#line 219
  tmp___7 = scale___0(2);
#line 219
  points[4] = coordAdd___0((XPoint const   */* const  */)(& points[5]), tmp___7, 0);
#line 220
  tmp___8 = scale___0(5);
#line 220
  tmp___9 = scale___0(5);
#line 220
  points[3] = coordAdd___0((XPoint const   */* const  */)(& points[4]), tmp___9, - tmp___8);
  }
#line 223
  if (state == 1) {
#line 223
    c = gc_onColor___0;
  } else {
#line 223
    c = gc_offColor___0;
  }
#line 225
  if (buttonDown___0 != 0) {
    {
#line 229
    XFillPolygon(dpy___0, topLevel___0, c, points, 6, 2, 0);
#line 232
    points[2].y = (short )((int )points[2].y + 1);
#line 233
    points[5].x = (short )((int )points[5].x + 1);
#line 236
    i = 2;
    }
    {
#line 236
    while (1) {
      while_continue: /* CIL Label */ ;
#line 236
      if (! (i > 0)) {
#line 236
        goto while_break;
      }
      {
#line 238
      XDrawLines(dpy___0, topLevel___0, gc_black___0, & points[2], 4, 0);
#line 240
      XDrawLine(dpy___0, topLevel___0, gc_black___0, (int )points[3].x - 1, (int )points[3].y,
                (int )points[4].x - 1, (int )points[4].y);
#line 243
      points[2].x = (short )((int )points[2].x + 1);
#line 243
      points[2].y = (short )((int )points[2].y + 1);
#line 244
      points[3].x = (short )((int )points[3].x + 1);
#line 244
      points[3].y = (short )((int )points[3].y + 1);
#line 245
      points[4].x = (short )((int )points[4].x + 1);
#line 245
      points[4].y = (short )((int )points[4].y + 1);
#line 246
      points[5].x = (short )((int )points[5].x + 1);
#line 246
      points[5].y = (short )((int )points[5].y + 1);
#line 236
      i --;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 251
    XFillPolygon(dpy___0, topLevel___0, c, points, 6, 2, 0);
#line 254
    x = (int )points[0].x;
#line 255
    y = (int )points[0].y;
#line 256
    w = (unsigned int )((int )points[2].x - (int )points[0].x);
#line 257
    h = (unsigned int )((int )points[4].y - (int )points[0].y);
#line 260
    XFillRectangle(dpy___0, topLevel___0, gc_white___0, x - d, y - d, (unsigned int )d,
                   h + (unsigned int )d);
#line 262
    XFillRectangle(dpy___0, topLevel___0, gc_white___0, x, y - d, w, (unsigned int )d);
    }
  }
  {
#line 266
  base.x = (short )((int )base.x + buttonsize___0);
#line 267
  tmp___10 = scale___0(2);
#line 267
  y = (int )base.y + tmp___10;
#line 268
  tmp___11 = scale___0(3);
#line 268
  w = (unsigned int )tmp___11 + 1U;
#line 269
  tmp___12 = scale___0(11);
#line 269
  h = (unsigned int )tmp___12 + 1U;
  }
#line 270
  if (state == 2) {
#line 270
    c = gc_onColor___0;
  } else {
#line 270
    c = gc_offColor___0;
  }
  {
#line 272
  tmp___13 = scale___0(3);
#line 272
  draw3dRectangle((int const   )((int )base.x + tmp___13), (int const   )y, (unsigned int const   )w,
                  (unsigned int const   )h, (GC const   )c, (int const   )d, (int const   )(buttonDown___0 == 1));
#line 275
  tmp___14 = scale___0(9);
#line 275
  draw3dRectangle((int const   )((int )base.x + tmp___14), (int const   )y, (unsigned int const   )w,
                  (unsigned int const   )h, (GC const   )c, (int const   )d, (int const   )(buttonDown___0 == 1));
#line 279
  base.x = (short )((int )base.x + buttonsize___0);
#line 280
  tmp___15 = scale___0(9);
#line 280
  w = (unsigned int )tmp___15;
  }
#line 282
  if (state == 3) {
#line 282
    tmp___16 = gc_onColor___0;
  } else {
#line 282
    tmp___16 = gc_offColor___0;
  }
  {
#line 282
  tmp___17 = scale___0(3);
#line 282
  tmp___18 = scale___0(3);
#line 282
  draw3dRectangle((int const   )(((int )base.x + tmp___18) + 1), (int const   )(((int )base.y + tmp___17) + 1),
                  (unsigned int const   )w, (unsigned int const   )w, (GC const   )tmp___16,
                  (int const   )d, (int const   )(buttonDown___0 == 2));
  }
#line 288
  return;
}
}
#line 303 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static int igetenv(char *var , int def ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 305
  tmp___0 = getenv((char const   *)var);
#line 305
  tmp = tmp___0;
  }
#line 306
  if (! tmp) {
#line 308
    return (def);
  }
  {
#line 310
  tmp___1 = atoi((char const   *)tmp);
  }
#line 310
  return (tmp___1);
}
}
#line 322 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static void my_play(char *command___0 ) 
{ 
  int maxFd ;
  int tmp ;

  {
#line 326
  if (state != 3) {
    {
#line 328
    tmp = kill(- pid___0, 18);
    }
#line 328
    if (! tmp) {
#line 330
      state = 1;
#line 331
      return;
    }
  }
#line 335
  maxFd = pipe_fd___1;
#line 336
  if (dpy___0) {
#line 336
    if (((_XPrivDisplay )dpy___0)->fd > maxFd) {
#line 338
      maxFd = ((_XPrivDisplay )dpy___0)->fd;
    }
  }
  {
#line 341
  pid___0 = spawn_app(command___0, (int const   )flags___2, (int const   )maxFd);
  }
#line 342
  if (pid___0 == -1) {
#line 344
    state = 3;
#line 345
    return;
  }
#line 348
  state = 1;
#line 349
  if (! repeats___1) {
#line 351
    repeats___1 = repeatsResetVal___0;
  }
#line 353
  if (repeats___1 > 0) {
#line 353
    if (repeats___1 != 2147483647) {
#line 355
      repeats___1 --;
    }
  }
#line 357
  return;
}
}
#line 368 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static void my_pause(char *command___0 ) 
{ 
  int tmp ;

  {
#line 370
  if (state != 3) {
    {
#line 372
    tmp = kill(- pid___0, 19);
    }
#line 372
    if (tmp) {
#line 378
      state = 3;
    } else {
#line 374
      state = 2;
    }
#line 380
    return;
  }
#line 382
  return;
}
}
#line 391 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static void low_die___0(void) 
{ 


  {
#line 393
  if (pid___0 > 0) {
    {
#line 395
    my_kill(- pid___0);
    }
  }
  {
#line 397
  _exit(0);
  }
}
}
#line 409 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static void my_stop(char *command___0 ) 
{ 


  {
#line 411
  if (state == 2) {
    {
#line 413
    my_play(command___0);
    }
  }
#line 415
  if (state == 1) {
#line 417
    if (pid___0 > 0) {
      {
#line 419
      my_kill(- pid___0);
      }
    }
#line 421
    state = 3;
#line 422
    repeats___1 = 0;
  }
#line 424
  return;
}
}
#line 439 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static int die___0(Display *dpy___1 , XErrorEvent *ev ) 
{ 


  {
  {
#line 441
  low_die___0();
  }
#line 442
  return (0);
}
}
#line 457 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static int die2___0(Display *dpy___1 ) 
{ 


  {
  {
#line 459
  low_die___0();
  }
#line 460
  return (0);
}
}
#line 473 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static void sigdie___0(int sig ) 
{ 


  {
  {
#line 475
  low_die___0();
  }
#line 476
  return;
}
}
#line 486 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static void check_x_events___1(char *command___0 ) 
{ 
  int numEvents ;
  int tmp ;
  XEvent ev ;

  {
  {
#line 488
  tmp = XPending(dpy___0);
#line 488
  numEvents = tmp;
  }
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! (numEvents > 0)) {
#line 490
      goto while_break;
    }
    {
#line 494
    XNextEvent(dpy___0, & ev);
    }
    {
#line 498
    if (ev.type == 4) {
#line 498
      goto case_4;
    }
#line 520
    if (ev.type == 5) {
#line 520
      goto case_5;
    }
#line 528
    if (ev.type == 12) {
#line 528
      goto case_12;
    }
#line 534
    if (ev.type == 19) {
#line 534
      goto case_19;
    }
#line 534
    if (ev.type == 25) {
#line 534
      goto case_19;
    }
#line 538
    goto switch_default;
    case_4: /* CIL Label */ 
#line 499
    if (ev.xbutton.button == 1U) {
      {
#line 501
      buttonDown___0 = (ev.xbutton.x - bx) / buttonsize___0;
#line 502
      redraw___0();
#line 503
      XSync(dpy___0, 0);
      }
      {
#line 507
      if (buttonDown___0 == 0) {
#line 507
        goto case_0;
      }
#line 510
      if (buttonDown___0 == 1) {
#line 510
        goto case_1;
      }
#line 513
      if (buttonDown___0 == 2) {
#line 513
        goto case_2;
      }
#line 505
      goto switch_break___0;
      case_0: /* CIL Label */ 
      {
#line 508
      my_play(command___0);
      }
#line 509
      goto switch_break___0;
      case_1: /* CIL Label */ 
      {
#line 511
      my_pause(command___0);
      }
#line 512
      goto switch_break___0;
      case_2: /* CIL Label */ 
      {
#line 514
      my_stop(command___0);
      }
#line 515
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 518
    goto switch_break;
    case_5: /* CIL Label */ 
#line 521
    if (buttonDown___0 != -1) {
      {
#line 523
      buttonDown___0 = -1;
#line 524
      redraw___0();
      }
    }
#line 526
    goto switch_break;
    case_12: /* CIL Label */ 
#line 529
    if (ev.xexpose.count) {
#line 531
      goto switch_break;
    }
    case_19: /* CIL Label */ 
    case_25: /* CIL Label */ 
    {
#line 535
    redraw___0();
    }
#line 536
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 539
    D((char *)"Unknown event %d\n", ev.type);
    }
#line 540
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 545
    numEvents --;
#line 546
    if (numEvents == 0) {
      {
#line 548
      numEvents = XPending(dpy___0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 551
  return;
}
}
#line 567 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static void normalise_window_coords___0(unsigned int *width , unsigned int *height ,
                                        int *x , int *y ) 
{ 
  unsigned int w ;
  unsigned int h ;
  unsigned int target_aspect ;
  int tmp ;
  int tmp___0 ;

  {
#line 570
  w = *width;
#line 571
  h = *height;
#line 572
  target_aspect = 3U;
#line 574
  if (smallControls) {
#line 576
    tmp = 0;
#line 576
    *x = tmp;
#line 576
    *y = tmp;
#line 577
    *width = 48U;
#line 578
    *height = 16U;
#line 579
    return;
  }
#line 582
  if ((unsigned int )flags___2 & 1024U) {
#line 584
    tmp___0 = 0;
#line 584
    *y = tmp___0;
#line 584
    *x = tmp___0;
#line 585
    return;
  }
#line 588
  if ((w > 300U) & ! ((unsigned int )flags___2 & 512U)) {
#line 590
    w = 300U;
  }
#line 594
  if (h > w / target_aspect) {
#line 596
    h = w / target_aspect;
  }
#line 599
  *x = (int )(*width - w) / 2;
#line 600
  *y = (int )(*height - h) / 2;
#line 602
  *height = h;
#line 603
  *width = w;
#line 604
  return;
}
}
#line 614 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static void check_pipe_fd_events___1(void) 
{ 
  NPWindow wintmp___0 ;
  int n ;
  int x ;
  int y ;
  unsigned int w ;
  unsigned int h ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  {
#line 621
  D((char *)"Got pipe_fd data, pipe_fd=%d\n", pipe_fd___1);
#line 623
  tmp = read(pipe_fd___1, (void *)((char *)(& wintmp___0)), sizeof(wintmp___0));
#line 623
  n = (int )tmp;
  }
#line 624
  if (n < 0) {
    {
#line 626
    tmp___0 = __errno_location();
    }
#line 626
    if (*tmp___0 == 4) {
#line 628
      return;
    }
    {
#line 630
    exit(69);
    }
  }
#line 633
  if (n == 0) {
    {
#line 635
    exit(69);
    }
  }
#line 638
  if ((unsigned long )n != sizeof(wintmp___0)) {
#line 640
    return;
  }
  {
#line 644
  w = wintmp___0.width - 2U;
#line 645
  h = wintmp___0.height - 2U;
#line 647
  normalise_window_coords___0(& w, & h, & x, & y);
#line 649
  D((char *)"Controller window: x=%i, y=%i, w=%u, h=%u\n", x, y, w, h);
#line 651
  XMoveResizeWindow(dpy___0, topLevel___0, x, y, w, h);
  }
#line 652
  return;
}
}
#line 663 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static void exitEarly___1(void) 
{ 


  {
  {
#line 665
  D((char *)"Invalid parameters passed to Controller - controller exiting\n");
#line 667
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MozPlugger version 1.14.5 controller application.\nPlease see \'man mozplugger\' for details.\n");
#line 670
  exit(1);
  }
}
}
#line 693 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./mozplugger-controller.c"
static int readCommandLine(int argc , char **argv , unsigned int *pWidth , unsigned int *pHeight ,
                           Window *pWindow , char **pCommand ) 
{ 
  unsigned long temp ;
  int x ;
  int y ;
  int i ;
  char *fileName ;
  char const   *tmp ;

  {
  {
#line 698
  temp = 0UL;
#line 703
  D((char *)"Controller started.....\n");
  }
#line 705
  if (argc < 3) {
#line 707
    return (0);
  }
  {
#line 715
  i = sscanf((char const   */* __restrict  */)*(argv + 1), (char const   */* __restrict  */)"%d,%d,%d,%lu,%d,%d,%d,%d",
             & flags___2, & repeatsResetVal___0, & pipe_fd___1, & temp, & x, & y,
             (int *)pWidth, (int *)pHeight);
  }
#line 725
  if (i < 8) {
#line 727
    return (0);
  }
  {
#line 730
  *pWindow = temp;
#line 731
  *pCommand = *(argv + 2);
#line 733
  fileName = getenv("file");
  }
#line 735
  if (fileName) {
#line 735
    tmp = (char const   *)fileName;
  } else {
#line 735
    tmp = "NULL";
  }
  {
#line 735
  D((char *)"CONTROLLER: %s %s %s %s\n", *(argv + 0), *(argv + 1), tmp, *(argv + 2));
  }
#line 741
  return (1);
}
}
#line 34 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./child.c"
static int sig_fds___1[2]  ;
#line 73 "/home/wheatley/newnew/temp/mozplugger-1.14.5/./child.c"
static void sig_to_fd___1(int sig ) 
{ 
  ssize_t tmp ;

  {
  {
#line 75
  D((char *)"Signal %i routed to pipe\n", sig);
#line 76
  tmp = write(sig_fds___1[1], (void const   *)(& sig), sizeof(int ));
  }
#line 76
  if ((unsigned long )tmp != sizeof(int )) {
    {
#line 78
    D((char *)"Signal write to pipe failed\n");
    }
  }
#line 80
  return;
}
}
