/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 21 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.h"
struct cdb {
   int cdb_fd ;
   unsigned int cdb_fsize ;
   unsigned int cdb_dend ;
   unsigned char const   *cdb_mem ;
   unsigned int cdb_vpos ;
   unsigned int cdb_vlen ;
   unsigned int cdb_kpos ;
   unsigned int cdb_klen ;
};
#line 57 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.h"
struct cdb_find {
   struct cdb *cdb_cdbp ;
   unsigned int cdb_hval ;
   unsigned char const   *cdb_htp ;
   unsigned char const   *cdb_htab ;
   unsigned char const   *cdb_htend ;
   unsigned int cdb_httodo ;
   void const   *cdb_key ;
   unsigned int cdb_klen ;
};
#line 80
struct cdb_rl;
#line 80 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.h"
struct cdb_make {
   int cdb_fd ;
   unsigned int cdb_dpos ;
   unsigned int cdb_rcnt ;
   unsigned char cdb_buf[4096] ;
   unsigned char *cdb_bpos ;
   struct cdb_rl *cdb_rec[256] ;
};
#line 90
enum cdb_put_mode {
    CDB_PUT_ADD = 0,
    CDB_FIND = 0,
    CDB_PUT_REPLACE = 1,
    CDB_FIND_REMOVE = 1,
    CDB_PUT_INSERT = 2,
    CDB_PUT_WARN = 3,
    CDB_PUT_REPLACE0 = 4,
    CDB_FIND_FILL0 = 4
} ;
#line 23 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_int.h"
struct cdb_rec {
   unsigned int hval ;
   unsigned int rpos ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_int.h"
struct cdb_rl {
   struct cdb_rl *next ;
   unsigned int cnt ;
   struct cdb_rec rec[254] ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 435
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 580
extern int putchar(int __c ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 54 "/usr/include/errno.h"
extern char *program_invocation_short_name ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.h"
unsigned int cdb_unpack(unsigned char const   *buf___0 ) ;
#line 39
int cdb_init(struct cdb *cdbp , int fd ) ;
#line 42
int cdb_read(struct cdb  const  *cdbp , void *buf___0 , unsigned int len , unsigned int pos ) ;
#line 66
int cdb_findinit(struct cdb_find *cdbfp , struct cdb *cdbp , void const   *key , unsigned int klen ) ;
#line 68
int cdb_findnext(struct cdb_find *cdbfp ) ;
#line 106
int cdb_make_start(struct cdb_make *cdbmp , int fd ) ;
#line 115
int cdb_make_put(struct cdb_make *cdbmp , void const   *key , unsigned int klen ,
                 void const   *val , unsigned int vlen , enum cdb_put_mode mode ) ;
#line 119
int cdb_make_finish(struct cdb_make *cdbmp ) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.c"
__inline static size_t ustrlen(unsigned char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 64
  tmp = strlen((char const   *)s);
  }
#line 64
  return (tmp);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.c"
__inline static unsigned char *ufgets(unsigned char *s , int size , FILE *f ) 
{ 
  char *tmp ;

  {
  {
#line 67
  tmp = fgets((char */* __restrict  */)((char *)s), size, (FILE */* __restrict  */)f);
  }
#line 67
  return ((unsigned char *)tmp);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.c"
static unsigned char *buf  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.c"
static unsigned int blen  ;
#line 77
static  __attribute__((__noreturn__)) void ( /* format attribute */  error)(int errnum ,
                                                                            char const   *fmt 
                                                                            , ...) ;
#line 77 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.c"
static void ( /* format attribute */  error)(int errnum , char const   *fmt  , ...) 
{ 
  va_list ap ;
  char *tmp ;
  int tmp___0 ;

  {
#line 83
  if (fmt) {
    {
#line 85
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            program_invocation_short_name);
#line 86
    __builtin_va_start(ap, fmt);
#line 87
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
             ap);
#line 88
    __builtin_va_end(ap);
    }
  }
#line 90
  if (errnum) {
    {
#line 91
    tmp = strerror(errnum);
#line 91
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s\n",
            tmp);
    }
  } else {
#line 93
    if (fmt) {
      {
#line 93
      _IO_putc('\n', stderr);
      }
    }
    {
#line 94
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: try `%s -h\' for help\n",
            program_invocation_short_name, program_invocation_short_name);
    }
  }
  {
#line 96
  fflush(stderr);
  }
#line 97
  if (errnum) {
#line 97
    tmp___0 = 111;
  } else {
#line 97
    tmp___0 = 2;
  }
  {
#line 97
  exit(tmp___0);
  }
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.c"
static void allocbuf(unsigned int len ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 101
  if (blen < len) {
#line 102
    if (buf) {
      {
#line 102
      tmp = realloc((void *)buf, (size_t )len);
#line 102
      tmp___1 = tmp;
      }
    } else {
      {
#line 102
      tmp___0 = malloc((size_t )len);
#line 102
      tmp___1 = tmp___0;
      }
    }
#line 102
    buf = (unsigned char *)tmp___1;
#line 103
    if (! buf) {
      {
#line 104
      error(12, "unable to allocate %u bytes", len);
      }
    }
#line 105
    blen = len;
  }
#line 107
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.c"
static int qmode(char *dbname , char const   *key , int num , int flags ) 
{ 
  struct cdb c ;
  struct cdb_find cf ;
  int r ;
  int n ;
  int found ;
  int *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 116
  r = open((char const   *)dbname, 0);
  }
#line 117
  if (r < 0) {
    {
#line 118
    tmp = __errno_location();
#line 118
    error(*tmp, "unable to open database `%s\'", dbname);
    }
  } else {
    {
#line 117
    tmp___0 = cdb_init(& c, r);
    }
#line 117
    if (tmp___0 != 0) {
      {
#line 118
      tmp = __errno_location();
#line 118
      error(*tmp, "unable to open database `%s\'", dbname);
      }
    }
  }
  {
#line 120
  tmp___1 = strlen(key);
#line 120
  r = cdb_findinit(& cf, & c, (void const   *)key, (unsigned int )tmp___1);
  }
#line 121
  if (! r) {
#line 122
    return (100);
  } else
#line 123
  if (r < 0) {
    {
#line 124
    tmp___2 = __errno_location();
#line 124
    error(*tmp___2, "%s", key);
    }
  }
#line 125
  n = 0;
#line 125
  found = 0;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 126
    r = cdb_findnext(& cf);
    }
#line 126
    if (! (r > 0)) {
#line 126
      goto while_break;
    }
#line 127
    n ++;
#line 128
    if (num) {
#line 128
      if (num != n) {
#line 128
        goto while_continue;
      }
    }
    {
#line 129
    found ++;
#line 130
    allocbuf(c.cdb_vlen);
#line 131
    tmp___4 = cdb_read((struct cdb  const  *)(& c), (void *)buf, c.cdb_vlen, c.cdb_vpos);
    }
#line 131
    if (tmp___4 != 0) {
      {
#line 132
      tmp___3 = __errno_location();
#line 132
      error(*tmp___3, "unable to read value");
      }
    }
    {
#line 133
    fwrite((void const   */* __restrict  */)buf, (size_t )1, (size_t )c.cdb_vlen,
           (FILE */* __restrict  */)stdout);
    }
#line 134
    if (flags & 4096) {
      {
#line 134
      putchar('\n');
      }
    }
#line 135
    if (num) {
#line 136
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  if (r < 0) {
    {
#line 139
    error(0, "%s", key);
    }
  }
#line 140
  if (found) {
#line 140
    tmp___5 = 0;
  } else {
#line 140
    tmp___5 = 100;
  }
#line 140
  return (tmp___5);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.c"
static void fget(FILE *f , unsigned char *b , unsigned int len , unsigned int *posp ,
                 unsigned int limit ) 
{ 
  int *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 146
  if (posp) {
#line 146
    if (limit - *posp < len) {
      {
#line 147
      error(71, "invalid database format");
      }
    }
  }
  {
#line 148
  tmp___1 = fread((void */* __restrict  */)b, (size_t )1, (size_t )len, (FILE */* __restrict  */)f);
  }
#line 148
  if (tmp___1 != (size_t )len) {
    {
#line 149
    tmp___0 = ferror(f);
    }
#line 149
    if (tmp___0) {
      {
#line 149
      tmp = __errno_location();
#line 149
      error(*tmp, "unable to read");
      }
    }
    {
#line 150
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unable to read: short file\n",
            program_invocation_short_name);
#line 151
    exit(2);
    }
  }
#line 153
  if (posp) {
#line 153
    *posp += len;
  }
#line 154
  return;
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.c"
static int fcpy(FILE *fi , FILE *fo , unsigned int len , unsigned int *posp , unsigned int limit ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (! (len > blen)) {
#line 159
      goto while_break;
    }
    {
#line 160
    fget(fi, buf, blen, posp, limit);
    }
#line 161
    if (fo) {
      {
#line 161
      tmp = fwrite((void const   */* __restrict  */)buf, (size_t )1, (size_t )blen,
                   (FILE */* __restrict  */)fo);
      }
#line 161
      if (tmp != (size_t )blen) {
#line 161
        return (-1);
      }
    }
#line 162
    len -= blen;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  if (len) {
    {
#line 165
    fget(fi, buf, len, posp, limit);
    }
#line 166
    if (fo) {
      {
#line 166
      tmp___0 = fwrite((void const   */* __restrict  */)buf, (size_t )1, (size_t )len,
                       (FILE */* __restrict  */)fo);
      }
#line 166
      if (tmp___0 != (size_t )len) {
#line 166
        return (-1);
      }
    }
  }
#line 168
  return (0);
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.c"
static int dmode(char *dbname , char mode , int flags ) 
{ 
  unsigned int eod ;
  unsigned int klen ;
  unsigned int vlen ;
  unsigned int pos ;
  FILE *f ;
  int *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  struct _IO_FILE *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 175
  pos = 0U;
#line 177
  tmp___0 = strcmp((char const   *)dbname, "-");
  }
#line 177
  if (tmp___0 == 0) {
#line 178
    f = stdin;
  } else {
    {
#line 179
    f = fopen((char const   */* __restrict  */)dbname, (char const   */* __restrict  */)"r");
    }
#line 179
    if ((unsigned long )f == (unsigned long )((void *)0)) {
      {
#line 180
      tmp = __errno_location();
#line 180
      error(*tmp, "open %s", dbname);
      }
    }
  }
  {
#line 181
  allocbuf(2048U);
#line 182
  fget(f, buf, 2048U, & pos, 2048U);
#line 183
  eod = cdb_unpack((unsigned char const   *)buf);
  }
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! (pos < eod)) {
#line 184
      goto while_break;
    }
    {
#line 185
    fget(f, buf, 8U, & pos, eod);
#line 186
    klen = cdb_unpack((unsigned char const   *)buf);
#line 187
    vlen = cdb_unpack((unsigned char const   *)(buf + 4));
    }
#line 188
    if (! (flags & 4096)) {
#line 189
      if ((int )mode == 100) {
#line 189
        tmp___1 = "+%u,%u:";
      } else {
#line 189
        tmp___1 = "+%u:";
      }
      {
#line 189
      tmp___2 = printf((char const   */* __restrict  */)tmp___1, klen, vlen);
      }
#line 189
      if (tmp___2 < 0) {
#line 189
        return (-1);
      }
    }
    {
#line 190
    tmp___3 = fcpy(f, stdout, klen, & pos, eod);
    }
#line 190
    if (tmp___3 != 0) {
#line 190
      return (-1);
    }
#line 191
    if ((int )mode == 100) {
#line 192
      if (flags & 4096) {
#line 192
        tmp___4 = " ";
      } else {
#line 192
        tmp___4 = "->";
      }
      {
#line 192
      tmp___5 = fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)stdout);
      }
#line 192
      if (tmp___5 < 0) {
#line 193
        return (-1);
      }
    }
#line 194
    if ((int )mode == 100) {
#line 194
      tmp___6 = stdout;
    } else {
#line 194
      tmp___6 = (struct _IO_FILE *)((void *)0);
    }
    {
#line 194
    tmp___7 = fcpy(f, tmp___6, vlen, & pos, eod);
    }
#line 194
    if (tmp___7 != 0) {
#line 195
      return (-1);
    }
    {
#line 196
    tmp___8 = _IO_putc('\n', stdout);
    }
#line 196
    if (tmp___8 < 0) {
#line 197
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  if (pos != eod) {
    {
#line 200
    error(71, "invalid cdb file format");
    }
  }
#line 201
  if (! (flags & 4096)) {
    {
#line 202
    tmp___9 = _IO_putc('\n', stdout);
    }
#line 202
    if (tmp___9 < 0) {
#line 203
      return (-1);
    }
  }
#line 204
  return (0);
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.c"
static int smode(char *dbname ) 
{ 
  FILE *f ;
  unsigned int pos ;
  unsigned int eod ;
  unsigned int cnt ;
  unsigned int kmin ;
  unsigned int kmax ;
  unsigned int ktot ;
  unsigned int vmin ;
  unsigned int vmax ;
  unsigned int vtot ;
  unsigned int hmin ;
  unsigned int hmax ;
  unsigned int htot ;
  unsigned int hcnt ;
  unsigned int dist[11] ;
  unsigned char toc[2048] ;
  unsigned int k ;
  int *tmp ;
  int tmp___0 ;
  unsigned int klen ;
  unsigned int vlen ;
  unsigned int i ;
  unsigned int tmp___1 ;
  unsigned int hlen ;
  unsigned int tmp___2 ;
  unsigned int h ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 210
  cnt = 0U;
#line 211
  kmin = 0U;
#line 211
  kmax = 0U;
#line 211
  ktot = 0U;
#line 212
  vmin = 0U;
#line 212
  vmax = 0U;
#line 212
  vtot = 0U;
#line 213
  hmin = 0U;
#line 213
  hmax = 0U;
#line 213
  htot = 0U;
#line 213
  hcnt = 0U;
#line 219
  tmp___0 = strcmp((char const   *)dbname, "-");
  }
#line 219
  if (tmp___0 == 0) {
#line 220
    f = stdin;
  } else {
    {
#line 221
    f = fopen((char const   */* __restrict  */)dbname, (char const   */* __restrict  */)"r");
    }
#line 221
    if ((unsigned long )f == (unsigned long )((void *)0)) {
      {
#line 222
      tmp = __errno_location();
#line 222
      error(*tmp, "open %s", dbname);
      }
    }
  }
  {
#line 224
  pos = 0U;
#line 225
  fget(f, toc, 2048U, & pos, 2048U);
#line 227
  allocbuf(2048U);
#line 229
  eod = cdb_unpack((unsigned char const   *)(toc));
  }
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (pos < eod)) {
#line 230
      goto while_break;
    }
    {
#line 232
    fget(f, buf, 8U, & pos, eod);
#line 233
    klen = cdb_unpack((unsigned char const   *)buf);
#line 234
    vlen = cdb_unpack((unsigned char const   *)(buf + 4));
#line 235
    fcpy(f, (FILE *)((void *)0), klen, & pos, eod);
#line 236
    fcpy(f, (FILE *)((void *)0), vlen, & pos, eod);
#line 237
    cnt ++;
#line 238
    ktot += klen;
    }
#line 239
    if (! kmin) {
#line 239
      kmin = klen;
    } else
#line 239
    if (kmin > klen) {
#line 239
      kmin = klen;
    }
#line 240
    if (kmax < klen) {
#line 240
      kmax = klen;
    }
#line 241
    vtot += vlen;
#line 242
    if (! vmin) {
#line 242
      vmin = vlen;
    } else
#line 242
    if (vmin > vlen) {
#line 242
      vmin = vlen;
    }
#line 243
    if (vmax < vlen) {
#line 243
      vmax = vlen;
    }
#line 244
    vlen += klen;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  if (pos != eod) {
    {
#line 246
    error(71, "invalid cdb file format");
    }
  }
#line 248
  k = 0U;
  {
#line 248
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 248
    if (! (k < 11U)) {
#line 248
      goto while_break___0;
    }
#line 249
    dist[k] = 0U;
#line 248
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 250
  k = 0U;
  {
#line 250
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 250
    if (! (k < 256U)) {
#line 250
      goto while_break___1;
    }
    {
#line 251
    tmp___1 = cdb_unpack((unsigned char const   *)(toc + (k << 3)));
#line 251
    i = tmp___1;
#line 252
    tmp___2 = cdb_unpack((unsigned char const   *)((toc + (k << 3)) + 4));
#line 252
    hlen = tmp___2;
    }
#line 253
    if (i != pos) {
      {
#line 253
      error(71, "invalid cdb hash table");
      }
    }
#line 254
    if (! hlen) {
#line 254
      goto __Cont;
    }
#line 255
    i = 0U;
    {
#line 255
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 255
      if (! (i < hlen)) {
#line 255
        goto while_break___2;
      }
      {
#line 257
      fget(f, buf, 8U, & pos, 4294967295U);
#line 258
      tmp___3 = cdb_unpack((unsigned char const   *)(buf + 4));
      }
#line 258
      if (! tmp___3) {
#line 258
        goto __Cont___0;
      }
      {
#line 259
      tmp___4 = cdb_unpack((unsigned char const   *)buf);
#line 259
      h = (tmp___4 >> 8) % hlen;
      }
#line 260
      if (h == i) {
#line 260
        h = 0U;
      } else {
#line 262
        if (h < i) {
#line 262
          h = i - h;
        } else {
#line 263
          h = (hlen - h) + i;
        }
#line 264
        if (h >= 11U) {
#line 264
          h = 10U;
        }
      }
#line 266
      (dist[h]) ++;
      __Cont___0: /* CIL Label */ 
#line 255
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 268
    if (! hmin) {
#line 268
      hmin = hlen;
    } else
#line 268
    if (hmin > hlen) {
#line 268
      hmin = hlen;
    }
#line 269
    if (hmax < hlen) {
#line 269
      hmax = hlen;
    }
#line 270
    htot += hlen;
#line 271
    hcnt ++;
    __Cont: /* CIL Label */ 
#line 250
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 273
  printf((char const   */* __restrict  */)"number of records: %u\n", cnt);
  }
#line 274
  if (cnt) {
#line 274
    tmp___5 = (ktot + cnt / 2U) / cnt;
  } else {
#line 274
    tmp___5 = 0U;
  }
  {
#line 274
  printf((char const   */* __restrict  */)"key min/avg/max length: %u/%u/%u\n", kmin,
         tmp___5, kmax);
  }
#line 276
  if (cnt) {
#line 276
    tmp___6 = (vtot + cnt / 2U) / cnt;
  } else {
#line 276
    tmp___6 = 0U;
  }
  {
#line 276
  printf((char const   */* __restrict  */)"val min/avg/max length: %u/%u/%u\n", vmin,
         tmp___6, vmax);
#line 278
  printf((char const   */* __restrict  */)"hash tables/entries/collisions: %u/%u/%u\n",
         hcnt, htot, cnt - dist[0]);
  }
#line 280
  if (hcnt) {
#line 280
    tmp___7 = (htot + hcnt / 2U) / hcnt;
  } else {
#line 280
    tmp___7 = 0U;
  }
  {
#line 280
  printf((char const   */* __restrict  */)"hash table min/avg/max length: %u/%u/%u\n",
         hmin, tmp___7, hmax);
#line 282
  printf((char const   */* __restrict  */)"hash table distances:\n");
#line 283
  k = 0U;
  }
  {
#line 283
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 283
    if (! (k < 11U)) {
#line 283
      goto while_break___3;
    }
#line 284
    if (cnt) {
#line 284
      tmp___8 = (dist[k] * 100U) / cnt;
    } else {
#line 284
      tmp___8 = 0U;
    }
#line 284
    if (k == 10U) {
#line 284
      tmp___9 = k - 1U;
    } else {
#line 284
      tmp___9 = k;
    }
#line 284
    if (k == 10U) {
#line 284
      tmp___10 = '>';
    } else {
#line 284
      tmp___10 = 'd';
    }
    {
#line 284
    printf((char const   */* __restrict  */)" %c%u: %6u %2u%%\n", tmp___10, tmp___9,
           dist[k], tmp___8);
#line 283
    k ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 287
  return (0);
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.c"
static void badinput(char const   *fn ) 
{ 


  {
  {
#line 291
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: bad format\n",
          program_invocation_short_name, fn);
#line 292
  exit(2);
  }
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.c"
static int getnum(FILE *f , unsigned int *np , char const   *fn ) 
{ 
  unsigned int n ;
  int c ;
  int tmp ;

  {
  {
#line 297
  tmp = _IO_getc(f);
#line 297
  c = tmp;
  }
#line 298
  if (c < 48) {
    {
#line 298
    badinput(fn);
    }
  } else
#line 298
  if (c > 57) {
    {
#line 298
    badinput(fn);
    }
  }
#line 299
  n = (unsigned int )(c - 48);
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 300
    c = _IO_getc(f);
    }
#line 300
    if (c >= 48) {
#line 300
      if (! (c <= 57)) {
#line 300
        goto while_break;
      }
    } else {
#line 300
      goto while_break;
    }
#line 301
    c -= 48;
#line 302
    if (429496729U - (unsigned int )c < n) {
      {
#line 302
      badinput(fn);
      }
    }
#line 303
    n = n * 10U + (unsigned int )c;
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  *np = n;
#line 306
  return (c);
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.c"
static void addrec(struct cdb_make *cdbmp , unsigned char const   *key , unsigned int klen ,
                   unsigned char const   *val , unsigned int vlen , int flags ) 
{ 
  int r ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 315
  tmp = cdb_make_put(cdbmp, (void const   *)key, klen, (void const   *)val, vlen,
                     (enum cdb_put_mode )(flags & 15));
#line 315
  r = tmp;
  }
#line 316
  if (r < 0) {
    {
#line 317
    tmp___0 = __errno_location();
#line 317
    error(*tmp___0, "cdb_make_put");
    }
  } else
#line 318
  if (r) {
#line 318
    if (flags & 256) {
      {
#line 319
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: key `",
              program_invocation_short_name);
#line 320
      fwrite((void const   */* __restrict  */)key, (size_t )1, (size_t )klen, (FILE */* __restrict  */)stderr);
#line 321
      fputs((char const   */* __restrict  */)"\' duplicated\n", (FILE */* __restrict  */)stderr);
      }
#line 322
      if (flags & 512) {
        {
#line 323
        exit(1);
        }
      }
    }
  }
#line 325
  return;
}
}
#line 327 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.c"
static void dofile_cdb(struct cdb_make *cdbmp , FILE *f , char const   *fn , int flags ) 
{ 
  unsigned int klen ;
  unsigned int vlen ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 332
    c = _IO_getc(f);
    }
#line 332
    if (! (c == 43)) {
#line 332
      goto while_break;
    }
    {
#line 333
    c = getnum(f, & klen, fn);
    }
#line 333
    if (c != 44) {
      {
#line 336
      badinput(fn);
      }
    } else {
      {
#line 333
      c = getnum(f, & vlen, fn);
      }
#line 333
      if (c != 58) {
        {
#line 336
        badinput(fn);
        }
      } else
#line 333
      if (4294967295U - klen < vlen) {
        {
#line 336
        badinput(fn);
        }
      }
    }
    {
#line 337
    allocbuf(klen + vlen);
#line 338
    fget(f, buf, klen, (unsigned int *)((void *)0), 0U);
#line 339
    tmp = _IO_getc(f);
    }
#line 339
    if (tmp != 45) {
      {
#line 339
      badinput(fn);
      }
    } else {
      {
#line 339
      tmp___0 = _IO_getc(f);
      }
#line 339
      if (tmp___0 != 62) {
        {
#line 339
        badinput(fn);
        }
      }
    }
    {
#line 340
    fget(f, buf + klen, vlen, (unsigned int *)((void *)0), 0U);
#line 341
    tmp___1 = _IO_getc(f);
    }
#line 341
    if (tmp___1 != 10) {
      {
#line 341
      badinput(fn);
      }
    }
    {
#line 342
    addrec(cdbmp, (unsigned char const   *)buf, klen, (unsigned char const   *)(buf + klen),
           vlen, flags);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 344
  if (c != 10) {
    {
#line 344
    badinput(fn);
    }
  }
#line 345
  return;
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.c"
static void dofile_ln(struct cdb_make *cdbmp , FILE *f , int flags ) 
{ 
  unsigned char *k ;
  unsigned char *v ;
  unsigned int l ;
  size_t tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  unsigned char *tmp___4 ;

  {
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 351
    tmp___4 = ufgets(buf, (int )blen, f);
    }
#line 351
    if (! ((unsigned long )tmp___4 != (unsigned long )((void *)0))) {
#line 351
      goto while_break;
    }
#line 352
    l = 0U;
    {
#line 353
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 354
      tmp = ustrlen((unsigned char const   *)(buf + l));
#line 354
      l = (unsigned int )((size_t )l + tmp);
#line 355
      v = buf + l;
      }
#line 356
      if ((unsigned long )v > (unsigned long )buf) {
#line 356
        if ((int )*(v + -1) == 10) {
#line 357
          *(v + -1) = (unsigned char )'\000';
#line 358
          goto while_break___0;
        }
      }
#line 360
      if (l < blen) {
        {
#line 361
        allocbuf(l + 512U);
        }
      }
      {
#line 362
      tmp___0 = ufgets(buf + l, (int )(blen - l), f);
      }
#line 362
      if (! tmp___0) {
#line 363
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 365
    k = buf;
    {
#line 366
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 366
      if (! ((int )*k == 32)) {
#line 366
        if (! ((int )*k == 9)) {
#line 366
          goto while_break___1;
        }
      }
#line 366
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 367
    if (! *k) {
#line 368
      goto while_continue;
    } else
#line 367
    if ((int )*k == 35) {
#line 368
      goto while_continue;
    }
#line 369
    v = k;
    {
#line 370
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 370
      if (*v) {
#line 370
        if ((int )*v != 32) {
#line 370
          if (! ((int )*v != 9)) {
#line 370
            goto while_break___2;
          }
        } else {
#line 370
          goto while_break___2;
        }
      } else {
#line 370
        goto while_break___2;
      }
#line 370
      v ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 371
    if (*v) {
#line 371
      tmp___1 = v;
#line 371
      v ++;
#line 371
      *tmp___1 = (unsigned char )'\000';
    }
    {
#line 372
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 372
      if (! ((int )*v == 32)) {
#line 372
        if (! ((int )*v == 9)) {
#line 372
          goto while_break___3;
        }
      }
#line 372
      v ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 373
    tmp___2 = ustrlen((unsigned char const   *)v);
#line 373
    tmp___3 = ustrlen((unsigned char const   *)k);
#line 373
    addrec(cdbmp, (unsigned char const   *)k, (unsigned int )tmp___3, (unsigned char const   *)v,
           (unsigned int )tmp___2, flags);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 375
  return;
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.c"
static void dofile(struct cdb_make *cdbmp , FILE *f , char const   *fn , int flags ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
#line 380
  if (flags & 4096) {
    {
#line 381
    dofile_ln(cdbmp, f, flags);
    }
  } else {
    {
#line 383
    dofile_cdb(cdbmp, f, fn, flags);
    }
  }
  {
#line 384
  tmp___0 = ferror(f);
  }
#line 384
  if (tmp___0) {
    {
#line 385
    tmp = __errno_location();
#line 385
    error(*tmp, "read error");
    }
  }
#line 386
  return;
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.c"
static int cmode(char *dbname , char *tmpname , int argc , char **argv , int flags ,
                 int perms ) 
{ 
  struct cdb_make cdb ;
  int fd ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int i ;
  FILE *f ;
  FILE *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;

  {
#line 393
  if (! tmpname) {
    {
#line 394
    tmp = strlen((char const   *)dbname);
#line 394
    tmp___0 = malloc(tmp + 5UL);
#line 394
    tmpname = (char *)tmp___0;
    }
#line 395
    if (! tmpname) {
      {
#line 396
      error(12, "unable to allocate memory");
      }
    }
    {
#line 404
    tmp___1 = strcpy((char */* __restrict  */)tmpname, (char const   */* __restrict  */)dbname);
#line 404
    strcat((char */* __restrict  */)tmp___1, (char const   */* __restrict  */)".tmp");
    }
  } else {
    {
#line 406
    tmp___2 = strcmp((char const   *)tmpname, "-");
    }
#line 406
    if (tmp___2 == 0) {
#line 407
      tmpname = dbname;
    } else {
      {
#line 406
      tmp___3 = strcmp((char const   *)tmpname, (char const   *)dbname);
      }
#line 406
      if (tmp___3 == 0) {
#line 407
        tmpname = dbname;
      }
    }
  }
#line 408
  if (perms >= 0) {
    {
#line 409
    umask((__mode_t )0);
    }
  }
  {
#line 410
  unlink((char const   *)tmpname);
  }
#line 411
  if (perms >= 0) {
#line 411
    tmp___4 = perms;
  } else {
#line 411
    tmp___4 = 438;
  }
  {
#line 411
  fd = open((char const   *)tmpname, 131266, tmp___4);
  }
#line 413
  if (fd < 0) {
    {
#line 414
    tmp___5 = __errno_location();
#line 414
    error(*tmp___5, "unable to create %s", tmpname);
    }
  }
  {
#line 415
  cdb_make_start(& cdb, fd);
#line 416
  allocbuf(4096U);
  }
#line 417
  if (argc) {
#line 419
    i = 0;
    {
#line 419
    while (1) {
      while_continue: /* CIL Label */ ;
#line 419
      if (! (i < argc)) {
#line 419
        goto while_break;
      }
      {
#line 420
      tmp___8 = strcmp((char const   *)*(argv + i), "-");
      }
#line 420
      if (tmp___8 == 0) {
        {
#line 421
        dofile(& cdb, stdin, "(stdin)", flags);
        }
      } else {
        {
#line 423
        tmp___6 = fopen((char const   */* __restrict  */)*(argv + i), (char const   */* __restrict  */)"r");
#line 423
        f = tmp___6;
        }
#line 424
        if (! f) {
          {
#line 425
          tmp___7 = __errno_location();
#line 425
          error(*tmp___7, "%s", *(argv + i));
          }
        }
        {
#line 426
        dofile(& cdb, f, (char const   *)*(argv + i), flags);
#line 427
        fclose(f);
        }
      }
#line 419
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 432
    dofile(& cdb, stdin, "(stdin)", flags);
    }
  }
  {
#line 433
  tmp___10 = cdb_make_finish(& cdb);
  }
#line 433
  if (tmp___10 != 0) {
    {
#line 434
    tmp___9 = __errno_location();
#line 434
    error(*tmp___9, "cdb_make_finish");
    }
  }
  {
#line 435
  close(fd);
  }
#line 436
  if ((unsigned long )tmpname != (unsigned long )dbname) {
    {
#line 437
    tmp___12 = rename((char const   *)tmpname, (char const   *)dbname);
    }
#line 437
    if (tmp___12 != 0) {
      {
#line 438
      tmp___11 = __errno_location();
#line 438
      error(*tmp___11, "rename %s->%s", tmpname, dbname);
      }
    }
  }
#line 439
  return (0);
}
}
#line 442 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.c"
int main(int argc , char **argv ) 
{ 
  int c ;
  char mode ;
  char *tmpname ;
  int flags ;
  int num ;
  int r ;
  int perms ;
  char *ep ;
  long tmp ;
  char *ep___0 ;
  long tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 445
  mode = (char)0;
#line 446
  tmpname = (char *)((void *)0);
#line 447
  flags = 0;
#line 448
  num = 0;
#line 450
  perms = -1;
#line 455
  *(argv + 0) = program_invocation_short_name;
#line 463
  if (argc <= 1) {
    {
#line 464
    error(0, "no arguments given");
    }
  }
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 466
    c = getopt(argc, (char * const  *)argv, "qdlcsht:n:mwruep:0");
    }
#line 466
    if (! (c != -1)) {
#line 466
      goto while_break;
    }
    {
#line 468
    if (c == 115) {
#line 468
      goto case_115;
    }
#line 468
    if (c == 99) {
#line 468
      goto case_115;
    }
#line 468
    if (c == 108) {
#line 468
      goto case_115;
    }
#line 468
    if (c == 100) {
#line 468
      goto case_115;
    }
#line 468
    if (c == 113) {
#line 468
      goto case_115;
    }
#line 473
    if (c == 116) {
#line 473
      goto case_116;
    }
#line 474
    if (c == 119) {
#line 474
      goto case_119;
    }
#line 475
    if (c == 101) {
#line 475
      goto case_101;
    }
#line 476
    if (c == 114) {
#line 476
      goto case_114;
    }
#line 477
    if (c == 117) {
#line 477
      goto case_117;
    }
#line 478
    if (c == 48) {
#line 478
      goto case_48;
    }
#line 479
    if (c == 109) {
#line 479
      goto case_109;
    }
#line 480
    if (c == 112) {
#line 480
      goto case_112;
    }
#line 487
    if (c == 110) {
#line 487
      goto case_110;
    }
#line 493
    if (c == 104) {
#line 493
      goto case_104;
    }
#line 508
    goto switch_default;
    case_115: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_113: /* CIL Label */ 
#line 469
    if (mode) {
#line 469
      if ((int )mode != c) {
        {
#line 470
        error(0, "different modes of operation requested");
        }
      }
    }
#line 471
    mode = (char )c;
#line 472
    goto switch_break;
    case_116: /* CIL Label */ 
#line 473
    tmpname = optarg;
#line 473
    goto switch_break;
    case_119: /* CIL Label */ 
#line 474
    flags |= 256;
#line 474
    goto switch_break;
    case_101: /* CIL Label */ 
#line 475
    flags |= 768;
#line 475
    goto switch_break;
    case_114: /* CIL Label */ 
#line 476
    flags = (flags & -16) | 1;
#line 476
    goto switch_break;
    case_117: /* CIL Label */ 
#line 477
    flags = (flags & -16) | 2;
#line 477
    goto switch_break;
    case_48: /* CIL Label */ 
#line 478
    flags = (flags & -16) | 4;
#line 478
    goto switch_break;
    case_109: /* CIL Label */ 
#line 479
    flags |= 4096;
#line 479
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 481
    ep = (char *)((void *)0);
#line 482
    tmp = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& ep),
                 0);
#line 482
    perms = (int )tmp;
    }
#line 483
    if (perms < 0) {
      {
#line 484
      error(0, "invalid permissions `%s\'", optarg);
      }
    } else
#line 483
    if (perms > 511) {
      {
#line 484
      error(0, "invalid permissions `%s\'", optarg);
      }
    } else
#line 483
    if (ep) {
#line 483
      if (*ep) {
        {
#line 484
        error(0, "invalid permissions `%s\'", optarg);
        }
      }
    }
#line 485
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 488
    ep___0 = (char *)((void *)0);
#line 489
    tmp___0 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& ep___0),
                     0);
#line 489
    num = (int )tmp___0;
    }
#line 489
    if (num <= 0) {
      {
#line 490
      error(0, "invalid record number `%s\'", optarg);
      }
    } else
#line 489
    if (ep___0) {
#line 489
      if (*ep___0) {
        {
#line 490
        error(0, "invalid record number `%s\'", optarg);
        }
      }
    }
#line 491
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 496
    printf((char const   */* __restrict  */)"%s: Constant DataBase (CDB) tool version 0.78. Usage is:\n query:  %s -q [-m] [-n recno|-a] cdbfile key\n dump:   %s -d [-m] [cdbfile|-]\n list:   %s -l [-m] [cdbfile|-]\n create: %s -c [-m] [-wrue0] [-t tempfile|-] [-p perms] cdbfile [infile...]\n stats:  %s -s [cdbfile|-]\n help:   %s -h\n",
           program_invocation_short_name, program_invocation_short_name, program_invocation_short_name,
           program_invocation_short_name, program_invocation_short_name, program_invocation_short_name,
           program_invocation_short_name);
    }
#line 506
    return (0);
    switch_default: /* CIL Label */ 
    {
#line 509
    error(0, (char const   *)((void *)0));
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 512
  argv += optind;
#line 513
  argc -= optind;
  {
#line 515
  if ((int )mode == 113) {
#line 515
    goto case_113___0;
  }
#line 520
  if ((int )mode == 99) {
#line 520
    goto case_99___0;
  }
#line 527
  if ((int )mode == 108) {
#line 527
    goto case_108___0;
  }
#line 527
  if ((int )mode == 100) {
#line 527
    goto case_108___0;
  }
#line 531
  if ((int )mode == 115) {
#line 531
    goto case_115___0;
  }
#line 535
  goto switch_default___0;
  case_113___0: /* CIL Label */ 
#line 516
  if (argc < 2) {
    {
#line 516
    error(0, "no database or key to query specified");
    }
  }
#line 517
  if (argc > 2) {
    {
#line 517
    error(0, "extra arguments in command line");
    }
  }
  {
#line 518
  r = qmode(*(argv + 0), (char const   *)*(argv + 1), num, flags);
  }
#line 519
  goto switch_break___0;
  case_99___0: /* CIL Label */ 
#line 521
  if (! argc) {
    {
#line 521
    error(0, "no database name specified");
    }
  }
#line 522
  if (flags & 256) {
#line 522
    if (! (flags & 15)) {
#line 523
      flags |= 3;
    }
  }
  {
#line 524
  r = cmode(*(argv + 0), tmpname, argc - 1, argv + 1, flags, perms);
  }
#line 525
  goto switch_break___0;
  case_108___0: /* CIL Label */ 
  case_100___0: /* CIL Label */ 
#line 528
  if (argc > 1) {
    {
#line 528
    error(0, "extra arguments for dump/list");
    }
  }
#line 529
  if (argc) {
#line 529
    tmp___1 = (char const   *)*(argv + 0);
  } else {
#line 529
    tmp___1 = "-";
  }
  {
#line 529
  r = dmode((char *)tmp___1, mode, flags);
  }
#line 530
  goto switch_break___0;
  case_115___0: /* CIL Label */ 
#line 532
  if (argc > 1) {
    {
#line 532
    error(0, "extra argument(s) for stats");
    }
  }
#line 533
  if (argc) {
#line 533
    tmp___2 = (char const   *)*(argv + 0);
  } else {
#line 533
    tmp___2 = "-";
  }
  {
#line 533
  r = smode((char *)tmp___2);
  }
#line 534
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 536
  error(0, "no -q, -c, -d, -l or -s option specified");
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 538
  if (r < 0) {
    {
#line 539
    tmp___3 = __errno_location();
#line 539
    error(*tmp___3, "unable to write: %d", c);
    }
  } else {
    {
#line 538
    tmp___4 = fflush(stdout);
    }
#line 538
    if (tmp___4 < 0) {
      {
#line 539
      tmp___3 = __errno_location();
#line 539
      error(*tmp___3, "unable to write: %d", c);
      }
    }
  }
#line 540
  return (r);
}
}
#line 17 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.h"
unsigned int cdb_hash(void const   *buf___0 , unsigned int len ) ;
#line 19
void cdb_pack(unsigned int num , unsigned char *buf___0 ) ;
#line 107
int cdb_make_add(struct cdb_make *cdbmp , void const   *key , unsigned int klen ,
                 void const   *val , unsigned int vlen ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_int.h"
int __attribute__((__visibility__("hidden")))  _cdb_make_write(struct cdb_make *cdbmp ,
                                                               unsigned char const   *ptr ,
                                                               unsigned int len ) ;
#line 38
int __attribute__((__visibility__("hidden")))  _cdb_make_add(struct cdb_make *cdbmp ,
                                                             unsigned int hval , void const   *key ,
                                                             unsigned int klen , void const   *val ,
                                                             unsigned int vlen ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_make_add.c"
int __attribute__((__visibility__("hidden")))  _cdb_make_add(struct cdb_make *cdbmp ,
                                                             unsigned int hval , void const   *key ,
                                                             unsigned int klen , void const   *val ,
                                                             unsigned int vlen ) 
{ 
  unsigned char rlen[8] ;
  struct cdb_rl *rl ;
  unsigned int i ;
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 18
  if (klen > 4294967295U - (cdbmp->cdb_dpos + 8U)) {
    {
#line 20
    tmp = __errno_location();
#line 20
    *tmp = 12;
    }
#line 20
    return ((int __attribute__((__visibility__("hidden")))  )-1);
  } else
#line 18
  if (vlen > 4294967295U - ((cdbmp->cdb_dpos + klen) + 8U)) {
    {
#line 20
    tmp = __errno_location();
#line 20
    *tmp = 12;
    }
#line 20
    return ((int __attribute__((__visibility__("hidden")))  )-1);
  }
#line 21
  i = hval & 255U;
#line 22
  rl = cdbmp->cdb_rec[i];
#line 23
  if (! rl) {
#line 23
    goto _L;
  } else
#line 23
  if ((unsigned long )rl->cnt >= sizeof(rl->rec) / sizeof(rl->rec[0])) {
    _L: /* CIL Label */ 
    {
#line 24
    tmp___0 = malloc(sizeof(struct cdb_rl ));
#line 24
    rl = (struct cdb_rl *)tmp___0;
    }
#line 25
    if (! rl) {
      {
#line 26
      tmp___1 = __errno_location();
#line 26
      *tmp___1 = 12;
      }
#line 26
      return ((int __attribute__((__visibility__("hidden")))  )-1);
    }
#line 27
    rl->cnt = 0U;
#line 28
    rl->next = cdbmp->cdb_rec[i];
#line 29
    cdbmp->cdb_rec[i] = rl;
  }
  {
#line 31
  tmp___2 = rl->cnt;
#line 31
  (rl->cnt) ++;
#line 31
  i = tmp___2;
#line 32
  rl->rec[i].hval = hval;
#line 33
  rl->rec[i].rpos = cdbmp->cdb_dpos;
#line 34
  (cdbmp->cdb_rcnt) ++;
#line 35
  cdb_pack(klen, (unsigned char *)(rlen));
#line 36
  cdb_pack(vlen, (unsigned char *)(rlen + 4));
#line 37
  tmp___3 = (int )_cdb_make_write(cdbmp, (unsigned char const   *)(rlen), 8U);
  }
#line 37
  if (tmp___3 < 0) {
#line 40
    return ((int __attribute__((__visibility__("hidden")))  )-1);
  } else {
    {
#line 37
    tmp___4 = (int )_cdb_make_write(cdbmp, (unsigned char const   *)key, klen);
    }
#line 37
    if (tmp___4 < 0) {
#line 40
      return ((int __attribute__((__visibility__("hidden")))  )-1);
    } else {
      {
#line 37
      tmp___5 = (int )_cdb_make_write(cdbmp, (unsigned char const   *)val, vlen);
      }
#line 37
      if (tmp___5 < 0) {
#line 40
        return ((int __attribute__((__visibility__("hidden")))  )-1);
      }
    }
  }
#line 41
  return ((int __attribute__((__visibility__("hidden")))  )0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_make_add.c"
int cdb_make_add(struct cdb_make *cdbmp , void const   *key , unsigned int klen ,
                 void const   *val , unsigned int vlen ) 
{ 
  unsigned int tmp ;
  int __attribute__((__visibility__("hidden")))  tmp___0 ;

  {
  {
#line 48
  tmp = cdb_hash(key, klen);
#line 48
  tmp___0 = _cdb_make_add(cdbmp, tmp, key, klen, val, vlen);
  }
#line 48
  return ((int )tmp___0);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.h"
int cdb_seqnext(unsigned int *cptr , struct cdb *cdbp ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_seq.c"
int cdb_seqnext(unsigned int *cptr , struct cdb *cdbp ) 
{ 
  unsigned int klen ;
  unsigned int vlen ;
  unsigned int pos ;
  unsigned int dend ;
  unsigned char const   *mem ;
  int *tmp ;

  {
#line 12
  pos = *cptr;
#line 13
  dend = cdbp->cdb_dend;
#line 14
  mem = cdbp->cdb_mem;
#line 15
  if (pos > dend - 8U) {
#line 16
    return (0);
  }
  {
#line 17
  klen = cdb_unpack((unsigned char const   *)(mem + pos));
#line 18
  vlen = cdb_unpack((unsigned char const   *)((mem + pos) + 4));
#line 19
  pos += 8U;
  }
#line 20
  if (dend - klen < pos) {
    {
#line 21
    tmp = __errno_location();
#line 21
    *tmp = 71;
    }
#line 21
    return (-1);
  } else
#line 20
  if (dend - vlen < pos + klen) {
    {
#line 21
    tmp = __errno_location();
#line 21
    *tmp = 71;
    }
#line 21
    return (-1);
  }
#line 22
  cdbp->cdb_kpos = pos;
#line 23
  cdbp->cdb_klen = klen;
#line 24
  cdbp->cdb_vpos = pos + klen;
#line 25
  cdbp->cdb_vlen = vlen;
#line 26
  *cptr = (pos + klen) + vlen;
#line 27
  return (1);
}
}
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_findnext.c"
int cdb_findinit(struct cdb_find *cdbfp , struct cdb *cdbp , void const   *key , unsigned int klen ) 
{ 
  unsigned int n ;
  unsigned int pos ;
  int *tmp ;

  {
  {
#line 17
  cdbfp->cdb_cdbp = cdbp;
#line 18
  cdbfp->cdb_key = key;
#line 19
  cdbfp->cdb_klen = klen;
#line 20
  cdbfp->cdb_hval = cdb_hash(key, klen);
#line 22
  cdbfp->cdb_htp = cdbp->cdb_mem + ((cdbfp->cdb_hval << 3) & 2047U);
#line 23
  n = cdb_unpack((unsigned char const   *)(cdbfp->cdb_htp + 4));
#line 24
  cdbfp->cdb_httodo = n << 3;
  }
#line 25
  if (! n) {
#line 26
    return (0);
  }
  {
#line 27
  pos = cdb_unpack((unsigned char const   *)cdbfp->cdb_htp);
  }
#line 28
  if (n > cdbp->cdb_fsize >> 3) {
    {
#line 32
    tmp = __errno_location();
#line 32
    *tmp = 71;
    }
#line 32
    return (-1);
  } else
#line 28
  if (pos < cdbp->cdb_dend) {
    {
#line 32
    tmp = __errno_location();
#line 32
    *tmp = 71;
    }
#line 32
    return (-1);
  } else
#line 28
  if (pos > cdbp->cdb_fsize) {
    {
#line 32
    tmp = __errno_location();
#line 32
    *tmp = 71;
    }
#line 32
    return (-1);
  } else
#line 28
  if (cdbfp->cdb_httodo > cdbp->cdb_fsize - pos) {
    {
#line 32
    tmp = __errno_location();
#line 32
    *tmp = 71;
    }
#line 32
    return (-1);
  }
#line 34
  cdbfp->cdb_htab = cdbp->cdb_mem + pos;
#line 35
  cdbfp->cdb_htend = cdbfp->cdb_htab + cdbfp->cdb_httodo;
#line 36
  cdbfp->cdb_htp = cdbfp->cdb_htab + ((cdbfp->cdb_hval >> 8) % n << 3);
#line 38
  return (1);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_findnext.c"
int cdb_findnext(struct cdb_find *cdbfp ) 
{ 
  struct cdb *cdbp ;
  unsigned int pos ;
  unsigned int n ;
  unsigned int klen ;
  unsigned int tmp ;
  unsigned char const   *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;

  {
#line 43
  cdbp = cdbfp->cdb_cdbp;
#line 45
  klen = cdbfp->cdb_klen;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! cdbfp->cdb_httodo) {
#line 47
      goto while_break;
    }
    {
#line 48
    pos = cdb_unpack((unsigned char const   *)(cdbfp->cdb_htp + 4));
    }
#line 49
    if (! pos) {
#line 50
      return (0);
    }
    {
#line 51
    tmp = cdb_unpack((unsigned char const   *)cdbfp->cdb_htp);
#line 51
    n = (unsigned int )(tmp == cdbfp->cdb_hval);
#line 52
    tmp___0 = cdbfp->cdb_htp + 8;
#line 52
    cdbfp->cdb_htp = tmp___0;
    }
#line 52
    if ((unsigned long )tmp___0 >= (unsigned long )cdbfp->cdb_htend) {
#line 53
      cdbfp->cdb_htp = cdbfp->cdb_htab;
    }
#line 54
    cdbfp->cdb_httodo -= 8U;
#line 55
    if (n) {
#line 56
      if (pos > cdbp->cdb_fsize - 8U) {
        {
#line 57
        tmp___1 = __errno_location();
#line 57
        *tmp___1 = 71;
        }
#line 57
        return (-1);
      }
      {
#line 58
      tmp___5 = cdb_unpack((unsigned char const   *)(cdbp->cdb_mem + pos));
      }
#line 58
      if (tmp___5 == klen) {
#line 59
        if (cdbp->cdb_fsize - klen < pos + 8U) {
          {
#line 60
          tmp___2 = __errno_location();
#line 60
          *tmp___2 = 71;
          }
#line 60
          return (-1);
        }
        {
#line 61
        tmp___4 = memcmp(cdbfp->cdb_key, (void const   *)((cdbp->cdb_mem + pos) + 8),
                         (size_t )klen);
        }
#line 61
        if (tmp___4 == 0) {
          {
#line 63
          n = cdb_unpack((unsigned char const   *)((cdbp->cdb_mem + pos) + 4));
#line 64
          pos += 8U;
          }
#line 65
          if (cdbp->cdb_fsize < n) {
            {
#line 67
            tmp___3 = __errno_location();
#line 67
            *tmp___3 = 71;
            }
#line 67
            return (-1);
          } else
#line 65
          if (cdbp->cdb_fsize - n < pos + klen) {
            {
#line 67
            tmp___3 = __errno_location();
#line 67
            *tmp___3 = 71;
            }
#line 67
            return (-1);
          }
#line 68
          cdbp->cdb_kpos = pos;
#line 69
          cdbp->cdb_klen = klen;
#line 70
          cdbp->cdb_vpos = pos + klen;
#line 71
          cdbp->cdb_vlen = n;
#line 72
          return (1);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return (0);
}
}
#line 9 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_unpack.c"
unsigned int cdb_unpack(unsigned char const   *buf___0 ) 
{ 
  unsigned int n ;

  {
#line 12
  n = (unsigned int )*(buf___0 + 3);
#line 13
  n <<= 8;
#line 13
  n |= (unsigned int )*(buf___0 + 2);
#line 14
  n <<= 8;
#line 14
  n |= (unsigned int )*(buf___0 + 1);
#line 15
  n <<= 8;
#line 15
  n |= (unsigned int )*(buf___0 + 0);
#line 16
  return (n);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.h"
int cdb_find(struct cdb *cdbp , void const   *key , unsigned int klen ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_find.c"
int cdb_find(struct cdb *cdbp , void const   *key , unsigned int klen ) 
{ 
  unsigned char const   *htp ;
  unsigned char const   *htab ;
  unsigned char const   *htend ;
  unsigned int httodo ;
  unsigned int pos ;
  unsigned int n ;
  unsigned int hval ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;

  {
#line 20
  if (klen >= cdbp->cdb_dend) {
#line 21
    return (0);
  }
  {
#line 23
  hval = cdb_hash(key, klen);
#line 28
  htp = cdbp->cdb_mem + ((hval << 3) & 2047U);
#line 29
  n = cdb_unpack((unsigned char const   *)(htp + 4));
  }
#line 30
  if (! n) {
#line 31
    return (0);
  }
  {
#line 32
  httodo = n << 3;
#line 33
  pos = cdb_unpack((unsigned char const   *)htp);
  }
#line 34
  if (n > cdbp->cdb_fsize >> 3) {
    {
#line 38
    tmp = __errno_location();
#line 38
    *tmp = 71;
    }
#line 38
    return (-1);
  } else
#line 34
  if (pos < cdbp->cdb_dend) {
    {
#line 38
    tmp = __errno_location();
#line 38
    *tmp = 71;
    }
#line 38
    return (-1);
  } else
#line 34
  if (pos > cdbp->cdb_fsize) {
    {
#line 38
    tmp = __errno_location();
#line 38
    *tmp = 71;
    }
#line 38
    return (-1);
  } else
#line 34
  if (httodo > cdbp->cdb_fsize - pos) {
    {
#line 38
    tmp = __errno_location();
#line 38
    *tmp = 71;
    }
#line 38
    return (-1);
  }
#line 40
  htab = cdbp->cdb_mem + pos;
#line 41
  htend = htab + httodo;
#line 43
  htp = htab + ((hval >> 8) % n << 3);
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 46
    pos = cdb_unpack((unsigned char const   *)(htp + 4));
    }
#line 47
    if (! pos) {
#line 48
      return (0);
    }
    {
#line 49
    tmp___5 = cdb_unpack((unsigned char const   *)htp);
    }
#line 49
    if (tmp___5 == hval) {
#line 50
      if (pos > cdbp->cdb_dend - 8U) {
        {
#line 51
        tmp___0 = __errno_location();
#line 51
        *tmp___0 = 71;
        }
#line 51
        return (-1);
      }
      {
#line 52
      tmp___4 = cdb_unpack((unsigned char const   *)(cdbp->cdb_mem + pos));
      }
#line 52
      if (tmp___4 == klen) {
#line 53
        if (cdbp->cdb_dend - klen < pos + 8U) {
          {
#line 54
          tmp___1 = __errno_location();
#line 54
          *tmp___1 = 71;
          }
#line 54
          return (-1);
        }
        {
#line 55
        tmp___3 = memcmp(key, (void const   *)((cdbp->cdb_mem + pos) + 8), (size_t )klen);
        }
#line 55
        if (tmp___3 == 0) {
          {
#line 56
          n = cdb_unpack((unsigned char const   *)((cdbp->cdb_mem + pos) + 4));
#line 57
          pos += 8U;
          }
#line 58
          if (cdbp->cdb_dend < n) {
            {
#line 59
            tmp___2 = __errno_location();
#line 59
            *tmp___2 = 71;
            }
#line 59
            return (-1);
          } else
#line 58
          if (cdbp->cdb_dend - n < pos + klen) {
            {
#line 59
            tmp___2 = __errno_location();
#line 59
            *tmp___2 = 71;
            }
#line 59
            return (-1);
          }
#line 60
          cdbp->cdb_kpos = pos;
#line 61
          cdbp->cdb_klen = klen;
#line 62
          cdbp->cdb_vpos = pos + klen;
#line 63
          cdbp->cdb_vlen = n;
#line 64
          return (1);
        }
      }
    }
#line 68
    httodo -= 8U;
#line 69
    if (! httodo) {
#line 70
      return (0);
    }
#line 71
    htp += 8;
#line 71
    if ((unsigned long )htp >= (unsigned long )htend) {
#line 72
      htp = htab;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                  __off64_t __offset ,
                                                                                  int __whence )  __asm__("lseek64")  ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_int.h"
int __attribute__((__visibility__("hidden")))  _cdb_make_fullwrite(int fd , unsigned char const   *buf___0 ,
                                                                   unsigned int len ) ;
#line 37
int __attribute__((__visibility__("hidden")))  _cdb_make_flush(struct cdb_make *cdbmp ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_make.c"
void cdb_pack(unsigned int num , unsigned char *buf___0 ) 
{ 


  {
#line 15
  *(buf___0 + 0) = (unsigned char )(num & 255U);
#line 15
  num >>= 8;
#line 16
  *(buf___0 + 1) = (unsigned char )(num & 255U);
#line 16
  num >>= 8;
#line 17
  *(buf___0 + 2) = (unsigned char )(num & 255U);
#line 18
  *(buf___0 + 3) = (unsigned char )(num >> 8);
#line 19
  return;
}
}
#line 21 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_make.c"
int cdb_make_start(struct cdb_make *cdbmp , int fd ) 
{ 


  {
  {
#line 24
  memset((void *)cdbmp, 0, sizeof(*cdbmp));
#line 25
  cdbmp->cdb_fd = fd;
#line 26
  cdbmp->cdb_dpos = 2048U;
#line 27
  cdbmp->cdb_bpos = cdbmp->cdb_buf + 2048;
  }
#line 28
  return (0);
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_make.c"
int __attribute__((__visibility__("hidden")))  _cdb_make_fullwrite(int fd , unsigned char const   *buf___0 ,
                                                                   unsigned int len ) 
{ 
  int l ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (! len) {
#line 34
      goto while_break;
    }
    {
#line 35
    tmp = write(fd, (void const   *)buf___0, (size_t )len);
#line 35
    l = (int )tmp;
    }
#line 36
    if (l > 0) {
#line 37
      len -= (unsigned int )l;
#line 38
      buf___0 += l;
    } else
#line 40
    if (l < 0) {
      {
#line 40
      tmp___0 = __errno_location();
      }
#line 40
      if (*tmp___0 != 4) {
#line 41
        return ((int __attribute__((__visibility__("hidden")))  )-1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  return ((int __attribute__((__visibility__("hidden")))  )0);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_make.c"
int __attribute__((__visibility__("hidden")))  _cdb_make_flush(struct cdb_make *cdbmp ) 
{ 
  unsigned int len ;
  int __attribute__((__visibility__("hidden")))  tmp ;

  {
#line 48
  len = (unsigned int )(cdbmp->cdb_bpos - cdbmp->cdb_buf);
#line 49
  if (len) {
    {
#line 50
    tmp = _cdb_make_fullwrite(cdbmp->cdb_fd, (unsigned char const   *)(cdbmp->cdb_buf),
                              len);
    }
#line 50
    if (tmp < (int __attribute__((__visibility__("hidden")))  )0) {
#line 51
      return ((int __attribute__((__visibility__("hidden")))  )-1);
    }
#line 52
    cdbmp->cdb_bpos = cdbmp->cdb_buf;
  }
#line 54
  return ((int __attribute__((__visibility__("hidden")))  )0);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_make.c"
int __attribute__((__visibility__("hidden")))  _cdb_make_write(struct cdb_make *cdbmp ,
                                                               unsigned char const   *ptr ,
                                                               unsigned int len ) 
{ 
  unsigned int l ;
  int __attribute__((__visibility__("hidden")))  tmp ;
  int __attribute__((__visibility__("hidden")))  tmp___0 ;

  {
#line 60
  l = (unsigned int )(sizeof(cdbmp->cdb_buf) - (unsigned long )(cdbmp->cdb_bpos - cdbmp->cdb_buf));
#line 61
  cdbmp->cdb_dpos += len;
#line 62
  if (len > l) {
    {
#line 63
    memcpy((void */* __restrict  */)cdbmp->cdb_bpos, (void const   */* __restrict  */)ptr,
           (size_t )l);
#line 64
    cdbmp->cdb_bpos += l;
#line 65
    tmp = _cdb_make_flush(cdbmp);
    }
#line 65
    if (tmp < (int __attribute__((__visibility__("hidden")))  )0) {
#line 66
      return ((int __attribute__((__visibility__("hidden")))  )-1);
    }
#line 67
    ptr += l;
#line 67
    len -= l;
#line 68
    l = (unsigned int )((unsigned long )len / sizeof(cdbmp->cdb_buf));
#line 69
    if (l) {
      {
#line 70
      l = (unsigned int )((unsigned long )l * sizeof(cdbmp->cdb_buf));
#line 71
      tmp___0 = _cdb_make_fullwrite(cdbmp->cdb_fd, ptr, l);
      }
#line 71
      if (tmp___0 < (int __attribute__((__visibility__("hidden")))  )0) {
#line 72
        return ((int __attribute__((__visibility__("hidden")))  )-1);
      }
#line 73
      ptr += l;
#line 73
      len -= l;
    }
  }
#line 76
  if (len) {
    {
#line 77
    memcpy((void */* __restrict  */)cdbmp->cdb_bpos, (void const   */* __restrict  */)ptr,
           (size_t )len);
#line 78
    cdbmp->cdb_bpos += len;
    }
  }
#line 80
  return ((int __attribute__((__visibility__("hidden")))  )0);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_make.c"
static int cdb_make_finish_internal(struct cdb_make *cdbmp ) 
{ 
  unsigned int hcnt[256] ;
  unsigned int hpos[256] ;
  struct cdb_rec *htab ;
  unsigned char *p ;
  struct cdb_rl *rl ;
  unsigned int hsize ;
  unsigned int t ;
  unsigned int i ;
  int *tmp ;
  struct cdb_rl *rlt ;
  struct cdb_rl *rln ;
  unsigned int tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  unsigned int len ;
  unsigned int hi ;
  unsigned int tmp___3 ;
  int __attribute__((__visibility__("hidden")))  tmp___4 ;
  int __attribute__((__visibility__("hidden")))  tmp___5 ;
  __off64_t tmp___6 ;
  int __attribute__((__visibility__("hidden")))  tmp___7 ;

  {
#line 94
  if ((4294967295U - cdbmp->cdb_dpos) >> 3 < cdbmp->cdb_rcnt) {
    {
#line 95
    tmp = __errno_location();
#line 95
    *tmp = 12;
    }
#line 95
    return (-1);
  }
#line 98
  hsize = 0U;
#line 99
  t = 0U;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (t < 256U)) {
#line 99
      goto while_break;
    }
#line 100
    rlt = (struct cdb_rl *)((void *)0);
#line 101
    i = 0U;
#line 102
    rl = cdbmp->cdb_rec[t];
    {
#line 103
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 103
      if (! rl) {
#line 103
        goto while_break___0;
      }
#line 104
      rln = rl->next;
#line 105
      rl->next = rlt;
#line 106
      rlt = rl;
#line 107
      i += rl->cnt;
#line 108
      rl = rln;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 110
    cdbmp->cdb_rec[t] = rlt;
#line 111
    tmp___0 = i << 1;
#line 111
    hcnt[t] = tmp___0;
#line 111
    if (hsize < tmp___0) {
#line 112
      hsize = hcnt[t];
    }
#line 99
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 116
  tmp___1 = malloc((unsigned long )(hsize + 2U) * sizeof(struct cdb_rec ));
#line 116
  htab = (struct cdb_rec *)tmp___1;
  }
#line 117
  if (! htab) {
    {
#line 118
    tmp___2 = __errno_location();
#line 118
    *tmp___2 = 2;
    }
#line 118
    return (-1);
  }
#line 119
  p = (unsigned char *)htab;
#line 120
  htab += 2;
#line 123
  t = 0U;
  {
#line 123
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 123
    if (! (t < 256U)) {
#line 123
      goto while_break___1;
    }
#line 125
    hpos[t] = cdbmp->cdb_dpos;
#line 126
    len = hcnt[t];
#line 126
    if (len == 0U) {
#line 127
      goto __Cont;
    }
#line 128
    i = 0U;
    {
#line 128
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 128
      if (! (i < len)) {
#line 128
        goto while_break___2;
      }
#line 129
      tmp___3 = 0U;
#line 129
      (htab + i)->rpos = tmp___3;
#line 129
      (htab + i)->hval = tmp___3;
#line 128
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 130
    rl = cdbmp->cdb_rec[t];
    {
#line 130
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 130
      if (! rl) {
#line 130
        goto while_break___3;
      }
#line 131
      i = 0U;
      {
#line 131
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 131
        if (! (i < rl->cnt)) {
#line 131
          goto while_break___4;
        }
#line 132
        hi = (rl->rec[i].hval >> 8) % len;
        {
#line 133
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 133
          if (! (htab + hi)->rpos) {
#line 133
            goto while_break___5;
          }
#line 134
          hi ++;
#line 134
          if (hi == len) {
#line 135
            hi = 0U;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 136
        *(htab + hi) = rl->rec[i];
#line 131
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 130
      rl = rl->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 138
    i = 0U;
    {
#line 138
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 138
      if (! (i < len)) {
#line 138
        goto while_break___6;
      }
      {
#line 139
      cdb_pack((htab + i)->hval, (unsigned char *)(p + (i << 3)));
#line 140
      cdb_pack((htab + i)->rpos, (unsigned char *)((p + (i << 3)) + 4));
#line 138
      i ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 142
    tmp___4 = _cdb_make_write(cdbmp, (unsigned char const   *)p, len << 3);
    }
#line 142
    if (tmp___4 < (int __attribute__((__visibility__("hidden")))  )0) {
      {
#line 143
      free((void *)p);
      }
#line 144
      return (-1);
    }
    __Cont: /* CIL Label */ 
#line 123
    t ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 147
  free((void *)p);
#line 148
  tmp___5 = _cdb_make_flush(cdbmp);
  }
#line 148
  if (tmp___5 < (int __attribute__((__visibility__("hidden")))  )0) {
#line 149
    return (-1);
  }
#line 150
  p = cdbmp->cdb_buf;
#line 151
  t = 0U;
  {
#line 151
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 151
    if (! (t < 256U)) {
#line 151
      goto while_break___7;
    }
    {
#line 152
    cdb_pack(hpos[t], (unsigned char *)(p + (t << 3)));
#line 153
    cdb_pack(hcnt[t], (unsigned char *)((p + (t << 3)) + 4));
#line 151
    t ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 155
  tmp___6 = lseek(cdbmp->cdb_fd, (__off64_t )0, 0);
  }
#line 155
  if (tmp___6 != 0L) {
#line 157
    return (-1);
  } else {
    {
#line 155
    tmp___7 = _cdb_make_fullwrite(cdbmp->cdb_fd, (unsigned char const   *)p, 2048U);
    }
#line 155
    if (tmp___7 != (int __attribute__((__visibility__("hidden")))  )0) {
#line 157
      return (-1);
    }
  }
#line 159
  return (0);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_make.c"
static void cdb_make_free(struct cdb_make *cdbmp ) 
{ 
  unsigned int t ;
  struct cdb_rl *rl ;
  struct cdb_rl *tm ;

  {
#line 166
  t = 0U;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! (t < 256U)) {
#line 166
      goto while_break;
    }
#line 167
    rl = cdbmp->cdb_rec[t];
    {
#line 168
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 168
      if (! rl) {
#line 168
        goto while_break___0;
      }
      {
#line 169
      tm = rl;
#line 170
      rl = rl->next;
#line 171
      free((void *)tm);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 166
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return;
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_make.c"
int cdb_make_finish(struct cdb_make *cdbmp ) 
{ 
  int r ;
  int tmp ;

  {
  {
#line 179
  tmp = cdb_make_finish_internal(cdbmp);
#line 179
  r = tmp;
#line 180
  cdb_make_free(cdbmp);
  }
#line 181
  return (r);
}
}
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 110 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.h"
int cdb_make_exists(struct cdb_make *cdbmp , void const   *key , unsigned int klen ) ;
#line 112
int cdb_make_find(struct cdb_make *cdbmp , void const   *key , unsigned int klen ,
                  enum cdb_put_mode mode ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_make_put.c"
static void fixup_rpos(struct cdb_make *cdbmp , unsigned int rpos , unsigned int rlen ) 
{ 
  unsigned int i ;
  struct cdb_rl *rl ;
  register struct cdb_rec *rp ;
  register struct cdb_rec *rs ;

  {
#line 17
  i = 0U;
  {
#line 17
  while (1) {
    while_continue: /* CIL Label */ ;
#line 17
    if (! (i < 256U)) {
#line 17
      goto while_break;
    }
#line 18
    rl = cdbmp->cdb_rec[i];
    {
#line 18
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 18
      if (! rl) {
#line 18
        goto while_break___0;
      }
#line 19
      rs = rl->rec;
#line 19
      rp = rs + rl->cnt;
      {
#line 19
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 19
        rp --;
#line 19
        if (! ((unsigned long )rp >= (unsigned long )rs)) {
#line 19
          goto while_break___1;
        }
#line 20
        if (rp->rpos <= rpos) {
#line 20
          goto nexthash;
        } else {
#line 21
          rp->rpos -= rlen;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 18
      rl = rl->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    nexthash: 
#line 17
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 24
  return;
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_make_put.c"
static int remove_record(struct cdb_make *cdbmp , unsigned int rpos , unsigned int rlen ) 
{ 
  unsigned int pos ;
  unsigned int len ;
  int r ;
  int fd ;
  __off64_t tmp ;
  ssize_t tmp___0 ;
  __off64_t tmp___1 ;
  int tmp___2 ;

  {
#line 31
  len = (cdbmp->cdb_dpos - rpos) - rlen;
#line 32
  cdbmp->cdb_dpos -= rlen;
#line 33
  if (! len) {
#line 34
    return (0);
  }
#line 35
  pos = rpos;
#line 36
  fd = cdbmp->cdb_fd;
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if ((unsigned long )len > sizeof(cdbmp->cdb_buf)) {
#line 38
      r = (int )sizeof(cdbmp->cdb_buf);
    } else {
#line 38
      r = (int )len;
    }
    {
#line 39
    tmp = lseek(fd, (__off64_t )(pos + rlen), 0);
    }
#line 39
    if (tmp < 0L) {
#line 41
      return (-1);
    } else {
      {
#line 39
      tmp___0 = read(fd, (void *)(cdbmp->cdb_buf), (size_t )r);
#line 39
      r = (int )tmp___0;
      }
#line 39
      if (r <= 0) {
#line 41
        return (-1);
      }
    }
    {
#line 42
    tmp___1 = lseek(fd, (__off64_t )pos, 0);
    }
#line 42
    if (tmp___1 < 0L) {
#line 44
      return (-1);
    } else {
      {
#line 42
      tmp___2 = (int )_cdb_make_fullwrite(fd, (unsigned char const   *)(cdbmp->cdb_buf),
                                          (unsigned int )r);
      }
#line 42
      if (tmp___2 < 0) {
#line 44
        return (-1);
      }
    }
#line 45
    pos += (unsigned int )r;
#line 46
    len -= (unsigned int )r;
#line 37
    if (! len) {
#line 37
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  if (! (cdbmp->cdb_dpos == pos)) {
    {
#line 48
    __assert_fail("cdbmp->cdb_dpos == pos", "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_make_put.c",
                  48U, "remove_record");
    }
  }
  {
#line 49
  fixup_rpos(cdbmp, rpos, rlen);
  }
#line 50
  return (0);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_make_put.c"
static int zerofill_record(struct cdb_make *cdbmp , unsigned int rpos , unsigned int rlen ) 
{ 
  __off64_t tmp ;
  int tmp___0 ;

  {
#line 55
  if (rpos + rlen == cdbmp->cdb_dpos) {
#line 56
    cdbmp->cdb_dpos = rpos;
#line 57
    return (0);
  }
  {
#line 59
  tmp = lseek(cdbmp->cdb_fd, (__off64_t )rpos, 0);
  }
#line 59
  if (tmp < 0L) {
#line 60
    return (-1);
  }
  {
#line 61
  memset((void *)(cdbmp->cdb_buf), 0, sizeof(cdbmp->cdb_buf));
#line 62
  cdb_pack(rlen - 8U, (unsigned char *)(cdbmp->cdb_buf + 4));
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if ((unsigned long )rlen > sizeof(cdbmp->cdb_buf)) {
#line 64
      rpos = (unsigned int )sizeof(cdbmp->cdb_buf);
    } else {
#line 64
      rpos = rlen;
    }
    {
#line 65
    tmp___0 = (int )_cdb_make_fullwrite(cdbmp->cdb_fd, (unsigned char const   *)(cdbmp->cdb_buf),
                                        rpos);
    }
#line 65
    if (tmp___0 < 0) {
#line 66
      return (-1);
    }
#line 67
    rlen -= rpos;
#line 68
    if (! rlen) {
#line 68
      return (0);
    }
    {
#line 69
    memset((void *)(cdbmp->cdb_buf + 4), 0, (size_t )4);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_make_put.c"
static unsigned int match(struct cdb_make *cdbmp , unsigned int pos , char const   *key ,
                          unsigned int klen ) 
{ 
  int len ;
  unsigned int rlen ;
  __off64_t tmp ;
  ssize_t tmp___0 ;
  unsigned int tmp___1 ;
  int *tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 79
  tmp = lseek(cdbmp->cdb_fd, (__off64_t )pos, 0);
  }
#line 79
  if (tmp < 0L) {
#line 80
    return (1U);
  }
  {
#line 81
  tmp___0 = read(cdbmp->cdb_fd, (void *)(cdbmp->cdb_buf), (size_t )8);
  }
#line 81
  if (tmp___0 != 8L) {
#line 82
    return (1U);
  }
  {
#line 83
  tmp___1 = cdb_unpack((unsigned char const   *)(cdbmp->cdb_buf));
  }
#line 83
  if (tmp___1 != klen) {
#line 84
    return (0U);
  }
  {
#line 87
  rlen = cdb_unpack((unsigned char const   *)(cdbmp->cdb_buf + 4));
  }
#line 88
  if (rlen > ((cdbmp->cdb_dpos - pos) - klen) - 8U) {
    {
#line 89
    tmp___2 = __errno_location();
#line 89
    *tmp___2 = 71;
    }
#line 89
    return (1U);
  }
#line 90
  rlen += klen + 8U;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! klen) {
#line 92
      goto while_break;
    }
#line 93
    if ((unsigned long )klen > sizeof(cdbmp->cdb_buf)) {
#line 93
      len = (int )sizeof(cdbmp->cdb_buf);
    } else {
#line 93
      len = (int )klen;
    }
    {
#line 94
    tmp___3 = read(cdbmp->cdb_fd, (void *)(cdbmp->cdb_buf), (size_t )len);
#line 94
    len = (int )tmp___3;
    }
#line 95
    if (len <= 0) {
#line 96
      return (1U);
    }
    {
#line 97
    tmp___4 = memcmp((void const   *)(cdbmp->cdb_buf), (void const   *)key, (size_t )len);
    }
#line 97
    if (tmp___4 != 0) {
#line 98
      return (0U);
    }
#line 99
    key += len;
#line 100
    klen -= (unsigned int )len;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return (rlen);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_make_put.c"
static int findrec(struct cdb_make *cdbmp , void const   *key , unsigned int klen ,
                   unsigned int hval , enum cdb_put_mode mode ) 
{ 
  struct cdb_rl *rl ;
  struct cdb_rec *rp ;
  struct cdb_rec *rs ;
  unsigned int r ;
  int seeked ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __off64_t tmp___2 ;

  {
#line 114
  seeked = 0;
#line 115
  ret = 0;
#line 116
  rl = cdbmp->cdb_rec[hval & 255U];
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! rl) {
#line 116
      goto while_break;
    }
#line 117
    rs = rl->rec;
#line 117
    rp = rs + rl->cnt;
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 117
      rp --;
#line 117
      if (! ((unsigned long )rp >= (unsigned long )rs)) {
#line 117
        goto while_break___0;
      }
#line 118
      if (rp->hval != hval) {
#line 119
        goto __Cont;
      }
#line 124
      if (! seeked) {
        {
#line 124
        tmp = (int )_cdb_make_flush(cdbmp);
        }
#line 124
        if (tmp < 0) {
#line 125
          return (-1);
        }
      }
      {
#line 126
      seeked = 1;
#line 127
      r = match(cdbmp, rp->rpos, (char const   *)key, klen);
      }
#line 128
      if (! r) {
#line 129
        goto __Cont;
      }
#line 130
      if (r == 1U) {
#line 131
        return (-1);
      }
#line 132
      ret = 1;
      {
#line 134
      if ((unsigned int )mode == 1U) {
#line 134
        goto case_1;
      }
#line 138
      if ((unsigned int )mode == 4U) {
#line 138
        goto case_4;
      }
#line 142
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 135
      tmp___0 = remove_record(cdbmp, rp->rpos, r);
      }
#line 135
      if (tmp___0 < 0) {
#line 136
        return (-1);
      }
#line 137
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 139
      tmp___1 = zerofill_record(cdbmp, rp->rpos, r);
      }
#line 139
      if (tmp___1 < 0) {
#line 140
        return (-1);
      }
#line 141
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 142
      goto finish;
      switch_break: /* CIL Label */ ;
      }
      {
#line 144
      memmove((void *)rp, (void const   *)(rp + 1), (unsigned long )(((rs + rl->cnt) - 1) - rp) * sizeof(*rp));
#line 145
      (rl->cnt) --;
#line 146
      (cdbmp->cdb_rcnt) --;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 116
    rl = rl->next;
  }
  while_break: /* CIL Label */ ;
  }
  finish: 
#line 149
  if (seeked) {
    {
#line 149
    tmp___2 = lseek(cdbmp->cdb_fd, (__off64_t )cdbmp->cdb_dpos, 0);
    }
#line 149
    if (tmp___2 < 0L) {
#line 150
      return (-1);
    }
  }
#line 151
  return (ret);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_make_put.c"
int cdb_make_find(struct cdb_make *cdbmp , void const   *key , unsigned int klen ,
                  enum cdb_put_mode mode ) 
{ 
  unsigned int tmp ;
  int tmp___0 ;

  {
  {
#line 159
  tmp = cdb_hash(key, klen);
#line 159
  tmp___0 = findrec(cdbmp, key, klen, tmp, mode);
  }
#line 159
  return (tmp___0);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_make_put.c"
int cdb_make_exists(struct cdb_make *cdbmp , void const   *key , unsigned int klen ) 
{ 
  int tmp ;

  {
  {
#line 166
  tmp = cdb_make_find(cdbmp, key, klen, (enum cdb_put_mode )0);
  }
#line 166
  return (tmp);
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_make_put.c"
int cdb_make_put(struct cdb_make *cdbmp , void const   *key , unsigned int klen ,
                 void const   *val , unsigned int vlen , enum cdb_put_mode mode ) 
{ 
  unsigned int hval ;
  unsigned int tmp ;
  int r ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 175
  tmp = cdb_hash(key, klen);
#line 175
  hval = tmp;
  }
  {
#line 182
  if ((unsigned int )mode == 4U) {
#line 182
    goto case_4;
  }
#line 182
  if ((unsigned int )mode == 3U) {
#line 182
    goto case_4;
  }
#line 182
  if ((unsigned int )mode == 2U) {
#line 182
    goto case_4;
  }
#line 182
  if ((unsigned int )mode == 1U) {
#line 182
    goto case_4;
  }
#line 190
  if ((unsigned int )mode == 0U) {
#line 190
    goto case_0;
  }
#line 194
  goto switch_default;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 183
  r = findrec(cdbmp, key, klen, hval, mode);
  }
#line 184
  if (r < 0) {
#line 185
    return (-1);
  }
#line 186
  if (r) {
#line 186
    if ((unsigned int )mode == 2U) {
      {
#line 187
      tmp___0 = __errno_location();
#line 187
      *tmp___0 = 17;
      }
#line 187
      return (1);
    }
  }
#line 188
  goto switch_break;
  case_0: /* CIL Label */ 
#line 191
  r = 0;
#line 192
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 195
  tmp___1 = __errno_location();
#line 195
  *tmp___1 = 22;
  }
#line 195
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 198
  tmp___2 = (int )_cdb_make_add(cdbmp, hval, key, klen, val, vlen);
  }
#line 198
  if (tmp___2 < 0) {
#line 199
    return (-1);
  }
#line 201
  return (r);
}
}
#line 9 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_hash.c"
unsigned int cdb_hash(void const   *buf___0 , unsigned int len ) 
{ 
  register unsigned char const   *p ;
  register unsigned char const   *end ;
  register unsigned int hash ;
  unsigned char const   *tmp ;

  {
#line 12
  p = (unsigned char const   *)buf___0;
#line 13
  end = p + len;
#line 14
  hash = 5381U;
  {
#line 15
  while (1) {
    while_continue: /* CIL Label */ ;
#line 15
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 15
      goto while_break;
    }
#line 16
    tmp = p;
#line 16
    p ++;
#line 16
    hash = (hash + (hash << 5)) ^ (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 17
  return (hash);
}
}
#line 61 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off64_t __offset )  __asm__("mmap64")  ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 220 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf )  __asm__("fstat64")  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.h"
void cdb_free(struct cdb *cdbp ) ;
#line 49
void const   *cdb_get(struct cdb  const  *cdbp , unsigned int len , unsigned int pos ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_init.c"
int cdb_init(struct cdb *cdbp , int fd ) 
{ 
  struct stat st ;
  unsigned char *mem ;
  unsigned int fsize ;
  unsigned int dend ;
  int tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;

  {
  {
#line 30
  tmp = fstat(fd, & st);
  }
#line 30
  if (tmp < 0) {
#line 31
    return (-1);
  }
#line 33
  if (st.st_size < 2048L) {
    {
#line 34
    tmp___0 = __errno_location();
#line 34
    *tmp___0 = 71;
    }
#line 34
    return (-1);
  }
#line 35
  if (st.st_size < 4294967295L) {
#line 35
    fsize = (unsigned int )st.st_size;
  } else {
#line 35
    fsize = 4294967295U;
  }
  {
#line 49
  tmp___1 = mmap((void *)0, (size_t )fsize, 1, 1, fd, (__off64_t )0);
#line 49
  mem = (unsigned char *)tmp___1;
  }
#line 50
  if ((unsigned long )mem == (unsigned long )((void *)-1)) {
#line 51
    return (-1);
  }
  {
#line 54
  cdbp->cdb_fd = fd;
#line 55
  cdbp->cdb_fsize = fsize;
#line 56
  cdbp->cdb_mem = (unsigned char const   *)mem;
#line 71
  tmp___2 = 0U;
#line 71
  cdbp->cdb_vlen = tmp___2;
#line 71
  cdbp->cdb_vpos = tmp___2;
#line 72
  tmp___3 = 0U;
#line 72
  cdbp->cdb_klen = tmp___3;
#line 72
  cdbp->cdb_kpos = tmp___3;
#line 73
  dend = cdb_unpack((unsigned char const   *)mem);
  }
#line 74
  if (dend < 2048U) {
#line 74
    dend = 2048U;
  } else
#line 75
  if (dend >= fsize) {
#line 75
    dend = fsize;
  }
#line 76
  cdbp->cdb_dend = dend;
#line 78
  return (0);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_init.c"
void cdb_free(struct cdb *cdbp ) 
{ 


  {
#line 84
  if (cdbp->cdb_mem) {
    {
#line 88
    munmap((void *)cdbp->cdb_mem, (size_t )cdbp->cdb_fsize);
#line 90
    cdbp->cdb_mem = (unsigned char const   *)((void *)0);
    }
  }
#line 92
  cdbp->cdb_fsize = 0U;
#line 93
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_init.c"
void const   *cdb_get(struct cdb  const  *cdbp , unsigned int len , unsigned int pos ) 
{ 
  int *tmp ;

  {
#line 98
  if (pos > (unsigned int )cdbp->cdb_fsize) {
    {
#line 99
    tmp = __errno_location();
#line 99
    *tmp = 71;
    }
#line 100
    return ((void const   *)((void *)0));
  } else
#line 98
  if (cdbp->cdb_fsize - (unsigned int const   )pos < (unsigned int const   )len) {
    {
#line 99
    tmp = __errno_location();
#line 99
    *tmp = 71;
    }
#line 100
    return ((void const   *)((void *)0));
  }
#line 102
  return ((void const   *)(cdbp->cdb_mem + pos));
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_init.c"
int cdb_read(struct cdb  const  *cdbp , void *buf___0 , unsigned int len , unsigned int pos ) 
{ 
  void const   *data ;
  void const   *tmp ;

  {
  {
#line 108
  tmp = cdb_get(cdbp, len, pos);
#line 108
  data = tmp;
  }
#line 109
  if (! data) {
#line 109
    return (-1);
  }
  {
#line 110
  memcpy((void */* __restrict  */)buf___0, (void const   */* __restrict  */)data,
         (size_t )len);
  }
#line 111
  return (0);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb.h"
int cdb_seek(int fd , void const   *key , unsigned int klen , unsigned int *dlenp ) ;
#line 76
int cdb_bread(int fd , void *buf___0 , int len ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_seek.c"
int cdb_bread(int fd , void *buf___0 , int len ) 
{ 
  int l ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
#line 20
    if (! (len > 0)) {
#line 20
      goto while_break;
    }
    {
#line 21
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 21
      tmp = read(fd, buf___0, (size_t )len);
#line 21
      l = (int )tmp;
      }
#line 21
      if (l < 0) {
        {
#line 21
        tmp___0 = __errno_location();
        }
#line 21
        if (! (*tmp___0 == 4)) {
#line 21
          goto while_break___0;
        }
      } else {
#line 21
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 23
    if (l <= 0) {
#line 24
      if (! l) {
        {
#line 25
        tmp___1 = __errno_location();
#line 25
        *tmp___1 = 5;
        }
      }
#line 26
      return (-1);
    }
#line 28
    buf___0 = (void *)((char *)buf___0 + l);
#line 29
    len -= l;
  }
  while_break: /* CIL Label */ ;
  }
#line 31
  return (0);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/tinycdb-0.78/cdb_seek.c"
int cdb_seek(int fd , void const   *key , unsigned int klen , unsigned int *dlenp ) 
{ 
  unsigned int htstart ;
  unsigned int htsize ;
  unsigned int httodo ;
  unsigned int hti ;
  unsigned int pos ;
  unsigned int hval ;
  unsigned char rbuf[64] ;
  int needseek ;
  __off64_t tmp ;
  int tmp___0 ;
  __off64_t tmp___1 ;
  int tmp___2 ;
  __off64_t tmp___3 ;
  int tmp___4 ;
  unsigned int l ;
  unsigned int c ;
  char const   *k ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;

  {
  {
#line 47
  needseek = 1;
#line 49
  hval = cdb_hash(key, klen);
#line 50
  pos = (hval & 255U) << 3;
#line 52
  tmp = lseek(fd, (__off64_t )pos, 0);
  }
#line 52
  if (tmp < 0L) {
#line 53
    return (-1);
  } else {
    {
#line 52
    tmp___0 = cdb_bread(fd, (void *)(rbuf), 8);
    }
#line 52
    if (tmp___0 < 0) {
#line 53
      return (-1);
    }
  }
  {
#line 54
  htsize = cdb_unpack((unsigned char const   *)(rbuf + 4));
  }
#line 54
  if (htsize == 0U) {
#line 55
    return (0);
  }
  {
#line 56
  hti = (hval >> 8) % htsize;
#line 57
  httodo = htsize;
#line 58
  htstart = cdb_unpack((unsigned char const   *)(rbuf));
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (needseek) {
      {
#line 61
      tmp___1 = lseek(fd, (__off64_t )(htstart + (hti << 3)), 0);
      }
#line 61
      if (tmp___1 < 0L) {
#line 62
        return (-1);
      }
    }
    {
#line 63
    tmp___2 = cdb_bread(fd, (void *)(rbuf), 8);
    }
#line 63
    if (tmp___2 < 0) {
#line 64
      return (-1);
    }
    {
#line 65
    pos = cdb_unpack((unsigned char const   *)(rbuf + 4));
    }
#line 65
    if (pos == 0U) {
#line 66
      return (0);
    }
    {
#line 68
    tmp___8 = cdb_unpack((unsigned char const   *)(rbuf));
    }
#line 68
    if (tmp___8 != hval) {
#line 69
      needseek = 0;
    } else {
      {
#line 71
      tmp___3 = lseek(fd, (__off64_t )pos, 0);
      }
#line 71
      if (tmp___3 < 0L) {
#line 72
        return (-1);
      } else {
        {
#line 71
        tmp___4 = cdb_bread(fd, (void *)(rbuf), 8);
        }
#line 71
        if (tmp___4 < 0) {
#line 72
          return (-1);
        }
      }
      {
#line 73
      tmp___7 = cdb_unpack((unsigned char const   *)(rbuf));
      }
#line 73
      if (tmp___7 == klen) {
#line 75
        l = klen;
#line 76
        k = (char const   *)key;
#line 77
        if (dlenp) {
          {
#line 78
          *dlenp = cdb_unpack((unsigned char const   *)(rbuf + 4));
          }
        }
        {
#line 79
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 80
          if (! l) {
#line 81
            return (1);
          }
#line 82
          if ((unsigned long )l > sizeof(rbuf)) {
#line 82
            c = (unsigned int )sizeof(rbuf);
          } else {
#line 82
            c = l;
          }
          {
#line 83
          tmp___5 = cdb_bread(fd, (void *)(rbuf), (int )c);
          }
#line 83
          if (tmp___5 < 0) {
#line 84
            return (-1);
          }
          {
#line 85
          tmp___6 = memcmp((void const   *)(rbuf), (void const   *)k, (size_t )c);
          }
#line 85
          if (tmp___6 != 0) {
#line 86
            goto while_break___0;
          }
#line 87
          k += c;
#line 87
          l -= c;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 90
      needseek = 1;
    }
#line 92
    httodo --;
#line 92
    if (! httodo) {
#line 93
      return (0);
    }
#line 94
    hti ++;
#line 94
    if (hti == htsize) {
#line 95
      hti = 0U;
#line 96
      needseek = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
