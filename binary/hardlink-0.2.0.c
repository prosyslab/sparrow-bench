/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 88 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off64_t off_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 105 "/usr/include/ftw.h"
struct FTW {
   int base ;
   int level ;
};
#line 118 "/usr/include/search.h"
enum __anonenum_VISIT_35 {
    preorder = 0,
    postorder = 1,
    endorder = 2,
    leaf = 3
} ;
#line 118 "/usr/include/search.h"
typedef enum __anonenum_VISIT_35 VISIT;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_38 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_39 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_40 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_41 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_42 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_43 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_44 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_37 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_38 _kill ;
   struct __anonstruct__timer_39 _timer ;
   struct __anonstruct__rt_40 _rt ;
   struct __anonstruct__sigchld_41 _sigchld ;
   struct __anonstruct__sigfault_42 _sigfault ;
   struct __anonstruct__sigpoll_43 _sigpoll ;
   struct __anonstruct__sigsys_44 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_36 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_37 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_36 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_56 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_56 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 51 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
enum hl_bool {
    FALSE = 0,
    TRUE = 1
} ;
#line 51 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
typedef enum hl_bool hl_bool;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_74 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_74 regmatch_t;
#line 97 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
struct file {
   struct stat st ;
   struct file *next ;
   int basename ;
   hl_bool slave ;
   char path[0] ;
};
#line 122
enum log_level {
    JLOG_SYSFAT = -4,
    JLOG_FATAL = -3,
    JLOG_SYSERR = -2,
    JLOG_ERROR = -1,
    JLOG_SUMMARY = 0,
    JLOG_INFO = 1,
    JLOG_DEBUG1 = 2,
    JLOG_DEBUG2 = 3
} ;
#line 142 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
struct statistics {
   hl_bool started ;
   size_t files ;
   size_t linked ;
   size_t comparisons ;
   double saved ;
   double start_time ;
};
#line 164 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
struct regex_link {
   regex_t preg ;
   struct regex_link *next ;
};
#line 164 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
struct options {
   struct regex_link *include ;
   struct regex_link *exclude ;
   int verbosity ;
   unsigned int respect_mode : 1 ;
   unsigned int respect_owner : 1 ;
   unsigned int respect_name : 1 ;
   unsigned int respect_time : 1 ;
   unsigned int maximise : 1 ;
   unsigned int minimise : 1 ;
   unsigned int dry_run : 1 ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 790 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) link)(char const   *__from ,
                                                                                             char const   *__to ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 242 "/usr/include/fcntl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) posix_fadvise)(int __fd ,
                                                                                    __off64_t __offset ,
                                                                                    __off64_t __len ,
                                                                                    int __advise )  __asm__("posix_fadvise64")  ;
#line 162 "/usr/include/ftw.h"
extern int ( __attribute__((__nonnull__(1,2))) nftw)(char const   *__dir , int (*__func)(char const   *__filename ,
                                                                                         struct stat  const  *__status ,
                                                                                         int __flag ,
                                                                                         struct FTW *__info ) ,
                                                     int __descriptors , int __flag )  __asm__("nftw64")  ;
#line 129 "/usr/include/search.h"
extern void *tsearch(void const   *__key , void **__rootp , int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 150
extern void twalk(void const   *__root , void (*__action)(void const   *__nodep ,
                                                          VISIT __value , int __level ) ) ;
#line 158
extern void tdestroy(void *__root , void (*__freefct)(void *__nodep ) ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 218 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigfillset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 580
extern int putchar(int __c ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 519
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 582
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 142 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static struct statistics stats  ;
#line 164 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static struct options opts  ;
#line 185 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static void *files  ;
#line 193 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static int last_signal  ;
#line 195 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static void ( /* format attribute */  jlog)(enum log_level level , char const   *format 
                                            , ...) 
{ 
  FILE *stream ;
  struct _IO_FILE *tmp ;
  int errno_ ;
  int *tmp___0 ;
  va_list args ;
  char *tmp___1 ;

  {
#line 203
  if ((int )level >= 0) {
#line 203
    tmp = stdout;
  } else {
#line 203
    tmp = stderr;
  }
  {
#line 203
  stream = tmp;
#line 204
  tmp___0 = __errno_location();
#line 204
  errno_ = *tmp___0;
  }
#line 207
  if ((int )level <= opts.verbosity) {
#line 208
    if ((int )level <= -3) {
      {
#line 209
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"ERROR: ");
      }
    } else
#line 210
    if ((int )level < 0) {
      {
#line 211
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"WARNING: ");
      }
    }
    {
#line 212
    __builtin_va_start(args, format);
#line 213
    vfprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)format,
             args);
#line 214
    __builtin_va_end(args);
    }
#line 215
    if ((int )level == -2) {
      {
#line 216
      tmp___1 = strerror(errno_);
#line 216
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)": %s\n",
              tmp___1);
      }
    } else
#line 215
    if ((int )level == -4) {
      {
#line 216
      tmp___1 = strerror(errno_);
#line 216
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)": %s\n",
              tmp___1);
      }
    } else {
      {
#line 218
      fputc('\n', stream);
      }
    }
  }
#line 220
  return;
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static char buf[256]  ;
#line 238 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static char const   *format(double bytes ) 
{ 


  {
#line 242
  if (bytes >= (double )1073741824) {
    {
#line 243
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%.2f GiB",
             ((bytes / (double )1024) / (double )1024) / (double )1024);
    }
  } else
#line 244
  if (bytes >= (double )1048576) {
    {
#line 245
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%.2f MiB",
             (bytes / (double )1024) / (double )1024);
    }
  } else
#line 246
  if (bytes >= (double )1024) {
    {
#line 247
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%.2f KiB",
             bytes / (double )1024);
    }
  } else {
    {
#line 249
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%.0f bytes",
             bytes);
    }
  }
#line 251
  return ((char const   *)(buf));
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static double gettime(void) 
{ 
  struct timeval tv ;
  int tmp ;

  {
  {
#line 259
  tv.tv_sec = (__time_t )0;
#line 259
  tv.tv_usec = (__suseconds_t )0;
#line 261
  tmp = gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
  }
#line 261
  if (tmp != 0) {
    {
#line 262
    jlog((enum log_level )-2, "Cannot read current time");
    }
  }
#line 264
  return ((double )tv.tv_sec + (double )tv.tv_usec / (double )1000000);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static hl_bool regexec_any(struct regex_link *pregs , char const   *what ) 
{ 
  int tmp ;

  {
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! ((unsigned long )pregs != (unsigned long )((void *)0))) {
#line 277
      goto while_break;
    }
    {
#line 278
    tmp = regexec((regex_t const   */* __restrict  */)(& pregs->preg), (char const   */* __restrict  */)what,
                  (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 278
    if (tmp == 0) {
#line 279
      return ((hl_bool )1);
    }
#line 277
    pregs = pregs->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  return ((hl_bool )0);
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static int compare_nodes(void const   *_a , void const   *_b ) 
{ 
  struct file  const  *a ;
  struct file  const  *b ;
  int diff ;
  int tmp ;
  int tmp___0 ;

  {
#line 292
  a = (struct file  const  *)_a;
#line 293
  b = (struct file  const  *)_b;
#line 294
  diff = 0;
#line 296
  if (diff == 0) {
#line 297
    if (a->st.st_dev > b->st.st_dev) {
#line 297
      diff = 1;
    } else {
#line 297
      if (a->st.st_dev < b->st.st_dev) {
#line 297
        tmp = -1;
      } else {
#line 297
        tmp = 0;
      }
#line 297
      diff = tmp;
    }
  }
#line 298
  if (diff == 0) {
#line 299
    if (a->st.st_size > b->st.st_size) {
#line 299
      diff = 1;
    } else {
#line 299
      if (a->st.st_size < b->st.st_size) {
#line 299
        tmp___0 = -1;
      } else {
#line 299
        tmp___0 = 0;
      }
#line 299
      diff = tmp___0;
    }
  }
#line 301
  return (diff);
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static void print_stats(void) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  double tmp___1 ;

  {
#line 309
  if (opts.dry_run) {
#line 309
    tmp = "dry-run";
  } else {
#line 309
    tmp = "real";
  }
  {
#line 309
  jlog((enum log_level )0, "Mode:     %s", tmp);
#line 310
  jlog((enum log_level )0, "Files:    %zu", stats.files);
#line 311
  jlog((enum log_level )0, "Linked:   %zu files", stats.linked);
#line 312
  jlog((enum log_level )0, "Compared: %zu files", stats.comparisons);
#line 313
  tmp___0 = format(stats.saved);
#line 313
  jlog((enum log_level )0, "Saved:    %s", tmp___0);
#line 314
  tmp___1 = gettime();
#line 314
  jlog((enum log_level )0, "Duration: %.2f seconds", tmp___1 - stats.start_time);
  }
#line 315
  return;
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static hl_bool handle_interrupt(void) 
{ 


  {
  {
#line 326
  if (last_signal == 15) {
#line 326
    goto case_15;
  }
#line 326
  if (last_signal == 2) {
#line 326
    goto case_15;
  }
#line 328
  if (last_signal == 10) {
#line 328
    goto case_10;
  }
#line 324
  goto switch_break;
  case_15: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 327
  return ((hl_bool )1);
  case_10: /* CIL Label */ 
  {
#line 329
  print_stats();
#line 330
  putchar('\n');
  }
#line 331
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 334
  last_signal = 0;
#line 335
  return ((hl_bool )0);
}
}
#line 345 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static hl_bool file_contents_equal(struct file  const  *a , struct file  const  *b ) 
{ 
  FILE *fa ;
  FILE *fb ;
  char buf_a[8192] ;
  char buf_b[8192] ;
  int cmp ;
  off_t off ;
  int tmp ;
  int tmp___0 ;
  size_t ca ;
  size_t cb ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  hl_bool tmp___4 ;
  char *tmp___5 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 347
  fa = (FILE *)((void *)0);
#line 348
  fb = (FILE *)((void *)0);
#line 351
  cmp = 0;
#line 352
  off = (off_t )0;
#line 354
  jlog((enum log_level )2, "Comparing %s to %s", a->path, b->path);
#line 356
  (stats.comparisons) ++;
#line 358
  fa = fopen((char const   */* __restrict  */)(a->path), (char const   */* __restrict  */)"rb");
  }
#line 358
  if ((unsigned long )fa == (unsigned long )((void *)0)) {
#line 359
    goto err;
  }
  {
#line 360
  fb = fopen((char const   */* __restrict  */)(b->path), (char const   */* __restrict  */)"rb");
  }
#line 360
  if ((unsigned long )fb == (unsigned long )((void *)0)) {
#line 361
    goto err;
  }
  {
#line 363
  tmp = fileno(fa);
#line 363
  posix_fadvise(tmp, (__off64_t )0, (__off64_t )0, 2);
#line 364
  tmp___0 = fileno(fb);
#line 364
  posix_fadvise(tmp___0, (__off64_t )0, (__off64_t )0, 2);
  }
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 366
    tmp___4 = handle_interrupt();
    }
#line 366
    if (tmp___4) {
#line 366
      goto while_break;
    } else
#line 366
    if (! (cmp == 0)) {
#line 366
      goto while_break;
    }
    {
#line 370
    ca = fread((void */* __restrict  */)(buf_a), (size_t )1, sizeof(buf_a), (FILE */* __restrict  */)fa);
    }
#line 371
    if (ca < sizeof(buf_a)) {
      {
#line 371
      tmp___1 = ferror(fa);
      }
#line 371
      if (tmp___1) {
#line 372
        goto err;
      }
    }
    {
#line 374
    cb = fread((void */* __restrict  */)(buf_b), (size_t )1, sizeof(buf_b), (FILE */* __restrict  */)fb);
    }
#line 375
    if (cb < sizeof(buf_b)) {
      {
#line 375
      tmp___2 = ferror(fb);
      }
#line 375
      if (tmp___2) {
#line 376
        goto err;
      }
    }
#line 378
    off = (off_t )((size_t )off + ca);
#line 380
    if (ca != cb) {
#line 380
      goto _L;
    } else
#line 380
    if (ca == 0UL) {
      _L: /* CIL Label */ 
#line 381
      if (ca > cb) {
#line 381
        cmp = 1;
      } else {
#line 381
        if (ca < cb) {
#line 381
          tmp___3 = -1;
        } else {
#line 381
          tmp___3 = 0;
        }
#line 381
        cmp = tmp___3;
      }
#line 382
      goto while_break;
    }
    {
#line 384
    cmp = memcmp((void const   *)(buf_a), (void const   *)(buf_b), ca);
    }
  }
  while_break: /* CIL Label */ ;
  }
  out: 
#line 387
  if ((unsigned long )fa != (unsigned long )((void *)0)) {
    {
#line 388
    fclose(fa);
    }
  }
#line 389
  if ((unsigned long )fb != (unsigned long )((void *)0)) {
    {
#line 390
    fclose(fb);
    }
  }
#line 391
  return ((hl_bool )(cmp == 0));
  err: 
#line 393
  if ((unsigned long )fa == (unsigned long )((void *)0)) {
#line 393
    goto _L___0;
  } else
#line 393
  if ((unsigned long )fb == (unsigned long )((void *)0)) {
    _L___0: /* CIL Label */ 
#line 394
    if (fa) {
#line 394
      tmp___5 = b->path;
    } else {
#line 394
      tmp___5 = a->path;
    }
    {
#line 394
    jlog((enum log_level )-2, "Cannot open %s", tmp___5);
    }
  } else {
    {
#line 396
    tmp___8 = ferror(fa);
    }
#line 396
    if (tmp___8) {
#line 396
      tmp___7 = a->path;
    } else {
#line 396
      tmp___7 = b->path;
    }
    {
#line 396
    jlog((enum log_level )-2, "Cannot read %s", tmp___7);
    }
  }
#line 397
  cmp = 1;
#line 398
  goto out;
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static hl_bool file_may_link_to(struct file  const  *a , struct file  const  *b ) 
{ 
  int tmp ;
  hl_bool tmp___0 ;
  int tmp___1 ;

  {
#line 412
  if (a->st.st_size != 0L) {
#line 412
    if (a->st.st_size == b->st.st_size) {
#line 412
      if (a->st.st_dev == b->st.st_dev) {
#line 412
        if (a->st.st_ino != b->st.st_ino) {
#line 412
          if (! opts.respect_mode) {
#line 412
            goto _L___3;
          } else
#line 412
          if (a->st.st_mode == b->st.st_mode) {
            _L___3: /* CIL Label */ 
#line 412
            if (! opts.respect_owner) {
#line 412
              goto _L___2;
            } else
#line 412
            if (a->st.st_uid == b->st.st_uid) {
              _L___2: /* CIL Label */ 
#line 412
              if (! opts.respect_owner) {
#line 412
                goto _L___1;
              } else
#line 412
              if (a->st.st_gid == b->st.st_gid) {
                _L___1: /* CIL Label */ 
#line 412
                if (! opts.respect_time) {
#line 412
                  goto _L___0;
                } else
#line 412
                if (a->st.st_mtim.tv_sec == b->st.st_mtim.tv_sec) {
                  _L___0: /* CIL Label */ 
#line 412
                  if (! opts.respect_name) {
#line 412
                    goto _L;
                  } else {
                    {
#line 412
                    tmp = strcmp((char const   *)(a->path + a->basename), (char const   *)(b->path + b->basename));
                    }
#line 412
                    if (tmp == 0) {
                      _L: /* CIL Label */ 
                      {
#line 412
                      tmp___0 = file_contents_equal(a, b);
                      }
#line 412
                      if (tmp___0) {
#line 412
                        tmp___1 = 1;
                      } else {
#line 412
                        tmp___1 = 0;
                      }
                    } else {
#line 412
                      tmp___1 = 0;
                    }
                  }
                } else {
#line 412
                  tmp___1 = 0;
                }
              } else {
#line 412
                tmp___1 = 0;
              }
            } else {
#line 412
              tmp___1 = 0;
            }
          } else {
#line 412
            tmp___1 = 0;
          }
        } else {
#line 412
          tmp___1 = 0;
        }
      } else {
#line 412
        tmp___1 = 0;
      }
    } else {
#line 412
      tmp___1 = 0;
    }
  } else {
#line 412
    tmp___1 = 0;
  }
#line 412
  return ((hl_bool )tmp___1);
}
}
#line 434 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static int file_compare(struct file  const  *a , struct file  const  *b ) 
{ 
  int res ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 436
  res = 0;
#line 437
  if (a->st.st_dev == b->st.st_dev) {
#line 437
    if (a->st.st_ino == b->st.st_ino) {
#line 438
      return (0);
    }
  }
#line 440
  if (res == 0) {
#line 440
    if (opts.maximise) {
#line 441
      if (a->st.st_nlink > b->st.st_nlink) {
#line 441
        res = 1;
      } else {
#line 441
        if (a->st.st_nlink < b->st.st_nlink) {
#line 441
          tmp = -1;
        } else {
#line 441
          tmp = 0;
        }
#line 441
        res = tmp;
      }
    }
  }
#line 442
  if (res == 0) {
#line 442
    if (opts.minimise) {
#line 443
      if (b->st.st_nlink > a->st.st_nlink) {
#line 443
        res = 1;
      } else {
#line 443
        if (b->st.st_nlink < a->st.st_nlink) {
#line 443
          tmp___0 = -1;
        } else {
#line 443
          tmp___0 = 0;
        }
#line 443
        res = tmp___0;
      }
    }
  }
#line 444
  if (res == 0) {
#line 445
    if (a->st.st_mtim.tv_sec > b->st.st_mtim.tv_sec) {
#line 445
      res = 1;
    } else {
#line 445
      if (a->st.st_mtim.tv_sec < b->st.st_mtim.tv_sec) {
#line 445
        tmp___1 = -1;
      } else {
#line 445
        tmp___1 = 0;
      }
#line 445
      res = tmp___1;
    }
  }
#line 446
  if (res == 0) {
#line 447
    if (b->st.st_ino > a->st.st_ino) {
#line 447
      res = 1;
    } else {
#line 447
      if (b->st.st_ino < a->st.st_ino) {
#line 447
        tmp___2 = -1;
      } else {
#line 447
        tmp___2 = 0;
      }
#line 447
      res = tmp___2;
    }
  }
#line 449
  return (res);
}
}
#line 461 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static hl_bool file_link(struct file *a , struct file *b ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  size_t len ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *new_path ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 463
  tmp = format((double )a->st.st_size);
  }
#line 463
  if (opts.dry_run) {
#line 463
    tmp___0 = "[DryRun] ";
  } else {
#line 463
    tmp___0 = "";
  }
  {
#line 463
  jlog((enum log_level )1, "%sLinking %s to %s (-%s)", tmp___0, a->path, b->path,
       tmp);
  }
#line 467
  if (a->st.st_dev == b->st.st_dev) {
#line 467
    if (a->st.st_ino == b->st.st_ino) {
#line 468
      b->slave = (hl_bool )1;
#line 469
      return ((hl_bool )1);
    }
  }
#line 472
  if (! opts.dry_run) {
    {
#line 473
    tmp___1 = strlen((char const   *)(b->path));
#line 473
    tmp___2 = strlen(".hardlink-temporary");
#line 473
    len = (tmp___1 + tmp___2) + 1UL;
#line 474
    tmp___3 = malloc(len);
#line 474
    new_path = (char *)tmp___3;
    }
#line 476
    if ((unsigned long )new_path == (unsigned long )((void *)0)) {
      {
#line 477
      jlog((enum log_level )-4, "Cannot allocate memory");
#line 478
      exit(1);
      }
    }
    {
#line 481
    snprintf((char */* __restrict  */)new_path, len, (char const   */* __restrict  */)"%s.hardlink-temporary",
             b->path);
#line 483
    tmp___5 = link((char const   *)(a->path), (char const   *)new_path);
    }
#line 483
    if (tmp___5 != 0) {
      {
#line 484
      jlog((enum log_level )-2, "Cannot link %s to %s", a->path, new_path);
#line 485
      free((void *)new_path);
      }
#line 486
      return ((hl_bool )0);
    } else {
      {
#line 487
      tmp___4 = rename((char const   *)new_path, (char const   *)(b->path));
      }
#line 487
      if (tmp___4 != 0) {
        {
#line 488
        jlog((enum log_level )-2, "Cannot rename %s to %s", a->path, new_path);
#line 489
        unlink((char const   *)new_path);
#line 490
        free((void *)new_path);
        }
#line 491
        return ((hl_bool )0);
      }
    }
    {
#line 493
    free((void *)new_path);
    }
  }
#line 497
  (stats.linked) ++;
#line 498
  stats.saved += (double )a->st.st_size;
#line 501
  (a->st.st_nlink) ++;
#line 502
  b->st = a->st;
#line 504
  b->slave = (hl_bool )1;
#line 506
  return ((hl_bool )1);
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static void file_free_chain(void *node ) 
{ 
  struct file *file ;

  {
#line 518
  file = (struct file *)node;
#line 520
  if (file) {
    {
#line 521
    file_free_chain((void *)file->next);
#line 522
    free(node);
    }
  }
#line 524
  return;
}
}
#line 536 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static int inserter(char const   *fpath , struct stat  const  *sb , int typeflag ,
                    struct FTW *ftwbuf ) 
{ 
  struct file *fil ;
  struct file **node ;
  size_t pathlen ;
  hl_bool included ;
  hl_bool excluded ;
  hl_bool tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 545
  tmp = handle_interrupt();
  }
#line 545
  if (tmp) {
#line 546
    return (1);
  }
#line 547
  if (typeflag == 2) {
    {
#line 548
    jlog((enum log_level )-2, "Cannot read %s", fpath);
    }
  } else
#line 547
  if (typeflag == 3) {
    {
#line 548
    jlog((enum log_level )-2, "Cannot read %s", fpath);
    }
  }
#line 549
  if (typeflag != 0) {
#line 550
    return (0);
  } else
#line 549
  if (! ((sb->st_mode & 61440U) == 32768U)) {
#line 550
    return (0);
  }
  {
#line 552
  included = regexec_any(opts.include, fpath);
#line 553
  excluded = regexec_any(opts.exclude, fpath);
  }
#line 555
  if (opts.exclude) {
#line 555
    if (excluded) {
#line 555
      if (! included) {
#line 557
        return (0);
      } else {
#line 555
        goto _L___0;
      }
    } else {
#line 555
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 555
  if (! opts.exclude) {
#line 555
    if (opts.include) {
#line 555
      if (! included) {
#line 557
        return (0);
      }
    }
  }
#line 559
  (stats.files) ++;
#line 561
  if (sb->st_size == 0L) {
#line 562
    return (0);
  }
  {
#line 564
  jlog((enum log_level )3, "Visiting %s (file %zu)", fpath, stats.files);
#line 566
  tmp___0 = strlen(fpath);
#line 566
  pathlen = tmp___0 + 1UL;
#line 568
  tmp___1 = calloc((size_t )1, sizeof(*fil) + pathlen);
#line 568
  fil = (struct file *)tmp___1;
  }
#line 570
  if ((unsigned long )fil == (unsigned long )((void *)0)) {
    {
#line 571
    jlog((enum log_level )-4, "Cannot continue");
    }
#line 571
    return (1);
  }
  {
#line 573
  fil->st = (struct stat )*sb;
#line 574
  fil->basename = ftwbuf->base;
#line 576
  memcpy((void */* __restrict  */)(fil->path), (void const   */* __restrict  */)fpath,
         pathlen);
#line 578
  tmp___2 = tsearch((void const   *)fil, & files, & compare_nodes);
#line 578
  node = (struct file **)tmp___2;
  }
#line 580
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    {
#line 581
    jlog((enum log_level )-4, "Cannot continue");
    }
#line 581
    return (1);
  }
#line 583
  if ((unsigned long )*node != (unsigned long )fil) {
#line 584
    if (! ((*node)->st.st_size == (__off_t )sb->st_size)) {
      {
#line 584
      __assert_fail("(*node)->st.st_size == sb->st_size", "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c",
                    584U, "inserter");
      }
    }
#line 585
    fil->next = *node;
#line 586
    *node = fil;
  }
#line 589
  return (0);
}
}
#line 600 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static int hardlinker(struct file *master ) 
{ 
  struct file *other ;
  struct file **others ;
  size_t i ;
  size_t n ;
  hl_bool tmp ;
  hl_bool tmp___0 ;
  hl_bool tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  hl_bool tmp___6 ;
  hl_bool tmp___7 ;

  {
  {
#line 602
  other = (struct file *)((void *)0);
#line 603
  others = (struct file **)((void *)0);
#line 604
  i = (size_t )8;
#line 604
  n = (size_t )0;
#line 606
  tmp = handle_interrupt();
  }
#line 606
  if (tmp) {
#line 607
    return (1);
  }
#line 608
  if (master->slave) {
#line 609
    return (0);
  }
#line 611
  other = master->next;
  {
#line 611
  while (1) {
    while_continue: /* CIL Label */ ;
#line 611
    if (! ((unsigned long )other != (unsigned long )((void *)0))) {
#line 611
      goto while_break;
    }
    {
#line 612
    tmp___0 = handle_interrupt();
    }
#line 612
    if (tmp___0) {
#line 613
      return (1);
    }
#line 615
    if (! ((unsigned long )other != (unsigned long )other->next)) {
      {
#line 615
      __assert_fail("other != other->next", "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c",
                    615U, "hardlinker");
      }
    }
#line 616
    if (! (other->st.st_size == master->st.st_size)) {
      {
#line 616
      __assert_fail("other->st.st_size == master->st.st_size", "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c",
                    616U, "hardlinker");
      }
    }
    {
#line 618
    tmp___1 = file_may_link_to((struct file  const  *)master, (struct file  const  *)other);
    }
#line 618
    if (! tmp___1) {
#line 619
      goto __Cont;
    }
#line 620
    if (i <= n) {
      {
#line 621
      i *= 2UL;
#line 621
      tmp___2 = realloc((void *)others, i * sizeof(*others));
#line 621
      others = (struct file **)tmp___2;
      }
    } else
#line 620
    if ((unsigned long )others == (unsigned long )((void *)0)) {
      {
#line 621
      i *= 2UL;
#line 621
      tmp___2 = realloc((void *)others, i * sizeof(*others));
#line 621
      others = (struct file **)tmp___2;
      }
    }
#line 622
    if ((unsigned long )others == (unsigned long )((void *)0)) {
      {
#line 623
      jlog((enum log_level )-4, "Unable to continue");
      }
#line 624
      return (-1);
    }
    {
#line 626
    tmp___5 = file_compare((struct file  const  *)master, (struct file  const  *)other);
    }
#line 626
    if (tmp___5 < 0) {
#line 627
      tmp___3 = n;
#line 627
      n ++;
#line 627
      *(others + tmp___3) = master;
#line 628
      master = other;
    } else {
#line 630
      tmp___4 = n;
#line 630
      n ++;
#line 630
      *(others + tmp___4) = other;
    }
    __Cont: /* CIL Label */ 
#line 611
    other = other->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 634
  i = (size_t )0;
  {
#line 634
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 634
    tmp___6 = handle_interrupt();
    }
#line 634
    if (tmp___6) {
#line 634
      goto while_break___0;
    } else
#line 634
    if (! (i < n)) {
#line 634
      goto while_break___0;
    }
    {
#line 635
    file_link(master, *(others + i));
#line 634
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 637
  free((void *)others);
#line 639
  tmp___7 = handle_interrupt();
  }
#line 639
  return ((int )tmp___7);
}
}
#line 652 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static void visitor(void const   *nodep , VISIT const   which , int const   depth ) 
{ 
  struct file *file ;
  int tmp ;

  {
#line 654
  file = *((struct file **)nodep);
#line 658
  if ((unsigned int const   )which != 3U) {
#line 658
    if ((unsigned int const   )which != 2U) {
#line 659
      return;
    }
  }
  {
#line 661
  while (1) {
    while_continue: /* CIL Label */ ;
#line 661
    if (! ((unsigned long )file != (unsigned long )((void *)0))) {
#line 661
      goto while_break;
    }
    {
#line 662
    tmp = hardlinker(file);
    }
#line 662
    if (tmp != 0) {
      {
#line 663
      exit(1);
      }
    }
#line 661
    file = file->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 664
  return;
}
}
#line 669 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static int version(void) 
{ 


  {
  {
#line 671
  printf((char const   */* __restrict  */)"hardlink 0.2\n");
#line 672
  printf((char const   */* __restrict  */)"Compiled %s at %s\n", "Mar  4 2016", "00:58:43");
#line 673
  exit(0);
  }
}
}
#line 680 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static int help(char const   *name ) 
{ 


  {
  {
#line 682
  printf((char const   */* __restrict  */)"Usage: %s [options] directory|file ...\n",
         name);
#line 683
  puts("Options:");
#line 684
  puts("  -V, --version         show program\'s version number and exit");
#line 685
  puts("  -h, --help            show this help message and exit");
#line 686
  puts("  -v, --verbose         Increase verbosity (repeat for more verbosity)");
#line 687
  puts("  -n, --dry-run         Modify nothing, just print what would happen");
#line 688
  puts("  -f, --respect-name    Filenames have to be identical");
#line 689
  puts("  -p, --ignore-mode     Ignore changes of file mode");
#line 690
  puts("  -o, --ignore-owner    Ignore owner changes");
#line 691
  puts("  -t, --ignore-time     Ignore timestamps. Will retain the newer timestamp,");
#line 692
  puts("                        unless -m or -M is given");
#line 693
  puts("  -m, --maximize        Maximize the hardlink count, remove the file with");
#line 694
  puts("                        lowest hardlink cout");
#line 695
  puts("  -M, --minimize        Reverse the meaning of -m");
#line 696
  puts("  -x REGEXP, --exclude=REGEXP");
#line 697
  puts("                        Regular expression to exclude files");
#line 698
  puts("  -i REGEXP, --include=REGEXP");
#line 699
  puts("                        Regular expression to include files/dirs");
#line 700
  puts("");
#line 701
  puts("Compatibility options to Jakub Jelinek\'s hardlink:");
#line 702
  puts("  -c                    Compare only file contents, same as -pot");
#line 708
  exit(0);
  }
}
}
#line 716 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static int register_regex(struct regex_link **pregs , char const   *regex ) 
{ 
  struct regex_link *link___0 ;
  int err ;
  void *tmp ;
  size_t size ;
  size_t tmp___0 ;
  char *buf___0 ;
  void *tmp___1 ;

  {
  {
#line 721
  tmp = malloc(sizeof(*link___0));
#line 721
  link___0 = (struct regex_link *)tmp;
  }
#line 723
  if ((unsigned long )link___0 == (unsigned long )((void *)0)) {
    {
#line 724
    jlog((enum log_level )-4, "Cannot allocate memory");
#line 725
    exit(1);
    }
  }
  {
#line 728
  err = regcomp((regex_t */* __restrict  */)(& link___0->preg), (char const   */* __restrict  */)regex,
                (((1 << 1) << 1) << 1) | 1);
  }
#line 728
  if (err != 0) {
    {
#line 729
    tmp___0 = regerror(err, (regex_t const   */* __restrict  */)(& link___0->preg),
                       (char */* __restrict  */)((void *)0), (size_t )0);
#line 729
    size = tmp___0;
#line 730
    tmp___1 = malloc(size + 1UL);
#line 730
    buf___0 = (char *)tmp___1;
    }
#line 732
    if ((unsigned long )buf___0 == (unsigned long )((void *)0)) {
      {
#line 733
      jlog((enum log_level )-4, "Cannot allocate memory");
#line 734
      exit(1);
      }
    }
    {
#line 737
    regerror(err, (regex_t const   */* __restrict  */)(& link___0->preg), (char */* __restrict  */)buf___0,
             size);
#line 739
    jlog((enum log_level )-3, "Could not compile regular expression %s: %s", regex,
         buf___0);
#line 741
    free((void *)buf___0);
#line 742
    free((void *)link___0);
    }
#line 743
    return (1);
  }
#line 746
  link___0->next = *pregs;
#line 747
  *pregs = link___0;
#line 748
  return (0);
}
}
#line 758
static int parse_options(int argc , char **argv ) ;
#line 758 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static char const   optstr[16]  = 
#line 758
  {      (char const   )'V',      (char const   )'h',      (char const   )'v',      (char const   )'n', 
        (char const   )'f',      (char const   )'p',      (char const   )'o',      (char const   )'t', 
        (char const   )'c',      (char const   )'m',      (char const   )'M',      (char const   )'x', 
        (char const   )':',      (char const   )'i',      (char const   )':',      (char const   )'\000'};
#line 760
static int parse_options(int argc , char **argv ) ;
#line 760 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static struct option  const  long_options[13]  = 
#line 760
  {      {"version", 0, (int *)((void *)0), 'V'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"verbose", 0, (int *)((void *)0), 'v'}, 
        {"dry-run", 0, (int *)((void *)0), 'n'}, 
        {"respect-name", 0, (int *)((void *)0), 'f'}, 
        {"ignore-mode", 0, (int *)((void *)0), 'p'}, 
        {"ignore-owner", 0, (int *)((void *)0), 'o'}, 
        {"ignore-time", 0, (int *)((void *)0), 't'}, 
        {"maximize", 0, (int *)((void *)0), 'm'}, 
        {"minimize", 0, (int *)((void *)0), 'M'}, 
        {"exclude", 1, (int *)((void *)0), 'x'}, 
        {"include", 1, (int *)((void *)0), 'i'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 756 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static int parse_options(int argc , char **argv ) 
{ 
  int opt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 779
  opts.respect_mode = 1U;
#line 780
  opts.respect_owner = 1U;
#line 781
  opts.respect_time = 1U;
  {
#line 783
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 783
    opt = getopt_long(argc, (char * const  *)argv, optstr, long_options, (int *)((void *)0));
    }
#line 783
    if (! (opt != -1)) {
#line 783
      goto while_break;
    }
    {
#line 785
    if (opt == 112) {
#line 785
      goto case_112;
    }
#line 788
    if (opt == 111) {
#line 788
      goto case_111;
    }
#line 791
    if (opt == 116) {
#line 791
      goto case_116;
    }
#line 794
    if (opt == 109) {
#line 794
      goto case_109;
    }
#line 797
    if (opt == 77) {
#line 797
      goto case_77;
    }
#line 800
    if (opt == 102) {
#line 800
      goto case_102;
    }
#line 803
    if (opt == 118) {
#line 803
      goto case_118;
    }
#line 806
    if (opt == 99) {
#line 806
      goto case_99;
    }
#line 812
    if (opt == 110) {
#line 812
      goto case_110;
    }
#line 815
    if (opt == 104) {
#line 815
      goto case_104;
    }
#line 817
    if (opt == 86) {
#line 817
      goto case_86;
    }
#line 819
    if (opt == 120) {
#line 819
      goto case_120;
    }
#line 823
    if (opt == 105) {
#line 823
      goto case_105;
    }
#line 827
    if (opt == 63) {
#line 827
      goto case_63;
    }
#line 829
    goto switch_default;
    case_112: /* CIL Label */ 
#line 786
    opts.respect_mode = 0U;
#line 787
    goto switch_break;
    case_111: /* CIL Label */ 
#line 789
    opts.respect_owner = 0U;
#line 790
    goto switch_break;
    case_116: /* CIL Label */ 
#line 792
    opts.respect_time = 0U;
#line 793
    goto switch_break;
    case_109: /* CIL Label */ 
#line 795
    opts.maximise = 1U;
#line 796
    goto switch_break;
    case_77: /* CIL Label */ 
#line 798
    opts.minimise = 1U;
#line 799
    goto switch_break;
    case_102: /* CIL Label */ 
#line 801
    opts.respect_name = 1U;
#line 802
    goto switch_break;
    case_118: /* CIL Label */ 
#line 804
    (opts.verbosity) ++;
#line 805
    goto switch_break;
    case_99: /* CIL Label */ 
#line 807
    opts.respect_mode = 0U;
#line 808
    opts.respect_name = 0U;
#line 809
    opts.respect_owner = 0U;
#line 810
    opts.respect_time = 0U;
#line 811
    goto switch_break;
    case_110: /* CIL Label */ 
#line 813
    opts.dry_run = 1U;
#line 814
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 816
    tmp = help((char const   *)*(argv + 0));
    }
#line 816
    return (tmp);
    case_86: /* CIL Label */ 
    {
#line 818
    tmp___0 = version();
    }
#line 818
    return (tmp___0);
    case_120: /* CIL Label */ 
    {
#line 820
    tmp___1 = register_regex(& opts.exclude, (char const   *)optarg);
    }
#line 820
    if (tmp___1 != 0) {
#line 821
      return (1);
    }
#line 822
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 824
    tmp___2 = register_regex(& opts.include, (char const   *)optarg);
    }
#line 824
    if (tmp___2 != 0) {
#line 825
      return (1);
    }
#line 826
    goto switch_break;
    case_63: /* CIL Label */ 
#line 828
    return (1);
    switch_default: /* CIL Label */ 
    {
#line 830
    jlog((enum log_level )-1, "Unexpected invalid option: -%c\n", opt);
    }
#line 831
    return (1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 834
  return (0);
}
}
#line 840 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static void to_be_called_atexit(void) 
{ 
  struct regex_link *next ;
  struct regex_link *next___0 ;

  {
#line 842
  if (stats.started) {
    {
#line 843
    print_stats();
    }
  }
  {
#line 846
  tdestroy(files, & file_free_chain);
  }
  {
#line 849
  while (1) {
    while_continue: /* CIL Label */ ;
#line 849
    if (! opts.include) {
#line 849
      goto while_break;
    }
    {
#line 850
    next = (opts.include)->next;
#line 851
    regfree(& (opts.include)->preg);
#line 852
    free((void *)opts.include);
#line 853
    opts.include = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 855
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 855
    if (! opts.exclude) {
#line 855
      goto while_break___0;
    }
    {
#line 856
    next___0 = (opts.exclude)->next;
#line 857
    regfree(& (opts.exclude)->preg);
#line 858
    free((void *)opts.exclude);
#line 859
    opts.exclude = next___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 861
  return;
}
}
#line 867 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
static void sighandler(int i ) 
{ 


  {
#line 869
  if (last_signal != 2) {
#line 870
    last_signal = i;
  }
#line 871
  if (i == 2) {
    {
#line 872
    putchar('\n');
    }
  }
#line 873
  return;
}
}
#line 875 "/home/june/repo/benchmarks/collector/temp/hardlink-0.2.0/hardlink.c"
int main(int argc , char **argv ) 
{ 
  struct sigaction sa ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 879
  sa.__sigaction_handler.sa_handler = & sighandler;
#line 880
  sa.sa_flags = 268435456;
#line 881
  sigfillset(& sa.sa_mask);
#line 884
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 885
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 886
  sigaction(10, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 887
  sigaction(12, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 890
  setlocale(1, "");
#line 891
  stats.start_time = gettime();
#line 893
  tmp = atexit(& to_be_called_atexit);
  }
#line 893
  if (tmp != 0) {
    {
#line 894
    jlog((enum log_level )-4, "Cannot register exit handler");
    }
#line 895
    return (1);
  }
  {
#line 898
  tmp___0 = parse_options(argc, argv);
  }
#line 898
  if (tmp___0 != 0) {
#line 899
    return (1);
  }
#line 901
  if (optind == argc) {
    {
#line 902
    jlog((enum log_level )-3, "Expected file or directory names");
    }
#line 903
    return (1);
  }
#line 906
  stats.started = (hl_bool )1;
  {
#line 908
  while (1) {
    while_continue: /* CIL Label */ ;
#line 908
    if (! (optind < argc)) {
#line 908
      goto while_break;
    }
    {
#line 909
    tmp___1 = nftw((char const   *)*(argv + optind), & inserter, 20, 1);
    }
#line 909
    if (tmp___1 == -1) {
      {
#line 910
      jlog((enum log_level )-2, "Cannot process %s", *(argv + optind));
      }
    }
#line 908
    optind ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 912
  twalk((void const   *)files, (void (*)(void const   *__nodep , VISIT __value , int __level ))(& visitor));
  }
#line 914
  return (0);
}
}
