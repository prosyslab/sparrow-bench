/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 73 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
enum __anonenum_cgiFormResultType_6 {
    cgiFormSuccess = 0,
    cgiFormTruncated = 1,
    cgiFormBadType = 2,
    cgiFormEmpty = 3,
    cgiFormNotFound = 4,
    cgiFormConstrained = 5,
    cgiFormNoSuchChoice = 6,
    cgiFormMemory = 7,
    cgiFormNoFileName = 8,
    cgiFormNoContentType = 9,
    cgiFormNotAFile = 10,
    cgiFormOpenFailed = 11,
    cgiFormIO = 12,
    cgiFormEOF = 13
} ;
#line 73 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
typedef enum __anonenum_cgiFormResultType_6 cgiFormResultType;
#line 159
struct cgiFileStruct;
#line 159 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
typedef struct cgiFileStruct *cgiFilePtr;
#line 190
enum __anonenum_cgiEnvironmentResultType_7 {
    cgiEnvironmentIO = 0,
    cgiEnvironmentMemory = 1,
    cgiEnvironmentSuccess = 2,
    cgiEnvironmentWrongVersion = 3
} ;
#line 190 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
typedef enum __anonenum_cgiEnvironmentResultType_7 cgiEnvironmentResultType;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 78 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
enum __anonenum_cgiParseResultType_31 {
    cgiParseSuccess = 0,
    cgiParseMemory = 1,
    cgiParseIO = 2
} ;
#line 78 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
typedef enum __anonenum_cgiParseResultType_31 cgiParseResultType;
#line 92 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
struct cgiFormEntryStruct {
   char *attr ;
   char *value ;
   int valueLength ;
   char *fileName ;
   char *contentType ;
   char *tfileName ;
   struct cgiFormEntryStruct *next ;
};
#line 92 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
typedef struct cgiFormEntryStruct cgiFormEntry;
#line 323 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
struct __anonstruct_mpStream_32 {
   char putback[1024] ;
   int readPos ;
   int writePos ;
   int offset ;
};
#line 323 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
typedef struct __anonstruct_mpStream_32 mpStream;
#line 323 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
typedef struct __anonstruct_mpStream_32 *mpStreamPtr;
#line 969
enum __anonenum_cgiEscapeState_33 {
    cgiEscapeRest = 0,
    cgiEscapeFirst = 1,
    cgiEscapeSecond = 2
} ;
#line 969 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
typedef enum __anonenum_cgiEscapeState_33 cgiEscapeState;
#line 975
enum __anonenum_cgiUnescapeResultType_34 {
    cgiUnescapeSuccess = 0,
    cgiUnescapeMemory = 1
} ;
#line 975 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
typedef enum __anonenum_cgiUnescapeResultType_34 cgiUnescapeResultType;
#line 1292 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
struct cgiFileStruct {
   FILE *in ;
};
#line 1292 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
typedef struct cgiFileStruct cgiFile;
#line 356 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
char *cgiServerName ;
#line 30
char *cgiScriptName ;
#line 63
FILE *cgiOut ;
#line 93
cgiFormResultType cgiFormString(char *name , char *result , int max ) ;
#line 96
cgiFormResultType cgiFormStringNoNewlines(char *name , char *result , int max ) ;
#line 104
cgiFormResultType cgiFormStringMultiple(char *name , char ***result ) ;
#line 107
void cgiStringArrayFree(char **stringArray ) ;
#line 109
cgiFormResultType cgiFormInteger(char *name , int *result , int defaultV ) ;
#line 118
cgiFormResultType cgiFormDoubleBounded(char *name , double *result , double min ,
                                       double max , double defaultV ) ;
#line 121
cgiFormResultType cgiFormSelectSingle(char *name , char **choicesText , int choicesTotal ,
                                      int *result , int defaultV ) ;
#line 126
cgiFormResultType cgiFormSelectMultiple(char *name , char **choicesText , int choicesTotal ,
                                        int *result , int *invalid ) ;
#line 133
cgiFormResultType cgiFormCheckboxSingle(char *name ) ;
#line 136
extern cgiFormResultType cgiFormCheckboxMultiple(char *name , char **valuesText ,
                                                 int valuesTotal , int *result , int *invalid ) ;
#line 140
cgiFormResultType cgiFormRadio(char *name , char **valuesText , int valuesTotal ,
                               int *result , int defaultV ) ;
#line 147
cgiFormResultType cgiFormFileName(char *name , char *result , int resultSpace ) ;
#line 153
cgiFormResultType cgiFormFileContentType(char *name , char *result , int resultSpace ) ;
#line 156
cgiFormResultType cgiFormFileSize(char *name , int *sizeP ) ;
#line 161
cgiFormResultType cgiFormFileOpen(char *name , cgiFilePtr *cfpp ) ;
#line 164
cgiFormResultType cgiFormFileRead(cgiFilePtr cfp , char *buffer , int bufferSize ,
                                  int *gotP ) ;
#line 167
cgiFormResultType cgiFormFileClose(cgiFilePtr cfp ) ;
#line 170
cgiFormResultType cgiCookieString(char *name , char *value , int space ) ;
#line 176
cgiFormResultType cgiCookies(char ***result ) ;
#line 182
void cgiHeaderCookieSetString(char *name , char *value , int secondsToLive , char *path ,
                              char *domain ) ;
#line 188
void cgiHeaderContentType(char *mimeType ) ;
#line 197
cgiEnvironmentResultType cgiWriteEnvironment(char *filename ) ;
#line 198
cgiEnvironmentResultType cgiReadEnvironment(char *filename ) ;
#line 200
int cgiMain(void) ;
#line 202
cgiFormResultType cgiFormEntries(char ***result ) ;
#line 208
cgiFormResultType cgiHtmlEscape(char *s ) ;
#line 214
cgiFormResultType cgiHtmlEscapeData(char *data , int len ) ;
#line 221
cgiFormResultType cgiValueEscape(char *s ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgictest.c"
void HandleSubmit(void) ;
#line 28
void ShowForm(void) ;
#line 29
void CookieSet(void) ;
#line 30
void Name(void) ;
#line 31
void Address(void) ;
#line 32
void Hungry(void) ;
#line 33
void Temperature(void) ;
#line 34
void Frogs(void) ;
#line 35
void Color(void) ;
#line 36
void Flavors(void) ;
#line 37
void NonExButtons(void) ;
#line 38
void RadioButtons(void) ;
#line 39
void File(void) ;
#line 40
void Entries(void) ;
#line 41
void Cookies(void) ;
#line 42
void LoadEnvironment(void) ;
#line 43
void SaveEnvironment(void) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgictest.c"
int cgiMain(void) 
{ 
  cgiFormResultType tmp ;
  cgiFormResultType tmp___0 ;
  cgiFormResultType tmp___1 ;

  {
  {
#line 51
  tmp = cgiFormCheckboxSingle((char *)"loadenvironment");
  }
#line 51
  if ((unsigned int )tmp == 0U) {
    {
#line 52
    LoadEnvironment();
    }
  }
  {
#line 56
  CookieSet();
#line 58
  cgiHeaderContentType((char *)"text/html");
#line 60
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<HTML><HEAD>\n");
#line 61
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<TITLE>cgic test</TITLE></HEAD>\n");
#line 62
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<BODY><H1>cgic test</H1>\n");
#line 65
  tmp___0 = cgiFormCheckboxSingle((char *)"testcgic");
  }
#line 65
  if ((unsigned int )tmp___0 == 0U) {
    {
#line 68
    HandleSubmit();
#line 69
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<hr>\n");
    }
  } else {
    {
#line 65
    tmp___1 = cgiFormCheckboxSingle((char *)"saveenvironment");
    }
#line 65
    if ((unsigned int )tmp___1 == 0U) {
      {
#line 68
      HandleSubmit();
#line 69
      fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<hr>\n");
      }
    }
  }
  {
#line 72
  ShowForm();
#line 74
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"</BODY></HTML>\n");
  }
#line 75
  return (0);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgictest.c"
void HandleSubmit(void) 
{ 
  cgiFormResultType tmp ;

  {
  {
#line 80
  Name();
#line 81
  Address();
#line 82
  Hungry();
#line 83
  Temperature();
#line 84
  Frogs();
#line 85
  Color();
#line 86
  Flavors();
#line 87
  NonExButtons();
#line 88
  RadioButtons();
#line 89
  File();
#line 90
  Entries();
#line 91
  Cookies();
#line 95
  tmp = cgiFormCheckboxSingle((char *)"saveenvironment");
  }
#line 95
  if ((unsigned int )tmp == 0U) {
    {
#line 96
    SaveEnvironment();
    }
  }
#line 98
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgictest.c"
void Name(void) 
{ 
  char name[81] ;

  {
  {
#line 102
  cgiFormStringNoNewlines((char *)"name", name, 81);
#line 103
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Name: ");
#line 104
  cgiHtmlEscape(name);
#line 105
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<BR>\n");
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgictest.c"
void Address(void) 
{ 
  char address[241] ;

  {
  {
#line 110
  cgiFormString((char *)"address", address, 241);
#line 111
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Address: <PRE>\n");
#line 112
  cgiHtmlEscape(address);
#line 113
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"</PRE>\n");
  }
#line 114
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgictest.c"
void Hungry(void) 
{ 
  cgiFormResultType tmp ;

  {
  {
#line 117
  tmp = cgiFormCheckboxSingle((char *)"hungry");
  }
#line 117
  if ((unsigned int )tmp == 0U) {
    {
#line 118
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"I\'m Hungry!<BR>\n");
    }
  } else {
    {
#line 120
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"I\'m Not Hungry!<BR>\n");
    }
  }
#line 122
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgictest.c"
void Temperature(void) 
{ 
  double temperature ;

  {
  {
#line 126
  cgiFormDoubleBounded((char *)"temperature", & temperature, 80.0, 120.0, 98.6);
#line 127
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"My temperature is %f.<BR>\n",
          temperature);
  }
#line 128
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgictest.c"
void Frogs(void) 
{ 
  int frogsEaten ;

  {
  {
#line 132
  cgiFormInteger((char *)"frogs", & frogsEaten, 0);
#line 133
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"I have eaten %d frogs.<BR>\n",
          frogsEaten);
  }
#line 134
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgictest.c"
char *colors[3]  = {      (char *)"Red",      (char *)"Green",      (char *)"Blue"};
#line 142 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgictest.c"
void Color(void) 
{ 
  int colorChoice ;

  {
  {
#line 144
  cgiFormSelectSingle((char *)"colors", colors, 3, & colorChoice, 0);
#line 145
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"I am: %s<BR>\n",
          colors[colorChoice]);
  }
#line 146
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgictest.c"
char *flavors[3]  = {      (char *)"pistachio",      (char *)"walnut",      (char *)"creme"};
#line 154 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgictest.c"
void Flavors(void) 
{ 
  int flavorChoices[3] ;
  int i ;
  int result ;
  int invalid ;
  cgiFormResultType tmp ;

  {
  {
#line 159
  tmp = cgiFormSelectMultiple((char *)"flavors", flavors, 3, flavorChoices, & invalid);
#line 159
  result = (int )tmp;
  }
#line 161
  if (result == 4) {
    {
#line 162
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"I hate ice cream.<p>\n");
    }
  } else {
    {
#line 164
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"My favorite ice cream flavors are:\n");
#line 165
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<ul>\n");
#line 166
    i = 0;
    }
    {
#line 166
    while (1) {
      while_continue: /* CIL Label */ ;
#line 166
      if (! (i < 3)) {
#line 166
        goto while_break;
      }
#line 167
      if (flavorChoices[i]) {
        {
#line 168
        fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<li>%s\n",
                flavors[i]);
        }
      }
#line 166
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 171
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"</ul>\n");
    }
  }
#line 173
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgictest.c"
char *ages[4]  = {      (char *)"1",      (char *)"2",      (char *)"3",      (char *)"4"};
#line 182 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgictest.c"
void RadioButtons(void) 
{ 
  int ageChoice ;
  char ageText[10] ;

  {
  {
#line 188
  cgiFormRadio((char *)"age", ages, 4, & ageChoice, 0);
#line 190
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Age of Truck: %s (method #1)<BR>\n",
          ages[ageChoice]);
#line 199
  cgiFormString((char *)"age", ageText, 10);
#line 201
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Age of Truck: %s (method #2)<BR>\n",
          ageText);
  }
#line 202
  return;
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgictest.c"
char *votes[4]  = {      (char *)"A",      (char *)"B",      (char *)"C",      (char *)"D"};
#line 211 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgictest.c"
void NonExButtons(void) 
{ 
  int voteChoices[4] ;
  int i ;
  int result ;
  int invalid ;
  char **responses ;
  cgiFormResultType tmp ;
  cgiFormResultType tmp___0 ;
  int i___0 ;

  {
  {
#line 222
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Votes (method 1):<BR>\n");
#line 223
  tmp = cgiFormCheckboxMultiple((char *)"vote", votes, 4, voteChoices, & invalid);
#line 223
  result = (int )tmp;
  }
#line 225
  if (result == 4) {
    {
#line 226
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"I hate them all!<p>\n");
    }
  } else {
    {
#line 228
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"My preferred candidates are:\n");
#line 229
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<ul>\n");
#line 230
    i = 0;
    }
    {
#line 230
    while (1) {
      while_continue: /* CIL Label */ ;
#line 230
      if (! (i < 4)) {
#line 230
        goto while_break;
      }
#line 231
      if (voteChoices[i]) {
        {
#line 232
        fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<li>%s\n",
                votes[i]);
        }
      }
#line 230
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 235
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"</ul>\n");
    }
  }
  {
#line 242
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Votes (method 2):<BR>\n");
#line 243
  tmp___0 = cgiFormStringMultiple((char *)"vote", & responses);
#line 243
  result = (int )tmp___0;
  }
#line 244
  if (result == 4) {
    {
#line 245
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"I hate them all!<p>\n");
    }
  } else {
    {
#line 247
    i___0 = 0;
#line 248
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"My preferred candidates are:\n");
#line 249
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<ul>\n");
    }
    {
#line 250
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 250
      if (! *(responses + i___0)) {
#line 250
        goto while_break___0;
      }
      {
#line 251
      fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<li>%s\n",
              *(responses + i___0));
#line 252
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 254
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"</ul>\n");
    }
  }
  {
#line 260
  cgiStringArrayFree(responses);
  }
#line 261
  return;
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgictest.c"
void Entries(void) 
{ 
  char **array ;
  char **arrayStep ;
  cgiFormResultType tmp ;

  {
  {
#line 266
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"List of All Submitted Form Field Names:<p>\n");
#line 267
  tmp = cgiFormEntries(& array);
  }
#line 267
  if ((unsigned int )tmp != 0U) {
#line 268
    return;
  }
  {
#line 270
  arrayStep = array;
#line 271
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<ul>\n");
  }
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! *arrayStep) {
#line 272
      goto while_break;
    }
    {
#line 273
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<li>");
#line 274
    cgiHtmlEscape(*arrayStep);
#line 275
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"\n");
#line 276
    arrayStep ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 278
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"</ul>\n");
#line 279
  cgiStringArrayFree(array);
  }
#line 280
  return;
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgictest.c"
void Cookies(void) 
{ 
  char **array ;
  char **arrayStep ;
  char cname[1024] ;
  char cvalue[1024] ;
  cgiFormResultType tmp ;
  char value[1024] ;
  size_t tmp___0 ;

  {
  {
#line 286
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Cookies Submitted On This Call, With Values (Many Browsers NEVER Submit Cookies):<p>\n");
#line 287
  tmp = cgiCookies(& array);
  }
#line 287
  if ((unsigned int )tmp != 0U) {
#line 288
    return;
  }
  {
#line 290
  arrayStep = array;
#line 291
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<table border=1>\n");
#line 292
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<tr><th>Cookie<th>Value</tr>\n");
  }
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    if (! *arrayStep) {
#line 293
      goto while_break;
    }
    {
#line 295
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<tr>");
#line 296
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<td>");
#line 297
    cgiHtmlEscape(*arrayStep);
#line 298
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<td>");
#line 299
    cgiCookieString(*arrayStep, value, (int )sizeof(value));
#line 300
    cgiHtmlEscape(value);
#line 301
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"\n");
#line 302
    arrayStep ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 304
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"</table>\n");
#line 305
  cgiFormString((char *)"cname", cname, (int )sizeof(cname));
#line 306
  cgiFormString((char *)"cvalue", cvalue, (int )sizeof(cvalue));
#line 307
  tmp___0 = strlen((char const   *)(cname));
  }
#line 307
  if (tmp___0) {
    {
#line 308
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"New Cookie Set On This Call:<p>\n");
#line 309
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Name: ");
#line 310
    cgiHtmlEscape(cname);
#line 311
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Value: ");
#line 312
    cgiHtmlEscape(cvalue);
#line 313
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<p>\n");
#line 314
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"If your browser accepts cookies (many do not), this new cookie should appear in the above list the next time the form is submitted.<p>\n");
    }
  }
  {
#line 316
  cgiStringArrayFree(array);
  }
#line 317
  return;
}
}
#line 319 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgictest.c"
void File(void) 
{ 
  cgiFilePtr file ;
  char name[1024] ;
  char contentType[1024] ;
  char buffer[1024] ;
  int size ;
  int got ;
  cgiFormResultType tmp ;
  cgiFormResultType tmp___0 ;
  cgiFormResultType tmp___1 ;

  {
  {
#line 327
  tmp = cgiFormFileName((char *)"file", name, (int )sizeof(name));
  }
#line 327
  if ((unsigned int )tmp != 0U) {
    {
#line 328
    printf((char const   */* __restrict  */)"<p>No file was uploaded.<p>\n");
    }
#line 329
    return;
  }
  {
#line 331
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"The filename submitted was: ");
#line 332
  cgiHtmlEscape(name);
#line 333
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<p>\n");
#line 334
  cgiFormFileSize((char *)"file", & size);
#line 335
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"The file size was: %d bytes<p>\n",
          size);
#line 336
  cgiFormFileContentType((char *)"file", contentType, (int )sizeof(contentType));
#line 337
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"The alleged content type of the file was: ");
#line 338
  cgiHtmlEscape(contentType);
#line 339
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<p>\n");
#line 340
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Of course, this is only the claim the browser made when uploading the file. Much like the filename, it cannot be trusted.<p>\n");
#line 341
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"The file\'s contents are shown here:<p>\n");
#line 342
  tmp___0 = cgiFormFileOpen((char *)"file", & file);
  }
#line 342
  if ((unsigned int )tmp___0 != 0U) {
    {
#line 343
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Could not open the file.<p>\n");
    }
#line 344
    return;
  }
  {
#line 346
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<pre>\n");
  }
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 347
    tmp___1 = cgiFormFileRead(file, buffer, (int )sizeof(buffer), & got);
    }
#line 347
    if (! ((unsigned int )tmp___1 == 0U)) {
#line 347
      goto while_break;
    }
    {
#line 350
    cgiHtmlEscapeData(buffer, got);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 352
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"</pre>\n");
#line 353
  cgiFormFileClose(file);
  }
#line 354
  return;
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgictest.c"
void ShowForm(void) 
{ 


  {
  {
#line 358
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<!-- 2.0: multipart/form-data is required for file uploads. -->");
#line 359
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<form method=\"POST\" enctype=\"multipart/form-data\" ");
#line 360
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"\taction=\"");
#line 361
  cgiValueEscape(cgiScriptName);
#line 362
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"\">\n");
#line 363
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<p>\n");
#line 364
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Text Field containing Plaintext\n");
#line 365
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<p>\n");
#line 366
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<input type=\"text\" name=\"name\">Your Name\n");
#line 367
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<p>\n");
#line 368
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Multiple-Line Text Field\n");
#line 369
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<p>\n");
#line 370
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<textarea NAME=\"address\" ROWS=4 COLS=40>\n");
#line 371
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Default contents go here. \n");
#line 372
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"</textarea>\n");
#line 373
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<p>\n");
#line 374
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Checkbox\n");
#line 375
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<p>\n");
#line 376
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<input type=\"checkbox\" name=\"hungry\" checked>Hungry\n");
#line 377
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<p>\n");
#line 378
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Text Field containing a Numeric Value\n");
#line 379
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<p>\n");
#line 380
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<input type=\"text\" name=\"temperature\" value=\"98.6\">\n");
#line 381
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Blood Temperature (80.0-120.0)\n");
#line 382
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<p>\n");
#line 383
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Text Field containing an Integer Value\n");
#line 384
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<p>\n");
#line 385
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<input type=\"text\" name=\"frogs\" value=\"1\">\n");
#line 386
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Frogs Eaten\n");
#line 387
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<p>\n");
#line 388
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Single-SELECT\n");
#line 389
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<br>\n");
#line 390
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<select name=\"colors\">\n");
#line 391
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<option value=\"Red\">Red\n");
#line 392
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<option value=\"Green\">Green\n");
#line 393
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<option value=\"Blue\">Blue\n");
#line 394
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"</select>\n");
#line 395
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<br>\n");
#line 396
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Multiple-SELECT\n");
#line 397
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<br>\n");
#line 398
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<select name=\"flavors\" multiple>\n");
#line 399
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<option value=\"pistachio\">Pistachio\n");
#line 400
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<option value=\"walnut\">Walnut\n");
#line 401
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<option value=\"creme\">Creme\n");
#line 402
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"</select>\n");
#line 403
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<p>Exclusive Radio Button Group: Age of Truck in Years\n");
#line 404
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<input type=\"radio\" name=\"age\" value=\"1\">1\n");
#line 405
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<input type=\"radio\" name=\"age\" value=\"2\">2\n");
#line 406
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<input type=\"radio\" name=\"age\" value=\"3\" checked>3\n");
#line 407
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<input type=\"radio\" name=\"age\" value=\"4\">4\n");
#line 408
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<p>Nonexclusive Checkbox Group: Voting for Zero through Four Candidates\n");
#line 409
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<input type=\"checkbox\" name=\"vote\" value=\"A\">A\n");
#line 410
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<input type=\"checkbox\" name=\"vote\" value=\"B\">B\n");
#line 411
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<input type=\"checkbox\" name=\"vote\" value=\"C\">C\n");
#line 412
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<input type=\"checkbox\" name=\"vote\" value=\"D\">D\n");
#line 413
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<p>File Upload:\n");
#line 414
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<input type=\"file\" name=\"file\" value=\"\"> (Select A Local File)\n");
#line 415
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<p>\n");
#line 416
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<p>Set a Cookie<p>\n");
#line 417
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<input name=\"cname\" value=\"\"> Cookie Name\n");
#line 418
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<input name=\"cvalue\" value=\"\"> Cookie Value<p>\n");
#line 419
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<input type=\"submit\" name=\"testcgic\" value=\"Submit Request\">\n");
#line 420
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<input type=\"reset\" value=\"Reset Request\">\n");
#line 421
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<p>Save the CGI Environment<p>\n");
#line 422
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Pressing this button will submit the form, then save the CGI environment so that it can be replayed later by calling cgiReadEnvironment (in a debugger, for instance).<p>\n");
#line 423
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<input type=\"submit\" name=\"saveenvironment\" value=\"Save Environment\">\n");
#line 424
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"</form>\n");
  }
#line 425
  return;
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgictest.c"
void CookieSet(void) 
{ 
  char cname[1024] ;
  char cvalue[1024] ;
  size_t tmp ;

  {
  {
#line 432
  cgiFormString((char *)"cname", cname, (int )sizeof(cname));
#line 433
  cgiFormString((char *)"cvalue", cvalue, (int )sizeof(cvalue));
#line 434
  tmp = strlen((char const   *)(cname));
  }
#line 434
  if (tmp) {
    {
#line 438
    cgiHeaderCookieSetString(cname, cvalue, 86400, cgiScriptName, cgiServerName);
    }
  }
#line 441
  return;
}
}
#line 443 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgictest.c"
void LoadEnvironment(void) 
{ 
  cgiEnvironmentResultType tmp ;

  {
  {
#line 445
  tmp = cgiReadEnvironment((char *)"/tmp/cgicsave.env");
  }
#line 445
  if ((unsigned int )tmp != 2U) {
    {
#line 448
    cgiHeaderContentType((char *)"text/html");
#line 449
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<head>Error</head>\n");
#line 450
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<body><h1>Error</h1>\n");
#line 451
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"cgiReadEnvironment failed. Most likely you have not saved an environment yet.\n");
#line 454
    exit(0);
    }
  }
#line 457
  return;
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgictest.c"
void SaveEnvironment(void) 
{ 
  cgiEnvironmentResultType tmp ;

  {
  {
#line 461
  tmp = cgiWriteEnvironment((char *)"/tmp/cgicsave.env");
  }
#line 461
  if ((unsigned int )tmp != 2U) {
    {
#line 464
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<p>cgiWriteEnvironment failed. Most likely %s is not a valid path or is not writable by the user that the CGI program is running as.<p>\n",
            "/tmp/cgicsave.env");
    }
  } else {
    {
#line 469
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"<p>Environment saved. Click this button to restore it, playing back exactly the same scenario: <form method=POST action=\"");
#line 473
    cgiValueEscape(cgiScriptName);
#line 474
    fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"\"><input type=\"submit\" value=\"Load Environment\" name=\"loadenvironment\"></form><p>\n");
    }
  }
#line 479
  return;
}
}
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 620
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 239
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 284 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
char *cgiServerSoftware  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
char *cgiServerName  ;
#line 24 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
char *cgiGatewayInterface  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
char *cgiServerProtocol  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
char *cgiServerPort  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
char *cgiRequestMethod  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
char *cgiPathInfo  ;
#line 29 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
char *cgiPathTranslated  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
char *cgiScriptName  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
char *cgiQueryString  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
char *cgiRemoteHost  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
char *cgiRemoteAddr  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
char *cgiAuthType  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
char *cgiRemoteUser  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
char *cgiRemoteIdent  ;
#line 37
char *cgiContentType ;
#line 38 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
char *cgiAccept  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
char *cgiUserAgent  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
char *cgiReferrer  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
char *cgiCookie  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
int cgiContentLength  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
FILE *cgiOut  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.h"
FILE *cgiIn  ;
#line 100
cgiFormResultType cgiFormStringSpaceNeeded(char *name , int *result ) ;
#line 112
cgiFormResultType cgiFormIntegerBounded(char *name , int *result , int min , int max ,
                                        int defaultV ) ;
#line 115
cgiFormResultType cgiFormDouble(char *name , double *result , double defaultV ) ;
#line 173
cgiFormResultType cgiCookieInteger(char *name , int *result , int defaultV ) ;
#line 184
void cgiHeaderCookieSetInteger(char *name , int value , int secondsToLive , char *path ,
                               char *domain ) ;
#line 186
void cgiHeaderLocation(char *redirectUrl ) ;
#line 187
void cgiHeaderStatus(int status , char *statusMessage ) ;
#line 229
cgiFormResultType cgiValueEscapeData(char *data , int len ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
char cgiContentTypeData[1024]  ;
#line 62 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
char *cgiContentType  =    cgiContentTypeData;
#line 63 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
char *cgiMultipartBoundary  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static int cgiRestored  =    0;
#line 76
static void cgiGetenv(char **s , char *var ) ;
#line 111 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static cgiFormEntry *cgiFormEntryFirst  ;
#line 113
static cgiParseResultType cgiParseGetFormInput(void) ;
#line 114
static cgiParseResultType cgiParsePostFormInput(void) ;
#line 115
static cgiParseResultType cgiParsePostMultipartInput(void) ;
#line 116
static cgiParseResultType cgiParseFormInput(char *data , int length ) ;
#line 117
static void cgiSetupConstants(void) ;
#line 118
static void cgiFreeResources(void) ;
#line 119
static int cgiStrEqNc(char *s1 , char *s2 ) ;
#line 120
static int cgiStrBeginsNc(char *s1 , char *s2 ) ;
#line 122 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
int main(int argc , char **argv ) 
{ 
  int result ;
  char *cgiContentLengthString ;
  char *e ;
  size_t tmp ;
  char *sat ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *s ;
  size_t tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  cgiParseResultType tmp___6 ;
  cgiParseResultType tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  cgiParseResultType tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 126
  cgiSetupConstants();
#line 127
  cgiGetenv(& cgiServerSoftware, (char *)"SERVER_SOFTWARE");
#line 128
  cgiGetenv(& cgiServerName, (char *)"SERVER_NAME");
#line 129
  cgiGetenv(& cgiGatewayInterface, (char *)"GATEWAY_INTERFACE");
#line 130
  cgiGetenv(& cgiServerProtocol, (char *)"SERVER_PROTOCOL");
#line 131
  cgiGetenv(& cgiServerPort, (char *)"SERVER_PORT");
#line 132
  cgiGetenv(& cgiRequestMethod, (char *)"REQUEST_METHOD");
#line 133
  cgiGetenv(& cgiPathInfo, (char *)"PATH_INFO");
#line 134
  cgiGetenv(& cgiPathTranslated, (char *)"PATH_TRANSLATED");
#line 135
  cgiGetenv(& cgiScriptName, (char *)"SCRIPT_NAME");
#line 136
  cgiGetenv(& cgiQueryString, (char *)"QUERY_STRING");
#line 137
  cgiGetenv(& cgiRemoteHost, (char *)"REMOTE_HOST");
#line 138
  cgiGetenv(& cgiRemoteAddr, (char *)"REMOTE_ADDR");
#line 139
  cgiGetenv(& cgiAuthType, (char *)"AUTH_TYPE");
#line 140
  cgiGetenv(& cgiRemoteUser, (char *)"REMOTE_USER");
#line 141
  cgiGetenv(& cgiRemoteIdent, (char *)"REMOTE_IDENT");
#line 144
  e = getenv("CONTENT_TYPE");
  }
#line 145
  if (e) {
    {
#line 146
    tmp = strlen((char const   *)e);
    }
#line 146
    if (tmp < sizeof(cgiContentTypeData)) {
      {
#line 147
      strcpy((char */* __restrict  */)cgiContentType, (char const   */* __restrict  */)e);
      }
    } else {
      {
#line 151
      strncpy((char */* __restrict  */)cgiContentType, (char const   */* __restrict  */)e,
              sizeof(cgiContentTypeData));
#line 152
      *(cgiContentType + (sizeof(cgiContentTypeData) - 1UL)) = (char )'\000';
      }
    }
  } else {
#line 155
    *(cgiContentType + 0) = (char )'\000';
  }
  {
#line 158
  cgiMultipartBoundary = (char *)"";
#line 163
  tmp___5 = strchr((char const   *)cgiContentType, ';');
  }
#line 163
  if (tmp___5) {
    {
#line 164
    tmp___0 = strchr((char const   *)cgiContentType, ';');
#line 164
    sat = tmp___0;
    }
    {
#line 165
    while (1) {
      while_continue: /* CIL Label */ ;
#line 165
      if (! sat) {
#line 165
        goto while_break;
      }
#line 166
      *sat = (char )'\000';
#line 167
      sat ++;
      {
#line 168
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 168
        tmp___1 = __ctype_b_loc();
        }
#line 168
        if (! ((int const   )*(*tmp___1 + (int )*sat) & 8192)) {
#line 168
          goto while_break___0;
        }
#line 169
        sat ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 171
      tmp___4 = cgiStrBeginsNc(sat, (char *)"boundary=");
      }
#line 171
      if (tmp___4) {
        {
#line 173
        tmp___2 = strlen("boundary=");
#line 173
        cgiMultipartBoundary = sat + tmp___2;
#line 174
        s = cgiMultipartBoundary;
        }
        {
#line 175
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 175
          if (*s) {
            {
#line 175
            tmp___3 = __ctype_b_loc();
            }
#line 175
            if ((int const   )*(*tmp___3 + (int )*s) & 8192) {
#line 175
              goto while_break___1;
            }
          } else {
#line 175
            goto while_break___1;
          }
#line 176
          s ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 178
        *s = (char )'\000';
#line 179
        goto while_break;
      } else {
        {
#line 181
        sat = strchr((char const   *)sat, ';');
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 185
  cgiGetenv(& cgiContentLengthString, (char *)"CONTENT_LENGTH");
#line 186
  cgiContentLength = atoi((char const   *)cgiContentLengthString);
#line 187
  cgiGetenv(& cgiAccept, (char *)"HTTP_ACCEPT");
#line 188
  cgiGetenv(& cgiUserAgent, (char *)"HTTP_USER_AGENT");
#line 189
  cgiGetenv(& cgiReferrer, (char *)"HTTP_REFERER");
#line 190
  cgiGetenv(& cgiCookie, (char *)"HTTP_COOKIE");
#line 204
  cgiFormEntryFirst = (cgiFormEntry *)0;
#line 205
  cgiIn = stdin;
#line 206
  cgiOut = stdout;
#line 207
  cgiRestored = 0;
  }
#line 213
  if (argc) {
#line 214
    if (*(argv + 0)) {
#line 215
      cgiRestored = 0;
    }
  }
  {
#line 220
  tmp___13 = cgiStrEqNc(cgiRequestMethod, (char *)"post");
  }
#line 220
  if (tmp___13) {
    {
#line 226
    tmp___9 = cgiStrEqNc(cgiContentType, (char *)"application/x-www-form-urlencoded");
    }
#line 226
    if (tmp___9) {
      {
#line 232
      tmp___6 = cgiParsePostFormInput();
      }
#line 232
      if ((unsigned int )tmp___6 != 0U) {
        {
#line 238
        cgiFreeResources();
        }
#line 239
        return (-1);
      }
    } else {
      {
#line 246
      tmp___8 = cgiStrEqNc(cgiContentType, (char *)"multipart/form-data");
      }
#line 246
      if (tmp___8) {
        {
#line 252
        tmp___7 = cgiParsePostMultipartInput();
        }
#line 252
        if ((unsigned int )tmp___7 != 0U) {
          {
#line 258
          cgiFreeResources();
          }
#line 259
          return (-1);
        }
      }
    }
  } else {
    {
#line 267
    tmp___12 = cgiStrEqNc(cgiRequestMethod, (char *)"get");
    }
#line 267
    if (tmp___12) {
      {
#line 270
      tmp___10 = strlen((char const   *)cgiQueryString);
#line 270
      cgiContentLength = (int )tmp___10;
#line 271
      tmp___11 = cgiParseGetFormInput();
      }
#line 271
      if ((unsigned int )tmp___11 != 0U) {
        {
#line 277
        cgiFreeResources();
        }
#line 278
        return (-1);
      }
    }
  }
  {
#line 287
  result = cgiMain();
#line 288
  cgiFreeResources();
  }
#line 289
  return (result);
}
}
#line 292 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static void cgiGetenv(char **s , char *var ) 
{ 


  {
  {
#line 293
  *s = getenv((char const   *)var);
  }
#line 294
  if (! *s) {
#line 295
    *s = (char *)"";
  }
#line 297
  return;
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static cgiParseResultType cgiParsePostFormInput(void) 
{ 
  char *input ;
  cgiParseResultType result ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 302
  if (! cgiContentLength) {
#line 303
    return ((cgiParseResultType )0);
  }
  {
#line 305
  tmp = malloc((size_t )cgiContentLength);
#line 305
  input = (char *)tmp;
  }
#line 306
  if (! input) {
#line 307
    return ((cgiParseResultType )1);
  }
  {
#line 309
  tmp___0 = fread((void */* __restrict  */)input, (size_t )1, (size_t )cgiContentLength,
                  (FILE */* __restrict  */)cgiIn);
  }
#line 309
  if ((int )tmp___0 != cgiContentLength) {
#line 312
    return ((cgiParseResultType )2);
  }
  {
#line 314
  result = cgiParseFormInput(input, cgiContentLength);
#line 315
  free((void *)input);
  }
#line 316
  return (result);
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
int mpRead(mpStreamPtr mpp , char *buffer , int len ) 
{ 
  int ilen ;
  int got ;
  char *tmp ;
  int tmp___0 ;
  int fgot ;
  size_t tmp___1 ;

  {
#line 343
  ilen = len;
#line 344
  got = 0;
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;
#line 345
    if (! len) {
#line 345
      goto while_break;
    }
#line 346
    if (mpp->readPos != mpp->writePos) {
#line 347
      tmp = buffer;
#line 347
      buffer ++;
#line 347
      tmp___0 = mpp->readPos;
#line 347
      (mpp->readPos) ++;
#line 347
      *tmp = mpp->putback[tmp___0];
#line 348
      mpp->readPos = (int )((unsigned long )mpp->readPos % sizeof(mpp->putback));
#line 349
      got ++;
#line 350
      len --;
    } else {
#line 352
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  if (len > cgiContentLength - mpp->offset) {
#line 358
    len = cgiContentLength - mpp->offset;
  }
#line 360
  if (len) {
    {
#line 361
    tmp___1 = fread((void */* __restrict  */)buffer, (size_t )1, (size_t )len, (FILE */* __restrict  */)cgiIn);
#line 361
    fgot = (int )tmp___1;
    }
#line 362
    if (fgot >= 0) {
#line 363
      mpp->offset += got + fgot;
#line 364
      return (got + fgot);
    } else
#line 365
    if (got > 0) {
#line 366
      mpp->offset += got;
#line 367
      return (got);
    } else {
#line 370
      return (fgot);
    }
  } else
#line 372
  if (got) {
#line 373
    return (got);
  } else
#line 374
  if (ilen) {
#line 375
    return (-1);
  } else {
#line 378
    return (0);
  }
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
void mpPutBack(mpStreamPtr mpp , char *data , int len ) 
{ 
  int tmp ;
  char *tmp___0 ;

  {
#line 384
  mpp->offset -= len;
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 385
    if (! len) {
#line 385
      goto while_break;
    }
#line 386
    tmp = mpp->writePos;
#line 386
    (mpp->writePos) ++;
#line 386
    tmp___0 = data;
#line 386
    data ++;
#line 386
    mpp->putback[tmp] = *tmp___0;
#line 387
    mpp->writePos = (int )((unsigned long )mpp->writePos % sizeof(mpp->putback));
#line 388
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  return;
}
}
#line 406
static cgiParseResultType afterNextBoundary(mpStreamPtr mpp , FILE *outf , char **outP ,
                                            int *bodyLengthP , int first ) ;
#line 413
static int readHeaderLine(mpStreamPtr mpp , char *attr , int attrSpace , char *value ,
                          int valueSpace ) ;
#line 420
static void decomposeValue(char *value , char *mvalue , int mvalueSpace , char **argNames ,
                           char **argValues , int argValueSpace ) ;
#line 432
static cgiParseResultType getTempFileName(char *tfileName ) ;
#line 434 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static cgiParseResultType cgiParsePostMultipartInput(void) 
{ 
  cgiParseResultType result ;
  cgiFormEntry *n ;
  cgiFormEntry *l ;
  int got ;
  FILE *outf ;
  char *out ;
  char tfileName[1024] ;
  mpStream mp ;
  mpStreamPtr mpp ;
  char d[1024] ;
  char fvalue[1024] ;
  char fname[1024] ;
  int bodyLength ;
  char ffileName[1024] ;
  char fcontentType[1024] ;
  char attr[1024] ;
  char value[1024] ;
  char *argNames[3] ;
  char *argValues[2] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  cgiParseResultType tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;

  {
  {
#line 436
  n = (cgiFormEntry *)0;
#line 436
  l = (cgiFormEntry *)0;
#line 438
  outf = (FILE *)0;
#line 439
  out = (char *)0;
#line 442
  mpp = & mp;
#line 443
  memset((void *)(& mp), 0, sizeof(mp));
  }
#line 444
  if (! cgiContentLength) {
#line 445
    return ((cgiParseResultType )0);
  }
  {
#line 448
  result = afterNextBoundary(mpp, (FILE *)0, (char **)0, (int *)0, 1);
  }
#line 449
  if ((unsigned int )result == 2U) {
#line 451
    return ((cgiParseResultType )0);
  } else
#line 452
  if ((unsigned int )result != 0U) {
#line 453
    return (result);
  }
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 459
    bodyLength = 0;
#line 464
    fvalue[0] = (char)0;
#line 465
    fname[0] = (char)0;
#line 466
    ffileName[0] = (char)0;
#line 467
    fcontentType[0] = (char)0;
#line 468
    out = (char *)0;
#line 469
    outf = (FILE *)0;
#line 471
    got = mpRead(mpp, d, 2);
    }
#line 472
    if (got < 2) {
#line 474
      goto while_break;
    }
#line 476
    if ((int )d[0] == 45) {
#line 476
      if ((int )d[1] == 45) {
#line 478
        goto while_break;
      }
    }
    {
#line 480
    mpPutBack(mpp, d, 2);
    }
    {
#line 482
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 482
      tmp___1 = readHeaderLine(mpp, attr, (int )sizeof(attr), value, (int )sizeof(value));
      }
#line 482
      if (! tmp___1) {
#line 482
        goto while_break___0;
      }
      {
#line 489
      tmp___0 = cgiStrEqNc(attr, (char *)"Content-Disposition");
      }
#line 489
      if (tmp___0) {
        {
#line 490
        argNames[0] = (char *)"name";
#line 491
        argNames[1] = (char *)"filename";
#line 492
        argNames[2] = (char *)0;
#line 493
        argValues[0] = fname;
#line 494
        argValues[1] = ffileName;
#line 495
        decomposeValue(value, fvalue, (int )sizeof(fvalue), argNames, argValues, 1024);
        }
      } else {
        {
#line 500
        tmp = cgiStrEqNc(attr, (char *)"Content-Type");
        }
#line 500
        if (tmp) {
          {
#line 501
          argNames[0] = (char *)0;
#line 502
          decomposeValue(value, fcontentType, (int )sizeof(fcontentType), argNames,
                         (char **)0, 0);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 509
    tmp___2 = cgiStrEqNc(fvalue, (char *)"form-data");
    }
#line 509
    if (! tmp___2) {
#line 511
      goto while_continue;
    }
    {
#line 519
    tmp___4 = strlen((char const   *)(ffileName));
    }
#line 519
    if (tmp___4) {
      {
#line 520
      tmp___3 = getTempFileName(tfileName);
      }
#line 520
      if ((unsigned int )tmp___3 != 0U) {
#line 521
        return ((cgiParseResultType )2);
      }
      {
#line 523
      outf = fopen((char const   */* __restrict  */)(tfileName), (char const   */* __restrict  */)"w+b");
      }
    } else {
#line 525
      outf = (FILE *)0;
#line 526
      tfileName[0] = (char )'\000';
    }
    {
#line 528
    result = afterNextBoundary(mpp, outf, & out, & bodyLength, 0);
    }
#line 529
    if ((unsigned int )result != 0U) {
#line 531
      if (outf) {
        {
#line 532
        fclose(outf);
#line 533
        unlink((char const   *)(tfileName));
        }
      }
#line 535
      if (out) {
        {
#line 536
        free((void *)out);
        }
      }
#line 538
      return (result);
    }
    {
#line 541
    tmp___5 = malloc(sizeof(cgiFormEntry ));
#line 541
    n = (cgiFormEntry *)tmp___5;
    }
#line 542
    if (! n) {
#line 543
      goto outOfMemory;
    }
    {
#line 545
    memset((void *)n, 0, sizeof(cgiFormEntry ));
#line 548
    tmp___6 = strlen((char const   *)(fname));
#line 548
    tmp___7 = malloc(tmp___6 + 1UL);
#line 548
    n->attr = (char *)tmp___7;
    }
#line 549
    if (! n->attr) {
#line 550
      goto outOfMemory;
    }
    {
#line 552
    strcpy((char */* __restrict  */)n->attr, (char const   */* __restrict  */)(fname));
    }
#line 553
    if (out) {
#line 554
      n->value = out;
#line 555
      out = (char *)0;
    } else
#line 556
    if (outf) {
      {
#line 557
      tmp___8 = malloc((size_t )1);
#line 557
      n->value = (char *)tmp___8;
      }
#line 558
      if (! n->value) {
#line 559
        goto outOfMemory;
      }
      {
#line 561
      *(n->value + 0) = (char )'\000';
#line 562
      fclose(outf);
      }
    }
#line 564
    n->valueLength = bodyLength;
#line 565
    n->next = (struct cgiFormEntryStruct *)0;
#line 566
    if (! l) {
#line 567
      cgiFormEntryFirst = n;
    } else {
#line 569
      l->next = n;
    }
    {
#line 571
    tmp___9 = strlen((char const   *)(ffileName));
#line 571
    tmp___10 = malloc(tmp___9 + 1UL);
#line 571
    n->fileName = (char *)tmp___10;
    }
#line 572
    if (! n->fileName) {
#line 573
      goto outOfMemory;
    }
    {
#line 575
    strcpy((char */* __restrict  */)n->fileName, (char const   */* __restrict  */)(ffileName));
#line 576
    tmp___11 = strlen((char const   *)(fcontentType));
#line 576
    tmp___12 = malloc(tmp___11 + 1UL);
#line 576
    n->contentType = (char *)tmp___12;
    }
#line 577
    if (! n->contentType) {
#line 578
      goto outOfMemory;
    }
    {
#line 580
    strcpy((char */* __restrict  */)n->contentType, (char const   */* __restrict  */)(fcontentType));
#line 581
    tmp___13 = strlen((char const   *)(tfileName));
#line 581
    tmp___14 = malloc(tmp___13 + 1UL);
#line 581
    n->tfileName = (char *)tmp___14;
    }
#line 582
    if (! n->tfileName) {
#line 583
      goto outOfMemory;
    }
    {
#line 585
    strcpy((char */* __restrict  */)n->tfileName, (char const   */* __restrict  */)(tfileName));
#line 587
    l = n;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 589
  return ((cgiParseResultType )0);
  outOfMemory: 
#line 591
  if (n) {
#line 592
    if (n->attr) {
      {
#line 593
      free((void *)n->attr);
      }
    }
#line 595
    if (n->value) {
      {
#line 596
      free((void *)n->value);
      }
    }
#line 598
    if (n->fileName) {
      {
#line 599
      free((void *)n->fileName);
      }
    }
#line 601
    if (n->tfileName) {
      {
#line 602
      free((void *)n->tfileName);
      }
    }
#line 604
    if (n->contentType) {
      {
#line 605
      free((void *)n->contentType);
      }
    }
    {
#line 607
    free((void *)n);
    }
  }
#line 609
  if (out) {
    {
#line 610
    free((void *)out);
    }
  }
#line 612
  if (outf) {
    {
#line 613
    fclose(outf);
#line 614
    unlink((char const   *)(tfileName));
    }
  }
#line 616
  return ((cgiParseResultType )1);
}
}
#line 619 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static cgiParseResultType getTempFileName(char *tfileName ) 
{ 
  int outfd ;
  int tmp ;

  {
  {
#line 631
  strcpy((char */* __restrict  */)tfileName, (char const   */* __restrict  */)"/tmp/cgicXXXXXX");
#line 632
  outfd = mkstemp(tfileName);
  }
#line 633
  if (outfd == -1) {
#line 634
    return ((cgiParseResultType )2);
  }
  {
#line 636
  close(outfd);
#line 638
  tmp = chmod((char const   *)tfileName, (__mode_t )384);
  }
#line 638
  if (tmp != 0) {
    {
#line 639
    unlink((char const   *)tfileName);
    }
#line 640
    return ((cgiParseResultType )2);
  }
#line 648
  return ((cgiParseResultType )0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static cgiParseResultType afterNextBoundary(mpStreamPtr mpp , FILE *outf , char **outP ,
                                            int *bodyLengthP , int first ) 
{ 
  int outLen ;
  int outSpace ;
  char *out ;
  cgiParseResultType result ;
  int boffset ;
  int got ;
  char d[2] ;
  char workingBoundaryData[1024] ;
  char *workingBoundary ;
  int workingBoundaryLength ;
  void *tmp ;
  size_t tmp___0 ;
  char *sold ;
  void *tmp___1 ;
  int tmp___2 ;
  char *sold___0 ;
  void *tmp___3 ;
  int tmp___4 ;
  char *oout ;
  void *tmp___5 ;

  {
#line 686
  outLen = 0;
#line 687
  outSpace = 256;
#line 688
  out = (char *)0;
#line 698
  workingBoundary = workingBoundaryData;
#line 700
  if (! outf) {
#line 700
    if (outP) {
      {
#line 701
      tmp = malloc((size_t )outSpace);
#line 701
      out = (char *)tmp;
      }
#line 702
      if (! out) {
#line 703
        goto outOfMemory;
      }
    }
  }
  {
#line 706
  boffset = 0;
#line 707
  sprintf((char */* __restrict  */)(workingBoundaryData), (char const   */* __restrict  */)"\r\n--%s",
          cgiMultipartBoundary);
  }
#line 708
  if (first) {
#line 709
    workingBoundary = workingBoundaryData + 2;
  }
  {
#line 711
  tmp___0 = strlen((char const   *)workingBoundary);
#line 711
  workingBoundaryLength = (int )tmp___0;
  }
  {
#line 712
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 713
    got = mpRead(mpp, d, 1);
    }
#line 714
    if (got != 1) {
#line 716
      result = (cgiParseResultType )2;
#line 717
      goto error;
    }
#line 719
    if ((int )d[0] == (int )*(workingBoundary + boffset)) {
#line 723
      boffset ++;
#line 724
      if (boffset == workingBoundaryLength) {
#line 725
        goto while_break;
      }
    } else
#line 727
    if (boffset > 0) {
#line 735
      if (outf) {
        {
#line 735
        _IO_putc((int )*(workingBoundary + 0), outf);
#line 735
        outLen ++;
        }
      } else
#line 735
      if (out) {
#line 735
        if (outLen + 1 == outSpace) {
          {
#line 735
          sold = out;
#line 735
          outSpace *= 2;
#line 735
          tmp___1 = realloc((void *)out, (size_t )outSpace);
#line 735
          out = (char *)tmp___1;
          }
#line 735
          if (! out) {
#line 735
            out = sold;
#line 735
            goto outOfMemory;
          }
        }
#line 735
        tmp___2 = outLen;
#line 735
        outLen ++;
#line 735
        *(out + tmp___2) = *(workingBoundary + 0);
      }
      {
#line 736
      mpPutBack(mpp, workingBoundary + 1, boffset - 1);
#line 738
      mpPutBack(mpp, d, 1);
#line 739
      boffset = 0;
      }
    } else
#line 743
    if (outf) {
      {
#line 743
      _IO_putc((int )d[0], outf);
#line 743
      outLen ++;
      }
    } else
#line 743
    if (out) {
#line 743
      if (outLen + 1 == outSpace) {
        {
#line 743
        sold___0 = out;
#line 743
        outSpace *= 2;
#line 743
        tmp___3 = realloc((void *)out, (size_t )outSpace);
#line 743
        out = (char *)tmp___3;
        }
#line 743
        if (! out) {
#line 743
          out = sold___0;
#line 743
          goto outOfMemory;
        }
      }
#line 743
      tmp___4 = outLen;
#line 743
      outLen ++;
#line 743
      *(out + tmp___4) = d[0];
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 748
  got = mpRead(mpp, d, 2);
  }
#line 749
  if (got != 2) {
#line 750
    result = (cgiParseResultType )2;
#line 751
    goto error;
  }
#line 753
  if ((int )d[0] == 13) {
#line 753
    if (! ((int )d[1] == 10)) {
#line 753
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 755
  if ((int )d[0] == 45) {
    {
#line 758
    mpPutBack(mpp, d, 2);
    }
  }
#line 760
  if (out) {
#line 760
    if (outSpace) {
      {
#line 761
      oout = out;
#line 762
      *(out + outLen) = (char )'\000';
#line 763
      tmp___5 = realloc((void *)out, (size_t )(outLen + 1));
#line 763
      out = (char *)tmp___5;
      }
#line 764
      if (! out) {
#line 768
        out = oout;
      }
#line 770
      *outP = out;
    }
  }
#line 772
  if (bodyLengthP) {
#line 773
    *bodyLengthP = outLen;
  }
#line 775
  return ((cgiParseResultType )0);
  outOfMemory: 
#line 777
  result = (cgiParseResultType )1;
#line 778
  if (outP) {
#line 779
    if (out) {
      {
#line 780
      free((void *)out);
      }
    }
#line 782
    *outP = (char *)'\000';
  }
  error: 
#line 785
  if (bodyLengthP) {
#line 786
    *bodyLengthP = 0;
  }
#line 788
  if (out) {
    {
#line 789
    free((void *)out);
    }
  }
#line 791
  if (outP) {
#line 792
    *outP = (char *)0;
  }
#line 794
  return (result);
}
}
#line 797 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static void decomposeValue(char *value , char *mvalue , int mvalueSpace , char **argNames ,
                           char **argValues , int argValueSpace ) 
{ 
  char argName[1024] ;
  int argNameSpace ;
  int argNameLen ;
  int mvalueLen ;
  char *argValue ;
  int argNum ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int argNum___0 ;
  int argValueLen ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 804
  argNameSpace = (int )sizeof(argName);
#line 805
  argNameLen = 0;
#line 806
  mvalueLen = 0;
#line 808
  argNum = 0;
  {
#line 809
  while (1) {
    while_continue: /* CIL Label */ ;
#line 809
    if (! *(argNames + argNum)) {
#line 809
      goto while_break;
    }
#line 810
    if (argValueSpace) {
#line 811
      *(*(argValues + argNum) + 0) = (char )'\000';
    }
#line 813
    argNum ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 815
    tmp = __ctype_b_loc();
    }
#line 815
    if (! ((int const   )*(*tmp + (int )*value) & 8192)) {
#line 815
      goto while_break___0;
    }
#line 816
    value ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 819
  if ((int )*value == 34) {
#line 820
    value ++;
    {
#line 821
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 821
      if (*value) {
#line 821
        if (! ((int )*value != 34)) {
#line 821
          goto while_break___1;
        }
      } else {
#line 821
        goto while_break___1;
      }
#line 822
      if (mvalueLen + 1 < mvalueSpace) {
#line 822
        tmp___0 = mvalueLen;
#line 822
        mvalueLen ++;
#line 822
        *(mvalue + tmp___0) = *value;
      }
#line 823
      value ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 825
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 825
      if (*value) {
#line 825
        if (! ((int )*value != 59)) {
#line 825
          goto while_break___2;
        }
      } else {
#line 825
        goto while_break___2;
      }
#line 826
      value ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 830
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 830
      if (*value) {
#line 830
        if (! ((int )*value != 59)) {
#line 830
          goto while_break___3;
        }
      } else {
#line 830
        goto while_break___3;
      }
#line 831
      if (mvalueLen + 1 < mvalueSpace) {
#line 831
        tmp___1 = mvalueLen;
#line 831
        mvalueLen ++;
#line 831
        *(mvalue + tmp___1) = *value;
      }
#line 832
      value ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 835
  if (mvalueSpace) {
#line 836
    *(mvalue + mvalueLen) = (char )'\000';
  }
  {
#line 838
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 838
    if (! ((int )*value == 59)) {
#line 838
      goto while_break___4;
    }
#line 840
    argValueLen = 0;
#line 842
    value ++;
    {
#line 844
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 844
      if (*value) {
        {
#line 844
        tmp___2 = __ctype_b_loc();
        }
#line 844
        if (! ((int const   )*(*tmp___2 + (int )*value) & 8192)) {
#line 844
          goto while_break___5;
        }
      } else {
#line 844
        goto while_break___5;
      }
#line 845
      value ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 848
    argNameLen = 0;
    {
#line 849
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 849
      if (*value) {
        {
#line 849
        tmp___4 = __ctype_b_loc();
        }
#line 849
        if (! ((int const   )*(*tmp___4 + (int )*value) & 8)) {
#line 849
          goto while_break___6;
        }
      } else {
#line 849
        goto while_break___6;
      }
#line 850
      if (argNameLen + 1 < argNameSpace) {
#line 850
        tmp___3 = argNameLen;
#line 850
        argNameLen ++;
#line 850
        argName[tmp___3] = *value;
      }
#line 851
      value ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 853
    if (argNameSpace) {
#line 854
      argName[argNameLen] = (char )'\000';
    }
    {
#line 856
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 856
      if (*value) {
        {
#line 856
        tmp___5 = __ctype_b_loc();
        }
#line 856
        if (! ((int const   )*(*tmp___5 + (int )*value) & 8192)) {
#line 856
          goto while_break___7;
        }
      } else {
#line 856
        goto while_break___7;
      }
#line 857
      value ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 859
    if ((int )*value != 61) {
#line 861
      return;
    }
#line 863
    value ++;
    {
#line 864
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 864
      if (*value) {
        {
#line 864
        tmp___6 = __ctype_b_loc();
        }
#line 864
        if (! ((int const   )*(*tmp___6 + (int )*value) & 8192)) {
#line 864
          goto while_break___8;
        }
      } else {
#line 864
        goto while_break___8;
      }
#line 865
      value ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 868
    argNum___0 = 0;
#line 869
    argValue = (char *)0;
    {
#line 870
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 870
      if (! *(argNames + argNum___0)) {
#line 870
        goto while_break___9;
      }
      {
#line 871
      tmp___7 = cgiStrEqNc(argName, *(argNames + argNum___0));
      }
#line 871
      if (tmp___7) {
#line 872
        argValue = *(argValues + argNum___0);
#line 873
        goto while_break___9;
      }
#line 875
      argNum___0 ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 878
    if ((int )*value == 34) {
#line 879
      value ++;
      {
#line 880
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 880
        if (*value) {
#line 880
          if (! ((int )*value != 34)) {
#line 880
            goto while_break___10;
          }
        } else {
#line 880
          goto while_break___10;
        }
#line 881
        if (argValue) {
#line 882
          if (argValueLen + 1 < argValueSpace) {
#line 882
            tmp___8 = argValueLen;
#line 882
            argValueLen ++;
#line 882
            *(argValue + tmp___8) = *value;
          }
        }
#line 884
        value ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 886
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 886
        if (*value) {
#line 886
          if (! ((int )*value != 59)) {
#line 886
            goto while_break___11;
          }
        } else {
#line 886
          goto while_break___11;
        }
#line 887
        value ++;
      }
      while_break___11: /* CIL Label */ ;
      }
    } else {
      {
#line 891
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 891
        if (*value) {
#line 891
          if (! ((int )*value != 59)) {
#line 891
            goto while_break___12;
          }
        } else {
#line 891
          goto while_break___12;
        }
#line 892
        if (*(argNames + argNum___0)) {
#line 893
          if (argValueLen + 1 < argValueSpace) {
#line 893
            tmp___9 = argValueLen;
#line 893
            argValueLen ++;
#line 893
            *(argValue + tmp___9) = *value;
          }
        }
#line 895
        value ++;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 898
    if (argValueSpace) {
#line 899
      *(argValue + argValueLen) = (char )'\000';
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 902
  return;
}
}
#line 904 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static int readHeaderLine(mpStreamPtr mpp , char *attr , int attrSpace , char *value ,
                          int valueSpace ) 
{ 
  int attrLen ;
  int valueLen ;
  int valueFound ;
  char d[1] ;
  int got ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;

  {
#line 911
  attrLen = 0;
#line 912
  valueLen = 0;
#line 913
  valueFound = 0;
  {
#line 914
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 916
    tmp = mpRead(mpp, d, 1);
#line 916
    got = tmp;
    }
#line 917
    if (got != 1) {
#line 918
      return (0);
    }
#line 920
    if ((int )d[0] == 13) {
      {
#line 921
      got = mpRead(mpp, d, 1);
      }
#line 922
      if (got == 1) {
#line 923
        if (! ((int )d[0] == 10)) {
          {
#line 926
          mpPutBack(mpp, d, 1);
          }
        }
      }
#line 929
      goto while_break;
    } else
#line 930
    if ((int )d[0] == 10) {
#line 931
      goto while_break;
    } else
#line 932
    if ((int )d[0] == 58) {
#line 932
      if (attrLen) {
#line 933
        valueFound = 1;
        {
#line 934
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 934
          tmp___1 = mpRead(mpp, d, 1);
          }
#line 934
          if (! (tmp___1 == 1)) {
#line 934
            goto while_break___0;
          }
          {
#line 935
          tmp___0 = __ctype_b_loc();
          }
#line 935
          if (! ((int const   )*(*tmp___0 + (int )d[0]) & 8192)) {
            {
#line 936
            mpPutBack(mpp, d, 1);
            }
#line 937
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 932
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 940
    if (! valueFound) {
      {
#line 941
      tmp___3 = __ctype_b_loc();
      }
#line 941
      if (! ((int const   )*(*tmp___3 + (int )d[0]) & 8192)) {
#line 942
        if (attrLen < attrSpace - 1) {
#line 943
          tmp___2 = attrLen;
#line 943
          attrLen ++;
#line 943
          *(attr + tmp___2) = d[0];
        }
      }
    } else
#line 946
    if (valueFound) {
#line 947
      if (valueLen < valueSpace - 1) {
#line 948
        tmp___4 = valueLen;
#line 948
        valueLen ++;
#line 948
        *(value + tmp___4) = d[0];
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 952
  if (attrSpace) {
#line 953
    *(attr + attrLen) = (char )'\000';
  }
#line 955
  if (valueSpace) {
#line 956
    *(value + valueLen) = (char )'\000';
  }
#line 958
  if (attrLen) {
#line 958
    if (valueLen) {
#line 959
      return (1);
    } else {
#line 961
      return (0);
    }
  } else {
#line 961
    return (0);
  }
}
}
#line 965 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static cgiParseResultType cgiParseGetFormInput(void) 
{ 
  cgiParseResultType tmp ;

  {
  {
#line 966
  tmp = cgiParseFormInput(cgiQueryString, cgiContentLength);
  }
#line 966
  return (tmp);
}
}
#line 980
static cgiUnescapeResultType cgiUnescapeChars(char **sp , char *cp , int len ) ;
#line 982 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static cgiParseResultType cgiParseFormInput(char *data , int length ) 
{ 
  int pos ;
  cgiFormEntry *n ;
  cgiFormEntry *l ;
  int foundEq ;
  int foundAmp ;
  int start ;
  int len ;
  char *attr ;
  char *value ;
  cgiUnescapeResultType tmp ;
  cgiUnescapeResultType tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 984
  pos = 0;
#line 986
  l = (cgiFormEntry *)0;
  {
#line 987
  while (1) {
    while_continue: /* CIL Label */ ;
#line 987
    if (! (pos != length)) {
#line 987
      goto while_break;
    }
#line 988
    foundEq = 0;
#line 989
    foundAmp = 0;
#line 990
    start = pos;
#line 991
    len = 0;
    {
#line 994
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 994
      if (! (pos != length)) {
#line 994
        goto while_break___0;
      }
#line 995
      if ((int )*(data + pos) == 61) {
#line 996
        foundEq = 1;
#line 997
        pos ++;
#line 998
        goto while_break___0;
      }
#line 1000
      pos ++;
#line 1001
      len ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1003
    if (! foundEq) {
#line 1004
      goto while_break;
    }
    {
#line 1006
    tmp = cgiUnescapeChars(& attr, data + start, len);
    }
#line 1006
    if ((unsigned int )tmp != 0U) {
#line 1008
      return ((cgiParseResultType )1);
    }
#line 1010
    start = pos;
#line 1011
    len = 0;
    {
#line 1012
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1012
      if (! (pos != length)) {
#line 1012
        goto while_break___1;
      }
#line 1013
      if ((int )*(data + pos) == 38) {
#line 1014
        foundAmp = 1;
#line 1015
        pos ++;
#line 1016
        goto while_break___1;
      }
#line 1018
      pos ++;
#line 1019
      len ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1023
    tmp___0 = cgiUnescapeChars(& value, data + start, len);
    }
#line 1023
    if ((unsigned int )tmp___0 != 0U) {
      {
#line 1025
      free((void *)attr);
      }
#line 1026
      return ((cgiParseResultType )1);
    }
    {
#line 1029
    tmp___1 = malloc(sizeof(cgiFormEntry ));
#line 1029
    n = (cgiFormEntry *)tmp___1;
    }
#line 1030
    if (! n) {
      {
#line 1031
      free((void *)attr);
#line 1032
      free((void *)value);
      }
#line 1033
      return ((cgiParseResultType )1);
    }
    {
#line 1035
    n->attr = attr;
#line 1036
    n->value = value;
#line 1037
    tmp___2 = strlen((char const   *)n->value);
#line 1037
    n->valueLength = (int )tmp___2;
#line 1038
    tmp___3 = malloc((size_t )1);
#line 1038
    n->fileName = (char *)tmp___3;
    }
#line 1039
    if (! n->fileName) {
      {
#line 1040
      free((void *)attr);
#line 1041
      free((void *)value);
#line 1042
      free((void *)n);
      }
#line 1043
      return ((cgiParseResultType )1);
    }
    {
#line 1045
    *(n->fileName + 0) = (char )'\000';
#line 1046
    tmp___4 = malloc((size_t )1);
#line 1046
    n->contentType = (char *)tmp___4;
    }
#line 1047
    if (! n->contentType) {
      {
#line 1048
      free((void *)attr);
#line 1049
      free((void *)value);
#line 1050
      free((void *)n->fileName);
#line 1051
      free((void *)n);
      }
#line 1052
      return ((cgiParseResultType )1);
    }
    {
#line 1054
    *(n->contentType + 0) = (char )'\000';
#line 1055
    tmp___5 = malloc((size_t )1);
#line 1055
    n->tfileName = (char *)tmp___5;
    }
#line 1056
    if (! n->tfileName) {
      {
#line 1057
      free((void *)attr);
#line 1058
      free((void *)value);
#line 1059
      free((void *)n->fileName);
#line 1060
      free((void *)n->contentType);
#line 1061
      free((void *)n);
      }
#line 1062
      return ((cgiParseResultType )1);
    }
#line 1064
    *(n->tfileName + 0) = (char )'\000';
#line 1065
    n->next = (struct cgiFormEntryStruct *)0;
#line 1066
    if (! l) {
#line 1067
      cgiFormEntryFirst = n;
    } else {
#line 1069
      l->next = n;
    }
#line 1071
    l = n;
#line 1072
    if (! foundAmp) {
#line 1073
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1076
  return ((cgiParseResultType )0);
}
}
#line 1079 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static int cgiHexValue[256]  ;
#line 1081 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static cgiUnescapeResultType cgiUnescapeChars(char **sp , char *cp , int len ) 
{ 
  char *s ;
  cgiEscapeState escapeState ;
  int escapedValue ;
  int srcPos ;
  int dstPos ;
  void *tmp ;
  int ch ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1083
  escapeState = (cgiEscapeState )0;
#line 1084
  escapedValue = 0;
#line 1085
  srcPos = 0;
#line 1086
  dstPos = 0;
#line 1087
  tmp = malloc((size_t )(len + 1));
#line 1087
  s = (char *)tmp;
  }
#line 1088
  if (! s) {
#line 1089
    return ((cgiUnescapeResultType )1);
  }
  {
#line 1091
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1091
    if (! (srcPos < len)) {
#line 1091
      goto while_break;
    }
#line 1092
    ch = (int )*(cp + srcPos);
    {
#line 1094
    if ((unsigned int )escapeState == 0U) {
#line 1094
      goto case_0;
    }
#line 1103
    if ((unsigned int )escapeState == 1U) {
#line 1103
      goto case_1;
    }
#line 1107
    if ((unsigned int )escapeState == 2U) {
#line 1107
      goto case_2;
    }
#line 1093
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1095
    if (ch == 37) {
#line 1096
      escapeState = (cgiEscapeState )1;
    } else
#line 1097
    if (ch == 43) {
#line 1098
      tmp___0 = dstPos;
#line 1098
      dstPos ++;
#line 1098
      *(s + tmp___0) = (char )' ';
    } else {
#line 1100
      tmp___1 = dstPos;
#line 1100
      dstPos ++;
#line 1100
      *(s + tmp___1) = (char )ch;
    }
#line 1102
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1104
    escapedValue = cgiHexValue[ch] << 4;
#line 1105
    escapeState = (cgiEscapeState )2;
#line 1106
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1108
    escapedValue += cgiHexValue[ch];
#line 1109
    tmp___2 = dstPos;
#line 1109
    dstPos ++;
#line 1109
    *(s + tmp___2) = (char )escapedValue;
#line 1110
    escapeState = (cgiEscapeState )0;
#line 1111
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1113
    srcPos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1115
  *(s + dstPos) = (char )'\000';
#line 1116
  *sp = s;
#line 1117
  return ((cgiUnescapeResultType )0);
}
}
#line 1120 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static void cgiSetupConstants(void) 
{ 
  int i ;

  {
#line 1122
  i = 0;
  {
#line 1122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1122
    if (! (i < 256)) {
#line 1122
      goto while_break;
    }
#line 1123
    cgiHexValue[i] = 0;
#line 1122
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1125
  cgiHexValue['0'] = 0;
#line 1126
  cgiHexValue['1'] = 1;
#line 1127
  cgiHexValue['2'] = 2;
#line 1128
  cgiHexValue['3'] = 3;
#line 1129
  cgiHexValue['4'] = 4;
#line 1130
  cgiHexValue['5'] = 5;
#line 1131
  cgiHexValue['6'] = 6;
#line 1132
  cgiHexValue['7'] = 7;
#line 1133
  cgiHexValue['8'] = 8;
#line 1134
  cgiHexValue['9'] = 9;
#line 1135
  cgiHexValue['A'] = 10;
#line 1136
  cgiHexValue['B'] = 11;
#line 1137
  cgiHexValue['C'] = 12;
#line 1138
  cgiHexValue['D'] = 13;
#line 1139
  cgiHexValue['E'] = 14;
#line 1140
  cgiHexValue['F'] = 15;
#line 1141
  cgiHexValue['a'] = 10;
#line 1142
  cgiHexValue['b'] = 11;
#line 1143
  cgiHexValue['c'] = 12;
#line 1144
  cgiHexValue['d'] = 13;
#line 1145
  cgiHexValue['e'] = 14;
#line 1146
  cgiHexValue['f'] = 15;
#line 1147
  return;
}
}
#line 1149 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static void cgiFreeResources(void) 
{ 
  cgiFormEntry *c ;
  cgiFormEntry *n ;
  size_t tmp ;

  {
#line 1150
  c = cgiFormEntryFirst;
  {
#line 1152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1152
    if (! c) {
#line 1152
      goto while_break;
    }
    {
#line 1153
    n = c->next;
#line 1154
    free((void *)c->attr);
#line 1155
    free((void *)c->value);
#line 1156
    free((void *)c->fileName);
#line 1157
    free((void *)c->contentType);
#line 1158
    tmp = strlen((char const   *)c->tfileName);
    }
#line 1158
    if (tmp) {
      {
#line 1159
      unlink((char const   *)c->tfileName);
      }
    }
    {
#line 1161
    free((void *)c->tfileName);
#line 1162
    free((void *)c);
#line 1163
    c = n;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1167
  if (cgiRestored) {
    {
#line 1168
    free((void *)cgiServerSoftware);
#line 1169
    free((void *)cgiServerName);
#line 1170
    free((void *)cgiGatewayInterface);
#line 1171
    free((void *)cgiServerProtocol);
#line 1172
    free((void *)cgiServerPort);
#line 1173
    free((void *)cgiRequestMethod);
#line 1174
    free((void *)cgiPathInfo);
#line 1175
    free((void *)cgiPathTranslated);
#line 1176
    free((void *)cgiScriptName);
#line 1177
    free((void *)cgiQueryString);
#line 1178
    free((void *)cgiRemoteHost);
#line 1179
    free((void *)cgiRemoteAddr);
#line 1180
    free((void *)cgiAuthType);
#line 1181
    free((void *)cgiRemoteUser);
#line 1182
    free((void *)cgiRemoteIdent);
#line 1183
    free((void *)cgiContentType);
#line 1184
    free((void *)cgiAccept);
#line 1185
    free((void *)cgiUserAgent);
#line 1186
    free((void *)cgiReferrer);
    }
  }
#line 1190
  cgiFormEntryFirst = (cgiFormEntry *)0;
#line 1191
  cgiRestored = 0;
#line 1192
  return;
}
}
#line 1194
static cgiFormResultType cgiFormEntryString(cgiFormEntry *e , char *result , int max ,
                                            int newlines ) ;
#line 1197
static cgiFormEntry *cgiFormEntryFindFirst(char *name ) ;
#line 1198
static cgiFormEntry *cgiFormEntryFindNext(void) ;
#line 1200 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiFormString(char *name , char *result , int max ) 
{ 
  cgiFormEntry *e ;
  cgiFormResultType tmp ;

  {
  {
#line 1203
  e = cgiFormEntryFindFirst(name);
  }
#line 1204
  if (! e) {
    {
#line 1205
    strcpy((char */* __restrict  */)result, (char const   */* __restrict  */)"");
    }
#line 1206
    return ((cgiFormResultType )4);
  }
  {
#line 1208
  tmp = cgiFormEntryString(e, result, max, 1);
  }
#line 1208
  return (tmp);
}
}
#line 1211 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiFormFileName(char *name , char *result , int resultSpace ) 
{ 
  cgiFormEntry *e ;
  int resultLen ;
  char *s ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 1215
  resultLen = 0;
#line 1217
  e = cgiFormEntryFindFirst(name);
  }
#line 1218
  if (! e) {
    {
#line 1219
    strcpy((char */* __restrict  */)result, (char const   */* __restrict  */)"");
    }
#line 1220
    return ((cgiFormResultType )4);
  }
#line 1222
  s = e->fileName;
  {
#line 1223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1223
    if (! *s) {
#line 1223
      goto while_break;
    }
#line 1224
    if (resultLen + 1 < resultSpace) {
#line 1224
      tmp = resultLen;
#line 1224
      resultLen ++;
#line 1224
      *(result + tmp) = *s;
    }
#line 1225
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1227
  if (resultSpace) {
#line 1228
    *(result + resultLen) = (char )'\000';
  }
  {
#line 1230
  tmp___1 = strlen((char const   *)e->fileName);
  }
#line 1230
  if (tmp___1) {
    {
#line 1232
    tmp___0 = strlen((char const   *)e->fileName);
    }
#line 1232
    if ((int )tmp___0 > resultSpace - 1) {
#line 1233
      return ((cgiFormResultType )1);
    } else {
#line 1235
      return ((cgiFormResultType )0);
    }
  } else {
#line 1231
    return ((cgiFormResultType )8);
  }
}
}
#line 1239 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiFormFileContentType(char *name , char *result , int resultSpace ) 
{ 
  cgiFormEntry *e ;
  int resultLen ;
  char *s ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 1243
  resultLen = 0;
#line 1245
  e = cgiFormEntryFindFirst(name);
  }
#line 1246
  if (! e) {
#line 1247
    if (resultSpace) {
#line 1248
      *(result + 0) = (char )'\000';
    }
#line 1250
    return ((cgiFormResultType )4);
  }
#line 1252
  s = e->contentType;
  {
#line 1253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1253
    if (! *s) {
#line 1253
      goto while_break;
    }
#line 1254
    if (resultLen + 1 < resultSpace) {
#line 1254
      tmp = resultLen;
#line 1254
      resultLen ++;
#line 1254
      *(result + tmp) = *s;
    }
#line 1255
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1257
  if (resultSpace) {
#line 1258
    *(result + resultLen) = (char )'\000';
  }
  {
#line 1260
  tmp___1 = strlen((char const   *)e->contentType);
  }
#line 1260
  if (tmp___1) {
    {
#line 1262
    tmp___0 = strlen((char const   *)e->contentType);
    }
#line 1262
    if ((int )tmp___0 > resultSpace - 1) {
#line 1263
      return ((cgiFormResultType )1);
    } else {
#line 1265
      return ((cgiFormResultType )0);
    }
  } else {
#line 1261
    return ((cgiFormResultType )9);
  }
}
}
#line 1269 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiFormFileSize(char *name , int *sizeP ) 
{ 
  cgiFormEntry *e ;
  size_t tmp ;

  {
  {
#line 1273
  e = cgiFormEntryFindFirst(name);
  }
#line 1274
  if (! e) {
#line 1275
    if (sizeP) {
#line 1276
      *sizeP = 0;
    }
#line 1278
    return ((cgiFormResultType )4);
  } else {
    {
#line 1279
    tmp = strlen((char const   *)e->tfileName);
    }
#line 1279
    if (tmp) {
#line 1285
      if (sizeP) {
#line 1286
        *sizeP = e->valueLength;
      }
#line 1288
      return ((cgiFormResultType )0);
    } else {
#line 1280
      if (sizeP) {
#line 1281
        *sizeP = 0;
      }
#line 1283
      return ((cgiFormResultType )10);
    }
  }
}
}
#line 1296 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiFormFileOpen(char *name , cgiFilePtr *cfpp ) 
{ 
  cgiFormEntry *e ;
  cgiFilePtr cfp ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 1301
  e = cgiFormEntryFindFirst(name);
  }
#line 1302
  if (! e) {
#line 1303
    *cfpp = (cgiFilePtr )0;
#line 1304
    return ((cgiFormResultType )4);
  }
  {
#line 1306
  tmp = strlen((char const   *)e->tfileName);
  }
#line 1306
  if (! tmp) {
#line 1307
    *cfpp = (cgiFilePtr )0;
#line 1308
    return ((cgiFormResultType )10);
  }
  {
#line 1310
  tmp___0 = malloc(sizeof(cgiFile ));
#line 1310
  cfp = (cgiFilePtr )tmp___0;
  }
#line 1311
  if (! cfp) {
#line 1312
    *cfpp = (cgiFilePtr )0;
#line 1313
    return ((cgiFormResultType )7);
  }
  {
#line 1315
  cfp->in = fopen((char const   */* __restrict  */)e->tfileName, (char const   */* __restrict  */)"rb");
  }
#line 1316
  if (! cfp->in) {
    {
#line 1317
    free((void *)cfp);
    }
#line 1318
    return ((cgiFormResultType )12);
  }
#line 1320
  *cfpp = cfp;
#line 1321
  return ((cgiFormResultType )0);
}
}
#line 1324 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiFormFileRead(cgiFilePtr cfp , char *buffer , int bufferSize ,
                                  int *gotP ) 
{ 
  int got ;
  size_t tmp ;

  {
#line 1328
  got = 0;
#line 1329
  if (! cfp) {
#line 1330
    return ((cgiFormResultType )11);
  }
  {
#line 1332
  tmp = fread((void */* __restrict  */)buffer, (size_t )1, (size_t )bufferSize, (FILE */* __restrict  */)cfp->in);
#line 1332
  got = (int )tmp;
  }
#line 1333
  if (got <= 0) {
#line 1334
    return ((cgiFormResultType )13);
  }
#line 1336
  *gotP = got;
#line 1337
  return ((cgiFormResultType )0);
}
}
#line 1340 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiFormFileClose(cgiFilePtr cfp ) 
{ 


  {
#line 1342
  if (! cfp) {
#line 1343
    return ((cgiFormResultType )11);
  }
  {
#line 1345
  fclose(cfp->in);
#line 1346
  free((void *)cfp);
  }
#line 1347
  return ((cgiFormResultType )0);
}
}
#line 1350 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiFormStringNoNewlines(char *name , char *result , int max ) 
{ 
  cgiFormEntry *e ;
  cgiFormResultType tmp ;

  {
  {
#line 1353
  e = cgiFormEntryFindFirst(name);
  }
#line 1354
  if (! e) {
    {
#line 1355
    strcpy((char */* __restrict  */)result, (char const   */* __restrict  */)"");
    }
#line 1356
    return ((cgiFormResultType )4);
  }
  {
#line 1358
  tmp = cgiFormEntryString(e, result, max, 0);
  }
#line 1358
  return (tmp);
}
}
#line 1361 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiFormStringMultiple(char *name , char ***result ) 
{ 
  char **stringArray ;
  cgiFormEntry *e ;
  int i ;
  int total ;
  void *tmp ;
  int max ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1366
  total = 0;
#line 1370
  e = cgiFormEntryFindFirst(name);
  }
#line 1371
  if ((unsigned long )e != (unsigned long )((cgiFormEntry *)0)) {
    {
#line 1372
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1373
      total ++;
#line 1372
      e = cgiFormEntryFindNext();
      }
#line 1372
      if (! ((unsigned long )e != (unsigned long )((cgiFormEntry *)0))) {
#line 1372
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1376
  tmp = malloc(sizeof(char *) * (unsigned long )(total + 1));
#line 1376
  stringArray = (char **)tmp;
  }
#line 1377
  if (! stringArray) {
#line 1378
    *result = (char **)0;
#line 1379
    return ((cgiFormResultType )7);
  }
#line 1382
  i = 0;
  {
#line 1382
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1382
    if (! (i <= total)) {
#line 1382
      goto while_break___0;
    }
#line 1383
    *(stringArray + i) = (char *)0;
#line 1382
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1386
  e = cgiFormEntryFindFirst(name);
  }
#line 1392
  if (e) {
#line 1393
    i = 0;
    {
#line 1394
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1395
      tmp___0 = strlen((char const   *)e->value);
#line 1395
      max = (int )(tmp___0 + 1UL);
#line 1396
      tmp___1 = malloc((size_t )max);
#line 1396
      *(stringArray + i) = (char *)tmp___1;
      }
#line 1397
      if ((unsigned long )*(stringArray + i) == (unsigned long )((char *)0)) {
        {
#line 1399
        cgiStringArrayFree(stringArray);
#line 1400
        *result = (char **)0;
        }
#line 1401
        return ((cgiFormResultType )7);
      }
      {
#line 1403
      strcpy((char */* __restrict  */)*(stringArray + i), (char const   */* __restrict  */)e->value);
#line 1404
      cgiFormEntryString(e, *(stringArray + i), max, 1);
#line 1405
      i ++;
#line 1394
      e = cgiFormEntryFindNext();
      }
#line 1394
      if (! ((unsigned long )e != (unsigned long )((cgiFormEntry *)0))) {
#line 1394
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1407
    *result = stringArray;
#line 1413
    return ((cgiFormResultType )0);
  } else {
#line 1415
    *result = stringArray;
#line 1421
    return ((cgiFormResultType )4);
  }
}
}
#line 1425 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiFormStringSpaceNeeded(char *name , int *result ) 
{ 
  cgiFormEntry *e ;
  size_t tmp ;

  {
  {
#line 1428
  e = cgiFormEntryFindFirst(name);
  }
#line 1429
  if (! e) {
#line 1430
    *result = 1;
#line 1431
    return ((cgiFormResultType )4);
  }
  {
#line 1433
  tmp = strlen((char const   *)e->value);
#line 1433
  *result = (int )tmp + 1;
  }
#line 1434
  return ((cgiFormResultType )0);
}
}
#line 1437 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static cgiFormResultType cgiFormEntryString(cgiFormEntry *e , char *result , int max ,
                                            int newlines ) 
{ 
  char *dp ;
  char *sp ;
  int truncated ;
  int len ;
  int avail ;
  int crCount ;
  int lfCount ;
  int ch ;
  int lfsAdd ;

  {
#line 1440
  truncated = 0;
#line 1441
  len = 0;
#line 1442
  avail = max - 1;
#line 1443
  crCount = 0;
#line 1444
  lfCount = 0;
#line 1445
  dp = result;
#line 1446
  sp = e->value;
  {
#line 1447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1454
    ch = (int )*sp;
#line 1461
    if (ch == 13) {
#line 1461
      goto _L___0;
    } else
#line 1461
    if (ch == 10) {
      _L___0: /* CIL Label */ 
#line 1462
      if (ch == 13) {
#line 1463
        crCount ++;
      } else {
#line 1465
        lfCount ++;
      }
    } else {
#line 1468
      if (crCount) {
#line 1468
        goto _L;
      } else
#line 1468
      if (lfCount) {
        _L: /* CIL Label */ 
#line 1469
        lfsAdd = crCount;
#line 1470
        if (lfCount > crCount) {
#line 1471
          lfsAdd = lfCount;
        }
#line 1474
        if (! newlines) {
#line 1475
          lfsAdd = 0;
        }
        {
#line 1477
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1477
          if (! lfsAdd) {
#line 1477
            goto while_break___0;
          }
#line 1478
          if (len >= avail) {
#line 1479
            truncated = 1;
#line 1480
            goto while_break___0;
          }
#line 1482
          *dp = (char)10;
#line 1483
          dp ++;
#line 1484
          lfsAdd --;
#line 1485
          len ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1487
        crCount = 0;
#line 1488
        lfCount = 0;
      }
#line 1490
      if (ch == 0) {
#line 1492
        goto while_break;
      }
#line 1497
      if (len >= avail) {
#line 1498
        truncated = 1;
#line 1499
        goto while_break;
      }
#line 1501
      *dp = (char )ch;
#line 1502
      dp ++;
#line 1503
      len ++;
    }
#line 1505
    sp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1507
  *dp = (char )'\000';
#line 1508
  if (truncated) {
#line 1509
    return ((cgiFormResultType )1);
  } else
#line 1510
  if (! len) {
#line 1511
    return ((cgiFormResultType )3);
  } else {
#line 1513
    return ((cgiFormResultType )0);
  }
}
}
#line 1517
static int cgiFirstNonspaceChar(char *s ) ;
#line 1519 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiFormInteger(char *name , int *result , int defaultV ) 
{ 
  cgiFormEntry *e ;
  int ch ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 1523
  e = cgiFormEntryFindFirst(name);
  }
#line 1524
  if (! e) {
#line 1525
    *result = defaultV;
#line 1526
    return ((cgiFormResultType )4);
  }
  {
#line 1528
  tmp = strlen((char const   *)e->value);
  }
#line 1528
  if (! tmp) {
#line 1529
    *result = defaultV;
#line 1530
    return ((cgiFormResultType )3);
  }
  {
#line 1532
  ch = cgiFirstNonspaceChar(e->value);
#line 1533
  tmp___0 = __ctype_b_loc();
  }
#line 1533
  if ((int const   )*(*tmp___0 + ch) & 2048) {
    {
#line 1537
    *result = atoi((char const   *)e->value);
    }
#line 1538
    return ((cgiFormResultType )0);
  } else
#line 1533
  if (ch != 45) {
#line 1533
    if (ch != 43) {
#line 1534
      *result = defaultV;
#line 1535
      return ((cgiFormResultType )2);
    } else {
      {
#line 1537
      *result = atoi((char const   *)e->value);
      }
#line 1538
      return ((cgiFormResultType )0);
    }
  } else {
    {
#line 1537
    *result = atoi((char const   *)e->value);
    }
#line 1538
    return ((cgiFormResultType )0);
  }
}
}
#line 1542 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiFormIntegerBounded(char *name , int *result , int min , int max ,
                                        int defaultV ) 
{ 
  cgiFormResultType error ;
  cgiFormResultType tmp ;

  {
  {
#line 1544
  tmp = cgiFormInteger(name, result, defaultV);
#line 1544
  error = tmp;
  }
#line 1545
  if ((unsigned int )error != 0U) {
#line 1546
    return (error);
  }
#line 1548
  if (*result < min) {
#line 1549
    *result = min;
#line 1550
    return ((cgiFormResultType )5);
  }
#line 1552
  if (*result > max) {
#line 1553
    *result = max;
#line 1554
    return ((cgiFormResultType )5);
  }
#line 1556
  return ((cgiFormResultType )0);
}
}
#line 1559 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiFormDouble(char *name , double *result , double defaultV ) 
{ 
  cgiFormEntry *e ;
  int ch ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 1563
  e = cgiFormEntryFindFirst(name);
  }
#line 1564
  if (! e) {
#line 1565
    *result = defaultV;
#line 1566
    return ((cgiFormResultType )4);
  }
  {
#line 1568
  tmp = strlen((char const   *)e->value);
  }
#line 1568
  if (! tmp) {
#line 1569
    *result = defaultV;
#line 1570
    return ((cgiFormResultType )3);
  }
  {
#line 1572
  ch = cgiFirstNonspaceChar(e->value);
#line 1573
  tmp___0 = __ctype_b_loc();
  }
#line 1573
  if ((int const   )*(*tmp___0 + ch) & 2048) {
    {
#line 1577
    *result = atof((char const   *)e->value);
    }
#line 1578
    return ((cgiFormResultType )0);
  } else
#line 1573
  if (ch != 46) {
#line 1573
    if (ch != 45) {
#line 1573
      if (ch != 43) {
#line 1574
        *result = defaultV;
#line 1575
        return ((cgiFormResultType )2);
      } else {
        {
#line 1577
        *result = atof((char const   *)e->value);
        }
#line 1578
        return ((cgiFormResultType )0);
      }
    } else {
      {
#line 1577
      *result = atof((char const   *)e->value);
      }
#line 1578
      return ((cgiFormResultType )0);
    }
  } else {
    {
#line 1577
    *result = atof((char const   *)e->value);
    }
#line 1578
    return ((cgiFormResultType )0);
  }
}
}
#line 1582 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiFormDoubleBounded(char *name , double *result , double min ,
                                       double max , double defaultV ) 
{ 
  cgiFormResultType error ;
  cgiFormResultType tmp ;

  {
  {
#line 1584
  tmp = cgiFormDouble(name, result, defaultV);
#line 1584
  error = tmp;
  }
#line 1585
  if ((unsigned int )error != 0U) {
#line 1586
    return (error);
  }
#line 1588
  if (*result < min) {
#line 1589
    *result = min;
#line 1590
    return ((cgiFormResultType )5);
  }
#line 1592
  if (*result > max) {
#line 1593
    *result = max;
#line 1594
    return ((cgiFormResultType )5);
  }
#line 1596
  return ((cgiFormResultType )0);
}
}
#line 1599 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiFormSelectSingle(char *name , char **choicesText , int choicesTotal ,
                                      int *result , int defaultV ) 
{ 
  cgiFormEntry *e ;
  int i ;
  int tmp ;

  {
  {
#line 1605
  e = cgiFormEntryFindFirst(name);
  }
#line 1611
  if (! e) {
#line 1612
    *result = defaultV;
#line 1613
    return ((cgiFormResultType )4);
  }
#line 1615
  i = 0;
  {
#line 1615
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1615
    if (! (i < choicesTotal)) {
#line 1615
      goto while_break;
    }
    {
#line 1621
    tmp = strcmp((char const   *)*(choicesText + i), (char const   *)e->value);
    }
#line 1621
    if (! tmp) {
#line 1627
      *result = i;
#line 1628
      return ((cgiFormResultType )0);
    }
#line 1615
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1631
  *result = defaultV;
#line 1632
  return ((cgiFormResultType )6);
}
}
#line 1635 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiFormSelectMultiple(char *name , char **choicesText , int choicesTotal ,
                                        int *result , int *invalid ) 
{ 
  cgiFormEntry *e ;
  int i ;
  int hits ;
  int invalidE ;
  int hit ;
  int tmp ;

  {
#line 1641
  hits = 0;
#line 1642
  invalidE = 0;
#line 1643
  i = 0;
  {
#line 1643
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1643
    if (! (i < choicesTotal)) {
#line 1643
      goto while_break;
    }
#line 1644
    *(result + i) = 0;
#line 1643
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1646
  e = cgiFormEntryFindFirst(name);
  }
#line 1647
  if (! e) {
#line 1648
    *invalid = invalidE;
#line 1649
    return ((cgiFormResultType )4);
  }
  {
#line 1651
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1652
    hit = 0;
#line 1653
    i = 0;
    {
#line 1653
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1653
      if (! (i < choicesTotal)) {
#line 1653
        goto while_break___1;
      }
      {
#line 1654
      tmp = strcmp((char const   *)*(choicesText + i), (char const   *)e->value);
      }
#line 1654
      if (! tmp) {
#line 1655
        *(result + i) = 1;
#line 1656
        hits ++;
#line 1657
        hit = 1;
#line 1658
        goto while_break___1;
      }
#line 1653
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1661
    if (! hit) {
#line 1662
      invalidE ++;
    }
    {
#line 1651
    e = cgiFormEntryFindNext();
    }
#line 1651
    if (! ((unsigned long )e != (unsigned long )((cgiFormEntry *)0))) {
#line 1651
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1666
  *invalid = invalidE;
#line 1668
  if (hits) {
#line 1669
    return ((cgiFormResultType )0);
  } else {
#line 1671
    return ((cgiFormResultType )4);
  }
}
}
#line 1675 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiFormCheckboxSingle(char *name ) 
{ 
  cgiFormEntry *e ;

  {
  {
#line 1679
  e = cgiFormEntryFindFirst(name);
  }
#line 1680
  if (! e) {
#line 1681
    return ((cgiFormResultType )4);
  }
#line 1683
  return ((cgiFormResultType )0);
}
}
#line 1686 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
extern cgiFormResultType cgiFormCheckboxMultiple(char *name , char **valuesText ,
                                                 int valuesTotal , int *result , int *invalid ) 
{ 
  cgiFormResultType tmp ;

  {
  {
#line 1691
  tmp = cgiFormSelectMultiple(name, valuesText, valuesTotal, result, invalid);
  }
#line 1691
  return (tmp);
}
}
#line 1695 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiFormRadio(char *name , char **valuesText , int valuesTotal ,
                               int *result , int defaultV ) 
{ 
  cgiFormResultType tmp ;

  {
  {
#line 1700
  tmp = cgiFormSelectSingle(name, valuesText, valuesTotal, result, defaultV);
  }
#line 1700
  return (tmp);
}
}
#line 1704 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiCookieString(char *name , char *value , int space ) 
{ 
  char *p ;
  char *n ;
  unsigned short const   **tmp ;

  {
#line 1709
  p = cgiCookie;
  {
#line 1710
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1710
    if (! *p) {
#line 1710
      goto while_break;
    }
#line 1711
    n = name;
    {
#line 1718
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1718
      if (! ((int )*p == (int )*n)) {
#line 1718
        goto while_break___0;
      }
#line 1719
      if ((unsigned long )p == (unsigned long )((char *)0)) {
#line 1719
        if ((unsigned long )n == (unsigned long )((char *)0)) {
#line 1721
          return ((cgiFormResultType )4);
        }
      }
#line 1723
      p ++;
#line 1724
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1726
    if (! *n) {
#line 1726
      if ((int )*p == 61) {
#line 1727
        p ++;
        {
#line 1728
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1728
          if ((int )*p != 59) {
#line 1728
            if ((int )*p != 0) {
#line 1728
              if (! (space > 1)) {
#line 1728
                goto while_break___1;
              }
            } else {
#line 1728
              goto while_break___1;
            }
          } else {
#line 1728
            goto while_break___1;
          }
#line 1731
          *value = *p;
#line 1732
          value ++;
#line 1733
          p ++;
#line 1734
          space --;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1736
        if (space > 0) {
#line 1737
          *value = (char )'\000';
        }
#line 1741
        if ((int )*p == 59) {
#line 1745
          return ((cgiFormResultType )0);
        } else
#line 1741
        if ((int )*p == 0) {
#line 1745
          return ((cgiFormResultType )0);
        } else {
#line 1743
          return ((cgiFormResultType )1);
        }
      } else {
#line 1726
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1749
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1749
        if (! *p) {
#line 1749
          goto while_break___2;
        }
#line 1750
        if ((int )*p == 59) {
#line 1751
          goto while_break___2;
        }
#line 1753
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1755
      if (! *p) {
#line 1757
        if (space) {
#line 1758
          *value = (char )'\000';
        }
#line 1760
        return ((cgiFormResultType )4);
      }
#line 1762
      p ++;
      {
#line 1764
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1764
        if (*p) {
          {
#line 1764
          tmp = __ctype_b_loc();
          }
#line 1764
          if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 1764
            goto while_break___3;
          }
        } else {
#line 1764
          goto while_break___3;
        }
#line 1765
        p ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1771
  if (space) {
#line 1772
    *value = (char )'\000';
  }
#line 1774
  return ((cgiFormResultType )4);
}
}
#line 1777 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiCookieInteger(char *name , int *result , int defaultV ) 
{ 
  char buffer[256] ;
  cgiFormResultType r ;
  cgiFormResultType tmp ;

  {
  {
#line 1783
  tmp = cgiCookieString(name, buffer, (int )sizeof(buffer));
#line 1783
  r = tmp;
  }
#line 1785
  if ((unsigned int )r != 0U) {
#line 1786
    *result = defaultV;
  } else {
    {
#line 1788
    *result = atoi((char const   *)(buffer));
    }
  }
#line 1790
  return (r);
}
}
#line 1793 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
void cgiHeaderCookieSetInteger(char *name , int value , int secondsToLive , char *path ,
                               char *domain ) 
{ 
  char svalue[256] ;

  {
  {
#line 1797
  sprintf((char */* __restrict  */)(svalue), (char const   */* __restrict  */)"%d",
          value);
#line 1798
  cgiHeaderCookieSetString(name, svalue, secondsToLive, path, domain);
  }
#line 1799
  return;
}
}
#line 1801 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
char *days[7]  = {      (char *)"Sun",      (char *)"Mon",      (char *)"Tue",      (char *)"Wed", 
        (char *)"Thu",      (char *)"Fri",      (char *)"Sat"};
#line 1811 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
char *months[12]  = 
#line 1811
  {      (char *)"Jan",      (char *)"Feb",      (char *)"Mar",      (char *)"Apr", 
        (char *)"May",      (char *)"Jun",      (char *)"Jul",      (char *)"Aug", 
        (char *)"Sep",      (char *)"Oct",      (char *)"Nov",      (char *)"Dec"};
#line 1826 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
void cgiHeaderCookieSetString(char *name , char *value , int secondsToLive , char *path ,
                              char *domain ) 
{ 
  time_t now ;
  time_t then ;
  struct tm *gt ;

  {
  {
#line 1842
  time(& now);
#line 1843
  then = now + (time_t )secondsToLive;
#line 1844
  gt = gmtime((time_t const   *)(& then));
#line 1845
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Set-Cookie: %s=%s; domain=%s; expires=%s, %02d-%s-%04d %02d:%02d:%02d GMT; path=%s\r\n",
          name, value, domain, days[gt->tm_wday], gt->tm_mday, months[gt->tm_mon],
          gt->tm_year + 1900, gt->tm_hour, gt->tm_min, gt->tm_sec, path);
  }
#line 1856
  return;
}
}
#line 1858 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
void cgiHeaderLocation(char *redirectUrl ) 
{ 


  {
  {
#line 1859
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Location: %s\r\n\r\n",
          redirectUrl);
  }
#line 1860
  return;
}
}
#line 1862 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
void cgiHeaderStatus(int status , char *statusMessage ) 
{ 


  {
  {
#line 1863
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Status: %d %s\r\n\r\n",
          status, statusMessage);
  }
#line 1864
  return;
}
}
#line 1866 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
void cgiHeaderContentType(char *mimeType ) 
{ 


  {
  {
#line 1867
  fprintf((FILE */* __restrict  */)cgiOut, (char const   */* __restrict  */)"Content-type: %s\r\n\r\n",
          mimeType);
  }
#line 1868
  return;
}
}
#line 1870
static int cgiWriteString(FILE *out , char *s ) ;
#line 1872
static int cgiWriteInt(FILE *out , int i ) ;
#line 1876 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiEnvironmentResultType cgiWriteEnvironment(char *filename ) 
{ 
  FILE *out ;
  cgiFormEntry *e ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  cgiFilePtr fp ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char buffer[1024] ;
  int got ;
  int tmp___26 ;
  size_t tmp___27 ;
  cgiFormResultType tmp___28 ;
  cgiFormResultType tmp___29 ;
  int tmp___30 ;
  cgiFormResultType tmp___31 ;

  {
  {
#line 1880
  out = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
  }
#line 1881
  if (! out) {
#line 1883
    return ((cgiEnvironmentResultType )0);
  }
  {
#line 1885
  tmp = cgiWriteString(out, (char *)"CGIC2.0");
  }
#line 1885
  if (! tmp) {
#line 1886
    goto error;
  }
  {
#line 1888
  tmp___0 = cgiWriteString(out, cgiServerSoftware);
  }
#line 1888
  if (! tmp___0) {
#line 1889
    goto error;
  }
  {
#line 1891
  tmp___1 = cgiWriteString(out, cgiServerName);
  }
#line 1891
  if (! tmp___1) {
#line 1892
    goto error;
  }
  {
#line 1894
  tmp___2 = cgiWriteString(out, cgiGatewayInterface);
  }
#line 1894
  if (! tmp___2) {
#line 1895
    goto error;
  }
  {
#line 1897
  tmp___3 = cgiWriteString(out, cgiServerProtocol);
  }
#line 1897
  if (! tmp___3) {
#line 1898
    goto error;
  }
  {
#line 1900
  tmp___4 = cgiWriteString(out, cgiServerPort);
  }
#line 1900
  if (! tmp___4) {
#line 1901
    goto error;
  }
  {
#line 1903
  tmp___5 = cgiWriteString(out, cgiRequestMethod);
  }
#line 1903
  if (! tmp___5) {
#line 1904
    goto error;
  }
  {
#line 1906
  tmp___6 = cgiWriteString(out, cgiPathInfo);
  }
#line 1906
  if (! tmp___6) {
#line 1907
    goto error;
  }
  {
#line 1909
  tmp___7 = cgiWriteString(out, cgiPathTranslated);
  }
#line 1909
  if (! tmp___7) {
#line 1910
    goto error;
  }
  {
#line 1912
  tmp___8 = cgiWriteString(out, cgiScriptName);
  }
#line 1912
  if (! tmp___8) {
#line 1913
    goto error;
  }
  {
#line 1915
  tmp___9 = cgiWriteString(out, cgiQueryString);
  }
#line 1915
  if (! tmp___9) {
#line 1916
    goto error;
  }
  {
#line 1918
  tmp___10 = cgiWriteString(out, cgiRemoteHost);
  }
#line 1918
  if (! tmp___10) {
#line 1919
    goto error;
  }
  {
#line 1921
  tmp___11 = cgiWriteString(out, cgiRemoteAddr);
  }
#line 1921
  if (! tmp___11) {
#line 1922
    goto error;
  }
  {
#line 1924
  tmp___12 = cgiWriteString(out, cgiAuthType);
  }
#line 1924
  if (! tmp___12) {
#line 1925
    goto error;
  }
  {
#line 1927
  tmp___13 = cgiWriteString(out, cgiRemoteUser);
  }
#line 1927
  if (! tmp___13) {
#line 1928
    goto error;
  }
  {
#line 1930
  tmp___14 = cgiWriteString(out, cgiRemoteIdent);
  }
#line 1930
  if (! tmp___14) {
#line 1931
    goto error;
  }
  {
#line 1933
  tmp___15 = cgiWriteString(out, cgiContentType);
  }
#line 1933
  if (! tmp___15) {
#line 1934
    goto error;
  }
  {
#line 1936
  tmp___16 = cgiWriteString(out, cgiAccept);
  }
#line 1936
  if (! tmp___16) {
#line 1937
    goto error;
  }
  {
#line 1939
  tmp___17 = cgiWriteString(out, cgiUserAgent);
  }
#line 1939
  if (! tmp___17) {
#line 1940
    goto error;
  }
  {
#line 1942
  tmp___18 = cgiWriteString(out, cgiReferrer);
  }
#line 1942
  if (! tmp___18) {
#line 1943
    goto error;
  }
  {
#line 1945
  tmp___19 = cgiWriteString(out, cgiCookie);
  }
#line 1945
  if (! tmp___19) {
#line 1946
    goto error;
  }
  {
#line 1948
  tmp___20 = cgiWriteInt(out, cgiContentLength);
  }
#line 1948
  if (! tmp___20) {
#line 1949
    goto error;
  }
#line 1951
  e = cgiFormEntryFirst;
  {
#line 1952
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1952
    if (! e) {
#line 1952
      goto while_break;
    }
    {
#line 1954
    tmp___21 = cgiWriteString(out, e->attr);
    }
#line 1954
    if (! tmp___21) {
#line 1955
      goto error;
    }
    {
#line 1957
    tmp___22 = cgiWriteString(out, e->value);
    }
#line 1957
    if (! tmp___22) {
#line 1958
      goto error;
    }
    {
#line 1961
    tmp___23 = cgiWriteString(out, e->fileName);
    }
#line 1961
    if (! tmp___23) {
#line 1962
      goto error;
    }
    {
#line 1964
    tmp___24 = cgiWriteString(out, e->contentType);
    }
#line 1964
    if (! tmp___24) {
#line 1965
      goto error;
    }
    {
#line 1967
    tmp___25 = cgiWriteInt(out, e->valueLength);
    }
#line 1967
    if (! tmp___25) {
#line 1968
      goto error;
    }
    {
#line 1970
    tmp___31 = cgiFormFileOpen(e->attr, & fp);
    }
#line 1970
    if ((unsigned int )tmp___31 == 0U) {
      {
#line 1973
      tmp___26 = cgiWriteInt(out, 1);
      }
#line 1973
      if (! tmp___26) {
        {
#line 1974
        cgiFormFileClose(fp);
        }
#line 1975
        goto error;
      }
      {
#line 1977
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1977
        tmp___28 = cgiFormFileRead(fp, buffer, (int )sizeof(buffer), & got);
        }
#line 1977
        if (! ((unsigned int )tmp___28 == 0U)) {
#line 1977
          goto while_break___0;
        }
        {
#line 1980
        tmp___27 = fwrite((void const   */* __restrict  */)(buffer), (size_t )1, (size_t )got,
                          (FILE */* __restrict  */)out);
        }
#line 1980
        if ((int )tmp___27 != got) {
          {
#line 1981
          cgiFormFileClose(fp);
          }
#line 1982
          goto error;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1985
      tmp___29 = cgiFormFileClose(fp);
      }
#line 1985
      if ((unsigned int )tmp___29 != 0U) {
#line 1986
        goto error;
      }
    } else {
      {
#line 1989
      tmp___30 = cgiWriteInt(out, 0);
      }
#line 1989
      if (! tmp___30) {
#line 1990
        goto error;
      }
    }
#line 1993
    e = e->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1995
  fclose(out);
  }
#line 1996
  return ((cgiEnvironmentResultType )2);
  error: 
  {
#line 1998
  fclose(out);
#line 2002
  unlink((char const   *)filename);
  }
#line 2003
  return ((cgiEnvironmentResultType )0);
}
}
#line 2006 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static int cgiWriteString(FILE *out , char *s ) 
{ 
  int len ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 2007
  tmp = strlen((char const   *)s);
#line 2007
  len = (int )tmp;
#line 2008
  cgiWriteInt(out, len);
#line 2009
  tmp___0 = fwrite((void const   */* __restrict  */)s, (size_t )1, (size_t )len, (FILE */* __restrict  */)out);
  }
#line 2009
  if ((int )tmp___0 != len) {
#line 2010
    return (0);
  }
#line 2012
  return (1);
}
}
#line 2015 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static int cgiWriteInt(FILE *out , int i ) 
{ 
  size_t tmp ;

  {
  {
#line 2016
  tmp = fwrite((void const   */* __restrict  */)(& i), sizeof(int ), (size_t )1, (FILE */* __restrict  */)out);
  }
#line 2016
  if (! tmp) {
#line 2017
    return (0);
  }
#line 2019
  return (1);
}
}
#line 2022
static int cgiReadString(FILE *in , char **s ) ;
#line 2024
static int cgiReadInt(FILE *out , int *i ) ;
#line 2026 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiEnvironmentResultType cgiReadEnvironment(char *filename ) 
{ 
  FILE *in ;
  cgiFormEntry *e ;
  cgiFormEntry *p ;
  char *version ;
  cgiEnvironmentResultType result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int fileFlag ;
  void *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  char buffer[1024] ;
  FILE *out ;
  char tfileName[1024] ;
  int got ;
  int len ;
  cgiParseResultType tmp___29 ;
  int tryr ;
  size_t tmp___30 ;
  size_t tmp___31 ;
  size_t tmp___32 ;
  void *tmp___33 ;
  void *tmp___34 ;

  {
  {
#line 2028
  e = (cgiFormEntry *)0;
#line 2031
  result = (cgiEnvironmentResultType )0;
#line 2033
  cgiFreeResources();
#line 2035
  in = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"rb");
  }
#line 2036
  if (! in) {
#line 2038
    return ((cgiEnvironmentResultType )0);
  }
  {
#line 2040
  tmp = cgiReadString(in, & version);
  }
#line 2040
  if (! tmp) {
#line 2041
    goto error;
  }
  {
#line 2043
  tmp___0 = strcmp((char const   *)version, "CGIC2.0");
  }
#line 2043
  if (tmp___0) {
    {
#line 2045
    free((void *)version);
    }
#line 2046
    return ((cgiEnvironmentResultType )3);
  }
  {
#line 2049
  free((void *)version);
#line 2050
  tmp___1 = cgiReadString(in, & cgiServerSoftware);
  }
#line 2050
  if (! tmp___1) {
#line 2051
    goto error;
  }
  {
#line 2053
  tmp___2 = cgiReadString(in, & cgiServerName);
  }
#line 2053
  if (! tmp___2) {
#line 2054
    goto error;
  }
  {
#line 2056
  tmp___3 = cgiReadString(in, & cgiGatewayInterface);
  }
#line 2056
  if (! tmp___3) {
#line 2057
    goto error;
  }
  {
#line 2059
  tmp___4 = cgiReadString(in, & cgiServerProtocol);
  }
#line 2059
  if (! tmp___4) {
#line 2060
    goto error;
  }
  {
#line 2062
  tmp___5 = cgiReadString(in, & cgiServerPort);
  }
#line 2062
  if (! tmp___5) {
#line 2063
    goto error;
  }
  {
#line 2065
  tmp___6 = cgiReadString(in, & cgiRequestMethod);
  }
#line 2065
  if (! tmp___6) {
#line 2066
    goto error;
  }
  {
#line 2068
  tmp___7 = cgiReadString(in, & cgiPathInfo);
  }
#line 2068
  if (! tmp___7) {
#line 2069
    goto error;
  }
  {
#line 2071
  tmp___8 = cgiReadString(in, & cgiPathTranslated);
  }
#line 2071
  if (! tmp___8) {
#line 2072
    goto error;
  }
  {
#line 2074
  tmp___9 = cgiReadString(in, & cgiScriptName);
  }
#line 2074
  if (! tmp___9) {
#line 2075
    goto error;
  }
  {
#line 2077
  tmp___10 = cgiReadString(in, & cgiQueryString);
  }
#line 2077
  if (! tmp___10) {
#line 2078
    goto error;
  }
  {
#line 2080
  tmp___11 = cgiReadString(in, & cgiRemoteHost);
  }
#line 2080
  if (! tmp___11) {
#line 2081
    goto error;
  }
  {
#line 2083
  tmp___12 = cgiReadString(in, & cgiRemoteAddr);
  }
#line 2083
  if (! tmp___12) {
#line 2084
    goto error;
  }
  {
#line 2086
  tmp___13 = cgiReadString(in, & cgiAuthType);
  }
#line 2086
  if (! tmp___13) {
#line 2087
    goto error;
  }
  {
#line 2089
  tmp___14 = cgiReadString(in, & cgiRemoteUser);
  }
#line 2089
  if (! tmp___14) {
#line 2090
    goto error;
  }
  {
#line 2092
  tmp___15 = cgiReadString(in, & cgiRemoteIdent);
  }
#line 2092
  if (! tmp___15) {
#line 2093
    goto error;
  }
  {
#line 2095
  tmp___16 = cgiReadString(in, & cgiContentType);
  }
#line 2095
  if (! tmp___16) {
#line 2096
    goto error;
  }
  {
#line 2098
  tmp___17 = cgiReadString(in, & cgiAccept);
  }
#line 2098
  if (! tmp___17) {
#line 2099
    goto error;
  }
  {
#line 2101
  tmp___18 = cgiReadString(in, & cgiUserAgent);
  }
#line 2101
  if (! tmp___18) {
#line 2102
    goto error;
  }
  {
#line 2104
  tmp___19 = cgiReadString(in, & cgiReferrer);
  }
#line 2104
  if (! tmp___19) {
#line 2105
    goto error;
  }
  {
#line 2108
  tmp___20 = cgiReadString(in, & cgiCookie);
  }
#line 2108
  if (! tmp___20) {
#line 2109
    goto error;
  }
  {
#line 2111
  tmp___21 = cgiReadInt(in, & cgiContentLength);
  }
#line 2111
  if (! tmp___21) {
#line 2112
    goto error;
  }
#line 2114
  p = (cgiFormEntry *)0;
  {
#line 2115
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2117
    tmp___22 = calloc((size_t )1, sizeof(cgiFormEntry ));
#line 2117
    e = (cgiFormEntry *)tmp___22;
    }
#line 2118
    if (! e) {
      {
#line 2119
      cgiFreeResources();
#line 2120
      fclose(in);
      }
#line 2121
      return ((cgiEnvironmentResultType )1);
    }
    {
#line 2123
    memset((void *)e, 0, sizeof(cgiFormEntry ));
#line 2124
    tmp___23 = cgiReadString(in, & e->attr);
    }
#line 2124
    if (! tmp___23) {
      {
#line 2127
      free((void *)e);
      }
#line 2128
      goto while_break;
    }
    {
#line 2130
    tmp___24 = cgiReadString(in, & e->value);
    }
#line 2130
    if (! tmp___24) {
#line 2131
      goto outOfMemory;
    }
    {
#line 2133
    tmp___25 = cgiReadString(in, & e->fileName);
    }
#line 2133
    if (! tmp___25) {
#line 2134
      goto outOfMemory;
    }
    {
#line 2136
    tmp___26 = cgiReadString(in, & e->contentType);
    }
#line 2136
    if (! tmp___26) {
#line 2137
      goto outOfMemory;
    }
    {
#line 2139
    tmp___27 = cgiReadInt(in, & e->valueLength);
    }
#line 2139
    if (! tmp___27) {
#line 2140
      goto outOfMemory;
    }
    {
#line 2142
    tmp___28 = cgiReadInt(in, & fileFlag);
    }
#line 2142
    if (! tmp___28) {
#line 2143
      goto outOfMemory;
    }
#line 2145
    if (fileFlag) {
      {
#line 2150
      len = e->valueLength;
#line 2151
      tmp___29 = getTempFileName(tfileName);
      }
#line 2151
      if ((unsigned int )tmp___29 != 0U) {
#line 2154
        result = (cgiEnvironmentResultType )0;
#line 2155
        goto error;
      }
      {
#line 2157
      out = fopen((char const   */* __restrict  */)(tfileName), (char const   */* __restrict  */)"w+b");
      }
#line 2158
      if (! out) {
#line 2159
        result = (cgiEnvironmentResultType )0;
#line 2160
        goto error;
      }
      {
#line 2162
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2162
        if (! (len > 0)) {
#line 2162
          goto while_break___0;
        }
#line 2166
        tryr = len;
#line 2167
        if (tryr > (int )sizeof(buffer)) {
#line 2168
          tryr = (int )sizeof(buffer);
        }
        {
#line 2170
        tmp___30 = fread((void */* __restrict  */)(buffer), (size_t )1, (size_t )tryr,
                         (FILE */* __restrict  */)in);
#line 2170
        got = (int )tmp___30;
        }
#line 2171
        if (got <= 0) {
          {
#line 2172
          result = (cgiEnvironmentResultType )0;
#line 2173
          fclose(out);
#line 2174
          unlink((char const   *)(tfileName));
          }
#line 2175
          goto error;
        }
        {
#line 2177
        tmp___31 = fwrite((void const   */* __restrict  */)(buffer), (size_t )1, (size_t )got,
                          (FILE */* __restrict  */)out);
        }
#line 2177
        if ((int )tmp___31 != got) {
          {
#line 2178
          result = (cgiEnvironmentResultType )0;
#line 2179
          fclose(out);
#line 2180
          unlink((char const   *)(tfileName));
          }
#line 2181
          goto error;
        }
#line 2183
        len -= got;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 2186
      fclose(out);
#line 2187
      tmp___32 = strlen((char const   *)(tfileName));
#line 2187
      tmp___33 = malloc((size_t )((int )tmp___32 + 1));
#line 2187
      e->tfileName = (char *)tmp___33;
      }
#line 2188
      if (! e->tfileName) {
        {
#line 2189
        result = (cgiEnvironmentResultType )1;
#line 2190
        unlink((char const   *)(tfileName));
        }
#line 2191
        goto error;
      }
      {
#line 2193
      strcpy((char */* __restrict  */)e->tfileName, (char const   */* __restrict  */)(tfileName));
      }
    } else {
      {
#line 2195
      tmp___34 = malloc((size_t )1);
#line 2195
      e->tfileName = (char *)tmp___34;
      }
#line 2196
      if (! e->tfileName) {
#line 2197
        result = (cgiEnvironmentResultType )1;
#line 2198
        goto error;
      }
    }
#line 2201
    e->next = (struct cgiFormEntryStruct *)0;
#line 2202
    if (p) {
#line 2203
      p->next = e;
    } else {
#line 2205
      cgiFormEntryFirst = e;
    }
#line 2207
    p = e;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2209
  fclose(in);
#line 2210
  cgiRestored = 1;
  }
#line 2211
  return ((cgiEnvironmentResultType )2);
  outOfMemory: 
#line 2213
  result = (cgiEnvironmentResultType )1;
  error: 
  {
#line 2215
  cgiFreeResources();
#line 2216
  fclose(in);
  }
#line 2217
  if (e) {
#line 2218
    if (e->attr) {
      {
#line 2219
      free((void *)e->attr);
      }
    }
#line 2221
    if (e->value) {
      {
#line 2222
      free((void *)e->value);
      }
    }
#line 2224
    if (e->fileName) {
      {
#line 2225
      free((void *)e->fileName);
      }
    }
#line 2227
    if (e->contentType) {
      {
#line 2228
      free((void *)e->contentType);
      }
    }
#line 2230
    if (e->tfileName) {
      {
#line 2231
      free((void *)e->tfileName);
      }
    }
    {
#line 2233
    free((void *)e);
    }
  }
#line 2235
  return (result);
}
}
#line 2238 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static int cgiReadString(FILE *in , char **s ) 
{ 
  int len ;
  int tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 2241
  tmp = cgiReadInt(in, & len);
  }
#line 2241
  if (! tmp) {
#line 2242
    return (0);
  }
  {
#line 2244
  tmp___0 = malloc((size_t )(len + 1));
#line 2244
  *s = (char *)tmp___0;
  }
#line 2245
  if (! *s) {
#line 2246
    return (0);
  }
  {
#line 2248
  tmp___1 = fread((void */* __restrict  */)*s, (size_t )1, (size_t )len, (FILE */* __restrict  */)in);
  }
#line 2248
  if ((int )tmp___1 != len) {
#line 2249
    return (0);
  }
#line 2251
  *(*s + len) = (char )'\000';
#line 2252
  return (1);
}
}
#line 2255 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static int cgiReadInt(FILE *out , int *i ) 
{ 
  size_t tmp ;

  {
  {
#line 2256
  tmp = fread((void */* __restrict  */)i, sizeof(int ), (size_t )1, (FILE */* __restrict  */)out);
  }
#line 2256
  if (! tmp) {
#line 2257
    return (0);
  }
#line 2259
  return (1);
}
}
#line 2262 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static int cgiStrEqNc(char *s1 , char *s2 ) 
{ 
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 2263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2264
    if (! *s1) {
#line 2265
      if (! *s2) {
#line 2266
        return (1);
      } else {
#line 2268
        return (0);
      }
    } else
#line 2270
    if (! *s2) {
#line 2271
      return (0);
    }
    {
#line 2273
    tmp___1 = __ctype_b_loc();
    }
#line 2273
    if ((int const   )*(*tmp___1 + (int )*s1) & 1024) {
      {
#line 2274
      tmp = tolower((int )*s1);
#line 2274
      tmp___0 = tolower((int )*s2);
      }
#line 2274
      if (tmp != tmp___0) {
#line 2275
        return (0);
      }
    } else
#line 2277
    if ((int )*s1 != (int )*s2) {
#line 2278
      return (0);
    }
#line 2280
    s1 ++;
#line 2281
    s2 ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2285 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static int cgiStrBeginsNc(char *s1 , char *s2 ) 
{ 
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 2286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2287
    if (! *s2) {
#line 2288
      return (1);
    } else
#line 2289
    if (! *s1) {
#line 2290
      return (0);
    }
    {
#line 2292
    tmp___1 = __ctype_b_loc();
    }
#line 2292
    if ((int const   )*(*tmp___1 + (int )*s1) & 1024) {
      {
#line 2293
      tmp = tolower((int )*s1);
#line 2293
      tmp___0 = tolower((int )*s2);
      }
#line 2293
      if (tmp != tmp___0) {
#line 2294
        return (0);
      }
    } else
#line 2296
    if ((int )*s1 != (int )*s2) {
#line 2297
      return (0);
    }
#line 2299
    s1 ++;
#line 2300
    s2 ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2304 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static char *cgiFindTarget  =    (char *)0;
#line 2305 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static cgiFormEntry *cgiFindPos  =    (cgiFormEntry *)0;
#line 2307 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static cgiFormEntry *cgiFormEntryFindFirst(char *name ) 
{ 
  cgiFormEntry *tmp ;

  {
  {
#line 2308
  cgiFindTarget = name;
#line 2309
  cgiFindPos = cgiFormEntryFirst;
#line 2310
  tmp = cgiFormEntryFindNext();
  }
#line 2310
  return (tmp);
}
}
#line 2313 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static cgiFormEntry *cgiFormEntryFindNext(void) 
{ 
  cgiFormEntry *c ;
  int tmp ;

  {
  {
#line 2314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2314
    if (! cgiFindPos) {
#line 2314
      goto while_break;
    }
    {
#line 2315
    c = cgiFindPos;
#line 2316
    cgiFindPos = c->next;
#line 2317
    tmp = strcmp((char const   *)c->attr, (char const   *)cgiFindTarget);
    }
#line 2317
    if (! tmp) {
#line 2318
      return (c);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2321
  return ((cgiFormEntry *)0);
}
}
#line 2324 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static int cgiFirstNonspaceChar(char *s ) 
{ 
  int len ;
  size_t tmp ;

  {
  {
#line 2325
  tmp = strspn((char const   *)s, " \n\r\t");
#line 2325
  len = (int )tmp;
  }
#line 2326
  return ((int )*(s + len));
}
}
#line 2329 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
void cgiStringArrayFree(char **stringArray ) 
{ 
  char *p ;
  char **arrayItself ;

  {
#line 2331
  arrayItself = stringArray;
#line 2332
  p = *stringArray;
  {
#line 2333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2333
    if (! p) {
#line 2333
      goto while_break;
    }
    {
#line 2334
    free((void *)p);
#line 2335
    stringArray ++;
#line 2336
    p = *stringArray;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2339
  free((void *)arrayItself);
  }
#line 2340
  return;
}
}
#line 2342 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiCookies(char ***result ) 
{ 
  char **stringArray ;
  int i ;
  int total ;
  char *p ;
  char *n ;
  void *tmp ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;

  {
#line 2345
  total = 0;
#line 2348
  p = cgiCookie;
  {
#line 2349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2349
    if (! *p) {
#line 2349
      goto while_break;
    }
#line 2350
    if ((int )*p == 61) {
#line 2351
      total ++;
    }
#line 2353
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2355
  tmp = malloc(sizeof(char *) * (unsigned long )(total + 1));
#line 2355
  stringArray = (char **)tmp;
  }
#line 2356
  if (! stringArray) {
#line 2357
    *result = (char **)0;
#line 2358
    return ((cgiFormResultType )7);
  }
#line 2361
  i = 0;
  {
#line 2361
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2361
    if (! (i <= total)) {
#line 2361
      goto while_break___0;
    }
#line 2362
    *(stringArray + i) = (char *)0;
#line 2361
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2364
  i = 0;
#line 2365
  p = cgiCookie;
  {
#line 2366
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2366
    if (! *p) {
#line 2366
      goto while_break___1;
    }
    {
#line 2367
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2367
      if (*p) {
        {
#line 2367
        tmp___0 = __ctype_b_loc();
        }
#line 2367
        if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 2367
          goto while_break___2;
        }
      } else {
#line 2367
        goto while_break___2;
      }
#line 2368
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2370
    n = p;
    {
#line 2371
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2371
      if (*p) {
#line 2371
        if (! ((int )*p != 61)) {
#line 2371
          goto while_break___3;
        }
      } else {
#line 2371
        goto while_break___3;
      }
#line 2372
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2374
    if ((unsigned long )p != (unsigned long )n) {
      {
#line 2375
      tmp___1 = malloc((size_t )((p - n) + 1L));
#line 2375
      *(stringArray + i) = (char *)tmp___1;
      }
#line 2376
      if (! *(stringArray + i)) {
        {
#line 2377
        cgiStringArrayFree(stringArray);
#line 2378
        *result = (char **)0;
        }
#line 2379
        return ((cgiFormResultType )7);
      }
      {
#line 2381
      memcpy((void */* __restrict  */)*(stringArray + i), (void const   */* __restrict  */)n,
             (size_t )(p - n));
#line 2382
      *(*(stringArray + i) + (p - n)) = (char )'\000';
#line 2383
      i ++;
      }
    }
    {
#line 2385
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2385
      if (*p) {
#line 2385
        if (! ((int )*p != 59)) {
#line 2385
          goto while_break___4;
        }
      } else {
#line 2385
        goto while_break___4;
      }
#line 2386
      p ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2388
    if (! *p) {
#line 2389
      goto while_break___1;
    }
#line 2391
    if ((int )*p == 59) {
#line 2392
      p ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2395
  *result = stringArray;
#line 2396
  return ((cgiFormResultType )0);
}
}
#line 2399 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiFormEntries(char ***result ) 
{ 
  char **stringArray ;
  cgiFormEntry *e ;
  cgiFormEntry *pe ;
  int i ;
  int total ;
  int tmp ;
  void *tmp___0 ;
  int space ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
#line 2403
  total = 0;
#line 2404
  e = cgiFormEntryFirst;
  {
#line 2405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2405
    if (! e) {
#line 2405
      goto while_break;
    }
#line 2408
    pe = cgiFormEntryFirst;
    {
#line 2409
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2409
      if (! ((unsigned long )pe != (unsigned long )e)) {
#line 2409
        goto while_break___0;
      }
      {
#line 2410
      tmp = strcmp((char const   *)e->attr, (char const   *)pe->attr);
      }
#line 2410
      if (! tmp) {
#line 2411
        goto skipSecondValue;
      }
#line 2413
      pe = pe->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2415
    total ++;
    skipSecondValue: 
#line 2417
    e = e->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2419
  tmp___0 = malloc(sizeof(char *) * (unsigned long )(total + 1));
#line 2419
  stringArray = (char **)tmp___0;
  }
#line 2420
  if (! stringArray) {
#line 2421
    *result = (char **)0;
#line 2422
    return ((cgiFormResultType )7);
  }
#line 2425
  i = 0;
  {
#line 2425
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2425
    if (! (i <= total)) {
#line 2425
      goto while_break___1;
    }
#line 2426
    *(stringArray + i) = (char *)0;
#line 2425
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2429
  e = cgiFormEntryFirst;
#line 2430
  i = 0;
  {
#line 2431
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2431
    if (! e) {
#line 2431
      goto while_break___2;
    }
#line 2435
    pe = cgiFormEntryFirst;
    {
#line 2436
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2436
      if (! ((unsigned long )pe != (unsigned long )e)) {
#line 2436
        goto while_break___3;
      }
      {
#line 2437
      tmp___1 = strcmp((char const   *)e->attr, (char const   *)pe->attr);
      }
#line 2437
      if (! tmp___1) {
#line 2438
        goto skipSecondValue2;
      }
#line 2440
      pe = pe->next;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 2442
    tmp___2 = strlen((char const   *)e->attr);
#line 2442
    space = (int )tmp___2 + 1;
#line 2443
    tmp___3 = malloc((size_t )space);
#line 2443
    *(stringArray + i) = (char *)tmp___3;
    }
#line 2444
    if ((unsigned long )*(stringArray + i) == (unsigned long )((char *)0)) {
      {
#line 2446
      cgiStringArrayFree(stringArray);
#line 2447
      *result = (char **)0;
      }
#line 2448
      return ((cgiFormResultType )7);
    }
    {
#line 2450
    strcpy((char */* __restrict  */)*(stringArray + i), (char const   */* __restrict  */)e->attr);
#line 2451
    i ++;
    }
    skipSecondValue2: 
#line 2453
    e = e->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2455
  *result = stringArray;
#line 2456
  return ((cgiFormResultType )0);
}
}
#line 2466 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiHtmlEscapeData(char *data , int len ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 2468
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2468
    tmp___13 = len;
#line 2468
    len --;
#line 2468
    if (! tmp___13) {
#line 2468
      goto while_break;
    }
#line 2469
    if ((int )*data == 60) {
      {
#line 2470
      tmp = _IO_putc('&', cgiOut);
      }
#line 2470
      if (tmp == -1) {
#line 2470
        return ((cgiFormResultType )12);
      }
      {
#line 2471
      tmp___0 = _IO_putc('l', cgiOut);
      }
#line 2471
      if (tmp___0 == -1) {
#line 2471
        return ((cgiFormResultType )12);
      }
      {
#line 2472
      tmp___1 = _IO_putc('t', cgiOut);
      }
#line 2472
      if (tmp___1 == -1) {
#line 2472
        return ((cgiFormResultType )12);
      }
      {
#line 2473
      tmp___2 = _IO_putc(';', cgiOut);
      }
#line 2473
      if (tmp___2 == -1) {
#line 2473
        return ((cgiFormResultType )12);
      }
    } else
#line 2474
    if ((int )*data == 38) {
      {
#line 2475
      tmp___3 = _IO_putc('&', cgiOut);
      }
#line 2475
      if (tmp___3 == -1) {
#line 2475
        return ((cgiFormResultType )12);
      }
      {
#line 2476
      tmp___4 = _IO_putc('a', cgiOut);
      }
#line 2476
      if (tmp___4 == -1) {
#line 2476
        return ((cgiFormResultType )12);
      }
      {
#line 2477
      tmp___5 = _IO_putc('m', cgiOut);
      }
#line 2477
      if (tmp___5 == -1) {
#line 2477
        return ((cgiFormResultType )12);
      }
      {
#line 2478
      tmp___6 = _IO_putc('p', cgiOut);
      }
#line 2478
      if (tmp___6 == -1) {
#line 2478
        return ((cgiFormResultType )12);
      }
      {
#line 2479
      tmp___7 = _IO_putc(';', cgiOut);
      }
#line 2479
      if (tmp___7 == -1) {
#line 2479
        return ((cgiFormResultType )12);
      }
    } else
#line 2480
    if ((int )*data == 62) {
      {
#line 2481
      tmp___8 = _IO_putc('&', cgiOut);
      }
#line 2481
      if (tmp___8 == -1) {
#line 2481
        return ((cgiFormResultType )12);
      }
      {
#line 2482
      tmp___9 = _IO_putc('g', cgiOut);
      }
#line 2482
      if (tmp___9 == -1) {
#line 2482
        return ((cgiFormResultType )12);
      }
      {
#line 2483
      tmp___10 = _IO_putc('t', cgiOut);
      }
#line 2483
      if (tmp___10 == -1) {
#line 2483
        return ((cgiFormResultType )12);
      }
      {
#line 2484
      tmp___11 = _IO_putc(';', cgiOut);
      }
#line 2484
      if (tmp___11 == -1) {
#line 2484
        return ((cgiFormResultType )12);
      }
    } else {
      {
#line 2486
      tmp___12 = _IO_putc((int )*data, cgiOut);
      }
#line 2486
      if (tmp___12 == -1) {
#line 2486
        return ((cgiFormResultType )12);
      }
    }
#line 2488
    data ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2490
  return ((cgiFormResultType )0);
}
}
#line 2493 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiHtmlEscape(char *s ) 
{ 
  size_t tmp ;
  cgiFormResultType tmp___0 ;

  {
  {
#line 2495
  tmp = strlen((char const   *)s);
#line 2495
  tmp___0 = cgiHtmlEscapeData(s, (int )tmp);
  }
#line 2495
  return (tmp___0);
}
}
#line 2504 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiValueEscapeData(char *data , int len ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 2506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2506
    tmp___5 = len;
#line 2506
    len --;
#line 2506
    if (! tmp___5) {
#line 2506
      goto while_break;
    }
#line 2507
    if ((int )*data == 34) {
      {
#line 2508
      tmp = _IO_putc('&', cgiOut);
      }
#line 2508
      if (tmp == -1) {
#line 2508
        return ((cgiFormResultType )12);
      }
      {
#line 2509
      tmp___0 = _IO_putc('#', cgiOut);
      }
#line 2509
      if (tmp___0 == -1) {
#line 2509
        return ((cgiFormResultType )12);
      }
      {
#line 2510
      tmp___1 = _IO_putc('3', cgiOut);
      }
#line 2510
      if (tmp___1 == -1) {
#line 2510
        return ((cgiFormResultType )12);
      }
      {
#line 2511
      tmp___2 = _IO_putc('4', cgiOut);
      }
#line 2511
      if (tmp___2 == -1) {
#line 2511
        return ((cgiFormResultType )12);
      }
      {
#line 2512
      tmp___3 = _IO_putc(';', cgiOut);
      }
#line 2512
      if (tmp___3 == -1) {
#line 2512
        return ((cgiFormResultType )12);
      }
    } else {
      {
#line 2514
      tmp___4 = _IO_putc((int )*data, cgiOut);
      }
#line 2514
      if (tmp___4 == -1) {
#line 2514
        return ((cgiFormResultType )12);
      }
    }
#line 2516
    data ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2518
  return ((cgiFormResultType )0);
}
}
#line 2521 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
cgiFormResultType cgiValueEscape(char *s ) 
{ 
  size_t tmp ;
  cgiFormResultType tmp___0 ;

  {
  {
#line 2523
  tmp = strlen((char const   *)s);
#line 2523
  tmp___0 = cgiValueEscapeData(s, (int )tmp);
  }
#line 2523
  return (tmp___0);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static int cgiRestored___0  =    0;
#line 76
static void cgiGetenv___0(char **s , char *var ) ;
#line 111 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static cgiFormEntry *cgiFormEntryFirst___0  ;
#line 113
static cgiParseResultType cgiParseGetFormInput___0(void) ;
#line 114
static cgiParseResultType cgiParsePostFormInput___0(void) ;
#line 115
static cgiParseResultType cgiParsePostMultipartInput___0(void) ;
#line 116
static cgiParseResultType cgiParseFormInput___0(char *data , int length ) ;
#line 117
static void cgiSetupConstants___0(void) ;
#line 118
static void cgiFreeResources___0(void) ;
#line 119
static int cgiStrEqNc___0(char *s1 , char *s2 ) ;
#line 120
static int cgiStrBeginsNc___0(char *s1 , char *s2 ) ;
#line 292 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static void cgiGetenv___0(char **s , char *var ) 
{ 


  {
  {
#line 293
  *s = getenv((char const   *)var);
  }
#line 294
  if (! *s) {
#line 295
    *s = (char *)"";
  }
#line 297
  return;
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static cgiParseResultType cgiParsePostFormInput___0(void) 
{ 
  char *input ;
  cgiParseResultType result ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 302
  if (! cgiContentLength) {
#line 303
    return ((cgiParseResultType )0);
  }
  {
#line 305
  tmp = malloc((size_t )cgiContentLength);
#line 305
  input = (char *)tmp;
  }
#line 306
  if (! input) {
#line 307
    return ((cgiParseResultType )1);
  }
  {
#line 309
  tmp___0 = fread((void */* __restrict  */)input, (size_t )1, (size_t )cgiContentLength,
                  (FILE */* __restrict  */)cgiIn);
  }
#line 309
  if ((int )tmp___0 != cgiContentLength) {
#line 312
    return ((cgiParseResultType )2);
  }
  {
#line 314
  result = cgiParseFormInput___0(input, cgiContentLength);
#line 315
  free((void *)input);
  }
#line 316
  return (result);
}
}
#line 406
static cgiParseResultType afterNextBoundary___0(mpStreamPtr mpp , FILE *outf , char **outP ,
                                                int *bodyLengthP , int first ) ;
#line 413
static int readHeaderLine___0(mpStreamPtr mpp , char *attr , int attrSpace , char *value ,
                              int valueSpace ) ;
#line 420
static void decomposeValue___0(char *value , char *mvalue , int mvalueSpace , char **argNames ,
                               char **argValues , int argValueSpace ) ;
#line 432
static cgiParseResultType getTempFileName___0(char *tfileName ) ;
#line 434 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static cgiParseResultType cgiParsePostMultipartInput___0(void) 
{ 
  cgiParseResultType result ;
  cgiFormEntry *n ;
  cgiFormEntry *l ;
  int got ;
  FILE *outf ;
  char *out ;
  char tfileName[1024] ;
  mpStream mp ;
  mpStreamPtr mpp ;
  char d[1024] ;
  char fvalue[1024] ;
  char fname[1024] ;
  int bodyLength ;
  char ffileName[1024] ;
  char fcontentType[1024] ;
  char attr[1024] ;
  char value[1024] ;
  char *argNames[3] ;
  char *argValues[2] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  cgiParseResultType tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;

  {
  {
#line 436
  n = (cgiFormEntry *)0;
#line 436
  l = (cgiFormEntry *)0;
#line 438
  outf = (FILE *)0;
#line 439
  out = (char *)0;
#line 442
  mpp = & mp;
#line 443
  memset((void *)(& mp), 0, sizeof(mp));
  }
#line 444
  if (! cgiContentLength) {
#line 445
    return ((cgiParseResultType )0);
  }
  {
#line 448
  result = afterNextBoundary___0(mpp, (FILE *)0, (char **)0, (int *)0, 1);
  }
#line 449
  if ((unsigned int )result == 2U) {
#line 451
    return ((cgiParseResultType )0);
  } else
#line 452
  if ((unsigned int )result != 0U) {
#line 453
    return (result);
  }
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 459
    bodyLength = 0;
#line 464
    fvalue[0] = (char)0;
#line 465
    fname[0] = (char)0;
#line 466
    ffileName[0] = (char)0;
#line 467
    fcontentType[0] = (char)0;
#line 468
    out = (char *)0;
#line 469
    outf = (FILE *)0;
#line 471
    got = mpRead(mpp, d, 2);
    }
#line 472
    if (got < 2) {
#line 474
      goto while_break;
    }
#line 476
    if ((int )d[0] == 45) {
#line 476
      if ((int )d[1] == 45) {
#line 478
        goto while_break;
      }
    }
    {
#line 480
    mpPutBack(mpp, d, 2);
    }
    {
#line 482
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 482
      tmp___1 = readHeaderLine___0(mpp, attr, (int )sizeof(attr), value, (int )sizeof(value));
      }
#line 482
      if (! tmp___1) {
#line 482
        goto while_break___0;
      }
      {
#line 489
      tmp___0 = cgiStrEqNc___0(attr, (char *)"Content-Disposition");
      }
#line 489
      if (tmp___0) {
        {
#line 490
        argNames[0] = (char *)"name";
#line 491
        argNames[1] = (char *)"filename";
#line 492
        argNames[2] = (char *)0;
#line 493
        argValues[0] = fname;
#line 494
        argValues[1] = ffileName;
#line 495
        decomposeValue___0(value, fvalue, (int )sizeof(fvalue), argNames, argValues,
                           1024);
        }
      } else {
        {
#line 500
        tmp = cgiStrEqNc___0(attr, (char *)"Content-Type");
        }
#line 500
        if (tmp) {
          {
#line 501
          argNames[0] = (char *)0;
#line 502
          decomposeValue___0(value, fcontentType, (int )sizeof(fcontentType), argNames,
                             (char **)0, 0);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 509
    tmp___2 = cgiStrEqNc___0(fvalue, (char *)"form-data");
    }
#line 509
    if (! tmp___2) {
#line 511
      goto while_continue;
    }
    {
#line 519
    tmp___4 = strlen((char const   *)(ffileName));
    }
#line 519
    if (tmp___4) {
      {
#line 520
      tmp___3 = getTempFileName___0(tfileName);
      }
#line 520
      if ((unsigned int )tmp___3 != 0U) {
#line 521
        return ((cgiParseResultType )2);
      }
      {
#line 523
      outf = fopen((char const   */* __restrict  */)(tfileName), (char const   */* __restrict  */)"w+b");
      }
    } else {
#line 525
      outf = (FILE *)0;
#line 526
      tfileName[0] = (char )'\000';
    }
    {
#line 528
    result = afterNextBoundary___0(mpp, outf, & out, & bodyLength, 0);
    }
#line 529
    if ((unsigned int )result != 0U) {
#line 531
      if (outf) {
        {
#line 532
        fclose(outf);
#line 533
        unlink((char const   *)(tfileName));
        }
      }
#line 535
      if (out) {
        {
#line 536
        free((void *)out);
        }
      }
#line 538
      return (result);
    }
    {
#line 541
    tmp___5 = malloc(sizeof(cgiFormEntry ));
#line 541
    n = (cgiFormEntry *)tmp___5;
    }
#line 542
    if (! n) {
#line 543
      goto outOfMemory;
    }
    {
#line 545
    memset((void *)n, 0, sizeof(cgiFormEntry ));
#line 548
    tmp___6 = strlen((char const   *)(fname));
#line 548
    tmp___7 = malloc(tmp___6 + 1UL);
#line 548
    n->attr = (char *)tmp___7;
    }
#line 549
    if (! n->attr) {
#line 550
      goto outOfMemory;
    }
    {
#line 552
    strcpy((char */* __restrict  */)n->attr, (char const   */* __restrict  */)(fname));
    }
#line 553
    if (out) {
#line 554
      n->value = out;
#line 555
      out = (char *)0;
    } else
#line 556
    if (outf) {
      {
#line 557
      tmp___8 = malloc((size_t )1);
#line 557
      n->value = (char *)tmp___8;
      }
#line 558
      if (! n->value) {
#line 559
        goto outOfMemory;
      }
      {
#line 561
      *(n->value + 0) = (char )'\000';
#line 562
      fclose(outf);
      }
    }
#line 564
    n->valueLength = bodyLength;
#line 565
    n->next = (struct cgiFormEntryStruct *)0;
#line 566
    if (! l) {
#line 567
      cgiFormEntryFirst___0 = n;
    } else {
#line 569
      l->next = n;
    }
    {
#line 571
    tmp___9 = strlen((char const   *)(ffileName));
#line 571
    tmp___10 = malloc(tmp___9 + 1UL);
#line 571
    n->fileName = (char *)tmp___10;
    }
#line 572
    if (! n->fileName) {
#line 573
      goto outOfMemory;
    }
    {
#line 575
    strcpy((char */* __restrict  */)n->fileName, (char const   */* __restrict  */)(ffileName));
#line 576
    tmp___11 = strlen((char const   *)(fcontentType));
#line 576
    tmp___12 = malloc(tmp___11 + 1UL);
#line 576
    n->contentType = (char *)tmp___12;
    }
#line 577
    if (! n->contentType) {
#line 578
      goto outOfMemory;
    }
    {
#line 580
    strcpy((char */* __restrict  */)n->contentType, (char const   */* __restrict  */)(fcontentType));
#line 581
    tmp___13 = strlen((char const   *)(tfileName));
#line 581
    tmp___14 = malloc(tmp___13 + 1UL);
#line 581
    n->tfileName = (char *)tmp___14;
    }
#line 582
    if (! n->tfileName) {
#line 583
      goto outOfMemory;
    }
    {
#line 585
    strcpy((char */* __restrict  */)n->tfileName, (char const   */* __restrict  */)(tfileName));
#line 587
    l = n;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 589
  return ((cgiParseResultType )0);
  outOfMemory: 
#line 591
  if (n) {
#line 592
    if (n->attr) {
      {
#line 593
      free((void *)n->attr);
      }
    }
#line 595
    if (n->value) {
      {
#line 596
      free((void *)n->value);
      }
    }
#line 598
    if (n->fileName) {
      {
#line 599
      free((void *)n->fileName);
      }
    }
#line 601
    if (n->tfileName) {
      {
#line 602
      free((void *)n->tfileName);
      }
    }
#line 604
    if (n->contentType) {
      {
#line 605
      free((void *)n->contentType);
      }
    }
    {
#line 607
    free((void *)n);
    }
  }
#line 609
  if (out) {
    {
#line 610
    free((void *)out);
    }
  }
#line 612
  if (outf) {
    {
#line 613
    fclose(outf);
#line 614
    unlink((char const   *)(tfileName));
    }
  }
#line 616
  return ((cgiParseResultType )1);
}
}
#line 619 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static cgiParseResultType getTempFileName___0(char *tfileName ) 
{ 
  int outfd ;
  int tmp ;

  {
  {
#line 631
  strcpy((char */* __restrict  */)tfileName, (char const   */* __restrict  */)"/tmp/cgicXXXXXX");
#line 632
  outfd = mkstemp(tfileName);
  }
#line 633
  if (outfd == -1) {
#line 634
    return ((cgiParseResultType )2);
  }
  {
#line 636
  close(outfd);
#line 638
  tmp = chmod((char const   *)tfileName, (__mode_t )384);
  }
#line 638
  if (tmp != 0) {
    {
#line 639
    unlink((char const   *)tfileName);
    }
#line 640
    return ((cgiParseResultType )2);
  }
#line 648
  return ((cgiParseResultType )0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static cgiParseResultType afterNextBoundary___0(mpStreamPtr mpp , FILE *outf , char **outP ,
                                                int *bodyLengthP , int first ) 
{ 
  int outLen ;
  int outSpace ;
  char *out ;
  cgiParseResultType result ;
  int boffset ;
  int got ;
  char d[2] ;
  char workingBoundaryData[1024] ;
  char *workingBoundary ;
  int workingBoundaryLength ;
  void *tmp ;
  size_t tmp___0 ;
  char *sold ;
  void *tmp___1 ;
  int tmp___2 ;
  char *sold___0 ;
  void *tmp___3 ;
  int tmp___4 ;
  char *oout ;
  void *tmp___5 ;

  {
#line 686
  outLen = 0;
#line 687
  outSpace = 256;
#line 688
  out = (char *)0;
#line 698
  workingBoundary = workingBoundaryData;
#line 700
  if (! outf) {
#line 700
    if (outP) {
      {
#line 701
      tmp = malloc((size_t )outSpace);
#line 701
      out = (char *)tmp;
      }
#line 702
      if (! out) {
#line 703
        goto outOfMemory;
      }
    }
  }
  {
#line 706
  boffset = 0;
#line 707
  sprintf((char */* __restrict  */)(workingBoundaryData), (char const   */* __restrict  */)"\r\n--%s",
          cgiMultipartBoundary);
  }
#line 708
  if (first) {
#line 709
    workingBoundary = workingBoundaryData + 2;
  }
  {
#line 711
  tmp___0 = strlen((char const   *)workingBoundary);
#line 711
  workingBoundaryLength = (int )tmp___0;
  }
  {
#line 712
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 713
    got = mpRead(mpp, d, 1);
    }
#line 714
    if (got != 1) {
#line 716
      result = (cgiParseResultType )2;
#line 717
      goto error;
    }
#line 719
    if ((int )d[0] == (int )*(workingBoundary + boffset)) {
#line 723
      boffset ++;
#line 724
      if (boffset == workingBoundaryLength) {
#line 725
        goto while_break;
      }
    } else
#line 727
    if (boffset > 0) {
#line 735
      if (outf) {
        {
#line 735
        _IO_putc((int )*(workingBoundary + 0), outf);
#line 735
        outLen ++;
        }
      } else
#line 735
      if (out) {
#line 735
        if (outLen + 1 == outSpace) {
          {
#line 735
          sold = out;
#line 735
          outSpace *= 2;
#line 735
          tmp___1 = realloc((void *)out, (size_t )outSpace);
#line 735
          out = (char *)tmp___1;
          }
#line 735
          if (! out) {
#line 735
            out = sold;
#line 735
            goto outOfMemory;
          }
        }
#line 735
        tmp___2 = outLen;
#line 735
        outLen ++;
#line 735
        *(out + tmp___2) = *(workingBoundary + 0);
      }
      {
#line 736
      mpPutBack(mpp, workingBoundary + 1, boffset - 1);
#line 738
      mpPutBack(mpp, d, 1);
#line 739
      boffset = 0;
      }
    } else
#line 743
    if (outf) {
      {
#line 743
      _IO_putc((int )d[0], outf);
#line 743
      outLen ++;
      }
    } else
#line 743
    if (out) {
#line 743
      if (outLen + 1 == outSpace) {
        {
#line 743
        sold___0 = out;
#line 743
        outSpace *= 2;
#line 743
        tmp___3 = realloc((void *)out, (size_t )outSpace);
#line 743
        out = (char *)tmp___3;
        }
#line 743
        if (! out) {
#line 743
          out = sold___0;
#line 743
          goto outOfMemory;
        }
      }
#line 743
      tmp___4 = outLen;
#line 743
      outLen ++;
#line 743
      *(out + tmp___4) = d[0];
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 748
  got = mpRead(mpp, d, 2);
  }
#line 749
  if (got != 2) {
#line 750
    result = (cgiParseResultType )2;
#line 751
    goto error;
  }
#line 753
  if ((int )d[0] == 13) {
#line 753
    if (! ((int )d[1] == 10)) {
#line 753
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 755
  if ((int )d[0] == 45) {
    {
#line 758
    mpPutBack(mpp, d, 2);
    }
  }
#line 760
  if (out) {
#line 760
    if (outSpace) {
      {
#line 761
      oout = out;
#line 762
      *(out + outLen) = (char )'\000';
#line 763
      tmp___5 = realloc((void *)out, (size_t )(outLen + 1));
#line 763
      out = (char *)tmp___5;
      }
#line 764
      if (! out) {
#line 768
        out = oout;
      }
#line 770
      *outP = out;
    }
  }
#line 772
  if (bodyLengthP) {
#line 773
    *bodyLengthP = outLen;
  }
#line 775
  return ((cgiParseResultType )0);
  outOfMemory: 
#line 777
  result = (cgiParseResultType )1;
#line 778
  if (outP) {
#line 779
    if (out) {
      {
#line 780
      free((void *)out);
      }
    }
#line 782
    *outP = (char *)'\000';
  }
  error: 
#line 785
  if (bodyLengthP) {
#line 786
    *bodyLengthP = 0;
  }
#line 788
  if (out) {
    {
#line 789
    free((void *)out);
    }
  }
#line 791
  if (outP) {
#line 792
    *outP = (char *)0;
  }
#line 794
  return (result);
}
}
#line 797 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static void decomposeValue___0(char *value , char *mvalue , int mvalueSpace , char **argNames ,
                               char **argValues , int argValueSpace ) 
{ 
  char argName[1024] ;
  int argNameSpace ;
  int argNameLen ;
  int mvalueLen ;
  char *argValue ;
  int argNum ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int argNum___0 ;
  int argValueLen ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 804
  argNameSpace = (int )sizeof(argName);
#line 805
  argNameLen = 0;
#line 806
  mvalueLen = 0;
#line 808
  argNum = 0;
  {
#line 809
  while (1) {
    while_continue: /* CIL Label */ ;
#line 809
    if (! *(argNames + argNum)) {
#line 809
      goto while_break;
    }
#line 810
    if (argValueSpace) {
#line 811
      *(*(argValues + argNum) + 0) = (char )'\000';
    }
#line 813
    argNum ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 815
    tmp = __ctype_b_loc();
    }
#line 815
    if (! ((int const   )*(*tmp + (int )*value) & 8192)) {
#line 815
      goto while_break___0;
    }
#line 816
    value ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 819
  if ((int )*value == 34) {
#line 820
    value ++;
    {
#line 821
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 821
      if (*value) {
#line 821
        if (! ((int )*value != 34)) {
#line 821
          goto while_break___1;
        }
      } else {
#line 821
        goto while_break___1;
      }
#line 822
      if (mvalueLen + 1 < mvalueSpace) {
#line 822
        tmp___0 = mvalueLen;
#line 822
        mvalueLen ++;
#line 822
        *(mvalue + tmp___0) = *value;
      }
#line 823
      value ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 825
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 825
      if (*value) {
#line 825
        if (! ((int )*value != 59)) {
#line 825
          goto while_break___2;
        }
      } else {
#line 825
        goto while_break___2;
      }
#line 826
      value ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 830
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 830
      if (*value) {
#line 830
        if (! ((int )*value != 59)) {
#line 830
          goto while_break___3;
        }
      } else {
#line 830
        goto while_break___3;
      }
#line 831
      if (mvalueLen + 1 < mvalueSpace) {
#line 831
        tmp___1 = mvalueLen;
#line 831
        mvalueLen ++;
#line 831
        *(mvalue + tmp___1) = *value;
      }
#line 832
      value ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 835
  if (mvalueSpace) {
#line 836
    *(mvalue + mvalueLen) = (char )'\000';
  }
  {
#line 838
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 838
    if (! ((int )*value == 59)) {
#line 838
      goto while_break___4;
    }
#line 840
    argValueLen = 0;
#line 842
    value ++;
    {
#line 844
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 844
      if (*value) {
        {
#line 844
        tmp___2 = __ctype_b_loc();
        }
#line 844
        if (! ((int const   )*(*tmp___2 + (int )*value) & 8192)) {
#line 844
          goto while_break___5;
        }
      } else {
#line 844
        goto while_break___5;
      }
#line 845
      value ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 848
    argNameLen = 0;
    {
#line 849
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 849
      if (*value) {
        {
#line 849
        tmp___4 = __ctype_b_loc();
        }
#line 849
        if (! ((int const   )*(*tmp___4 + (int )*value) & 8)) {
#line 849
          goto while_break___6;
        }
      } else {
#line 849
        goto while_break___6;
      }
#line 850
      if (argNameLen + 1 < argNameSpace) {
#line 850
        tmp___3 = argNameLen;
#line 850
        argNameLen ++;
#line 850
        argName[tmp___3] = *value;
      }
#line 851
      value ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 853
    if (argNameSpace) {
#line 854
      argName[argNameLen] = (char )'\000';
    }
    {
#line 856
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 856
      if (*value) {
        {
#line 856
        tmp___5 = __ctype_b_loc();
        }
#line 856
        if (! ((int const   )*(*tmp___5 + (int )*value) & 8192)) {
#line 856
          goto while_break___7;
        }
      } else {
#line 856
        goto while_break___7;
      }
#line 857
      value ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 859
    if ((int )*value != 61) {
#line 861
      return;
    }
#line 863
    value ++;
    {
#line 864
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 864
      if (*value) {
        {
#line 864
        tmp___6 = __ctype_b_loc();
        }
#line 864
        if (! ((int const   )*(*tmp___6 + (int )*value) & 8192)) {
#line 864
          goto while_break___8;
        }
      } else {
#line 864
        goto while_break___8;
      }
#line 865
      value ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 868
    argNum___0 = 0;
#line 869
    argValue = (char *)0;
    {
#line 870
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 870
      if (! *(argNames + argNum___0)) {
#line 870
        goto while_break___9;
      }
      {
#line 871
      tmp___7 = cgiStrEqNc___0(argName, *(argNames + argNum___0));
      }
#line 871
      if (tmp___7) {
#line 872
        argValue = *(argValues + argNum___0);
#line 873
        goto while_break___9;
      }
#line 875
      argNum___0 ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 878
    if ((int )*value == 34) {
#line 879
      value ++;
      {
#line 880
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 880
        if (*value) {
#line 880
          if (! ((int )*value != 34)) {
#line 880
            goto while_break___10;
          }
        } else {
#line 880
          goto while_break___10;
        }
#line 881
        if (argValue) {
#line 882
          if (argValueLen + 1 < argValueSpace) {
#line 882
            tmp___8 = argValueLen;
#line 882
            argValueLen ++;
#line 882
            *(argValue + tmp___8) = *value;
          }
        }
#line 884
        value ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 886
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 886
        if (*value) {
#line 886
          if (! ((int )*value != 59)) {
#line 886
            goto while_break___11;
          }
        } else {
#line 886
          goto while_break___11;
        }
#line 887
        value ++;
      }
      while_break___11: /* CIL Label */ ;
      }
    } else {
      {
#line 891
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 891
        if (*value) {
#line 891
          if (! ((int )*value != 59)) {
#line 891
            goto while_break___12;
          }
        } else {
#line 891
          goto while_break___12;
        }
#line 892
        if (*(argNames + argNum___0)) {
#line 893
          if (argValueLen + 1 < argValueSpace) {
#line 893
            tmp___9 = argValueLen;
#line 893
            argValueLen ++;
#line 893
            *(argValue + tmp___9) = *value;
          }
        }
#line 895
        value ++;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 898
    if (argValueSpace) {
#line 899
      *(argValue + argValueLen) = (char )'\000';
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 902
  return;
}
}
#line 904 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static int readHeaderLine___0(mpStreamPtr mpp , char *attr , int attrSpace , char *value ,
                              int valueSpace ) 
{ 
  int attrLen ;
  int valueLen ;
  int valueFound ;
  char d[1] ;
  int got ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;

  {
#line 911
  attrLen = 0;
#line 912
  valueLen = 0;
#line 913
  valueFound = 0;
  {
#line 914
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 916
    tmp = mpRead(mpp, d, 1);
#line 916
    got = tmp;
    }
#line 917
    if (got != 1) {
#line 918
      return (0);
    }
#line 920
    if ((int )d[0] == 13) {
      {
#line 921
      got = mpRead(mpp, d, 1);
      }
#line 922
      if (got == 1) {
#line 923
        if (! ((int )d[0] == 10)) {
          {
#line 926
          mpPutBack(mpp, d, 1);
          }
        }
      }
#line 929
      goto while_break;
    } else
#line 930
    if ((int )d[0] == 10) {
#line 931
      goto while_break;
    } else
#line 932
    if ((int )d[0] == 58) {
#line 932
      if (attrLen) {
#line 933
        valueFound = 1;
        {
#line 934
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 934
          tmp___1 = mpRead(mpp, d, 1);
          }
#line 934
          if (! (tmp___1 == 1)) {
#line 934
            goto while_break___0;
          }
          {
#line 935
          tmp___0 = __ctype_b_loc();
          }
#line 935
          if (! ((int const   )*(*tmp___0 + (int )d[0]) & 8192)) {
            {
#line 936
            mpPutBack(mpp, d, 1);
            }
#line 937
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 932
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 940
    if (! valueFound) {
      {
#line 941
      tmp___3 = __ctype_b_loc();
      }
#line 941
      if (! ((int const   )*(*tmp___3 + (int )d[0]) & 8192)) {
#line 942
        if (attrLen < attrSpace - 1) {
#line 943
          tmp___2 = attrLen;
#line 943
          attrLen ++;
#line 943
          *(attr + tmp___2) = d[0];
        }
      }
    } else
#line 946
    if (valueFound) {
#line 947
      if (valueLen < valueSpace - 1) {
#line 948
        tmp___4 = valueLen;
#line 948
        valueLen ++;
#line 948
        *(value + tmp___4) = d[0];
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 952
  if (attrSpace) {
#line 953
    *(attr + attrLen) = (char )'\000';
  }
#line 955
  if (valueSpace) {
#line 956
    *(value + valueLen) = (char )'\000';
  }
#line 958
  if (attrLen) {
#line 958
    if (valueLen) {
#line 959
      return (1);
    } else {
#line 961
      return (0);
    }
  } else {
#line 961
    return (0);
  }
}
}
#line 965 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static cgiParseResultType cgiParseGetFormInput___0(void) 
{ 
  cgiParseResultType tmp ;

  {
  {
#line 966
  tmp = cgiParseFormInput___0(cgiQueryString, cgiContentLength);
  }
#line 966
  return (tmp);
}
}
#line 980
static cgiUnescapeResultType cgiUnescapeChars___0(char **sp , char *cp , int len ) ;
#line 982 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static cgiParseResultType cgiParseFormInput___0(char *data , int length ) 
{ 
  int pos ;
  cgiFormEntry *n ;
  cgiFormEntry *l ;
  int foundEq ;
  int foundAmp ;
  int start ;
  int len ;
  char *attr ;
  char *value ;
  cgiUnescapeResultType tmp ;
  cgiUnescapeResultType tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 984
  pos = 0;
#line 986
  l = (cgiFormEntry *)0;
  {
#line 987
  while (1) {
    while_continue: /* CIL Label */ ;
#line 987
    if (! (pos != length)) {
#line 987
      goto while_break;
    }
#line 988
    foundEq = 0;
#line 989
    foundAmp = 0;
#line 990
    start = pos;
#line 991
    len = 0;
    {
#line 994
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 994
      if (! (pos != length)) {
#line 994
        goto while_break___0;
      }
#line 995
      if ((int )*(data + pos) == 61) {
#line 996
        foundEq = 1;
#line 997
        pos ++;
#line 998
        goto while_break___0;
      }
#line 1000
      pos ++;
#line 1001
      len ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1003
    if (! foundEq) {
#line 1004
      goto while_break;
    }
    {
#line 1006
    tmp = cgiUnescapeChars___0(& attr, data + start, len);
    }
#line 1006
    if ((unsigned int )tmp != 0U) {
#line 1008
      return ((cgiParseResultType )1);
    }
#line 1010
    start = pos;
#line 1011
    len = 0;
    {
#line 1012
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1012
      if (! (pos != length)) {
#line 1012
        goto while_break___1;
      }
#line 1013
      if ((int )*(data + pos) == 38) {
#line 1014
        foundAmp = 1;
#line 1015
        pos ++;
#line 1016
        goto while_break___1;
      }
#line 1018
      pos ++;
#line 1019
      len ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1023
    tmp___0 = cgiUnescapeChars___0(& value, data + start, len);
    }
#line 1023
    if ((unsigned int )tmp___0 != 0U) {
      {
#line 1025
      free((void *)attr);
      }
#line 1026
      return ((cgiParseResultType )1);
    }
    {
#line 1029
    tmp___1 = malloc(sizeof(cgiFormEntry ));
#line 1029
    n = (cgiFormEntry *)tmp___1;
    }
#line 1030
    if (! n) {
      {
#line 1031
      free((void *)attr);
#line 1032
      free((void *)value);
      }
#line 1033
      return ((cgiParseResultType )1);
    }
    {
#line 1035
    n->attr = attr;
#line 1036
    n->value = value;
#line 1037
    tmp___2 = strlen((char const   *)n->value);
#line 1037
    n->valueLength = (int )tmp___2;
#line 1038
    tmp___3 = malloc((size_t )1);
#line 1038
    n->fileName = (char *)tmp___3;
    }
#line 1039
    if (! n->fileName) {
      {
#line 1040
      free((void *)attr);
#line 1041
      free((void *)value);
#line 1042
      free((void *)n);
      }
#line 1043
      return ((cgiParseResultType )1);
    }
    {
#line 1045
    *(n->fileName + 0) = (char )'\000';
#line 1046
    tmp___4 = malloc((size_t )1);
#line 1046
    n->contentType = (char *)tmp___4;
    }
#line 1047
    if (! n->contentType) {
      {
#line 1048
      free((void *)attr);
#line 1049
      free((void *)value);
#line 1050
      free((void *)n->fileName);
#line 1051
      free((void *)n);
      }
#line 1052
      return ((cgiParseResultType )1);
    }
    {
#line 1054
    *(n->contentType + 0) = (char )'\000';
#line 1055
    tmp___5 = malloc((size_t )1);
#line 1055
    n->tfileName = (char *)tmp___5;
    }
#line 1056
    if (! n->tfileName) {
      {
#line 1057
      free((void *)attr);
#line 1058
      free((void *)value);
#line 1059
      free((void *)n->fileName);
#line 1060
      free((void *)n->contentType);
#line 1061
      free((void *)n);
      }
#line 1062
      return ((cgiParseResultType )1);
    }
#line 1064
    *(n->tfileName + 0) = (char )'\000';
#line 1065
    n->next = (struct cgiFormEntryStruct *)0;
#line 1066
    if (! l) {
#line 1067
      cgiFormEntryFirst___0 = n;
    } else {
#line 1069
      l->next = n;
    }
#line 1071
    l = n;
#line 1072
    if (! foundAmp) {
#line 1073
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1076
  return ((cgiParseResultType )0);
}
}
#line 1079 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static int cgiHexValue___0[256]  ;
#line 1081 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static cgiUnescapeResultType cgiUnescapeChars___0(char **sp , char *cp , int len ) 
{ 
  char *s ;
  cgiEscapeState escapeState ;
  int escapedValue ;
  int srcPos ;
  int dstPos ;
  void *tmp ;
  int ch ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1083
  escapeState = (cgiEscapeState )0;
#line 1084
  escapedValue = 0;
#line 1085
  srcPos = 0;
#line 1086
  dstPos = 0;
#line 1087
  tmp = malloc((size_t )(len + 1));
#line 1087
  s = (char *)tmp;
  }
#line 1088
  if (! s) {
#line 1089
    return ((cgiUnescapeResultType )1);
  }
  {
#line 1091
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1091
    if (! (srcPos < len)) {
#line 1091
      goto while_break;
    }
#line 1092
    ch = (int )*(cp + srcPos);
    {
#line 1094
    if ((unsigned int )escapeState == 0U) {
#line 1094
      goto case_0;
    }
#line 1103
    if ((unsigned int )escapeState == 1U) {
#line 1103
      goto case_1;
    }
#line 1107
    if ((unsigned int )escapeState == 2U) {
#line 1107
      goto case_2;
    }
#line 1093
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1095
    if (ch == 37) {
#line 1096
      escapeState = (cgiEscapeState )1;
    } else
#line 1097
    if (ch == 43) {
#line 1098
      tmp___0 = dstPos;
#line 1098
      dstPos ++;
#line 1098
      *(s + tmp___0) = (char )' ';
    } else {
#line 1100
      tmp___1 = dstPos;
#line 1100
      dstPos ++;
#line 1100
      *(s + tmp___1) = (char )ch;
    }
#line 1102
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1104
    escapedValue = cgiHexValue___0[ch] << 4;
#line 1105
    escapeState = (cgiEscapeState )2;
#line 1106
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1108
    escapedValue += cgiHexValue___0[ch];
#line 1109
    tmp___2 = dstPos;
#line 1109
    dstPos ++;
#line 1109
    *(s + tmp___2) = (char )escapedValue;
#line 1110
    escapeState = (cgiEscapeState )0;
#line 1111
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1113
    srcPos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1115
  *(s + dstPos) = (char )'\000';
#line 1116
  *sp = s;
#line 1117
  return ((cgiUnescapeResultType )0);
}
}
#line 1120 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static void cgiSetupConstants___0(void) 
{ 
  int i ;

  {
#line 1122
  i = 0;
  {
#line 1122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1122
    if (! (i < 256)) {
#line 1122
      goto while_break;
    }
#line 1123
    cgiHexValue___0[i] = 0;
#line 1122
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1125
  cgiHexValue___0['0'] = 0;
#line 1126
  cgiHexValue___0['1'] = 1;
#line 1127
  cgiHexValue___0['2'] = 2;
#line 1128
  cgiHexValue___0['3'] = 3;
#line 1129
  cgiHexValue___0['4'] = 4;
#line 1130
  cgiHexValue___0['5'] = 5;
#line 1131
  cgiHexValue___0['6'] = 6;
#line 1132
  cgiHexValue___0['7'] = 7;
#line 1133
  cgiHexValue___0['8'] = 8;
#line 1134
  cgiHexValue___0['9'] = 9;
#line 1135
  cgiHexValue___0['A'] = 10;
#line 1136
  cgiHexValue___0['B'] = 11;
#line 1137
  cgiHexValue___0['C'] = 12;
#line 1138
  cgiHexValue___0['D'] = 13;
#line 1139
  cgiHexValue___0['E'] = 14;
#line 1140
  cgiHexValue___0['F'] = 15;
#line 1141
  cgiHexValue___0['a'] = 10;
#line 1142
  cgiHexValue___0['b'] = 11;
#line 1143
  cgiHexValue___0['c'] = 12;
#line 1144
  cgiHexValue___0['d'] = 13;
#line 1145
  cgiHexValue___0['e'] = 14;
#line 1146
  cgiHexValue___0['f'] = 15;
#line 1147
  return;
}
}
#line 1149 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static void cgiFreeResources___0(void) 
{ 
  cgiFormEntry *c ;
  cgiFormEntry *n ;
  size_t tmp ;

  {
#line 1150
  c = cgiFormEntryFirst___0;
  {
#line 1152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1152
    if (! c) {
#line 1152
      goto while_break;
    }
    {
#line 1153
    n = c->next;
#line 1154
    free((void *)c->attr);
#line 1155
    free((void *)c->value);
#line 1156
    free((void *)c->fileName);
#line 1157
    free((void *)c->contentType);
#line 1158
    tmp = strlen((char const   *)c->tfileName);
    }
#line 1158
    if (tmp) {
      {
#line 1159
      unlink((char const   *)c->tfileName);
      }
    }
    {
#line 1161
    free((void *)c->tfileName);
#line 1162
    free((void *)c);
#line 1163
    c = n;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1167
  if (cgiRestored___0) {
    {
#line 1168
    free((void *)cgiServerSoftware);
#line 1169
    free((void *)cgiServerName);
#line 1170
    free((void *)cgiGatewayInterface);
#line 1171
    free((void *)cgiServerProtocol);
#line 1172
    free((void *)cgiServerPort);
#line 1173
    free((void *)cgiRequestMethod);
#line 1174
    free((void *)cgiPathInfo);
#line 1175
    free((void *)cgiPathTranslated);
#line 1176
    free((void *)cgiScriptName);
#line 1177
    free((void *)cgiQueryString);
#line 1178
    free((void *)cgiRemoteHost);
#line 1179
    free((void *)cgiRemoteAddr);
#line 1180
    free((void *)cgiAuthType);
#line 1181
    free((void *)cgiRemoteUser);
#line 1182
    free((void *)cgiRemoteIdent);
#line 1183
    free((void *)cgiContentType);
#line 1184
    free((void *)cgiAccept);
#line 1185
    free((void *)cgiUserAgent);
#line 1186
    free((void *)cgiReferrer);
    }
  }
#line 1190
  cgiFormEntryFirst___0 = (cgiFormEntry *)0;
#line 1191
  cgiRestored___0 = 0;
#line 1192
  return;
}
}
#line 1194
static cgiFormResultType cgiFormEntryString___0(cgiFormEntry *e , char *result , int max ,
                                                int newlines ) ;
#line 1197
static cgiFormEntry *cgiFormEntryFindFirst___0(char *name ) ;
#line 1198
static cgiFormEntry *cgiFormEntryFindNext___0(void) ;
#line 1437 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static cgiFormResultType cgiFormEntryString___0(cgiFormEntry *e , char *result , int max ,
                                                int newlines ) 
{ 
  char *dp ;
  char *sp ;
  int truncated ;
  int len ;
  int avail ;
  int crCount ;
  int lfCount ;
  int ch ;
  int lfsAdd ;

  {
#line 1440
  truncated = 0;
#line 1441
  len = 0;
#line 1442
  avail = max - 1;
#line 1443
  crCount = 0;
#line 1444
  lfCount = 0;
#line 1445
  dp = result;
#line 1446
  sp = e->value;
  {
#line 1447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1454
    ch = (int )*sp;
#line 1461
    if (ch == 13) {
#line 1461
      goto _L___0;
    } else
#line 1461
    if (ch == 10) {
      _L___0: /* CIL Label */ 
#line 1462
      if (ch == 13) {
#line 1463
        crCount ++;
      } else {
#line 1465
        lfCount ++;
      }
    } else {
#line 1468
      if (crCount) {
#line 1468
        goto _L;
      } else
#line 1468
      if (lfCount) {
        _L: /* CIL Label */ 
#line 1469
        lfsAdd = crCount;
#line 1470
        if (lfCount > crCount) {
#line 1471
          lfsAdd = lfCount;
        }
#line 1474
        if (! newlines) {
#line 1475
          lfsAdd = 0;
        }
        {
#line 1477
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1477
          if (! lfsAdd) {
#line 1477
            goto while_break___0;
          }
#line 1478
          if (len >= avail) {
#line 1479
            truncated = 1;
#line 1480
            goto while_break___0;
          }
#line 1482
          *dp = (char)10;
#line 1483
          dp ++;
#line 1484
          lfsAdd --;
#line 1485
          len ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1487
        crCount = 0;
#line 1488
        lfCount = 0;
      }
#line 1490
      if (ch == 0) {
#line 1492
        goto while_break;
      }
#line 1497
      if (len >= avail) {
#line 1498
        truncated = 1;
#line 1499
        goto while_break;
      }
#line 1501
      *dp = (char )ch;
#line 1502
      dp ++;
#line 1503
      len ++;
    }
#line 1505
    sp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1507
  *dp = (char )'\000';
#line 1508
  if (truncated) {
#line 1509
    return ((cgiFormResultType )1);
  } else
#line 1510
  if (! len) {
#line 1511
    return ((cgiFormResultType )3);
  } else {
#line 1513
    return ((cgiFormResultType )0);
  }
}
}
#line 1517
static int cgiFirstNonspaceChar___0(char *s ) ;
#line 1870
static int cgiWriteString___0(FILE *out , char *s ) ;
#line 1872
static int cgiWriteInt___0(FILE *out , int i ) ;
#line 2006 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static int cgiWriteString___0(FILE *out , char *s ) 
{ 
  int len ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 2007
  tmp = strlen((char const   *)s);
#line 2007
  len = (int )tmp;
#line 2008
  cgiWriteInt___0(out, len);
#line 2009
  tmp___0 = fwrite((void const   */* __restrict  */)s, (size_t )1, (size_t )len, (FILE */* __restrict  */)out);
  }
#line 2009
  if ((int )tmp___0 != len) {
#line 2010
    return (0);
  }
#line 2012
  return (1);
}
}
#line 2015 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static int cgiWriteInt___0(FILE *out , int i ) 
{ 
  size_t tmp ;

  {
  {
#line 2016
  tmp = fwrite((void const   */* __restrict  */)(& i), sizeof(int ), (size_t )1, (FILE */* __restrict  */)out);
  }
#line 2016
  if (! tmp) {
#line 2017
    return (0);
  }
#line 2019
  return (1);
}
}
#line 2022
static int cgiReadString___0(FILE *in , char **s ) ;
#line 2024
static int cgiReadInt___0(FILE *out , int *i ) ;
#line 2238 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static int cgiReadString___0(FILE *in , char **s ) 
{ 
  int len ;
  int tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 2241
  tmp = cgiReadInt___0(in, & len);
  }
#line 2241
  if (! tmp) {
#line 2242
    return (0);
  }
  {
#line 2244
  tmp___0 = malloc((size_t )(len + 1));
#line 2244
  *s = (char *)tmp___0;
  }
#line 2245
  if (! *s) {
#line 2246
    return (0);
  }
  {
#line 2248
  tmp___1 = fread((void */* __restrict  */)*s, (size_t )1, (size_t )len, (FILE */* __restrict  */)in);
  }
#line 2248
  if ((int )tmp___1 != len) {
#line 2249
    return (0);
  }
#line 2251
  *(*s + len) = (char )'\000';
#line 2252
  return (1);
}
}
#line 2255 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static int cgiReadInt___0(FILE *out , int *i ) 
{ 
  size_t tmp ;

  {
  {
#line 2256
  tmp = fread((void */* __restrict  */)i, sizeof(int ), (size_t )1, (FILE */* __restrict  */)out);
  }
#line 2256
  if (! tmp) {
#line 2257
    return (0);
  }
#line 2259
  return (1);
}
}
#line 2262 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static int cgiStrEqNc___0(char *s1 , char *s2 ) 
{ 
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 2263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2264
    if (! *s1) {
#line 2265
      if (! *s2) {
#line 2266
        return (1);
      } else {
#line 2268
        return (0);
      }
    } else
#line 2270
    if (! *s2) {
#line 2271
      return (0);
    }
    {
#line 2273
    tmp___1 = __ctype_b_loc();
    }
#line 2273
    if ((int const   )*(*tmp___1 + (int )*s1) & 1024) {
      {
#line 2274
      tmp = tolower((int )*s1);
#line 2274
      tmp___0 = tolower((int )*s2);
      }
#line 2274
      if (tmp != tmp___0) {
#line 2275
        return (0);
      }
    } else
#line 2277
    if ((int )*s1 != (int )*s2) {
#line 2278
      return (0);
    }
#line 2280
    s1 ++;
#line 2281
    s2 ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2285 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static int cgiStrBeginsNc___0(char *s1 , char *s2 ) 
{ 
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 2286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2287
    if (! *s2) {
#line 2288
      return (1);
    } else
#line 2289
    if (! *s1) {
#line 2290
      return (0);
    }
    {
#line 2292
    tmp___1 = __ctype_b_loc();
    }
#line 2292
    if ((int const   )*(*tmp___1 + (int )*s1) & 1024) {
      {
#line 2293
      tmp = tolower((int )*s1);
#line 2293
      tmp___0 = tolower((int )*s2);
      }
#line 2293
      if (tmp != tmp___0) {
#line 2294
        return (0);
      }
    } else
#line 2296
    if ((int )*s1 != (int )*s2) {
#line 2297
      return (0);
    }
#line 2299
    s1 ++;
#line 2300
    s2 ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2304 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static char *cgiFindTarget___0  =    (char *)0;
#line 2305 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static cgiFormEntry *cgiFindPos___0  =    (cgiFormEntry *)0;
#line 2307 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static cgiFormEntry *cgiFormEntryFindFirst___0(char *name ) 
{ 
  cgiFormEntry *tmp ;

  {
  {
#line 2308
  cgiFindTarget___0 = name;
#line 2309
  cgiFindPos___0 = cgiFormEntryFirst___0;
#line 2310
  tmp = cgiFormEntryFindNext___0();
  }
#line 2310
  return (tmp);
}
}
#line 2313 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static cgiFormEntry *cgiFormEntryFindNext___0(void) 
{ 
  cgiFormEntry *c ;
  int tmp ;

  {
  {
#line 2314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2314
    if (! cgiFindPos___0) {
#line 2314
      goto while_break;
    }
    {
#line 2315
    c = cgiFindPos___0;
#line 2316
    cgiFindPos___0 = c->next;
#line 2317
    tmp = strcmp((char const   *)c->attr, (char const   *)cgiFindTarget___0);
    }
#line 2317
    if (! tmp) {
#line 2318
      return (c);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2321
  return ((cgiFormEntry *)0);
}
}
#line 2324 "/home/june/repo/benchmarks/collector/temp/libcgic-2.05/cgic.c"
static int cgiFirstNonspaceChar___0(char *s ) 
{ 
  int len ;
  size_t tmp ;

  {
  {
#line 2325
  tmp = strspn((char const   *)s, " \n\r\t");
#line 2325
  len = (int )tmp;
  }
#line 2326
  return ((int )*(s + len));
}
}
