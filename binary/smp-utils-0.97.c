/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/mpi_type.h"
typedef unsigned char U8;
#line 49 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/mpi_type.h"
typedef unsigned short U16;
#line 53 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/mpi_type.h"
typedef u_int32_t U32;
#line 61 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/mpi_type.h"
struct _U64 {
   U32 Low ;
   U32 High ;
};
#line 61 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/mpi_type.h"
typedef struct _U64 U64;
#line 357 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/mpi.h"
struct _SGE_SIMPLE64 {
   U32 FlagsLength ;
   U64 Address ;
};
#line 357 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/mpi.h"
typedef struct _SGE_SIMPLE64 SGESimple64_t;
#line 364 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/mpi.h"
union __anonunion_u_30 {
   U32 Address32 ;
   U64 Address64 ;
};
#line 364 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/mpi.h"
struct _SGE_SIMPLE_UNION {
   U32 FlagsLength ;
   union __anonunion_u_30 u ;
};
#line 364 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/mpi.h"
typedef struct _SGE_SIMPLE_UNION SGE_SIMPLE_UNION;
#line 88 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/mpi_sas.h"
struct _MSG_SMP_PASSTHROUGH_REQUEST {
   U8 PassthroughFlags ;
   U8 PhysicalPort ;
   U8 ChainOffset ;
   U8 Function ;
   U16 RequestDataLength ;
   U8 ConnectionRate ;
   U8 MsgFlags ;
   U32 MsgContext ;
   U32 Reserved1 ;
   U64 SASAddress ;
   U32 Reserved2 ;
   U32 Reserved3 ;
   SGE_SIMPLE_UNION SGL ;
};
#line 88 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/mpi_sas.h"
typedef struct _MSG_SMP_PASSTHROUGH_REQUEST SmpPassthroughRequest_t;
#line 88 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/mpi_sas.h"
typedef struct _MSG_SMP_PASSTHROUGH_REQUEST *pSmpPassthroughRequest_t;
#line 116 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/mpi_sas.h"
struct _MSG_SMP_PASSTHROUGH_REPLY {
   U8 PassthroughFlags ;
   U8 PhysicalPort ;
   U8 MsgLength ;
   U8 Function ;
   U16 ResponseDataLength ;
   U8 Reserved1 ;
   U8 MsgFlags ;
   U32 MsgContext ;
   U8 Reserved2 ;
   U8 SASStatus ;
   U16 IOCStatus ;
   U32 IOCLogInfo ;
   U32 Reserved3 ;
   U8 ResponseData[4] ;
};
#line 116 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/mpi_sas.h"
typedef struct _MSG_SMP_PASSTHROUGH_REPLY *pSmpPassthroughReply_t;
#line 10 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_glue.h"
typedef unsigned int uint___0;
#line 26 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_glue.h"
typedef unsigned short u16;
#line 154 "../include/smp_lib.h"
struct smp_req_resp {
   int request_len ;
   unsigned char *request ;
   int max_response_len ;
   unsigned char *response ;
   int act_response_len ;
   int transport_err ;
};
#line 144 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/mptctl.h"
struct _mpt_ioctl_header {
   unsigned int iocnum ;
   unsigned int port ;
   int maxDataSize ;
};
#line 144 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/mptctl.h"
typedef struct _mpt_ioctl_header mpt_ioctl_header;
#line 337 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/mptctl.h"
struct mpt_ioctl_command {
   mpt_ioctl_header hdr ;
   int timeout ;
   char *replyFrameBufPtr ;
   char *dataInBufPtr ;
   char *dataOutBufPtr ;
   char *senseDataPtr ;
   int maxReplyBytes ;
   int dataInSize ;
   int dataOutSize ;
   int maxSenseBytes ;
   int dataSgeOffset ;
   char MF[1] ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
typedef struct mpt_ioctl_command mpiIoctlBlk_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 122 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 25 "/usr/include/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 20 "/usr/include/linux/bsg.h"
struct sg_io_v4 {
   __s32 guard ;
   __u32 protocol ;
   __u32 subprotocol ;
   __u32 request_len ;
   __u64 request ;
   __u64 request_tag ;
   __u32 request_attr ;
   __u32 request_priority ;
   __u32 request_extra ;
   __u32 max_response_len ;
   __u64 response ;
   __u32 dout_iovec_count ;
   __u32 dout_xfer_len ;
   __u32 din_iovec_count ;
   __u32 din_xfer_len ;
   __u64 dout_xferp ;
   __u64 din_xferp ;
   __u32 timeout ;
   __u32 flags ;
   __u64 usr_ptr ;
   __u32 spare_in ;
   __u32 driver_status ;
   __u32 transport_status ;
   __u32 device_status ;
   __u32 retry_delay ;
   __u32 info ;
   __u32 duration ;
   __u32 response_len ;
   __s32 din_resid ;
   __s32 dout_resid ;
   __u64 generated_tag ;
   __u32 spare_out ;
   __u32 padding ;
};
#line 207 "../include/smp_lib.h"
struct smp_val_name {
   int value ;
   char *name ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
struct smp_func_def_rrlen {
   int func ;
   int def_req_len ;
   int def_resp_len ;
};
#line 140 "../include/smp_lib.h"
struct smp_target_obj {
   char device_name[256] ;
   int subvalue ;
   unsigned char sas_addr[8] ;
   int interface_selector ;
   int opened ;
   int fd ;
   void *vp ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 82 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover_list.c"
struct opts_t {
   int do_adn ;
   int do_brief ;
   int desc_type ;
   int desc_type_given ;
   int filter ;
   int do_hex ;
   int ign_zp ;
   int do_num ;
   int num_given ;
   int do_1line ;
   int phy_id ;
   int phy_id_given ;
   int do_raw ;
   int do_summary ;
   int verbose ;
   int sa_given ;
   unsigned long long sa ;
   char const   *zpi_fn ;
   FILE *zpi_filep ;
};
#line 61 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover.c"
struct opts_t___0 {
   int do_adn ;
   int do_brief ;
   int do_hex ;
   int ign_zp ;
   int do_list ;
   int multiple ;
   int do_my ;
   int do_num ;
   int phy_id ;
   int phy_id_given ;
   int do_raw ;
   int do_summary ;
   int verbose ;
   int do_zero ;
   int sa_given ;
   unsigned long long sa ;
};
#line 58 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_phy_event.c"
struct pes_name_t {
   int pes ;
   char const   *pes_name ;
};
#line 71 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_exp_route_tbl.c"
struct opts_t___1 {
   int do_brief ;
   int do_hex ;
   int start_rsa_index ;
   int do_num ;
   int phy_id ;
   int do_raw ;
   int verbose ;
   int sa_given ;
   unsigned long long sa ;
};
#line 27 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 30
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 217 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 220
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf )  __asm__("fstat64")  ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.h"
int chk_mpt_device(char const   *dev_name , int verbose ) ;
#line 10
int open_mpt_device(char const   *dev_name , int verbose ) ;
#line 12
int close_mpt_device(int fd ) ;
#line 14
int send_req_mpt(int fd , int subvalue , unsigned char const   *target_sa , struct smp_req_resp *rresp ,
                 int verbose ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 47 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
int chk_mpt_device(char const   *dev_name , int verbose ) 
{ 
  struct stat st ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;

  {
  {
#line 52
  tmp = stat((char const   */* __restrict  */)dev_name, (struct stat */* __restrict  */)(& st));
  }
#line 52
  if (tmp < 0) {
#line 53
    if (verbose) {
      {
#line 54
      perror("chk_mpt_device: stat failed");
      }
    }
#line 55
    return (0);
  }
#line 57
  if ((st.st_mode & 61440U) == 8192U) {
    {
#line 57
    tmp___2 = gnu_dev_major((unsigned long long )st.st_rdev);
    }
#line 57
    if (10U == tmp___2) {
      {
#line 58
      tmp___0 = gnu_dev_minor((unsigned long long )st.st_rdev);
      }
#line 58
      if (220U == tmp___0) {
#line 60
        return (1);
      } else {
        {
#line 58
        tmp___1 = gnu_dev_minor((unsigned long long )st.st_rdev);
        }
#line 58
        if (221U == tmp___1) {
#line 60
          return (1);
        }
      }
    }
  }
#line 62
  if (verbose) {
#line 63
    if ((st.st_mode & 61440U) == 8192U) {
      {
#line 64
      tmp___3 = gnu_dev_minor((unsigned long long )st.st_rdev);
#line 64
      tmp___4 = gnu_dev_major((unsigned long long )st.st_rdev);
#line 64
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"chk_mpt_device: wanted char device major,minor=%d,%d-%d\n    got=%d,%d\n",
              10, 220, 221, tmp___4, tmp___3);
      }
    } else {
      {
#line 69
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"chk_mpt_device: wanted char device major,minor=%d,%d-%d\n    but didn\'t get char device\n",
              10, 220, 221);
      }
    }
  }
#line 73
  return (0);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
int open_mpt_device(char const   *dev_name , int verbose ) 
{ 
  int res ;
  struct stat st ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 83
  res = open(dev_name, 2);
  }
#line 84
  if (res < 0) {
#line 85
    if (verbose) {
      {
#line 86
      perror("open_mpt_device failed");
      }
    }
  } else {
    {
#line 87
    tmp___1 = fstat(res, & st);
    }
#line 87
    if (tmp___1 >= 0) {
#line 88
      if ((st.st_mode & 61440U) == 8192U) {
        {
#line 88
        tmp = gnu_dev_major((unsigned long long )st.st_rdev);
        }
#line 88
        if (10U == tmp) {
          {
#line 88
          tmp___0 = gnu_dev_minor((unsigned long long )st.st_rdev);
          }
#line 88
          if (221U == tmp___0) {
#line 90
            mptcommand = (int )((unsigned long )(((3U << 30) | (unsigned int )(76 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
          } else {
#line 92
            mptcommand = (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
          }
        } else {
#line 92
          mptcommand = (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
        }
      } else {
#line 92
        mptcommand = (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
      }
    } else
#line 93
    if (verbose) {
      {
#line 94
      perror("open_mpt_device: stat failed");
      }
    }
  }
#line 95
  return (res);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
int close_mpt_device(int fd ) 
{ 
  int tmp ;

  {
  {
#line 102
  tmp = close(fd);
  }
#line 102
  return (tmp);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
int issueMptCommand(int fd , int ioc_num , mpiIoctlBlk_t *mpiBlkPtr ) 
{ 
  int status ;
  int tmp ;

  {
  {
#line 128
  status = -1;
#line 138
  mpiBlkPtr->hdr.iocnum = (unsigned int )ioc_num;
#line 139
  mpiBlkPtr->hdr.port = 0U;
#line 141
  tmp = ioctl(fd, (unsigned long )mptcommand, (char *)mpiBlkPtr);
  }
#line 141
  if (tmp != 0) {
    {
#line 142
    perror("MPTCOMMAND or MPT2COMMAND ioctl failed");
    }
  } else {
#line 163
    status = 0;
  }
#line 166
  return (status);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
int send_req_mpt(int fd , int subvalue , unsigned char const   *target_sa , struct smp_req_resp *rresp ,
                 int verbose ) 
{ 
  mpiIoctlBlk_t *mpiBlkPtr ;
  pSmpPassthroughRequest_t smpReq ;
  pSmpPassthroughReply_t smpReply ;
  uint___0 numBytes ;
  int k ;
  int status ;
  char reply_m[1200] ;
  u16 ioc_stat ;
  unsigned char *ucp ;
  int ret ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 174
  mpiBlkPtr = (mpiIoctlBlk_t *)((void *)0);
#line 182
  ret = -1;
#line 184
  if (verbose) {
    {
#line 184
    tmp = memcmp((void const   *)target_sa, (void const   *)(null_sas_addr), (size_t )8);
    }
#line 184
    if (0 == tmp) {
      {
#line 185
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The MPT interface typically needs SAS address of target (e.g. expander).\n");
#line 187
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A \'--sa=SAS_ADDR\' command line option may be required. See man page.\n");
      }
    }
  }
#line 190
  if (verbose > 2) {
    {
#line 191
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"send_req_mpt: subvalue=%d  ",
            subvalue);
#line 192
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SAS address=0x");
#line 193
    k = 0;
    }
    {
#line 193
    while (1) {
      while_continue: /* CIL Label */ ;
#line 193
      if (! (k < 8)) {
#line 193
        goto while_break;
      }
      {
#line 194
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x",
              (int const   )*(target_sa + (7 - k)));
#line 193
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 195
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
#line 196
    if (verbose > 3) {
      {
#line 197
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    mptctl two scatter gather list interface\n");
      }
    }
  }
  {
#line 200
  numBytes = (uint___0 )((unsigned long )(& ((SmpPassthroughRequest_t *)0)->SGL) + 2UL * sizeof(SGESimple64_t ));
#line 202
  tmp___0 = malloc(sizeof(mpiIoctlBlk_t ) + (unsigned long )numBytes);
#line 202
  mpiBlkPtr = (mpiIoctlBlk_t *)tmp___0;
  }
#line 203
  if ((unsigned long )mpiBlkPtr == (unsigned long )((void *)0)) {
#line 204
    goto err_out;
  }
  {
#line 205
  memset((void *)mpiBlkPtr, 0, sizeof(mpiIoctlBlk_t ) + (unsigned long )numBytes);
#line 206
  mpiBlkPtr->replyFrameBufPtr = reply_m;
#line 207
  memset((void *)mpiBlkPtr->replyFrameBufPtr, 0, sizeof(reply_m));
#line 208
  mpiBlkPtr->maxReplyBytes = (int )sizeof(reply_m);
#line 209
  smpReq = (pSmpPassthroughRequest_t )(mpiBlkPtr->MF);
#line 210
  mpiBlkPtr->dataSgeOffset = (int )((unsigned long )(& ((SmpPassthroughRequest_t *)0)->SGL) / 4UL);
#line 211
  smpReply = (pSmpPassthroughReply_t )mpiBlkPtr->replyFrameBufPtr;
#line 214
  mpiBlkPtr->dataOutSize = rresp->request_len - 4;
#line 215
  mpiBlkPtr->dataOutBufPtr = (char *)rresp->request;
#line 216
  mpiBlkPtr->dataInSize = rresp->max_response_len + 4;
#line 217
  tmp___1 = malloc((size_t )mpiBlkPtr->dataInSize);
#line 217
  mpiBlkPtr->dataInBufPtr = (char *)tmp___1;
  }
#line 218
  if ((unsigned long )mpiBlkPtr->dataInBufPtr == (unsigned long )((void *)0)) {
#line 219
    goto err_out;
  }
  {
#line 220
  memset((void *)mpiBlkPtr->dataInBufPtr, 0, (size_t )mpiBlkPtr->dataInSize);
#line 228
  memset((void *)smpReq, 0, sizeof(smpReq));
#line 229
  smpReq->RequestDataLength = (U16 )(rresp->request_len - 4);
#line 230
  smpReq->Function = (U8 )26;
#line 231
  ucp = (unsigned char *)(& smpReq->SASAddress);
#line 232
  memcpy((void */* __restrict  */)ucp, (void const   */* __restrict  */)target_sa,
         (size_t )8);
#line 234
  status = issueMptCommand(fd, subvalue, mpiBlkPtr);
  }
#line 236
  if (status != 0) {
    {
#line 237
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ioctl failed\n");
    }
#line 238
    goto err_out;
  }
#line 241
  ioc_stat = (u16 )((int )smpReply->IOCStatus & 32767);
#line 242
  if ((int )ioc_stat != 0) {
#line 242
    goto _L;
  } else
#line 242
  if ((int )smpReply->SASStatus != 0) {
    _L: /* CIL Label */ 
#line 244
    if (verbose) {
      {
#line 246
      if ((int )smpReply->SASStatus == 1) {
#line 246
        goto case_1;
      }
#line 249
      if ((int )smpReply->SASStatus == 2) {
#line 249
        goto case_2;
      }
#line 252
      if ((int )smpReply->SASStatus == 3) {
#line 252
        goto case_3;
      }
#line 256
      if ((int )smpReply->SASStatus == 4) {
#line 256
        goto case_4;
      }
#line 260
      if ((int )smpReply->SASStatus == 5) {
#line 260
        goto case_5;
      }
#line 264
      if ((int )smpReply->SASStatus == 6) {
#line 264
        goto case_6;
      }
#line 268
      if ((int )smpReply->SASStatus == 7) {
#line 268
        goto case_7;
      }
#line 272
      if ((int )smpReply->SASStatus == 9) {
#line 272
        goto case_9;
      }
#line 276
      if ((int )smpReply->SASStatus == 10) {
#line 276
        goto case_10;
      }
#line 279
      if ((int )smpReply->SASStatus == 15) {
#line 279
        goto case_15;
      }
#line 282
      if ((int )smpReply->SASStatus == 20) {
#line 282
        goto case_20;
      }
#line 286
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 247
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown SAS (SMP) error\n");
      }
#line 248
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 250
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid frame\n");
      }
#line 251
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 253
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to connect (bad destination)\n");
      }
#line 255
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 257
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to connect (break received)\n");
      }
#line 259
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 261
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to connect (connect rate not supported)\n");
      }
#line 263
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 265
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to connect (port layer request)\n");
      }
#line 267
      goto switch_break;
      case_7: /* CIL Label */ 
      {
#line 269
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to connect (protocol (SMP target) not supported)\n");
      }
#line 271
      goto switch_break;
      case_9: /* CIL Label */ 
      {
#line 273
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to connect (wrong destination)\n");
      }
#line 275
      goto switch_break;
      case_10: /* CIL Label */ 
      {
#line 277
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Short information unit\n");
      }
#line 278
      goto switch_break;
      case_15: /* CIL Label */ 
      {
#line 280
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Incorrect data length\n");
      }
#line 281
      goto switch_break;
      case_20: /* CIL Label */ 
      {
#line 283
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Initiator response timeout\n");
      }
#line 285
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 287
      if ((int )smpReply->SASStatus != 0) {
        {
#line 289
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unrecognized SAS (SMP) error 0x%x\n",
                (int )smpReply->SASStatus);
        }
#line 292
        goto switch_break;
      }
#line 294
      if ((int )smpReply->IOCStatus == 144) {
        {
#line 296
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SMP request failed (IOCStatus)\n");
        }
      } else
#line 298
      if ((int )smpReply->IOCStatus == 145) {
        {
#line 300
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SMP data overrun (IOCStatus)\n");
        }
      } else
#line 302
      if ((int )smpReply->IOCStatus == 67) {
        {
#line 304
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Device not there (IOCStatus)\n");
        }
      } else {
        {
#line 307
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"IOCStatus=0x%x\n",
                (int )smpReply->IOCStatus);
        }
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 311
    if (verbose > 1) {
      {
#line 312
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"IOCStatus=0x%X IOCLogInfo=0x%X SASStatus=0x%X\n",
              (int )smpReply->IOCStatus, smpReply->IOCLogInfo, (int )smpReply->SASStatus);
      }
    }
  } else {
#line 318
    ret = 0;
  }
  {
#line 320
  memcpy((void */* __restrict  */)rresp->response, (void const   */* __restrict  */)mpiBlkPtr->dataInBufPtr,
         (size_t )rresp->max_response_len);
#line 321
  rresp->act_response_len = -1;
  }
  err_out: 
#line 324
  if (mpiBlkPtr) {
#line 325
    if (mpiBlkPtr->dataInBufPtr) {
      {
#line 326
      free((void *)mpiBlkPtr->dataInBufPtr);
      }
    }
    {
#line 327
    free((void *)mpiBlkPtr);
    }
  }
#line 329
  return (ret);
}
}
#line 33 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__leaf__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                                     unsigned int __minor )  __attribute__((__const__)) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 511 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 336 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mknod)(char const   *__path ,
                                                                                            __mode_t __mode ,
                                                                                            __dev_t __dev ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 227 "../include/smp_lib.h"
void dStrHex(char const   *str , int len , int no_ascii ) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lin_bsg.h"
int chk_lin_bsg_device(char const   *dev_name , int verbose ) ;
#line 8
int open_lin_bsg_device(char const   *dev_name , int verbose ) ;
#line 10
int close_lin_bsg_device(int fd ) ;
#line 12
int send_req_lin_bsg(int fd , int subvalue , struct smp_req_resp *rresp , int verbose ) ;
#line 74 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lin_bsg.c"
int chk_lin_bsg_device(char const   *dev_name , int verbose ) 
{ 
  char buff[1024] ;
  char sysfs_nm[1024] ;
  char *cp ;
  struct stat st ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 83
  tmp = strlen(dev_name);
  }
#line 83
  if (tmp > sizeof(buff)) {
    {
#line 84
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"device name too long (greater than %d bytes)\n",
            (int )sizeof(buff));
    }
#line 86
    return (0);
  }
#line 88
  len = 0;
#line 89
  if (47 != (int )*(dev_name + 0)) {
    {
#line 90
    tmp___2 = getcwd(buff, sizeof(buff) - 1UL);
    }
#line 90
    if (tmp___2) {
      {
#line 91
      tmp___0 = strlen((char const   *)(buff));
#line 91
      len = (int )tmp___0;
      }
#line 92
      if (47 != (int )buff[len - 1]) {
#line 93
        tmp___1 = len;
#line 93
        len ++;
#line 93
        buff[tmp___1] = (char )'/';
      }
    } else {
#line 95
      if (verbose > 3) {
        {
#line 96
        perror("chk_lin_bsg_device: getcwd failed");
        }
      }
#line 97
      return (0);
    }
    {
#line 99
    strncpy((char */* __restrict  */)(buff + len), (char const   */* __restrict  */)dev_name,
            sizeof(buff) - (unsigned long )len);
    }
  } else {
    {
#line 101
    strncpy((char */* __restrict  */)(buff), (char const   */* __restrict  */)dev_name,
            sizeof(buff));
    }
  }
  {
#line 102
  buff[sizeof(buff) - 1UL] = (char )'\000';
#line 103
  tmp___4 = strlen((char const   *)(buff));
  }
#line 103
  if (47 == (int )buff[tmp___4 - 1UL]) {
    {
#line 104
    tmp___3 = strlen((char const   *)(buff));
#line 104
    buff[tmp___3 - 1UL] = (char )'\000';
    }
  }
  {
#line 105
  tmp___7 = strncmp((char const   *)(buff), "/sys/", (size_t )5);
  }
#line 105
  if (0 == tmp___7) {
    {
#line 106
    tmp___6 = strstr((char const   *)(buff), "/bsg/");
    }
#line 106
    if (tmp___6) {
      {
#line 107
      tmp___5 = stat((char const   */* __restrict  */)(buff), (struct stat */* __restrict  */)(& st));
      }
#line 107
      if (tmp___5 < 0) {
#line 108
        if (verbose > 3) {
          {
#line 109
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"chk_lin_bsg_device: stat() on %s failed: ",
                  buff);
#line 111
          perror("");
          }
        }
#line 113
        return (0);
      }
#line 115
      return (1);
    } else {
#line 117
      return (0);
    }
  }
  {
#line 119
  tmp___9 = strncmp((char const   *)(buff), "/dev/", (size_t )5);
  }
#line 119
  if (0 == tmp___9) {
    {
#line 120
    cp = strrchr((char const   *)(buff), '/');
#line 121
    snprintf((char */* __restrict  */)(sysfs_nm), sizeof(sysfs_nm), (char const   */* __restrict  */)"/sys/class/bsg/%s/dev",
             cp + 1);
#line 122
    tmp___8 = stat((char const   */* __restrict  */)(sysfs_nm), (struct stat */* __restrict  */)(& st));
    }
#line 122
    if (tmp___8 < 0) {
#line 123
      if (verbose > 3) {
        {
#line 124
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"chk_lin_bsg_device: stat() on redirected %s failed: ",
                sysfs_nm);
#line 126
        perror("");
        }
      }
#line 128
      return (0);
    }
#line 130
    return (1);
  }
#line 132
  return (0);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lin_bsg.c"
int open_lin_bsg_device(char const   *dev_name , int verbose ) 
{ 
  char buff[1024] ;
  char sysfs_nm[1024] ;
  int len ;
  int res ;
  int maj ;
  int min ;
  int ret ;
  FILE *fp ;
  struct timeval t ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  unsigned long long tmp___7 ;
  int tmp___8 ;

  {
  {
#line 142
  ret = -1;
#line 143
  fp = (FILE *)((void *)0);
#line 146
  tmp = strlen(dev_name);
  }
#line 146
  if (tmp > sizeof(buff)) {
    {
#line 147
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"device name too long (greater than %d bytes)\n",
            (int )sizeof(buff));
    }
#line 149
    return (0);
  }
#line 151
  len = 0;
#line 152
  if (47 != (int )*(dev_name + 0)) {
    {
#line 153
    tmp___2 = getcwd(buff, sizeof(buff) - 1UL);
    }
#line 153
    if (tmp___2) {
      {
#line 154
      tmp___0 = strlen((char const   *)(buff));
#line 154
      len = (int )tmp___0;
      }
#line 155
      if (47 != (int )buff[len - 1]) {
#line 156
        tmp___1 = len;
#line 156
        len ++;
#line 156
        buff[tmp___1] = (char )'/';
      }
    } else {
#line 158
      if (verbose) {
        {
#line 159
        perror("open_lin_bsg_device: getcwd failed");
        }
      }
#line 160
      return (0);
    }
    {
#line 162
    strncpy((char */* __restrict  */)(buff + len), (char const   */* __restrict  */)dev_name,
            sizeof(buff) - (unsigned long )len);
    }
  } else {
    {
#line 164
    strncpy((char */* __restrict  */)(buff), (char const   */* __restrict  */)dev_name,
            sizeof(buff));
    }
  }
  {
#line 165
  buff[sizeof(buff) - 1UL] = (char )'\000';
#line 166
  tmp___4 = strlen((char const   *)(buff));
  }
#line 166
  if (47 == (int )buff[tmp___4 - 1UL]) {
    {
#line 167
    tmp___3 = strlen((char const   *)(buff));
#line 167
    buff[tmp___3 - 1UL] = (char )'\000';
    }
  }
  {
#line 168
  tmp___8 = strncmp((char const   *)(buff), "/sys/", (size_t )5);
  }
#line 168
  if (0 == tmp___8) {
    {
#line 169
    snprintf((char */* __restrict  */)(sysfs_nm), sizeof(sysfs_nm), (char const   */* __restrict  */)"%s/dev",
             buff);
#line 171
    fp = fopen((char const   */* __restrict  */)(sysfs_nm), (char const   */* __restrict  */)"r");
    }
#line 172
    if (! fp) {
#line 173
      if (verbose) {
        {
#line 174
        perror("open_lin_bsg_device: fopen() in sysfs failed");
        }
      }
#line 175
      return (-1);
    }
    {
#line 177
    tmp___5 = fgets((char */* __restrict  */)(buff), (int )sizeof(buff), (FILE */* __restrict  */)fp);
    }
#line 177
    if (! tmp___5) {
#line 178
      if (verbose) {
        {
#line 179
        perror("open_lin_bsg_device: fgets() in sysfs failed");
        }
      }
#line 180
      goto close_sysfs;
    }
    {
#line 182
    tmp___6 = sscanf((char const   */* __restrict  */)(buff), (char const   */* __restrict  */)"%d:%d",
                     & maj, & min);
    }
#line 182
    if (2 != tmp___6) {
#line 183
      if (verbose) {
        {
#line 184
        perror("open_lin_bsg_device: fclose() in sysfs failed");
        }
      }
#line 185
      goto close_sysfs;
    }
    {
#line 187
    res = gettimeofday((struct timeval */* __restrict  */)(& t), (__timezone_ptr_t )((void *)0));
    }
#line 188
    if (res) {
#line 189
      if (verbose) {
        {
#line 190
        perror("open_lin_bsg_device: gettimeofday() failed");
        }
      }
#line 191
      goto close_sysfs;
    }
    {
#line 193
    memset((void *)(buff), 0, sizeof(buff));
#line 194
    snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"/tmp/bsg_%lx%lx",
             t.tv_sec, t.tv_usec);
    }
#line 195
    if (verbose > 2) {
      {
#line 196
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"about to make temporary device node at %s\n\tfor char device maj:%d min:%d\n",
              buff, maj, min);
      }
    }
    {
#line 198
    tmp___7 = gnu_dev_makedev((unsigned int )maj, (unsigned int )min);
#line 198
    res = mknod((char const   *)(buff), (__mode_t )((8576 | (256 >> 3)) | ((256 >> 3) >> 3)),
                (__dev_t )tmp___7);
    }
#line 200
    if (res) {
#line 201
      if (verbose) {
        {
#line 202
        perror("open_lin_bsg_device: mknod() failed");
        }
      }
#line 203
      goto close_sysfs;
    }
    {
#line 205
    ret = open((char const   *)(buff), 2);
    }
#line 206
    if (ret < 0) {
#line 207
      if (verbose) {
        {
#line 208
        perror("open_lin_bsg_device: open() temporary device node failed");
#line 209
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\ttried to open %s\n",
                buff);
        }
      }
#line 211
      goto close_sysfs;
    }
    {
#line 213
    unlink((char const   *)(buff));
    }
  } else {
    {
#line 216
    ret = open((char const   *)(buff), 2);
    }
#line 217
    if (ret < 0) {
#line 218
      if (verbose) {
        {
#line 219
        perror("open_lin_bsg_device: open() device node failed");
#line 220
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\ttried to open %s\n",
                buff);
        }
      }
#line 222
      goto close_sysfs;
    }
#line 224
    return (ret);
  }
  close_sysfs: 
#line 228
  if (fp) {
    {
#line 229
    fclose(fp);
    }
  }
#line 230
  return (ret);
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lin_bsg.c"
int close_lin_bsg_device(int fd ) 
{ 
  int tmp ;

  {
  {
#line 236
  tmp = close(fd);
  }
#line 236
  return (tmp);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lin_bsg.c"
int send_req_lin_bsg(int fd , int subvalue , struct smp_req_resp *rresp , int verbose ) 
{ 
  struct sg_io_v4 hdr ;
  unsigned char cmd[16] ;
  int res ;
  int tmp ;

  {
  {
#line 248
  subvalue ++;
#line 250
  memset((void *)(& hdr), 0, sizeof(hdr));
#line 251
  memset((void *)(cmd), 0, sizeof(cmd));
#line 253
  hdr.guard = 'Q';
#line 254
  hdr.protocol = (__u32 )0;
#line 255
  hdr.subprotocol = (__u32 )2;
#line 257
  hdr.request_len = (__u32 )sizeof(cmd);
#line 258
  hdr.request = (__u64 )((uintptr_t )(cmd));
#line 260
  hdr.dout_xfer_len = (__u32 )rresp->request_len;
#line 261
  hdr.dout_xferp = (__u64 )((uintptr_t )rresp->request);
#line 263
  hdr.din_xfer_len = (__u32 )rresp->max_response_len;
#line 264
  hdr.din_xferp = (__u64 )((uintptr_t )rresp->response);
#line 266
  hdr.timeout = (__u32 )20000;
  }
#line 268
  if (verbose > 3) {
    {
#line 269
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"send_req_lin_bsg: dout_xfer_len=%u, din_xfer_len=%u, timeout=%u ms\n",
            hdr.dout_xfer_len, hdr.din_xfer_len, hdr.timeout);
    }
  }
  {
#line 273
  res = ioctl(fd, 8837UL, & hdr);
  }
#line 274
  if (res) {
    {
#line 275
    perror("send_req_lin_bsg: SG_IO ioctl");
    }
#line 276
    return (-1);
  }
#line 278
  res = (int )(hdr.din_xfer_len - (__u32 )hdr.din_resid);
#line 279
  rresp->act_response_len = res;
#line 281
  if (verbose > 3) {
    {
#line 282
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"send_req_lin_bsg: driver_status=%u, transport_status=%u\n",
            hdr.driver_status, hdr.transport_status);
#line 284
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    device_status=%u, duration=%u, info=%u\n",
            hdr.device_status, hdr.duration, hdr.info);
#line 286
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    din_resid=%d, dout_resid=%d\n",
            hdr.din_resid, hdr.dout_resid);
#line 288
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  smp_req_resp::max_response_len=%d  act_response_len=%d\n",
            rresp->max_response_len, res);
    }
#line 290
    if (verbose > 4) {
#line 290
      if (hdr.din_xfer_len > 0U) {
        {
#line 291
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  response (din_resid might exclude CRC):\n");
        }
#line 292
        if (res > 0) {
#line 292
          tmp = res;
        } else {
#line 292
          tmp = (int )hdr.din_xfer_len;
        }
        {
#line 292
        dStrHex((char const   *)rresp->response, tmp, 1);
        }
      }
    }
  }
#line 296
  if (hdr.driver_status) {
#line 297
    rresp->transport_err = (int )hdr.driver_status;
  } else
#line 298
  if (hdr.transport_status) {
#line 299
    rresp->transport_err = (int )hdr.transport_status;
  } else
#line 300
  if (hdr.device_status) {
#line 301
    rresp->transport_err = (int )hdr.device_status;
  }
#line 302
  return (0);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 186 "../include/smp_lib.h"
char *smp_get_func_res_str(int func_res , int buff_len , char *buff ) ;
#line 193
int smp_get_func_def_req_len(int func_code ) ;
#line 199
int smp_get_func_def_resp_len(int func_code ) ;
#line 203
int smp_is_naa5(unsigned long long addr ) ;
#line 205
char const   *smp_lib_version(void) ;
#line 216
char *safe_strerror(int errnum ) ;
#line 235
int smp_get_num(char const   *buf ) ;
#line 242
long long smp_get_llnum(char const   *buf ) ;
#line 248
int smp_get_dhnum(char const   *buf ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str  =    (char *)"1.19 20110805";
#line 62 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
struct smp_func_def_rrlen smp_def_rrlen_arr[32]  = 
#line 62
  {      {0, 0, 6}, 
        {1, 0, 14}, 
        {2, -3, -3}, 
        {3, -2, -2}, 
        {4, -2, -2}, 
        {5, -2, -2}, 
        {6, -2, -2}, 
        {7, -2, -2}, 
        {16, 2, 12}, 
        {17, 2, 6}, 
        {18, 2, 13}, 
        {19, 2, 9}, 
        {20, -2, -2}, 
        {32, -2, -2}, 
        {33, -2, -2}, 
        {34, -2, -2}, 
        {128, 3, 0}, 
        {129, -2, 0}, 
        {130, -3, -3}, 
        {131, -2, -2}, 
        {133, -2, 0}, 
        {134, -2, -2}, 
        {135, -2, 0}, 
        {136, -2, 0}, 
        {137, -2, 0}, 
        {138, -2, 0}, 
        {139, -2, 0}, 
        {144, 9, 0}, 
        {145, 9, 0}, 
        {146, 9, 0}, 
        {147, -2, 0}, 
        {-1, -1, -1}};
#line 98 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
int smp_get_func_def_req_len(int func_code ) 
{ 
  struct smp_func_def_rrlen *drlp ;

  {
#line 103
  drlp = smp_def_rrlen_arr;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! (drlp->func >= 0)) {
#line 103
      goto while_break;
    }
#line 104
    if (func_code == drlp->func) {
#line 105
      return (drlp->def_req_len);
    }
#line 103
    drlp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  return (-1);
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
int smp_get_func_def_resp_len(int func_code ) 
{ 
  struct smp_func_def_rrlen *drlp ;

  {
#line 115
  drlp = smp_def_rrlen_arr;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! (drlp->func >= 0)) {
#line 115
      goto while_break;
    }
#line 116
    if (func_code == drlp->func) {
#line 117
      return (drlp->def_resp_len);
    }
#line 115
    drlp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return (-1);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 158 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
char *smp_get_func_res_str(int func_res , int buff_len , char *buff ) 
{ 
  struct smp_val_name *vnp ;

  {
#line 163
  vnp = smp_func_results;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! vnp->name) {
#line 163
      goto while_break;
    }
#line 164
    if (func_res == vnp->value) {
      {
#line 165
      snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"%s",
               vnp->name);
      }
#line 166
      return (buff);
    }
#line 163
    vnp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 169
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Unknown function result code=0x%x\n",
           func_res);
  }
#line 170
  return (buff);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
int smp_is_naa5(unsigned long long addr ) 
{ 


  {
#line 175
  return (5ULL == ((addr >> 60) & 15ULL));
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 187 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
char *safe_strerror(int errnum ) 
{ 
  size_t len ;
  char *errstr ;

  {
#line 193
  if (errnum < 0) {
#line 194
    errnum = - errnum;
  }
  {
#line 195
  errstr = strerror(errnum);
  }
#line 196
  if ((unsigned long )((void *)0) == (unsigned long )errstr) {
    {
#line 197
    len = strlen((char const   *)(safe_errbuf));
#line 198
    snprintf((char */* __restrict  */)(safe_errbuf + len), sizeof(safe_errbuf) - len,
             (char const   */* __restrict  */)"%i", errnum);
#line 199
    safe_errbuf[sizeof(safe_errbuf) - 1UL] = (char )'\000';
    }
#line 200
    return (safe_errbuf);
  }
#line 202
  return (errstr);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
void dStrHex(char const   *str , int len , int no_ascii ) 
{ 
  char const   *p ;
  unsigned char c ;
  char buff[82] ;
  int a ;
  int bpstart ;
  int cpstart ;
  int cpos ;
  int bpos ;
  int i ;
  int k ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 213
  p = str;
#line 216
  a = 0;
#line 217
  bpstart = 5;
#line 218
  cpstart = 60;
#line 219
  cpos = cpstart;
#line 220
  bpos = bpstart;
#line 223
  if (len <= 0) {
#line 224
    return;
  }
  {
#line 225
  memset((void *)(buff), ' ', (size_t )80);
#line 226
  buff[80] = (char )'\000';
  }
#line 227
  if (no_ascii < 0) {
#line 228
    k = 0;
    {
#line 228
    while (1) {
      while_continue: /* CIL Label */ ;
#line 228
      if (! (k < len)) {
#line 228
        goto while_break;
      }
#line 229
      tmp = p;
#line 229
      p ++;
#line 229
      c = (unsigned char )*tmp;
#line 230
      bpos += 3;
#line 231
      if (bpos == bpstart + 27) {
#line 232
        bpos ++;
      }
      {
#line 233
      sprintf((char */* __restrict  */)(& buff[bpos]), (char const   */* __restrict  */)"%.2x",
              (int )c);
#line 234
      buff[bpos + 2] = (char )' ';
      }
#line 235
      if (k > 0) {
#line 235
        if (0 == (k + 1) % 16) {
          {
#line 236
          printf((char const   */* __restrict  */)"%.60s\n", buff);
#line 237
          bpos = bpstart;
#line 238
          memset((void *)(buff), ' ', (size_t )80);
          }
        }
      }
#line 228
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 241
    if (bpos > bpstart) {
      {
#line 242
      printf((char const   */* __restrict  */)"%.60s\n", buff);
      }
    }
#line 243
    return;
  }
  {
#line 246
  k = sprintf((char */* __restrict  */)(buff + 1), (char const   */* __restrict  */)"%.2x",
              a);
#line 247
  buff[k + 1] = (char )' ';
#line 249
  i = 0;
  }
  {
#line 249
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 249
    if (! (i < len)) {
#line 249
      goto while_break___0;
    }
#line 250
    tmp___0 = p;
#line 250
    p ++;
#line 250
    c = (unsigned char )*tmp___0;
#line 251
    bpos += 3;
#line 252
    if (bpos == bpstart + 27) {
#line 253
      bpos ++;
    }
    {
#line 254
    sprintf((char */* __restrict  */)(& buff[bpos]), (char const   */* __restrict  */)"%.2x",
            (int )c);
#line 255
    buff[bpos + 2] = (char )' ';
    }
#line 256
    if (no_ascii) {
#line 257
      tmp___1 = cpos;
#line 257
      cpos ++;
#line 257
      buff[tmp___1] = (char )' ';
    } else {
#line 259
      if ((int )c < 32) {
#line 260
        c = (unsigned char )'.';
      } else
#line 259
      if ((int )c >= 127) {
#line 260
        c = (unsigned char )'.';
      }
#line 261
      tmp___2 = cpos;
#line 261
      cpos ++;
#line 261
      buff[tmp___2] = (char )c;
    }
#line 263
    if (cpos > cpstart + 15) {
      {
#line 264
      printf((char const   */* __restrict  */)"%.76s\n", buff);
#line 265
      bpos = bpstart;
#line 266
      cpos = cpstart;
#line 267
      a += 16;
#line 268
      memset((void *)(buff), ' ', (size_t )80);
#line 269
      k = sprintf((char */* __restrict  */)(buff + 1), (char const   */* __restrict  */)"%.2x",
                  a);
#line 270
      buff[k + 1] = (char )' ';
      }
    }
#line 249
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 273
  if (cpos > cpstart) {
    {
#line 274
    printf((char const   */* __restrict  */)"%.76s\n", buff);
    }
  }
#line 275
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
int smp_get_num(char const   *buf ) 
{ 
  int res ;
  int num ;
  int n ;
  int len ;
  unsigned int unum ;
  char *cp ;
  char c ;
  char c2 ;
  char c3 ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 287
  c = (char )'c';
#line 290
  if ((unsigned long )((void *)0) == (unsigned long )buf) {
#line 291
    return (-1);
  } else
#line 290
  if (0 == (int )*(buf + 0)) {
#line 291
    return (-1);
  }
  {
#line 292
  tmp = strlen(buf);
#line 292
  len = (int )tmp;
  }
#line 293
  if (48 == (int )*(buf + 0)) {
#line 293
    if (120 == (int )*(buf + 1)) {
      {
#line 294
      res = sscanf((char const   */* __restrict  */)(buf + 2), (char const   */* __restrict  */)"%x",
                   & unum);
#line 295
      num = (int )unum;
      }
    } else
#line 293
    if (88 == (int )*(buf + 1)) {
      {
#line 294
      res = sscanf((char const   */* __restrict  */)(buf + 2), (char const   */* __restrict  */)"%x",
                   & unum);
#line 295
      num = (int )unum;
      }
    } else {
#line 293
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 296
    tmp___0 = toupper((int )*(buf + (len - 1)));
    }
#line 296
    if (72 == tmp___0) {
      {
#line 297
      res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%x",
                   & unum);
#line 298
      num = (int )unum;
      }
    } else {
      {
#line 300
      res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%d%c%c%c",
                   & num, & c, & c2, & c3);
      }
    }
  }
#line 301
  if (res < 1) {
#line 302
    return (-1);
  } else
#line 303
  if (1 == res) {
#line 304
    return (num);
  } else {
#line 306
    if (res > 2) {
      {
#line 307
      tmp___1 = toupper((int )c2);
#line 307
      c2 = (char )tmp___1;
      }
    }
#line 308
    if (res > 3) {
      {
#line 309
      tmp___2 = toupper((int )c3);
#line 309
      c3 = (char )tmp___2;
      }
    }
    {
#line 310
    tmp___3 = toupper((int )c);
    }
    {
#line 312
    if (tmp___3 == 67) {
#line 312
      goto case_67;
    }
#line 312
    if (tmp___3 == 44) {
#line 312
      goto case_67;
    }
#line 314
    if (tmp___3 == 87) {
#line 314
      goto case_87;
    }
#line 316
    if (tmp___3 == 66) {
#line 316
      goto case_66;
    }
#line 318
    if (tmp___3 == 75) {
#line 318
      goto case_75;
    }
#line 326
    if (tmp___3 == 77) {
#line 326
      goto case_77;
    }
#line 334
    if (tmp___3 == 71) {
#line 334
      goto case_71;
    }
#line 342
    if (tmp___3 == 88) {
#line 342
      goto case_88;
    }
#line 352
    goto switch_default;
    case_67: /* CIL Label */ 
    case_44: /* CIL Label */ 
#line 313
    return (num);
    case_87: /* CIL Label */ 
#line 315
    return (num * 2);
    case_66: /* CIL Label */ 
#line 317
    return (num * 512);
    case_75: /* CIL Label */ 
#line 319
    if (2 == res) {
#line 320
      return (num * 1024);
    }
#line 321
    if (66 == (int )c2) {
#line 322
      return (num * 1000);
    } else
#line 321
    if (68 == (int )c2) {
#line 322
      return (num * 1000);
    }
#line 323
    if (73 == (int )c2) {
#line 323
      if (4 == res) {
#line 323
        if (66 == (int )c3) {
#line 324
          return (num * 1024);
        }
      }
    }
#line 325
    return (-1);
    case_77: /* CIL Label */ 
#line 327
    if (2 == res) {
#line 328
      return (num * 1048576);
    }
#line 329
    if (66 == (int )c2) {
#line 330
      return (num * 1000000);
    } else
#line 329
    if (68 == (int )c2) {
#line 330
      return (num * 1000000);
    }
#line 331
    if (73 == (int )c2) {
#line 331
      if (4 == res) {
#line 331
        if (66 == (int )c3) {
#line 332
          return (num * 1048576);
        }
      }
    }
#line 333
    return (-1);
    case_71: /* CIL Label */ 
#line 335
    if (2 == res) {
#line 336
      return (num * 1073741824);
    }
#line 337
    if (66 == (int )c2) {
#line 338
      return (num * 1000000000);
    } else
#line 337
    if (68 == (int )c2) {
#line 338
      return (num * 1000000000);
    }
#line 339
    if (73 == (int )c2) {
#line 339
      if (4 == res) {
#line 339
        if (66 == (int )c3) {
#line 340
          return (num * 1073741824);
        }
      }
    }
#line 341
    return (-1);
    case_88: /* CIL Label */ 
    {
#line 343
    cp = strchr(buf, 'x');
    }
#line 344
    if ((unsigned long )((void *)0) == (unsigned long )cp) {
      {
#line 345
      cp = strchr(buf, 'X');
      }
    }
#line 346
    if (cp) {
      {
#line 347
      n = smp_get_num((char const   *)(cp + 1));
      }
#line 348
      if (-1 != n) {
#line 349
        return (num * n);
      }
    }
#line 351
    return (-1);
    switch_default: /* CIL Label */ 
    {
#line 353
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unrecognized multiplier\n");
    }
#line 354
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
long long smp_get_llnum(char const   *buf ) 
{ 
  int res ;
  int len ;
  long long num ;
  long long ll ;
  unsigned long long unum ;
  char *cp ;
  char c ;
  char c2 ;
  char c3 ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 370
  c = (char )'c';
#line 373
  if ((unsigned long )((void *)0) == (unsigned long )buf) {
#line 374
    return (-1LL);
  } else
#line 373
  if (0 == (int )*(buf + 0)) {
#line 374
    return (-1LL);
  }
  {
#line 375
  tmp = strlen(buf);
#line 375
  len = (int )tmp;
  }
#line 376
  if (48 == (int )*(buf + 0)) {
#line 376
    if (120 == (int )*(buf + 1)) {
      {
#line 377
      res = sscanf((char const   */* __restrict  */)(buf + 2), (char const   */* __restrict  */)"%llx",
                   & unum);
#line 378
      num = (long long )unum;
      }
    } else
#line 376
    if (88 == (int )*(buf + 1)) {
      {
#line 377
      res = sscanf((char const   */* __restrict  */)(buf + 2), (char const   */* __restrict  */)"%llx",
                   & unum);
#line 378
      num = (long long )unum;
      }
    } else {
#line 376
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 379
    tmp___0 = toupper((int )*(buf + (len - 1)));
    }
#line 379
    if (72 == tmp___0) {
      {
#line 380
      res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%llx",
                   & unum);
#line 381
      num = (long long )unum;
      }
    } else {
      {
#line 383
      res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%lld%c%c%c",
                   & num, & c, & c2, & c3);
      }
    }
  }
#line 384
  if (res < 1) {
#line 385
    return (-1LL);
  } else
#line 386
  if (1 == res) {
#line 387
    return (num);
  } else {
#line 389
    if (res > 2) {
      {
#line 390
      tmp___1 = toupper((int )c2);
#line 390
      c2 = (char )tmp___1;
      }
    }
#line 391
    if (res > 3) {
      {
#line 392
      tmp___2 = toupper((int )c3);
#line 392
      c3 = (char )tmp___2;
      }
    }
    {
#line 393
    tmp___3 = toupper((int )c);
    }
    {
#line 394
    if (tmp___3 == 67) {
#line 394
      goto case_67;
    }
#line 396
    if (tmp___3 == 87) {
#line 396
      goto case_87;
    }
#line 398
    if (tmp___3 == 66) {
#line 398
      goto case_66;
    }
#line 400
    if (tmp___3 == 75) {
#line 400
      goto case_75;
    }
#line 408
    if (tmp___3 == 77) {
#line 408
      goto case_77;
    }
#line 416
    if (tmp___3 == 71) {
#line 416
      goto case_71;
    }
#line 424
    if (tmp___3 == 84) {
#line 424
      goto case_84;
    }
#line 432
    if (tmp___3 == 80) {
#line 432
      goto case_80;
    }
#line 440
    if (tmp___3 == 88) {
#line 440
      goto case_88;
    }
#line 450
    goto switch_default;
    case_67: /* CIL Label */ 
#line 395
    return (num);
    case_87: /* CIL Label */ 
#line 397
    return (num * 2LL);
    case_66: /* CIL Label */ 
#line 399
    return (num * 512LL);
    case_75: /* CIL Label */ 
#line 401
    if (2 == res) {
#line 402
      return (num * 1024LL);
    }
#line 403
    if (66 == (int )c2) {
#line 404
      return (num * 1000LL);
    } else
#line 403
    if (68 == (int )c2) {
#line 404
      return (num * 1000LL);
    }
#line 405
    if (73 == (int )c2) {
#line 405
      if (4 == res) {
#line 405
        if (66 == (int )c3) {
#line 406
          return (num * 1024LL);
        }
      }
    }
#line 407
    return (-1LL);
    case_77: /* CIL Label */ 
#line 409
    if (2 == res) {
#line 410
      return (num * 1048576LL);
    }
#line 411
    if (66 == (int )c2) {
#line 412
      return (num * 1000000LL);
    } else
#line 411
    if (68 == (int )c2) {
#line 412
      return (num * 1000000LL);
    }
#line 413
    if (73 == (int )c2) {
#line 413
      if (4 == res) {
#line 413
        if (66 == (int )c3) {
#line 414
          return (num * 1048576LL);
        }
      }
    }
#line 415
    return (-1LL);
    case_71: /* CIL Label */ 
#line 417
    if (2 == res) {
#line 418
      return (num * 1073741824LL);
    }
#line 419
    if (66 == (int )c2) {
#line 420
      return (num * 1000000000LL);
    } else
#line 419
    if (68 == (int )c2) {
#line 420
      return (num * 1000000000LL);
    }
#line 421
    if (73 == (int )c2) {
#line 421
      if (4 == res) {
#line 421
        if (66 == (int )c3) {
#line 422
          return (num * 1073741824LL);
        }
      }
    }
#line 423
    return (-1LL);
    case_84: /* CIL Label */ 
#line 425
    if (2 == res) {
#line 426
      return (num * 1099511627776LL);
    }
#line 427
    if (66 == (int )c2) {
#line 428
      return (num * 1000000000000LL);
    } else
#line 427
    if (68 == (int )c2) {
#line 428
      return (num * 1000000000000LL);
    }
#line 429
    if (73 == (int )c2) {
#line 429
      if (4 == res) {
#line 429
        if (66 == (int )c3) {
#line 430
          return (num * 1099511627776LL);
        }
      }
    }
#line 431
    return (-1LL);
    case_80: /* CIL Label */ 
#line 433
    if (2 == res) {
#line 434
      return ((num * 1099511627776LL) * 1024LL);
    }
#line 435
    if (66 == (int )c2) {
#line 436
      return ((num * 1000000000000LL) * 1000LL);
    } else
#line 435
    if (68 == (int )c2) {
#line 436
      return ((num * 1000000000000LL) * 1000LL);
    }
#line 437
    if (73 == (int )c2) {
#line 437
      if (4 == res) {
#line 437
        if (66 == (int )c3) {
#line 438
          return ((num * 1099511627776LL) * 1024LL);
        }
      }
    }
#line 439
    return (-1LL);
    case_88: /* CIL Label */ 
    {
#line 441
    cp = strchr(buf, 'x');
    }
#line 442
    if ((unsigned long )((void *)0) == (unsigned long )cp) {
      {
#line 443
      cp = strchr(buf, 'X');
      }
    }
#line 444
    if (cp) {
      {
#line 445
      ll = smp_get_llnum((char const   *)(cp + 1));
      }
#line 446
      if (-1LL != ll) {
#line 447
        return (num * ll);
      }
    }
#line 449
    return (-1LL);
    switch_default: /* CIL Label */ 
    {
#line 451
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unrecognized multiplier\n");
    }
#line 452
    return (-1LL);
    switch_break: /* CIL Label */ ;
    }
  }
}
}
#line 461 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
int smp_get_dhnum(char const   *buf ) 
{ 
  int res ;
  int n ;
  int len ;
  unsigned int unum ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 467
  if ((unsigned long )((void *)0) == (unsigned long )buf) {
#line 468
    return (-1);
  } else
#line 467
  if (0 == (int )*(buf + 0)) {
#line 468
    return (-1);
  }
  {
#line 469
  tmp = strspn(buf, " ,\t");
#line 469
  buf += tmp;
  }
#line 470
  if (48 == (int )*(buf + 0)) {
    {
#line 470
    tmp___1 = toupper((int )*(buf + 1));
    }
#line 470
    if (88 == tmp___1) {
      {
#line 471
      res = sscanf((char const   */* __restrict  */)(buf + 2), (char const   */* __restrict  */)"%x",
                   & unum);
      }
#line 472
      if (res) {
#line 472
        tmp___0 = (int )unum;
      } else {
#line 472
        tmp___0 = -1;
      }
#line 472
      return (tmp___0);
    }
  }
  {
#line 474
  tmp___2 = strcspn(buf, " ,\t");
#line 474
  len = (int )tmp___2;
#line 475
  tmp___4 = toupper((int )*(buf + (len - 1)));
  }
#line 475
  if (72 == tmp___4) {
    {
#line 476
    res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%x",
                 & unum);
    }
#line 477
    if (res) {
#line 477
      tmp___3 = (int )unum;
    } else {
#line 477
      tmp___3 = -1;
    }
#line 477
    return (tmp___3);
  }
  {
#line 479
  res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%d",
               & n);
  }
#line 480
  if (res) {
#line 480
    tmp___5 = n;
  } else {
#line 480
    tmp___5 = -1;
  }
#line 480
  return (tmp___5);
}
}
#line 483 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
char const   *smp_lib_version(void) 
{ 


  {
#line 486
  return ((char const   *)version_str);
}
}
#line 167 "../include/smp_lib.h"
int smp_initiator_open(char const   *device_name , int subvalue , char const   *i_params ,
                       unsigned long long sa , struct smp_target_obj *tobj , int verbose ) ;
#line 175
int smp_send_req(struct smp_target_obj  const  *tobj , struct smp_req_resp *rresp ,
                 int verbose ) ;
#line 180
int smp_initiator_close(struct smp_target_obj *tobj ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lin_sel.c"
int smp_initiator_open(char const   *device_name , int subvalue , char const   *i_params ,
                       unsigned long long sa , struct smp_target_obj *tobj , int verbose ) 
{ 
  int force ;
  char *cp ;
  int res ;
  int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 53
  force = 0;
#line 57
  if ((unsigned long )((void *)0) == (unsigned long )tobj) {
#line 58
    return (-1);
  } else
#line 57
  if ((unsigned long )((void *)0) == (unsigned long )device_name) {
#line 58
    return (-1);
  }
  {
#line 59
  memset((void *)tobj, 0, sizeof(struct smp_target_obj ));
#line 60
  strncpy((char */* __restrict  */)(tobj->device_name), (char const   */* __restrict  */)device_name,
          (size_t )256);
  }
#line 61
  if (sa) {
#line 62
    j = 0;
    {
#line 62
    while (1) {
      while_continue: /* CIL Label */ ;
#line 62
      if (! (j < 8)) {
#line 62
        goto while_break;
      }
#line 63
      tobj->sas_addr[j] = (unsigned char )(sa & 255ULL);
#line 62
      j ++;
#line 62
      sa >>= 8;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 65
  if (*(i_params + 0)) {
    {
#line 66
    tmp___2 = strncmp("mpt", i_params, (size_t )3);
    }
#line 66
    if (0 == tmp___2) {
#line 67
      tobj->interface_selector = 2;
    } else {
      {
#line 68
      tmp___0 = strncmp("sgv4", i_params, (size_t )2);
      }
#line 68
      if (0 == tmp___0) {
#line 70
        tobj->interface_selector = 4;
      } else {
        {
#line 68
        tmp___1 = strncmp("bsg", i_params, (size_t )3);
        }
#line 68
        if (0 == tmp___1) {
#line 70
          tobj->interface_selector = 4;
        } else {
          {
#line 71
          tmp = strncmp("for", i_params, (size_t )3);
          }
#line 71
          if (0 == tmp) {
#line 72
            force = 1;
          } else
#line 73
          if (verbose > 3) {
            {
#line 74
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"smp_initiator_open: interface not recognized\n");
            }
          }
        }
      }
    }
    {
#line 75
    cp = strchr(i_params, ',');
    }
#line 76
    if (cp) {
#line 77
      if (tobj->interface_selector > 0) {
        {
#line 77
        tmp___3 = strncmp("for", (char const   *)(cp + 1), (size_t )3);
        }
#line 77
        if (0 == tmp___3) {
#line 79
          force = 1;
        }
      }
    }
  }
#line 82
  if (4 == tobj->interface_selector) {
#line 82
    goto _L___0;
  } else
#line 82
  if (0 == tobj->interface_selector) {
    _L___0: /* CIL Label */ 
    {
#line 84
    res = chk_lin_bsg_device(device_name, verbose);
    }
#line 85
    if (res) {
#line 85
      goto _L;
    } else
#line 85
    if (force) {
      _L: /* CIL Label */ 
#line 86
      if (0 == tobj->interface_selector) {
#line 87
        tobj->interface_selector = 4;
      }
#line 88
      if (0 == res) {
#line 88
        if (force) {
          {
#line 89
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"... overriding failed check due to \'force\'\n");
          }
        }
      }
      {
#line 91
      res = open_lin_bsg_device(device_name, verbose);
      }
#line 92
      if (res < 0) {
#line 93
        goto err_out;
      }
#line 94
      tobj->fd = res;
#line 95
      tobj->subvalue = subvalue;
#line 96
      tobj->opened = 1;
#line 97
      return (0);
    } else
#line 98
    if (verbose > 2) {
      {
#line 99
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"chk_lin_bsg_device: failed\n");
      }
    }
  }
#line 101
  if (2 == tobj->interface_selector) {
#line 101
    goto _L___2;
  } else
#line 101
  if (0 == tobj->interface_selector) {
    _L___2: /* CIL Label */ 
    {
#line 103
    res = chk_mpt_device(device_name, verbose);
    }
#line 104
    if (res) {
#line 104
      goto _L___1;
    } else
#line 104
    if (force) {
      _L___1: /* CIL Label */ 
#line 105
      if (0 == tobj->interface_selector) {
#line 106
        tobj->interface_selector = 2;
      }
#line 107
      if (0 == res) {
#line 107
        if (force) {
          {
#line 108
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"... overriding failed check due to \'force\'\n");
          }
        }
      }
      {
#line 110
      res = open_mpt_device(device_name, verbose);
      }
#line 111
      if (res < 0) {
#line 112
        goto err_out;
      }
#line 113
      tobj->fd = res;
#line 114
      tobj->subvalue = subvalue;
#line 115
      tobj->opened = 1;
#line 116
      return (0);
    } else
#line 117
    if (verbose > 2) {
      {
#line 118
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"smp_initiator_open: chk_mpt_device failed\n");
      }
    }
  }
  err_out: 
  {
#line 121
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"smp_initiator_open: failed to open %s\n",
          device_name);
  }
#line 122
  return (-1);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lin_sel.c"
int smp_send_req(struct smp_target_obj  const  *tobj , struct smp_req_resp *rresp ,
                 int verbose ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 129
  if ((unsigned long )((void *)0) == (unsigned long )tobj) {
#line 129
    goto _L;
  } else
#line 129
  if (0 == (int )tobj->opened) {
    _L: /* CIL Label */ 
#line 130
    if (verbose > 2) {
      {
#line 131
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"smp_send_req: nothing open??\n");
      }
    }
#line 132
    return (-1);
  }
#line 134
  if (4 == (int )tobj->interface_selector) {
    {
#line 135
    tmp = send_req_lin_bsg((int )tobj->fd, (int )tobj->subvalue, rresp, verbose);
    }
#line 135
    return (tmp);
  } else
#line 136
  if (2 == (int )tobj->interface_selector) {
    {
#line 137
    tmp___0 = send_req_mpt((int )tobj->fd, (int )tobj->subvalue, (unsigned char const   *)(tobj->sas_addr),
                           rresp, verbose);
    }
#line 137
    return (tmp___0);
  } else {
#line 140
    if (verbose) {
      {
#line 141
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"smp_send_req: no transport??\n");
      }
    }
#line 142
    return (-1);
  }
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lin_sel.c"
int smp_initiator_close(struct smp_target_obj *tobj ) 
{ 
  int res ;

  {
#line 151
  if ((unsigned long )((void *)0) == (unsigned long )tobj) {
    {
#line 152
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"smp_initiator_close: nothing open??\n");
    }
#line 153
    return (-1);
  } else
#line 151
  if (0 == tobj->opened) {
    {
#line 152
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"smp_initiator_close: nothing open??\n");
    }
#line 153
    return (-1);
  }
#line 155
  if (2 == tobj->interface_selector) {
    {
#line 156
    res = close_mpt_device(tobj->fd);
    }
#line 157
    if (res < 0) {
      {
#line 158
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"close_mpt_device: failed\n");
      }
    }
  }
#line 160
  tobj->opened = 0;
#line 161
  return (0);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___0  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___0[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___0[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_zone_unlock.c"
static char *version_str___1  =    (char *)"1.03 20111222";
#line 55 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_zone_unlock.c"
static struct option long_options[10]  = 
#line 55
  {      {"activate", 0, (int *)0, 'a'}, 
        {"expected", 1, (int *)0, 'E'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 69 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_zone_unlock.c"
static void usage(void) 
{ 


  {
  {
#line 72
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_zone_unlock [--activate] [--expected=EX] [--help] [--hex]\n                       [--interface=PARAMS] [--raw] [--sa=SAS_ADDR]\n                       [--verbose] [--version] SMP_DEVICE[,N]\n  where:\n    --activate|-a          activate required; function will result in\n                           error if ZONE ACTIVATE has not been called\n    --expected=EX|-E EX    set expected expander change count to EX\n                           SAS-2 marks this field \'restricted\'\n    --help|-h              print out usage message\n    --hex|-H               print response in hexadecimal\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --raw|-r               output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n    --verbose|-v           increase verbosity\n    --version|-V           print version string and exit\n\nPerforms a SMP ZONE UNLOCK function\n");
  }
#line 100
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_zone_unlock.c"
static void dStrRaw(char const   *str , int len ) 
{ 
  int k ;

  {
#line 107
  k = 0;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (k < len)) {
#line 107
      goto while_break;
    }
    {
#line 108
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 107
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_zone_unlock.c"
int main(int argc , char **argv ) 
{ 
  int res ;
  int c ;
  int k ;
  int len ;
  int act_resplen ;
  int activate_required ;
  int expected_cc ;
  int do_hex ;
  int do_raw ;
  int verbose ;
  long long sa_ll ;
  unsigned long long sa ;
  char i_params[256] ;
  char device_name[512] ;
  char b[256] ;
  unsigned char smp_req[12] ;
  unsigned char smp_resp[8] ;
  struct smp_req_resp smp_rr ;
  struct smp_target_obj tobj ;
  int subvalue ;
  char *cp ;
  int ret ;
  int option_index ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 116
  activate_required = 0;
#line 117
  expected_cc = 0;
#line 118
  do_hex = 0;
#line 119
  do_raw = 0;
#line 120
  verbose = 0;
#line 122
  sa = 0ULL;
#line 126
  smp_req[0] = (unsigned char)64;
#line 126
  smp_req[1] = (unsigned char)136;
#line 126
  smp_req[2] = (unsigned char)0;
#line 126
  smp_req[3] = (unsigned char)1;
#line 126
  smp_req[4] = (unsigned char)0;
#line 126
  smp_req[5] = (unsigned char)0;
#line 126
  smp_req[6] = (unsigned char)0;
#line 126
  smp_req[7] = (unsigned char)0;
#line 126
  smp_req[8] = (unsigned char)0;
#line 126
  smp_req[9] = (unsigned char)0;
#line 126
  smp_req[10] = (unsigned char)0;
#line 126
  smp_req[11] = (unsigned char)0;
#line 131
  subvalue = 0;
#line 133
  ret = 0;
#line 135
  memset((void *)(device_name), 0, sizeof(device_name));
  }
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 137
    option_index = 0;
#line 139
    c = getopt_long(argc, (char * const  *)argv, "aE:hHI:rs:vV", (struct option  const  *)(long_options),
                    & option_index);
    }
#line 141
    if (c == -1) {
#line 142
      goto while_break;
    }
    {
#line 145
    if (c == 97) {
#line 145
      goto case_97;
    }
#line 148
    if (c == 69) {
#line 148
      goto case_69;
    }
#line 156
    if (c == 63) {
#line 156
      goto case_63;
    }
#line 156
    if (c == 104) {
#line 156
      goto case_63;
    }
#line 159
    if (c == 72) {
#line 159
      goto case_72;
    }
#line 162
    if (c == 73) {
#line 162
      goto case_73;
    }
#line 166
    if (c == 114) {
#line 166
      goto case_114;
    }
#line 169
    if (c == 115) {
#line 169
      goto case_115;
    }
#line 177
    if (c == 118) {
#line 177
      goto case_118;
    }
#line 180
    if (c == 86) {
#line 180
      goto case_86;
    }
#line 183
    goto switch_default;
    case_97: /* CIL Label */ 
#line 146
    activate_required = 1;
#line 147
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 149
    expected_cc = smp_get_num((char const   *)optarg);
    }
#line 150
    if (expected_cc < 0) {
      {
#line 151
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad argument to \'--expected\'\n");
      }
#line 152
      return (91);
    } else
#line 150
    if (expected_cc > 65535) {
      {
#line 151
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad argument to \'--expected\'\n");
      }
#line 152
      return (91);
    }
#line 154
    goto switch_break;
    case_63: /* CIL Label */ 
    case_104: /* CIL Label */ 
    {
#line 157
    usage();
    }
#line 158
    return (0);
    case_72: /* CIL Label */ 
#line 160
    do_hex ++;
#line 161
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 163
    strncpy((char */* __restrict  */)(i_params), (char const   */* __restrict  */)optarg,
            sizeof(i_params));
#line 164
    i_params[sizeof(i_params) - 1UL] = (char )'\000';
    }
#line 165
    goto switch_break;
    case_114: /* CIL Label */ 
#line 167
    do_raw ++;
#line 168
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 170
    sa_ll = smp_get_llnum((char const   *)optarg);
    }
#line 171
    if (-1LL == sa_ll) {
      {
#line 172
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad argument to \'--sa\'\n");
      }
#line 173
      return (91);
    }
#line 175
    sa = (unsigned long long )sa_ll;
#line 176
    goto switch_break;
    case_118: /* CIL Label */ 
#line 178
    verbose ++;
#line 179
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 181
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"version: %s\n",
            version_str___1);
    }
#line 182
    return (0);
    switch_default: /* CIL Label */ 
    {
#line 184
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unrecognised switch code 0x%x ??\n",
            c);
#line 185
    usage();
    }
#line 186
    return (91);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  if (optind < argc) {
#line 190
    if (0 == (int )device_name[0]) {
      {
#line 191
      strncpy((char */* __restrict  */)(device_name), (char const   */* __restrict  */)*(argv + optind),
              sizeof(device_name) - 1UL);
#line 192
      device_name[sizeof(device_name) - 1UL] = (char )'\000';
#line 193
      optind ++;
      }
    }
#line 195
    if (optind < argc) {
      {
#line 196
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 196
        if (! (optind < argc)) {
#line 196
          goto while_break___0;
        }
        {
#line 197
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected extra argument: %s\n",
                *(argv + optind));
#line 196
        optind ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 199
      usage();
      }
#line 200
      return (91);
    }
  }
#line 203
  if (0 == (int )device_name[0]) {
    {
#line 204
    cp = getenv("SMP_UTILS_DEVICE");
    }
#line 205
    if (cp) {
      {
#line 206
      strncpy((char */* __restrict  */)(device_name), (char const   */* __restrict  */)cp,
              sizeof(device_name) - 1UL);
      }
    } else {
      {
#line 208
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"missing device name on command line\n    [Could use environment variable SMP_UTILS_DEVICE instead]\n");
#line 210
      usage();
      }
#line 211
      return (91);
    }
  }
  {
#line 214
  cp = strchr((char const   *)(device_name), ',');
  }
#line 214
  if (cp) {
    {
#line 215
    *cp = (char )'\000';
#line 216
    tmp = sscanf((char const   */* __restrict  */)(cp + 1), (char const   */* __restrict  */)"%d",
                 & subvalue);
    }
#line 216
    if (1 != tmp) {
      {
#line 217
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"expected number after separator in SMP_DEVICE name\n");
      }
#line 219
      return (91);
    }
  }
#line 222
  if (0ULL == sa) {
    {
#line 223
    cp = getenv("SMP_UTILS_SAS_ADDR");
    }
#line 224
    if (cp) {
      {
#line 225
      sa_ll = smp_get_llnum((char const   *)cp);
      }
#line 226
      if (-1LL == sa_ll) {
        {
#line 227
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad value in environment variable SMP_UTILS_SAS_ADDR\n");
#line 229
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    use 0\n");
#line 230
        sa_ll = 0LL;
        }
      }
#line 232
      sa = (unsigned long long )sa_ll;
    }
  }
#line 235
  if (sa > 0ULL) {
    {
#line 236
    tmp___0 = smp_is_naa5(sa);
    }
#line 236
    if (! tmp___0) {
      {
#line 237
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SAS (target) address not in naa-5 format (may need leading \'0x\')\n");
      }
#line 239
      if (0 == (int )i_params[0]) {
        {
#line 240
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    use \'--interface=\' to override\n");
        }
#line 241
        return (91);
      }
    }
  }
  {
#line 246
  res = smp_initiator_open((char const   *)(device_name), subvalue, (char const   *)(i_params),
                           sa, & tobj, verbose);
  }
#line 248
  if (res < 0) {
#line 249
    return (92);
  }
#line 251
  smp_req[4] = (unsigned char )((expected_cc >> 8) & 255);
#line 252
  smp_req[5] = (unsigned char )(expected_cc & 255);
#line 253
  smp_req[6] = (unsigned char )(activate_required & 1);
#line 254
  if (verbose) {
    {
#line 255
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Zone unlock request: ");
#line 256
    k = 0;
    }
    {
#line 256
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 256
      if (! (k < (int )sizeof(smp_req))) {
#line 256
        goto while_break___1;
      }
      {
#line 257
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x ",
              (int )smp_req[k]);
#line 256
      k ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 258
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 260
  memset((void *)(& smp_rr), 0, sizeof(smp_rr));
#line 261
  smp_rr.request_len = (int )sizeof(smp_req);
#line 262
  smp_rr.request = smp_req;
#line 263
  smp_rr.max_response_len = (int )sizeof(smp_resp);
#line 264
  smp_rr.response = smp_resp;
#line 265
  res = smp_send_req((struct smp_target_obj  const  *)(& tobj), & smp_rr, verbose);
  }
#line 267
  if (res) {
    {
#line 268
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"smp_send_req failed, res=%d\n",
            res);
    }
#line 269
    if (0 == verbose) {
      {
#line 270
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    try adding \'-v\' option for more debug\n");
      }
    }
#line 271
    ret = -1;
#line 272
    goto err_out;
  }
#line 274
  if (smp_rr.transport_err) {
    {
#line 275
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"smp_send_req transport_error=%d\n",
            smp_rr.transport_err);
#line 277
    ret = -1;
    }
#line 278
    goto err_out;
  }
#line 280
  act_resplen = smp_rr.act_response_len;
#line 281
  if (act_resplen >= 0) {
#line 281
    if (act_resplen < 4) {
      {
#line 282
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"response too short, len=%d\n",
              act_resplen);
#line 283
      ret = 97;
      }
#line 284
      goto err_out;
    }
  }
#line 286
  len = (int )smp_resp[3];
#line 287
  if (0 == len) {
#line 287
    if (0 == (int )smp_resp[2]) {
      {
#line 288
      len = smp_get_func_def_resp_len((int )smp_resp[1]);
      }
#line 289
      if (len < 0) {
#line 290
        len = 0;
#line 291
        if (verbose > 0) {
          {
#line 292
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to determine response length\n");
          }
        }
      }
    }
  }
#line 295
  len = 4 + len * 4;
#line 296
  if (act_resplen >= 0) {
#line 296
    if (len > act_resplen) {
#line 297
      if (verbose) {
        {
#line 298
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"actual response length [%d] less than deduced length [%d]\n",
                act_resplen, len);
        }
      }
#line 300
      len = act_resplen;
    }
  }
#line 302
  if (do_hex) {
#line 302
    goto _L;
  } else
#line 302
  if (do_raw) {
    _L: /* CIL Label */ 
#line 303
    if (do_hex) {
      {
#line 304
      dStrHex((char const   *)(smp_resp), len, 1);
      }
    } else {
      {
#line 306
      dStrRaw((char const   *)(smp_resp), len);
      }
    }
#line 307
    if (65 != (int )smp_resp[0]) {
#line 308
      ret = 97;
    } else
#line 309
    if ((int )smp_resp[1] != (int )smp_req[1]) {
#line 310
      ret = 97;
    } else
#line 311
    if (smp_resp[2]) {
#line 312
      if (verbose) {
        {
#line 313
        tmp___1 = smp_get_func_res_str((int )smp_resp[2], (int )sizeof(b), b);
#line 313
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Zone unlock result: %s\n",
                tmp___1);
        }
      }
#line 315
      ret = (int )smp_resp[2];
    }
#line 317
    goto err_out;
  }
#line 319
  if (65 != (int )smp_resp[0]) {
    {
#line 320
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"expected SMP frame response type, got=0x%x\n",
            (int )smp_resp[0]);
#line 322
    ret = 97;
    }
#line 323
    goto err_out;
  }
#line 325
  if ((int )smp_resp[1] != (int )smp_req[1]) {
    {
#line 326
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Expected function code=0x%x, got=0x%x\n",
            (int )smp_req[1], (int )smp_resp[1]);
#line 328
    ret = 97;
    }
#line 329
    goto err_out;
  }
#line 331
  if (smp_resp[2]) {
    {
#line 332
    cp = smp_get_func_res_str((int )smp_resp[2], (int )sizeof(b), b);
#line 333
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Zone unlock result: %s\n",
            cp);
#line 334
    ret = (int )smp_resp[2];
    }
#line 335
    goto err_out;
  }
  err_out: 
  {
#line 338
  res = smp_initiator_close(& tobj);
  }
#line 339
  if (res < 0) {
    {
#line 340
    tmp___2 = __errno_location();
#line 340
    tmp___3 = safe_strerror(*tmp___2);
#line 340
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"close error: %s\n",
            tmp___3);
    }
#line 341
    if (0 == ret) {
#line 342
      return (92);
    }
  }
#line 344
  if (ret < 0) {
#line 345
    ret = 99;
  }
#line 346
  if (verbose) {
#line 346
    if (ret) {
      {
#line 347
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Exit status %d indicates error detected\n",
              ret);
      }
    }
  }
#line 348
  return (ret);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___0[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___0  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 54 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_zone_activate.c"
static char *version_str___2  =    (char *)"1.03 20111222";
#line 56 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_zone_activate.c"
static struct option long_options___0[9]  = 
#line 56
  {      {"expected", 1, (int *)0, 'E'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 69 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_zone_activate.c"
static void usage___0(void) 
{ 


  {
  {
#line 72
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_zone_activate [--expected=EX] [--help] [--hex]\n                         [--interface=PARAMS] [--raw] [--sa=SAS_ADDR]\n                         [--verbose] [--version] SMP_DEVICE[,N]\n  where:\n    --expected=EX|-E EX    set expected expander change count to EX\n                           SAS-2 marks this field \'restricted\'\n    --help|-h              print out usage message\n    --hex|-H               print response in hexadecimal\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --raw|-r               output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n    --verbose|-v           increase verbosity\n    --version|-V           print version string and exit\n\nPerforms a SMP ZONE ACTIVATE function\n");
  }
#line 96
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_zone_activate.c"
static void dStrRaw___0(char const   *str , int len ) 
{ 
  int k ;

  {
#line 103
  k = 0;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! (k < len)) {
#line 103
      goto while_break;
    }
    {
#line 104
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 103
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___3  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___1[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___1[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___1[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___1  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_zone_man_pass.c"
static char *version_str___4  =    (char *)"1.02 20111222";
#line 57 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_zone_man_pass.c"
static struct option long_options___1[11]  = 
#line 57
  {      {"fpass", 1, (int *)0, 'F'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"phex", 0, (int *)0, 'p'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"report", 1, (int *)0, 'R'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 72 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_zone_man_pass.c"
static void usage___1(void) 
{ 


  {
  {
#line 75
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_rep_zone_man_pass [--fpass=FP] [--help] [--hex]\n                             [--interface=PARAMS] [--phex] [--raw]\n                             [--report=RT] [--sa=SAS_ADDR] [--verbose]\n                             [--version] SMP_DEVICE[,N]\n  where:\n    --fpass=FP|-F FP     FP is file to write password to\n                         (default: stdout)\n    --help|-h            print out usage message\n    --hex|-H             print response in hexadecimal\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --phex|-p            output password (only) in hex\n                         (default: ASCII between single quotes)\n    --raw|-r             output response in binary\n    --report=RT|-R RT    report type: 0 (default) -> current\n                         2 -> saved; 3 -> default manager password\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n    --verbose|-v         increase verbosity\n    --version|-V         print version string and exit\n\nPerforms a SMP REPORT ZONE MANAGER PASSWORD function\n");
  }
#line 105
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_zone_man_pass.c"
static void dStrRaw___1(char const   *str , int len ) 
{ 
  int k ;

  {
#line 112
  k = 0;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! (k < len)) {
#line 112
      goto while_break;
    }
    {
#line 113
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 112
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___5  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___2[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___2[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___2[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___2  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___6  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___3[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___3[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 52 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_broadcast.c"
static char *version_str___7  =    (char *)"1.02 20111222";
#line 56 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_broadcast.c"
static struct option long_options___2[9]  = 
#line 56
  {      {"broadcast", 1, (int *)0, 'b'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 69 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_broadcast.c"
static void usage___2(void) 
{ 


  {
  {
#line 72
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_rep_broadcast [--broadcast=BT] [--help] [--hex]\n                         [--interface=PARAMS] [raw] [--sa=SAS_ADDR]\n                         [--verbose] [--version] SMP_DEVICE[,N]\n  where:\n    --broadcast=RT|-b RT    RT is report type (def: 0 which is\n                            Broadcast(Change))\n    --help|-h               print out usage message\n    --hex|-H                print response in hexadecimal\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --raw|-r                output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending\n                                 on the interface, may not be needed\n    --verbose|-v            increase verbosity\n    --version|-V            print version string and exit\n\nPerforms a SMP REPORT BROADCAST function\n");
  }
#line 97
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_broadcast.c"
static void dStrRaw___2(char const   *str , int len ) 
{ 
  int k ;

  {
#line 104
  k = 0;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! (k < len)) {
#line 104
      goto while_break;
    }
    {
#line 105
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 104
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___3[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___3  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___8  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___4[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___4[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 53 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_manufacturer.c"
static char *version_str___9  =    (char *)"1.10 20111222";
#line 57 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_manufacturer.c"
static struct option long_options___3[9]  = 
#line 57
  {      {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"zero", 0, (int *)0, 'z'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 70 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_manufacturer.c"
static void usage___3(void) 
{ 


  {
  {
#line 73
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_rep_manufacturer [--help] [--hex] [--interface=PARAMS] [--raw]\n                            [--sa=SAS_ADDR] [--verbose] [--version]\n                            [--zero] SMP_DEVICE[,N]\n  where:\n    --help|-h            print out usage message\n    --hex|-H             print response in hexadecimal\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --raw|-r             output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n    --verbose|-v         increase verbosity\n    --version|-V         print version string and exit\n    --zero|-z            zero Allocated Response Length field,\n                         may be required prior to SAS-2\n\nPerforms a SMP REPORT MANUFACTURER INFORMATION function\n");
  }
#line 98
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_manufacturer.c"
static void dStrRaw___3(char const   *str , int len ) 
{ 
  int k ;

  {
#line 105
  k = 0;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! (k < len)) {
#line 105
      goto while_break;
    }
    {
#line 106
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 105
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___4[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___4  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___10  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___5[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___5[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___5[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___5  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 52 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_general.c"
static char *version_str___11  =    (char *)"1.07 20111222";
#line 54 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_general.c"
static struct option long_options___4[15]  = 
#line 54
  {      {"connect", 1, (int *)0, 'c'}, 
        {"expected", 1, (int *)0, 'E'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"inactivity", 1, (int *)0, 'i'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"nexus", 1, (int *)0, 'p'}, 
        {"open", 1, (int *)0, 'o'}, 
        {"power", 1, (int *)0, 'p'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"reduced", 1, (int *)0, 'R'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 73 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_general.c"
static void usage___4(void) 
{ 


  {
  {
#line 76
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_conf_general [--connect=CO] [--expected=EX] [--help] [--hex]\n                        [--inactivity=IN] [--interface=PARAMS]\n                        [--nexus=NE] [--open=OP] [--power] [--raw]\n                        [--reduced=RE] [--sa=SAS_ADDR] [--verbose]\n                        [--version] SMP_DEVICE[,N]\n  where:\n    --connect=CO|-c CO     STP maximum connect time limit (100 us)\n    --expected=EX|-E EX    set expected expander change count to EX\n    --help|-h              print out usage message then exit\n    --hex|-H               print response in hexadecimal\n    --inactivity=IN|-i IN    STP bus inactivity time limit (100 us)\n    --interface=PARAMS|-I PARAMS   specify or override interface\n    --nexus=NE|-n NE       STP SMP I_T nexus loss time (ms)\n    --open=OP|-o OP        STP reject to open limit (10 us)\n    --power=PD|-p PD       power done timeout (unit: second)\n    --raw|-r               output response in binary\n    --reduced=RE|-R RE     initial time to reduced functionality (100 ms)\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n    --verbose|-v           increase verbosity\n    --version|-V           print version string and exit\n\nPerforms a SMP CONFIGURE GENERAL function\n");
  }
#line 115
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_general.c"
static void dStrRaw___4(char const   *str , int len ) 
{ 
  int k ;

  {
#line 122
  k = 0;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (k < len)) {
#line 122
      goto while_break;
    }
    {
#line 123
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 122
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___12  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___6[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___6[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___6[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___6  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 315 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_write_gpio.c"
static char *version_str___13  =    (char *)"1.09 20111222";
#line 64 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_write_gpio.c"
static struct option long_options___5[14]  = 
#line 64
  {      {"count", 1, (int *)0, 'c'}, 
        {"data", 1, (int *)0, 'd'}, 
        {"enhanced", 0, (int *)0, 'E'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"index", 1, (int *)0, 'i'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"phy", 1, (int *)0, 'p'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"type", 0, (int *)0, 't'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 82 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_write_gpio.c"
static void usage___5(void) 
{ 


  {
  {
#line 85
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_write_gpio [--count=CO] [--data=H,H...] [--enhanced] [--help]\n                      [--hex] [--index=IN] [--interface=PARAMS] [--raw]\n                      [--sa=SAS_ADDR] [type=TY] [--verbose] [--version]\n                      SMP_DEVICE[,N]\n  where:\n    --count=CO|-c CO     register count (dwords to write) (def: 1)\n    --data=H,H...|-d H,H...    comma separated list of hex bytes to write\n    --data=-|-d -        read stdin for hex bytes to write\n    --enhanced|-E        use WRITE GPIO REGISTER ENHANCED function\n    --help|-h            print out usage message\n    --hex|-H             print response in hexadecimal\n    --index=IN|-i IN     register index (def: 0)\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --raw|-r             output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n    --type=TY|-t TY      register type (def: 0 (GPIO_CFG))\n    --verbose|-v         increase verbosity\n    --version|-V         print version string and exit\n\nPerforms a SMP WRITE GPIO REGISTER (default) or SMP WRITE GPIO REGISTER\nENHANCED function\n");
  }
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_write_gpio.c"
static void dStrRaw___5(char const   *str , int len ) 
{ 
  int k ;

  {
#line 126
  k = 0;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! (k < len)) {
#line 126
      goto while_break;
    }
    {
#line 127
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 126
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_write_gpio.c"
static int read_hex(char const   *inp , unsigned char *arr , int *arr_len ) 
{ 
  int in_len ;
  int k ;
  int j ;
  int m ;
  int off ;
  unsigned int h ;
  char const   *lcp ;
  char *cp ;
  char line[1024] ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
#line 139
  if ((unsigned long )((void *)0) == (unsigned long )inp) {
#line 140
    return (1);
  } else
#line 139
  if ((unsigned long )((void *)0) == (unsigned long )arr) {
#line 140
    return (1);
  } else
#line 139
  if ((unsigned long )((void *)0) == (unsigned long )arr_len) {
#line 140
    return (1);
  }
  {
#line 141
  lcp = inp;
#line 142
  tmp = strlen(inp);
#line 142
  in_len = (int )tmp;
  }
#line 143
  if (0 == in_len) {
#line 144
    *arr_len = 0;
  }
#line 146
  if (45 == (int )*(inp + 0)) {
#line 147
    j = 0;
#line 147
    off = 0;
    {
#line 147
    while (1) {
      while_continue: /* CIL Label */ ;
#line 147
      if (! (j < 1024)) {
#line 147
        goto while_break;
      }
      {
#line 148
      tmp___0 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)stdin);
      }
#line 148
      if ((unsigned long )((void *)0) == (unsigned long )tmp___0) {
#line 149
        goto while_break;
      }
      {
#line 150
      tmp___1 = strlen((char const   *)(line));
#line 150
      in_len = (int )tmp___1;
      }
#line 151
      if (in_len > 0) {
#line 152
        if (10 == (int )line[in_len - 1]) {
#line 153
          in_len --;
#line 154
          line[in_len] = (char )'\000';
        }
      }
#line 157
      if (0 == in_len) {
#line 158
        goto __Cont;
      }
      {
#line 159
      lcp = (char const   *)(line);
#line 160
      tmp___2 = strspn(lcp, " \t");
#line 160
      m = (int )tmp___2;
      }
#line 161
      if (m == in_len) {
#line 162
        goto __Cont;
      }
#line 163
      lcp += m;
#line 164
      in_len -= m;
#line 165
      if (35 == (int )*lcp) {
#line 166
        goto __Cont;
      }
      {
#line 167
      tmp___3 = strspn(lcp, "0123456789aAbBcCdDeEfF ,\t");
#line 167
      k = (int )tmp___3;
      }
#line 168
      if (in_len != k) {
        {
#line 169
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"read_hex: syntax error at line %d, pos %d\n",
                j + 1, (m + k) + 1);
        }
#line 171
        return (1);
      }
#line 173
      k = 0;
      {
#line 173
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 173
        if (! (k < 1024)) {
#line 173
          goto while_break___0;
        }
        {
#line 174
        tmp___6 = sscanf((char const   */* __restrict  */)lcp, (char const   */* __restrict  */)"%x",
                         & h);
        }
#line 174
        if (1 == tmp___6) {
#line 175
          if (h > 255U) {
            {
#line 176
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"read_hex: hex number larger than 0xff in line %d, pos %d\n",
                    j + 1, (int )((lcp - (char const   *)(line)) + 1L));
            }
#line 179
            return (1);
          }
          {
#line 181
          *(arr + (off + k)) = (unsigned char )h;
#line 182
          tmp___4 = strpbrk(lcp, " ,\t");
#line 182
          lcp = (char const   *)tmp___4;
          }
#line 183
          if ((unsigned long )((void *)0) == (unsigned long )lcp) {
#line 184
            goto while_break___0;
          }
          {
#line 185
          tmp___5 = strspn(lcp, " ,\t");
#line 185
          lcp += tmp___5;
          }
#line 186
          if (0 == (int )*lcp) {
#line 187
            goto while_break___0;
          }
        } else {
          {
#line 189
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"read_hex: error in line %d, at pos %d\n",
                  j + 1, (int )((lcp - (char const   *)(line)) + 1L));
          }
#line 192
          return (1);
        }
#line 173
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 195
      off += k + 1;
      __Cont: /* CIL Label */ 
#line 147
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 197
    *arr_len = off;
  } else {
    {
#line 199
    tmp___7 = strspn(inp, "0123456789aAbBcCdDeEfF,");
#line 199
    k = (int )tmp___7;
    }
#line 200
    if (in_len != k) {
      {
#line 201
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"read_hex: error at pos %d\n",
              k + 1);
      }
#line 203
      return (1);
    }
#line 205
    k = 0;
    {
#line 205
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 205
      if (! (k < 1024)) {
#line 205
        goto while_break___1;
      }
      {
#line 206
      tmp___8 = sscanf((char const   */* __restrict  */)lcp, (char const   */* __restrict  */)"%x",
                       & h);
      }
#line 206
      if (1 == tmp___8) {
#line 207
        if (h > 255U) {
          {
#line 208
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"read_hex: hex number larger than 0xff at pos %d\n",
                  (int )((lcp - inp) + 1L));
          }
#line 210
          return (1);
        }
        {
#line 212
        *(arr + k) = (unsigned char )h;
#line 213
        cp = strchr(lcp, ',');
        }
#line 214
        if ((unsigned long )((void *)0) == (unsigned long )cp) {
#line 215
          goto while_break___1;
        }
#line 216
        lcp = (char const   *)(cp + 1);
      } else {
        {
#line 218
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"read_hex: error at pos %d\n",
                (int )((lcp - inp) + 1L));
        }
#line 220
        return (1);
      }
#line 205
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 223
    *arr_len = k + 1;
  }
#line 225
  return (0);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___14  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___7[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___7[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___7[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___7  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 55 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover_list.c"
static char *version_str___15  =    (char *)"1.27 20111222";
#line 60 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover_list.c"
static struct option long_options___6[19]  = 
#line 60
  {      {"adn", 0, (int *)0, 'A'}, 
        {"brief", 0, (int *)0, 'b'}, 
        {"descriptor", 1, (int *)0, 'd'}, 
        {"filter", 1, (int *)0, 'f'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"ignore", 0, (int *)0, 'i'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"list", 0, (int *)0, 'l'}, 
        {"num", 1, (int *)0, 'n'}, 
        {"one", 0, (int *)0, 'o'}, 
        {"phy", 1, (int *)0, 'p'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"summary", 0, (int *)0, 'S'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"zpi", 1, (int *)0, 'Z'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 105 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover_list.c"
static void usage___6(void) 
{ 


  {
  {
#line 108
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_discover_list  [--adn] [--brief] [--descriptor=TY] [--filter=FI]\n                          [--help] [--hex] [--ignore] [--interface=PARAMS]\n                          [--num=NUM] [--one] [--phy=ID] [--raw]\n                          [--sa=SAS_ADDR] [--summary] [--verbose]\n                          [--version] [--zpi=FN] <smp_device>[,<n>]\n");
#line 119
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  where:\n    --adn|-A             output attached device name in one line per\n                         phy mode (i.e. with --one)\n    --brief|-b           brief: less output, can be used multiple times\n    --descriptor=TY|-d TY    descriptor type:\n                         0 -> long (as in DISCOVER); 1 -> short (24 byte)\n                         default is 1 if --brief given, else default is 0\n    --filter=FI|-f FI    phy filter: 0 -> all (def); 1 -> expander\n                         attached; 2 -> expander or end device\n    --help|-h            print out usage message\n    --hex|-H             print response in hexadecimal\n    --ignore|-i          sets the Ignore Zone Group bit; will show\n                         phys otherwise hidden by zoning\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --num=NUM|-n NUM     maximum number of descriptors to fetch (def: 1)\n    --one|-o             one line output per response descriptor (phy)\n    --phy=ID|-p ID       phy identifier [or starting phy id]\n    --raw|-r             output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n");
#line 154
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    --summary|-S         output 1 line per active phy; typically\n                         equivalent to: \'-o -d 1 -n 254 -b\' .\n                         This option is assumed if \'--phy=ID\' not given\n    --verbose|-v         increase verbosity\n    --version|-V         print version string and exit\n    --zpi=FN|-Z FN       FN is file that zone phy information will be\n                         written to (for smp_conf_zone_phy_info)\n\nPerforms one or more SMP DISCOVER LIST functions. If \'--phy=ID\' not given\nthen \'--summary\' is assumed. The \'--summary\' option shows the disposition\nof each active expander phy in table form.\n");
  }
#line 171
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover_list.c"
static void dStrRaw___6(char const   *str , int len ) 
{ 
  int k ;

  {
#line 178
  k = 0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (k < len)) {
#line 178
      goto while_break;
    }
    {
#line 179
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 178
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover_list.c"
static char *smp_attached_device_type[8]  = 
#line 182
  {      (char *)"no device attached",      (char *)"end device",      (char *)"expander device",      (char *)"expander device (fanout)", 
        (char *)"reserved [4]",      (char *)"reserved [5]",      (char *)"reserved [6]",      (char *)"reserved [7]"};
#line 193 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover_list.c"
static char *smp_short_attached_device_type[8]  = 
#line 193
  {      (char *)"",      (char *)"",      (char *)"exp",      (char *)"fex", 
        (char *)"res",      (char *)"res",      (char *)"res",      (char *)"res"};
#line 204 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover_list.c"
static char *smp_get_plink_rate(int val , int prog , int b_len , char *b ) 
{ 


  {
  {
#line 208
  if (val == 0) {
#line 208
    goto case_0;
  }
#line 211
  if (val == 8) {
#line 211
    goto case_8;
  }
#line 214
  if (val == 9) {
#line 214
    goto case_9;
  }
#line 217
  if (val == 10) {
#line 217
    goto case_10;
  }
#line 220
  if (val == 11) {
#line 220
    goto case_11;
  }
#line 223
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 209
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"not programmable");
  }
#line 210
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 212
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"1.5 Gbps");
  }
#line 213
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 215
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"3 Gbps");
  }
#line 216
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 218
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"6 Gbps");
  }
#line 219
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 221
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"12 Gbps");
  }
#line 222
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 224
  if (prog) {
#line 224
    if (0 == val) {
      {
#line 225
      snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"not programmable");
      }
    } else {
      {
#line 227
      snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"reserved [%d]",
               val);
      }
    }
  } else {
    {
#line 227
    snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"reserved [%d]",
             val);
    }
  }
#line 228
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 230
  return (b);
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover_list.c"
static char *smp_get_reason(int val , int b_len , char *b ) 
{ 


  {
  {
#line 237
  if (val == 0) {
#line 237
    goto case_0;
  }
#line 238
  if (val == 1) {
#line 238
    goto case_1;
  }
#line 239
  if (val == 2) {
#line 239
    goto case_2;
  }
#line 241
  if (val == 3) {
#line 241
    goto case_3;
  }
#line 243
  if (val == 4) {
#line 243
    goto case_4;
  }
#line 244
  if (val == 5) {
#line 244
    goto case_5;
  }
#line 245
  if (val == 6) {
#line 245
    goto case_6;
  }
#line 246
  if (val == 7) {
#line 246
    goto case_7;
  }
#line 247
  if (val == 8) {
#line 247
    goto case_8;
  }
#line 248
  if (val == 9) {
#line 248
    goto case_9;
  }
#line 249
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 237
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"unknown");
  }
#line 237
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 238
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"power on");
  }
#line 238
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 239
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"hard reset");
  }
#line 240
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 241
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"SMP phy control requested");
  }
#line 242
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 243
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"loss of dword synchronization");
  }
#line 243
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 244
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"error in multiplexing (MUX) sequence");
  }
#line 244
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 245
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"I_T nexus loss timeout STP/SATA");
  }
#line 245
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 246
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"break timeout timer expired");
  }
#line 246
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 247
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"phy test function stopped");
  }
#line 247
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 248
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"expander reduced functionality");
  }
#line 248
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 249
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"reserved [%d]",
           val);
  }
#line 249
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 251
  return (b);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover_list.c"
static char *smp_get_neg_xxx_link_rate(int val , int b_len , char *b ) 
{ 


  {
  {
#line 258
  if (val == 0) {
#line 258
    goto case_0;
  }
#line 259
  if (val == 1) {
#line 259
    goto case_1;
  }
#line 260
  if (val == 2) {
#line 260
    goto case_2;
  }
#line 262
  if (val == 3) {
#line 262
    goto case_3;
  }
#line 264
  if (val == 4) {
#line 264
    goto case_4;
  }
#line 265
  if (val == 5) {
#line 265
    goto case_5;
  }
#line 266
  if (val == 6) {
#line 266
    goto case_6;
  }
#line 268
  if (val == 8) {
#line 268
    goto case_8;
  }
#line 269
  if (val == 9) {
#line 269
    goto case_9;
  }
#line 270
  if (val == 10) {
#line 270
    goto case_10;
  }
#line 271
  if (val == 11) {
#line 271
    goto case_11;
  }
#line 272
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 258
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"phy enabled; unknown");
  }
#line 258
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 259
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"phy disabled");
  }
#line 259
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 260
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"phy enabled; speed negotiation failed");
  }
#line 261
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 262
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"phy enabled; SATA spinup hold state");
  }
#line 263
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 264
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"phy enabled; port selector");
  }
#line 264
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 265
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"phy enabled; reset in progress");
  }
#line 265
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 266
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"phy enabled; unsupported phy attached");
  }
#line 267
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 268
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"phy enabled, 1.5 Gbps");
  }
#line 268
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 269
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"phy enabled, 3 Gbps");
  }
#line 269
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 270
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"phy enabled, 6 Gbps");
  }
#line 270
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 271
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"phy enabled, 12 Gbps");
  }
#line 271
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 272
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"reserved [%d]",
           val);
  }
#line 272
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 274
  return (b);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover_list.c"
static char *find_sas_connector_type(int conn_type , char *buff , int buff_len ) 
{ 


  {
  {
#line 281
  if (conn_type == 0) {
#line 281
    goto case_0;
  }
#line 284
  if (conn_type == 1) {
#line 284
    goto case_1;
  }
#line 288
  if (conn_type == 2) {
#line 288
    goto case_2;
  }
#line 292
  if (conn_type == 15) {
#line 292
    goto case_15;
  }
#line 295
  if (conn_type == 16) {
#line 295
    goto case_16;
  }
#line 298
  if (conn_type == 17) {
#line 298
    goto case_17;
  }
#line 302
  if (conn_type == 32) {
#line 302
    goto case_32;
  }
#line 306
  if (conn_type == 33) {
#line 306
    goto case_33;
  }
#line 309
  if (conn_type == 34) {
#line 309
    goto case_34;
  }
#line 312
  if (conn_type == 35) {
#line 312
    goto case_35;
  }
#line 315
  if (conn_type == 47) {
#line 315
    goto case_47;
  }
#line 318
  if (conn_type == 63) {
#line 318
    goto case_63;
  }
#line 321
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 282
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"No information");
  }
#line 283
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 285
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"SAS 4x receptacle (SFF-8470) [max 4 phys]");
  }
#line 287
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 289
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Mini SAS 4x receptacle (SFF-8088) [max 4 phys]");
  }
#line 291
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 293
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Vendor specific external connector");
  }
#line 294
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 296
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"SAS 4i plug (SFF-8484) [max 4 phys]");
  }
#line 297
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 299
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Mini SAS 4i receptacle (SFF-8087) [max 4 phys]");
  }
#line 301
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 303
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"SAS Drive backplane receptacle (SFF-8482) [max 2 phys]");
  }
#line 305
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 307
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"SATA host plug [max 1 phy]");
  }
#line 308
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 310
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"SAS Drive plug (SFF-8482) [max 2 phys]");
  }
#line 311
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 313
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"SATA device plug [max 1 phy]");
  }
#line 314
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 316
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"SAS virtual connector [max 1 phy]");
  }
#line 317
  goto switch_break;
  case_63: /* CIL Label */ 
  {
#line 319
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Vendor specific internal connector");
  }
#line 320
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 322
  if (conn_type < 16) {
    {
#line 323
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"unknown external connector type: 0x%x",
             conn_type);
    }
  } else
#line 325
  if (conn_type < 32) {
    {
#line 326
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"unknown internal wide connector type: 0x%x",
             conn_type);
    }
  } else
#line 328
  if (conn_type < 48) {
    {
#line 329
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"unknown internal connector to end device, type: 0x%x",
             conn_type);
    }
  } else
#line 331
  if (conn_type < 112) {
    {
#line 332
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"reserved connector type: 0x%x",
             conn_type);
    }
  } else
#line 334
  if (conn_type < 128) {
    {
#line 335
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"vendor specific connector type: 0x%x",
             conn_type);
    }
  } else {
    {
#line 338
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"unexpected connector type: 0x%x",
             conn_type);
    }
  }
#line 340
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 342
  return (buff);
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover_list.c"
static int do_discover_list(struct smp_target_obj *top , int sphy_id , unsigned char *resp ,
                            int max_resp_len , struct opts_t *op ) 
{ 
  unsigned char smp_req[32] ;
  struct smp_req_resp smp_rr ;
  char b[256] ;
  char *cp ;
  int len ;
  int res ;
  int k ;
  int dword_resp_len ;
  int mnum_desc ;
  int act_resplen ;
  char *tmp ;

  {
#line 352
  smp_req[0] = (unsigned char)64;
#line 352
  smp_req[1] = (unsigned char)32;
#line 352
  smp_req[2] = (unsigned char)0;
#line 352
  smp_req[3] = (unsigned char)6;
#line 352
  smp_req[4] = (unsigned char)0;
#line 352
  smp_req[5] = (unsigned char)0;
#line 352
  smp_req[6] = (unsigned char)0;
#line 352
  smp_req[7] = (unsigned char)0;
#line 352
  smp_req[8] = (unsigned char)0;
#line 352
  smp_req[9] = (unsigned char)0;
#line 352
  smp_req[10] = (unsigned char)0;
#line 352
  smp_req[11] = (unsigned char)0;
#line 352
  smp_req[12] = (unsigned char)0;
#line 352
  smp_req[13] = (unsigned char)0;
#line 352
  smp_req[14] = (unsigned char)0;
#line 352
  smp_req[15] = (unsigned char)0;
#line 352
  smp_req[16] = (unsigned char)0;
#line 352
  smp_req[17] = (unsigned char)0;
#line 352
  smp_req[18] = (unsigned char)0;
#line 352
  smp_req[19] = (unsigned char)0;
#line 352
  smp_req[20] = (unsigned char)0;
#line 352
  smp_req[21] = (unsigned char)0;
#line 352
  smp_req[22] = (unsigned char)0;
#line 352
  smp_req[23] = (unsigned char)0;
#line 352
  smp_req[24] = (unsigned char)0;
#line 352
  smp_req[25] = (unsigned char)0;
#line 352
  smp_req[26] = (unsigned char)0;
#line 352
  smp_req[27] = (unsigned char)0;
#line 352
  smp_req[28] = (unsigned char)0;
#line 352
  smp_req[29] = (unsigned char)0;
#line 352
  smp_req[30] = (unsigned char)0;
#line 352
  smp_req[31] = (unsigned char)0;
#line 361
  dword_resp_len = (max_resp_len - 8) / 4;
#line 362
  if (dword_resp_len < 256) {
#line 362
    smp_req[2] = (unsigned char )dword_resp_len;
  } else {
#line 362
    smp_req[2] = (unsigned char)255;
  }
#line 363
  smp_req[8] = (unsigned char )sphy_id;
#line 364
  mnum_desc = op->do_num;
#line 365
  if (0 == op->desc_type) {
#line 365
    if (mnum_desc > 8) {
#line 366
      mnum_desc = 8;
    }
  }
#line 367
  if (1 == op->desc_type) {
#line 367
    if (mnum_desc > 40) {
#line 368
      mnum_desc = 40;
    }
  }
#line 369
  smp_req[9] = (unsigned char )mnum_desc;
#line 370
  smp_req[10] = (unsigned char )(op->filter & 15);
#line 371
  if (op->ign_zp) {
#line 372
    smp_req[10] = (unsigned char )((int )smp_req[10] | 128);
  }
#line 373
  smp_req[11] = (unsigned char )(op->desc_type & 15);
#line 374
  if (op->verbose) {
    {
#line 375
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Discover list request: ");
#line 376
    k = 0;
    }
    {
#line 376
    while (1) {
      while_continue: /* CIL Label */ ;
#line 376
      if (! (k < (int )sizeof(smp_req))) {
#line 376
        goto while_break;
      }
#line 377
      if (0 == k % 16) {
        {
#line 378
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n      ");
        }
      } else
#line 379
      if (0 == k % 8) {
        {
#line 380
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ");
        }
      }
      {
#line 381
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x ",
              (int )smp_req[k]);
#line 376
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 383
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 385
  memset((void *)(& smp_rr), 0, sizeof(smp_rr));
#line 386
  smp_rr.request_len = (int )sizeof(smp_req);
#line 387
  smp_rr.request = smp_req;
#line 388
  smp_rr.max_response_len = max_resp_len;
#line 389
  smp_rr.response = resp;
#line 391
  res = smp_send_req((struct smp_target_obj  const  *)top, & smp_rr, op->verbose);
  }
#line 392
  if (res) {
    {
#line 393
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"smp_send_req failed, res=%d\n",
            res);
    }
#line 394
    if (0 == op->verbose) {
      {
#line 395
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    try adding \'-v\' option for more debug\n");
      }
    }
#line 396
    return (-1);
  }
#line 398
  if (smp_rr.transport_err) {
    {
#line 399
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"smp_send_req transport_error=%d\n",
            smp_rr.transport_err);
    }
#line 401
    return (-1);
  }
#line 403
  act_resplen = smp_rr.act_response_len;
#line 404
  if (act_resplen >= 0) {
#line 404
    if (act_resplen < 4) {
      {
#line 405
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"response too short, len=%d\n",
              act_resplen);
      }
#line 406
      return (97);
    }
  }
#line 408
  len = (int )*(resp + 3);
#line 409
  if (0 == len) {
#line 409
    if (0 == (int )*(resp + 2)) {
      {
#line 410
      len = smp_get_func_def_resp_len((int )*(resp + 1));
      }
#line 411
      if (len < 0) {
#line 412
        len = 0;
#line 413
        if (op->verbose > 0) {
          {
#line 414
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to determine response length\n");
          }
        }
      }
    }
  }
#line 417
  len = 4 + len * 4;
#line 418
  if (act_resplen >= 0) {
#line 418
    if (len > act_resplen) {
#line 419
      if (op->verbose) {
        {
#line 420
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"actual response length [%d] less than deduced length [%d]\n",
                act_resplen, len);
        }
      }
#line 422
      len = act_resplen;
    }
  }
#line 424
  if (op->do_hex) {
#line 424
    goto _L;
  } else
#line 424
  if (op->do_raw) {
    _L: /* CIL Label */ 
#line 425
    if (op->do_hex) {
      {
#line 426
      dStrHex((char const   *)resp, len, 1);
      }
    } else {
      {
#line 428
      dStrRaw___6((char const   *)resp, len);
      }
    }
#line 429
    if (65 != (int )*(resp + 0)) {
#line 430
      return (97);
    }
#line 431
    if ((int )*(resp + 1) != (int )smp_req[1]) {
#line 432
      return (97);
    }
#line 433
    if (*(resp + 2)) {
#line 434
      if (op->verbose) {
        {
#line 435
        tmp = smp_get_func_res_str((int )*(resp + 2), (int )sizeof(b), b);
#line 435
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Discover list result: %s\n",
                tmp);
        }
      }
#line 437
      return ((int )*(resp + 2));
    }
#line 439
    return (0);
  }
#line 441
  if (65 != (int )*(resp + 0)) {
    {
#line 442
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"expected SMP frame response type, got=0x%x\n",
            (int )*(resp + 0));
    }
#line 444
    return (97);
  }
#line 446
  if ((int )*(resp + 1) != (int )smp_req[1]) {
    {
#line 447
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Expected function code=0x%x, got=0x%x\n",
            (int )smp_req[1], (int )*(resp + 1));
    }
#line 449
    return (97);
  }
#line 451
  if (*(resp + 2)) {
#line 452
    if (16 != (int )*(resp + 2)) {
      {
#line 453
      cp = smp_get_func_res_str((int )*(resp + 2), (int )sizeof(b), b);
#line 454
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Discover list result: %s\n",
              cp);
      }
    }
#line 456
    return ((int )*(resp + 2));
  }
#line 458
  return (0);
}
}
#line 463 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover_list.c"
static int decode_desc0_multiline(unsigned char const   *resp , int offset , int hdr_ecc ,
                                  struct opts_t *op ) 
{ 
  unsigned char const   *rp ;
  unsigned long long ull ;
  unsigned int ui ;
  int func_res ;
  int phy_id ;
  int ecc ;
  int adt ;
  int route_attr ;
  int len ;
  int j ;
  char b[256] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 473
  rp = resp + offset;
#line 474
  phy_id = (int )*(rp + 9);
#line 475
  func_res = (int )*(rp + 2);
#line 476
  len = 4 + (int )((int const   )*(rp + 3) * 4);
#line 477
  printf((char const   */* __restrict  */)"  phy identifier: %d\n", phy_id);
  }
#line 478
  if (22 == func_res) {
    {
#line 479
    printf((char const   */* __restrict  */)"  inaccessible (phy vacant)\n");
    }
#line 480
    return (0);
  } else
#line 481
  if (func_res) {
    {
#line 482
    tmp = smp_get_func_res_str(func_res, (int )sizeof(b), b);
#line 482
    printf((char const   */* __restrict  */)"  >>> function result: %s\n", tmp);
    }
#line 484
    return (-1);
  }
#line 486
  ecc = (int )(((int const   )*(rp + 4) << 8) + (int const   )*(rp + 5));
#line 487
  if (0 != ecc) {
#line 487
    if (hdr_ecc != ecc) {
      {
#line 488
      printf((char const   */* __restrict  */)"  >>> expander change counts differ, header: %d, this phy: %d\n",
             hdr_ecc, ecc);
      }
    }
  }
#line 490
  adt = (112 & (int )*(rp + 12)) >> 4;
#line 491
  if (adt < 8) {
    {
#line 492
    printf((char const   */* __restrict  */)"  attached device type: %s\n", smp_attached_device_type[adt]);
    }
  }
#line 493
  if (op->do_brief > 1) {
#line 493
    if (0 == adt) {
#line 494
      return (0);
    }
  }
#line 495
  if (0 == op->do_brief) {
    {
#line 496
    tmp___0 = smp_get_reason(15 & (int )*(rp + 12), (int )sizeof(b), b);
#line 496
    printf((char const   */* __restrict  */)"  attached reason: %s\n", tmp___0);
    }
  }
  {
#line 499
  tmp___1 = smp_get_neg_xxx_link_rate(15 & (int )*(rp + 13), (int )sizeof(b), b);
#line 499
  printf((char const   */* __restrict  */)"  negotiated logical link rate: %s\n",
         tmp___1);
#line 501
  printf((char const   */* __restrict  */)"  attached initiator: ssp=%d stp=%d smp=%d sata_host=%d\n",
         ! (! ((int const   )*(rp + 14) & 8)), ! (! ((int const   )*(rp + 14) & 4)),
         ! (! ((int const   )*(rp + 14) & 2)), (int const   )*(rp + 14) & 1);
  }
#line 503
  if (0 == op->do_brief) {
    {
#line 504
    printf((char const   */* __restrict  */)"  attached sata port selector: %d\n",
           ! (! ((int const   )*(rp + 15) & 128)));
#line 505
    printf((char const   */* __restrict  */)"  STP buffer too small: %d\n", ! (! ((int const   )*(rp + 15) & 16)));
    }
  }
  {
#line 507
  printf((char const   */* __restrict  */)"  attached target: ssp=%d stp=%d smp=%d sata_device=%d\n",
         ! (! ((int const   )*(rp + 15) & 8)), ! (! ((int const   )*(rp + 15) & 4)),
         ! (! ((int const   )*(rp + 15) & 2)), (int const   )*(rp + 15) & 1);
#line 510
  ull = 0ULL;
#line 511
  j = 0;
  }
  {
#line 511
  while (1) {
    while_continue: /* CIL Label */ ;
#line 511
    if (! (j < 8)) {
#line 511
      goto while_break;
    }
#line 512
    if (j > 0) {
#line 513
      ull <<= 8;
    }
#line 514
    ull |= (unsigned long long )*(rp + (16 + j));
#line 511
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 516
  printf((char const   */* __restrict  */)"  SAS address: 0x%llx\n", ull);
#line 517
  ull = 0ULL;
#line 518
  j = 0;
  }
  {
#line 518
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 518
    if (! (j < 8)) {
#line 518
      goto while_break___0;
    }
#line 519
    if (j > 0) {
#line 520
      ull <<= 8;
    }
#line 521
    ull |= (unsigned long long )*(rp + (24 + j));
#line 518
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 523
  printf((char const   */* __restrict  */)"  attached SAS address: 0x%llx\n", ull);
#line 524
  printf((char const   */* __restrict  */)"  attached phy identifier: %d\n", (int const   )*(rp + 32));
  }
#line 525
  if (0 == op->do_brief) {
    {
#line 526
    printf((char const   */* __restrict  */)"  attached power capable: %d\n", ((int const   )*(rp + 33) >> 5) & 3);
#line 527
    printf((char const   */* __restrict  */)"  attached slumber capable: %d\n", ! (! ((int const   )*(rp + 33) & 16)));
#line 528
    printf((char const   */* __restrict  */)"  attached partial capable: %d\n", ! (! ((int const   )*(rp + 33) & 8)));
#line 529
    printf((char const   */* __restrict  */)"  attached inside ZPSDS persistent: %d\n",
           ! (! ((int const   )*(rp + 33) & 4)));
#line 530
    printf((char const   */* __restrict  */)"  attached requested inside ZPSDS: %d\n",
           ! (! ((int const   )*(rp + 33) & 2)));
#line 531
    printf((char const   */* __restrict  */)"  attached break_reply capable: %d\n",
           ! (! ((int const   )*(rp + 33) & 1)));
#line 532
    tmp___2 = smp_get_plink_rate((int )(((int const   )*(rp + 40) >> 4) & 15), 1,
                                 (int )sizeof(b), b);
#line 532
    printf((char const   */* __restrict  */)"  programmed minimum physical link rate: %s\n",
           tmp___2);
#line 535
    tmp___3 = smp_get_plink_rate((int )((int const   )*(rp + 40) & 15), 0, (int )sizeof(b),
                                 b);
#line 535
    printf((char const   */* __restrict  */)"  hardware minimum physical link rate: %s\n",
           tmp___3);
#line 537
    tmp___4 = smp_get_plink_rate((int )(((int const   )*(rp + 41) >> 4) & 15), 1,
                                 (int )sizeof(b), b);
#line 537
    printf((char const   */* __restrict  */)"  programmed maximum physical link rate: %s\n",
           tmp___4);
#line 540
    tmp___5 = smp_get_plink_rate((int )((int const   )*(rp + 41) & 15), 0, (int )sizeof(b),
                                 b);
#line 540
    printf((char const   */* __restrict  */)"  hardware maximum physical link rate: %s\n",
           tmp___5);
#line 543
    printf((char const   */* __restrict  */)"  phy change count: %d\n", (int const   )*(rp + 42));
#line 544
    printf((char const   */* __restrict  */)"  virtual phy: %d\n", ! (! ((int const   )*(rp + 43) & 128)));
#line 545
    printf((char const   */* __restrict  */)"  partial pathway timeout value: %d us\n",
           (int const   )*(rp + 43) & 15);
    }
  }
#line 548
  route_attr = 15 & (int )*(rp + 44);
  {
#line 550
  if (route_attr == 0) {
#line 550
    goto case_0;
  }
#line 551
  if (route_attr == 1) {
#line 551
    goto case_1;
  }
#line 552
  if (route_attr == 2) {
#line 552
    goto case_2;
  }
#line 553
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 550
  snprintf((char */* __restrict  */)(b), sizeof(b), (char const   */* __restrict  */)"direct");
  }
#line 550
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 551
  snprintf((char */* __restrict  */)(b), sizeof(b), (char const   */* __restrict  */)"subtractive");
  }
#line 551
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 552
  snprintf((char */* __restrict  */)(b), sizeof(b), (char const   */* __restrict  */)"table");
  }
#line 552
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 553
  snprintf((char */* __restrict  */)(b), sizeof(b), (char const   */* __restrict  */)"reserved [%d]",
           route_attr);
  }
#line 553
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 555
  printf((char const   */* __restrict  */)"  routing attribute: %s\n", b);
  }
#line 556
  if (op->do_brief) {
#line 557
    if (len > 59) {
#line 557
      if ((int const   )*(rp + 60) & 1) {
        {
#line 558
        printf((char const   */* __restrict  */)"  zone group: %d\n", (int const   )*(rp + 63));
        }
      }
    }
#line 559
    return (0);
  }
  {
#line 561
  tmp___6 = find_sas_connector_type((int )((int const   )*(rp + 45) & 127), b, (int )sizeof(b));
#line 561
  printf((char const   */* __restrict  */)"  connector type: %s\n", tmp___6);
#line 563
  printf((char const   */* __restrict  */)"  connector element index: %d\n", (int const   )*(rp + 46));
#line 564
  printf((char const   */* __restrict  */)"  connector physical link: %d\n", (int const   )*(rp + 47));
#line 565
  printf((char const   */* __restrict  */)"  phy power condition: %d\n", ((int const   )*(rp + 48) & 192) >> 6);
#line 566
  printf((char const   */* __restrict  */)"  sas slumber capable: %d\n", ! (! ((int const   )*(rp + 48) & 8)));
#line 567
  printf((char const   */* __restrict  */)"  sas partial capable: %d\n", ! (! ((int const   )*(rp + 48) & 4)));
#line 568
  printf((char const   */* __restrict  */)"  sata slumber capable: %d\n", ! (! ((int const   )*(rp + 48) & 2)));
#line 569
  printf((char const   */* __restrict  */)"  sata partial capable: %d\n", ! (! ((int const   )*(rp + 48) & 1)));
#line 570
  printf((char const   */* __restrict  */)"  sas slumber enabled: %d\n", ! (! ((int const   )*(rp + 49) & 8)));
#line 571
  printf((char const   */* __restrict  */)"  sas partial enabled: %d\n", ! (! ((int const   )*(rp + 49) & 4)));
#line 572
  printf((char const   */* __restrict  */)"  sata slumber enabled: %d\n", ! (! ((int const   )*(rp + 49) & 2)));
#line 573
  printf((char const   */* __restrict  */)"  sata partial enabled: %d\n", ! (! ((int const   )*(rp + 49) & 1)));
  }
#line 574
  if (len > 59) {
#line 575
    ull = 0ULL;
#line 576
    j = 0;
    {
#line 576
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 576
      if (! (j < 8)) {
#line 576
        goto while_break___1;
      }
#line 577
      if (j > 0) {
#line 578
        ull <<= 8;
      }
#line 579
      ull |= (unsigned long long )*(rp + (52 + j));
#line 576
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 581
    printf((char const   */* __restrict  */)"  attached device name: 0x%llx\n", ull);
#line 582
    printf((char const   */* __restrict  */)"  requested inside ZPSDS changed by expander: %d\n",
           ! (! ((int const   )*(rp + 60) & 64)));
#line 584
    printf((char const   */* __restrict  */)"  inside ZPSDS persistent: %d\n", ! (! ((int const   )*(rp + 60) & 32)));
#line 585
    printf((char const   */* __restrict  */)"  requested inside ZPSDS: %d\n", ! (! ((int const   )*(rp + 60) & 16)));
#line 587
    printf((char const   */* __restrict  */)"  zone group persistent: %d\n", ! (! ((int const   )*(rp + 60) & 4)));
#line 588
    printf((char const   */* __restrict  */)"  inside ZPSDS: %d\n", ! (! ((int const   )*(rp + 60) & 2)));
#line 589
    printf((char const   */* __restrict  */)"  zoning enabled: %d\n", ! (! ((int const   )*(rp + 60) & 1)));
#line 590
    printf((char const   */* __restrict  */)"  zone group: %d\n", (int const   )*(rp + 63));
    }
#line 591
    if (len < 76) {
#line 592
      return (0);
    }
    {
#line 593
    printf((char const   */* __restrict  */)"  self-configuration status: %d\n", (int const   )*(rp + 64));
#line 594
    printf((char const   */* __restrict  */)"  self-configuration level completed: %d\n",
           (int const   )*(rp + 65));
#line 595
    ull = 0ULL;
#line 596
    j = 0;
    }
    {
#line 596
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 596
      if (! (j < 8)) {
#line 596
        goto while_break___2;
      }
#line 597
      if (j > 0) {
#line 598
        ull <<= 8;
      }
#line 599
      ull |= (unsigned long long )*(rp + (68 + j));
#line 596
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 601
    printf((char const   */* __restrict  */)"  self-configuration sas address: 0x%llx\n",
           ull);
#line 602
    ui = 0U;
#line 603
    j = 0;
    }
    {
#line 603
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 603
      if (! (j < 4)) {
#line 603
        goto while_break___3;
      }
#line 604
      if (j > 0) {
#line 605
        ui <<= 8;
      }
#line 606
      ui |= (unsigned int )*(rp + (76 + j));
#line 603
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 608
    printf((char const   */* __restrict  */)"  programmed phy capabilities: 0x%x\n",
           ui);
#line 609
    ui = 0U;
#line 610
    j = 0;
    }
    {
#line 610
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 610
      if (! (j < 4)) {
#line 610
        goto while_break___4;
      }
#line 611
      if (j > 0) {
#line 612
        ui <<= 8;
      }
#line 613
      ui |= (unsigned int )*(rp + (80 + j));
#line 610
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 615
    printf((char const   */* __restrict  */)"  current phy capabilities: 0x%x\n",
           ui);
#line 616
    ui = 0U;
#line 617
    j = 0;
    }
    {
#line 617
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 617
      if (! (j < 4)) {
#line 617
        goto while_break___5;
      }
#line 618
      if (j > 0) {
#line 619
        ui <<= 8;
      }
#line 620
      ui |= (unsigned int )*(rp + (84 + j));
#line 617
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 622
    printf((char const   */* __restrict  */)"  attached phy capabilities: 0x%x\n",
           ui);
    }
  }
#line 624
  if (len > 95) {
    {
#line 625
    tmp___7 = smp_get_reason((240 & (int )*(rp + 94)) >> 4, (int )sizeof(b), b);
#line 625
    printf((char const   */* __restrict  */)"  reason: %s\n", tmp___7);
#line 627
    tmp___8 = smp_get_neg_xxx_link_rate(15 & (int )*(rp + 94), (int )sizeof(b), b);
#line 627
    printf((char const   */* __restrict  */)"  negotiated physical link rate: %s\n",
           tmp___8);
#line 629
    printf((char const   */* __restrict  */)"  optical mode enabled: %d\n", ! (! ((int const   )*(rp + 95) & 4)));
#line 630
    printf((char const   */* __restrict  */)"  negotiated SSC: %d\n", ! (! ((int const   )*(rp + 95) & 2)));
#line 631
    printf((char const   */* __restrict  */)"  hardware muxing supported: %d\n", ! (! ((int const   )*(rp + 95) & 1)));
    }
  }
#line 633
  if (len > 107) {
    {
#line 634
    printf((char const   */* __restrict  */)"  default inside ZPSDS persistent: %d\n",
           ! (! ((int const   )*(rp + 96) & 32)));
#line 635
    printf((char const   */* __restrict  */)"  default requested inside ZPSDS: %d\n",
           ! (! ((int const   )*(rp + 96) & 16)));
#line 636
    printf((char const   */* __restrict  */)"  default zone group persistent: %d\n",
           ! (! ((int const   )*(rp + 96) & 4)));
#line 637
    printf((char const   */* __restrict  */)"  default zoning enabled: %d\n", ! (! ((int const   )*(rp + 96) & 1)));
#line 638
    printf((char const   */* __restrict  */)"  default zone group: %d\n", (int const   )*(rp + 99));
#line 639
    printf((char const   */* __restrict  */)"  saved inside ZPSDS persistent: %d\n",
           ! (! ((int const   )*(rp + 100) & 32)));
#line 640
    printf((char const   */* __restrict  */)"  saved requested inside ZPSDS: %d\n",
           ! (! ((int const   )*(rp + 100) & 16)));
#line 641
    printf((char const   */* __restrict  */)"  saved zone group persistent: %d\n",
           ! (! ((int const   )*(rp + 100) & 4)));
#line 642
    printf((char const   */* __restrict  */)"  saved zoning enabled: %d\n", ! (! ((int const   )*(rp + 100) & 1)));
#line 643
    printf((char const   */* __restrict  */)"  saved zone group: %d\n", (int const   )*(rp + 103));
#line 644
    printf((char const   */* __restrict  */)"  shadow inside ZPSDS persistent: %d\n",
           ! (! ((int const   )*(rp + 104) & 32)));
#line 645
    printf((char const   */* __restrict  */)"  shadow requested inside ZPSDS: %d\n",
           ! (! ((int const   )*(rp + 104) & 16)));
#line 646
    printf((char const   */* __restrict  */)"  shadow zone group persistent: %d\n",
           ! (! ((int const   )*(rp + 104) & 4)));
#line 648
    printf((char const   */* __restrict  */)"  shadow zoning enabled: %d\n", ! (! ((int const   )*(rp + 104) & 1)));
#line 649
    printf((char const   */* __restrict  */)"  shadow zone group: %d\n", (int const   )*(rp + 107));
    }
  }
#line 651
  if (len > 115) {
    {
#line 652
    printf((char const   */* __restrict  */)"  device slot number: %d\n", (int const   )*(rp + 108));
#line 653
    printf((char const   */* __restrict  */)"  device slot group number: %d\n", (int const   )*(rp + 109));
#line 654
    printf((char const   */* __restrict  */)"  device slot group output connector: %.6s\n",
           rp + 110);
    }
  }
#line 657
  if (len > 117) {
    {
#line 658
    printf((char const   */* __restrict  */)"  STP buffer size: %d\n", ((int const   )*(rp + 116) << 8) + (int const   )*(rp + 117));
    }
  }
#line 659
  return (0);
}
}
#line 664 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover_list.c"
static int decode_desc1_multiline(unsigned char const   *resp , int offset , int z_supported ,
                                  struct opts_t *op ) 
{ 
  unsigned char const   *rp ;
  unsigned long long ull ;
  int func_res ;
  int phy_id ;
  int adt ;
  int route_attr ;
  int j ;
  char b[256] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 673
  rp = resp + offset;
#line 674
  phy_id = (int )*(rp + 0);
#line 675
  func_res = (int )*(rp + 1);
#line 676
  printf((char const   */* __restrict  */)"  phy identifier: %d\n", phy_id);
  }
#line 677
  if (22 == func_res) {
    {
#line 678
    printf((char const   */* __restrict  */)"  inaccessible (phy vacant)\n");
    }
#line 679
    return (0);
  } else
#line 680
  if (func_res) {
    {
#line 681
    tmp = smp_get_func_res_str(func_res, (int )sizeof(b), b);
#line 681
    printf((char const   */* __restrict  */)"  >>> function result: %s\n", tmp);
    }
#line 683
    return (-1);
  }
#line 685
  adt = (112 & (int )*(rp + 2)) >> 4;
#line 686
  if (adt < 8) {
    {
#line 687
    printf((char const   */* __restrict  */)"  attached device type: %s\n", smp_attached_device_type[adt]);
    }
  }
#line 688
  if (op->do_brief > 1) {
#line 688
    if (0 == adt) {
#line 689
      return (0);
    }
  }
#line 690
  if (0 == op->do_brief) {
    {
#line 691
    tmp___0 = smp_get_reason(15 & (int )*(rp + 2), (int )sizeof(b), b);
#line 691
    printf((char const   */* __restrict  */)"  attached reason: %s\n", tmp___0);
    }
  }
  {
#line 693
  tmp___1 = smp_get_neg_xxx_link_rate(15 & (int )*(rp + 3), (int )sizeof(b), b);
#line 693
  printf((char const   */* __restrict  */)"  negotiated logical link rate: %s\n",
         tmp___1);
#line 696
  printf((char const   */* __restrict  */)"  attached initiator: ssp=%d stp=%d smp=%d sata_host=%d\n",
         ! (! ((int const   )*(rp + 4) & 8)), ! (! ((int const   )*(rp + 4) & 4)),
         ! (! ((int const   )*(rp + 4) & 2)), (int const   )*(rp + 4) & 1);
  }
#line 698
  if (0 == op->do_brief) {
    {
#line 699
    printf((char const   */* __restrict  */)"  attached sata port selector: %d\n",
           ! (! ((int const   )*(rp + 5) & 128)));
    }
  }
  {
#line 700
  printf((char const   */* __restrict  */)"  attached target: ssp=%d stp=%d smp=%d sata_device=%d\n",
         ! (! ((int const   )*(rp + 5) & 8)), ! (! ((int const   )*(rp + 5) & 4)),
         ! (! ((int const   )*(rp + 5) & 2)), (int const   )*(rp + 5) & 1);
  }
#line 703
  if (0 == op->do_brief) {
    {
#line 704
    printf((char const   */* __restrict  */)"  virtual phy: %d\n", ! (! ((int const   )*(rp + 6) & 128)));
    }
  }
#line 705
  ull = 0ULL;
#line 706
  j = 0;
  {
#line 706
  while (1) {
    while_continue: /* CIL Label */ ;
#line 706
    if (! (j < 8)) {
#line 706
      goto while_break;
    }
#line 707
    if (j > 0) {
#line 708
      ull <<= 8;
    }
#line 709
    ull |= (unsigned long long )*(rp + (12 + j));
#line 706
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 711
  printf((char const   */* __restrict  */)"  attached SAS address: 0x%llx\n", ull);
#line 712
  printf((char const   */* __restrict  */)"  attached phy identifier: %d\n", (int const   )*(rp + 10));
  }
#line 713
  if (0 == op->do_brief) {
    {
#line 714
    printf((char const   */* __restrict  */)"  phy change count: %d\n", (int const   )*(rp + 11));
    }
  }
#line 715
  route_attr = 15 & (int )*(rp + 6);
  {
#line 717
  if (route_attr == 0) {
#line 717
    goto case_0;
  }
#line 718
  if (route_attr == 1) {
#line 718
    goto case_1;
  }
#line 719
  if (route_attr == 2) {
#line 719
    goto case_2;
  }
#line 720
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 717
  snprintf((char */* __restrict  */)(b), sizeof(b), (char const   */* __restrict  */)"direct");
  }
#line 717
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 718
  snprintf((char */* __restrict  */)(b), sizeof(b), (char const   */* __restrict  */)"subtractive");
  }
#line 718
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 719
  snprintf((char */* __restrict  */)(b), sizeof(b), (char const   */* __restrict  */)"table");
  }
#line 719
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 720
  snprintf((char */* __restrict  */)(b), sizeof(b), (char const   */* __restrict  */)"reserved [%d]",
           route_attr);
  }
#line 720
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 722
  printf((char const   */* __restrict  */)"  routing attribute: %s\n", b);
  }
#line 723
  if (op->do_brief) {
#line 724
    if (z_supported) {
      {
#line 725
      printf((char const   */* __restrict  */)"  zone group: %d\n", (int const   )*(rp + 8));
      }
    }
#line 726
    return (0);
  }
  {
#line 728
  tmp___2 = smp_get_reason(15 & (int )((int const   )*(rp + 7) >> 4), (int )sizeof(b),
                           b);
#line 728
  printf((char const   */* __restrict  */)"  reason: %s\n", tmp___2);
#line 730
  tmp___3 = smp_get_neg_xxx_link_rate(15 & (int )*(rp + 7), (int )sizeof(b), b);
#line 730
  printf((char const   */* __restrict  */)"  negotiated physical link rate: %s\n",
         tmp___3);
#line 732
  printf((char const   */* __restrict  */)"  zone group: %d\n", (int const   )*(rp + 8));
#line 733
  printf((char const   */* __restrict  */)"  inside ZPSDS persistent: %d\n", ! (! ((int const   )*(rp + 9) & 32)));
#line 734
  printf((char const   */* __restrict  */)"  requested inside ZPSDS: %d\n", ! (! ((int const   )*(rp + 9) & 16)));
#line 736
  printf((char const   */* __restrict  */)"  zone group persistent: %d\n", ! (! ((int const   )*(rp + 9) & 4)));
#line 737
  printf((char const   */* __restrict  */)"  inside ZPSDS: %d\n", ! (! ((int const   )*(rp + 9) & 2)));
  }
#line 738
  return (0);
}
}
#line 744 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover_list.c"
static int decode_1line(unsigned char const   *resp , int offset , int desc , int z_supported ,
                        struct opts_t *op ) 
{ 
  unsigned char const   *rp ;
  unsigned long long ull ;
  unsigned long long adn ;
  int phy_id ;
  int j ;
  int off ;
  int plus ;
  int negot ;
  int adt ;
  int route_attr ;
  int vp ;
  int asa_off ;
  int func_res ;
  int aphy_id ;
  int a_init ;
  int a_target ;
  int z_group ;
  int iz_mask ;
  int zg_not1 ;
  char b[256] ;
  char const   *cp ;
  char *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  int tmp___18 ;
  char const   *tmp___19 ;
  int tmp___20 ;

  {
#line 752
  zg_not1 = 0;
#line 756
  rp = resp + offset;
  {
#line 758
  if (desc == 0) {
#line 758
    goto case_0;
  }
#line 772
  if (desc == 1) {
#line 772
    goto case_1;
  }
#line 786
  goto switch_default;
  case_0: /* CIL Label */ 
#line 759
  phy_id = (int )*(rp + 9);
#line 760
  func_res = (int )*(rp + 2);
#line 761
  adt = (112 & (int )*(rp + 12)) >> 4;
#line 762
  negot = (int )((int const   )*(rp + 13) & 15);
#line 763
  route_attr = (int )((int const   )*(rp + 44) & 15);
#line 764
  vp = (int )((int const   )*(rp + 43) & 128);
#line 765
  asa_off = 24;
#line 766
  aphy_id = (int )*(rp + 32);
#line 767
  a_init = (int )*(rp + 14);
#line 768
  a_target = (int )*(rp + 15);
#line 769
  z_group = (int )*(rp + 63);
#line 770
  iz_mask = (int )*(rp + 60);
#line 771
  goto switch_break;
  case_1: /* CIL Label */ 
#line 773
  phy_id = (int )*(rp + 0);
#line 774
  func_res = (int )*(rp + 1);
#line 775
  adt = (112 & (int )*(rp + 2)) >> 4;
#line 776
  negot = (int )((int const   )*(rp + 3) & 15);
#line 777
  route_attr = (int )((int const   )*(rp + 6) & 15);
#line 778
  vp = ! (! ((int const   )*(rp + 6) & 128));
#line 779
  asa_off = 12;
#line 780
  aphy_id = (int )*(rp + 10);
#line 781
  a_init = (int )*(rp + 4);
#line 782
  a_target = (int )*(rp + 5);
#line 783
  z_group = (int )*(rp + 8);
#line 784
  iz_mask = (int )*(rp + 9);
#line 785
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 787
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  Unknown descriptor type %d\n",
          desc);
  }
#line 788
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 790
  if (op->zpi_fn) {
#line 791
    if (func_res) {
#line 791
      if (22 != func_res) {
        {
#line 792
        tmp = smp_get_func_res_str(func_res, (int )sizeof(b), b);
#line 792
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  >>> function result: %s\n",
                tmp);
        }
#line 794
        return (-1);
      }
    }
    {
#line 796
    snprintf((char */* __restrict  */)(b), sizeof(b) - 1UL, (char const   */* __restrict  */)"%x,%x,0,%x\n",
             phy_id, iz_mask & 52, z_group);
#line 798
    b[sizeof(b) - 1UL] = (char )'\000';
#line 799
    fprintf((FILE */* __restrict  */)op->zpi_filep, (char const   */* __restrict  */)"%s",
            b);
    }
#line 800
    return (0);
  }
#line 802
  if (22 == func_res) {
    {
#line 803
    printf((char const   */* __restrict  */)"  phy %3d: inaccessible (phy vacant)\n",
           phy_id);
    }
#line 804
    return (0);
  } else
#line 805
  if (func_res) {
    {
#line 806
    tmp___0 = smp_get_func_res_str(func_res, (int )sizeof(b), b);
#line 806
    printf((char const   */* __restrict  */)"  phy %3d: function result: %s\n", phy_id,
           tmp___0);
    }
#line 808
    return (-1);
  }
#line 810
  if (0 == op->verbose) {
#line 810
    if (0 == adt) {
#line 810
      if (op->do_brief > 1) {
#line 811
        return (0);
      }
    }
  }
  {
#line 814
  if (route_attr == 0) {
#line 814
    goto case_0___0;
  }
#line 817
  if (route_attr == 1) {
#line 817
    goto case_1___0;
  }
#line 820
  if (route_attr == 2) {
#line 820
    goto case_2;
  }
#line 823
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
#line 815
  cp = "D";
#line 816
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 818
  cp = "S";
#line 819
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 821
  cp = "T";
#line 822
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 824
  cp = "R";
#line 825
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 827
  if (1 == negot) {
    {
#line 828
    printf((char const   */* __restrict  */)"  phy %3d:%s:disabled\n", phy_id, cp);
    }
#line 829
    return (0);
  } else
#line 830
  if (2 == negot) {
    {
#line 831
    printf((char const   */* __restrict  */)"  phy %3d:%s:reset problem\n", phy_id,
           cp);
    }
#line 832
    return (0);
  } else
#line 833
  if (3 == negot) {
    {
#line 834
    printf((char const   */* __restrict  */)"  phy %3d:%s:spinup hold\n", phy_id,
           cp);
    }
#line 835
    return (0);
  } else
#line 836
  if (4 == negot) {
    {
#line 837
    printf((char const   */* __restrict  */)"  phy %3d:%s:port selector\n", phy_id,
           cp);
    }
#line 838
    return (0);
  } else
#line 839
  if (5 == negot) {
    {
#line 840
    printf((char const   */* __restrict  */)"  phy %3d:%s:reset in progress\n", phy_id,
           cp);
    }
#line 841
    return (0);
  }
#line 843
  if (0 == op->verbose) {
#line 843
    if (0 == adt) {
#line 843
      if (op->do_brief) {
#line 844
        return (0);
      }
    }
  }
#line 845
  ull = 0ULL;
#line 846
  j = 0;
  {
#line 846
  while (1) {
    while_continue: /* CIL Label */ ;
#line 846
    if (! (j < 8)) {
#line 846
      goto while_break;
    }
#line 847
    if (j > 0) {
#line 848
      ull <<= 8;
    }
#line 849
    ull |= (unsigned long long )*(rp + (asa_off + j));
#line 846
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 851
  if (0 == adt) {
#line 851
    goto _L;
  } else
#line 851
  if (adt > 3) {
    _L: /* CIL Label */ 
    {
#line 852
    printf((char const   */* __restrict  */)"  phy %3d:%s:attached:[0000000000000000:00]",
           phy_id, cp);
    }
#line 853
    if (op->do_brief > 1) {
      {
#line 854
      printf((char const   */* __restrict  */)"\n");
      }
#line 855
      return (0);
    } else
#line 853
    if (op->do_adn) {
      {
#line 854
      printf((char const   */* __restrict  */)"\n");
      }
#line 855
      return (0);
    }
#line 857
    if (z_supported) {
#line 857
      if (1 != z_group) {
        {
#line 858
        zg_not1 ++;
#line 859
        printf((char const   */* __restrict  */)"  ZG:%d\n", z_group);
        }
      } else {
        {
#line 861
        printf((char const   */* __restrict  */)"\n");
        }
      }
    } else {
      {
#line 861
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 862
    return (! (! zg_not1));
  }
#line 864
  if (0 == desc) {
#line 864
    if (op->do_adn) {
#line 865
      adn = 0ULL;
#line 866
      j = 0;
      {
#line 866
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 866
        if (! (j < 8)) {
#line 866
          goto while_break___0;
        }
#line 867
        if (j > 0) {
#line 868
          adn <<= 8;
        }
#line 869
        adn |= (unsigned long long )*(rp + (52 + j));
#line 866
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 871
      if (vp) {
#line 871
        tmp___1 = " V";
      } else {
#line 871
        tmp___1 = "";
      }
      {
#line 871
      printf((char const   */* __restrict  */)"  phy %3d:%s:attached:[%016llx:%02d %016llx %s%s",
             phy_id, cp, ull, aphy_id, adn, smp_short_attached_device_type[adt], tmp___1);
      }
    } else {
#line 864
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 875
    if (vp) {
#line 875
      tmp___2 = " V";
    } else {
#line 875
      tmp___2 = "";
    }
    {
#line 875
    printf((char const   */* __restrict  */)"  phy %3d:%s:attached:[%016llx:%02d %s%s",
           phy_id, cp, ull, aphy_id, smp_short_attached_device_type[adt], tmp___2);
    }
  }
#line 878
  if (a_init & 15) {
    {
#line 879
    off = 0;
#line 880
    plus = 0;
#line 881
    tmp___3 = snprintf((char */* __restrict  */)(b + off), sizeof(b) - (unsigned long )off,
                       (char const   */* __restrict  */)" i(");
#line 881
    off += tmp___3;
    }
#line 882
    if (a_init & 8) {
      {
#line 883
      tmp___4 = snprintf((char */* __restrict  */)(b + off), sizeof(b) - (unsigned long )off,
                         (char const   */* __restrict  */)"SSP");
#line 883
      off += tmp___4;
#line 884
      plus ++;
      }
    }
#line 886
    if (a_init & 4) {
#line 887
      if (plus) {
#line 887
        tmp___5 = "+";
      } else {
#line 887
        tmp___5 = "";
      }
      {
#line 887
      tmp___6 = snprintf((char */* __restrict  */)(b + off), sizeof(b) - (unsigned long )off,
                         (char const   */* __restrict  */)"%sSTP", tmp___5);
#line 887
      off += tmp___6;
#line 889
      plus ++;
      }
    }
#line 891
    if (a_init & 2) {
#line 892
      if (plus) {
#line 892
        tmp___7 = "+";
      } else {
#line 892
        tmp___7 = "";
      }
      {
#line 892
      tmp___8 = snprintf((char */* __restrict  */)(b + off), sizeof(b) - (unsigned long )off,
                         (char const   */* __restrict  */)"%sSMP", tmp___7);
#line 892
      off += tmp___8;
#line 894
      plus ++;
      }
    }
#line 896
    if (a_init & 1) {
#line 897
      if (plus) {
#line 897
        tmp___9 = "+";
      } else {
#line 897
        tmp___9 = "";
      }
      {
#line 897
      tmp___10 = snprintf((char */* __restrict  */)(b + off), sizeof(b) - (unsigned long )off,
                          (char const   */* __restrict  */)"%sSATA", tmp___9);
#line 897
      off += tmp___10;
#line 899
      plus ++;
      }
    }
    {
#line 901
    printf((char const   */* __restrict  */)"%s)", b);
    }
  }
#line 903
  if (a_target & 15) {
    {
#line 904
    off = 0;
#line 905
    plus = 0;
#line 906
    tmp___11 = snprintf((char */* __restrict  */)(b + off), sizeof(b) - (unsigned long )off,
                        (char const   */* __restrict  */)" t(");
#line 906
    off += tmp___11;
    }
#line 907
    if (a_target & 128) {
      {
#line 908
      tmp___12 = snprintf((char */* __restrict  */)(b + off), sizeof(b) - (unsigned long )off,
                          (char const   */* __restrict  */)"PORT_SEL");
#line 908
      off += tmp___12;
#line 909
      plus ++;
      }
    }
#line 911
    if (a_target & 8) {
#line 912
      if (plus) {
#line 912
        tmp___13 = "+";
      } else {
#line 912
        tmp___13 = "";
      }
      {
#line 912
      tmp___14 = snprintf((char */* __restrict  */)(b + off), sizeof(b) - (unsigned long )off,
                          (char const   */* __restrict  */)"%sSSP", tmp___13);
#line 912
      off += tmp___14;
#line 914
      plus ++;
      }
    }
#line 916
    if (a_target & 4) {
#line 917
      if (plus) {
#line 917
        tmp___15 = "+";
      } else {
#line 917
        tmp___15 = "";
      }
      {
#line 917
      tmp___16 = snprintf((char */* __restrict  */)(b + off), sizeof(b) - (unsigned long )off,
                          (char const   */* __restrict  */)"%sSTP", tmp___15);
#line 917
      off += tmp___16;
#line 919
      plus ++;
      }
    }
#line 921
    if (a_target & 2) {
#line 922
      if (plus) {
#line 922
        tmp___17 = "+";
      } else {
#line 922
        tmp___17 = "";
      }
      {
#line 922
      tmp___18 = snprintf((char */* __restrict  */)(b + off), sizeof(b) - (unsigned long )off,
                          (char const   */* __restrict  */)"%sSMP", tmp___17);
#line 922
      off += tmp___18;
#line 924
      plus ++;
      }
    }
#line 926
    if (a_target & 1) {
#line 927
      if (plus) {
#line 927
        tmp___19 = "+";
      } else {
#line 927
        tmp___19 = "";
      }
      {
#line 927
      tmp___20 = snprintf((char */* __restrict  */)(b + off), sizeof(b) - (unsigned long )off,
                          (char const   */* __restrict  */)"%sSATA", tmp___19);
#line 927
      off += tmp___20;
#line 929
      plus ++;
      }
    }
    {
#line 931
    printf((char const   */* __restrict  */)"%s)", b);
    }
  }
  {
#line 933
  printf((char const   */* __restrict  */)"]");
  }
#line 934
  if (op->do_brief < 2) {
#line 934
    if (0 == op->do_adn) {
      {
#line 936
      if (negot == 8) {
#line 936
        goto case_8;
      }
#line 939
      if (negot == 9) {
#line 939
        goto case_9;
      }
#line 942
      if (negot == 10) {
#line 942
        goto case_10;
      }
#line 945
      if (negot == 11) {
#line 945
        goto case_11;
      }
#line 948
      goto switch_default___1;
      case_8: /* CIL Label */ 
#line 937
      cp = "  1.5 Gbps";
#line 938
      goto switch_break___1;
      case_9: /* CIL Label */ 
#line 940
      cp = "  3 Gbps";
#line 941
      goto switch_break___1;
      case_10: /* CIL Label */ 
#line 943
      cp = "  6 Gbps";
#line 944
      goto switch_break___1;
      case_11: /* CIL Label */ 
#line 946
      cp = "  12 Gbps";
#line 947
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
#line 949
      cp = "";
#line 950
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
      {
#line 952
      printf((char const   */* __restrict  */)"%s", cp);
      }
#line 953
      if (z_supported) {
#line 953
        if (1 != z_group) {
          {
#line 954
          zg_not1 ++;
#line 955
          printf((char const   */* __restrict  */)"  ZG:%d", z_group);
          }
        }
      }
    }
  }
  {
#line 958
  printf((char const   */* __restrict  */)"\n");
  }
#line 959
  return (! (! zg_not1));
}
}
#line 962 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover_list.c"
static void output_header_info(unsigned char const   *resp , struct opts_t *op ) 
{ 
  int hdr_ecc ;
  int sphy_id ;
  int z_enabled ;

  {
#line 967
  hdr_ecc = (int )(((int const   )*(resp + 4) << 8) + (int const   )*(resp + 5));
#line 968
  sphy_id = (int )*(resp + 8);
#line 969
  z_enabled = ! (! ((int const   )*(resp + 16) & 64));
#line 971
  if (op->zpi_fn) {
#line 972
    if (0 == op->do_brief) {
      {
#line 973
      fprintf((FILE */* __restrict  */)op->zpi_filep, (char const   */* __restrict  */)"# Zone phy information from DISCOVER LIST:\n");
#line 975
      fprintf((FILE */* __restrict  */)op->zpi_filep, (char const   */* __restrict  */)"#  expander change count: %d\n",
              hdr_ecc);
#line 977
      fprintf((FILE */* __restrict  */)op->zpi_filep, (char const   */* __restrict  */)"#  starting phy id: %d\n",
              sphy_id);
#line 978
      fprintf((FILE */* __restrict  */)op->zpi_filep, (char const   */* __restrict  */)"#  maximum number of phys output: %d\n",
              op->do_num);
#line 980
      fprintf((FILE */* __restrict  */)op->zpi_filep, (char const   */* __restrict  */)"#  zoning enabled: %d\n",
              z_enabled);
#line 981
      fprintf((FILE */* __restrict  */)op->zpi_filep, (char const   */* __restrict  */)"#\n# Values below are in hex, phy_id in first column, zone group in last\n");
      }
    }
  } else {
#line 985
    if (! op->do_1line) {
      {
#line 986
      printf((char const   */* __restrict  */)"Discover list response header:\n");
#line 987
      printf((char const   */* __restrict  */)"  starting phy id: %d\n", sphy_id);
#line 988
      printf((char const   */* __restrict  */)"  number of discover list descriptors: %d\n",
             (int const   )*(resp + 9));
      }
    }
#line 990
    if (! op->do_1line) {
#line 990
      if (0 == op->do_brief) {
        {
#line 991
        printf((char const   */* __restrict  */)"  expander change count: %d\n", hdr_ecc);
#line 992
        printf((char const   */* __restrict  */)"  filter: %d\n", (int const   )*(resp + 10) & 15);
#line 993
        printf((char const   */* __restrict  */)"  descriptor type: %d\n", (int const   )*(resp + 11) & 15);
#line 994
        printf((char const   */* __restrict  */)"  discover list descriptor length: %d bytes\n",
               (int const   )*(resp + 12) * 4);
#line 996
        printf((char const   */* __restrict  */)"  zoning supported: %d\n", ! (! ((int const   )*(resp + 16) & 128)));
#line 997
        printf((char const   */* __restrict  */)"  zoning enabled: %d\n", z_enabled);
#line 998
        printf((char const   */* __restrict  */)"  self configuring: %d\n", ! (! ((int const   )*(resp + 16) & 8)));
#line 999
        printf((char const   */* __restrict  */)"  zone configuring: %d\n", ! (! ((int const   )*(resp + 16) & 4)));
#line 1000
        printf((char const   */* __restrict  */)"  configuring: %d\n", ! (! ((int const   )*(resp + 16) & 2)));
#line 1001
        printf((char const   */* __restrict  */)"  externally configurable route table: %d\n",
               ! (! ((int const   )*(resp + 16) & 1)));
#line 1003
        printf((char const   */* __restrict  */)"  last self-configuration status descriptor index: %d\n",
               ((int const   )*(resp + 18) << 8) + (int const   )*(resp + 19));
#line 1005
        printf((char const   */* __restrict  */)"  last phy event list descriptor index: %d\n",
               ((int const   )*(resp + 20) << 8) + (int const   )*(resp + 21));
        }
      }
    }
  }
#line 1009
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_phy_test.c"
static char *version_str___16  =    (char *)"1.11 20111222";
#line 55 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_phy_test.c"
static struct option long_options___7[17]  = 
#line 55
  {      {"control", 1, (int *)0, 'c'}, 
        {"dwords", 1, (int *)0, 'd'}, 
        {"expected", 1, (int *)0, 'E'}, 
        {"function", 1, (int *)0, 'f'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"linkrate", 1, (int *)0, 'l'}, 
        {"pattern", 1, (int *)0, 'P'}, 
        {"phy", 1, (int *)0, 'p'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"sata", 0, (int *)0, 't'}, 
        {"spread", 1, (int *)0, 'S'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 76 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_phy_test.c"
static void usage___7(void) 
{ 


  {
  {
#line 79
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_phy_test [--control=CO] [--dwords=DW] [--expected=EX]\n                    [--function=FN] [--help] [--hex] [--interface=PARAMS]\n                    [--linkrate=LR] [--pattern=PA] [--phy=ID]\n                    [--raw] [--sa=SAS_ADDR] [--sata] [--spread=SP]\n                    [--verbose] [--version] SMP_DEVICE[,N]\n  where:\n    --control=CO|-c CO     phy test pattern dwords control (def: 0)\n    --dwords=DW|-d DW      phy test pattern dwords (def:0)\n    --expected=EX|-E EX    set expected expander change count to EX\n    --function=FN|-f FN    phy test function (def:0 -> stop)\n    --help|-h              print out usage message\n    --hex|-H               print response in hexadecimal\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --linkrate=LR|-l LR    physical link rate (def: 9 -> 3 Gbps)\n    --pattern=PA|-P PA     phy test pattern (def: 2 -> CJTPAT)\n    --phy=ID|-p ID         phy identifier (def: 0)\n    --raw|-r               output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on the\n                                 interface, may not be needed\n    --sata|-t              set phy test function SATA bit (def: 0)\n    --spread=SC|-S SC      set phy test function SCC to SC (def: 0)\n    --verbose|-v           increase verbosity\n    --version|-V           print version string and exit\n\nPerforms a SMP PHY TEST FUNCTION function\n");
  }
#line 117
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_phy_test.c"
static void dStrRaw___7(char const   *str , int len ) 
{ 
  int k ;

  {
#line 124
  k = 0;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (k < len)) {
#line 124
      goto while_break;
    }
    {
#line 125
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 124
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___17  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___8[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___8[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___8[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___8  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___18  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___9[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___9[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___9[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___9  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_zone_man_pass.c"
static char *version_str___19  =    (char *)"1.02 20111222";
#line 56 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_zone_man_pass.c"
static struct option long_options___8[13]  = 
#line 56
  {      {"expected", 1, (int *)0, 'E'}, 
        {"fpass", 1, (int *)0, 'F'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"new-fpass", 1, (int *)0, 'N'}, 
        {"new-pass", 1, (int *)0, 'n'}, 
        {"password", 1, (int *)0, 'P'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"save", 1, (int *)0, 'S'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 73 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_zone_man_pass.c"
static void usage___8(void) 
{ 


  {
  {
#line 76
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_conf_zone_man_pass [--expected=EX] [--fpass=FP] [--help] [--hex]\n                              [--interface=PARAMS] [--new-fpass=NF]\n                              [--new-pass=NP] [--password=PA] [--raw]\n                              [--sa=SAS_ADDR] [--save=SAV] [--verbose]\n                              [--version] SMP_DEVICE[,N]\n  where:\n    --expected=EX|-E EX    set expected expander change count to EX\n    --fpass=FP|-F FP       file FP contains password, in hex or ASCII\n    --help|-h              print out usage message\n    --hex|-H               print response in hexadecimal\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --new-fpass=NF|-N NF    file NF contains new password, in hex or\n                           ASCII\n    --new-pass=NP|-n NP    new password NP in ASCII, padded with NULLs to\n                           be 32 bytes long (def: all NULLs)\n    --password=PA|-P PA    password PA in ASCII, padded with NULLs to\n                           be 32 bytes long (def: all NULLs)\n    --raw|-r               output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n    --save=SAV|-S SAV      SAV: 0 -> shadow (def); 1 -> saved\n                           2 -> shadow (and saved if supported))\n                           3 -> shadow and saved\n    --verbose|-v           increase verbosity\n    --version|-V           print version string and exit\n\nPerforms a SMP CONFIGURE ZONE MANAGER PASSWORD function\n");
  }
#line 120
  return;
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_zone_man_pass.c"
static int f2hex_arr(char const   *fname , unsigned char *mp_arr , int *mp_arr_len ,
                     int max_arr_len ) 
{ 
  int fn_len ;
  int in_len ;
  int k ;
  int j ;
  int m ;
  int no_space ;
  int checked_hexlen ;
  unsigned int h ;
  char const   *lcp ;
  char *cp ;
  FILE *fp ;
  char line[512] ;
  int off ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;

  {
#line 140
  no_space = 0;
#line 141
  checked_hexlen = 0;
#line 147
  off = 0;
#line 149
  if ((unsigned long )((void *)0) == (unsigned long )fname) {
#line 150
    return (1);
  } else
#line 149
  if ((unsigned long )((void *)0) == (unsigned long )mp_arr) {
#line 150
    return (1);
  } else
#line 149
  if ((unsigned long )((void *)0) == (unsigned long )mp_arr_len) {
#line 150
    return (1);
  }
  {
#line 151
  tmp = strlen(fname);
#line 151
  fn_len = (int )tmp;
  }
#line 152
  if (0 == fn_len) {
#line 153
    return (1);
  }
#line 154
  if (1 == fn_len) {
#line 154
    if (45 == (int )*(fname + 0)) {
#line 155
      fp = stdin;
    } else {
#line 154
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 157
    fp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
    }
#line 158
    if ((unsigned long )((void *)0) == (unsigned long )fp) {
      {
#line 159
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to open %s for reading\n",
              fname);
      }
#line 160
      return (1);
    }
  }
#line 164
  j = 0;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (j < 512)) {
#line 164
      goto while_break;
    }
    {
#line 165
    tmp___0 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)fp);
    }
#line 165
    if ((unsigned long )((void *)0) == (unsigned long )tmp___0) {
#line 166
      goto while_break;
    }
    {
#line 167
    tmp___1 = strlen((char const   *)(line));
#line 167
    in_len = (int )tmp___1;
    }
#line 168
    if (in_len > 0) {
#line 169
      if (10 == (int )line[in_len - 1]) {
#line 170
        in_len --;
#line 171
        line[in_len] = (char )'\000';
      }
    }
#line 174
    if (0 == in_len) {
#line 175
      goto __Cont;
    }
    {
#line 176
    lcp = (char const   *)(line);
#line 177
    tmp___2 = strspn(lcp, " \t");
#line 177
    m = (int )tmp___2;
    }
#line 178
    if (m == in_len) {
#line 179
      goto __Cont;
    }
#line 180
    lcp += m;
#line 181
    in_len -= m;
#line 182
    if (35 == (int )*lcp) {
#line 183
      goto __Cont;
    }
#line 184
    if (39 == (int )*lcp) {
#line 185
      goto astring;
    } else
#line 184
    if (34 == (int )*lcp) {
#line 185
      goto astring;
    }
#line 186
    if (45 == (int )*lcp) {
#line 186
      if (49 == (int )*(lcp + 1)) {
#line 187
        goto minus1;
      }
    }
#line 188
    if (! checked_hexlen) {
      {
#line 189
      checked_hexlen ++;
#line 190
      tmp___3 = strspn(lcp, "0123456789aAbBcCdDeEfF");
#line 190
      k = (int )tmp___3;
      }
#line 191
      if (k > 2) {
#line 192
        no_space = 1;
      }
    }
    {
#line 195
    tmp___4 = strspn(lcp, "0123456789aAbBcCdDeEfF ,\t");
#line 195
    k = (int )tmp___4;
    }
#line 196
    if (k < in_len) {
#line 196
      if (35 != (int )*(lcp + k)) {
        {
#line 197
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: syntax error at line %d, pos %d\n",
                j + 1, (m + k) + 1);
        }
#line 199
        goto bad;
      }
    }
#line 201
    if (no_space) {
#line 202
      k = 0;
      {
#line 202
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 202
        tmp___6 = __ctype_b_loc();
        }
#line 202
        if ((int const   )*(*tmp___6 + (int )*lcp) & 4096) {
          {
#line 202
          tmp___7 = __ctype_b_loc();
          }
#line 202
          if (! ((int const   )*(*tmp___7 + (int )*(lcp + 1)) & 4096)) {
#line 202
            goto while_break___0;
          }
        } else {
#line 202
          goto while_break___0;
        }
        {
#line 204
        tmp___5 = sscanf((char const   */* __restrict  */)lcp, (char const   */* __restrict  */)"%2x",
                         & h);
        }
#line 204
        if (1 != tmp___5) {
          {
#line 205
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: bad hex number in line %d, pos %d\n",
                  j + 1, (int )((lcp - (char const   *)(line)) + 1L));
          }
#line 207
          goto bad;
        }
#line 209
        if (off + k >= max_arr_len) {
          {
#line 210
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: array length exceeded\n");
          }
#line 211
          goto bad;
        }
#line 213
        *(mp_arr + (off + k)) = (unsigned char )h;
#line 202
        k ++;
#line 202
        lcp += 2;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 215
      off += k;
    } else {
#line 217
      k = 0;
      {
#line 217
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 217
        if (! (k < 1024)) {
#line 217
          goto while_break___1;
        }
        {
#line 218
        tmp___10 = sscanf((char const   */* __restrict  */)lcp, (char const   */* __restrict  */)"%x",
                          & h);
        }
#line 218
        if (1 == tmp___10) {
#line 219
          if (h > 255U) {
            {
#line 220
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: hex number larger than 0xff in line %d, pos %d\n",
                    j + 1, (int )((lcp - (char const   *)(line)) + 1L));
            }
#line 223
            goto bad;
          }
#line 225
          if (off + k >= max_arr_len) {
            {
#line 226
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: array length exceeded\n");
            }
#line 228
            goto bad;
          }
          {
#line 230
          *(mp_arr + (off + k)) = (unsigned char )h;
#line 231
          tmp___8 = strpbrk(lcp, " ,\t");
#line 231
          lcp = (char const   *)tmp___8;
          }
#line 232
          if ((unsigned long )((void *)0) == (unsigned long )lcp) {
#line 233
            goto while_break___1;
          }
          {
#line 234
          tmp___9 = strspn(lcp, " ,\t");
#line 234
          lcp += tmp___9;
          }
#line 235
          if (0 == (int )*lcp) {
#line 236
            goto while_break___1;
          }
        } else {
#line 238
          if (35 == (int )*lcp) {
#line 239
            k --;
#line 240
            goto while_break___1;
          }
          {
#line 242
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: error in line %d, at pos %d\n",
                  j + 1, (int )((lcp - (char const   *)(line)) + 1L));
          }
#line 245
          goto bad;
        }
#line 217
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 248
      off += k + 1;
    }
    __Cont: /* CIL Label */ 
#line 164
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 251
  *mp_arr_len = off;
#line 252
  fclose(fp);
  }
#line 253
  return (0);
  astring: 
  {
#line 255
  cp = strchr(lcp + 1, (int )*lcp);
  }
#line 256
  if ((unsigned long )((void *)0) == (unsigned long )cp) {
    {
#line 257
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: unterminated ASCII string on line %d, starts: %s\n",
            j + 1, lcp);
    }
#line 259
    goto bad;
  }
#line 261
  k = (int )((cp - (char *)lcp) - 1L);
#line 262
  if (k > 0) {
#line 263
    if (off + k > max_arr_len) {
      {
#line 264
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: array length exceeded\n");
      }
#line 265
      goto bad;
    }
    {
#line 267
    memcpy((void */* __restrict  */)(mp_arr + off), (void const   */* __restrict  */)(lcp + 1),
           (size_t )k);
    }
  }
  {
#line 269
  off += k;
#line 270
  *mp_arr_len = off;
#line 271
  fclose(fp);
  }
#line 272
  return (0);
  minus1: 
#line 274
  k = off;
  {
#line 274
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 274
    if (! (k < max_arr_len)) {
#line 274
      goto while_break___2;
    }
#line 275
    *(mp_arr + k) = (unsigned char)255;
#line 274
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 276
  *mp_arr_len = k;
#line 277
  fclose(fp);
  }
#line 278
  return (0);
  bad: 
  {
#line 280
  fclose(fp);
  }
#line 281
  return (1);
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_zone_man_pass.c"
static void dStrRaw___8(char const   *str , int len ) 
{ 
  int k ;

  {
#line 290
  k = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! (k < len)) {
#line 290
      goto while_break;
    }
    {
#line 291
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 290
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___20  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___10[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___10[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___10[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___10  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 53 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_route_info.c"
static char *version_str___21  =    (char *)"1.08 20112222";
#line 55 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_route_info.c"
static struct option long_options___9[13]  = 
#line 55
  {      {"disable", 0, (int *)0, 'd'}, 
        {"expected", 1, (int *)0, 'E'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"index", 1, (int *)0, 'i'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"phy", 1, (int *)0, 'p'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"routed", 1, (int *)0, 'R'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 72 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_route_info.c"
static void usage___9(void) 
{ 


  {
  {
#line 75
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_conf_route_info [--disable] [--expected=EX] [--help] [--hex]\n                       [--index=IN] [--interface=PARAMS] [--phy=ID]\n                       [--raw] [--routed=R_SAS_ADDR] [--sa=SAS_ADDR]\n                       [--verbose] [--version] SMP_DEVICE[,N]\n  where:\n    --disable|-d         disable expander route entry\n    --expected=EX|-E EX    set expected expander change count to EX\n    --help|-h            print out usage message\n    --hex|-H             print response in hexadecimal\n    --index=IN|-i IN     expander route index (def: 0)\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --phy=ID|-p ID       phy identifier (def: 0)\n    --raw|-r             output response in binary\n    --routed=R_SAS_ADDR|-R R_SAS_ADDR    routed SAS address\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n    --verbose|-v         increase verbosity\n    --version|-V         print version string and exit\n\nPerforms a SMP CONFIGURE ROUTE INFORMATION function\n");
  }
#line 107
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_route_info.c"
static void dStrRaw___9(char const   *str , int len ) 
{ 
  int k ;

  {
#line 114
  k = 0;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (k < len)) {
#line 114
      goto while_break;
    }
    {
#line 115
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 114
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___22  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___11[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___11[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___11[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___11  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 53 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_phy_err_log.c"
static char *version_str___23  =    (char *)"1.12 20111222";
#line 57 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_phy_err_log.c"
static struct option long_options___10[10]  = 
#line 57
  {      {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"phy", 1, (int *)0, 'p'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"zero", 0, (int *)0, 'z'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 71 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_phy_err_log.c"
static void usage___10(void) 
{ 


  {
  {
#line 74
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_rep_phy_err_log [--help] [--hex] [--interface=PARAMS] [--phy=ID]\n                           [--raw] [--sa=SAS_ADDR] [--verbose] [--version]\n                           [--zero] SMP_DEVICE[,N]\n  where:\n    --help|-h            print out usage message\n    --hex|-H             print response in hexadecimal\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --phy=ID|-p ID       phy identifier (def: 0)\n    --raw|-r             output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n    --verbose|-v         increase verbosity\n    --version|-V         print version string and exit\n    --zero|-z            zero Allocated Response Length field,\n                         may be required prior to SAS-2\n\nPerforms a SMP REPORT PHY ERROR LOG function\n");
  }
#line 100
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_phy_err_log.c"
static void dStrRaw___10(char const   *str , int len ) 
{ 
  int k ;

  {
#line 107
  k = 0;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (k < len)) {
#line 107
      goto while_break;
    }
    {
#line 108
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 107
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___24  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___12[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___12[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___12[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___12  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 53 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_route_info.c"
static char *version_str___25  =    (char *)"1.09 20111222";
#line 57 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_route_info.c"
static struct option long_options___11[13]  = 
#line 57
  {      {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"index", 1, (int *)0, 'i'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"multiple", 0, (int *)0, 'm'}, 
        {"num", 1, (int *)0, 'n'}, 
        {"phy", 1, (int *)0, 'p'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"zero", 0, (int *)0, 'z'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 74 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_route_info.c"
static void usage___11(void) 
{ 


  {
  {
#line 77
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_rep_route_info [--help] [--hex] [--index=IN] [--interface=PARAMS]\n                          [--multiple] [--num=NUM] [--phy=ID] [--raw]\n                          [--sa=SAS_ADDR] [--verbose] [--version]\n                          [--zero] SMP_DEVICE[,N]\n  where:\n    --help|-h         print out usage message\n    --hex|-H          print response in hexadecimal\n    --index=IN|-i IN    expander route index (def: 0)\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --multiple|-m     query multiple indexes, output 1 line for each\n    --num=NUM|-n NUM  number of indexes to examine when \'-m\' is given\n    --phy=ID|-p ID    phy identifier (def: 0)\n    --raw|-r          output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n    --verbose|-v      increase verbosity\n    --version|-V      print version string and exit\n    --zero|-z         zero Allocated Response Length field,\n                      may be required prior to SAS-2\n\nPerforms a SMP REPORT ROUTE INFORMATION function\n");
  }
#line 110
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_route_info.c"
static void dStrRaw___11(char const   *str , int len ) 
{ 
  int k ;

  {
#line 117
  k = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (k < len)) {
#line 117
      goto while_break;
    }
    {
#line 118
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 117
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_route_info.c"
static int do_rep_route(struct smp_target_obj *top , int phy_id , int index___0 ,
                        unsigned char *resp , int max_resp_len , int *resp_len , int do_zero ,
                        int do_hex , int do_raw , int verbose ) 
{ 
  unsigned char smp_req[16] ;
  struct smp_req_resp smp_rr ;
  char b[256] ;
  char *cp ;
  int len ;
  int res ;
  int k ;
  int act_resplen ;
  char *tmp ;

  {
#line 130
  smp_req[0] = (unsigned char)64;
#line 130
  smp_req[1] = (unsigned char)19;
#line 130
  smp_req[2] = (unsigned char)0;
#line 130
  smp_req[3] = (unsigned char)0;
#line 130
  smp_req[4] = (unsigned char)0;
#line 130
  smp_req[5] = (unsigned char)0;
#line 130
  smp_req[6] = (unsigned char)0;
#line 130
  smp_req[7] = (unsigned char)0;
#line 130
  smp_req[8] = (unsigned char)0;
#line 130
  smp_req[9] = (unsigned char)0;
#line 130
  smp_req[10] = (unsigned char)0;
#line 130
  smp_req[11] = (unsigned char)0;
#line 130
  smp_req[12] = (unsigned char)0;
#line 130
  smp_req[13] = (unsigned char)0;
#line 130
  smp_req[14] = (unsigned char)0;
#line 130
  smp_req[15] = (unsigned char)0;
#line 137
  if (! do_zero) {
#line 138
    len = (max_resp_len - 8) / 4;
#line 139
    if (len < 256) {
#line 139
      smp_req[2] = (unsigned char )len;
    } else {
#line 139
      smp_req[2] = (unsigned char)255;
    }
#line 140
    smp_req[3] = (unsigned char)2;
  }
#line 142
  smp_req[6] = (unsigned char )((index___0 >> 8) & 255);
#line 143
  smp_req[7] = (unsigned char )(index___0 & 255);
#line 144
  smp_req[9] = (unsigned char )phy_id;
#line 145
  if (verbose) {
    {
#line 146
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Report route information request: ");
#line 147
    k = 0;
    }
    {
#line 147
    while (1) {
      while_continue: /* CIL Label */ ;
#line 147
      if (! (k < (int )sizeof(smp_req))) {
#line 147
        goto while_break;
      }
      {
#line 148
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x ",
              (int )smp_req[k]);
#line 147
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 149
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 151
  memset((void *)(& smp_rr), 0, sizeof(smp_rr));
#line 152
  smp_rr.request_len = (int )sizeof(smp_req);
#line 153
  smp_rr.request = smp_req;
#line 154
  smp_rr.max_response_len = max_resp_len;
#line 155
  smp_rr.response = resp;
#line 156
  res = smp_send_req((struct smp_target_obj  const  *)top, & smp_rr, verbose);
  }
#line 158
  if (res) {
    {
#line 159
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"smp_send_req failed, res=%d\n",
            res);
    }
#line 160
    if (0 == verbose) {
      {
#line 161
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    try adding \'-v\' option for more debug\n");
      }
    }
#line 162
    return (-1);
  }
#line 164
  if (smp_rr.transport_err) {
    {
#line 165
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"smp_send_req transport_error=%d\n",
            smp_rr.transport_err);
    }
#line 167
    return (-1);
  }
#line 169
  act_resplen = smp_rr.act_response_len;
#line 170
  if (act_resplen >= 0) {
#line 170
    if (act_resplen < 4) {
      {
#line 171
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"response too short, len=%d\n",
              act_resplen);
      }
#line 172
      return (97);
    }
  }
#line 174
  len = (int )*(resp + 3);
#line 175
  if (0 == len) {
#line 175
    if (0 == (int )*(resp + 2)) {
      {
#line 176
      len = smp_get_func_def_resp_len((int )*(resp + 1));
      }
#line 177
      if (len < 0) {
#line 178
        len = 0;
#line 179
        if (verbose > 1) {
          {
#line 180
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to determine response length\n");
          }
        }
      }
    }
  }
#line 183
  len = 4 + len * 4;
#line 184
  if (act_resplen >= 0) {
#line 184
    if (len > act_resplen) {
#line 185
      if (verbose) {
        {
#line 186
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"actual response length [%d] less than deduced length [%d]\n",
                act_resplen, len);
        }
      }
#line 188
      len = act_resplen;
    }
  }
#line 190
  if (do_hex) {
#line 190
    goto _L;
  } else
#line 190
  if (do_raw) {
    _L: /* CIL Label */ 
#line 191
    if (do_hex) {
      {
#line 192
      dStrHex((char const   *)resp, len, 1);
      }
    } else {
      {
#line 194
      dStrRaw___11((char const   *)resp, len);
      }
    }
#line 195
    if (65 != (int )*(resp + 0)) {
#line 196
      return (97);
    }
#line 197
    if ((int )*(resp + 1) != (int )smp_req[1]) {
#line 198
      return (97);
    }
#line 199
    if (*(resp + 2)) {
#line 200
      if (verbose) {
        {
#line 201
        tmp = smp_get_func_res_str((int )*(resp + 2), (int )sizeof(b), b);
#line 201
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Report route information result: %s\n",
                tmp);
        }
      }
#line 203
      return ((int )*(resp + 2));
    }
#line 205
    if (resp_len) {
#line 206
      *resp_len = len;
    }
#line 207
    return (0);
  }
#line 209
  if (65 != (int )*(resp + 0)) {
    {
#line 210
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"expected SMP frame response type, got=0x%x\n",
            (int )*(resp + 0));
    }
#line 212
    return (97);
  }
#line 214
  if ((int )*(resp + 1) != (int )smp_req[1]) {
    {
#line 215
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Expected function code=0x%x, got=0x%x\n",
            (int )smp_req[1], (int )*(resp + 1));
    }
#line 217
    return (97);
  }
#line 219
  if (*(resp + 2)) {
#line 220
    if (verbose > 0) {
      {
#line 221
      cp = smp_get_func_res_str((int )*(resp + 2), (int )sizeof(b), b);
#line 222
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Report route information result: %s\n",
              cp);
      }
    }
#line 224
    return ((int )*(resp + 2));
  }
#line 226
  if (resp_len) {
#line 227
    *resp_len = len;
  }
#line 228
  return (0);
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_route_info.c"
static int do_multiple(struct smp_target_obj *top , int phy_id , int index___0 , int num_ind ,
                       int do_zero , int do_hex , int do_raw , int verbose ) 
{ 
  unsigned char smp_resp[44] ;
  unsigned long long ull ;
  int res ;
  int len ;
  int j ;
  int k ;
  int num ;
  int disabled ;
  int adj_dis ;
  int first ;

  {
#line 241
  first = 1;
#line 243
  if (num_ind) {
#line 243
    num = index___0 + num_ind;
  } else {
#line 243
    num = 16384;
  }
#line 244
  adj_dis = 0;
#line 244
  k = index___0;
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if (! (k < num)) {
#line 244
      goto while_break;
    }
    {
#line 245
    res = do_rep_route(top, phy_id, k, smp_resp, (int )sizeof(smp_resp), & len, do_zero,
                       do_hex, do_raw, verbose);
    }
#line 247
    if (17 == res) {
#line 248
      return (0);
    }
#line 249
    if (res) {
#line 250
      return (res);
    }
#line 251
    if (first) {
#line 251
      if (! do_raw) {
        {
#line 252
        first = 0;
#line 253
        printf((char const   */* __restrict  */)"Route table for phy_id: %d\n", phy_id);
        }
      }
    }
#line 255
    if (do_hex) {
#line 256
      goto __Cont;
    } else
#line 255
    if (do_raw) {
#line 256
      goto __Cont;
    }
#line 257
    disabled = ! (! ((int )smp_resp[12] & 128));
#line 258
    if (0 == num_ind) {
#line 258
      if (disabled) {
#line 259
        adj_dis ++;
#line 259
        if (adj_dis >= 4) {
#line 260
          if (verbose > 2) {
            {
#line 261
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"number of \'adjacent disables\' exceeded at index=%d\n",
                    k);
            }
          }
#line 263
          goto while_break;
        }
      }
    }
#line 266
    if (disabled) {
#line 267
      goto __Cont;
    }
#line 268
    adj_dis = 0;
#line 269
    ull = 0ULL;
#line 270
    j = 0;
    {
#line 270
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 270
      if (! (j < 8)) {
#line 270
        goto while_break___0;
      }
#line 271
      if (j > 0) {
#line 272
        ull <<= 8;
      }
#line 273
      ull |= (unsigned long long )smp_resp[16 + j];
#line 270
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 275
    printf((char const   */* __restrict  */)"  Index: %d    Routed SAS address: 0x%llx\n",
           k, ull);
    }
    __Cont: /* CIL Label */ 
#line 244
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  return (0);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_route_info.c"
static int do_single(struct smp_target_obj *top , int phy_id , int index___0 , int do_zero ,
                     int do_hex , int do_raw , int verbose ) 
{ 
  unsigned char smp_resp[44] ;
  unsigned long long ull ;
  int res ;
  int len ;
  int j ;

  {
  {
#line 288
  res = do_rep_route(top, phy_id, index___0, smp_resp, (int )sizeof(smp_resp), & len,
                     do_zero, do_hex, do_raw, verbose);
  }
#line 290
  if (res) {
#line 291
    return (res);
  }
#line 292
  if (do_hex) {
#line 293
    return (0);
  } else
#line 292
  if (do_raw) {
#line 293
    return (0);
  }
  {
#line 295
  printf((char const   */* __restrict  */)"Report route information response:\n");
#line 296
  res = ((int )smp_resp[4] << 8) + (int )smp_resp[5];
  }
#line 297
  if (verbose) {
    {
#line 298
    printf((char const   */* __restrict  */)"  expander change count: %d\n", res);
    }
  } else
#line 297
  if (res > 0) {
    {
#line 298
    printf((char const   */* __restrict  */)"  expander change count: %d\n", res);
    }
  }
  {
#line 299
  printf((char const   */* __restrict  */)"  expander route index: %d\n", ((int )smp_resp[6] << 8) + (int )smp_resp[7]);
#line 300
  printf((char const   */* __restrict  */)"  phy identifier: %d\n", (int )smp_resp[9]);
#line 301
  printf((char const   */* __restrict  */)"  expander route entry disabled: %d\n",
         ! (! ((int )smp_resp[12] & 128)));
  }
#line 302
  if (! ((int )smp_resp[12] & 128)) {
#line 302
    goto _L;
  } else
#line 302
  if (verbose > 0) {
    _L: /* CIL Label */ 
#line 303
    ull = 0ULL;
#line 304
    j = 0;
    {
#line 304
    while (1) {
      while_continue: /* CIL Label */ ;
#line 304
      if (! (j < 8)) {
#line 304
        goto while_break;
      }
#line 305
      if (j > 0) {
#line 306
        ull <<= 8;
      }
#line 307
      ull |= (unsigned long long )smp_resp[16 + j];
#line 304
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 309
    printf((char const   */* __restrict  */)"  routed SAS address: 0x%llx\n", ull);
    }
  }
#line 311
  return (0);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___26  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___13[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___13[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___13[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___13  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 52 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_general.c"
static char *version_str___27  =    (char *)"1.22 20111222";
#line 56 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_general.c"
static struct option long_options___12[11]  = 
#line 56
  {      {"brief", 0, (int *)0, 'b'}, 
        {"changecount", 0, (int *)0, 'c'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"zero", 0, (int *)0, 'z'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 71 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_general.c"
static void usage___12(void) 
{ 


  {
  {
#line 74
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_rep_general [--brief] [--changecount] [--help] [--hex]\n                       [--interface=PARAMS] [--raw] [--sa=SAS_ADDR]\n                       [--verbose] [--version] [--zero]SMP_DEVICE[,N]\n  where:\n    --brief|-b           brief report, only important settings\n    --changecount|-c     report expander change count only\n    --help|-h            print out usage message\n    --hex|-H             print response in hexadecimal\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --raw|-r             output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n    --verbose|-v         increase verbosity\n    --version|-V         print version string and exit\n    --zero|-z            zero Allocated Response Length field,\n                         may be required prior to SAS-2\n\nPerforms a SMP REPORT GENERAL function\n");
  }
#line 102
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_general.c"
static void dStrRaw___12(char const   *str , int len ) 
{ 
  int k ;

  {
#line 109
  k = 0;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (k < len)) {
#line 109
      goto while_break;
    }
    {
#line 110
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 109
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___28  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___14[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___14[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___14[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___14  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 55 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover.c"
static char *version_str___29  =    (char *)"1.34 20111221";
#line 80 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover.c"
static struct option long_options___13[18]  = 
#line 80
  {      {"adn", 0, (int *)0, 'A'}, 
        {"brief", 0, (int *)0, 'b'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"ignore", 0, (int *)0, 'i'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"list", 0, (int *)0, 'l'}, 
        {"multiple", 0, (int *)0, 'm'}, 
        {"my", 0, (int *)0, 'M'}, 
        {"num", 1, (int *)0, 'n'}, 
        {"phy", 1, (int *)0, 'p'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"summary", 0, (int *)0, 'S'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"zero", 0, (int *)0, 'z'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 102 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover.c"
static void usage___13(void) 
{ 


  {
  {
#line 105
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_discover [--adn] [--brief] [--help] [--hex] [--ignore]\n                    [--interface=PARAMS] [--list] [--my] [--multiple]\n                    [--num=NUM] [--phy=ID] [--raw] [--sa=SAS_ADDR]\n                    [--summary] [--verbose] [--version] [--zero]\n                    SMP_DEVICE[,N]\n  where:\n    --adn|-A             output attached device name in one line per\n                         phy mode (i.e. with --multiple)\n    --brief|-b           less output, can be used multiple times\n    --help|-h            print out usage message\n    --hex|-H             print response in hexadecimal\n    --ignore|-i          sets the Ignore Zone Group bit; will show\n                         phys otherwise hidden by zoning\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --list|-l            output attribute=value, 1 per line\n    --multiple|-m        query multiple phys, output 1 line for each\n    --my|-M              output my (expander\'s) SAS address\n    --num=NUM|-n NUM     number of phys to fetch when \'-m\' is given\n                         (def: 0 -> the rest)\n    --phy=ID|-p ID       phy identifier [or starting phy id]\n    --raw|-r             output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n    --summary|-S         query phys, output 1 line for each active one,\n                         equivalent to \'--multiple --brief\' (\'-mb\').\n                         This option is assumed if \'--phy=ID\' not given\n    --verbose|-v         increase verbosity\n    --version|-V         print version string and exit\n    --zero|-z            zero Allocated Response Length field,\n                         may be required prior to SAS-2\n\nSends one or more SMP DISCOVER functions. If \'--phy=ID\' not given then\n\'--summary\' is assumed. The \'--summary\' option shows the disposition\nof each active expander phy in table form.\n");
  }
#line 158
  return;
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover.c"
static void dStrRaw___13(char const   *str , int len ) 
{ 
  int k ;

  {
#line 165
  k = 0;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! (k < len)) {
#line 165
      goto while_break;
    }
    {
#line 166
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 165
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover.c"
static char *smp_attached_device_type___0[8]  = 
#line 169
  {      (char *)"no device attached",      (char *)"end device",      (char *)"expander device",      (char *)"expander device (fanout)", 
        (char *)"reserved [4]",      (char *)"reserved [5]",      (char *)"reserved [6]",      (char *)"reserved [7]"};
#line 180 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover.c"
static char *smp_short_attached_device_type___0[8]  = 
#line 180
  {      (char *)"",      (char *)"",      (char *)"exp",      (char *)"fex", 
        (char *)"res",      (char *)"res",      (char *)"res",      (char *)"res"};
#line 191 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover.c"
static char *smp_get_plink_rate___0(int val , int prog , int b_len , char *b ) 
{ 


  {
  {
#line 195
  if (val == 0) {
#line 195
    goto case_0;
  }
#line 198
  if (val == 8) {
#line 198
    goto case_8;
  }
#line 201
  if (val == 9) {
#line 201
    goto case_9;
  }
#line 204
  if (val == 10) {
#line 204
    goto case_10;
  }
#line 207
  if (val == 11) {
#line 207
    goto case_11;
  }
#line 210
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 196
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"not programmable");
  }
#line 197
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 199
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"1.5 Gbps");
  }
#line 200
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 202
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"3 Gbps");
  }
#line 203
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 205
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"6 Gbps");
  }
#line 206
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 208
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"12 Gbps");
  }
#line 209
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 211
  if (prog) {
#line 211
    if (0 == val) {
      {
#line 212
      snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"not programmable");
      }
    } else {
      {
#line 214
      snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"reserved [%d]",
               val);
      }
    }
  } else {
    {
#line 214
    snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"reserved [%d]",
             val);
    }
  }
#line 215
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 217
  return (b);
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover.c"
static char *smp_get_reason___0(int val , int b_len , char *b ) 
{ 


  {
  {
#line 224
  if (val == 0) {
#line 224
    goto case_0;
  }
#line 225
  if (val == 1) {
#line 225
    goto case_1;
  }
#line 226
  if (val == 2) {
#line 226
    goto case_2;
  }
#line 228
  if (val == 3) {
#line 228
    goto case_3;
  }
#line 230
  if (val == 4) {
#line 230
    goto case_4;
  }
#line 231
  if (val == 5) {
#line 231
    goto case_5;
  }
#line 232
  if (val == 6) {
#line 232
    goto case_6;
  }
#line 233
  if (val == 7) {
#line 233
    goto case_7;
  }
#line 234
  if (val == 8) {
#line 234
    goto case_8;
  }
#line 235
  if (val == 9) {
#line 235
    goto case_9;
  }
#line 236
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 224
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"unknown");
  }
#line 224
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 225
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"power on");
  }
#line 225
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 226
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"hard reset");
  }
#line 227
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 228
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"SMP phy control requested");
  }
#line 229
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 230
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"loss of dword synchronization");
  }
#line 230
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 231
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"error in multiplexing (MUX) sequence");
  }
#line 231
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 232
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"I_T nexus loss timeout STP/SATA");
  }
#line 232
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 233
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"break timeout timer expired");
  }
#line 233
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 234
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"phy test function stopped");
  }
#line 234
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 235
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"expander reduced functionality");
  }
#line 235
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 236
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"reserved [%d]",
           val);
  }
#line 236
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 238
  return (b);
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover.c"
static char *smp_get_neg_xxx_link_rate___0(int val , int b_len , char *b ) 
{ 


  {
  {
#line 245
  if (val == 0) {
#line 245
    goto case_0;
  }
#line 246
  if (val == 1) {
#line 246
    goto case_1;
  }
#line 247
  if (val == 2) {
#line 247
    goto case_2;
  }
#line 249
  if (val == 3) {
#line 249
    goto case_3;
  }
#line 251
  if (val == 4) {
#line 251
    goto case_4;
  }
#line 252
  if (val == 5) {
#line 252
    goto case_5;
  }
#line 253
  if (val == 6) {
#line 253
    goto case_6;
  }
#line 255
  if (val == 8) {
#line 255
    goto case_8;
  }
#line 256
  if (val == 9) {
#line 256
    goto case_9;
  }
#line 257
  if (val == 10) {
#line 257
    goto case_10;
  }
#line 258
  if (val == 11) {
#line 258
    goto case_11;
  }
#line 259
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 245
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"phy enabled; unknown");
  }
#line 245
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 246
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"phy disabled");
  }
#line 246
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 247
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"phy enabled; speed negotiation failed");
  }
#line 248
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 249
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"phy enabled; SATA spinup hold state");
  }
#line 250
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 251
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"phy enabled; port selector");
  }
#line 251
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 252
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"phy enabled; reset in progress");
  }
#line 252
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 253
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"phy enabled; unsupported phy attached");
  }
#line 254
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 255
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"phy enabled, 1.5 Gbps");
  }
#line 255
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 256
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"phy enabled, 3 Gbps");
  }
#line 256
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 257
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"phy enabled, 6 Gbps");
  }
#line 257
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 258
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"phy enabled, 12 Gbps");
  }
#line 258
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 259
  snprintf((char */* __restrict  */)b, (size_t )b_len, (char const   */* __restrict  */)"reserved [%d]",
           val);
  }
#line 259
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 261
  return (b);
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover.c"
static char *find_sas_connector_type___0(int conn_type , char *buff , int buff_len ) 
{ 


  {
  {
#line 268
  if (conn_type == 0) {
#line 268
    goto case_0;
  }
#line 271
  if (conn_type == 1) {
#line 271
    goto case_1;
  }
#line 275
  if (conn_type == 2) {
#line 275
    goto case_2;
  }
#line 279
  if (conn_type == 15) {
#line 279
    goto case_15;
  }
#line 282
  if (conn_type == 16) {
#line 282
    goto case_16;
  }
#line 285
  if (conn_type == 17) {
#line 285
    goto case_17;
  }
#line 289
  if (conn_type == 32) {
#line 289
    goto case_32;
  }
#line 293
  if (conn_type == 33) {
#line 293
    goto case_33;
  }
#line 296
  if (conn_type == 34) {
#line 296
    goto case_34;
  }
#line 299
  if (conn_type == 35) {
#line 299
    goto case_35;
  }
#line 302
  if (conn_type == 47) {
#line 302
    goto case_47;
  }
#line 305
  if (conn_type == 63) {
#line 305
    goto case_63;
  }
#line 308
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 269
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"No information");
  }
#line 270
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 272
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"SAS 4x receptacle (SFF-8470) [max 4 phys]");
  }
#line 274
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 276
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Mini SAS 4x receptacle (SFF-8088) [max 4 phys]");
  }
#line 278
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 280
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Vendor specific external connector");
  }
#line 281
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 283
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"SAS 4i plug (SFF-8484) [max 4 phys]");
  }
#line 284
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 286
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Mini SAS 4i receptacle (SFF-8087) [max 4 phys]");
  }
#line 288
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 290
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"SAS Drive backplane receptacle (SFF-8482) [max 2 phys]");
  }
#line 292
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 294
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"SATA host plug [max 1 phy]");
  }
#line 295
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 297
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"SAS Drive plug (SFF-8482) [max 2 phys]");
  }
#line 298
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 300
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"SATA device plug [max 1 phy]");
  }
#line 301
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 303
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"SAS virtual connector [max 1 phy]");
  }
#line 304
  goto switch_break;
  case_63: /* CIL Label */ 
  {
#line 306
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Vendor specific internal connector");
  }
#line 307
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 309
  if (conn_type < 16) {
    {
#line 310
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"unknown external connector type: 0x%x",
             conn_type);
    }
  } else
#line 312
  if (conn_type < 32) {
    {
#line 313
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"unknown internal wide connector type: 0x%x",
             conn_type);
    }
  } else
#line 315
  if (conn_type < 48) {
    {
#line 316
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"unknown internal connector to end device, type: 0x%x",
             conn_type);
    }
  } else
#line 318
  if (conn_type < 112) {
    {
#line 319
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"reserved connector type: 0x%x",
             conn_type);
    }
  } else
#line 321
  if (conn_type < 128) {
    {
#line 322
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"vendor specific connector type: 0x%x",
             conn_type);
    }
  } else {
    {
#line 325
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"unexpected connector type: 0x%x",
             conn_type);
    }
  }
#line 327
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 329
  return (buff);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover.c"
static int do_discover(struct smp_target_obj *top , int disc_phy_id , unsigned char *resp ,
                       int max_resp_len , int silence_err_report , struct opts_t___0  const  *optsp ) 
{ 
  unsigned char smp_req[16] ;
  struct smp_req_resp smp_rr ;
  char b[256] ;
  char *cp ;
  int len ;
  int res ;
  int k ;
  int act_resplen ;
  char *tmp ;

  {
  {
#line 340
  smp_req[0] = (unsigned char)64;
#line 340
  smp_req[1] = (unsigned char)16;
#line 340
  smp_req[2] = (unsigned char)0;
#line 340
  smp_req[3] = (unsigned char)0;
#line 340
  smp_req[4] = (unsigned char)0;
#line 340
  smp_req[5] = (unsigned char)0;
#line 340
  smp_req[6] = (unsigned char)0;
#line 340
  smp_req[7] = (unsigned char)0;
#line 340
  smp_req[8] = (unsigned char)0;
#line 340
  smp_req[9] = (unsigned char)0;
#line 340
  smp_req[10] = (unsigned char)0;
#line 340
  smp_req[11] = (unsigned char)0;
#line 340
  smp_req[12] = (unsigned char)0;
#line 340
  smp_req[13] = (unsigned char)0;
#line 340
  smp_req[14] = (unsigned char)0;
#line 340
  smp_req[15] = (unsigned char)0;
#line 347
  memset((void *)resp, 0, (size_t )max_resp_len);
  }
#line 348
  if (! optsp->do_zero) {
#line 349
    len = (max_resp_len - 8) / 4;
#line 350
    if (len < 256) {
#line 350
      smp_req[2] = (unsigned char )len;
    } else {
#line 350
      smp_req[2] = (unsigned char)255;
    }
#line 351
    smp_req[3] = (unsigned char)2;
  }
#line 353
  if (optsp->ign_zp) {
#line 354
    smp_req[8] = (unsigned char )((int )smp_req[8] | 1);
  }
#line 355
  smp_req[9] = (unsigned char )disc_phy_id;
#line 356
  if (optsp->verbose) {
    {
#line 357
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Discover request: ");
#line 358
    k = 0;
    }
    {
#line 358
    while (1) {
      while_continue: /* CIL Label */ ;
#line 358
      if (! (k < (int )sizeof(smp_req))) {
#line 358
        goto while_break;
      }
      {
#line 359
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x ",
              (int )smp_req[k]);
#line 358
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 360
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 362
  memset((void *)(& smp_rr), 0, sizeof(smp_rr));
#line 363
  smp_rr.request_len = (int )sizeof(smp_req);
#line 364
  smp_rr.request = smp_req;
#line 365
  smp_rr.max_response_len = max_resp_len;
#line 366
  smp_rr.response = resp;
#line 367
  res = smp_send_req((struct smp_target_obj  const  *)top, & smp_rr, (int )optsp->verbose);
  }
#line 369
  if (res) {
    {
#line 370
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"smp_send_req failed, res=%d\n",
            res);
    }
#line 371
    if (0 == (int )optsp->verbose) {
      {
#line 372
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    try adding \'-v\' option for more debug\n");
      }
    }
#line 373
    return (-1);
  }
#line 375
  if (smp_rr.transport_err) {
    {
#line 376
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"smp_send_req transport_error=%d\n",
            smp_rr.transport_err);
    }
#line 378
    return (-1);
  }
#line 380
  act_resplen = smp_rr.act_response_len;
#line 381
  if (act_resplen >= 0) {
#line 381
    if (act_resplen < 4) {
      {
#line 382
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"response too short, len=%d\n",
              act_resplen);
      }
#line 383
      return (-101);
    }
  }
#line 385
  len = (int )*(resp + 3);
#line 386
  if (0 == len) {
#line 386
    if (0 == (int )*(resp + 2)) {
      {
#line 387
      len = smp_get_func_def_resp_len((int )*(resp + 1));
      }
#line 388
      if (len < 0) {
#line 389
        len = 0;
#line 390
        if (optsp->verbose > 1) {
          {
#line 391
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to determine response length\n");
          }
        }
      }
    }
  }
#line 394
  len = 4 + len * 4;
#line 395
  if (act_resplen >= 0) {
#line 395
    if (len > act_resplen) {
#line 396
      if (optsp->verbose) {
        {
#line 397
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"actual response length [%d] less than deduced length [%d]\n",
                act_resplen, len);
        }
      }
#line 399
      len = act_resplen;
    }
  }
#line 401
  if (optsp->do_hex) {
#line 401
    goto _L;
  } else
#line 401
  if (optsp->do_raw) {
    _L: /* CIL Label */ 
#line 402
    if (optsp->do_hex) {
      {
#line 403
      dStrHex((char const   *)resp, len, 1);
      }
    } else {
      {
#line 405
      dStrRaw___13((char const   *)resp, len);
      }
    }
#line 406
    if (65 != (int )*(resp + 0)) {
#line 407
      return (-101);
    }
#line 408
    if ((int )*(resp + 1) != (int )smp_req[1]) {
#line 409
      return (-101);
    }
#line 410
    if (*(resp + 2)) {
#line 411
      if (optsp->verbose) {
        {
#line 412
        tmp = smp_get_func_res_str((int )*(resp + 2), (int )sizeof(b), b);
#line 412
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Discover result: %s\n",
                tmp);
        }
      }
#line 414
      return (-4 - (int )*(resp + 2));
    }
#line 416
    return (len);
  }
#line 418
  if (65 != (int )*(resp + 0)) {
    {
#line 419
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"expected SMP frame response type, got=0x%x\n",
            (int )*(resp + 0));
    }
#line 421
    return (-101);
  }
#line 423
  if ((int )*(resp + 1) != (int )smp_req[1]) {
    {
#line 424
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Expected function code=0x%x, got=0x%x\n",
            (int )smp_req[1], (int )*(resp + 1));
    }
#line 426
    return (-101);
  }
#line 428
  if (*(resp + 2)) {
#line 429
    if (optsp->verbose > 0) {
      {
#line 430
      cp = smp_get_func_res_str((int )*(resp + 2), (int )sizeof(b), b);
#line 431
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Discover result: %s\n",
              cp);
      }
    } else
#line 429
    if (! silence_err_report) {
      {
#line 430
      cp = smp_get_func_res_str((int )*(resp + 2), (int )sizeof(b), b);
#line 431
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Discover result: %s\n",
              cp);
      }
    }
#line 433
    return (-4 - (int )*(resp + 2));
  }
#line 435
  return (len);
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover.c"
static int do_single_list(unsigned char const   *rp , int len , int show_exp_cc ,
                          int do_brief ) 
{ 
  int res ;
  int j ;
  int sas2 ;
  unsigned long long ull ;

  {
#line 447
  sas2 = ! (! *(rp + 3));
#line 448
  if (sas2) {
#line 448
    if (show_exp_cc) {
#line 448
      if (! do_brief) {
        {
#line 449
        res = (int )(((int const   )*(rp + 4) << 8) + (int const   )*(rp + 5));
#line 450
        printf((char const   */* __restrict  */)"expander_cc=%d\n", res);
        }
      }
    }
  }
  {
#line 452
  printf((char const   */* __restrict  */)"phy_id=%d\n", (int const   )*(rp + 9));
  }
#line 453
  if (! do_brief) {
#line 454
    if (sas2) {
      {
#line 455
      printf((char const   */* __restrict  */)"  att_br_cap=%d\n", ! (! (1 & (int )*(rp + 33))));
      }
    }
#line 456
    if (len > 59) {
#line 457
      ull = 0ULL;
#line 457
      j = 0;
      {
#line 457
      while (1) {
        while_continue: /* CIL Label */ ;
#line 457
        if (! (j < 8)) {
#line 457
          goto while_break;
        }
#line 458
        if (j > 0) {
#line 459
          ull <<= 8;
        }
#line 460
        ull |= (unsigned long long )*(rp + (52 + j));
#line 457
        j ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 462
      printf((char const   */* __restrict  */)"  att_dev_name=0x%llx\n", ull);
      }
    }
  }
  {
#line 465
  printf((char const   */* __restrict  */)"  att_dev_type=%d\n", (112 & (int )*(rp + 12)) >> 4);
  }
#line 466
  if (sas2) {
#line 466
    if (! do_brief) {
      {
#line 467
      printf((char const   */* __restrict  */)"  att_iz_per=%d\n", ! (! (4 & (int )*(rp + 33))));
#line 468
      printf((char const   */* __restrict  */)"  att_pa_cap=%d\n", ! (! (8 & (int )*(rp + 33))));
      }
    }
  }
  {
#line 470
  printf((char const   */* __restrict  */)"  att_phy_id=%d\n", (int const   )*(rp + 32));
  }
#line 471
  if (sas2) {
#line 471
    if (! do_brief) {
      {
#line 472
      printf((char const   */* __restrict  */)"  att_pow_cap=%d\n", ((int const   )*(rp + 33) >> 5) & 3);
#line 473
      printf((char const   */* __restrict  */)"  att_reason=%d\n", 15 & (int )*(rp + 12));
#line 474
      printf((char const   */* __restrict  */)"  att_req_iz=%d\n", ! (! (2 & (int )*(rp + 33))));
      }
    }
  }
#line 476
  ull = 0ULL;
#line 476
  j = 0;
  {
#line 476
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 476
    if (! (j < 8)) {
#line 476
      goto while_break___0;
    }
#line 477
    if (j > 0) {
#line 478
      ull <<= 8;
    }
#line 479
    ull |= (unsigned long long )*(rp + (24 + j));
#line 476
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 481
  printf((char const   */* __restrict  */)"  att_sas_addr=0x%llx\n", ull);
#line 482
  printf((char const   */* __restrict  */)"  att_sata_dev=%d\n", ! (! (1 & (int )*(rp + 15))));
#line 483
  printf((char const   */* __restrict  */)"  att_sata_host=%d\n", ! (! (1 & (int )*(rp + 14))));
#line 484
  printf((char const   */* __restrict  */)"  att_sata_ps=%d\n", ! (! (128 & (int )*(rp + 15))));
  }
#line 485
  if (sas2) {
#line 485
    if (! do_brief) {
      {
#line 486
      printf((char const   */* __restrict  */)"  att_sl_cap=%d\n", ! (! (16 & (int )*(rp + 33))));
      }
    }
  }
  {
#line 487
  printf((char const   */* __restrict  */)"  att_smp_init=%d\n", ! (! (2 & (int )*(rp + 14))));
#line 488
  printf((char const   */* __restrict  */)"  att_smp_targ=%d\n", ! (! (2 & (int )*(rp + 15))));
#line 489
  printf((char const   */* __restrict  */)"  att_ssp_init=%d\n", ! (! (8 & (int )*(rp + 14))));
#line 490
  printf((char const   */* __restrict  */)"  att_ssp_targ=%d\n", ! (! (8 & (int )*(rp + 15))));
#line 491
  printf((char const   */* __restrict  */)"  att_stp_init=%d\n", ! (! (4 & (int )*(rp + 14))));
#line 492
  printf((char const   */* __restrict  */)"  att_stp_targ=%d\n", ! (! (4 & (int )*(rp + 15))));
  }
#line 493
  if (! do_brief) {
#line 494
    if (sas2) {
      {
#line 495
      printf((char const   */* __restrict  */)"  conn_elem_ind=%d\n", (int const   )*(rp + 46));
#line 496
      printf((char const   */* __restrict  */)"  conn_p_link=%d\n", (int const   )*(rp + 47));
#line 497
      printf((char const   */* __restrict  */)"  conn_type=%d\n", 127 & (int )*(rp + 45));
      }
    } else
#line 494
    if ((int const   )*(rp + 45) & 127) {
      {
#line 495
      printf((char const   */* __restrict  */)"  conn_elem_ind=%d\n", (int const   )*(rp + 46));
#line 496
      printf((char const   */* __restrict  */)"  conn_p_link=%d\n", (int const   )*(rp + 47));
#line 497
      printf((char const   */* __restrict  */)"  conn_type=%d\n", 127 & (int )*(rp + 45));
      }
    }
  }
#line 500
  if (! do_brief) {
    {
#line 501
    printf((char const   */* __restrict  */)"  hw_max_p_lrate=%d\n", 15 & (int )*(rp + 41));
#line 502
    printf((char const   */* __restrict  */)"  hw_min_p_lrate=%d\n", 15 & (int )*(rp + 40));
    }
#line 503
    if (len > 95) {
      {
#line 504
      printf((char const   */* __restrict  */)"  hw_mux_sup=%d\n", ! (! ((int const   )*(rp + 95) & 1)));
      }
    }
  }
#line 507
  if (! do_brief) {
    {
#line 508
    printf((char const   */* __restrict  */)"  iz=%d\n", ! (! (2 & (int )*(rp + 60))));
#line 509
    printf((char const   */* __restrict  */)"  iz_pers=%d\n", ! (! (32 & (int )*(rp + 60))));
    }
  }
  {
#line 511
  printf((char const   */* __restrict  */)"  neg_log_lrate=%d\n", 15 & (int )*(rp + 13));
  }
#line 512
  if (! do_brief) {
#line 513
    if (len > 95) {
      {
#line 514
      printf((char const   */* __restrict  */)"  neg_phy_lrate=%d\n", 15 & (int )*(rp + 94));
#line 515
      printf((char const   */* __restrict  */)"  opt_m_en=%d\n", ! (! ((int const   )*(rp + 95) & 4)));
      }
    }
    {
#line 517
    printf((char const   */* __restrict  */)"  phy_cc=%d\n", (int const   )*(rp + 42));
#line 518
    printf((char const   */* __restrict  */)"  phy_power_cond=%d\n", (192 & (int )*(rp + 48)) >> 6);
#line 519
    printf((char const   */* __restrict  */)"  pp_timeout=%d\n", 15 & (int )*(rp + 43));
#line 520
    printf((char const   */* __restrict  */)"  pr_max_p_lrate=%d\n", (240 & (int )*(rp + 41)) >> 4);
#line 521
    printf((char const   */* __restrict  */)"  pr_min_p_lrate=%d\n", (240 & (int )*(rp + 40)) >> 4);
    }
  }
#line 523
  if (! do_brief) {
#line 523
    if (len > 95) {
      {
#line 524
      printf((char const   */* __restrict  */)"  reason=%d\n", (240 & (int )*(rp + 94)) >> 4);
      }
    }
  }
#line 525
  if (! do_brief) {
    {
#line 526
    printf((char const   */* __restrict  */)"  req_iz=%d\n", ! (! (16 & (int )*(rp + 60))));
#line 527
    printf((char const   */* __restrict  */)"  req_iz_cbe=%d\n", ! (! (64 & (int )*(rp + 60))));
    }
  }
  {
#line 529
  printf((char const   */* __restrict  */)"  routing_attr=%d\n", (int const   )*(rp + 44) & 15);
#line 531
  ull = 0ULL;
#line 531
  j = 0;
  }
  {
#line 531
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 531
    if (! (j < 8)) {
#line 531
      goto while_break___1;
    }
#line 532
    if (j > 0) {
#line 533
      ull <<= 8;
    }
#line 534
    ull |= (unsigned long long )*(rp + (16 + j));
#line 531
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 536
  printf((char const   */* __restrict  */)"  sas_addr=0x%llx\n", ull);
  }
#line 537
  if (! do_brief) {
    {
#line 538
    printf((char const   */* __restrict  */)"  sas_pa_cap=%d\n", ! (! (4 & (int )*(rp + 48))));
#line 539
    printf((char const   */* __restrict  */)"  sas_pa_en=%d\n", ! (! (4 & (int )*(rp + 49))));
#line 540
    printf((char const   */* __restrict  */)"  sas_pow_cap=%d\n", ((int const   )*(rp + 48) >> 4) & 3);
#line 541
    printf((char const   */* __restrict  */)"  sas_sl_cap=%d\n", ! (! (8 & (int )*(rp + 48))));
#line 542
    printf((char const   */* __restrict  */)"  sas_sl_en=%d\n", ! (! (8 & (int )*(rp + 49))));
#line 543
    printf((char const   */* __restrict  */)"  sata_pa_cap=%d\n", ! (! (1 & (int )*(rp + 48))));
#line 544
    printf((char const   */* __restrict  */)"  sata_pa_en=%d\n", ! (! (1 & (int )*(rp + 49))));
#line 545
    printf((char const   */* __restrict  */)"  sata_sl_cap=%d\n", ! (! (2 & (int )*(rp + 48))));
#line 546
    printf((char const   */* __restrict  */)"  sata_sl_en=%d\n", ! (! (2 & (int )*(rp + 49))));
#line 547
    printf((char const   */* __restrict  */)"  stp_buff_tsmall=%d\n", ! (! (16 & (int )*(rp + 15))));
    }
  }
  {
#line 550
  printf((char const   */* __restrict  */)"  virt_phy=%d\n", ! (! (128 & (int )*(rp + 43))));
  }
#line 551
  if (! do_brief) {
    {
#line 552
    printf((char const   */* __restrict  */)"  zg=%d\n", (int const   )*(rp + 63));
#line 553
    printf((char const   */* __restrict  */)"  zg_pers=%d\n", ! (! (4 & (int )*(rp + 60))));
#line 554
    printf((char const   */* __restrict  */)"  zoning_en=%d\n", ! (! (1 & (int )*(rp + 60))));
    }
  }
#line 556
  return (0);
}
}
#line 561 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover.c"
static int do_single___0(struct smp_target_obj *top , struct opts_t___0  const  *optsp ) 
{ 
  unsigned char rp[124] ;
  unsigned long long ull ;
  unsigned int ui ;
  int res ;
  int len ;
  int j ;
  int sas2 ;
  int ret ;
  char b[256] ;
  int tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 571
  len = do_discover(top, (int )optsp->phy_id, rp, (int )sizeof(rp), 0, optsp);
  }
#line 573
  if (len < 0) {
#line 574
    if (len < -2) {
#line 574
      ret = -4 - len;
    } else {
#line 574
      ret = len;
    }
  } else {
#line 576
    ret = 0;
  }
#line 577
  if (optsp->do_hex) {
#line 578
    return (ret);
  } else
#line 577
  if (optsp->do_raw) {
#line 578
    return (ret);
  }
#line 579
  ull = 0ULL;
#line 580
  if (len > 23) {
#line 582
    j = 0;
    {
#line 582
    while (1) {
      while_continue: /* CIL Label */ ;
#line 582
      if (! (j < 8)) {
#line 582
        goto while_break;
      }
#line 583
      if (j > 0) {
#line 584
        ull <<= 8;
      }
#line 585
      ull |= (unsigned long long )rp[16 + j];
#line 582
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 588
  if (optsp->do_my) {
    {
#line 589
    printf((char const   */* __restrict  */)"0x%llx\n", ull);
    }
#line 590
    if (ull > 0ULL) {
#line 590
      if (22 == ret) {
#line 591
        return (0);
      } else {
#line 593
        return (ret);
      }
    } else {
#line 593
      return (ret);
    }
  }
#line 595
  if (ret) {
#line 596
    if (22 == ret) {
      {
#line 597
      printf((char const   */* __restrict  */)"  phy identifier: %d  inaccessible (phy vacant)\n",
             optsp->phy_id);
      }
    }
#line 599
    return (ret);
  }
#line 601
  if (optsp->do_list) {
    {
#line 602
    tmp = do_single_list((unsigned char const   *)(rp), len, 1, (int )optsp->do_brief);
    }
#line 602
    return (tmp);
  }
#line 603
  if (optsp->do_brief) {
#line 603
    tmp___0 = " (brief)";
  } else {
#line 603
    tmp___0 = "";
  }
  {
#line 603
  printf((char const   */* __restrict  */)"Discover response%s:\n", tmp___0);
#line 604
  sas2 = ! (! rp[3]);
#line 605
  res = ((int )rp[4] << 8) + (int )rp[5];
  }
#line 606
  if (sas2) {
#line 606
    goto _L;
  } else
#line 606
  if (optsp->verbose > 3) {
    _L: /* CIL Label */ 
#line 607
    if (optsp->verbose) {
      {
#line 608
      printf((char const   */* __restrict  */)"  expander change count: %d\n", res);
      }
    } else
#line 607
    if (res > 0) {
      {
#line 608
      printf((char const   */* __restrict  */)"  expander change count: %d\n", res);
      }
    }
  }
  {
#line 610
  printf((char const   */* __restrict  */)"  phy identifier: %d\n", (int )rp[9]);
#line 611
  res = (112 & (int )rp[12]) >> 4;
  }
#line 612
  if (res < 8) {
    {
#line 613
    printf((char const   */* __restrict  */)"  attached device type: %s\n", smp_attached_device_type___0[res]);
    }
  }
#line 614
  if (optsp->do_brief > 1) {
#line 614
    if (0 == res) {
#line 615
      return (0);
    }
  }
#line 616
  if (sas2) {
    {
#line 617
    tmp___1 = smp_get_reason___0(15 & (int )rp[12], (int )sizeof(b), b);
#line 617
    printf((char const   */* __restrict  */)"  attached reason: %s\n", tmp___1);
    }
  } else
#line 616
  if (optsp->verbose > 3) {
    {
#line 617
    tmp___1 = smp_get_reason___0(15 & (int )rp[12], (int )sizeof(b), b);
#line 617
    printf((char const   */* __restrict  */)"  attached reason: %s\n", tmp___1);
    }
  }
  {
#line 620
  tmp___2 = smp_get_neg_xxx_link_rate___0(15 & (int )rp[13], (int )sizeof(b), b);
#line 620
  printf((char const   */* __restrict  */)"  negotiated logical link rate: %s\n",
         tmp___2);
#line 623
  printf((char const   */* __restrict  */)"  attached initiator: ssp=%d stp=%d smp=%d sata_host=%d\n",
         ! (! ((int )rp[14] & 8)), ! (! ((int )rp[14] & 4)), ! (! ((int )rp[14] & 2)),
         (int )rp[14] & 1);
  }
#line 625
  if (0 == (int )optsp->do_brief) {
    {
#line 626
    printf((char const   */* __restrict  */)"  attached sata port selector: %d\n",
           ! (! ((int )rp[15] & 128)));
#line 628
    printf((char const   */* __restrict  */)"  STP buffer too small: %d\n", ! (! ((int )rp[15] & 16)));
    }
  }
  {
#line 630
  printf((char const   */* __restrict  */)"  attached target: ssp=%d stp=%d smp=%d sata_device=%d\n",
         ! (! ((int )rp[15] & 8)), ! (! ((int )rp[15] & 4)), ! (! ((int )rp[15] & 2)),
         (int )rp[15] & 1);
#line 633
  printf((char const   */* __restrict  */)"  SAS address: 0x%llx\n", ull);
#line 634
  ull = 0ULL;
#line 635
  j = 0;
  }
  {
#line 635
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 635
    if (! (j < 8)) {
#line 635
      goto while_break___0;
    }
#line 636
    if (j > 0) {
#line 637
      ull <<= 8;
    }
#line 638
    ull |= (unsigned long long )rp[24 + j];
#line 635
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 640
  printf((char const   */* __restrict  */)"  attached SAS address: 0x%llx\n", ull);
#line 641
  printf((char const   */* __restrict  */)"  attached phy identifier: %d\n", (int )rp[32]);
  }
#line 642
  if (0 == (int )optsp->do_brief) {
#line 643
    if (sas2) {
#line 643
      goto _L___0;
    } else
#line 643
    if (optsp->verbose > 3) {
      _L___0: /* CIL Label */ 
      {
#line 644
      printf((char const   */* __restrict  */)"  attached power capable: %d\n", ((int )rp[33] >> 5) & 3);
#line 645
      printf((char const   */* __restrict  */)"  attached slumber capable: %d\n",
             ! (! ((int )rp[33] & 16)));
#line 646
      printf((char const   */* __restrict  */)"  attached partial capable: %d\n",
             ! (! ((int )rp[33] & 8)));
#line 647
      printf((char const   */* __restrict  */)"  attached inside ZPSDS persistent: %d\n",
             ! (! ((int )rp[33] & 4)));
#line 649
      printf((char const   */* __restrict  */)"  attached requested inside ZPSDS: %d\n",
             ! (! ((int )rp[33] & 2)));
#line 650
      printf((char const   */* __restrict  */)"  attached break_reply capable: %d\n",
             ! (! ((int )rp[33] & 1)));
      }
    }
    {
#line 652
    tmp___3 = smp_get_plink_rate___0(((int )rp[40] >> 4) & 15, 1, (int )sizeof(b),
                                     b);
#line 652
    printf((char const   */* __restrict  */)"  programmed minimum physical link rate: %s\n",
           tmp___3);
#line 654
    tmp___4 = smp_get_plink_rate___0((int )rp[40] & 15, 0, (int )sizeof(b), b);
#line 654
    printf((char const   */* __restrict  */)"  hardware minimum physical link rate: %s\n",
           tmp___4);
#line 656
    tmp___5 = smp_get_plink_rate___0(((int )rp[41] >> 4) & 15, 1, (int )sizeof(b),
                                     b);
#line 656
    printf((char const   */* __restrict  */)"  programmed maximum physical link rate: %s\n",
           tmp___5);
#line 658
    tmp___6 = smp_get_plink_rate___0((int )rp[41] & 15, 0, (int )sizeof(b), b);
#line 658
    printf((char const   */* __restrict  */)"  hardware maximum physical link rate: %s\n",
           tmp___6);
#line 660
    printf((char const   */* __restrict  */)"  phy change count: %d\n", (int )rp[42]);
#line 661
    printf((char const   */* __restrict  */)"  virtual phy: %d\n", ! (! ((int )rp[43] & 128)));
#line 662
    printf((char const   */* __restrict  */)"  partial pathway timeout value: %d us\n",
           (int )rp[43] & 15);
    }
  }
#line 664
  res = 15 & (int )rp[44];
  {
#line 666
  if (res == 0) {
#line 666
    goto case_0;
  }
#line 667
  if (res == 1) {
#line 667
    goto case_1;
  }
#line 668
  if (res == 2) {
#line 668
    goto case_2;
  }
#line 669
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 666
  snprintf((char */* __restrict  */)(b), sizeof(b), (char const   */* __restrict  */)"direct");
  }
#line 666
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 667
  snprintf((char */* __restrict  */)(b), sizeof(b), (char const   */* __restrict  */)"subtractive");
  }
#line 667
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 668
  snprintf((char */* __restrict  */)(b), sizeof(b), (char const   */* __restrict  */)"table");
  }
#line 668
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 669
  snprintf((char */* __restrict  */)(b), sizeof(b), (char const   */* __restrict  */)"reserved [%d]",
           res);
  }
#line 669
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 671
  printf((char const   */* __restrict  */)"  routing attribute: %s\n", b);
  }
#line 672
  if (optsp->do_brief) {
#line 673
    if (len > 63) {
#line 673
      if (! (! ((int )rp[60] & 1))) {
        {
#line 674
        printf((char const   */* __restrict  */)"  zone group: %d\n", (int )rp[63]);
        }
      }
    }
#line 675
    return (0);
  }
#line 677
  if (sas2) {
#line 677
    goto _L___1;
  } else
#line 677
  if ((int )rp[45] & 127) {
    _L___1: /* CIL Label */ 
    {
#line 678
    tmp___7 = find_sas_connector_type___0((int )rp[45] & 127, b, (int )sizeof(b));
#line 678
    printf((char const   */* __restrict  */)"  connector type: %s\n", tmp___7);
#line 680
    printf((char const   */* __restrict  */)"  connector element index: %d\n", (int )rp[46]);
#line 681
    printf((char const   */* __restrict  */)"  connector physical link: %d\n", (int )rp[47]);
#line 682
    printf((char const   */* __restrict  */)"  phy power condition: %d\n", ((int )rp[48] & 192) >> 6);
#line 683
    printf((char const   */* __restrict  */)"  sas power capable: %d\n", ((int )rp[48] >> 4) & 3);
#line 684
    printf((char const   */* __restrict  */)"  sas slumber capable: %d\n", ! (! ((int )rp[48] & 8)));
#line 685
    printf((char const   */* __restrict  */)"  sas partial capable: %d\n", ! (! ((int )rp[48] & 4)));
#line 686
    printf((char const   */* __restrict  */)"  sata slumber capable: %d\n", ! (! ((int )rp[48] & 2)));
#line 687
    printf((char const   */* __restrict  */)"  sata partial capable: %d\n", ! (! ((int )rp[48] & 1)));
#line 688
    printf((char const   */* __restrict  */)"  sas slumber enabled: %d\n", ! (! ((int )rp[49] & 8)));
#line 689
    printf((char const   */* __restrict  */)"  sas partial enabled: %d\n", ! (! ((int )rp[49] & 4)));
#line 690
    printf((char const   */* __restrict  */)"  sata slumber enabled: %d\n", ! (! ((int )rp[49] & 2)));
#line 691
    printf((char const   */* __restrict  */)"  sata partial enabled: %d\n", ! (! ((int )rp[49] & 1)));
    }
  }
#line 693
  if (len > 59) {
#line 694
    ull = 0ULL;
#line 695
    j = 0;
    {
#line 695
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 695
      if (! (j < 8)) {
#line 695
        goto while_break___1;
      }
#line 696
      if (j > 0) {
#line 697
        ull <<= 8;
      }
#line 698
      ull |= (unsigned long long )rp[52 + j];
#line 695
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 700
    printf((char const   */* __restrict  */)"  attached device name: 0x%llx\n", ull);
#line 701
    printf((char const   */* __restrict  */)"  requested inside ZPSDS changed by expander: %d\n",
           ! (! ((int )rp[60] & 64)));
#line 703
    printf((char const   */* __restrict  */)"  inside ZPSDS persistent: %d\n", ! (! ((int )rp[60] & 32)));
#line 704
    printf((char const   */* __restrict  */)"  requested inside ZPSDS: %d\n", ! (! ((int )rp[60] & 16)));
#line 706
    printf((char const   */* __restrict  */)"  zone group persistent: %d\n", ! (! ((int )rp[60] & 4)));
#line 707
    printf((char const   */* __restrict  */)"  inside ZPSDS: %d\n", ! (! ((int )rp[60] & 2)));
#line 708
    printf((char const   */* __restrict  */)"  zoning enabled: %d\n", ! (! ((int )rp[60] & 1)));
#line 709
    printf((char const   */* __restrict  */)"  zone group: %d\n", (int )rp[63]);
    }
#line 710
    if (len < 76) {
#line 711
      return (0);
    }
    {
#line 712
    printf((char const   */* __restrict  */)"  self-configuration status: %d\n", (int )rp[64]);
#line 713
    printf((char const   */* __restrict  */)"  self-configuration levels completed: %d\n",
           (int )rp[65]);
#line 714
    ull = 0ULL;
#line 715
    j = 0;
    }
    {
#line 715
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 715
      if (! (j < 8)) {
#line 715
        goto while_break___2;
      }
#line 716
      if (j > 0) {
#line 717
        ull <<= 8;
      }
#line 718
      ull |= (unsigned long long )rp[68 + j];
#line 715
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 720
    printf((char const   */* __restrict  */)"  self-configuration sas address: 0x%llx\n",
           ull);
#line 721
    ui = 0U;
#line 722
    j = 0;
    }
    {
#line 722
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 722
      if (! (j < 4)) {
#line 722
        goto while_break___3;
      }
#line 723
      if (j > 0) {
#line 724
        ui <<= 8;
      }
#line 725
      ui |= (unsigned int )rp[76 + j];
#line 722
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 727
    printf((char const   */* __restrict  */)"  programmed phy capabilities: 0x%x\n",
           ui);
#line 728
    ui = 0U;
#line 729
    j = 0;
    }
    {
#line 729
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 729
      if (! (j < 4)) {
#line 729
        goto while_break___4;
      }
#line 730
      if (j > 0) {
#line 731
        ui <<= 8;
      }
#line 732
      ui |= (unsigned int )rp[80 + j];
#line 729
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 734
    printf((char const   */* __restrict  */)"  current phy capabilities: 0x%x\n",
           ui);
#line 735
    ui = 0U;
#line 736
    j = 0;
    }
    {
#line 736
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 736
      if (! (j < 4)) {
#line 736
        goto while_break___5;
      }
#line 737
      if (j > 0) {
#line 738
        ui <<= 8;
      }
#line 739
      ui |= (unsigned int )rp[84 + j];
#line 736
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 741
    printf((char const   */* __restrict  */)"  attached phy capabilities: 0x%x\n",
           ui);
    }
  }
#line 743
  if (len > 95) {
    {
#line 744
    tmp___8 = smp_get_reason___0((240 & (int )rp[94]) >> 4, (int )sizeof(b), b);
#line 744
    printf((char const   */* __restrict  */)"  reason: %s\n", tmp___8);
#line 746
    tmp___9 = smp_get_neg_xxx_link_rate___0(15 & (int )rp[94], (int )sizeof(b), b);
#line 746
    printf((char const   */* __restrict  */)"  negotiated physical link rate: %s\n",
           tmp___9);
#line 748
    printf((char const   */* __restrict  */)"  optical mode enabled: %d\n", ! (! ((int )rp[95] & 4)));
#line 749
    printf((char const   */* __restrict  */)"  negotiated SSC: %d\n", ! (! ((int )rp[95] & 2)));
#line 750
    printf((char const   */* __restrict  */)"  hardware muxing supported: %d\n", ! (! ((int )rp[95] & 1)));
    }
  }
#line 752
  if (len > 107) {
    {
#line 753
    printf((char const   */* __restrict  */)"  default inside ZPSDS persistent: %d\n",
           ! (! ((int )rp[96] & 32)));
#line 754
    printf((char const   */* __restrict  */)"  default requested inside ZPSDS: %d\n",
           ! (! ((int )rp[96] & 16)));
#line 755
    printf((char const   */* __restrict  */)"  default zone group persistent: %d\n",
           ! (! ((int )rp[96] & 4)));
#line 756
    printf((char const   */* __restrict  */)"  default zoning enabled: %d\n", ! (! ((int )rp[96] & 1)));
#line 757
    printf((char const   */* __restrict  */)"  default zone group: %d\n", (int )rp[99]);
#line 758
    printf((char const   */* __restrict  */)"  saved inside ZPSDS persistent: %d\n",
           ! (! ((int )rp[100] & 32)));
#line 759
    printf((char const   */* __restrict  */)"  saved requested inside ZPSDS: %d\n",
           ! (! ((int )rp[100] & 16)));
#line 760
    printf((char const   */* __restrict  */)"  saved zone group persistent: %d\n",
           ! (! ((int )rp[100] & 4)));
#line 761
    printf((char const   */* __restrict  */)"  saved zoning enabled: %d\n", ! (! ((int )rp[100] & 1)));
#line 762
    printf((char const   */* __restrict  */)"  saved zone group: %d\n", (int )rp[103]);
#line 763
    printf((char const   */* __restrict  */)"  shadow inside ZPSDS persistent: %d\n",
           ! (! ((int )rp[104] & 32)));
#line 764
    printf((char const   */* __restrict  */)"  shadow requested inside ZPSDS: %d\n",
           ! (! ((int )rp[104] & 16)));
#line 765
    printf((char const   */* __restrict  */)"  shadow zone group persistent: %d\n",
           ! (! ((int )rp[104] & 4)));
#line 767
    printf((char const   */* __restrict  */)"  shadow zoning enabled: %d\n", ! (! ((int )rp[104] & 1)));
#line 768
    printf((char const   */* __restrict  */)"  shadow zone group: %d\n", (int )rp[107]);
    }
  }
#line 770
  if (len > 115) {
    {
#line 771
    printf((char const   */* __restrict  */)"  device slot number: %d\n", (int )rp[108]);
#line 772
    printf((char const   */* __restrict  */)"  device slot group number: %d\n", (int )rp[109]);
#line 773
    printf((char const   */* __restrict  */)"  device slot group output connector: %.6s\n",
           rp + 110);
    }
  }
#line 775
  if (len > 117) {
    {
#line 776
    printf((char const   */* __restrict  */)"  STP buffer size: %d\n", ((int )rp[116] << 8) + (int )rp[117]);
    }
  }
#line 777
  return (0);
}
}
#line 784 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_discover.c"
static int do_multiple___0(struct smp_target_obj *top , struct opts_t___0  const  *optsp ) 
{ 
  unsigned char rp[124] ;
  unsigned long long ull ;
  unsigned long long adn ;
  unsigned long long expander_sa ;
  int ret ;
  int len ;
  int k ;
  int j ;
  int num ;
  int off ;
  int plus ;
  int negot ;
  int adt ;
  int zg ;
  char b[256] ;
  int first ;
  char const   *cp ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  int tmp___18 ;

  {
#line 792
  first = 1;
#line 795
  expander_sa = 0ULL;
#line 796
  if (optsp->do_num) {
#line 796
    num = (int )(optsp->phy_id + optsp->do_num);
  } else {
#line 796
    num = 254;
  }
#line 797
  k = (int )optsp->phy_id;
  {
#line 797
  while (1) {
    while_continue: /* CIL Label */ ;
#line 797
    if (! (k < num)) {
#line 797
      goto while_break;
    }
    {
#line 798
    len = do_discover(top, k, rp, (int )sizeof(rp), 1, optsp);
    }
#line 799
    if (len < 0) {
#line 800
      if (len < -2) {
#line 800
        ret = -4 - len;
      } else {
#line 800
        ret = len;
      }
    } else {
#line 802
      ret = 0;
    }
#line 803
    if (16 == ret) {
#line 804
      return (0);
    } else
#line 805
    if (22 == ret) {
      {
#line 806
      printf((char const   */* __restrict  */)"  phy %3d: inaccessible (phy vacant)\n",
             k);
      }
#line 807
      goto __Cont;
    } else
#line 808
    if (ret) {
#line 809
      return (ret);
    }
#line 810
    ull = 0ULL;
#line 811
    j = 0;
    {
#line 811
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 811
      if (! (j < 8)) {
#line 811
        goto while_break___0;
      }
#line 812
      if (j > 0) {
#line 813
        ull <<= 8;
      }
#line 814
      ull |= (unsigned long long )rp[16 + j];
#line 811
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 816
    if (0ULL == expander_sa) {
#line 817
      expander_sa = ull;
    } else
#line 819
    if (ull != expander_sa) {
#line 820
      if (ull > 0ULL) {
        {
#line 821
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> expander\'s SAS address is changing?? phy_id=%d, was=%llxh, now=%llxh\n",
                (int )rp[9], expander_sa, ull);
#line 824
        expander_sa = ull;
        }
      } else
#line 825
      if (optsp->verbose) {
        {
#line 826
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> expander\'s SAS address shown as 0 at phy_id=%d\n",
                (int )rp[9]);
        }
      }
    }
#line 830
    if (first) {
#line 830
      if (! optsp->do_raw) {
#line 831
        first = 0;
#line 832
        if (optsp->sa_given) {
#line 832
          if (optsp->sa != (unsigned long long const   )expander_sa) {
            {
#line 833
            printf((char const   */* __restrict  */)"  <<< Warning: reported expander address is not the one requested >>>\n");
            }
          }
        }
      }
    }
#line 841
    if (optsp->do_hex) {
#line 842
      goto __Cont;
    } else
#line 841
    if (optsp->do_raw) {
#line 842
      goto __Cont;
    }
#line 844
    if (optsp->do_list) {
      {
#line 845
      do_single_list((unsigned char const   *)(rp), len, 0, (int )optsp->do_brief);
      }
#line 846
      goto __Cont;
    }
#line 848
    adt = (112 & (int )rp[12]) >> 4;
#line 849
    if (optsp->do_brief > 1) {
#line 849
      if (0 == adt) {
#line 850
        goto __Cont;
      }
    }
#line 852
    negot = (int )rp[13] & 15;
    {
#line 854
    if (((int )rp[44] & 15) == 0) {
#line 854
      goto case_0;
    }
#line 857
    if (((int )rp[44] & 15) == 1) {
#line 857
      goto case_1;
    }
#line 860
    if (((int )rp[44] & 15) == 2) {
#line 860
      goto case_2;
    }
#line 863
    goto switch_default;
    case_0: /* CIL Label */ 
#line 855
    cp = "D";
#line 856
    goto switch_break;
    case_1: /* CIL Label */ 
#line 858
    cp = "S";
#line 859
    goto switch_break;
    case_2: /* CIL Label */ 
#line 861
    cp = "T";
#line 862
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 864
    cp = "R";
#line 865
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 867
    if (1 == negot) {
      {
#line 868
      printf((char const   */* __restrict  */)"  phy %3d:%s:disabled\n", (int )rp[9],
             cp);
      }
#line 869
      goto __Cont;
    } else
#line 870
    if (2 == negot) {
      {
#line 871
      printf((char const   */* __restrict  */)"  phy %3d:%s:reset problem\n", (int )rp[9],
             cp);
      }
#line 872
      goto __Cont;
    } else
#line 873
    if (3 == negot) {
      {
#line 874
      printf((char const   */* __restrict  */)"  phy %3d:%s:spinup hold\n", (int )rp[9],
             cp);
      }
#line 875
      goto __Cont;
    } else
#line 876
    if (4 == negot) {
      {
#line 877
      printf((char const   */* __restrict  */)"  phy %3d:%s:port selector\n", (int )rp[9],
             cp);
      }
#line 878
      goto __Cont;
    } else
#line 879
    if (5 == negot) {
      {
#line 880
      printf((char const   */* __restrict  */)"  phy %3d:%s:reset in progress\n",
             (int )rp[9], cp);
      }
#line 881
      goto __Cont;
    } else
#line 882
    if (6 == negot) {
      {
#line 883
      printf((char const   */* __restrict  */)"  phy %3d:%s:unsupported phy attached\n",
             (int )rp[9], cp);
      }
#line 885
      goto __Cont;
    }
#line 887
    if (optsp->do_brief > 0) {
#line 887
      if (0 == adt) {
#line 888
        goto __Cont;
      }
    }
#line 889
    if (k != (int )rp[9]) {
      {
#line 890
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> requested phy_id=%d differs from response phy=%d\n",
              k, (int )rp[9]);
      }
    }
#line 892
    ull = 0ULL;
#line 893
    j = 0;
    {
#line 893
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 893
      if (! (j < 8)) {
#line 893
        goto while_break___1;
      }
#line 894
      if (j > 0) {
#line 895
        ull <<= 8;
      }
#line 896
      ull |= (unsigned long long )rp[24 + j];
#line 893
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 898
    if (0 == adt) {
#line 898
      goto _L___0;
    } else
#line 898
    if (adt > 3) {
      _L___0: /* CIL Label */ 
      {
#line 899
      printf((char const   */* __restrict  */)"  phy %3d:%s:attached:[0000000000000000:00]",
             k, cp);
      }
#line 900
      if (optsp->do_brief > 1) {
        {
#line 901
        printf((char const   */* __restrict  */)"\n");
        }
#line 902
        goto __Cont;
      } else
#line 900
      if (optsp->do_adn) {
        {
#line 901
        printf((char const   */* __restrict  */)"\n");
        }
#line 902
        goto __Cont;
      } else
#line 900
      if (len < 64) {
        {
#line 901
        printf((char const   */* __restrict  */)"\n");
        }
#line 902
        goto __Cont;
      }
#line 904
      zg = (int )rp[63];
#line 906
      if ((int )rp[60] & 1) {
#line 906
        goto _L;
      } else
#line 906
      if (zg) {
        _L: /* CIL Label */ 
#line 906
        if (1 != zg) {
          {
#line 907
          printf((char const   */* __restrict  */)"  ZG:%d\n", zg);
          }
        } else {
          {
#line 909
          printf((char const   */* __restrict  */)"\n");
          }
        }
      } else {
        {
#line 909
        printf((char const   */* __restrict  */)"\n");
        }
      }
#line 910
      goto __Cont;
    }
#line 912
    if (optsp->do_adn) {
#line 912
      if (len > 59) {
#line 913
        adn = 0ULL;
#line 914
        j = 0;
        {
#line 914
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 914
          if (! (j < 8)) {
#line 914
            goto while_break___2;
          }
#line 915
          if (j > 0) {
#line 916
            adn <<= 8;
          }
#line 917
          adn |= (unsigned long long )rp[52 + j];
#line 914
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 919
        if ((int )rp[43] & 128) {
#line 919
          tmp = " V";
        } else {
#line 919
          tmp = "";
        }
        {
#line 919
        printf((char const   */* __restrict  */)"  phy %3d:%s:attached:[%016llx:%02d %016llx %s%s",
               k, cp, ull, (int )rp[32], adn, smp_short_attached_device_type___0[adt],
               tmp);
        }
      } else {
#line 912
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 923
      if ((int )rp[43] & 128) {
#line 923
        tmp___0 = " V";
      } else {
#line 923
        tmp___0 = "";
      }
      {
#line 923
      printf((char const   */* __restrict  */)"  phy %3d:%s:attached:[%016llx:%02d %s%s",
             k, cp, ull, (int )rp[32], smp_short_attached_device_type___0[adt], tmp___0);
      }
    }
#line 926
    if ((int )rp[14] & 15) {
      {
#line 927
      off = 0;
#line 928
      plus = 0;
#line 929
      tmp___1 = snprintf((char */* __restrict  */)(b + off), sizeof(b) - (unsigned long )off,
                         (char const   */* __restrict  */)" i(");
#line 929
      off += tmp___1;
      }
#line 930
      if ((int )rp[14] & 8) {
        {
#line 931
        tmp___2 = snprintf((char */* __restrict  */)(b + off), sizeof(b) - (unsigned long )off,
                           (char const   */* __restrict  */)"SSP");
#line 931
        off += tmp___2;
#line 932
        plus ++;
        }
      }
#line 934
      if ((int )rp[14] & 4) {
#line 935
        if (plus) {
#line 935
          tmp___3 = "+";
        } else {
#line 935
          tmp___3 = "";
        }
        {
#line 935
        tmp___4 = snprintf((char */* __restrict  */)(b + off), sizeof(b) - (unsigned long )off,
                           (char const   */* __restrict  */)"%sSTP", tmp___3);
#line 935
        off += tmp___4;
#line 937
        plus ++;
        }
      }
#line 939
      if ((int )rp[14] & 2) {
#line 940
        if (plus) {
#line 940
          tmp___5 = "+";
        } else {
#line 940
          tmp___5 = "";
        }
        {
#line 940
        tmp___6 = snprintf((char */* __restrict  */)(b + off), sizeof(b) - (unsigned long )off,
                           (char const   */* __restrict  */)"%sSMP", tmp___5);
#line 940
        off += tmp___6;
#line 942
        plus ++;
        }
      }
#line 944
      if ((int )rp[14] & 1) {
#line 945
        if (plus) {
#line 945
          tmp___7 = "+";
        } else {
#line 945
          tmp___7 = "";
        }
        {
#line 945
        tmp___8 = snprintf((char */* __restrict  */)(b + off), sizeof(b) - (unsigned long )off,
                           (char const   */* __restrict  */)"%sSATA", tmp___7);
#line 945
        off += tmp___8;
#line 947
        plus ++;
        }
      }
      {
#line 949
      printf((char const   */* __restrict  */)"%s)", b);
      }
    }
#line 951
    if ((int )rp[15] & 15) {
      {
#line 952
      off = 0;
#line 953
      plus = 0;
#line 954
      tmp___9 = snprintf((char */* __restrict  */)(b + off), sizeof(b) - (unsigned long )off,
                         (char const   */* __restrict  */)" t(");
#line 954
      off += tmp___9;
      }
#line 955
      if ((int )rp[15] & 128) {
        {
#line 956
        tmp___10 = snprintf((char */* __restrict  */)(b + off), sizeof(b) - (unsigned long )off,
                            (char const   */* __restrict  */)"PORT_SEL");
#line 956
        off += tmp___10;
#line 957
        plus ++;
        }
      }
#line 959
      if ((int )rp[15] & 8) {
#line 960
        if (plus) {
#line 960
          tmp___11 = "+";
        } else {
#line 960
          tmp___11 = "";
        }
        {
#line 960
        tmp___12 = snprintf((char */* __restrict  */)(b + off), sizeof(b) - (unsigned long )off,
                            (char const   */* __restrict  */)"%sSSP", tmp___11);
#line 960
        off += tmp___12;
#line 962
        plus ++;
        }
      }
#line 964
      if ((int )rp[15] & 4) {
#line 965
        if (plus) {
#line 965
          tmp___13 = "+";
        } else {
#line 965
          tmp___13 = "";
        }
        {
#line 965
        tmp___14 = snprintf((char */* __restrict  */)(b + off), sizeof(b) - (unsigned long )off,
                            (char const   */* __restrict  */)"%sSTP", tmp___13);
#line 965
        off += tmp___14;
#line 967
        plus ++;
        }
      }
#line 969
      if ((int )rp[15] & 2) {
#line 970
        if (plus) {
#line 970
          tmp___15 = "+";
        } else {
#line 970
          tmp___15 = "";
        }
        {
#line 970
        tmp___16 = snprintf((char */* __restrict  */)(b + off), sizeof(b) - (unsigned long )off,
                            (char const   */* __restrict  */)"%sSMP", tmp___15);
#line 970
        off += tmp___16;
#line 972
        plus ++;
        }
      }
#line 974
      if ((int )rp[15] & 1) {
#line 975
        if (plus) {
#line 975
          tmp___17 = "+";
        } else {
#line 975
          tmp___17 = "";
        }
        {
#line 975
        tmp___18 = snprintf((char */* __restrict  */)(b + off), sizeof(b) - (unsigned long )off,
                            (char const   */* __restrict  */)"%sSATA", tmp___17);
#line 975
        off += tmp___18;
#line 977
        plus ++;
        }
      }
      {
#line 979
      printf((char const   */* __restrict  */)"%s)", b);
      }
    }
#line 981
    if (optsp->do_brief > 1) {
      {
#line 982
      printf((char const   */* __restrict  */)"]\n");
      }
#line 983
      goto __Cont;
    } else
#line 981
    if (optsp->do_adn) {
      {
#line 982
      printf((char const   */* __restrict  */)"]\n");
      }
#line 983
      goto __Cont;
    } else {
      {
#line 985
      printf((char const   */* __restrict  */)"]");
      }
    }
    {
#line 987
    if (negot == 8) {
#line 987
      goto case_8;
    }
#line 990
    if (negot == 9) {
#line 990
      goto case_9;
    }
#line 993
    if (negot == 10) {
#line 993
      goto case_10;
    }
#line 996
    if (negot == 11) {
#line 996
      goto case_11;
    }
#line 999
    goto switch_default___0;
    case_8: /* CIL Label */ 
#line 988
    cp = "  1.5 Gbps";
#line 989
    goto switch_break___0;
    case_9: /* CIL Label */ 
#line 991
    cp = "  3 Gbps";
#line 992
    goto switch_break___0;
    case_10: /* CIL Label */ 
#line 994
    cp = "  6 Gbps";
#line 995
    goto switch_break___0;
    case_11: /* CIL Label */ 
#line 997
    cp = "  12 Gbps";
#line 998
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 1000
    cp = "";
#line 1001
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 1003
    printf((char const   */* __restrict  */)"%s", cp);
    }
#line 1004
    if (len > 63) {
#line 1005
      zg = (int )rp[63];
#line 1006
      if ((int )rp[60] & 1) {
#line 1006
        goto _L___2;
      } else
#line 1006
      if (zg) {
        _L___2: /* CIL Label */ 
#line 1006
        if (1 != zg) {
          {
#line 1007
          printf((char const   */* __restrict  */)"  ZG:%d\n", zg);
          }
        } else {
          {
#line 1009
          printf((char const   */* __restrict  */)"\n");
          }
        }
      } else {
        {
#line 1009
        printf((char const   */* __restrict  */)"\n");
        }
      }
    } else {
      {
#line 1011
      printf((char const   */* __restrict  */)"\n");
      }
    }
    __Cont: /* CIL Label */ 
#line 797
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1013
  return (0);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_phy_control.c"
static char *version_str___30  =    (char *)"1.15 20111222";
#line 55 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_phy_control.c"
static struct option long_options___14[19]  = 
#line 55
  {      {"attached", 1, (int *)0, 'a'}, 
        {"expected", 1, (int *)0, 'E'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"min", 1, (int *)0, 'm'}, 
        {"max", 1, (int *)0, 'M'}, 
        {"op", 1, (int *)0, 'o'}, 
        {"phy", 1, (int *)0, 'p'}, 
        {"pptv", 1, (int *)0, 'P'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"sas_pa", 1, (int *)0, 'q'}, 
        {"sas_sl", 1, (int *)0, 'l'}, 
        {"sata_pa", 1, (int *)0, 'Q'}, 
        {"sata_sl", 1, (int *)0, 'L'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 78 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_phy_control.c"
static void usage___14(void) 
{ 


  {
  {
#line 81
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_phy_control [--attached=ADN] [--expected=EX] [--help] [--hex]\n                       [--interface=PARAMS] [--max=MA] [--min=MI] [--op=OP]\n                       [--phy=ID] [--pptv=TI] [--raw] [--sa=SAS_ADDR]\n                       [--sas_pa=CO] [--sas_sl=CO] [--sata_pa=CO]\n                       [--sata_sl=CO] [--version] [--verbose] [--version]\n                       SMP_DEVICE[,N]\n  where:\n    --attached=ADN|-a ADN    attached device name [a decimal number,\n                             use \'0x\' prefix for hex], (def: 0)\n    --expected=EX|-E EX      set expected expander change count to EX\n                             (def: 0 (implies ignore))\n    --help|-h                print out usage message\n    --hex|-H                 print response in hexadecimal\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --max=MA|-M MA           programmable maximum physical link speed\n                             (8->1.5 Gbps, 9->3 Gbps, 10->6 Gbps,\n                             11->12 Gbps)\n    --min=MI|-m MI           programmable minimum physical link speed\n    --sas_pa=CO|-q CO        Enable SAS Partial field; CO: 0->leave (def)\n                             1->manage (enable), 2->disable\n    --sas_sl=CO|-l CO        Enable Slumber Partial field\n    --sata_pa=CO|-Q CO       Enable SATA Partial field\n    --sata_sl=CO|-L CO       Enable SATA Slumber field\n    --op=OP|-o OP            OP (operation) is a number or abbreviation.\n                             Default: 0 (nop). See below\n    --phy=ID|-p ID           phy identifier (def: 0)\n    --pptv=TI|-P TI          partial pathway timeout value (microseconds)\n                             (if given sets UPPTV bit)\n    --raw|-r                 output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n    --verbose|-v             increase verbosity\n    --version|-V             print version string and exit\n\nPerforms a SMP PHY CONTROL function. Operation codes (OP): 0,\'nop\'; 1,\'lr\'\n[link reset]; 2,\'hr\' [hard reset]; 3,\'dis\' [disable]; 5,\'cel\' [clear error\nlog]; 6,\'ca\' [clear affiliation]; 7,\'tspss\' [transmit SATA port selection\nsignal]; 8,\'citnl\' [clear STP I_T nexus loss]; 9,\'sadn\' [set attached\ndevice name].\n");
  }
#line 141
  return;
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_phy_control.c"
static void dStrRaw___14(char const   *str , int len ) 
{ 
  int k ;

  {
#line 148
  k = 0;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! (k < len)) {
#line 148
      goto while_break;
    }
    {
#line 149
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 148
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_phy_control.c"
static struct smp_val_name op_abbrev[10]  = 
#line 152
  {      {0, (char *)"nop"}, 
        {1, (char *)"lr"}, 
        {2, (char *)"hr"}, 
        {3, (char *)"dis"}, 
        {5, (char *)"cel"}, 
        {6, (char *)"ca"}, 
        {7, (char *)"tspss"}, 
        {8, (char *)"citnl"}, 
        {9, (char *)"sadn"}, 
        {-1, (char *)((void *)0)}};
#line 165 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_phy_control.c"
static void list_op_abbrevs(void) 
{ 
  struct smp_val_name *vnp ;

  {
  {
#line 170
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  Valid operation abbreviations are:\n");
#line 171
  vnp = op_abbrev;
  }
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! vnp->name) {
#line 171
      goto while_break;
    }
    {
#line 172
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    %s\n",
            vnp->name);
#line 171
    vnp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___31  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___15[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___15[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___15[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___15  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___32  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___16[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___16[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___16[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___16  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 53 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_zone_lock.c"
static char *version_str___33  =    (char *)"1.03 20111222";
#line 55 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_zone_lock.c"
static struct option long_options___15[12]  = 
#line 55
  {      {"expected", 1, (int *)0, 'E'}, 
        {"fpass", 1, (int *)0, 'F'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"inactivity", 1, (int *)0, 'i'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"password", 1, (int *)0, 'P'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 71 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_zone_lock.c"
static void usage___15(void) 
{ 


  {
  {
#line 74
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_zone_lock [--expected=EX] [--fpass=FP] [--help] [--hex]\n                     [--inactivity=TL] [--interface=PARAMS]\n                     [--password=PA] [--raw] [--sa=SAS_ADDR]\n                     [--verbose] [--version] SMP_DEVICE[,N]\n  where:\n    --expected=EX|-E EX    set expected expander change count to EX\n    --fpass=FP|-F FP       file FP contains password, in hex or ASCII\n    --help|-h              print out usage message\n    --hex|-H               print response in hexadecimal\n    --inactivity=TL|-i TL    TL is inactivity time limit (units: 100ms)\n                             (def: 0 -> no time limit)\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --password=PA|-P PA    password PA in ASCII, padded with NULLs to\n                           be 32 bytes long (def: all NULLs)\n    --raw|-r               output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n    --verbose|-v           increase verbosity\n    --version|-V           print version string and exit\n\nPerforms a SMP ZONE LOCK function\n");
  }
#line 106
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_zone_lock.c"
static int f2hex_arr___0(char const   *fname , unsigned char *mp_arr , int *mp_arr_len ,
                         int max_arr_len ) 
{ 
  int fn_len ;
  int in_len ;
  int k ;
  int j ;
  int m ;
  int no_space ;
  int checked_hexlen ;
  unsigned int h ;
  char const   *lcp ;
  char *cp ;
  FILE *fp ;
  char line[512] ;
  int off ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;

  {
#line 126
  no_space = 0;
#line 127
  checked_hexlen = 0;
#line 133
  off = 0;
#line 135
  if ((unsigned long )((void *)0) == (unsigned long )fname) {
#line 136
    return (1);
  } else
#line 135
  if ((unsigned long )((void *)0) == (unsigned long )mp_arr) {
#line 136
    return (1);
  } else
#line 135
  if ((unsigned long )((void *)0) == (unsigned long )mp_arr_len) {
#line 136
    return (1);
  }
  {
#line 137
  tmp = strlen(fname);
#line 137
  fn_len = (int )tmp;
  }
#line 138
  if (0 == fn_len) {
#line 139
    return (1);
  }
#line 140
  if (1 == fn_len) {
#line 140
    if (45 == (int )*(fname + 0)) {
#line 141
      fp = stdin;
    } else {
#line 140
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 143
    fp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
    }
#line 144
    if ((unsigned long )((void *)0) == (unsigned long )fp) {
      {
#line 145
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to open %s for reading\n",
              fname);
      }
#line 146
      return (1);
    }
  }
#line 150
  j = 0;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! (j < 512)) {
#line 150
      goto while_break;
    }
    {
#line 151
    tmp___0 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)fp);
    }
#line 151
    if ((unsigned long )((void *)0) == (unsigned long )tmp___0) {
#line 152
      goto while_break;
    }
    {
#line 153
    tmp___1 = strlen((char const   *)(line));
#line 153
    in_len = (int )tmp___1;
    }
#line 154
    if (in_len > 0) {
#line 155
      if (10 == (int )line[in_len - 1]) {
#line 156
        in_len --;
#line 157
        line[in_len] = (char )'\000';
      }
    }
#line 160
    if (0 == in_len) {
#line 161
      goto __Cont;
    }
    {
#line 162
    lcp = (char const   *)(line);
#line 163
    tmp___2 = strspn(lcp, " \t");
#line 163
    m = (int )tmp___2;
    }
#line 164
    if (m == in_len) {
#line 165
      goto __Cont;
    }
#line 166
    lcp += m;
#line 167
    in_len -= m;
#line 168
    if (35 == (int )*lcp) {
#line 169
      goto __Cont;
    }
#line 170
    if (39 == (int )*lcp) {
#line 171
      goto astring;
    } else
#line 170
    if (34 == (int )*lcp) {
#line 171
      goto astring;
    }
#line 172
    if (45 == (int )*lcp) {
#line 172
      if (49 == (int )*(lcp + 1)) {
#line 173
        goto minus1;
      }
    }
#line 174
    if (! checked_hexlen) {
      {
#line 175
      checked_hexlen ++;
#line 176
      tmp___3 = strspn(lcp, "0123456789aAbBcCdDeEfF");
#line 176
      k = (int )tmp___3;
      }
#line 177
      if (k > 2) {
#line 178
        no_space = 1;
      }
    }
    {
#line 181
    tmp___4 = strspn(lcp, "0123456789aAbBcCdDeEfF ,\t");
#line 181
    k = (int )tmp___4;
    }
#line 182
    if (k < in_len) {
#line 182
      if (35 != (int )*(lcp + k)) {
        {
#line 183
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: syntax error at line %d, pos %d\n",
                j + 1, (m + k) + 1);
        }
#line 185
        goto bad;
      }
    }
#line 187
    if (no_space) {
#line 188
      k = 0;
      {
#line 188
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 188
        tmp___6 = __ctype_b_loc();
        }
#line 188
        if ((int const   )*(*tmp___6 + (int )*lcp) & 4096) {
          {
#line 188
          tmp___7 = __ctype_b_loc();
          }
#line 188
          if (! ((int const   )*(*tmp___7 + (int )*(lcp + 1)) & 4096)) {
#line 188
            goto while_break___0;
          }
        } else {
#line 188
          goto while_break___0;
        }
        {
#line 190
        tmp___5 = sscanf((char const   */* __restrict  */)lcp, (char const   */* __restrict  */)"%2x",
                         & h);
        }
#line 190
        if (1 != tmp___5) {
          {
#line 191
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: bad hex number in line %d, pos %d\n",
                  j + 1, (int )((lcp - (char const   *)(line)) + 1L));
          }
#line 193
          goto bad;
        }
#line 195
        if (off + k >= max_arr_len) {
          {
#line 196
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: array length exceeded\n");
          }
#line 197
          goto bad;
        }
#line 199
        *(mp_arr + (off + k)) = (unsigned char )h;
#line 188
        k ++;
#line 188
        lcp += 2;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 201
      off += k;
    } else {
#line 203
      k = 0;
      {
#line 203
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 203
        if (! (k < 1024)) {
#line 203
          goto while_break___1;
        }
        {
#line 204
        tmp___10 = sscanf((char const   */* __restrict  */)lcp, (char const   */* __restrict  */)"%x",
                          & h);
        }
#line 204
        if (1 == tmp___10) {
#line 205
          if (h > 255U) {
            {
#line 206
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: hex number larger than 0xff in line %d, pos %d\n",
                    j + 1, (int )((lcp - (char const   *)(line)) + 1L));
            }
#line 209
            goto bad;
          }
#line 211
          if (off + k >= max_arr_len) {
            {
#line 212
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: array length exceeded\n");
            }
#line 214
            goto bad;
          }
          {
#line 216
          *(mp_arr + (off + k)) = (unsigned char )h;
#line 217
          tmp___8 = strpbrk(lcp, " ,\t");
#line 217
          lcp = (char const   *)tmp___8;
          }
#line 218
          if ((unsigned long )((void *)0) == (unsigned long )lcp) {
#line 219
            goto while_break___1;
          }
          {
#line 220
          tmp___9 = strspn(lcp, " ,\t");
#line 220
          lcp += tmp___9;
          }
#line 221
          if (0 == (int )*lcp) {
#line 222
            goto while_break___1;
          }
        } else {
#line 224
          if (35 == (int )*lcp) {
#line 225
            k --;
#line 226
            goto while_break___1;
          }
          {
#line 228
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: error in line %d, at pos %d\n",
                  j + 1, (int )((lcp - (char const   *)(line)) + 1L));
          }
#line 231
          goto bad;
        }
#line 203
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 234
      off += k + 1;
    }
    __Cont: /* CIL Label */ 
#line 150
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  *mp_arr_len = off;
#line 238
  fclose(fp);
  }
#line 239
  return (0);
  astring: 
  {
#line 241
  cp = strchr(lcp + 1, (int )*lcp);
  }
#line 242
  if ((unsigned long )((void *)0) == (unsigned long )cp) {
    {
#line 243
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: unterminated ASCII string on line %d, starts: %s\n",
            j + 1, lcp);
    }
#line 245
    goto bad;
  }
#line 247
  k = (int )((cp - (char *)lcp) - 1L);
#line 248
  if (k > 0) {
#line 249
    if (off + k > max_arr_len) {
      {
#line 250
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: array length exceeded\n");
      }
#line 251
      goto bad;
    }
    {
#line 253
    memcpy((void */* __restrict  */)(mp_arr + off), (void const   */* __restrict  */)(lcp + 1),
           (size_t )k);
    }
  }
  {
#line 255
  off += k;
#line 256
  *mp_arr_len = off;
#line 257
  fclose(fp);
  }
#line 258
  return (0);
  minus1: 
#line 260
  k = off;
  {
#line 260
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 260
    if (! (k < max_arr_len)) {
#line 260
      goto while_break___2;
    }
#line 261
    *(mp_arr + k) = (unsigned char)255;
#line 260
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 262
  *mp_arr_len = k;
#line 263
  fclose(fp);
  }
#line 264
  return (0);
  bad: 
  {
#line 266
  fclose(fp);
  }
#line 267
  return (1);
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_zone_lock.c"
static void dStrRaw___15(char const   *str , int len ) 
{ 
  int k ;

  {
#line 275
  k = 0;
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    if (! (k < len)) {
#line 275
      goto while_break;
    }
    {
#line 276
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 275
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___34  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___17[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___17[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___17[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___17  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 53 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_zone_perm_tbl.c"
static char *version_str___35  =    (char *)"1.05 20111222";
#line 58 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_zone_perm_tbl.c"
static char *decode_rtype[4]  = {      (char *)"current",      (char *)"shadow",      (char *)"saved",      (char *)"default"};
#line 65 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_zone_perm_tbl.c"
static char *decode_numzg[4]  = {      (char *)"128",      (char *)"256",      (char *)"?",      (char *)"? ?"};
#line 72 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_zone_perm_tbl.c"
static int numzg_blen[4]  = {      16,      32,      0,      0};
#line 79 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_zone_perm_tbl.c"
static struct option long_options___16[16]  = 
#line 79
  {      {"append", 0, (int *)0, 'a'}, 
        {"bits", 1, (int *)0, 'B'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"multiple", 0, (int *)0, 'm'}, 
        {"num", 1, (int *)0, 'n'}, 
        {"nocomma", 0, (int *)0, 'N'}, 
        {"permf", 1, (int *)0, 'P'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"report", 1, (int *)0, 'R'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"start", 1, (int *)0, 'f'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 99 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_zone_perm_tbl.c"
static void usage___16(void) 
{ 


  {
  {
#line 102
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_rep_zone_perm_tbl [--append] [--bits=COL] [--help] [--hex]\n                             [--interface=PARAMS] [--multiple] [--nocomma]\n                             [--num=MD] [--permf=FN] [--raw] [--report=RT]\n                             [--sa=SAS_ADDR] [--start=SS] [--verbose]\n                             [--version] SMP_DEVICE[,N]\n  where:\n    --append|-a          append to FN with \'--permf\' option\n    --bits=COL|-B COL    output table as bit array with COL columns\n                         and ZP[0,0] top left (def: output byte array)\n    --help|-h            print out usage message\n    --hex|-H             print response in hexadecimal\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --multiple|-m        issue multiple function requests until all\n                         available descriptors (from SS) are read\n    --nocomma|-N         output descriptors as long string of hex\n                         (default: bytes comma separated)\n    --num=MD|-n MD       maximum number of descriptors in one response\n                         (default: 63)\n    --permf=FN|-P FN     write descriptors to file FN (default: write\n                         to stdout)\n    --raw|-r             output response in binary\n    --report=RT|-R RT    report type (default: 0). 0 -> current;\n                         1 -> shadow; 2 -> saved; 3 -> default\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n    --start=SS|-f SS     starting (first) source zone group (default: 0)\n    --verbose|-v         increase verbosity\n    --version|-V         print version string and exit\n\nPerform one or more SMP REPORT ZONE PERMISSION TABLE functions\n");
  }
#line 150
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_zone_perm_tbl.c"
static void dStrRaw___16(char const   *str , int len ) 
{ 
  int k ;

  {
#line 157
  k = 0;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! (k < len)) {
#line 157
      goto while_break;
    }
    {
#line 158
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 157
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___36  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___18[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___18[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 53 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_self_conf_stat.c"
static char *version_str___37  =    (char *)"1.02 20111222";
#line 57 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_self_conf_stat.c"
static struct option long_options___17[12]  = 
#line 57
  {      {"brief", 0, (int *)0, 'b'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"index", 1, (int *)0, 'i'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"last", 0, (int *)0, 'l'}, 
        {"one", 0, (int *)0, 'o'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 73 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_self_conf_stat.c"
static void usage___17(void) 
{ 


  {
  {
#line 76
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_rep_self_conf_stat [--brief] [--help] [--hex] [--index=SDI]\n                              [--interface=PARAMS] [--last] [--one] [raw]\n                              [--sa=SAS_ADDR] [--verbose] [--version]\n                              SMP_DEVICE[,N]\n  where:\n    --brief|-b              lessen the amount output\n    --help|-h               print out usage message\n    --hex|-H                print response in hexadecimal\n    --index=SDI|-i SDI      SDI is starting self-configuration status\n                            descriptor index (def: 1)\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --last|-l               output descriptors starting at last recorded\n    --one|-o                only output first descriptor\n    --raw|-r                output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending\n                                 on the interface, may not be needed\n    --verbose|-v            increase verbosity\n    --version|-V            print version string and exit\n\nPerforms a SMP REPORT SELF-CONFIGURATION STATUS function\n");
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_self_conf_stat.c"
static void dStrRaw___17(char const   *str , int len ) 
{ 
  int k ;

  {
#line 113
  k = 0;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! (k < len)) {
#line 113
      goto while_break;
    }
    {
#line 114
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 113
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_self_conf_stat.c"
static char *find_status_description(int status , char *buff , int buff_len ) 
{ 
  char const   *cp ;

  {
#line 120
  cp = (char const   *)((void *)0);
  {
#line 123
  if (status == 0) {
#line 123
    goto case_0;
  }
#line 124
  if (status == 1) {
#line 124
    goto case_1;
  }
#line 125
  if (status == 2) {
#line 125
    goto case_2;
  }
#line 126
  if (status == 3) {
#line 126
    goto case_3;
  }
#line 127
  if (status == 4) {
#line 127
    goto case_4;
  }
#line 128
  if (status == 32) {
#line 128
    goto case_32;
  }
#line 129
  if (status == 33) {
#line 129
    goto case_33;
  }
#line 130
  if (status == 64) {
#line 130
    goto case_64;
  }
#line 131
  if (status == 65) {
#line 131
    goto case_65;
  }
#line 132
  if (status == 66) {
#line 132
    goto case_66;
  }
#line 133
  if (status == 67) {
#line 133
    goto case_67;
  }
#line 134
  if (status == 68) {
#line 134
    goto case_68;
  }
#line 135
  if (status == 69) {
#line 135
    goto case_69;
  }
#line 136
  if (status == 70) {
#line 136
    goto case_70;
  }
#line 137
  if (status == 96) {
#line 137
    goto case_96;
  }
#line 138
  if (status == 97) {
#line 138
    goto case_97;
  }
#line 139
  if (status == 128) {
#line 139
    goto case_128;
  }
#line 140
  if (status == 160) {
#line 140
    goto case_160;
  }
#line 141
  if (status == 161) {
#line 141
    goto case_161;
  }
#line 142
  if (status == 162) {
#line 142
    goto case_162;
  }
#line 143
  if (status == 163) {
#line 143
    goto case_163;
  }
#line 144
  if (status == 164) {
#line 144
    goto case_164;
  }
#line 145
  if (status == 165) {
#line 145
    goto case_165;
  }
#line 146
  if (status == 166) {
#line 146
    goto case_166;
  }
#line 147
  goto switch_default;
  case_0: /* CIL Label */ 
#line 123
  cp = "reserved";
#line 123
  goto switch_break;
  case_1: /* CIL Label */ 
#line 124
  cp = "error not related to a specific layer";
#line 124
  goto switch_break;
  case_2: /* CIL Label */ 
#line 125
  cp = "trying to connect to SMP target {SA}";
#line 125
  goto switch_break;
  case_3: /* CIL Label */ 
#line 126
  cp = "route table full, unable to add {SA}";
#line 126
  goto switch_break;
  case_4: /* CIL Label */ 
#line 127
  cp = "expander out of resources";
#line 127
  goto switch_break;
  case_32: /* CIL Label */ 
#line 128
  cp = "error reported by phy layer";
#line 128
  goto switch_break;
  case_33: /* CIL Label */ 
#line 129
  cp = "all phys including {PI} lost dword sync";
#line 129
  goto switch_break;
  case_64: /* CIL Label */ 
#line 130
  cp = "error reported by link layer";
#line 130
  goto switch_break;
  case_65: /* CIL Label */ 
#line 131
  cp = "open timeout timer expired";
#line 131
  goto switch_break;
  case_66: /* CIL Label */ 
#line 132
  cp = "received an abandon-class open-reject";
#line 132
  goto switch_break;
  case_67: /* CIL Label */ 
#line 133
  cp = "vendor specific number of retry-class";
#line 133
  goto switch_break;
  case_68: /* CIL Label */ 
#line 134
  cp = "I_T nexus loss occurred";
#line 134
  goto switch_break;
  case_69: /* CIL Label */ 
#line 135
  cp = "connection request, received break";
#line 135
  goto switch_break;
  case_70: /* CIL Label */ 
#line 136
  cp = "SMP response frame CRC error";
#line 136
  goto switch_break;
  case_96: /* CIL Label */ 
#line 137
  cp = "error reported by port layer";
#line 137
  goto switch_break;
  case_97: /* CIL Label */ 
#line 138
  cp = "SMP response frame timeout";
#line 138
  goto switch_break;
  case_128: /* CIL Label */ 
#line 139
  cp = "error reported by SMP transport layer";
#line 139
  goto switch_break;
  case_160: /* CIL Label */ 
#line 140
  cp = "error reported by management app layer";
#line 140
  goto switch_break;
  case_161: /* CIL Label */ 
#line 141
  cp = "SMP response frame is too short";
#line 141
  goto switch_break;
  case_162: /* CIL Label */ 
#line 142
  cp = "SMP response contains invalid fields";
#line 142
  goto switch_break;
  case_163: /* CIL Label */ 
#line 143
  cp = "SMP response contains inconsistent fields";
#line 143
  goto switch_break;
  case_164: /* CIL Label */ 
#line 144
  cp = "{SA} has configuring bit set";
#line 144
  goto switch_break;
  case_165: /* CIL Label */ 
#line 145
  cp = "{SA} has self configuring bit set";
#line 145
  goto switch_break;
  case_166: /* CIL Label */ 
#line 146
  cp = "{SA} has zone configuring bit set";
#line 146
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 148
  if (status < 32) {
#line 149
    cp = "reserved for status not related to specific layer";
  } else
#line 150
  if (status < 64) {
#line 151
    cp = "reserved for status reported by phy layer";
  } else
#line 152
  if (status < 96) {
#line 153
    cp = "reserved for status reported by link layer";
  } else
#line 154
  if (status < 128) {
#line 155
    cp = "reserved for status reported by port layer";
  } else
#line 156
  if (status < 160) {
#line 157
    cp = "reserved for status reported by SMP transport layer";
  } else
#line 158
  if (status < 192) {
#line 159
    cp = "reserved for status reported by management app layer";
  } else
#line 160
  if (status < 224) {
#line 161
    cp = "reserved";
  } else {
#line 163
    cp = "vendor specific";
  }
  switch_break: /* CIL Label */ ;
  }
#line 165
  if (buff) {
#line 166
    if (cp) {
#line 166
      if (buff_len > 0) {
        {
#line 167
        strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)cp,
                (size_t )(buff_len - 1));
#line 168
        *(buff + (buff_len - 1)) = (char )'\000';
        }
      } else {
#line 166
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 169
    if (buff_len > 0) {
#line 170
      *(buff + 0) = (char )'\000';
    }
  }
#line 172
  return (buff);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___18[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___18  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___38  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___19[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___19[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 54 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_phy_event.c"
static char *version_str___39  =    (char *)"1.07 20111222";
#line 63 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_phy_event.c"
static struct option long_options___18[12]  = 
#line 63
  {      {"desc", 0, (int *)0, 'd'}, 
        {"enumerate", 0, (int *)0, 'e'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"long", 0, (int *)0, 'l'}, 
        {"phy", 1, (int *)0, 'p'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 78 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_phy_event.c"
static struct pes_name_t pes_name_arr[35]  = 
#line 78
  {      {0, "No event"}, 
        {1, "Invalid word count"}, 
        {2, "Running disparity error count"}, 
        {3, "Loss of dword synchronization count"}, 
        {4, "Phy reset problem count"}, 
        {5, "Elasticity buffer overflow count"}, 
        {6, "Received ERROR count"}, 
        {32, "Received address frame error count"}, 
        {33, "Transmitted abandon-class OPEN_REJECT count"}, 
        {34, "Received abandon-class OPEN_REJECT count"}, 
        {35, "Transmitted retry-class OPEN_REJECT count"}, 
        {36, "Received retry-class OPEN_REJECT count"}, 
        {37, "Received AIP (WATING ON PARTIAL) count"}, 
        {38, "Received AIP (WAITING ON CONNECTION) count"}, 
        {39, "Transmitted BREAK count"}, 
        {40, "Received BREAK count"}, 
        {41, "Break timeout count"}, 
        {42, "Connection count"}, 
        {43, "Peak transmitted pathway blocked count"}, 
        {44, "Peak transmitted arbitration wait time"}, 
        {45, "Peak arbitration time"}, 
        {46, "Peak connection time"}, 
        {64, "Transmitted SSP frame count"}, 
        {65, "Received SSP frame count"}, 
        {66, "Transmitted SSP frame error count"}, 
        {67, "Received SSP frame error count"}, 
        {68, "Transmitted CREDIT_BLOCKED count"}, 
        {69, "Received CREDIT_BLOCKED count"}, 
        {80, "Transmitted SATA frame count"}, 
        {81, "Received SATA frame count"}, 
        {82, "SATA flow control buffer overflow count"}, 
        {96, "Transmitted SMP frame count"}, 
        {97, "Received SMP frame count"}, 
        {99, "Received SMP frame error count"}, 
        {-1, (char const   *)((void *)0)}};
#line 125 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_phy_event.c"
static void usage___18(void) 
{ 


  {
  {
#line 128
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_rep_phy_event [--desc] [--enumerate] [--help] [--hex]\n                         [--interface=PARAMS] [--long] [--phy=ID] [--raw]\n                         [--sa=SAS_ADDR] [--verbose] [--version]\n                         SMP_DEVICE[,N]\n  where:\n    --desc|-d            show descriptor number in output\n    --enumerate|-e       enumerate phy event source names, ignore\n                         SMP_DEVICE if given\n    --help|-h            print out usage message\n    --hex|-H             print response in hexadecimal\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --long|-l            show phy event source hex value in output\n    --phy=ID|-p ID       phy identifier (def: 0)\n    --raw|-r             output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n    --verbose|-v         increase verbosity\n    --version|-V         print version string and exit\n\nPerforms a SMP REPORT PHY EVENT function\n");
  }
#line 158
  return;
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_phy_event.c"
static void dStrRaw___18(char const   *str , int len ) 
{ 
  int k ;

  {
#line 165
  k = 0;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! (k < len)) {
#line 165
      goto while_break;
    }
    {
#line 166
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 165
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_phy_event.c"
static char const   *get_pes_name(int pes , char *b , int blen ) 
{ 
  int len ;
  char const   *res ;
  struct pes_name_t  const  *pnp ;
  size_t tmp ;

  {
#line 173
  res = (char const   *)((void *)0);
#line 176
  if ((unsigned long )((void *)0) == (unsigned long )b) {
#line 177
    return (res);
  } else
#line 176
  if (blen < 1) {
#line 177
    return (res);
  }
#line 178
  pnp = (struct pes_name_t  const  *)(pes_name_arr);
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! pnp->pes_name) {
#line 178
      goto while_break;
    }
#line 179
    if (pes == (int )pnp->pes) {
      {
#line 180
      tmp = strlen((char const   *)pnp->pes_name);
#line 180
      len = (int )tmp;
      }
#line 181
      if (len > blen - 1) {
#line 182
        len = blen - 1;
      }
      {
#line 183
      memcpy((void */* __restrict  */)b, (void const   */* __restrict  */)pnp->pes_name,
             (size_t )len);
#line 184
      *(b + len) = (char )'\000';
      }
#line 185
      return ((char const   *)b);
    }
#line 178
    pnp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  return (res);
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_phy_event.c"
static void show_phy_event_info(int pes , unsigned int val , unsigned int thresh_val ,
                                int do_long ) 
{ 
  unsigned int u ;
  char str[32] ;
  char b[80] ;
  char const   *cp ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 201
  memset((void *)(str), 0, sizeof(str));
  }
#line 202
  if (do_long) {
    {
#line 203
    snprintf((char */* __restrict  */)(str), sizeof(str) - 1UL, (char const   */* __restrict  */)"[0x%x] ",
             (unsigned int )pes);
    }
  }
  {
#line 206
  if (pes == 0) {
#line 206
    goto case_0;
  }
#line 237
  if (pes == 99) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 97) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 96) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 82) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 81) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 80) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 69) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 68) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 67) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 66) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 65) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 64) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 42) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 41) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 40) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 39) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 38) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 37) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 36) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 35) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 34) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 33) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 32) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 6) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 5) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 4) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 3) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 2) {
#line 237
    goto case_99;
  }
#line 237
  if (pes == 1) {
#line 237
    goto case_99;
  }
#line 244
  if (pes == 43) {
#line 244
    goto case_43;
  }
#line 250
  if (pes == 44) {
#line 250
    goto case_44;
  }
#line 264
  if (pes == 45) {
#line 264
    goto case_45;
  }
#line 269
  if (pes == 46) {
#line 269
    goto case_46;
  }
#line 274
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 207
  printf((char const   */* __restrict  */)"     %sNo event\n", str);
  }
#line 208
  goto switch_break;
  case_99: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_32: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 238
  cp = get_pes_name(pes, b, (int )sizeof(b));
  }
#line 238
  if (cp) {
    {
#line 239
    printf((char const   */* __restrict  */)"     %s%s: %u\n", str, cp, val);
    }
  } else {
    {
#line 241
    printf((char const   */* __restrict  */)"     %sUnknown Phy Event Source [0x%x]: %u\n",
           str, pes, val);
    }
  }
#line 243
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 245
  tmp = get_pes_name(pes, b, (int )sizeof(b));
#line 245
  printf((char const   */* __restrict  */)"     %s%s: %u\n", str, tmp, val & 255U);
#line 247
  printf((char const   */* __restrict  */)"         Peak value detector threshold: %u\n",
         thresh_val & 255U);
  }
#line 249
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 251
  cp = get_pes_name(pes, b, (int )sizeof(b));
#line 252
  u = val & 65535U;
  }
#line 253
  if (u < 32768U) {
    {
#line 254
    printf((char const   */* __restrict  */)"     %s%s (us): %u\n", str, cp, u);
    }
  } else {
    {
#line 256
    printf((char const   */* __restrict  */)"     %s%s (ms): %u\n", str, cp, 33U + (u - 32768U));
    }
  }
#line 257
  u = thresh_val & 65535U;
#line 258
  if (u < 32768U) {
    {
#line 259
    printf((char const   */* __restrict  */)"         Peak value detector threshold (us): %u\n",
           u);
    }
  } else {
    {
#line 261
    printf((char const   */* __restrict  */)"         Peak value detector threshold (ms): %u\n",
           33U + (u - 32768U));
    }
  }
#line 263
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 265
  tmp___0 = get_pes_name(pes, b, (int )sizeof(b));
#line 265
  printf((char const   */* __restrict  */)"     %s%s (us): %u\n", str, tmp___0, val);
#line 267
  printf((char const   */* __restrict  */)"         Peak value detector threshold: %u\n",
         thresh_val);
  }
#line 268
  goto switch_break;
  case_46: /* CIL Label */ 
  {
#line 270
  tmp___1 = get_pes_name(pes, b, (int )sizeof(b));
#line 270
  printf((char const   */* __restrict  */)"     %s%s (us): %u\n", str, tmp___1, val);
#line 272
  printf((char const   */* __restrict  */)"         Peak value detector threshold: %u\n",
         thresh_val);
  }
#line 273
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 275
  printf((char const   */* __restrict  */)"     Unknown phy event source: 0x%x, val=%u, thresh_val=%u\n",
         pes, val, thresh_val);
  }
#line 277
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 279
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___19[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___19  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___40  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___20[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___20[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___20[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___20  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 53 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_phy_sata.c"
static char *version_str___41  =    (char *)"1.13 20111222";
#line 57 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_phy_sata.c"
static struct option long_options___19[11]  = 
#line 57
  {      {"affiliation", 1, (int *)0, 'a'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"phy", 1, (int *)0, 'p'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"zero", 0, (int *)0, 'z'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 72 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_phy_sata.c"
static void usage___19(void) 
{ 


  {
  {
#line 75
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_rep_phy_sata [--affiliation=AC] [--help] [--hex]\n                        [--interface=PARAMS] [--phy=ID] [--raw]\n                        [--sa=SAS_ADDR] [--verbose] [--version] [--zero]\n                        SMP_DEVICE[,N]\n  where:\n    --affiliation=AC|-a AC    relative identifier of affiliation context\n                              (def: 0)\n    --help|-h            print out usage message\n    --hex|-H             print response in hexadecimal\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --phy=ID|-p ID       phy identifier (def: 0)\n    --raw|-r             output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n    --verbose|-v         increase verbosity\n    --version|-V         print version string and exit\n    --zero|-z            zero Allocated Response Length field,\n                         may be required prior to SAS-2\n\nPerforms a SMP REPORT PHY SATA function\n");
  }
#line 105
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_phy_sata.c"
static void dStrRaw___19(char const   *str , int len ) 
{ 
  int k ;

  {
#line 112
  k = 0;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! (k < len)) {
#line 112
      goto while_break;
    }
    {
#line 113
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 112
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___42  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___21[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___21[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___21[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___21  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 54 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_phy_event.c"
static char *version_str___43  =    (char *)"1.00 20111222";
#line 63 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_phy_event.c"
static struct option long_options___20[15]  = 
#line 63
  {      {"clear", 0, (int *)0, 'C'}, 
        {"enumerate", 0, (int *)0, 'e'}, 
        {"expected", 1, (int *)0, 'E'}, 
        {"file", 1, (int *)0, 'f'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"pes", 1, (int *)0, 'P'}, 
        {"phy", 1, (int *)0, 'p'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"thres", 1, (int *)0, 'T'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 81 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_phy_event.c"
static struct pes_name_t pes_name_arr___0[35]  = 
#line 81
  {      {0, "No event"}, 
        {1, "Invalid word count"}, 
        {2, "Running disparity error count"}, 
        {3, "Loss of dword synchronization count"}, 
        {4, "Phy reset problem count"}, 
        {5, "Elasticity buffer overflow count"}, 
        {6, "Received ERROR count"}, 
        {32, "Received address frame error count"}, 
        {33, "Transmitted abandon-class OPEN_REJECT count"}, 
        {34, "Received abandon-class OPEN_REJECT count"}, 
        {35, "Transmitted retry-class OPEN_REJECT count"}, 
        {36, "Received retry-class OPEN_REJECT count"}, 
        {37, "Received AIP (WATING ON PARTIAL) count"}, 
        {38, "Received AIP (WAITING ON CONNECTION) count"}, 
        {39, "Transmitted BREAK count"}, 
        {40, "Received BREAK count"}, 
        {41, "Break timeout count"}, 
        {42, "Connection count"}, 
        {43, "Peak transmitted pathway blocked count"}, 
        {44, "Peak transmitted arbitration wait time"}, 
        {45, "Peak arbitration time"}, 
        {46, "Peak connection time"}, 
        {64, "Transmitted SSP frame count"}, 
        {65, "Received SSP frame count"}, 
        {66, "Transmitted SSP frame error count"}, 
        {67, "Received SSP frame error count"}, 
        {68, "Transmitted CREDIT_BLOCKED count"}, 
        {69, "Received CREDIT_BLOCKED count"}, 
        {80, "Transmitted SATA frame count"}, 
        {81, "Received SATA frame count"}, 
        {82, "SATA flow control buffer overflow count"}, 
        {96, "Transmitted SMP frame count"}, 
        {97, "Received SMP frame count"}, 
        {99, "Received SMP frame error count"}, 
        {-1, (char const   *)((void *)0)}};
#line 128 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_phy_event.c"
static void usage___20(void) 
{ 


  {
  {
#line 131
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_conf_phy_event [--clear] [--enumerate] [--expected=EX]\n                          [--file=FILE] [--help] [--hex]\n                          [--interface=PARAMS] [--pes=PES,PES...]\n                          [--phy=ID] [--raw] [--sa=SAS_ADDR]\n                          [--thres=THR,THR...] [--verbose] [--version]\n                          SMP_DEVICE[,N]\n  where:\n    --clear|-C             clear all peak value detectors for this phy\n    --enumerate|-e         enumerate phy event source names, ignore\n                           SMP_DEVICE if given\n    --expected=EX|-E EX    set expected expander change count to EX\n    --file=FILE|-f FILE    read PES, THR pairs from FILE\n    --help|-h              print out usage message\n    --hex|-H               print response in hexadecimal\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --pes=PES,PES...|-P PES,PES...    comma separated list of Phy\n                                      Event Sources\n    --phy=ID|-p ID         phy identifier (def: 0)\n    --raw|-r               output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n    --thres=THR,THR...|-T THR,THR...    comma separated list of peak\n                                        value detector thresholds\n    --verbose|-v           increase verbosity\n    --version|-V           print version string and exit\n\nPerforms a SMP CONFIGURE PHY EVENT function\n");
  }
#line 172
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_phy_event.c"
unsigned int get_unum(char const   *buf , int *err ) 
{ 
  int res ;
  int len ;
  unsigned int unum ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 185
  if ((unsigned long )((void *)0) == (unsigned long )buf) {
#line 185
    goto _L;
  } else
#line 185
  if (0 == (int )*(buf + 0)) {
    _L: /* CIL Label */ 
#line 186
    if (err) {
#line 187
      *err = 1;
    }
#line 188
    return (0U);
  }
  {
#line 190
  tmp = strspn(buf, "0123456789aAbBcCdDeEfFhHxX");
#line 190
  len = (int )tmp;
  }
#line 191
  if (0 == len) {
#line 192
    if (err) {
#line 193
      *err = 1;
    }
#line 194
    return (0U);
  }
#line 196
  if (48 == (int )*(buf + 0)) {
#line 196
    if (120 == (int )*(buf + 1)) {
      {
#line 197
      res = sscanf((char const   */* __restrict  */)(buf + 2), (char const   */* __restrict  */)"%x",
                   & unum);
      }
    } else
#line 196
    if (88 == (int )*(buf + 1)) {
      {
#line 197
      res = sscanf((char const   */* __restrict  */)(buf + 2), (char const   */* __restrict  */)"%x",
                   & unum);
      }
    } else {
#line 196
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 198
    tmp___0 = toupper((int )*(buf + (len - 1)));
    }
#line 198
    if (72 == tmp___0) {
      {
#line 199
      res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%x",
                   & unum);
      }
    } else {
      {
#line 201
      res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%u",
                   & unum);
      }
    }
  }
#line 202
  if (1 == res) {
#line 203
    if (err) {
#line 204
      *err = 0;
    }
#line 205
    return (unum);
  } else {
#line 207
    if (err) {
#line 208
      *err = 1;
    }
#line 209
    return (0U);
  }
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_phy_event.c"
static int build_pes_arr(char const   *inp , unsigned char *pes_arr , int *pes_arr_len ,
                         int max_arr_len ) 
{ 
  int in_len ;
  int k ;
  int err ;
  char const   *lcp ;
  unsigned int unum ;
  char *cp ;
  char *c2p ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 227
  if ((unsigned long )((void *)0) == (unsigned long )inp) {
#line 228
    return (1);
  } else
#line 227
  if ((unsigned long )((void *)0) == (unsigned long )pes_arr) {
#line 228
    return (1);
  } else
#line 227
  if ((unsigned long )((void *)0) == (unsigned long )pes_arr_len) {
#line 228
    return (1);
  }
  {
#line 229
  lcp = inp;
#line 230
  tmp = strlen(inp);
#line 230
  in_len = (int )tmp;
  }
#line 231
  if (0 == in_len) {
#line 232
    *pes_arr_len = 0;
  }
#line 233
  if (45 == (int )*(inp + 0)) {
    {
#line 234
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'--pes\' cannot be read from stdin\n");
    }
#line 235
    return (1);
  } else {
    {
#line 237
    tmp___0 = strspn(inp, "0123456789aAbBcCdDeEfFhHxX, ");
#line 237
    k = (int )tmp___0;
    }
#line 238
    if (in_len != k) {
      {
#line 239
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"build_pes_arr: error at pos %d\n",
              k + 1);
      }
#line 240
      return (1);
    }
#line 242
    k = 0;
    {
#line 242
    while (1) {
      while_continue: /* CIL Label */ ;
#line 242
      if (! (k < max_arr_len)) {
#line 242
        goto while_break;
      }
      {
#line 243
      unum = get_unum(lcp, & err);
      }
#line 244
      if (! err) {
#line 244
        if (unum < 256U) {
          {
#line 245
          *(pes_arr + k) = (unsigned char )unum;
#line 246
          cp = strchr(lcp, ',');
#line 247
          c2p = strchr(lcp, ' ');
          }
#line 248
          if ((unsigned long )((void *)0) == (unsigned long )cp) {
#line 249
            cp = c2p;
          }
#line 250
          if ((unsigned long )((void *)0) == (unsigned long )cp) {
#line 251
            goto while_break;
          }
#line 252
          if (c2p) {
#line 252
            if ((unsigned long )c2p < (unsigned long )cp) {
#line 253
              cp = c2p;
            }
          }
#line 254
          lcp = (char const   *)(cp + 1);
        } else {
          {
#line 256
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"build_pes_arr: error at pos %d\n",
                  (int )((lcp - inp) + 1L));
          }
#line 258
          return (1);
        }
      } else {
        {
#line 256
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"build_pes_arr: error at pos %d\n",
                (int )((lcp - inp) + 1L));
        }
#line 258
        return (1);
      }
#line 242
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 261
    *pes_arr_len = k + 1;
#line 262
    if (k == max_arr_len) {
      {
#line 263
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"build_pes_arr: array length exceeded\n");
      }
#line 264
      return (1);
    }
  }
#line 267
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_phy_event.c"
static int build_thres_arr(char const   *inp , unsigned int *thres_arr , int *thres_arr_len ,
                           int max_arr_len ) 
{ 
  int in_len ;
  int k ;
  int err ;
  char const   *lcp ;
  unsigned int unum ;
  char *cp ;
  char *c2p ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 284
  if ((unsigned long )((void *)0) == (unsigned long )inp) {
#line 285
    return (1);
  } else
#line 284
  if ((unsigned long )((void *)0) == (unsigned long )thres_arr) {
#line 285
    return (1);
  } else
#line 284
  if ((unsigned long )((void *)0) == (unsigned long )thres_arr_len) {
#line 285
    return (1);
  }
  {
#line 286
  lcp = inp;
#line 287
  tmp = strlen(inp);
#line 287
  in_len = (int )tmp;
  }
#line 288
  if (0 == in_len) {
#line 289
    *thres_arr_len = 0;
  }
#line 290
  if (45 == (int )*(inp + 0)) {
    {
#line 291
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'--thres\' cannot be read from stdin\n");
    }
#line 292
    return (1);
  } else {
    {
#line 294
    tmp___0 = strspn(inp, "0123456789aAbBcCdDeEfFhHxX, ");
#line 294
    k = (int )tmp___0;
    }
#line 295
    if (in_len != k) {
      {
#line 296
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"build_thres_arr: error at pos %d\n",
              k + 1);
      }
#line 297
      return (1);
    }
#line 299
    k = 0;
    {
#line 299
    while (1) {
      while_continue: /* CIL Label */ ;
#line 299
      if (! (k < max_arr_len)) {
#line 299
        goto while_break;
      }
      {
#line 300
      unum = get_unum(lcp, & err);
      }
#line 301
      if (! err) {
        {
#line 302
        *(thres_arr + k) = unum;
#line 303
        cp = strchr(lcp, ',');
#line 304
        c2p = strchr(lcp, ' ');
        }
#line 305
        if ((unsigned long )((void *)0) == (unsigned long )cp) {
#line 306
          cp = c2p;
        }
#line 307
        if ((unsigned long )((void *)0) == (unsigned long )cp) {
#line 308
          goto while_break;
        }
#line 309
        if (c2p) {
#line 309
          if ((unsigned long )c2p < (unsigned long )cp) {
#line 310
            cp = c2p;
          }
        }
#line 311
        lcp = (char const   *)(cp + 1);
      } else {
        {
#line 313
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"build_thres_arr: error at pos %d\n",
                (int )((lcp - inp) + 1L));
        }
#line 315
        return (1);
      }
#line 299
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 318
    *thres_arr_len = k + 1;
#line 319
    if (k == max_arr_len) {
      {
#line 320
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"build_num_arr: array length exceeded\n");
      }
#line 321
      return (1);
    }
  }
#line 324
  return (0);
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_phy_event.c"
static int build_joint_arr(char const   *file_name , unsigned char *pes_arr , unsigned int *thres_arr ,
                           int *arr_len , int max_arr_len ) 
{ 
  char line[512] ;
  int off ;
  int in_len ;
  int k ;
  int j ;
  int m ;
  int have_stdin ;
  int ind ;
  int bit0 ;
  int err ;
  char *lcp ;
  FILE *fp ;
  unsigned int unum ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char const   *tmp___6 ;

  {
  {
#line 337
  off = 0;
#line 343
  tmp = strlen(file_name);
  }
#line 343
  if (1UL == tmp) {
#line 343
    if (45 == (int )*(file_name + 0)) {
#line 343
      tmp___0 = 1;
    } else {
#line 343
      tmp___0 = 0;
    }
  } else {
#line 343
    tmp___0 = 0;
  }
#line 343
  have_stdin = tmp___0;
#line 344
  if (have_stdin) {
#line 345
    fp = stdin;
  } else {
    {
#line 347
    fp = fopen((char const   */* __restrict  */)file_name, (char const   */* __restrict  */)"r");
    }
#line 348
    if ((unsigned long )((void *)0) == (unsigned long )fp) {
      {
#line 349
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"build_joint_arr: unable to open %s\n",
              file_name);
      }
#line 351
      return (1);
    }
  }
#line 355
  j = 0;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    if (! (j < 512)) {
#line 355
      goto while_break;
    }
    {
#line 356
    tmp___1 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)fp);
    }
#line 356
    if ((unsigned long )((void *)0) == (unsigned long )tmp___1) {
#line 357
      goto while_break;
    }
    {
#line 358
    tmp___2 = strlen((char const   *)(line));
#line 358
    in_len = (int )tmp___2;
    }
#line 359
    if (in_len > 0) {
#line 360
      if (10 == (int )line[in_len - 1]) {
#line 361
        in_len --;
#line 362
        line[in_len] = (char )'\000';
      }
    }
#line 365
    if (0 == in_len) {
#line 366
      goto __Cont;
    }
    {
#line 367
    lcp = line;
#line 368
    tmp___3 = strspn((char const   *)lcp, " \t");
#line 368
    m = (int )tmp___3;
    }
#line 369
    if (m == in_len) {
#line 370
      goto __Cont;
    }
#line 371
    lcp += m;
#line 372
    in_len -= m;
#line 373
    if (35 == (int )*lcp) {
#line 374
      goto __Cont;
    }
    {
#line 375
    tmp___4 = strspn((char const   *)lcp, "0123456789aAbBcCdDeEfFhHxX ,\t");
#line 375
    k = (int )tmp___4;
    }
#line 376
    if (k < in_len) {
#line 376
      if (35 != (int )*(lcp + k)) {
        {
#line 377
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"build_joint_arr: syntax error at line %d, pos %d\n",
                j + 1, (m + k) + 1);
        }
#line 379
        return (1);
      }
    }
#line 381
    k = 0;
    {
#line 381
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 381
      if (! (k < 1024)) {
#line 381
        goto while_break___0;
      }
      {
#line 382
      unum = get_unum((char const   *)lcp, & err);
      }
#line 383
      if (! err) {
#line 384
        ind = (off + k) >> 1;
#line 385
        bit0 = 1 & (off + k);
#line 386
        if (ind >= max_arr_len) {
          {
#line 387
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"build_joint_arr: array length exceeded\n");
          }
#line 389
          return (1);
        }
#line 391
        if (bit0) {
#line 392
          *(thres_arr + ind) = unum;
        } else {
#line 394
          if (unum > 255U) {
            {
#line 395
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"build_joint_arr: pes (%u) too large\n",
                    unum);
            }
#line 397
            return (1);
          }
#line 399
          *(pes_arr + ind) = (unsigned char )unum;
        }
        {
#line 401
        lcp = strpbrk((char const   *)lcp, " ,\t");
        }
#line 402
        if ((unsigned long )((void *)0) == (unsigned long )lcp) {
#line 403
          goto while_break___0;
        }
        {
#line 404
        tmp___5 = strspn((char const   *)lcp, " ,\t");
#line 404
        lcp += tmp___5;
        }
#line 405
        if (0 == (int )*lcp) {
#line 406
          goto while_break___0;
        }
      } else {
#line 408
        if (35 == (int )*lcp) {
#line 409
          k --;
#line 410
          goto while_break___0;
        }
        {
#line 412
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"build_joint_arr: error in line %d, at pos %d\n",
                j + 1, (int )((lcp - line) + 1L));
        }
#line 415
        return (1);
      }
#line 381
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 418
    off += k + 1;
    __Cont: /* CIL Label */ 
#line 355
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 420
  if (1 & off) {
#line 421
    if (have_stdin) {
#line 421
      tmp___6 = "stdin";
    } else {
#line 421
      tmp___6 = file_name;
    }
    {
#line 421
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"build_joint_arr: expect LBA,NUM pairs but decoded odd number\n  from %s\n",
            tmp___6);
    }
#line 423
    return (1);
  }
#line 425
  *arr_len = off >> 1;
#line 426
  return (0);
}
}
#line 429 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_phy_event.c"
static void dStrRaw___20(char const   *str , int len ) 
{ 
  int k ;

  {
#line 434
  k = 0;
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! (k < len)) {
#line 434
      goto while_break;
    }
    {
#line 435
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 434
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 436
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___44  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___22[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___22[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___22[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___22  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 53 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_exp_route_tbl.c"
static char *version_str___45  =    (char *)"1.10 20111222";
#line 56 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_exp_route_tbl.c"
static struct option long_options___21[12]  = 
#line 56
  {      {"brief", 0, (int *)0, 'b'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"index", 1, (int *)0, 'i'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"num", 1, (int *)0, 'n'}, 
        {"phy", 1, (int *)0, 'p'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 84 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_exp_route_tbl.c"
static void usage___21(void) 
{ 


  {
  {
#line 87
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_rep_exp_route_tbl  [--brief] [--help] [--hex] [--index=IN]\n                    [--interface=PARAMS] [--num=NUM] [--phy=ID] [--raw]\n                    [--sa=SAS_ADDR] ");
#line 93
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[--verbose] [--version]\n                    <smp_device>[,<n>]\n  where:\n    --brief|-b           brief: abridge output\n    --help|-h            print out usage message\n    --hex|-H             print response in hexadecimal\n    --index=IN|-i IN     starting routed SAS address index (def: 0)\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --num=NUM|-n NUM     maximum number of descriptors to fetch (def: 62)\n    --phy=ID|-p ID       starting phy identifier within bitmap (def: 0)\n                         [should be a multiple of 48]\n    --raw|-r             output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n");
#line 116
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    --verbose|-v         increase verbosity\n    --version|-V         print version string and exit\n\nPerforms a SMP REPORT EXPANDER ROUTE TABLE LIST function. Each descriptor\nin the output contains: a routed SAS address, a 48 bit phy bitmap and a\nzone group\n");
  }
#line 123
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_exp_route_tbl.c"
static void dStrRaw___21(char const   *str , int len ) 
{ 
  int k ;

  {
#line 130
  k = 0;
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! (k < len)) {
#line 130
      goto while_break;
    }
    {
#line 131
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 130
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_exp_route_tbl.c"
static int do_rep_exp_rou_tbl(struct smp_target_obj *top , unsigned char *resp , int max_resp_len ,
                              struct opts_t___1 *optsp ) 
{ 
  unsigned char smp_req[32] ;
  struct smp_req_resp smp_rr ;
  char b[256] ;
  char *cp ;
  int len ;
  int res ;
  int k ;
  int dword_resp_len ;
  int act_resplen ;
  char *tmp ;

  {
#line 140
  smp_req[0] = (unsigned char)64;
#line 140
  smp_req[1] = (unsigned char)34;
#line 140
  smp_req[2] = (unsigned char)0;
#line 140
  smp_req[3] = (unsigned char)6;
#line 140
  smp_req[4] = (unsigned char)0;
#line 140
  smp_req[5] = (unsigned char)0;
#line 140
  smp_req[6] = (unsigned char)0;
#line 140
  smp_req[7] = (unsigned char)0;
#line 140
  smp_req[8] = (unsigned char)0;
#line 140
  smp_req[9] = (unsigned char)0;
#line 140
  smp_req[10] = (unsigned char)0;
#line 140
  smp_req[11] = (unsigned char)0;
#line 140
  smp_req[12] = (unsigned char)0;
#line 140
  smp_req[13] = (unsigned char)0;
#line 140
  smp_req[14] = (unsigned char)0;
#line 140
  smp_req[15] = (unsigned char)0;
#line 140
  smp_req[16] = (unsigned char)0;
#line 140
  smp_req[17] = (unsigned char)0;
#line 140
  smp_req[18] = (unsigned char)0;
#line 140
  smp_req[19] = (unsigned char)0;
#line 140
  smp_req[20] = (unsigned char)0;
#line 140
  smp_req[21] = (unsigned char)0;
#line 140
  smp_req[22] = (unsigned char)0;
#line 140
  smp_req[23] = (unsigned char)0;
#line 140
  smp_req[24] = (unsigned char)0;
#line 140
  smp_req[25] = (unsigned char)0;
#line 140
  smp_req[26] = (unsigned char)0;
#line 140
  smp_req[27] = (unsigned char)0;
#line 140
  smp_req[28] = (unsigned char)0;
#line 140
  smp_req[29] = (unsigned char)0;
#line 140
  smp_req[30] = (unsigned char)0;
#line 140
  smp_req[31] = (unsigned char)0;
#line 150
  dword_resp_len = (max_resp_len - 8) / 4;
#line 151
  if (dword_resp_len < 256) {
#line 151
    smp_req[2] = (unsigned char )dword_resp_len;
  } else {
#line 151
    smp_req[2] = (unsigned char)255;
  }
#line 152
  smp_req[8] = (unsigned char )((optsp->do_num >> 8) & 255);
#line 153
  smp_req[9] = (unsigned char )(optsp->do_num & 255);
#line 154
  smp_req[10] = (unsigned char )((optsp->start_rsa_index >> 8) & 255);
#line 155
  smp_req[11] = (unsigned char )(optsp->start_rsa_index & 255);
#line 156
  smp_req[19] = (unsigned char )optsp->phy_id;
#line 157
  if (optsp->verbose) {
    {
#line 158
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Report expander route table request: ");
#line 159
    k = 0;
    }
    {
#line 159
    while (1) {
      while_continue: /* CIL Label */ ;
#line 159
      if (! (k < (int )sizeof(smp_req))) {
#line 159
        goto while_break;
      }
#line 160
      if (0 == k % 16) {
        {
#line 161
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n      ");
        }
      } else
#line 162
      if (0 == k % 8) {
        {
#line 163
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ");
        }
      }
      {
#line 164
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x ",
              (int )smp_req[k]);
#line 159
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 166
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 168
  memset((void *)(& smp_rr), 0, sizeof(smp_rr));
#line 169
  smp_rr.request_len = (int )sizeof(smp_req);
#line 170
  smp_rr.request = smp_req;
#line 171
  smp_rr.max_response_len = max_resp_len;
#line 172
  smp_rr.response = resp;
#line 173
  res = smp_send_req((struct smp_target_obj  const  *)top, & smp_rr, optsp->verbose);
  }
#line 175
  if (res) {
    {
#line 176
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"smp_send_req failed, res=%d\n",
            res);
    }
#line 177
    if (0 == optsp->verbose) {
      {
#line 178
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    try adding \'-v\' option for more debug\n");
      }
    }
#line 179
    return (-1);
  }
#line 181
  if (smp_rr.transport_err) {
    {
#line 182
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"smp_send_req transport_error=%d\n",
            smp_rr.transport_err);
    }
#line 184
    return (-1);
  }
#line 186
  act_resplen = smp_rr.act_response_len;
#line 187
  if (act_resplen >= 0) {
#line 187
    if (act_resplen < 4) {
      {
#line 188
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"response too short, len=%d\n",
              act_resplen);
      }
#line 189
      return (97);
    }
  }
#line 191
  len = (int )*(resp + 3);
#line 192
  if (0 == len) {
#line 192
    if (0 == (int )*(resp + 2)) {
      {
#line 193
      len = smp_get_func_def_resp_len((int )*(resp + 1));
      }
#line 194
      if (len < 0) {
#line 195
        len = 0;
#line 196
        if (optsp->verbose > 0) {
          {
#line 197
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to determine response length\n");
          }
        }
      }
    }
  }
#line 200
  len = 4 + len * 4;
#line 201
  if (act_resplen >= 0) {
#line 201
    if (len > act_resplen) {
#line 202
      if (optsp->verbose) {
        {
#line 203
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"actual response length [%d] less than deduced length [%d]\n",
                act_resplen, len);
        }
      }
#line 205
      len = act_resplen;
    }
  }
#line 207
  if (optsp->do_hex) {
#line 207
    goto _L;
  } else
#line 207
  if (optsp->do_raw) {
    _L: /* CIL Label */ 
#line 208
    if (optsp->do_hex) {
      {
#line 209
      dStrHex((char const   *)resp, len, 1);
      }
    } else {
      {
#line 211
      dStrRaw___21((char const   *)resp, len);
      }
    }
#line 212
    if (65 != (int )*(resp + 0)) {
#line 213
      return (97);
    }
#line 214
    if ((int )*(resp + 1) != (int )smp_req[1]) {
#line 215
      return (97);
    }
#line 216
    if (*(resp + 2)) {
#line 217
      if (optsp->verbose) {
        {
#line 218
        tmp = smp_get_func_res_str((int )*(resp + 2), (int )sizeof(b), b);
#line 218
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Report expander route table result: %s\n",
                tmp);
        }
      }
#line 220
      return ((int )*(resp + 2));
    }
#line 222
    return (0);
  }
#line 224
  if (65 != (int )*(resp + 0)) {
    {
#line 225
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"expected SMP frame response type, got=0x%x\n",
            (int )*(resp + 0));
    }
#line 227
    return (97);
  }
#line 229
  if ((int )*(resp + 1) != (int )smp_req[1]) {
    {
#line 230
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Expected function code=0x%x, got=0x%x\n",
            (int )smp_req[1], (int )*(resp + 1));
    }
#line 232
    return (97);
  }
#line 234
  if (*(resp + 2)) {
    {
#line 235
    cp = smp_get_func_res_str((int )*(resp + 2), (int )sizeof(b), b);
#line 236
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Report expander route table result: %s\n",
            cp);
    }
#line 237
    return ((int )*(resp + 2));
  }
#line 239
  return (0);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_zoned_broadcast.c"
static char *version_str___46  =    (char *)"1.02 20111222";
#line 55 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_zoned_broadcast.c"
static struct option long_options___22[12]  = 
#line 55
  {      {"broadcast", 1, (int *)0, 'b'}, 
        {"expected", 1, (int *)0, 'E'}, 
        {"fszg", 1, (int *)0, 'F'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"szg", 1, (int *)0, 'S'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 71 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_zoned_broadcast.c"
static void usage___22(void) 
{ 


  {
  {
#line 74
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_zoned_broadcast [--broadcast=BT] [--expected=EX] [--fszg=FS]\n                           [--help] [--hex] [--interface=PARAMS] [--raw]\n                           [--sa=SAS_ADDR] [--szg=ZGL] [--verbose]\n                           [--version] SMP_DEVICE[,N]\n  where:\n    --broadcast=BT|-b BT    BT is type of broadcast (def: 0 which is\n                            Broadcast(Change))\n    --expected=EX|-E EX     set expected expander change count to EX\n    --fszg=FS|-F FS         file FS contains one or more source zone groups\n    --help|-h               print out usage message\n    --hex|-H                print response in hexadecimal\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --raw|-r                output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending\n                                 on the interface, may not be needed\n    --szg=ZGL|-S ZGL        ZGL is a comma separated list of source\n                            zone groups for broadcast\n    --verbose|-v            increase verbosity\n    --version|-V            print version string and exit\n\nPerforms a SMP ZONED BROADCAST function. Source zone groups can be given\nin decimal (default) or hex with a \'0x\' prefix  or a \'h\' suffix.\nBroadcast(Change) will cause an SMP initiator to run its discover process.\n");
  }
#line 111
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_zoned_broadcast.c"
static int fd2hex_arr(char const   *fname , unsigned char *mp_arr , int *mp_arr_len ,
                      int max_arr_len ) 
{ 
  int fn_len ;
  int in_len ;
  int k ;
  int j ;
  int m ;
  int h ;
  char const   *lcp ;
  FILE *fp ;
  char line[512] ;
  int off ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;

  {
#line 128
  off = 0;
#line 130
  if ((unsigned long )((void *)0) == (unsigned long )fname) {
#line 131
    return (1);
  } else
#line 130
  if ((unsigned long )((void *)0) == (unsigned long )mp_arr) {
#line 131
    return (1);
  } else
#line 130
  if ((unsigned long )((void *)0) == (unsigned long )mp_arr_len) {
#line 131
    return (1);
  }
  {
#line 132
  tmp = strlen(fname);
#line 132
  fn_len = (int )tmp;
  }
#line 133
  if (0 == fn_len) {
#line 134
    return (1);
  }
#line 135
  if (1 == fn_len) {
#line 135
    if (45 == (int )*(fname + 0)) {
#line 136
      fp = stdin;
    } else {
#line 135
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 138
    fp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
    }
#line 139
    if ((unsigned long )((void *)0) == (unsigned long )fp) {
      {
#line 140
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to open %s for reading\n",
              fname);
      }
#line 141
      return (1);
    }
  }
#line 145
  j = 0;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! (j < 512)) {
#line 145
      goto while_break;
    }
    {
#line 146
    tmp___0 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)fp);
    }
#line 146
    if ((unsigned long )((void *)0) == (unsigned long )tmp___0) {
#line 147
      goto while_break;
    }
    {
#line 148
    tmp___1 = strlen((char const   *)(line));
#line 148
    in_len = (int )tmp___1;
    }
#line 149
    if (in_len > 0) {
#line 150
      if (10 == (int )line[in_len - 1]) {
#line 151
        in_len --;
#line 152
        line[in_len] = (char )'\000';
      }
    }
#line 155
    if (0 == in_len) {
#line 156
      goto __Cont;
    }
    {
#line 157
    lcp = (char const   *)(line);
#line 158
    tmp___2 = strspn(lcp, " \t");
#line 158
    m = (int )tmp___2;
    }
#line 159
    if (m == in_len) {
#line 160
      goto __Cont;
    }
#line 161
    lcp += m;
#line 162
    in_len -= m;
#line 163
    if (35 == (int )*lcp) {
#line 164
      goto __Cont;
    }
    {
#line 166
    tmp___3 = strspn(lcp, "0123456789aAbBcCdDeEfFxXhH ,\t");
#line 166
    k = (int )tmp___3;
    }
#line 167
    if (k < in_len) {
#line 167
      if (35 != (int )*(lcp + k)) {
        {
#line 168
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fd2hex_arr: syntax error at line %d, pos %d\n",
                j + 1, (m + k) + 1);
        }
#line 170
        goto bad;
      }
    }
#line 172
    k = 0;
    {
#line 172
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 172
      if (! (k < 1024)) {
#line 172
        goto while_break___0;
      }
      {
#line 173
      h = smp_get_dhnum(lcp);
      }
#line 174
      if (h >= 0) {
#line 174
        if (h < 256) {
#line 175
          if (h > 255) {
            {
#line 176
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fd2hex_arr: hex number larger than 0xff in line %d, pos %d\n",
                    j + 1, (int )((lcp - (char const   *)(line)) + 1L));
            }
#line 179
            goto bad;
          }
#line 181
          if (off + k >= max_arr_len) {
            {
#line 182
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fd2hex_arr: array length exceeded\n");
            }
#line 184
            goto bad;
          }
          {
#line 186
          *(mp_arr + (off + k)) = (unsigned char )h;
#line 187
          tmp___5 = __ctype_b_loc();
          }
#line 187
          if (! ((int const   )*(*tmp___5 + (int )*lcp) & 4096)) {
            {
#line 188
            tmp___4 = strspn(lcp, " ,\t");
#line 188
            lcp += tmp___4;
            }
          }
          {
#line 190
          tmp___6 = strpbrk(lcp, " ,\t");
#line 190
          lcp = (char const   *)tmp___6;
          }
#line 191
          if ((unsigned long )((void *)0) == (unsigned long )lcp) {
#line 192
            goto while_break___0;
          }
          {
#line 193
          tmp___7 = strspn(lcp, " ,\t");
#line 193
          lcp += tmp___7;
          }
#line 194
          if (0 == (int )*lcp) {
#line 195
            goto while_break___0;
          }
        } else {
#line 174
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 197
        if (35 == (int )*lcp) {
#line 198
          k --;
#line 199
          goto while_break___0;
        }
        {
#line 201
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fd2hex_arr: error in line %d, at pos %d\n",
                j + 1, (int )((lcp - (char const   *)(line)) + 1L));
        }
#line 204
        goto bad;
      }
#line 172
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 207
    off += k + 1;
    __Cont: /* CIL Label */ 
#line 145
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 209
  *mp_arr_len = off;
#line 210
  fclose(fp);
  }
#line 211
  return (0);
  bad: 
  {
#line 213
  fclose(fp);
  }
#line 214
  return (1);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_zoned_broadcast.c"
static void dStrRaw___22(char const   *str , int len ) 
{ 
  int k ;

  {
#line 222
  k = 0;
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (! (k < len)) {
#line 222
      goto while_break;
    }
    {
#line 223
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 222
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___47  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___23[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___23[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___23[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___23  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 59 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_read_gpio.c"
static char *version_str___48  =    (char *)"1.09 20111222";
#line 63 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_read_gpio.c"
static struct option long_options___23[13]  = 
#line 63
  {      {"count", 1, (int *)0, 'c'}, 
        {"enhanced", 0, (int *)0, 'E'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"index", 1, (int *)0, 'i'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"phy", 1, (int *)0, 'p'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"type", 0, (int *)0, 't'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 80 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_read_gpio.c"
static void usage___23(void) 
{ 


  {
  {
#line 83
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_read_gpio   [--count=CO] [--enhanced] [--help] [--hex]\n                       [--index=IN] [--interface=PARAMS] [--raw]\n                       [--sa=SAS_ADDR] [type=TY] [--verbose] [--version]\n                       SMP_DEVICE[,N]\n  where:\n    --count=CO|-c CO     register count (dwords to read) (def: 1)\n    --enhanced|-E        use READ GPIO REGISTER ENHANCED function\n    --help|-h            print out usage message\n    --hex|-H             print response in hexadecimal\n    --index=IN|-i IN     register index (def: 0)\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --raw|-r             output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n    --type=TY|-t TY      register type (def: 0 (GPIO_CFG))\n    --verbose|-v         increase verbosity\n    --version|-V         print version string and exit\n\nPerforms a SMP READ GPIO REGISTER (default) or READ GPIO REGISTER ENHANCED\nfunction\n");
  }
#line 112
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_read_gpio.c"
static void dStrRaw___23(char const   *str , int len ) 
{ 
  int k ;

  {
#line 119
  k = 0;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! (k < len)) {
#line 119
      goto while_break;
    }
    {
#line 120
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 119
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___49  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___24[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___24[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___24[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___24  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 54 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_zone_phy_info.c"
static char *version_str___50  =    (char *)"1.03 20111222";
#line 56 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_zone_phy_info.c"
static struct option long_options___24[11]  = 
#line 56
  {      {"expected", 1, (int *)0, 'E'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"pconf", 1, (int *)0, 'p'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"save", 1, (int *)0, 'S'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 71 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_zone_phy_info.c"
static void usage___24(void) 
{ 


  {
  {
#line 74
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_conf_zone_phy_info [--expected=EX] [--help] [--hex]\n                              [--interface=PARAMS] --pconf=FN\n                              [--raw] [--sa=SAS_ADDR] [--save=SAV]\n                              [--verbose] [--version] SMP_DEVICE[,N]\n  where:\n    --expected=EX|-E EX    set expected expander change count to EX\n    --help|-h              print out usage message\n    --hex|-H               print response in hexadecimal\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --pconf=FN|-p FN       FN is a file containing zone phy\n                           configuration descriptors in hex; required\n    --raw|-r               output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n    --save=SAV|-S SAV      SAV: 0 -> shadow (def); 1 -> saved\n                           2 -> shadow (and saved if supported))\n                           3 -> shadow and saved\n    --verbose|-v           increase verbosity\n    --version|-V           print version string and exit\n\nPerforms a SMP CONFIGURE ZONE PHY INFORMATION function\n");
  }
#line 109
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_zone_phy_info.c"
static int f2hex_arr___1(char const   *fname , unsigned char *mp_arr , int *mp_arr_len ,
                         int max_arr_len ) 
{ 
  int fn_len ;
  int in_len ;
  int k ;
  int j ;
  int m ;
  int no_space ;
  int checked_hexlen ;
  unsigned int h ;
  char const   *lcp ;
  FILE *fp ;
  char line[512] ;
  int off ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;

  {
#line 124
  no_space = 0;
#line 125
  checked_hexlen = 0;
#line 130
  off = 0;
#line 132
  if ((unsigned long )((void *)0) == (unsigned long )fname) {
#line 133
    return (1);
  } else
#line 132
  if ((unsigned long )((void *)0) == (unsigned long )mp_arr) {
#line 133
    return (1);
  } else
#line 132
  if ((unsigned long )((void *)0) == (unsigned long )mp_arr_len) {
#line 133
    return (1);
  }
  {
#line 134
  tmp = strlen(fname);
#line 134
  fn_len = (int )tmp;
  }
#line 135
  if (0 == fn_len) {
#line 136
    return (1);
  }
#line 137
  if (1 == fn_len) {
#line 137
    if (45 == (int )*(fname + 0)) {
#line 138
      fp = stdin;
    } else {
#line 137
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 140
    fp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
    }
#line 141
    if ((unsigned long )((void *)0) == (unsigned long )fp) {
      {
#line 142
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to open %s for reading\n",
              fname);
      }
#line 143
      return (1);
    }
  }
#line 147
  j = 0;
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! (j < 512)) {
#line 147
      goto while_break;
    }
    {
#line 148
    tmp___0 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)fp);
    }
#line 148
    if ((unsigned long )((void *)0) == (unsigned long )tmp___0) {
#line 149
      goto while_break;
    }
    {
#line 150
    tmp___1 = strlen((char const   *)(line));
#line 150
    in_len = (int )tmp___1;
    }
#line 151
    if (in_len > 0) {
#line 152
      if (10 == (int )line[in_len - 1]) {
#line 153
        in_len --;
#line 154
        line[in_len] = (char )'\000';
      }
    }
#line 157
    if (0 == in_len) {
#line 158
      goto __Cont;
    }
    {
#line 159
    lcp = (char const   *)(line);
#line 160
    tmp___2 = strspn(lcp, " \t");
#line 160
    m = (int )tmp___2;
    }
#line 161
    if (m == in_len) {
#line 162
      goto __Cont;
    }
#line 163
    lcp += m;
#line 164
    in_len -= m;
#line 165
    if (35 == (int )*lcp) {
#line 166
      goto __Cont;
    }
#line 167
    if (! checked_hexlen) {
      {
#line 168
      checked_hexlen ++;
#line 169
      tmp___3 = strspn(lcp, "0123456789aAbBcCdDeEfF");
#line 169
      k = (int )tmp___3;
      }
#line 170
      if (k > 2) {
#line 171
        no_space = 1;
      }
    }
    {
#line 174
    tmp___4 = strspn(lcp, "0123456789aAbBcCdDeEfF ,\t");
#line 174
    k = (int )tmp___4;
    }
#line 175
    if (k < in_len) {
#line 175
      if (35 != (int )*(lcp + k)) {
        {
#line 176
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: syntax error at line %d, pos %d\n",
                j + 1, (m + k) + 1);
        }
#line 178
        goto bad;
      }
    }
#line 180
    if (no_space) {
#line 181
      k = 0;
      {
#line 181
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 181
        tmp___6 = __ctype_b_loc();
        }
#line 181
        if ((int const   )*(*tmp___6 + (int )*lcp) & 4096) {
          {
#line 181
          tmp___7 = __ctype_b_loc();
          }
#line 181
          if (! ((int const   )*(*tmp___7 + (int )*(lcp + 1)) & 4096)) {
#line 181
            goto while_break___0;
          }
        } else {
#line 181
          goto while_break___0;
        }
        {
#line 183
        tmp___5 = sscanf((char const   */* __restrict  */)lcp, (char const   */* __restrict  */)"%2x",
                         & h);
        }
#line 183
        if (1 != tmp___5) {
          {
#line 184
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: bad hex number in line %d, pos %d\n",
                  j + 1, (int )((lcp - (char const   *)(line)) + 1L));
          }
#line 186
          goto bad;
        }
#line 188
        if (off + k >= max_arr_len) {
          {
#line 189
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: array length exceeded\n");
          }
#line 190
          goto bad;
        }
#line 192
        *(mp_arr + (off + k)) = (unsigned char )h;
#line 181
        k ++;
#line 181
        lcp += 2;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 194
      off += k;
    } else {
#line 196
      k = 0;
      {
#line 196
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 196
        if (! (k < 1024)) {
#line 196
          goto while_break___1;
        }
        {
#line 197
        tmp___10 = sscanf((char const   */* __restrict  */)lcp, (char const   */* __restrict  */)"%x",
                          & h);
        }
#line 197
        if (1 == tmp___10) {
#line 198
          if (h > 255U) {
            {
#line 199
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: hex number larger than 0xff in line %d, pos %d\n",
                    j + 1, (int )((lcp - (char const   *)(line)) + 1L));
            }
#line 202
            goto bad;
          }
#line 204
          if (off + k >= max_arr_len) {
            {
#line 205
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: array length exceeded\n");
            }
#line 207
            goto bad;
          }
          {
#line 209
          *(mp_arr + (off + k)) = (unsigned char )h;
#line 210
          tmp___8 = strpbrk(lcp, " ,\t");
#line 210
          lcp = (char const   *)tmp___8;
          }
#line 211
          if ((unsigned long )((void *)0) == (unsigned long )lcp) {
#line 212
            goto while_break___1;
          }
          {
#line 213
          tmp___9 = strspn(lcp, " ,\t");
#line 213
          lcp += tmp___9;
          }
#line 214
          if (0 == (int )*lcp) {
#line 215
            goto while_break___1;
          }
        } else {
#line 217
          if (35 == (int )*lcp) {
#line 218
            k --;
#line 219
            goto while_break___1;
          }
          {
#line 221
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: error in line %d, at pos %d\n",
                  j + 1, (int )((lcp - (char const   *)(line)) + 1L));
          }
#line 224
          goto bad;
        }
#line 196
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 227
      off += k + 1;
    }
    __Cont: /* CIL Label */ 
#line 147
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 230
  *mp_arr_len = off;
#line 231
  fclose(fp);
  }
#line 232
  return (0);
  bad: 
  {
#line 234
  fclose(fp);
  }
#line 235
  return (1);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_zone_phy_info.c"
static void dStrRaw___24(char const   *str , int len ) 
{ 
  int k ;

  {
#line 243
  k = 0;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! (k < len)) {
#line 243
      goto while_break;
    }
    {
#line 244
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 243
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___51  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___25[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___25[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___25[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___25  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___52  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___26[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___26[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 53 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_ena_dis_zoning.c"
static char *version_str___53  =    (char *)"1.05 20111222";
#line 55 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_ena_dis_zoning.c"
static struct option long_options___25[12]  = 
#line 55
  {      {"disable", 0, (int *)0, 'd'}, 
        {"ena-dis", 1, (int *)0, 'e'}, 
        {"expected", 1, (int *)0, 'E'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"save", 1, (int *)0, 'S'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 71 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_ena_dis_zoning.c"
static void usage___25(void) 
{ 


  {
  {
#line 74
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_ena_dis_zoning [--disable] [--ena-dis=ED] [--expected=EX] [--help]\n                          [--hex] [--interface=PARAMS] [--raw]\n                          [--sa=SAS_ADDR] [--save=SAV] [--verbose]\n                          [--version] SMP_DEVICE[,N]\n  where:\n    --disable|-d           disable zoning (equivalent to \'--ena-dis=2\')\n    --ena-dis=ED|-e ED     ED: 0 -> no change; 1 -> enable zoning (def)\n                           2 -> disable zoning\n    --expected=EX|-E EX    set expected expander change count to EX\n    --help|-h              print out usage message\n    --hex|-H               print response in hexadecimal\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --raw|-r               output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n    --save=SAV|-S SAV      SAV: 0 -> shadow (def); 1 -> saved\n                           2 -> shadow (and saved if supported))\n                           3 -> shadow and saved\n    --verbose|-v           increase verbosity\n    --version|-V           print version string and exit\n\nPerforms a SMP ENABLE DISABLE ZONING function. Default action (when no\noptions given) is to enable zoning.\n");
  }
#line 110
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_ena_dis_zoning.c"
static void dStrRaw___25(char const   *str , int len ) 
{ 
  int k ;

  {
#line 117
  k = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (k < len)) {
#line 117
      goto while_break;
    }
    {
#line 118
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 117
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___26[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___26  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___54  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___27[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___27[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___27[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___27  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
#line 54 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_zone_perm_tbl.c"
static char *version_str___55  =    (char *)"1.04 20111222";
#line 59 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_zone_perm_tbl.c"
static unsigned char full_perm_tbl[8192]  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_zone_perm_tbl.c"
static int sszg  =    0;
#line 62 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_zone_perm_tbl.c"
static int sszg_given  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_zone_perm_tbl.c"
static struct option long_options___26[14]  = 
#line 64
  {      {"deduce", 0, (int *)0, 'd'}, 
        {"expected", 1, (int *)0, 'E'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"numzg", 1, (int *)0, 'n'}, 
        {"permf", 1, (int *)0, 'P'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"save", 1, (int *)0, 'S'}, 
        {"start", 1, (int *)0, 'f'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 82 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_zone_perm_tbl.c"
static void usage___26(void) 
{ 


  {
  {
#line 85
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_conf_zone_perm_tbl [--deduce] [--expected=EX] [--help] [--hex]\n                              [--interface=PARAMS] [--numzg=NG] --permf=FN\n                              [--raw] [--sa=SAS_ADDR] [--save=SAV]\n                              [--start=SS] [--verbose] [--version]\n                              SMP_DEVICE[,N]\n  where:\n    --deduce|-d            deduce number of zone groups from number\n                           of bytes on active FN lines\n    --expected=EX|-E EX    set expected expander change count to EX\n    --help|-h              print out usage message\n    --hex|-H               print response in hexadecimal\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --numzg=NG|-n NG       number of zone groups. NG should be 0 (def)\n                           or 1. 0 -> 128 zone groups, 1 -> 256\n    --permf=FN|-P FN       FN is a file containing zone permission\n                           configuration descriptors in hex; required\n    --raw|-r               output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n    --save=SAV|-S SAV      SAV: 0 -> shadow (def); 1 -> saved\n                           2 -> shadow (and saved if supported))\n                           3 -> shadow and saved\n    --start=SS|-f SS       starting (first) source zone group (def: 0)\n    --verbose|-v           increase verbosity\n    --version|-V           print version string and exit\n\nPerforms one of more SMP CONFIGURE ZONE PERMISSION TABLE functions\n");
  }
#line 131
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_zone_perm_tbl.c"
static int f2hex_arr___2(char const   *fname , unsigned char *mp_arr , int *mp_arr_len ,
                         int max_arr_len , int *numzg256p , int verbose ) 
{ 
  int fn_len ;
  int in_len ;
  int k ;
  int j ;
  int m ;
  int no_space ;
  int checked_hexlen ;
  int numzg256 ;
  unsigned int h ;
  char const   *lcp ;
  FILE *fp ;
  char line[512] ;
  int off ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;

  {
#line 149
  no_space = 0;
#line 150
  checked_hexlen = 0;
#line 151
  numzg256 = 0;
#line 156
  off = 0;
#line 158
  if ((unsigned long )((void *)0) == (unsigned long )fname) {
#line 159
    return (1);
  } else
#line 158
  if ((unsigned long )((void *)0) == (unsigned long )mp_arr) {
#line 159
    return (1);
  } else
#line 158
  if ((unsigned long )((void *)0) == (unsigned long )mp_arr_len) {
#line 159
    return (1);
  }
  {
#line 160
  tmp = strlen(fname);
#line 160
  fn_len = (int )tmp;
  }
#line 161
  if (0 == fn_len) {
#line 162
    return (1);
  }
#line 163
  if (1 == fn_len) {
#line 163
    if (45 == (int )*(fname + 0)) {
#line 164
      fp = stdin;
    } else {
#line 163
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 166
    fp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
    }
#line 167
    if ((unsigned long )((void *)0) == (unsigned long )fp) {
      {
#line 168
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to open %s for reading\n",
              fname);
      }
#line 169
      return (1);
    }
  }
#line 173
  j = 0;
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! (j < 512)) {
#line 173
      goto while_break;
    }
    {
#line 174
    tmp___0 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)fp);
    }
#line 174
    if ((unsigned long )((void *)0) == (unsigned long )tmp___0) {
#line 175
      goto while_break;
    }
    {
#line 176
    tmp___1 = strlen((char const   *)(line));
#line 176
    in_len = (int )tmp___1;
    }
#line 177
    if (in_len > 0) {
#line 178
      if (10 == (int )line[in_len - 1]) {
#line 179
        in_len --;
#line 180
        line[in_len] = (char )'\000';
      }
    }
#line 183
    if (0 == in_len) {
#line 184
      goto __Cont;
    }
    {
#line 185
    lcp = (char const   *)(line);
#line 186
    tmp___2 = strspn(lcp, " \t");
#line 186
    m = (int )tmp___2;
    }
#line 187
    if (m == in_len) {
#line 188
      goto __Cont;
    }
#line 189
    lcp += m;
#line 190
    in_len -= m;
#line 191
    if (35 == (int )*lcp) {
#line 192
      goto __Cont;
    }
#line 193
    if (45 == (int )*lcp) {
      {
#line 194
      tmp___4 = strncmp("--start=", lcp, (size_t )8);
      }
#line 194
      if (0 == tmp___4) {
        {
#line 195
        tmp___3 = sscanf((char const   */* __restrict  */)lcp, (char const   */* __restrict  */)"--start=%d",
                         & k);
        }
#line 195
        if (1 == tmp___3) {
#line 196
          if (sszg_given) {
#line 196
            if (k != sszg) {
              {
#line 197
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"permission file \'--start=%d\' contradicts command line \'--start=%d\'\n",
                      k, sszg);
              }
#line 200
              goto bad;
            }
          }
#line 202
          if (verbose) {
            {
#line 203
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"permission file contains --start=%d, using it\n",
                    k);
            }
          }
#line 205
          sszg = k;
        } else
#line 206
        if (verbose) {
          {
#line 207
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"found line with \'-\' but could not decode --start=<num>\n");
          }
        }
      }
#line 210
      goto __Cont;
    }
#line 212
    if (! checked_hexlen) {
      {
#line 213
      checked_hexlen ++;
#line 214
      tmp___5 = strspn(lcp, "0123456789aAbBcCdDeEfF");
#line 214
      k = (int )tmp___5;
      }
#line 215
      if (k > 2) {
#line 216
        no_space = 1;
      }
    }
    {
#line 219
    tmp___6 = strspn(lcp, "0123456789aAbBcCdDeEfF ,\t");
#line 219
    k = (int )tmp___6;
    }
#line 220
    if (k < in_len) {
#line 220
      if (35 != (int )*(lcp + k)) {
#line 220
        if (45 != (int )*(lcp + k)) {
          {
#line 221
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: syntax error at line %d, pos %d\n",
                  j + 1, (m + k) + 1);
          }
#line 223
          goto bad;
        }
      }
    }
#line 225
    if (no_space) {
#line 226
      k = 0;
      {
#line 226
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 226
        tmp___8 = __ctype_b_loc();
        }
#line 226
        if ((int const   )*(*tmp___8 + (int )*lcp) & 4096) {
          {
#line 226
          tmp___9 = __ctype_b_loc();
          }
#line 226
          if (! ((int const   )*(*tmp___9 + (int )*(lcp + 1)) & 4096)) {
#line 226
            goto while_break___0;
          }
        } else {
#line 226
          goto while_break___0;
        }
        {
#line 228
        tmp___7 = sscanf((char const   */* __restrict  */)lcp, (char const   */* __restrict  */)"%2x",
                         & h);
        }
#line 228
        if (1 != tmp___7) {
          {
#line 229
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: bad hex number in line %d, pos %d\n",
                  j + 1, (int )((lcp - (char const   *)(line)) + 1L));
          }
#line 231
          goto bad;
        }
#line 233
        if (off + k >= max_arr_len) {
          {
#line 234
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: array length exceeded\n");
          }
#line 235
          goto bad;
        }
#line 237
        *(mp_arr + (off + k)) = (unsigned char )h;
#line 226
        k ++;
#line 226
        lcp += 2;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 239
      if (k > 16) {
#line 240
        numzg256 ++;
      }
#line 241
      off += k;
    } else {
#line 243
      k = 0;
      {
#line 243
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 243
        if (! (k < 1024)) {
#line 243
          goto while_break___1;
        }
        {
#line 244
        tmp___12 = sscanf((char const   */* __restrict  */)lcp, (char const   */* __restrict  */)"%x",
                          & h);
        }
#line 244
        if (1 == tmp___12) {
#line 245
          if (h > 255U) {
            {
#line 246
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: hex number larger than 0xff in line %d, pos %d\n",
                    j + 1, (int )((lcp - (char const   *)(line)) + 1L));
            }
#line 249
            goto bad;
          }
#line 251
          if (off + k >= max_arr_len) {
            {
#line 252
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: array length exceeded\n");
            }
#line 254
            goto bad;
          }
          {
#line 256
          *(mp_arr + (off + k)) = (unsigned char )h;
#line 257
          tmp___10 = strpbrk(lcp, " ,\t");
#line 257
          lcp = (char const   *)tmp___10;
          }
#line 258
          if ((unsigned long )((void *)0) == (unsigned long )lcp) {
#line 259
            goto while_break___1;
          }
          {
#line 260
          tmp___11 = strspn(lcp, " ,\t");
#line 260
          lcp += tmp___11;
          }
#line 261
          if (0 == (int )*lcp) {
#line 262
            goto while_break___1;
          }
        } else {
#line 264
          if (35 == (int )*lcp) {
#line 265
            k --;
#line 266
            goto while_break___1;
          } else
#line 264
          if (45 == (int )*lcp) {
#line 265
            k --;
#line 266
            goto while_break___1;
          }
          {
#line 268
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f2hex_arr: error in line %d, at pos %d\n",
                  j + 1, (int )((lcp - (char const   *)(line)) + 1L));
          }
#line 271
          goto bad;
        }
#line 243
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 274
      if (k > 15) {
#line 275
        numzg256 ++;
      }
#line 276
      off += k + 1;
    }
    __Cont: /* CIL Label */ 
#line 173
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 279
  *mp_arr_len = off;
#line 280
  fclose(fp);
  }
#line 281
  if (numzg256p) {
#line 282
    *numzg256p = ! (! numzg256);
  }
#line 283
  return (0);
  bad: 
  {
#line 285
  fclose(fp);
  }
#line 286
  return (1);
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_conf_zone_perm_tbl.c"
static void dStrRaw___26(char const   *str , int len ) 
{ 
  int k ;

  {
#line 294
  k = 0;
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    if (! (k < len)) {
#line 294
      goto while_break;
    }
    {
#line 295
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 294
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_phy_event_list.c"
static char *version_str___56  =    (char *)"1.07 20111222";
#line 64 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_phy_event_list.c"
static struct option long_options___27[14]  = 
#line 64
  {      {"desc", 0, (int *)0, 'd'}, 
        {"enumerate", 0, (int *)0, 'e'}, 
        {"force", 0, (int *)0, 'f'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"index", 1, (int *)0, 'i'}, 
        {"interface", 1, (int *)0, 'I'}, 
        {"long", 0, (int *)0, 'l'}, 
        {"nonz", 0, (int *)0, 'n'}, 
        {"raw", 0, (int *)0, 'r'}, 
        {"sa", 1, (int *)0, 's'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 81 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_phy_event_list.c"
static struct pes_name_t pes_name_arr___1[35]  = 
#line 81
  {      {0, "No event"}, 
        {1, "Invalid word count"}, 
        {2, "Running disparity error count"}, 
        {3, "Loss of dword synchronization count"}, 
        {4, "Phy reset problem count"}, 
        {5, "Elasticity buffer overflow count"}, 
        {6, "Received ERROR count"}, 
        {32, "Received address frame error count"}, 
        {33, "Transmitted abandon-class OPEN_REJECT count"}, 
        {34, "Received abandon-class OPEN_REJECT count"}, 
        {35, "Transmitted retry-class OPEN_REJECT count"}, 
        {36, "Received retry-class OPEN_REJECT count"}, 
        {37, "Received AIP (WATING ON PARTIAL) count"}, 
        {38, "Received AIP (WAITING ON CONNECTION) count"}, 
        {39, "Transmitted BREAK count"}, 
        {40, "Received BREAK count"}, 
        {41, "Break timeout count"}, 
        {42, "Connection count"}, 
        {43, "Peak transmitted pathway blocked count"}, 
        {44, "Peak transmitted arbitration wait time"}, 
        {45, "Peak arbitration time"}, 
        {46, "Peak connection time"}, 
        {64, "Transmitted SSP frame count"}, 
        {65, "Received SSP frame count"}, 
        {66, "Transmitted SSP frame error count"}, 
        {67, "Received SSP frame error count"}, 
        {68, "Transmitted CREDIT_BLOCKED count"}, 
        {69, "Received CREDIT_BLOCKED count"}, 
        {80, "Transmitted SATA frame count"}, 
        {81, "Received SATA frame count"}, 
        {82, "SATA flow control buffer overflow count"}, 
        {96, "Transmitted SMP frame count"}, 
        {97, "Received SMP frame count"}, 
        {99, "Received SMP frame error count"}, 
        {-1, (char const   *)((void *)0)}};
#line 128 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_phy_event_list.c"
static void usage___27(void) 
{ 


  {
  {
#line 131
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: smp_rep_phy_event_list [--desc] [--enumerate] [--force] [--help]\n                              [--hex] [--index=IN] [--interface=PARAMS]\n                              [--long] [--raw] [--sa=SAS_ADDR] [--verbose]\n                              [--version] SMP_DEVICE[,N]\n  where:\n    --desc|-d            show descriptor number in output\n    --enumerate|-e       enumerate phy event source names, ignore\n                         SMP_DEVICE if given\n    --force|-f           force to continue past last descriptor index\n    --help|-h            print out usage message\n    --hex|-H             print response in hexadecimal\n    --index=IN|-i IN     starting phy event list descriptor index (def: 1)\n    --interface=PARAMS|-I PARAMS    specify or override interface\n    --long|-l            show phy event source hex value in output\n    --nonz|-n            only show phy events with non-zero counts\n    --raw|-r             output response in binary\n    --sa=SAS_ADDR|-s SAS_ADDR    SAS address of SMP target (use leading\n                                 \'0x\' or trailing \'h\'). Depending on\n                                 the interface, may not be needed\n    --verbose|-v         increase verbosity\n    --version|-V         print version string and exit\n\nPerforms a SMP REPORT PHY EVENT LIST function\n");
  }
#line 167
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_phy_event_list.c"
static void dStrRaw___27(char const   *str , int len ) 
{ 
  int k ;

  {
#line 174
  k = 0;
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! (k < len)) {
#line 174
      goto while_break;
    }
    {
#line 175
    printf((char const   */* __restrict  */)"%c", (int const   )*(str + k));
#line 174
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_phy_event_list.c"
static char const   *get_pes_name___0(int pes , char *b , int blen ) 
{ 
  int len ;
  char const   *res ;
  struct pes_name_t  const  *pnp ;
  size_t tmp ;

  {
#line 182
  res = (char const   *)((void *)0);
#line 185
  if ((unsigned long )((void *)0) == (unsigned long )b) {
#line 186
    return (res);
  } else
#line 185
  if (blen < 1) {
#line 186
    return (res);
  }
#line 187
  pnp = (struct pes_name_t  const  *)(pes_name_arr___1);
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! pnp->pes_name) {
#line 187
      goto while_break;
    }
#line 188
    if (pes == (int )pnp->pes) {
      {
#line 189
      tmp = strlen((char const   *)pnp->pes_name);
#line 189
      len = (int )tmp;
      }
#line 190
      if (len > blen - 1) {
#line 191
        len = blen - 1;
      }
      {
#line 192
      memcpy((void */* __restrict  */)b, (void const   */* __restrict  */)pnp->pes_name,
             (size_t )len);
#line 193
      *(b + len) = (char )'\000';
      }
#line 194
      return ((char const   *)b);
    }
#line 187
    pnp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  return (res);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/src/smp_rep_phy_event_list.c"
static void show_phy_event_info___0(int phy_id , int prev_pid , int pes , unsigned int val ,
                                    unsigned int thresh_val , int do_long ) 
{ 
  unsigned int u ;
  char b[80] ;
  char const   *cp ;
  size_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 209
  if (do_long) {
    {
#line 210
    printf((char const   */* __restrict  */)"    phy_id=%d: [0x%x] ", phy_id, (unsigned int )pes);
    }
  } else {
    {
#line 212
    snprintf((char */* __restrict  */)(b), sizeof(b) - 1UL, (char const   */* __restrict  */)"    %d: ",
             phy_id);
#line 213
    b[sizeof(b) - 1UL] = (char )'\000';
    }
#line 214
    if (prev_pid == phy_id) {
      {
#line 215
      tmp = strlen((char const   *)(b));
#line 215
      memset((void *)(b), ' ', tmp);
      }
    }
    {
#line 216
    printf((char const   */* __restrict  */)"%s", b);
    }
  }
  {
#line 220
  if (pes == 0) {
#line 220
    goto case_0;
  }
#line 251
  if (pes == 99) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 97) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 96) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 82) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 81) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 80) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 69) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 68) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 67) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 66) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 65) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 64) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 42) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 41) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 40) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 39) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 38) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 37) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 36) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 35) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 34) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 33) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 32) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 6) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 5) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 4) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 3) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 2) {
#line 251
    goto case_99;
  }
#line 251
  if (pes == 1) {
#line 251
    goto case_99;
  }
#line 259
  if (pes == 43) {
#line 259
    goto case_43;
  }
#line 264
  if (pes == 44) {
#line 264
    goto case_44;
  }
#line 279
  if (pes == 45) {
#line 279
    goto case_45;
  }
#line 283
  if (pes == 46) {
#line 283
    goto case_46;
  }
#line 287
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 221
  printf((char const   */* __restrict  */)"No event\n");
  }
#line 222
  goto switch_break;
  case_99: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_32: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 252
  cp = get_pes_name___0(pes, b, (int )sizeof(b));
  }
#line 252
  if (cp) {
    {
#line 253
    printf((char const   */* __restrict  */)"%s: %u\n", cp, val);
    }
  } else {
    {
#line 255
    printf((char const   */* __restrict  */)"Unknown Phy Event Source [0x%x]: %u\n",
           pes, val);
    }
  }
#line 256
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 260
  tmp___0 = get_pes_name___0(pes, b, (int )sizeof(b));
#line 260
  printf((char const   */* __restrict  */)"%s: %u\n", tmp___0, val & 255U);
#line 261
  printf((char const   */* __restrict  */)"      Peak value detector threshold: %u\n",
         thresh_val & 255U);
  }
#line 263
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 265
  cp = get_pes_name___0(pes, b, (int )sizeof(b));
#line 266
  u = val & 65535U;
  }
#line 267
  if (u < 32768U) {
    {
#line 268
    printf((char const   */* __restrict  */)"%s (us): %u\n", cp, u);
    }
  } else {
    {
#line 270
    printf((char const   */* __restrict  */)"%s (ms): %u\n", cp, 33U + (u - 32768U));
    }
  }
#line 271
  u = thresh_val & 65535U;
#line 272
  if (u < 32768U) {
    {
#line 273
    printf((char const   */* __restrict  */)"      Peak value detector threshold (us): %u\n",
           u);
    }
  } else {
    {
#line 276
    printf((char const   */* __restrict  */)"      Peak value detector threshold (ms): %u\n",
           33U + (u - 32768U));
    }
  }
#line 278
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 280
  tmp___1 = get_pes_name___0(pes, b, (int )sizeof(b));
#line 280
  printf((char const   */* __restrict  */)"%s (us): %u\n", tmp___1, val);
#line 281
  printf((char const   */* __restrict  */)"      Peak value detector threshold: %u\n",
         thresh_val);
  }
#line 282
  goto switch_break;
  case_46: /* CIL Label */ 
  {
#line 284
  tmp___2 = get_pes_name___0(pes, b, (int )sizeof(b));
#line 284
  printf((char const   */* __restrict  */)"%s (us): %u\n", tmp___2, val);
#line 285
  printf((char const   */* __restrict  */)"      Peak value detector threshold: %u\n",
         thresh_val);
  }
#line 286
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 288
  printf((char const   */* __restrict  */)"Unknown phy event source: %d, val=%u, thresh_val=%u\n",
         pes, val, thresh_val);
  }
#line 290
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 292
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char *version_str___57  =    (char *)"1.19 20110805";
#line 123 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static struct smp_val_name smp_func_results___28[29]  = 
#line 123
  {      {0, (char *)"SMP function accepted"}, 
        {1, (char *)"Unknown SMP function"}, 
        {2, (char *)"SMP function failed"}, 
        {3, (char *)"Invalid request frame length"}, 
        {4, (char *)"Invalid expander change count"}, 
        {5, (char *)"Busy"}, 
        {6, (char *)"Incomplete descriptor list"}, 
        {16, (char *)"Phy does not exist"}, 
        {17, (char *)"Index does not exist"}, 
        {18, (char *)"Phy does not support SATA"}, 
        {19, (char *)"Unknown phy operation"}, 
        {20, (char *)"Unknown phy test function"}, 
        {21, (char *)"Phy test function in progress"}, 
        {22, (char *)"Phy vacant"}, 
        {23, (char *)"Unknown phy event source"}, 
        {24, (char *)"Unknown descriptor type"}, 
        {25, (char *)"Unknown phy filter"}, 
        {26, (char *)"Affiliation violation"}, 
        {32, (char *)"SMP zone violation"}, 
        {33, (char *)"No management access rights"}, 
        {34, (char *)"Unknown enable disable zoning value"}, 
        {35, (char *)"Zone lock violation"}, 
        {36, (char *)"Not activated"}, 
        {37, (char *)"Zone group out of range"}, 
        {38, (char *)"No physical presence"}, 
        {39, (char *)"Saving not supported"}, 
        {40, (char *)"Source zone group does not exist"}, 
        {41, (char *)"Disable password not supported"}, 
        {0, (char *)((void *)0)}};
#line 184 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_lib.c"
static char safe_errbuf___28[64]  = 
#line 184
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 42 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static char const   null_sas_addr___28[8]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/smp-utils-0.97/lib/smp_mptctl_io.c"
static int mptcommand___28  =    (int )((unsigned long )(((3U << 30) | (unsigned int )(109 << 8)) | 20U) | (sizeof(struct mpt_ioctl_command ) << 16));
