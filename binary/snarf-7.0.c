/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 90 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 11 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/url.h"
struct _UrlResource;
#line 11 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/url.h"
typedef struct _UrlResource UrlResource;
#line 12
struct _Url;
#line 12 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/url.h"
typedef struct _Url Url;
#line 14 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/url.h"
struct _Url {
   char *full_url ;
   int service_type ;
   char *username ;
   char *password ;
   char *host ;
   int port ;
   char *path ;
   char *file ;
};
#line 25 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/url.h"
struct _UrlResource {
   Url *url ;
   char *outfile ;
   char *proxy ;
   char *proxy_username ;
   char *proxy_password ;
   unsigned char options ;
   off_t outfile_size ;
   off_t outfile_offset ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/util.h"
enum report_levels {
    DEBUG = 0,
    WARN = 1,
    ERR = 2
} ;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 11 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/util.h"
struct _Progress;
#line 11 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/util.h"
typedef struct _Progress Progress;
#line 13 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/util.h"
struct _Progress {
   unsigned char tty ;
   long length ;
   long current ;
   long offset ;
   int max_hashes ;
   int cur_hashes ;
   int overflow ;
   unsigned char frame ;
   double start_time ;
   UrlResource *rsrc ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/llist.h"
struct _List;
#line 6 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/llist.h"
typedef struct _List List;
#line 8 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/llist.h"
struct _List {
   void *data ;
   List *next ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/http.c"
struct _HttpHeader;
#line 27 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/http.c"
typedef struct _HttpHeader HttpHeader;
#line 28
struct _HttpHeaderEntry;
#line 28 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/http.c"
typedef struct _HttpHeaderEntry HttpHeaderEntry;
#line 30 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/http.c"
struct _HttpHeader {
   List *header_list ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/http.c"
struct _HttpHeaderEntry {
   char *key ;
   char *value ;
};
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/gopher.h"
int gopher_transfer(UrlResource *rsrc ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/util.h"
char *get_proxy(char const   *firstchoice ) ;
#line 38
int dump_data(UrlResource *rsrc , int sock , FILE *out ) ;
#line 39
char *strconcat(char const   *string1  , ...) ;
#line 41
void report(enum report_levels lev , char *format  , ...) ;
#line 42
int tcp_connect(char *remote_host , int port ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/http.h"
int http_transfer(UrlResource *rsrc ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/gopher.c"
int gopher_transfer(UrlResource *rsrc ) 
{ 
  Url *u ;
  int sock ;
  FILE *out ;
  char *request ;
  int tmp ;
  size_t tmp___0 ;
  FILE *tmp___1 ;
  FILE *tmp___2 ;
  FILE *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;

  {
  {
#line 20
  u = (Url *)((void *)0);
#line 21
  sock = 0;
#line 22
  out = (FILE *)((void *)0);
#line 23
  request = (char *)((void *)0);
#line 25
  u = rsrc->url;
#line 30
  rsrc->proxy = get_proxy("GOPHER_PROXY");
  }
#line 32
  if (rsrc->proxy) {
    {
#line 33
    tmp = http_transfer(rsrc);
    }
#line 33
    return (tmp);
  }
#line 37
  if (! u->path) {
    {
#line 38
    u->path = strdup("");
    }
  } else {
    {
#line 40
    tmp___0 = strlen((char const   *)u->path);
    }
#line 40
    if (tmp___0 > 1UL) {
      {
#line 41
      u->path = strdup((char const   *)(u->path + 2));
      }
    }
  }
#line 45
  if (! u->file) {
    {
#line 46
    u->file = strdup("");
    }
  }
#line 48
  if (! u->port) {
#line 49
    u->port = 70;
  }
#line 51
  if (! rsrc->outfile) {
    {
#line 52
    rsrc->outfile = strdup("gopherindex.txt");
    }
  }
  {
#line 54
  sock = tcp_connect(u->host, u->port);
  }
#line 56
  if (! sock) {
#line 57
    return (0);
  }
  {
#line 59
  request = strconcat((char const   *)u->path, u->file, "\r\n", (void *)0);
  }
#line 61
  if (! request) {
#line 62
    return (0);
  }
#line 64
  if ((int )*(rsrc->outfile + 0) == 45) {
#line 64
    out = stdout;
  } else {
#line 64
    if ((int )rsrc->options & 1) {
#line 64
      if (! ((int )rsrc->options & (1 << 4))) {
        {
#line 64
        tmp___1 = fopen((char const   */* __restrict  */)rsrc->outfile, (char const   */* __restrict  */)"a");
#line 64
        tmp___3 = tmp___1;
        }
      } else {
        {
#line 64
        tmp___2 = fopen((char const   */* __restrict  */)rsrc->outfile, (char const   */* __restrict  */)"w");
#line 64
        tmp___3 = tmp___2;
        }
      }
    } else {
      {
#line 64
      tmp___2 = fopen((char const   */* __restrict  */)rsrc->outfile, (char const   */* __restrict  */)"w");
#line 64
      tmp___3 = tmp___2;
      }
    }
#line 64
    out = tmp___3;
  }
#line 66
  if (! out) {
    {
#line 67
    tmp___4 = __errno_location();
#line 67
    tmp___5 = strerror(*tmp___4);
#line 67
    report((enum report_levels )2, (char *)"opening %s: %s", rsrc->outfile, tmp___5);
#line 68
    close(sock);
    }
#line 69
    return (0);
  }
  {
#line 72
  tmp___6 = strlen((char const   *)request);
#line 72
  write(sock, (void const   *)request, tmp___6);
#line 75
  tmp___7 = dump_data(rsrc, sock, out);
  }
#line 75
  return (tmp___7);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 332
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/util.h"
Progress *progress_new(void) ;
#line 31
int progress_init(Progress *p , UrlResource *rsrc , long len ) ;
#line 32
void progress_update(Progress *p , long increment ) ;
#line 33
void progress_destroy(Progress *p ) ;
#line 34
double double_time(void) ;
#line 36
char *string_lowercase(char *string ) ;
#line 40
char *base64(char *bin , int len ) ;
#line 43
off_t get_file_size(char const   *file ) ;
#line 44
void repchar(FILE *fp , char ch , int count ) ;
#line 45
int transfer(UrlResource *rsrc ) ;
#line 53
int debug_enabled ;
#line 10 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/ftp.h"
int ftp_transfer(UrlResource *rsrc ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 92 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) herror)(char const   *__str ) ;
#line 144
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/util.c"
char output_buf[8192]  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/util.c"
void repchar(FILE *fp , char ch , int count ) 
{ 
  int tmp ;

  {
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    tmp = count;
#line 68
    count --;
#line 68
    if (! tmp) {
#line 68
      goto while_break;
    }
    {
#line 69
    fputc((int )ch, fp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/util.c"
int guess_winsize(void) 
{ 


  {
#line 88
  return (79);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/util.c"
double double_time(void) 
{ 
  struct timeval tv ;

  {
  {
#line 98
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
  }
#line 99
  return ((double )tv.tv_sec + (double )tv.tv_usec / 1000000.00);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/util.c"
char *string_lowercase(char *string ) 
{ 
  char *start ;
  int tmp ;

  {
#line 109
  start = string;
#line 111
  if ((unsigned long )string == (unsigned long )((void *)0)) {
#line 112
    return ((char *)((void *)0));
  }
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! *string) {
#line 114
      goto while_break;
    }
    {
#line 115
    tmp = tolower((int )*string);
#line 115
    *string = (char )tmp;
#line 116
    string ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return (start);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/util.c"
char *get_proxy(char const   *firstchoice ) 
{ 
  char *proxy ;
  char *help ;
  char *tmp ;

  {
  {
#line 129
  proxy = getenv(firstchoice);
  }
#line 129
  if (proxy) {
#line 130
    return (proxy);
  }
#line 132
  if (firstchoice) {
    {
#line 132
    tmp = strdup(firstchoice);
#line 132
    help = tmp;
    }
  } else {
#line 132
    help = (char *)((void *)0);
  }
  {
#line 133
  string_lowercase(help);
#line 134
  proxy = getenv((char const   *)help);
  }
#line 135
  if (help) {
    {
#line 135
    free((void *)help);
    }
  }
#line 136
  if (proxy) {
#line 137
    return (proxy);
  }
  {
#line 139
  proxy = getenv("SNARF_PROXY");
  }
#line 139
  if (proxy) {
#line 140
    return (proxy);
  }
  {
#line 142
  proxy = getenv("PROXY");
  }
#line 142
  if (proxy) {
#line 143
    return (proxy);
  }
#line 145
  return ((char *)((void *)0));
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/util.c"
int dump_data(UrlResource *rsrc , int sock , FILE *out ) 
{ 
  int out_fd ;
  int tmp ;
  Progress *p ;
  int bytes_read ;
  ssize_t written ;
  char buf[10240] ;
  ssize_t tmp___0 ;

  {
  {
#line 152
  tmp = fileno(out);
#line 152
  out_fd = tmp;
#line 153
  p = (Progress *)((void *)0);
#line 154
  bytes_read = 0;
#line 155
  written = (ssize_t )0;
  }
#line 159
  if (! ((int )rsrc->options & (1 << 4))) {
#line 160
    if (rsrc->outfile_size) {
#line 160
      if (rsrc->outfile_offset >= rsrc->outfile_size) {
        {
#line 162
        report((enum report_levels )1, (char *)"you already have all of `%s\', skipping",
               rsrc->outfile);
#line 164
        close(sock);
        }
#line 165
        return (0);
      }
    }
  }
  {
#line 169
  p = progress_new();
#line 170
  progress_init(p, rsrc, rsrc->outfile_size);
  }
#line 171
  if (! ((int )rsrc->options & (1 << 4))) {
    {
#line 172
    progress_update(p, rsrc->outfile_offset);
#line 173
    p->offset = rsrc->outfile_offset;
    }
  }
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 177
    tmp___0 = read(sock, (void *)(buf), (size_t )10240);
#line 177
    bytes_read = (int )tmp___0;
    }
#line 177
    if (! bytes_read) {
#line 177
      goto while_break;
    }
    {
#line 178
    progress_update(p, (long )bytes_read);
#line 179
    written = write(out_fd, (void const   *)(buf), (size_t )bytes_read);
    }
#line 180
    if (written == -1L) {
      {
#line 181
      perror("write");
#line 182
      close(sock);
      }
#line 183
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 187
  close(sock);
#line 188
  progress_destroy(p);
  }
#line 189
  return (1);
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/util.c"
off_t get_file_size(char const   *file ) 
{ 
  struct stat file_info ;
  int tmp ;

  {
#line 198
  if (! file) {
#line 198
    if (! *file) {
#line 199
      return ((off_t )0);
    }
  }
#line 201
  if ((int const   )*(file + 0) == 45) {
#line 202
    return ((off_t )0);
  }
  {
#line 204
  tmp = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& file_info));
  }
#line 204
  if (tmp == -1) {
#line 205
    return ((off_t )0);
  } else {
#line 207
    return (file_info.st_size);
  }
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/util.c"
int debug_enabled  =    0;
#line 214 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/util.c"
Progress *progress_new(void) 
{ 
  Progress *new_progress ;
  void *tmp ;

  {
  {
#line 219
  tmp = malloc(sizeof(Progress ));
#line 219
  new_progress = (Progress *)tmp;
#line 221
  new_progress->tty = (unsigned char)0;
#line 222
  new_progress->length = 0L;
#line 223
  new_progress->current = 0L;
#line 224
  new_progress->offset = 0L;
#line 225
  new_progress->overflow = 0;
#line 226
  new_progress->max_hashes = 0;
#line 227
  new_progress->cur_hashes = 0;
#line 229
  new_progress->start_time = double_time();
  }
#line 231
  return (new_progress);
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/util.c"
int progress_init(Progress *p , UrlResource *rsrc , long len ) 
{ 
  char *filename ;
  int win_width ;
  int total_units ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 238
  filename = (char *)((void *)0);
#line 239
  win_width = 0;
#line 240
  total_units = 0;
#line 242
  if (! p) {
#line 243
    return (0);
  }
#line 245
  p->rsrc = rsrc;
#line 248
  if ((int )rsrc->options & (1 << 5)) {
#line 249
    p->tty = (unsigned char)1;
  } else {
    {
#line 251
    tmp = isatty(2);
    }
#line 251
    if (tmp) {
#line 251
      if ((int )*(rsrc->outfile + 0) == 45) {
#line 254
        p->tty = (unsigned char)0;
#line 255
        return (1);
      } else
#line 251
      if ((int )rsrc->options & (1 << 2)) {
#line 254
        p->tty = (unsigned char)0;
#line 255
        return (1);
      } else {
#line 257
        p->tty = (unsigned char)1;
      }
    } else {
#line 254
      p->tty = (unsigned char)0;
#line 255
      return (1);
    }
  }
  {
#line 269
  win_width = guess_winsize();
  }
#line 271
  if (win_width > 30) {
#line 272
    total_units = win_width - 55;
  } else {
#line 275
    total_units = 20;
  }
  {
#line 278
  p->length = len;
#line 281
  setbuf((FILE */* __restrict  */)stderr, (char */* __restrict  */)((char *)(& output_buf)));
#line 283
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s (",
          (rsrc->url)->full_url);
  }
#line 285
  if (total_units) {
#line 285
    if (len) {
      {
#line 286
      p->length = len;
#line 287
      p->max_hashes = total_units;
#line 288
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%dK",
              (int )(len / 1024L));
      }
    } else {
      {
#line 290
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unknown size");
      }
    }
  } else {
    {
#line 290
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unknown size");
    }
  }
  {
#line 293
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)")\n");
#line 295
  p->current = 0L;
#line 297
  filename = strdup((char const   *)rsrc->outfile);
#line 299
  tmp___0 = strlen((char const   *)filename);
  }
#line 299
  if (tmp___0 > 24UL) {
#line 300
    *(filename + 24) = (char )'\000';
  }
  {
#line 302
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-25s[",
          filename);
  }
#line 304
  if (p->length) {
    {
#line 305
    repchar(stderr, (char )' ', p->max_hashes);
    }
  } else {
    {
#line 307
    fputc('+', stderr);
    }
  }
  {
#line 309
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"] %7dK",
          (int )p->current);
#line 310
  fflush(stderr);
  }
#line 311
  return (1);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/util.c"
void progress_update(Progress *p , long increment ) 
{ 
  unsigned int units ;
  char *anim ;
  size_t tmp ;
  float percent_done ;
  double elapsed ;
  float rate ;
  double tmp___0 ;
  unsigned char tmp___1 ;

  {
#line 320
  anim = (char *)"-\\|/";
#line 322
  if (! p->tty) {
#line 323
    return;
  }
  {
#line 325
  p->current += increment;
#line 327
  tmp = strlen((char const   *)(p->rsrc)->outfile);
  }
#line 327
  if (tmp > 24UL) {
#line 328
    *((p->rsrc)->outfile + 24) = (char )'\000';
  }
  {
#line 331
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r");
#line 332
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-25s [",
          (p->rsrc)->outfile);
  }
#line 335
  if (p->length) {
#line 336
    percent_done = (float )p->current / (float )p->length;
#line 340
    units = (unsigned int )(percent_done * (float )p->max_hashes);
#line 341
    if (units) {
      {
#line 342
      repchar(stderr, (char )'#', (int )units);
      }
    }
    {
#line 343
    repchar(stderr, (char )' ', (int )((unsigned int )p->max_hashes - units));
#line 344
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"] ");
#line 345
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%7dK",
            (int )(p->current / 1024L));
#line 347
    tmp___0 = double_time();
#line 347
    elapsed = tmp___0 - p->start_time;
    }
#line 349
    if (elapsed) {
#line 350
      rate = (float )(((double )(p->current - p->offset) / elapsed) / (double )1024);
    } else {
#line 352
      rate = (float )0;
    }
#line 355
    if (rate > (float )999999) {
#line 356
      rate = (float )0;
    }
    {
#line 358
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" | %7.2fK/s",
            (double )rate);
    }
  } else {
    {
#line 362
    tmp___1 = p->frame;
#line 362
    p->frame = (unsigned char )((int )p->frame + 1);
#line 362
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%c]",
            (int )*(anim + (int )tmp___1 % 4));
#line 363
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %7dK",
            (int )(p->current / 1024L));
    }
  }
  {
#line 366
  fflush(stderr);
  }
#line 367
  return;
}
}
#line 371 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/util.c"
void progress_destroy(Progress *p ) 
{ 
  double elapsed ;
  double kbytes ;
  double tmp ;

  {
#line 374
  elapsed = (double )0;
#line 376
  if (p) {
#line 376
    if (! p->tty) {
#line 377
      return;
    }
  }
  {
#line 379
  tmp = double_time();
#line 379
  elapsed = tmp - p->start_time;
#line 381
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 383
  if (elapsed) {
    {
#line 384
    kbytes = ((double )((float )(p->current - p->offset)) / elapsed) / 1024.0;
#line 385
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld bytes transferred in %.2f sec (%.2fk/sec)\n",
            p->current - p->offset, elapsed, kbytes);
    }
  } else {
    {
#line 389
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld bytes transferred in less than a second\n",
            p->current);
    }
  }
  {
#line 393
  fflush(stderr);
  }
#line 395
  if (p) {
    {
#line 395
    free((void *)p);
    }
  }
#line 396
  return;
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/util.c"
char *strconcat(char const   *string1  , ...) 
{ 
  unsigned int l ;
  va_list args ;
  char *s ;
  char *concat ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 410
  tmp = strlen(string1);
#line 410
  l = (unsigned int )(1UL + tmp);
#line 411
  __builtin_va_start(args, string1);
#line 412
  tmp___0 = __builtin_va_arg(args, char *);
#line 412
  s = tmp___0;
  }
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (! s) {
#line 414
      goto while_break;
    }
    {
#line 415
    tmp___1 = strlen((char const   *)s);
#line 415
    l = (unsigned int )((size_t )l + tmp___1);
#line 416
    tmp___2 = __builtin_va_arg(args, char *);
#line 416
    s = tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 418
  __builtin_va_end(args);
#line 420
  tmp___3 = malloc((size_t )l);
#line 420
  concat = (char *)tmp___3;
#line 421
  *(concat + 0) = (char)0;
#line 423
  strcat((char */* __restrict  */)concat, (char const   */* __restrict  */)string1);
#line 424
  __builtin_va_start(args, string1);
#line 425
  tmp___4 = __builtin_va_arg(args, char *);
#line 425
  s = tmp___4;
  }
  {
#line 426
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 426
    if (! s) {
#line 426
      goto while_break___0;
    }
    {
#line 427
    strcat((char */* __restrict  */)concat, (char const   */* __restrict  */)s);
#line 428
    tmp___5 = __builtin_va_arg(args, char *);
#line 428
    s = tmp___5;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 430
  __builtin_va_end(args);
  }
#line 432
  return (concat);
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/util.c"
char *base64(char *bin , int len ) 
{ 
  char *buf ;
  void *tmp ;
  int i ;
  int j ;
  char BASE64_END ;
  char base64_table[64] ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 440
  tmp = malloc((size_t )(((len + 2) / 3) * 4 + 1));
#line 440
  buf = (char *)tmp;
#line 441
  i = 0;
#line 441
  j = 0;
#line 443
  BASE64_END = (char )'=';
#line 444
  base64_table[0] = (char )'A';
#line 444
  base64_table[1] = (char )'B';
#line 444
  base64_table[2] = (char )'C';
#line 444
  base64_table[3] = (char )'D';
#line 444
  base64_table[4] = (char )'E';
#line 444
  base64_table[5] = (char )'F';
#line 444
  base64_table[6] = (char )'G';
#line 444
  base64_table[7] = (char )'H';
#line 444
  base64_table[8] = (char )'I';
#line 444
  base64_table[9] = (char )'J';
#line 444
  base64_table[10] = (char )'K';
#line 444
  base64_table[11] = (char )'L';
#line 444
  base64_table[12] = (char )'M';
#line 444
  base64_table[13] = (char )'N';
#line 444
  base64_table[14] = (char )'O';
#line 444
  base64_table[15] = (char )'P';
#line 444
  base64_table[16] = (char )'Q';
#line 444
  base64_table[17] = (char )'R';
#line 444
  base64_table[18] = (char )'S';
#line 444
  base64_table[19] = (char )'T';
#line 444
  base64_table[20] = (char )'U';
#line 444
  base64_table[21] = (char )'V';
#line 444
  base64_table[22] = (char )'W';
#line 444
  base64_table[23] = (char )'X';
#line 444
  base64_table[24] = (char )'Y';
#line 444
  base64_table[25] = (char )'Z';
#line 444
  base64_table[26] = (char )'a';
#line 444
  base64_table[27] = (char )'b';
#line 444
  base64_table[28] = (char )'c';
#line 444
  base64_table[29] = (char )'d';
#line 444
  base64_table[30] = (char )'e';
#line 444
  base64_table[31] = (char )'f';
#line 444
  base64_table[32] = (char )'g';
#line 444
  base64_table[33] = (char )'h';
#line 444
  base64_table[34] = (char )'i';
#line 444
  base64_table[35] = (char )'j';
#line 444
  base64_table[36] = (char )'k';
#line 444
  base64_table[37] = (char )'l';
#line 444
  base64_table[38] = (char )'m';
#line 444
  base64_table[39] = (char )'n';
#line 444
  base64_table[40] = (char )'o';
#line 444
  base64_table[41] = (char )'p';
#line 444
  base64_table[42] = (char )'q';
#line 444
  base64_table[43] = (char )'r';
#line 444
  base64_table[44] = (char )'s';
#line 444
  base64_table[45] = (char )'t';
#line 444
  base64_table[46] = (char )'u';
#line 444
  base64_table[47] = (char )'v';
#line 444
  base64_table[48] = (char )'w';
#line 444
  base64_table[49] = (char )'x';
#line 444
  base64_table[50] = (char )'y';
#line 444
  base64_table[51] = (char )'z';
#line 444
  base64_table[52] = (char )'0';
#line 444
  base64_table[53] = (char )'1';
#line 444
  base64_table[54] = (char )'2';
#line 444
  base64_table[55] = (char )'3';
#line 444
  base64_table[56] = (char )'4';
#line 444
  base64_table[57] = (char )'5';
#line 444
  base64_table[58] = (char )'6';
#line 444
  base64_table[59] = (char )'7';
#line 444
  base64_table[60] = (char )'8';
#line 444
  base64_table[61] = (char )'9';
#line 444
  base64_table[62] = (char )'+';
#line 444
  base64_table[63] = (char )'/';
  }
  {
#line 448
  while (1) {
    while_continue: /* CIL Label */ ;
#line 448
    if (! (j < len - 2)) {
#line 448
      goto while_break;
    }
#line 449
    tmp___0 = i;
#line 449
    i ++;
#line 449
    *(buf + tmp___0) = base64_table[(int )*(bin + j) >> 2];
#line 450
    tmp___1 = i;
#line 450
    i ++;
#line 450
    *(buf + tmp___1) = base64_table[(((int )*(bin + j) & 3) << 4) | ((int )*(bin + (j + 1)) >> 4)];
#line 451
    tmp___2 = i;
#line 451
    i ++;
#line 451
    *(buf + tmp___2) = base64_table[(((int )*(bin + (j + 1)) & 15) << 2) | ((int )*(bin + (j + 2)) >> 6)];
#line 452
    tmp___3 = i;
#line 452
    i ++;
#line 452
    *(buf + tmp___3) = base64_table[(int )*(bin + (j + 2)) & 63];
#line 453
    j += 3;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 457
  if (len - j == 1) {
#line 457
    goto case_1;
  }
#line 463
  if (len - j == 2) {
#line 463
    goto case_2;
  }
#line 470
  if (len - j == 0) {
#line 470
    goto case_0;
  }
#line 456
  goto switch_break;
  case_1: /* CIL Label */ 
#line 458
  tmp___4 = i;
#line 458
  i ++;
#line 458
  *(buf + tmp___4) = base64_table[(int )*(bin + j) >> 2];
#line 459
  tmp___5 = i;
#line 459
  i ++;
#line 459
  *(buf + tmp___5) = base64_table[((int )*(bin + j) & 3) << 4];
#line 460
  tmp___6 = i;
#line 460
  i ++;
#line 460
  *(buf + tmp___6) = BASE64_END;
#line 461
  tmp___7 = i;
#line 461
  i ++;
#line 461
  *(buf + tmp___7) = BASE64_END;
#line 462
  goto switch_break;
  case_2: /* CIL Label */ 
#line 464
  tmp___8 = i;
#line 464
  i ++;
#line 464
  *(buf + tmp___8) = base64_table[(int )*(bin + j) >> 2];
#line 465
  tmp___9 = i;
#line 465
  i ++;
#line 465
  *(buf + tmp___9) = base64_table[(((int )*(bin + j) & 3) << 4) | ((int )*(bin + (j + 1)) >> 4)];
#line 467
  tmp___10 = i;
#line 467
  i ++;
#line 467
  *(buf + tmp___10) = base64_table[((int )*(bin + (j + 1)) & 15) << 2];
#line 468
  tmp___11 = i;
#line 468
  i ++;
#line 468
  *(buf + tmp___11) = BASE64_END;
#line 469
  goto switch_break;
  case_0: /* CIL Label */ 
#line 471
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 473
  *(buf + i) = (char )'\000';
#line 474
  return (buf);
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/util.c"
void report(enum report_levels lev , char *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 483
  if ((unsigned int )lev == 0U) {
#line 483
    goto case_0;
  }
#line 486
  if ((unsigned int )lev == 1U) {
#line 486
    goto case_1;
  }
#line 489
  if ((unsigned int )lev == 2U) {
#line 489
    goto case_2;
  }
#line 492
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 484
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"debug: ");
  }
#line 485
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 487
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: ");
  }
#line 488
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 490
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error: ");
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 493
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  if (format) {
    {
#line 498
    __builtin_va_start(args, format);
#line 499
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
             args);
#line 500
    __builtin_va_end(args);
#line 501
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 503
  return;
}
}
#line 506 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/util.c"
int tcp_connect(char *remote_host , int port ) 
{ 
  struct hostent *host ;
  struct sockaddr_in sa ;
  int sock_fd ;
  struct hostent *tmp ;
  int tmp___0 ;

  {
  {
#line 513
  tmp = gethostbyname((char const   *)remote_host);
#line 513
  host = tmp;
  }
#line 513
  if ((unsigned long )host == (unsigned long )((void *)0)) {
    {
#line 514
    herror((char const   *)remote_host);
    }
#line 515
    return (0);
  }
  {
#line 519
  sock_fd = socket(2, 1, 0);
  }
#line 519
  if (sock_fd < 0) {
    {
#line 520
    perror("socket");
    }
#line 521
    return (0);
  }
  {
#line 525
  sa.sin_family = (sa_family_t )2;
#line 526
  sa.sin_port = htons((uint16_t )port);
#line 527
  memcpy((void */* __restrict  */)(& sa.sin_addr), (void const   */* __restrict  */)*(host->h_addr_list + 0),
         (size_t )host->h_length);
#line 529
  tmp___0 = connect(sock_fd, (struct sockaddr  const  *)((struct sockaddr *)(& sa)),
                    (socklen_t )sizeof(sa));
  }
#line 529
  if (tmp___0 < 0) {
    {
#line 530
    perror((char const   *)remote_host);
    }
#line 531
    return (0);
  }
#line 534
  return (sock_fd);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/util.c"
int transfer(UrlResource *rsrc ) 
{ 
  int i ;

  {
#line 559
  i = 0;
  {
#line 562
  if ((rsrc->url)->service_type == 1) {
#line 562
    goto case_1;
  }
#line 565
  if ((rsrc->url)->service_type == 2) {
#line 565
    goto case_2;
  }
#line 568
  if ((rsrc->url)->service_type == 3) {
#line 568
    goto case_3;
  }
#line 571
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 563
  i = http_transfer(rsrc);
  }
#line 564
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 566
  i = ftp_transfer(rsrc);
  }
#line 567
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 569
  i = gopher_transfer(rsrc);
  }
#line 570
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 572
  report((enum report_levels )2, (char *)"bad url: %s", (rsrc->url)->full_url);
  }
  switch_break: /* CIL Label */ ;
  }
#line 575
  return (i);
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/url.h"
Url *url_new(void) ;
#line 54
void url_destroy(Url *u ) ;
#line 55
Url *url_init(Url *u , char *string ) ;
#line 56
UrlResource *url_resource_new(void) ;
#line 57
void url_resource_destroy(UrlResource *rsrc ) ;
#line 58
int is_probably_an_url(char *string ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/url.c"
int is_probably_an_url(char *string ) 
{ 
  char *tmp ;

  {
  {
#line 29
  tmp = strstr((char const   *)string, "://");
  }
#line 29
  if (tmp) {
#line 30
    return (1);
  }
#line 32
  return (0);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/url.c"
static char *get_service_type(char *string , Url *u ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 41
  tmp = strstr((char const   *)string, "http://");
  }
#line 41
  if (tmp) {
#line 42
    string += 7;
#line 43
    u->service_type = 1;
#line 44
    return (string);
  }
  {
#line 47
  tmp___0 = strstr((char const   *)string, "ftp://");
  }
#line 47
  if (tmp___0) {
#line 48
    string += 6;
#line 49
    u->service_type = 2;
#line 50
    return (string);
  }
  {
#line 53
  tmp___1 = strstr((char const   *)string, "gopher://");
  }
#line 53
  if (tmp___1) {
#line 54
    string += 9;
#line 55
    u->service_type = 3;
#line 56
    return (string);
  }
  {
#line 59
  tmp___2 = strncasecmp((char const   *)string, "www", (size_t )3);
  }
#line 59
  if (tmp___2 == 0) {
    {
#line 60
    u->service_type = 1;
#line 61
    u->full_url = strconcat("http://", u->full_url, (void *)0);
    }
#line 62
    return (string);
  }
  {
#line 65
  tmp___3 = strncasecmp((char const   *)string, "ftp", (size_t )3);
  }
#line 65
  if (tmp___3 == 0) {
    {
#line 66
    u->service_type = 2;
#line 67
    u->full_url = strconcat("ftp://", u->full_url, (void *)0);
    }
#line 68
    return (string);
  }
  {
#line 72
  u->full_url = strconcat("http://", u->full_url, (void *)0);
#line 73
  u->service_type = 1;
  }
#line 74
  return (string);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/url.c"
static char *get_username(char *string , Url *u ) 
{ 
  int i ;
  char *username ;
  char *at ;
  char *slash ;
  void *tmp ;

  {
  {
#line 86
  at = strchr((char const   *)string, '@');
#line 87
  slash = strchr((char const   *)string, '/');
  }
#line 89
  if (! at) {
#line 90
    return (string);
  } else
#line 89
  if (slash) {
#line 89
    if ((unsigned long )at >= (unsigned long )slash) {
#line 90
      return (string);
    }
  }
#line 92
  i = 0;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (*(string + i)) {
#line 92
      if ((int )*(string + i) != 58) {
#line 92
        if ((int )*(string + i) != 64) {
#line 92
          if (! ((int )*(string + i) != 47)) {
#line 92
            goto while_break;
          }
        } else {
#line 92
          goto while_break;
        }
      } else {
#line 92
        goto while_break;
      }
    } else {
#line 92
      goto while_break;
    }
#line 92
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  if ((int )*(string + i) != 64) {
#line 95
    if ((int )*(string + i) != 58) {
#line 96
      return (string);
    }
  }
  {
#line 99
  tmp = malloc((size_t )i);
#line 99
  username = (char *)tmp;
#line 100
  memcpy((void */* __restrict  */)username, (void const   */* __restrict  */)string,
         (size_t )(i + 1));
#line 102
  *(username + i) = (char )'\000';
#line 104
  string += i + 1;
#line 106
  u->username = username;
  }
#line 107
  return (string);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/url.c"
static char *get_password(char *string , Url *u ) 
{ 
  int i ;
  char *password ;
  char *at ;
  char *slash ;
  void *tmp ;

  {
  {
#line 119
  at = strchr((char const   *)string, '@');
#line 120
  slash = strchr((char const   *)string, '/');
  }
#line 122
  if (! at) {
#line 123
    return (string);
  } else
#line 122
  if (slash) {
#line 122
    if ((unsigned long )at >= (unsigned long )slash) {
#line 123
      return (string);
    }
  }
#line 136
  i = 0;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! ((int )*(string + i) != 64)) {
#line 136
      goto while_break;
    }
#line 136
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 138
  tmp = malloc((size_t )i);
#line 138
  password = (char *)tmp;
#line 141
  memcpy((void */* __restrict  */)password, (void const   */* __restrict  */)string,
         (size_t )i);
#line 142
  *(password + i) = (char )'\000';
#line 144
  string += i + 1;
#line 146
  u->password = password;
  }
#line 148
  return (string);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/url.c"
static char *get_hostname(char *url , Url *u ) 
{ 
  char *hostname ;
  int i ;
  void *tmp ;

  {
#line 159
  i = 0;
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (*(url + i)) {
#line 159
      if ((int )*(url + i) != 47) {
#line 159
        if (! ((int )*(url + i) != 58)) {
#line 159
          goto while_break;
        }
      } else {
#line 159
        goto while_break;
      }
    } else {
#line 159
      goto while_break;
    }
#line 159
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 161
  tmp = malloc((size_t )(i + 1));
#line 161
  hostname = (char *)tmp;
#line 163
  memcpy((void */* __restrict  */)hostname, (void const   */* __restrict  */)url,
         (size_t )i);
#line 165
  *(hostname + i) = (char )'\000';
  }
#line 168
  if ((int )*(url + i) == 58) {
#line 169
    url += i + 1;
  } else {
#line 171
    url += i;
  }
#line 173
  u->host = hostname;
#line 174
  return (url);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/url.c"
static char *get_port(char *url , Url *u ) 
{ 
  char *port_string ;
  int i ;
  unsigned short const   **tmp ;
  void *tmp___0 ;

  {
#line 183
  i = 0;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 183
    tmp = __ctype_b_loc();
    }
#line 183
    if (! ((int const   )*(*tmp + (int )*(url + i)) & 2048)) {
#line 183
      goto while_break;
    }
#line 183
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  if (i == 0) {
#line 186
    return (url);
  }
  {
#line 189
  tmp___0 = malloc((size_t )(i + 1));
#line 189
  port_string = (char *)tmp___0;
#line 190
  memcpy((void */* __restrict  */)port_string, (void const   */* __restrict  */)url,
         (size_t )(i + 1));
#line 192
  *(port_string + i) = (char )'\000';
#line 194
  url += i;
#line 196
  u->port = atoi((char const   *)port_string);
  }
#line 198
  return (url);
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/url.c"
static char *get_path(char *url , Url *u ) 
{ 
  int i ;
  char *path ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 209
  tmp = strlen((char const   *)url);
#line 209
  i = (int )tmp;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (i > 0) {
#line 209
      if (! ((int )*(url + i) != 47)) {
#line 209
        goto while_break;
      }
    } else {
#line 209
      goto while_break;
    }
#line 209
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  if ((int )*(url + i) != 47) {
#line 212
    return (url);
  }
  {
#line 214
  tmp___0 = malloc((size_t )(i + 2));
#line 214
  path = (char *)tmp___0;
#line 215
  memcpy((void */* __restrict  */)path, (void const   */* __restrict  */)url, (size_t )(i + 1));
#line 216
  *(path + i) = (char )'/';
#line 217
  *(path + (i + 1)) = (char )'\000';
#line 219
  url += i + 1;
#line 220
  u->path = path;
  }
#line 222
  return (url);
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/url.c"
static char *get_file(char *string , Url *u ) 
{ 
  char *file ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 231
  if (! *(string + 0)) {
#line 232
    return ((char *)((void *)0));
  }
  {
#line 234
  tmp = strlen((char const   *)string);
#line 234
  tmp___0 = malloc(tmp + 1UL);
#line 234
  file = (char *)tmp___0;
#line 236
  tmp___1 = strlen((char const   *)string);
#line 236
  memcpy((void */* __restrict  */)file, (void const   */* __restrict  */)string, tmp___1 + 1UL);
#line 238
  u->file = file;
  }
#line 240
  return (string);
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/url.c"
Url *url_new(void) 
{ 
  Url *new_url ;
  void *tmp ;

  {
  {
#line 249
  tmp = malloc(sizeof(Url ));
#line 249
  new_url = (Url *)tmp;
#line 251
  new_url->full_url = (char *)((void *)0);
#line 252
  new_url->service_type = 0;
#line 253
  new_url->username = (char *)((void *)0);
#line 254
  new_url->password = (char *)((void *)0);
#line 255
  new_url->host = (char *)((void *)0);
#line 256
  new_url->port = 0;
#line 257
  new_url->path = (char *)((void *)0);
#line 258
  new_url->file = (char *)((void *)0);
  }
#line 260
  return (new_url);
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/url.c"
void url_destroy(Url *u ) 
{ 


  {
#line 267
  if (! u) {
#line 268
    return;
  }
#line 270
  if (u->full_url) {
    {
#line 270
    free((void *)u->full_url);
    }
  }
#line 271
  if (u->username) {
    {
#line 271
    free((void *)u->username);
    }
  }
#line 272
  if (u->password) {
    {
#line 272
    free((void *)u->password);
    }
  }
#line 273
  if (u->host) {
    {
#line 273
    free((void *)u->host);
    }
  }
#line 274
  if (u->path) {
    {
#line 274
    free((void *)u->path);
    }
  }
#line 275
  if (u->file) {
    {
#line 275
    free((void *)u->file);
    }
  }
#line 276
  return;
}
}
#line 279 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/url.c"
UrlResource *url_resource_new(void) 
{ 
  UrlResource *new_resource ;
  void *tmp ;

  {
  {
#line 284
  tmp = malloc(sizeof(UrlResource ));
#line 284
  new_resource = (UrlResource *)tmp;
#line 286
  new_resource->url = (Url *)((void *)0);
#line 287
  new_resource->outfile = (char *)((void *)0);
#line 288
  new_resource->proxy = (char *)((void *)0);
#line 289
  new_resource->proxy_username = (char *)((void *)0);
#line 290
  new_resource->proxy_password = (char *)((void *)0);
#line 291
  new_resource->options = (unsigned char)0;
#line 292
  new_resource->outfile_size = (off_t )0;
#line 293
  new_resource->outfile_offset = (off_t )0;
  }
#line 295
  return (new_resource);
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/url.c"
void url_resource_destroy(UrlResource *rsrc ) 
{ 


  {
#line 302
  if (! rsrc) {
#line 303
    return;
  }
#line 305
  if (rsrc->url) {
    {
#line 306
    url_destroy(rsrc->url);
    }
  }
#line 308
  if (rsrc->outfile) {
    {
#line 308
    free((void *)rsrc->outfile);
    }
  }
  {
#line 310
  free((void *)rsrc);
  }
#line 311
  return;
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/url.c"
Url *url_init(Url *u , char *string ) 
{ 
  char *sp ;
  char *tmp ;

  {
  {
#line 320
  sp = string;
#line 322
  tmp = strdup((char const   *)string);
#line 322
  u->full_url = tmp;
#line 324
  sp = get_service_type(sp, u);
  }
#line 324
  if (! sp) {
#line 325
    return ((Url *)0);
  }
#line 330
  if (! u->username) {
    {
#line 331
    sp = get_username(sp, u);
    }
  }
#line 332
  if (! u->password) {
    {
#line 333
    sp = get_password(sp, u);
    }
  }
  {
#line 335
  sp = get_hostname(sp, u);
  }
#line 337
  if (u->host) {
#line 337
    if (! *(u->host)) {
#line 338
      return ((Url *)((void *)0));
    }
  } else {
#line 338
    return ((Url *)((void *)0));
  }
  {
#line 340
  sp = get_port(sp, u);
#line 342
  sp = get_path(sp, u);
#line 343
  sp = get_file(sp, u);
  }
#line 345
  return (u);
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/options.h"
unsigned char set_options(unsigned char opts , char *optstring ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/options.h"
int default_opts  ;
#line 11 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/options.c"
unsigned char set_options(unsigned char opts , char *optstring ) 
{ 
  int i ;

  {
#line 16
  i = 0;
  {
#line 16
  while (1) {
    while_continue: /* CIL Label */ ;
#line 16
    if (! *(optstring + i)) {
#line 16
      goto while_break;
    }
    {
#line 18
    if ((int )*(optstring + i) == 45) {
#line 18
      goto case_45;
    }
#line 21
    if ((int )*(optstring + i) == 114) {
#line 21
      goto case_114;
    }
#line 24
    if ((int )*(optstring + i) == 82) {
#line 24
      goto case_82;
    }
#line 30
    if ((int )*(optstring + i) == 110) {
#line 30
      goto case_110;
    }
#line 33
    if ((int )*(optstring + i) == 78) {
#line 33
      goto case_78;
    }
#line 36
    if ((int )*(optstring + i) == 118) {
#line 36
      goto case_118;
    }
#line 39
    if ((int )*(optstring + i) == 86) {
#line 39
      goto case_86;
    }
#line 43
    if ((int )*(optstring + i) == 122) {
#line 43
      goto case_122;
    }
#line 46
    if ((int )*(optstring + i) == 90) {
#line 46
      goto case_90;
    }
#line 50
    if ((int )*(optstring + i) == 109) {
#line 50
      goto case_109;
    }
#line 53
    if ((int )*(optstring + i) == 77) {
#line 53
      goto case_77;
    }
#line 57
    if ((int )*(optstring + i) == 97) {
#line 57
      goto case_97;
    }
#line 60
    if ((int )*(optstring + i) == 65) {
#line 60
      goto case_65;
    }
#line 64
    if ((int )*(optstring + i) == 113) {
#line 64
      goto case_113;
    }
#line 67
    if ((int )*(optstring + i) == 81) {
#line 67
      goto case_81;
    }
#line 71
    if ((int )*(optstring + i) == 112) {
#line 71
      goto case_112;
    }
#line 74
    if ((int )*(optstring + i) == 80) {
#line 74
      goto case_80;
    }
#line 78
    if ((int )*(optstring + i) == 100) {
#line 78
      goto case_100;
    }
#line 81
    goto switch_default;
    case_45: /* CIL Label */ 
#line 19
    goto switch_break;
    case_114: /* CIL Label */ 
#line 22
    opts = (unsigned char )((int )opts | 1);
#line 23
    goto switch_break;
    case_82: /* CIL Label */ 
#line 25
    default_opts |= 1;
#line 26
    goto switch_break;
    case_110: /* CIL Label */ 
#line 31
    opts = (unsigned char )((int )opts | (1 << 4));
#line 32
    goto switch_break;
    case_78: /* CIL Label */ 
#line 34
    opts = (unsigned char )((int )opts | (1 << 4));
    case_118: /* CIL Label */ 
#line 37
    opts = (unsigned char )((int )opts | (1 << 1));
#line 38
    goto switch_break;
    case_86: /* CIL Label */ 
#line 40
    default_opts |= 1 << 1;
#line 41
    goto switch_break;
    case_122: /* CIL Label */ 
#line 44
    opts = (unsigned char )((int )opts | (1 << 6));
#line 45
    goto switch_break;
    case_90: /* CIL Label */ 
#line 47
    default_opts |= 1 << 6;
#line 48
    goto switch_break;
    case_109: /* CIL Label */ 
#line 51
    opts = (unsigned char )((int )opts | (1 << 7));
#line 52
    goto switch_break;
    case_77: /* CIL Label */ 
#line 54
    default_opts |= 1 << 7;
#line 55
    goto switch_break;
    case_97: /* CIL Label */ 
#line 58
    opts = (unsigned char )((int )opts | (1 << 3));
#line 59
    goto switch_break;
    case_65: /* CIL Label */ 
#line 61
    default_opts |= 1 << 3;
#line 62
    goto switch_break;
    case_113: /* CIL Label */ 
#line 65
    opts = (unsigned char )((int )opts | (1 << 2));
#line 66
    goto switch_break;
    case_81: /* CIL Label */ 
#line 68
    default_opts |= 1 << 2;
#line 69
    goto switch_break;
    case_112: /* CIL Label */ 
#line 72
    opts = (unsigned char )((int )opts | (1 << 5));
#line 73
    goto switch_break;
    case_80: /* CIL Label */ 
#line 75
    default_opts |= 1 << 5;
#line 76
    goto switch_break;
    case_100: /* CIL Label */ 
#line 79
    debug_enabled = ! debug_enabled;
#line 80
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 82
    report((enum report_levels )1, (char *)"unknown option `%c\', ignoring", (int )*(optstring + i));
    }
    switch_break: /* CIL Label */ ;
    }
#line 16
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return (opts);
}
}
#line 19 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/llist.h"
List *list_new(void) ;
#line 20
List *list_append(List *l , void *data ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/llist.c"
List *list_new(void) 
{ 
  List *new_list ;
  void *tmp ;

  {
  {
#line 14
  tmp = malloc(sizeof(List ));
#line 14
  new_list = (List *)tmp;
#line 16
  new_list->data = (void *)0;
#line 17
  new_list->next = (List *)((void *)0);
  }
#line 19
  return (new_list);
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/llist.c"
List *list_append(List *l , void *data ) 
{ 


  {
#line 26
  if ((unsigned long )l->data == (unsigned long )((void *)0)) {
#line 27
    l->data = data;
#line 28
    return (l);
  }
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! l->next) {
#line 31
      goto while_break;
    }
#line 32
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 35
  l->next = list_new();
#line 36
  (l->next)->data = data;
#line 37
  (l->next)->next = (List *)((void *)0);
  }
#line 39
  return (l);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 948 "/usr/include/unistd.h"
extern char *( __attribute__((__nonnull__(1))) getpass)(char const   *__prompt ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/http.c"
int redirect_count  =    0;
#line 40 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/http.c"
static HttpHeader *make_http_header(char *r ) 
{ 
  HttpHeader *h ;
  HttpHeaderEntry *he ;
  char *s ;
  char *raw_header ;
  char *raw_header_head ;
  void *tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 43
  h = (HttpHeader *)((void *)0);
#line 44
  he = (HttpHeaderEntry *)((void *)0);
#line 45
  s = (char *)((void *)0);
#line 46
  raw_header = (char *)((void *)0);
#line 47
  raw_header_head = (char *)((void *)0);
#line 49
  raw_header = strdup((char const   *)r);
#line 51
  raw_header_head = raw_header;
#line 53
  tmp = malloc(sizeof(HttpHeader ));
#line 53
  h = (HttpHeader *)tmp;
#line 54
  h->header_list = list_new();
#line 57
  s = raw_header;
  }
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if ((int )*s != 0) {
#line 58
      if ((int )*s != 13) {
#line 58
        if (! ((int )*s != 10)) {
#line 58
          goto while_break;
        }
      } else {
#line 58
        goto while_break;
      }
    } else {
#line 58
      goto while_break;
    }
#line 59
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 61
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 61
    if ((int )*s != 0) {
      {
#line 61
      tmp___0 = __ctype_b_loc();
      }
#line 61
      if (! ((int const   )*(*tmp___0 + (int )*s) & 8192)) {
#line 61
        goto while_break___0;
      }
    } else {
#line 61
      goto while_break___0;
    }
#line 62
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 65
  raw_header = s;
#line 67
  s = strstr((char const   *)raw_header, ": ");
  }
  {
#line 68
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 68
    if (! s) {
#line 68
      goto while_break___1;
    }
    {
#line 70
    tmp___1 = s;
#line 70
    s ++;
#line 70
    *tmp___1 = (char )'\000';
#line 71
    tmp___2 = malloc(sizeof(HttpHeaderEntry ));
#line 71
    he = (HttpHeaderEntry *)tmp___2;
#line 72
    he->key = strdup((char const   *)raw_header);
#line 74
    string_lowercase(he->key);
#line 77
    s ++;
#line 78
    raw_header = s;
    }
    {
#line 79
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 79
      if ((int )*s != 0) {
#line 79
        if ((int )*s != 13) {
#line 79
          if (! ((int )*s != 10)) {
#line 79
            goto while_break___2;
          }
        } else {
#line 79
          goto while_break___2;
        }
      } else {
#line 79
        goto while_break___2;
      }
#line 80
      s ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 82
    tmp___3 = s;
#line 82
    s ++;
#line 82
    *tmp___3 = (char )'\000';
#line 83
    he->value = strdup((char const   *)raw_header);
#line 84
    list_append(h->header_list, (void *)he);
    }
    {
#line 87
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 87
      if ((int )*s != 0) {
        {
#line 87
        tmp___4 = __ctype_b_loc();
        }
#line 87
        if (! ((int const   )*(*tmp___4 + (int )*s) & 8192)) {
#line 87
          goto while_break___3;
        }
      } else {
#line 87
        goto while_break___3;
      }
#line 88
      s ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 90
    raw_header = s;
#line 91
    s = strstr((char const   *)raw_header, ": ");
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 94
  free((void *)raw_header_head);
  }
#line 95
  return (h);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/http.c"
static void free_http_header(HttpHeader *h ) 
{ 
  List *l ;
  List *l1 ;
  HttpHeaderEntry *he ;

  {
#line 106
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 107
    return;
  }
#line 110
  l = h->header_list;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (l) {
#line 111
      if (! l->data) {
#line 111
        goto while_break;
      }
    } else {
#line 111
      goto while_break;
    }
    {
#line 112
    he = (HttpHeaderEntry *)l->data;
#line 113
    free((void *)he->key);
#line 114
    free((void *)he->value);
#line 115
    free(l->data);
#line 116
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  l = h->header_list;
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 120
    if (! l) {
#line 120
      goto while_break___0;
    }
    {
#line 121
    l1 = l->next;
#line 122
    free((void *)l);
#line 123
    l = l1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 125
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/http.c"
static char *get_header_value(char *key , HttpHeader *header ) 
{ 
  List *l ;
  HttpHeaderEntry *he ;
  char *tmp ;
  int tmp___0 ;

  {
#line 131
  l = (List *)((void *)0);
#line 132
  he = (HttpHeaderEntry *)((void *)0);
#line 134
  l = header->header_list;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (l) {
#line 136
      if (! l->data) {
#line 136
        goto while_break;
      }
    } else {
#line 136
      goto while_break;
    }
    {
#line 137
    he = (HttpHeaderEntry *)l->data;
#line 138
    tmp___0 = strcmp((char const   *)he->key, (char const   *)key);
    }
#line 138
    if (tmp___0 == 0) {
      {
#line 139
      tmp = strdup((char const   *)he->value);
      }
#line 139
      return (tmp);
    }
#line 141
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  return ((char *)((void *)0));
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/http.c"
static char *get_raw_header(int fd ) 
{ 
  char *header ;
  char buf[10240] ;
  int bytes_read ;
  int total_read ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 151
  header = (char *)((void *)0);
#line 154
  bytes_read = 0;
#line 155
  total_read = 0;
#line 157
  header = strdup("");
#line 159
  buf[2] = (char )'\000';
#line 159
  buf[1] = buf[2];
#line 159
  buf[0] = buf[1];
  }
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 161
    tmp___1 = read(fd, (void *)(buf), (size_t )1);
#line 161
    bytes_read = (int )tmp___1;
    }
#line 161
    if (! bytes_read) {
#line 161
      goto while_break;
    }
    {
#line 162
    total_read += bytes_read;
#line 164
    header = strconcat((char const   *)header, buf, (void *)0);
    }
#line 165
    if (total_read > 1) {
      {
#line 166
      tmp = strcmp((char const   *)(header + (total_read - 2)), "\n\n");
      }
#line 166
      if (tmp == 0) {
#line 167
        goto while_break;
      }
    }
#line 170
    if (total_read > 3) {
      {
#line 171
      tmp___0 = strcmp((char const   *)(header + (total_read - 4)), "\r\n\r\n");
      }
#line 171
      if (tmp___0 == 0) {
#line 173
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  return (header);
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/http.c"
static char *get_request(UrlResource *rsrc ) 
{ 
  char *request ;
  char *auth ;
  char buf[10240] ;
  Url *u ;
  off_t file_size ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 183
  request = (char *)((void *)0);
#line 184
  auth = (char *)((void *)0);
#line 189
  u = rsrc->url;
#line 191
  request = strconcat("GET ", u->path, u->file, " HTTP/1.0\r\n", "Host: ", u->host,
                      "\r\n", (void *)0);
  }
#line 194
  if (u->username) {
#line 194
    if (u->password) {
      {
#line 195
      auth = strconcat((char const   *)u->username, ":", u->password, (void *)0);
#line 196
      tmp = strlen((char const   *)auth);
#line 196
      auth = base64(auth, (int )tmp);
#line 197
      request = strconcat((char const   *)request, "Authorization: Basic ", auth,
                          "\r\n", (void *)0);
      }
    }
  }
#line 201
  if (rsrc->proxy_username) {
#line 201
    if (rsrc->proxy_password) {
      {
#line 202
      auth = strconcat((char const   *)rsrc->proxy_username, ":", rsrc->proxy_password,
                       (void *)0);
#line 204
      tmp___0 = strlen((char const   *)auth);
#line 204
      auth = base64(auth, (int )tmp___0);
#line 205
      request = strconcat((char const   *)request, "Proxy-Authorization: Basic ",
                          auth, "\r\n", (void *)0);
      }
    }
  }
#line 209
  if ((int )rsrc->options & 1) {
    {
#line 209
    file_size = get_file_size((char const   *)rsrc->outfile);
    }
#line 209
    if (file_size) {
      {
#line 211
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%ld-",
              file_size);
#line 212
      request = strconcat((char const   *)request, "Range: bytes=", buf, "\r\n", (void *)0);
      }
    }
  }
  {
#line 222
  request = strconcat((char const   *)request, "User-Agent: ", (void *)0);
  }
#line 226
  if (! ((int )rsrc->options & ((1 << 6) | (1 << 7)))) {
    {
#line 227
    tmp___1 = strcmp((char const   *)u->host, "google.com");
    }
#line 227
    if (tmp___1) {
      {
#line 227
      tmp___2 = strlen((char const   *)u->host);
#line 227
      tmp___3 = strlen("google.com");
      }
#line 227
      if (tmp___2 > tmp___3) {
        {
#line 227
        tmp___4 = strlen((char const   *)u->host);
#line 227
        tmp___5 = strlen("google.com");
#line 227
        tmp___6 = strcmp((char const   *)((u->host + (tmp___4 - tmp___5)) - 1), ".google.com");
        }
#line 227
        if (! tmp___6) {
#line 231
          rsrc->options = (unsigned char )((int )rsrc->options | (1 << 6));
        }
      }
    } else {
#line 231
      rsrc->options = (unsigned char )((int )rsrc->options | (1 << 6));
    }
  }
  {
#line 235
  tmp___8 = getenv("SNARF_HTTP_USER_AGENT");
  }
#line 235
  if (tmp___8) {
    {
#line 236
    tmp___7 = getenv("SNARF_HTTP_USER_AGENT");
#line 236
    request = strconcat((char const   *)request, tmp___7, (void *)0);
    }
  } else
#line 238
  if ((int )rsrc->options & (1 << 6)) {
    {
#line 239
    request = strconcat((char const   *)request, "Mozilla/4.0 (X11; Unix; Hi-mom)",
                        (void *)0);
    }
  } else
#line 240
  if ((int )rsrc->options & (1 << 7)) {
    {
#line 241
    request = strconcat((char const   *)request, "Mozilla/4.0 (Compatible; MSIE 4.0)",
                        (void *)0);
    }
  } else {
    {
#line 243
    request = strconcat((char const   *)request, "snarf/7.0 (http://www.xach.com/snarf)",
                        (void *)0);
    }
  }
  {
#line 246
  request = strconcat((char const   *)request, "\r\n", (void *)0);
#line 249
  tmp___10 = getenv("SNARF_HTTP_REFERER");
  }
#line 249
  if (tmp___10) {
    {
#line 250
    tmp___9 = getenv("SNARF_HTTP_REFERER");
#line 250
    request = strconcat((char const   *)request, "Referer: ", tmp___9, "\r\n", (void *)0);
    }
  }
  {
#line 255
  request = strconcat((char const   *)request, "\r\n", (void *)0);
  }
#line 257
  return (request);
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/http.c"
int http_transfer(UrlResource *rsrc ) 
{ 
  FILE *out ;
  Url *u ;
  Url *proxy_url ;
  Url *redir_u ;
  char *request ;
  char *raw_header ;
  HttpHeader *header ;
  char *len_string ;
  char *new_location ;
  char buf[10240] ;
  int sock ;
  ssize_t bytes_read ;
  int retval ;
  int i ;
  char *prompt ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  FILE *tmp___2 ;
  FILE *tmp___3 ;
  FILE *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;

  {
#line 264
  out = (FILE *)((void *)0);
#line 265
  u = (Url *)((void *)0);
#line 266
  proxy_url = (Url *)((void *)0);
#line 267
  redir_u = (Url *)((void *)0);
#line 268
  request = (char *)((void *)0);
#line 269
  raw_header = (char *)((void *)0);
#line 270
  header = (HttpHeader *)((void *)0);
#line 271
  len_string = (char *)((void *)0);
#line 272
  new_location = (char *)((void *)0);
#line 274
  sock = 0;
#line 275
  bytes_read = (ssize_t )0;
#line 276
  retval = 0;
#line 281
  if (redirect_count > 10) {
    {
#line 282
    report((enum report_levels )2, (char *)"redirection max count exceeded (looping redirect?)");
#line 284
    redirect_count = 0;
    }
#line 285
    return (0);
  }
#line 290
  u = rsrc->url;
#line 292
  if (! *(u->host)) {
    {
#line 293
    report((enum report_levels )2, (char *)"no host specified");
    }
#line 294
    return (0);
  }
#line 298
  if (! rsrc->proxy) {
    {
#line 299
    rsrc->proxy = get_proxy("HTTP_PROXY");
    }
  }
#line 302
  if (! rsrc->outfile) {
#line 303
    if (u->file) {
      {
#line 304
      rsrc->outfile = strdup((char const   *)u->file);
      }
    } else {
      {
#line 306
      rsrc->outfile = strdup("index.html");
      }
    }
  }
#line 309
  if (! u->path) {
    {
#line 310
    u->path = strdup("/");
    }
  }
#line 312
  if (! u->file) {
    {
#line 313
    u->file = strdup("");
    }
  }
#line 315
  if (! u->port) {
#line 316
    u->port = 80;
  }
#line 318
  rsrc->options = (unsigned char )((int )rsrc->options | default_opts);
#line 321
  if (rsrc->proxy) {
    {
#line 322
    proxy_url = url_new();
#line 323
    url_init(proxy_url, rsrc->proxy);
    }
#line 325
    if (! proxy_url->port) {
#line 326
      proxy_url->port = 80;
    }
#line 328
    if (! proxy_url->host) {
      {
#line 329
      report((enum report_levels )2, (char *)"bad proxy `%s\'", rsrc->proxy);
      }
#line 330
      return (0);
    }
#line 333
    if (proxy_url->username) {
      {
#line 334
      rsrc->proxy_username = strdup((char const   *)proxy_url->username);
      }
    }
#line 336
    if (proxy_url->password) {
      {
#line 337
      rsrc->proxy_password = strdup((char const   *)proxy_url->password);
      }
    }
#line 340
    if (proxy_url->username) {
#line 340
      if (! proxy_url->password) {
        {
#line 341
        prompt = (char *)((void *)0);
#line 342
        prompt = strconcat("Password for proxy ", proxy_url->username, "@", proxy_url->host,
                           ": ", (void *)0);
#line 345
        tmp = getpass((char const   *)prompt);
#line 345
        proxy_url->password = strdup((char const   *)tmp);
#line 346
        free((void *)prompt);
        }
      }
    }
    {
#line 349
    sock = tcp_connect(proxy_url->host, proxy_url->port);
    }
#line 349
    if (! sock) {
#line 350
      return (0);
    }
    {
#line 353
    u->path = strdup("");
#line 354
    u->file = strdup((char const   *)u->full_url);
#line 355
    request = get_request(rsrc);
#line 357
    tmp___0 = strlen((char const   *)request);
#line 357
    write(sock, (void const   *)request, tmp___0);
    }
  } else {
    {
#line 361
    sock = tcp_connect(u->host, u->port);
    }
#line 361
    if (! sock) {
#line 362
      return (0);
    }
    {
#line 364
    request = get_request(rsrc);
#line 365
    tmp___1 = strlen((char const   *)request);
#line 365
    write(sock, (void const   *)request, tmp___1);
    }
  }
#line 369
  if ((int )*(rsrc->outfile + 0) == 45) {
#line 369
    out = stdout;
  } else {
#line 369
    if ((int )rsrc->options & 1) {
#line 369
      if (! ((int )rsrc->options & (1 << 4))) {
        {
#line 369
        tmp___2 = fopen((char const   */* __restrict  */)rsrc->outfile, (char const   */* __restrict  */)"a");
#line 369
        tmp___4 = tmp___2;
        }
      } else {
        {
#line 369
        tmp___3 = fopen((char const   */* __restrict  */)rsrc->outfile, (char const   */* __restrict  */)"w");
#line 369
        tmp___4 = tmp___3;
        }
      }
    } else {
      {
#line 369
      tmp___3 = fopen((char const   */* __restrict  */)rsrc->outfile, (char const   */* __restrict  */)"w");
#line 369
      tmp___4 = tmp___3;
      }
    }
#line 369
    out = tmp___4;
  }
#line 370
  if (! out) {
    {
#line 371
    tmp___5 = __errno_location();
#line 371
    tmp___6 = strerror(*tmp___5);
#line 371
    report((enum report_levels )2, (char *)"opening %s: %s", rsrc->outfile, tmp___6);
    }
#line 372
    return (0);
  }
  {
#line 376
  memset((void *)(buf), '\000', (size_t )5);
#line 378
  bytes_read = read(sock, (void *)(buf), (size_t )8);
  }
#line 380
  if (bytes_read == 0L) {
    {
#line 381
    close(sock);
    }
#line 382
    return (0);
  }
#line 385
  if ((int )buf[0] == 72) {
#line 385
    if ((int )buf[1] == 84) {
#line 385
      if ((int )buf[2] == 84) {
#line 385
        if ((int )buf[3] == 80) {
          {
#line 399
          buf[bytes_read] = (char )'\000';
#line 400
          raw_header = get_raw_header(sock);
#line 401
          raw_header = strconcat((char const   *)(buf), raw_header, (void *)0);
#line 402
          header = make_http_header(raw_header);
          }
#line 404
          if ((int )rsrc->options & (1 << 1)) {
            {
#line 405
            tmp___8 = strlen((char const   *)raw_header);
#line 405
            fwrite((void const   */* __restrict  */)raw_header, (size_t )1, tmp___8,
                   (FILE */* __restrict  */)stderr);
            }
          }
          {
#line 410
          new_location = get_header_value((char *)"location", header);
          }
#line 412
          if ((int )*(raw_header + 9) == 51) {
#line 412
            if (new_location) {
              {
#line 413
              redir_u = url_new();
              }
#line 416
              if (u->username) {
                {
#line 416
                tmp___9 = strdup((char const   *)u->username);
#line 416
                redir_u->username = tmp___9;
                }
              } else {
#line 416
                redir_u->username = (char *)((void *)0);
              }
#line 417
              if (u->password) {
                {
#line 417
                tmp___10 = strdup((char const   *)u->password);
#line 417
                redir_u->password = tmp___10;
                }
              } else {
#line 417
                redir_u->password = (char *)((void *)0);
              }
              {
#line 419
              url_init(redir_u, new_location);
#line 420
              rsrc->url = redir_u;
#line 421
              redirect_count ++;
#line 422
              retval = transfer(rsrc);
              }
#line 423
              goto cleanup;
            }
          }
#line 426
          if ((int )*(raw_header + 9) == 52) {
#line 426
            goto _L;
          } else
#line 426
          if ((int )*(raw_header + 9) == 53) {
            _L: /* CIL Label */ 
#line 427
            i = 0;
            {
#line 427
            while (1) {
              while_continue: /* CIL Label */ ;
#line 427
              if (*(raw_header + i)) {
#line 427
                if (! ((int )*(raw_header + i) != 10)) {
#line 427
                  goto while_break;
                }
              } else {
#line 427
                goto while_break;
              }
#line 427
              i ++;
            }
            while_break: /* CIL Label */ ;
            }
            {
#line 428
            *(raw_header + i) = (char )'\000';
#line 429
            report((enum report_levels )2, (char *)"HTTP error from server: %s", raw_header);
#line 430
            retval = 0;
            }
#line 431
            goto cleanup;
          }
          {
#line 434
          len_string = get_header_value((char *)"content-length", header);
          }
#line 436
          if (len_string) {
            {
#line 437
            tmp___11 = atoi((char const   *)len_string);
#line 437
            rsrc->outfile_size = (off_t )tmp___11;
            }
          }
          {
#line 439
          tmp___12 = get_header_value((char *)"content-range", header);
          }
#line 439
          if (tmp___12) {
#line 440
            rsrc->outfile_size += rsrc->outfile_offset;
          }
#line 442
          if (! rsrc->outfile_size) {
#line 442
            if ((int )rsrc->options & 1) {
#line 442
              if (! ((int )rsrc->options & (1 << 4))) {
#line 442
                if (rsrc->outfile_offset) {
                  {
#line 446
                  report((enum report_levels )1, (char *)"unable to determine remote file size, try again with -n (no resume)");
#line 449
                  retval = 0;
                  }
#line 450
                  goto cleanup;
                }
              }
            }
          }
        } else {
#line 385
          goto _L___2;
        }
      } else {
#line 385
        goto _L___2;
      }
    } else {
#line 385
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 387
    if ((int )rsrc->options & 1) {
#line 387
      if (rsrc->outfile_offset) {
        {
#line 389
        report((enum report_levels )1, (char *)"server does not support resume, try again with -n (no resume)");
#line 393
        retval = 0;
        }
#line 394
        goto cleanup;
      }
    }
    {
#line 396
    tmp___7 = fileno(out);
#line 396
    write(tmp___7, (void const   *)(buf), (size_t )bytes_read);
    }
  }
  {
#line 454
  tmp___13 = dump_data(rsrc, sock, out);
  }
#line 454
  if (tmp___13) {
#line 457
    retval = 1;
  } else {
#line 455
    retval = 0;
  }
  cleanup: 
  {
#line 460
  free_http_header(header);
#line 461
  close(sock);
#line 461
  fclose(out);
  }
#line 462
  return (retval);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/snarf.c"
static void usage(int verbose ) 
{ 


  {
#line 37
  if (! verbose) {
    {
#line 38
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Use `snarf --help\' for help\n");
#line 39
    exit(1);
    }
  }
  {
#line 42
  printf((char const   */* __restrict  */)"This is snarf, version %s\n", "7.0");
#line 43
  printf((char const   */* __restrict  */)"usage: snarf [OPTIONS] URL [OUTFILE] ...\n");
#line 44
  printf((char const   */* __restrict  */)"Options:\n    -a     Force active FTP (default is passive)\n    -v     Verbose; print anything the server sends\n    -q     Don\'t print progress bars (compiled default is %s)\n    -p     Force printing of progress bars (overrides -q)\n    -r     Resume downloading a partially transferred file\n    -n     Ignore \'-r\' and transfer file in its entirety\n    -m     Spoof MSIE user-agent string\n    -z     Spoof Navigator user-agent string\n\nLowercase option letters only affect the URLs that immediately follow them.\nIf you give an option in caps, it will be the default option for all URLs\nthat follow it.\n\nIf you specify the outfile as \'-\', the file will be printed to standard\noutput as it downloads.\n\nYou can have as many URLs and outfiles as you want\n\nYou can specify a username and password for ftp or http authentication. The\nformat is:\n\n    ftp://username:password@host/\n\nIf you don\'t specify a password, you will be prompted for one.\n\nsnarf checks the SNARF_PROXY, FTP_PROXY, GOPHER_PROXY, HTTP_PROXY, and PROXY\nenvironment variables.\n\nsnarf is free software and has NO WARRANTY. See the file COPYING for details.\n",
         "on");
#line 78
  exit(1);
  }
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/snarf.c"
int main(int argc , char **argv ) 
{ 
  List *arglist ;
  UrlResource *rsrc ;
  Url *u ;
  int retval ;
  int i ;
  int tmp ;
  int tmp___0 ;
  Url *tmp___1 ;
  int tmp___2 ;
  Url *tmp___3 ;
  Url *tmp___4 ;
  int tmp___5 ;
  char *prompt ;
  char *tmp___6 ;

  {
  {
#line 85
  arglist = (List *)((void *)0);
#line 86
  rsrc = (UrlResource *)((void *)0);
#line 87
  u = (Url *)((void *)0);
#line 88
  retval = 0;
#line 91
  arglist = list_new();
#line 92
  rsrc = url_resource_new();
  }
#line 94
  if (argc < 2) {
    {
#line 95
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"snarf: not enough arguments\n");
#line 96
    usage(0);
    }
  }
  {
#line 99
  tmp = strcmp((char const   *)*(argv + 1), "--version");
  }
#line 99
  if (tmp == 0) {
    {
#line 100
    printf((char const   */* __restrict  */)"snarf %s\n", "7.0");
#line 101
    exit(0);
    }
  }
  {
#line 104
  tmp___0 = strcmp((char const   *)*(argv + 1), "--help");
  }
#line 104
  if (tmp___0 == 0) {
    {
#line 105
    usage(1);
    }
  }
#line 108
  i = 1;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    argc --;
#line 108
    if (! argc) {
#line 108
      goto while_break;
    }
    {
#line 109
    tmp___2 = strcmp((char const   *)*(argv + i), "LATEST");
    }
#line 109
    if (tmp___2 == 0) {
      {
#line 110
      u = url_new();
#line 111
      tmp___1 = url_init(u, (char *)"http://www.xach.com/snarf/snarf-latest.tar.gz");
      }
#line 111
      if (! tmp___1) {
        {
#line 112
        report((enum report_levels )2, (char *)"`%s\' is not a valid URL");
        }
#line 113
        goto __Cont;
      }
#line 116
      rsrc->url = u;
#line 117
      goto __Cont;
    }
#line 121
    if ((int )*(*(argv + i) + 0) == 45) {
#line 121
      if (*(*(argv + i) + 1)) {
#line 122
        if (rsrc->url) {
          {
#line 123
          list_append(arglist, (void *)rsrc);
#line 124
          rsrc = url_resource_new();
          }
        }
        {
#line 127
        rsrc->options = set_options(rsrc->options, *(argv + i));
        }
#line 128
        goto __Cont;
      }
    }
#line 132
    if (! rsrc->url) {
      {
#line 133
      u = url_new();
#line 134
      tmp___3 = url_init(u, *(argv + i));
      }
#line 134
      if (! tmp___3) {
        {
#line 135
        report((enum report_levels )2, (char *)"bad url `%s\'", *(argv + i));
        }
#line 136
        goto __Cont;
      }
#line 138
      rsrc->url = u;
    } else {
      {
#line 139
      tmp___5 = is_probably_an_url(*(argv + i));
      }
#line 139
      if (tmp___5) {
        {
#line 140
        list_append(arglist, (void *)rsrc);
#line 141
        rsrc = url_resource_new();
#line 143
        u = url_new();
#line 144
        tmp___4 = url_init(u, *(argv + i));
        }
#line 144
        if (! tmp___4) {
          {
#line 145
          report((enum report_levels )2, (char *)"bad url `%s\'", *(argv + i));
          }
#line 146
          goto __Cont;
        }
#line 148
        rsrc->url = u;
      } else
#line 150
      if (rsrc->outfile) {
        {
#line 151
        report((enum report_levels )1, (char *)"ignoring `%s\' for outfile", *(argv + i));
        }
      } else {
        {
#line 154
        rsrc->outfile = strdup((char const   *)*(argv + i));
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 108
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  if (rsrc->url) {
    {
#line 159
    list_append(arglist, (void *)rsrc);
    }
  }
#line 162
  if ((unsigned long )arglist->data == (unsigned long )((void *)0)) {
    {
#line 163
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"snarf: not enough arguments\n");
#line 164
    usage(0);
    }
  }
  {
#line 170
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 170
    if (! ((unsigned long )arglist != (unsigned long )((void *)0))) {
#line 170
      goto while_break___0;
    }
#line 171
    rsrc = (UrlResource *)arglist->data;
#line 172
    arglist = arglist->next;
#line 173
    u = rsrc->url;
#line 175
    if (! rsrc->outfile) {
#line 175
      if (u->file) {
        {
#line 176
        rsrc->outfile = strdup((char const   *)u->file);
        }
      }
    }
#line 178
    if (rsrc->outfile) {
      {
#line 179
      rsrc->outfile_offset = get_file_size((char const   *)rsrc->outfile);
      }
#line 181
      if (rsrc->outfile_offset) {
#line 181
        if (! ((int )rsrc->options & (1 << 4))) {
          {
#line 183
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"setting resume on existing file `%s\' at %ld bytes\n",
                  rsrc->outfile, rsrc->outfile_offset);
#line 186
          rsrc->options = (unsigned char )((int )rsrc->options | 1);
          }
        }
      }
    }
#line 191
    if (u->username) {
#line 191
      if (! u->password) {
        {
#line 192
        prompt = (char *)((void *)0);
#line 194
        prompt = strconcat("Password for ", u->username, "@", u->host, ": ", (void *)0);
#line 198
        tmp___6 = getpass((char const   *)prompt);
#line 198
        u->password = strdup((char const   *)tmp___6);
#line 199
        free((void *)prompt);
        }
      }
    }
    {
#line 202
    i = transfer(rsrc);
    }
#line 203
    if (i == 0) {
#line 204
      retval ++;
    }
    {
#line 206
    url_resource_destroy(rsrc);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 209
  return (retval);
}
}
#line 695 "/usr/include/stdio.h"
extern int puts(char const   *__s ) ;
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 123 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/ftp.c"
void close_quit(int sock ) 
{ 


  {
#line 34
  if (sock) {
    {
#line 35
    write(sock, (void const   *)"QUIT\r\n", (size_t )6);
#line 36
    close(sock);
    }
  }
#line 38
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/ftp.c"
static void ftp_set_defaults(UrlResource *rsrc , Url *u ) 
{ 


  {
#line 44
  if (! u->port) {
#line 45
    u->port = 21;
  }
#line 46
  if (! u->username) {
    {
#line 47
    u->username = strdup("anonymous");
    }
  }
#line 48
  if (! u->password) {
    {
#line 49
    u->password = strdup("snarf@");
    }
  }
#line 51
  if (! rsrc->outfile) {
#line 52
    if (u->file) {
      {
#line 53
      rsrc->outfile = strdup((char const   *)u->file);
      }
    } else {
      {
#line 55
      rsrc->outfile = strdup("ftpindex.txt");
      }
    }
  }
#line 57
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/ftp.c"
void send_control(int sock , char *string  , ...) 
{ 
  va_list args ;
  char *line ;
  char *newline ;
  char *s ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;

  {
#line 64
  line = (char *)((void *)0);
#line 66
  s = (char *)((void *)0);
#line 68
  if (string) {
    {
#line 68
    tmp = strdup((char const   *)string);
#line 68
    line = tmp;
    }
  } else {
#line 68
    line = (char *)((void *)0);
  }
  {
#line 70
  __builtin_va_start(args, string);
#line 71
  tmp___0 = __builtin_va_arg(args, char *);
#line 71
  s = tmp___0;
  }
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (! s) {
#line 72
      goto while_break;
    }
    {
#line 73
    newline = strconcat((char const   *)line, s, (void *)0);
    }
#line 74
    if (line) {
      {
#line 74
      free((void *)line);
      }
    }
    {
#line 75
    line = newline;
#line 76
    tmp___1 = __builtin_va_arg(args, char *);
#line 76
    s = tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 78
  __builtin_va_end(args);
#line 80
  tmp___2 = strlen((char const   *)line);
#line 80
  write(sock, (void const   *)line, tmp___2);
  }
#line 81
  if (line) {
    {
#line 81
    free((void *)line);
    }
  }
#line 82
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/ftp.c"
char *get_line(UrlResource *rsrc , int control ) 
{ 
  int bytes_read ;
  char *end ;
  char buf[10241] ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 88
  bytes_read = 0;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 92
    tmp___3 = read(control, (void *)(buf), (size_t )10240);
#line 92
    bytes_read = (int )tmp___3;
    }
#line 92
    if (! bytes_read) {
#line 92
      goto while_break;
    }
#line 93
    if ((int )rsrc->options & (1 << 1)) {
      {
#line 94
      fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )bytes_read,
             (FILE */* __restrict  */)stderr);
      }
    }
#line 96
    if ((int )buf[0] == 52) {
#line 96
      goto _L;
    } else
#line 96
    if ((int )buf[0] == 53) {
      _L: /* CIL Label */ 
#line 96
      if (! ((int )rsrc->options & ((1 << 1) | (1 << 2)))) {
        {
#line 98
        fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )bytes_read,
               (FILE */* __restrict  */)stderr);
        }
#line 99
        return ((char *)((void *)0));
      }
    }
#line 103
    buf[bytes_read] = (char )'\000';
#line 105
    if ((int )buf[bytes_read - 1] == 10) {
#line 106
      buf[bytes_read - 1] = (char )'\000';
    }
#line 108
    if ((int )buf[bytes_read - 2] == 13) {
#line 109
      buf[bytes_read - 2] = (char )'\000';
    }
    {
#line 111
    tmp___0 = __ctype_b_loc();
    }
#line 111
    if ((int const   )*(*tmp___0 + (int )buf[0]) & 2048) {
#line 111
      if ((int )buf[3] == 32) {
        {
#line 112
        tmp = strdup((char const   *)(buf));
        }
#line 112
        return (tmp);
      }
    }
    {
#line 117
    end = strrchr((char const   *)(buf), '\n');
    }
#line 117
    if (end) {
      {
#line 118
      end ++;
#line 119
      tmp___2 = __ctype_b_loc();
      }
#line 119
      if ((int const   )*(*tmp___2 + (int )*(end + 0)) & 2048) {
#line 119
        if ((int )*(end + 3) == 32) {
          {
#line 120
          tmp___1 = strdup((char const   *)end);
          }
#line 120
          return (tmp___1);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  return ((char *)((void *)0));
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/ftp.c"
static int check_numeric(char const   *numeric , char const   *buf ) 
{ 
  int tmp ;

  {
#line 131
  if ((int const   )*(buf + 0) == (int const   )*(numeric + 0)) {
#line 131
    if ((int const   )*(buf + 1) == (int const   )*(numeric + 1)) {
#line 131
      if ((int const   )*(buf + 2) == (int const   )*(numeric + 2)) {
#line 131
        tmp = 1;
      } else {
#line 131
        tmp = 0;
      }
    } else {
#line 131
      tmp = 0;
    }
  } else {
#line 131
    tmp = 0;
  }
#line 131
  return (tmp);
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/ftp.c"
int sock_init(struct sockaddr_in *sa , int control ) 
{ 
  socklen_t i ;
  int sock ;
  int tmp ;

  {
  {
#line 145
  sock = socket(2, 1, 0);
  }
#line 145
  if (sock < 0) {
    {
#line 146
    perror("socket");
    }
#line 147
    return (0);
  }
  {
#line 150
  i = (socklen_t )sizeof(*sa);
#line 152
  getsockname(control, (struct sockaddr */* __restrict  */)((struct sockaddr *)sa),
              (socklen_t */* __restrict  */)(& i));
#line 153
  sa->sin_port = (in_port_t )0;
#line 154
  tmp = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)sa), (socklen_t )sizeof(*sa));
  }
#line 154
  if (tmp < 0) {
    {
#line 155
    perror("bind");
    }
#line 156
    return (0);
  }
#line 159
  return (sock);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/ftp.c"
int get_passive_sock(UrlResource *rsrc , int control ) 
{ 
  unsigned char *addr ;
  struct sockaddr_in sa ;
  int sock ;
  int commas ;
  int x ;
  char *line ;
  char *orig_line ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 173
  send_control(control, (char *)"PASV\r\n", (void *)0);
#line 175
  line = get_line(rsrc, control);
  }
#line 175
  if (line) {
    {
#line 175
    tmp = check_numeric("227", (char const   *)line);
    }
#line 175
    if (! tmp) {
#line 175
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 177
    if (line) {
      {
#line 177
      free((void *)line);
      }
    }
#line 178
    return (0);
  }
  {
#line 181
  orig_line = line;
#line 183
  tmp___0 = strlen((char const   *)line);
  }
#line 183
  if (tmp___0 < 4UL) {
#line 184
    if (line) {
      {
#line 184
      free((void *)line);
      }
    }
#line 185
    return (0);
  }
#line 188
  commas = 0;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! *line) {
#line 189
      goto while_break;
    }
#line 190
    tmp___1 = line;
#line 190
    line ++;
#line 190
    if ((int )*tmp___1 == 44) {
#line 191
      commas ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  line = orig_line;
#line 194
  if (commas < 5) {
#line 195
    if (orig_line) {
      {
#line 195
      free((void *)orig_line);
      }
    }
    {
#line 196
    puts("can\'t parse PASV response");
    }
#line 197
    return (0);
  }
  {
#line 200
  sock = sock_init(& sa, control);
  }
#line 200
  if (! sock) {
#line 201
    return (-1);
  }
#line 204
  line += 4;
  {
#line 208
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 208
    tmp___2 = __ctype_b_loc();
    }
#line 208
    if ((int const   )*(*tmp___2 + (int )*line) & 2048) {
#line 208
      goto while_break___0;
    }
#line 209
    line ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 213
  sa.sin_family = (sa_family_t )2;
#line 214
  addr = (unsigned char *)(& sa.sin_addr);
#line 216
  x = 0;
  {
#line 216
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 216
    if (! (x < 4)) {
#line 216
      goto while_break___1;
    }
    {
#line 217
    tmp___3 = atoi((char const   *)line);
#line 217
    *(addr + x) = (unsigned char )tmp___3;
#line 218
    tmp___4 = strchr((char const   *)line, ',');
#line 218
    line = tmp___4 + 1;
#line 216
    x ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 221
  addr = (unsigned char *)(& sa.sin_port);
#line 222
  tmp___5 = atoi((char const   *)line);
#line 222
  *(addr + 0) = (unsigned char )tmp___5;
#line 223
  tmp___6 = strchr((char const   *)line, ',');
#line 223
  line = tmp___6 + 1;
#line 224
  tmp___7 = atoi((char const   *)line);
#line 224
  *(addr + 1) = (unsigned char )tmp___7;
#line 226
  tmp___8 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sa)),
                    (socklen_t )sizeof(sa));
  }
#line 226
  if (tmp___8 < 0) {
#line 227
    if (orig_line) {
      {
#line 227
      free((void *)orig_line);
      }
    }
    {
#line 228
    perror("connect");
    }
#line 229
    return (-1);
  }
#line 232
  if (orig_line) {
    {
#line 232
    free((void *)orig_line);
    }
  }
#line 233
  return (sock);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/ftp.c"
int get_sock(UrlResource *rsrc , int control ) 
{ 
  struct sockaddr_in sa ;
  unsigned char *addr ;
  unsigned char *port ;
  char *line ;
  char port_string[10240] ;
  unsigned int sock ;
  socklen_t i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 248
  tmp = sock_init(& sa, control);
#line 248
  sock = (unsigned int )tmp;
  }
#line 248
  if (! sock) {
#line 249
    return (0);
  }
  {
#line 252
  tmp___0 = listen((int )sock, 0);
  }
#line 252
  if (tmp___0 < 0) {
    {
#line 253
    perror("listen");
    }
#line 254
    return (0);
  }
  {
#line 257
  i = (socklen_t )sizeof(sa);
#line 259
  getsockname((int )sock, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& sa)),
              (socklen_t */* __restrict  */)(& i));
#line 261
  addr = (unsigned char *)(& sa.sin_addr.s_addr);
#line 262
  port = (unsigned char *)(& sa.sin_port);
#line 264
  sprintf((char */* __restrict  */)(port_string), (char const   */* __restrict  */)"PORT %d,%d,%d,%d,%d,%d\r\n",
          (int )*(addr + 0), (int )*(addr + 1), (int )*(addr + 2), (int )*(addr + 3),
          (int )*(port + 0), (int )*(port + 1));
#line 268
  send_control(control, port_string, (void *)0);
#line 270
  line = get_line(rsrc, control);
  }
#line 270
  if (line) {
    {
#line 270
    tmp___1 = check_numeric("200", (char const   *)line);
    }
#line 270
    if (! tmp___1) {
#line 270
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 272
    if (line) {
      {
#line 272
      free((void *)line);
      }
    }
#line 273
    return (0);
  }
#line 275
  if (line) {
    {
#line 275
    free((void *)line);
    }
  }
#line 277
  return ((int )sock);
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/snarf-7.0/ftp.c"
int ftp_transfer(UrlResource *rsrc ) 
{ 
  Url *u ;
  FILE *out ;
  char *line ;
  int sock ;
  int data_sock ;
  int passive ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char numstring[10240] ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  FILE *tmp___12 ;
  FILE *tmp___13 ;
  FILE *tmp___14 ;

  {
  {
#line 286
  u = (Url *)((void *)0);
#line 287
  out = (FILE *)((void *)0);
#line 288
  line = (char *)((void *)0);
#line 289
  sock = 0;
#line 290
  data_sock = 0;
#line 291
  passive = 1;
#line 292
  retval = 0;
#line 294
  u = rsrc->url;
#line 299
  rsrc->proxy = get_proxy("FTP_PROXY");
  }
#line 301
  if (rsrc->proxy) {
    {
#line 302
    tmp = http_transfer(rsrc);
    }
#line 302
    return (tmp);
  }
  {
#line 305
  ftp_set_defaults(rsrc, u);
#line 307
  sock = tcp_connect(u->host, u->port);
  }
#line 307
  if (! sock) {
#line 308
    return (0);
  }
  {
#line 310
  line = get_line(rsrc, sock);
  }
#line 310
  if (! line) {
#line 311
    return (0);
  }
  {
#line 313
  tmp___0 = check_numeric("220", (char const   *)line);
  }
#line 313
  if (! tmp___0) {
#line 314
    if (line) {
      {
#line 314
      free((void *)line);
      }
    }
    {
#line 315
    report((enum report_levels )2, (char *)"bad server greeting: %s");
    }
#line 316
    return (0);
  }
  {
#line 320
  send_control(sock, (char *)"USER ", u->username, "\r\n", (void *)0);
#line 322
  line = get_line(rsrc, sock);
  }
#line 322
  if (! line) {
#line 323
    return (0);
  }
  {
#line 326
  tmp___3 = check_numeric("230", (char const   *)line);
  }
#line 326
  if (! tmp___3) {
    {
#line 327
    tmp___2 = check_numeric("331", (char const   *)line);
    }
#line 327
    if (tmp___2) {
#line 332
      if (line) {
        {
#line 332
        free((void *)line);
        }
      }
      {
#line 334
      send_control(sock, (char *)"PASS ", u->password, "\r\n", (void *)0);
#line 336
      line = get_line(rsrc, sock);
      }
#line 336
      if (line) {
        {
#line 336
        tmp___1 = check_numeric("230", (char const   *)line);
        }
#line 336
        if (! tmp___1) {
#line 336
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 338
        if (line) {
          {
#line 338
          free((void *)line);
          }
        }
        {
#line 339
        report((enum report_levels )2, (char *)"login failed");
        }
#line 340
        return (0);
      }
#line 342
      if (line) {
        {
#line 342
        free((void *)line);
        }
      }
    } else {
#line 328
      if (line) {
        {
#line 328
        free((void *)line);
        }
      }
      {
#line 329
      report((enum report_levels )2, (char *)"bad/unexpected response: %s", line);
      }
#line 330
      return (0);
    }
  }
  {
#line 347
  send_control(sock, (char *)"TYPE I\r\n", (void *)0);
#line 349
  line = get_line(rsrc, sock);
  }
#line 349
  if (! line) {
#line 350
    return (0);
  }
#line 351
  if (line) {
    {
#line 351
    free((void *)line);
    }
  }
#line 353
  if (u->path) {
    {
#line 354
    send_control(sock, (char *)"CWD ", u->path, "\r\n", (void *)0);
#line 356
    line = get_line(rsrc, sock);
    }
#line 356
    if (line) {
      {
#line 356
      tmp___4 = check_numeric("250", (char const   *)line);
      }
#line 356
      if (! tmp___4) {
#line 356
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 358
      if (line) {
        {
#line 358
        free((void *)line);
        }
      }
      {
#line 359
      close_quit(sock);
      }
#line 360
      return (0);
    }
#line 362
    if (line) {
      {
#line 362
      free((void *)line);
      }
    }
  }
#line 369
  if (! ((int )rsrc->options & (1 << 3))) {
    {
#line 370
    data_sock = get_passive_sock(rsrc, sock);
    }
#line 370
    if (data_sock == -1) {
#line 371
      return (0);
    }
  }
#line 375
  if (! data_sock) {
    {
#line 376
    data_sock = get_sock(rsrc, sock);
    }
#line 376
    if (data_sock < 1) {
#line 377
      return (0);
    } else {
#line 379
      passive = 0;
    }
  }
#line 382
  if (u->file) {
    {
#line 383
    send_control(sock, (char *)"SIZE ", u->file, "\r\n", (void *)0);
#line 384
    line = get_line(rsrc, sock);
    }
#line 385
    if (line) {
      {
#line 385
      tmp___6 = check_numeric("213", (char const   *)line);
      }
#line 385
      if (tmp___6) {
        {
#line 386
        tmp___5 = atoi((char const   *)(line + 3));
#line 386
        rsrc->outfile_size = (off_t )tmp___5;
        }
      } else {
#line 388
        rsrc->outfile_size = (off_t )0;
      }
    } else {
#line 388
      rsrc->outfile_size = (off_t )0;
    }
  }
#line 393
  if (rsrc->outfile_offset) {
#line 393
    if ((int )rsrc->options & 1) {
      {
#line 396
      sprintf((char */* __restrict  */)(numstring), (char const   */* __restrict  */)"%ld",
              rsrc->outfile_offset);
#line 397
      send_control(sock, (char *)"REST ", numstring, "\r\n", (void *)0);
#line 399
      line = get_line(rsrc, sock);
      }
#line 399
      if (line) {
        {
#line 399
        tmp___7 = check_numeric("350", (char const   *)line);
        }
#line 399
        if (! tmp___7) {
#line 399
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 401
        if (line) {
          {
#line 401
          free((void *)line);
          }
        }
        {
#line 402
        close_quit(sock);
#line 403
        report((enum report_levels )2, (char *)"server does not support FTP resume, try again without -r");
        }
#line 405
        return (0);
      }
#line 407
      if (line) {
        {
#line 407
        free((void *)line);
        }
      }
    }
  }
#line 410
  if (u->file) {
    {
#line 411
    send_control(sock, (char *)"RETR ", u->file, "\r\n", (void *)0);
    }
  } else {
    {
#line 413
    send_control(sock, (char *)"NLST\r\n", (void *)0);
    }
  }
  {
#line 415
  line = get_line(rsrc, sock);
  }
#line 415
  if (line) {
    {
#line 415
    tmp___8 = check_numeric("150", (char const   *)line);
    }
#line 415
    if (! tmp___8) {
      {
#line 415
      tmp___9 = check_numeric("125", (char const   *)line);
      }
#line 415
      if (! tmp___9) {
#line 415
        goto _L___2;
      }
    }
  } else {
    _L___2: /* CIL Label */ 
#line 417
    if (line) {
      {
#line 417
      free((void *)line);
      }
    }
    {
#line 418
    close_quit(sock);
    }
#line 419
    return (0);
  }
#line 422
  if (! passive) {
    {
#line 423
    data_sock = accept(data_sock, (struct sockaddr */* __restrict  */)((void *)0),
                       (socklen_t */* __restrict  */)((void *)0));
    }
  }
#line 427
  if (line) {
    {
#line 427
    free((void *)line);
    }
  }
#line 429
  if ((int )*(rsrc->outfile + 0) == 45) {
#line 429
    out = stdout;
  } else {
#line 429
    if ((int )rsrc->options & 1) {
#line 429
      if (! ((int )rsrc->options & (1 << 4))) {
        {
#line 429
        tmp___12 = fopen((char const   */* __restrict  */)rsrc->outfile, (char const   */* __restrict  */)"a");
#line 429
        tmp___14 = tmp___12;
        }
      } else {
        {
#line 429
        tmp___13 = fopen((char const   */* __restrict  */)rsrc->outfile, (char const   */* __restrict  */)"w");
#line 429
        tmp___14 = tmp___13;
        }
      }
    } else {
      {
#line 429
      tmp___13 = fopen((char const   */* __restrict  */)rsrc->outfile, (char const   */* __restrict  */)"w");
#line 429
      tmp___14 = tmp___13;
      }
    }
#line 429
    out = tmp___14;
  }
#line 429
  if (! out) {
    {
#line 430
    tmp___10 = __errno_location();
#line 430
    tmp___11 = strerror(*tmp___10);
#line 430
    report((enum report_levels )2, (char *)"opening %s: %s", rsrc->outfile, tmp___11);
#line 432
    close_quit(sock);
    }
#line 433
    return (0);
  }
  {
#line 436
  retval = dump_data(rsrc, data_sock, out);
#line 438
  line = get_line(rsrc, sock);
  }
#line 439
  if (line) {
    {
#line 439
    free((void *)line);
    }
  }
  {
#line 440
  send_control(sock, (char *)"QUIT\r\n", (void *)0);
#line 441
  line = get_line(rsrc, sock);
  }
#line 442
  if (line) {
    {
#line 442
    free((void *)line);
    }
  }
  {
#line 445
  fclose(out);
#line 446
  close(sock);
#line 447
  close(data_sock);
  }
#line 448
  return (retval);
}
}
